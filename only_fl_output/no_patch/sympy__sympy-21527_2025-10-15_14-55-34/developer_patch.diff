diff --git a/sympy/polys/constructor.py b/sympy/polys/constructor.py
--- a/sympy/polys/constructor.py
+++ b/sympy/polys/constructor.py
@@ -48,7 +48,7 @@ def _construct_simple(coeffs, opt):
                         float_numbers.append(x)
                     if y.is_Float:
                         float_numbers.append(y)
-            if is_algebraic(coeff):
+            elif is_algebraic(coeff):
                 if floats:
                     # there are both algebraics and reals -> EX
                     return False
diff --git a/sympy/polys/matrices/ddm.py b/sympy/polys/matrices/ddm.py
--- a/sympy/polys/matrices/ddm.py
+++ b/sympy/polys/matrices/ddm.py
@@ -284,7 +284,9 @@ def applyfunc(self, func, domain):
     def rref(a):
         """Reduced-row echelon form of a and list of pivots"""
         b = a.copy()
-        pivots = ddm_irref(b)
+        K = a.domain
+        partial_pivot = K.is_RealField or K.is_ComplexField
+        pivots = ddm_irref(b, _partial_pivot=partial_pivot)
         return b, pivots
 
     def nullspace(a):
diff --git a/sympy/polys/matrices/dense.py b/sympy/polys/matrices/dense.py
--- a/sympy/polys/matrices/dense.py
+++ b/sympy/polys/matrices/dense.py
@@ -85,7 +85,7 @@ def ddm_imatmul(a, b, c):
             ai[j] = sum(map(mul, bi, cTj), ai[j])
 
 
-def ddm_irref(a):
+def ddm_irref(a, _partial_pivot=False):
     """a  <--  rref(a)"""
     # a is (m x n)
     m = len(a)
@@ -97,6 +97,15 @@ def ddm_irref(a):
     pivots = []
 
     for j in range(n):
+        # Proper pivoting should be used for all domains for performance
+        # reasons but it is only strictly needed for RR and CC (and possibly
+        # other domains like RR(x)). This path is used by DDM.rref() if the
+        # domain is RR or CC. It uses partial (row) pivoting based on the
+        # absolute value of the pivot candidates.
+        if _partial_pivot:
+            ip = max(range(i, m), key=lambda ip: abs(a[ip][j]))
+            a[i], a[ip] = a[ip], a[i]
+
         # pivot
         aij = a[i][j]
 
diff --git a/sympy/polys/matrices/linsolve.py b/sympy/polys/matrices/linsolve.py
--- a/sympy/polys/matrices/linsolve.py
+++ b/sympy/polys/matrices/linsolve.py
@@ -73,6 +73,12 @@ def _linsolve(eqs, syms):
     Aaug = sympy_dict_to_dm(eqsdict, rhs, syms)
     K = Aaug.domain
 
+    # sdm_irref has issues with float matrices. This uses the ddm_rref()
+    # function. When sdm_rref() can handle float matrices reasonably this
+    # should be removed...
+    if K.is_RealField or K.is_ComplexField:
+        Aaug = Aaug.to_ddm().rref()[0].to_sdm()
+
     # Compute reduced-row echelon form (RREF)
     Arref, pivots, nzcols = sdm_irref(Aaug)
 
diff --git a/sympy/polys/matrices/sdm.py b/sympy/polys/matrices/sdm.py
--- a/sympy/polys/matrices/sdm.py
+++ b/sympy/polys/matrices/sdm.py
@@ -904,6 +904,8 @@ def sdm_irref(A):
             Ajnz = set(Aj)
             for k in Ajnz - Ainz:
                 Ai[k] = - Aij * Aj[k]
+            Ai.pop(j)
+            Ainz.remove(j)
             for k in Ajnz & Ainz:
                 Aik = Ai[k] - Aij * Aj[k]
                 if Aik:
@@ -938,6 +940,8 @@ def sdm_irref(A):
             for l in Ainz - Aknz:
                 Ak[l] = - Akj * Ai[l]
                 nonzero_columns[l].add(k)
+            Ak.pop(j)
+            Aknz.remove(j)
             for l in Ainz & Aknz:
                 Akl = Ak[l] - Akj * Ai[l]
                 if Akl:
