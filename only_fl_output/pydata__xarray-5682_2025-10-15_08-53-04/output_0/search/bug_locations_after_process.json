[
    {
        "rel_file_path": "xarray/plot/plot.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/pydata__xarray/setup_pydata__xarray__0.19/xarray/plot/plot.py",
        "start": 337,
        "end": 465,
        "class_name": null,
        "method_name": "line",
        "code": "337 def line(\n338     darray,\n339     *args,\n340     row=None,\n341     col=None,\n342     figsize=None,\n343     aspect=None,\n344     size=None,\n345     ax=None,\n346     hue=None,\n347     x=None,\n348     y=None,\n349     xincrease=None,\n350     yincrease=None,\n351     xscale=None,\n352     yscale=None,\n353     xticks=None,\n354     yticks=None,\n355     xlim=None,\n356     ylim=None,\n357     add_legend=True,\n358     _labels=True,\n359     **kwargs,\n360 ):\n361     \"\"\"\n362     Line plot of DataArray values.\n363 \n364     Wraps :py:func:`matplotlib:matplotlib.pyplot.plot`.\n365 \n366     Parameters\n367     ----------\n368     darray : DataArray\n369         Either 1D or 2D. If 2D, one of ``hue``, ``x`` or ``y`` must be provided.\n370     figsize : tuple, optional\n371         A tuple (width, height) of the figure in inches.\n372         Mutually exclusive with ``size`` and ``ax``.\n373     aspect : scalar, optional\n374         Aspect ratio of plot, so that ``aspect * size`` gives the *width* in\n375         inches. Only used if a ``size`` is provided.\n376     size : scalar, optional\n377         If provided, create a new figure for the plot with the given size:\n378         *height* (in inches) of each plot. See also: ``aspect``.\n379     ax : matplotlib axes object, optional\n380         Axes on which to plot. By default, the current is used.\n381         Mutually exclusive with ``size`` and ``figsize``.\n382     hue : str, optional\n383         Dimension or coordinate for which you want multiple lines plotted.\n384         If plotting against a 2D coordinate, ``hue`` must be a dimension.\n385     x, y : str, optional\n386         Dimension, coordinate or multi-index level for *x*, *y* axis.\n387         Only one of these may be specified.\n388         The other will be used for values from the DataArray on which this\n389         plot method is called.\n390     xscale, yscale : {'linear', 'symlog', 'log', 'logit'}, optional\n391         Specifies scaling for the *x*- and *y*-axis, respectively.\n392     xticks, yticks : array-like, optional\n393         Specify tick locations for *x*- and *y*-axis.\n394     xlim, ylim : array-like, optional\n395         Specify *x*- and *y*-axis limits.\n396     xincrease : None, True, or False, optional\n397         Should the values on the *x* axis be increasing from left to right?\n398         if ``None``, use the default for the Matplotlib function.\n399     yincrease : None, True, or False, optional\n400         Should the values on the *y* axis be increasing from top to bottom?\n401         if ``None``, use the default for the Matplotlib function.\n402     add_legend : bool, optional\n403         Add legend with *y* axis coordinates (2D inputs only).\n404     *args, **kwargs : optional\n405         Additional arguments to :py:func:`matplotlib:matplotlib.pyplot.plot`.\n406     \"\"\"\n407     # Handle facetgrids first\n408     if row or col:\n409         allargs = locals().copy()\n410         allargs.update(allargs.pop(\"kwargs\"))\n411         allargs.pop(\"darray\")\n412         return _easy_facetgrid(darray, line, kind=\"line\", **allargs)\n413 \n414     ndims = len(darray.dims)\n415     if ndims > 2:\n416         raise ValueError(\n417             \"Line plots are for 1- or 2-dimensional DataArrays. \"\n418             \"Passed DataArray has {ndims} \"\n419             \"dimensions\".format(ndims=ndims)\n420         )\n421 \n422     # The allargs dict passed to _easy_facetgrid above contains args\n423     if args == ():\n424         args = kwargs.pop(\"args\", ())\n425     else:\n426         assert \"args\" not in kwargs\n427 \n428     ax = get_axis(figsize, size, aspect, ax)\n429     xplt, yplt, hueplt, hue_label = _infer_line_data(darray, x, y, hue)\n430 \n431     # Remove pd.Intervals if contained in xplt.values and/or yplt.values.\n432     xplt_val, yplt_val, x_suffix, y_suffix, kwargs = _resolve_intervals_1dplot(\n433         xplt.to_numpy(), yplt.to_numpy(), kwargs\n434     )\n435     xlabel = label_from_attrs(xplt, extra=x_suffix)\n436     ylabel = label_from_attrs(yplt, extra=y_suffix)\n437 \n438     _ensure_plottable(xplt_val, yplt_val)\n439 \n440     primitive = ax.plot(xplt_val, yplt_val, *args, **kwargs)\n441 \n442     if _labels:\n443         if xlabel is not None:\n444             ax.set_xlabel(xlabel)\n445 \n446         if ylabel is not None:\n447             ax.set_ylabel(ylabel)\n448 \n449         ax.set_title(darray._title_for_slice())\n450 \n451     if darray.ndim == 2 and add_legend:\n452         ax.legend(handles=primitive, labels=list(hueplt.to_numpy()), title=hue_label)\n453 \n454     # Rotate dates on xlabels\n455     # Do this without calling autofmt_xdate so that x-axes ticks\n456     # on other subplots (if any) are not deleted.\n457     # https://stackoverflow.com/questions/17430105/autofmt-xdate-deletes-x-axis-labels-of-all-subplots\n458     if np.issubdtype(xplt.dtype, np.datetime64):\n459         for xlabels in ax.get_xticklabels():\n460             xlabels.set_rotation(30)\n461             xlabels.set_ha(\"right\")\n462 \n463     _update_axes(ax, xincrease, yincrease, xscale, yscale, xticks, yticks, xlim, ylim)\n464 \n465     return primitive\n",
        "intended_behavior": "Each of these methods must ensure any long_name that includes LaTeX expressions is recognized and correctly formatted before being passed to matplotlib for plotting. This likely involves a check within each method to determine if the long_name is a LaTeX string (e.g., contains $...$) and ensuring that it is passed to matplotlib in a way that enables the LaTeX rendering, potentially by leveraging matplotlib's text handling capabilities explicitly for LaTeX."
    },
    {
        "rel_file_path": "xarray/plot/plot.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/pydata__xarray/setup_pydata__xarray__0.19/xarray/plot/plot.py",
        "start": 878,
        "end": 879,
        "class_name": null,
        "method_name": "line",
        "code": "878     def line(self, *args, **kwargs):\n879         return line(self._da, *args, **kwargs)\n",
        "intended_behavior": "Each of these methods must ensure any long_name that includes LaTeX expressions is recognized and correctly formatted before being passed to matplotlib for plotting. This likely involves a check within each method to determine if the long_name is a LaTeX string (e.g., contains $...$) and ensuring that it is passed to matplotlib in a way that enables the LaTeX rendering, potentially by leveraging matplotlib's text handling capabilities explicitly for LaTeX."
    },
    {
        "rel_file_path": "xarray/plot/plot.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/pydata__xarray/setup_pydata__xarray__0.19/xarray/plot/plot.py",
        "start": 878,
        "end": 879,
        "class_name": "_PlotMethods",
        "method_name": "line",
        "code": "878     def line(self, *args, **kwargs):\n879         return line(self._da, *args, **kwargs)\n",
        "intended_behavior": "Each of these methods must ensure any long_name that includes LaTeX expressions is recognized and correctly formatted before being passed to matplotlib for plotting. This likely involves a check within each method to determine if the long_name is a LaTeX string (e.g., contains $...$) and ensuring that it is passed to matplotlib in a way that enables the LaTeX rendering, potentially by leveraging matplotlib's text handling capabilities explicitly for LaTeX."
    },
    {
        "rel_file_path": "xarray/plot/plot.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/pydata__xarray/setup_pydata__xarray__0.19/xarray/plot/plot.py",
        "start": 509,
        "end": 564,
        "class_name": null,
        "method_name": "hist",
        "code": "509 def hist(\n510     darray,\n511     figsize=None,\n512     size=None,\n513     aspect=None,\n514     ax=None,\n515     xincrease=None,\n516     yincrease=None,\n517     xscale=None,\n518     yscale=None,\n519     xticks=None,\n520     yticks=None,\n521     xlim=None,\n522     ylim=None,\n523     **kwargs,\n524 ):\n525     \"\"\"\n526     Histogram of DataArray.\n527 \n528     Wraps :py:func:`matplotlib:matplotlib.pyplot.hist`.\n529 \n530     Plots *N*-dimensional arrays by first flattening the array.\n531 \n532     Parameters\n533     ----------\n534     darray : DataArray\n535         Can have any number of dimensions.\n536     figsize : tuple, optional\n537         A tuple (width, height) of the figure in inches.\n538         Mutually exclusive with ``size`` and ``ax``.\n539     aspect : scalar, optional\n540         Aspect ratio of plot, so that ``aspect * size`` gives the *width* in\n541         inches. Only used if a ``size`` is provided.\n542     size : scalar, optional\n543         If provided, create a new figure for the plot with the given size:\n544         *height* (in inches) of each plot. See also: ``aspect``.\n545     ax : matplotlib axes object, optional\n546         Axes on which to plot. By default, use the current axes.\n547         Mutually exclusive with ``size`` and ``figsize``.\n548     **kwargs : optional\n549         Additional keyword arguments to :py:func:`matplotlib:matplotlib.pyplot.hist`.\n550 \n551     \"\"\"\n552     ax = get_axis(figsize, size, aspect, ax)\n553 \n554     no_nan = np.ravel(darray.to_numpy())\n555     no_nan = no_nan[pd.notnull(no_nan)]\n556 \n557     primitive = ax.hist(no_nan, **kwargs)\n558 \n559     ax.set_title(\"Histogram\")\n560     ax.set_xlabel(label_from_attrs(darray))\n561 \n562     _update_axes(ax, xincrease, yincrease, xscale, yscale, xticks, yticks, xlim, ylim)\n563 \n564     return primitive\n",
        "intended_behavior": "Each of these methods must ensure any long_name that includes LaTeX expressions is recognized and correctly formatted before being passed to matplotlib for plotting. This likely involves a check within each method to determine if the long_name is a LaTeX string (e.g., contains $...$) and ensuring that it is passed to matplotlib in a way that enables the LaTeX rendering, potentially by leveraging matplotlib's text handling capabilities explicitly for LaTeX."
    },
    {
        "rel_file_path": "xarray/plot/plot.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/pydata__xarray/setup_pydata__xarray__0.19/xarray/plot/plot.py",
        "start": 874,
        "end": 875,
        "class_name": null,
        "method_name": "hist",
        "code": "874     def hist(self, ax=None, **kwargs):\n875         return hist(self._da, ax=ax, **kwargs)\n",
        "intended_behavior": "Each of these methods must ensure any long_name that includes LaTeX expressions is recognized and correctly formatted before being passed to matplotlib for plotting. This likely involves a check within each method to determine if the long_name is a LaTeX string (e.g., contains $...$) and ensuring that it is passed to matplotlib in a way that enables the LaTeX rendering, potentially by leveraging matplotlib's text handling capabilities explicitly for LaTeX."
    },
    {
        "rel_file_path": "xarray/plot/plot.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/pydata__xarray/setup_pydata__xarray__0.19/xarray/plot/plot.py",
        "start": 874,
        "end": 875,
        "class_name": "_PlotMethods",
        "method_name": "hist",
        "code": "874     def hist(self, ax=None, **kwargs):\n875         return hist(self._da, ax=ax, **kwargs)\n",
        "intended_behavior": "Each of these methods must ensure any long_name that includes LaTeX expressions is recognized and correctly formatted before being passed to matplotlib for plotting. This likely involves a check within each method to determine if the long_name is a LaTeX string (e.g., contains $...$) and ensuring that it is passed to matplotlib in a way that enables the LaTeX rendering, potentially by leveraging matplotlib's text handling capabilities explicitly for LaTeX."
    },
    {
        "rel_file_path": "xarray/plot/plot.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/pydata__xarray/setup_pydata__xarray__0.19/xarray/plot/plot.py",
        "start": 567,
        "end": 849,
        "class_name": null,
        "method_name": "scatter",
        "code": "567 def scatter(\n568     darray,\n569     *args,\n570     row=None,\n571     col=None,\n572     figsize=None,\n573     aspect=None,\n574     size=None,\n575     ax=None,\n576     hue=None,\n577     hue_style=None,\n578     x=None,\n579     z=None,\n580     xincrease=None,\n581     yincrease=None,\n582     xscale=None,\n583     yscale=None,\n584     xticks=None,\n585     yticks=None,\n586     xlim=None,\n587     ylim=None,\n588     add_legend=None,\n589     add_colorbar=None,\n590     cbar_kwargs=None,\n591     cbar_ax=None,\n592     vmin=None,\n593     vmax=None,\n594     norm=None,\n595     infer_intervals=None,\n596     center=None,\n597     levels=None,\n598     robust=None,\n599     colors=None,\n600     extend=None,\n601     cmap=None,\n602     _labels=True,\n603     **kwargs,\n604 ):\n605     \"\"\"\n606     Scatter plot a DataArray along some coordinates.\n607 \n608     Parameters\n609     ----------\n610     darray : DataArray\n611         Dataarray to plot.\n612     x, y : str\n613         Variable names for x, y axis.\n614     hue: str, optional\n615         Variable by which to color scattered points\n616     hue_style: str, optional\n617         Can be either 'discrete' (legend) or 'continuous' (color bar).\n618     markersize: str, optional\n619         scatter only. Variable by which to vary size of scattered points.\n620     size_norm: optional\n621         Either None or 'Norm' instance to normalize the 'markersize' variable.\n622     add_guide: bool, optional\n623         Add a guide that depends on hue_style\n624             - for \"discrete\", build a legend.\n625               This is the default for non-numeric `hue` variables.\n626             - for \"continuous\",  build a colorbar\n627     row : str, optional\n628         If passed, make row faceted plots on this dimension name\n629     col : str, optional\n630         If passed, make column faceted plots on this dimension name\n631     col_wrap : int, optional\n632         Use together with ``col`` to wrap faceted plots\n633     ax : matplotlib axes object, optional\n634         If None, uses the current axis. Not applicable when using facets.\n635     subplot_kws : dict, optional\n636         Dictionary of keyword arguments for matplotlib subplots. Only applies\n637         to FacetGrid plotting.\n638     aspect : scalar, optional\n639         Aspect ratio of plot, so that ``aspect * size`` gives the width in\n640         inches. Only used if a ``size`` is provided.\n641     size : scalar, optional\n642         If provided, create a new figure for the plot with the given size.\n643         Height (in inches) of each plot. See also: ``aspect``.\n644     norm : ``matplotlib.colors.Normalize`` instance, optional\n645         If the ``norm`` has vmin or vmax specified, the corresponding kwarg\n646         must be None.\n647     vmin, vmax : float, optional\n648         Values to anchor the colormap, otherwise they are inferred from the\n649         data and other keyword arguments. When a diverging dataset is inferred,\n650         setting one of these values will fix the other by symmetry around\n651         ``center``. Setting both values prevents use of a diverging colormap.\n652         If discrete levels are provided as an explicit list, both of these\n653         values are ignored.\n654     cmap : str or colormap, optional\n655         The mapping from data values to color space. Either a\n656         matplotlib colormap name or object. If not provided, this will\n657         be either ``viridis`` (if the function infers a sequential\n658         dataset) or ``RdBu_r`` (if the function infers a diverging\n659         dataset).  When `Seaborn` is installed, ``cmap`` may also be a\n660         `seaborn` color palette. If ``cmap`` is seaborn color palette\n661         and the plot type is not ``contour`` or ``contourf``, ``levels``\n662         must also be specified.\n663     colors : color-like or list of color-like, optional\n664         A single color or a list of colors. If the plot type is not ``contour``\n665         or ``contourf``, the ``levels`` argument is required.\n666     center : float, optional\n667         The value at which to center the colormap. Passing this value implies\n668         use of a diverging colormap. Setting it to ``False`` prevents use of a\n669         diverging colormap.\n670     robust : bool, optional\n671         If True and ``vmin`` or ``vmax`` are absent, the colormap range is\n672         computed with 2nd and 98th percentiles instead of the extreme values.\n673     extend : {\"neither\", \"both\", \"min\", \"max\"}, optional\n674         How to draw arrows extending the colorbar beyond its limits. If not\n675         provided, extend is inferred from vmin, vmax and the data limits.\n676     levels : int or list-like object, optional\n677         Split the colormap (cmap) into discrete color intervals. If an integer\n678         is provided, \"nice\" levels are chosen based on the data range: this can\n679         imply that the final number of levels is not exactly the expected one.\n680         Setting ``vmin`` and/or ``vmax`` with ``levels=N`` is equivalent to\n681         setting ``levels=np.linspace(vmin, vmax, N)``.\n682     **kwargs : optional\n683         Additional keyword arguments to matplotlib\n684     \"\"\"\n685     plt = import_matplotlib_pyplot()\n686 \n687     # Handle facetgrids first\n688     if row or col:\n689         allargs = locals().copy()\n690         allargs.update(allargs.pop(\"kwargs\"))\n691         allargs.pop(\"darray\")\n692         subplot_kws = dict(projection=\"3d\") if z is not None else None\n693         return _easy_facetgrid(\n694             darray, scatter, kind=\"dataarray\", subplot_kws=subplot_kws, **allargs\n695         )\n696 \n697     # Further\n698     _is_facetgrid = kwargs.pop(\"_is_facetgrid\", False)\n699     if _is_facetgrid:\n700         # Why do I need to pop these here?\n701         kwargs.pop(\"y\", None)\n702         kwargs.pop(\"args\", None)\n703         kwargs.pop(\"add_labels\", None)\n704 \n705     _sizes = kwargs.pop(\"markersize\", kwargs.pop(\"linewidth\", None))\n706     size_norm = kwargs.pop(\"size_norm\", None)\n707     size_mapping = kwargs.pop(\"size_mapping\", None)  # set by facetgrid\n708     cmap_params = kwargs.pop(\"cmap_params\", None)\n709 \n710     figsize = kwargs.pop(\"figsize\", None)\n711     subplot_kws = dict()\n712     if z is not None and ax is None:\n713         # TODO: Importing Axes3D is not necessary in matplotlib >= 3.2.\n714         # Remove when minimum requirement of matplotlib is 3.2:\n715         from mpl_toolkits.mplot3d import Axes3D  # type: ignore # noqa\n716 \n717         subplot_kws.update(projection=\"3d\")\n718         ax = get_axis(figsize, size, aspect, ax, **subplot_kws)\n719         # Using 30, 30 minimizes rotation of the plot. Making it easier to\n720         # build on your intuition from 2D plots:\n721         if LooseVersion(plt.matplotlib.__version__) < \"3.5.0\":\n722             ax.view_init(azim=30, elev=30)\n723         else:\n724             # https://github.com/matplotlib/matplotlib/pull/19873\n725             ax.view_init(azim=30, elev=30, vertical_axis=\"y\")\n726     else:\n727         ax = get_axis(figsize, size, aspect, ax, **subplot_kws)\n728 \n729     _data = _infer_scatter_metadata(darray, x, z, hue, hue_style, _sizes)\n730 \n731     add_guide = kwargs.pop(\"add_guide\", None)\n732     if add_legend is not None:\n733         pass\n734     elif add_guide is None or add_guide is True:\n735         add_legend = True if _data[\"hue_style\"] == \"discrete\" else False\n736     elif add_legend is None:\n737         add_legend = False\n738 \n739     if add_colorbar is not None:\n740         pass\n741     elif add_guide is None or add_guide is True:\n742         add_colorbar = True if _data[\"hue_style\"] == \"continuous\" else False\n743     else:\n744         add_colorbar = False\n745 \n746     # need to infer size_mapping with full dataset\n747     _data.update(\n748         _infer_scatter_data(\n749             darray,\n750             x,\n751             z,\n752             hue,\n753             _sizes,\n754             size_norm,\n755             size_mapping,\n756             _MARKERSIZE_RANGE,\n757         )\n758     )\n759 \n760     cmap_params_subset = {}\n761     if _data[\"hue\"] is not None:\n762         kwargs.update(c=_data[\"hue\"].values.ravel())\n763         cmap_params, cbar_kwargs = _process_cmap_cbar_kwargs(\n764             scatter, _data[\"hue\"].values, **locals()\n765         )\n766 \n767         # subset that can be passed to scatter, hist2d\n768         cmap_params_subset = {\n769             vv: cmap_params[vv] for vv in [\"vmin\", \"vmax\", \"norm\", \"cmap\"]\n770         }\n771 \n772     if _data[\"size\"] is not None:\n773         kwargs.update(s=_data[\"size\"].values.ravel())\n774 \n775     if LooseVersion(plt.matplotlib.__version__) < \"3.5.0\":\n776         # Plot the data. 3d plots has the z value in upward direction\n777         # instead of y. To make jumping between 2d and 3d easy and intuitive\n778         # switch the order so that z is shown in the depthwise direction:\n779         axis_order = [\"x\", \"z\", \"y\"]\n780     else:\n781         # Switching axis order not needed in 3.5.0, can also simplify the code\n782         # that uses axis_order:\n783         # https://github.com/matplotlib/matplotlib/pull/19873\n784         axis_order = [\"x\", \"y\", \"z\"]\n785 \n786     primitive = ax.scatter(\n787         *[\n788             _data[v].values.ravel()\n789             for v in axis_order\n790             if _data.get(v, None) is not None\n791         ],\n792         **cmap_params_subset,\n793         **kwargs,\n794     )\n795 \n796     # Set x, y, z labels:\n797     i = 0\n798     set_label = [ax.set_xlabel, ax.set_ylabel, getattr(ax, \"set_zlabel\", None)]\n799     for v in axis_order:\n800         if _data.get(f\"{v}label\", None) is not None:\n801             set_label[i](_data[f\"{v}label\"])\n802             i += 1\n803 \n804     if add_legend:\n805 \n806         def to_label(data, key, x):\n807             \"\"\"Map prop values back to its original values.\"\"\"\n808             if key in data:\n809                 # Use reindex to be less sensitive to float errors.\n810                 # Return as numpy array since legend_elements\n811                 # seems to require that:\n812                 return data[key].reindex(x, method=\"nearest\").to_numpy()\n813             else:\n814                 return x\n815 \n816         handles, labels = [], []\n817         for subtitle, prop, func in [\n818             (\n819                 _data[\"hue_label\"],\n820                 \"colors\",\n821                 functools.partial(to_label, _data, \"hue_to_label\"),\n822             ),\n823             (\n824                 _data[\"size_label\"],\n825                 \"sizes\",\n826                 functools.partial(to_label, _data, \"size_to_label\"),\n827             ),\n828         ]:\n829             if subtitle:\n830                 # Get legend handles and labels that displays the\n831                 # values correctly. Order might be different because\n832                 # legend_elements uses np.unique instead of pd.unique,\n833                 # FacetGrid.add_legend might have troubles with this:\n834                 hdl, lbl = legend_elements(primitive, prop, num=\"auto\", func=func)\n835                 hdl, lbl = _legend_add_subtitle(hdl, lbl, subtitle, ax.scatter)\n836                 handles += hdl\n837                 labels += lbl\n838         legend = ax.legend(handles, labels, framealpha=0.5)\n839         _adjust_legend_subtitles(legend)\n840 \n841     if add_colorbar and _data[\"hue_label\"]:\n842         if _data[\"hue_style\"] == \"discrete\":\n843             raise NotImplementedError(\"Cannot create a colorbar for non numerics.\")\n844         cbar_kwargs = {} if cbar_kwargs is None else cbar_kwargs\n845         if \"label\" not in cbar_kwargs:\n846             cbar_kwargs[\"label\"] = _data[\"hue_label\"]\n847         _add_colorbar(primitive, ax, cbar_ax, cbar_kwargs, cmap_params)\n848 \n849     return primitive\n",
        "intended_behavior": "Each of these methods must ensure any long_name that includes LaTeX expressions is recognized and correctly formatted before being passed to matplotlib for plotting. This likely involves a check within each method to determine if the long_name is a LaTeX string (e.g., contains $...$) and ensuring that it is passed to matplotlib in a way that enables the LaTeX rendering, potentially by leveraging matplotlib's text handling capabilities explicitly for LaTeX."
    },
    {
        "rel_file_path": "xarray/plot/utils.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/pydata__xarray/setup_pydata__xarray__0.19/xarray/plot/utils.py",
        "start": 465,
        "end": 493,
        "class_name": null,
        "method_name": "label_from_attrs",
        "code": "465 def label_from_attrs(da, extra=\"\"):\n466     \"\"\"Makes informative labels if variable metadata (attrs) follows\n467     CF conventions.\"\"\"\n468 \n469     if da.attrs.get(\"long_name\"):\n470         name = da.attrs[\"long_name\"]\n471     elif da.attrs.get(\"standard_name\"):\n472         name = da.attrs[\"standard_name\"]\n473     elif da.name is not None:\n474         name = da.name\n475     else:\n476         name = \"\"\n477 \n478     def _get_units_from_attrs(da):\n479         if da.attrs.get(\"units\"):\n480             units = \" [{}]\".format(da.attrs[\"units\"])\n481         elif da.attrs.get(\"unit\"):\n482             units = \" [{}]\".format(da.attrs[\"unit\"])\n483         else:\n484             units = \"\"\n485         return units\n486 \n487     pint_array_type = DuckArrayModule(\"pint\").type\n488     if isinstance(da.data, pint_array_type):\n489         units = \" [{}]\".format(str(da.data.units))\n490     else:\n491         units = _get_units_from_attrs(da)\n492 \n493     return \"\\n\".join(textwrap.wrap(name + extra + units, 30))\n",
        "intended_behavior": "This utility function should be enhanced to detect long_name values that are structured as LaTeX expressions. Upon detection, it should ensure that these values are formatted or flagged appropriately for LaTeX rendering by matplotlib. This could involve prepending r'$...$' if it's not already present (while being cautious not to double-wrap LaTeX strings) or utilizing any matplotlib utilities designed for LaTeX label handling. The change must preserve the handling of non-LaTeX long_names as plain text."
    }
]