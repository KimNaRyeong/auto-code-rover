2025-10-15 07:43:41.973 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-15 07:43:47.011 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=306, output_tokens=12, cost=0.003420
2025-10-15 07:43:58.808 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=486, output_tokens=458, cost=0.018600
2025-10-15 07:44:00.141 | INFO     | registered non reproducing test 0
2025-10-15 07:44:17.443 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1327, output_tokens=649, cost=0.032740
2025-10-15 07:44:18.730 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 07:44:25.355 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=613, output_tokens=228, cost=0.012970
2025-10-15 07:44:25.360 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 07:44:28.683 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=582, output_tokens=60, cost=0.007620
2025-10-15 07:44:28.685 | INFO     | Refactored invocation argument parsing gives different result on 'get_code_around_line("lib/matplotlib/figure.py", 1550, 5)': old result is ['lib/matplotlib/figure.py', '1550', '5'], new result  is ['lib/matplotlib/figure.py', 1550, 5]
2025-10-15 07:44:28.686 | DEBUG    | Extracted a valid json.
2025-10-15 07:44:28.686 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_class(\"Figure\")",
        "search_method_in_class(\"subfigures\", \"Figure\")",
        "get_code_around_line(\"lib/matplotlib/figure.py\", 1550, 5)"
    ],
    "bug_locations": []
}
2025-10-15 07:44:28.706 | INFO     | Refactored invocation argument parsing gives different result on 'get_code_around_line("lib/matplotlib/figure.py", 1550, 5)': old result is ['lib/matplotlib/figure.py', '1550', '5'], new result  is ['lib/matplotlib/figure.py', 1550, 5]
2025-10-15 07:44:28.731 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-15 07:44:28.731 | DEBUG    | <Agent search> Analyzing search results.
2025-10-15 07:44:48.253 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1916, output_tokens=761, cost=0.041990
2025-10-15 07:44:48.268 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 07:44:54.498 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2893, output_tokens=236, cost=0.036010
2025-10-15 07:44:54.519 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 07:45:02.357 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=590, output_tokens=233, cost=0.012890
2025-10-15 07:45:02.358 | DEBUG    | Extracted a valid json.
2025-10-15 07:45:02.358 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_code_in_file(\"wspace\", \"lib/matplotlib/figure.py\")",
        "search_code_in_file(\"hspace\", \"lib/matplotlib/figure.py\")"
    ],
    "bug_locations": [
        {
            "file": "lib/matplotlib/figure.py",
            "class": "FigureBase",
            "method": "subfigures",
            "intended_behavior": "The `subfigures` method should ensure that the `wspace` and `hspace` parameters are correctly applied to control the horizontal and vertical spacing between subfigures. To resolve the issue, the method's implementation needs to be reviewed to ensure that `wspace` and `hspace` values are effectively used to set the spacing between subfigures as intended, without overriding or neglecting these parameters during layout adjustments. This might involve modifying how these parameters interact with the layout engine or applying these spacing configurations directly within the method. The resolution should maintain or improve upon the method's current functionality, ensuring that it can dynamically adjust spacing based on provided parameters while preserving other layout arrangements and constraints."
        }
    ]
}
2025-10-15 07:45:02.406 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-15 07:45:02.406 | DEBUG    | <Agent search> Analyzing search results.
2025-10-15 07:45:21.159 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=3644, output_tokens=766, cost=0.059420
2025-10-15 07:45:21.171 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 07:45:27.769 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=4626, output_tokens=211, cost=0.052590
2025-10-15 07:45:27.774 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 07:45:33.783 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=565, output_tokens=200, cost=0.011650
2025-10-15 07:45:33.784 | DEBUG    | Extracted a valid json.
2025-10-15 07:45:33.784 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations":[
        {
            "file": "lib/matplotlib/figure.py",
            "class": "FigureBase",
            "method": "subfigures",
            "intended_behavior": "The implementation of `subfigures` should correctly apply `wspace` and `hspace` parameters to adjust the horizontal and vertical spacing between subfigures. Specifically, when a user specifies these parameters, the layout of subfigures created by this method should visually reflect the specified spacings. This necessitates a check that these parameters are not merely accepted but actively influence the layout properties of the resulting subfigures. Any functionality to calculate or adjust layout spacing based on `wspace` and `hspace` needs to ensure these parameters contribute to the final layout calculation process. This behavior would not only resolve the reported issue but also enhance user control over figure layouts in matplotlib, maintaining the library's flexibility and utility for complex visualizations."
        }
    ]
}
2025-10-15 07:45:33.796 | DEBUG    | Bug location extracted successfully: [<file>lib/matplotlib/figure.py</file>
<class>FigureBase</class>
<method>subfigures</method>
<code>
1545     def subfigures(self, nrows=1, ncols=1, squeeze=True,
1546                    wspace=None, hspace=None,
1547                    width_ratios=None, height_ratios=None,
1548                    **kwargs):
1549         """
1550         Add a set of subfigures to this figure or subfigure.
1551 
1552         A subfigure has the same artist methods as a figure, and is logically
1553         the same as a figure, but cannot print itself.
1554         See :doc:`/gallery/subplots_axes_and_figures/subfigures`.
1555 
1556         .. note::
1557             The *subfigure* concept is new in v3.4, and the API is still provisional.
1558 
1559         Parameters
1560         ----------
1561         nrows, ncols : int, default: 1
1562             Number of rows/columns of the subfigure grid.
1563 
1564         squeeze : bool, default: True
1565             If True, extra dimensions are squeezed out from the returned
1566             array of subfigures.
1567 
1568         wspace, hspace : float, default: None
1569             The amount of width/height reserved for space between subfigures,
1570             expressed as a fraction of the average subfigure width/height.
1571             If not given, the values will be inferred from a figure or
1572             rcParams when necessary.
1573 
1574         width_ratios : array-like of length *ncols*, optional
1575             Defines the relative widths of the columns. Each column gets a
1576             relative width of ``width_ratios[i] / sum(width_ratios)``.
1577             If not given, all columns will have the same width.
1578 
1579         height_ratios : array-like of length *nrows*, optional
1580             Defines the relative heights of the rows. Each row gets a
1581             relative height of ``height_ratios[i] / sum(height_ratios)``.
1582             If not given, all rows will have the same height.
1583         """
1584         gs = GridSpec(nrows=nrows, ncols=ncols, figure=self,
1585                       wspace=wspace, hspace=hspace,
1586                       width_ratios=width_ratios,
1587                       height_ratios=height_ratios)
1588 
1589         sfarr = np.empty((nrows, ncols), dtype=object)
1590         for i in range(ncols):
1591             for j in range(nrows):
1592                 sfarr[j, i] = self.add_subfigure(gs[j, i], **kwargs)
1593 
1594         if squeeze:
1595             # Discarding unneeded dimensions that equal 1.  If we only have one
1596             # subfigure, just return it instead of a 1-element array.
1597             return sfarr.item() if sfarr.size == 1 else sfarr.squeeze()
1598         else:
1599             # Returned axis array will be always 2-d, even if nrows=ncols=1.
1600             return sfarr

</code><intended_behavior>The implementation of `subfigures` should correctly apply `wspace` and `hspace` parameters to adjust the horizontal and vertical spacing between subfigures. Specifically, when a user specifies these parameters, the layout of subfigures created by this method should visually reflect the specified spacings. This necessitates a check that these parameters are not merely accepted but actively influence the layout properties of the resulting subfigures. Any functionality to calculate or adjust layout spacing based on `wspace` and `hspace` needs to ensure these parameters contribute to the final layout calculation process. This behavior would not only resolve the reported issue but also enhance user control over figure layouts in matplotlib, maintaining the library's flexibility and utility for complex visualizations.</intended_behavior>, <file>lib/matplotlib/figure.py</file>
<class>FigureBase</class>
<method>None</method>
<code>
180 class FigureBase(Artist):
181     """
182     Base class for `.Figure` and `.SubFigure` containing the methods that add
183     artists to the figure or subfigure, create Axes, etc.
184     """
185     def __init__(self, **kwargs):
186         super().__init__()
187         # remove the non-figure artist _axes property
188         # as it makes no sense for a figure to be _in_ an Axes
189         # this is used by the property methods in the artist base class
190         # which are over-ridden in this class
191         del self._axes
192 
193         self._suptitle = None
194         self._supxlabel = None
195         self._supylabel = None
196 
197         # groupers to keep track of x and y labels we want to align.
198         # see self.align_xlabels and self.align_ylabels and
199         # axis._get_tick_boxes_siblings
200         self._align_label_groups = {"x": cbook.Grouper(), "y": cbook.Grouper()}
201 
202         self._localaxes = []  # track all axes
203         self.artists = []
204         self.lines = []
205         self.patches = []
206         self.texts = []
207         self.images = []
208         self.legends = []
209         self.subfigs = []
210         self.stale = True
211         self.suppressComposite = None
212         self.set(**kwargs)
213 
214     def _get_draw_artists(self, renderer):
215         """Also runs apply_aspect"""
216         artists = self.get_children()
217         for sfig in self.subfigs:
218             artists.remove(sfig)
219             childa = sfig.get_children()
220             for child in childa:
221                 if child in artists:
222                     artists.remove(child)
223 
224         artists.remove(self.patch)
225         artists = sorted(
226             (artist for artist in artists if not artist.get_animated()),
227             key=lambda artist: artist.get_zorder())
228         for ax in self._localaxes:
229             locator = ax.get_axes_locator()
230             ax.apply_aspect(locator(ax, renderer) if locator else None)
231 
232             for child in ax.get_children():
233                 if hasattr(child, 'apply_aspect'):
234                     locator = child.get_axes_locator()
235                     child.apply_aspect(
236                         locator(child, renderer) if locator else None)
237         return artists
238 
239     def autofmt_xdate(
240             self, bottom=0.2, rotation=30, ha='right', which='major'):
241         """
242         Date ticklabels often overlap, so it is useful to rotate them
243         and right align them.  Also, a common use case is a number of
244         subplots with shared x-axis where the x-axis is date data.  The
245         ticklabels are often long, and it helps to rotate them on the
246         bottom subplot and turn them off on other subplots, as well as
247         turn off xlabels.
248 
249         Parameters
250         ----------
251         bottom : float, default: 0.2
252             The bottom of the subplots for `subplots_adjust`.
253         rotation : float, default: 30 degrees
254             The rotation angle of the xtick labels in degrees.
255         ha : {'left', 'center', 'right'}, default: 'right'
256             The horizontal alignment of the xticklabels.
257         which : {'major', 'minor', 'both'}, default: 'major'
258             Selects which ticklabels to rotate.
259         """
260         _api.check_in_list(['major', 'minor', 'both'], which=which)
261         allsubplots = all(ax.get_subplotspec() for ax in self.axes)
262         if len(self.axes) == 1:
263             for label in self.axes[0].get_xticklabels(which=which):
264                 label.set_ha(ha)
265                 label.set_rotation(rotation)
266         else:
267             if allsubplots:
268                 for ax in self.get_axes():
269                     if ax.get_subplotspec().is_last_row():
270                         for label in ax.get_xticklabels(which=which):
271                             label.set_ha(ha)
272                             label.set_rotation(rotation)
273                     else:
274                         for label in ax.get_xticklabels(which=which):
275                             label.set_visible(False)
276                         ax.set_xlabel('')
277 
278         if allsubplots:
279             self.subplots_adjust(bottom=bottom)
280         self.stale = True
281 
282     def get_children(self):
283         """Get a list of artists contained in the figure."""
284         return [self.patch,
285                 *self.artists,
286                 *self._localaxes,
287                 *self.lines,
288                 *self.patches,
289                 *self.texts,
290                 *self.images,
291                 *self.legends,
292                 *self.subfigs]
293 
294     def contains(self, mouseevent):
295         """
296         Test whether the mouse event occurred on the figure.
297 
298         Returns
299         -------
300             bool, {}
301         """
302         if self._different_canvas(mouseevent):
303             return False, {}
304         inside = self.bbox.contains(mouseevent.x, mouseevent.y)
305         return inside, {}
306 
307     def get_window_extent(self, renderer=None):
308         # docstring inherited
309         return self.bbox
310 
311     def _suplabels(self, t, info, **kwargs):
312         """
313         Add a centered %(name)s to the figure.
314 
315         Parameters
316         ----------
317         t : str
318             The %(name)s text.
319         x : float, default: %(x0)s
320             The x location of the text in figure coordinates.
321         y : float, default: %(y0)s
322             The y location of the text in figure coordinates.
323         horizontalalignment, ha : {'center', 'left', 'right'}, default: %(ha)s
324             The horizontal alignment of the text relative to (*x*, *y*).
325         verticalalignment, va : {'top', 'center', 'bottom', 'baseline'}, \
326 default: %(va)s
327             The vertical alignment of the text relative to (*x*, *y*).
328         fontsize, size : default: :rc:`figure.%(rc)ssize`
329             The font size of the text. See `.Text.set_size` for possible
330             values.
331         fontweight, weight : default: :rc:`figure.%(rc)sweight`
332             The font weight of the text. See `.Text.set_weight` for possible
333             values.
334 
335         Returns
336         -------
337         text
338             The `.Text` instance of the %(name)s.
339 
340         Other Parameters
341         ----------------
342         fontproperties : None or dict, optional
343             A dict of font properties. If *fontproperties* is given the
344             default values for font size and weight are taken from the
345             `.FontProperties` defaults. :rc:`figure.%(rc)ssize` and
346             :rc:`figure.%(rc)sweight` are ignored in this case.
347 
348         **kwargs
349             Additional kwargs are `matplotlib.text.Text` properties.
350         """
351 
352         suplab = getattr(self, info['name'])
353 
354         x = kwargs.pop('x', None)
355         y = kwargs.pop('y', None)
356         if info['name'] in ['_supxlabel', '_suptitle']:
357             autopos = y is None
358         elif info['name'] == '_supylabel':
359             autopos = x is None
360         if x is None:
361             x = info['x0']
362         if y is None:
363             y = info['y0']
364 
365         if 'horizontalalignment' not in kwargs and 'ha' not in kwargs:
366             kwargs['horizontalalignment'] = info['ha']
367         if 'verticalalignment' not in kwargs and 'va' not in kwargs:
368             kwargs['verticalalignment'] = info['va']
369         if 'rotation' not in kwargs:
370             kwargs['rotation'] = info['rotation']
371 
372         if 'fontproperties' not in kwargs:
373             if 'fontsize' not in kwargs and 'size' not in kwargs:
374                 kwargs['size'] = mpl.rcParams[info['size']]
375             if 'fontweight' not in kwargs and 'weight' not in kwargs:
376                 kwargs['weight'] = mpl.rcParams[info['weight']]
377 
378         sup = self.text(x, y, t, **kwargs)
379         if suplab is not None:
380             suplab.set_text(t)
381             suplab.set_position((x, y))
382             suplab.update_from(sup)
383             sup.remove()
384         else:
385             suplab = sup
386         suplab._autopos = autopos
387         setattr(self, info['name'], suplab)
388         self.stale = True
389         return suplab
390 
391     @_docstring.Substitution(x0=0.5, y0=0.98, name='suptitle', ha='center',
392                              va='top', rc='title')
393     @_docstring.copy(_suplabels)
394     def suptitle(self, t, **kwargs):
395         # docstring from _suplabels...
396         info = {'name': '_suptitle', 'x0': 0.5, 'y0': 0.98,
397                 'ha': 'center', 'va': 'top', 'rotation': 0,
398                 'size': 'figure.titlesize', 'weight': 'figure.titleweight'}
399         return self._suplabels(t, info, **kwargs)
400 
401     def get_suptitle(self):
402         """Return the suptitle as string or an empty string if not set."""
403         text_obj = self._suptitle
404         return "" if text_obj is None else text_obj.get_text()
405 
406     @_docstring.Substitution(x0=0.5, y0=0.01, name='supxlabel', ha='center',
407                              va='bottom', rc='label')
408     @_docstring.copy(_suplabels)
409     def supxlabel(self, t, **kwargs):
410         # docstring from _suplabels...
411         info = {'name': '_supxlabel', 'x0': 0.5, 'y0': 0.01,
412                 'ha': 'center', 'va': 'bottom', 'rotation': 0,
413                 'size': 'figure.labelsize', 'weight': 'figure.labelweight'}
414         return self._suplabels(t, info, **kwargs)
415 
416     def get_supxlabel(self):
417         """Return the supxlabel as string or an empty string if not set."""
418         text_obj = self._supxlabel
419         return "" if text_obj is None else text_obj.get_text()
420 
421     @_docstring.Substitution(x0=0.02, y0=0.5, name='supylabel', ha='left',
422                              va='center', rc='label')
423     @_docstring.copy(_suplabels)
424     def supylabel(self, t, **kwargs):
425         # docstring from _suplabels...
426         info = {'name': '_supylabel', 'x0': 0.02, 'y0': 0.5,
427                 'ha': 'left', 'va': 'center', 'rotation': 'vertical',
428                 'rotation_mode': 'anchor', 'size': 'figure.labelsize',
429                 'weight': 'figure.labelweight'}
430         return self._suplabels(t, info, **kwargs)
431 
432     def get_supylabel(self):
433         """Return the supylabel as string or an empty string if not set."""
434         text_obj = self._supylabel
435         return "" if text_obj is None else text_obj.get_text()
436 
437     def get_edgecolor(self):
438         """Get the edge color of the Figure rectangle."""
439         return self.patch.get_edgecolor()
440 
441     def get_facecolor(self):
442         """Get the face color of the Figure rectangle."""
443         return self.patch.get_facecolor()
444 
445     def get_frameon(self):
446         """
447         Return the figure's background patch visibility, i.e.
448         whether the figure background will be drawn. Equivalent to
449         ``Figure.patch.get_visible()``.
450         """
451         return self.patch.get_visible()
452 
453     def set_linewidth(self, linewidth):
454         """
455         Set the line width of the Figure rectangle.
456 
457         Parameters
458         ----------
459         linewidth : number
460         """
461         self.patch.set_linewidth(linewidth)
462 
463     def get_linewidth(self):
464         """
465         Get the line width of the Figure rectangle.
466         """
467         return self.patch.get_linewidth()
468 
469     def set_edgecolor(self, color):
470         """
471         Set the edge color of the Figure rectangle.
472 
473         Parameters
474         ----------
475         color : color
476         """
477         self.patch.set_edgecolor(color)
478 
479     def set_facecolor(self, color):
480         """
481         Set the face color of the Figure rectangle.
482 
483         Parameters
484         ----------
485         color : color
486         """
487         self.patch.set_facecolor(color)
488 
489     def set_frameon(self, b):
490         """
491         Set the figure's background patch visibility, i.e.
492         whether the figure background will be drawn. Equivalent to
493         ``Figure.patch.set_visible()``.
494 
495         Parameters
496         ----------
497         b : bool
498         """
499         self.patch.set_visible(b)
500         self.stale = True
501 
502     frameon = property(get_frameon, set_frameon)
503 
504     def add_artist(self, artist, clip=False):
505         """
506         Add an `.Artist` to the figure.
507 
508         Usually artists are added to `~.axes.Axes` objects using
509         `.Axes.add_artist`; this method can be used in the rare cases where
510         one needs to add artists directly to the figure instead.
511 
512         Parameters
513         ----------
514         artist : `~matplotlib.artist.Artist`
515             The artist to add to the figure. If the added artist has no
516             transform previously set, its transform will be set to
517             ``figure.transSubfigure``.
518         clip : bool, default: False
519             Whether the added artist should be clipped by the figure patch.
520 
521         Returns
522         -------
523         `~matplotlib.artist.Artist`
524             The added artist.
525         """
526         artist.set_figure(self)
527         self.artists.append(artist)
528         artist._remove_method = self.artists.remove
529 
530         if not artist.is_transform_set():
531             artist.set_transform(self.transSubfigure)
532 
533         if clip and artist.get_clip_path() is None:
534             artist.set_clip_path(self.patch)
535 
536         self.stale = True
537         return artist
538 
539     @_docstring.dedent_interpd
540     def add_axes(self, *args, **kwargs):
541         """
542         Add an `~.axes.Axes` to the figure.
543 
544         Call signatures::
545 
546             add_axes(rect, projection=None, polar=False, **kwargs)
547             add_axes(ax)
548 
549         Parameters
550         ----------
551         rect : tuple (left, bottom, width, height)
552             The dimensions (left, bottom, width, height) of the new
553             `~.axes.Axes`. All quantities are in fractions of figure width and
554             height.
555 
556         projection : {None, 'aitoff', 'hammer', 'lambert', 'mollweide', \
557 'polar', 'rectilinear', str}, optional
558             The projection type of the `~.axes.Axes`. *str* is the name of
559             a custom projection, see `~matplotlib.projections`. The default
560             None results in a 'rectilinear' projection.
561 
562         polar : bool, default: False
563             If True, equivalent to projection='polar'.
564 
565         axes_class : subclass type of `~.axes.Axes`, optional
566             The `.axes.Axes` subclass that is instantiated.  This parameter
567             is incompatible with *projection* and *polar*.  See
568             :ref:`axisartist_users-guide-index` for examples.
569 
570         sharex, sharey : `~.axes.Axes`, optional
571             Share the x or y `~matplotlib.axis` with sharex and/or sharey.
572             The axis will have the same limits, ticks, and scale as the axis
573             of the shared axes.
574 
575         label : str
576             A label for the returned Axes.
577 
578         Returns
579         -------
580         `~.axes.Axes`, or a subclass of `~.axes.Axes`
581             The returned axes class depends on the projection used. It is
582             `~.axes.Axes` if rectilinear projection is used and
583             `.projections.polar.PolarAxes` if polar projection is used.
584 
585         Other Parameters
586         ----------------
587         **kwargs
588             This method also takes the keyword arguments for
589             the returned Axes class. The keyword arguments for the
590             rectilinear Axes class `~.axes.Axes` can be found in
591             the following table but there might also be other keyword
592             arguments if another projection is used, see the actual Axes
593             class.
594 
595             %(Axes:kwdoc)s
596 
597         Notes
598         -----
599         In rare circumstances, `.add_axes` may be called with a single
600         argument, an Axes instance already created in the present figure but
601         not in the figure's list of Axes.
602 
603         See Also
604         --------
605         .Figure.add_subplot
606         .pyplot.subplot
607         .pyplot.axes
608         .Figure.subplots
609         .pyplot.subplots
610 
611         Examples
612         --------
613         Some simple examples::
614 
615             rect = l, b, w, h
616             fig = plt.figure()
617             fig.add_axes(rect)
618             fig.add_axes(rect, frameon=False, facecolor='g')
619             fig.add_axes(rect, polar=True)
620             ax = fig.add_axes(rect, projection='polar')
621             fig.delaxes(ax)
622             fig.add_axes(ax)
623         """
624 
625         if not len(args) and 'rect' not in kwargs:
626             raise TypeError(
627                 "add_axes() missing 1 required positional argument: 'rect'")
628         elif 'rect' in kwargs:
629             if len(args):
630                 raise TypeError(
631                     "add_axes() got multiple values for argument 'rect'")
632             args = (kwargs.pop('rect'), )
633 
634         if isinstance(args[0], Axes):
635             a, *extra_args = args
636             key = a._projection_init
637             if a.get_figure() is not self:
638                 raise ValueError(
639                     "The Axes must have been created in the present figure")
640         else:
641             rect, *extra_args = args
642             if not np.isfinite(rect).all():
643                 raise ValueError(f'all entries in rect must be finite not {rect}')
644             projection_class, pkw = self._process_projection_requirements(**kwargs)
645 
646             # create the new axes using the axes class given
647             a = projection_class(self, rect, **pkw)
648             key = (projection_class, pkw)
649 
650         if extra_args:
651             _api.warn_deprecated(
652                 "3.8",
653                 name="Passing more than one positional argument to Figure.add_axes",
654                 addendum="Any additional positional arguments are currently ignored.")
655         return self._add_axes_internal(a, key)
656 
657     @_docstring.dedent_interpd
658     def add_subplot(self, *args, **kwargs):
659         """
660         Add an `~.axes.Axes` to the figure as part of a subplot arrangement.
661 
662         Call signatures::
663 
664            add_subplot(nrows, ncols, index, **kwargs)
665            add_subplot(pos, **kwargs)
666            add_subplot(ax)
667            add_subplot()
668 
669         Parameters
670         ----------
671         *args : int, (int, int, *index*), or `.SubplotSpec`, default: (1, 1, 1)
672             The position of the subplot described by one of
673 
674             - Three integers (*nrows*, *ncols*, *index*). The subplot will
675               take the *index* position on a grid with *nrows* rows and
676               *ncols* columns. *index* starts at 1 in the upper left corner
677               and increases to the right.  *index* can also be a two-tuple
678               specifying the (*first*, *last*) indices (1-based, and including
679               *last*) of the subplot, e.g., ``fig.add_subplot(3, 1, (1, 2))``
680               makes a subplot that spans the upper 2/3 of the figure.
681             - A 3-digit integer. The digits are interpreted as if given
682               separately as three single-digit integers, i.e.
683               ``fig.add_subplot(235)`` is the same as
684               ``fig.add_subplot(2, 3, 5)``. Note that this can only be used
685               if there are no more than 9 subplots.
686             - A `.SubplotSpec`.
687 
688             In rare circumstances, `.add_subplot` may be called with a single
689             argument, a subplot Axes instance already created in the
690             present figure but not in the figure's list of Axes.
691 
692         projection : {None, 'aitoff', 'hammer', 'lambert', 'mollweide', \
693 'polar', 'rectilinear', str}, optional
694             The projection type of the subplot (`~.axes.Axes`). *str* is the
695             name of a custom projection, see `~matplotlib.projections`. The
696             default None results in a 'rectilinear' projection.
697 
698         polar : bool, default: False
699             If True, equivalent to projection='polar'.
700 
701         axes_class : subclass type of `~.axes.Axes`, optional
702             The `.axes.Axes` subclass that is instantiated.  This parameter
703             is incompatible with *projection* and *polar*.  See
704             :ref:`axisartist_users-guide-index` for examples.
705 
706         sharex, sharey : `~.axes.Axes`, optional
707             Share the x or y `~matplotlib.axis` with sharex and/or sharey.
708             The axis will have the same limits, ticks, and scale as the axis
709             of the shared axes.
710 
711         label : str
712             A label for the returned Axes.
713 
714         Returns
715         -------
716         `~.axes.Axes`
717 
718             The Axes of the subplot. The returned Axes can actually be an
719             instance of a subclass, such as `.projections.polar.PolarAxes` for
720             polar projections.
721 
722         Other Parameters
723         ----------------
724         **kwargs
725             This method also takes the keyword arguments for the returned Axes
726             base class; except for the *figure* argument. The keyword arguments
727             for the rectilinear base class `~.axes.Axes` can be found in
728             the following table but there might also be other keyword
729             arguments if another projection is used.
730 
731             %(Axes:kwdoc)s
732 
733         See Also
734         --------
735         .Figure.add_axes
736         .pyplot.subplot
737         .pyplot.axes
738         .Figure.subplots
739         .pyplot.subplots
740 
741         Examples
742         --------
743         ::
744 
745             fig = plt.figure()
746 
747             fig.add_subplot(231)
748             ax1 = fig.add_subplot(2, 3, 1)  # equivalent but more general
749 
750             fig.add_subplot(232, frameon=False)  # subplot with no frame
751             fig.add_subplot(233, projection='polar')  # polar subplot
752             fig.add_subplot(234, sharex=ax1)  # subplot sharing x-axis with ax1
753             fig.add_subplot(235, facecolor="red")  # red subplot
754 
755             ax1.remove()  # delete ax1 from the figure
756             fig.add_subplot(ax1)  # add ax1 back to the figure
757         """
758         if 'figure' in kwargs:
759             # Axes itself allows for a 'figure' kwarg, but since we want to
760             # bind the created Axes to self, it is not allowed here.
761             raise _api.kwarg_error("add_subplot", "figure")
762 
763         if (len(args) == 1
764                 and isinstance(args[0], mpl.axes._base._AxesBase)
765                 and args[0].get_subplotspec()):
766             ax = args[0]
767             key = ax._projection_init
768             if ax.get_figure() is not self:
769                 raise ValueError("The Axes must have been created in "
770                                  "the present figure")
771         else:
772             if not args:
773                 args = (1, 1, 1)
774             # Normalize correct ijk values to (i, j, k) here so that
775             # add_subplot(211) == add_subplot(2, 1, 1).  Invalid values will
776             # trigger errors later (via SubplotSpec._from_subplot_args).
777             if (len(args) == 1 and isinstance(args[0], Integral)
778                     and 100 <= args[0] <= 999):
779                 args = tuple(map(int, str(args[0])))
780             projection_class, pkw = self._process_projection_requirements(**kwargs)
781             ax = projection_class(self, *args, **pkw)
782             key = (projection_class, pkw)
783         return self._add_axes_internal(ax, key)
784 
785     def _add_axes_internal(self, ax, key):
786         """Private helper for `add_axes` and `add_subplot`."""
787         self._axstack.add(ax)
788         if ax not in self._localaxes:
789             self._localaxes.append(ax)
790         self.sca(ax)
791         ax._remove_method = self.delaxes
792         # this is to support plt.subplot's re-selection logic
793         ax._projection_init = key
794         self.stale = True
795         ax.stale_callback = _stale_figure_callback
796         return ax
797 
798     def subplots(self, nrows=1, ncols=1, *, sharex=False, sharey=False,
799                  squeeze=True, width_ratios=None, height_ratios=None,
800                  subplot_kw=None, gridspec_kw=None):
801         """
802         Add a set of subplots to this figure.
803 
804         This utility wrapper makes it convenient to create common layouts of
805         subplots in a single call.
806 
807         Parameters
808         ----------
809         nrows, ncols : int, default: 1
810             Number of rows/columns of the subplot grid.
811 
812         sharex, sharey : bool or {'none', 'all', 'row', 'col'}, default: False
813             Controls sharing of x-axis (*sharex*) or y-axis (*sharey*):
814 
815             - True or 'all': x- or y-axis will be shared among all subplots.
816             - False or 'none': each subplot x- or y-axis will be independent.
817             - 'row': each subplot row will share an x- or y-axis.
818             - 'col': each subplot column will share an x- or y-axis.
819 
820             When subplots have a shared x-axis along a column, only the x tick
821             labels of the bottom subplot are created. Similarly, when subplots
822             have a shared y-axis along a row, only the y tick labels of the
823             first column subplot are created. To later turn other subplots'
824             ticklabels on, use `~matplotlib.axes.Axes.tick_params`.
825 
826             When subplots have a shared axis that has units, calling
827             `.Axis.set_units` will update each axis with the new units.
828 
829         squeeze : bool, default: True
830             - If True, extra dimensions are squeezed out from the returned
831               array of Axes:
832 
833               - if only one subplot is constructed (nrows=ncols=1), the
834                 resulting single Axes object is returned as a scalar.
835               - for Nx1 or 1xM subplots, the returned object is a 1D numpy
836                 object array of Axes objects.
837               - for NxM, subplots with N>1 and M>1 are returned as a 2D array.
838 
839             - If False, no squeezing at all is done: the returned Axes object
840               is always a 2D array containing Axes instances, even if it ends
841               up being 1x1.
842 
843         width_ratios : array-like of length *ncols*, optional
844             Defines the relative widths of the columns. Each column gets a
845             relative width of ``width_ratios[i] / sum(width_ratios)``.
846             If not given, all columns will have the same width.  Equivalent
847             to ``gridspec_kw={'width_ratios': [...]}``.
848 
849         height_ratios : array-like of length *nrows*, optional
850             Defines the relative heights of the rows. Each row gets a
851             relative height of ``height_ratios[i] / sum(height_ratios)``.
852             If not given, all rows will have the same height. Equivalent
853             to ``gridspec_kw={'height_ratios': [...]}``.
854 
855         subplot_kw : dict, optional
856             Dict with keywords passed to the `.Figure.add_subplot` call used to
857             create each subplot.
858 
859         gridspec_kw : dict, optional
860             Dict with keywords passed to the
861             `~matplotlib.gridspec.GridSpec` constructor used to create
862             the grid the subplots are placed on.
863 
864         Returns
865         -------
866         `~.axes.Axes` or array of Axes
867             Either a single `~matplotlib.axes.Axes` object or an array of Axes
868             objects if more than one subplot was created. The dimensions of the
869             resulting array can be controlled with the *squeeze* keyword, see
870             above.
871 
872         See Also
873         --------
874         .pyplot.subplots
875         .Figure.add_subplot
876         .pyplot.subplot
877 
878         Examples
879         --------
880         ::
881 
882             # First create some toy data:
883             x = np.linspace(0, 2*np.pi, 400)
884             y = np.sin(x**2)
885 
886             # Create a figure
887             fig = plt.figure()
888 
889             # Create a subplot
890             ax = fig.subplots()
891             ax.plot(x, y)
892             ax.set_title('Simple plot')
893 
894             # Create two subplots and unpack the output array immediately
895             ax1, ax2 = fig.subplots(1, 2, sharey=True)
896             ax1.plot(x, y)
897             ax1.set_title('Sharing Y axis')
898             ax2.scatter(x, y)
899 
900             # Create four polar Axes and access them through the returned array
901             axes = fig.subplots(2, 2, subplot_kw=dict(projection='polar'))
902             axes[0, 0].plot(x, y)
903             axes[1, 1].scatter(x, y)
904 
905             # Share an X-axis with each column of subplots
906             fig.subplots(2, 2, sharex='col')
907 
908             # Share a Y-axis with each row of subplots
909             fig.subplots(2, 2, sharey='row')
910 
911             # Share both X- and Y-axes with all subplots
912             fig.subplots(2, 2, sharex='all', sharey='all')
913 
914             # Note that this is the same as
915             fig.subplots(2, 2, sharex=True, sharey=True)
916         """
917         gridspec_kw = dict(gridspec_kw or {})
918         if height_ratios is not None:
919             if 'height_ratios' in gridspec_kw:
920                 raise ValueError("'height_ratios' must not be defined both as "
921                                  "parameter and as key in 'gridspec_kw'")
922             gridspec_kw['height_ratios'] = height_ratios
923         if width_ratios is not None:
924             if 'width_ratios' in gridspec_kw:
925                 raise ValueError("'width_ratios' must not be defined both as "
926                                  "parameter and as key in 'gridspec_kw'")
927             gridspec_kw['width_ratios'] = width_ratios
928 
929         gs = self.add_gridspec(nrows, ncols, figure=self, **gridspec_kw)
930         axs = gs.subplots(sharex=sharex, sharey=sharey, squeeze=squeeze,
931                           subplot_kw=subplot_kw)
932         return axs
933 
934     def delaxes(self, ax):
935         """
936         Remove the `~.axes.Axes` *ax* from the figure; update the current Axes.
937         """
938 
939         self._axstack.remove(ax)
940         self._axobservers.process("_axes_change_event", self)
941         self.stale = True
942         self._localaxes.remove(ax)
943         self.canvas.release_mouse(ax)
944 
945         for name in ax._axis_names:  # Break link between any shared axes
946             grouper = ax._shared_axes[name]
947             siblings = [other for other in grouper.get_siblings(ax) if other is not ax]
948             if not siblings:  # Axes was not shared along this axis; we're done.
949                 continue
950             grouper.remove(ax)
951             # Formatters and locators may previously have been associated with the now
952             # removed axis.  Update them to point to an axis still there (we can pick
953             # any of them, and use the first sibling).
954             remaining_axis = siblings[0]._axis_map[name]
955             remaining_axis.get_major_formatter().set_axis(remaining_axis)
956             remaining_axis.get_major_locator().set_axis(remaining_axis)
957             remaining_axis.get_minor_formatter().set_axis(remaining_axis)
958             remaining_axis.get_minor_locator().set_axis(remaining_axis)
959 
960         ax._twinned_axes.remove(ax)  # Break link between any twinned axes.
961 
962     def clear(self, keep_observers=False):
963         """
964         Clear the figure.
965 
966         Parameters
967         ----------
968         keep_observers : bool, default: False
969             Set *keep_observers* to True if, for example,
970             a gui widget is tracking the Axes in the figure.
971         """
972         self.suppressComposite = None
973 
974         # first clear the axes in any subfigures
975         for subfig in self.subfigs:
976             subfig.clear(keep_observers=keep_observers)
977         self.subfigs = []
978 
979         for ax in tuple(self.axes):  # Iterate over the copy.
980             ax.clear()
981             self.delaxes(ax)  # Remove ax from self._axstack.
982 
983         self.artists = []
984         self.lines = []
985         self.patches = []
986         self.texts = []
987         self.images = []
988         self.legends = []
989         if not keep_observers:
990             self._axobservers = cbook.CallbackRegistry()
991         self._suptitle = None
992         self._supxlabel = None
993         self._supylabel = None
994 
995         self.stale = True
996 
997     # synonym for `clear`.
998     def clf(self, keep_observers=False):
999         """
1000         [*Discouraged*] Alias for the `clear()` method.
1001 
1002         .. admonition:: Discouraged
1003 
1004             The use of ``clf()`` is discouraged. Use ``clear()`` instead.
1005 
1006         Parameters
1007         ----------
1008         keep_observers : bool, default: False
1009             Set *keep_observers* to True if, for example,
1010             a gui widget is tracking the Axes in the figure.
1011         """
1012         return self.clear(keep_observers=keep_observers)
1013 
1014     # Note: the docstring below is modified with replace for the pyplot
1015     # version of this function because the method name differs (plt.figlegend)
1016     # the replacements are:
1017     #    " legend(" -> " figlegend(" for the signatures
1018     #    "fig.legend(" -> "plt.figlegend" for the code examples
1019     #    "ax.plot" -> "plt.plot" for consistency in using pyplot when able
1020     @_docstring.dedent_interpd
1021     def legend(self, *args, **kwargs):
1022         """
1023         Place a legend on the figure.
1024 
1025         Call signatures::
1026 
1027             legend()
1028             legend(handles, labels)
1029             legend(handles=handles)
1030             legend(labels)
1031 
1032         The call signatures correspond to the following different ways to use
1033         this method:
1034 
1035         **1. Automatic detection of elements to be shown in the legend**
1036 
1037         The elements to be added to the legend are automatically determined,
1038         when you do not pass in any extra arguments.
1039 
1040         In this case, the labels are taken from the artist. You can specify
1041         them either at artist creation or by calling the
1042         :meth:`~.Artist.set_label` method on the artist::
1043 
1044             ax.plot([1, 2, 3], label='Inline label')
1045             fig.legend()
1046 
1047         or::
1048 
1049             line, = ax.plot([1, 2, 3])
1050             line.set_label('Label via method')
1051             fig.legend()
1052 
1053         Specific lines can be excluded from the automatic legend element
1054         selection by defining a label starting with an underscore.
1055         This is default for all artists, so calling `.Figure.legend` without
1056         any arguments and without setting the labels manually will result in
1057         no legend being drawn.
1058 
1059 
1060         **2. Explicitly listing the artists and labels in the legend**
1061 
1062         For full control of which artists have a legend entry, it is possible
1063         to pass an iterable of legend artists followed by an iterable of
1064         legend labels respectively::
1065 
1066             fig.legend([line1, line2, line3], ['label1', 'label2', 'label3'])
1067 
1068 
1069         **3. Explicitly listing the artists in the legend**
1070 
1071         This is similar to 2, but the labels are taken from the artists'
1072         label properties. Example::
1073 
1074             line1, = ax1.plot([1, 2, 3], label='label1')
1075             line2, = ax2.plot([1, 2, 3], label='label2')
1076             fig.legend(handles=[line1, line2])
1077 
1078 
1079         **4. Labeling existing plot elements**
1080 
1081         .. admonition:: Discouraged
1082 
1083             This call signature is discouraged, because the relation between
1084             plot elements and labels is only implicit by their order and can
1085             easily be mixed up.
1086 
1087         To make a legend for all artists on all Axes, call this function with
1088         an iterable of strings, one for each legend item. For example::
1089 
1090             fig, (ax1, ax2) = plt.subplots(1, 2)
1091             ax1.plot([1, 3, 5], color='blue')
1092             ax2.plot([2, 4, 6], color='red')
1093             fig.legend(['the blues', 'the reds'])
1094 
1095 
1096         Parameters
1097         ----------
1098         handles : list of `.Artist`, optional
1099             A list of Artists (lines, patches) to be added to the legend.
1100             Use this together with *labels*, if you need full control on what
1101             is shown in the legend and the automatic mechanism described above
1102             is not sufficient.
1103 
1104             The length of handles and labels should be the same in this
1105             case. If they are not, they are truncated to the smaller length.
1106 
1107         labels : list of str, optional
1108             A list of labels to show next to the artists.
1109             Use this together with *handles*, if you need full control on what
1110             is shown in the legend and the automatic mechanism described above
1111             is not sufficient.
1112 
1113         Returns
1114         -------
1115         `~matplotlib.legend.Legend`
1116 
1117         Other Parameters
1118         ----------------
1119         %(_legend_kw_figure)s
1120 
1121         See Also
1122         --------
1123         .Axes.legend
1124 
1125         Notes
1126         -----
1127         Some artists are not supported by this function.  See
1128         :ref:`legend_guide` for details.
1129         """
1130 
1131         handles, labels, extra_args, kwargs = mlegend._parse_legend_args(
1132                 self.axes,
1133                 *args,
1134                 **kwargs)
1135         # check for third arg
1136         if len(extra_args):
1137             # _api.warn_deprecated(
1138             #     "2.1",
1139             #     message="Figure.legend will accept no more than two "
1140             #     "positional arguments in the future.  Use "
1141             #     "'fig.legend(handles, labels, loc=location)' "
1142             #     "instead.")
1143             # kwargs['loc'] = extra_args[0]
1144             # extra_args = extra_args[1:]
1145             pass
1146         transform = kwargs.pop('bbox_transform', self.transSubfigure)
1147         # explicitly set the bbox transform if the user hasn't.
1148         l = mlegend.Legend(self, handles, labels, *extra_args,
1149                            bbox_transform=transform, **kwargs)
1150         self.legends.append(l)
1151         l._remove_method = self.legends.remove
1152         self.stale = True
1153         return l
1154 
1155     @_docstring.dedent_interpd
1156     def text(self, x, y, s, fontdict=None, **kwargs):
1157         """
1158         Add text to figure.
1159 
1160         Parameters
1161         ----------
1162         x, y : float
1163             The position to place the text. By default, this is in figure
1164             coordinates, floats in [0, 1]. The coordinate system can be changed
1165             using the *transform* keyword.
1166 
1167         s : str
1168             The text string.
1169 
1170         fontdict : dict, optional
1171             A dictionary to override the default text properties. If not given,
1172             the defaults are determined by :rc:`font.*`. Properties passed as
1173             *kwargs* override the corresponding ones given in *fontdict*.
1174 
1175         Returns
1176         -------
1177         `~.text.Text`
1178 
1179         Other Parameters
1180         ----------------
1181         **kwargs : `~matplotlib.text.Text` properties
1182             Other miscellaneous text parameters.
1183 
1184             %(Text:kwdoc)s
1185 
1186         See Also
1187         --------
1188         .Axes.text
1189         .pyplot.text
1190         """
1191         effective_kwargs = {
1192             'transform': self.transSubfigure,
1193             **(fontdict if fontdict is not None else {}),
1194             **kwargs,
1195         }
1196         text = Text(x=x, y=y, text=s, **effective_kwargs)
1197         text.set_figure(self)
1198         text.stale_callback = _stale_figure_callback
1199 
1200         self.texts.append(text)
1201         text._remove_method = self.texts.remove
1202         self.stale = True
1203         return text
1204 
1205     @_docstring.dedent_interpd
1206     def colorbar(
1207             self, mappable, cax=None, ax=None, use_gridspec=True, **kwargs):
1208         """
1209         Add a colorbar to a plot.
1210 
1211         Parameters
1212         ----------
1213         mappable
1214             The `matplotlib.cm.ScalarMappable` (i.e., `.AxesImage`,
1215             `.ContourSet`, etc.) described by this colorbar.  This argument is
1216             mandatory for the `.Figure.colorbar` method but optional for the
1217             `.pyplot.colorbar` function, which sets the default to the current
1218             image.
1219 
1220             Note that one can create a `.ScalarMappable` "on-the-fly" to
1221             generate colorbars not attached to a previously drawn artist, e.g.
1222             ::
1223 
1224                 fig.colorbar(cm.ScalarMappable(norm=norm, cmap=cmap), ax=ax)
1225 
1226         cax : `~matplotlib.axes.Axes`, optional
1227             Axes into which the colorbar will be drawn.  If `None`, then a new
1228             Axes is created and the space for it will be stolen from the Axes(s)
1229             specified in *ax*.
1230 
1231         ax : `~.axes.Axes` or iterable or `numpy.ndarray` of Axes, optional
1232             The one or more parent Axes from which space for a new colorbar Axes
1233             will be stolen. This parameter is only used if *cax* is not set.
1234 
1235             Defaults to the Axes that contains the mappable used to create the
1236             colorbar.
1237 
1238         use_gridspec : bool, optional
1239             If *cax* is ``None``, a new *cax* is created as an instance of
1240             Axes.  If *ax* is positioned with a subplotspec and *use_gridspec*
1241             is ``True``, then *cax* is also positioned with a subplotspec.
1242 
1243         Returns
1244         -------
1245         colorbar : `~matplotlib.colorbar.Colorbar`
1246 
1247         Other Parameters
1248         ----------------
1249         %(_make_axes_kw_doc)s
1250         %(_colormap_kw_doc)s
1251 
1252         Notes
1253         -----
1254         If *mappable* is a `~.contour.ContourSet`, its *extend* kwarg is
1255         included automatically.
1256 
1257         The *shrink* kwarg provides a simple way to scale the colorbar with
1258         respect to the axes. Note that if *cax* is specified, it determines the
1259         size of the colorbar, and *shrink* and *aspect* are ignored.
1260 
1261         For more precise control, you can manually specify the positions of the
1262         axes objects in which the mappable and the colorbar are drawn.  In this
1263         case, do not use any of the axes properties kwargs.
1264 
1265         It is known that some vector graphics viewers (svg and pdf) render
1266         white gaps between segments of the colorbar.  This is due to bugs in
1267         the viewers, not Matplotlib.  As a workaround, the colorbar can be
1268         rendered with overlapping segments::
1269 
1270             cbar = colorbar()
1271             cbar.solids.set_edgecolor("face")
1272             draw()
1273 
1274         However, this has negative consequences in other circumstances, e.g.
1275         with semi-transparent images (alpha < 1) and colorbar extensions;
1276         therefore, this workaround is not used by default (see issue #1188).
1277 
1278         """
1279 
1280         if ax is None:
1281             ax = getattr(mappable, "axes", None)
1282 
1283         if cax is None:
1284             if ax is None:
1285                 raise ValueError(
1286                     'Unable to determine Axes to steal space for Colorbar. '
1287                     'Either provide the *cax* argument to use as the Axes for '
1288                     'the Colorbar, provide the *ax* argument to steal space '
1289                     'from it, or add *mappable* to an Axes.')
1290             fig = (  # Figure of first axes; logic copied from make_axes.
1291                 [*ax.flat] if isinstance(ax, np.ndarray)
1292                 else [*ax] if np.iterable(ax)
1293                 else [ax])[0].figure
1294             current_ax = fig.gca()
1295             if (fig.get_layout_engine() is not None and
1296                     not fig.get_layout_engine().colorbar_gridspec):
1297                 use_gridspec = False
1298             if (use_gridspec
1299                     and isinstance(ax, mpl.axes._base._AxesBase)
1300                     and ax.get_subplotspec()):
1301                 cax, kwargs = cbar.make_axes_gridspec(ax, **kwargs)
1302             else:
1303                 cax, kwargs = cbar.make_axes(ax, **kwargs)
1304             # make_axes calls add_{axes,subplot} which changes gca; undo that.
1305             fig.sca(current_ax)
1306             cax.grid(visible=False, which='both', axis='both')
1307 
1308         NON_COLORBAR_KEYS = [  # remove kws that cannot be passed to Colorbar
1309             'fraction', 'pad', 'shrink', 'aspect', 'anchor', 'panchor']
1310         cb = cbar.Colorbar(cax, mappable, **{
1311             k: v for k, v in kwargs.items() if k not in NON_COLORBAR_KEYS})
1312         cax.figure.stale = True
1313         return cb
1314 
1315     def subplots_adjust(self, left=None, bottom=None, right=None, top=None,
1316                         wspace=None, hspace=None):
1317         """
1318         Adjust the subplot layout parameters.
1319 
1320         Unset parameters are left unmodified; initial values are given by
1321         :rc:`figure.subplot.[name]`.
1322 
1323         Parameters
1324         ----------
1325         left : float, optional
1326             The position of the left edge of the subplots,
1327             as a fraction of the figure width.
1328         right : float, optional
1329             The position of the right edge of the subplots,
1330             as a fraction of the figure width.
1331         bottom : float, optional
1332             The position of the bottom edge of the subplots,
1333             as a fraction of the figure height.
1334         top : float, optional
1335             The position of the top edge of the subplots,
1336             as a fraction of the figure height.
1337         wspace : float, optional
1338             The width of the padding between subplots,
1339             as a fraction of the average Axes width.
1340         hspace : float, optional
1341             The height of the padding between subplots,
1342             as a fraction of the average Axes height.
1343         """
1344         if (self.get_layout_engine() is not None and
1345                 not self.get_layout_engine().adjust_compatible):
1346             _api.warn_external(
1347                 "This figure was using a layout engine that is "
1348                 "incompatible with subplots_adjust and/or tight_layout; "
1349                 "not calling subplots_adjust.")
1350             return
1351         self.subplotpars.update(left, bottom, right, top, wspace, hspace)
1352         for ax in self.axes:
1353             if ax.get_subplotspec() is not None:
1354                 ax._set_position(ax.get_subplotspec().get_position(self))
1355         self.stale = True
1356 
1357     def align_xlabels(self, axs=None):
1358         """
1359         Align the xlabels of subplots in the same subplot column if label
1360         alignment is being done automatically (i.e. the label position is
1361         not manually set).
1362 
1363         Alignment persists for draw events after this is called.
1364 
1365         If a label is on the bottom, it is aligned with labels on Axes that
1366         also have their label on the bottom and that have the same
1367         bottom-most subplot row.  If the label is on the top,
1368         it is aligned with labels on Axes with the same top-most row.
1369 
1370         Parameters
1371         ----------
1372         axs : list of `~matplotlib.axes.Axes`
1373             Optional list of (or `~numpy.ndarray`) `~matplotlib.axes.Axes`
1374             to align the xlabels.
1375             Default is to align all Axes on the figure.
1376 
1377         See Also
1378         --------
1379         matplotlib.figure.Figure.align_ylabels
1380         matplotlib.figure.Figure.align_labels
1381 
1382         Notes
1383         -----
1384         This assumes that ``axs`` are from the same `.GridSpec`, so that
1385         their `.SubplotSpec` positions correspond to figure positions.
1386 
1387         Examples
1388         --------
1389         Example with rotated xtick labels::
1390 
1391             fig, axs = plt.subplots(1, 2)
1392             for tick in axs[0].get_xticklabels():
1393                 tick.set_rotation(55)
1394             axs[0].set_xlabel('XLabel 0')
1395             axs[1].set_xlabel('XLabel 1')
1396             fig.align_xlabels()
1397         """
1398         if axs is None:
1399             axs = self.axes
1400         axs = [ax for ax in np.ravel(axs) if ax.get_subplotspec() is not None]
1401         for ax in axs:
1402             _log.debug(' Working on: %s', ax.get_xlabel())
1403             rowspan = ax.get_subplotspec().rowspan
1404             pos = ax.xaxis.get_label_position()  # top or bottom
1405             # Search through other axes for label positions that are same as
1406             # this one and that share the appropriate row number.
1407             # Add to a grouper associated with each axes of siblings.
1408             # This list is inspected in `axis.draw` by
1409             # `axis._update_label_position`.
1410             for axc in axs:
1411                 if axc.xaxis.get_label_position() == pos:
1412                     rowspanc = axc.get_subplotspec().rowspan
1413                     if (pos == 'top' and rowspan.start == rowspanc.start or
1414                             pos == 'bottom' and rowspan.stop == rowspanc.stop):
1415                         # grouper for groups of xlabels to align
1416                         self._align_label_groups['x'].join(ax, axc)
1417 
1418     def align_ylabels(self, axs=None):
1419         """
1420         Align the ylabels of subplots in the same subplot column if label
1421         alignment is being done automatically (i.e. the label position is
1422         not manually set).
1423 
1424         Alignment persists for draw events after this is called.
1425 
1426         If a label is on the left, it is aligned with labels on Axes that
1427         also have their label on the left and that have the same
1428         left-most subplot column.  If the label is on the right,
1429         it is aligned with labels on Axes with the same right-most column.
1430 
1431         Parameters
1432         ----------
1433         axs : list of `~matplotlib.axes.Axes`
1434             Optional list (or `~numpy.ndarray`) of `~matplotlib.axes.Axes`
1435             to align the ylabels.
1436             Default is to align all Axes on the figure.
1437 
1438         See Also
1439         --------
1440         matplotlib.figure.Figure.align_xlabels
1441         matplotlib.figure.Figure.align_labels
1442 
1443         Notes
1444         -----
1445         This assumes that ``axs`` are from the same `.GridSpec`, so that
1446         their `.SubplotSpec` positions correspond to figure positions.
1447 
1448         Examples
1449         --------
1450         Example with large yticks labels::
1451 
1452             fig, axs = plt.subplots(2, 1)
1453             axs[0].plot(np.arange(0, 1000, 50))
1454             axs[0].set_ylabel('YLabel 0')
1455             axs[1].set_ylabel('YLabel 1')
1456             fig.align_ylabels()
1457         """
1458         if axs is None:
1459             axs = self.axes
1460         axs = [ax for ax in np.ravel(axs) if ax.get_subplotspec() is not None]
1461         for ax in axs:
1462             _log.debug(' Working on: %s', ax.get_ylabel())
1463             colspan = ax.get_subplotspec().colspan
1464             pos = ax.yaxis.get_label_position()  # left or right
1465             # Search through other axes for label positions that are same as
1466             # this one and that share the appropriate column number.
1467             # Add to a list associated with each axes of siblings.
1468             # This list is inspected in `axis.draw` by
1469             # `axis._update_label_position`.
1470             for axc in axs:
1471                 if axc.yaxis.get_label_position() == pos:
1472                     colspanc = axc.get_subplotspec().colspan
1473                     if (pos == 'left' and colspan.start == colspanc.start or
1474                             pos == 'right' and colspan.stop == colspanc.stop):
1475                         # grouper for groups of ylabels to align
1476                         self._align_label_groups['y'].join(ax, axc)
1477 
1478     def align_labels(self, axs=None):
1479         """
1480         Align the xlabels and ylabels of subplots with the same subplots
1481         row or column (respectively) if label alignment is being
1482         done automatically (i.e. the label position is not manually set).
1483 
1484         Alignment persists for draw events after this is called.
1485 
1486         Parameters
1487         ----------
1488         axs : list of `~matplotlib.axes.Axes`
1489             Optional list (or `~numpy.ndarray`) of `~matplotlib.axes.Axes`
1490             to align the labels.
1491             Default is to align all Axes on the figure.
1492 
1493         See Also
1494         --------
1495         matplotlib.figure.Figure.align_xlabels
1496 
1497         matplotlib.figure.Figure.align_ylabels
1498         """
1499         self.align_xlabels(axs=axs)
1500         self.align_ylabels(axs=axs)
1501 
1502     def add_gridspec(self, nrows=1, ncols=1, **kwargs):
1503         """
1504         Return a `.GridSpec` that has this figure as a parent.  This allows
1505         complex layout of Axes in the figure.
1506 
1507         Parameters
1508         ----------
1509         nrows : int, default: 1
1510             Number of rows in grid.
1511 
1512         ncols : int, default: 1
1513             Number of columns in grid.
1514 
1515         Returns
1516         -------
1517         `.GridSpec`
1518 
1519         Other Parameters
1520         ----------------
1521         **kwargs
1522             Keyword arguments are passed to `.GridSpec`.
1523 
1524         See Also
1525         --------
1526         matplotlib.pyplot.subplots
1527 
1528         Examples
1529         --------
1530         Adding a subplot that spans two rows::
1531 
1532             fig = plt.figure()
1533             gs = fig.add_gridspec(2, 2)
1534             ax1 = fig.add_subplot(gs[0, 0])
1535             ax2 = fig.add_subplot(gs[1, 0])
1536             # spans two rows:
1537             ax3 = fig.add_subplot(gs[:, 1])
1538 
1539         """
1540 
1541         _ = kwargs.pop('figure', None)  # pop in case user has added this...
1542         gs = GridSpec(nrows=nrows, ncols=ncols, figure=self, **kwargs)
1543         return gs
1544 
1545     def subfigures(self, nrows=1, ncols=1, squeeze=True,
1546                    wspace=None, hspace=None,
1547                    width_ratios=None, height_ratios=None,
1548                    **kwargs):
1549         """
1550         Add a set of subfigures to this figure or subfigure.
1551 
1552         A subfigure has the same artist methods as a figure, and is logically
1553         the same as a figure, but cannot print itself.
1554         See :doc:`/gallery/subplots_axes_and_figures/subfigures`.
1555 
1556         .. note::
1557             The *subfigure* concept is new in v3.4, and the API is still provisional.
1558 
1559         Parameters
1560         ----------
1561         nrows, ncols : int, default: 1
1562             Number of rows/columns of the subfigure grid.
1563 
1564         squeeze : bool, default: True
1565             If True, extra dimensions are squeezed out from the returned
1566             array of subfigures.
1567 
1568         wspace, hspace : float, default: None
1569             The amount of width/height reserved for space between subfigures,
1570             expressed as a fraction of the average subfigure width/height.
1571             If not given, the values will be inferred from a figure or
1572             rcParams when necessary.
1573 
1574         width_ratios : array-like of length *ncols*, optional
1575             Defines the relative widths of the columns. Each column gets a
1576             relative width of ``width_ratios[i] / sum(width_ratios)``.
1577             If not given, all columns will have the same width.
1578 
1579         height_ratios : array-like of length *nrows*, optional
1580             Defines the relative heights of the rows. Each row gets a
1581             relative height of ``height_ratios[i] / sum(height_ratios)``.
1582             If not given, all rows will have the same height.
1583         """
1584         gs = GridSpec(nrows=nrows, ncols=ncols, figure=self,
1585                       wspace=wspace, hspace=hspace,
1586                       width_ratios=width_ratios,
1587                       height_ratios=height_ratios)
1588 
1589         sfarr = np.empty((nrows, ncols), dtype=object)
1590         for i in range(ncols):
1591             for j in range(nrows):
1592                 sfarr[j, i] = self.add_subfigure(gs[j, i], **kwargs)
1593 
1594         if squeeze:
1595             # Discarding unneeded dimensions that equal 1.  If we only have one
1596             # subfigure, just return it instead of a 1-element array.
1597             return sfarr.item() if sfarr.size == 1 else sfarr.squeeze()
1598         else:
1599             # Returned axis array will be always 2-d, even if nrows=ncols=1.
1600             return sfarr
1601 
1602     def add_subfigure(self, subplotspec, **kwargs):
1603         """
1604         Add a `.SubFigure` to the figure as part of a subplot arrangement.
1605 
1606         Parameters
1607         ----------
1608         subplotspec : `.gridspec.SubplotSpec`
1609             Defines the region in a parent gridspec where the subfigure will
1610             be placed.
1611 
1612         Returns
1613         -------
1614         `.SubFigure`
1615 
1616         Other Parameters
1617         ----------------
1618         **kwargs
1619             Are passed to the `.SubFigure` object.
1620 
1621         See Also
1622         --------
1623         .Figure.subfigures
1624         """
1625         sf = SubFigure(self, subplotspec, **kwargs)
1626         self.subfigs += [sf]
1627         return sf
1628 
1629     def sca(self, a):
1630         """Set the current Axes to be *a* and return *a*."""
1631         self._axstack.bubble(a)
1632         self._axobservers.process("_axes_change_event", self)
1633         return a
1634 
1635     def gca(self):
1636         """
1637         Get the current Axes.
1638 
1639         If there is currently no Axes on this Figure, a new one is created
1640         using `.Figure.add_subplot`.  (To test whether there is currently an
1641         Axes on a Figure, check whether ``figure.axes`` is empty.  To test
1642         whether there is currently a Figure on the pyplot figure stack, check
1643         whether `.pyplot.get_fignums()` is empty.)
1644         """
1645         ax = self._axstack.current()
1646         return ax if ax is not None else self.add_subplot()
1647 
1648     def _gci(self):
1649         # Helper for `~matplotlib.pyplot.gci`.  Do not use elsewhere.
1650         """
1651         Get the current colorable artist.
1652 
1653         Specifically, returns the current `.ScalarMappable` instance (`.Image`
1654         created by `imshow` or `figimage`, `.Collection` created by `pcolor` or
1655         `scatter`, etc.), or *None* if no such instance has been defined.
1656 
1657         The current image is an attribute of the current Axes, or the nearest
1658         earlier Axes in the current figure that contains an image.
1659 
1660         Notes
1661         -----
1662         Historically, the only colorable artists were images; hence the name
1663         ``gci`` (get current image).
1664         """
1665         # Look first for an image in the current Axes.
1666         ax = self._axstack.current()
1667         if ax is None:
1668             return None
1669         im = ax._gci()
1670         if im is not None:
1671             return im
1672         # If there is no image in the current Axes, search for
1673         # one in a previously created Axes.  Whether this makes
1674         # sense is debatable, but it is the documented behavior.
1675         for ax in reversed(self.axes):
1676             im = ax._gci()
1677             if im is not None:
1678                 return im
1679         return None
1680 
1681     def _process_projection_requirements(self, *, axes_class=None, polar=False,
1682                                          projection=None, **kwargs):
1683         """
1684         Handle the args/kwargs to add_axes/add_subplot/gca, returning::
1685 
1686             (axes_proj_class, proj_class_kwargs)
1687 
1688         which can be used for new Axes initialization/identification.
1689         """
1690         if axes_class is not None:
1691             if polar or projection is not None:
1692                 raise ValueError(
1693                     "Cannot combine 'axes_class' and 'projection' or 'polar'")
1694             projection_class = axes_class
1695         else:
1696 
1697             if polar:
1698                 if projection is not None and projection != 'polar':
1699                     raise ValueError(
1700                         f"polar={polar}, yet projection={projection!r}. "
1701                         "Only one of these arguments should be supplied."
1702                     )
1703                 projection = 'polar'
1704 
1705             if isinstance(projection, str) or projection is None:
1706                 projection_class = projections.get_projection_class(projection)
1707             elif hasattr(projection, '_as_mpl_axes'):
1708                 projection_class, extra_kwargs = projection._as_mpl_axes()
1709                 kwargs.update(**extra_kwargs)
1710             else:
1711                 raise TypeError(
1712                     f"projection must be a string, None or implement a "
1713                     f"_as_mpl_axes method, not {projection!r}")
1714         return projection_class, kwargs
1715 
1716     def get_default_bbox_extra_artists(self):
1717         bbox_artists = [artist for artist in self.get_children()
1718                         if (artist.get_visible() and artist.get_in_layout())]
1719         for ax in self.axes:
1720             if ax.get_visible():
1721                 bbox_artists.extend(ax.get_default_bbox_extra_artists())
1722         return bbox_artists
1723 
1724     @_api.make_keyword_only("3.8", "bbox_extra_artists")
1725     def get_tightbbox(self, renderer=None, bbox_extra_artists=None):
1726         """
1727         Return a (tight) bounding box of the figure *in inches*.
1728 
1729         Note that `.FigureBase` differs from all other artists, which return
1730         their `.Bbox` in pixels.
1731 
1732         Artists that have ``artist.set_in_layout(False)`` are not included
1733         in the bbox.
1734 
1735         Parameters
1736         ----------
1737         renderer : `.RendererBase` subclass
1738             Renderer that will be used to draw the figures (i.e.
1739             ``fig.canvas.get_renderer()``)
1740 
1741         bbox_extra_artists : list of `.Artist` or ``None``
1742             List of artists to include in the tight bounding box.  If
1743             ``None`` (default), then all artist children of each Axes are
1744             included in the tight bounding box.
1745 
1746         Returns
1747         -------
1748         `.BboxBase`
1749             containing the bounding box (in figure inches).
1750         """
1751 
1752         if renderer is None:
1753             renderer = self.figure._get_renderer()
1754 
1755         bb = []
1756         if bbox_extra_artists is None:
1757             artists = self.get_default_bbox_extra_artists()
1758         else:
1759             artists = bbox_extra_artists
1760 
1761         for a in artists:
1762             bbox = a.get_tightbbox(renderer)
1763             if bbox is not None:
1764                 bb.append(bbox)
1765 
1766         for ax in self.axes:
1767             if ax.get_visible():
1768                 # some axes don't take the bbox_extra_artists kwarg so we
1769                 # need this conditional....
1770                 try:
1771                     bbox = ax.get_tightbbox(
1772                         renderer, bbox_extra_artists=bbox_extra_artists)
1773                 except TypeError:
1774                     bbox = ax.get_tightbbox(renderer)
1775                 bb.append(bbox)
1776         bb = [b for b in bb
1777               if (np.isfinite(b.width) and np.isfinite(b.height)
1778                   and (b.width != 0 or b.height != 0))]
1779 
1780         isfigure = hasattr(self, 'bbox_inches')
1781         if len(bb) == 0:
1782             if isfigure:
1783                 return self.bbox_inches
1784             else:
1785                 # subfigures do not have bbox_inches, but do have a bbox
1786                 bb = [self.bbox]
1787 
1788         _bbox = Bbox.union(bb)
1789 
1790         if isfigure:
1791             # transform from pixels to inches...
1792             _bbox = TransformedBbox(_bbox, self.dpi_scale_trans.inverted())
1793 
1794         return _bbox
1795 
1796     @staticmethod
1797     def _norm_per_subplot_kw(per_subplot_kw):
1798         expanded = {}
1799         for k, v in per_subplot_kw.items():
1800             if isinstance(k, tuple):
1801                 for sub_key in k:
1802                     if sub_key in expanded:
1803                         raise ValueError(
1804                             f'The key {sub_key!r} appears multiple times.'
1805                             )
1806                     expanded[sub_key] = v
1807             else:
1808                 if k in expanded:
1809                     raise ValueError(
1810                         f'The key {k!r} appears multiple times.'
1811                     )
1812                 expanded[k] = v
1813         return expanded
1814 
1815     @staticmethod
1816     def _normalize_grid_string(layout):
1817         if '\n' not in layout:
1818             # single-line string
1819             return [list(ln) for ln in layout.split(';')]
1820         else:
1821             # multi-line string
1822             layout = inspect.cleandoc(layout)
1823             return [list(ln) for ln in layout.strip('\n').split('\n')]
1824 
1825     def subplot_mosaic(self, mosaic, *, sharex=False, sharey=False,
1826                        width_ratios=None, height_ratios=None,
1827                        empty_sentinel='.',
1828                        subplot_kw=None, per_subplot_kw=None, gridspec_kw=None):
1829         """
1830         Build a layout of Axes based on ASCII art or nested lists.
1831 
1832         This is a helper function to build complex GridSpec layouts visually.
1833 
1834         See :ref:`mosaic`
1835         for an example and full API documentation
1836 
1837         Parameters
1838         ----------
1839         mosaic : list of list of {hashable or nested} or str
1840 
1841             A visual layout of how you want your Axes to be arranged
1842             labeled as strings.  For example ::
1843 
1844                x = [['A panel', 'A panel', 'edge'],
1845                     ['C panel', '.',       'edge']]
1846 
1847             produces 4 Axes:
1848 
1849             - 'A panel' which is 1 row high and spans the first two columns
1850             - 'edge' which is 2 rows high and is on the right edge
1851             - 'C panel' which in 1 row and 1 column wide in the bottom left
1852             - a blank space 1 row and 1 column wide in the bottom center
1853 
1854             Any of the entries in the layout can be a list of lists
1855             of the same form to create nested layouts.
1856 
1857             If input is a str, then it can either be a multi-line string of
1858             the form ::
1859 
1860               '''
1861               AAE
1862               C.E
1863               '''
1864 
1865             where each character is a column and each line is a row. Or it
1866             can be a single-line string where rows are separated by ``;``::
1867 
1868               'AB;CC'
1869 
1870             The string notation allows only single character Axes labels and
1871             does not support nesting but is very terse.
1872 
1873             The Axes identifiers may be `str` or a non-iterable hashable
1874             object (e.g. `tuple` s may not be used).
1875 
1876         sharex, sharey : bool, default: False
1877             If True, the x-axis (*sharex*) or y-axis (*sharey*) will be shared
1878             among all subplots.  In that case, tick label visibility and axis
1879             units behave as for `subplots`.  If False, each subplot's x- or
1880             y-axis will be independent.
1881 
1882         width_ratios : array-like of length *ncols*, optional
1883             Defines the relative widths of the columns. Each column gets a
1884             relative width of ``width_ratios[i] / sum(width_ratios)``.
1885             If not given, all columns will have the same width.  Equivalent
1886             to ``gridspec_kw={'width_ratios': [...]}``. In the case of nested
1887             layouts, this argument applies only to the outer layout.
1888 
1889         height_ratios : array-like of length *nrows*, optional
1890             Defines the relative heights of the rows. Each row gets a
1891             relative height of ``height_ratios[i] / sum(height_ratios)``.
1892             If not given, all rows will have the same height. Equivalent
1893             to ``gridspec_kw={'height_ratios': [...]}``. In the case of nested
1894             layouts, this argument applies only to the outer layout.
1895 
1896         subplot_kw : dict, optional
1897             Dictionary with keywords passed to the `.Figure.add_subplot` call
1898             used to create each subplot.  These values may be overridden by
1899             values in *per_subplot_kw*.
1900 
1901         per_subplot_kw : dict, optional
1902             A dictionary mapping the Axes identifiers or tuples of identifiers
1903             to a dictionary of keyword arguments to be passed to the
1904             `.Figure.add_subplot` call used to create each subplot.  The values
1905             in these dictionaries have precedence over the values in
1906             *subplot_kw*.
1907 
1908             If *mosaic* is a string, and thus all keys are single characters,
1909             it is possible to use a single string instead of a tuple as keys;
1910             i.e. ``"AB"`` is equivalent to ``("A", "B")``.
1911 
1912             .. versionadded:: 3.7
1913 
1914         gridspec_kw : dict, optional
1915             Dictionary with keywords passed to the `.GridSpec` constructor used
1916             to create the grid the subplots are placed on. In the case of
1917             nested layouts, this argument applies only to the outer layout.
1918             For more complex layouts, users should use `.Figure.subfigures`
1919             to create the nesting.
1920 
1921         empty_sentinel : object, optional
1922             Entry in the layout to mean "leave this space empty".  Defaults
1923             to ``'.'``. Note, if *layout* is a string, it is processed via
1924             `inspect.cleandoc` to remove leading white space, which may
1925             interfere with using white-space as the empty sentinel.
1926 
1927         Returns
1928         -------
1929         dict[label, Axes]
1930            A dictionary mapping the labels to the Axes objects.  The order of
1931            the axes is left-to-right and top-to-bottom of their position in the
1932            total layout.
1933 
1934         """
1935         subplot_kw = subplot_kw or {}
1936         gridspec_kw = dict(gridspec_kw or {})
1937         per_subplot_kw = per_subplot_kw or {}
1938 
1939         if height_ratios is not None:
1940             if 'height_ratios' in gridspec_kw:
1941                 raise ValueError("'height_ratios' must not be defined both as "
1942                                  "parameter and as key in 'gridspec_kw'")
1943             gridspec_kw['height_ratios'] = height_ratios
1944         if width_ratios is not None:
1945             if 'width_ratios' in gridspec_kw:
1946                 raise ValueError("'width_ratios' must not be defined both as "
1947                                  "parameter and as key in 'gridspec_kw'")
1948             gridspec_kw['width_ratios'] = width_ratios
1949 
1950         # special-case string input
1951         if isinstance(mosaic, str):
1952             mosaic = self._normalize_grid_string(mosaic)
1953             per_subplot_kw = {
1954                 tuple(k): v for k, v in per_subplot_kw.items()
1955             }
1956 
1957         per_subplot_kw = self._norm_per_subplot_kw(per_subplot_kw)
1958 
1959         # Only accept strict bools to allow a possible future API expansion.
1960         _api.check_isinstance(bool, sharex=sharex, sharey=sharey)
1961 
1962         def _make_array(inp):
1963             """
1964             Convert input into 2D array
1965 
1966             We need to have this internal function rather than
1967             ``np.asarray(..., dtype=object)`` so that a list of lists
1968             of lists does not get converted to an array of dimension > 2.
1969 
1970             Returns
1971             -------
1972             2D object array
1973             """
1974             r0, *rest = inp
1975             if isinstance(r0, str):
1976                 raise ValueError('List mosaic specification must be 2D')
1977             for j, r in enumerate(rest, start=1):
1978                 if isinstance(r, str):
1979                     raise ValueError('List mosaic specification must be 2D')
1980                 if len(r0) != len(r):
1981                     raise ValueError(
1982                         "All of the rows must be the same length, however "
1983                         f"the first row ({r0!r}) has length {len(r0)} "
1984                         f"and row {j} ({r!r}) has length {len(r)}."
1985                     )
1986             out = np.zeros((len(inp), len(r0)), dtype=object)
1987             for j, r in enumerate(inp):
1988                 for k, v in enumerate(r):
1989                     out[j, k] = v
1990             return out
1991 
1992         def _identify_keys_and_nested(mosaic):
1993             """
1994             Given a 2D object array, identify unique IDs and nested mosaics
1995 
1996             Parameters
1997             ----------
1998             mosaic : 2D object array
1999 
2000             Returns
2001             -------
2002             unique_ids : tuple
2003                 The unique non-sub mosaic entries in this mosaic
2004             nested : dict[tuple[int, int], 2D object array]
2005             """
2006             # make sure we preserve the user supplied order
2007             unique_ids = cbook._OrderedSet()
2008             nested = {}
2009             for j, row in enumerate(mosaic):
2010                 for k, v in enumerate(row):
2011                     if v == empty_sentinel:
2012                         continue
2013                     elif not cbook.is_scalar_or_string(v):
2014                         nested[(j, k)] = _make_array(v)
2015                     else:
2016                         unique_ids.add(v)
2017 
2018             return tuple(unique_ids), nested
2019 
2020         def _do_layout(gs, mosaic, unique_ids, nested):
2021             """
2022             Recursively do the mosaic.
2023 
2024             Parameters
2025             ----------
2026             gs : GridSpec
2027             mosaic : 2D object array
2028                 The input converted to a 2D array for this level.
2029             unique_ids : tuple
2030                 The identified scalar labels at this level of nesting.
2031             nested : dict[tuple[int, int]], 2D object array
2032                 The identified nested mosaics, if any.
2033 
2034             Returns
2035             -------
2036             dict[label, Axes]
2037                 A flat dict of all of the Axes created.
2038             """
2039             output = dict()
2040 
2041             # we need to merge together the Axes at this level and the axes
2042             # in the (recursively) nested sub-mosaics so that we can add
2043             # them to the figure in the "natural" order if you were to
2044             # ravel in c-order all of the Axes that will be created
2045             #
2046             # This will stash the upper left index of each object (axes or
2047             # nested mosaic) at this level
2048             this_level = dict()
2049 
2050             # go through the unique keys,
2051             for name in unique_ids:
2052                 # sort out where each axes starts/ends
2053                 indx = np.argwhere(mosaic == name)
2054                 start_row, start_col = np.min(indx, axis=0)
2055                 end_row, end_col = np.max(indx, axis=0) + 1
2056                 # and construct the slice object
2057                 slc = (slice(start_row, end_row), slice(start_col, end_col))
2058                 # some light error checking
2059                 if (mosaic[slc] != name).any():
2060                     raise ValueError(
2061                         f"While trying to layout\n{mosaic!r}\n"
2062                         f"we found that the label {name!r} specifies a "
2063                         "non-rectangular or non-contiguous area.")
2064                 # and stash this slice for later
2065                 this_level[(start_row, start_col)] = (name, slc, 'axes')
2066 
2067             # do the same thing for the nested mosaics (simpler because these
2068             # cannot be spans yet!)
2069             for (j, k), nested_mosaic in nested.items():
2070                 this_level[(j, k)] = (None, nested_mosaic, 'nested')
2071 
2072             # now go through the things in this level and add them
2073             # in order left-to-right top-to-bottom
2074             for key in sorted(this_level):
2075                 name, arg, method = this_level[key]
2076                 # we are doing some hokey function dispatch here based
2077                 # on the 'method' string stashed above to sort out if this
2078                 # element is an Axes or a nested mosaic.
2079                 if method == 'axes':
2080                     slc = arg
2081                     # add a single axes
2082                     if name in output:
2083                         raise ValueError(f"There are duplicate keys {name} "
2084                                          f"in the layout\n{mosaic!r}")
2085                     ax = self.add_subplot(
2086                         gs[slc], **{
2087                             'label': str(name),
2088                             **subplot_kw,
2089                             **per_subplot_kw.get(name, {})
2090                         }
2091                     )
2092                     output[name] = ax
2093                 elif method == 'nested':
2094                     nested_mosaic = arg
2095                     j, k = key
2096                     # recursively add the nested mosaic
2097                     rows, cols = nested_mosaic.shape
2098                     nested_output = _do_layout(
2099                         gs[j, k].subgridspec(rows, cols),
2100                         nested_mosaic,
2101                         *_identify_keys_and_nested(nested_mosaic)
2102                     )
2103                     overlap = set(output) & set(nested_output)
2104                     if overlap:
2105                         raise ValueError(
2106                             f"There are duplicate keys {overlap} "
2107                             f"between the outer layout\n{mosaic!r}\n"
2108                             f"and the nested layout\n{nested_mosaic}"
2109                         )
2110                     output.update(nested_output)
2111                 else:
2112                     raise RuntimeError("This should never happen")
2113             return output
2114 
2115         mosaic = _make_array(mosaic)
2116         rows, cols = mosaic.shape
2117         gs = self.add_gridspec(rows, cols, **gridspec_kw)
2118         ret = _do_layout(gs, mosaic, *_identify_keys_and_nested(mosaic))
2119         ax0 = next(iter(ret.values()))
2120         for ax in ret.values():
2121             if sharex:
2122                 ax.sharex(ax0)
2123                 ax._label_outer_xaxis(check_patch=True)
2124             if sharey:
2125                 ax.sharey(ax0)
2126                 ax._label_outer_yaxis(check_patch=True)
2127         if extra := set(per_subplot_kw) - set(ret):
2128             raise ValueError(
2129                 f"The keys {extra} are in *per_subplot_kw* "
2130                 "but not in the mosaic."
2131             )
2132         return ret
2133 
2134     def _set_artist_props(self, a):
2135         if a != self:
2136             a.set_figure(self)
2137         a.stale_callback = _stale_figure_callback
2138         a.set_transform(self.transSubfigure)

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>]
2025-10-15 07:45:33.796 | INFO     | Search completed. Bug locations: [<file>lib/matplotlib/figure.py</file>
<class>FigureBase</class>
<method>subfigures</method>
<code>
1545     def subfigures(self, nrows=1, ncols=1, squeeze=True,
1546                    wspace=None, hspace=None,
1547                    width_ratios=None, height_ratios=None,
1548                    **kwargs):
1549         """
1550         Add a set of subfigures to this figure or subfigure.
1551 
1552         A subfigure has the same artist methods as a figure, and is logically
1553         the same as a figure, but cannot print itself.
1554         See :doc:`/gallery/subplots_axes_and_figures/subfigures`.
1555 
1556         .. note::
1557             The *subfigure* concept is new in v3.4, and the API is still provisional.
1558 
1559         Parameters
1560         ----------
1561         nrows, ncols : int, default: 1
1562             Number of rows/columns of the subfigure grid.
1563 
1564         squeeze : bool, default: True
1565             If True, extra dimensions are squeezed out from the returned
1566             array of subfigures.
1567 
1568         wspace, hspace : float, default: None
1569             The amount of width/height reserved for space between subfigures,
1570             expressed as a fraction of the average subfigure width/height.
1571             If not given, the values will be inferred from a figure or
1572             rcParams when necessary.
1573 
1574         width_ratios : array-like of length *ncols*, optional
1575             Defines the relative widths of the columns. Each column gets a
1576             relative width of ``width_ratios[i] / sum(width_ratios)``.
1577             If not given, all columns will have the same width.
1578 
1579         height_ratios : array-like of length *nrows*, optional
1580             Defines the relative heights of the rows. Each row gets a
1581             relative height of ``height_ratios[i] / sum(height_ratios)``.
1582             If not given, all rows will have the same height.
1583         """
1584         gs = GridSpec(nrows=nrows, ncols=ncols, figure=self,
1585                       wspace=wspace, hspace=hspace,
1586                       width_ratios=width_ratios,
1587                       height_ratios=height_ratios)
1588 
1589         sfarr = np.empty((nrows, ncols), dtype=object)
1590         for i in range(ncols):
1591             for j in range(nrows):
1592                 sfarr[j, i] = self.add_subfigure(gs[j, i], **kwargs)
1593 
1594         if squeeze:
1595             # Discarding unneeded dimensions that equal 1.  If we only have one
1596             # subfigure, just return it instead of a 1-element array.
1597             return sfarr.item() if sfarr.size == 1 else sfarr.squeeze()
1598         else:
1599             # Returned axis array will be always 2-d, even if nrows=ncols=1.
1600             return sfarr

</code><intended_behavior>The implementation of `subfigures` should correctly apply `wspace` and `hspace` parameters to adjust the horizontal and vertical spacing between subfigures. Specifically, when a user specifies these parameters, the layout of subfigures created by this method should visually reflect the specified spacings. This necessitates a check that these parameters are not merely accepted but actively influence the layout properties of the resulting subfigures. Any functionality to calculate or adjust layout spacing based on `wspace` and `hspace` needs to ensure these parameters contribute to the final layout calculation process. This behavior would not only resolve the reported issue but also enhance user control over figure layouts in matplotlib, maintaining the library's flexibility and utility for complex visualizations.</intended_behavior>, <file>lib/matplotlib/figure.py</file>
<class>FigureBase</class>
<method>None</method>
<code>
180 class FigureBase(Artist):
181     """
182     Base class for `.Figure` and `.SubFigure` containing the methods that add
183     artists to the figure or subfigure, create Axes, etc.
184     """
185     def __init__(self, **kwargs):
186         super().__init__()
187         # remove the non-figure artist _axes property
188         # as it makes no sense for a figure to be _in_ an Axes
189         # this is used by the property methods in the artist base class
190         # which are over-ridden in this class
191         del self._axes
192 
193         self._suptitle = None
194         self._supxlabel = None
195         self._supylabel = None
196 
197         # groupers to keep track of x and y labels we want to align.
198         # see self.align_xlabels and self.align_ylabels and
199         # axis._get_tick_boxes_siblings
200         self._align_label_groups = {"x": cbook.Grouper(), "y": cbook.Grouper()}
201 
202         self._localaxes = []  # track all axes
203         self.artists = []
204         self.lines = []
205         self.patches = []
206         self.texts = []
207         self.images = []
208         self.legends = []
209         self.subfigs = []
210         self.stale = True
211         self.suppressComposite = None
212         self.set(**kwargs)
213 
214     def _get_draw_artists(self, renderer):
215         """Also runs apply_aspect"""
216         artists = self.get_children()
217         for sfig in self.subfigs:
218             artists.remove(sfig)
219             childa = sfig.get_children()
220             for child in childa:
221                 if child in artists:
222                     artists.remove(child)
223 
224         artists.remove(self.patch)
225         artists = sorted(
226             (artist for artist in artists if not artist.get_animated()),
227             key=lambda artist: artist.get_zorder())
228         for ax in self._localaxes:
229             locator = ax.get_axes_locator()
230             ax.apply_aspect(locator(ax, renderer) if locator else None)
231 
232             for child in ax.get_children():
233                 if hasattr(child, 'apply_aspect'):
234                     locator = child.get_axes_locator()
235                     child.apply_aspect(
236                         locator(child, renderer) if locator else None)
237         return artists
238 
239     def autofmt_xdate(
240             self, bottom=0.2, rotation=30, ha='right', which='major'):
241         """
242         Date ticklabels often overlap, so it is useful to rotate them
243         and right align them.  Also, a common use case is a number of
244         subplots with shared x-axis where the x-axis is date data.  The
245         ticklabels are often long, and it helps to rotate them on the
246         bottom subplot and turn them off on other subplots, as well as
247         turn off xlabels.
248 
249         Parameters
250         ----------
251         bottom : float, default: 0.2
252             The bottom of the subplots for `subplots_adjust`.
253         rotation : float, default: 30 degrees
254             The rotation angle of the xtick labels in degrees.
255         ha : {'left', 'center', 'right'}, default: 'right'
256             The horizontal alignment of the xticklabels.
257         which : {'major', 'minor', 'both'}, default: 'major'
258             Selects which ticklabels to rotate.
259         """
260         _api.check_in_list(['major', 'minor', 'both'], which=which)
261         allsubplots = all(ax.get_subplotspec() for ax in self.axes)
262         if len(self.axes) == 1:
263             for label in self.axes[0].get_xticklabels(which=which):
264                 label.set_ha(ha)
265                 label.set_rotation(rotation)
266         else:
267             if allsubplots:
268                 for ax in self.get_axes():
269                     if ax.get_subplotspec().is_last_row():
270                         for label in ax.get_xticklabels(which=which):
271                             label.set_ha(ha)
272                             label.set_rotation(rotation)
273                     else:
274                         for label in ax.get_xticklabels(which=which):
275                             label.set_visible(False)
276                         ax.set_xlabel('')
277 
278         if allsubplots:
279             self.subplots_adjust(bottom=bottom)
280         self.stale = True
281 
282     def get_children(self):
283         """Get a list of artists contained in the figure."""
284         return [self.patch,
285                 *self.artists,
286                 *self._localaxes,
287                 *self.lines,
288                 *self.patches,
289                 *self.texts,
290                 *self.images,
291                 *self.legends,
292                 *self.subfigs]
293 
294     def contains(self, mouseevent):
295         """
296         Test whether the mouse event occurred on the figure.
297 
298         Returns
299         -------
300             bool, {}
301         """
302         if self._different_canvas(mouseevent):
303             return False, {}
304         inside = self.bbox.contains(mouseevent.x, mouseevent.y)
305         return inside, {}
306 
307     def get_window_extent(self, renderer=None):
308         # docstring inherited
309         return self.bbox
310 
311     def _suplabels(self, t, info, **kwargs):
312         """
313         Add a centered %(name)s to the figure.
314 
315         Parameters
316         ----------
317         t : str
318             The %(name)s text.
319         x : float, default: %(x0)s
320             The x location of the text in figure coordinates.
321         y : float, default: %(y0)s
322             The y location of the text in figure coordinates.
323         horizontalalignment, ha : {'center', 'left', 'right'}, default: %(ha)s
324             The horizontal alignment of the text relative to (*x*, *y*).
325         verticalalignment, va : {'top', 'center', 'bottom', 'baseline'}, \
326 default: %(va)s
327             The vertical alignment of the text relative to (*x*, *y*).
328         fontsize, size : default: :rc:`figure.%(rc)ssize`
329             The font size of the text. See `.Text.set_size` for possible
330             values.
331         fontweight, weight : default: :rc:`figure.%(rc)sweight`
332             The font weight of the text. See `.Text.set_weight` for possible
333             values.
334 
335         Returns
336         -------
337         text
338             The `.Text` instance of the %(name)s.
339 
340         Other Parameters
341         ----------------
342         fontproperties : None or dict, optional
343             A dict of font properties. If *fontproperties* is given the
344             default values for font size and weight are taken from the
345             `.FontProperties` defaults. :rc:`figure.%(rc)ssize` and
346             :rc:`figure.%(rc)sweight` are ignored in this case.
347 
348         **kwargs
349             Additional kwargs are `matplotlib.text.Text` properties.
350         """
351 
352         suplab = getattr(self, info['name'])
353 
354         x = kwargs.pop('x', None)
355         y = kwargs.pop('y', None)
356         if info['name'] in ['_supxlabel', '_suptitle']:
357             autopos = y is None
358         elif info['name'] == '_supylabel':
359             autopos = x is None
360         if x is None:
361             x = info['x0']
362         if y is None:
363             y = info['y0']
364 
365         if 'horizontalalignment' not in kwargs and 'ha' not in kwargs:
366             kwargs['horizontalalignment'] = info['ha']
367         if 'verticalalignment' not in kwargs and 'va' not in kwargs:
368             kwargs['verticalalignment'] = info['va']
369         if 'rotation' not in kwargs:
370             kwargs['rotation'] = info['rotation']
371 
372         if 'fontproperties' not in kwargs:
373             if 'fontsize' not in kwargs and 'size' not in kwargs:
374                 kwargs['size'] = mpl.rcParams[info['size']]
375             if 'fontweight' not in kwargs and 'weight' not in kwargs:
376                 kwargs['weight'] = mpl.rcParams[info['weight']]
377 
378         sup = self.text(x, y, t, **kwargs)
379         if suplab is not None:
380             suplab.set_text(t)
381             suplab.set_position((x, y))
382             suplab.update_from(sup)
383             sup.remove()
384         else:
385             suplab = sup
386         suplab._autopos = autopos
387         setattr(self, info['name'], suplab)
388         self.stale = True
389         return suplab
390 
391     @_docstring.Substitution(x0=0.5, y0=0.98, name='suptitle', ha='center',
392                              va='top', rc='title')
393     @_docstring.copy(_suplabels)
394     def suptitle(self, t, **kwargs):
395         # docstring from _suplabels...
396         info = {'name': '_suptitle', 'x0': 0.5, 'y0': 0.98,
397                 'ha': 'center', 'va': 'top', 'rotation': 0,
398                 'size': 'figure.titlesize', 'weight': 'figure.titleweight'}
399         return self._suplabels(t, info, **kwargs)
400 
401     def get_suptitle(self):
402         """Return the suptitle as string or an empty string if not set."""
403         text_obj = self._suptitle
404         return "" if text_obj is None else text_obj.get_text()
405 
406     @_docstring.Substitution(x0=0.5, y0=0.01, name='supxlabel', ha='center',
407                              va='bottom', rc='label')
408     @_docstring.copy(_suplabels)
409     def supxlabel(self, t, **kwargs):
410         # docstring from _suplabels...
411         info = {'name': '_supxlabel', 'x0': 0.5, 'y0': 0.01,
412                 'ha': 'center', 'va': 'bottom', 'rotation': 0,
413                 'size': 'figure.labelsize', 'weight': 'figure.labelweight'}
414         return self._suplabels(t, info, **kwargs)
415 
416     def get_supxlabel(self):
417         """Return the supxlabel as string or an empty string if not set."""
418         text_obj = self._supxlabel
419         return "" if text_obj is None else text_obj.get_text()
420 
421     @_docstring.Substitution(x0=0.02, y0=0.5, name='supylabel', ha='left',
422                              va='center', rc='label')
423     @_docstring.copy(_suplabels)
424     def supylabel(self, t, **kwargs):
425         # docstring from _suplabels...
426         info = {'name': '_supylabel', 'x0': 0.02, 'y0': 0.5,
427                 'ha': 'left', 'va': 'center', 'rotation': 'vertical',
428                 'rotation_mode': 'anchor', 'size': 'figure.labelsize',
429                 'weight': 'figure.labelweight'}
430         return self._suplabels(t, info, **kwargs)
431 
432     def get_supylabel(self):
433         """Return the supylabel as string or an empty string if not set."""
434         text_obj = self._supylabel
435         return "" if text_obj is None else text_obj.get_text()
436 
437     def get_edgecolor(self):
438         """Get the edge color of the Figure rectangle."""
439         return self.patch.get_edgecolor()
440 
441     def get_facecolor(self):
442         """Get the face color of the Figure rectangle."""
443         return self.patch.get_facecolor()
444 
445     def get_frameon(self):
446         """
447         Return the figure's background patch visibility, i.e.
448         whether the figure background will be drawn. Equivalent to
449         ``Figure.patch.get_visible()``.
450         """
451         return self.patch.get_visible()
452 
453     def set_linewidth(self, linewidth):
454         """
455         Set the line width of the Figure rectangle.
456 
457         Parameters
458         ----------
459         linewidth : number
460         """
461         self.patch.set_linewidth(linewidth)
462 
463     def get_linewidth(self):
464         """
465         Get the line width of the Figure rectangle.
466         """
467         return self.patch.get_linewidth()
468 
469     def set_edgecolor(self, color):
470         """
471         Set the edge color of the Figure rectangle.
472 
473         Parameters
474         ----------
475         color : color
476         """
477         self.patch.set_edgecolor(color)
478 
479     def set_facecolor(self, color):
480         """
481         Set the face color of the Figure rectangle.
482 
483         Parameters
484         ----------
485         color : color
486         """
487         self.patch.set_facecolor(color)
488 
489     def set_frameon(self, b):
490         """
491         Set the figure's background patch visibility, i.e.
492         whether the figure background will be drawn. Equivalent to
493         ``Figure.patch.set_visible()``.
494 
495         Parameters
496         ----------
497         b : bool
498         """
499         self.patch.set_visible(b)
500         self.stale = True
501 
502     frameon = property(get_frameon, set_frameon)
503 
504     def add_artist(self, artist, clip=False):
505         """
506         Add an `.Artist` to the figure.
507 
508         Usually artists are added to `~.axes.Axes` objects using
509         `.Axes.add_artist`; this method can be used in the rare cases where
510         one needs to add artists directly to the figure instead.
511 
512         Parameters
513         ----------
514         artist : `~matplotlib.artist.Artist`
515             The artist to add to the figure. If the added artist has no
516             transform previously set, its transform will be set to
517             ``figure.transSubfigure``.
518         clip : bool, default: False
519             Whether the added artist should be clipped by the figure patch.
520 
521         Returns
522         -------
523         `~matplotlib.artist.Artist`
524             The added artist.
525         """
526         artist.set_figure(self)
527         self.artists.append(artist)
528         artist._remove_method = self.artists.remove
529 
530         if not artist.is_transform_set():
531             artist.set_transform(self.transSubfigure)
532 
533         if clip and artist.get_clip_path() is None:
534             artist.set_clip_path(self.patch)
535 
536         self.stale = True
537         return artist
538 
539     @_docstring.dedent_interpd
540     def add_axes(self, *args, **kwargs):
541         """
542         Add an `~.axes.Axes` to the figure.
543 
544         Call signatures::
545 
546             add_axes(rect, projection=None, polar=False, **kwargs)
547             add_axes(ax)
548 
549         Parameters
550         ----------
551         rect : tuple (left, bottom, width, height)
552             The dimensions (left, bottom, width, height) of the new
553             `~.axes.Axes`. All quantities are in fractions of figure width and
554             height.
555 
556         projection : {None, 'aitoff', 'hammer', 'lambert', 'mollweide', \
557 'polar', 'rectilinear', str}, optional
558             The projection type of the `~.axes.Axes`. *str* is the name of
559             a custom projection, see `~matplotlib.projections`. The default
560             None results in a 'rectilinear' projection.
561 
562         polar : bool, default: False
563             If True, equivalent to projection='polar'.
564 
565         axes_class : subclass type of `~.axes.Axes`, optional
566             The `.axes.Axes` subclass that is instantiated.  This parameter
567             is incompatible with *projection* and *polar*.  See
568             :ref:`axisartist_users-guide-index` for examples.
569 
570         sharex, sharey : `~.axes.Axes`, optional
571             Share the x or y `~matplotlib.axis` with sharex and/or sharey.
572             The axis will have the same limits, ticks, and scale as the axis
573             of the shared axes.
574 
575         label : str
576             A label for the returned Axes.
577 
578         Returns
579         -------
580         `~.axes.Axes`, or a subclass of `~.axes.Axes`
581             The returned axes class depends on the projection used. It is
582             `~.axes.Axes` if rectilinear projection is used and
583             `.projections.polar.PolarAxes` if polar projection is used.
584 
585         Other Parameters
586         ----------------
587         **kwargs
588             This method also takes the keyword arguments for
589             the returned Axes class. The keyword arguments for the
590             rectilinear Axes class `~.axes.Axes` can be found in
591             the following table but there might also be other keyword
592             arguments if another projection is used, see the actual Axes
593             class.
594 
595             %(Axes:kwdoc)s
596 
597         Notes
598         -----
599         In rare circumstances, `.add_axes` may be called with a single
600         argument, an Axes instance already created in the present figure but
601         not in the figure's list of Axes.
602 
603         See Also
604         --------
605         .Figure.add_subplot
606         .pyplot.subplot
607         .pyplot.axes
608         .Figure.subplots
609         .pyplot.subplots
610 
611         Examples
612         --------
613         Some simple examples::
614 
615             rect = l, b, w, h
616             fig = plt.figure()
617             fig.add_axes(rect)
618             fig.add_axes(rect, frameon=False, facecolor='g')
619             fig.add_axes(rect, polar=True)
620             ax = fig.add_axes(rect, projection='polar')
621             fig.delaxes(ax)
622             fig.add_axes(ax)
623         """
624 
625         if not len(args) and 'rect' not in kwargs:
626             raise TypeError(
627                 "add_axes() missing 1 required positional argument: 'rect'")
628         elif 'rect' in kwargs:
629             if len(args):
630                 raise TypeError(
631                     "add_axes() got multiple values for argument 'rect'")
632             args = (kwargs.pop('rect'), )
633 
634         if isinstance(args[0], Axes):
635             a, *extra_args = args
636             key = a._projection_init
637             if a.get_figure() is not self:
638                 raise ValueError(
639                     "The Axes must have been created in the present figure")
640         else:
641             rect, *extra_args = args
642             if not np.isfinite(rect).all():
643                 raise ValueError(f'all entries in rect must be finite not {rect}')
644             projection_class, pkw = self._process_projection_requirements(**kwargs)
645 
646             # create the new axes using the axes class given
647             a = projection_class(self, rect, **pkw)
648             key = (projection_class, pkw)
649 
650         if extra_args:
651             _api.warn_deprecated(
652                 "3.8",
653                 name="Passing more than one positional argument to Figure.add_axes",
654                 addendum="Any additional positional arguments are currently ignored.")
655         return self._add_axes_internal(a, key)
656 
657     @_docstring.dedent_interpd
658     def add_subplot(self, *args, **kwargs):
659         """
660         Add an `~.axes.Axes` to the figure as part of a subplot arrangement.
661 
662         Call signatures::
663 
664            add_subplot(nrows, ncols, index, **kwargs)
665            add_subplot(pos, **kwargs)
666            add_subplot(ax)
667            add_subplot()
668 
669         Parameters
670         ----------
671         *args : int, (int, int, *index*), or `.SubplotSpec`, default: (1, 1, 1)
672             The position of the subplot described by one of
673 
674             - Three integers (*nrows*, *ncols*, *index*). The subplot will
675               take the *index* position on a grid with *nrows* rows and
676               *ncols* columns. *index* starts at 1 in the upper left corner
677               and increases to the right.  *index* can also be a two-tuple
678               specifying the (*first*, *last*) indices (1-based, and including
679               *last*) of the subplot, e.g., ``fig.add_subplot(3, 1, (1, 2))``
680               makes a subplot that spans the upper 2/3 of the figure.
681             - A 3-digit integer. The digits are interpreted as if given
682               separately as three single-digit integers, i.e.
683               ``fig.add_subplot(235)`` is the same as
684               ``fig.add_subplot(2, 3, 5)``. Note that this can only be used
685               if there are no more than 9 subplots.
686             - A `.SubplotSpec`.
687 
688             In rare circumstances, `.add_subplot` may be called with a single
689             argument, a subplot Axes instance already created in the
690             present figure but not in the figure's list of Axes.
691 
692         projection : {None, 'aitoff', 'hammer', 'lambert', 'mollweide', \
693 'polar', 'rectilinear', str}, optional
694             The projection type of the subplot (`~.axes.Axes`). *str* is the
695             name of a custom projection, see `~matplotlib.projections`. The
696             default None results in a 'rectilinear' projection.
697 
698         polar : bool, default: False
699             If True, equivalent to projection='polar'.
700 
701         axes_class : subclass type of `~.axes.Axes`, optional
702             The `.axes.Axes` subclass that is instantiated.  This parameter
703             is incompatible with *projection* and *polar*.  See
704             :ref:`axisartist_users-guide-index` for examples.
705 
706         sharex, sharey : `~.axes.Axes`, optional
707             Share the x or y `~matplotlib.axis` with sharex and/or sharey.
708             The axis will have the same limits, ticks, and scale as the axis
709             of the shared axes.
710 
711         label : str
712             A label for the returned Axes.
713 
714         Returns
715         -------
716         `~.axes.Axes`
717 
718             The Axes of the subplot. The returned Axes can actually be an
719             instance of a subclass, such as `.projections.polar.PolarAxes` for
720             polar projections.
721 
722         Other Parameters
723         ----------------
724         **kwargs
725             This method also takes the keyword arguments for the returned Axes
726             base class; except for the *figure* argument. The keyword arguments
727             for the rectilinear base class `~.axes.Axes` can be found in
728             the following table but there might also be other keyword
729             arguments if another projection is used.
730 
731             %(Axes:kwdoc)s
732 
733         See Also
734         --------
735         .Figure.add_axes
736         .pyplot.subplot
737         .pyplot.axes
738         .Figure.subplots
739         .pyplot.subplots
740 
741         Examples
742         --------
743         ::
744 
745             fig = plt.figure()
746 
747             fig.add_subplot(231)
748             ax1 = fig.add_subplot(2, 3, 1)  # equivalent but more general
749 
750             fig.add_subplot(232, frameon=False)  # subplot with no frame
751             fig.add_subplot(233, projection='polar')  # polar subplot
752             fig.add_subplot(234, sharex=ax1)  # subplot sharing x-axis with ax1
753             fig.add_subplot(235, facecolor="red")  # red subplot
754 
755             ax1.remove()  # delete ax1 from the figure
756             fig.add_subplot(ax1)  # add ax1 back to the figure
757         """
758         if 'figure' in kwargs:
759             # Axes itself allows for a 'figure' kwarg, but since we want to
760             # bind the created Axes to self, it is not allowed here.
761             raise _api.kwarg_error("add_subplot", "figure")
762 
763         if (len(args) == 1
764                 and isinstance(args[0], mpl.axes._base._AxesBase)
765                 and args[0].get_subplotspec()):
766             ax = args[0]
767             key = ax._projection_init
768             if ax.get_figure() is not self:
769                 raise ValueError("The Axes must have been created in "
770                                  "the present figure")
771         else:
772             if not args:
773                 args = (1, 1, 1)
774             # Normalize correct ijk values to (i, j, k) here so that
775             # add_subplot(211) == add_subplot(2, 1, 1).  Invalid values will
776             # trigger errors later (via SubplotSpec._from_subplot_args).
777             if (len(args) == 1 and isinstance(args[0], Integral)
778                     and 100 <= args[0] <= 999):
779                 args = tuple(map(int, str(args[0])))
780             projection_class, pkw = self._process_projection_requirements(**kwargs)
781             ax = projection_class(self, *args, **pkw)
782             key = (projection_class, pkw)
783         return self._add_axes_internal(ax, key)
784 
785     def _add_axes_internal(self, ax, key):
786         """Private helper for `add_axes` and `add_subplot`."""
787         self._axstack.add(ax)
788         if ax not in self._localaxes:
789             self._localaxes.append(ax)
790         self.sca(ax)
791         ax._remove_method = self.delaxes
792         # this is to support plt.subplot's re-selection logic
793         ax._projection_init = key
794         self.stale = True
795         ax.stale_callback = _stale_figure_callback
796         return ax
797 
798     def subplots(self, nrows=1, ncols=1, *, sharex=False, sharey=False,
799                  squeeze=True, width_ratios=None, height_ratios=None,
800                  subplot_kw=None, gridspec_kw=None):
801         """
802         Add a set of subplots to this figure.
803 
804         This utility wrapper makes it convenient to create common layouts of
805         subplots in a single call.
806 
807         Parameters
808         ----------
809         nrows, ncols : int, default: 1
810             Number of rows/columns of the subplot grid.
811 
812         sharex, sharey : bool or {'none', 'all', 'row', 'col'}, default: False
813             Controls sharing of x-axis (*sharex*) or y-axis (*sharey*):
814 
815             - True or 'all': x- or y-axis will be shared among all subplots.
816             - False or 'none': each subplot x- or y-axis will be independent.
817             - 'row': each subplot row will share an x- or y-axis.
818             - 'col': each subplot column will share an x- or y-axis.
819 
820             When subplots have a shared x-axis along a column, only the x tick
821             labels of the bottom subplot are created. Similarly, when subplots
822             have a shared y-axis along a row, only the y tick labels of the
823             first column subplot are created. To later turn other subplots'
824             ticklabels on, use `~matplotlib.axes.Axes.tick_params`.
825 
826             When subplots have a shared axis that has units, calling
827             `.Axis.set_units` will update each axis with the new units.
828 
829         squeeze : bool, default: True
830             - If True, extra dimensions are squeezed out from the returned
831               array of Axes:
832 
833               - if only one subplot is constructed (nrows=ncols=1), the
834                 resulting single Axes object is returned as a scalar.
835               - for Nx1 or 1xM subplots, the returned object is a 1D numpy
836                 object array of Axes objects.
837               - for NxM, subplots with N>1 and M>1 are returned as a 2D array.
838 
839             - If False, no squeezing at all is done: the returned Axes object
840               is always a 2D array containing Axes instances, even if it ends
841               up being 1x1.
842 
843         width_ratios : array-like of length *ncols*, optional
844             Defines the relative widths of the columns. Each column gets a
845             relative width of ``width_ratios[i] / sum(width_ratios)``.
846             If not given, all columns will have the same width.  Equivalent
847             to ``gridspec_kw={'width_ratios': [...]}``.
848 
849         height_ratios : array-like of length *nrows*, optional
850             Defines the relative heights of the rows. Each row gets a
851             relative height of ``height_ratios[i] / sum(height_ratios)``.
852             If not given, all rows will have the same height. Equivalent
853             to ``gridspec_kw={'height_ratios': [...]}``.
854 
855         subplot_kw : dict, optional
856             Dict with keywords passed to the `.Figure.add_subplot` call used to
857             create each subplot.
858 
859         gridspec_kw : dict, optional
860             Dict with keywords passed to the
861             `~matplotlib.gridspec.GridSpec` constructor used to create
862             the grid the subplots are placed on.
863 
864         Returns
865         -------
866         `~.axes.Axes` or array of Axes
867             Either a single `~matplotlib.axes.Axes` object or an array of Axes
868             objects if more than one subplot was created. The dimensions of the
869             resulting array can be controlled with the *squeeze* keyword, see
870             above.
871 
872         See Also
873         --------
874         .pyplot.subplots
875         .Figure.add_subplot
876         .pyplot.subplot
877 
878         Examples
879         --------
880         ::
881 
882             # First create some toy data:
883             x = np.linspace(0, 2*np.pi, 400)
884             y = np.sin(x**2)
885 
886             # Create a figure
887             fig = plt.figure()
888 
889             # Create a subplot
890             ax = fig.subplots()
891             ax.plot(x, y)
892             ax.set_title('Simple plot')
893 
894             # Create two subplots and unpack the output array immediately
895             ax1, ax2 = fig.subplots(1, 2, sharey=True)
896             ax1.plot(x, y)
897             ax1.set_title('Sharing Y axis')
898             ax2.scatter(x, y)
899 
900             # Create four polar Axes and access them through the returned array
901             axes = fig.subplots(2, 2, subplot_kw=dict(projection='polar'))
902             axes[0, 0].plot(x, y)
903             axes[1, 1].scatter(x, y)
904 
905             # Share an X-axis with each column of subplots
906             fig.subplots(2, 2, sharex='col')
907 
908             # Share a Y-axis with each row of subplots
909             fig.subplots(2, 2, sharey='row')
910 
911             # Share both X- and Y-axes with all subplots
912             fig.subplots(2, 2, sharex='all', sharey='all')
913 
914             # Note that this is the same as
915             fig.subplots(2, 2, sharex=True, sharey=True)
916         """
917         gridspec_kw = dict(gridspec_kw or {})
918         if height_ratios is not None:
919             if 'height_ratios' in gridspec_kw:
920                 raise ValueError("'height_ratios' must not be defined both as "
921                                  "parameter and as key in 'gridspec_kw'")
922             gridspec_kw['height_ratios'] = height_ratios
923         if width_ratios is not None:
924             if 'width_ratios' in gridspec_kw:
925                 raise ValueError("'width_ratios' must not be defined both as "
926                                  "parameter and as key in 'gridspec_kw'")
927             gridspec_kw['width_ratios'] = width_ratios
928 
929         gs = self.add_gridspec(nrows, ncols, figure=self, **gridspec_kw)
930         axs = gs.subplots(sharex=sharex, sharey=sharey, squeeze=squeeze,
931                           subplot_kw=subplot_kw)
932         return axs
933 
934     def delaxes(self, ax):
935         """
936         Remove the `~.axes.Axes` *ax* from the figure; update the current Axes.
937         """
938 
939         self._axstack.remove(ax)
940         self._axobservers.process("_axes_change_event", self)
941         self.stale = True
942         self._localaxes.remove(ax)
943         self.canvas.release_mouse(ax)
944 
945         for name in ax._axis_names:  # Break link between any shared axes
946             grouper = ax._shared_axes[name]
947             siblings = [other for other in grouper.get_siblings(ax) if other is not ax]
948             if not siblings:  # Axes was not shared along this axis; we're done.
949                 continue
950             grouper.remove(ax)
951             # Formatters and locators may previously have been associated with the now
952             # removed axis.  Update them to point to an axis still there (we can pick
953             # any of them, and use the first sibling).
954             remaining_axis = siblings[0]._axis_map[name]
955             remaining_axis.get_major_formatter().set_axis(remaining_axis)
956             remaining_axis.get_major_locator().set_axis(remaining_axis)
957             remaining_axis.get_minor_formatter().set_axis(remaining_axis)
958             remaining_axis.get_minor_locator().set_axis(remaining_axis)
959 
960         ax._twinned_axes.remove(ax)  # Break link between any twinned axes.
961 
962     def clear(self, keep_observers=False):
963         """
964         Clear the figure.
965 
966         Parameters
967         ----------
968         keep_observers : bool, default: False
969             Set *keep_observers* to True if, for example,
970             a gui widget is tracking the Axes in the figure.
971         """
972         self.suppressComposite = None
973 
974         # first clear the axes in any subfigures
975         for subfig in self.subfigs:
976             subfig.clear(keep_observers=keep_observers)
977         self.subfigs = []
978 
979         for ax in tuple(self.axes):  # Iterate over the copy.
980             ax.clear()
981             self.delaxes(ax)  # Remove ax from self._axstack.
982 
983         self.artists = []
984         self.lines = []
985         self.patches = []
986         self.texts = []
987         self.images = []
988         self.legends = []
989         if not keep_observers:
990             self._axobservers = cbook.CallbackRegistry()
991         self._suptitle = None
992         self._supxlabel = None
993         self._supylabel = None
994 
995         self.stale = True
996 
997     # synonym for `clear`.
998     def clf(self, keep_observers=False):
999         """
1000         [*Discouraged*] Alias for the `clear()` method.
1001 
1002         .. admonition:: Discouraged
1003 
1004             The use of ``clf()`` is discouraged. Use ``clear()`` instead.
1005 
1006         Parameters
1007         ----------
1008         keep_observers : bool, default: False
1009             Set *keep_observers* to True if, for example,
1010             a gui widget is tracking the Axes in the figure.
1011         """
1012         return self.clear(keep_observers=keep_observers)
1013 
1014     # Note: the docstring below is modified with replace for the pyplot
1015     # version of this function because the method name differs (plt.figlegend)
1016     # the replacements are:
1017     #    " legend(" -> " figlegend(" for the signatures
1018     #    "fig.legend(" -> "plt.figlegend" for the code examples
1019     #    "ax.plot" -> "plt.plot" for consistency in using pyplot when able
1020     @_docstring.dedent_interpd
1021     def legend(self, *args, **kwargs):
1022         """
1023         Place a legend on the figure.
1024 
1025         Call signatures::
1026 
1027             legend()
1028             legend(handles, labels)
1029             legend(handles=handles)
1030             legend(labels)
1031 
1032         The call signatures correspond to the following different ways to use
1033         this method:
1034 
1035         **1. Automatic detection of elements to be shown in the legend**
1036 
1037         The elements to be added to the legend are automatically determined,
1038         when you do not pass in any extra arguments.
1039 
1040         In this case, the labels are taken from the artist. You can specify
1041         them either at artist creation or by calling the
1042         :meth:`~.Artist.set_label` method on the artist::
1043 
1044             ax.plot([1, 2, 3], label='Inline label')
1045             fig.legend()
1046 
1047         or::
1048 
1049             line, = ax.plot([1, 2, 3])
1050             line.set_label('Label via method')
1051             fig.legend()
1052 
1053         Specific lines can be excluded from the automatic legend element
1054         selection by defining a label starting with an underscore.
1055         This is default for all artists, so calling `.Figure.legend` without
1056         any arguments and without setting the labels manually will result in
1057         no legend being drawn.
1058 
1059 
1060         **2. Explicitly listing the artists and labels in the legend**
1061 
1062         For full control of which artists have a legend entry, it is possible
1063         to pass an iterable of legend artists followed by an iterable of
1064         legend labels respectively::
1065 
1066             fig.legend([line1, line2, line3], ['label1', 'label2', 'label3'])
1067 
1068 
1069         **3. Explicitly listing the artists in the legend**
1070 
1071         This is similar to 2, but the labels are taken from the artists'
1072         label properties. Example::
1073 
1074             line1, = ax1.plot([1, 2, 3], label='label1')
1075             line2, = ax2.plot([1, 2, 3], label='label2')
1076             fig.legend(handles=[line1, line2])
1077 
1078 
1079         **4. Labeling existing plot elements**
1080 
1081         .. admonition:: Discouraged
1082 
1083             This call signature is discouraged, because the relation between
1084             plot elements and labels is only implicit by their order and can
1085             easily be mixed up.
1086 
1087         To make a legend for all artists on all Axes, call this function with
1088         an iterable of strings, one for each legend item. For example::
1089 
1090             fig, (ax1, ax2) = plt.subplots(1, 2)
1091             ax1.plot([1, 3, 5], color='blue')
1092             ax2.plot([2, 4, 6], color='red')
1093             fig.legend(['the blues', 'the reds'])
1094 
1095 
1096         Parameters
1097         ----------
1098         handles : list of `.Artist`, optional
1099             A list of Artists (lines, patches) to be added to the legend.
1100             Use this together with *labels*, if you need full control on what
1101             is shown in the legend and the automatic mechanism described above
1102             is not sufficient.
1103 
1104             The length of handles and labels should be the same in this
1105             case. If they are not, they are truncated to the smaller length.
1106 
1107         labels : list of str, optional
1108             A list of labels to show next to the artists.
1109             Use this together with *handles*, if you need full control on what
1110             is shown in the legend and the automatic mechanism described above
1111             is not sufficient.
1112 
1113         Returns
1114         -------
1115         `~matplotlib.legend.Legend`
1116 
1117         Other Parameters
1118         ----------------
1119         %(_legend_kw_figure)s
1120 
1121         See Also
1122         --------
1123         .Axes.legend
1124 
1125         Notes
1126         -----
1127         Some artists are not supported by this function.  See
1128         :ref:`legend_guide` for details.
1129         """
1130 
1131         handles, labels, extra_args, kwargs = mlegend._parse_legend_args(
1132                 self.axes,
1133                 *args,
1134                 **kwargs)
1135         # check for third arg
1136         if len(extra_args):
1137             # _api.warn_deprecated(
1138             #     "2.1",
1139             #     message="Figure.legend will accept no more than two "
1140             #     "positional arguments in the future.  Use "
1141             #     "'fig.legend(handles, labels, loc=location)' "
1142             #     "instead.")
1143             # kwargs['loc'] = extra_args[0]
1144             # extra_args = extra_args[1:]
1145             pass
1146         transform = kwargs.pop('bbox_transform', self.transSubfigure)
1147         # explicitly set the bbox transform if the user hasn't.
1148         l = mlegend.Legend(self, handles, labels, *extra_args,
1149                            bbox_transform=transform, **kwargs)
1150         self.legends.append(l)
1151         l._remove_method = self.legends.remove
1152         self.stale = True
1153         return l
1154 
1155     @_docstring.dedent_interpd
1156     def text(self, x, y, s, fontdict=None, **kwargs):
1157         """
1158         Add text to figure.
1159 
1160         Parameters
1161         ----------
1162         x, y : float
1163             The position to place the text. By default, this is in figure
1164             coordinates, floats in [0, 1]. The coordinate system can be changed
1165             using the *transform* keyword.
1166 
1167         s : str
1168             The text string.
1169 
1170         fontdict : dict, optional
1171             A dictionary to override the default text properties. If not given,
1172             the defaults are determined by :rc:`font.*`. Properties passed as
1173             *kwargs* override the corresponding ones given in *fontdict*.
1174 
1175         Returns
1176         -------
1177         `~.text.Text`
1178 
1179         Other Parameters
1180         ----------------
1181         **kwargs : `~matplotlib.text.Text` properties
1182             Other miscellaneous text parameters.
1183 
1184             %(Text:kwdoc)s
1185 
1186         See Also
1187         --------
1188         .Axes.text
1189         .pyplot.text
1190         """
1191         effective_kwargs = {
1192             'transform': self.transSubfigure,
1193             **(fontdict if fontdict is not None else {}),
1194             **kwargs,
1195         }
1196         text = Text(x=x, y=y, text=s, **effective_kwargs)
1197         text.set_figure(self)
1198         text.stale_callback = _stale_figure_callback
1199 
1200         self.texts.append(text)
1201         text._remove_method = self.texts.remove
1202         self.stale = True
1203         return text
1204 
1205     @_docstring.dedent_interpd
1206     def colorbar(
1207             self, mappable, cax=None, ax=None, use_gridspec=True, **kwargs):
1208         """
1209         Add a colorbar to a plot.
1210 
1211         Parameters
1212         ----------
1213         mappable
1214             The `matplotlib.cm.ScalarMappable` (i.e., `.AxesImage`,
1215             `.ContourSet`, etc.) described by this colorbar.  This argument is
1216             mandatory for the `.Figure.colorbar` method but optional for the
1217             `.pyplot.colorbar` function, which sets the default to the current
1218             image.
1219 
1220             Note that one can create a `.ScalarMappable` "on-the-fly" to
1221             generate colorbars not attached to a previously drawn artist, e.g.
1222             ::
1223 
1224                 fig.colorbar(cm.ScalarMappable(norm=norm, cmap=cmap), ax=ax)
1225 
1226         cax : `~matplotlib.axes.Axes`, optional
1227             Axes into which the colorbar will be drawn.  If `None`, then a new
1228             Axes is created and the space for it will be stolen from the Axes(s)
1229             specified in *ax*.
1230 
1231         ax : `~.axes.Axes` or iterable or `numpy.ndarray` of Axes, optional
1232             The one or more parent Axes from which space for a new colorbar Axes
1233             will be stolen. This parameter is only used if *cax* is not set.
1234 
1235             Defaults to the Axes that contains the mappable used to create the
1236             colorbar.
1237 
1238         use_gridspec : bool, optional
1239             If *cax* is ``None``, a new *cax* is created as an instance of
1240             Axes.  If *ax* is positioned with a subplotspec and *use_gridspec*
1241             is ``True``, then *cax* is also positioned with a subplotspec.
1242 
1243         Returns
1244         -------
1245         colorbar : `~matplotlib.colorbar.Colorbar`
1246 
1247         Other Parameters
1248         ----------------
1249         %(_make_axes_kw_doc)s
1250         %(_colormap_kw_doc)s
1251 
1252         Notes
1253         -----
1254         If *mappable* is a `~.contour.ContourSet`, its *extend* kwarg is
1255         included automatically.
1256 
1257         The *shrink* kwarg provides a simple way to scale the colorbar with
1258         respect to the axes. Note that if *cax* is specified, it determines the
1259         size of the colorbar, and *shrink* and *aspect* are ignored.
1260 
1261         For more precise control, you can manually specify the positions of the
1262         axes objects in which the mappable and the colorbar are drawn.  In this
1263         case, do not use any of the axes properties kwargs.
1264 
1265         It is known that some vector graphics viewers (svg and pdf) render
1266         white gaps between segments of the colorbar.  This is due to bugs in
1267         the viewers, not Matplotlib.  As a workaround, the colorbar can be
1268         rendered with overlapping segments::
1269 
1270             cbar = colorbar()
1271             cbar.solids.set_edgecolor("face")
1272             draw()
1273 
1274         However, this has negative consequences in other circumstances, e.g.
1275         with semi-transparent images (alpha < 1) and colorbar extensions;
1276         therefore, this workaround is not used by default (see issue #1188).
1277 
1278         """
1279 
1280         if ax is None:
1281             ax = getattr(mappable, "axes", None)
1282 
1283         if cax is None:
1284             if ax is None:
1285                 raise ValueError(
1286                     'Unable to determine Axes to steal space for Colorbar. '
1287                     'Either provide the *cax* argument to use as the Axes for '
1288                     'the Colorbar, provide the *ax* argument to steal space '
1289                     'from it, or add *mappable* to an Axes.')
1290             fig = (  # Figure of first axes; logic copied from make_axes.
1291                 [*ax.flat] if isinstance(ax, np.ndarray)
1292                 else [*ax] if np.iterable(ax)
1293                 else [ax])[0].figure
1294             current_ax = fig.gca()
1295             if (fig.get_layout_engine() is not None and
1296                     not fig.get_layout_engine().colorbar_gridspec):
1297                 use_gridspec = False
1298             if (use_gridspec
1299                     and isinstance(ax, mpl.axes._base._AxesBase)
1300                     and ax.get_subplotspec()):
1301                 cax, kwargs = cbar.make_axes_gridspec(ax, **kwargs)
1302             else:
1303                 cax, kwargs = cbar.make_axes(ax, **kwargs)
1304             # make_axes calls add_{axes,subplot} which changes gca; undo that.
1305             fig.sca(current_ax)
1306             cax.grid(visible=False, which='both', axis='both')
1307 
1308         NON_COLORBAR_KEYS = [  # remove kws that cannot be passed to Colorbar
1309             'fraction', 'pad', 'shrink', 'aspect', 'anchor', 'panchor']
1310         cb = cbar.Colorbar(cax, mappable, **{
1311             k: v for k, v in kwargs.items() if k not in NON_COLORBAR_KEYS})
1312         cax.figure.stale = True
1313         return cb
1314 
1315     def subplots_adjust(self, left=None, bottom=None, right=None, top=None,
1316                         wspace=None, hspace=None):
1317         """
1318         Adjust the subplot layout parameters.
1319 
1320         Unset parameters are left unmodified; initial values are given by
1321         :rc:`figure.subplot.[name]`.
1322 
1323         Parameters
1324         ----------
1325         left : float, optional
1326             The position of the left edge of the subplots,
1327             as a fraction of the figure width.
1328         right : float, optional
1329             The position of the right edge of the subplots,
1330             as a fraction of the figure width.
1331         bottom : float, optional
1332             The position of the bottom edge of the subplots,
1333             as a fraction of the figure height.
1334         top : float, optional
1335             The position of the top edge of the subplots,
1336             as a fraction of the figure height.
1337         wspace : float, optional
1338             The width of the padding between subplots,
1339             as a fraction of the average Axes width.
1340         hspace : float, optional
1341             The height of the padding between subplots,
1342             as a fraction of the average Axes height.
1343         """
1344         if (self.get_layout_engine() is not None and
1345                 not self.get_layout_engine().adjust_compatible):
1346             _api.warn_external(
1347                 "This figure was using a layout engine that is "
1348                 "incompatible with subplots_adjust and/or tight_layout; "
1349                 "not calling subplots_adjust.")
1350             return
1351         self.subplotpars.update(left, bottom, right, top, wspace, hspace)
1352         for ax in self.axes:
1353             if ax.get_subplotspec() is not None:
1354                 ax._set_position(ax.get_subplotspec().get_position(self))
1355         self.stale = True
1356 
1357     def align_xlabels(self, axs=None):
1358         """
1359         Align the xlabels of subplots in the same subplot column if label
1360         alignment is being done automatically (i.e. the label position is
1361         not manually set).
1362 
1363         Alignment persists for draw events after this is called.
1364 
1365         If a label is on the bottom, it is aligned with labels on Axes that
1366         also have their label on the bottom and that have the same
1367         bottom-most subplot row.  If the label is on the top,
1368         it is aligned with labels on Axes with the same top-most row.
1369 
1370         Parameters
1371         ----------
1372         axs : list of `~matplotlib.axes.Axes`
1373             Optional list of (or `~numpy.ndarray`) `~matplotlib.axes.Axes`
1374             to align the xlabels.
1375             Default is to align all Axes on the figure.
1376 
1377         See Also
1378         --------
1379         matplotlib.figure.Figure.align_ylabels
1380         matplotlib.figure.Figure.align_labels
1381 
1382         Notes
1383         -----
1384         This assumes that ``axs`` are from the same `.GridSpec`, so that
1385         their `.SubplotSpec` positions correspond to figure positions.
1386 
1387         Examples
1388         --------
1389         Example with rotated xtick labels::
1390 
1391             fig, axs = plt.subplots(1, 2)
1392             for tick in axs[0].get_xticklabels():
1393                 tick.set_rotation(55)
1394             axs[0].set_xlabel('XLabel 0')
1395             axs[1].set_xlabel('XLabel 1')
1396             fig.align_xlabels()
1397         """
1398         if axs is None:
1399             axs = self.axes
1400         axs = [ax for ax in np.ravel(axs) if ax.get_subplotspec() is not None]
1401         for ax in axs:
1402             _log.debug(' Working on: %s', ax.get_xlabel())
1403             rowspan = ax.get_subplotspec().rowspan
1404             pos = ax.xaxis.get_label_position()  # top or bottom
1405             # Search through other axes for label positions that are same as
1406             # this one and that share the appropriate row number.
1407             # Add to a grouper associated with each axes of siblings.
1408             # This list is inspected in `axis.draw` by
1409             # `axis._update_label_position`.
1410             for axc in axs:
1411                 if axc.xaxis.get_label_position() == pos:
1412                     rowspanc = axc.get_subplotspec().rowspan
1413                     if (pos == 'top' and rowspan.start == rowspanc.start or
1414                             pos == 'bottom' and rowspan.stop == rowspanc.stop):
1415                         # grouper for groups of xlabels to align
1416                         self._align_label_groups['x'].join(ax, axc)
1417 
1418     def align_ylabels(self, axs=None):
1419         """
1420         Align the ylabels of subplots in the same subplot column if label
1421         alignment is being done automatically (i.e. the label position is
1422         not manually set).
1423 
1424         Alignment persists for draw events after this is called.
1425 
1426         If a label is on the left, it is aligned with labels on Axes that
1427         also have their label on the left and that have the same
1428         left-most subplot column.  If the label is on the right,
1429         it is aligned with labels on Axes with the same right-most column.
1430 
1431         Parameters
1432         ----------
1433         axs : list of `~matplotlib.axes.Axes`
1434             Optional list (or `~numpy.ndarray`) of `~matplotlib.axes.Axes`
1435             to align the ylabels.
1436             Default is to align all Axes on the figure.
1437 
1438         See Also
1439         --------
1440         matplotlib.figure.Figure.align_xlabels
1441         matplotlib.figure.Figure.align_labels
1442 
1443         Notes
1444         -----
1445         This assumes that ``axs`` are from the same `.GridSpec`, so that
1446         their `.SubplotSpec` positions correspond to figure positions.
1447 
1448         Examples
1449         --------
1450         Example with large yticks labels::
1451 
1452             fig, axs = plt.subplots(2, 1)
1453             axs[0].plot(np.arange(0, 1000, 50))
1454             axs[0].set_ylabel('YLabel 0')
1455             axs[1].set_ylabel('YLabel 1')
1456             fig.align_ylabels()
1457         """
1458         if axs is None:
1459             axs = self.axes
1460         axs = [ax for ax in np.ravel(axs) if ax.get_subplotspec() is not None]
1461         for ax in axs:
1462             _log.debug(' Working on: %s', ax.get_ylabel())
1463             colspan = ax.get_subplotspec().colspan
1464             pos = ax.yaxis.get_label_position()  # left or right
1465             # Search through other axes for label positions that are same as
1466             # this one and that share the appropriate column number.
1467             # Add to a list associated with each axes of siblings.
1468             # This list is inspected in `axis.draw` by
1469             # `axis._update_label_position`.
1470             for axc in axs:
1471                 if axc.yaxis.get_label_position() == pos:
1472                     colspanc = axc.get_subplotspec().colspan
1473                     if (pos == 'left' and colspan.start == colspanc.start or
1474                             pos == 'right' and colspan.stop == colspanc.stop):
1475                         # grouper for groups of ylabels to align
1476                         self._align_label_groups['y'].join(ax, axc)
1477 
1478     def align_labels(self, axs=None):
1479         """
1480         Align the xlabels and ylabels of subplots with the same subplots
1481         row or column (respectively) if label alignment is being
1482         done automatically (i.e. the label position is not manually set).
1483 
1484         Alignment persists for draw events after this is called.
1485 
1486         Parameters
1487         ----------
1488         axs : list of `~matplotlib.axes.Axes`
1489             Optional list (or `~numpy.ndarray`) of `~matplotlib.axes.Axes`
1490             to align the labels.
1491             Default is to align all Axes on the figure.
1492 
1493         See Also
1494         --------
1495         matplotlib.figure.Figure.align_xlabels
1496 
1497         matplotlib.figure.Figure.align_ylabels
1498         """
1499         self.align_xlabels(axs=axs)
1500         self.align_ylabels(axs=axs)
1501 
1502     def add_gridspec(self, nrows=1, ncols=1, **kwargs):
1503         """
1504         Return a `.GridSpec` that has this figure as a parent.  This allows
1505         complex layout of Axes in the figure.
1506 
1507         Parameters
1508         ----------
1509         nrows : int, default: 1
1510             Number of rows in grid.
1511 
1512         ncols : int, default: 1
1513             Number of columns in grid.
1514 
1515         Returns
1516         -------
1517         `.GridSpec`
1518 
1519         Other Parameters
1520         ----------------
1521         **kwargs
1522             Keyword arguments are passed to `.GridSpec`.
1523 
1524         See Also
1525         --------
1526         matplotlib.pyplot.subplots
1527 
1528         Examples
1529         --------
1530         Adding a subplot that spans two rows::
1531 
1532             fig = plt.figure()
1533             gs = fig.add_gridspec(2, 2)
1534             ax1 = fig.add_subplot(gs[0, 0])
1535             ax2 = fig.add_subplot(gs[1, 0])
1536             # spans two rows:
1537             ax3 = fig.add_subplot(gs[:, 1])
1538 
1539         """
1540 
1541         _ = kwargs.pop('figure', None)  # pop in case user has added this...
1542         gs = GridSpec(nrows=nrows, ncols=ncols, figure=self, **kwargs)
1543         return gs
1544 
1545     def subfigures(self, nrows=1, ncols=1, squeeze=True,
1546                    wspace=None, hspace=None,
1547                    width_ratios=None, height_ratios=None,
1548                    **kwargs):
1549         """
1550         Add a set of subfigures to this figure or subfigure.
1551 
1552         A subfigure has the same artist methods as a figure, and is logically
1553         the same as a figure, but cannot print itself.
1554         See :doc:`/gallery/subplots_axes_and_figures/subfigures`.
1555 
1556         .. note::
1557             The *subfigure* concept is new in v3.4, and the API is still provisional.
1558 
1559         Parameters
1560         ----------
1561         nrows, ncols : int, default: 1
1562             Number of rows/columns of the subfigure grid.
1563 
1564         squeeze : bool, default: True
1565             If True, extra dimensions are squeezed out from the returned
1566             array of subfigures.
1567 
1568         wspace, hspace : float, default: None
1569             The amount of width/height reserved for space between subfigures,
1570             expressed as a fraction of the average subfigure width/height.
1571             If not given, the values will be inferred from a figure or
1572             rcParams when necessary.
1573 
1574         width_ratios : array-like of length *ncols*, optional
1575             Defines the relative widths of the columns. Each column gets a
1576             relative width of ``width_ratios[i] / sum(width_ratios)``.
1577             If not given, all columns will have the same width.
1578 
1579         height_ratios : array-like of length *nrows*, optional
1580             Defines the relative heights of the rows. Each row gets a
1581             relative height of ``height_ratios[i] / sum(height_ratios)``.
1582             If not given, all rows will have the same height.
1583         """
1584         gs = GridSpec(nrows=nrows, ncols=ncols, figure=self,
1585                       wspace=wspace, hspace=hspace,
1586                       width_ratios=width_ratios,
1587                       height_ratios=height_ratios)
1588 
1589         sfarr = np.empty((nrows, ncols), dtype=object)
1590         for i in range(ncols):
1591             for j in range(nrows):
1592                 sfarr[j, i] = self.add_subfigure(gs[j, i], **kwargs)
1593 
1594         if squeeze:
1595             # Discarding unneeded dimensions that equal 1.  If we only have one
1596             # subfigure, just return it instead of a 1-element array.
1597             return sfarr.item() if sfarr.size == 1 else sfarr.squeeze()
1598         else:
1599             # Returned axis array will be always 2-d, even if nrows=ncols=1.
1600             return sfarr
1601 
1602     def add_subfigure(self, subplotspec, **kwargs):
1603         """
1604         Add a `.SubFigure` to the figure as part of a subplot arrangement.
1605 
1606         Parameters
1607         ----------
1608         subplotspec : `.gridspec.SubplotSpec`
1609             Defines the region in a parent gridspec where the subfigure will
1610             be placed.
1611 
1612         Returns
1613         -------
1614         `.SubFigure`
1615 
1616         Other Parameters
1617         ----------------
1618         **kwargs
1619             Are passed to the `.SubFigure` object.
1620 
1621         See Also
1622         --------
1623         .Figure.subfigures
1624         """
1625         sf = SubFigure(self, subplotspec, **kwargs)
1626         self.subfigs += [sf]
1627         return sf
1628 
1629     def sca(self, a):
1630         """Set the current Axes to be *a* and return *a*."""
1631         self._axstack.bubble(a)
1632         self._axobservers.process("_axes_change_event", self)
1633         return a
1634 
1635     def gca(self):
1636         """
1637         Get the current Axes.
1638 
1639         If there is currently no Axes on this Figure, a new one is created
1640         using `.Figure.add_subplot`.  (To test whether there is currently an
1641         Axes on a Figure, check whether ``figure.axes`` is empty.  To test
1642         whether there is currently a Figure on the pyplot figure stack, check
1643         whether `.pyplot.get_fignums()` is empty.)
1644         """
1645         ax = self._axstack.current()
1646         return ax if ax is not None else self.add_subplot()
1647 
1648     def _gci(self):
1649         # Helper for `~matplotlib.pyplot.gci`.  Do not use elsewhere.
1650         """
1651         Get the current colorable artist.
1652 
1653         Specifically, returns the current `.ScalarMappable` instance (`.Image`
1654         created by `imshow` or `figimage`, `.Collection` created by `pcolor` or
1655         `scatter`, etc.), or *None* if no such instance has been defined.
1656 
1657         The current image is an attribute of the current Axes, or the nearest
1658         earlier Axes in the current figure that contains an image.
1659 
1660         Notes
1661         -----
1662         Historically, the only colorable artists were images; hence the name
1663         ``gci`` (get current image).
1664         """
1665         # Look first for an image in the current Axes.
1666         ax = self._axstack.current()
1667         if ax is None:
1668             return None
1669         im = ax._gci()
1670         if im is not None:
1671             return im
1672         # If there is no image in the current Axes, search for
1673         # one in a previously created Axes.  Whether this makes
1674         # sense is debatable, but it is the documented behavior.
1675         for ax in reversed(self.axes):
1676             im = ax._gci()
1677             if im is not None:
1678                 return im
1679         return None
1680 
1681     def _process_projection_requirements(self, *, axes_class=None, polar=False,
1682                                          projection=None, **kwargs):
1683         """
1684         Handle the args/kwargs to add_axes/add_subplot/gca, returning::
1685 
1686             (axes_proj_class, proj_class_kwargs)
1687 
1688         which can be used for new Axes initialization/identification.
1689         """
1690         if axes_class is not None:
1691             if polar or projection is not None:
1692                 raise ValueError(
1693                     "Cannot combine 'axes_class' and 'projection' or 'polar'")
1694             projection_class = axes_class
1695         else:
1696 
1697             if polar:
1698                 if projection is not None and projection != 'polar':
1699                     raise ValueError(
1700                         f"polar={polar}, yet projection={projection!r}. "
1701                         "Only one of these arguments should be supplied."
1702                     )
1703                 projection = 'polar'
1704 
1705             if isinstance(projection, str) or projection is None:
1706                 projection_class = projections.get_projection_class(projection)
1707             elif hasattr(projection, '_as_mpl_axes'):
1708                 projection_class, extra_kwargs = projection._as_mpl_axes()
1709                 kwargs.update(**extra_kwargs)
1710             else:
1711                 raise TypeError(
1712                     f"projection must be a string, None or implement a "
1713                     f"_as_mpl_axes method, not {projection!r}")
1714         return projection_class, kwargs
1715 
1716     def get_default_bbox_extra_artists(self):
1717         bbox_artists = [artist for artist in self.get_children()
1718                         if (artist.get_visible() and artist.get_in_layout())]
1719         for ax in self.axes:
1720             if ax.get_visible():
1721                 bbox_artists.extend(ax.get_default_bbox_extra_artists())
1722         return bbox_artists
1723 
1724     @_api.make_keyword_only("3.8", "bbox_extra_artists")
1725     def get_tightbbox(self, renderer=None, bbox_extra_artists=None):
1726         """
1727         Return a (tight) bounding box of the figure *in inches*.
1728 
1729         Note that `.FigureBase` differs from all other artists, which return
1730         their `.Bbox` in pixels.
1731 
1732         Artists that have ``artist.set_in_layout(False)`` are not included
1733         in the bbox.
1734 
1735         Parameters
1736         ----------
1737         renderer : `.RendererBase` subclass
1738             Renderer that will be used to draw the figures (i.e.
1739             ``fig.canvas.get_renderer()``)
1740 
1741         bbox_extra_artists : list of `.Artist` or ``None``
1742             List of artists to include in the tight bounding box.  If
1743             ``None`` (default), then all artist children of each Axes are
1744             included in the tight bounding box.
1745 
1746         Returns
1747         -------
1748         `.BboxBase`
1749             containing the bounding box (in figure inches).
1750         """
1751 
1752         if renderer is None:
1753             renderer = self.figure._get_renderer()
1754 
1755         bb = []
1756         if bbox_extra_artists is None:
1757             artists = self.get_default_bbox_extra_artists()
1758         else:
1759             artists = bbox_extra_artists
1760 
1761         for a in artists:
1762             bbox = a.get_tightbbox(renderer)
1763             if bbox is not None:
1764                 bb.append(bbox)
1765 
1766         for ax in self.axes:
1767             if ax.get_visible():
1768                 # some axes don't take the bbox_extra_artists kwarg so we
1769                 # need this conditional....
1770                 try:
1771                     bbox = ax.get_tightbbox(
1772                         renderer, bbox_extra_artists=bbox_extra_artists)
1773                 except TypeError:
1774                     bbox = ax.get_tightbbox(renderer)
1775                 bb.append(bbox)
1776         bb = [b for b in bb
1777               if (np.isfinite(b.width) and np.isfinite(b.height)
1778                   and (b.width != 0 or b.height != 0))]
1779 
1780         isfigure = hasattr(self, 'bbox_inches')
1781         if len(bb) == 0:
1782             if isfigure:
1783                 return self.bbox_inches
1784             else:
1785                 # subfigures do not have bbox_inches, but do have a bbox
1786                 bb = [self.bbox]
1787 
1788         _bbox = Bbox.union(bb)
1789 
1790         if isfigure:
1791             # transform from pixels to inches...
1792             _bbox = TransformedBbox(_bbox, self.dpi_scale_trans.inverted())
1793 
1794         return _bbox
1795 
1796     @staticmethod
1797     def _norm_per_subplot_kw(per_subplot_kw):
1798         expanded = {}
1799         for k, v in per_subplot_kw.items():
1800             if isinstance(k, tuple):
1801                 for sub_key in k:
1802                     if sub_key in expanded:
1803                         raise ValueError(
1804                             f'The key {sub_key!r} appears multiple times.'
1805                             )
1806                     expanded[sub_key] = v
1807             else:
1808                 if k in expanded:
1809                     raise ValueError(
1810                         f'The key {k!r} appears multiple times.'
1811                     )
1812                 expanded[k] = v
1813         return expanded
1814 
1815     @staticmethod
1816     def _normalize_grid_string(layout):
1817         if '\n' not in layout:
1818             # single-line string
1819             return [list(ln) for ln in layout.split(';')]
1820         else:
1821             # multi-line string
1822             layout = inspect.cleandoc(layout)
1823             return [list(ln) for ln in layout.strip('\n').split('\n')]
1824 
1825     def subplot_mosaic(self, mosaic, *, sharex=False, sharey=False,
1826                        width_ratios=None, height_ratios=None,
1827                        empty_sentinel='.',
1828                        subplot_kw=None, per_subplot_kw=None, gridspec_kw=None):
1829         """
1830         Build a layout of Axes based on ASCII art or nested lists.
1831 
1832         This is a helper function to build complex GridSpec layouts visually.
1833 
1834         See :ref:`mosaic`
1835         for an example and full API documentation
1836 
1837         Parameters
1838         ----------
1839         mosaic : list of list of {hashable or nested} or str
1840 
1841             A visual layout of how you want your Axes to be arranged
1842             labeled as strings.  For example ::
1843 
1844                x = [['A panel', 'A panel', 'edge'],
1845                     ['C panel', '.',       'edge']]
1846 
1847             produces 4 Axes:
1848 
1849             - 'A panel' which is 1 row high and spans the first two columns
1850             - 'edge' which is 2 rows high and is on the right edge
1851             - 'C panel' which in 1 row and 1 column wide in the bottom left
1852             - a blank space 1 row and 1 column wide in the bottom center
1853 
1854             Any of the entries in the layout can be a list of lists
1855             of the same form to create nested layouts.
1856 
1857             If input is a str, then it can either be a multi-line string of
1858             the form ::
1859 
1860               '''
1861               AAE
1862               C.E
1863               '''
1864 
1865             where each character is a column and each line is a row. Or it
1866             can be a single-line string where rows are separated by ``;``::
1867 
1868               'AB;CC'
1869 
1870             The string notation allows only single character Axes labels and
1871             does not support nesting but is very terse.
1872 
1873             The Axes identifiers may be `str` or a non-iterable hashable
1874             object (e.g. `tuple` s may not be used).
1875 
1876         sharex, sharey : bool, default: False
1877             If True, the x-axis (*sharex*) or y-axis (*sharey*) will be shared
1878             among all subplots.  In that case, tick label visibility and axis
1879             units behave as for `subplots`.  If False, each subplot's x- or
1880             y-axis will be independent.
1881 
1882         width_ratios : array-like of length *ncols*, optional
1883             Defines the relative widths of the columns. Each column gets a
1884             relative width of ``width_ratios[i] / sum(width_ratios)``.
1885             If not given, all columns will have the same width.  Equivalent
1886             to ``gridspec_kw={'width_ratios': [...]}``. In the case of nested
1887             layouts, this argument applies only to the outer layout.
1888 
1889         height_ratios : array-like of length *nrows*, optional
1890             Defines the relative heights of the rows. Each row gets a
1891             relative height of ``height_ratios[i] / sum(height_ratios)``.
1892             If not given, all rows will have the same height. Equivalent
1893             to ``gridspec_kw={'height_ratios': [...]}``. In the case of nested
1894             layouts, this argument applies only to the outer layout.
1895 
1896         subplot_kw : dict, optional
1897             Dictionary with keywords passed to the `.Figure.add_subplot` call
1898             used to create each subplot.  These values may be overridden by
1899             values in *per_subplot_kw*.
1900 
1901         per_subplot_kw : dict, optional
1902             A dictionary mapping the Axes identifiers or tuples of identifiers
1903             to a dictionary of keyword arguments to be passed to the
1904             `.Figure.add_subplot` call used to create each subplot.  The values
1905             in these dictionaries have precedence over the values in
1906             *subplot_kw*.
1907 
1908             If *mosaic* is a string, and thus all keys are single characters,
1909             it is possible to use a single string instead of a tuple as keys;
1910             i.e. ``"AB"`` is equivalent to ``("A", "B")``.
1911 
1912             .. versionadded:: 3.7
1913 
1914         gridspec_kw : dict, optional
1915             Dictionary with keywords passed to the `.GridSpec` constructor used
1916             to create the grid the subplots are placed on. In the case of
1917             nested layouts, this argument applies only to the outer layout.
1918             For more complex layouts, users should use `.Figure.subfigures`
1919             to create the nesting.
1920 
1921         empty_sentinel : object, optional
1922             Entry in the layout to mean "leave this space empty".  Defaults
1923             to ``'.'``. Note, if *layout* is a string, it is processed via
1924             `inspect.cleandoc` to remove leading white space, which may
1925             interfere with using white-space as the empty sentinel.
1926 
1927         Returns
1928         -------
1929         dict[label, Axes]
1930            A dictionary mapping the labels to the Axes objects.  The order of
1931            the axes is left-to-right and top-to-bottom of their position in the
1932            total layout.
1933 
1934         """
1935         subplot_kw = subplot_kw or {}
1936         gridspec_kw = dict(gridspec_kw or {})
1937         per_subplot_kw = per_subplot_kw or {}
1938 
1939         if height_ratios is not None:
1940             if 'height_ratios' in gridspec_kw:
1941                 raise ValueError("'height_ratios' must not be defined both as "
1942                                  "parameter and as key in 'gridspec_kw'")
1943             gridspec_kw['height_ratios'] = height_ratios
1944         if width_ratios is not None:
1945             if 'width_ratios' in gridspec_kw:
1946                 raise ValueError("'width_ratios' must not be defined both as "
1947                                  "parameter and as key in 'gridspec_kw'")
1948             gridspec_kw['width_ratios'] = width_ratios
1949 
1950         # special-case string input
1951         if isinstance(mosaic, str):
1952             mosaic = self._normalize_grid_string(mosaic)
1953             per_subplot_kw = {
1954                 tuple(k): v for k, v in per_subplot_kw.items()
1955             }
1956 
1957         per_subplot_kw = self._norm_per_subplot_kw(per_subplot_kw)
1958 
1959         # Only accept strict bools to allow a possible future API expansion.
1960         _api.check_isinstance(bool, sharex=sharex, sharey=sharey)
1961 
1962         def _make_array(inp):
1963             """
1964             Convert input into 2D array
1965 
1966             We need to have this internal function rather than
1967             ``np.asarray(..., dtype=object)`` so that a list of lists
1968             of lists does not get converted to an array of dimension > 2.
1969 
1970             Returns
1971             -------
1972             2D object array
1973             """
1974             r0, *rest = inp
1975             if isinstance(r0, str):
1976                 raise ValueError('List mosaic specification must be 2D')
1977             for j, r in enumerate(rest, start=1):
1978                 if isinstance(r, str):
1979                     raise ValueError('List mosaic specification must be 2D')
1980                 if len(r0) != len(r):
1981                     raise ValueError(
1982                         "All of the rows must be the same length, however "
1983                         f"the first row ({r0!r}) has length {len(r0)} "
1984                         f"and row {j} ({r!r}) has length {len(r)}."
1985                     )
1986             out = np.zeros((len(inp), len(r0)), dtype=object)
1987             for j, r in enumerate(inp):
1988                 for k, v in enumerate(r):
1989                     out[j, k] = v
1990             return out
1991 
1992         def _identify_keys_and_nested(mosaic):
1993             """
1994             Given a 2D object array, identify unique IDs and nested mosaics
1995 
1996             Parameters
1997             ----------
1998             mosaic : 2D object array
1999 
2000             Returns
2001             -------
2002             unique_ids : tuple
2003                 The unique non-sub mosaic entries in this mosaic
2004             nested : dict[tuple[int, int], 2D object array]
2005             """
2006             # make sure we preserve the user supplied order
2007             unique_ids = cbook._OrderedSet()
2008             nested = {}
2009             for j, row in enumerate(mosaic):
2010                 for k, v in enumerate(row):
2011                     if v == empty_sentinel:
2012                         continue
2013                     elif not cbook.is_scalar_or_string(v):
2014                         nested[(j, k)] = _make_array(v)
2015                     else:
2016                         unique_ids.add(v)
2017 
2018             return tuple(unique_ids), nested
2019 
2020         def _do_layout(gs, mosaic, unique_ids, nested):
2021             """
2022             Recursively do the mosaic.
2023 
2024             Parameters
2025             ----------
2026             gs : GridSpec
2027             mosaic : 2D object array
2028                 The input converted to a 2D array for this level.
2029             unique_ids : tuple
2030                 The identified scalar labels at this level of nesting.
2031             nested : dict[tuple[int, int]], 2D object array
2032                 The identified nested mosaics, if any.
2033 
2034             Returns
2035             -------
2036             dict[label, Axes]
2037                 A flat dict of all of the Axes created.
2038             """
2039             output = dict()
2040 
2041             # we need to merge together the Axes at this level and the axes
2042             # in the (recursively) nested sub-mosaics so that we can add
2043             # them to the figure in the "natural" order if you were to
2044             # ravel in c-order all of the Axes that will be created
2045             #
2046             # This will stash the upper left index of each object (axes or
2047             # nested mosaic) at this level
2048             this_level = dict()
2049 
2050             # go through the unique keys,
2051             for name in unique_ids:
2052                 # sort out where each axes starts/ends
2053                 indx = np.argwhere(mosaic == name)
2054                 start_row, start_col = np.min(indx, axis=0)
2055                 end_row, end_col = np.max(indx, axis=0) + 1
2056                 # and construct the slice object
2057                 slc = (slice(start_row, end_row), slice(start_col, end_col))
2058                 # some light error checking
2059                 if (mosaic[slc] != name).any():
2060                     raise ValueError(
2061                         f"While trying to layout\n{mosaic!r}\n"
2062                         f"we found that the label {name!r} specifies a "
2063                         "non-rectangular or non-contiguous area.")
2064                 # and stash this slice for later
2065                 this_level[(start_row, start_col)] = (name, slc, 'axes')
2066 
2067             # do the same thing for the nested mosaics (simpler because these
2068             # cannot be spans yet!)
2069             for (j, k), nested_mosaic in nested.items():
2070                 this_level[(j, k)] = (None, nested_mosaic, 'nested')
2071 
2072             # now go through the things in this level and add them
2073             # in order left-to-right top-to-bottom
2074             for key in sorted(this_level):
2075                 name, arg, method = this_level[key]
2076                 # we are doing some hokey function dispatch here based
2077                 # on the 'method' string stashed above to sort out if this
2078                 # element is an Axes or a nested mosaic.
2079                 if method == 'axes':
2080                     slc = arg
2081                     # add a single axes
2082                     if name in output:
2083                         raise ValueError(f"There are duplicate keys {name} "
2084                                          f"in the layout\n{mosaic!r}")
2085                     ax = self.add_subplot(
2086                         gs[slc], **{
2087                             'label': str(name),
2088                             **subplot_kw,
2089                             **per_subplot_kw.get(name, {})
2090                         }
2091                     )
2092                     output[name] = ax
2093                 elif method == 'nested':
2094                     nested_mosaic = arg
2095                     j, k = key
2096                     # recursively add the nested mosaic
2097                     rows, cols = nested_mosaic.shape
2098                     nested_output = _do_layout(
2099                         gs[j, k].subgridspec(rows, cols),
2100                         nested_mosaic,
2101                         *_identify_keys_and_nested(nested_mosaic)
2102                     )
2103                     overlap = set(output) & set(nested_output)
2104                     if overlap:
2105                         raise ValueError(
2106                             f"There are duplicate keys {overlap} "
2107                             f"between the outer layout\n{mosaic!r}\n"
2108                             f"and the nested layout\n{nested_mosaic}"
2109                         )
2110                     output.update(nested_output)
2111                 else:
2112                     raise RuntimeError("This should never happen")
2113             return output
2114 
2115         mosaic = _make_array(mosaic)
2116         rows, cols = mosaic.shape
2117         gs = self.add_gridspec(rows, cols, **gridspec_kw)
2118         ret = _do_layout(gs, mosaic, *_identify_keys_and_nested(mosaic))
2119         ax0 = next(iter(ret.values()))
2120         for ax in ret.values():
2121             if sharex:
2122                 ax.sharex(ax0)
2123                 ax._label_outer_xaxis(check_patch=True)
2124             if sharey:
2125                 ax.sharey(ax0)
2126                 ax._label_outer_yaxis(check_patch=True)
2127         if extra := set(per_subplot_kw) - set(ret):
2128             raise ValueError(
2129                 f"The keys {extra} are in *per_subplot_kw* "
2130                 "but not in the mosaic."
2131             )
2132         return ret
2133 
2134     def _set_artist_props(self, a):
2135         if a != self:
2136             a.set_figure(self)
2137         a.stale_callback = _stale_figure_callback
2138         a.set_transform(self.transSubfigure)

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>]
2025-10-15 07:45:33.796 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-15 07:45:33.797 | INFO     | Search-only: skipping patch selection
2025-10-15 07:45:33.946 | INFO     | Task matplotlib__matplotlib-25960 completed successfully.
2025-10-15 07:45:33.947 | INFO     | No patch generated. You can try running ACR again.
