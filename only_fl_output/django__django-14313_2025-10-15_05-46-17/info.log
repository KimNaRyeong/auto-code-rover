2025-10-15 05:46:18.038 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-15 05:46:20.824 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=839, output_tokens=12, cost=0.008750
2025-10-15 05:46:32.193 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1019, output_tokens=490, cost=0.024890
2025-10-15 05:46:33.365 | INFO     | registered non reproducing test 0
2025-10-15 05:46:50.433 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2162, output_tokens=712, cost=0.042980
2025-10-15 05:46:51.621 | INFO     | registered non reproducing test 1
2025-10-15 05:47:08.370 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2978, output_tokens=782, cost=0.053240
2025-10-15 05:47:09.467 | INFO     | registered non reproducing test 2
2025-10-15 05:47:09.468 | WARNING  | Failed to write a reproducer test; skipping reproducer tracing
2025-10-15 05:47:09.474 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 05:47:18.853 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1148, output_tokens=364, cost=0.022400
2025-10-15 05:47:18.861 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 05:47:21.797 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=718, output_tokens=88, cost=0.009820
2025-10-15 05:47:21.799 | DEBUG    | Extracted a valid json.
2025-10-15 05:47:21.799 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_class(\"Post\")",
        "search_class(\"User\")",
        "search_class_in_file(\"PostAdmin\", \"admin.py\")",
        "search_method_in_class(\"delete_queryset\", \"PostAdmin\")",
        "search_code(\"distinct()\")",
        "search_method_in_class(\"changelist_view\", \"PostAdmin\")"
    ],
    "bug_locations": []
}
2025-10-15 05:47:21.857 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-15 05:47:21.858 | DEBUG    | <Agent search> Analyzing search results.
2025-10-15 05:47:40.322 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1913, output_tokens=726, cost=0.040910
2025-10-15 05:47:40.335 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-15 05:47:49.069 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2855, output_tokens=377, cost=0.039860
2025-10-15 05:47:49.077 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-15 05:47:56.534 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=731, output_tokens=284, cost=0.015830
2025-10-15 05:47:56.536 | DEBUG    | Extracted a valid json.
2025-10-15 05:47:56.536 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations":[
        {
            "file": "django/contrib/admin/options.py",
            "class": "ModelAdmin",
            "method": "delete_queryset",
            "intended_behavior": "This method needs to handle queryset deletion carefully when the queryset involves a distinct() call, especially in the context of the admin interface where searches can generate querysets that use distinct(). The intended behavior here is to ensure that the queryset handed over to delete_queryset can be safely deleted, possibly by re-evaluating the queryset without distinct() if it's not compatible with deletion. This adjustment must preserve the admin's ability to filter and search efficiently without causing errors during bulk delete actions."
        },
        {
            "file": "django/contrib/admin/views/main.py",
            "class": "",
            "method": "",
            "intended_behavior": "The code handling search queries in the admin page that involves many-to-many fields (directly or indirectly) needs to ensure that the operations following a search, such as delete, do not fail because of intermediate query modifications like distinct(). Here, the solution might involve reworking how search querysets are prepared or offering an alternative path for delete actions that does not rely on potentially modified querysets containing distinct(). This ensures the admin interface remains robust, supporting both complex searches and bulk actions without leading to exceptions."
        }
    ]
}
2025-10-15 05:47:56.552 | DEBUG    | Bug location extracted successfully: [<file>django/contrib/admin/options.py</file>
<class>ModelAdmin</class>
<method>delete_queryset</method>
<code>
1105     def delete_queryset(self, request, queryset):
1106         """Given a queryset, delete it from the database."""
1107         queryset.delete()

</code><intended_behavior>This method needs to handle queryset deletion carefully when the queryset involves a distinct() call, especially in the context of the admin interface where searches can generate querysets that use distinct(). The intended behavior here is to ensure that the queryset handed over to delete_queryset can be safely deleted, possibly by re-evaluating the queryset without distinct() if it's not compatible with deletion. This adjustment must preserve the admin's ability to filter and search efficiently without causing errors during bulk delete actions.</intended_behavior>, <file>django/contrib/admin/options.py</file>
<class>ModelAdmin</class>
<method>None</method>
<code>
551 class ModelAdmin(BaseModelAdmin):
552     """Encapsulate all admin options and functionality for a given model."""
553 
554     list_display = ('__str__',)
555     list_display_links = ()
556     list_filter = ()
557     list_select_related = False
558     list_per_page = 100
559     list_max_show_all = 200
560     list_editable = ()
561     search_fields = ()
562     date_hierarchy = None
563     save_as = False
564     save_as_continue = True
565     save_on_top = False
566     paginator = Paginator
567     preserve_filters = True
568     inlines = []
569 
570     # Custom templates (designed to be over-ridden in subclasses)
571     add_form_template = None
572     change_form_template = None
573     change_list_template = None
574     delete_confirmation_template = None
575     delete_selected_confirmation_template = None
576     object_history_template = None
577     popup_response_template = None
578 
579     # Actions
580     actions = []
581     action_form = helpers.ActionForm
582     actions_on_top = True
583     actions_on_bottom = False
584     actions_selection_counter = True
585     checks_class = ModelAdminChecks
586 
587     def __init__(self, model, admin_site):
588         self.model = model
589         self.opts = model._meta
590         self.admin_site = admin_site
591         super().__init__()
592 
593     def __str__(self):
594         return "%s.%s" % (self.model._meta.app_label, self.__class__.__name__)
595 
596     def get_inline_instances(self, request, obj=None):
597         inline_instances = []
598         for inline_class in self.get_inlines(request, obj):
599             inline = inline_class(self.model, self.admin_site)
600             if request:
601                 if not (inline.has_view_or_change_permission(request, obj) or
602                         inline.has_add_permission(request, obj) or
603                         inline.has_delete_permission(request, obj)):
604                     continue
605                 if not inline.has_add_permission(request, obj):
606                     inline.max_num = 0
607             inline_instances.append(inline)
608 
609         return inline_instances
610 
611     def get_urls(self):
612         from django.urls import path
613 
614         def wrap(view):
615             def wrapper(*args, **kwargs):
616                 return self.admin_site.admin_view(view)(*args, **kwargs)
617             wrapper.model_admin = self
618             return update_wrapper(wrapper, view)
619 
620         info = self.model._meta.app_label, self.model._meta.model_name
621 
622         return [
623             path('', wrap(self.changelist_view), name='%s_%s_changelist' % info),
624             path('add/', wrap(self.add_view), name='%s_%s_add' % info),
625             path('<path:object_id>/history/', wrap(self.history_view), name='%s_%s_history' % info),
626             path('<path:object_id>/delete/', wrap(self.delete_view), name='%s_%s_delete' % info),
627             path('<path:object_id>/change/', wrap(self.change_view), name='%s_%s_change' % info),
628             # For backwards compatibility (was the change url before 1.9)
629             path('<path:object_id>/', wrap(RedirectView.as_view(
630                 pattern_name='%s:%s_%s_change' % ((self.admin_site.name,) + info)
631             ))),
632         ]
633 
634     @property
635     def urls(self):
636         return self.get_urls()
637 
638     @property
639     def media(self):
640         extra = '' if settings.DEBUG else '.min'
641         js = [
642             'vendor/jquery/jquery%s.js' % extra,
643             'jquery.init.js',
644             'core.js',
645             'admin/RelatedObjectLookups.js',
646             'actions.js',
647             'urlify.js',
648             'prepopulate.js',
649             'vendor/xregexp/xregexp%s.js' % extra,
650         ]
651         return forms.Media(js=['admin/js/%s' % url for url in js])
652 
653     def get_model_perms(self, request):
654         """
655         Return a dict of all perms for this model. This dict has the keys
656         ``add``, ``change``, ``delete``, and ``view`` mapping to the True/False
657         for each of those actions.
658         """
659         return {
660             'add': self.has_add_permission(request),
661             'change': self.has_change_permission(request),
662             'delete': self.has_delete_permission(request),
663             'view': self.has_view_permission(request),
664         }
665 
666     def _get_form_for_get_fields(self, request, obj):
667         return self.get_form(request, obj, fields=None)
668 
669     def get_form(self, request, obj=None, change=False, **kwargs):
670         """
671         Return a Form class for use in the admin add view. This is used by
672         add_view and change_view.
673         """
674         if 'fields' in kwargs:
675             fields = kwargs.pop('fields')
676         else:
677             fields = flatten_fieldsets(self.get_fieldsets(request, obj))
678         excluded = self.get_exclude(request, obj)
679         exclude = [] if excluded is None else list(excluded)
680         readonly_fields = self.get_readonly_fields(request, obj)
681         exclude.extend(readonly_fields)
682         # Exclude all fields if it's a change form and the user doesn't have
683         # the change permission.
684         if change and hasattr(request, 'user') and not self.has_change_permission(request, obj):
685             exclude.extend(fields)
686         if excluded is None and hasattr(self.form, '_meta') and self.form._meta.exclude:
687             # Take the custom ModelForm's Meta.exclude into account only if the
688             # ModelAdmin doesn't define its own.
689             exclude.extend(self.form._meta.exclude)
690         # if exclude is an empty list we pass None to be consistent with the
691         # default on modelform_factory
692         exclude = exclude or None
693 
694         # Remove declared form fields which are in readonly_fields.
695         new_attrs = dict.fromkeys(f for f in readonly_fields if f in self.form.declared_fields)
696         form = type(self.form.__name__, (self.form,), new_attrs)
697 
698         defaults = {
699             'form': form,
700             'fields': fields,
701             'exclude': exclude,
702             'formfield_callback': partial(self.formfield_for_dbfield, request=request),
703             **kwargs,
704         }
705 
706         if defaults['fields'] is None and not modelform_defines_fields(defaults['form']):
707             defaults['fields'] = forms.ALL_FIELDS
708 
709         try:
710             return modelform_factory(self.model, **defaults)
711         except FieldError as e:
712             raise FieldError(
713                 '%s. Check fields/fieldsets/exclude attributes of class %s.'
714                 % (e, self.__class__.__name__)
715             )
716 
717     def get_changelist(self, request, **kwargs):
718         """
719         Return the ChangeList class for use on the changelist page.
720         """
721         from django.contrib.admin.views.main import ChangeList
722         return ChangeList
723 
724     def get_changelist_instance(self, request):
725         """
726         Return a `ChangeList` instance based on `request`. May raise
727         `IncorrectLookupParameters`.
728         """
729         list_display = self.get_list_display(request)
730         list_display_links = self.get_list_display_links(request, list_display)
731         # Add the action checkboxes if any actions are available.
732         if self.get_actions(request):
733             list_display = ['action_checkbox', *list_display]
734         sortable_by = self.get_sortable_by(request)
735         ChangeList = self.get_changelist(request)
736         return ChangeList(
737             request,
738             self.model,
739             list_display,
740             list_display_links,
741             self.get_list_filter(request),
742             self.date_hierarchy,
743             self.get_search_fields(request),
744             self.get_list_select_related(request),
745             self.list_per_page,
746             self.list_max_show_all,
747             self.list_editable,
748             self,
749             sortable_by,
750         )
751 
752     def get_object(self, request, object_id, from_field=None):
753         """
754         Return an instance matching the field and value provided, the primary
755         key is used if no field is provided. Return ``None`` if no match is
756         found or the object_id fails validation.
757         """
758         queryset = self.get_queryset(request)
759         model = queryset.model
760         field = model._meta.pk if from_field is None else model._meta.get_field(from_field)
761         try:
762             object_id = field.to_python(object_id)
763             return queryset.get(**{field.name: object_id})
764         except (model.DoesNotExist, ValidationError, ValueError):
765             return None
766 
767     def get_changelist_form(self, request, **kwargs):
768         """
769         Return a Form class for use in the Formset on the changelist page.
770         """
771         defaults = {
772             'formfield_callback': partial(self.formfield_for_dbfield, request=request),
773             **kwargs,
774         }
775         if defaults.get('fields') is None and not modelform_defines_fields(defaults.get('form')):
776             defaults['fields'] = forms.ALL_FIELDS
777 
778         return modelform_factory(self.model, **defaults)
779 
780     def get_changelist_formset(self, request, **kwargs):
781         """
782         Return a FormSet class for use on the changelist page if list_editable
783         is used.
784         """
785         defaults = {
786             'formfield_callback': partial(self.formfield_for_dbfield, request=request),
787             **kwargs,
788         }
789         return modelformset_factory(
790             self.model, self.get_changelist_form(request), extra=0,
791             fields=self.list_editable, **defaults
792         )
793 
794     def get_formsets_with_inlines(self, request, obj=None):
795         """
796         Yield formsets and the corresponding inlines.
797         """
798         for inline in self.get_inline_instances(request, obj):
799             yield inline.get_formset(request, obj), inline
800 
801     def get_paginator(self, request, queryset, per_page, orphans=0, allow_empty_first_page=True):
802         return self.paginator(queryset, per_page, orphans, allow_empty_first_page)
803 
804     def log_addition(self, request, object, message):
805         """
806         Log that an object has been successfully added.
807 
808         The default implementation creates an admin LogEntry object.
809         """
810         from django.contrib.admin.models import ADDITION, LogEntry
811         return LogEntry.objects.log_action(
812             user_id=request.user.pk,
813             content_type_id=get_content_type_for_model(object).pk,
814             object_id=object.pk,
815             object_repr=str(object),
816             action_flag=ADDITION,
817             change_message=message,
818         )
819 
820     def log_change(self, request, object, message):
821         """
822         Log that an object has been successfully changed.
823 
824         The default implementation creates an admin LogEntry object.
825         """
826         from django.contrib.admin.models import CHANGE, LogEntry
827         return LogEntry.objects.log_action(
828             user_id=request.user.pk,
829             content_type_id=get_content_type_for_model(object).pk,
830             object_id=object.pk,
831             object_repr=str(object),
832             action_flag=CHANGE,
833             change_message=message,
834         )
835 
836     def log_deletion(self, request, object, object_repr):
837         """
838         Log that an object will be deleted. Note that this method must be
839         called before the deletion.
840 
841         The default implementation creates an admin LogEntry object.
842         """
843         from django.contrib.admin.models import DELETION, LogEntry
844         return LogEntry.objects.log_action(
845             user_id=request.user.pk,
846             content_type_id=get_content_type_for_model(object).pk,
847             object_id=object.pk,
848             object_repr=object_repr,
849             action_flag=DELETION,
850         )
851 
852     @display(description=mark_safe('<input type="checkbox" id="action-toggle">'))
853     def action_checkbox(self, obj):
854         """
855         A list_display column containing a checkbox widget.
856         """
857         return helpers.checkbox.render(helpers.ACTION_CHECKBOX_NAME, str(obj.pk))
858 
859     @staticmethod
860     def _get_action_description(func, name):
861         return getattr(func, 'short_description', capfirst(name.replace('_', ' ')))
862 
863     def _get_base_actions(self):
864         """Return the list of actions, prior to any request-based filtering."""
865         actions = []
866         base_actions = (self.get_action(action) for action in self.actions or [])
867         # get_action might have returned None, so filter any of those out.
868         base_actions = [action for action in base_actions if action]
869         base_action_names = {name for _, name, _ in base_actions}
870 
871         # Gather actions from the admin site first
872         for (name, func) in self.admin_site.actions:
873             if name in base_action_names:
874                 continue
875             description = self._get_action_description(func, name)
876             actions.append((func, name, description))
877         # Add actions from this ModelAdmin.
878         actions.extend(base_actions)
879         return actions
880 
881     def _filter_actions_by_permissions(self, request, actions):
882         """Filter out any actions that the user doesn't have access to."""
883         filtered_actions = []
884         for action in actions:
885             callable = action[0]
886             if not hasattr(callable, 'allowed_permissions'):
887                 filtered_actions.append(action)
888                 continue
889             permission_checks = (
890                 getattr(self, 'has_%s_permission' % permission)
891                 for permission in callable.allowed_permissions
892             )
893             if any(has_permission(request) for has_permission in permission_checks):
894                 filtered_actions.append(action)
895         return filtered_actions
896 
897     def get_actions(self, request):
898         """
899         Return a dictionary mapping the names of all actions for this
900         ModelAdmin to a tuple of (callable, name, description) for each action.
901         """
902         # If self.actions is set to None that means actions are disabled on
903         # this page.
904         if self.actions is None or IS_POPUP_VAR in request.GET:
905             return {}
906         actions = self._filter_actions_by_permissions(request, self._get_base_actions())
907         return {name: (func, name, desc) for func, name, desc in actions}
908 
909     def get_action_choices(self, request, default_choices=models.BLANK_CHOICE_DASH):
910         """
911         Return a list of choices for use in a form object.  Each choice is a
912         tuple (name, description).
913         """
914         choices = [] + default_choices
915         for func, name, description in self.get_actions(request).values():
916             choice = (name, description % model_format_dict(self.opts))
917             choices.append(choice)
918         return choices
919 
920     def get_action(self, action):
921         """
922         Return a given action from a parameter, which can either be a callable,
923         or the name of a method on the ModelAdmin.  Return is a tuple of
924         (callable, name, description).
925         """
926         # If the action is a callable, just use it.
927         if callable(action):
928             func = action
929             action = action.__name__
930 
931         # Next, look for a method. Grab it off self.__class__ to get an unbound
932         # method instead of a bound one; this ensures that the calling
933         # conventions are the same for functions and methods.
934         elif hasattr(self.__class__, action):
935             func = getattr(self.__class__, action)
936 
937         # Finally, look for a named method on the admin site
938         else:
939             try:
940                 func = self.admin_site.get_action(action)
941             except KeyError:
942                 return None
943 
944         description = self._get_action_description(func, action)
945         return func, action, description
946 
947     def get_list_display(self, request):
948         """
949         Return a sequence containing the fields to be displayed on the
950         changelist.
951         """
952         return self.list_display
953 
954     def get_list_display_links(self, request, list_display):
955         """
956         Return a sequence containing the fields to be displayed as links
957         on the changelist. The list_display parameter is the list of fields
958         returned by get_list_display().
959         """
960         if self.list_display_links or self.list_display_links is None or not list_display:
961             return self.list_display_links
962         else:
963             # Use only the first item in list_display as link
964             return list(list_display)[:1]
965 
966     def get_list_filter(self, request):
967         """
968         Return a sequence containing the fields to be displayed as filters in
969         the right sidebar of the changelist page.
970         """
971         return self.list_filter
972 
973     def get_list_select_related(self, request):
974         """
975         Return a list of fields to add to the select_related() part of the
976         changelist items query.
977         """
978         return self.list_select_related
979 
980     def get_search_fields(self, request):
981         """
982         Return a sequence containing the fields to be searched whenever
983         somebody submits a search query.
984         """
985         return self.search_fields
986 
987     def get_search_results(self, request, queryset, search_term):
988         """
989         Return a tuple containing a queryset to implement the search
990         and a boolean indicating if the results may contain duplicates.
991         """
992         # Apply keyword searches.
993         def construct_search(field_name):
994             if field_name.startswith('^'):
995                 return "%s__istartswith" % field_name[1:]
996             elif field_name.startswith('='):
997                 return "%s__iexact" % field_name[1:]
998             elif field_name.startswith('@'):
999                 return "%s__search" % field_name[1:]
1000             # Use field_name if it includes a lookup.
1001             opts = queryset.model._meta
1002             lookup_fields = field_name.split(LOOKUP_SEP)
1003             # Go through the fields, following all relations.
1004             prev_field = None
1005             for path_part in lookup_fields:
1006                 if path_part == 'pk':
1007                     path_part = opts.pk.name
1008                 try:
1009                     field = opts.get_field(path_part)
1010                 except FieldDoesNotExist:
1011                     # Use valid query lookups.
1012                     if prev_field and prev_field.get_lookup(path_part):
1013                         return field_name
1014                 else:
1015                     prev_field = field
1016                     if hasattr(field, 'get_path_info'):
1017                         # Update opts to follow the relation.
1018                         opts = field.get_path_info()[-1].to_opts
1019             # Otherwise, use the field with icontains.
1020             return "%s__icontains" % field_name
1021 
1022         use_distinct = False
1023         search_fields = self.get_search_fields(request)
1024         if search_fields and search_term:
1025             orm_lookups = [construct_search(str(search_field))
1026                            for search_field in search_fields]
1027             for bit in smart_split(search_term):
1028                 if bit.startswith(('"', "'")) and bit[0] == bit[-1]:
1029                     bit = unescape_string_literal(bit)
1030                 or_queries = [models.Q(**{orm_lookup: bit})
1031                               for orm_lookup in orm_lookups]
1032                 queryset = queryset.filter(reduce(operator.or_, or_queries))
1033             use_distinct |= any(lookup_needs_distinct(self.opts, search_spec) for search_spec in orm_lookups)
1034 
1035         return queryset, use_distinct
1036 
1037     def get_preserved_filters(self, request):
1038         """
1039         Return the preserved filters querystring.
1040         """
1041         match = request.resolver_match
1042         if self.preserve_filters and match:
1043             opts = self.model._meta
1044             current_url = '%s:%s' % (match.app_name, match.url_name)
1045             changelist_url = 'admin:%s_%s_changelist' % (opts.app_label, opts.model_name)
1046             if current_url == changelist_url:
1047                 preserved_filters = request.GET.urlencode()
1048             else:
1049                 preserved_filters = request.GET.get('_changelist_filters')
1050 
1051             if preserved_filters:
1052                 return urlencode({'_changelist_filters': preserved_filters})
1053         return ''
1054 
1055     def construct_change_message(self, request, form, formsets, add=False):
1056         """
1057         Construct a JSON structure describing changes from a changed object.
1058         """
1059         return construct_change_message(form, formsets, add)
1060 
1061     def message_user(self, request, message, level=messages.INFO, extra_tags='',
1062                      fail_silently=False):
1063         """
1064         Send a message to the user. The default implementation
1065         posts a message using the django.contrib.messages backend.
1066 
1067         Exposes almost the same API as messages.add_message(), but accepts the
1068         positional arguments in a different order to maintain backwards
1069         compatibility. For convenience, it accepts the `level` argument as
1070         a string rather than the usual level number.
1071         """
1072         if not isinstance(level, int):
1073             # attempt to get the level if passed a string
1074             try:
1075                 level = getattr(messages.constants, level.upper())
1076             except AttributeError:
1077                 levels = messages.constants.DEFAULT_TAGS.values()
1078                 levels_repr = ', '.join('`%s`' % level for level in levels)
1079                 raise ValueError(
1080                     'Bad message level string: `%s`. Possible values are: %s'
1081                     % (level, levels_repr)
1082                 )
1083 
1084         messages.add_message(request, level, message, extra_tags=extra_tags, fail_silently=fail_silently)
1085 
1086     def save_form(self, request, form, change):
1087         """
1088         Given a ModelForm return an unsaved instance. ``change`` is True if
1089         the object is being changed, and False if it's being added.
1090         """
1091         return form.save(commit=False)
1092 
1093     def save_model(self, request, obj, form, change):
1094         """
1095         Given a model instance save it to the database.
1096         """
1097         obj.save()
1098 
1099     def delete_model(self, request, obj):
1100         """
1101         Given a model instance delete it from the database.
1102         """
1103         obj.delete()
1104 
1105     def delete_queryset(self, request, queryset):
1106         """Given a queryset, delete it from the database."""
1107         queryset.delete()
1108 
1109     def save_formset(self, request, form, formset, change):
1110         """
1111         Given an inline formset save it to the database.
1112         """
1113         formset.save()
1114 
1115     def save_related(self, request, form, formsets, change):
1116         """
1117         Given the ``HttpRequest``, the parent ``ModelForm`` instance, the
1118         list of inline formsets and a boolean value based on whether the
1119         parent is being added or changed, save the related objects to the
1120         database. Note that at this point save_form() and save_model() have
1121         already been called.
1122         """
1123         form.save_m2m()
1124         for formset in formsets:
1125             self.save_formset(request, form, formset, change=change)
1126 
1127     def render_change_form(self, request, context, add=False, change=False, form_url='', obj=None):
1128         opts = self.model._meta
1129         app_label = opts.app_label
1130         preserved_filters = self.get_preserved_filters(request)
1131         form_url = add_preserved_filters({'preserved_filters': preserved_filters, 'opts': opts}, form_url)
1132         view_on_site_url = self.get_view_on_site_url(obj)
1133         has_editable_inline_admin_formsets = False
1134         for inline in context['inline_admin_formsets']:
1135             if inline.has_add_permission or inline.has_change_permission or inline.has_delete_permission:
1136                 has_editable_inline_admin_formsets = True
1137                 break
1138         context.update({
1139             'add': add,
1140             'change': change,
1141             'has_view_permission': self.has_view_permission(request, obj),
1142             'has_add_permission': self.has_add_permission(request),
1143             'has_change_permission': self.has_change_permission(request, obj),
1144             'has_delete_permission': self.has_delete_permission(request, obj),
1145             'has_editable_inline_admin_formsets': has_editable_inline_admin_formsets,
1146             'has_file_field': context['adminform'].form.is_multipart() or any(
1147                 admin_formset.formset.is_multipart()
1148                 for admin_formset in context['inline_admin_formsets']
1149             ),
1150             'has_absolute_url': view_on_site_url is not None,
1151             'absolute_url': view_on_site_url,
1152             'form_url': form_url,
1153             'opts': opts,
1154             'content_type_id': get_content_type_for_model(self.model).pk,
1155             'save_as': self.save_as,
1156             'save_on_top': self.save_on_top,
1157             'to_field_var': TO_FIELD_VAR,
1158             'is_popup_var': IS_POPUP_VAR,
1159             'app_label': app_label,
1160         })
1161         if add and self.add_form_template is not None:
1162             form_template = self.add_form_template
1163         else:
1164             form_template = self.change_form_template
1165 
1166         request.current_app = self.admin_site.name
1167 
1168         return TemplateResponse(request, form_template or [
1169             "admin/%s/%s/change_form.html" % (app_label, opts.model_name),
1170             "admin/%s/change_form.html" % app_label,
1171             "admin/change_form.html"
1172         ], context)
1173 
1174     def response_add(self, request, obj, post_url_continue=None):
1175         """
1176         Determine the HttpResponse for the add_view stage.
1177         """
1178         opts = obj._meta
1179         preserved_filters = self.get_preserved_filters(request)
1180         obj_url = reverse(
1181             'admin:%s_%s_change' % (opts.app_label, opts.model_name),
1182             args=(quote(obj.pk),),
1183             current_app=self.admin_site.name,
1184         )
1185         # Add a link to the object's change form if the user can edit the obj.
1186         if self.has_change_permission(request, obj):
1187             obj_repr = format_html('<a href="{}">{}</a>', urlquote(obj_url), obj)
1188         else:
1189             obj_repr = str(obj)
1190         msg_dict = {
1191             'name': opts.verbose_name,
1192             'obj': obj_repr,
1193         }
1194         # Here, we distinguish between different save types by checking for
1195         # the presence of keys in request.POST.
1196 
1197         if IS_POPUP_VAR in request.POST:
1198             to_field = request.POST.get(TO_FIELD_VAR)
1199             if to_field:
1200                 attr = str(to_field)
1201             else:
1202                 attr = obj._meta.pk.attname
1203             value = obj.serializable_value(attr)
1204             popup_response_data = json.dumps({
1205                 'value': str(value),
1206                 'obj': str(obj),
1207             })
1208             return TemplateResponse(request, self.popup_response_template or [
1209                 'admin/%s/%s/popup_response.html' % (opts.app_label, opts.model_name),
1210                 'admin/%s/popup_response.html' % opts.app_label,
1211                 'admin/popup_response.html',
1212             ], {
1213                 'popup_response_data': popup_response_data,
1214             })
1215 
1216         elif "_continue" in request.POST or (
1217                 # Redirecting after "Save as new".
1218                 "_saveasnew" in request.POST and self.save_as_continue and
1219                 self.has_change_permission(request, obj)
1220         ):
1221             msg = _('The {name} “{obj}” was added successfully.')
1222             if self.has_change_permission(request, obj):
1223                 msg += ' ' + _('You may edit it again below.')
1224             self.message_user(request, format_html(msg, **msg_dict), messages.SUCCESS)
1225             if post_url_continue is None:
1226                 post_url_continue = obj_url
1227             post_url_continue = add_preserved_filters(
1228                 {'preserved_filters': preserved_filters, 'opts': opts},
1229                 post_url_continue
1230             )
1231             return HttpResponseRedirect(post_url_continue)
1232 
1233         elif "_addanother" in request.POST:
1234             msg = format_html(
1235                 _('The {name} “{obj}” was added successfully. You may add another {name} below.'),
1236                 **msg_dict
1237             )
1238             self.message_user(request, msg, messages.SUCCESS)
1239             redirect_url = request.path
1240             redirect_url = add_preserved_filters({'preserved_filters': preserved_filters, 'opts': opts}, redirect_url)
1241             return HttpResponseRedirect(redirect_url)
1242 
1243         else:
1244             msg = format_html(
1245                 _('The {name} “{obj}” was added successfully.'),
1246                 **msg_dict
1247             )
1248             self.message_user(request, msg, messages.SUCCESS)
1249             return self.response_post_save_add(request, obj)
1250 
1251     def response_change(self, request, obj):
1252         """
1253         Determine the HttpResponse for the change_view stage.
1254         """
1255 
1256         if IS_POPUP_VAR in request.POST:
1257             opts = obj._meta
1258             to_field = request.POST.get(TO_FIELD_VAR)
1259             attr = str(to_field) if to_field else opts.pk.attname
1260             value = request.resolver_match.kwargs['object_id']
1261             new_value = obj.serializable_value(attr)
1262             popup_response_data = json.dumps({
1263                 'action': 'change',
1264                 'value': str(value),
1265                 'obj': str(obj),
1266                 'new_value': str(new_value),
1267             })
1268             return TemplateResponse(request, self.popup_response_template or [
1269                 'admin/%s/%s/popup_response.html' % (opts.app_label, opts.model_name),
1270                 'admin/%s/popup_response.html' % opts.app_label,
1271                 'admin/popup_response.html',
1272             ], {
1273                 'popup_response_data': popup_response_data,
1274             })
1275 
1276         opts = self.model._meta
1277         preserved_filters = self.get_preserved_filters(request)
1278 
1279         msg_dict = {
1280             'name': opts.verbose_name,
1281             'obj': format_html('<a href="{}">{}</a>', urlquote(request.path), obj),
1282         }
1283         if "_continue" in request.POST:
1284             msg = format_html(
1285                 _('The {name} “{obj}” was changed successfully. You may edit it again below.'),
1286                 **msg_dict
1287             )
1288             self.message_user(request, msg, messages.SUCCESS)
1289             redirect_url = request.path
1290             redirect_url = add_preserved_filters({'preserved_filters': preserved_filters, 'opts': opts}, redirect_url)
1291             return HttpResponseRedirect(redirect_url)
1292 
1293         elif "_saveasnew" in request.POST:
1294             msg = format_html(
1295                 _('The {name} “{obj}” was added successfully. You may edit it again below.'),
1296                 **msg_dict
1297             )
1298             self.message_user(request, msg, messages.SUCCESS)
1299             redirect_url = reverse('admin:%s_%s_change' %
1300                                    (opts.app_label, opts.model_name),
1301                                    args=(obj.pk,),
1302                                    current_app=self.admin_site.name)
1303             redirect_url = add_preserved_filters({'preserved_filters': preserved_filters, 'opts': opts}, redirect_url)
1304             return HttpResponseRedirect(redirect_url)
1305 
1306         elif "_addanother" in request.POST:
1307             msg = format_html(
1308                 _('The {name} “{obj}” was changed successfully. You may add another {name} below.'),
1309                 **msg_dict
1310             )
1311             self.message_user(request, msg, messages.SUCCESS)
1312             redirect_url = reverse('admin:%s_%s_add' %
1313                                    (opts.app_label, opts.model_name),
1314                                    current_app=self.admin_site.name)
1315             redirect_url = add_preserved_filters({'preserved_filters': preserved_filters, 'opts': opts}, redirect_url)
1316             return HttpResponseRedirect(redirect_url)
1317 
1318         else:
1319             msg = format_html(
1320                 _('The {name} “{obj}” was changed successfully.'),
1321                 **msg_dict
1322             )
1323             self.message_user(request, msg, messages.SUCCESS)
1324             return self.response_post_save_change(request, obj)
1325 
1326     def _response_post_save(self, request, obj):
1327         opts = self.model._meta
1328         if self.has_view_or_change_permission(request):
1329             post_url = reverse('admin:%s_%s_changelist' %
1330                                (opts.app_label, opts.model_name),
1331                                current_app=self.admin_site.name)
1332             preserved_filters = self.get_preserved_filters(request)
1333             post_url = add_preserved_filters({'preserved_filters': preserved_filters, 'opts': opts}, post_url)
1334         else:
1335             post_url = reverse('admin:index',
1336                                current_app=self.admin_site.name)
1337         return HttpResponseRedirect(post_url)
1338 
1339     def response_post_save_add(self, request, obj):
1340         """
1341         Figure out where to redirect after the 'Save' button has been pressed
1342         when adding a new object.
1343         """
1344         return self._response_post_save(request, obj)
1345 
1346     def response_post_save_change(self, request, obj):
1347         """
1348         Figure out where to redirect after the 'Save' button has been pressed
1349         when editing an existing object.
1350         """
1351         return self._response_post_save(request, obj)
1352 
1353     def response_action(self, request, queryset):
1354         """
1355         Handle an admin action. This is called if a request is POSTed to the
1356         changelist; it returns an HttpResponse if the action was handled, and
1357         None otherwise.
1358         """
1359 
1360         # There can be multiple action forms on the page (at the top
1361         # and bottom of the change list, for example). Get the action
1362         # whose button was pushed.
1363         try:
1364             action_index = int(request.POST.get('index', 0))
1365         except ValueError:
1366             action_index = 0
1367 
1368         # Construct the action form.
1369         data = request.POST.copy()
1370         data.pop(helpers.ACTION_CHECKBOX_NAME, None)
1371         data.pop("index", None)
1372 
1373         # Use the action whose button was pushed
1374         try:
1375             data.update({'action': data.getlist('action')[action_index]})
1376         except IndexError:
1377             # If we didn't get an action from the chosen form that's invalid
1378             # POST data, so by deleting action it'll fail the validation check
1379             # below. So no need to do anything here
1380             pass
1381 
1382         action_form = self.action_form(data, auto_id=None)
1383         action_form.fields['action'].choices = self.get_action_choices(request)
1384 
1385         # If the form's valid we can handle the action.
1386         if action_form.is_valid():
1387             action = action_form.cleaned_data['action']
1388             select_across = action_form.cleaned_data['select_across']
1389             func = self.get_actions(request)[action][0]
1390 
1391             # Get the list of selected PKs. If nothing's selected, we can't
1392             # perform an action on it, so bail. Except we want to perform
1393             # the action explicitly on all objects.
1394             selected = request.POST.getlist(helpers.ACTION_CHECKBOX_NAME)
1395             if not selected and not select_across:
1396                 # Reminder that something needs to be selected or nothing will happen
1397                 msg = _("Items must be selected in order to perform "
1398                         "actions on them. No items have been changed.")
1399                 self.message_user(request, msg, messages.WARNING)
1400                 return None
1401 
1402             if not select_across:
1403                 # Perform the action only on the selected objects
1404                 queryset = queryset.filter(pk__in=selected)
1405 
1406             response = func(self, request, queryset)
1407 
1408             # Actions may return an HttpResponse-like object, which will be
1409             # used as the response from the POST. If not, we'll be a good
1410             # little HTTP citizen and redirect back to the changelist page.
1411             if isinstance(response, HttpResponseBase):
1412                 return response
1413             else:
1414                 return HttpResponseRedirect(request.get_full_path())
1415         else:
1416             msg = _("No action selected.")
1417             self.message_user(request, msg, messages.WARNING)
1418             return None
1419 
1420     def response_delete(self, request, obj_display, obj_id):
1421         """
1422         Determine the HttpResponse for the delete_view stage.
1423         """
1424         opts = self.model._meta
1425 
1426         if IS_POPUP_VAR in request.POST:
1427             popup_response_data = json.dumps({
1428                 'action': 'delete',
1429                 'value': str(obj_id),
1430             })
1431             return TemplateResponse(request, self.popup_response_template or [
1432                 'admin/%s/%s/popup_response.html' % (opts.app_label, opts.model_name),
1433                 'admin/%s/popup_response.html' % opts.app_label,
1434                 'admin/popup_response.html',
1435             ], {
1436                 'popup_response_data': popup_response_data,
1437             })
1438 
1439         self.message_user(
1440             request,
1441             _('The %(name)s “%(obj)s” was deleted successfully.') % {
1442                 'name': opts.verbose_name,
1443                 'obj': obj_display,
1444             },
1445             messages.SUCCESS,
1446         )
1447 
1448         if self.has_change_permission(request, None):
1449             post_url = reverse(
1450                 'admin:%s_%s_changelist' % (opts.app_label, opts.model_name),
1451                 current_app=self.admin_site.name,
1452             )
1453             preserved_filters = self.get_preserved_filters(request)
1454             post_url = add_preserved_filters(
1455                 {'preserved_filters': preserved_filters, 'opts': opts}, post_url
1456             )
1457         else:
1458             post_url = reverse('admin:index', current_app=self.admin_site.name)
1459         return HttpResponseRedirect(post_url)
1460 
1461     def render_delete_form(self, request, context):
1462         opts = self.model._meta
1463         app_label = opts.app_label
1464 
1465         request.current_app = self.admin_site.name
1466         context.update(
1467             to_field_var=TO_FIELD_VAR,
1468             is_popup_var=IS_POPUP_VAR,
1469             media=self.media,
1470         )
1471 
1472         return TemplateResponse(
1473             request,
1474             self.delete_confirmation_template or [
1475                 "admin/{}/{}/delete_confirmation.html".format(app_label, opts.model_name),
1476                 "admin/{}/delete_confirmation.html".format(app_label),
1477                 "admin/delete_confirmation.html",
1478             ],
1479             context,
1480         )
1481 
1482     def get_inline_formsets(self, request, formsets, inline_instances, obj=None):
1483         # Edit permissions on parent model are required for editable inlines.
1484         can_edit_parent = self.has_change_permission(request, obj) if obj else self.has_add_permission(request)
1485         inline_admin_formsets = []
1486         for inline, formset in zip(inline_instances, formsets):
1487             fieldsets = list(inline.get_fieldsets(request, obj))
1488             readonly = list(inline.get_readonly_fields(request, obj))
1489             if can_edit_parent:
1490                 has_add_permission = inline.has_add_permission(request, obj)
1491                 has_change_permission = inline.has_change_permission(request, obj)
1492                 has_delete_permission = inline.has_delete_permission(request, obj)
1493             else:
1494                 # Disable all edit-permissions, and overide formset settings.
1495                 has_add_permission = has_change_permission = has_delete_permission = False
1496                 formset.extra = formset.max_num = 0
1497             has_view_permission = inline.has_view_permission(request, obj)
1498             prepopulated = dict(inline.get_prepopulated_fields(request, obj))
1499             inline_admin_formset = helpers.InlineAdminFormSet(
1500                 inline, formset, fieldsets, prepopulated, readonly, model_admin=self,
1501                 has_add_permission=has_add_permission, has_change_permission=has_change_permission,
1502                 has_delete_permission=has_delete_permission, has_view_permission=has_view_permission,
1503             )
1504             inline_admin_formsets.append(inline_admin_formset)
1505         return inline_admin_formsets
1506 
1507     def get_changeform_initial_data(self, request):
1508         """
1509         Get the initial form data from the request's GET params.
1510         """
1511         initial = dict(request.GET.items())
1512         for k in initial:
1513             try:
1514                 f = self.model._meta.get_field(k)
1515             except FieldDoesNotExist:
1516                 continue
1517             # We have to special-case M2Ms as a list of comma-separated PKs.
1518             if isinstance(f, models.ManyToManyField):
1519                 initial[k] = initial[k].split(",")
1520         return initial
1521 
1522     def _get_obj_does_not_exist_redirect(self, request, opts, object_id):
1523         """
1524         Create a message informing the user that the object doesn't exist
1525         and return a redirect to the admin index page.
1526         """
1527         msg = _('%(name)s with ID “%(key)s” doesn’t exist. Perhaps it was deleted?') % {
1528             'name': opts.verbose_name,
1529             'key': unquote(object_id),
1530         }
1531         self.message_user(request, msg, messages.WARNING)
1532         url = reverse('admin:index', current_app=self.admin_site.name)
1533         return HttpResponseRedirect(url)
1534 
1535     @csrf_protect_m
1536     def changeform_view(self, request, object_id=None, form_url='', extra_context=None):
1537         with transaction.atomic(using=router.db_for_write(self.model)):
1538             return self._changeform_view(request, object_id, form_url, extra_context)
1539 
1540     def _changeform_view(self, request, object_id, form_url, extra_context):
1541         to_field = request.POST.get(TO_FIELD_VAR, request.GET.get(TO_FIELD_VAR))
1542         if to_field and not self.to_field_allowed(request, to_field):
1543             raise DisallowedModelAdminToField("The field %s cannot be referenced." % to_field)
1544 
1545         model = self.model
1546         opts = model._meta
1547 
1548         if request.method == 'POST' and '_saveasnew' in request.POST:
1549             object_id = None
1550 
1551         add = object_id is None
1552 
1553         if add:
1554             if not self.has_add_permission(request):
1555                 raise PermissionDenied
1556             obj = None
1557 
1558         else:
1559             obj = self.get_object(request, unquote(object_id), to_field)
1560 
1561             if request.method == 'POST':
1562                 if not self.has_change_permission(request, obj):
1563                     raise PermissionDenied
1564             else:
1565                 if not self.has_view_or_change_permission(request, obj):
1566                     raise PermissionDenied
1567 
1568             if obj is None:
1569                 return self._get_obj_does_not_exist_redirect(request, opts, object_id)
1570 
1571         fieldsets = self.get_fieldsets(request, obj)
1572         ModelForm = self.get_form(
1573             request, obj, change=not add, fields=flatten_fieldsets(fieldsets)
1574         )
1575         if request.method == 'POST':
1576             form = ModelForm(request.POST, request.FILES, instance=obj)
1577             form_validated = form.is_valid()
1578             if form_validated:
1579                 new_object = self.save_form(request, form, change=not add)
1580             else:
1581                 new_object = form.instance
1582             formsets, inline_instances = self._create_formsets(request, new_object, change=not add)
1583             if all_valid(formsets) and form_validated:
1584                 self.save_model(request, new_object, form, not add)
1585                 self.save_related(request, form, formsets, not add)
1586                 change_message = self.construct_change_message(request, form, formsets, add)
1587                 if add:
1588                     self.log_addition(request, new_object, change_message)
1589                     return self.response_add(request, new_object)
1590                 else:
1591                     self.log_change(request, new_object, change_message)
1592                     return self.response_change(request, new_object)
1593             else:
1594                 form_validated = False
1595         else:
1596             if add:
1597                 initial = self.get_changeform_initial_data(request)
1598                 form = ModelForm(initial=initial)
1599                 formsets, inline_instances = self._create_formsets(request, form.instance, change=False)
1600             else:
1601                 form = ModelForm(instance=obj)
1602                 formsets, inline_instances = self._create_formsets(request, obj, change=True)
1603 
1604         if not add and not self.has_change_permission(request, obj):
1605             readonly_fields = flatten_fieldsets(fieldsets)
1606         else:
1607             readonly_fields = self.get_readonly_fields(request, obj)
1608         adminForm = helpers.AdminForm(
1609             form,
1610             list(fieldsets),
1611             # Clear prepopulated fields on a view-only form to avoid a crash.
1612             self.get_prepopulated_fields(request, obj) if add or self.has_change_permission(request, obj) else {},
1613             readonly_fields,
1614             model_admin=self)
1615         media = self.media + adminForm.media
1616 
1617         inline_formsets = self.get_inline_formsets(request, formsets, inline_instances, obj)
1618         for inline_formset in inline_formsets:
1619             media = media + inline_formset.media
1620 
1621         if add:
1622             title = _('Add %s')
1623         elif self.has_change_permission(request, obj):
1624             title = _('Change %s')
1625         else:
1626             title = _('View %s')
1627         context = {
1628             **self.admin_site.each_context(request),
1629             'title': title % opts.verbose_name,
1630             'subtitle': str(obj) if obj else None,
1631             'adminform': adminForm,
1632             'object_id': object_id,
1633             'original': obj,
1634             'is_popup': IS_POPUP_VAR in request.POST or IS_POPUP_VAR in request.GET,
1635             'to_field': to_field,
1636             'media': media,
1637             'inline_admin_formsets': inline_formsets,
1638             'errors': helpers.AdminErrorList(form, formsets),
1639             'preserved_filters': self.get_preserved_filters(request),
1640         }
1641 
1642         # Hide the "Save" and "Save and continue" buttons if "Save as New" was
1643         # previously chosen to prevent the interface from getting confusing.
1644         if request.method == 'POST' and not form_validated and "_saveasnew" in request.POST:
1645             context['show_save'] = False
1646             context['show_save_and_continue'] = False
1647             # Use the change template instead of the add template.
1648             add = False
1649 
1650         context.update(extra_context or {})
1651 
1652         return self.render_change_form(request, context, add=add, change=not add, obj=obj, form_url=form_url)
1653 
1654     def add_view(self, request, form_url='', extra_context=None):
1655         return self.changeform_view(request, None, form_url, extra_context)
1656 
1657     def change_view(self, request, object_id, form_url='', extra_context=None):
1658         return self.changeform_view(request, object_id, form_url, extra_context)
1659 
1660     def _get_edited_object_pks(self, request, prefix):
1661         """Return POST data values of list_editable primary keys."""
1662         pk_pattern = re.compile(
1663             r'{}-\d+-{}$'.format(re.escape(prefix), self.model._meta.pk.name)
1664         )
1665         return [value for key, value in request.POST.items() if pk_pattern.match(key)]
1666 
1667     def _get_list_editable_queryset(self, request, prefix):
1668         """
1669         Based on POST data, return a queryset of the objects that were edited
1670         via list_editable.
1671         """
1672         object_pks = self._get_edited_object_pks(request, prefix)
1673         queryset = self.get_queryset(request)
1674         validate = queryset.model._meta.pk.to_python
1675         try:
1676             for pk in object_pks:
1677                 validate(pk)
1678         except ValidationError:
1679             # Disable the optimization if the POST data was tampered with.
1680             return queryset
1681         return queryset.filter(pk__in=object_pks)
1682 
1683     @csrf_protect_m
1684     def changelist_view(self, request, extra_context=None):
1685         """
1686         The 'change list' admin view for this model.
1687         """
1688         from django.contrib.admin.views.main import ERROR_FLAG
1689         opts = self.model._meta
1690         app_label = opts.app_label
1691         if not self.has_view_or_change_permission(request):
1692             raise PermissionDenied
1693 
1694         try:
1695             cl = self.get_changelist_instance(request)
1696         except IncorrectLookupParameters:
1697             # Wacky lookup parameters were given, so redirect to the main
1698             # changelist page, without parameters, and pass an 'invalid=1'
1699             # parameter via the query string. If wacky parameters were given
1700             # and the 'invalid=1' parameter was already in the query string,
1701             # something is screwed up with the database, so display an error
1702             # page.
1703             if ERROR_FLAG in request.GET:
1704                 return SimpleTemplateResponse('admin/invalid_setup.html', {
1705                     'title': _('Database error'),
1706                 })
1707             return HttpResponseRedirect(request.path + '?' + ERROR_FLAG + '=1')
1708 
1709         # If the request was POSTed, this might be a bulk action or a bulk
1710         # edit. Try to look up an action or confirmation first, but if this
1711         # isn't an action the POST will fall through to the bulk edit check,
1712         # below.
1713         action_failed = False
1714         selected = request.POST.getlist(helpers.ACTION_CHECKBOX_NAME)
1715 
1716         actions = self.get_actions(request)
1717         # Actions with no confirmation
1718         if (actions and request.method == 'POST' and
1719                 'index' in request.POST and '_save' not in request.POST):
1720             if selected:
1721                 response = self.response_action(request, queryset=cl.get_queryset(request))
1722                 if response:
1723                     return response
1724                 else:
1725                     action_failed = True
1726             else:
1727                 msg = _("Items must be selected in order to perform "
1728                         "actions on them. No items have been changed.")
1729                 self.message_user(request, msg, messages.WARNING)
1730                 action_failed = True
1731 
1732         # Actions with confirmation
1733         if (actions and request.method == 'POST' and
1734                 helpers.ACTION_CHECKBOX_NAME in request.POST and
1735                 'index' not in request.POST and '_save' not in request.POST):
1736             if selected:
1737                 response = self.response_action(request, queryset=cl.get_queryset(request))
1738                 if response:
1739                     return response
1740                 else:
1741                     action_failed = True
1742 
1743         if action_failed:
1744             # Redirect back to the changelist page to avoid resubmitting the
1745             # form if the user refreshes the browser or uses the "No, take
1746             # me back" button on the action confirmation page.
1747             return HttpResponseRedirect(request.get_full_path())
1748 
1749         # If we're allowing changelist editing, we need to construct a formset
1750         # for the changelist given all the fields to be edited. Then we'll
1751         # use the formset to validate/process POSTed data.
1752         formset = cl.formset = None
1753 
1754         # Handle POSTed bulk-edit data.
1755         if request.method == 'POST' and cl.list_editable and '_save' in request.POST:
1756             if not self.has_change_permission(request):
1757                 raise PermissionDenied
1758             FormSet = self.get_changelist_formset(request)
1759             modified_objects = self._get_list_editable_queryset(request, FormSet.get_default_prefix())
1760             formset = cl.formset = FormSet(request.POST, request.FILES, queryset=modified_objects)
1761             if formset.is_valid():
1762                 changecount = 0
1763                 for form in formset.forms:
1764                     if form.has_changed():
1765                         obj = self.save_form(request, form, change=True)
1766                         self.save_model(request, obj, form, change=True)
1767                         self.save_related(request, form, formsets=[], change=True)
1768                         change_msg = self.construct_change_message(request, form, None)
1769                         self.log_change(request, obj, change_msg)
1770                         changecount += 1
1771 
1772                 if changecount:
1773                     msg = ngettext(
1774                         "%(count)s %(name)s was changed successfully.",
1775                         "%(count)s %(name)s were changed successfully.",
1776                         changecount
1777                     ) % {
1778                         'count': changecount,
1779                         'name': model_ngettext(opts, changecount),
1780                     }
1781                     self.message_user(request, msg, messages.SUCCESS)
1782 
1783                 return HttpResponseRedirect(request.get_full_path())
1784 
1785         # Handle GET -- construct a formset for display.
1786         elif cl.list_editable and self.has_change_permission(request):
1787             FormSet = self.get_changelist_formset(request)
1788             formset = cl.formset = FormSet(queryset=cl.result_list)
1789 
1790         # Build the list of media to be used by the formset.
1791         if formset:
1792             media = self.media + formset.media
1793         else:
1794             media = self.media
1795 
1796         # Build the action form and populate it with available actions.
1797         if actions:
1798             action_form = self.action_form(auto_id=None)
1799             action_form.fields['action'].choices = self.get_action_choices(request)
1800             media += action_form.media
1801         else:
1802             action_form = None
1803 
1804         selection_note_all = ngettext(
1805             '%(total_count)s selected',
1806             'All %(total_count)s selected',
1807             cl.result_count
1808         )
1809 
1810         context = {
1811             **self.admin_site.each_context(request),
1812             'module_name': str(opts.verbose_name_plural),
1813             'selection_note': _('0 of %(cnt)s selected') % {'cnt': len(cl.result_list)},
1814             'selection_note_all': selection_note_all % {'total_count': cl.result_count},
1815             'title': cl.title,
1816             'subtitle': None,
1817             'is_popup': cl.is_popup,
1818             'to_field': cl.to_field,
1819             'cl': cl,
1820             'media': media,
1821             'has_add_permission': self.has_add_permission(request),
1822             'opts': cl.opts,
1823             'action_form': action_form,
1824             'actions_on_top': self.actions_on_top,
1825             'actions_on_bottom': self.actions_on_bottom,
1826             'actions_selection_counter': self.actions_selection_counter,
1827             'preserved_filters': self.get_preserved_filters(request),
1828             **(extra_context or {}),
1829         }
1830 
1831         request.current_app = self.admin_site.name
1832 
1833         return TemplateResponse(request, self.change_list_template or [
1834             'admin/%s/%s/change_list.html' % (app_label, opts.model_name),
1835             'admin/%s/change_list.html' % app_label,
1836             'admin/change_list.html'
1837         ], context)
1838 
1839     def get_deleted_objects(self, objs, request):
1840         """
1841         Hook for customizing the delete process for the delete view and the
1842         "delete selected" action.
1843         """
1844         return get_deleted_objects(objs, request, self.admin_site)
1845 
1846     @csrf_protect_m
1847     def delete_view(self, request, object_id, extra_context=None):
1848         with transaction.atomic(using=router.db_for_write(self.model)):
1849             return self._delete_view(request, object_id, extra_context)
1850 
1851     def _delete_view(self, request, object_id, extra_context):
1852         "The 'delete' admin view for this model."
1853         opts = self.model._meta
1854         app_label = opts.app_label
1855 
1856         to_field = request.POST.get(TO_FIELD_VAR, request.GET.get(TO_FIELD_VAR))
1857         if to_field and not self.to_field_allowed(request, to_field):
1858             raise DisallowedModelAdminToField("The field %s cannot be referenced." % to_field)
1859 
1860         obj = self.get_object(request, unquote(object_id), to_field)
1861 
1862         if not self.has_delete_permission(request, obj):
1863             raise PermissionDenied
1864 
1865         if obj is None:
1866             return self._get_obj_does_not_exist_redirect(request, opts, object_id)
1867 
1868         # Populate deleted_objects, a data structure of all related objects that
1869         # will also be deleted.
1870         deleted_objects, model_count, perms_needed, protected = self.get_deleted_objects([obj], request)
1871 
1872         if request.POST and not protected:  # The user has confirmed the deletion.
1873             if perms_needed:
1874                 raise PermissionDenied
1875             obj_display = str(obj)
1876             attr = str(to_field) if to_field else opts.pk.attname
1877             obj_id = obj.serializable_value(attr)
1878             self.log_deletion(request, obj, obj_display)
1879             self.delete_model(request, obj)
1880 
1881             return self.response_delete(request, obj_display, obj_id)
1882 
1883         object_name = str(opts.verbose_name)
1884 
1885         if perms_needed or protected:
1886             title = _("Cannot delete %(name)s") % {"name": object_name}
1887         else:
1888             title = _("Are you sure?")
1889 
1890         context = {
1891             **self.admin_site.each_context(request),
1892             'title': title,
1893             'subtitle': None,
1894             'object_name': object_name,
1895             'object': obj,
1896             'deleted_objects': deleted_objects,
1897             'model_count': dict(model_count).items(),
1898             'perms_lacking': perms_needed,
1899             'protected': protected,
1900             'opts': opts,
1901             'app_label': app_label,
1902             'preserved_filters': self.get_preserved_filters(request),
1903             'is_popup': IS_POPUP_VAR in request.POST or IS_POPUP_VAR in request.GET,
1904             'to_field': to_field,
1905             **(extra_context or {}),
1906         }
1907 
1908         return self.render_delete_form(request, context)
1909 
1910     def history_view(self, request, object_id, extra_context=None):
1911         "The 'history' admin view for this model."
1912         from django.contrib.admin.models import LogEntry
1913 
1914         # First check if the user can see this history.
1915         model = self.model
1916         obj = self.get_object(request, unquote(object_id))
1917         if obj is None:
1918             return self._get_obj_does_not_exist_redirect(request, model._meta, object_id)
1919 
1920         if not self.has_view_or_change_permission(request, obj):
1921             raise PermissionDenied
1922 
1923         # Then get the history for this object.
1924         opts = model._meta
1925         app_label = opts.app_label
1926         action_list = LogEntry.objects.filter(
1927             object_id=unquote(object_id),
1928             content_type=get_content_type_for_model(model)
1929         ).select_related().order_by('action_time')
1930 
1931         context = {
1932             **self.admin_site.each_context(request),
1933             'title': _('Change history: %s') % obj,
1934             'subtitle': None,
1935             'action_list': action_list,
1936             'module_name': str(capfirst(opts.verbose_name_plural)),
1937             'object': obj,
1938             'opts': opts,
1939             'preserved_filters': self.get_preserved_filters(request),
1940             **(extra_context or {}),
1941         }
1942 
1943         request.current_app = self.admin_site.name
1944 
1945         return TemplateResponse(request, self.object_history_template or [
1946             "admin/%s/%s/object_history.html" % (app_label, opts.model_name),
1947             "admin/%s/object_history.html" % app_label,
1948             "admin/object_history.html"
1949         ], context)
1950 
1951     def get_formset_kwargs(self, request, obj, inline, prefix):
1952         formset_params = {
1953             'instance': obj,
1954             'prefix': prefix,
1955             'queryset': inline.get_queryset(request),
1956         }
1957         if request.method == 'POST':
1958             formset_params.update({
1959                 'data': request.POST.copy(),
1960                 'files': request.FILES,
1961                 'save_as_new': '_saveasnew' in request.POST
1962             })
1963         return formset_params
1964 
1965     def _create_formsets(self, request, obj, change):
1966         "Helper function to generate formsets for add/change_view."
1967         formsets = []
1968         inline_instances = []
1969         prefixes = {}
1970         get_formsets_args = [request]
1971         if change:
1972             get_formsets_args.append(obj)
1973         for FormSet, inline in self.get_formsets_with_inlines(*get_formsets_args):
1974             prefix = FormSet.get_default_prefix()
1975             prefixes[prefix] = prefixes.get(prefix, 0) + 1
1976             if prefixes[prefix] != 1 or not prefix:
1977                 prefix = "%s-%s" % (prefix, prefixes[prefix])
1978             formset_params = self.get_formset_kwargs(request, obj, inline, prefix)
1979             formset = FormSet(**formset_params)
1980 
1981             def user_deleted_form(request, obj, formset, index):
1982                 """Return whether or not the user deleted the form."""
1983                 return (
1984                     inline.has_delete_permission(request, obj) and
1985                     '{}-{}-DELETE'.format(formset.prefix, index) in request.POST
1986                 )
1987 
1988             # Bypass validation of each view-only inline form (since the form's
1989             # data won't be in request.POST), unless the form was deleted.
1990             if not inline.has_change_permission(request, obj if change else None):
1991                 for index, form in enumerate(formset.initial_forms):
1992                     if user_deleted_form(request, obj, formset, index):
1993                         continue
1994                     form._errors = {}
1995                     form.cleaned_data = form.initial
1996             formsets.append(formset)
1997             inline_instances.append(inline)
1998         return formsets, inline_instances

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>, <file>django/contrib/admin/views/main.py</file>
<class>None</class>
<method>None</method>
<code>
1 from datetime import datetime, timedelta
2 
3 from django import forms
4 from django.conf import settings
5 from django.contrib import messages
6 from django.contrib.admin import FieldListFilter
7 from django.contrib.admin.exceptions import (
8     DisallowedModelAdminLookup, DisallowedModelAdminToField,
9 )
10 from django.contrib.admin.options import (
11     IS_POPUP_VAR, TO_FIELD_VAR, IncorrectLookupParameters,
12 )
13 from django.contrib.admin.utils import (
14     get_fields_from_path, lookup_needs_distinct, prepare_lookup_value, quote,
15 )
16 from django.core.exceptions import (
17     FieldDoesNotExist, ImproperlyConfigured, SuspiciousOperation,
18 )
19 from django.core.paginator import InvalidPage
20 from django.db.models import F, Field, ManyToOneRel, OrderBy
21 from django.db.models.expressions import Combinable
22 from django.urls import reverse
23 from django.utils.http import urlencode
24 from django.utils.timezone import make_aware
25 from django.utils.translation import gettext
26 
27 # Changelist settings
28 ALL_VAR = 'all'
29 ORDER_VAR = 'o'
30 ORDER_TYPE_VAR = 'ot'
31 PAGE_VAR = 'p'
32 SEARCH_VAR = 'q'
33 ERROR_FLAG = 'e'
34 
35 IGNORED_PARAMS = (
36     ALL_VAR, ORDER_VAR, ORDER_TYPE_VAR, SEARCH_VAR, IS_POPUP_VAR, TO_FIELD_VAR)
37 
38 
39 class ChangeListSearchForm(forms.Form):
40     def __init__(self, *args, **kwargs):
41         super().__init__(*args, **kwargs)
42         # Populate "fields" dynamically because SEARCH_VAR is a variable:
43         self.fields = {
44             SEARCH_VAR: forms.CharField(required=False, strip=False),
45         }
46 
47 
48 class ChangeList:
49     search_form_class = ChangeListSearchForm
50 
51     def __init__(self, request, model, list_display, list_display_links,
52                  list_filter, date_hierarchy, search_fields, list_select_related,
53                  list_per_page, list_max_show_all, list_editable, model_admin, sortable_by):
54         self.model = model
55         self.opts = model._meta
56         self.lookup_opts = self.opts
57         self.root_queryset = model_admin.get_queryset(request)
58         self.list_display = list_display
59         self.list_display_links = list_display_links
60         self.list_filter = list_filter
61         self.has_filters = None
62         self.has_active_filters = None
63         self.clear_all_filters_qs = None
64         self.date_hierarchy = date_hierarchy
65         self.search_fields = search_fields
66         self.list_select_related = list_select_related
67         self.list_per_page = list_per_page
68         self.list_max_show_all = list_max_show_all
69         self.model_admin = model_admin
70         self.preserved_filters = model_admin.get_preserved_filters(request)
71         self.sortable_by = sortable_by
72 
73         # Get search parameters from the query string.
74         _search_form = self.search_form_class(request.GET)
75         if not _search_form.is_valid():
76             for error in _search_form.errors.values():
77                 messages.error(request, ', '.join(error))
78         self.query = _search_form.cleaned_data.get(SEARCH_VAR) or ''
79         try:
80             self.page_num = int(request.GET.get(PAGE_VAR, 1))
81         except ValueError:
82             self.page_num = 1
83         self.show_all = ALL_VAR in request.GET
84         self.is_popup = IS_POPUP_VAR in request.GET
85         to_field = request.GET.get(TO_FIELD_VAR)
86         if to_field and not model_admin.to_field_allowed(request, to_field):
87             raise DisallowedModelAdminToField("The field %s cannot be referenced." % to_field)
88         self.to_field = to_field
89         self.params = dict(request.GET.items())
90         if PAGE_VAR in self.params:
91             del self.params[PAGE_VAR]
92         if ERROR_FLAG in self.params:
93             del self.params[ERROR_FLAG]
94 
95         if self.is_popup:
96             self.list_editable = ()
97         else:
98             self.list_editable = list_editable
99         self.queryset = self.get_queryset(request)
100         self.get_results(request)
101         if self.is_popup:
102             title = gettext('Select %s')
103         elif self.model_admin.has_change_permission(request):
104             title = gettext('Select %s to change')
105         else:
106             title = gettext('Select %s to view')
107         self.title = title % self.opts.verbose_name
108         self.pk_attname = self.lookup_opts.pk.attname
109 
110     def get_filters_params(self, params=None):
111         """
112         Return all params except IGNORED_PARAMS.
113         """
114         params = params or self.params
115         lookup_params = params.copy()  # a dictionary of the query string
116         # Remove all the parameters that are globally and systematically
117         # ignored.
118         for ignored in IGNORED_PARAMS:
119             if ignored in lookup_params:
120                 del lookup_params[ignored]
121         return lookup_params
122 
123     def get_filters(self, request):
124         lookup_params = self.get_filters_params()
125         use_distinct = False
126         has_active_filters = False
127 
128         for key, value in lookup_params.items():
129             if not self.model_admin.lookup_allowed(key, value):
130                 raise DisallowedModelAdminLookup("Filtering by %s not allowed" % key)
131 
132         filter_specs = []
133         for list_filter in self.list_filter:
134             lookup_params_count = len(lookup_params)
135             if callable(list_filter):
136                 # This is simply a custom list filter class.
137                 spec = list_filter(request, lookup_params, self.model, self.model_admin)
138             else:
139                 field_path = None
140                 if isinstance(list_filter, (tuple, list)):
141                     # This is a custom FieldListFilter class for a given field.
142                     field, field_list_filter_class = list_filter
143                 else:
144                     # This is simply a field name, so use the default
145                     # FieldListFilter class that has been registered for the
146                     # type of the given field.
147                     field, field_list_filter_class = list_filter, FieldListFilter.create
148                 if not isinstance(field, Field):
149                     field_path = field
150                     field = get_fields_from_path(self.model, field_path)[-1]
151 
152                 spec = field_list_filter_class(
153                     field, request, lookup_params,
154                     self.model, self.model_admin, field_path=field_path,
155                 )
156                 # field_list_filter_class removes any lookup_params it
157                 # processes. If that happened, check if distinct() is needed to
158                 # remove duplicate results.
159                 if lookup_params_count > len(lookup_params):
160                     use_distinct = use_distinct or lookup_needs_distinct(self.lookup_opts, field_path)
161             if spec and spec.has_output():
162                 filter_specs.append(spec)
163                 if lookup_params_count > len(lookup_params):
164                     has_active_filters = True
165 
166         if self.date_hierarchy:
167             # Create bounded lookup parameters so that the query is more
168             # efficient.
169             year = lookup_params.pop('%s__year' % self.date_hierarchy, None)
170             if year is not None:
171                 month = lookup_params.pop('%s__month' % self.date_hierarchy, None)
172                 day = lookup_params.pop('%s__day' % self.date_hierarchy, None)
173                 try:
174                     from_date = datetime(
175                         int(year),
176                         int(month if month is not None else 1),
177                         int(day if day is not None else 1),
178                     )
179                 except ValueError as e:
180                     raise IncorrectLookupParameters(e) from e
181                 if day:
182                     to_date = from_date + timedelta(days=1)
183                 elif month:
184                     # In this branch, from_date will always be the first of a
185                     # month, so advancing 32 days gives the next month.
186                     to_date = (from_date + timedelta(days=32)).replace(day=1)
187                 else:
188                     to_date = from_date.replace(year=from_date.year + 1)
189                 if settings.USE_TZ:
190                     from_date = make_aware(from_date)
191                     to_date = make_aware(to_date)
192                 lookup_params.update({
193                     '%s__gte' % self.date_hierarchy: from_date,
194                     '%s__lt' % self.date_hierarchy: to_date,
195                 })
196 
197         # At this point, all the parameters used by the various ListFilters
198         # have been removed from lookup_params, which now only contains other
199         # parameters passed via the query string. We now loop through the
200         # remaining parameters both to ensure that all the parameters are valid
201         # fields and to determine if at least one of them needs distinct(). If
202         # the lookup parameters aren't real fields, then bail out.
203         try:
204             for key, value in lookup_params.items():
205                 lookup_params[key] = prepare_lookup_value(key, value)
206                 use_distinct = use_distinct or lookup_needs_distinct(self.lookup_opts, key)
207             return (
208                 filter_specs, bool(filter_specs), lookup_params, use_distinct,
209                 has_active_filters,
210             )
211         except FieldDoesNotExist as e:
212             raise IncorrectLookupParameters(e) from e
213 
214     def get_query_string(self, new_params=None, remove=None):
215         if new_params is None:
216             new_params = {}
217         if remove is None:
218             remove = []
219         p = self.params.copy()
220         for r in remove:
221             for k in list(p):
222                 if k.startswith(r):
223                     del p[k]
224         for k, v in new_params.items():
225             if v is None:
226                 if k in p:
227                     del p[k]
228             else:
229                 p[k] = v
230         return '?%s' % urlencode(sorted(p.items()))
231 
232     def get_results(self, request):
233         paginator = self.model_admin.get_paginator(request, self.queryset, self.list_per_page)
234         # Get the number of objects, with admin filters applied.
235         result_count = paginator.count
236 
237         # Get the total number of objects, with no admin filters applied.
238         if self.model_admin.show_full_result_count:
239             full_result_count = self.root_queryset.count()
240         else:
241             full_result_count = None
242         can_show_all = result_count <= self.list_max_show_all
243         multi_page = result_count > self.list_per_page
244 
245         # Get the list of objects to display on this page.
246         if (self.show_all and can_show_all) or not multi_page:
247             result_list = self.queryset._clone()
248         else:
249             try:
250                 result_list = paginator.page(self.page_num).object_list
251             except InvalidPage:
252                 raise IncorrectLookupParameters
253 
254         self.result_count = result_count
255         self.show_full_result_count = self.model_admin.show_full_result_count
256         # Admin actions are shown if there is at least one entry
257         # or if entries are not counted because show_full_result_count is disabled
258         self.show_admin_actions = not self.show_full_result_count or bool(full_result_count)
259         self.full_result_count = full_result_count
260         self.result_list = result_list
261         self.can_show_all = can_show_all
262         self.multi_page = multi_page
263         self.paginator = paginator
264 
265     def _get_default_ordering(self):
266         ordering = []
267         if self.model_admin.ordering:
268             ordering = self.model_admin.ordering
269         elif self.lookup_opts.ordering:
270             ordering = self.lookup_opts.ordering
271         return ordering
272 
273     def get_ordering_field(self, field_name):
274         """
275         Return the proper model field name corresponding to the given
276         field_name to use for ordering. field_name may either be the name of a
277         proper model field or the name of a method (on the admin or model) or a
278         callable with the 'admin_order_field' attribute. Return None if no
279         proper model field name can be matched.
280         """
281         try:
282             field = self.lookup_opts.get_field(field_name)
283             return field.name
284         except FieldDoesNotExist:
285             # See whether field_name is a name of a non-field
286             # that allows sorting.
287             if callable(field_name):
288                 attr = field_name
289             elif hasattr(self.model_admin, field_name):
290                 attr = getattr(self.model_admin, field_name)
291             else:
292                 attr = getattr(self.model, field_name)
293             if isinstance(attr, property) and hasattr(attr, 'fget'):
294                 attr = attr.fget
295             return getattr(attr, 'admin_order_field', None)
296 
297     def get_ordering(self, request, queryset):
298         """
299         Return the list of ordering fields for the change list.
300         First check the get_ordering() method in model admin, then check
301         the object's default ordering. Then, any manually-specified ordering
302         from the query string overrides anything. Finally, a deterministic
303         order is guaranteed by calling _get_deterministic_ordering() with the
304         constructed ordering.
305         """
306         params = self.params
307         ordering = list(self.model_admin.get_ordering(request) or self._get_default_ordering())
308         if ORDER_VAR in params:
309             # Clear ordering and used params
310             ordering = []
311             order_params = params[ORDER_VAR].split('.')
312             for p in order_params:
313                 try:
314                     none, pfx, idx = p.rpartition('-')
315                     field_name = self.list_display[int(idx)]
316                     order_field = self.get_ordering_field(field_name)
317                     if not order_field:
318                         continue  # No 'admin_order_field', skip it
319                     if isinstance(order_field, OrderBy):
320                         if pfx == '-':
321                             order_field = order_field.copy()
322                             order_field.reverse_ordering()
323                         ordering.append(order_field)
324                     elif hasattr(order_field, 'resolve_expression'):
325                         # order_field is an expression.
326                         ordering.append(order_field.desc() if pfx == '-' else order_field.asc())
327                     # reverse order if order_field has already "-" as prefix
328                     elif order_field.startswith('-') and pfx == '-':
329                         ordering.append(order_field[1:])
330                     else:
331                         ordering.append(pfx + order_field)
332                 except (IndexError, ValueError):
333                     continue  # Invalid ordering specified, skip it.
334 
335         # Add the given query's ordering fields, if any.
336         ordering.extend(queryset.query.order_by)
337 
338         return self._get_deterministic_ordering(ordering)
339 
340     def _get_deterministic_ordering(self, ordering):
341         """
342         Ensure a deterministic order across all database backends. Search for a
343         single field or unique together set of fields providing a total
344         ordering. If these are missing, augment the ordering with a descendant
345         primary key.
346         """
347         ordering = list(ordering)
348         ordering_fields = set()
349         total_ordering_fields = {'pk'} | {
350             field.attname for field in self.lookup_opts.fields
351             if field.unique and not field.null
352         }
353         for part in ordering:
354             # Search for single field providing a total ordering.
355             field_name = None
356             if isinstance(part, str):
357                 field_name = part.lstrip('-')
358             elif isinstance(part, F):
359                 field_name = part.name
360             elif isinstance(part, OrderBy) and isinstance(part.expression, F):
361                 field_name = part.expression.name
362             if field_name:
363                 # Normalize attname references by using get_field().
364                 try:
365                     field = self.lookup_opts.get_field(field_name)
366                 except FieldDoesNotExist:
367                     # Could be "?" for random ordering or a related field
368                     # lookup. Skip this part of introspection for now.
369                     continue
370                 # Ordering by a related field name orders by the referenced
371                 # model's ordering. Skip this part of introspection for now.
372                 if field.remote_field and field_name == field.name:
373                     continue
374                 if field.attname in total_ordering_fields:
375                     break
376                 ordering_fields.add(field.attname)
377         else:
378             # No single total ordering field, try unique_together and total
379             # unique constraints.
380             constraint_field_names = (
381                 *self.lookup_opts.unique_together,
382                 *(
383                     constraint.fields
384                     for constraint in self.lookup_opts.total_unique_constraints
385                 ),
386             )
387             for field_names in constraint_field_names:
388                 # Normalize attname references by using get_field().
389                 fields = [self.lookup_opts.get_field(field_name) for field_name in field_names]
390                 # Composite unique constraints containing a nullable column
391                 # cannot ensure total ordering.
392                 if any(field.null for field in fields):
393                     continue
394                 if ordering_fields.issuperset(field.attname for field in fields):
395                     break
396             else:
397                 # If no set of unique fields is present in the ordering, rely
398                 # on the primary key to provide total ordering.
399                 ordering.append('-pk')
400         return ordering
401 
402     def get_ordering_field_columns(self):
403         """
404         Return a dictionary of ordering field column numbers and asc/desc.
405         """
406         # We must cope with more than one column having the same underlying sort
407         # field, so we base things on column numbers.
408         ordering = self._get_default_ordering()
409         ordering_fields = {}
410         if ORDER_VAR not in self.params:
411             # for ordering specified on ModelAdmin or model Meta, we don't know
412             # the right column numbers absolutely, because there might be more
413             # than one column associated with that ordering, so we guess.
414             for field in ordering:
415                 if isinstance(field, (Combinable, OrderBy)):
416                     if not isinstance(field, OrderBy):
417                         field = field.asc()
418                     if isinstance(field.expression, F):
419                         order_type = 'desc' if field.descending else 'asc'
420                         field = field.expression.name
421                     else:
422                         continue
423                 elif field.startswith('-'):
424                     field = field[1:]
425                     order_type = 'desc'
426                 else:
427                     order_type = 'asc'
428                 for index, attr in enumerate(self.list_display):
429                     if self.get_ordering_field(attr) == field:
430                         ordering_fields[index] = order_type
431                         break
432         else:
433             for p in self.params[ORDER_VAR].split('.'):
434                 none, pfx, idx = p.rpartition('-')
435                 try:
436                     idx = int(idx)
437                 except ValueError:
438                     continue  # skip it
439                 ordering_fields[idx] = 'desc' if pfx == '-' else 'asc'
440         return ordering_fields
441 
442     def get_queryset(self, request):
443         # First, we collect all the declared list filters.
444         (
445             self.filter_specs,
446             self.has_filters,
447             remaining_lookup_params,
448             filters_use_distinct,
449             self.has_active_filters,
450         ) = self.get_filters(request)
451         # Then, we let every list filter modify the queryset to its liking.
452         qs = self.root_queryset
453         for filter_spec in self.filter_specs:
454             new_qs = filter_spec.queryset(request, qs)
455             if new_qs is not None:
456                 qs = new_qs
457 
458         try:
459             # Finally, we apply the remaining lookup parameters from the query
460             # string (i.e. those that haven't already been processed by the
461             # filters).
462             qs = qs.filter(**remaining_lookup_params)
463         except (SuspiciousOperation, ImproperlyConfigured):
464             # Allow certain types of errors to be re-raised as-is so that the
465             # caller can treat them in a special way.
466             raise
467         except Exception as e:
468             # Every other error is caught with a naked except, because we don't
469             # have any other way of validating lookup parameters. They might be
470             # invalid if the keyword arguments are incorrect, or if the values
471             # are not in the correct type, so we might get FieldError,
472             # ValueError, ValidationError, or ?.
473             raise IncorrectLookupParameters(e)
474 
475         if not qs.query.select_related:
476             qs = self.apply_select_related(qs)
477 
478         # Set ordering.
479         ordering = self.get_ordering(request, qs)
480         qs = qs.order_by(*ordering)
481 
482         # Apply search results
483         qs, search_use_distinct = self.model_admin.get_search_results(request, qs, self.query)
484 
485         # Set query string for clearing all filters.
486         self.clear_all_filters_qs = self.get_query_string(
487             new_params=remaining_lookup_params,
488             remove=self.get_filters_params(),
489         )
490         # Remove duplicates from results, if necessary
491         if filters_use_distinct | search_use_distinct:
492             return qs.distinct()
493         else:
494             return qs
495 
496     def apply_select_related(self, qs):
497         if self.list_select_related is True:
498             return qs.select_related()
499 
500         if self.list_select_related is False:
501             if self.has_related_field_in_list_display():
502                 return qs.select_related()
503 
504         if self.list_select_related:
505             return qs.select_related(*self.list_select_related)
506         return qs
507 
508     def has_related_field_in_list_display(self):
509         for field_name in self.list_display:
510             try:
511                 field = self.lookup_opts.get_field(field_name)
512             except FieldDoesNotExist:
513                 pass
514             else:
515                 if isinstance(field.remote_field, ManyToOneRel):
516                     # <FK>_id field names don't require a join.
517                     if field_name != field.get_attname():
518                         return True
519         return False
520 
521     def url_for_result(self, result):
522         pk = getattr(result, self.pk_attname)
523         return reverse('admin:%s_%s_change' % (self.opts.app_label,
524                                                self.opts.model_name),
525                        args=(quote(pk),),
526                        current_app=self.model_admin.admin_site.name)

</code><intended_behavior>The code handling search queries in the admin page that involves many-to-many fields (directly or indirectly) needs to ensure that the operations following a search, such as delete, do not fail because of intermediate query modifications like distinct(). Here, the solution might involve reworking how search querysets are prepared or offering an alternative path for delete actions that does not rely on potentially modified querysets containing distinct(). This ensures the admin interface remains robust, supporting both complex searches and bulk actions without leading to exceptions.</intended_behavior>]
2025-10-15 05:47:56.552 | INFO     | Search completed. Bug locations: [<file>django/contrib/admin/options.py</file>
<class>ModelAdmin</class>
<method>delete_queryset</method>
<code>
1105     def delete_queryset(self, request, queryset):
1106         """Given a queryset, delete it from the database."""
1107         queryset.delete()

</code><intended_behavior>This method needs to handle queryset deletion carefully when the queryset involves a distinct() call, especially in the context of the admin interface where searches can generate querysets that use distinct(). The intended behavior here is to ensure that the queryset handed over to delete_queryset can be safely deleted, possibly by re-evaluating the queryset without distinct() if it's not compatible with deletion. This adjustment must preserve the admin's ability to filter and search efficiently without causing errors during bulk delete actions.</intended_behavior>, <file>django/contrib/admin/options.py</file>
<class>ModelAdmin</class>
<method>None</method>
<code>
551 class ModelAdmin(BaseModelAdmin):
552     """Encapsulate all admin options and functionality for a given model."""
553 
554     list_display = ('__str__',)
555     list_display_links = ()
556     list_filter = ()
557     list_select_related = False
558     list_per_page = 100
559     list_max_show_all = 200
560     list_editable = ()
561     search_fields = ()
562     date_hierarchy = None
563     save_as = False
564     save_as_continue = True
565     save_on_top = False
566     paginator = Paginator
567     preserve_filters = True
568     inlines = []
569 
570     # Custom templates (designed to be over-ridden in subclasses)
571     add_form_template = None
572     change_form_template = None
573     change_list_template = None
574     delete_confirmation_template = None
575     delete_selected_confirmation_template = None
576     object_history_template = None
577     popup_response_template = None
578 
579     # Actions
580     actions = []
581     action_form = helpers.ActionForm
582     actions_on_top = True
583     actions_on_bottom = False
584     actions_selection_counter = True
585     checks_class = ModelAdminChecks
586 
587     def __init__(self, model, admin_site):
588         self.model = model
589         self.opts = model._meta
590         self.admin_site = admin_site
591         super().__init__()
592 
593     def __str__(self):
594         return "%s.%s" % (self.model._meta.app_label, self.__class__.__name__)
595 
596     def get_inline_instances(self, request, obj=None):
597         inline_instances = []
598         for inline_class in self.get_inlines(request, obj):
599             inline = inline_class(self.model, self.admin_site)
600             if request:
601                 if not (inline.has_view_or_change_permission(request, obj) or
602                         inline.has_add_permission(request, obj) or
603                         inline.has_delete_permission(request, obj)):
604                     continue
605                 if not inline.has_add_permission(request, obj):
606                     inline.max_num = 0
607             inline_instances.append(inline)
608 
609         return inline_instances
610 
611     def get_urls(self):
612         from django.urls import path
613 
614         def wrap(view):
615             def wrapper(*args, **kwargs):
616                 return self.admin_site.admin_view(view)(*args, **kwargs)
617             wrapper.model_admin = self
618             return update_wrapper(wrapper, view)
619 
620         info = self.model._meta.app_label, self.model._meta.model_name
621 
622         return [
623             path('', wrap(self.changelist_view), name='%s_%s_changelist' % info),
624             path('add/', wrap(self.add_view), name='%s_%s_add' % info),
625             path('<path:object_id>/history/', wrap(self.history_view), name='%s_%s_history' % info),
626             path('<path:object_id>/delete/', wrap(self.delete_view), name='%s_%s_delete' % info),
627             path('<path:object_id>/change/', wrap(self.change_view), name='%s_%s_change' % info),
628             # For backwards compatibility (was the change url before 1.9)
629             path('<path:object_id>/', wrap(RedirectView.as_view(
630                 pattern_name='%s:%s_%s_change' % ((self.admin_site.name,) + info)
631             ))),
632         ]
633 
634     @property
635     def urls(self):
636         return self.get_urls()
637 
638     @property
639     def media(self):
640         extra = '' if settings.DEBUG else '.min'
641         js = [
642             'vendor/jquery/jquery%s.js' % extra,
643             'jquery.init.js',
644             'core.js',
645             'admin/RelatedObjectLookups.js',
646             'actions.js',
647             'urlify.js',
648             'prepopulate.js',
649             'vendor/xregexp/xregexp%s.js' % extra,
650         ]
651         return forms.Media(js=['admin/js/%s' % url for url in js])
652 
653     def get_model_perms(self, request):
654         """
655         Return a dict of all perms for this model. This dict has the keys
656         ``add``, ``change``, ``delete``, and ``view`` mapping to the True/False
657         for each of those actions.
658         """
659         return {
660             'add': self.has_add_permission(request),
661             'change': self.has_change_permission(request),
662             'delete': self.has_delete_permission(request),
663             'view': self.has_view_permission(request),
664         }
665 
666     def _get_form_for_get_fields(self, request, obj):
667         return self.get_form(request, obj, fields=None)
668 
669     def get_form(self, request, obj=None, change=False, **kwargs):
670         """
671         Return a Form class for use in the admin add view. This is used by
672         add_view and change_view.
673         """
674         if 'fields' in kwargs:
675             fields = kwargs.pop('fields')
676         else:
677             fields = flatten_fieldsets(self.get_fieldsets(request, obj))
678         excluded = self.get_exclude(request, obj)
679         exclude = [] if excluded is None else list(excluded)
680         readonly_fields = self.get_readonly_fields(request, obj)
681         exclude.extend(readonly_fields)
682         # Exclude all fields if it's a change form and the user doesn't have
683         # the change permission.
684         if change and hasattr(request, 'user') and not self.has_change_permission(request, obj):
685             exclude.extend(fields)
686         if excluded is None and hasattr(self.form, '_meta') and self.form._meta.exclude:
687             # Take the custom ModelForm's Meta.exclude into account only if the
688             # ModelAdmin doesn't define its own.
689             exclude.extend(self.form._meta.exclude)
690         # if exclude is an empty list we pass None to be consistent with the
691         # default on modelform_factory
692         exclude = exclude or None
693 
694         # Remove declared form fields which are in readonly_fields.
695         new_attrs = dict.fromkeys(f for f in readonly_fields if f in self.form.declared_fields)
696         form = type(self.form.__name__, (self.form,), new_attrs)
697 
698         defaults = {
699             'form': form,
700             'fields': fields,
701             'exclude': exclude,
702             'formfield_callback': partial(self.formfield_for_dbfield, request=request),
703             **kwargs,
704         }
705 
706         if defaults['fields'] is None and not modelform_defines_fields(defaults['form']):
707             defaults['fields'] = forms.ALL_FIELDS
708 
709         try:
710             return modelform_factory(self.model, **defaults)
711         except FieldError as e:
712             raise FieldError(
713                 '%s. Check fields/fieldsets/exclude attributes of class %s.'
714                 % (e, self.__class__.__name__)
715             )
716 
717     def get_changelist(self, request, **kwargs):
718         """
719         Return the ChangeList class for use on the changelist page.
720         """
721         from django.contrib.admin.views.main import ChangeList
722         return ChangeList
723 
724     def get_changelist_instance(self, request):
725         """
726         Return a `ChangeList` instance based on `request`. May raise
727         `IncorrectLookupParameters`.
728         """
729         list_display = self.get_list_display(request)
730         list_display_links = self.get_list_display_links(request, list_display)
731         # Add the action checkboxes if any actions are available.
732         if self.get_actions(request):
733             list_display = ['action_checkbox', *list_display]
734         sortable_by = self.get_sortable_by(request)
735         ChangeList = self.get_changelist(request)
736         return ChangeList(
737             request,
738             self.model,
739             list_display,
740             list_display_links,
741             self.get_list_filter(request),
742             self.date_hierarchy,
743             self.get_search_fields(request),
744             self.get_list_select_related(request),
745             self.list_per_page,
746             self.list_max_show_all,
747             self.list_editable,
748             self,
749             sortable_by,
750         )
751 
752     def get_object(self, request, object_id, from_field=None):
753         """
754         Return an instance matching the field and value provided, the primary
755         key is used if no field is provided. Return ``None`` if no match is
756         found or the object_id fails validation.
757         """
758         queryset = self.get_queryset(request)
759         model = queryset.model
760         field = model._meta.pk if from_field is None else model._meta.get_field(from_field)
761         try:
762             object_id = field.to_python(object_id)
763             return queryset.get(**{field.name: object_id})
764         except (model.DoesNotExist, ValidationError, ValueError):
765             return None
766 
767     def get_changelist_form(self, request, **kwargs):
768         """
769         Return a Form class for use in the Formset on the changelist page.
770         """
771         defaults = {
772             'formfield_callback': partial(self.formfield_for_dbfield, request=request),
773             **kwargs,
774         }
775         if defaults.get('fields') is None and not modelform_defines_fields(defaults.get('form')):
776             defaults['fields'] = forms.ALL_FIELDS
777 
778         return modelform_factory(self.model, **defaults)
779 
780     def get_changelist_formset(self, request, **kwargs):
781         """
782         Return a FormSet class for use on the changelist page if list_editable
783         is used.
784         """
785         defaults = {
786             'formfield_callback': partial(self.formfield_for_dbfield, request=request),
787             **kwargs,
788         }
789         return modelformset_factory(
790             self.model, self.get_changelist_form(request), extra=0,
791             fields=self.list_editable, **defaults
792         )
793 
794     def get_formsets_with_inlines(self, request, obj=None):
795         """
796         Yield formsets and the corresponding inlines.
797         """
798         for inline in self.get_inline_instances(request, obj):
799             yield inline.get_formset(request, obj), inline
800 
801     def get_paginator(self, request, queryset, per_page, orphans=0, allow_empty_first_page=True):
802         return self.paginator(queryset, per_page, orphans, allow_empty_first_page)
803 
804     def log_addition(self, request, object, message):
805         """
806         Log that an object has been successfully added.
807 
808         The default implementation creates an admin LogEntry object.
809         """
810         from django.contrib.admin.models import ADDITION, LogEntry
811         return LogEntry.objects.log_action(
812             user_id=request.user.pk,
813             content_type_id=get_content_type_for_model(object).pk,
814             object_id=object.pk,
815             object_repr=str(object),
816             action_flag=ADDITION,
817             change_message=message,
818         )
819 
820     def log_change(self, request, object, message):
821         """
822         Log that an object has been successfully changed.
823 
824         The default implementation creates an admin LogEntry object.
825         """
826         from django.contrib.admin.models import CHANGE, LogEntry
827         return LogEntry.objects.log_action(
828             user_id=request.user.pk,
829             content_type_id=get_content_type_for_model(object).pk,
830             object_id=object.pk,
831             object_repr=str(object),
832             action_flag=CHANGE,
833             change_message=message,
834         )
835 
836     def log_deletion(self, request, object, object_repr):
837         """
838         Log that an object will be deleted. Note that this method must be
839         called before the deletion.
840 
841         The default implementation creates an admin LogEntry object.
842         """
843         from django.contrib.admin.models import DELETION, LogEntry
844         return LogEntry.objects.log_action(
845             user_id=request.user.pk,
846             content_type_id=get_content_type_for_model(object).pk,
847             object_id=object.pk,
848             object_repr=object_repr,
849             action_flag=DELETION,
850         )
851 
852     @display(description=mark_safe('<input type="checkbox" id="action-toggle">'))
853     def action_checkbox(self, obj):
854         """
855         A list_display column containing a checkbox widget.
856         """
857         return helpers.checkbox.render(helpers.ACTION_CHECKBOX_NAME, str(obj.pk))
858 
859     @staticmethod
860     def _get_action_description(func, name):
861         return getattr(func, 'short_description', capfirst(name.replace('_', ' ')))
862 
863     def _get_base_actions(self):
864         """Return the list of actions, prior to any request-based filtering."""
865         actions = []
866         base_actions = (self.get_action(action) for action in self.actions or [])
867         # get_action might have returned None, so filter any of those out.
868         base_actions = [action for action in base_actions if action]
869         base_action_names = {name for _, name, _ in base_actions}
870 
871         # Gather actions from the admin site first
872         for (name, func) in self.admin_site.actions:
873             if name in base_action_names:
874                 continue
875             description = self._get_action_description(func, name)
876             actions.append((func, name, description))
877         # Add actions from this ModelAdmin.
878         actions.extend(base_actions)
879         return actions
880 
881     def _filter_actions_by_permissions(self, request, actions):
882         """Filter out any actions that the user doesn't have access to."""
883         filtered_actions = []
884         for action in actions:
885             callable = action[0]
886             if not hasattr(callable, 'allowed_permissions'):
887                 filtered_actions.append(action)
888                 continue
889             permission_checks = (
890                 getattr(self, 'has_%s_permission' % permission)
891                 for permission in callable.allowed_permissions
892             )
893             if any(has_permission(request) for has_permission in permission_checks):
894                 filtered_actions.append(action)
895         return filtered_actions
896 
897     def get_actions(self, request):
898         """
899         Return a dictionary mapping the names of all actions for this
900         ModelAdmin to a tuple of (callable, name, description) for each action.
901         """
902         # If self.actions is set to None that means actions are disabled on
903         # this page.
904         if self.actions is None or IS_POPUP_VAR in request.GET:
905             return {}
906         actions = self._filter_actions_by_permissions(request, self._get_base_actions())
907         return {name: (func, name, desc) for func, name, desc in actions}
908 
909     def get_action_choices(self, request, default_choices=models.BLANK_CHOICE_DASH):
910         """
911         Return a list of choices for use in a form object.  Each choice is a
912         tuple (name, description).
913         """
914         choices = [] + default_choices
915         for func, name, description in self.get_actions(request).values():
916             choice = (name, description % model_format_dict(self.opts))
917             choices.append(choice)
918         return choices
919 
920     def get_action(self, action):
921         """
922         Return a given action from a parameter, which can either be a callable,
923         or the name of a method on the ModelAdmin.  Return is a tuple of
924         (callable, name, description).
925         """
926         # If the action is a callable, just use it.
927         if callable(action):
928             func = action
929             action = action.__name__
930 
931         # Next, look for a method. Grab it off self.__class__ to get an unbound
932         # method instead of a bound one; this ensures that the calling
933         # conventions are the same for functions and methods.
934         elif hasattr(self.__class__, action):
935             func = getattr(self.__class__, action)
936 
937         # Finally, look for a named method on the admin site
938         else:
939             try:
940                 func = self.admin_site.get_action(action)
941             except KeyError:
942                 return None
943 
944         description = self._get_action_description(func, action)
945         return func, action, description
946 
947     def get_list_display(self, request):
948         """
949         Return a sequence containing the fields to be displayed on the
950         changelist.
951         """
952         return self.list_display
953 
954     def get_list_display_links(self, request, list_display):
955         """
956         Return a sequence containing the fields to be displayed as links
957         on the changelist. The list_display parameter is the list of fields
958         returned by get_list_display().
959         """
960         if self.list_display_links or self.list_display_links is None or not list_display:
961             return self.list_display_links
962         else:
963             # Use only the first item in list_display as link
964             return list(list_display)[:1]
965 
966     def get_list_filter(self, request):
967         """
968         Return a sequence containing the fields to be displayed as filters in
969         the right sidebar of the changelist page.
970         """
971         return self.list_filter
972 
973     def get_list_select_related(self, request):
974         """
975         Return a list of fields to add to the select_related() part of the
976         changelist items query.
977         """
978         return self.list_select_related
979 
980     def get_search_fields(self, request):
981         """
982         Return a sequence containing the fields to be searched whenever
983         somebody submits a search query.
984         """
985         return self.search_fields
986 
987     def get_search_results(self, request, queryset, search_term):
988         """
989         Return a tuple containing a queryset to implement the search
990         and a boolean indicating if the results may contain duplicates.
991         """
992         # Apply keyword searches.
993         def construct_search(field_name):
994             if field_name.startswith('^'):
995                 return "%s__istartswith" % field_name[1:]
996             elif field_name.startswith('='):
997                 return "%s__iexact" % field_name[1:]
998             elif field_name.startswith('@'):
999                 return "%s__search" % field_name[1:]
1000             # Use field_name if it includes a lookup.
1001             opts = queryset.model._meta
1002             lookup_fields = field_name.split(LOOKUP_SEP)
1003             # Go through the fields, following all relations.
1004             prev_field = None
1005             for path_part in lookup_fields:
1006                 if path_part == 'pk':
1007                     path_part = opts.pk.name
1008                 try:
1009                     field = opts.get_field(path_part)
1010                 except FieldDoesNotExist:
1011                     # Use valid query lookups.
1012                     if prev_field and prev_field.get_lookup(path_part):
1013                         return field_name
1014                 else:
1015                     prev_field = field
1016                     if hasattr(field, 'get_path_info'):
1017                         # Update opts to follow the relation.
1018                         opts = field.get_path_info()[-1].to_opts
1019             # Otherwise, use the field with icontains.
1020             return "%s__icontains" % field_name
1021 
1022         use_distinct = False
1023         search_fields = self.get_search_fields(request)
1024         if search_fields and search_term:
1025             orm_lookups = [construct_search(str(search_field))
1026                            for search_field in search_fields]
1027             for bit in smart_split(search_term):
1028                 if bit.startswith(('"', "'")) and bit[0] == bit[-1]:
1029                     bit = unescape_string_literal(bit)
1030                 or_queries = [models.Q(**{orm_lookup: bit})
1031                               for orm_lookup in orm_lookups]
1032                 queryset = queryset.filter(reduce(operator.or_, or_queries))
1033             use_distinct |= any(lookup_needs_distinct(self.opts, search_spec) for search_spec in orm_lookups)
1034 
1035         return queryset, use_distinct
1036 
1037     def get_preserved_filters(self, request):
1038         """
1039         Return the preserved filters querystring.
1040         """
1041         match = request.resolver_match
1042         if self.preserve_filters and match:
1043             opts = self.model._meta
1044             current_url = '%s:%s' % (match.app_name, match.url_name)
1045             changelist_url = 'admin:%s_%s_changelist' % (opts.app_label, opts.model_name)
1046             if current_url == changelist_url:
1047                 preserved_filters = request.GET.urlencode()
1048             else:
1049                 preserved_filters = request.GET.get('_changelist_filters')
1050 
1051             if preserved_filters:
1052                 return urlencode({'_changelist_filters': preserved_filters})
1053         return ''
1054 
1055     def construct_change_message(self, request, form, formsets, add=False):
1056         """
1057         Construct a JSON structure describing changes from a changed object.
1058         """
1059         return construct_change_message(form, formsets, add)
1060 
1061     def message_user(self, request, message, level=messages.INFO, extra_tags='',
1062                      fail_silently=False):
1063         """
1064         Send a message to the user. The default implementation
1065         posts a message using the django.contrib.messages backend.
1066 
1067         Exposes almost the same API as messages.add_message(), but accepts the
1068         positional arguments in a different order to maintain backwards
1069         compatibility. For convenience, it accepts the `level` argument as
1070         a string rather than the usual level number.
1071         """
1072         if not isinstance(level, int):
1073             # attempt to get the level if passed a string
1074             try:
1075                 level = getattr(messages.constants, level.upper())
1076             except AttributeError:
1077                 levels = messages.constants.DEFAULT_TAGS.values()
1078                 levels_repr = ', '.join('`%s`' % level for level in levels)
1079                 raise ValueError(
1080                     'Bad message level string: `%s`. Possible values are: %s'
1081                     % (level, levels_repr)
1082                 )
1083 
1084         messages.add_message(request, level, message, extra_tags=extra_tags, fail_silently=fail_silently)
1085 
1086     def save_form(self, request, form, change):
1087         """
1088         Given a ModelForm return an unsaved instance. ``change`` is True if
1089         the object is being changed, and False if it's being added.
1090         """
1091         return form.save(commit=False)
1092 
1093     def save_model(self, request, obj, form, change):
1094         """
1095         Given a model instance save it to the database.
1096         """
1097         obj.save()
1098 
1099     def delete_model(self, request, obj):
1100         """
1101         Given a model instance delete it from the database.
1102         """
1103         obj.delete()
1104 
1105     def delete_queryset(self, request, queryset):
1106         """Given a queryset, delete it from the database."""
1107         queryset.delete()
1108 
1109     def save_formset(self, request, form, formset, change):
1110         """
1111         Given an inline formset save it to the database.
1112         """
1113         formset.save()
1114 
1115     def save_related(self, request, form, formsets, change):
1116         """
1117         Given the ``HttpRequest``, the parent ``ModelForm`` instance, the
1118         list of inline formsets and a boolean value based on whether the
1119         parent is being added or changed, save the related objects to the
1120         database. Note that at this point save_form() and save_model() have
1121         already been called.
1122         """
1123         form.save_m2m()
1124         for formset in formsets:
1125             self.save_formset(request, form, formset, change=change)
1126 
1127     def render_change_form(self, request, context, add=False, change=False, form_url='', obj=None):
1128         opts = self.model._meta
1129         app_label = opts.app_label
1130         preserved_filters = self.get_preserved_filters(request)
1131         form_url = add_preserved_filters({'preserved_filters': preserved_filters, 'opts': opts}, form_url)
1132         view_on_site_url = self.get_view_on_site_url(obj)
1133         has_editable_inline_admin_formsets = False
1134         for inline in context['inline_admin_formsets']:
1135             if inline.has_add_permission or inline.has_change_permission or inline.has_delete_permission:
1136                 has_editable_inline_admin_formsets = True
1137                 break
1138         context.update({
1139             'add': add,
1140             'change': change,
1141             'has_view_permission': self.has_view_permission(request, obj),
1142             'has_add_permission': self.has_add_permission(request),
1143             'has_change_permission': self.has_change_permission(request, obj),
1144             'has_delete_permission': self.has_delete_permission(request, obj),
1145             'has_editable_inline_admin_formsets': has_editable_inline_admin_formsets,
1146             'has_file_field': context['adminform'].form.is_multipart() or any(
1147                 admin_formset.formset.is_multipart()
1148                 for admin_formset in context['inline_admin_formsets']
1149             ),
1150             'has_absolute_url': view_on_site_url is not None,
1151             'absolute_url': view_on_site_url,
1152             'form_url': form_url,
1153             'opts': opts,
1154             'content_type_id': get_content_type_for_model(self.model).pk,
1155             'save_as': self.save_as,
1156             'save_on_top': self.save_on_top,
1157             'to_field_var': TO_FIELD_VAR,
1158             'is_popup_var': IS_POPUP_VAR,
1159             'app_label': app_label,
1160         })
1161         if add and self.add_form_template is not None:
1162             form_template = self.add_form_template
1163         else:
1164             form_template = self.change_form_template
1165 
1166         request.current_app = self.admin_site.name
1167 
1168         return TemplateResponse(request, form_template or [
1169             "admin/%s/%s/change_form.html" % (app_label, opts.model_name),
1170             "admin/%s/change_form.html" % app_label,
1171             "admin/change_form.html"
1172         ], context)
1173 
1174     def response_add(self, request, obj, post_url_continue=None):
1175         """
1176         Determine the HttpResponse for the add_view stage.
1177         """
1178         opts = obj._meta
1179         preserved_filters = self.get_preserved_filters(request)
1180         obj_url = reverse(
1181             'admin:%s_%s_change' % (opts.app_label, opts.model_name),
1182             args=(quote(obj.pk),),
1183             current_app=self.admin_site.name,
1184         )
1185         # Add a link to the object's change form if the user can edit the obj.
1186         if self.has_change_permission(request, obj):
1187             obj_repr = format_html('<a href="{}">{}</a>', urlquote(obj_url), obj)
1188         else:
1189             obj_repr = str(obj)
1190         msg_dict = {
1191             'name': opts.verbose_name,
1192             'obj': obj_repr,
1193         }
1194         # Here, we distinguish between different save types by checking for
1195         # the presence of keys in request.POST.
1196 
1197         if IS_POPUP_VAR in request.POST:
1198             to_field = request.POST.get(TO_FIELD_VAR)
1199             if to_field:
1200                 attr = str(to_field)
1201             else:
1202                 attr = obj._meta.pk.attname
1203             value = obj.serializable_value(attr)
1204             popup_response_data = json.dumps({
1205                 'value': str(value),
1206                 'obj': str(obj),
1207             })
1208             return TemplateResponse(request, self.popup_response_template or [
1209                 'admin/%s/%s/popup_response.html' % (opts.app_label, opts.model_name),
1210                 'admin/%s/popup_response.html' % opts.app_label,
1211                 'admin/popup_response.html',
1212             ], {
1213                 'popup_response_data': popup_response_data,
1214             })
1215 
1216         elif "_continue" in request.POST or (
1217                 # Redirecting after "Save as new".
1218                 "_saveasnew" in request.POST and self.save_as_continue and
1219                 self.has_change_permission(request, obj)
1220         ):
1221             msg = _('The {name} “{obj}” was added successfully.')
1222             if self.has_change_permission(request, obj):
1223                 msg += ' ' + _('You may edit it again below.')
1224             self.message_user(request, format_html(msg, **msg_dict), messages.SUCCESS)
1225             if post_url_continue is None:
1226                 post_url_continue = obj_url
1227             post_url_continue = add_preserved_filters(
1228                 {'preserved_filters': preserved_filters, 'opts': opts},
1229                 post_url_continue
1230             )
1231             return HttpResponseRedirect(post_url_continue)
1232 
1233         elif "_addanother" in request.POST:
1234             msg = format_html(
1235                 _('The {name} “{obj}” was added successfully. You may add another {name} below.'),
1236                 **msg_dict
1237             )
1238             self.message_user(request, msg, messages.SUCCESS)
1239             redirect_url = request.path
1240             redirect_url = add_preserved_filters({'preserved_filters': preserved_filters, 'opts': opts}, redirect_url)
1241             return HttpResponseRedirect(redirect_url)
1242 
1243         else:
1244             msg = format_html(
1245                 _('The {name} “{obj}” was added successfully.'),
1246                 **msg_dict
1247             )
1248             self.message_user(request, msg, messages.SUCCESS)
1249             return self.response_post_save_add(request, obj)
1250 
1251     def response_change(self, request, obj):
1252         """
1253         Determine the HttpResponse for the change_view stage.
1254         """
1255 
1256         if IS_POPUP_VAR in request.POST:
1257             opts = obj._meta
1258             to_field = request.POST.get(TO_FIELD_VAR)
1259             attr = str(to_field) if to_field else opts.pk.attname
1260             value = request.resolver_match.kwargs['object_id']
1261             new_value = obj.serializable_value(attr)
1262             popup_response_data = json.dumps({
1263                 'action': 'change',
1264                 'value': str(value),
1265                 'obj': str(obj),
1266                 'new_value': str(new_value),
1267             })
1268             return TemplateResponse(request, self.popup_response_template or [
1269                 'admin/%s/%s/popup_response.html' % (opts.app_label, opts.model_name),
1270                 'admin/%s/popup_response.html' % opts.app_label,
1271                 'admin/popup_response.html',
1272             ], {
1273                 'popup_response_data': popup_response_data,
1274             })
1275 
1276         opts = self.model._meta
1277         preserved_filters = self.get_preserved_filters(request)
1278 
1279         msg_dict = {
1280             'name': opts.verbose_name,
1281             'obj': format_html('<a href="{}">{}</a>', urlquote(request.path), obj),
1282         }
1283         if "_continue" in request.POST:
1284             msg = format_html(
1285                 _('The {name} “{obj}” was changed successfully. You may edit it again below.'),
1286                 **msg_dict
1287             )
1288             self.message_user(request, msg, messages.SUCCESS)
1289             redirect_url = request.path
1290             redirect_url = add_preserved_filters({'preserved_filters': preserved_filters, 'opts': opts}, redirect_url)
1291             return HttpResponseRedirect(redirect_url)
1292 
1293         elif "_saveasnew" in request.POST:
1294             msg = format_html(
1295                 _('The {name} “{obj}” was added successfully. You may edit it again below.'),
1296                 **msg_dict
1297             )
1298             self.message_user(request, msg, messages.SUCCESS)
1299             redirect_url = reverse('admin:%s_%s_change' %
1300                                    (opts.app_label, opts.model_name),
1301                                    args=(obj.pk,),
1302                                    current_app=self.admin_site.name)
1303             redirect_url = add_preserved_filters({'preserved_filters': preserved_filters, 'opts': opts}, redirect_url)
1304             return HttpResponseRedirect(redirect_url)
1305 
1306         elif "_addanother" in request.POST:
1307             msg = format_html(
1308                 _('The {name} “{obj}” was changed successfully. You may add another {name} below.'),
1309                 **msg_dict
1310             )
1311             self.message_user(request, msg, messages.SUCCESS)
1312             redirect_url = reverse('admin:%s_%s_add' %
1313                                    (opts.app_label, opts.model_name),
1314                                    current_app=self.admin_site.name)
1315             redirect_url = add_preserved_filters({'preserved_filters': preserved_filters, 'opts': opts}, redirect_url)
1316             return HttpResponseRedirect(redirect_url)
1317 
1318         else:
1319             msg = format_html(
1320                 _('The {name} “{obj}” was changed successfully.'),
1321                 **msg_dict
1322             )
1323             self.message_user(request, msg, messages.SUCCESS)
1324             return self.response_post_save_change(request, obj)
1325 
1326     def _response_post_save(self, request, obj):
1327         opts = self.model._meta
1328         if self.has_view_or_change_permission(request):
1329             post_url = reverse('admin:%s_%s_changelist' %
1330                                (opts.app_label, opts.model_name),
1331                                current_app=self.admin_site.name)
1332             preserved_filters = self.get_preserved_filters(request)
1333             post_url = add_preserved_filters({'preserved_filters': preserved_filters, 'opts': opts}, post_url)
1334         else:
1335             post_url = reverse('admin:index',
1336                                current_app=self.admin_site.name)
1337         return HttpResponseRedirect(post_url)
1338 
1339     def response_post_save_add(self, request, obj):
1340         """
1341         Figure out where to redirect after the 'Save' button has been pressed
1342         when adding a new object.
1343         """
1344         return self._response_post_save(request, obj)
1345 
1346     def response_post_save_change(self, request, obj):
1347         """
1348         Figure out where to redirect after the 'Save' button has been pressed
1349         when editing an existing object.
1350         """
1351         return self._response_post_save(request, obj)
1352 
1353     def response_action(self, request, queryset):
1354         """
1355         Handle an admin action. This is called if a request is POSTed to the
1356         changelist; it returns an HttpResponse if the action was handled, and
1357         None otherwise.
1358         """
1359 
1360         # There can be multiple action forms on the page (at the top
1361         # and bottom of the change list, for example). Get the action
1362         # whose button was pushed.
1363         try:
1364             action_index = int(request.POST.get('index', 0))
1365         except ValueError:
1366             action_index = 0
1367 
1368         # Construct the action form.
1369         data = request.POST.copy()
1370         data.pop(helpers.ACTION_CHECKBOX_NAME, None)
1371         data.pop("index", None)
1372 
1373         # Use the action whose button was pushed
1374         try:
1375             data.update({'action': data.getlist('action')[action_index]})
1376         except IndexError:
1377             # If we didn't get an action from the chosen form that's invalid
1378             # POST data, so by deleting action it'll fail the validation check
1379             # below. So no need to do anything here
1380             pass
1381 
1382         action_form = self.action_form(data, auto_id=None)
1383         action_form.fields['action'].choices = self.get_action_choices(request)
1384 
1385         # If the form's valid we can handle the action.
1386         if action_form.is_valid():
1387             action = action_form.cleaned_data['action']
1388             select_across = action_form.cleaned_data['select_across']
1389             func = self.get_actions(request)[action][0]
1390 
1391             # Get the list of selected PKs. If nothing's selected, we can't
1392             # perform an action on it, so bail. Except we want to perform
1393             # the action explicitly on all objects.
1394             selected = request.POST.getlist(helpers.ACTION_CHECKBOX_NAME)
1395             if not selected and not select_across:
1396                 # Reminder that something needs to be selected or nothing will happen
1397                 msg = _("Items must be selected in order to perform "
1398                         "actions on them. No items have been changed.")
1399                 self.message_user(request, msg, messages.WARNING)
1400                 return None
1401 
1402             if not select_across:
1403                 # Perform the action only on the selected objects
1404                 queryset = queryset.filter(pk__in=selected)
1405 
1406             response = func(self, request, queryset)
1407 
1408             # Actions may return an HttpResponse-like object, which will be
1409             # used as the response from the POST. If not, we'll be a good
1410             # little HTTP citizen and redirect back to the changelist page.
1411             if isinstance(response, HttpResponseBase):
1412                 return response
1413             else:
1414                 return HttpResponseRedirect(request.get_full_path())
1415         else:
1416             msg = _("No action selected.")
1417             self.message_user(request, msg, messages.WARNING)
1418             return None
1419 
1420     def response_delete(self, request, obj_display, obj_id):
1421         """
1422         Determine the HttpResponse for the delete_view stage.
1423         """
1424         opts = self.model._meta
1425 
1426         if IS_POPUP_VAR in request.POST:
1427             popup_response_data = json.dumps({
1428                 'action': 'delete',
1429                 'value': str(obj_id),
1430             })
1431             return TemplateResponse(request, self.popup_response_template or [
1432                 'admin/%s/%s/popup_response.html' % (opts.app_label, opts.model_name),
1433                 'admin/%s/popup_response.html' % opts.app_label,
1434                 'admin/popup_response.html',
1435             ], {
1436                 'popup_response_data': popup_response_data,
1437             })
1438 
1439         self.message_user(
1440             request,
1441             _('The %(name)s “%(obj)s” was deleted successfully.') % {
1442                 'name': opts.verbose_name,
1443                 'obj': obj_display,
1444             },
1445             messages.SUCCESS,
1446         )
1447 
1448         if self.has_change_permission(request, None):
1449             post_url = reverse(
1450                 'admin:%s_%s_changelist' % (opts.app_label, opts.model_name),
1451                 current_app=self.admin_site.name,
1452             )
1453             preserved_filters = self.get_preserved_filters(request)
1454             post_url = add_preserved_filters(
1455                 {'preserved_filters': preserved_filters, 'opts': opts}, post_url
1456             )
1457         else:
1458             post_url = reverse('admin:index', current_app=self.admin_site.name)
1459         return HttpResponseRedirect(post_url)
1460 
1461     def render_delete_form(self, request, context):
1462         opts = self.model._meta
1463         app_label = opts.app_label
1464 
1465         request.current_app = self.admin_site.name
1466         context.update(
1467             to_field_var=TO_FIELD_VAR,
1468             is_popup_var=IS_POPUP_VAR,
1469             media=self.media,
1470         )
1471 
1472         return TemplateResponse(
1473             request,
1474             self.delete_confirmation_template or [
1475                 "admin/{}/{}/delete_confirmation.html".format(app_label, opts.model_name),
1476                 "admin/{}/delete_confirmation.html".format(app_label),
1477                 "admin/delete_confirmation.html",
1478             ],
1479             context,
1480         )
1481 
1482     def get_inline_formsets(self, request, formsets, inline_instances, obj=None):
1483         # Edit permissions on parent model are required for editable inlines.
1484         can_edit_parent = self.has_change_permission(request, obj) if obj else self.has_add_permission(request)
1485         inline_admin_formsets = []
1486         for inline, formset in zip(inline_instances, formsets):
1487             fieldsets = list(inline.get_fieldsets(request, obj))
1488             readonly = list(inline.get_readonly_fields(request, obj))
1489             if can_edit_parent:
1490                 has_add_permission = inline.has_add_permission(request, obj)
1491                 has_change_permission = inline.has_change_permission(request, obj)
1492                 has_delete_permission = inline.has_delete_permission(request, obj)
1493             else:
1494                 # Disable all edit-permissions, and overide formset settings.
1495                 has_add_permission = has_change_permission = has_delete_permission = False
1496                 formset.extra = formset.max_num = 0
1497             has_view_permission = inline.has_view_permission(request, obj)
1498             prepopulated = dict(inline.get_prepopulated_fields(request, obj))
1499             inline_admin_formset = helpers.InlineAdminFormSet(
1500                 inline, formset, fieldsets, prepopulated, readonly, model_admin=self,
1501                 has_add_permission=has_add_permission, has_change_permission=has_change_permission,
1502                 has_delete_permission=has_delete_permission, has_view_permission=has_view_permission,
1503             )
1504             inline_admin_formsets.append(inline_admin_formset)
1505         return inline_admin_formsets
1506 
1507     def get_changeform_initial_data(self, request):
1508         """
1509         Get the initial form data from the request's GET params.
1510         """
1511         initial = dict(request.GET.items())
1512         for k in initial:
1513             try:
1514                 f = self.model._meta.get_field(k)
1515             except FieldDoesNotExist:
1516                 continue
1517             # We have to special-case M2Ms as a list of comma-separated PKs.
1518             if isinstance(f, models.ManyToManyField):
1519                 initial[k] = initial[k].split(",")
1520         return initial
1521 
1522     def _get_obj_does_not_exist_redirect(self, request, opts, object_id):
1523         """
1524         Create a message informing the user that the object doesn't exist
1525         and return a redirect to the admin index page.
1526         """
1527         msg = _('%(name)s with ID “%(key)s” doesn’t exist. Perhaps it was deleted?') % {
1528             'name': opts.verbose_name,
1529             'key': unquote(object_id),
1530         }
1531         self.message_user(request, msg, messages.WARNING)
1532         url = reverse('admin:index', current_app=self.admin_site.name)
1533         return HttpResponseRedirect(url)
1534 
1535     @csrf_protect_m
1536     def changeform_view(self, request, object_id=None, form_url='', extra_context=None):
1537         with transaction.atomic(using=router.db_for_write(self.model)):
1538             return self._changeform_view(request, object_id, form_url, extra_context)
1539 
1540     def _changeform_view(self, request, object_id, form_url, extra_context):
1541         to_field = request.POST.get(TO_FIELD_VAR, request.GET.get(TO_FIELD_VAR))
1542         if to_field and not self.to_field_allowed(request, to_field):
1543             raise DisallowedModelAdminToField("The field %s cannot be referenced." % to_field)
1544 
1545         model = self.model
1546         opts = model._meta
1547 
1548         if request.method == 'POST' and '_saveasnew' in request.POST:
1549             object_id = None
1550 
1551         add = object_id is None
1552 
1553         if add:
1554             if not self.has_add_permission(request):
1555                 raise PermissionDenied
1556             obj = None
1557 
1558         else:
1559             obj = self.get_object(request, unquote(object_id), to_field)
1560 
1561             if request.method == 'POST':
1562                 if not self.has_change_permission(request, obj):
1563                     raise PermissionDenied
1564             else:
1565                 if not self.has_view_or_change_permission(request, obj):
1566                     raise PermissionDenied
1567 
1568             if obj is None:
1569                 return self._get_obj_does_not_exist_redirect(request, opts, object_id)
1570 
1571         fieldsets = self.get_fieldsets(request, obj)
1572         ModelForm = self.get_form(
1573             request, obj, change=not add, fields=flatten_fieldsets(fieldsets)
1574         )
1575         if request.method == 'POST':
1576             form = ModelForm(request.POST, request.FILES, instance=obj)
1577             form_validated = form.is_valid()
1578             if form_validated:
1579                 new_object = self.save_form(request, form, change=not add)
1580             else:
1581                 new_object = form.instance
1582             formsets, inline_instances = self._create_formsets(request, new_object, change=not add)
1583             if all_valid(formsets) and form_validated:
1584                 self.save_model(request, new_object, form, not add)
1585                 self.save_related(request, form, formsets, not add)
1586                 change_message = self.construct_change_message(request, form, formsets, add)
1587                 if add:
1588                     self.log_addition(request, new_object, change_message)
1589                     return self.response_add(request, new_object)
1590                 else:
1591                     self.log_change(request, new_object, change_message)
1592                     return self.response_change(request, new_object)
1593             else:
1594                 form_validated = False
1595         else:
1596             if add:
1597                 initial = self.get_changeform_initial_data(request)
1598                 form = ModelForm(initial=initial)
1599                 formsets, inline_instances = self._create_formsets(request, form.instance, change=False)
1600             else:
1601                 form = ModelForm(instance=obj)
1602                 formsets, inline_instances = self._create_formsets(request, obj, change=True)
1603 
1604         if not add and not self.has_change_permission(request, obj):
1605             readonly_fields = flatten_fieldsets(fieldsets)
1606         else:
1607             readonly_fields = self.get_readonly_fields(request, obj)
1608         adminForm = helpers.AdminForm(
1609             form,
1610             list(fieldsets),
1611             # Clear prepopulated fields on a view-only form to avoid a crash.
1612             self.get_prepopulated_fields(request, obj) if add or self.has_change_permission(request, obj) else {},
1613             readonly_fields,
1614             model_admin=self)
1615         media = self.media + adminForm.media
1616 
1617         inline_formsets = self.get_inline_formsets(request, formsets, inline_instances, obj)
1618         for inline_formset in inline_formsets:
1619             media = media + inline_formset.media
1620 
1621         if add:
1622             title = _('Add %s')
1623         elif self.has_change_permission(request, obj):
1624             title = _('Change %s')
1625         else:
1626             title = _('View %s')
1627         context = {
1628             **self.admin_site.each_context(request),
1629             'title': title % opts.verbose_name,
1630             'subtitle': str(obj) if obj else None,
1631             'adminform': adminForm,
1632             'object_id': object_id,
1633             'original': obj,
1634             'is_popup': IS_POPUP_VAR in request.POST or IS_POPUP_VAR in request.GET,
1635             'to_field': to_field,
1636             'media': media,
1637             'inline_admin_formsets': inline_formsets,
1638             'errors': helpers.AdminErrorList(form, formsets),
1639             'preserved_filters': self.get_preserved_filters(request),
1640         }
1641 
1642         # Hide the "Save" and "Save and continue" buttons if "Save as New" was
1643         # previously chosen to prevent the interface from getting confusing.
1644         if request.method == 'POST' and not form_validated and "_saveasnew" in request.POST:
1645             context['show_save'] = False
1646             context['show_save_and_continue'] = False
1647             # Use the change template instead of the add template.
1648             add = False
1649 
1650         context.update(extra_context or {})
1651 
1652         return self.render_change_form(request, context, add=add, change=not add, obj=obj, form_url=form_url)
1653 
1654     def add_view(self, request, form_url='', extra_context=None):
1655         return self.changeform_view(request, None, form_url, extra_context)
1656 
1657     def change_view(self, request, object_id, form_url='', extra_context=None):
1658         return self.changeform_view(request, object_id, form_url, extra_context)
1659 
1660     def _get_edited_object_pks(self, request, prefix):
1661         """Return POST data values of list_editable primary keys."""
1662         pk_pattern = re.compile(
1663             r'{}-\d+-{}$'.format(re.escape(prefix), self.model._meta.pk.name)
1664         )
1665         return [value for key, value in request.POST.items() if pk_pattern.match(key)]
1666 
1667     def _get_list_editable_queryset(self, request, prefix):
1668         """
1669         Based on POST data, return a queryset of the objects that were edited
1670         via list_editable.
1671         """
1672         object_pks = self._get_edited_object_pks(request, prefix)
1673         queryset = self.get_queryset(request)
1674         validate = queryset.model._meta.pk.to_python
1675         try:
1676             for pk in object_pks:
1677                 validate(pk)
1678         except ValidationError:
1679             # Disable the optimization if the POST data was tampered with.
1680             return queryset
1681         return queryset.filter(pk__in=object_pks)
1682 
1683     @csrf_protect_m
1684     def changelist_view(self, request, extra_context=None):
1685         """
1686         The 'change list' admin view for this model.
1687         """
1688         from django.contrib.admin.views.main import ERROR_FLAG
1689         opts = self.model._meta
1690         app_label = opts.app_label
1691         if not self.has_view_or_change_permission(request):
1692             raise PermissionDenied
1693 
1694         try:
1695             cl = self.get_changelist_instance(request)
1696         except IncorrectLookupParameters:
1697             # Wacky lookup parameters were given, so redirect to the main
1698             # changelist page, without parameters, and pass an 'invalid=1'
1699             # parameter via the query string. If wacky parameters were given
1700             # and the 'invalid=1' parameter was already in the query string,
1701             # something is screwed up with the database, so display an error
1702             # page.
1703             if ERROR_FLAG in request.GET:
1704                 return SimpleTemplateResponse('admin/invalid_setup.html', {
1705                     'title': _('Database error'),
1706                 })
1707             return HttpResponseRedirect(request.path + '?' + ERROR_FLAG + '=1')
1708 
1709         # If the request was POSTed, this might be a bulk action or a bulk
1710         # edit. Try to look up an action or confirmation first, but if this
1711         # isn't an action the POST will fall through to the bulk edit check,
1712         # below.
1713         action_failed = False
1714         selected = request.POST.getlist(helpers.ACTION_CHECKBOX_NAME)
1715 
1716         actions = self.get_actions(request)
1717         # Actions with no confirmation
1718         if (actions and request.method == 'POST' and
1719                 'index' in request.POST and '_save' not in request.POST):
1720             if selected:
1721                 response = self.response_action(request, queryset=cl.get_queryset(request))
1722                 if response:
1723                     return response
1724                 else:
1725                     action_failed = True
1726             else:
1727                 msg = _("Items must be selected in order to perform "
1728                         "actions on them. No items have been changed.")
1729                 self.message_user(request, msg, messages.WARNING)
1730                 action_failed = True
1731 
1732         # Actions with confirmation
1733         if (actions and request.method == 'POST' and
1734                 helpers.ACTION_CHECKBOX_NAME in request.POST and
1735                 'index' not in request.POST and '_save' not in request.POST):
1736             if selected:
1737                 response = self.response_action(request, queryset=cl.get_queryset(request))
1738                 if response:
1739                     return response
1740                 else:
1741                     action_failed = True
1742 
1743         if action_failed:
1744             # Redirect back to the changelist page to avoid resubmitting the
1745             # form if the user refreshes the browser or uses the "No, take
1746             # me back" button on the action confirmation page.
1747             return HttpResponseRedirect(request.get_full_path())
1748 
1749         # If we're allowing changelist editing, we need to construct a formset
1750         # for the changelist given all the fields to be edited. Then we'll
1751         # use the formset to validate/process POSTed data.
1752         formset = cl.formset = None
1753 
1754         # Handle POSTed bulk-edit data.
1755         if request.method == 'POST' and cl.list_editable and '_save' in request.POST:
1756             if not self.has_change_permission(request):
1757                 raise PermissionDenied
1758             FormSet = self.get_changelist_formset(request)
1759             modified_objects = self._get_list_editable_queryset(request, FormSet.get_default_prefix())
1760             formset = cl.formset = FormSet(request.POST, request.FILES, queryset=modified_objects)
1761             if formset.is_valid():
1762                 changecount = 0
1763                 for form in formset.forms:
1764                     if form.has_changed():
1765                         obj = self.save_form(request, form, change=True)
1766                         self.save_model(request, obj, form, change=True)
1767                         self.save_related(request, form, formsets=[], change=True)
1768                         change_msg = self.construct_change_message(request, form, None)
1769                         self.log_change(request, obj, change_msg)
1770                         changecount += 1
1771 
1772                 if changecount:
1773                     msg = ngettext(
1774                         "%(count)s %(name)s was changed successfully.",
1775                         "%(count)s %(name)s were changed successfully.",
1776                         changecount
1777                     ) % {
1778                         'count': changecount,
1779                         'name': model_ngettext(opts, changecount),
1780                     }
1781                     self.message_user(request, msg, messages.SUCCESS)
1782 
1783                 return HttpResponseRedirect(request.get_full_path())
1784 
1785         # Handle GET -- construct a formset for display.
1786         elif cl.list_editable and self.has_change_permission(request):
1787             FormSet = self.get_changelist_formset(request)
1788             formset = cl.formset = FormSet(queryset=cl.result_list)
1789 
1790         # Build the list of media to be used by the formset.
1791         if formset:
1792             media = self.media + formset.media
1793         else:
1794             media = self.media
1795 
1796         # Build the action form and populate it with available actions.
1797         if actions:
1798             action_form = self.action_form(auto_id=None)
1799             action_form.fields['action'].choices = self.get_action_choices(request)
1800             media += action_form.media
1801         else:
1802             action_form = None
1803 
1804         selection_note_all = ngettext(
1805             '%(total_count)s selected',
1806             'All %(total_count)s selected',
1807             cl.result_count
1808         )
1809 
1810         context = {
1811             **self.admin_site.each_context(request),
1812             'module_name': str(opts.verbose_name_plural),
1813             'selection_note': _('0 of %(cnt)s selected') % {'cnt': len(cl.result_list)},
1814             'selection_note_all': selection_note_all % {'total_count': cl.result_count},
1815             'title': cl.title,
1816             'subtitle': None,
1817             'is_popup': cl.is_popup,
1818             'to_field': cl.to_field,
1819             'cl': cl,
1820             'media': media,
1821             'has_add_permission': self.has_add_permission(request),
1822             'opts': cl.opts,
1823             'action_form': action_form,
1824             'actions_on_top': self.actions_on_top,
1825             'actions_on_bottom': self.actions_on_bottom,
1826             'actions_selection_counter': self.actions_selection_counter,
1827             'preserved_filters': self.get_preserved_filters(request),
1828             **(extra_context or {}),
1829         }
1830 
1831         request.current_app = self.admin_site.name
1832 
1833         return TemplateResponse(request, self.change_list_template or [
1834             'admin/%s/%s/change_list.html' % (app_label, opts.model_name),
1835             'admin/%s/change_list.html' % app_label,
1836             'admin/change_list.html'
1837         ], context)
1838 
1839     def get_deleted_objects(self, objs, request):
1840         """
1841         Hook for customizing the delete process for the delete view and the
1842         "delete selected" action.
1843         """
1844         return get_deleted_objects(objs, request, self.admin_site)
1845 
1846     @csrf_protect_m
1847     def delete_view(self, request, object_id, extra_context=None):
1848         with transaction.atomic(using=router.db_for_write(self.model)):
1849             return self._delete_view(request, object_id, extra_context)
1850 
1851     def _delete_view(self, request, object_id, extra_context):
1852         "The 'delete' admin view for this model."
1853         opts = self.model._meta
1854         app_label = opts.app_label
1855 
1856         to_field = request.POST.get(TO_FIELD_VAR, request.GET.get(TO_FIELD_VAR))
1857         if to_field and not self.to_field_allowed(request, to_field):
1858             raise DisallowedModelAdminToField("The field %s cannot be referenced." % to_field)
1859 
1860         obj = self.get_object(request, unquote(object_id), to_field)
1861 
1862         if not self.has_delete_permission(request, obj):
1863             raise PermissionDenied
1864 
1865         if obj is None:
1866             return self._get_obj_does_not_exist_redirect(request, opts, object_id)
1867 
1868         # Populate deleted_objects, a data structure of all related objects that
1869         # will also be deleted.
1870         deleted_objects, model_count, perms_needed, protected = self.get_deleted_objects([obj], request)
1871 
1872         if request.POST and not protected:  # The user has confirmed the deletion.
1873             if perms_needed:
1874                 raise PermissionDenied
1875             obj_display = str(obj)
1876             attr = str(to_field) if to_field else opts.pk.attname
1877             obj_id = obj.serializable_value(attr)
1878             self.log_deletion(request, obj, obj_display)
1879             self.delete_model(request, obj)
1880 
1881             return self.response_delete(request, obj_display, obj_id)
1882 
1883         object_name = str(opts.verbose_name)
1884 
1885         if perms_needed or protected:
1886             title = _("Cannot delete %(name)s") % {"name": object_name}
1887         else:
1888             title = _("Are you sure?")
1889 
1890         context = {
1891             **self.admin_site.each_context(request),
1892             'title': title,
1893             'subtitle': None,
1894             'object_name': object_name,
1895             'object': obj,
1896             'deleted_objects': deleted_objects,
1897             'model_count': dict(model_count).items(),
1898             'perms_lacking': perms_needed,
1899             'protected': protected,
1900             'opts': opts,
1901             'app_label': app_label,
1902             'preserved_filters': self.get_preserved_filters(request),
1903             'is_popup': IS_POPUP_VAR in request.POST or IS_POPUP_VAR in request.GET,
1904             'to_field': to_field,
1905             **(extra_context or {}),
1906         }
1907 
1908         return self.render_delete_form(request, context)
1909 
1910     def history_view(self, request, object_id, extra_context=None):
1911         "The 'history' admin view for this model."
1912         from django.contrib.admin.models import LogEntry
1913 
1914         # First check if the user can see this history.
1915         model = self.model
1916         obj = self.get_object(request, unquote(object_id))
1917         if obj is None:
1918             return self._get_obj_does_not_exist_redirect(request, model._meta, object_id)
1919 
1920         if not self.has_view_or_change_permission(request, obj):
1921             raise PermissionDenied
1922 
1923         # Then get the history for this object.
1924         opts = model._meta
1925         app_label = opts.app_label
1926         action_list = LogEntry.objects.filter(
1927             object_id=unquote(object_id),
1928             content_type=get_content_type_for_model(model)
1929         ).select_related().order_by('action_time')
1930 
1931         context = {
1932             **self.admin_site.each_context(request),
1933             'title': _('Change history: %s') % obj,
1934             'subtitle': None,
1935             'action_list': action_list,
1936             'module_name': str(capfirst(opts.verbose_name_plural)),
1937             'object': obj,
1938             'opts': opts,
1939             'preserved_filters': self.get_preserved_filters(request),
1940             **(extra_context or {}),
1941         }
1942 
1943         request.current_app = self.admin_site.name
1944 
1945         return TemplateResponse(request, self.object_history_template or [
1946             "admin/%s/%s/object_history.html" % (app_label, opts.model_name),
1947             "admin/%s/object_history.html" % app_label,
1948             "admin/object_history.html"
1949         ], context)
1950 
1951     def get_formset_kwargs(self, request, obj, inline, prefix):
1952         formset_params = {
1953             'instance': obj,
1954             'prefix': prefix,
1955             'queryset': inline.get_queryset(request),
1956         }
1957         if request.method == 'POST':
1958             formset_params.update({
1959                 'data': request.POST.copy(),
1960                 'files': request.FILES,
1961                 'save_as_new': '_saveasnew' in request.POST
1962             })
1963         return formset_params
1964 
1965     def _create_formsets(self, request, obj, change):
1966         "Helper function to generate formsets for add/change_view."
1967         formsets = []
1968         inline_instances = []
1969         prefixes = {}
1970         get_formsets_args = [request]
1971         if change:
1972             get_formsets_args.append(obj)
1973         for FormSet, inline in self.get_formsets_with_inlines(*get_formsets_args):
1974             prefix = FormSet.get_default_prefix()
1975             prefixes[prefix] = prefixes.get(prefix, 0) + 1
1976             if prefixes[prefix] != 1 or not prefix:
1977                 prefix = "%s-%s" % (prefix, prefixes[prefix])
1978             formset_params = self.get_formset_kwargs(request, obj, inline, prefix)
1979             formset = FormSet(**formset_params)
1980 
1981             def user_deleted_form(request, obj, formset, index):
1982                 """Return whether or not the user deleted the form."""
1983                 return (
1984                     inline.has_delete_permission(request, obj) and
1985                     '{}-{}-DELETE'.format(formset.prefix, index) in request.POST
1986                 )
1987 
1988             # Bypass validation of each view-only inline form (since the form's
1989             # data won't be in request.POST), unless the form was deleted.
1990             if not inline.has_change_permission(request, obj if change else None):
1991                 for index, form in enumerate(formset.initial_forms):
1992                     if user_deleted_form(request, obj, formset, index):
1993                         continue
1994                     form._errors = {}
1995                     form.cleaned_data = form.initial
1996             formsets.append(formset)
1997             inline_instances.append(inline)
1998         return formsets, inline_instances

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>, <file>django/contrib/admin/views/main.py</file>
<class>None</class>
<method>None</method>
<code>
1 from datetime import datetime, timedelta
2 
3 from django import forms
4 from django.conf import settings
5 from django.contrib import messages
6 from django.contrib.admin import FieldListFilter
7 from django.contrib.admin.exceptions import (
8     DisallowedModelAdminLookup, DisallowedModelAdminToField,
9 )
10 from django.contrib.admin.options import (
11     IS_POPUP_VAR, TO_FIELD_VAR, IncorrectLookupParameters,
12 )
13 from django.contrib.admin.utils import (
14     get_fields_from_path, lookup_needs_distinct, prepare_lookup_value, quote,
15 )
16 from django.core.exceptions import (
17     FieldDoesNotExist, ImproperlyConfigured, SuspiciousOperation,
18 )
19 from django.core.paginator import InvalidPage
20 from django.db.models import F, Field, ManyToOneRel, OrderBy
21 from django.db.models.expressions import Combinable
22 from django.urls import reverse
23 from django.utils.http import urlencode
24 from django.utils.timezone import make_aware
25 from django.utils.translation import gettext
26 
27 # Changelist settings
28 ALL_VAR = 'all'
29 ORDER_VAR = 'o'
30 ORDER_TYPE_VAR = 'ot'
31 PAGE_VAR = 'p'
32 SEARCH_VAR = 'q'
33 ERROR_FLAG = 'e'
34 
35 IGNORED_PARAMS = (
36     ALL_VAR, ORDER_VAR, ORDER_TYPE_VAR, SEARCH_VAR, IS_POPUP_VAR, TO_FIELD_VAR)
37 
38 
39 class ChangeListSearchForm(forms.Form):
40     def __init__(self, *args, **kwargs):
41         super().__init__(*args, **kwargs)
42         # Populate "fields" dynamically because SEARCH_VAR is a variable:
43         self.fields = {
44             SEARCH_VAR: forms.CharField(required=False, strip=False),
45         }
46 
47 
48 class ChangeList:
49     search_form_class = ChangeListSearchForm
50 
51     def __init__(self, request, model, list_display, list_display_links,
52                  list_filter, date_hierarchy, search_fields, list_select_related,
53                  list_per_page, list_max_show_all, list_editable, model_admin, sortable_by):
54         self.model = model
55         self.opts = model._meta
56         self.lookup_opts = self.opts
57         self.root_queryset = model_admin.get_queryset(request)
58         self.list_display = list_display
59         self.list_display_links = list_display_links
60         self.list_filter = list_filter
61         self.has_filters = None
62         self.has_active_filters = None
63         self.clear_all_filters_qs = None
64         self.date_hierarchy = date_hierarchy
65         self.search_fields = search_fields
66         self.list_select_related = list_select_related
67         self.list_per_page = list_per_page
68         self.list_max_show_all = list_max_show_all
69         self.model_admin = model_admin
70         self.preserved_filters = model_admin.get_preserved_filters(request)
71         self.sortable_by = sortable_by
72 
73         # Get search parameters from the query string.
74         _search_form = self.search_form_class(request.GET)
75         if not _search_form.is_valid():
76             for error in _search_form.errors.values():
77                 messages.error(request, ', '.join(error))
78         self.query = _search_form.cleaned_data.get(SEARCH_VAR) or ''
79         try:
80             self.page_num = int(request.GET.get(PAGE_VAR, 1))
81         except ValueError:
82             self.page_num = 1
83         self.show_all = ALL_VAR in request.GET
84         self.is_popup = IS_POPUP_VAR in request.GET
85         to_field = request.GET.get(TO_FIELD_VAR)
86         if to_field and not model_admin.to_field_allowed(request, to_field):
87             raise DisallowedModelAdminToField("The field %s cannot be referenced." % to_field)
88         self.to_field = to_field
89         self.params = dict(request.GET.items())
90         if PAGE_VAR in self.params:
91             del self.params[PAGE_VAR]
92         if ERROR_FLAG in self.params:
93             del self.params[ERROR_FLAG]
94 
95         if self.is_popup:
96             self.list_editable = ()
97         else:
98             self.list_editable = list_editable
99         self.queryset = self.get_queryset(request)
100         self.get_results(request)
101         if self.is_popup:
102             title = gettext('Select %s')
103         elif self.model_admin.has_change_permission(request):
104             title = gettext('Select %s to change')
105         else:
106             title = gettext('Select %s to view')
107         self.title = title % self.opts.verbose_name
108         self.pk_attname = self.lookup_opts.pk.attname
109 
110     def get_filters_params(self, params=None):
111         """
112         Return all params except IGNORED_PARAMS.
113         """
114         params = params or self.params
115         lookup_params = params.copy()  # a dictionary of the query string
116         # Remove all the parameters that are globally and systematically
117         # ignored.
118         for ignored in IGNORED_PARAMS:
119             if ignored in lookup_params:
120                 del lookup_params[ignored]
121         return lookup_params
122 
123     def get_filters(self, request):
124         lookup_params = self.get_filters_params()
125         use_distinct = False
126         has_active_filters = False
127 
128         for key, value in lookup_params.items():
129             if not self.model_admin.lookup_allowed(key, value):
130                 raise DisallowedModelAdminLookup("Filtering by %s not allowed" % key)
131 
132         filter_specs = []
133         for list_filter in self.list_filter:
134             lookup_params_count = len(lookup_params)
135             if callable(list_filter):
136                 # This is simply a custom list filter class.
137                 spec = list_filter(request, lookup_params, self.model, self.model_admin)
138             else:
139                 field_path = None
140                 if isinstance(list_filter, (tuple, list)):
141                     # This is a custom FieldListFilter class for a given field.
142                     field, field_list_filter_class = list_filter
143                 else:
144                     # This is simply a field name, so use the default
145                     # FieldListFilter class that has been registered for the
146                     # type of the given field.
147                     field, field_list_filter_class = list_filter, FieldListFilter.create
148                 if not isinstance(field, Field):
149                     field_path = field
150                     field = get_fields_from_path(self.model, field_path)[-1]
151 
152                 spec = field_list_filter_class(
153                     field, request, lookup_params,
154                     self.model, self.model_admin, field_path=field_path,
155                 )
156                 # field_list_filter_class removes any lookup_params it
157                 # processes. If that happened, check if distinct() is needed to
158                 # remove duplicate results.
159                 if lookup_params_count > len(lookup_params):
160                     use_distinct = use_distinct or lookup_needs_distinct(self.lookup_opts, field_path)
161             if spec and spec.has_output():
162                 filter_specs.append(spec)
163                 if lookup_params_count > len(lookup_params):
164                     has_active_filters = True
165 
166         if self.date_hierarchy:
167             # Create bounded lookup parameters so that the query is more
168             # efficient.
169             year = lookup_params.pop('%s__year' % self.date_hierarchy, None)
170             if year is not None:
171                 month = lookup_params.pop('%s__month' % self.date_hierarchy, None)
172                 day = lookup_params.pop('%s__day' % self.date_hierarchy, None)
173                 try:
174                     from_date = datetime(
175                         int(year),
176                         int(month if month is not None else 1),
177                         int(day if day is not None else 1),
178                     )
179                 except ValueError as e:
180                     raise IncorrectLookupParameters(e) from e
181                 if day:
182                     to_date = from_date + timedelta(days=1)
183                 elif month:
184                     # In this branch, from_date will always be the first of a
185                     # month, so advancing 32 days gives the next month.
186                     to_date = (from_date + timedelta(days=32)).replace(day=1)
187                 else:
188                     to_date = from_date.replace(year=from_date.year + 1)
189                 if settings.USE_TZ:
190                     from_date = make_aware(from_date)
191                     to_date = make_aware(to_date)
192                 lookup_params.update({
193                     '%s__gte' % self.date_hierarchy: from_date,
194                     '%s__lt' % self.date_hierarchy: to_date,
195                 })
196 
197         # At this point, all the parameters used by the various ListFilters
198         # have been removed from lookup_params, which now only contains other
199         # parameters passed via the query string. We now loop through the
200         # remaining parameters both to ensure that all the parameters are valid
201         # fields and to determine if at least one of them needs distinct(). If
202         # the lookup parameters aren't real fields, then bail out.
203         try:
204             for key, value in lookup_params.items():
205                 lookup_params[key] = prepare_lookup_value(key, value)
206                 use_distinct = use_distinct or lookup_needs_distinct(self.lookup_opts, key)
207             return (
208                 filter_specs, bool(filter_specs), lookup_params, use_distinct,
209                 has_active_filters,
210             )
211         except FieldDoesNotExist as e:
212             raise IncorrectLookupParameters(e) from e
213 
214     def get_query_string(self, new_params=None, remove=None):
215         if new_params is None:
216             new_params = {}
217         if remove is None:
218             remove = []
219         p = self.params.copy()
220         for r in remove:
221             for k in list(p):
222                 if k.startswith(r):
223                     del p[k]
224         for k, v in new_params.items():
225             if v is None:
226                 if k in p:
227                     del p[k]
228             else:
229                 p[k] = v
230         return '?%s' % urlencode(sorted(p.items()))
231 
232     def get_results(self, request):
233         paginator = self.model_admin.get_paginator(request, self.queryset, self.list_per_page)
234         # Get the number of objects, with admin filters applied.
235         result_count = paginator.count
236 
237         # Get the total number of objects, with no admin filters applied.
238         if self.model_admin.show_full_result_count:
239             full_result_count = self.root_queryset.count()
240         else:
241             full_result_count = None
242         can_show_all = result_count <= self.list_max_show_all
243         multi_page = result_count > self.list_per_page
244 
245         # Get the list of objects to display on this page.
246         if (self.show_all and can_show_all) or not multi_page:
247             result_list = self.queryset._clone()
248         else:
249             try:
250                 result_list = paginator.page(self.page_num).object_list
251             except InvalidPage:
252                 raise IncorrectLookupParameters
253 
254         self.result_count = result_count
255         self.show_full_result_count = self.model_admin.show_full_result_count
256         # Admin actions are shown if there is at least one entry
257         # or if entries are not counted because show_full_result_count is disabled
258         self.show_admin_actions = not self.show_full_result_count or bool(full_result_count)
259         self.full_result_count = full_result_count
260         self.result_list = result_list
261         self.can_show_all = can_show_all
262         self.multi_page = multi_page
263         self.paginator = paginator
264 
265     def _get_default_ordering(self):
266         ordering = []
267         if self.model_admin.ordering:
268             ordering = self.model_admin.ordering
269         elif self.lookup_opts.ordering:
270             ordering = self.lookup_opts.ordering
271         return ordering
272 
273     def get_ordering_field(self, field_name):
274         """
275         Return the proper model field name corresponding to the given
276         field_name to use for ordering. field_name may either be the name of a
277         proper model field or the name of a method (on the admin or model) or a
278         callable with the 'admin_order_field' attribute. Return None if no
279         proper model field name can be matched.
280         """
281         try:
282             field = self.lookup_opts.get_field(field_name)
283             return field.name
284         except FieldDoesNotExist:
285             # See whether field_name is a name of a non-field
286             # that allows sorting.
287             if callable(field_name):
288                 attr = field_name
289             elif hasattr(self.model_admin, field_name):
290                 attr = getattr(self.model_admin, field_name)
291             else:
292                 attr = getattr(self.model, field_name)
293             if isinstance(attr, property) and hasattr(attr, 'fget'):
294                 attr = attr.fget
295             return getattr(attr, 'admin_order_field', None)
296 
297     def get_ordering(self, request, queryset):
298         """
299         Return the list of ordering fields for the change list.
300         First check the get_ordering() method in model admin, then check
301         the object's default ordering. Then, any manually-specified ordering
302         from the query string overrides anything. Finally, a deterministic
303         order is guaranteed by calling _get_deterministic_ordering() with the
304         constructed ordering.
305         """
306         params = self.params
307         ordering = list(self.model_admin.get_ordering(request) or self._get_default_ordering())
308         if ORDER_VAR in params:
309             # Clear ordering and used params
310             ordering = []
311             order_params = params[ORDER_VAR].split('.')
312             for p in order_params:
313                 try:
314                     none, pfx, idx = p.rpartition('-')
315                     field_name = self.list_display[int(idx)]
316                     order_field = self.get_ordering_field(field_name)
317                     if not order_field:
318                         continue  # No 'admin_order_field', skip it
319                     if isinstance(order_field, OrderBy):
320                         if pfx == '-':
321                             order_field = order_field.copy()
322                             order_field.reverse_ordering()
323                         ordering.append(order_field)
324                     elif hasattr(order_field, 'resolve_expression'):
325                         # order_field is an expression.
326                         ordering.append(order_field.desc() if pfx == '-' else order_field.asc())
327                     # reverse order if order_field has already "-" as prefix
328                     elif order_field.startswith('-') and pfx == '-':
329                         ordering.append(order_field[1:])
330                     else:
331                         ordering.append(pfx + order_field)
332                 except (IndexError, ValueError):
333                     continue  # Invalid ordering specified, skip it.
334 
335         # Add the given query's ordering fields, if any.
336         ordering.extend(queryset.query.order_by)
337 
338         return self._get_deterministic_ordering(ordering)
339 
340     def _get_deterministic_ordering(self, ordering):
341         """
342         Ensure a deterministic order across all database backends. Search for a
343         single field or unique together set of fields providing a total
344         ordering. If these are missing, augment the ordering with a descendant
345         primary key.
346         """
347         ordering = list(ordering)
348         ordering_fields = set()
349         total_ordering_fields = {'pk'} | {
350             field.attname for field in self.lookup_opts.fields
351             if field.unique and not field.null
352         }
353         for part in ordering:
354             # Search for single field providing a total ordering.
355             field_name = None
356             if isinstance(part, str):
357                 field_name = part.lstrip('-')
358             elif isinstance(part, F):
359                 field_name = part.name
360             elif isinstance(part, OrderBy) and isinstance(part.expression, F):
361                 field_name = part.expression.name
362             if field_name:
363                 # Normalize attname references by using get_field().
364                 try:
365                     field = self.lookup_opts.get_field(field_name)
366                 except FieldDoesNotExist:
367                     # Could be "?" for random ordering or a related field
368                     # lookup. Skip this part of introspection for now.
369                     continue
370                 # Ordering by a related field name orders by the referenced
371                 # model's ordering. Skip this part of introspection for now.
372                 if field.remote_field and field_name == field.name:
373                     continue
374                 if field.attname in total_ordering_fields:
375                     break
376                 ordering_fields.add(field.attname)
377         else:
378             # No single total ordering field, try unique_together and total
379             # unique constraints.
380             constraint_field_names = (
381                 *self.lookup_opts.unique_together,
382                 *(
383                     constraint.fields
384                     for constraint in self.lookup_opts.total_unique_constraints
385                 ),
386             )
387             for field_names in constraint_field_names:
388                 # Normalize attname references by using get_field().
389                 fields = [self.lookup_opts.get_field(field_name) for field_name in field_names]
390                 # Composite unique constraints containing a nullable column
391                 # cannot ensure total ordering.
392                 if any(field.null for field in fields):
393                     continue
394                 if ordering_fields.issuperset(field.attname for field in fields):
395                     break
396             else:
397                 # If no set of unique fields is present in the ordering, rely
398                 # on the primary key to provide total ordering.
399                 ordering.append('-pk')
400         return ordering
401 
402     def get_ordering_field_columns(self):
403         """
404         Return a dictionary of ordering field column numbers and asc/desc.
405         """
406         # We must cope with more than one column having the same underlying sort
407         # field, so we base things on column numbers.
408         ordering = self._get_default_ordering()
409         ordering_fields = {}
410         if ORDER_VAR not in self.params:
411             # for ordering specified on ModelAdmin or model Meta, we don't know
412             # the right column numbers absolutely, because there might be more
413             # than one column associated with that ordering, so we guess.
414             for field in ordering:
415                 if isinstance(field, (Combinable, OrderBy)):
416                     if not isinstance(field, OrderBy):
417                         field = field.asc()
418                     if isinstance(field.expression, F):
419                         order_type = 'desc' if field.descending else 'asc'
420                         field = field.expression.name
421                     else:
422                         continue
423                 elif field.startswith('-'):
424                     field = field[1:]
425                     order_type = 'desc'
426                 else:
427                     order_type = 'asc'
428                 for index, attr in enumerate(self.list_display):
429                     if self.get_ordering_field(attr) == field:
430                         ordering_fields[index] = order_type
431                         break
432         else:
433             for p in self.params[ORDER_VAR].split('.'):
434                 none, pfx, idx = p.rpartition('-')
435                 try:
436                     idx = int(idx)
437                 except ValueError:
438                     continue  # skip it
439                 ordering_fields[idx] = 'desc' if pfx == '-' else 'asc'
440         return ordering_fields
441 
442     def get_queryset(self, request):
443         # First, we collect all the declared list filters.
444         (
445             self.filter_specs,
446             self.has_filters,
447             remaining_lookup_params,
448             filters_use_distinct,
449             self.has_active_filters,
450         ) = self.get_filters(request)
451         # Then, we let every list filter modify the queryset to its liking.
452         qs = self.root_queryset
453         for filter_spec in self.filter_specs:
454             new_qs = filter_spec.queryset(request, qs)
455             if new_qs is not None:
456                 qs = new_qs
457 
458         try:
459             # Finally, we apply the remaining lookup parameters from the query
460             # string (i.e. those that haven't already been processed by the
461             # filters).
462             qs = qs.filter(**remaining_lookup_params)
463         except (SuspiciousOperation, ImproperlyConfigured):
464             # Allow certain types of errors to be re-raised as-is so that the
465             # caller can treat them in a special way.
466             raise
467         except Exception as e:
468             # Every other error is caught with a naked except, because we don't
469             # have any other way of validating lookup parameters. They might be
470             # invalid if the keyword arguments are incorrect, or if the values
471             # are not in the correct type, so we might get FieldError,
472             # ValueError, ValidationError, or ?.
473             raise IncorrectLookupParameters(e)
474 
475         if not qs.query.select_related:
476             qs = self.apply_select_related(qs)
477 
478         # Set ordering.
479         ordering = self.get_ordering(request, qs)
480         qs = qs.order_by(*ordering)
481 
482         # Apply search results
483         qs, search_use_distinct = self.model_admin.get_search_results(request, qs, self.query)
484 
485         # Set query string for clearing all filters.
486         self.clear_all_filters_qs = self.get_query_string(
487             new_params=remaining_lookup_params,
488             remove=self.get_filters_params(),
489         )
490         # Remove duplicates from results, if necessary
491         if filters_use_distinct | search_use_distinct:
492             return qs.distinct()
493         else:
494             return qs
495 
496     def apply_select_related(self, qs):
497         if self.list_select_related is True:
498             return qs.select_related()
499 
500         if self.list_select_related is False:
501             if self.has_related_field_in_list_display():
502                 return qs.select_related()
503 
504         if self.list_select_related:
505             return qs.select_related(*self.list_select_related)
506         return qs
507 
508     def has_related_field_in_list_display(self):
509         for field_name in self.list_display:
510             try:
511                 field = self.lookup_opts.get_field(field_name)
512             except FieldDoesNotExist:
513                 pass
514             else:
515                 if isinstance(field.remote_field, ManyToOneRel):
516                     # <FK>_id field names don't require a join.
517                     if field_name != field.get_attname():
518                         return True
519         return False
520 
521     def url_for_result(self, result):
522         pk = getattr(result, self.pk_attname)
523         return reverse('admin:%s_%s_change' % (self.opts.app_label,
524                                                self.opts.model_name),
525                        args=(quote(pk),),
526                        current_app=self.model_admin.admin_site.name)

</code><intended_behavior>The code handling search queries in the admin page that involves many-to-many fields (directly or indirectly) needs to ensure that the operations following a search, such as delete, do not fail because of intermediate query modifications like distinct(). Here, the solution might involve reworking how search querysets are prepared or offering an alternative path for delete actions that does not rely on potentially modified querysets containing distinct(). This ensures the admin interface remains robust, supporting both complex searches and bulk actions without leading to exceptions.</intended_behavior>]
2025-10-15 05:47:56.553 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-15 05:47:56.553 | INFO     | Search-only: skipping patch selection
2025-10-15 05:47:56.689 | INFO     | Task django__django-14313 completed successfully.
2025-10-15 05:47:56.690 | INFO     | No patch generated. You can try running ACR again.
