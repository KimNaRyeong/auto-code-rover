[
    {
        "rel_file_path": "sphinx/pycode/parser.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sphinx-doc__sphinx/setup_sphinx-doc__sphinx__3.5/sphinx/pycode/parser.py",
        "start": 1,
        "end": 576,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\"\n2     sphinx.pycode.parser\n3     ~~~~~~~~~~~~~~~~~~~~\n4 \n5     Utilities parsing and analyzing Python code.\n6 \n7     :copyright: Copyright 2007-2021 by the Sphinx team, see AUTHORS.\n8     :license: BSD, see LICENSE for details.\n9 \"\"\"\n10 import inspect\n11 import itertools\n12 import re\n13 import sys\n14 import tokenize\n15 from collections import OrderedDict\n16 from inspect import Signature\n17 from token import DEDENT, INDENT, NAME, NEWLINE, NUMBER, OP, STRING\n18 from tokenize import COMMENT, NL\n19 from typing import Any, Dict, List, Optional, Tuple\n20 \n21 from sphinx.pycode.ast import ast  # for py37 or older\n22 from sphinx.pycode.ast import parse, unparse\n23 \n24 comment_re = re.compile('^\\\\s*#: ?(.*)\\r?\\n?$')\n25 indent_re = re.compile('^\\\\s*$')\n26 emptyline_re = re.compile('^\\\\s*(#.*)?$')\n27 \n28 \n29 if sys.version_info >= (3, 6):\n30     ASSIGN_NODES = (ast.Assign, ast.AnnAssign)\n31 else:\n32     ASSIGN_NODES = (ast.Assign)\n33 \n34 \n35 def filter_whitespace(code: str) -> str:\n36     return code.replace('\\f', ' ')  # replace FF (form feed) with whitespace\n37 \n38 \n39 def get_assign_targets(node: ast.AST) -> List[ast.expr]:\n40     \"\"\"Get list of targets from Assign and AnnAssign node.\"\"\"\n41     if isinstance(node, ast.Assign):\n42         return node.targets\n43     else:\n44         return [node.target]  # type: ignore\n45 \n46 \n47 def get_lvar_names(node: ast.AST, self: ast.arg = None) -> List[str]:\n48     \"\"\"Convert assignment-AST to variable names.\n49 \n50     This raises `TypeError` if the assignment does not create new variable::\n51 \n52         ary[0] = 'foo'\n53         dic[\"bar\"] = 'baz'\n54         # => TypeError\n55     \"\"\"\n56     if self:\n57         self_id = self.arg\n58 \n59     node_name = node.__class__.__name__\n60     if node_name in ('Index', 'Num', 'Slice', 'Str', 'Subscript'):\n61         raise TypeError('%r does not create new variable' % node)\n62     elif node_name == 'Name':\n63         if self is None or node.id == self_id:  # type: ignore\n64             return [node.id]  # type: ignore\n65         else:\n66             raise TypeError('The assignment %r is not instance variable' % node)\n67     elif node_name in ('Tuple', 'List'):\n68         members = []\n69         for elt in node.elts:  # type: ignore\n70             try:\n71                 members.extend(get_lvar_names(elt, self))\n72             except TypeError:\n73                 pass\n74         return members\n75     elif node_name == 'Attribute':\n76         if node.value.__class__.__name__ == 'Name' and self and node.value.id == self_id:  # type: ignore  # NOQA\n77             # instance variable\n78             return [\"%s\" % get_lvar_names(node.attr, self)[0]]  # type: ignore\n79         else:\n80             raise TypeError('The assignment %r is not instance variable' % node)\n81     elif node_name == 'str':\n82         return [node]  # type: ignore\n83     elif node_name == 'Starred':\n84         return get_lvar_names(node.value, self)  # type: ignore\n85     else:\n86         raise NotImplementedError('Unexpected node name %r' % node_name)\n87 \n88 \n89 def dedent_docstring(s: str) -> str:\n90     \"\"\"Remove common leading indentation from docstring.\"\"\"\n91     def dummy() -> None:\n92         # dummy function to mock `inspect.getdoc`.\n93         pass\n94 \n95     dummy.__doc__ = s\n96     docstring = inspect.getdoc(dummy)\n97     return docstring.lstrip(\"\\r\\n\").rstrip(\"\\r\\n\")\n98 \n99 \n100 class Token:\n101     \"\"\"Better token wrapper for tokenize module.\"\"\"\n102 \n103     def __init__(self, kind: int, value: Any, start: Tuple[int, int], end: Tuple[int, int],\n104                  source: str) -> None:\n105         self.kind = kind\n106         self.value = value\n107         self.start = start\n108         self.end = end\n109         self.source = source\n110 \n111     def __eq__(self, other: Any) -> bool:\n112         if isinstance(other, int):\n113             return self.kind == other\n114         elif isinstance(other, str):\n115             return self.value == other\n116         elif isinstance(other, (list, tuple)):\n117             return [self.kind, self.value] == list(other)\n118         elif other is None:\n119             return False\n120         else:\n121             raise ValueError('Unknown value: %r' % other)\n122 \n123     def match(self, *conditions: Any) -> bool:\n124         return any(self == candidate for candidate in conditions)\n125 \n126     def __repr__(self) -> str:\n127         return '<Token kind=%r value=%r>' % (tokenize.tok_name[self.kind],\n128                                              self.value.strip())\n129 \n130 \n131 class TokenProcessor:\n132     def __init__(self, buffers: List[str]) -> None:\n133         lines = iter(buffers)\n134         self.buffers = buffers\n135         self.tokens = tokenize.generate_tokens(lambda: next(lines))\n136         self.current = None     # type: Token\n137         self.previous = None    # type: Token\n138 \n139     def get_line(self, lineno: int) -> str:\n140         \"\"\"Returns specified line.\"\"\"\n141         return self.buffers[lineno - 1]\n142 \n143     def fetch_token(self) -> Token:\n144         \"\"\"Fetch a next token from source code.\n145 \n146         Returns ``None`` if sequence finished.\n147         \"\"\"\n148         try:\n149             self.previous = self.current\n150             self.current = Token(*next(self.tokens))\n151         except StopIteration:\n152             self.current = None\n153 \n154         return self.current\n155 \n156     def fetch_until(self, condition: Any) -> List[Token]:\n157         \"\"\"Fetch tokens until specified token appeared.\n158 \n159         .. note:: This also handles parenthesis well.\n160         \"\"\"\n161         tokens = []\n162         while self.fetch_token():\n163             tokens.append(self.current)\n164             if self.current == condition:\n165                 break\n166             elif self.current == [OP, '(']:\n167                 tokens += self.fetch_until([OP, ')'])\n168             elif self.current == [OP, '{']:\n169                 tokens += self.fetch_until([OP, '}'])\n170             elif self.current == [OP, '[']:\n171                 tokens += self.fetch_until([OP, ']'])\n172 \n173         return tokens\n174 \n175 \n176 class AfterCommentParser(TokenProcessor):\n177     \"\"\"Python source code parser to pick up comment after assignment.\n178 \n179     This parser takes a python code starts with assignment statement,\n180     and returns the comments for variable if exists.\n181     \"\"\"\n182 \n183     def __init__(self, lines: List[str]) -> None:\n184         super().__init__(lines)\n185         self.comment = None  # type: str\n186 \n187     def fetch_rvalue(self) -> List[Token]:\n188         \"\"\"Fetch right-hand value of assignment.\"\"\"\n189         tokens = []\n190         while self.fetch_token():\n191             tokens.append(self.current)\n192             if self.current == [OP, '(']:\n193                 tokens += self.fetch_until([OP, ')'])\n194             elif self.current == [OP, '{']:\n195                 tokens += self.fetch_until([OP, '}'])\n196             elif self.current == [OP, '[']:\n197                 tokens += self.fetch_until([OP, ']'])\n198             elif self.current == INDENT:\n199                 tokens += self.fetch_until(DEDENT)\n200             elif self.current == [OP, ';']:\n201                 break\n202             elif self.current.kind not in (OP, NAME, NUMBER, STRING):\n203                 break\n204 \n205         return tokens\n206 \n207     def parse(self) -> None:\n208         \"\"\"Parse the code and obtain comment after assignment.\"\"\"\n209         # skip lvalue (or whole of AnnAssign)\n210         while not self.fetch_token().match([OP, '='], NEWLINE, COMMENT):\n211             assert self.current\n212 \n213         # skip rvalue (if exists)\n214         if self.current == [OP, '=']:\n215             self.fetch_rvalue()\n216 \n217         if self.current == COMMENT:\n218             self.comment = self.current.value\n219 \n220 \n221 class VariableCommentPicker(ast.NodeVisitor):\n222     \"\"\"Python source code parser to pick up variable comments.\"\"\"\n223 \n224     def __init__(self, buffers: List[str], encoding: str) -> None:\n225         self.counter = itertools.count()\n226         self.buffers = buffers\n227         self.encoding = encoding\n228         self.context = []               # type: List[str]\n229         self.current_classes = []       # type: List[str]\n230         self.current_function = None    # type: ast.FunctionDef\n231         self.comments = OrderedDict()   # type: Dict[Tuple[str, str], str]\n232         self.annotations = {}           # type: Dict[Tuple[str, str], str]\n233         self.previous = None            # type: ast.AST\n234         self.deforders = {}             # type: Dict[str, int]\n235         self.finals = []                # type: List[str]\n236         self.overloads = {}             # type: Dict[str, List[Signature]]\n237         self.typing = None              # type: str\n238         self.typing_final = None        # type: str\n239         self.typing_overload = None     # type: str\n240         super().__init__()\n241 \n242     def get_qualname_for(self, name: str) -> Optional[List[str]]:\n243         \"\"\"Get qualified name for given object as a list of string.\"\"\"\n244         if self.current_function:\n245             if self.current_classes and self.context[-1] == \"__init__\":\n246                 # store variable comments inside __init__ method of classes\n247                 return self.context[:-1] + [name]\n248             else:\n249                 return None\n250         else:\n251             return self.context + [name]\n252 \n253     def add_entry(self, name: str) -> None:\n254         qualname = self.get_qualname_for(name)\n255         if qualname:\n256             self.deforders[\".\".join(qualname)] = next(self.counter)\n257 \n258     def add_final_entry(self, name: str) -> None:\n259         qualname = self.get_qualname_for(name)\n260         if qualname:\n261             self.finals.append(\".\".join(qualname))\n262 \n263     def add_overload_entry(self, func: ast.FunctionDef) -> None:\n264         # avoid circular import problem\n265         from sphinx.util.inspect import signature_from_ast\n266         qualname = self.get_qualname_for(func.name)\n267         if qualname:\n268             overloads = self.overloads.setdefault(\".\".join(qualname), [])\n269             overloads.append(signature_from_ast(func))\n270 \n271     def add_variable_comment(self, name: str, comment: str) -> None:\n272         qualname = self.get_qualname_for(name)\n273         if qualname:\n274             basename = \".\".join(qualname[:-1])\n275             self.comments[(basename, name)] = comment\n276 \n277     def add_variable_annotation(self, name: str, annotation: ast.AST) -> None:\n278         qualname = self.get_qualname_for(name)\n279         if qualname:\n280             basename = \".\".join(qualname[:-1])\n281             self.annotations[(basename, name)] = unparse(annotation)\n282 \n283     def is_final(self, decorators: List[ast.expr]) -> bool:\n284         final = []\n285         if self.typing:\n286             final.append('%s.final' % self.typing)\n287         if self.typing_final:\n288             final.append(self.typing_final)\n289 \n290         for decorator in decorators:\n291             try:\n292                 if unparse(decorator) in final:\n293                     return True\n294             except NotImplementedError:\n295                 pass\n296 \n297         return False\n298 \n299     def is_overload(self, decorators: List[ast.expr]) -> bool:\n300         overload = []\n301         if self.typing:\n302             overload.append('%s.overload' % self.typing)\n303         if self.typing_overload:\n304             overload.append(self.typing_overload)\n305 \n306         for decorator in decorators:\n307             try:\n308                 if unparse(decorator) in overload:\n309                     return True\n310             except NotImplementedError:\n311                 pass\n312 \n313         return False\n314 \n315     def get_self(self) -> ast.arg:\n316         \"\"\"Returns the name of first argument if in function.\"\"\"\n317         if self.current_function and self.current_function.args.args:\n318             return self.current_function.args.args[0]\n319         else:\n320             return None\n321 \n322     def get_line(self, lineno: int) -> str:\n323         \"\"\"Returns specified line.\"\"\"\n324         return self.buffers[lineno - 1]\n325 \n326     def visit(self, node: ast.AST) -> None:\n327         \"\"\"Updates self.previous to .\"\"\"\n328         super().visit(node)\n329         self.previous = node\n330 \n331     def visit_Import(self, node: ast.Import) -> None:\n332         \"\"\"Handles Import node and record it to definition orders.\"\"\"\n333         for name in node.names:\n334             self.add_entry(name.asname or name.name)\n335 \n336             if name.name == 'typing':\n337                 self.typing = name.asname or name.name\n338             elif name.name == 'typing.final':\n339                 self.typing_final = name.asname or name.name\n340             elif name.name == 'typing.overload':\n341                 self.typing_overload = name.asname or name.name\n342 \n343     def visit_ImportFrom(self, node: ast.ImportFrom) -> None:\n344         \"\"\"Handles Import node and record it to definition orders.\"\"\"\n345         for name in node.names:\n346             self.add_entry(name.asname or name.name)\n347 \n348             if node.module == 'typing' and name.name == 'final':\n349                 self.typing_final = name.asname or name.name\n350             elif node.module == 'typing' and name.name == 'overload':\n351                 self.typing_overload = name.asname or name.name\n352 \n353     def visit_Assign(self, node: ast.Assign) -> None:\n354         \"\"\"Handles Assign node and pick up a variable comment.\"\"\"\n355         try:\n356             targets = get_assign_targets(node)\n357             varnames = sum([get_lvar_names(t, self=self.get_self()) for t in targets], [])  # type: List[str]  # NOQA\n358             current_line = self.get_line(node.lineno)\n359         except TypeError:\n360             return  # this assignment is not new definition!\n361 \n362         # record annotation\n363         if hasattr(node, 'annotation') and node.annotation:  # type: ignore\n364             for varname in varnames:\n365                 self.add_variable_annotation(varname, node.annotation)  # type: ignore\n366         elif hasattr(node, 'type_comment') and node.type_comment:\n367             for varname in varnames:\n368                 self.add_variable_annotation(varname, node.type_comment)  # type: ignore\n369 \n370         # check comments after assignment\n371         parser = AfterCommentParser([current_line[node.col_offset:]] +\n372                                     self.buffers[node.lineno:])\n373         parser.parse()\n374         if parser.comment and comment_re.match(parser.comment):\n375             for varname in varnames:\n376                 self.add_variable_comment(varname, comment_re.sub('\\\\1', parser.comment))\n377                 self.add_entry(varname)\n378             return\n379 \n380         # check comments before assignment\n381         if indent_re.match(current_line[:node.col_offset]):\n382             comment_lines = []\n383             for i in range(node.lineno - 1):\n384                 before_line = self.get_line(node.lineno - 1 - i)\n385                 if comment_re.match(before_line):\n386                     comment_lines.append(comment_re.sub('\\\\1', before_line))\n387                 else:\n388                     break\n389 \n390             if comment_lines:\n391                 comment = dedent_docstring('\\n'.join(reversed(comment_lines)))\n392                 for varname in varnames:\n393                     self.add_variable_comment(varname, comment)\n394                     self.add_entry(varname)\n395                 return\n396 \n397         # not commented (record deforders only)\n398         for varname in varnames:\n399             self.add_entry(varname)\n400 \n401     def visit_AnnAssign(self, node: ast.AST) -> None:  # Note: ast.AnnAssign not found in py35\n402         \"\"\"Handles AnnAssign node and pick up a variable comment.\"\"\"\n403         self.visit_Assign(node)  # type: ignore\n404 \n405     def visit_Expr(self, node: ast.Expr) -> None:\n406         \"\"\"Handles Expr node and pick up a comment if string.\"\"\"\n407         if (isinstance(self.previous, ASSIGN_NODES) and isinstance(node.value, ast.Str)):\n408             try:\n409                 targets = get_assign_targets(self.previous)\n410                 varnames = get_lvar_names(targets[0], self.get_self())\n411                 for varname in varnames:\n412                     if isinstance(node.value.s, str):\n413                         docstring = node.value.s\n414                     else:\n415                         docstring = node.value.s.decode(self.encoding or 'utf-8')\n416 \n417                     self.add_variable_comment(varname, dedent_docstring(docstring))\n418                     self.add_entry(varname)\n419             except TypeError:\n420                 pass  # this assignment is not new definition!\n421 \n422     def visit_Try(self, node: ast.Try) -> None:\n423         \"\"\"Handles Try node and processes body and else-clause.\n424 \n425         .. note:: pycode parser ignores objects definition in except-clause.\n426         \"\"\"\n427         for subnode in node.body:\n428             self.visit(subnode)\n429         for subnode in node.orelse:\n430             self.visit(subnode)\n431 \n432     def visit_ClassDef(self, node: ast.ClassDef) -> None:\n433         \"\"\"Handles ClassDef node and set context.\"\"\"\n434         self.current_classes.append(node.name)\n435         self.add_entry(node.name)\n436         if self.is_final(node.decorator_list):\n437             self.add_final_entry(node.name)\n438         self.context.append(node.name)\n439         self.previous = node\n440         for child in node.body:\n441             self.visit(child)\n442         self.context.pop()\n443         self.current_classes.pop()\n444 \n445     def visit_FunctionDef(self, node: ast.FunctionDef) -> None:\n446         \"\"\"Handles FunctionDef node and set context.\"\"\"\n447         if self.current_function is None:\n448             self.add_entry(node.name)  # should be called before setting self.current_function\n449             if self.is_final(node.decorator_list):\n450                 self.add_final_entry(node.name)\n451             if self.is_overload(node.decorator_list):\n452                 self.add_overload_entry(node)\n453             self.context.append(node.name)\n454             self.current_function = node\n455             for child in node.body:\n456                 self.visit(child)\n457             self.context.pop()\n458             self.current_function = None\n459 \n460     def visit_AsyncFunctionDef(self, node: ast.AsyncFunctionDef) -> None:\n461         \"\"\"Handles AsyncFunctionDef node and set context.\"\"\"\n462         self.visit_FunctionDef(node)  # type: ignore\n463 \n464 \n465 class DefinitionFinder(TokenProcessor):\n466     \"\"\"Python source code parser to detect location of functions,\n467     classes and methods.\n468     \"\"\"\n469 \n470     def __init__(self, lines: List[str]) -> None:\n471         super().__init__(lines)\n472         self.decorator = None   # type: Token\n473         self.context = []       # type: List[str]\n474         self.indents = []       # type: List\n475         self.definitions = {}   # type: Dict[str, Tuple[str, int, int]]\n476 \n477     def add_definition(self, name: str, entry: Tuple[str, int, int]) -> None:\n478         \"\"\"Add a location of definition.\"\"\"\n479         if self.indents and self.indents[-1][0] == 'def' and entry[0] == 'def':\n480             # ignore definition of inner function\n481             pass\n482         else:\n483             self.definitions[name] = entry\n484 \n485     def parse(self) -> None:\n486         \"\"\"Parse the code to obtain location of definitions.\"\"\"\n487         while True:\n488             token = self.fetch_token()\n489             if token is None:\n490                 break\n491             elif token == COMMENT:\n492                 pass\n493             elif token == [OP, '@'] and (self.previous is None or\n494                                          self.previous.match(NEWLINE, NL, INDENT, DEDENT)):\n495                 if self.decorator is None:\n496                     self.decorator = token\n497             elif token.match([NAME, 'class']):\n498                 self.parse_definition('class')\n499             elif token.match([NAME, 'def']):\n500                 self.parse_definition('def')\n501             elif token == INDENT:\n502                 self.indents.append(('other', None, None))\n503             elif token == DEDENT:\n504                 self.finalize_block()\n505 \n506     def parse_definition(self, typ: str) -> None:\n507         \"\"\"Parse AST of definition.\"\"\"\n508         name = self.fetch_token()\n509         self.context.append(name.value)\n510         funcname = '.'.join(self.context)\n511 \n512         if self.decorator:\n513             start_pos = self.decorator.start[0]\n514             self.decorator = None\n515         else:\n516             start_pos = name.start[0]\n517 \n518         self.fetch_until([OP, ':'])\n519         if self.fetch_token().match(COMMENT, NEWLINE):\n520             self.fetch_until(INDENT)\n521             self.indents.append((typ, funcname, start_pos))\n522         else:\n523             # one-liner\n524             self.add_definition(funcname, (typ, start_pos, name.end[0]))\n525             self.context.pop()\n526 \n527     def finalize_block(self) -> None:\n528         \"\"\"Finalize definition block.\"\"\"\n529         definition = self.indents.pop()\n530         if definition[0] != 'other':\n531             typ, funcname, start_pos = definition\n532             end_pos = self.current.end[0] - 1\n533             while emptyline_re.match(self.get_line(end_pos)):\n534                 end_pos -= 1\n535 \n536             self.add_definition(funcname, (typ, start_pos, end_pos))\n537             self.context.pop()\n538 \n539 \n540 class Parser:\n541     \"\"\"Python source code parser to pick up variable comments.\n542 \n543     This is a better wrapper for ``VariableCommentPicker``.\n544     \"\"\"\n545 \n546     def __init__(self, code: str, encoding: str = 'utf-8') -> None:\n547         self.code = filter_whitespace(code)\n548         self.encoding = encoding\n549         self.annotations = {}       # type: Dict[Tuple[str, str], str]\n550         self.comments = {}          # type: Dict[Tuple[str, str], str]\n551         self.deforders = {}         # type: Dict[str, int]\n552         self.definitions = {}       # type: Dict[str, Tuple[str, int, int]]\n553         self.finals = []            # type: List[str]\n554         self.overloads = {}         # type: Dict[str, List[Signature]]\n555 \n556     def parse(self) -> None:\n557         \"\"\"Parse the source code.\"\"\"\n558         self.parse_comments()\n559         self.parse_definition()\n560 \n561     def parse_comments(self) -> None:\n562         \"\"\"Parse the code and pick up comments.\"\"\"\n563         tree = parse(self.code)\n564         picker = VariableCommentPicker(self.code.splitlines(True), self.encoding)\n565         picker.visit(tree)\n566         self.annotations = picker.annotations\n567         self.comments = picker.comments\n568         self.deforders = picker.deforders\n569         self.finals = picker.finals\n570         self.overloads = picker.overloads\n571 \n572     def parse_definition(self) -> None:\n573         \"\"\"Parse the location of definitions from the code.\"\"\"\n574         parser = DefinitionFinder(self.code.splitlines(True))\n575         parser.parse()\n576         self.definitions = parser.definitions\n",
        "intended_behavior": "This file possibly contains logic for parsing and analyzing Python code within the documentation. To resolve the issue, the parser's handling of code blocks should be extended to automatically dedent them unless a specific `:dedent:` value is given. This will allow for easier inclusion of code samples without manually adjusting indentation."
    },
    {
        "rel_file_path": "sphinx/domains/std.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sphinx-doc__sphinx/setup_sphinx-doc__sphinx__3.5/sphinx/domains/std.py",
        "start": 1,
        "end": 1139,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\"\n2     sphinx.domains.std\n3     ~~~~~~~~~~~~~~~~~~\n4 \n5     The standard domain.\n6 \n7     :copyright: Copyright 2007-2021 by the Sphinx team, see AUTHORS.\n8     :license: BSD, see LICENSE for details.\n9 \"\"\"\n10 \n11 import re\n12 import unicodedata\n13 import warnings\n14 from copy import copy\n15 from typing import Any, Callable, Dict, Iterable, Iterator, List, Optional, Tuple, Union, cast\n16 \n17 from docutils import nodes\n18 from docutils.nodes import Element, Node, system_message\n19 from docutils.parsers.rst import Directive, directives\n20 from docutils.statemachine import StringList\n21 \n22 from sphinx import addnodes\n23 from sphinx.addnodes import desc_signature, pending_xref\n24 from sphinx.deprecation import RemovedInSphinx40Warning, RemovedInSphinx50Warning\n25 from sphinx.directives import ObjectDescription\n26 from sphinx.domains import Domain, ObjType\n27 from sphinx.locale import _, __\n28 from sphinx.roles import XRefRole\n29 from sphinx.util import docname_join, logging, ws_re\n30 from sphinx.util.docutils import SphinxDirective\n31 from sphinx.util.nodes import clean_astext, make_id, make_refnode\n32 from sphinx.util.typing import RoleFunction\n33 \n34 if False:\n35     # For type annotation\n36     from typing import Type  # for python3.5.1\n37 \n38     from sphinx.application import Sphinx\n39     from sphinx.builders import Builder\n40     from sphinx.environment import BuildEnvironment\n41 \n42 logger = logging.getLogger(__name__)\n43 \n44 \n45 # RE for option descriptions\n46 option_desc_re = re.compile(r'((?:/|--|-|\\+)?[^\\s=]+)(=?\\s*.*)')\n47 # RE for grammar tokens\n48 token_re = re.compile(r'`(\\w+)`', re.U)\n49 \n50 \n51 class GenericObject(ObjectDescription[str]):\n52     \"\"\"\n53     A generic x-ref directive registered with Sphinx.add_object_type().\n54     \"\"\"\n55     indextemplate = ''\n56     parse_node = None  # type: Callable[[GenericObject, BuildEnvironment, str, desc_signature], str]  # NOQA\n57 \n58     def handle_signature(self, sig: str, signode: desc_signature) -> str:\n59         if self.parse_node:\n60             name = self.parse_node(self.env, sig, signode)\n61         else:\n62             signode.clear()\n63             signode += addnodes.desc_name(sig, sig)\n64             # normalize whitespace like XRefRole does\n65             name = ws_re.sub(' ', sig)\n66         return name\n67 \n68     def add_target_and_index(self, name: str, sig: str, signode: desc_signature) -> None:\n69         node_id = make_id(self.env, self.state.document, self.objtype, name)\n70         signode['ids'].append(node_id)\n71 \n72         # Assign old styled node_id not to break old hyperlinks (if possible)\n73         # Note: Will be removed in Sphinx-5.0 (RemovedInSphinx50Warning)\n74         old_node_id = self.make_old_id(name)\n75         if old_node_id not in self.state.document.ids and old_node_id not in signode['ids']:\n76             signode['ids'].append(old_node_id)\n77 \n78         self.state.document.note_explicit_target(signode)\n79 \n80         if self.indextemplate:\n81             colon = self.indextemplate.find(':')\n82             if colon != -1:\n83                 indextype = self.indextemplate[:colon].strip()\n84                 indexentry = self.indextemplate[colon + 1:].strip() % (name,)\n85             else:\n86                 indextype = 'single'\n87                 indexentry = self.indextemplate % (name,)\n88             self.indexnode['entries'].append((indextype, indexentry, node_id, '', None))\n89 \n90         std = cast(StandardDomain, self.env.get_domain('std'))\n91         std.note_object(self.objtype, name, node_id, location=signode)\n92 \n93     def make_old_id(self, name: str) -> str:\n94         \"\"\"Generate old styled node_id for generic objects.\n95 \n96         .. note:: Old Styled node_id was used until Sphinx-3.0.\n97                   This will be removed in Sphinx-5.0.\n98         \"\"\"\n99         return self.objtype + '-' + name\n100 \n101 \n102 class EnvVar(GenericObject):\n103     indextemplate = _('environment variable; %s')\n104 \n105 \n106 class EnvVarXRefRole(XRefRole):\n107     \"\"\"\n108     Cross-referencing role for environment variables (adds an index entry).\n109     \"\"\"\n110 \n111     def result_nodes(self, document: nodes.document, env: \"BuildEnvironment\", node: Element,\n112                      is_ref: bool) -> Tuple[List[Node], List[system_message]]:\n113         if not is_ref:\n114             return [node], []\n115         varname = node['reftarget']\n116         tgtid = 'index-%s' % env.new_serialno('index')\n117         indexnode = addnodes.index()\n118         indexnode['entries'] = [\n119             ('single', varname, tgtid, '', None),\n120             ('single', _('environment variable; %s') % varname, tgtid, '', None)\n121         ]\n122         targetnode = nodes.target('', '', ids=[tgtid])\n123         document.note_explicit_target(targetnode)\n124         return [indexnode, targetnode, node], []\n125 \n126 \n127 class Target(SphinxDirective):\n128     \"\"\"\n129     Generic target for user-defined cross-reference types.\n130     \"\"\"\n131     indextemplate = ''\n132 \n133     has_content = False\n134     required_arguments = 1\n135     optional_arguments = 0\n136     final_argument_whitespace = True\n137     option_spec = {}  # type: Dict\n138 \n139     def run(self) -> List[Node]:\n140         # normalize whitespace in fullname like XRefRole does\n141         fullname = ws_re.sub(' ', self.arguments[0].strip())\n142         node_id = make_id(self.env, self.state.document, self.name, fullname)\n143         node = nodes.target('', '', ids=[node_id])\n144         self.set_source_info(node)\n145 \n146         # Assign old styled node_id not to break old hyperlinks (if possible)\n147         # Note: Will be removed in Sphinx-5.0 (RemovedInSphinx50Warning)\n148         old_node_id = self.make_old_id(fullname)\n149         if old_node_id not in self.state.document.ids and old_node_id not in node['ids']:\n150             node['ids'].append(old_node_id)\n151 \n152         self.state.document.note_explicit_target(node)\n153         ret = [node]  # type: List[Node]\n154         if self.indextemplate:\n155             indexentry = self.indextemplate % (fullname,)\n156             indextype = 'single'\n157             colon = indexentry.find(':')\n158             if colon != -1:\n159                 indextype = indexentry[:colon].strip()\n160                 indexentry = indexentry[colon + 1:].strip()\n161             inode = addnodes.index(entries=[(indextype, indexentry, node_id, '', None)])\n162             ret.insert(0, inode)\n163         name = self.name\n164         if ':' in self.name:\n165             _, name = self.name.split(':', 1)\n166 \n167         std = cast(StandardDomain, self.env.get_domain('std'))\n168         std.note_object(name, fullname, node_id, location=node)\n169 \n170         return ret\n171 \n172     def make_old_id(self, name: str) -> str:\n173         \"\"\"Generate old styled node_id for targets.\n174 \n175         .. note:: Old Styled node_id was used until Sphinx-3.0.\n176                   This will be removed in Sphinx-5.0.\n177         \"\"\"\n178         return self.name + '-' + name\n179 \n180 \n181 class Cmdoption(ObjectDescription[str]):\n182     \"\"\"\n183     Description of a command-line option (.. option).\n184     \"\"\"\n185 \n186     def handle_signature(self, sig: str, signode: desc_signature) -> str:\n187         \"\"\"Transform an option description into RST nodes.\"\"\"\n188         count = 0\n189         firstname = ''\n190         for potential_option in sig.split(', '):\n191             potential_option = potential_option.strip()\n192             m = option_desc_re.match(potential_option)\n193             if not m:\n194                 logger.warning(__('Malformed option description %r, should '\n195                                   'look like \"opt\", \"-opt args\", \"--opt args\", '\n196                                   '\"/opt args\" or \"+opt args\"'), potential_option,\n197                                location=signode)\n198                 continue\n199             optname, args = m.groups()\n200             if optname.endswith('[') and args.endswith(']'):\n201                 # optional value surrounded by brackets (ex. foo[=bar])\n202                 optname = optname[:-1]\n203                 args = '[' + args\n204 \n205             if count:\n206                 signode += addnodes.desc_addname(', ', ', ')\n207             signode += addnodes.desc_name(optname, optname)\n208             signode += addnodes.desc_addname(args, args)\n209             if not count:\n210                 firstname = optname\n211                 signode['allnames'] = [optname]\n212             else:\n213                 signode['allnames'].append(optname)\n214             count += 1\n215         if not firstname:\n216             raise ValueError\n217         return firstname\n218 \n219     def add_target_and_index(self, firstname: str, sig: str, signode: desc_signature) -> None:\n220         currprogram = self.env.ref_context.get('std:program')\n221         for optname in signode.get('allnames', []):\n222             prefixes = ['cmdoption']\n223             if currprogram:\n224                 prefixes.append(currprogram)\n225             if not optname.startswith(('-', '/')):\n226                 prefixes.append('arg')\n227             prefix = '-'.join(prefixes)\n228             node_id = make_id(self.env, self.state.document, prefix, optname)\n229             signode['ids'].append(node_id)\n230 \n231             old_node_id = self.make_old_id(prefix, optname)\n232             if old_node_id not in self.state.document.ids and \\\n233                old_node_id not in signode['ids']:\n234                 signode['ids'].append(old_node_id)\n235 \n236         self.state.document.note_explicit_target(signode)\n237 \n238         domain = cast(StandardDomain, self.env.get_domain('std'))\n239         for optname in signode.get('allnames', []):\n240             domain.add_program_option(currprogram, optname,\n241                                       self.env.docname, signode['ids'][0])\n242 \n243         # create an index entry\n244         if currprogram:\n245             descr = _('%s command line option') % currprogram\n246         else:\n247             descr = _('command line option')\n248         for option in sig.split(', '):\n249             entry = '; '.join([descr, option])\n250             self.indexnode['entries'].append(('pair', entry, signode['ids'][0], '', None))\n251 \n252     def make_old_id(self, prefix: str, optname: str) -> str:\n253         \"\"\"Generate old styled node_id for cmdoption.\n254 \n255         .. note:: Old Styled node_id was used until Sphinx-3.0.\n256                   This will be removed in Sphinx-5.0.\n257         \"\"\"\n258         return nodes.make_id(prefix + '-' + optname)\n259 \n260 \n261 class Program(SphinxDirective):\n262     \"\"\"\n263     Directive to name the program for which options are documented.\n264     \"\"\"\n265 \n266     has_content = False\n267     required_arguments = 1\n268     optional_arguments = 0\n269     final_argument_whitespace = True\n270     option_spec = {}  # type: Dict\n271 \n272     def run(self) -> List[Node]:\n273         program = ws_re.sub('-', self.arguments[0].strip())\n274         if program == 'None':\n275             self.env.ref_context.pop('std:program', None)\n276         else:\n277             self.env.ref_context['std:program'] = program\n278         return []\n279 \n280 \n281 class OptionXRefRole(XRefRole):\n282     def process_link(self, env: \"BuildEnvironment\", refnode: Element, has_explicit_title: bool,\n283                      title: str, target: str) -> Tuple[str, str]:\n284         refnode['std:program'] = env.ref_context.get('std:program')\n285         return title, target\n286 \n287 \n288 def split_term_classifiers(line: str) -> List[Optional[str]]:\n289     # split line into a term and classifiers. if no classifier, None is used..\n290     parts = re.split(' +: +', line) + [None]\n291     return parts\n292 \n293 \n294 def make_glossary_term(env: \"BuildEnvironment\", textnodes: Iterable[Node], index_key: str,\n295                        source: str, lineno: int, node_id: str = None,\n296                        document: nodes.document = None) -> nodes.term:\n297     # get a text-only representation of the term and register it\n298     # as a cross-reference target\n299     term = nodes.term('', '', *textnodes)\n300     term.source = source\n301     term.line = lineno\n302     termtext = term.astext()\n303 \n304     if node_id:\n305         # node_id is given from outside (mainly i18n module), use it forcedly\n306         term['ids'].append(node_id)\n307     elif document:\n308         node_id = make_id(env, document, 'term', termtext)\n309         term['ids'].append(node_id)\n310         document.note_explicit_target(term)\n311     else:\n312         warnings.warn('make_glossary_term() expects document is passed as an argument.',\n313                       RemovedInSphinx40Warning, stacklevel=2)\n314         gloss_entries = env.temp_data.setdefault('gloss_entries', set())\n315         node_id = nodes.make_id('term-' + termtext)\n316         if node_id == 'term':\n317             # \"term\" is not good for node_id.  Generate it by sequence number instead.\n318             node_id = 'term-%d' % env.new_serialno('glossary')\n319 \n320         while node_id in gloss_entries:\n321             node_id = 'term-%d' % env.new_serialno('glossary')\n322         gloss_entries.add(node_id)\n323         term['ids'].append(node_id)\n324 \n325     std = cast(StandardDomain, env.get_domain('std'))\n326     std.note_object('term', termtext, node_id, location=term)\n327 \n328     # add an index entry too\n329     indexnode = addnodes.index()\n330     indexnode['entries'] = [('single', termtext, node_id, 'main', index_key)]\n331     indexnode.source, indexnode.line = term.source, term.line\n332     term.append(indexnode)\n333 \n334     return term\n335 \n336 \n337 class Glossary(SphinxDirective):\n338     \"\"\"\n339     Directive to create a glossary with cross-reference targets for :term:\n340     roles.\n341     \"\"\"\n342 \n343     has_content = True\n344     required_arguments = 0\n345     optional_arguments = 0\n346     final_argument_whitespace = False\n347     option_spec = {\n348         'sorted': directives.flag,\n349     }\n350 \n351     def run(self) -> List[Node]:\n352         node = addnodes.glossary()\n353         node.document = self.state.document\n354 \n355         # This directive implements a custom format of the reST definition list\n356         # that allows multiple lines of terms before the definition.  This is\n357         # easy to parse since we know that the contents of the glossary *must\n358         # be* a definition list.\n359 \n360         # first, collect single entries\n361         entries = []  # type: List[Tuple[List[Tuple[str, str, int]], StringList]]\n362         in_definition = True\n363         in_comment = False\n364         was_empty = True\n365         messages = []  # type: List[Node]\n366         for line, (source, lineno) in zip(self.content, self.content.items):\n367             # empty line -> add to last definition\n368             if not line:\n369                 if in_definition and entries:\n370                     entries[-1][1].append('', source, lineno)\n371                 was_empty = True\n372                 continue\n373             # unindented line -> a term\n374             if line and not line[0].isspace():\n375                 # enable comments\n376                 if line.startswith('.. '):\n377                     in_comment = True\n378                     continue\n379                 else:\n380                     in_comment = False\n381 \n382                 # first term of definition\n383                 if in_definition:\n384                     if not was_empty:\n385                         messages.append(self.state.reporter.warning(\n386                             _('glossary term must be preceded by empty line'),\n387                             source=source, line=lineno))\n388                     entries.append(([(line, source, lineno)], StringList()))\n389                     in_definition = False\n390                 # second term and following\n391                 else:\n392                     if was_empty:\n393                         messages.append(self.state.reporter.warning(\n394                             _('glossary terms must not be separated by empty lines'),\n395                             source=source, line=lineno))\n396                     if entries:\n397                         entries[-1][0].append((line, source, lineno))\n398                     else:\n399                         messages.append(self.state.reporter.warning(\n400                             _('glossary seems to be misformatted, check indentation'),\n401                             source=source, line=lineno))\n402             elif in_comment:\n403                 pass\n404             else:\n405                 if not in_definition:\n406                     # first line of definition, determines indentation\n407                     in_definition = True\n408                     indent_len = len(line) - len(line.lstrip())\n409                 if entries:\n410                     entries[-1][1].append(line[indent_len:], source, lineno)\n411                 else:\n412                     messages.append(self.state.reporter.warning(\n413                         _('glossary seems to be misformatted, check indentation'),\n414                         source=source, line=lineno))\n415             was_empty = False\n416 \n417         # now, parse all the entries into a big definition list\n418         items = []\n419         for terms, definition in entries:\n420             termtexts = []          # type: List[str]\n421             termnodes = []          # type: List[Node]\n422             system_messages = []    # type: List[Node]\n423             for line, source, lineno in terms:\n424                 parts = split_term_classifiers(line)\n425                 # parse the term with inline markup\n426                 # classifiers (parts[1:]) will not be shown on doctree\n427                 textnodes, sysmsg = self.state.inline_text(parts[0], lineno)\n428 \n429                 # use first classifier as a index key\n430                 term = make_glossary_term(self.env, textnodes, parts[1], source, lineno,\n431                                           document=self.state.document)\n432                 term.rawsource = line\n433                 system_messages.extend(sysmsg)\n434                 termtexts.append(term.astext())\n435                 termnodes.append(term)\n436 \n437             termnodes.extend(system_messages)\n438 \n439             defnode = nodes.definition()\n440             if definition:\n441                 self.state.nested_parse(definition, definition.items[0][1],\n442                                         defnode)\n443             termnodes.append(defnode)\n444             items.append((termtexts,\n445                           nodes.definition_list_item('', *termnodes)))\n446 \n447         if 'sorted' in self.options:\n448             items.sort(key=lambda x:\n449                        unicodedata.normalize('NFD', x[0][0].lower()))\n450 \n451         dlist = nodes.definition_list()\n452         dlist['classes'].append('glossary')\n453         dlist.extend(item[1] for item in items)\n454         node += dlist\n455         return messages + [node]\n456 \n457 \n458 def token_xrefs(text: str, productionGroup: str = '') -> List[Node]:\n459     if len(productionGroup) != 0:\n460         productionGroup += ':'\n461     retnodes = []  # type: List[Node]\n462     pos = 0\n463     for m in token_re.finditer(text):\n464         if m.start() > pos:\n465             txt = text[pos:m.start()]\n466             retnodes.append(nodes.Text(txt, txt))\n467         refnode = pending_xref(m.group(1), reftype='token', refdomain='std',\n468                                reftarget=productionGroup + m.group(1))\n469         refnode += nodes.literal(m.group(1), m.group(1), classes=['xref'])\n470         retnodes.append(refnode)\n471         pos = m.end()\n472     if pos < len(text):\n473         retnodes.append(nodes.Text(text[pos:], text[pos:]))\n474     return retnodes\n475 \n476 \n477 class ProductionList(SphinxDirective):\n478     \"\"\"\n479     Directive to list grammar productions.\n480     \"\"\"\n481 \n482     has_content = False\n483     required_arguments = 1\n484     optional_arguments = 0\n485     final_argument_whitespace = True\n486     option_spec = {}  # type: Dict\n487 \n488     def run(self) -> List[Node]:\n489         domain = cast(StandardDomain, self.env.get_domain('std'))\n490         node = addnodes.productionlist()  # type: Element\n491         self.set_source_info(node)\n492         # The backslash handling is from ObjectDescription.get_signatures\n493         nl_escape_re = re.compile(r'\\\\\\n')\n494         lines = nl_escape_re.sub('', self.arguments[0]).split('\\n')\n495 \n496         productionGroup = \"\"\n497         i = 0\n498         for rule in lines:\n499             if i == 0 and ':' not in rule:\n500                 productionGroup = rule.strip()\n501                 continue\n502             i += 1\n503             try:\n504                 name, tokens = rule.split(':', 1)\n505             except ValueError:\n506                 break\n507             subnode = addnodes.production(rule)\n508             name = name.strip()\n509             subnode['tokenname'] = name\n510             if subnode['tokenname']:\n511                 prefix = 'grammar-token-%s' % productionGroup\n512                 node_id = make_id(self.env, self.state.document, prefix, name)\n513                 subnode['ids'].append(node_id)\n514 \n515                 # Assign old styled node_id not to break old hyperlinks (if possible)\n516                 # Note: Will be removed in Sphinx-5.0 (RemovedInSphinx50Warning)\n517                 old_node_id = self.make_old_id(name)\n518                 if (old_node_id not in self.state.document.ids and\n519                         old_node_id not in subnode['ids']):\n520                     subnode['ids'].append(old_node_id)\n521 \n522                 self.state.document.note_implicit_target(subnode, subnode)\n523 \n524                 if len(productionGroup) != 0:\n525                     objName = \"%s:%s\" % (productionGroup, name)\n526                 else:\n527                     objName = name\n528                 domain.note_object('token', objName, node_id, location=node)\n529             subnode.extend(token_xrefs(tokens, productionGroup))\n530             node.append(subnode)\n531         return [node]\n532 \n533     def make_old_id(self, token: str) -> str:\n534         \"\"\"Generate old styled node_id for tokens.\n535 \n536         .. note:: Old Styled node_id was used until Sphinx-3.0.\n537                   This will be removed in Sphinx-5.0.\n538         \"\"\"\n539         return nodes.make_id('grammar-token-' + token)\n540 \n541 \n542 class TokenXRefRole(XRefRole):\n543     def process_link(self, env: \"BuildEnvironment\", refnode: Element, has_explicit_title: bool,\n544                      title: str, target: str) -> Tuple[str, str]:\n545         target = target.lstrip('~')  # a title-specific thing\n546         if not self.has_explicit_title and title[0] == '~':\n547             if ':' in title:\n548                 _, title = title.split(':')\n549             else:\n550                 title = title[1:]\n551         return title, target\n552 \n553 \n554 class StandardDomain(Domain):\n555     \"\"\"\n556     Domain for all objects that don't fit into another domain or are added\n557     via the application interface.\n558     \"\"\"\n559 \n560     name = 'std'\n561     label = 'Default'\n562 \n563     object_types = {\n564         'term': ObjType(_('glossary term'), 'term', searchprio=-1),\n565         'token': ObjType(_('grammar token'), 'token', searchprio=-1),\n566         'label': ObjType(_('reference label'), 'ref', 'keyword',\n567                          searchprio=-1),\n568         'envvar': ObjType(_('environment variable'), 'envvar'),\n569         'cmdoption': ObjType(_('program option'), 'option'),\n570         'doc': ObjType(_('document'), 'doc', searchprio=-1)\n571     }  # type: Dict[str, ObjType]\n572 \n573     directives = {\n574         'program': Program,\n575         'cmdoption': Cmdoption,  # old name for backwards compatibility\n576         'option': Cmdoption,\n577         'envvar': EnvVar,\n578         'glossary': Glossary,\n579         'productionlist': ProductionList,\n580     }  # type: Dict[str, Type[Directive]]\n581     roles = {\n582         'option':  OptionXRefRole(warn_dangling=True),\n583         'envvar':  EnvVarXRefRole(),\n584         # links to tokens in grammar productions\n585         'token':   TokenXRefRole(),\n586         # links to terms in glossary\n587         'term':    XRefRole(innernodeclass=nodes.inline,\n588                             warn_dangling=True),\n589         # links to headings or arbitrary labels\n590         'ref':     XRefRole(lowercase=True, innernodeclass=nodes.inline,\n591                             warn_dangling=True),\n592         # links to labels of numbered figures, tables and code-blocks\n593         'numref':  XRefRole(lowercase=True,\n594                             warn_dangling=True),\n595         # links to labels, without a different title\n596         'keyword': XRefRole(warn_dangling=True),\n597         # links to documents\n598         'doc':     XRefRole(warn_dangling=True, innernodeclass=nodes.inline),\n599     }  # type: Dict[str, Union[RoleFunction, XRefRole]]\n600 \n601     initial_data = {\n602         'progoptions': {},      # (program, name) -> docname, labelid\n603         'objects': {},          # (type, name) -> docname, labelid\n604         'labels': {             # labelname -> docname, labelid, sectionname\n605             'genindex': ('genindex', '', _('Index')),\n606             'modindex': ('py-modindex', '', _('Module Index')),\n607             'search':   ('search', '', _('Search Page')),\n608         },\n609         'anonlabels': {         # labelname -> docname, labelid\n610             'genindex': ('genindex', ''),\n611             'modindex': ('py-modindex', ''),\n612             'search':   ('search', ''),\n613         },\n614     }\n615 \n616     dangling_warnings = {\n617         'term': 'term not in glossary: %(target)s',\n618         'numref':  'undefined label: %(target)s',\n619         'keyword': 'unknown keyword: %(target)s',\n620         'doc': 'unknown document: %(target)s',\n621         'option': 'unknown option: %(target)s',\n622     }\n623 \n624     enumerable_nodes = {  # node_class -> (figtype, title_getter)\n625         nodes.figure: ('figure', None),\n626         nodes.table: ('table', None),\n627         nodes.container: ('code-block', None),\n628     }  # type: Dict[Type[Node], Tuple[str, Callable]]\n629 \n630     def __init__(self, env: \"BuildEnvironment\") -> None:\n631         super().__init__(env)\n632 \n633         # set up enumerable nodes\n634         self.enumerable_nodes = copy(self.enumerable_nodes)  # create a copy for this instance\n635         for node, settings in env.app.registry.enumerable_nodes.items():\n636             self.enumerable_nodes[node] = settings\n637 \n638     def note_hyperlink_target(self, name: str, docname: str, node_id: str,\n639                               title: str = '') -> None:\n640         \"\"\"Add a hyperlink target for cross reference.\n641 \n642         .. warning::\n643 \n644            This is only for internal use.  Please don't use this from your extension.\n645            ``document.note_explicit_target()`` or ``note_implicit_target()`` are recommended to\n646            add a hyperlink target to the document.\n647 \n648            This only adds a hyperlink target to the StandardDomain.  And this does not add a\n649            node_id to node.  Therefore, it is very fragile to calling this without\n650            understanding hyperlink target framework in both docutils and Sphinx.\n651 \n652         .. versionadded:: 3.0\n653         \"\"\"\n654         if name in self.anonlabels and self.anonlabels[name] != (docname, node_id):\n655             logger.warning(__('duplicate label %s, other instance in %s'),\n656                            name, self.env.doc2path(self.anonlabels[name][0]))\n657 \n658         self.anonlabels[name] = (docname, node_id)\n659         if title:\n660             self.labels[name] = (docname, node_id, title)\n661 \n662     @property\n663     def objects(self) -> Dict[Tuple[str, str], Tuple[str, str]]:\n664         return self.data.setdefault('objects', {})  # (objtype, name) -> docname, labelid\n665 \n666     def note_object(self, objtype: str, name: str, labelid: str, location: Any = None\n667                     ) -> None:\n668         \"\"\"Note a generic object for cross reference.\n669 \n670         .. versionadded:: 3.0\n671         \"\"\"\n672         if (objtype, name) in self.objects:\n673             docname = self.objects[objtype, name][0]\n674             logger.warning(__('duplicate %s description of %s, other instance in %s'),\n675                            objtype, name, docname, location=location)\n676         self.objects[objtype, name] = (self.env.docname, labelid)\n677 \n678     def add_object(self, objtype: str, name: str, docname: str, labelid: str) -> None:\n679         warnings.warn('StandardDomain.add_object() is deprecated.',\n680                       RemovedInSphinx50Warning, stacklevel=2)\n681         self.objects[objtype, name] = (docname, labelid)\n682 \n683     @property\n684     def progoptions(self) -> Dict[Tuple[str, str], Tuple[str, str]]:\n685         return self.data.setdefault('progoptions', {})  # (program, name) -> docname, labelid\n686 \n687     @property\n688     def labels(self) -> Dict[str, Tuple[str, str, str]]:\n689         return self.data.setdefault('labels', {})  # labelname -> docname, labelid, sectionname\n690 \n691     @property\n692     def anonlabels(self) -> Dict[str, Tuple[str, str]]:\n693         return self.data.setdefault('anonlabels', {})  # labelname -> docname, labelid\n694 \n695     def clear_doc(self, docname: str) -> None:\n696         key = None  # type: Any\n697         for key, (fn, _l) in list(self.progoptions.items()):\n698             if fn == docname:\n699                 del self.progoptions[key]\n700         for key, (fn, _l) in list(self.objects.items()):\n701             if fn == docname:\n702                 del self.objects[key]\n703         for key, (fn, _l, _l) in list(self.labels.items()):\n704             if fn == docname:\n705                 del self.labels[key]\n706         for key, (fn, _l) in list(self.anonlabels.items()):\n707             if fn == docname:\n708                 del self.anonlabels[key]\n709 \n710     def merge_domaindata(self, docnames: List[str], otherdata: Dict) -> None:\n711         # XXX duplicates?\n712         for key, data in otherdata['progoptions'].items():\n713             if data[0] in docnames:\n714                 self.progoptions[key] = data\n715         for key, data in otherdata['objects'].items():\n716             if data[0] in docnames:\n717                 self.objects[key] = data\n718         for key, data in otherdata['labels'].items():\n719             if data[0] in docnames:\n720                 self.labels[key] = data\n721         for key, data in otherdata['anonlabels'].items():\n722             if data[0] in docnames:\n723                 self.anonlabels[key] = data\n724 \n725     def process_doc(self, env: \"BuildEnvironment\", docname: str, document: nodes.document) -> None:  # NOQA\n726         for name, explicit in document.nametypes.items():\n727             if not explicit:\n728                 continue\n729             labelid = document.nameids[name]\n730             if labelid is None:\n731                 continue\n732             node = document.ids[labelid]\n733             if isinstance(node, nodes.target) and 'refid' in node:\n734                 # indirect hyperlink targets\n735                 node = document.ids.get(node['refid'])\n736                 labelid = node['names'][0]\n737             if (node.tagname == 'footnote' or\n738                     'refuri' in node or\n739                     node.tagname.startswith('desc_')):\n740                 # ignore footnote labels, labels automatically generated from a\n741                 # link and object descriptions\n742                 continue\n743             if name in self.labels:\n744                 logger.warning(__('duplicate label %s, other instance in %s'),\n745                                name, env.doc2path(self.labels[name][0]),\n746                                location=node)\n747             self.anonlabels[name] = docname, labelid\n748             if node.tagname == 'section':\n749                 title = cast(nodes.title, node[0])\n750                 sectname = clean_astext(title)\n751             elif node.tagname == 'rubric':\n752                 sectname = clean_astext(node)\n753             elif self.is_enumerable_node(node):\n754                 sectname = self.get_numfig_title(node)\n755                 if not sectname:\n756                     continue\n757             else:\n758                 toctree = next(iter(node.traverse(addnodes.toctree)), None)\n759                 if toctree and toctree.get('caption'):\n760                     sectname = toctree.get('caption')\n761                 else:\n762                     # anonymous-only labels\n763                     continue\n764             self.labels[name] = docname, labelid, sectname\n765 \n766     def add_program_option(self, program: str, name: str, docname: str, labelid: str) -> None:\n767         self.progoptions[program, name] = (docname, labelid)\n768 \n769     def build_reference_node(self, fromdocname: str, builder: \"Builder\", docname: str,\n770                              labelid: str, sectname: str, rolename: str, **options: Any\n771                              ) -> Element:\n772         nodeclass = options.pop('nodeclass', nodes.reference)\n773         newnode = nodeclass('', '', internal=True, **options)\n774         innernode = nodes.inline(sectname, sectname)\n775         if innernode.get('classes') is not None:\n776             innernode['classes'].append('std')\n777             innernode['classes'].append('std-' + rolename)\n778         if docname == fromdocname:\n779             newnode['refid'] = labelid\n780         else:\n781             # set more info in contnode; in case the\n782             # get_relative_uri call raises NoUri,\n783             # the builder will then have to resolve these\n784             contnode = pending_xref('')\n785             contnode['refdocname'] = docname\n786             contnode['refsectname'] = sectname\n787             newnode['refuri'] = builder.get_relative_uri(\n788                 fromdocname, docname)\n789             if labelid:\n790                 newnode['refuri'] += '#' + labelid\n791         newnode.append(innernode)\n792         return newnode\n793 \n794     def resolve_xref(self, env: \"BuildEnvironment\", fromdocname: str, builder: \"Builder\",\n795                      typ: str, target: str, node: pending_xref, contnode: Element) -> Element:\n796         if typ == 'ref':\n797             resolver = self._resolve_ref_xref\n798         elif typ == 'numref':\n799             resolver = self._resolve_numref_xref\n800         elif typ == 'keyword':\n801             resolver = self._resolve_keyword_xref\n802         elif typ == 'doc':\n803             resolver = self._resolve_doc_xref\n804         elif typ == 'option':\n805             resolver = self._resolve_option_xref\n806         elif typ == 'citation':\n807             warnings.warn('pending_xref(domain=std, type=citation) is deprecated: %r' % node,\n808                           RemovedInSphinx40Warning, stacklevel=2)\n809             domain = env.get_domain('citation')\n810             return domain.resolve_xref(env, fromdocname, builder, typ, target, node, contnode)\n811         elif typ == 'term':\n812             resolver = self._resolve_term_xref\n813         else:\n814             resolver = self._resolve_obj_xref\n815 \n816         return resolver(env, fromdocname, builder, typ, target, node, contnode)\n817 \n818     def _resolve_ref_xref(self, env: \"BuildEnvironment\", fromdocname: str,\n819                           builder: \"Builder\", typ: str, target: str, node: pending_xref,\n820                           contnode: Element) -> Element:\n821         if node['refexplicit']:\n822             # reference to anonymous label; the reference uses\n823             # the supplied link caption\n824             docname, labelid = self.anonlabels.get(target, ('', ''))\n825             sectname = node.astext()\n826         else:\n827             # reference to named label; the final node will\n828             # contain the section name after the label\n829             docname, labelid, sectname = self.labels.get(target, ('', '', ''))\n830         if not docname:\n831             return None\n832 \n833         return self.build_reference_node(fromdocname, builder,\n834                                          docname, labelid, sectname, 'ref')\n835 \n836     def _resolve_numref_xref(self, env: \"BuildEnvironment\", fromdocname: str,\n837                              builder: \"Builder\", typ: str, target: str,\n838                              node: pending_xref, contnode: Element) -> Element:\n839         if target in self.labels:\n840             docname, labelid, figname = self.labels.get(target, ('', '', ''))\n841         else:\n842             docname, labelid = self.anonlabels.get(target, ('', ''))\n843             figname = None\n844 \n845         if not docname:\n846             return None\n847 \n848         target_node = env.get_doctree(docname).ids.get(labelid)\n849         figtype = self.get_enumerable_node_type(target_node)\n850         if figtype is None:\n851             return None\n852 \n853         if figtype != 'section' and env.config.numfig is False:\n854             logger.warning(__('numfig is disabled. :numref: is ignored.'), location=node)\n855             return contnode\n856 \n857         try:\n858             fignumber = self.get_fignumber(env, builder, figtype, docname, target_node)\n859             if fignumber is None:\n860                 return contnode\n861         except ValueError:\n862             logger.warning(__(\"Failed to create a cross reference. Any number is not \"\n863                               \"assigned: %s\"),\n864                            labelid, location=node)\n865             return contnode\n866 \n867         try:\n868             if node['refexplicit']:\n869                 title = contnode.astext()\n870             else:\n871                 title = env.config.numfig_format.get(figtype, '')\n872 \n873             if figname is None and '{name}' in title:\n874                 logger.warning(__('the link has no caption: %s'), title, location=node)\n875                 return contnode\n876             else:\n877                 fignum = '.'.join(map(str, fignumber))\n878                 if '{name}' in title or 'number' in title:\n879                     # new style format (cf. \"Fig.{number}\")\n880                     if figname:\n881                         newtitle = title.format(name=figname, number=fignum)\n882                     else:\n883                         newtitle = title.format(number=fignum)\n884                 else:\n885                     # old style format (cf. \"Fig.%s\")\n886                     newtitle = title % fignum\n887         except KeyError as exc:\n888             logger.warning(__('invalid numfig_format: %s (%r)'), title, exc, location=node)\n889             return contnode\n890         except TypeError:\n891             logger.warning(__('invalid numfig_format: %s'), title, location=node)\n892             return contnode\n893 \n894         return self.build_reference_node(fromdocname, builder,\n895                                          docname, labelid, newtitle, 'numref',\n896                                          nodeclass=addnodes.number_reference,\n897                                          title=title)\n898 \n899     def _resolve_keyword_xref(self, env: \"BuildEnvironment\", fromdocname: str,\n900                               builder: \"Builder\", typ: str, target: str,\n901                               node: pending_xref, contnode: Element) -> Element:\n902         # keywords are oddballs: they are referenced by named labels\n903         docname, labelid, _ = self.labels.get(target, ('', '', ''))\n904         if not docname:\n905             return None\n906         return make_refnode(builder, fromdocname, docname,\n907                             labelid, contnode)\n908 \n909     def _resolve_doc_xref(self, env: \"BuildEnvironment\", fromdocname: str,\n910                           builder: \"Builder\", typ: str, target: str,\n911                           node: pending_xref, contnode: Element) -> Element:\n912         # directly reference to document by source name; can be absolute or relative\n913         refdoc = node.get('refdoc', fromdocname)\n914         docname = docname_join(refdoc, node['reftarget'])\n915         if docname not in env.all_docs:\n916             return None\n917         else:\n918             if node['refexplicit']:\n919                 # reference with explicit title\n920                 caption = node.astext()\n921             else:\n922                 caption = clean_astext(env.titles[docname])\n923             innernode = nodes.inline(caption, caption, classes=['doc'])\n924             return make_refnode(builder, fromdocname, docname, None, innernode)\n925 \n926     def _resolve_option_xref(self, env: \"BuildEnvironment\", fromdocname: str,\n927                              builder: \"Builder\", typ: str, target: str,\n928                              node: pending_xref, contnode: Element) -> Element:\n929         progname = node.get('std:program')\n930         target = target.strip()\n931         docname, labelid = self.progoptions.get((progname, target), ('', ''))\n932         if not docname:\n933             commands = []\n934             while ws_re.search(target):\n935                 subcommand, target = ws_re.split(target, 1)\n936                 commands.append(subcommand)\n937                 progname = \"-\".join(commands)\n938 \n939                 docname, labelid = self.progoptions.get((progname, target), ('', ''))\n940                 if docname:\n941                     break\n942             else:\n943                 return None\n944 \n945         return make_refnode(builder, fromdocname, docname,\n946                             labelid, contnode)\n947 \n948     def _resolve_term_xref(self, env: \"BuildEnvironment\", fromdocname: str,\n949                            builder: \"Builder\", typ: str, target: str,\n950                            node: pending_xref, contnode: Element) -> Element:\n951         result = self._resolve_obj_xref(env, fromdocname, builder, typ,\n952                                         target, node, contnode)\n953         if result:\n954             return result\n955         else:\n956             for objtype, term in self.objects:\n957                 if objtype == 'term' and term.lower() == target.lower():\n958                     docname, labelid = self.objects[objtype, term]\n959                     logger.warning(__('term %s not found in case sensitive match.'\n960                                       'made a reference to %s instead.'),\n961                                    target, term, location=node, type='ref', subtype='term')\n962                     break\n963             else:\n964                 docname, labelid = '', ''\n965             if not docname:\n966                 return None\n967             return make_refnode(builder, fromdocname, docname,\n968                                 labelid, contnode)\n969 \n970     def _resolve_obj_xref(self, env: \"BuildEnvironment\", fromdocname: str,\n971                           builder: \"Builder\", typ: str, target: str,\n972                           node: pending_xref, contnode: Element) -> Element:\n973         objtypes = self.objtypes_for_role(typ) or []\n974         for objtype in objtypes:\n975             if (objtype, target) in self.objects:\n976                 docname, labelid = self.objects[objtype, target]\n977                 break\n978         else:\n979             docname, labelid = '', ''\n980         if not docname:\n981             return None\n982         return make_refnode(builder, fromdocname, docname,\n983                             labelid, contnode)\n984 \n985     def resolve_any_xref(self, env: \"BuildEnvironment\", fromdocname: str,\n986                          builder: \"Builder\", target: str, node: pending_xref,\n987                          contnode: Element) -> List[Tuple[str, Element]]:\n988         results = []  # type: List[Tuple[str, Element]]\n989         ltarget = target.lower()  # :ref: lowercases its target automatically\n990         for role in ('ref', 'option'):  # do not try \"keyword\"\n991             res = self.resolve_xref(env, fromdocname, builder, role,\n992                                     ltarget if role == 'ref' else target,\n993                                     node, contnode)\n994             if res:\n995                 results.append(('std:' + role, res))\n996         # all others\n997         for objtype in self.object_types:\n998             key = (objtype, target)\n999             if objtype == 'term':\n1000                 key = (objtype, ltarget)\n1001             if key in self.objects:\n1002                 docname, labelid = self.objects[key]\n1003                 results.append(('std:' + self.role_for_objtype(objtype),\n1004                                 make_refnode(builder, fromdocname, docname,\n1005                                              labelid, contnode)))\n1006         return results\n1007 \n1008     def get_objects(self) -> Iterator[Tuple[str, str, str, str, str, int]]:\n1009         # handle the special 'doc' reference here\n1010         for doc in self.env.all_docs:\n1011             yield (doc, clean_astext(self.env.titles[doc]), 'doc', doc, '', -1)\n1012         for (prog, option), info in self.progoptions.items():\n1013             if prog:\n1014                 fullname = \".\".join([prog, option])\n1015                 yield (fullname, fullname, 'cmdoption', info[0], info[1], 1)\n1016             else:\n1017                 yield (option, option, 'cmdoption', info[0], info[1], 1)\n1018         for (type, name), info in self.objects.items():\n1019             yield (name, name, type, info[0], info[1],\n1020                    self.object_types[type].attrs['searchprio'])\n1021         for name, (docname, labelid, sectionname) in self.labels.items():\n1022             yield (name, sectionname, 'label', docname, labelid, -1)\n1023         # add anonymous-only labels as well\n1024         non_anon_labels = set(self.labels)\n1025         for name, (docname, labelid) in self.anonlabels.items():\n1026             if name not in non_anon_labels:\n1027                 yield (name, name, 'label', docname, labelid, -1)\n1028 \n1029     def get_type_name(self, type: ObjType, primary: bool = False) -> str:\n1030         # never prepend \"Default\"\n1031         return type.lname\n1032 \n1033     def is_enumerable_node(self, node: Node) -> bool:\n1034         return node.__class__ in self.enumerable_nodes\n1035 \n1036     def get_numfig_title(self, node: Node) -> str:\n1037         \"\"\"Get the title of enumerable nodes to refer them using its title\"\"\"\n1038         if self.is_enumerable_node(node):\n1039             elem = cast(Element, node)\n1040             _, title_getter = self.enumerable_nodes.get(elem.__class__, (None, None))\n1041             if title_getter:\n1042                 return title_getter(elem)\n1043             else:\n1044                 for subnode in elem:\n1045                     if isinstance(subnode, (nodes.caption, nodes.title)):\n1046                         return clean_astext(subnode)\n1047 \n1048         return None\n1049 \n1050     def get_enumerable_node_type(self, node: Node) -> str:\n1051         \"\"\"Get type of enumerable nodes.\"\"\"\n1052         def has_child(node: Element, cls: \"Type\") -> bool:\n1053             return any(isinstance(child, cls) for child in node)\n1054 \n1055         if isinstance(node, nodes.section):\n1056             return 'section'\n1057         elif (isinstance(node, nodes.container) and\n1058               'literal_block' in node and\n1059               has_child(node, nodes.literal_block)):\n1060             # given node is a code-block having caption\n1061             return 'code-block'\n1062         else:\n1063             figtype, _ = self.enumerable_nodes.get(node.__class__, (None, None))\n1064             return figtype\n1065 \n1066     def get_fignumber(self, env: \"BuildEnvironment\", builder: \"Builder\",\n1067                       figtype: str, docname: str, target_node: Element) -> Tuple[int, ...]:\n1068         if figtype == 'section':\n1069             if builder.name == 'latex':\n1070                 return tuple()\n1071             elif docname not in env.toc_secnumbers:\n1072                 raise ValueError  # no number assigned\n1073             else:\n1074                 anchorname = '#' + target_node['ids'][0]\n1075                 if anchorname not in env.toc_secnumbers[docname]:\n1076                     # try first heading which has no anchor\n1077                     return env.toc_secnumbers[docname].get('')\n1078                 else:\n1079                     return env.toc_secnumbers[docname].get(anchorname)\n1080         else:\n1081             try:\n1082                 figure_id = target_node['ids'][0]\n1083                 return env.toc_fignumbers[docname][figtype][figure_id]\n1084             except (KeyError, IndexError) as exc:\n1085                 # target_node is found, but fignumber is not assigned.\n1086                 # Maybe it is defined in orphaned document.\n1087                 raise ValueError from exc\n1088 \n1089     def get_full_qualified_name(self, node: Element) -> str:\n1090         if node.get('reftype') == 'option':\n1091             progname = node.get('std:program')\n1092             command = ws_re.split(node.get('reftarget'))\n1093             if progname:\n1094                 command.insert(0, progname)\n1095             option = command.pop()\n1096             if command:\n1097                 return '.'.join(['-'.join(command), option])\n1098             else:\n1099                 return None\n1100         else:\n1101             return None\n1102 \n1103     def note_citations(self, env: \"BuildEnvironment\", docname: str, document: nodes.document) -> None:  # NOQA\n1104         warnings.warn('StandardDomain.note_citations() is deprecated.',\n1105                       RemovedInSphinx40Warning, stacklevel=2)\n1106 \n1107     def note_citation_refs(self, env: \"BuildEnvironment\", docname: str, document: nodes.document) -> None:  # NOQA\n1108         warnings.warn('StandardDomain.note_citation_refs() is deprecated.',\n1109                       RemovedInSphinx40Warning, stacklevel=2)\n1110 \n1111     def note_labels(self, env: \"BuildEnvironment\", docname: str, document: nodes.document) -> None:  # NOQA\n1112         warnings.warn('StandardDomain.note_labels() is deprecated.',\n1113                       RemovedInSphinx40Warning, stacklevel=2)\n1114 \n1115 \n1116 def warn_missing_reference(app: \"Sphinx\", domain: Domain, node: pending_xref) -> bool:\n1117     if (domain and domain.name != 'std') or node['reftype'] != 'ref':\n1118         return None\n1119     else:\n1120         target = node['reftarget']\n1121         if target not in domain.anonlabels:  # type: ignore\n1122             msg = __('undefined label: %s')\n1123         else:\n1124             msg = __('Failed to create a cross reference. A title or caption not found: %s')\n1125 \n1126         logger.warning(msg % target, location=node, type='ref', subtype=node['reftype'])\n1127         return True\n1128 \n1129 \n1130 def setup(app: \"Sphinx\") -> Dict[str, Any]:\n1131     app.add_domain(StandardDomain)\n1132     app.connect('warn-missing-reference', warn_missing_reference)\n1133 \n1134     return {\n1135         'version': 'builtin',\n1136         'env_version': 1,\n1137         'parallel_read_safe': True,\n1138         'parallel_write_safe': True,\n1139     }\n",
        "intended_behavior": "As this file likely includes directive processing logic for the standard domain, it should be ensured that the `:dedent:` option for `code-block` and `literalinclude` directives automatically removes common leading whitespace from all lines in the absence of an explicit dedent value. The change should maintain backward compatibility, allowing users to still specify a dedent value when desired."
    },
    {
        "rel_file_path": "sphinx/util/docstrings.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sphinx-doc__sphinx/setup_sphinx-doc__sphinx__3.5/sphinx/util/docstrings.py",
        "start": 1,
        "end": 101,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\"\n2     sphinx.util.docstrings\n3     ~~~~~~~~~~~~~~~~~~~~~~\n4 \n5     Utilities for docstring processing.\n6 \n7     :copyright: Copyright 2007-2021 by the Sphinx team, see AUTHORS.\n8     :license: BSD, see LICENSE for details.\n9 \"\"\"\n10 \n11 import re\n12 import sys\n13 import warnings\n14 from typing import Dict, List\n15 \n16 from docutils.parsers.rst.states import Body\n17 \n18 from sphinx.deprecation import RemovedInSphinx50Warning\n19 \n20 field_list_item_re = re.compile(Body.patterns['field_marker'])\n21 \n22 \n23 def extract_metadata(s: str) -> Dict[str, str]:\n24     \"\"\"Extract metadata from docstring.\"\"\"\n25     in_other_element = False\n26     metadata = {}  # type: Dict[str, str]\n27 \n28     if not s:\n29         return metadata\n30 \n31     for line in prepare_docstring(s):\n32         if line.strip() == '':\n33             in_other_element = False\n34         else:\n35             matched = field_list_item_re.match(line)\n36             if matched and not in_other_element:\n37                 field_name = matched.group()[1:].split(':', 1)[0]\n38                 if field_name.startswith('meta '):\n39                     name = field_name[5:].strip()\n40                     metadata[name] = line[matched.end():].strip()\n41             else:\n42                 in_other_element = True\n43 \n44     return metadata\n45 \n46 \n47 def prepare_docstring(s: str, ignore: int = None, tabsize: int = 8) -> List[str]:\n48     \"\"\"Convert a docstring into lines of parseable reST.  Remove common leading\n49     indentation, where the indentation of a given number of lines (usually just\n50     one) is ignored.\n51 \n52     Return the docstring as a list of lines usable for inserting into a docutils\n53     ViewList (used as argument of nested_parse().)  An empty line is added to\n54     act as a separator between this docstring and following content.\n55     \"\"\"\n56     if ignore is None:\n57         ignore = 1\n58     else:\n59         warnings.warn(\"The 'ignore' argument to prepare_docstring() is deprecated.\",\n60                       RemovedInSphinx50Warning, stacklevel=2)\n61 \n62     lines = s.expandtabs(tabsize).splitlines()\n63     # Find minimum indentation of any non-blank lines after ignored lines.\n64     margin = sys.maxsize\n65     for line in lines[ignore:]:\n66         content = len(line.lstrip())\n67         if content:\n68             indent = len(line) - content\n69             margin = min(margin, indent)\n70     # Remove indentation from ignored lines.\n71     for i in range(ignore):\n72         if i < len(lines):\n73             lines[i] = lines[i].lstrip()\n74     if margin < sys.maxsize:\n75         for i in range(ignore, len(lines)):\n76             lines[i] = lines[i][margin:]\n77     # Remove any leading blank lines.\n78     while lines and not lines[0]:\n79         lines.pop(0)\n80     # make sure there is an empty line at the end\n81     if lines and lines[-1]:\n82         lines.append('')\n83     return lines\n84 \n85 \n86 def prepare_commentdoc(s: str) -> List[str]:\n87     \"\"\"Extract documentation comment lines (starting with #:) and return them\n88     as a list of lines.  Returns an empty list if there is no documentation.\n89     \"\"\"\n90     result = []\n91     lines = [line.strip() for line in s.expandtabs().splitlines()]\n92     for line in lines:\n93         if line.startswith('#:'):\n94             line = line[2:]\n95             # the first space after the comment is ignored\n96             if line and line[0] == ' ':\n97                 line = line[1:]\n98             result.append(line)\n99     if result and result[-1]:\n100         result.append('')\n101     return result\n",
        "intended_behavior": "This file is probably responsible for processing docstring content. Enhancements should be made to apply the automatic dedentation logic for code blocks and literal includes within docstrings, applying a universal dedent if no `:dedent:` value is specified. This modifies the docstring handling to better format embedded code snippets."
    },
    {
        "rel_file_path": "sphinx/ext/autodoc/__init__.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sphinx-doc__sphinx/setup_sphinx-doc__sphinx__3.5/sphinx/ext/autodoc/__init__.py",
        "start": 1,
        "end": 2636,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\"\n2     sphinx.ext.autodoc\n3     ~~~~~~~~~~~~~~~~~~\n4 \n5     Automatically insert docstrings for functions, classes or whole modules into\n6     the doctree, thus avoiding duplication between docstrings and documentation\n7     for those who like elaborate docstrings.\n8 \n9     :copyright: Copyright 2007-2021 by the Sphinx team, see AUTHORS.\n10     :license: BSD, see LICENSE for details.\n11 \"\"\"\n12 \n13 import re\n14 import warnings\n15 from inspect import Parameter, Signature\n16 from types import ModuleType\n17 from typing import (Any, Callable, Dict, Iterator, List, Optional, Sequence, Set, Tuple, Type,\n18                     TypeVar, Union)\n19 \n20 from docutils.statemachine import StringList\n21 \n22 import sphinx\n23 from sphinx.application import Sphinx\n24 from sphinx.config import ENUM, Config\n25 from sphinx.deprecation import (RemovedInSphinx40Warning, RemovedInSphinx50Warning,\n26                                 RemovedInSphinx60Warning)\n27 from sphinx.environment import BuildEnvironment\n28 from sphinx.ext.autodoc.importer import (get_class_members, get_object_members, import_module,\n29                                          import_object)\n30 from sphinx.ext.autodoc.mock import ismock, mock\n31 from sphinx.locale import _, __\n32 from sphinx.pycode import ModuleAnalyzer, PycodeError\n33 from sphinx.util import inspect, logging\n34 from sphinx.util.docstrings import extract_metadata, prepare_docstring\n35 from sphinx.util.inspect import (evaluate_signature, getdoc, object_description, safe_getattr,\n36                                  stringify_signature)\n37 from sphinx.util.typing import get_type_hints, restify\n38 from sphinx.util.typing import stringify as stringify_typehint\n39 \n40 if False:\n41     # For type annotation\n42     from typing import Type  # NOQA # for python3.5.1\n43 \n44     from sphinx.ext.autodoc.directive import DocumenterBridge\n45 \n46 \n47 logger = logging.getLogger(__name__)\n48 \n49 \n50 # This type isn't exposed directly in any modules, but can be found\n51 # here in most Python versions\n52 MethodDescriptorType = type(type.__subclasses__)\n53 \n54 \n55 #: extended signature RE: with explicit module name separated by ::\n56 py_ext_sig_re = re.compile(\n57     r'''^ ([\\w.]+::)?            # explicit module name\n58           ([\\w.]+\\.)?            # module and/or class name(s)\n59           (\\w+)  \\s*             # thing name\n60           (?: \\((.*)\\)           # optional: arguments\n61            (?:\\s* -> \\s* (.*))?  #           return annotation\n62           )? $                   # and nothing more\n63           ''', re.VERBOSE)\n64 special_member_re = re.compile(r'^__\\S+__$')\n65 \n66 \n67 def identity(x: Any) -> Any:\n68     return x\n69 \n70 \n71 class _All:\n72     \"\"\"A special value for :*-members: that matches to any member.\"\"\"\n73 \n74     def __contains__(self, item: Any) -> bool:\n75         return True\n76 \n77 \n78 class _Empty:\n79     \"\"\"A special value for :exclude-members: that never matches to any member.\"\"\"\n80 \n81     def __contains__(self, item: Any) -> bool:\n82         return False\n83 \n84 \n85 ALL = _All()\n86 EMPTY = _Empty()\n87 UNINITIALIZED_ATTR = object()\n88 INSTANCEATTR = object()\n89 SLOTSATTR = object()\n90 \n91 \n92 def members_option(arg: Any) -> Union[object, List[str]]:\n93     \"\"\"Used to convert the :members: option to auto directives.\"\"\"\n94     if arg in (None, True):\n95         return ALL\n96     elif arg is False:\n97         return None\n98     else:\n99         return [x.strip() for x in arg.split(',') if x.strip()]\n100 \n101 \n102 def members_set_option(arg: Any) -> Union[object, Set[str]]:\n103     \"\"\"Used to convert the :members: option to auto directives.\"\"\"\n104     warnings.warn(\"members_set_option() is deprecated.\",\n105                   RemovedInSphinx50Warning, stacklevel=2)\n106     if arg is None:\n107         return ALL\n108     return {x.strip() for x in arg.split(',') if x.strip()}\n109 \n110 \n111 def exclude_members_option(arg: Any) -> Union[object, Set[str]]:\n112     \"\"\"Used to convert the :exclude-members: option.\"\"\"\n113     if arg in (None, True):\n114         return EMPTY\n115     return {x.strip() for x in arg.split(',') if x.strip()}\n116 \n117 \n118 def inherited_members_option(arg: Any) -> Union[object, Set[str]]:\n119     \"\"\"Used to convert the :members: option to auto directives.\"\"\"\n120     if arg in (None, True):\n121         return 'object'\n122     else:\n123         return arg\n124 \n125 \n126 def member_order_option(arg: Any) -> Optional[str]:\n127     \"\"\"Used to convert the :members: option to auto directives.\"\"\"\n128     if arg in (None, True):\n129         return None\n130     elif arg in ('alphabetical', 'bysource', 'groupwise'):\n131         return arg\n132     else:\n133         raise ValueError(__('invalid value for member-order option: %s') % arg)\n134 \n135 \n136 SUPPRESS = object()\n137 \n138 \n139 def annotation_option(arg: Any) -> Any:\n140     if arg in (None, True):\n141         # suppress showing the representation of the object\n142         return SUPPRESS\n143     else:\n144         return arg\n145 \n146 \n147 def bool_option(arg: Any) -> bool:\n148     \"\"\"Used to convert flag options to auto directives.  (Instead of\n149     directives.flag(), which returns None).\n150     \"\"\"\n151     return True\n152 \n153 \n154 def merge_special_members_option(options: Dict) -> None:\n155     \"\"\"Merge :special-members: option to :members: option.\"\"\"\n156     warnings.warn(\"merge_special_members_option() is deprecated.\",\n157                   RemovedInSphinx50Warning, stacklevel=2)\n158     if 'special-members' in options and options['special-members'] is not ALL:\n159         if options.get('members') is ALL:\n160             pass\n161         elif options.get('members'):\n162             for member in options['special-members']:\n163                 if member not in options['members']:\n164                     options['members'].append(member)\n165         else:\n166             options['members'] = options['special-members']\n167 \n168 \n169 def merge_members_option(options: Dict) -> None:\n170     \"\"\"Merge :*-members: option to the :members: option.\"\"\"\n171     if options.get('members') is ALL:\n172         # merging is not needed when members: ALL\n173         return\n174 \n175     members = options.setdefault('members', [])\n176     for key in {'private-members', 'special-members'}:\n177         if key in options and options[key] not in (ALL, None):\n178             for member in options[key]:\n179                 if member not in members:\n180                     members.append(member)\n181 \n182 \n183 # Some useful event listener factories for autodoc-process-docstring.\n184 \n185 def cut_lines(pre: int, post: int = 0, what: str = None) -> Callable:\n186     \"\"\"Return a listener that removes the first *pre* and last *post*\n187     lines of every docstring.  If *what* is a sequence of strings,\n188     only docstrings of a type in *what* will be processed.\n189 \n190     Use like this (e.g. in the ``setup()`` function of :file:`conf.py`)::\n191 \n192        from sphinx.ext.autodoc import cut_lines\n193        app.connect('autodoc-process-docstring', cut_lines(4, what=['module']))\n194 \n195     This can (and should) be used in place of :confval:`automodule_skip_lines`.\n196     \"\"\"\n197     def process(app: Sphinx, what_: str, name: str, obj: Any, options: Any, lines: List[str]\n198                 ) -> None:\n199         if what and what_ not in what:\n200             return\n201         del lines[:pre]\n202         if post:\n203             # remove one trailing blank line.\n204             if lines and not lines[-1]:\n205                 lines.pop(-1)\n206             del lines[-post:]\n207         # make sure there is a blank line at the end\n208         if lines and lines[-1]:\n209             lines.append('')\n210     return process\n211 \n212 \n213 def between(marker: str, what: Sequence[str] = None, keepempty: bool = False,\n214             exclude: bool = False) -> Callable:\n215     \"\"\"Return a listener that either keeps, or if *exclude* is True excludes,\n216     lines between lines that match the *marker* regular expression.  If no line\n217     matches, the resulting docstring would be empty, so no change will be made\n218     unless *keepempty* is true.\n219 \n220     If *what* is a sequence of strings, only docstrings of a type in *what* will\n221     be processed.\n222     \"\"\"\n223     marker_re = re.compile(marker)\n224 \n225     def process(app: Sphinx, what_: str, name: str, obj: Any, options: Any, lines: List[str]\n226                 ) -> None:\n227         if what and what_ not in what:\n228             return\n229         deleted = 0\n230         delete = not exclude\n231         orig_lines = lines[:]\n232         for i, line in enumerate(orig_lines):\n233             if delete:\n234                 lines.pop(i - deleted)\n235                 deleted += 1\n236             if marker_re.match(line):\n237                 delete = not delete\n238                 if delete:\n239                     lines.pop(i - deleted)\n240                     deleted += 1\n241         if not lines and not keepempty:\n242             lines[:] = orig_lines\n243         # make sure there is a blank line at the end\n244         if lines and lines[-1]:\n245             lines.append('')\n246     return process\n247 \n248 \n249 # This class is used only in ``sphinx.ext.autodoc.directive``,\n250 # But we define this class here to keep compatibility (see #4538)\n251 class Options(dict):\n252     \"\"\"A dict/attribute hybrid that returns None on nonexisting keys.\"\"\"\n253     def __getattr__(self, name: str) -> Any:\n254         try:\n255             return self[name.replace('_', '-')]\n256         except KeyError:\n257             return None\n258 \n259 \n260 class ObjectMember(tuple):\n261     \"\"\"A member of object.\n262 \n263     This is used for the result of `Documenter.get_object_members()` to\n264     represent each member of the object.\n265 \n266     .. Note::\n267 \n268        An instance of this class behaves as a tuple of (name, object)\n269        for compatibility to old Sphinx.  The behavior will be dropped\n270        in the future.  Therefore extensions should not use the tuple\n271        interface.\n272     \"\"\"\n273 \n274     def __new__(cls, name: str, obj: Any, **kwargs: Any) -> Any:\n275         return super().__new__(cls, (name, obj))  # type: ignore\n276 \n277     def __init__(self, name: str, obj: Any, docstring: Optional[str] = None,\n278                  class_: Any = None, skipped: bool = False) -> None:\n279         self.__name__ = name\n280         self.object = obj\n281         self.docstring = docstring\n282         self.skipped = skipped\n283         self.class_ = class_\n284 \n285 \n286 ObjectMembers = Union[List[ObjectMember], List[Tuple[str, Any]]]\n287 \n288 \n289 class Documenter:\n290     \"\"\"\n291     A Documenter knows how to autodocument a single object type.  When\n292     registered with the AutoDirective, it will be used to document objects\n293     of that type when needed by autodoc.\n294 \n295     Its *objtype* attribute selects what auto directive it is assigned to\n296     (the directive name is 'auto' + objtype), and what directive it generates\n297     by default, though that can be overridden by an attribute called\n298     *directivetype*.\n299 \n300     A Documenter has an *option_spec* that works like a docutils directive's;\n301     in fact, it will be used to parse an auto directive's options that matches\n302     the documenter.\n303     \"\"\"\n304     #: name by which the directive is called (auto...) and the default\n305     #: generated directive name\n306     objtype = 'object'\n307     #: indentation by which to indent the directive content\n308     content_indent = '   '\n309     #: priority if multiple documenters return True from can_document_member\n310     priority = 0\n311     #: order if autodoc_member_order is set to 'groupwise'\n312     member_order = 0\n313     #: true if the generated content may contain titles\n314     titles_allowed = False\n315 \n316     option_spec = {'noindex': bool_option}  # type: Dict[str, Callable]\n317 \n318     def get_attr(self, obj: Any, name: str, *defargs: Any) -> Any:\n319         \"\"\"getattr() override for types such as Zope interfaces.\"\"\"\n320         return autodoc_attrgetter(self.env.app, obj, name, *defargs)\n321 \n322     @classmethod\n323     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any\n324                             ) -> bool:\n325         \"\"\"Called to see if a member can be documented by this documenter.\"\"\"\n326         raise NotImplementedError('must be implemented in subclasses')\n327 \n328     def __init__(self, directive: \"DocumenterBridge\", name: str, indent: str = '') -> None:\n329         self.directive = directive\n330         self.config = directive.env.config\n331         self.env = directive.env    # type: BuildEnvironment\n332         self.options = directive.genopt\n333         self.name = name\n334         self.indent = indent\n335         # the module and object path within the module, and the fully\n336         # qualified name (all set after resolve_name succeeds)\n337         self.modname = None         # type: str\n338         self.module = None          # type: ModuleType\n339         self.objpath = None         # type: List[str]\n340         self.fullname = None        # type: str\n341         # extra signature items (arguments and return annotation,\n342         # also set after resolve_name succeeds)\n343         self.args = None            # type: str\n344         self.retann = None          # type: str\n345         # the object to document (set after import_object succeeds)\n346         self.object = None          # type: Any\n347         self.object_name = None     # type: str\n348         # the parent/owner of the object to document\n349         self.parent = None          # type: Any\n350         # the module analyzer to get at attribute docs, or None\n351         self.analyzer = None        # type: ModuleAnalyzer\n352 \n353     @property\n354     def documenters(self) -> Dict[str, \"Type[Documenter]\"]:\n355         \"\"\"Returns registered Documenter classes\"\"\"\n356         return self.env.app.registry.documenters\n357 \n358     def add_line(self, line: str, source: str, *lineno: int) -> None:\n359         \"\"\"Append one line of generated reST to the output.\"\"\"\n360         if line.strip():  # not a blank line\n361             self.directive.result.append(self.indent + line, source, *lineno)\n362         else:\n363             self.directive.result.append('', source, *lineno)\n364 \n365     def resolve_name(self, modname: str, parents: Any, path: str, base: Any\n366                      ) -> Tuple[str, List[str]]:\n367         \"\"\"Resolve the module and name of the object to document given by the\n368         arguments and the current module/class.\n369 \n370         Must return a pair of the module name and a chain of attributes; for\n371         example, it would return ``('zipfile', ['ZipFile', 'open'])`` for the\n372         ``zipfile.ZipFile.open`` method.\n373         \"\"\"\n374         raise NotImplementedError('must be implemented in subclasses')\n375 \n376     def parse_name(self) -> bool:\n377         \"\"\"Determine what module to import and what attribute to document.\n378 \n379         Returns True and sets *self.modname*, *self.objpath*, *self.fullname*,\n380         *self.args* and *self.retann* if parsing and resolving was successful.\n381         \"\"\"\n382         # first, parse the definition -- auto directives for classes and\n383         # functions can contain a signature which is then used instead of\n384         # an autogenerated one\n385         try:\n386             explicit_modname, path, base, args, retann = \\\n387                 py_ext_sig_re.match(self.name).groups()\n388         except AttributeError:\n389             logger.warning(__('invalid signature for auto%s (%r)') % (self.objtype, self.name),\n390                            type='autodoc')\n391             return False\n392 \n393         # support explicit module and class name separation via ::\n394         if explicit_modname is not None:\n395             modname = explicit_modname[:-2]\n396             parents = path.rstrip('.').split('.') if path else []\n397         else:\n398             modname = None\n399             parents = []\n400 \n401         with mock(self.config.autodoc_mock_imports):\n402             self.modname, self.objpath = self.resolve_name(modname, parents, path, base)\n403 \n404         if not self.modname:\n405             return False\n406 \n407         self.args = args\n408         self.retann = retann\n409         self.fullname = (self.modname or '') + \\\n410                         ('.' + '.'.join(self.objpath) if self.objpath else '')\n411         return True\n412 \n413     def import_object(self, raiseerror: bool = False) -> bool:\n414         \"\"\"Import the object given by *self.modname* and *self.objpath* and set\n415         it as *self.object*.\n416 \n417         Returns True if successful, False if an error occurred.\n418         \"\"\"\n419         with mock(self.config.autodoc_mock_imports):\n420             try:\n421                 ret = import_object(self.modname, self.objpath, self.objtype,\n422                                     attrgetter=self.get_attr,\n423                                     warningiserror=self.config.autodoc_warningiserror)\n424                 self.module, self.parent, self.object_name, self.object = ret\n425                 return True\n426             except ImportError as exc:\n427                 if raiseerror:\n428                     raise\n429                 else:\n430                     logger.warning(exc.args[0], type='autodoc', subtype='import_object')\n431                     self.env.note_reread()\n432                     return False\n433 \n434     def get_real_modname(self) -> str:\n435         \"\"\"Get the real module name of an object to document.\n436 \n437         It can differ from the name of the module through which the object was\n438         imported.\n439         \"\"\"\n440         return self.get_attr(self.object, '__module__', None) or self.modname\n441 \n442     def check_module(self) -> bool:\n443         \"\"\"Check if *self.object* is really defined in the module given by\n444         *self.modname*.\n445         \"\"\"\n446         if self.options.imported_members:\n447             return True\n448 \n449         subject = inspect.unpartial(self.object)\n450         modname = self.get_attr(subject, '__module__', None)\n451         if modname and modname != self.modname:\n452             return False\n453         return True\n454 \n455     def format_args(self, **kwargs: Any) -> str:\n456         \"\"\"Format the argument signature of *self.object*.\n457 \n458         Should return None if the object does not have a signature.\n459         \"\"\"\n460         return None\n461 \n462     def format_name(self) -> str:\n463         \"\"\"Format the name of *self.object*.\n464 \n465         This normally should be something that can be parsed by the generated\n466         directive, but doesn't need to be (Sphinx will display it unparsed\n467         then).\n468         \"\"\"\n469         # normally the name doesn't contain the module (except for module\n470         # directives of course)\n471         return '.'.join(self.objpath) or self.modname\n472 \n473     def _call_format_args(self, **kwargs: Any) -> str:\n474         if kwargs:\n475             try:\n476                 return self.format_args(**kwargs)\n477             except TypeError:\n478                 # avoid chaining exceptions, by putting nothing here\n479                 pass\n480 \n481         # retry without arguments for old documenters\n482         return self.format_args()\n483 \n484     def format_signature(self, **kwargs: Any) -> str:\n485         \"\"\"Format the signature (arguments and return annotation) of the object.\n486 \n487         Let the user process it via the ``autodoc-process-signature`` event.\n488         \"\"\"\n489         if self.args is not None:\n490             # signature given explicitly\n491             args = \"(%s)\" % self.args\n492             retann = self.retann\n493         else:\n494             # try to introspect the signature\n495             try:\n496                 retann = None\n497                 args = self._call_format_args(**kwargs)\n498                 if args:\n499                     matched = re.match(r'^(\\(.*\\))\\s+->\\s+(.*)$', args)\n500                     if matched:\n501                         args = matched.group(1)\n502                         retann = matched.group(2)\n503             except Exception as exc:\n504                 logger.warning(__('error while formatting arguments for %s: %s'),\n505                                self.fullname, exc, type='autodoc')\n506                 args = None\n507 \n508         result = self.env.events.emit_firstresult('autodoc-process-signature',\n509                                                   self.objtype, self.fullname,\n510                                                   self.object, self.options, args, retann)\n511         if result:\n512             args, retann = result\n513 \n514         if args is not None:\n515             return args + ((' -> %s' % retann) if retann else '')\n516         else:\n517             return ''\n518 \n519     def add_directive_header(self, sig: str) -> None:\n520         \"\"\"Add the directive header and options to the generated content.\"\"\"\n521         domain = getattr(self, 'domain', 'py')\n522         directive = getattr(self, 'directivetype', self.objtype)\n523         name = self.format_name()\n524         sourcename = self.get_sourcename()\n525 \n526         # one signature per line, indented by column\n527         prefix = '.. %s:%s:: ' % (domain, directive)\n528         for i, sig_line in enumerate(sig.split(\"\\n\")):\n529             self.add_line('%s%s%s' % (prefix, name, sig_line),\n530                           sourcename)\n531             if i == 0:\n532                 prefix = \" \" * len(prefix)\n533 \n534         if self.options.noindex:\n535             self.add_line('   :noindex:', sourcename)\n536         if self.objpath:\n537             # Be explicit about the module, this is necessary since .. class::\n538             # etc. don't support a prepended module name\n539             self.add_line('   :module: %s' % self.modname, sourcename)\n540 \n541     def get_doc(self, encoding: str = None, ignore: int = None) -> Optional[List[List[str]]]:\n542         \"\"\"Decode and return lines of the docstring(s) for the object.\n543 \n544         When it returns None value, autodoc-process-docstring will not be called for this\n545         object.\n546         \"\"\"\n547         if encoding is not None:\n548             warnings.warn(\"The 'encoding' argument to autodoc.%s.get_doc() is deprecated.\"\n549                           % self.__class__.__name__,\n550                           RemovedInSphinx40Warning, stacklevel=2)\n551         if ignore is not None:\n552             warnings.warn(\"The 'ignore' argument to autodoc.%s.get_doc() is deprecated.\"\n553                           % self.__class__.__name__,\n554                           RemovedInSphinx50Warning, stacklevel=2)\n555         docstring = getdoc(self.object, self.get_attr, self.config.autodoc_inherit_docstrings,\n556                            self.parent, self.object_name)\n557         if docstring:\n558             tab_width = self.directive.state.document.settings.tab_width\n559             return [prepare_docstring(docstring, ignore, tab_width)]\n560         return []\n561 \n562     def process_doc(self, docstrings: List[List[str]]) -> Iterator[str]:\n563         \"\"\"Let the user process the docstrings before adding them.\"\"\"\n564         for docstringlines in docstrings:\n565             if self.env.app:\n566                 # let extensions preprocess docstrings\n567                 self.env.app.emit('autodoc-process-docstring',\n568                                   self.objtype, self.fullname, self.object,\n569                                   self.options, docstringlines)\n570 \n571                 if docstringlines and docstringlines[-1] != '':\n572                     # append a blank line to the end of the docstring\n573                     docstringlines.append('')\n574 \n575             yield from docstringlines\n576 \n577     def get_sourcename(self) -> str:\n578         if (getattr(self.object, '__module__', None) and\n579                 getattr(self.object, '__qualname__', None)):\n580             # Get the correct location of docstring from self.object\n581             # to support inherited methods\n582             fullname = '%s.%s' % (self.object.__module__, self.object.__qualname__)\n583         else:\n584             fullname = self.fullname\n585 \n586         if self.analyzer:\n587             return '%s:docstring of %s' % (self.analyzer.srcname, fullname)\n588         else:\n589             return 'docstring of %s' % fullname\n590 \n591     def add_content(self, more_content: Optional[StringList], no_docstring: bool = False\n592                     ) -> None:\n593         \"\"\"Add content from docstrings, attribute documentation and user.\"\"\"\n594         if no_docstring:\n595             warnings.warn(\"The 'no_docstring' argument to %s.add_content() is deprecated.\"\n596                           % self.__class__.__name__,\n597                           RemovedInSphinx50Warning, stacklevel=2)\n598 \n599         # set sourcename and add content from attribute documentation\n600         sourcename = self.get_sourcename()\n601         if self.analyzer:\n602             attr_docs = self.analyzer.find_attr_docs()\n603             if self.objpath:\n604                 key = ('.'.join(self.objpath[:-1]), self.objpath[-1])\n605                 if key in attr_docs:\n606                     no_docstring = True\n607                     # make a copy of docstring for attributes to avoid cache\n608                     # the change of autodoc-process-docstring event.\n609                     docstrings = [list(attr_docs[key])]\n610 \n611                     for i, line in enumerate(self.process_doc(docstrings)):\n612                         self.add_line(line, sourcename, i)\n613 \n614         # add content from docstrings\n615         if not no_docstring:\n616             docstrings = self.get_doc()\n617             if docstrings is None:\n618                 # Do not call autodoc-process-docstring on get_doc() returns None.\n619                 pass\n620             else:\n621                 if not docstrings:\n622                     # append at least a dummy docstring, so that the event\n623                     # autodoc-process-docstring is fired and can add some\n624                     # content if desired\n625                     docstrings.append([])\n626                 for i, line in enumerate(self.process_doc(docstrings)):\n627                     self.add_line(line, sourcename, i)\n628 \n629         # add additional content (e.g. from document), if present\n630         if more_content:\n631             for line, src in zip(more_content.data, more_content.items):\n632                 self.add_line(line, src[0], src[1])\n633 \n634     def get_object_members(self, want_all: bool) -> Tuple[bool, ObjectMembers]:\n635         \"\"\"Return `(members_check_module, members)` where `members` is a\n636         list of `(membername, member)` pairs of the members of *self.object*.\n637 \n638         If *want_all* is True, return all members.  Else, only return those\n639         members given by *self.options.members* (which may also be none).\n640         \"\"\"\n641         warnings.warn('The implementation of Documenter.get_object_members() will be '\n642                       'removed from Sphinx-6.0.', RemovedInSphinx60Warning)\n643         members = get_object_members(self.object, self.objpath, self.get_attr, self.analyzer)\n644         if not want_all:\n645             if not self.options.members:\n646                 return False, []  # type: ignore\n647             # specific members given\n648             selected = []\n649             for name in self.options.members:  # type: str\n650                 if name in members:\n651                     selected.append((name, members[name].value))\n652                 else:\n653                     logger.warning(__('missing attribute %s in object %s') %\n654                                    (name, self.fullname), type='autodoc')\n655             return False, selected\n656         elif self.options.inherited_members:\n657             return False, [(m.name, m.value) for m in members.values()]\n658         else:\n659             return False, [(m.name, m.value) for m in members.values()\n660                            if m.directly_defined]\n661 \n662     def filter_members(self, members: ObjectMembers, want_all: bool\n663                        ) -> List[Tuple[str, Any, bool]]:\n664         \"\"\"Filter the given member list.\n665 \n666         Members are skipped if\n667 \n668         - they are private (except if given explicitly or the private-members\n669           option is set)\n670         - they are special methods (except if given explicitly or the\n671           special-members option is set)\n672         - they are undocumented (except if the undoc-members option is set)\n673 \n674         The user can override the skipping decision by connecting to the\n675         ``autodoc-skip-member`` event.\n676         \"\"\"\n677         def is_filtered_inherited_member(name: str, obj: Any) -> bool:\n678             if inspect.isclass(self.object):\n679                 for cls in self.object.__mro__:\n680                     if cls.__name__ == self.options.inherited_members and cls != self.object:\n681                         # given member is a member of specified *super class*\n682                         return True\n683                     elif name in cls.__dict__:\n684                         return False\n685                     elif name in self.get_attr(cls, '__annotations__', {}):\n686                         return False\n687                     elif isinstance(obj, ObjectMember) and obj.class_ is cls:\n688                         return False\n689 \n690             return False\n691 \n692         ret = []\n693 \n694         # search for members in source code too\n695         namespace = '.'.join(self.objpath)  # will be empty for modules\n696 \n697         if self.analyzer:\n698             attr_docs = self.analyzer.find_attr_docs()\n699         else:\n700             attr_docs = {}\n701 \n702         # process members and determine which to skip\n703         for obj in members:\n704             membername, member = obj\n705             # if isattr is True, the member is documented as an attribute\n706             if member is INSTANCEATTR:\n707                 isattr = True\n708             else:\n709                 isattr = False\n710 \n711             doc = getdoc(member, self.get_attr, self.config.autodoc_inherit_docstrings,\n712                          self.parent, self.object_name)\n713             if not isinstance(doc, str):\n714                 # Ignore non-string __doc__\n715                 doc = None\n716 \n717             # if the member __doc__ is the same as self's __doc__, it's just\n718             # inherited and therefore not the member's doc\n719             cls = self.get_attr(member, '__class__', None)\n720             if cls:\n721                 cls_doc = self.get_attr(cls, '__doc__', None)\n722                 if cls_doc == doc:\n723                     doc = None\n724 \n725             if isinstance(obj, ObjectMember) and obj.docstring:\n726                 # hack for ClassDocumenter to inject docstring via ObjectMember\n727                 doc = obj.docstring\n728 \n729             has_doc = bool(doc)\n730 \n731             metadata = extract_metadata(doc)\n732             if 'private' in metadata:\n733                 # consider a member private if docstring has \"private\" metadata\n734                 isprivate = True\n735             elif 'public' in metadata:\n736                 # consider a member public if docstring has \"public\" metadata\n737                 isprivate = False\n738             else:\n739                 isprivate = membername.startswith('_')\n740 \n741             keep = False\n742             if ismock(member):\n743                 # mocked module or object\n744                 pass\n745             elif self.options.exclude_members and membername in self.options.exclude_members:\n746                 # remove members given by exclude-members\n747                 keep = False\n748             elif want_all and special_member_re.match(membername):\n749                 # special __methods__\n750                 if self.options.special_members and membername in self.options.special_members:\n751                     if membername == '__doc__':\n752                         keep = False\n753                     elif is_filtered_inherited_member(membername, obj):\n754                         keep = False\n755                     else:\n756                         keep = has_doc or self.options.undoc_members\n757                 else:\n758                     keep = False\n759             elif (namespace, membername) in attr_docs:\n760                 if want_all and isprivate:\n761                     if self.options.private_members is None:\n762                         keep = False\n763                     else:\n764                         keep = membername in self.options.private_members\n765                 else:\n766                     # keep documented attributes\n767                     keep = True\n768                 isattr = True\n769             elif want_all and isprivate:\n770                 if has_doc or self.options.undoc_members:\n771                     if self.options.private_members is None:\n772                         keep = False\n773                     elif is_filtered_inherited_member(membername, obj):\n774                         keep = False\n775                     else:\n776                         keep = membername in self.options.private_members\n777                 else:\n778                     keep = False\n779             else:\n780                 if (self.options.members is ALL and\n781                         is_filtered_inherited_member(membername, obj)):\n782                     keep = False\n783                 else:\n784                     # ignore undocumented members if :undoc-members: is not given\n785                     keep = has_doc or self.options.undoc_members\n786 \n787             if isinstance(obj, ObjectMember) and obj.skipped:\n788                 # forcedly skipped member (ex. a module attribute not defined in __all__)\n789                 keep = False\n790 \n791             # give the user a chance to decide whether this member\n792             # should be skipped\n793             if self.env.app:\n794                 # let extensions preprocess docstrings\n795                 try:\n796                     skip_user = self.env.app.emit_firstresult(\n797                         'autodoc-skip-member', self.objtype, membername, member,\n798                         not keep, self.options)\n799                     if skip_user is not None:\n800                         keep = not skip_user\n801                 except Exception as exc:\n802                     logger.warning(__('autodoc: failed to determine %r to be documented, '\n803                                       'the following exception was raised:\\n%s'),\n804                                    member, exc, type='autodoc')\n805                     keep = False\n806 \n807             if keep:\n808                 ret.append((membername, member, isattr))\n809 \n810         return ret\n811 \n812     def document_members(self, all_members: bool = False) -> None:\n813         \"\"\"Generate reST for member documentation.\n814 \n815         If *all_members* is True, do all members, else those given by\n816         *self.options.members*.\n817         \"\"\"\n818         # set current namespace for finding members\n819         self.env.temp_data['autodoc:module'] = self.modname\n820         if self.objpath:\n821             self.env.temp_data['autodoc:class'] = self.objpath[0]\n822 \n823         want_all = all_members or self.options.inherited_members or \\\n824             self.options.members is ALL\n825         # find out which members are documentable\n826         members_check_module, members = self.get_object_members(want_all)\n827 \n828         # document non-skipped members\n829         memberdocumenters = []  # type: List[Tuple[Documenter, bool]]\n830         for (mname, member, isattr) in self.filter_members(members, want_all):\n831             classes = [cls for cls in self.documenters.values()\n832                        if cls.can_document_member(member, mname, isattr, self)]\n833             if not classes:\n834                 # don't know how to document this member\n835                 continue\n836             # prefer the documenter with the highest priority\n837             classes.sort(key=lambda cls: cls.priority)\n838             # give explicitly separated module name, so that members\n839             # of inner classes can be documented\n840             full_mname = self.modname + '::' + \\\n841                 '.'.join(self.objpath + [mname])\n842             documenter = classes[-1](self.directive, full_mname, self.indent)\n843             memberdocumenters.append((documenter, isattr))\n844 \n845         member_order = self.options.member_order or self.config.autodoc_member_order\n846         memberdocumenters = self.sort_members(memberdocumenters, member_order)\n847 \n848         for documenter, isattr in memberdocumenters:\n849             documenter.generate(\n850                 all_members=True, real_modname=self.real_modname,\n851                 check_module=members_check_module and not isattr)\n852 \n853         # reset current objects\n854         self.env.temp_data['autodoc:module'] = None\n855         self.env.temp_data['autodoc:class'] = None\n856 \n857     def sort_members(self, documenters: List[Tuple[\"Documenter\", bool]],\n858                      order: str) -> List[Tuple[\"Documenter\", bool]]:\n859         \"\"\"Sort the given member list.\"\"\"\n860         if order == 'groupwise':\n861             # sort by group; alphabetically within groups\n862             documenters.sort(key=lambda e: (e[0].member_order, e[0].name))\n863         elif order == 'bysource':\n864             if self.analyzer:\n865                 # sort by source order, by virtue of the module analyzer\n866                 tagorder = self.analyzer.tagorder\n867 \n868                 def keyfunc(entry: Tuple[Documenter, bool]) -> int:\n869                     fullname = entry[0].name.split('::')[1]\n870                     return tagorder.get(fullname, len(tagorder))\n871                 documenters.sort(key=keyfunc)\n872             else:\n873                 # Assume that member discovery order matches source order.\n874                 # This is a reasonable assumption in Python 3.6 and up, where\n875                 # module.__dict__ is insertion-ordered.\n876                 pass\n877         else:  # alphabetical\n878             documenters.sort(key=lambda e: e[0].name)\n879 \n880         return documenters\n881 \n882     def generate(self, more_content: Optional[StringList] = None, real_modname: str = None,\n883                  check_module: bool = False, all_members: bool = False) -> None:\n884         \"\"\"Generate reST for the object given by *self.name*, and possibly for\n885         its members.\n886 \n887         If *more_content* is given, include that content. If *real_modname* is\n888         given, use that module name to find attribute docs. If *check_module* is\n889         True, only generate if the object is defined in the module name it is\n890         imported from. If *all_members* is True, document all members.\n891         \"\"\"\n892         if not self.parse_name():\n893             # need a module to import\n894             logger.warning(\n895                 __('don\\'t know which module to import for autodocumenting '\n896                    '%r (try placing a \"module\" or \"currentmodule\" directive '\n897                    'in the document, or giving an explicit module name)') %\n898                 self.name, type='autodoc')\n899             return\n900 \n901         # now, import the module and get object to document\n902         if not self.import_object():\n903             return\n904 \n905         # If there is no real module defined, figure out which to use.\n906         # The real module is used in the module analyzer to look up the module\n907         # where the attribute documentation would actually be found in.\n908         # This is used for situations where you have a module that collects the\n909         # functions and classes of internal submodules.\n910         guess_modname = self.get_real_modname()\n911         self.real_modname = real_modname or guess_modname\n912 \n913         # try to also get a source code analyzer for attribute docs\n914         try:\n915             self.analyzer = ModuleAnalyzer.for_module(self.real_modname)\n916             # parse right now, to get PycodeErrors on parsing (results will\n917             # be cached anyway)\n918             self.analyzer.find_attr_docs()\n919         except PycodeError as exc:\n920             logger.debug('[autodoc] module analyzer failed: %s', exc)\n921             # no source file -- e.g. for builtin and C modules\n922             self.analyzer = None\n923             # at least add the module.__file__ as a dependency\n924             if hasattr(self.module, '__file__') and self.module.__file__:\n925                 self.directive.filename_set.add(self.module.__file__)\n926         else:\n927             self.directive.filename_set.add(self.analyzer.srcname)\n928 \n929         if self.real_modname != guess_modname:\n930             # Add module to dependency list if target object is defined in other module.\n931             try:\n932                 analyzer = ModuleAnalyzer.for_module(guess_modname)\n933                 self.directive.filename_set.add(analyzer.srcname)\n934             except PycodeError:\n935                 pass\n936 \n937         # check __module__ of object (for members not given explicitly)\n938         if check_module:\n939             if not self.check_module():\n940                 return\n941 \n942         sourcename = self.get_sourcename()\n943 \n944         # make sure that the result starts with an empty line.  This is\n945         # necessary for some situations where another directive preprocesses\n946         # reST and no starting newline is present\n947         self.add_line('', sourcename)\n948 \n949         # format the object's signature, if any\n950         try:\n951             sig = self.format_signature()\n952         except Exception as exc:\n953             logger.warning(__('error while formatting signature for %s: %s'),\n954                            self.fullname, exc, type='autodoc')\n955             return\n956 \n957         # generate the directive header and options, if applicable\n958         self.add_directive_header(sig)\n959         self.add_line('', sourcename)\n960 \n961         # e.g. the module directive doesn't have content\n962         self.indent += self.content_indent\n963 \n964         # add all content (from docstrings, attribute docs etc.)\n965         self.add_content(more_content)\n966 \n967         # document members, if possible\n968         self.document_members(all_members)\n969 \n970 \n971 class ModuleDocumenter(Documenter):\n972     \"\"\"\n973     Specialized Documenter subclass for modules.\n974     \"\"\"\n975     objtype = 'module'\n976     content_indent = ''\n977     titles_allowed = True\n978 \n979     option_spec = {\n980         'members': members_option, 'undoc-members': bool_option,\n981         'noindex': bool_option, 'inherited-members': inherited_members_option,\n982         'show-inheritance': bool_option, 'synopsis': identity,\n983         'platform': identity, 'deprecated': bool_option,\n984         'member-order': member_order_option, 'exclude-members': exclude_members_option,\n985         'private-members': members_option, 'special-members': members_option,\n986         'imported-members': bool_option, 'ignore-module-all': bool_option\n987     }  # type: Dict[str, Callable]\n988 \n989     def __init__(self, *args: Any) -> None:\n990         super().__init__(*args)\n991         merge_members_option(self.options)\n992         self.__all__ = None  # type: Optional[Sequence[str]]\n993 \n994     @classmethod\n995     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any\n996                             ) -> bool:\n997         # don't document submodules automatically\n998         return False\n999 \n1000     def resolve_name(self, modname: str, parents: Any, path: str, base: Any\n1001                      ) -> Tuple[str, List[str]]:\n1002         if modname is not None:\n1003             logger.warning(__('\"::\" in automodule name doesn\\'t make sense'),\n1004                            type='autodoc')\n1005         return (path or '') + base, []\n1006 \n1007     def parse_name(self) -> bool:\n1008         ret = super().parse_name()\n1009         if self.args or self.retann:\n1010             logger.warning(__('signature arguments or return annotation '\n1011                               'given for automodule %s') % self.fullname,\n1012                            type='autodoc')\n1013         return ret\n1014 \n1015     def import_object(self, raiseerror: bool = False) -> bool:\n1016         ret = super().import_object(raiseerror)\n1017 \n1018         try:\n1019             if not self.options.ignore_module_all:\n1020                 self.__all__ = inspect.getall(self.object)\n1021         except AttributeError as exc:\n1022             # __all__ raises an error.\n1023             logger.warning(__('%s.__all__ raises an error. Ignored: %r'),\n1024                            (self.fullname, exc), type='autodoc')\n1025         except ValueError as exc:\n1026             # invalid __all__ found.\n1027             logger.warning(__('__all__ should be a list of strings, not %r '\n1028                               '(in module %s) -- ignoring __all__') %\n1029                            (exc.args[0], self.fullname), type='autodoc')\n1030 \n1031         return ret\n1032 \n1033     def add_directive_header(self, sig: str) -> None:\n1034         Documenter.add_directive_header(self, sig)\n1035 \n1036         sourcename = self.get_sourcename()\n1037 \n1038         # add some module-specific options\n1039         if self.options.synopsis:\n1040             self.add_line('   :synopsis: ' + self.options.synopsis, sourcename)\n1041         if self.options.platform:\n1042             self.add_line('   :platform: ' + self.options.platform, sourcename)\n1043         if self.options.deprecated:\n1044             self.add_line('   :deprecated:', sourcename)\n1045 \n1046     def get_module_members(self) -> Dict[str, ObjectMember]:\n1047         \"\"\"Get members of target module.\"\"\"\n1048         if self.analyzer:\n1049             attr_docs = self.analyzer.attr_docs\n1050         else:\n1051             attr_docs = {}\n1052 \n1053         members = {}  # type: Dict[str, ObjectMember]\n1054         for name in dir(self.object):\n1055             try:\n1056                 value = safe_getattr(self.object, name, None)\n1057                 docstring = attr_docs.get(('', name), [])\n1058                 members[name] = ObjectMember(name, value, docstring=\"\\n\".join(docstring))\n1059             except AttributeError:\n1060                 continue\n1061 \n1062         # annotation only member (ex. attr: int)\n1063         try:\n1064             for name in inspect.getannotations(self.object):\n1065                 if name not in members:\n1066                     docstring = attr_docs.get(('', name), [])\n1067                     members[name] = ObjectMember(name, INSTANCEATTR,\n1068                                                  docstring=\"\\n\".join(docstring))\n1069         except AttributeError:\n1070             pass\n1071 \n1072         return members\n1073 \n1074     def get_object_members(self, want_all: bool) -> Tuple[bool, ObjectMembers]:\n1075         members = self.get_module_members()\n1076         if want_all:\n1077             if self.__all__ is None:\n1078                 # for implicit module members, check __module__ to avoid\n1079                 # documenting imported objects\n1080                 return True, list(members.values())\n1081             else:\n1082                 for member in members.values():\n1083                     if member.__name__ not in self.__all__:\n1084                         member.skipped = True\n1085 \n1086                 return False, list(members.values())\n1087         else:\n1088             memberlist = self.options.members or []\n1089             ret = []\n1090             for name in memberlist:\n1091                 if name in members:\n1092                     ret.append(members[name])\n1093                 else:\n1094                     logger.warning(__('missing attribute mentioned in :members: option: '\n1095                                       'module %s, attribute %s') %\n1096                                    (safe_getattr(self.object, '__name__', '???'), name),\n1097                                    type='autodoc')\n1098             return False, ret\n1099 \n1100     def sort_members(self, documenters: List[Tuple[\"Documenter\", bool]],\n1101                      order: str) -> List[Tuple[\"Documenter\", bool]]:\n1102         if order == 'bysource' and self.__all__:\n1103             # Sort alphabetically first (for members not listed on the __all__)\n1104             documenters.sort(key=lambda e: e[0].name)\n1105 \n1106             # Sort by __all__\n1107             def keyfunc(entry: Tuple[Documenter, bool]) -> int:\n1108                 name = entry[0].name.split('::')[1]\n1109                 if name in self.__all__:\n1110                     return self.__all__.index(name)\n1111                 else:\n1112                     return len(self.__all__)\n1113             documenters.sort(key=keyfunc)\n1114 \n1115             return documenters\n1116         else:\n1117             return super().sort_members(documenters, order)\n1118 \n1119 \n1120 class ModuleLevelDocumenter(Documenter):\n1121     \"\"\"\n1122     Specialized Documenter subclass for objects on module level (functions,\n1123     classes, data/constants).\n1124     \"\"\"\n1125     def resolve_name(self, modname: str, parents: Any, path: str, base: Any\n1126                      ) -> Tuple[str, List[str]]:\n1127         if modname is None:\n1128             if path:\n1129                 modname = path.rstrip('.')\n1130             else:\n1131                 # if documenting a toplevel object without explicit module,\n1132                 # it can be contained in another auto directive ...\n1133                 modname = self.env.temp_data.get('autodoc:module')\n1134                 # ... or in the scope of a module directive\n1135                 if not modname:\n1136                     modname = self.env.ref_context.get('py:module')\n1137                 # ... else, it stays None, which means invalid\n1138         return modname, parents + [base]\n1139 \n1140 \n1141 class ClassLevelDocumenter(Documenter):\n1142     \"\"\"\n1143     Specialized Documenter subclass for objects on class level (methods,\n1144     attributes).\n1145     \"\"\"\n1146     def resolve_name(self, modname: str, parents: Any, path: str, base: Any\n1147                      ) -> Tuple[str, List[str]]:\n1148         if modname is None:\n1149             if path:\n1150                 mod_cls = path.rstrip('.')\n1151             else:\n1152                 mod_cls = None\n1153                 # if documenting a class-level object without path,\n1154                 # there must be a current class, either from a parent\n1155                 # auto directive ...\n1156                 mod_cls = self.env.temp_data.get('autodoc:class')\n1157                 # ... or from a class directive\n1158                 if mod_cls is None:\n1159                     mod_cls = self.env.ref_context.get('py:class')\n1160                 # ... if still None, there's no way to know\n1161                 if mod_cls is None:\n1162                     return None, []\n1163             modname, sep, cls = mod_cls.rpartition('.')\n1164             parents = [cls]\n1165             # if the module name is still missing, get it like above\n1166             if not modname:\n1167                 modname = self.env.temp_data.get('autodoc:module')\n1168             if not modname:\n1169                 modname = self.env.ref_context.get('py:module')\n1170             # ... else, it stays None, which means invalid\n1171         return modname, parents + [base]\n1172 \n1173 \n1174 class DocstringSignatureMixin:\n1175     \"\"\"\n1176     Mixin for FunctionDocumenter and MethodDocumenter to provide the\n1177     feature of reading the signature from the docstring.\n1178     \"\"\"\n1179     _new_docstrings = None  # type: List[List[str]]\n1180     _signatures = None      # type: List[str]\n1181 \n1182     def _find_signature(self, encoding: str = None) -> Tuple[str, str]:\n1183         if encoding is not None:\n1184             warnings.warn(\"The 'encoding' argument to autodoc.%s._find_signature() is \"\n1185                           \"deprecated.\" % self.__class__.__name__,\n1186                           RemovedInSphinx40Warning, stacklevel=2)\n1187 \n1188         # candidates of the object name\n1189         valid_names = [self.objpath[-1]]  # type: ignore\n1190         if isinstance(self, ClassDocumenter):\n1191             valid_names.append('__init__')\n1192             if hasattr(self.object, '__mro__'):\n1193                 valid_names.extend(cls.__name__ for cls in self.object.__mro__)\n1194 \n1195         docstrings = self.get_doc()\n1196         if docstrings is None:\n1197             return None, None\n1198         self._new_docstrings = docstrings[:]\n1199         self._signatures = []\n1200         result = None\n1201         for i, doclines in enumerate(docstrings):\n1202             for j, line in enumerate(doclines):\n1203                 if not line:\n1204                     # no lines in docstring, no match\n1205                     break\n1206 \n1207                 if line.endswith('\\\\'):\n1208                     multiline = True\n1209                     line = line.rstrip('\\\\').rstrip()\n1210                 else:\n1211                     multiline = False\n1212 \n1213                 # match first line of docstring against signature RE\n1214                 match = py_ext_sig_re.match(line)\n1215                 if not match:\n1216                     continue\n1217                 exmod, path, base, args, retann = match.groups()\n1218 \n1219                 # the base name must match ours\n1220                 if base not in valid_names:\n1221                     continue\n1222 \n1223                 # re-prepare docstring to ignore more leading indentation\n1224                 tab_width = self.directive.state.document.settings.tab_width  # type: ignore\n1225                 self._new_docstrings[i] = prepare_docstring('\\n'.join(doclines[j + 1:]),\n1226                                                             tabsize=tab_width)\n1227 \n1228                 if result is None:\n1229                     # first signature\n1230                     result = args, retann\n1231                 else:\n1232                     # subsequent signatures\n1233                     self._signatures.append(\"(%s) -> %s\" % (args, retann))\n1234 \n1235                 if multiline:\n1236                     # the signature have multiple signatures on docstring\n1237                     continue\n1238                 else:\n1239                     # don't look any further\n1240                     break\n1241 \n1242             if result:\n1243                 # finish the loop when signature found\n1244                 break\n1245 \n1246         return result\n1247 \n1248     def get_doc(self, encoding: str = None, ignore: int = None) -> Optional[List[List[str]]]:\n1249         if encoding is not None:\n1250             warnings.warn(\"The 'encoding' argument to autodoc.%s.get_doc() is deprecated.\"\n1251                           % self.__class__.__name__,\n1252                           RemovedInSphinx40Warning, stacklevel=2)\n1253         if self._new_docstrings is not None:\n1254             return self._new_docstrings\n1255         return super().get_doc(None, ignore)  # type: ignore\n1256 \n1257     def format_signature(self, **kwargs: Any) -> str:\n1258         if self.args is None and self.config.autodoc_docstring_signature:  # type: ignore\n1259             # only act if a signature is not explicitly given already, and if\n1260             # the feature is enabled\n1261             result = self._find_signature()\n1262             if result is not None:\n1263                 self.args, self.retann = result\n1264         sig = super().format_signature(**kwargs)  # type: ignore\n1265         if self._signatures:\n1266             return \"\\n\".join([sig] + self._signatures)\n1267         else:\n1268             return sig\n1269 \n1270 \n1271 class DocstringStripSignatureMixin(DocstringSignatureMixin):\n1272     \"\"\"\n1273     Mixin for AttributeDocumenter to provide the\n1274     feature of stripping any function signature from the docstring.\n1275     \"\"\"\n1276     def format_signature(self, **kwargs: Any) -> str:\n1277         if self.args is None and self.config.autodoc_docstring_signature:  # type: ignore\n1278             # only act if a signature is not explicitly given already, and if\n1279             # the feature is enabled\n1280             result = self._find_signature()\n1281             if result is not None:\n1282                 # Discarding _args is a only difference with\n1283                 # DocstringSignatureMixin.format_signature.\n1284                 # Documenter.format_signature use self.args value to format.\n1285                 _args, self.retann = result\n1286         return super().format_signature(**kwargs)\n1287 \n1288 \n1289 class FunctionDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # type: ignore\n1290     \"\"\"\n1291     Specialized Documenter subclass for functions.\n1292     \"\"\"\n1293     objtype = 'function'\n1294     member_order = 30\n1295 \n1296     @classmethod\n1297     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any\n1298                             ) -> bool:\n1299         # supports functions, builtins and bound methods exported at the module level\n1300         return (inspect.isfunction(member) or inspect.isbuiltin(member) or\n1301                 (inspect.isroutine(member) and isinstance(parent, ModuleDocumenter)))\n1302 \n1303     def format_args(self, **kwargs: Any) -> str:\n1304         if self.config.autodoc_typehints in ('none', 'description'):\n1305             kwargs.setdefault('show_annotation', False)\n1306 \n1307         try:\n1308             self.env.app.emit('autodoc-before-process-signature', self.object, False)\n1309             sig = inspect.signature(self.object, type_aliases=self.config.autodoc_type_aliases)\n1310             args = stringify_signature(sig, **kwargs)\n1311         except TypeError as exc:\n1312             logger.warning(__(\"Failed to get a function signature for %s: %s\"),\n1313                            self.fullname, exc)\n1314             return None\n1315         except ValueError:\n1316             args = ''\n1317 \n1318         if self.config.strip_signature_backslash:\n1319             # escape backslashes for reST\n1320             args = args.replace('\\\\', '\\\\\\\\')\n1321         return args\n1322 \n1323     def document_members(self, all_members: bool = False) -> None:\n1324         pass\n1325 \n1326     def add_directive_header(self, sig: str) -> None:\n1327         sourcename = self.get_sourcename()\n1328         super().add_directive_header(sig)\n1329 \n1330         if inspect.iscoroutinefunction(self.object):\n1331             self.add_line('   :async:', sourcename)\n1332 \n1333     def format_signature(self, **kwargs: Any) -> str:\n1334         sigs = []\n1335         if (self.analyzer and\n1336                 '.'.join(self.objpath) in self.analyzer.overloads and\n1337                 self.config.autodoc_typehints == 'signature'):\n1338             # Use signatures for overloaded functions instead of the implementation function.\n1339             overloaded = True\n1340         else:\n1341             overloaded = False\n1342             sig = super().format_signature(**kwargs)\n1343             sigs.append(sig)\n1344 \n1345         if inspect.is_singledispatch_function(self.object):\n1346             # append signature of singledispatch'ed functions\n1347             for typ, func in self.object.registry.items():\n1348                 if typ is object:\n1349                     pass  # default implementation. skipped.\n1350                 else:\n1351                     self.annotate_to_first_argument(func, typ)\n1352 \n1353                     documenter = FunctionDocumenter(self.directive, '')\n1354                     documenter.object = func\n1355                     documenter.objpath = [None]\n1356                     sigs.append(documenter.format_signature())\n1357         if overloaded:\n1358             __globals__ = safe_getattr(self.object, '__globals__', {})\n1359             for overload in self.analyzer.overloads.get('.'.join(self.objpath)):\n1360                 overload = evaluate_signature(overload, __globals__,\n1361                                               self.config.autodoc_type_aliases)\n1362 \n1363                 sig = stringify_signature(overload, **kwargs)\n1364                 sigs.append(sig)\n1365 \n1366         return \"\\n\".join(sigs)\n1367 \n1368     def annotate_to_first_argument(self, func: Callable, typ: Type) -> None:\n1369         \"\"\"Annotate type hint to the first argument of function if needed.\"\"\"\n1370         try:\n1371             sig = inspect.signature(func, type_aliases=self.config.autodoc_type_aliases)\n1372         except TypeError as exc:\n1373             logger.warning(__(\"Failed to get a function signature for %s: %s\"),\n1374                            self.fullname, exc)\n1375             return\n1376         except ValueError:\n1377             return\n1378 \n1379         if len(sig.parameters) == 0:\n1380             return\n1381 \n1382         params = list(sig.parameters.values())\n1383         if params[0].annotation is Parameter.empty:\n1384             params[0] = params[0].replace(annotation=typ)\n1385             try:\n1386                 func.__signature__ = sig.replace(parameters=params)  # type: ignore\n1387             except TypeError:\n1388                 # failed to update signature (ex. built-in or extension types)\n1389                 return\n1390 \n1391 \n1392 class DecoratorDocumenter(FunctionDocumenter):\n1393     \"\"\"\n1394     Specialized Documenter subclass for decorator functions.\n1395     \"\"\"\n1396     objtype = 'decorator'\n1397 \n1398     # must be lower than FunctionDocumenter\n1399     priority = -1\n1400 \n1401     def format_args(self, **kwargs: Any) -> Any:\n1402         args = super().format_args(**kwargs)\n1403         if ',' in args:\n1404             return args\n1405         else:\n1406             return None\n1407 \n1408 \n1409 # Types which have confusing metaclass signatures it would be best not to show.\n1410 # These are listed by name, rather than storing the objects themselves, to avoid\n1411 # needing to import the modules.\n1412 _METACLASS_CALL_BLACKLIST = [\n1413     'enum.EnumMeta.__call__',\n1414 ]\n1415 \n1416 \n1417 # Types whose __new__ signature is a pass-thru.\n1418 _CLASS_NEW_BLACKLIST = [\n1419     'typing.Generic.__new__',\n1420 ]\n1421 \n1422 \n1423 class ClassDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # type: ignore\n1424     \"\"\"\n1425     Specialized Documenter subclass for classes.\n1426     \"\"\"\n1427     objtype = 'class'\n1428     member_order = 20\n1429     option_spec = {\n1430         'members': members_option, 'undoc-members': bool_option,\n1431         'noindex': bool_option, 'inherited-members': inherited_members_option,\n1432         'show-inheritance': bool_option, 'member-order': member_order_option,\n1433         'exclude-members': exclude_members_option,\n1434         'private-members': members_option, 'special-members': members_option,\n1435     }  # type: Dict[str, Callable]\n1436 \n1437     _signature_class = None  # type: Any\n1438     _signature_method_name = None  # type: str\n1439 \n1440     def __init__(self, *args: Any) -> None:\n1441         super().__init__(*args)\n1442         merge_members_option(self.options)\n1443 \n1444     @classmethod\n1445     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any\n1446                             ) -> bool:\n1447         return isinstance(member, type)\n1448 \n1449     def import_object(self, raiseerror: bool = False) -> bool:\n1450         ret = super().import_object(raiseerror)\n1451         # if the class is documented under another name, document it\n1452         # as data/attribute\n1453         if ret:\n1454             if hasattr(self.object, '__name__'):\n1455                 self.doc_as_attr = (self.objpath[-1] != self.object.__name__)\n1456             else:\n1457                 self.doc_as_attr = True\n1458         return ret\n1459 \n1460     def _get_signature(self) -> Tuple[Optional[Any], Optional[str], Optional[Signature]]:\n1461         def get_user_defined_function_or_method(obj: Any, attr: str) -> Any:\n1462             \"\"\" Get the `attr` function or method from `obj`, if it is user-defined. \"\"\"\n1463             if inspect.is_builtin_class_method(obj, attr):\n1464                 return None\n1465             attr = self.get_attr(obj, attr, None)\n1466             if not (inspect.ismethod(attr) or inspect.isfunction(attr)):\n1467                 return None\n1468             return attr\n1469 \n1470         # This sequence is copied from inspect._signature_from_callable.\n1471         # ValueError means that no signature could be found, so we keep going.\n1472 \n1473         # First, we check the obj has a __signature__ attribute\n1474         if (hasattr(self.object, '__signature__') and\n1475                 isinstance(self.object.__signature__, Signature)):\n1476             return None, None, self.object.__signature__\n1477 \n1478         # Next, let's see if it has an overloaded __call__ defined\n1479         # in its metaclass\n1480         call = get_user_defined_function_or_method(type(self.object), '__call__')\n1481 \n1482         if call is not None:\n1483             if \"{0.__module__}.{0.__qualname__}\".format(call) in _METACLASS_CALL_BLACKLIST:\n1484                 call = None\n1485 \n1486         if call is not None:\n1487             self.env.app.emit('autodoc-before-process-signature', call, True)\n1488             try:\n1489                 sig = inspect.signature(call, bound_method=True,\n1490                                         type_aliases=self.config.autodoc_type_aliases)\n1491                 return type(self.object), '__call__', sig\n1492             except ValueError:\n1493                 pass\n1494 \n1495         # Now we check if the 'obj' class has a '__new__' method\n1496         new = get_user_defined_function_or_method(self.object, '__new__')\n1497 \n1498         if new is not None:\n1499             if \"{0.__module__}.{0.__qualname__}\".format(new) in _CLASS_NEW_BLACKLIST:\n1500                 new = None\n1501 \n1502         if new is not None:\n1503             self.env.app.emit('autodoc-before-process-signature', new, True)\n1504             try:\n1505                 sig = inspect.signature(new, bound_method=True,\n1506                                         type_aliases=self.config.autodoc_type_aliases)\n1507                 return self.object, '__new__', sig\n1508             except ValueError:\n1509                 pass\n1510 \n1511         # Finally, we should have at least __init__ implemented\n1512         init = get_user_defined_function_or_method(self.object, '__init__')\n1513         if init is not None:\n1514             self.env.app.emit('autodoc-before-process-signature', init, True)\n1515             try:\n1516                 sig = inspect.signature(init, bound_method=True,\n1517                                         type_aliases=self.config.autodoc_type_aliases)\n1518                 return self.object, '__init__', sig\n1519             except ValueError:\n1520                 pass\n1521 \n1522         # None of the attributes are user-defined, so fall back to let inspect\n1523         # handle it.\n1524         # We don't know the exact method that inspect.signature will read\n1525         # the signature from, so just pass the object itself to our hook.\n1526         self.env.app.emit('autodoc-before-process-signature', self.object, False)\n1527         try:\n1528             sig = inspect.signature(self.object, bound_method=False,\n1529                                     type_aliases=self.config.autodoc_type_aliases)\n1530             return None, None, sig\n1531         except ValueError:\n1532             pass\n1533 \n1534         # Still no signature: happens e.g. for old-style classes\n1535         # with __init__ in C and no `__text_signature__`.\n1536         return None, None, None\n1537 \n1538     def format_args(self, **kwargs: Any) -> str:\n1539         if self.config.autodoc_typehints in ('none', 'description'):\n1540             kwargs.setdefault('show_annotation', False)\n1541 \n1542         try:\n1543             self._signature_class, self._signature_method_name, sig = self._get_signature()\n1544         except TypeError as exc:\n1545             # __signature__ attribute contained junk\n1546             logger.warning(__(\"Failed to get a constructor signature for %s: %s\"),\n1547                            self.fullname, exc)\n1548             return None\n1549 \n1550         if sig is None:\n1551             return None\n1552 \n1553         return stringify_signature(sig, show_return_annotation=False, **kwargs)\n1554 \n1555     def format_signature(self, **kwargs: Any) -> str:\n1556         if self.doc_as_attr:\n1557             return ''\n1558 \n1559         sig = super().format_signature()\n1560         sigs = []\n1561 \n1562         overloads = self.get_overloaded_signatures()\n1563         if overloads and self.config.autodoc_typehints == 'signature':\n1564             # Use signatures for overloaded methods instead of the implementation method.\n1565             method = safe_getattr(self._signature_class, self._signature_method_name, None)\n1566             __globals__ = safe_getattr(method, '__globals__', {})\n1567             for overload in overloads:\n1568                 overload = evaluate_signature(overload, __globals__,\n1569                                               self.config.autodoc_type_aliases)\n1570 \n1571                 parameters = list(overload.parameters.values())\n1572                 overload = overload.replace(parameters=parameters[1:],\n1573                                             return_annotation=Parameter.empty)\n1574                 sig = stringify_signature(overload, **kwargs)\n1575                 sigs.append(sig)\n1576         else:\n1577             sigs.append(sig)\n1578 \n1579         return \"\\n\".join(sigs)\n1580 \n1581     def get_overloaded_signatures(self) -> List[Signature]:\n1582         if self._signature_class and self._signature_method_name:\n1583             for cls in self._signature_class.__mro__:\n1584                 try:\n1585                     analyzer = ModuleAnalyzer.for_module(cls.__module__)\n1586                     analyzer.analyze()\n1587                     qualname = '.'.join([cls.__qualname__, self._signature_method_name])\n1588                     if qualname in analyzer.overloads:\n1589                         return analyzer.overloads.get(qualname)\n1590                     elif qualname in analyzer.tagorder:\n1591                         # the constructor is defined in the class, but not overrided.\n1592                         return []\n1593                 except PycodeError:\n1594                     pass\n1595 \n1596         return []\n1597 \n1598     def add_directive_header(self, sig: str) -> None:\n1599         sourcename = self.get_sourcename()\n1600 \n1601         if self.doc_as_attr:\n1602             self.directivetype = 'attribute'\n1603         super().add_directive_header(sig)\n1604 \n1605         if self.analyzer and '.'.join(self.objpath) in self.analyzer.finals:\n1606             self.add_line('   :final:', sourcename)\n1607 \n1608         # add inheritance info, if wanted\n1609         if not self.doc_as_attr and self.options.show_inheritance:\n1610             sourcename = self.get_sourcename()\n1611             self.add_line('', sourcename)\n1612 \n1613             if hasattr(self.object, '__orig_bases__') and len(self.object.__orig_bases__):\n1614                 # A subclass of generic types\n1615                 # refs: PEP-560 <https://www.python.org/dev/peps/pep-0560/>\n1616                 bases = [restify(cls) for cls in self.object.__orig_bases__]\n1617                 self.add_line('   ' + _('Bases: %s') % ', '.join(bases), sourcename)\n1618             elif hasattr(self.object, '__bases__') and len(self.object.__bases__):\n1619                 # A normal class\n1620                 bases = [restify(cls) for cls in self.object.__bases__]\n1621                 self.add_line('   ' + _('Bases: %s') % ', '.join(bases), sourcename)\n1622 \n1623     def get_object_members(self, want_all: bool) -> Tuple[bool, ObjectMembers]:\n1624         members = get_class_members(self.object, self.objpath, self.get_attr)\n1625         if not want_all:\n1626             if not self.options.members:\n1627                 return False, []  # type: ignore\n1628             # specific members given\n1629             selected = []\n1630             for name in self.options.members:  # type: str\n1631                 if name in members:\n1632                     selected.append(members[name])\n1633                 else:\n1634                     logger.warning(__('missing attribute %s in object %s') %\n1635                                    (name, self.fullname), type='autodoc')\n1636             return False, selected\n1637         elif self.options.inherited_members:\n1638             return False, list(members.values())\n1639         else:\n1640             return False, [m for m in members.values() if m.class_ == self.object]\n1641 \n1642     def get_doc(self, encoding: str = None, ignore: int = None) -> Optional[List[List[str]]]:\n1643         if encoding is not None:\n1644             warnings.warn(\"The 'encoding' argument to autodoc.%s.get_doc() is deprecated.\"\n1645                           % self.__class__.__name__,\n1646                           RemovedInSphinx40Warning, stacklevel=2)\n1647         if self.doc_as_attr:\n1648             # Don't show the docstring of the class when it is an alias.\n1649             return None\n1650 \n1651         lines = getattr(self, '_new_docstrings', None)\n1652         if lines is not None:\n1653             return lines\n1654 \n1655         content = self.config.autoclass_content\n1656 \n1657         docstrings = []\n1658         attrdocstring = self.get_attr(self.object, '__doc__', None)\n1659         if attrdocstring:\n1660             docstrings.append(attrdocstring)\n1661 \n1662         # for classes, what the \"docstring\" is can be controlled via a\n1663         # config value; the default is only the class docstring\n1664         if content in ('both', 'init'):\n1665             __init__ = self.get_attr(self.object, '__init__', None)\n1666             initdocstring = getdoc(__init__, self.get_attr,\n1667                                    self.config.autodoc_inherit_docstrings,\n1668                                    self.parent, self.object_name)\n1669             # for new-style classes, no __init__ means default __init__\n1670             if (initdocstring is not None and\n1671                 (initdocstring == object.__init__.__doc__ or  # for pypy\n1672                  initdocstring.strip() == object.__init__.__doc__)):  # for !pypy\n1673                 initdocstring = None\n1674             if not initdocstring:\n1675                 # try __new__\n1676                 __new__ = self.get_attr(self.object, '__new__', None)\n1677                 initdocstring = getdoc(__new__, self.get_attr,\n1678                                        self.config.autodoc_inherit_docstrings,\n1679                                        self.parent, self.object_name)\n1680                 # for new-style classes, no __new__ means default __new__\n1681                 if (initdocstring is not None and\n1682                     (initdocstring == object.__new__.__doc__ or  # for pypy\n1683                      initdocstring.strip() == object.__new__.__doc__)):  # for !pypy\n1684                     initdocstring = None\n1685             if initdocstring:\n1686                 if content == 'init':\n1687                     docstrings = [initdocstring]\n1688                 else:\n1689                     docstrings.append(initdocstring)\n1690 \n1691         tab_width = self.directive.state.document.settings.tab_width\n1692         return [prepare_docstring(docstring, ignore, tab_width) for docstring in docstrings]\n1693 \n1694     def add_content(self, more_content: Optional[StringList], no_docstring: bool = False\n1695                     ) -> None:\n1696         if self.doc_as_attr:\n1697             try:\n1698                 more_content = StringList([_('alias of %s') % restify(self.object)], source='')\n1699             except AttributeError:\n1700                 pass  # Invalid class object is passed.\n1701 \n1702         super().add_content(more_content)\n1703 \n1704     def document_members(self, all_members: bool = False) -> None:\n1705         if self.doc_as_attr:\n1706             return\n1707         super().document_members(all_members)\n1708 \n1709     def generate(self, more_content: Optional[StringList] = None, real_modname: str = None,\n1710                  check_module: bool = False, all_members: bool = False) -> None:\n1711         # Do not pass real_modname and use the name from the __module__\n1712         # attribute of the class.\n1713         # If a class gets imported into the module real_modname\n1714         # the analyzer won't find the source of the class, if\n1715         # it looks in real_modname.\n1716         return super().generate(more_content=more_content,\n1717                                 check_module=check_module,\n1718                                 all_members=all_members)\n1719 \n1720 \n1721 class ExceptionDocumenter(ClassDocumenter):\n1722     \"\"\"\n1723     Specialized ClassDocumenter subclass for exceptions.\n1724     \"\"\"\n1725     objtype = 'exception'\n1726     member_order = 10\n1727 \n1728     # needs a higher priority than ClassDocumenter\n1729     priority = 10\n1730 \n1731     @classmethod\n1732     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any\n1733                             ) -> bool:\n1734         return isinstance(member, type) and issubclass(member, BaseException)\n1735 \n1736 \n1737 class DataDocumenterMixinBase:\n1738     # define types of instance variables\n1739     config = None  # type: Config\n1740     env = None  # type: BuildEnvironment\n1741     modname = None  # type: str\n1742     parent = None  # type: Any\n1743     object = None  # type: Any\n1744     objpath = None  # type: List[str]\n1745 \n1746     def should_suppress_directive_header(self) -> bool:\n1747         \"\"\"Check directive header should be suppressed.\"\"\"\n1748         return False\n1749 \n1750     def should_suppress_value_header(self) -> bool:\n1751         \"\"\"Check :value: header should be suppressed.\"\"\"\n1752         return False\n1753 \n1754     def update_content(self, more_content: StringList) -> None:\n1755         \"\"\"Update docstring for the NewType object.\"\"\"\n1756         pass\n1757 \n1758 \n1759 class GenericAliasMixin(DataDocumenterMixinBase):\n1760     \"\"\"\n1761     Mixin for DataDocumenter and AttributeDocumenter to provide the feature for\n1762     supporting GenericAliases.\n1763     \"\"\"\n1764 \n1765     def should_suppress_directive_header(self) -> bool:\n1766         return (inspect.isgenericalias(self.object) or\n1767                 super().should_suppress_directive_header())\n1768 \n1769     def update_content(self, more_content: StringList) -> None:\n1770         if inspect.isgenericalias(self.object):\n1771             alias = stringify_typehint(self.object)\n1772             more_content.append(_('alias of %s') % alias, '')\n1773             more_content.append('', '')\n1774 \n1775         super().update_content(more_content)\n1776 \n1777 \n1778 class NewTypeMixin(DataDocumenterMixinBase):\n1779     \"\"\"\n1780     Mixin for DataDocumenter and AttributeDocumenter to provide the feature for\n1781     supporting NewTypes.\n1782     \"\"\"\n1783 \n1784     def should_suppress_directive_header(self) -> bool:\n1785         return (inspect.isNewType(self.object) or\n1786                 super().should_suppress_directive_header())\n1787 \n1788     def update_content(self, more_content: StringList) -> None:\n1789         if inspect.isNewType(self.object):\n1790             supertype = restify(self.object.__supertype__)\n1791             more_content.append(_('alias of %s') % supertype, '')\n1792             more_content.append('', '')\n1793 \n1794         super().update_content(more_content)\n1795 \n1796 \n1797 class TypeVarMixin(DataDocumenterMixinBase):\n1798     \"\"\"\n1799     Mixin for DataDocumenter and AttributeDocumenter to provide the feature for\n1800     supporting TypeVars.\n1801     \"\"\"\n1802 \n1803     def should_suppress_directive_header(self) -> bool:\n1804         return (isinstance(self.object, TypeVar) or\n1805                 super().should_suppress_directive_header())\n1806 \n1807     def get_doc(self, encoding: str = None, ignore: int = None) -> Optional[List[List[str]]]:\n1808         if ignore is not None:\n1809             warnings.warn(\"The 'ignore' argument to autodoc.%s.get_doc() is deprecated.\"\n1810                           % self.__class__.__name__,\n1811                           RemovedInSphinx50Warning, stacklevel=2)\n1812 \n1813         if isinstance(self.object, TypeVar):\n1814             if self.object.__doc__ != TypeVar.__doc__:\n1815                 return super().get_doc()  # type: ignore\n1816             else:\n1817                 return []\n1818         else:\n1819             return super().get_doc()  # type: ignore\n1820 \n1821     def update_content(self, more_content: StringList) -> None:\n1822         if isinstance(self.object, TypeVar):\n1823             attrs = [repr(self.object.__name__)]\n1824             for constraint in self.object.__constraints__:\n1825                 attrs.append(stringify_typehint(constraint))\n1826             if self.object.__covariant__:\n1827                 attrs.append(\"covariant=True\")\n1828             if self.object.__contravariant__:\n1829                 attrs.append(\"contravariant=True\")\n1830 \n1831             more_content.append(_('alias of TypeVar(%s)') % \", \".join(attrs), '')\n1832             more_content.append('', '')\n1833 \n1834         super().update_content(more_content)\n1835 \n1836 \n1837 class UninitializedGlobalVariableMixin(DataDocumenterMixinBase):\n1838     \"\"\"\n1839     Mixin for DataDocumenter to provide the feature for supporting uninitialized\n1840     (type annotation only) global variables.\n1841     \"\"\"\n1842 \n1843     def import_object(self, raiseerror: bool = False) -> bool:\n1844         try:\n1845             return super().import_object(raiseerror=True)  # type: ignore\n1846         except ImportError as exc:\n1847             # annotation only instance variable (PEP-526)\n1848             try:\n1849                 with mock(self.config.autodoc_mock_imports):\n1850                     parent = import_module(self.modname, self.config.autodoc_warningiserror)\n1851                     annotations = get_type_hints(parent, None,\n1852                                                  self.config.autodoc_type_aliases)\n1853                     if self.objpath[-1] in annotations:\n1854                         self.object = UNINITIALIZED_ATTR\n1855                         self.parent = parent\n1856                         return True\n1857             except ImportError:\n1858                 pass\n1859 \n1860             if raiseerror:\n1861                 raise\n1862             else:\n1863                 logger.warning(exc.args[0], type='autodoc', subtype='import_object')\n1864                 self.env.note_reread()\n1865                 return False\n1866 \n1867     def should_suppress_value_header(self) -> bool:\n1868         return (self.object is UNINITIALIZED_ATTR or\n1869                 super().should_suppress_value_header())\n1870 \n1871     def get_doc(self, encoding: str = None, ignore: int = None) -> Optional[List[List[str]]]:\n1872         if self.object is UNINITIALIZED_ATTR:\n1873             return []\n1874         else:\n1875             return super().get_doc(encoding, ignore)  # type: ignore\n1876 \n1877 \n1878 class DataDocumenter(GenericAliasMixin, NewTypeMixin, TypeVarMixin,\n1879                      UninitializedGlobalVariableMixin, ModuleLevelDocumenter):\n1880     \"\"\"\n1881     Specialized Documenter subclass for data items.\n1882     \"\"\"\n1883     objtype = 'data'\n1884     member_order = 40\n1885     priority = -10\n1886     option_spec = dict(ModuleLevelDocumenter.option_spec)\n1887     option_spec[\"annotation\"] = annotation_option\n1888     option_spec[\"no-value\"] = bool_option\n1889 \n1890     @classmethod\n1891     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any\n1892                             ) -> bool:\n1893         return isinstance(parent, ModuleDocumenter) and isattr\n1894 \n1895     def update_annotations(self, parent: Any) -> None:\n1896         \"\"\"Update __annotations__ to support type_comment and so on.\"\"\"\n1897         try:\n1898             annotations = dict(inspect.getannotations(parent))\n1899             parent.__annotations__ = annotations\n1900 \n1901             analyzer = ModuleAnalyzer.for_module(self.modname)\n1902             analyzer.analyze()\n1903             for (classname, attrname), annotation in analyzer.annotations.items():\n1904                 if classname == '' and attrname not in annotations:\n1905                     annotations[attrname] = annotation\n1906         except AttributeError:\n1907             pass\n1908 \n1909     def import_object(self, raiseerror: bool = False) -> bool:\n1910         ret = super().import_object(raiseerror)\n1911         if self.parent:\n1912             self.update_annotations(self.parent)\n1913 \n1914         return ret\n1915 \n1916     def should_suppress_value_header(self) -> bool:\n1917         if super().should_suppress_value_header():\n1918             return True\n1919         else:\n1920             doc = self.get_doc()\n1921             metadata = extract_metadata('\\n'.join(sum(doc, [])))\n1922             if 'hide-value' in metadata:\n1923                 return True\n1924 \n1925         return False\n1926 \n1927     def add_directive_header(self, sig: str) -> None:\n1928         super().add_directive_header(sig)\n1929         sourcename = self.get_sourcename()\n1930         if self.options.annotation is SUPPRESS or self.should_suppress_directive_header():\n1931             pass\n1932         elif self.options.annotation:\n1933             self.add_line('   :annotation: %s' % self.options.annotation,\n1934                           sourcename)\n1935         else:\n1936             # obtain annotation for this data\n1937             annotations = get_type_hints(self.parent, None, self.config.autodoc_type_aliases)\n1938             if self.objpath[-1] in annotations:\n1939                 objrepr = stringify_typehint(annotations.get(self.objpath[-1]))\n1940                 self.add_line('   :type: ' + objrepr, sourcename)\n1941 \n1942             try:\n1943                 if self.options.no_value or self.should_suppress_value_header():\n1944                     pass\n1945                 else:\n1946                     objrepr = object_description(self.object)\n1947                     self.add_line('   :value: ' + objrepr, sourcename)\n1948             except ValueError:\n1949                 pass\n1950 \n1951     def document_members(self, all_members: bool = False) -> None:\n1952         pass\n1953 \n1954     def get_real_modname(self) -> str:\n1955         return self.get_attr(self.parent or self.object, '__module__', None) \\\n1956             or self.modname\n1957 \n1958     def get_module_comment(self, attrname: str) -> Optional[List[str]]:\n1959         try:\n1960             analyzer = ModuleAnalyzer.for_module(self.modname)\n1961             analyzer.analyze()\n1962             key = ('', attrname)\n1963             if key in analyzer.attr_docs:\n1964                 return list(analyzer.attr_docs[key])\n1965         except PycodeError:\n1966             pass\n1967 \n1968         return None\n1969 \n1970     def get_doc(self, encoding: str = None, ignore: int = None) -> List[List[str]]:\n1971         # Check the variable has a docstring-comment\n1972         comment = self.get_module_comment(self.objpath[-1])\n1973         if comment:\n1974             return [comment]\n1975         else:\n1976             return super().get_doc(encoding, ignore)\n1977 \n1978     def add_content(self, more_content: Optional[StringList], no_docstring: bool = False\n1979                     ) -> None:\n1980         # Disable analyzing variable comment on Documenter.add_content() to control it on\n1981         # DataDocumenter.add_content()\n1982         self.analyzer = None\n1983 \n1984         if not more_content:\n1985             more_content = StringList()\n1986 \n1987         self.update_content(more_content)\n1988         super().add_content(more_content, no_docstring=no_docstring)\n1989 \n1990 \n1991 class NewTypeDataDocumenter(DataDocumenter):\n1992     \"\"\"\n1993     Specialized Documenter subclass for NewTypes.\n1994 \n1995     Note: This must be invoked before FunctionDocumenter because NewType is a kind of\n1996     function object.\n1997     \"\"\"\n1998 \n1999     objtype = 'newtypedata'\n2000     directivetype = 'data'\n2001     priority = FunctionDocumenter.priority + 1\n2002 \n2003     @classmethod\n2004     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any\n2005                             ) -> bool:\n2006         return inspect.isNewType(member) and isattr\n2007 \n2008 \n2009 class MethodDocumenter(DocstringSignatureMixin, ClassLevelDocumenter):  # type: ignore\n2010     \"\"\"\n2011     Specialized Documenter subclass for methods (normal, static and class).\n2012     \"\"\"\n2013     objtype = 'method'\n2014     directivetype = 'method'\n2015     member_order = 50\n2016     priority = 1  # must be more than FunctionDocumenter\n2017 \n2018     @classmethod\n2019     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any\n2020                             ) -> bool:\n2021         return inspect.isroutine(member) and \\\n2022             not isinstance(parent, ModuleDocumenter)\n2023 \n2024     def import_object(self, raiseerror: bool = False) -> bool:\n2025         ret = super().import_object(raiseerror)\n2026         if not ret:\n2027             return ret\n2028 \n2029         # to distinguish classmethod/staticmethod\n2030         obj = self.parent.__dict__.get(self.object_name)\n2031         if obj is None:\n2032             obj = self.object\n2033 \n2034         if (inspect.isclassmethod(obj) or\n2035                 inspect.isstaticmethod(obj, cls=self.parent, name=self.object_name)):\n2036             # document class and static members before ordinary ones\n2037             self.member_order = self.member_order - 1\n2038 \n2039         return ret\n2040 \n2041     def format_args(self, **kwargs: Any) -> str:\n2042         if self.config.autodoc_typehints in ('none', 'description'):\n2043             kwargs.setdefault('show_annotation', False)\n2044 \n2045         try:\n2046             if self.object == object.__init__ and self.parent != object:\n2047                 # Classes not having own __init__() method are shown as no arguments.\n2048                 #\n2049                 # Note: The signature of object.__init__() is (self, /, *args, **kwargs).\n2050                 #       But it makes users confused.\n2051                 args = '()'\n2052             else:\n2053                 if inspect.isstaticmethod(self.object, cls=self.parent, name=self.object_name):\n2054                     self.env.app.emit('autodoc-before-process-signature', self.object, False)\n2055                     sig = inspect.signature(self.object, bound_method=False,\n2056                                             type_aliases=self.config.autodoc_type_aliases)\n2057                 else:\n2058                     self.env.app.emit('autodoc-before-process-signature', self.object, True)\n2059                     sig = inspect.signature(self.object, bound_method=True,\n2060                                             type_aliases=self.config.autodoc_type_aliases)\n2061                 args = stringify_signature(sig, **kwargs)\n2062         except TypeError as exc:\n2063             logger.warning(__(\"Failed to get a method signature for %s: %s\"),\n2064                            self.fullname, exc)\n2065             return None\n2066         except ValueError:\n2067             args = ''\n2068 \n2069         if self.config.strip_signature_backslash:\n2070             # escape backslashes for reST\n2071             args = args.replace('\\\\', '\\\\\\\\')\n2072         return args\n2073 \n2074     def add_directive_header(self, sig: str) -> None:\n2075         super().add_directive_header(sig)\n2076 \n2077         sourcename = self.get_sourcename()\n2078         obj = self.parent.__dict__.get(self.object_name, self.object)\n2079         if inspect.isabstractmethod(obj):\n2080             self.add_line('   :abstractmethod:', sourcename)\n2081         if inspect.iscoroutinefunction(obj):\n2082             self.add_line('   :async:', sourcename)\n2083         if inspect.isclassmethod(obj):\n2084             self.add_line('   :classmethod:', sourcename)\n2085         if inspect.isstaticmethod(obj, cls=self.parent, name=self.object_name):\n2086             self.add_line('   :staticmethod:', sourcename)\n2087         if self.analyzer and '.'.join(self.objpath) in self.analyzer.finals:\n2088             self.add_line('   :final:', sourcename)\n2089 \n2090     def document_members(self, all_members: bool = False) -> None:\n2091         pass\n2092 \n2093     def format_signature(self, **kwargs: Any) -> str:\n2094         sigs = []\n2095         if (self.analyzer and\n2096                 '.'.join(self.objpath) in self.analyzer.overloads and\n2097                 self.config.autodoc_typehints == 'signature'):\n2098             # Use signatures for overloaded methods instead of the implementation method.\n2099             overloaded = True\n2100         else:\n2101             overloaded = False\n2102             sig = super().format_signature(**kwargs)\n2103             sigs.append(sig)\n2104 \n2105         meth = self.parent.__dict__.get(self.objpath[-1])\n2106         if inspect.is_singledispatch_method(meth):\n2107             # append signature of singledispatch'ed functions\n2108             for typ, func in meth.dispatcher.registry.items():\n2109                 if typ is object:\n2110                     pass  # default implementation. skipped.\n2111                 else:\n2112                     self.annotate_to_first_argument(func, typ)\n2113 \n2114                     documenter = MethodDocumenter(self.directive, '')\n2115                     documenter.parent = self.parent\n2116                     documenter.object = func\n2117                     documenter.objpath = [None]\n2118                     sigs.append(documenter.format_signature())\n2119         if overloaded:\n2120             __globals__ = safe_getattr(self.object, '__globals__', {})\n2121             for overload in self.analyzer.overloads.get('.'.join(self.objpath)):\n2122                 overload = evaluate_signature(overload, __globals__,\n2123                                               self.config.autodoc_type_aliases)\n2124 \n2125                 if not inspect.isstaticmethod(self.object, cls=self.parent,\n2126                                               name=self.object_name):\n2127                     parameters = list(overload.parameters.values())\n2128                     overload = overload.replace(parameters=parameters[1:])\n2129                 sig = stringify_signature(overload, **kwargs)\n2130                 sigs.append(sig)\n2131 \n2132         return \"\\n\".join(sigs)\n2133 \n2134     def annotate_to_first_argument(self, func: Callable, typ: Type) -> None:\n2135         \"\"\"Annotate type hint to the first argument of function if needed.\"\"\"\n2136         try:\n2137             sig = inspect.signature(func, type_aliases=self.config.autodoc_type_aliases)\n2138         except TypeError as exc:\n2139             logger.warning(__(\"Failed to get a method signature for %s: %s\"),\n2140                            self.fullname, exc)\n2141             return\n2142         except ValueError:\n2143             return\n2144         if len(sig.parameters) == 1:\n2145             return\n2146 \n2147         params = list(sig.parameters.values())\n2148         if params[1].annotation is Parameter.empty:\n2149             params[1] = params[1].replace(annotation=typ)\n2150             try:\n2151                 func.__signature__ = sig.replace(parameters=params)  # type: ignore\n2152             except TypeError:\n2153                 # failed to update signature (ex. built-in or extension types)\n2154                 return\n2155 \n2156 \n2157 class NonDataDescriptorMixin(DataDocumenterMixinBase):\n2158     \"\"\"\n2159     Mixin for AttributeDocumenter to provide the feature for supporting non\n2160     data-descriptors.\n2161 \n2162     .. note:: This mix-in must be inherited after other mix-ins.  Otherwise, docstring\n2163               and :value: header will be suppressed unexpectedly.\n2164     \"\"\"\n2165 \n2166     def import_object(self, raiseerror: bool = False) -> bool:\n2167         ret = super().import_object(raiseerror)  # type: ignore\n2168         if ret and not inspect.isattributedescriptor(self.object):\n2169             self.non_data_descriptor = True\n2170         else:\n2171             self.non_data_descriptor = False\n2172 \n2173         return ret\n2174 \n2175     def should_suppress_value_header(self) -> bool:\n2176         return (not getattr(self, 'non_data_descriptor', False) or\n2177                 super().should_suppress_directive_header())\n2178 \n2179     def get_doc(self, encoding: str = None, ignore: int = None) -> Optional[List[List[str]]]:\n2180         if getattr(self, 'non_data_descriptor', False):\n2181             # the docstring of non datadescriptor is very probably the wrong thing\n2182             # to display\n2183             return None\n2184         else:\n2185             return super().get_doc(encoding, ignore)  # type: ignore\n2186 \n2187 \n2188 class SlotsMixin(DataDocumenterMixinBase):\n2189     \"\"\"\n2190     Mixin for AttributeDocumenter to provide the feature for supporting __slots__.\n2191     \"\"\"\n2192 \n2193     def isslotsattribute(self) -> bool:\n2194         \"\"\"Check the subject is an attribute in __slots__.\"\"\"\n2195         try:\n2196             __slots__ = inspect.getslots(self.parent)\n2197             if __slots__ and self.objpath[-1] in __slots__:\n2198                 return True\n2199             else:\n2200                 return False\n2201         except (AttributeError, ValueError, TypeError):\n2202             return False\n2203 \n2204     def import_object(self, raiseerror: bool = False) -> bool:\n2205         ret = super().import_object(raiseerror)  # type: ignore\n2206         if self.isslotsattribute():\n2207             self.object = SLOTSATTR\n2208 \n2209         return ret\n2210 \n2211     def should_suppress_directive_header(self) -> bool:\n2212         if self.object is SLOTSATTR:\n2213             self._datadescriptor = True\n2214             return True\n2215         else:\n2216             return super().should_suppress_directive_header()\n2217 \n2218     def get_doc(self, encoding: str = None, ignore: int = None) -> Optional[List[List[str]]]:\n2219         if self.object is SLOTSATTR:\n2220             try:\n2221                 __slots__ = inspect.getslots(self.parent)\n2222                 if __slots__ and __slots__.get(self.objpath[-1]):\n2223                     docstring = prepare_docstring(__slots__[self.objpath[-1]])\n2224                     return [docstring]\n2225                 else:\n2226                     return []\n2227             except (AttributeError, ValueError) as exc:\n2228                 logger.warning(__('Invalid __slots__ found on %s. Ignored.'),\n2229                                (self.parent.__qualname__, exc), type='autodoc')\n2230                 return []\n2231         else:\n2232             return super().get_doc(encoding, ignore)  # type: ignore\n2233 \n2234 \n2235 class RuntimeInstanceAttributeMixin(DataDocumenterMixinBase):\n2236     \"\"\"\n2237     Mixin for AttributeDocumenter to provide the feature for supporting runtime\n2238     instance attributes (that are defined in __init__() methods with doc-comments).\n2239 \n2240     Example:\n2241 \n2242         class Foo:\n2243             def __init__(self):\n2244                 self.attr = None  #: This is a target of this mix-in.\n2245     \"\"\"\n2246 \n2247     RUNTIME_INSTANCE_ATTRIBUTE = object()\n2248 \n2249     def is_runtime_instance_attribute(self, parent: Any) -> bool:\n2250         \"\"\"Check the subject is an attribute defined in __init__().\"\"\"\n2251         # An instance variable defined in __init__().\n2252         if self.get_attribute_comment(parent, self.objpath[-1]):  # type: ignore\n2253             return True\n2254         else:\n2255             return False\n2256 \n2257     def import_object(self, raiseerror: bool = False) -> bool:\n2258         \"\"\"Check the existence of runtime instance attribute when failed to import the\n2259         attribute.\"\"\"\n2260         try:\n2261             return super().import_object(raiseerror=True)  # type: ignore\n2262         except ImportError as exc:\n2263             try:\n2264                 with mock(self.config.autodoc_mock_imports):\n2265                     ret = import_object(self.modname, self.objpath[:-1], 'class',\n2266                                         attrgetter=self.get_attr,  # type: ignore\n2267                                         warningiserror=self.config.autodoc_warningiserror)\n2268                     parent = ret[3]\n2269                     if self.is_runtime_instance_attribute(parent):\n2270                         self.object = self.RUNTIME_INSTANCE_ATTRIBUTE\n2271                         self.parent = parent\n2272                         return True\n2273             except ImportError:\n2274                 pass\n2275 \n2276             if raiseerror:\n2277                 raise\n2278             else:\n2279                 logger.warning(exc.args[0], type='autodoc', subtype='import_object')\n2280                 self.env.note_reread()\n2281                 return False\n2282 \n2283     def should_suppress_value_header(self) -> bool:\n2284         return (self.object is self.RUNTIME_INSTANCE_ATTRIBUTE or\n2285                 super().should_suppress_value_header())\n2286 \n2287 \n2288 class UninitializedInstanceAttributeMixin(DataDocumenterMixinBase):\n2289     \"\"\"\n2290     Mixin for AttributeDocumenter to provide the feature for supporting uninitialized\n2291     instance attributes (PEP-526 styled, annotation only attributes).\n2292 \n2293     Example:\n2294 \n2295         class Foo:\n2296             attr: int  #: This is a target of this mix-in.\n2297     \"\"\"\n2298 \n2299     def is_uninitialized_instance_attribute(self, parent: Any) -> bool:\n2300         \"\"\"Check the subject is an annotation only attribute.\"\"\"\n2301         annotations = get_type_hints(parent, None, self.config.autodoc_type_aliases)\n2302         if self.objpath[-1] in annotations:\n2303             return True\n2304         else:\n2305             return False\n2306 \n2307     def import_object(self, raiseerror: bool = False) -> bool:\n2308         \"\"\"Check the exisitence of uninitialized instance attribute when failed to import\n2309         the attribute.\"\"\"\n2310         try:\n2311             return super().import_object(raiseerror=True)  # type: ignore\n2312         except ImportError as exc:\n2313             try:\n2314                 ret = import_object(self.modname, self.objpath[:-1], 'class',\n2315                                     attrgetter=self.get_attr,  # type: ignore\n2316                                     warningiserror=self.config.autodoc_warningiserror)\n2317                 parent = ret[3]\n2318                 if self.is_uninitialized_instance_attribute(parent):\n2319                     self.object = UNINITIALIZED_ATTR\n2320                     self.parent = parent\n2321                     return True\n2322             except ImportError:\n2323                 pass\n2324 \n2325             if raiseerror:\n2326                 raise\n2327             else:\n2328                 logger.warning(exc.args[0], type='autodoc', subtype='import_object')\n2329                 self.env.note_reread()\n2330                 return False\n2331 \n2332     def should_suppress_value_header(self) -> bool:\n2333         return (self.object is UNINITIALIZED_ATTR or\n2334                 super().should_suppress_value_header())\n2335 \n2336     def get_doc(self, encoding: str = None, ignore: int = None) -> Optional[List[List[str]]]:\n2337         if self.object is UNINITIALIZED_ATTR:\n2338             return None\n2339         else:\n2340             return super().get_doc(encoding, ignore)  # type: ignore\n2341 \n2342 \n2343 class AttributeDocumenter(GenericAliasMixin, NewTypeMixin, SlotsMixin,  # type: ignore\n2344                           TypeVarMixin, RuntimeInstanceAttributeMixin,\n2345                           UninitializedInstanceAttributeMixin, NonDataDescriptorMixin,\n2346                           DocstringStripSignatureMixin, ClassLevelDocumenter):\n2347     \"\"\"\n2348     Specialized Documenter subclass for attributes.\n2349     \"\"\"\n2350     objtype = 'attribute'\n2351     member_order = 60\n2352     option_spec = dict(ModuleLevelDocumenter.option_spec)\n2353     option_spec[\"annotation\"] = annotation_option\n2354     option_spec[\"no-value\"] = bool_option\n2355 \n2356     # must be higher than the MethodDocumenter, else it will recognize\n2357     # some non-data descriptors as methods\n2358     priority = 10\n2359 \n2360     @staticmethod\n2361     def is_function_or_method(obj: Any) -> bool:\n2362         return inspect.isfunction(obj) or inspect.isbuiltin(obj) or inspect.ismethod(obj)\n2363 \n2364     @classmethod\n2365     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any\n2366                             ) -> bool:\n2367         if inspect.isattributedescriptor(member):\n2368             return True\n2369         elif (not isinstance(parent, ModuleDocumenter) and\n2370               not inspect.isroutine(member) and\n2371               not isinstance(member, type)):\n2372             return True\n2373         else:\n2374             return False\n2375 \n2376     def document_members(self, all_members: bool = False) -> None:\n2377         pass\n2378 \n2379     def isinstanceattribute(self) -> bool:\n2380         \"\"\"Check the subject is an instance attribute.\"\"\"\n2381         warnings.warn('AttributeDocumenter.isinstanceattribute() is deprecated.',\n2382                       RemovedInSphinx50Warning)\n2383         # uninitialized instance variable (PEP-526)\n2384         with mock(self.config.autodoc_mock_imports):\n2385             try:\n2386                 ret = import_object(self.modname, self.objpath[:-1], 'class',\n2387                                     attrgetter=self.get_attr,\n2388                                     warningiserror=self.config.autodoc_warningiserror)\n2389                 self.parent = ret[3]\n2390                 annotations = get_type_hints(self.parent, None,\n2391                                              self.config.autodoc_type_aliases)\n2392                 if self.objpath[-1] in annotations:\n2393                     self.object = UNINITIALIZED_ATTR\n2394                     return True\n2395             except ImportError:\n2396                 pass\n2397 \n2398         return False\n2399 \n2400     def update_annotations(self, parent: Any) -> None:\n2401         \"\"\"Update __annotations__ to support type_comment and so on.\"\"\"\n2402         try:\n2403             annotations = dict(inspect.getannotations(parent))\n2404             parent.__annotations__ = annotations\n2405 \n2406             for cls in inspect.getmro(parent):\n2407                 try:\n2408                     module = safe_getattr(cls, '__module__')\n2409                     qualname = safe_getattr(cls, '__qualname__')\n2410 \n2411                     analyzer = ModuleAnalyzer.for_module(module)\n2412                     analyzer.analyze()\n2413                     for (classname, attrname), annotation in analyzer.annotations.items():\n2414                         if classname == qualname and attrname not in annotations:\n2415                             annotations[attrname] = annotation\n2416                 except (AttributeError, PycodeError):\n2417                     pass\n2418         except AttributeError:\n2419             pass\n2420         except TypeError:\n2421             # Failed to set __annotations__ (built-in, extensions, etc.)\n2422             pass\n2423 \n2424     def import_object(self, raiseerror: bool = False) -> bool:\n2425         ret = super().import_object(raiseerror)\n2426         if inspect.isenumattribute(self.object):\n2427             self.object = self.object.value\n2428         if self.parent:\n2429             self.update_annotations(self.parent)\n2430 \n2431         return ret\n2432 \n2433     def get_real_modname(self) -> str:\n2434         return self.get_attr(self.parent or self.object, '__module__', None) \\\n2435             or self.modname\n2436 \n2437     def should_suppress_value_header(self) -> bool:\n2438         if super().should_suppress_value_header():\n2439             return True\n2440         else:\n2441             doc = self.get_doc()\n2442             if doc:\n2443                 metadata = extract_metadata('\\n'.join(sum(doc, [])))\n2444                 if 'hide-value' in metadata:\n2445                     return True\n2446 \n2447         return False\n2448 \n2449     def add_directive_header(self, sig: str) -> None:\n2450         super().add_directive_header(sig)\n2451         sourcename = self.get_sourcename()\n2452         if self.options.annotation is SUPPRESS or self.should_suppress_directive_header():\n2453             pass\n2454         elif self.options.annotation:\n2455             self.add_line('   :annotation: %s' % self.options.annotation, sourcename)\n2456         else:\n2457             # obtain type annotation for this attribute\n2458             annotations = get_type_hints(self.parent, None, self.config.autodoc_type_aliases)\n2459             if self.objpath[-1] in annotations:\n2460                 objrepr = stringify_typehint(annotations.get(self.objpath[-1]))\n2461                 self.add_line('   :type: ' + objrepr, sourcename)\n2462 \n2463             try:\n2464                 if self.options.no_value or self.should_suppress_value_header():\n2465                     pass\n2466                 else:\n2467                     objrepr = object_description(self.object)\n2468                     self.add_line('   :value: ' + objrepr, sourcename)\n2469             except ValueError:\n2470                 pass\n2471 \n2472     def get_attribute_comment(self, parent: Any, attrname: str) -> Optional[List[str]]:\n2473         try:\n2474             for cls in inspect.getmro(parent):\n2475                 try:\n2476                     module = safe_getattr(cls, '__module__')\n2477                     qualname = safe_getattr(cls, '__qualname__')\n2478 \n2479                     analyzer = ModuleAnalyzer.for_module(module)\n2480                     analyzer.analyze()\n2481                     if qualname and self.objpath:\n2482                         key = (qualname, attrname)\n2483                         if key in analyzer.attr_docs:\n2484                             return list(analyzer.attr_docs[key])\n2485                 except (AttributeError, PycodeError):\n2486                     pass\n2487         except (AttributeError, PycodeError):\n2488             pass\n2489 \n2490         return None\n2491 \n2492     def get_doc(self, encoding: str = None, ignore: int = None) -> Optional[List[List[str]]]:\n2493         # Check the attribute has a docstring-comment\n2494         comment = self.get_attribute_comment(self.parent, self.objpath[-1])\n2495         if comment:\n2496             return [comment]\n2497 \n2498         try:\n2499             # Disable `autodoc_inherit_docstring` temporarily to avoid to obtain\n2500             # a docstring from the value which descriptor returns unexpectedly.\n2501             # ref: https://github.com/sphinx-doc/sphinx/issues/7805\n2502             orig = self.config.autodoc_inherit_docstrings\n2503             self.config.autodoc_inherit_docstrings = False  # type: ignore\n2504             return super().get_doc(encoding, ignore)\n2505         finally:\n2506             self.config.autodoc_inherit_docstrings = orig  # type: ignore\n2507 \n2508     def add_content(self, more_content: Optional[StringList], no_docstring: bool = False\n2509                     ) -> None:\n2510         # Disable analyzing attribute comment on Documenter.add_content() to control it on\n2511         # AttributeDocumenter.add_content()\n2512         self.analyzer = None\n2513 \n2514         if more_content is None:\n2515             more_content = StringList()\n2516         self.update_content(more_content)\n2517         super().add_content(more_content, no_docstring)\n2518 \n2519 \n2520 class PropertyDocumenter(DocstringStripSignatureMixin, ClassLevelDocumenter):  # type: ignore\n2521     \"\"\"\n2522     Specialized Documenter subclass for properties.\n2523     \"\"\"\n2524     objtype = 'property'\n2525     directivetype = 'method'\n2526     member_order = 60\n2527 \n2528     # before AttributeDocumenter\n2529     priority = AttributeDocumenter.priority + 1\n2530 \n2531     @classmethod\n2532     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any\n2533                             ) -> bool:\n2534         return inspect.isproperty(member) and isinstance(parent, ClassDocumenter)\n2535 \n2536     def document_members(self, all_members: bool = False) -> None:\n2537         pass\n2538 \n2539     def get_real_modname(self) -> str:\n2540         return self.get_attr(self.parent or self.object, '__module__', None) \\\n2541             or self.modname\n2542 \n2543     def add_directive_header(self, sig: str) -> None:\n2544         super().add_directive_header(sig)\n2545         sourcename = self.get_sourcename()\n2546         if inspect.isabstractmethod(self.object):\n2547             self.add_line('   :abstractmethod:', sourcename)\n2548         self.add_line('   :property:', sourcename)\n2549 \n2550 \n2551 class NewTypeAttributeDocumenter(AttributeDocumenter):\n2552     \"\"\"\n2553     Specialized Documenter subclass for NewTypes.\n2554 \n2555     Note: This must be invoked before MethodDocumenter because NewType is a kind of\n2556     function object.\n2557     \"\"\"\n2558 \n2559     objtype = 'newvarattribute'\n2560     directivetype = 'attribute'\n2561     priority = MethodDocumenter.priority + 1\n2562 \n2563     @classmethod\n2564     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any\n2565                             ) -> bool:\n2566         return not isinstance(parent, ModuleDocumenter) and inspect.isNewType(member)\n2567 \n2568 \n2569 def get_documenters(app: Sphinx) -> Dict[str, \"Type[Documenter]\"]:\n2570     \"\"\"Returns registered Documenter classes\"\"\"\n2571     warnings.warn(\"get_documenters() is deprecated.\", RemovedInSphinx50Warning, stacklevel=2)\n2572     return app.registry.documenters\n2573 \n2574 \n2575 def autodoc_attrgetter(app: Sphinx, obj: Any, name: str, *defargs: Any) -> Any:\n2576     \"\"\"Alternative getattr() for types\"\"\"\n2577     for typ, func in app.registry.autodoc_attrgettrs.items():\n2578         if isinstance(obj, typ):\n2579             return func(obj, name, *defargs)\n2580 \n2581     return safe_getattr(obj, name, *defargs)\n2582 \n2583 \n2584 def migrate_autodoc_member_order(app: Sphinx, config: Config) -> None:\n2585     if config.autodoc_member_order == 'alphabetic':\n2586         # RemovedInSphinx50Warning\n2587         logger.warning(__('autodoc_member_order now accepts \"alphabetical\" '\n2588                           'instead of \"alphabetic\". Please update your setting.'))\n2589         config.autodoc_member_order = 'alphabetical'  # type: ignore\n2590 \n2591 \n2592 # for compatibility\n2593 from sphinx.ext.autodoc.deprecated import DataDeclarationDocumenter  # NOQA\n2594 from sphinx.ext.autodoc.deprecated import GenericAliasDocumenter  # NOQA\n2595 from sphinx.ext.autodoc.deprecated import InstanceAttributeDocumenter  # NOQA\n2596 from sphinx.ext.autodoc.deprecated import SingledispatchFunctionDocumenter  # NOQA\n2597 from sphinx.ext.autodoc.deprecated import SingledispatchMethodDocumenter  # NOQA\n2598 from sphinx.ext.autodoc.deprecated import SlotsAttributeDocumenter  # NOQA\n2599 from sphinx.ext.autodoc.deprecated import TypeVarDocumenter  # NOQA\n2600 \n2601 \n2602 def setup(app: Sphinx) -> Dict[str, Any]:\n2603     app.add_autodocumenter(ModuleDocumenter)\n2604     app.add_autodocumenter(ClassDocumenter)\n2605     app.add_autodocumenter(ExceptionDocumenter)\n2606     app.add_autodocumenter(DataDocumenter)\n2607     app.add_autodocumenter(NewTypeDataDocumenter)\n2608     app.add_autodocumenter(FunctionDocumenter)\n2609     app.add_autodocumenter(DecoratorDocumenter)\n2610     app.add_autodocumenter(MethodDocumenter)\n2611     app.add_autodocumenter(AttributeDocumenter)\n2612     app.add_autodocumenter(PropertyDocumenter)\n2613     app.add_autodocumenter(NewTypeAttributeDocumenter)\n2614 \n2615     app.add_config_value('autoclass_content', 'class', True, ENUM('both', 'class', 'init'))\n2616     app.add_config_value('autodoc_member_order', 'alphabetical', True,\n2617                          ENUM('alphabetic', 'alphabetical', 'bysource', 'groupwise'))\n2618     app.add_config_value('autodoc_default_options', {}, True)\n2619     app.add_config_value('autodoc_docstring_signature', True, True)\n2620     app.add_config_value('autodoc_mock_imports', [], True)\n2621     app.add_config_value('autodoc_typehints', \"signature\", True,\n2622                          ENUM(\"signature\", \"description\", \"none\"))\n2623     app.add_config_value('autodoc_type_aliases', {}, True)\n2624     app.add_config_value('autodoc_warningiserror', True, True)\n2625     app.add_config_value('autodoc_inherit_docstrings', True, True)\n2626     app.add_event('autodoc-before-process-signature')\n2627     app.add_event('autodoc-process-docstring')\n2628     app.add_event('autodoc-process-signature')\n2629     app.add_event('autodoc-skip-member')\n2630 \n2631     app.connect('config-inited', migrate_autodoc_member_order, priority=800)\n2632 \n2633     app.setup_extension('sphinx.ext.autodoc.type_comment')\n2634     app.setup_extension('sphinx.ext.autodoc.typehints')\n2635 \n2636     return {'version': sphinx.__display_version__, 'parallel_read_safe': True}\n",
        "intended_behavior": "This file's functionality includes automatically documenting Python source code files. The modification needed here involves ensuring that when extracting docstrings that include `code-block` or `literalinclude` directives, an automatic dedent is applied to these blocks if they lack a specific `:dedent:` value. This change should gracefully handle existing documentation and new inclusions alike, promoting ease of documentation writing and consistency in documentation appearance."
    }
]