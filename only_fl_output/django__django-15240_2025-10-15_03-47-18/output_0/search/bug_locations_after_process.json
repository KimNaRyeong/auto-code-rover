[
    {
        "rel_file_path": "django/db/migrations/recorder.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__4.1/django/db/migrations/recorder.py",
        "start": 9,
        "end": 96,
        "class_name": "MigrationRecorder",
        "method_name": null,
        "code": "9 class MigrationRecorder:\n10     \"\"\"\n11     Deal with storing migration records in the database.\n12 \n13     Because this table is actually itself used for dealing with model\n14     creation, it's the one thing we can't do normally via migrations.\n15     We manually handle table creation/schema updating (using schema backend)\n16     and then have a floating model to do queries with.\n17 \n18     If a migration is unapplied its row is removed from the table. Having\n19     a row in the table always means a migration is applied.\n20     \"\"\"\n21     _migration_class = None\n22 \n23     @classproperty\n24     def Migration(cls):\n25         \"\"\"\n26         Lazy load to avoid AppRegistryNotReady if installed apps import\n27         MigrationRecorder.\n28         \"\"\"\n29         if cls._migration_class is None:\n30             class Migration(models.Model):\n31                 app = models.CharField(max_length=255)\n32                 name = models.CharField(max_length=255)\n33                 applied = models.DateTimeField(default=now)\n34 \n35                 class Meta:\n36                     apps = Apps()\n37                     app_label = 'migrations'\n38                     db_table = 'django_migrations'\n39 \n40                 def __str__(self):\n41                     return 'Migration %s for %s' % (self.name, self.app)\n42 \n43             cls._migration_class = Migration\n44         return cls._migration_class\n45 \n46     def __init__(self, connection):\n47         self.connection = connection\n48 \n49     @property\n50     def migration_qs(self):\n51         return self.Migration.objects.using(self.connection.alias)\n52 \n53     def has_table(self):\n54         \"\"\"Return True if the django_migrations table exists.\"\"\"\n55         with self.connection.cursor() as cursor:\n56             tables = self.connection.introspection.table_names(cursor)\n57         return self.Migration._meta.db_table in tables\n58 \n59     def ensure_schema(self):\n60         \"\"\"Ensure the table exists and has the correct schema.\"\"\"\n61         # If the table's there, that's fine - we've never changed its schema\n62         # in the codebase.\n63         if self.has_table():\n64             return\n65         # Make the table\n66         try:\n67             with self.connection.schema_editor() as editor:\n68                 editor.create_model(self.Migration)\n69         except DatabaseError as exc:\n70             raise MigrationSchemaMissing(\"Unable to create the django_migrations table (%s)\" % exc)\n71 \n72     def applied_migrations(self):\n73         \"\"\"\n74         Return a dict mapping (app_name, migration_name) to Migration instances\n75         for all applied migrations.\n76         \"\"\"\n77         if self.has_table():\n78             return {(migration.app, migration.name): migration for migration in self.migration_qs}\n79         else:\n80             # If the django_migrations table doesn't exist, then no migrations\n81             # are applied.\n82             return {}\n83 \n84     def record_applied(self, app, name):\n85         \"\"\"Record that a migration was applied.\"\"\"\n86         self.ensure_schema()\n87         self.migration_qs.create(app=app, name=name)\n88 \n89     def record_unapplied(self, app, name):\n90         \"\"\"Record that a migration was unapplied.\"\"\"\n91         self.ensure_schema()\n92         self.migration_qs.filter(app=app, name=name).delete()\n93 \n94     def flush(self):\n95         \"\"\"Delete all migration records. Useful for testing migrations.\"\"\"\n96         self.migration_qs.all().delete()\n",
        "intended_behavior": "This class should incorporate a new method (e.g., `validate_migrations_existence`) tasked with checking the `django_migrations` table for any records of migrations that no longer exist in the file system. It might need to access the migration file directory to compare the list of migrations in the filesystem against those recorded in the database. Migrations listed in the database but not found in the file system should be handled appropriately, possibly with a mechanism to retain records of migrations that are intentionally \"squashed\" but still acknowledged by newer migration files."
    },
    {
        "rel_file_path": "django/db/migrations/executor.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__4.1/django/db/migrations/executor.py",
        "start": 91,
        "end": 138,
        "class_name": null,
        "method_name": "migrate",
        "code": "91     def migrate(self, targets, plan=None, state=None, fake=False, fake_initial=False):\n92         \"\"\"\n93         Migrate the database up to the given targets.\n94 \n95         Django first needs to create all project states before a migration is\n96         (un)applied and in a second step run all the database operations.\n97         \"\"\"\n98         # The django_migrations table must be present to record applied\n99         # migrations, but don't create it if there are no migrations to apply.\n100         if plan == []:\n101             if not self.recorder.has_table():\n102                 return self._create_project_state(with_applied_migrations=False)\n103         else:\n104             self.recorder.ensure_schema()\n105 \n106         if plan is None:\n107             plan = self.migration_plan(targets)\n108         # Create the forwards plan Django would follow on an empty database\n109         full_plan = self.migration_plan(self.loader.graph.leaf_nodes(), clean_start=True)\n110 \n111         all_forwards = all(not backwards for mig, backwards in plan)\n112         all_backwards = all(backwards for mig, backwards in plan)\n113 \n114         if not plan:\n115             if state is None:\n116                 # The resulting state should include applied migrations.\n117                 state = self._create_project_state(with_applied_migrations=True)\n118         elif all_forwards == all_backwards:\n119             # This should only happen if there's a mixed plan\n120             raise InvalidMigrationPlan(\n121                 \"Migration plans with both forwards and backwards migrations \"\n122                 \"are not supported. Please split your migration process into \"\n123                 \"separate plans of only forwards OR backwards migrations.\",\n124                 plan\n125             )\n126         elif all_forwards:\n127             if state is None:\n128                 # The resulting state should still include applied migrations.\n129                 state = self._create_project_state(with_applied_migrations=True)\n130             state = self._migrate_all_forwards(state, plan, full_plan, fake=fake, fake_initial=fake_initial)\n131         else:\n132             # No need to check for `elif all_backwards` here, as that condition\n133             # would always evaluate to true.\n134             state = self._migrate_all_backwards(plan, full_plan, fake=fake)\n135 \n136         self.check_replacements()\n137 \n138         return state\n",
        "intended_behavior": "Modify the `migrate` method to integrate a call to the newly proposed `MigrationRecorder.validate_migrations_existence` method at a strategic point before applying migrations. This adjustment ensures that the database's `django_migrations` table reflects only those migrations that are actively part of the project or are acknowledged by squashed migrations. Care must be taken to ensure this validation does not impede the squash migrations process or inadvertently remove historical data necessary for future rollbacks or audits."
    },
    {
        "rel_file_path": "django/db/migrations/executor.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__4.1/django/db/migrations/executor.py",
        "start": 91,
        "end": 138,
        "class_name": "MigrationExecutor",
        "method_name": "migrate",
        "code": "91     def migrate(self, targets, plan=None, state=None, fake=False, fake_initial=False):\n92         \"\"\"\n93         Migrate the database up to the given targets.\n94 \n95         Django first needs to create all project states before a migration is\n96         (un)applied and in a second step run all the database operations.\n97         \"\"\"\n98         # The django_migrations table must be present to record applied\n99         # migrations, but don't create it if there are no migrations to apply.\n100         if plan == []:\n101             if not self.recorder.has_table():\n102                 return self._create_project_state(with_applied_migrations=False)\n103         else:\n104             self.recorder.ensure_schema()\n105 \n106         if plan is None:\n107             plan = self.migration_plan(targets)\n108         # Create the forwards plan Django would follow on an empty database\n109         full_plan = self.migration_plan(self.loader.graph.leaf_nodes(), clean_start=True)\n110 \n111         all_forwards = all(not backwards for mig, backwards in plan)\n112         all_backwards = all(backwards for mig, backwards in plan)\n113 \n114         if not plan:\n115             if state is None:\n116                 # The resulting state should include applied migrations.\n117                 state = self._create_project_state(with_applied_migrations=True)\n118         elif all_forwards == all_backwards:\n119             # This should only happen if there's a mixed plan\n120             raise InvalidMigrationPlan(\n121                 \"Migration plans with both forwards and backwards migrations \"\n122                 \"are not supported. Please split your migration process into \"\n123                 \"separate plans of only forwards OR backwards migrations.\",\n124                 plan\n125             )\n126         elif all_forwards:\n127             if state is None:\n128                 # The resulting state should still include applied migrations.\n129                 state = self._create_project_state(with_applied_migrations=True)\n130             state = self._migrate_all_forwards(state, plan, full_plan, fake=fake, fake_initial=fake_initial)\n131         else:\n132             # No need to check for `elif all_backwards` here, as that condition\n133             # would always evaluate to true.\n134             state = self._migrate_all_backwards(plan, full_plan, fake=fake)\n135 \n136         self.check_replacements()\n137 \n138         return state\n",
        "intended_behavior": "Modify the `migrate` method to integrate a call to the newly proposed `MigrationRecorder.validate_migrations_existence` method at a strategic point before applying migrations. This adjustment ensures that the database's `django_migrations` table reflects only those migrations that are actively part of the project or are acknowledged by squashed migrations. Care must be taken to ensure this validation does not impede the squash migrations process or inadvertently remove historical data necessary for future rollbacks or audits."
    }
]