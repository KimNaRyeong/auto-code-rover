[
    {
        "rel_file_path": "sympy/core/numbers.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sympy__sympy/setup_sympy__sympy__1.5/sympy/core/numbers.py",
        "start": 3784,
        "end": 3834,
        "class_name": "Catalan",
        "method_name": null,
        "code": "3784 class Catalan(with_metaclass(Singleton, NumberSymbol)):\n3785     r\"\"\"Catalan's constant.\n3786 \n3787     `K = 0.91596559\\ldots` is given by the infinite series\n3788 \n3789     .. math:: K = \\sum_{k=0}^{\\infty} \\frac{(-1)^k}{(2k+1)^2}\n3790 \n3791     Catalan is a singleton, and can be accessed by ``S.Catalan``.\n3792 \n3793     Examples\n3794     ========\n3795 \n3796     >>> from sympy import S\n3797     >>> S.Catalan.is_irrational\n3798     >>> S.Catalan > 0\n3799     True\n3800     >>> S.Catalan > 1\n3801     False\n3802 \n3803     References\n3804     ==========\n3805 \n3806     .. [1] https://en.wikipedia.org/wiki/Catalan%27s_constant\n3807     \"\"\"\n3808 \n3809     is_real = True\n3810     is_positive = True\n3811     is_negative = False\n3812     is_irrational = None\n3813     is_number = True\n3814 \n3815     __slots__ = []\n3816 \n3817     def __int__(self):\n3818         return 0\n3819 \n3820     def _as_mpf_val(self, prec):\n3821         # XXX track down why this has to be increased\n3822         v = mlib.catalan_fixed(prec + 10)\n3823         rv = mlib.from_man_exp(v, -prec - 10)\n3824         return mpf_norm(rv, prec)\n3825 \n3826     def approximation_interval(self, number_cls):\n3827         if issubclass(number_cls, Integer):\n3828             return (S.Zero, S.One)\n3829         elif issubclass(number_cls, Rational):\n3830             return (Rational(9, 10), S.One)\n3831 \n3832     def _sage_(self):\n3833         import sage.all as sage\n3834         return sage.catalan\n",
        "intended_behavior": "Implement a new method named `rewrite` within the `Catalan` class. This method should allow the `Catalan` number to be rewritten as a sum expression, according to mathematical rules that define the Catalan number. The implementation should preserve existing functionalities of the `Catalan` class, ensuring that it remains a singleton, retains its number properties (real, positive), and functions correctly within the broader SymPy library. This new method aims to extend the class's capabilities without altering its established behavior or properties."
    },
    {
        "rel_file_path": "sympy/printing/latex.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sympy__sympy/setup_sympy__sympy__1.5/sympy/printing/latex.py",
        "start": 1,
        "end": 2835,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\"\n2 A Printer which converts an expression into its LaTeX equivalent.\n3 \"\"\"\n4 \n5 from __future__ import print_function, division\n6 \n7 import itertools\n8 \n9 from sympy.core import S, Add, Symbol, Mod\n10 from sympy.core.alphabets import greeks\n11 from sympy.core.containers import Tuple\n12 from sympy.core.function import _coeff_isneg, AppliedUndef, Derivative\n13 from sympy.core.operations import AssocOp\n14 from sympy.core.sympify import SympifyError\n15 from sympy.logic.boolalg import true\n16 \n17 # sympy.printing imports\n18 from sympy.printing.precedence import precedence_traditional\n19 from sympy.printing.printer import Printer\n20 from sympy.printing.conventions import split_super_sub, requires_partial\n21 from sympy.printing.precedence import precedence, PRECEDENCE\n22 \n23 import mpmath.libmp as mlib\n24 from mpmath.libmp import prec_to_dps\n25 \n26 from sympy.core.compatibility import default_sort_key, range\n27 from sympy.utilities.iterables import has_variety\n28 \n29 import re\n30 \n31 # Hand-picked functions which can be used directly in both LaTeX and MathJax\n32 # Complete list at\n33 # https://docs.mathjax.org/en/latest/tex.html#supported-latex-commands\n34 # This variable only contains those functions which sympy uses.\n35 accepted_latex_functions = ['arcsin', 'arccos', 'arctan', 'sin', 'cos', 'tan',\n36                             'sinh', 'cosh', 'tanh', 'sqrt', 'ln', 'log', 'sec',\n37                             'csc', 'cot', 'coth', 're', 'im', 'frac', 'root',\n38                             'arg',\n39                             ]\n40 \n41 tex_greek_dictionary = {\n42     'Alpha': 'A',\n43     'Beta': 'B',\n44     'Gamma': r'\\Gamma',\n45     'Delta': r'\\Delta',\n46     'Epsilon': 'E',\n47     'Zeta': 'Z',\n48     'Eta': 'H',\n49     'Theta': r'\\Theta',\n50     'Iota': 'I',\n51     'Kappa': 'K',\n52     'Lambda': r'\\Lambda',\n53     'Mu': 'M',\n54     'Nu': 'N',\n55     'Xi': r'\\Xi',\n56     'omicron': 'o',\n57     'Omicron': 'O',\n58     'Pi': r'\\Pi',\n59     'Rho': 'P',\n60     'Sigma': r'\\Sigma',\n61     'Tau': 'T',\n62     'Upsilon': r'\\Upsilon',\n63     'Phi': r'\\Phi',\n64     'Chi': 'X',\n65     'Psi': r'\\Psi',\n66     'Omega': r'\\Omega',\n67     'lamda': r'\\lambda',\n68     'Lamda': r'\\Lambda',\n69     'khi': r'\\chi',\n70     'Khi': r'X',\n71     'varepsilon': r'\\varepsilon',\n72     'varkappa': r'\\varkappa',\n73     'varphi': r'\\varphi',\n74     'varpi': r'\\varpi',\n75     'varrho': r'\\varrho',\n76     'varsigma': r'\\varsigma',\n77     'vartheta': r'\\vartheta',\n78 }\n79 \n80 other_symbols = set(['aleph', 'beth', 'daleth', 'gimel', 'ell', 'eth', 'hbar',\n81                      'hslash', 'mho', 'wp', ])\n82 \n83 # Variable name modifiers\n84 modifier_dict = {\n85     # Accents\n86     'mathring': lambda s: r'\\mathring{'+s+r'}',\n87     'ddddot': lambda s: r'\\ddddot{'+s+r'}',\n88     'dddot': lambda s: r'\\dddot{'+s+r'}',\n89     'ddot': lambda s: r'\\ddot{'+s+r'}',\n90     'dot': lambda s: r'\\dot{'+s+r'}',\n91     'check': lambda s: r'\\check{'+s+r'}',\n92     'breve': lambda s: r'\\breve{'+s+r'}',\n93     'acute': lambda s: r'\\acute{'+s+r'}',\n94     'grave': lambda s: r'\\grave{'+s+r'}',\n95     'tilde': lambda s: r'\\tilde{'+s+r'}',\n96     'hat': lambda s: r'\\hat{'+s+r'}',\n97     'bar': lambda s: r'\\bar{'+s+r'}',\n98     'vec': lambda s: r'\\vec{'+s+r'}',\n99     'prime': lambda s: \"{\"+s+\"}'\",\n100     'prm': lambda s: \"{\"+s+\"}'\",\n101     # Faces\n102     'bold': lambda s: r'\\boldsymbol{'+s+r'}',\n103     'bm': lambda s: r'\\boldsymbol{'+s+r'}',\n104     'cal': lambda s: r'\\mathcal{'+s+r'}',\n105     'scr': lambda s: r'\\mathscr{'+s+r'}',\n106     'frak': lambda s: r'\\mathfrak{'+s+r'}',\n107     # Brackets\n108     'norm': lambda s: r'\\left\\|{'+s+r'}\\right\\|',\n109     'avg': lambda s: r'\\left\\langle{'+s+r'}\\right\\rangle',\n110     'abs': lambda s: r'\\left|{'+s+r'}\\right|',\n111     'mag': lambda s: r'\\left|{'+s+r'}\\right|',\n112 }\n113 \n114 greek_letters_set = frozenset(greeks)\n115 \n116 _between_two_numbers_p = (\n117     re.compile(r'[0-9][} ]*$'),  # search\n118     re.compile(r'[{ ]*[-+0-9]'),  # match\n119 )\n120 \n121 \n122 class LatexPrinter(Printer):\n123     printmethod = \"_latex\"\n124 \n125     _default_settings = {\n126         \"fold_frac_powers\": False,\n127         \"fold_func_brackets\": False,\n128         \"fold_short_frac\": None,\n129         \"inv_trig_style\": \"abbreviated\",\n130         \"itex\": False,\n131         \"ln_notation\": False,\n132         \"long_frac_ratio\": None,\n133         \"mat_delim\": \"[\",\n134         \"mat_str\": None,\n135         \"mode\": \"plain\",\n136         \"mul_symbol\": None,\n137         \"order\": None,\n138         \"symbol_names\": {},\n139         \"root_notation\": True,\n140         \"mat_symbol_style\": \"plain\",\n141         \"imaginary_unit\": \"i\",\n142         \"gothic_re_im\": False,\n143         \"decimal_separator\": \"period\",\n144     }\n145 \n146     def __init__(self, settings=None):\n147         Printer.__init__(self, settings)\n148 \n149         if 'mode' in self._settings:\n150             valid_modes = ['inline', 'plain', 'equation',\n151                            'equation*']\n152             if self._settings['mode'] not in valid_modes:\n153                 raise ValueError(\"'mode' must be one of 'inline', 'plain', \"\n154                                  \"'equation' or 'equation*'\")\n155 \n156         if self._settings['fold_short_frac'] is None and \\\n157                 self._settings['mode'] == 'inline':\n158             self._settings['fold_short_frac'] = True\n159 \n160         mul_symbol_table = {\n161             None: r\" \",\n162             \"ldot\": r\" \\,.\\, \",\n163             \"dot\": r\" \\cdot \",\n164             \"times\": r\" \\times \"\n165         }\n166         try:\n167             self._settings['mul_symbol_latex'] = \\\n168                 mul_symbol_table[self._settings['mul_symbol']]\n169         except KeyError:\n170             self._settings['mul_symbol_latex'] = \\\n171                 self._settings['mul_symbol']\n172         try:\n173             self._settings['mul_symbol_latex_numbers'] = \\\n174                 mul_symbol_table[self._settings['mul_symbol'] or 'dot']\n175         except KeyError:\n176             if (self._settings['mul_symbol'].strip() in\n177                     ['', ' ', '\\\\', '\\\\,', '\\\\:', '\\\\;', '\\\\quad']):\n178                 self._settings['mul_symbol_latex_numbers'] = \\\n179                     mul_symbol_table['dot']\n180             else:\n181                 self._settings['mul_symbol_latex_numbers'] = \\\n182                     self._settings['mul_symbol']\n183 \n184         self._delim_dict = {'(': ')', '[': ']'}\n185 \n186         imaginary_unit_table = {\n187             None: r\"i\",\n188             \"i\": r\"i\",\n189             \"ri\": r\"\\mathrm{i}\",\n190             \"ti\": r\"\\text{i}\",\n191             \"j\": r\"j\",\n192             \"rj\": r\"\\mathrm{j}\",\n193             \"tj\": r\"\\text{j}\",\n194         }\n195         try:\n196             self._settings['imaginary_unit_latex'] = \\\n197                 imaginary_unit_table[self._settings['imaginary_unit']]\n198         except KeyError:\n199             self._settings['imaginary_unit_latex'] = \\\n200                 self._settings['imaginary_unit']\n201 \n202     def parenthesize(self, item, level, strict=False):\n203         prec_val = precedence_traditional(item)\n204         if (prec_val < level) or ((not strict) and prec_val <= level):\n205             return r\"\\left({}\\right)\".format(self._print(item))\n206         else:\n207             return self._print(item)\n208 \n209     def parenthesize_super(self, s):\n210         \"\"\" Parenthesize s if there is a superscript in s\"\"\"\n211         if \"^\" in s:\n212             return r\"\\left({}\\right)\".format(s)\n213         return s\n214 \n215     def embed_super(self, s):\n216         \"\"\" Embed s in {} if there is a superscript in s\"\"\"\n217         if \"^\" in s:\n218             return \"{{{}}}\".format(s)\n219         return s\n220 \n221     def doprint(self, expr):\n222         tex = Printer.doprint(self, expr)\n223 \n224         if self._settings['mode'] == 'plain':\n225             return tex\n226         elif self._settings['mode'] == 'inline':\n227             return r\"$%s$\" % tex\n228         elif self._settings['itex']:\n229             return r\"$$%s$$\" % tex\n230         else:\n231             env_str = self._settings['mode']\n232             return r\"\\begin{%s}%s\\end{%s}\" % (env_str, tex, env_str)\n233 \n234     def _needs_brackets(self, expr):\n235         \"\"\"\n236         Returns True if the expression needs to be wrapped in brackets when\n237         printed, False otherwise. For example: a + b => True; a => False;\n238         10 => False; -10 => True.\n239         \"\"\"\n240         return not ((expr.is_Integer and expr.is_nonnegative)\n241                     or (expr.is_Atom and (expr is not S.NegativeOne\n242                                           and expr.is_Rational is False)))\n243 \n244     def _needs_function_brackets(self, expr):\n245         \"\"\"\n246         Returns True if the expression needs to be wrapped in brackets when\n247         passed as an argument to a function, False otherwise. This is a more\n248         liberal version of _needs_brackets, in that many expressions which need\n249         to be wrapped in brackets when added/subtracted/raised to a power do\n250         not need them when passed to a function. Such an example is a*b.\n251         \"\"\"\n252         if not self._needs_brackets(expr):\n253             return False\n254         else:\n255             # Muls of the form a*b*c... can be folded\n256             if expr.is_Mul and not self._mul_is_clean(expr):\n257                 return True\n258             # Pows which don't need brackets can be folded\n259             elif expr.is_Pow and not self._pow_is_clean(expr):\n260                 return True\n261             # Add and Function always need brackets\n262             elif expr.is_Add or expr.is_Function:\n263                 return True\n264             else:\n265                 return False\n266 \n267     def _needs_mul_brackets(self, expr, first=False, last=False):\n268         \"\"\"\n269         Returns True if the expression needs to be wrapped in brackets when\n270         printed as part of a Mul, False otherwise. This is True for Add,\n271         but also for some container objects that would not need brackets\n272         when appearing last in a Mul, e.g. an Integral. ``last=True``\n273         specifies that this expr is the last to appear in a Mul.\n274         ``first=True`` specifies that this expr is the first to appear in\n275         a Mul.\n276         \"\"\"\n277         from sympy import Integral, Product, Sum\n278 \n279         if expr.is_Mul:\n280             if not first and _coeff_isneg(expr):\n281                 return True\n282         elif precedence_traditional(expr) < PRECEDENCE[\"Mul\"]:\n283             return True\n284         elif expr.is_Relational:\n285             return True\n286         if expr.is_Piecewise:\n287             return True\n288         if any([expr.has(x) for x in (Mod,)]):\n289             return True\n290         if (not last and\n291                 any([expr.has(x) for x in (Integral, Product, Sum)])):\n292             return True\n293 \n294         return False\n295 \n296     def _needs_add_brackets(self, expr):\n297         \"\"\"\n298         Returns True if the expression needs to be wrapped in brackets when\n299         printed as part of an Add, False otherwise.  This is False for most\n300         things.\n301         \"\"\"\n302         if expr.is_Relational:\n303             return True\n304         if any([expr.has(x) for x in (Mod,)]):\n305             return True\n306         if expr.is_Add:\n307             return True\n308         return False\n309 \n310     def _mul_is_clean(self, expr):\n311         for arg in expr.args:\n312             if arg.is_Function:\n313                 return False\n314         return True\n315 \n316     def _pow_is_clean(self, expr):\n317         return not self._needs_brackets(expr.base)\n318 \n319     def _do_exponent(self, expr, exp):\n320         if exp is not None:\n321             return r\"\\left(%s\\right)^{%s}\" % (expr, exp)\n322         else:\n323             return expr\n324 \n325     def _print_Basic(self, expr):\n326         ls = [self._print(o) for o in expr.args]\n327         return self._deal_with_super_sub(expr.__class__.__name__) + \\\n328             r\"\\left(%s\\right)\" % \", \".join(ls)\n329 \n330     def _print_bool(self, e):\n331         return r\"\\text{%s}\" % e\n332 \n333     _print_BooleanTrue = _print_bool\n334     _print_BooleanFalse = _print_bool\n335 \n336     def _print_NoneType(self, e):\n337         return r\"\\text{%s}\" % e\n338 \n339     def _print_Add(self, expr, order=None):\n340         if self.order == 'none':\n341             terms = list(expr.args)\n342         else:\n343             terms = self._as_ordered_terms(expr, order=order)\n344 \n345         tex = \"\"\n346         for i, term in enumerate(terms):\n347             if i == 0:\n348                 pass\n349             elif _coeff_isneg(term):\n350                 tex += \" - \"\n351                 term = -term\n352             else:\n353                 tex += \" + \"\n354             term_tex = self._print(term)\n355             if self._needs_add_brackets(term):\n356                 term_tex = r\"\\left(%s\\right)\" % term_tex\n357             tex += term_tex\n358 \n359         return tex\n360 \n361     def _print_Cycle(self, expr):\n362         from sympy.combinatorics.permutations import Permutation\n363         if expr.size == 0:\n364             return r\"\\left( \\right)\"\n365         expr = Permutation(expr)\n366         expr_perm = expr.cyclic_form\n367         siz = expr.size\n368         if expr.array_form[-1] == siz - 1:\n369             expr_perm = expr_perm + [[siz - 1]]\n370         term_tex = ''\n371         for i in expr_perm:\n372             term_tex += str(i).replace(',', r\"\\;\")\n373         term_tex = term_tex.replace('[', r\"\\left( \")\n374         term_tex = term_tex.replace(']', r\"\\right)\")\n375         return term_tex\n376 \n377     _print_Permutation = _print_Cycle\n378 \n379     def _print_Float(self, expr):\n380         # Based off of that in StrPrinter\n381         dps = prec_to_dps(expr._prec)\n382         str_real = mlib.to_str(expr._mpf_, dps, strip_zeros=True)\n383 \n384         # Must always have a mul symbol (as 2.5 10^{20} just looks odd)\n385         # thus we use the number separator\n386         separator = self._settings['mul_symbol_latex_numbers']\n387 \n388         if 'e' in str_real:\n389             (mant, exp) = str_real.split('e')\n390 \n391             if exp[0] == '+':\n392                 exp = exp[1:]\n393             if self._settings['decimal_separator'] == 'comma':\n394                 mant = mant.replace('.','{,}')\n395 \n396             return r\"%s%s10^{%s}\" % (mant, separator, exp)\n397         elif str_real == \"+inf\":\n398             return r\"\\infty\"\n399         elif str_real == \"-inf\":\n400             return r\"- \\infty\"\n401         else:\n402             if self._settings['decimal_separator'] == 'comma':\n403                 str_real = str_real.replace('.','{,}')\n404             return str_real\n405 \n406     def _print_Cross(self, expr):\n407         vec1 = expr._expr1\n408         vec2 = expr._expr2\n409         return r\"%s \\times %s\" % (self.parenthesize(vec1, PRECEDENCE['Mul']),\n410                                   self.parenthesize(vec2, PRECEDENCE['Mul']))\n411 \n412     def _print_Curl(self, expr):\n413         vec = expr._expr\n414         return r\"\\nabla\\times %s\" % self.parenthesize(vec, PRECEDENCE['Mul'])\n415 \n416     def _print_Divergence(self, expr):\n417         vec = expr._expr\n418         return r\"\\nabla\\cdot %s\" % self.parenthesize(vec, PRECEDENCE['Mul'])\n419 \n420     def _print_Dot(self, expr):\n421         vec1 = expr._expr1\n422         vec2 = expr._expr2\n423         return r\"%s \\cdot %s\" % (self.parenthesize(vec1, PRECEDENCE['Mul']),\n424                                  self.parenthesize(vec2, PRECEDENCE['Mul']))\n425 \n426     def _print_Gradient(self, expr):\n427         func = expr._expr\n428         return r\"\\nabla %s\" % self.parenthesize(func, PRECEDENCE['Mul'])\n429 \n430     def _print_Laplacian(self, expr):\n431         func = expr._expr\n432         return r\"\\triangle %s\" % self.parenthesize(func, PRECEDENCE['Mul'])\n433 \n434     def _print_Mul(self, expr):\n435         from sympy.core.power import Pow\n436         from sympy.physics.units import Quantity\n437         include_parens = False\n438         if _coeff_isneg(expr):\n439             expr = -expr\n440             tex = \"- \"\n441             if expr.is_Add:\n442                 tex += \"(\"\n443                 include_parens = True\n444         else:\n445             tex = \"\"\n446 \n447         from sympy.simplify import fraction\n448         numer, denom = fraction(expr, exact=True)\n449         separator = self._settings['mul_symbol_latex']\n450         numbersep = self._settings['mul_symbol_latex_numbers']\n451 \n452         def convert(expr):\n453             if not expr.is_Mul:\n454                 return str(self._print(expr))\n455             else:\n456                 _tex = last_term_tex = \"\"\n457 \n458                 if self.order not in ('old', 'none'):\n459                     args = expr.as_ordered_factors()\n460                 else:\n461                     args = list(expr.args)\n462 \n463                 # If quantities are present append them at the back\n464                 args = sorted(args, key=lambda x: isinstance(x, Quantity) or\n465                               (isinstance(x, Pow) and\n466                                isinstance(x.base, Quantity)))\n467 \n468                 for i, term in enumerate(args):\n469                     term_tex = self._print(term)\n470 \n471                     if self._needs_mul_brackets(term, first=(i == 0),\n472                                                 last=(i == len(args) - 1)):\n473                         term_tex = r\"\\left(%s\\right)\" % term_tex\n474 \n475                     if _between_two_numbers_p[0].search(last_term_tex) and \\\n476                             _between_two_numbers_p[1].match(term_tex):\n477                         # between two numbers\n478                         _tex += numbersep\n479                     elif _tex:\n480                         _tex += separator\n481 \n482                     _tex += term_tex\n483                     last_term_tex = term_tex\n484                 return _tex\n485 \n486         if denom is S.One and Pow(1, -1, evaluate=False) not in expr.args:\n487             # use the original expression here, since fraction() may have\n488             # altered it when producing numer and denom\n489             tex += convert(expr)\n490 \n491         else:\n492             snumer = convert(numer)\n493             sdenom = convert(denom)\n494             ldenom = len(sdenom.split())\n495             ratio = self._settings['long_frac_ratio']\n496             if self._settings['fold_short_frac'] and ldenom <= 2 and \\\n497                     \"^\" not in sdenom:\n498                 # handle short fractions\n499                 if self._needs_mul_brackets(numer, last=False):\n500                     tex += r\"\\left(%s\\right) / %s\" % (snumer, sdenom)\n501                 else:\n502                     tex += r\"%s / %s\" % (snumer, sdenom)\n503             elif ratio is not None and \\\n504                     len(snumer.split()) > ratio*ldenom:\n505                 # handle long fractions\n506                 if self._needs_mul_brackets(numer, last=True):\n507                     tex += r\"\\frac{1}{%s}%s\\left(%s\\right)\" \\\n508                         % (sdenom, separator, snumer)\n509                 elif numer.is_Mul:\n510                     # split a long numerator\n511                     a = S.One\n512                     b = S.One\n513                     for x in numer.args:\n514                         if self._needs_mul_brackets(x, last=False) or \\\n515                                 len(convert(a*x).split()) > ratio*ldenom or \\\n516                                 (b.is_commutative is x.is_commutative is False):\n517                             b *= x\n518                         else:\n519                             a *= x\n520                     if self._needs_mul_brackets(b, last=True):\n521                         tex += r\"\\frac{%s}{%s}%s\\left(%s\\right)\" \\\n522                             % (convert(a), sdenom, separator, convert(b))\n523                     else:\n524                         tex += r\"\\frac{%s}{%s}%s%s\" \\\n525                             % (convert(a), sdenom, separator, convert(b))\n526                 else:\n527                     tex += r\"\\frac{1}{%s}%s%s\" % (sdenom, separator, snumer)\n528             else:\n529                 tex += r\"\\frac{%s}{%s}\" % (snumer, sdenom)\n530 \n531         if include_parens:\n532             tex += \")\"\n533         return tex\n534 \n535     def _print_Pow(self, expr):\n536         # Treat x**Rational(1,n) as special case\n537         if expr.exp.is_Rational and abs(expr.exp.p) == 1 and expr.exp.q != 1 \\\n538                 and self._settings['root_notation']:\n539             base = self._print(expr.base)\n540             expq = expr.exp.q\n541 \n542             if expq == 2:\n543                 tex = r\"\\sqrt{%s}\" % base\n544             elif self._settings['itex']:\n545                 tex = r\"\\root{%d}{%s}\" % (expq, base)\n546             else:\n547                 tex = r\"\\sqrt[%d]{%s}\" % (expq, base)\n548 \n549             if expr.exp.is_negative:\n550                 return r\"\\frac{1}{%s}\" % tex\n551             else:\n552                 return tex\n553         elif self._settings['fold_frac_powers'] \\\n554             and expr.exp.is_Rational \\\n555                 and expr.exp.q != 1:\n556             base = self.parenthesize(expr.base, PRECEDENCE['Pow'])\n557             p, q = expr.exp.p, expr.exp.q\n558             # issue #12886: add parentheses for superscripts raised to powers\n559             if '^' in base and expr.base.is_Symbol:\n560                 base = r\"\\left(%s\\right)\" % base\n561             if expr.base.is_Function:\n562                 return self._print(expr.base, exp=\"%s/%s\" % (p, q))\n563             return r\"%s^{%s/%s}\" % (base, p, q)\n564         elif expr.exp.is_Rational and expr.exp.is_negative and \\\n565                 expr.base.is_commutative:\n566             # special case for 1^(-x), issue 9216\n567             if expr.base == 1:\n568                 return r\"%s^{%s}\" % (expr.base, expr.exp)\n569             # things like 1/x\n570             return self._print_Mul(expr)\n571         else:\n572             if expr.base.is_Function:\n573                 return self._print(expr.base, exp=self._print(expr.exp))\n574             else:\n575                 tex = r\"%s^{%s}\"\n576                 return self._helper_print_standard_power(expr, tex)\n577 \n578     def _helper_print_standard_power(self, expr, template):\n579         exp = self._print(expr.exp)\n580         # issue #12886: add parentheses around superscripts raised\n581         # to powers\n582         base = self.parenthesize(expr.base, PRECEDENCE['Pow'])\n583         if '^' in base and expr.base.is_Symbol:\n584             base = r\"\\left(%s\\right)\" % base\n585         elif (isinstance(expr.base, Derivative)\n586             and base.startswith(r'\\left(')\n587             and re.match(r'\\\\left\\(\\\\d?d?dot', base)\n588             and base.endswith(r'\\right)')):\n589             # don't use parentheses around dotted derivative\n590             base = base[6: -7]  # remove outermost added parens\n591         return template % (base, exp)\n592 \n593     def _print_UnevaluatedExpr(self, expr):\n594         return self._print(expr.args[0])\n595 \n596     def _print_Sum(self, expr):\n597         if len(expr.limits) == 1:\n598             tex = r\"\\sum_{%s=%s}^{%s} \" % \\\n599                 tuple([self._print(i) for i in expr.limits[0]])\n600         else:\n601             def _format_ineq(l):\n602                 return r\"%s \\leq %s \\leq %s\" % \\\n603                     tuple([self._print(s) for s in (l[1], l[0], l[2])])\n604 \n605             tex = r\"\\sum_{\\substack{%s}} \" % \\\n606                 str.join('\\\\\\\\', [_format_ineq(l) for l in expr.limits])\n607 \n608         if isinstance(expr.function, Add):\n609             tex += r\"\\left(%s\\right)\" % self._print(expr.function)\n610         else:\n611             tex += self._print(expr.function)\n612 \n613         return tex\n614 \n615     def _print_Product(self, expr):\n616         if len(expr.limits) == 1:\n617             tex = r\"\\prod_{%s=%s}^{%s} \" % \\\n618                 tuple([self._print(i) for i in expr.limits[0]])\n619         else:\n620             def _format_ineq(l):\n621                 return r\"%s \\leq %s \\leq %s\" % \\\n622                     tuple([self._print(s) for s in (l[1], l[0], l[2])])\n623 \n624             tex = r\"\\prod_{\\substack{%s}} \" % \\\n625                 str.join('\\\\\\\\', [_format_ineq(l) for l in expr.limits])\n626 \n627         if isinstance(expr.function, Add):\n628             tex += r\"\\left(%s\\right)\" % self._print(expr.function)\n629         else:\n630             tex += self._print(expr.function)\n631 \n632         return tex\n633 \n634     def _print_BasisDependent(self, expr):\n635         from sympy.vector import Vector\n636 \n637         o1 = []\n638         if expr == expr.zero:\n639             return expr.zero._latex_form\n640         if isinstance(expr, Vector):\n641             items = expr.separate().items()\n642         else:\n643             items = [(0, expr)]\n644 \n645         for system, vect in items:\n646             inneritems = list(vect.components.items())\n647             inneritems.sort(key=lambda x: x[0].__str__())\n648             for k, v in inneritems:\n649                 if v == 1:\n650                     o1.append(' + ' + k._latex_form)\n651                 elif v == -1:\n652                     o1.append(' - ' + k._latex_form)\n653                 else:\n654                     arg_str = '(' + LatexPrinter().doprint(v) + ')'\n655                     o1.append(' + ' + arg_str + k._latex_form)\n656 \n657         outstr = (''.join(o1))\n658         if outstr[1] != '-':\n659             outstr = outstr[3:]\n660         else:\n661             outstr = outstr[1:]\n662         return outstr\n663 \n664     def _print_Indexed(self, expr):\n665         tex_base = self._print(expr.base)\n666         tex = '{'+tex_base+'}'+'_{%s}' % ','.join(\n667             map(self._print, expr.indices))\n668         return tex\n669 \n670     def _print_IndexedBase(self, expr):\n671         return self._print(expr.label)\n672 \n673     def _print_Derivative(self, expr):\n674         if requires_partial(expr.expr):\n675             diff_symbol = r'\\partial'\n676         else:\n677             diff_symbol = r'd'\n678 \n679         tex = \"\"\n680         dim = 0\n681         for x, num in reversed(expr.variable_count):\n682             dim += num\n683             if num == 1:\n684                 tex += r\"%s %s\" % (diff_symbol, self._print(x))\n685             else:\n686                 tex += r\"%s %s^{%s}\" % (diff_symbol,\n687                                         self.parenthesize_super(self._print(x)),\n688                                         self._print(num))\n689 \n690         if dim == 1:\n691             tex = r\"\\frac{%s}{%s}\" % (diff_symbol, tex)\n692         else:\n693             tex = r\"\\frac{%s^{%s}}{%s}\" % (diff_symbol, self._print(dim), tex)\n694 \n695         return r\"%s %s\" % (tex, self.parenthesize(expr.expr,\n696                                                   PRECEDENCE[\"Mul\"],\n697                                                   strict=True))\n698 \n699     def _print_Subs(self, subs):\n700         expr, old, new = subs.args\n701         latex_expr = self._print(expr)\n702         latex_old = (self._print(e) for e in old)\n703         latex_new = (self._print(e) for e in new)\n704         latex_subs = r'\\\\ '.join(\n705             e[0] + '=' + e[1] for e in zip(latex_old, latex_new))\n706         return r'\\left. %s \\right|_{\\substack{ %s }}' % (latex_expr,\n707                                                          latex_subs)\n708 \n709     def _print_Integral(self, expr):\n710         tex, symbols = \"\", []\n711 \n712         # Only up to \\iiiint exists\n713         if len(expr.limits) <= 4 and all(len(lim) == 1 for lim in expr.limits):\n714             # Use len(expr.limits)-1 so that syntax highlighters don't think\n715             # \\\" is an escaped quote\n716             tex = r\"\\i\" + \"i\"*(len(expr.limits) - 1) + \"nt\"\n717             symbols = [r\"\\, d%s\" % self._print(symbol[0])\n718                        for symbol in expr.limits]\n719 \n720         else:\n721             for lim in reversed(expr.limits):\n722                 symbol = lim[0]\n723                 tex += r\"\\int\"\n724 \n725                 if len(lim) > 1:\n726                     if self._settings['mode'] != 'inline' \\\n727                             and not self._settings['itex']:\n728                         tex += r\"\\limits\"\n729 \n730                     if len(lim) == 3:\n731                         tex += \"_{%s}^{%s}\" % (self._print(lim[1]),\n732                                                self._print(lim[2]))\n733                     if len(lim) == 2:\n734                         tex += \"^{%s}\" % (self._print(lim[1]))\n735 \n736                 symbols.insert(0, r\"\\, d%s\" % self._print(symbol))\n737 \n738         return r\"%s %s%s\" % (tex, self.parenthesize(expr.function,\n739                                                     PRECEDENCE[\"Mul\"],\n740                                                     strict=True),\n741                              \"\".join(symbols))\n742 \n743     def _print_Limit(self, expr):\n744         e, z, z0, dir = expr.args\n745 \n746         tex = r\"\\lim_{%s \\to \" % self._print(z)\n747         if str(dir) == '+-' or z0 in (S.Infinity, S.NegativeInfinity):\n748             tex += r\"%s}\" % self._print(z0)\n749         else:\n750             tex += r\"%s^%s}\" % (self._print(z0), self._print(dir))\n751 \n752         if isinstance(e, AssocOp):\n753             return r\"%s\\left(%s\\right)\" % (tex, self._print(e))\n754         else:\n755             return r\"%s %s\" % (tex, self._print(e))\n756 \n757     def _hprint_Function(self, func):\n758         r'''\n759         Logic to decide how to render a function to latex\n760           - if it is a recognized latex name, use the appropriate latex command\n761           - if it is a single letter, just use that letter\n762           - if it is a longer name, then put \\operatorname{} around it and be\n763             mindful of undercores in the name\n764         '''\n765         func = self._deal_with_super_sub(func)\n766         if func in accepted_latex_functions:\n767             name = r\"\\%s\" % func\n768         elif len(func) == 1 or func.startswith('\\\\'):\n769             name = func\n770         else:\n771             name = r\"\\operatorname{%s}\" % func\n772         return name\n773 \n774     def _print_Function(self, expr, exp=None):\n775         r'''\n776         Render functions to LaTeX, handling functions that LaTeX knows about\n777         e.g., sin, cos, ... by using the proper LaTeX command (\\sin, \\cos, ...).\n778         For single-letter function names, render them as regular LaTeX math\n779         symbols. For multi-letter function names that LaTeX does not know\n780         about, (e.g., Li, sech) use \\operatorname{} so that the function name\n781         is rendered in Roman font and LaTeX handles spacing properly.\n782 \n783         expr is the expression involving the function\n784         exp is an exponent\n785         '''\n786         func = expr.func.__name__\n787         if hasattr(self, '_print_' + func) and \\\n788                 not isinstance(expr, AppliedUndef):\n789             return getattr(self, '_print_' + func)(expr, exp)\n790         else:\n791             args = [str(self._print(arg)) for arg in expr.args]\n792             # How inverse trig functions should be displayed, formats are:\n793             # abbreviated: asin, full: arcsin, power: sin^-1\n794             inv_trig_style = self._settings['inv_trig_style']\n795             # If we are dealing with a power-style inverse trig function\n796             inv_trig_power_case = False\n797             # If it is applicable to fold the argument brackets\n798             can_fold_brackets = self._settings['fold_func_brackets'] and \\\n799                 len(args) == 1 and \\\n800                 not self._needs_function_brackets(expr.args[0])\n801 \n802             inv_trig_table = [\"asin\", \"acos\", \"atan\", \"acsc\", \"asec\", \"acot\"]\n803 \n804             # If the function is an inverse trig function, handle the style\n805             if func in inv_trig_table:\n806                 if inv_trig_style == \"abbreviated\":\n807                     pass\n808                 elif inv_trig_style == \"full\":\n809                     func = \"arc\" + func[1:]\n810                 elif inv_trig_style == \"power\":\n811                     func = func[1:]\n812                     inv_trig_power_case = True\n813 \n814                     # Can never fold brackets if we're raised to a power\n815                     if exp is not None:\n816                         can_fold_brackets = False\n817 \n818             if inv_trig_power_case:\n819                 if func in accepted_latex_functions:\n820                     name = r\"\\%s^{-1}\" % func\n821                 else:\n822                     name = r\"\\operatorname{%s}^{-1}\" % func\n823             elif exp is not None:\n824                 name = r'%s^{%s}' % (self._hprint_Function(func), exp)\n825             else:\n826                 name = self._hprint_Function(func)\n827 \n828             if can_fold_brackets:\n829                 if func in accepted_latex_functions:\n830                     # Wrap argument safely to avoid parse-time conflicts\n831                     # with the function name itself\n832                     name += r\" {%s}\"\n833                 else:\n834                     name += r\"%s\"\n835             else:\n836                 name += r\"{\\left(%s \\right)}\"\n837 \n838             if inv_trig_power_case and exp is not None:\n839                 name += r\"^{%s}\" % exp\n840 \n841             return name % \",\".join(args)\n842 \n843     def _print_UndefinedFunction(self, expr):\n844         return self._hprint_Function(str(expr))\n845 \n846     def _print_ElementwiseApplyFunction(self, expr):\n847         return r\"{%s}_{\\circ}\\left({%s}\\right)\" % (\n848             self._print(expr.function),\n849             self._print(expr.expr),\n850         )\n851 \n852     @property\n853     def _special_function_classes(self):\n854         from sympy.functions.special.tensor_functions import KroneckerDelta\n855         from sympy.functions.special.gamma_functions import gamma, lowergamma\n856         from sympy.functions.special.beta_functions import beta\n857         from sympy.functions.special.delta_functions import DiracDelta\n858         from sympy.functions.special.error_functions import Chi\n859         return {KroneckerDelta: r'\\delta',\n860                 gamma:  r'\\Gamma',\n861                 lowergamma: r'\\gamma',\n862                 beta: r'\\operatorname{B}',\n863                 DiracDelta: r'\\delta',\n864                 Chi: r'\\operatorname{Chi}'}\n865 \n866     def _print_FunctionClass(self, expr):\n867         for cls in self._special_function_classes:\n868             if issubclass(expr, cls) and expr.__name__ == cls.__name__:\n869                 return self._special_function_classes[cls]\n870         return self._hprint_Function(str(expr))\n871 \n872     def _print_Lambda(self, expr):\n873         symbols, expr = expr.args\n874 \n875         if len(symbols) == 1:\n876             symbols = self._print(symbols[0])\n877         else:\n878             symbols = self._print(tuple(symbols))\n879 \n880         tex = r\"\\left( %s \\mapsto %s \\right)\" % (symbols, self._print(expr))\n881 \n882         return tex\n883 \n884     def _hprint_variadic_function(self, expr, exp=None):\n885         args = sorted(expr.args, key=default_sort_key)\n886         texargs = [r\"%s\" % self._print(symbol) for symbol in args]\n887         tex = r\"\\%s\\left(%s\\right)\" % (self._print((str(expr.func)).lower()),\n888                                        \", \".join(texargs))\n889         if exp is not None:\n890             return r\"%s^{%s}\" % (tex, exp)\n891         else:\n892             return tex\n893 \n894     _print_Min = _print_Max = _hprint_variadic_function\n895 \n896     def _print_floor(self, expr, exp=None):\n897         tex = r\"\\left\\lfloor{%s}\\right\\rfloor\" % self._print(expr.args[0])\n898 \n899         if exp is not None:\n900             return r\"%s^{%s}\" % (tex, exp)\n901         else:\n902             return tex\n903 \n904     def _print_ceiling(self, expr, exp=None):\n905         tex = r\"\\left\\lceil{%s}\\right\\rceil\" % self._print(expr.args[0])\n906 \n907         if exp is not None:\n908             return r\"%s^{%s}\" % (tex, exp)\n909         else:\n910             return tex\n911 \n912     def _print_log(self, expr, exp=None):\n913         if not self._settings[\"ln_notation\"]:\n914             tex = r\"\\log{\\left(%s \\right)}\" % self._print(expr.args[0])\n915         else:\n916             tex = r\"\\ln{\\left(%s \\right)}\" % self._print(expr.args[0])\n917 \n918         if exp is not None:\n919             return r\"%s^{%s}\" % (tex, exp)\n920         else:\n921             return tex\n922 \n923     def _print_Abs(self, expr, exp=None):\n924         tex = r\"\\left|{%s}\\right|\" % self._print(expr.args[0])\n925 \n926         if exp is not None:\n927             return r\"%s^{%s}\" % (tex, exp)\n928         else:\n929             return tex\n930     _print_Determinant = _print_Abs\n931 \n932     def _print_re(self, expr, exp=None):\n933         if self._settings['gothic_re_im']:\n934             tex = r\"\\Re{%s}\" % self.parenthesize(expr.args[0], PRECEDENCE['Atom'])\n935         else:\n936             tex = r\"\\operatorname{{re}}{{{}}}\".format(self.parenthesize(expr.args[0], PRECEDENCE['Atom']))\n937 \n938         return self._do_exponent(tex, exp)\n939 \n940     def _print_im(self, expr, exp=None):\n941         if self._settings['gothic_re_im']:\n942             tex = r\"\\Im{%s}\" % self.parenthesize(expr.args[0], PRECEDENCE['Atom'])\n943         else:\n944             tex = r\"\\operatorname{{im}}{{{}}}\".format(self.parenthesize(expr.args[0], PRECEDENCE['Atom']))\n945 \n946         return self._do_exponent(tex, exp)\n947 \n948     def _print_Not(self, e):\n949         from sympy import Equivalent, Implies\n950         if isinstance(e.args[0], Equivalent):\n951             return self._print_Equivalent(e.args[0], r\"\\not\\Leftrightarrow\")\n952         if isinstance(e.args[0], Implies):\n953             return self._print_Implies(e.args[0], r\"\\not\\Rightarrow\")\n954         if (e.args[0].is_Boolean):\n955             return r\"\\neg \\left(%s\\right)\" % self._print(e.args[0])\n956         else:\n957             return r\"\\neg %s\" % self._print(e.args[0])\n958 \n959     def _print_LogOp(self, args, char):\n960         arg = args[0]\n961         if arg.is_Boolean and not arg.is_Not:\n962             tex = r\"\\left(%s\\right)\" % self._print(arg)\n963         else:\n964             tex = r\"%s\" % self._print(arg)\n965 \n966         for arg in args[1:]:\n967             if arg.is_Boolean and not arg.is_Not:\n968                 tex += r\" %s \\left(%s\\right)\" % (char, self._print(arg))\n969             else:\n970                 tex += r\" %s %s\" % (char, self._print(arg))\n971 \n972         return tex\n973 \n974     def _print_And(self, e):\n975         args = sorted(e.args, key=default_sort_key)\n976         return self._print_LogOp(args, r\"\\wedge\")\n977 \n978     def _print_Or(self, e):\n979         args = sorted(e.args, key=default_sort_key)\n980         return self._print_LogOp(args, r\"\\vee\")\n981 \n982     def _print_Xor(self, e):\n983         args = sorted(e.args, key=default_sort_key)\n984         return self._print_LogOp(args, r\"\\veebar\")\n985 \n986     def _print_Implies(self, e, altchar=None):\n987         return self._print_LogOp(e.args, altchar or r\"\\Rightarrow\")\n988 \n989     def _print_Equivalent(self, e, altchar=None):\n990         args = sorted(e.args, key=default_sort_key)\n991         return self._print_LogOp(args, altchar or r\"\\Leftrightarrow\")\n992 \n993     def _print_conjugate(self, expr, exp=None):\n994         tex = r\"\\overline{%s}\" % self._print(expr.args[0])\n995 \n996         if exp is not None:\n997             return r\"%s^{%s}\" % (tex, exp)\n998         else:\n999             return tex\n1000 \n1001     def _print_polar_lift(self, expr, exp=None):\n1002         func = r\"\\operatorname{polar\\_lift}\"\n1003         arg = r\"{\\left(%s \\right)}\" % self._print(expr.args[0])\n1004 \n1005         if exp is not None:\n1006             return r\"%s^{%s}%s\" % (func, exp, arg)\n1007         else:\n1008             return r\"%s%s\" % (func, arg)\n1009 \n1010     def _print_ExpBase(self, expr, exp=None):\n1011         # TODO should exp_polar be printed differently?\n1012         #      what about exp_polar(0), exp_polar(1)?\n1013         tex = r\"e^{%s}\" % self._print(expr.args[0])\n1014         return self._do_exponent(tex, exp)\n1015 \n1016     def _print_elliptic_k(self, expr, exp=None):\n1017         tex = r\"\\left(%s\\right)\" % self._print(expr.args[0])\n1018         if exp is not None:\n1019             return r\"K^{%s}%s\" % (exp, tex)\n1020         else:\n1021             return r\"K%s\" % tex\n1022 \n1023     def _print_elliptic_f(self, expr, exp=None):\n1024         tex = r\"\\left(%s\\middle| %s\\right)\" % \\\n1025             (self._print(expr.args[0]), self._print(expr.args[1]))\n1026         if exp is not None:\n1027             return r\"F^{%s}%s\" % (exp, tex)\n1028         else:\n1029             return r\"F%s\" % tex\n1030 \n1031     def _print_elliptic_e(self, expr, exp=None):\n1032         if len(expr.args) == 2:\n1033             tex = r\"\\left(%s\\middle| %s\\right)\" % \\\n1034                 (self._print(expr.args[0]), self._print(expr.args[1]))\n1035         else:\n1036             tex = r\"\\left(%s\\right)\" % self._print(expr.args[0])\n1037         if exp is not None:\n1038             return r\"E^{%s}%s\" % (exp, tex)\n1039         else:\n1040             return r\"E%s\" % tex\n1041 \n1042     def _print_elliptic_pi(self, expr, exp=None):\n1043         if len(expr.args) == 3:\n1044             tex = r\"\\left(%s; %s\\middle| %s\\right)\" % \\\n1045                 (self._print(expr.args[0]), self._print(expr.args[1]),\n1046                  self._print(expr.args[2]))\n1047         else:\n1048             tex = r\"\\left(%s\\middle| %s\\right)\" % \\\n1049                 (self._print(expr.args[0]), self._print(expr.args[1]))\n1050         if exp is not None:\n1051             return r\"\\Pi^{%s}%s\" % (exp, tex)\n1052         else:\n1053             return r\"\\Pi%s\" % tex\n1054 \n1055     def _print_beta(self, expr, exp=None):\n1056         tex = r\"\\left(%s, %s\\right)\" % (self._print(expr.args[0]),\n1057                                         self._print(expr.args[1]))\n1058 \n1059         if exp is not None:\n1060             return r\"\\operatorname{B}^{%s}%s\" % (exp, tex)\n1061         else:\n1062             return r\"\\operatorname{B}%s\" % tex\n1063 \n1064     def _print_uppergamma(self, expr, exp=None):\n1065         tex = r\"\\left(%s, %s\\right)\" % (self._print(expr.args[0]),\n1066                                         self._print(expr.args[1]))\n1067 \n1068         if exp is not None:\n1069             return r\"\\Gamma^{%s}%s\" % (exp, tex)\n1070         else:\n1071             return r\"\\Gamma%s\" % tex\n1072 \n1073     def _print_lowergamma(self, expr, exp=None):\n1074         tex = r\"\\left(%s, %s\\right)\" % (self._print(expr.args[0]),\n1075                                         self._print(expr.args[1]))\n1076 \n1077         if exp is not None:\n1078             return r\"\\gamma^{%s}%s\" % (exp, tex)\n1079         else:\n1080             return r\"\\gamma%s\" % tex\n1081 \n1082     def _hprint_one_arg_func(self, expr, exp=None):\n1083         tex = r\"\\left(%s\\right)\" % self._print(expr.args[0])\n1084 \n1085         if exp is not None:\n1086             return r\"%s^{%s}%s\" % (self._print(expr.func), exp, tex)\n1087         else:\n1088             return r\"%s%s\" % (self._print(expr.func), tex)\n1089 \n1090     _print_gamma = _hprint_one_arg_func\n1091 \n1092     def _print_Chi(self, expr, exp=None):\n1093         tex = r\"\\left(%s\\right)\" % self._print(expr.args[0])\n1094 \n1095         if exp is not None:\n1096             return r\"\\operatorname{Chi}^{%s}%s\" % (exp, tex)\n1097         else:\n1098             return r\"\\operatorname{Chi}%s\" % tex\n1099 \n1100     def _print_expint(self, expr, exp=None):\n1101         tex = r\"\\left(%s\\right)\" % self._print(expr.args[1])\n1102         nu = self._print(expr.args[0])\n1103 \n1104         if exp is not None:\n1105             return r\"\\operatorname{E}_{%s}^{%s}%s\" % (nu, exp, tex)\n1106         else:\n1107             return r\"\\operatorname{E}_{%s}%s\" % (nu, tex)\n1108 \n1109     def _print_fresnels(self, expr, exp=None):\n1110         tex = r\"\\left(%s\\right)\" % self._print(expr.args[0])\n1111 \n1112         if exp is not None:\n1113             return r\"S^{%s}%s\" % (exp, tex)\n1114         else:\n1115             return r\"S%s\" % tex\n1116 \n1117     def _print_fresnelc(self, expr, exp=None):\n1118         tex = r\"\\left(%s\\right)\" % self._print(expr.args[0])\n1119 \n1120         if exp is not None:\n1121             return r\"C^{%s}%s\" % (exp, tex)\n1122         else:\n1123             return r\"C%s\" % tex\n1124 \n1125     def _print_subfactorial(self, expr, exp=None):\n1126         tex = r\"!%s\" % self.parenthesize(expr.args[0], PRECEDENCE[\"Func\"])\n1127 \n1128         if exp is not None:\n1129             return r\"\\left(%s\\right)^{%s}\" % (tex, exp)\n1130         else:\n1131             return tex\n1132 \n1133     def _print_factorial(self, expr, exp=None):\n1134         tex = r\"%s!\" % self.parenthesize(expr.args[0], PRECEDENCE[\"Func\"])\n1135 \n1136         if exp is not None:\n1137             return r\"%s^{%s}\" % (tex, exp)\n1138         else:\n1139             return tex\n1140 \n1141     def _print_factorial2(self, expr, exp=None):\n1142         tex = r\"%s!!\" % self.parenthesize(expr.args[0], PRECEDENCE[\"Func\"])\n1143 \n1144         if exp is not None:\n1145             return r\"%s^{%s}\" % (tex, exp)\n1146         else:\n1147             return tex\n1148 \n1149     def _print_binomial(self, expr, exp=None):\n1150         tex = r\"{\\binom{%s}{%s}}\" % (self._print(expr.args[0]),\n1151                                      self._print(expr.args[1]))\n1152 \n1153         if exp is not None:\n1154             return r\"%s^{%s}\" % (tex, exp)\n1155         else:\n1156             return tex\n1157 \n1158     def _print_RisingFactorial(self, expr, exp=None):\n1159         n, k = expr.args\n1160         base = r\"%s\" % self.parenthesize(n, PRECEDENCE['Func'])\n1161 \n1162         tex = r\"{%s}^{\\left(%s\\right)}\" % (base, self._print(k))\n1163 \n1164         return self._do_exponent(tex, exp)\n1165 \n1166     def _print_FallingFactorial(self, expr, exp=None):\n1167         n, k = expr.args\n1168         sub = r\"%s\" % self.parenthesize(k, PRECEDENCE['Func'])\n1169 \n1170         tex = r\"{\\left(%s\\right)}_{%s}\" % (self._print(n), sub)\n1171 \n1172         return self._do_exponent(tex, exp)\n1173 \n1174     def _hprint_BesselBase(self, expr, exp, sym):\n1175         tex = r\"%s\" % (sym)\n1176 \n1177         need_exp = False\n1178         if exp is not None:\n1179             if tex.find('^') == -1:\n1180                 tex = r\"%s^{%s}\" % (tex, self._print(exp))\n1181             else:\n1182                 need_exp = True\n1183 \n1184         tex = r\"%s_{%s}\\left(%s\\right)\" % (tex, self._print(expr.order),\n1185                                            self._print(expr.argument))\n1186 \n1187         if need_exp:\n1188             tex = self._do_exponent(tex, exp)\n1189         return tex\n1190 \n1191     def _hprint_vec(self, vec):\n1192         if not vec:\n1193             return \"\"\n1194         s = \"\"\n1195         for i in vec[:-1]:\n1196             s += \"%s, \" % self._print(i)\n1197         s += self._print(vec[-1])\n1198         return s\n1199 \n1200     def _print_besselj(self, expr, exp=None):\n1201         return self._hprint_BesselBase(expr, exp, 'J')\n1202 \n1203     def _print_besseli(self, expr, exp=None):\n1204         return self._hprint_BesselBase(expr, exp, 'I')\n1205 \n1206     def _print_besselk(self, expr, exp=None):\n1207         return self._hprint_BesselBase(expr, exp, 'K')\n1208 \n1209     def _print_bessely(self, expr, exp=None):\n1210         return self._hprint_BesselBase(expr, exp, 'Y')\n1211 \n1212     def _print_yn(self, expr, exp=None):\n1213         return self._hprint_BesselBase(expr, exp, 'y')\n1214 \n1215     def _print_jn(self, expr, exp=None):\n1216         return self._hprint_BesselBase(expr, exp, 'j')\n1217 \n1218     def _print_hankel1(self, expr, exp=None):\n1219         return self._hprint_BesselBase(expr, exp, 'H^{(1)}')\n1220 \n1221     def _print_hankel2(self, expr, exp=None):\n1222         return self._hprint_BesselBase(expr, exp, 'H^{(2)}')\n1223 \n1224     def _print_hn1(self, expr, exp=None):\n1225         return self._hprint_BesselBase(expr, exp, 'h^{(1)}')\n1226 \n1227     def _print_hn2(self, expr, exp=None):\n1228         return self._hprint_BesselBase(expr, exp, 'h^{(2)}')\n1229 \n1230     def _hprint_airy(self, expr, exp=None, notation=\"\"):\n1231         tex = r\"\\left(%s\\right)\" % self._print(expr.args[0])\n1232 \n1233         if exp is not None:\n1234             return r\"%s^{%s}%s\" % (notation, exp, tex)\n1235         else:\n1236             return r\"%s%s\" % (notation, tex)\n1237 \n1238     def _hprint_airy_prime(self, expr, exp=None, notation=\"\"):\n1239         tex = r\"\\left(%s\\right)\" % self._print(expr.args[0])\n1240 \n1241         if exp is not None:\n1242             return r\"{%s^\\prime}^{%s}%s\" % (notation, exp, tex)\n1243         else:\n1244             return r\"%s^\\prime%s\" % (notation, tex)\n1245 \n1246     def _print_airyai(self, expr, exp=None):\n1247         return self._hprint_airy(expr, exp, 'Ai')\n1248 \n1249     def _print_airybi(self, expr, exp=None):\n1250         return self._hprint_airy(expr, exp, 'Bi')\n1251 \n1252     def _print_airyaiprime(self, expr, exp=None):\n1253         return self._hprint_airy_prime(expr, exp, 'Ai')\n1254 \n1255     def _print_airybiprime(self, expr, exp=None):\n1256         return self._hprint_airy_prime(expr, exp, 'Bi')\n1257 \n1258     def _print_hyper(self, expr, exp=None):\n1259         tex = r\"{{}_{%s}F_{%s}\\left(\\begin{matrix} %s \\\\ %s \\end{matrix}\" \\\n1260               r\"\\middle| {%s} \\right)}\" % \\\n1261             (self._print(len(expr.ap)), self._print(len(expr.bq)),\n1262               self._hprint_vec(expr.ap), self._hprint_vec(expr.bq),\n1263               self._print(expr.argument))\n1264 \n1265         if exp is not None:\n1266             tex = r\"{%s}^{%s}\" % (tex, self._print(exp))\n1267         return tex\n1268 \n1269     def _print_meijerg(self, expr, exp=None):\n1270         tex = r\"{G_{%s, %s}^{%s, %s}\\left(\\begin{matrix} %s & %s \\\\\" \\\n1271               r\"%s & %s \\end{matrix} \\middle| {%s} \\right)}\" % \\\n1272             (self._print(len(expr.ap)), self._print(len(expr.bq)),\n1273               self._print(len(expr.bm)), self._print(len(expr.an)),\n1274               self._hprint_vec(expr.an), self._hprint_vec(expr.aother),\n1275               self._hprint_vec(expr.bm), self._hprint_vec(expr.bother),\n1276               self._print(expr.argument))\n1277 \n1278         if exp is not None:\n1279             tex = r\"{%s}^{%s}\" % (tex, self._print(exp))\n1280         return tex\n1281 \n1282     def _print_dirichlet_eta(self, expr, exp=None):\n1283         tex = r\"\\left(%s\\right)\" % self._print(expr.args[0])\n1284         if exp is not None:\n1285             return r\"\\eta^{%s}%s\" % (self._print(exp), tex)\n1286         return r\"\\eta%s\" % tex\n1287 \n1288     def _print_zeta(self, expr, exp=None):\n1289         if len(expr.args) == 2:\n1290             tex = r\"\\left(%s, %s\\right)\" % tuple(map(self._print, expr.args))\n1291         else:\n1292             tex = r\"\\left(%s\\right)\" % self._print(expr.args[0])\n1293         if exp is not None:\n1294             return r\"\\zeta^{%s}%s\" % (self._print(exp), tex)\n1295         return r\"\\zeta%s\" % tex\n1296 \n1297     def _print_stieltjes(self, expr, exp=None):\n1298         if len(expr.args) == 2:\n1299             tex = r\"_{%s}\\left(%s\\right)\" % tuple(map(self._print, expr.args))\n1300         else:\n1301             tex = r\"_{%s}\" % self._print(expr.args[0])\n1302         if exp is not None:\n1303             return r\"\\gamma%s^{%s}\" % (tex, self._print(exp))\n1304         return r\"\\gamma%s\" % tex\n1305 \n1306     def _print_lerchphi(self, expr, exp=None):\n1307         tex = r\"\\left(%s, %s, %s\\right)\" % tuple(map(self._print, expr.args))\n1308         if exp is None:\n1309             return r\"\\Phi%s\" % tex\n1310         return r\"\\Phi^{%s}%s\" % (self._print(exp), tex)\n1311 \n1312     def _print_polylog(self, expr, exp=None):\n1313         s, z = map(self._print, expr.args)\n1314         tex = r\"\\left(%s\\right)\" % z\n1315         if exp is None:\n1316             return r\"\\operatorname{Li}_{%s}%s\" % (s, tex)\n1317         return r\"\\operatorname{Li}_{%s}^{%s}%s\" % (s, self._print(exp), tex)\n1318 \n1319     def _print_jacobi(self, expr, exp=None):\n1320         n, a, b, x = map(self._print, expr.args)\n1321         tex = r\"P_{%s}^{\\left(%s,%s\\right)}\\left(%s\\right)\" % (n, a, b, x)\n1322         if exp is not None:\n1323             tex = r\"\\left(\" + tex + r\"\\right)^{%s}\" % (self._print(exp))\n1324         return tex\n1325 \n1326     def _print_gegenbauer(self, expr, exp=None):\n1327         n, a, x = map(self._print, expr.args)\n1328         tex = r\"C_{%s}^{\\left(%s\\right)}\\left(%s\\right)\" % (n, a, x)\n1329         if exp is not None:\n1330             tex = r\"\\left(\" + tex + r\"\\right)^{%s}\" % (self._print(exp))\n1331         return tex\n1332 \n1333     def _print_chebyshevt(self, expr, exp=None):\n1334         n, x = map(self._print, expr.args)\n1335         tex = r\"T_{%s}\\left(%s\\right)\" % (n, x)\n1336         if exp is not None:\n1337             tex = r\"\\left(\" + tex + r\"\\right)^{%s}\" % (self._print(exp))\n1338         return tex\n1339 \n1340     def _print_chebyshevu(self, expr, exp=None):\n1341         n, x = map(self._print, expr.args)\n1342         tex = r\"U_{%s}\\left(%s\\right)\" % (n, x)\n1343         if exp is not None:\n1344             tex = r\"\\left(\" + tex + r\"\\right)^{%s}\" % (self._print(exp))\n1345         return tex\n1346 \n1347     def _print_legendre(self, expr, exp=None):\n1348         n, x = map(self._print, expr.args)\n1349         tex = r\"P_{%s}\\left(%s\\right)\" % (n, x)\n1350         if exp is not None:\n1351             tex = r\"\\left(\" + tex + r\"\\right)^{%s}\" % (self._print(exp))\n1352         return tex\n1353 \n1354     def _print_assoc_legendre(self, expr, exp=None):\n1355         n, a, x = map(self._print, expr.args)\n1356         tex = r\"P_{%s}^{\\left(%s\\right)}\\left(%s\\right)\" % (n, a, x)\n1357         if exp is not None:\n1358             tex = r\"\\left(\" + tex + r\"\\right)^{%s}\" % (self._print(exp))\n1359         return tex\n1360 \n1361     def _print_hermite(self, expr, exp=None):\n1362         n, x = map(self._print, expr.args)\n1363         tex = r\"H_{%s}\\left(%s\\right)\" % (n, x)\n1364         if exp is not None:\n1365             tex = r\"\\left(\" + tex + r\"\\right)^{%s}\" % (self._print(exp))\n1366         return tex\n1367 \n1368     def _print_laguerre(self, expr, exp=None):\n1369         n, x = map(self._print, expr.args)\n1370         tex = r\"L_{%s}\\left(%s\\right)\" % (n, x)\n1371         if exp is not None:\n1372             tex = r\"\\left(\" + tex + r\"\\right)^{%s}\" % (self._print(exp))\n1373         return tex\n1374 \n1375     def _print_assoc_laguerre(self, expr, exp=None):\n1376         n, a, x = map(self._print, expr.args)\n1377         tex = r\"L_{%s}^{\\left(%s\\right)}\\left(%s\\right)\" % (n, a, x)\n1378         if exp is not None:\n1379             tex = r\"\\left(\" + tex + r\"\\right)^{%s}\" % (self._print(exp))\n1380         return tex\n1381 \n1382     def _print_Ynm(self, expr, exp=None):\n1383         n, m, theta, phi = map(self._print, expr.args)\n1384         tex = r\"Y_{%s}^{%s}\\left(%s,%s\\right)\" % (n, m, theta, phi)\n1385         if exp is not None:\n1386             tex = r\"\\left(\" + tex + r\"\\right)^{%s}\" % (self._print(exp))\n1387         return tex\n1388 \n1389     def _print_Znm(self, expr, exp=None):\n1390         n, m, theta, phi = map(self._print, expr.args)\n1391         tex = r\"Z_{%s}^{%s}\\left(%s,%s\\right)\" % (n, m, theta, phi)\n1392         if exp is not None:\n1393             tex = r\"\\left(\" + tex + r\"\\right)^{%s}\" % (self._print(exp))\n1394         return tex\n1395 \n1396     def __print_mathieu_functions(self, character, args, prime=False, exp=None):\n1397         a, q, z = map(self._print, args)\n1398         sup = r\"^{\\prime}\" if prime else \"\"\n1399         exp = \"\" if not exp else \"^{%s}\" % self._print(exp)\n1400         return r\"%s%s\\left(%s, %s, %s\\right)%s\" % (character, sup, a, q, z, exp)\n1401 \n1402     def _print_mathieuc(self, expr, exp=None):\n1403         return self.__print_mathieu_functions(\"C\", expr.args, exp=exp)\n1404 \n1405     def _print_mathieus(self, expr, exp=None):\n1406         return self.__print_mathieu_functions(\"S\", expr.args, exp=exp)\n1407 \n1408     def _print_mathieucprime(self, expr, exp=None):\n1409         return self.__print_mathieu_functions(\"C\", expr.args, prime=True, exp=exp)\n1410 \n1411     def _print_mathieusprime(self, expr, exp=None):\n1412         return self.__print_mathieu_functions(\"S\", expr.args, prime=True, exp=exp)\n1413 \n1414     def _print_Rational(self, expr):\n1415         if expr.q != 1:\n1416             sign = \"\"\n1417             p = expr.p\n1418             if expr.p < 0:\n1419                 sign = \"- \"\n1420                 p = -p\n1421             if self._settings['fold_short_frac']:\n1422                 return r\"%s%d / %d\" % (sign, p, expr.q)\n1423             return r\"%s\\frac{%d}{%d}\" % (sign, p, expr.q)\n1424         else:\n1425             return self._print(expr.p)\n1426 \n1427     def _print_Order(self, expr):\n1428         s = self._print(expr.expr)\n1429         if expr.point and any(p != S.Zero for p in expr.point) or \\\n1430            len(expr.variables) > 1:\n1431             s += '; '\n1432             if len(expr.variables) > 1:\n1433                 s += self._print(expr.variables)\n1434             elif expr.variables:\n1435                 s += self._print(expr.variables[0])\n1436             s += r'\\rightarrow '\n1437             if len(expr.point) > 1:\n1438                 s += self._print(expr.point)\n1439             else:\n1440                 s += self._print(expr.point[0])\n1441         return r\"O\\left(%s\\right)\" % s\n1442 \n1443     def _print_Symbol(self, expr, style='plain'):\n1444         if expr in self._settings['symbol_names']:\n1445             return self._settings['symbol_names'][expr]\n1446 \n1447         result = self._deal_with_super_sub(expr.name) if \\\n1448             '\\\\' not in expr.name else expr.name\n1449 \n1450         if style == 'bold':\n1451             result = r\"\\mathbf{{{}}}\".format(result)\n1452 \n1453         return result\n1454 \n1455     _print_RandomSymbol = _print_Symbol\n1456 \n1457     def _deal_with_super_sub(self, string):\n1458         if '{' in string:\n1459             return string\n1460 \n1461         name, supers, subs = split_super_sub(string)\n1462 \n1463         name = translate(name)\n1464         supers = [translate(sup) for sup in supers]\n1465         subs = [translate(sub) for sub in subs]\n1466 \n1467         # glue all items together:\n1468         if supers:\n1469             name += \"^{%s}\" % \" \".join(supers)\n1470         if subs:\n1471             name += \"_{%s}\" % \" \".join(subs)\n1472 \n1473         return name\n1474 \n1475     def _print_Relational(self, expr):\n1476         if self._settings['itex']:\n1477             gt = r\"\\gt\"\n1478             lt = r\"\\lt\"\n1479         else:\n1480             gt = \">\"\n1481             lt = \"<\"\n1482 \n1483         charmap = {\n1484             \"==\": \"=\",\n1485             \">\": gt,\n1486             \"<\": lt,\n1487             \">=\": r\"\\geq\",\n1488             \"<=\": r\"\\leq\",\n1489             \"!=\": r\"\\neq\",\n1490         }\n1491 \n1492         return \"%s %s %s\" % (self._print(expr.lhs),\n1493                              charmap[expr.rel_op], self._print(expr.rhs))\n1494 \n1495     def _print_Piecewise(self, expr):\n1496         ecpairs = [r\"%s & \\text{for}\\: %s\" % (self._print(e), self._print(c))\n1497                    for e, c in expr.args[:-1]]\n1498         if expr.args[-1].cond == true:\n1499             ecpairs.append(r\"%s & \\text{otherwise}\" %\n1500                            self._print(expr.args[-1].expr))\n1501         else:\n1502             ecpairs.append(r\"%s & \\text{for}\\: %s\" %\n1503                            (self._print(expr.args[-1].expr),\n1504                             self._print(expr.args[-1].cond)))\n1505         tex = r\"\\begin{cases} %s \\end{cases}\"\n1506         return tex % r\" \\\\\".join(ecpairs)\n1507 \n1508     def _print_MatrixBase(self, expr):\n1509         lines = []\n1510 \n1511         for line in range(expr.rows):  # horrible, should be 'rows'\n1512             lines.append(\" & \".join([self._print(i) for i in expr[line, :]]))\n1513 \n1514         mat_str = self._settings['mat_str']\n1515         if mat_str is None:\n1516             if self._settings['mode'] == 'inline':\n1517                 mat_str = 'smallmatrix'\n1518             else:\n1519                 if (expr.cols <= 10) is True:\n1520                     mat_str = 'matrix'\n1521                 else:\n1522                     mat_str = 'array'\n1523 \n1524         out_str = r'\\begin{%MATSTR%}%s\\end{%MATSTR%}'\n1525         out_str = out_str.replace('%MATSTR%', mat_str)\n1526         if mat_str == 'array':\n1527             out_str = out_str.replace('%s', '{' + 'c'*expr.cols + '}%s')\n1528         if self._settings['mat_delim']:\n1529             left_delim = self._settings['mat_delim']\n1530             right_delim = self._delim_dict[left_delim]\n1531             out_str = r'\\left' + left_delim + out_str + \\\n1532                       r'\\right' + right_delim\n1533         return out_str % r\"\\\\\".join(lines)\n1534     _print_ImmutableMatrix = _print_ImmutableDenseMatrix \\\n1535                            = _print_Matrix \\\n1536                            = _print_MatrixBase\n1537 \n1538     def _print_MatrixElement(self, expr):\n1539         return self.parenthesize(expr.parent, PRECEDENCE[\"Atom\"], strict=True)\\\n1540             + '_{%s, %s}' % (self._print(expr.i), self._print(expr.j))\n1541 \n1542     def _print_MatrixSlice(self, expr):\n1543         def latexslice(x):\n1544             x = list(x)\n1545             if x[2] == 1:\n1546                 del x[2]\n1547             if x[1] == x[0] + 1:\n1548                 del x[1]\n1549             if x[0] == 0:\n1550                 x[0] = ''\n1551             return ':'.join(map(self._print, x))\n1552         return (self._print(expr.parent) + r'\\left[' +\n1553                 latexslice(expr.rowslice) + ', ' +\n1554                 latexslice(expr.colslice) + r'\\right]')\n1555 \n1556     def _print_BlockMatrix(self, expr):\n1557         return self._print(expr.blocks)\n1558 \n1559     def _print_Transpose(self, expr):\n1560         mat = expr.arg\n1561         from sympy.matrices import MatrixSymbol\n1562         if not isinstance(mat, MatrixSymbol):\n1563             return r\"\\left(%s\\right)^{T}\" % self._print(mat)\n1564         else:\n1565             return \"%s^{T}\" % self.parenthesize(mat, precedence_traditional(expr), True)\n1566 \n1567     def _print_Trace(self, expr):\n1568         mat = expr.arg\n1569         return r\"\\operatorname{tr}\\left(%s \\right)\" % self._print(mat)\n1570 \n1571     def _print_Adjoint(self, expr):\n1572         mat = expr.arg\n1573         from sympy.matrices import MatrixSymbol\n1574         if not isinstance(mat, MatrixSymbol):\n1575             return r\"\\left(%s\\right)^{\\dagger}\" % self._print(mat)\n1576         else:\n1577             return r\"%s^{\\dagger}\" % self._print(mat)\n1578 \n1579     def _print_MatMul(self, expr):\n1580         from sympy import MatMul, Mul\n1581 \n1582         parens = lambda x: self.parenthesize(x, precedence_traditional(expr),\n1583                                              False)\n1584 \n1585         args = expr.args\n1586         if isinstance(args[0], Mul):\n1587             args = args[0].as_ordered_factors() + list(args[1:])\n1588         else:\n1589             args = list(args)\n1590 \n1591         if isinstance(expr, MatMul) and _coeff_isneg(expr):\n1592             if args[0] == -1:\n1593                 args = args[1:]\n1594             else:\n1595                 args[0] = -args[0]\n1596             return '- ' + ' '.join(map(parens, args))\n1597         else:\n1598             return ' '.join(map(parens, args))\n1599 \n1600     def _print_Mod(self, expr, exp=None):\n1601         if exp is not None:\n1602             return r'\\left(%s\\bmod{%s}\\right)^{%s}' % \\\n1603                 (self.parenthesize(expr.args[0], PRECEDENCE['Mul'],\n1604                                    strict=True), self._print(expr.args[1]),\n1605                  self._print(exp))\n1606         return r'%s\\bmod{%s}' % (self.parenthesize(expr.args[0],\n1607                                  PRECEDENCE['Mul'], strict=True),\n1608                                  self._print(expr.args[1]))\n1609 \n1610     def _print_HadamardProduct(self, expr):\n1611         args = expr.args\n1612         prec = PRECEDENCE['Pow']\n1613         parens = self.parenthesize\n1614 \n1615         return r' \\circ '.join(\n1616             map(lambda arg: parens(arg, prec, strict=True), args))\n1617 \n1618     def _print_HadamardPower(self, expr):\n1619         if precedence_traditional(expr.exp) < PRECEDENCE[\"Mul\"]:\n1620             template = r\"%s^{\\circ \\left({%s}\\right)}\"\n1621         else:\n1622             template = r\"%s^{\\circ {%s}}\"\n1623         return self._helper_print_standard_power(expr, template)\n1624 \n1625     def _print_KroneckerProduct(self, expr):\n1626         args = expr.args\n1627         prec = PRECEDENCE['Pow']\n1628         parens = self.parenthesize\n1629 \n1630         return r' \\otimes '.join(\n1631             map(lambda arg: parens(arg, prec, strict=True), args))\n1632 \n1633     def _print_MatPow(self, expr):\n1634         base, exp = expr.base, expr.exp\n1635         from sympy.matrices import MatrixSymbol\n1636         if not isinstance(base, MatrixSymbol):\n1637             return \"\\\\left(%s\\\\right)^{%s}\" % (self._print(base),\n1638                                               self._print(exp))\n1639         else:\n1640             return \"%s^{%s}\" % (self._print(base), self._print(exp))\n1641 \n1642     def _print_MatrixSymbol(self, expr):\n1643         return self._print_Symbol(expr, style=self._settings[\n1644             'mat_symbol_style'])\n1645 \n1646     def _print_ZeroMatrix(self, Z):\n1647         return r\"\\mathbb{0}\" if self._settings[\n1648             'mat_symbol_style'] == 'plain' else r\"\\mathbf{0}\"\n1649 \n1650     def _print_OneMatrix(self, O):\n1651         return r\"\\mathbb{1}\" if self._settings[\n1652             'mat_symbol_style'] == 'plain' else r\"\\mathbf{1}\"\n1653 \n1654     def _print_Identity(self, I):\n1655         return r\"\\mathbb{I}\" if self._settings[\n1656             'mat_symbol_style'] == 'plain' else r\"\\mathbf{I}\"\n1657 \n1658     def _print_NDimArray(self, expr):\n1659 \n1660         if expr.rank() == 0:\n1661             return self._print(expr[()])\n1662 \n1663         mat_str = self._settings['mat_str']\n1664         if mat_str is None:\n1665             if self._settings['mode'] == 'inline':\n1666                 mat_str = 'smallmatrix'\n1667             else:\n1668                 if (expr.rank() == 0) or (expr.shape[-1] <= 10):\n1669                     mat_str = 'matrix'\n1670                 else:\n1671                     mat_str = 'array'\n1672         block_str = r'\\begin{%MATSTR%}%s\\end{%MATSTR%}'\n1673         block_str = block_str.replace('%MATSTR%', mat_str)\n1674         if self._settings['mat_delim']:\n1675             left_delim = self._settings['mat_delim']\n1676             right_delim = self._delim_dict[left_delim]\n1677             block_str = r'\\left' + left_delim + block_str + \\\n1678                         r'\\right' + right_delim\n1679 \n1680         if expr.rank() == 0:\n1681             return block_str % \"\"\n1682 \n1683         level_str = [[]] + [[] for i in range(expr.rank())]\n1684         shape_ranges = [list(range(i)) for i in expr.shape]\n1685         for outer_i in itertools.product(*shape_ranges):\n1686             level_str[-1].append(self._print(expr[outer_i]))\n1687             even = True\n1688             for back_outer_i in range(expr.rank()-1, -1, -1):\n1689                 if len(level_str[back_outer_i+1]) < expr.shape[back_outer_i]:\n1690                     break\n1691                 if even:\n1692                     level_str[back_outer_i].append(\n1693                         r\" & \".join(level_str[back_outer_i+1]))\n1694                 else:\n1695                     level_str[back_outer_i].append(\n1696                         block_str % (r\"\\\\\".join(level_str[back_outer_i+1])))\n1697                     if len(level_str[back_outer_i+1]) == 1:\n1698                         level_str[back_outer_i][-1] = r\"\\left[\" + \\\n1699                             level_str[back_outer_i][-1] + r\"\\right]\"\n1700                 even = not even\n1701                 level_str[back_outer_i+1] = []\n1702 \n1703         out_str = level_str[0][0]\n1704 \n1705         if expr.rank() % 2 == 1:\n1706             out_str = block_str % out_str\n1707 \n1708         return out_str\n1709 \n1710     _print_ImmutableDenseNDimArray = _print_NDimArray\n1711     _print_ImmutableSparseNDimArray = _print_NDimArray\n1712     _print_MutableDenseNDimArray = _print_NDimArray\n1713     _print_MutableSparseNDimArray = _print_NDimArray\n1714 \n1715     def _printer_tensor_indices(self, name, indices, index_map={}):\n1716         out_str = self._print(name)\n1717         last_valence = None\n1718         prev_map = None\n1719         for index in indices:\n1720             new_valence = index.is_up\n1721             if ((index in index_map) or prev_map) and \\\n1722                     last_valence == new_valence:\n1723                 out_str += \",\"\n1724             if last_valence != new_valence:\n1725                 if last_valence is not None:\n1726                     out_str += \"}\"\n1727                 if index.is_up:\n1728                     out_str += \"{}^{\"\n1729                 else:\n1730                     out_str += \"{}_{\"\n1731             out_str += self._print(index.args[0])\n1732             if index in index_map:\n1733                 out_str += \"=\"\n1734                 out_str += self._print(index_map[index])\n1735                 prev_map = True\n1736             else:\n1737                 prev_map = False\n1738             last_valence = new_valence\n1739         if last_valence is not None:\n1740             out_str += \"}\"\n1741         return out_str\n1742 \n1743     def _print_Tensor(self, expr):\n1744         name = expr.args[0].args[0]\n1745         indices = expr.get_indices()\n1746         return self._printer_tensor_indices(name, indices)\n1747 \n1748     def _print_TensorElement(self, expr):\n1749         name = expr.expr.args[0].args[0]\n1750         indices = expr.expr.get_indices()\n1751         index_map = expr.index_map\n1752         return self._printer_tensor_indices(name, indices, index_map)\n1753 \n1754     def _print_TensMul(self, expr):\n1755         # prints expressions like \"A(a)\", \"3*A(a)\", \"(1+x)*A(a)\"\n1756         sign, args = expr._get_args_for_traditional_printer()\n1757         return sign + \"\".join(\n1758             [self.parenthesize(arg, precedence(expr)) for arg in args]\n1759         )\n1760 \n1761     def _print_TensAdd(self, expr):\n1762         a = []\n1763         args = expr.args\n1764         for x in args:\n1765             a.append(self.parenthesize(x, precedence(expr)))\n1766         a.sort()\n1767         s = ' + '.join(a)\n1768         s = s.replace('+ -', '- ')\n1769         return s\n1770 \n1771     def _print_TensorIndex(self, expr):\n1772         return \"{}%s{%s}\" % (\n1773             \"^\" if expr.is_up else \"_\",\n1774             self._print(expr.args[0])\n1775         )\n1776 \n1777     def _print_UniversalSet(self, expr):\n1778         return r\"\\mathbb{U}\"\n1779 \n1780     def _print_frac(self, expr, exp=None):\n1781         if exp is None:\n1782             return r\"\\operatorname{frac}{\\left(%s\\right)}\" % self._print(expr.args[0])\n1783         else:\n1784             return r\"\\operatorname{frac}{\\left(%s\\right)}^{%s}\" % (\n1785                     self._print(expr.args[0]), self._print(exp))\n1786 \n1787     def _print_tuple(self, expr):\n1788         if self._settings['decimal_separator'] =='comma':\n1789             return r\"\\left( %s\\right)\" % \\\n1790                 r\"; \\  \".join([self._print(i) for i in expr])\n1791         elif self._settings['decimal_separator'] =='period':\n1792             return r\"\\left( %s\\right)\" % \\\n1793                 r\", \\  \".join([self._print(i) for i in expr])\n1794         else:\n1795             raise ValueError('Unknown Decimal Separator')\n1796 \n1797     def _print_TensorProduct(self, expr):\n1798         elements = [self._print(a) for a in expr.args]\n1799         return r' \\otimes '.join(elements)\n1800 \n1801     def _print_WedgeProduct(self, expr):\n1802         elements = [self._print(a) for a in expr.args]\n1803         return r' \\wedge '.join(elements)\n1804 \n1805     def _print_Tuple(self, expr):\n1806         return self._print_tuple(expr)\n1807 \n1808     def _print_list(self, expr):\n1809         if self._settings['decimal_separator'] == 'comma':\n1810             return r\"\\left[ %s\\right]\" % \\\n1811                 r\"; \\  \".join([self._print(i) for i in expr])\n1812         elif self._settings['decimal_separator'] == 'period':\n1813             return r\"\\left[ %s\\right]\" % \\\n1814                 r\", \\  \".join([self._print(i) for i in expr])\n1815         else:\n1816             raise ValueError('Unknown Decimal Separator')\n1817 \n1818 \n1819     def _print_dict(self, d):\n1820         keys = sorted(d.keys(), key=default_sort_key)\n1821         items = []\n1822 \n1823         for key in keys:\n1824             val = d[key]\n1825             items.append(\"%s : %s\" % (self._print(key), self._print(val)))\n1826 \n1827         return r\"\\left\\{ %s\\right\\}\" % r\", \\  \".join(items)\n1828 \n1829     def _print_Dict(self, expr):\n1830         return self._print_dict(expr)\n1831 \n1832     def _print_DiracDelta(self, expr, exp=None):\n1833         if len(expr.args) == 1 or expr.args[1] == 0:\n1834             tex = r\"\\delta\\left(%s\\right)\" % self._print(expr.args[0])\n1835         else:\n1836             tex = r\"\\delta^{\\left( %s \\right)}\\left( %s \\right)\" % (\n1837                 self._print(expr.args[1]), self._print(expr.args[0]))\n1838         if exp:\n1839             tex = r\"\\left(%s\\right)^{%s}\" % (tex, exp)\n1840         return tex\n1841 \n1842     def _print_SingularityFunction(self, expr):\n1843         shift = self._print(expr.args[0] - expr.args[1])\n1844         power = self._print(expr.args[2])\n1845         tex = r\"{\\left\\langle %s \\right\\rangle}^{%s}\" % (shift, power)\n1846         return tex\n1847 \n1848     def _print_Heaviside(self, expr, exp=None):\n1849         tex = r\"\\theta\\left(%s\\right)\" % self._print(expr.args[0])\n1850         if exp:\n1851             tex = r\"\\left(%s\\right)^{%s}\" % (tex, exp)\n1852         return tex\n1853 \n1854     def _print_KroneckerDelta(self, expr, exp=None):\n1855         i = self._print(expr.args[0])\n1856         j = self._print(expr.args[1])\n1857         if expr.args[0].is_Atom and expr.args[1].is_Atom:\n1858             tex = r'\\delta_{%s %s}' % (i, j)\n1859         else:\n1860             tex = r'\\delta_{%s, %s}' % (i, j)\n1861         if exp is not None:\n1862             tex = r'\\left(%s\\right)^{%s}' % (tex, exp)\n1863         return tex\n1864 \n1865     def _print_LeviCivita(self, expr, exp=None):\n1866         indices = map(self._print, expr.args)\n1867         if all(x.is_Atom for x in expr.args):\n1868             tex = r'\\varepsilon_{%s}' % \" \".join(indices)\n1869         else:\n1870             tex = r'\\varepsilon_{%s}' % \", \".join(indices)\n1871         if exp:\n1872             tex = r'\\left(%s\\right)^{%s}' % (tex, exp)\n1873         return tex\n1874 \n1875     def _print_RandomDomain(self, d):\n1876         if hasattr(d, 'as_boolean'):\n1877             return '\\\\text{Domain: }' + self._print(d.as_boolean())\n1878         elif hasattr(d, 'set'):\n1879             return ('\\\\text{Domain: }' + self._print(d.symbols) + '\\\\text{ in }' +\n1880                     self._print(d.set))\n1881         elif hasattr(d, 'symbols'):\n1882             return '\\\\text{Domain on }' + self._print(d.symbols)\n1883         else:\n1884             return self._print(None)\n1885 \n1886     def _print_FiniteSet(self, s):\n1887         items = sorted(s.args, key=default_sort_key)\n1888         return self._print_set(items)\n1889 \n1890     def _print_set(self, s):\n1891         items = sorted(s, key=default_sort_key)\n1892         if self._settings['decimal_separator'] == 'comma':\n1893             items = \"; \".join(map(self._print, items))\n1894         elif self._settings['decimal_separator'] == 'period':\n1895             items = \", \".join(map(self._print, items))\n1896         else:\n1897             raise ValueError('Unknown Decimal Separator')\n1898         return r\"\\left\\{%s\\right\\}\" % items\n1899 \n1900 \n1901     _print_frozenset = _print_set\n1902 \n1903     def _print_Range(self, s):\n1904         dots = r'\\ldots'\n1905 \n1906         if s.start.is_infinite:\n1907             printset = dots, s[-1] - s.step, s[-1]\n1908         elif s.stop.is_infinite:\n1909             it = iter(s)\n1910             printset = next(it), next(it), dots\n1911         elif len(s) > 4:\n1912             it = iter(s)\n1913             printset = next(it), next(it), dots, s[-1]\n1914         else:\n1915             printset = tuple(s)\n1916 \n1917         return (r\"\\left\\{\" +\n1918                 r\", \".join(self._print(el) for el in printset) +\n1919                 r\"\\right\\}\")\n1920 \n1921     def __print_number_polynomial(self, expr, letter, exp=None):\n1922         if len(expr.args) == 2:\n1923             if exp is not None:\n1924                 return r\"%s_{%s}^{%s}\\left(%s\\right)\" % (letter,\n1925                             self._print(expr.args[0]), self._print(exp),\n1926                             self._print(expr.args[1]))\n1927             return r\"%s_{%s}\\left(%s\\right)\" % (letter,\n1928                         self._print(expr.args[0]), self._print(expr.args[1]))\n1929 \n1930         tex = r\"%s_{%s}\" % (letter, self._print(expr.args[0]))\n1931         if exp is not None:\n1932             tex = r\"%s^{%s}\" % (tex, self._print(exp))\n1933         return tex\n1934 \n1935     def _print_bernoulli(self, expr, exp=None):\n1936         return self.__print_number_polynomial(expr, \"B\", exp)\n1937 \n1938     def _print_bell(self, expr, exp=None):\n1939         if len(expr.args) == 3:\n1940             tex1 = r\"B_{%s, %s}\" % (self._print(expr.args[0]),\n1941                                 self._print(expr.args[1]))\n1942             tex2 = r\"\\left(%s\\right)\" % r\", \".join(self._print(el) for\n1943                                                el in expr.args[2])\n1944             if exp is not None:\n1945                 tex = r\"%s^{%s}%s\" % (tex1, self._print(exp), tex2)\n1946             else:\n1947                 tex = tex1 + tex2\n1948             return tex\n1949         return self.__print_number_polynomial(expr, \"B\", exp)\n1950 \n1951 \n1952     def _print_fibonacci(self, expr, exp=None):\n1953         return self.__print_number_polynomial(expr, \"F\", exp)\n1954 \n1955     def _print_lucas(self, expr, exp=None):\n1956         tex = r\"L_{%s}\" % self._print(expr.args[0])\n1957         if exp is not None:\n1958             tex = r\"%s^{%s}\" % (tex, self._print(exp))\n1959         return tex\n1960 \n1961     def _print_tribonacci(self, expr, exp=None):\n1962         return self.__print_number_polynomial(expr, \"T\", exp)\n1963 \n1964     def _print_SeqFormula(self, s):\n1965         if len(s.start.free_symbols) > 0 or len(s.stop.free_symbols) > 0:\n1966             return r\"\\left\\{%s\\right\\}_{%s=%s}^{%s}\" % (\n1967                 self._print(s.formula),\n1968                 self._print(s.variables[0]),\n1969                 self._print(s.start),\n1970                 self._print(s.stop)\n1971             )\n1972         if s.start is S.NegativeInfinity:\n1973             stop = s.stop\n1974             printset = (r'\\ldots', s.coeff(stop - 3), s.coeff(stop - 2),\n1975                         s.coeff(stop - 1), s.coeff(stop))\n1976         elif s.stop is S.Infinity or s.length > 4:\n1977             printset = s[:4]\n1978             printset.append(r'\\ldots')\n1979         else:\n1980             printset = tuple(s)\n1981 \n1982         return (r\"\\left[\" +\n1983                 r\", \".join(self._print(el) for el in printset) +\n1984                 r\"\\right]\")\n1985 \n1986     _print_SeqPer = _print_SeqFormula\n1987     _print_SeqAdd = _print_SeqFormula\n1988     _print_SeqMul = _print_SeqFormula\n1989 \n1990     def _print_Interval(self, i):\n1991         if i.start == i.end:\n1992             return r\"\\left\\{%s\\right\\}\" % self._print(i.start)\n1993 \n1994         else:\n1995             if i.left_open:\n1996                 left = '('\n1997             else:\n1998                 left = '['\n1999 \n2000             if i.right_open:\n2001                 right = ')'\n2002             else:\n2003                 right = ']'\n2004 \n2005             return r\"\\left%s%s, %s\\right%s\" % \\\n2006                    (left, self._print(i.start), self._print(i.end), right)\n2007 \n2008     def _print_AccumulationBounds(self, i):\n2009         return r\"\\left\\langle %s, %s\\right\\rangle\" % \\\n2010                 (self._print(i.min), self._print(i.max))\n2011 \n2012     def _print_Union(self, u):\n2013         prec = precedence_traditional(u)\n2014         args_str = [self.parenthesize(i, prec) for i in u.args]\n2015         return r\" \\cup \".join(args_str)\n2016 \n2017     def _print_Complement(self, u):\n2018         prec = precedence_traditional(u)\n2019         args_str = [self.parenthesize(i, prec) for i in u.args]\n2020         return r\" \\setminus \".join(args_str)\n2021 \n2022     def _print_Intersection(self, u):\n2023         prec = precedence_traditional(u)\n2024         args_str = [self.parenthesize(i, prec) for i in u.args]\n2025         return r\" \\cap \".join(args_str)\n2026 \n2027     def _print_SymmetricDifference(self, u):\n2028         prec = precedence_traditional(u)\n2029         args_str = [self.parenthesize(i, prec) for i in u.args]\n2030         return r\" \\triangle \".join(args_str)\n2031 \n2032     def _print_ProductSet(self, p):\n2033         prec = precedence_traditional(p)\n2034         if len(p.sets) >= 1 and not has_variety(p.sets):\n2035             return self.parenthesize(p.sets[0], prec) + \"^{%d}\" % len(p.sets)\n2036         return r\" \\times \".join(\n2037             self.parenthesize(set, prec) for set in p.sets)\n2038 \n2039     def _print_EmptySet(self, e):\n2040         return r\"\\emptyset\"\n2041 \n2042     def _print_Naturals(self, n):\n2043         return r\"\\mathbb{N}\"\n2044 \n2045     def _print_Naturals0(self, n):\n2046         return r\"\\mathbb{N}_0\"\n2047 \n2048     def _print_Integers(self, i):\n2049         return r\"\\mathbb{Z}\"\n2050 \n2051     def _print_Reals(self, i):\n2052         return r\"\\mathbb{R}\"\n2053 \n2054     def _print_Complexes(self, i):\n2055         return r\"\\mathbb{C}\"\n2056 \n2057     def _print_ImageSet(self, s):\n2058         expr = s.lamda.expr\n2059         sig = s.lamda.signature\n2060         xys = ((self._print(x), self._print(y)) for x, y in zip(sig, s.base_sets))\n2061         xinys = r\" , \".join(r\"%s \\in %s\" % xy for xy in xys)\n2062         return r\"\\left\\{%s\\; |\\; %s\\right\\}\" % (self._print(expr), xinys)\n2063 \n2064     def _print_ConditionSet(self, s):\n2065         vars_print = ', '.join([self._print(var) for var in Tuple(s.sym)])\n2066         if s.base_set is S.UniversalSet:\n2067             return r\"\\left\\{%s \\mid %s \\right\\}\" % \\\n2068                 (vars_print, self._print(s.condition.as_expr()))\n2069 \n2070         return r\"\\left\\{%s \\mid %s \\in %s \\wedge %s \\right\\}\" % (\n2071             vars_print,\n2072             vars_print,\n2073             self._print(s.base_set),\n2074             self._print(s.condition))\n2075 \n2076     def _print_ComplexRegion(self, s):\n2077         vars_print = ', '.join([self._print(var) for var in s.variables])\n2078         return r\"\\left\\{%s\\; |\\; %s \\in %s \\right\\}\" % (\n2079             self._print(s.expr),\n2080             vars_print,\n2081             self._print(s.sets))\n2082 \n2083     def _print_Contains(self, e):\n2084         return r\"%s \\in %s\" % tuple(self._print(a) for a in e.args)\n2085 \n2086     def _print_FourierSeries(self, s):\n2087         return self._print_Add(s.truncate()) + self._print(r' + \\ldots')\n2088 \n2089     def _print_FormalPowerSeries(self, s):\n2090         return self._print_Add(s.infinite)\n2091 \n2092     def _print_FiniteField(self, expr):\n2093         return r\"\\mathbb{F}_{%s}\" % expr.mod\n2094 \n2095     def _print_IntegerRing(self, expr):\n2096         return r\"\\mathbb{Z}\"\n2097 \n2098     def _print_RationalField(self, expr):\n2099         return r\"\\mathbb{Q}\"\n2100 \n2101     def _print_RealField(self, expr):\n2102         return r\"\\mathbb{R}\"\n2103 \n2104     def _print_ComplexField(self, expr):\n2105         return r\"\\mathbb{C}\"\n2106 \n2107     def _print_PolynomialRing(self, expr):\n2108         domain = self._print(expr.domain)\n2109         symbols = \", \".join(map(self._print, expr.symbols))\n2110         return r\"%s\\left[%s\\right]\" % (domain, symbols)\n2111 \n2112     def _print_FractionField(self, expr):\n2113         domain = self._print(expr.domain)\n2114         symbols = \", \".join(map(self._print, expr.symbols))\n2115         return r\"%s\\left(%s\\right)\" % (domain, symbols)\n2116 \n2117     def _print_PolynomialRingBase(self, expr):\n2118         domain = self._print(expr.domain)\n2119         symbols = \", \".join(map(self._print, expr.symbols))\n2120         inv = \"\"\n2121         if not expr.is_Poly:\n2122             inv = r\"S_<^{-1}\"\n2123         return r\"%s%s\\left[%s\\right]\" % (inv, domain, symbols)\n2124 \n2125     def _print_Poly(self, poly):\n2126         cls = poly.__class__.__name__\n2127         terms = []\n2128         for monom, coeff in poly.terms():\n2129             s_monom = ''\n2130             for i, exp in enumerate(monom):\n2131                 if exp > 0:\n2132                     if exp == 1:\n2133                         s_monom += self._print(poly.gens[i])\n2134                     else:\n2135                         s_monom += self._print(pow(poly.gens[i], exp))\n2136 \n2137             if coeff.is_Add:\n2138                 if s_monom:\n2139                     s_coeff = r\"\\left(%s\\right)\" % self._print(coeff)\n2140                 else:\n2141                     s_coeff = self._print(coeff)\n2142             else:\n2143                 if s_monom:\n2144                     if coeff is S.One:\n2145                         terms.extend(['+', s_monom])\n2146                         continue\n2147 \n2148                     if coeff is S.NegativeOne:\n2149                         terms.extend(['-', s_monom])\n2150                         continue\n2151 \n2152                 s_coeff = self._print(coeff)\n2153 \n2154             if not s_monom:\n2155                 s_term = s_coeff\n2156             else:\n2157                 s_term = s_coeff + \" \" + s_monom\n2158 \n2159             if s_term.startswith('-'):\n2160                 terms.extend(['-', s_term[1:]])\n2161             else:\n2162                 terms.extend(['+', s_term])\n2163 \n2164         if terms[0] in ['-', '+']:\n2165             modifier = terms.pop(0)\n2166 \n2167             if modifier == '-':\n2168                 terms[0] = '-' + terms[0]\n2169 \n2170         expr = ' '.join(terms)\n2171         gens = list(map(self._print, poly.gens))\n2172         domain = \"domain=%s\" % self._print(poly.get_domain())\n2173 \n2174         args = \", \".join([expr] + gens + [domain])\n2175         if cls in accepted_latex_functions:\n2176             tex = r\"\\%s {\\left(%s \\right)}\" % (cls, args)\n2177         else:\n2178             tex = r\"\\operatorname{%s}{\\left( %s \\right)}\" % (cls, args)\n2179 \n2180         return tex\n2181 \n2182     def _print_ComplexRootOf(self, root):\n2183         cls = root.__class__.__name__\n2184         if cls == \"ComplexRootOf\":\n2185             cls = \"CRootOf\"\n2186         expr = self._print(root.expr)\n2187         index = root.index\n2188         if cls in accepted_latex_functions:\n2189             return r\"\\%s {\\left(%s, %d\\right)}\" % (cls, expr, index)\n2190         else:\n2191             return r\"\\operatorname{%s} {\\left(%s, %d\\right)}\" % (cls, expr,\n2192                                                                  index)\n2193 \n2194     def _print_RootSum(self, expr):\n2195         cls = expr.__class__.__name__\n2196         args = [self._print(expr.expr)]\n2197 \n2198         if expr.fun is not S.IdentityFunction:\n2199             args.append(self._print(expr.fun))\n2200 \n2201         if cls in accepted_latex_functions:\n2202             return r\"\\%s {\\left(%s\\right)}\" % (cls, \", \".join(args))\n2203         else:\n2204             return r\"\\operatorname{%s} {\\left(%s\\right)}\" % (cls,\n2205                                                              \", \".join(args))\n2206 \n2207     def _print_PolyElement(self, poly):\n2208         mul_symbol = self._settings['mul_symbol_latex']\n2209         return poly.str(self, PRECEDENCE, \"{%s}^{%d}\", mul_symbol)\n2210 \n2211     def _print_FracElement(self, frac):\n2212         if frac.denom == 1:\n2213             return self._print(frac.numer)\n2214         else:\n2215             numer = self._print(frac.numer)\n2216             denom = self._print(frac.denom)\n2217             return r\"\\frac{%s}{%s}\" % (numer, denom)\n2218 \n2219     def _print_euler(self, expr, exp=None):\n2220         m, x = (expr.args[0], None) if len(expr.args) == 1 else expr.args\n2221         tex = r\"E_{%s}\" % self._print(m)\n2222         if exp is not None:\n2223             tex = r\"%s^{%s}\" % (tex, self._print(exp))\n2224         if x is not None:\n2225             tex = r\"%s\\left(%s\\right)\" % (tex, self._print(x))\n2226         return tex\n2227 \n2228     def _print_catalan(self, expr, exp=None):\n2229         tex = r\"C_{%s}\" % self._print(expr.args[0])\n2230         if exp is not None:\n2231             tex = r\"%s^{%s}\" % (tex, self._print(exp))\n2232         return tex\n2233 \n2234     def _print_UnifiedTransform(self, expr, s, inverse=False):\n2235         return r\"\\mathcal{{{}}}{}_{{{}}}\\left[{}\\right]\\left({}\\right)\".format(s, '^{-1}' if inverse else '', self._print(expr.args[1]), self._print(expr.args[0]), self._print(expr.args[2]))\n2236 \n2237     def _print_MellinTransform(self, expr):\n2238         return self._print_UnifiedTransform(expr, 'M')\n2239 \n2240     def _print_InverseMellinTransform(self, expr):\n2241         return self._print_UnifiedTransform(expr, 'M', True)\n2242 \n2243     def _print_LaplaceTransform(self, expr):\n2244         return self._print_UnifiedTransform(expr, 'L')\n2245 \n2246     def _print_InverseLaplaceTransform(self, expr):\n2247         return self._print_UnifiedTransform(expr, 'L', True)\n2248 \n2249     def _print_FourierTransform(self, expr):\n2250         return self._print_UnifiedTransform(expr, 'F')\n2251 \n2252     def _print_InverseFourierTransform(self, expr):\n2253         return self._print_UnifiedTransform(expr, 'F', True)\n2254 \n2255     def _print_SineTransform(self, expr):\n2256         return self._print_UnifiedTransform(expr, 'SIN')\n2257 \n2258     def _print_InverseSineTransform(self, expr):\n2259         return self._print_UnifiedTransform(expr, 'SIN', True)\n2260 \n2261     def _print_CosineTransform(self, expr):\n2262         return self._print_UnifiedTransform(expr, 'COS')\n2263 \n2264     def _print_InverseCosineTransform(self, expr):\n2265         return self._print_UnifiedTransform(expr, 'COS', True)\n2266 \n2267     def _print_DMP(self, p):\n2268         try:\n2269             if p.ring is not None:\n2270                 # TODO incorporate order\n2271                 return self._print(p.ring.to_sympy(p))\n2272         except SympifyError:\n2273             pass\n2274         return self._print(repr(p))\n2275 \n2276     def _print_DMF(self, p):\n2277         return self._print_DMP(p)\n2278 \n2279     def _print_Object(self, object):\n2280         return self._print(Symbol(object.name))\n2281 \n2282     def _print_LambertW(self, expr):\n2283         if len(expr.args) == 1:\n2284             return r\"W\\left(%s\\right)\" % self._print(expr.args[0])\n2285         return r\"W_{%s}\\left(%s\\right)\" % \\\n2286             (self._print(expr.args[1]), self._print(expr.args[0]))\n2287 \n2288     def _print_Morphism(self, morphism):\n2289         domain = self._print(morphism.domain)\n2290         codomain = self._print(morphism.codomain)\n2291         return \"%s\\\\rightarrow %s\" % (domain, codomain)\n2292 \n2293     def _print_NamedMorphism(self, morphism):\n2294         pretty_name = self._print(Symbol(morphism.name))\n2295         pretty_morphism = self._print_Morphism(morphism)\n2296         return \"%s:%s\" % (pretty_name, pretty_morphism)\n2297 \n2298     def _print_IdentityMorphism(self, morphism):\n2299         from sympy.categories import NamedMorphism\n2300         return self._print_NamedMorphism(NamedMorphism(\n2301             morphism.domain, morphism.codomain, \"id\"))\n2302 \n2303     def _print_CompositeMorphism(self, morphism):\n2304         # All components of the morphism have names and it is thus\n2305         # possible to build the name of the composite.\n2306         component_names_list = [self._print(Symbol(component.name)) for\n2307                                 component in morphism.components]\n2308         component_names_list.reverse()\n2309         component_names = \"\\\\circ \".join(component_names_list) + \":\"\n2310 \n2311         pretty_morphism = self._print_Morphism(morphism)\n2312         return component_names + pretty_morphism\n2313 \n2314     def _print_Category(self, morphism):\n2315         return r\"\\mathbf{{{}}}\".format(self._print(Symbol(morphism.name)))\n2316 \n2317     def _print_Diagram(self, diagram):\n2318         if not diagram.premises:\n2319             # This is an empty diagram.\n2320             return self._print(S.EmptySet)\n2321 \n2322         latex_result = self._print(diagram.premises)\n2323         if diagram.conclusions:\n2324             latex_result += \"\\\\Longrightarrow %s\" % \\\n2325                             self._print(diagram.conclusions)\n2326 \n2327         return latex_result\n2328 \n2329     def _print_DiagramGrid(self, grid):\n2330         latex_result = \"\\\\begin{array}{%s}\\n\" % (\"c\" * grid.width)\n2331 \n2332         for i in range(grid.height):\n2333             for j in range(grid.width):\n2334                 if grid[i, j]:\n2335                     latex_result += latex(grid[i, j])\n2336                 latex_result += \" \"\n2337                 if j != grid.width - 1:\n2338                     latex_result += \"& \"\n2339 \n2340             if i != grid.height - 1:\n2341                 latex_result += \"\\\\\\\\\"\n2342             latex_result += \"\\n\"\n2343 \n2344         latex_result += \"\\\\end{array}\\n\"\n2345         return latex_result\n2346 \n2347     def _print_FreeModule(self, M):\n2348         return '{{{}}}^{{{}}}'.format(self._print(M.ring), self._print(M.rank))\n2349 \n2350     def _print_FreeModuleElement(self, m):\n2351         # Print as row vector for convenience, for now.\n2352         return r\"\\left[ {} \\right]\".format(\",\".join(\n2353             '{' + self._print(x) + '}' for x in m))\n2354 \n2355     def _print_SubModule(self, m):\n2356         return r\"\\left\\langle {} \\right\\rangle\".format(\",\".join(\n2357             '{' + self._print(x) + '}' for x in m.gens))\n2358 \n2359     def _print_ModuleImplementedIdeal(self, m):\n2360         return r\"\\left\\langle {} \\right\\rangle\".format(\",\".join(\n2361             '{' + self._print(x) + '}' for [x] in m._module.gens))\n2362 \n2363     def _print_Quaternion(self, expr):\n2364         # TODO: This expression is potentially confusing,\n2365         # shall we print it as `Quaternion( ... )`?\n2366         s = [self.parenthesize(i, PRECEDENCE[\"Mul\"], strict=True)\n2367              for i in expr.args]\n2368         a = [s[0]] + [i+\" \"+j for i, j in zip(s[1:], \"ijk\")]\n2369         return \" + \".join(a)\n2370 \n2371     def _print_QuotientRing(self, R):\n2372         # TODO nicer fractions for few generators...\n2373         return r\"\\frac{{{}}}{{{}}}\".format(self._print(R.ring),\n2374                  self._print(R.base_ideal))\n2375 \n2376     def _print_QuotientRingElement(self, x):\n2377         return r\"{{{}}} + {{{}}}\".format(self._print(x.data),\n2378                  self._print(x.ring.base_ideal))\n2379 \n2380     def _print_QuotientModuleElement(self, m):\n2381         return r\"{{{}}} + {{{}}}\".format(self._print(m.data),\n2382                  self._print(m.module.killed_module))\n2383 \n2384     def _print_QuotientModule(self, M):\n2385         # TODO nicer fractions for few generators...\n2386         return r\"\\frac{{{}}}{{{}}}\".format(self._print(M.base),\n2387                  self._print(M.killed_module))\n2388 \n2389     def _print_MatrixHomomorphism(self, h):\n2390         return r\"{{{}}} : {{{}}} \\to {{{}}}\".format(self._print(h._sympy_matrix()),\n2391             self._print(h.domain), self._print(h.codomain))\n2392 \n2393     def _print_BaseScalarField(self, field):\n2394         string = field._coord_sys._names[field._index]\n2395         return r'\\mathbf{{{}}}'.format(self._print(Symbol(string)))\n2396 \n2397     def _print_BaseVectorField(self, field):\n2398         string = field._coord_sys._names[field._index]\n2399         return r'\\partial_{{{}}}'.format(self._print(Symbol(string)))\n2400 \n2401     def _print_Differential(self, diff):\n2402         field = diff._form_field\n2403         if hasattr(field, '_coord_sys'):\n2404             string = field._coord_sys._names[field._index]\n2405             return r'\\operatorname{{d}}{}'.format(self._print(Symbol(string)))\n2406         else:\n2407             string = self._print(field)\n2408             return r'\\operatorname{{d}}\\left({}\\right)'.format(string)\n2409 \n2410     def _print_Tr(self, p):\n2411         # TODO: Handle indices\n2412         contents = self._print(p.args[0])\n2413         return r'\\operatorname{{tr}}\\left({}\\right)'.format(contents)\n2414 \n2415     def _print_totient(self, expr, exp=None):\n2416         if exp is not None:\n2417             return r'\\left(\\phi\\left(%s\\right)\\right)^{%s}' % \\\n2418                 (self._print(expr.args[0]), self._print(exp))\n2419         return r'\\phi\\left(%s\\right)' % self._print(expr.args[0])\n2420 \n2421     def _print_reduced_totient(self, expr, exp=None):\n2422         if exp is not None:\n2423             return r'\\left(\\lambda\\left(%s\\right)\\right)^{%s}' % \\\n2424                 (self._print(expr.args[0]), self._print(exp))\n2425         return r'\\lambda\\left(%s\\right)' % self._print(expr.args[0])\n2426 \n2427     def _print_divisor_sigma(self, expr, exp=None):\n2428         if len(expr.args) == 2:\n2429             tex = r\"_%s\\left(%s\\right)\" % tuple(map(self._print,\n2430                                                 (expr.args[1], expr.args[0])))\n2431         else:\n2432             tex = r\"\\left(%s\\right)\" % self._print(expr.args[0])\n2433         if exp is not None:\n2434             return r\"\\sigma^{%s}%s\" % (self._print(exp), tex)\n2435         return r\"\\sigma%s\" % tex\n2436 \n2437     def _print_udivisor_sigma(self, expr, exp=None):\n2438         if len(expr.args) == 2:\n2439             tex = r\"_%s\\left(%s\\right)\" % tuple(map(self._print,\n2440                                                 (expr.args[1], expr.args[0])))\n2441         else:\n2442             tex = r\"\\left(%s\\right)\" % self._print(expr.args[0])\n2443         if exp is not None:\n2444             return r\"\\sigma^*^{%s}%s\" % (self._print(exp), tex)\n2445         return r\"\\sigma^*%s\" % tex\n2446 \n2447     def _print_primenu(self, expr, exp=None):\n2448         if exp is not None:\n2449             return r'\\left(\\nu\\left(%s\\right)\\right)^{%s}' % \\\n2450                 (self._print(expr.args[0]), self._print(exp))\n2451         return r'\\nu\\left(%s\\right)' % self._print(expr.args[0])\n2452 \n2453     def _print_primeomega(self, expr, exp=None):\n2454         if exp is not None:\n2455             return r'\\left(\\Omega\\left(%s\\right)\\right)^{%s}' % \\\n2456                 (self._print(expr.args[0]), self._print(exp))\n2457         return r'\\Omega\\left(%s\\right)' % self._print(expr.args[0])\n2458 \n2459 \n2460 def translate(s):\n2461     r'''\n2462     Check for a modifier ending the string.  If present, convert the\n2463     modifier to latex and translate the rest recursively.\n2464 \n2465     Given a description of a Greek letter or other special character,\n2466     return the appropriate latex.\n2467 \n2468     Let everything else pass as given.\n2469 \n2470     >>> from sympy.printing.latex import translate\n2471     >>> translate('alphahatdotprime')\n2472     \"{\\\\dot{\\\\hat{\\\\alpha}}}'\"\n2473     '''\n2474     # Process the rest\n2475     tex = tex_greek_dictionary.get(s)\n2476     if tex:\n2477         return tex\n2478     elif s.lower() in greek_letters_set:\n2479         return \"\\\\\" + s.lower()\n2480     elif s in other_symbols:\n2481         return \"\\\\\" + s\n2482     else:\n2483         # Process modifiers, if any, and recurse\n2484         for key in sorted(modifier_dict.keys(), key=lambda k:len(k), reverse=True):\n2485             if s.lower().endswith(key) and len(s) > len(key):\n2486                 return modifier_dict[key](translate(s[:-len(key)]))\n2487         return s\n2488 \n2489 \n2490 def latex(expr, fold_frac_powers=False, fold_func_brackets=False,\n2491           fold_short_frac=None, inv_trig_style=\"abbreviated\",\n2492           itex=False, ln_notation=False, long_frac_ratio=None,\n2493           mat_delim=\"[\", mat_str=None, mode=\"plain\", mul_symbol=None,\n2494           order=None, symbol_names=None, root_notation=True,\n2495           mat_symbol_style=\"plain\", imaginary_unit=\"i\", gothic_re_im=False,\n2496           decimal_separator=\"period\" ):\n2497     r\"\"\"Convert the given expression to LaTeX string representation.\n2498 \n2499     Parameters\n2500     ==========\n2501     fold_frac_powers : boolean, optional\n2502         Emit ``^{p/q}`` instead of ``^{\\frac{p}{q}}`` for fractional powers.\n2503     fold_func_brackets : boolean, optional\n2504         Fold function brackets where applicable.\n2505     fold_short_frac : boolean, optional\n2506         Emit ``p / q`` instead of ``\\frac{p}{q}`` when the denominator is\n2507         simple enough (at most two terms and no powers). The default value is\n2508         ``True`` for inline mode, ``False`` otherwise.\n2509     inv_trig_style : string, optional\n2510         How inverse trig functions should be displayed. Can be one of\n2511         ``abbreviated``, ``full``, or ``power``. Defaults to ``abbreviated``.\n2512     itex : boolean, optional\n2513         Specifies if itex-specific syntax is used, including emitting\n2514         ``$$...$$``.\n2515     ln_notation : boolean, optional\n2516         If set to ``True``, ``\\ln`` is used instead of default ``\\log``.\n2517     long_frac_ratio : float or None, optional\n2518         The allowed ratio of the width of the numerator to the width of the\n2519         denominator before the printer breaks off long fractions. If ``None``\n2520         (the default value), long fractions are not broken up.\n2521     mat_delim : string, optional\n2522         The delimiter to wrap around matrices. Can be one of ``[``, ``(``, or\n2523         the empty string. Defaults to ``[``.\n2524     mat_str : string, optional\n2525         Which matrix environment string to emit. ``smallmatrix``, ``matrix``,\n2526         ``array``, etc. Defaults to ``smallmatrix`` for inline mode, ``matrix``\n2527         for matrices of no more than 10 columns, and ``array`` otherwise.\n2528     mode: string, optional\n2529         Specifies how the generated code will be delimited. ``mode`` can be one\n2530         of ``plain``, ``inline``, ``equation`` or ``equation*``.  If ``mode``\n2531         is set to ``plain``, then the resulting code will not be delimited at\n2532         all (this is the default). If ``mode`` is set to ``inline`` then inline\n2533         LaTeX ``$...$`` will be used. If ``mode`` is set to ``equation`` or\n2534         ``equation*``, the resulting code will be enclosed in the ``equation``\n2535         or ``equation*`` environment (remember to import ``amsmath`` for\n2536         ``equation*``), unless the ``itex`` option is set. In the latter case,\n2537         the ``$$...$$`` syntax is used.\n2538     mul_symbol : string or None, optional\n2539         The symbol to use for multiplication. Can be one of ``None``, ``ldot``,\n2540         ``dot``, or ``times``.\n2541     order: string, optional\n2542         Any of the supported monomial orderings (currently ``lex``, ``grlex``,\n2543         or ``grevlex``), ``old``, and ``none``. This parameter does nothing for\n2544         Mul objects. Setting order to ``old`` uses the compatibility ordering\n2545         for Add defined in Printer. For very large expressions, set the\n2546         ``order`` keyword to ``none`` if speed is a concern.\n2547     symbol_names : dictionary of strings mapped to symbols, optional\n2548         Dictionary of symbols and the custom strings they should be emitted as.\n2549     root_notation : boolean, optional\n2550         If set to ``False``, exponents of the form 1/n are printed in fractonal\n2551         form. Default is ``True``, to print exponent in root form.\n2552     mat_symbol_style : string, optional\n2553         Can be either ``plain`` (default) or ``bold``. If set to ``bold``,\n2554         a MatrixSymbol A will be printed as ``\\mathbf{A}``, otherwise as ``A``.\n2555     imaginary_unit : string, optional\n2556         String to use for the imaginary unit. Defined options are \"i\" (default)\n2557         and \"j\". Adding \"r\" or \"t\" in front gives ``\\mathrm`` or ``\\text``, so\n2558         \"ri\" leads to ``\\mathrm{i}`` which gives `\\mathrm{i}`.\n2559     gothic_re_im : boolean, optional\n2560         If set to ``True``, `\\Re` and `\\Im` is used for ``re`` and ``im``, respectively.\n2561         The default is ``False`` leading to `\\operatorname{re}` and `\\operatorname{im}`.\n2562     decimal_separator : string, optional\n2563         Specifies what separator to use to separate the whole and fractional parts of a\n2564         floating point number as in `2.5` for the default, ``period`` or `2{,}5`\n2565         when ``comma`` is specified. Lists, sets, and tuple are printed with semicolon\n2566         separating the elements when ``comma`` is chosen. For example, [1; 2; 3] when\n2567         ``comma`` is chosen and [1,2,3] for when ``period`` is chosen.\n2568 \n2569     Notes\n2570     =====\n2571 \n2572     Not using a print statement for printing, results in double backslashes for\n2573     latex commands since that's the way Python escapes backslashes in strings.\n2574 \n2575     >>> from sympy import latex, Rational\n2576     >>> from sympy.abc import tau\n2577     >>> latex((2*tau)**Rational(7,2))\n2578     '8 \\\\sqrt{2} \\\\tau^{\\\\frac{7}{2}}'\n2579     >>> print(latex((2*tau)**Rational(7,2)))\n2580     8 \\sqrt{2} \\tau^{\\frac{7}{2}}\n2581 \n2582     Examples\n2583     ========\n2584 \n2585     >>> from sympy import latex, pi, sin, asin, Integral, Matrix, Rational, log\n2586     >>> from sympy.abc import x, y, mu, r, tau\n2587 \n2588     Basic usage:\n2589 \n2590     >>> print(latex((2*tau)**Rational(7,2)))\n2591     8 \\sqrt{2} \\tau^{\\frac{7}{2}}\n2592 \n2593     ``mode`` and ``itex`` options:\n2594 \n2595     >>> print(latex((2*mu)**Rational(7,2), mode='plain'))\n2596     8 \\sqrt{2} \\mu^{\\frac{7}{2}}\n2597     >>> print(latex((2*tau)**Rational(7,2), mode='inline'))\n2598     $8 \\sqrt{2} \\tau^{7 / 2}$\n2599     >>> print(latex((2*mu)**Rational(7,2), mode='equation*'))\n2600     \\begin{equation*}8 \\sqrt{2} \\mu^{\\frac{7}{2}}\\end{equation*}\n2601     >>> print(latex((2*mu)**Rational(7,2), mode='equation'))\n2602     \\begin{equation}8 \\sqrt{2} \\mu^{\\frac{7}{2}}\\end{equation}\n2603     >>> print(latex((2*mu)**Rational(7,2), mode='equation', itex=True))\n2604     $$8 \\sqrt{2} \\mu^{\\frac{7}{2}}$$\n2605     >>> print(latex((2*mu)**Rational(7,2), mode='plain'))\n2606     8 \\sqrt{2} \\mu^{\\frac{7}{2}}\n2607     >>> print(latex((2*tau)**Rational(7,2), mode='inline'))\n2608     $8 \\sqrt{2} \\tau^{7 / 2}$\n2609     >>> print(latex((2*mu)**Rational(7,2), mode='equation*'))\n2610     \\begin{equation*}8 \\sqrt{2} \\mu^{\\frac{7}{2}}\\end{equation*}\n2611     >>> print(latex((2*mu)**Rational(7,2), mode='equation'))\n2612     \\begin{equation}8 \\sqrt{2} \\mu^{\\frac{7}{2}}\\end{equation}\n2613     >>> print(latex((2*mu)**Rational(7,2), mode='equation', itex=True))\n2614     $$8 \\sqrt{2} \\mu^{\\frac{7}{2}}$$\n2615 \n2616     Fraction options:\n2617 \n2618     >>> print(latex((2*tau)**Rational(7,2), fold_frac_powers=True))\n2619     8 \\sqrt{2} \\tau^{7/2}\n2620     >>> print(latex((2*tau)**sin(Rational(7,2))))\n2621     \\left(2 \\tau\\right)^{\\sin{\\left(\\frac{7}{2} \\right)}}\n2622     >>> print(latex((2*tau)**sin(Rational(7,2)), fold_func_brackets=True))\n2623     \\left(2 \\tau\\right)^{\\sin {\\frac{7}{2}}}\n2624     >>> print(latex(3*x**2/y))\n2625     \\frac{3 x^{2}}{y}\n2626     >>> print(latex(3*x**2/y, fold_short_frac=True))\n2627     3 x^{2} / y\n2628     >>> print(latex(Integral(r, r)/2/pi, long_frac_ratio=2))\n2629     \\frac{\\int r\\, dr}{2 \\pi}\n2630     >>> print(latex(Integral(r, r)/2/pi, long_frac_ratio=0))\n2631     \\frac{1}{2 \\pi} \\int r\\, dr\n2632 \n2633     Multiplication options:\n2634 \n2635     >>> print(latex((2*tau)**sin(Rational(7,2)), mul_symbol=\"times\"))\n2636     \\left(2 \\times \\tau\\right)^{\\sin{\\left(\\frac{7}{2} \\right)}}\n2637 \n2638     Trig options:\n2639 \n2640     >>> print(latex(asin(Rational(7,2))))\n2641     \\operatorname{asin}{\\left(\\frac{7}{2} \\right)}\n2642     >>> print(latex(asin(Rational(7,2)), inv_trig_style=\"full\"))\n2643     \\arcsin{\\left(\\frac{7}{2} \\right)}\n2644     >>> print(latex(asin(Rational(7,2)), inv_trig_style=\"power\"))\n2645     \\sin^{-1}{\\left(\\frac{7}{2} \\right)}\n2646 \n2647     Matrix options:\n2648 \n2649     >>> print(latex(Matrix(2, 1, [x, y])))\n2650     \\left[\\begin{matrix}x\\\\y\\end{matrix}\\right]\n2651     >>> print(latex(Matrix(2, 1, [x, y]), mat_str = \"array\"))\n2652     \\left[\\begin{array}{c}x\\\\y\\end{array}\\right]\n2653     >>> print(latex(Matrix(2, 1, [x, y]), mat_delim=\"(\"))\n2654     \\left(\\begin{matrix}x\\\\y\\end{matrix}\\right)\n2655 \n2656     Custom printing of symbols:\n2657 \n2658     >>> print(latex(x**2, symbol_names={x: 'x_i'}))\n2659     x_i^{2}\n2660 \n2661     Logarithms:\n2662 \n2663     >>> print(latex(log(10)))\n2664     \\log{\\left(10 \\right)}\n2665     >>> print(latex(log(10), ln_notation=True))\n2666     \\ln{\\left(10 \\right)}\n2667 \n2668     ``latex()`` also supports the builtin container types list, tuple, and\n2669     dictionary.\n2670 \n2671     >>> print(latex([2/x, y], mode='inline'))\n2672     $\\left[ 2 / x, \\  y\\right]$\n2673 \n2674     \"\"\"\n2675     if symbol_names is None:\n2676         symbol_names = {}\n2677 \n2678     settings = {\n2679         'fold_frac_powers': fold_frac_powers,\n2680         'fold_func_brackets': fold_func_brackets,\n2681         'fold_short_frac': fold_short_frac,\n2682         'inv_trig_style': inv_trig_style,\n2683         'itex': itex,\n2684         'ln_notation': ln_notation,\n2685         'long_frac_ratio': long_frac_ratio,\n2686         'mat_delim': mat_delim,\n2687         'mat_str': mat_str,\n2688         'mode': mode,\n2689         'mul_symbol': mul_symbol,\n2690         'order': order,\n2691         'symbol_names': symbol_names,\n2692         'root_notation': root_notation,\n2693         'mat_symbol_style': mat_symbol_style,\n2694         'imaginary_unit': imaginary_unit,\n2695         'gothic_re_im': gothic_re_im,\n2696         'decimal_separator': decimal_separator,\n2697     }\n2698 \n2699     return LatexPrinter(settings).doprint(expr)\n2700 \n2701 \n2702 def print_latex(expr, **settings):\n2703     \"\"\"Prints LaTeX representation of the given expression. Takes the same\n2704     settings as ``latex()``.\"\"\"\n2705 \n2706     print(latex(expr, **settings))\n2707 \n2708 \n2709 def multiline_latex(lhs, rhs, terms_per_line=1, environment=\"align*\", use_dots=False, **settings):\n2710     r\"\"\"\n2711     This function generates a LaTeX equation with a multiline right-hand side\n2712     in an ``align*``, ``eqnarray`` or ``IEEEeqnarray`` environment.\n2713 \n2714     Parameters\n2715     ==========\n2716 \n2717     lhs : Expr\n2718         Left-hand side of equation\n2719 \n2720     rhs : Expr\n2721         Right-hand side of equation\n2722 \n2723     terms_per_line : integer, optional\n2724         Number of terms per line to print. Default is 1.\n2725 \n2726     environment : \"string\", optional\n2727         Which LaTeX wnvironment to use for the output. Options are \"align*\"\n2728         (default), \"eqnarray\", and \"IEEEeqnarray\".\n2729 \n2730     use_dots : boolean, optional\n2731         If ``True``, ``\\\\dots`` is added to the end of each line. Default is ``False``.\n2732 \n2733     Examples\n2734     ========\n2735 \n2736     >>> from sympy import multiline_latex, symbols, sin, cos, exp, log, I\n2737     >>> x, y, alpha = symbols('x y alpha')\n2738     >>> expr = sin(alpha*y) + exp(I*alpha) - cos(log(y))\n2739     >>> print(multiline_latex(x, expr))\n2740     \\begin{align*}\n2741     x = & e^{i \\alpha} \\\\\n2742     & + \\sin{\\left(\\alpha y \\right)} \\\\\n2743     & - \\cos{\\left(\\log{\\left(y \\right)} \\right)}\n2744     \\end{align*}\n2745 \n2746     Using at most two terms per line:\n2747     >>> print(multiline_latex(x, expr, 2))\n2748     \\begin{align*}\n2749     x = & e^{i \\alpha} + \\sin{\\left(\\alpha y \\right)} \\\\\n2750     & - \\cos{\\left(\\log{\\left(y \\right)} \\right)}\n2751     \\end{align*}\n2752 \n2753     Using ``eqnarray`` and dots:\n2754     >>> print(multiline_latex(x, expr, terms_per_line=2, environment=\"eqnarray\", use_dots=True))\n2755     \\begin{eqnarray}\n2756     x & = & e^{i \\alpha} + \\sin{\\left(\\alpha y \\right)} \\dots\\nonumber\\\\\n2757     & & - \\cos{\\left(\\log{\\left(y \\right)} \\right)}\n2758     \\end{eqnarray}\n2759 \n2760     Using ``IEEEeqnarray``:\n2761     >>> print(multiline_latex(x, expr, environment=\"IEEEeqnarray\"))\n2762     \\begin{IEEEeqnarray}{rCl}\n2763     x & = & e^{i \\alpha} \\nonumber\\\\\n2764     & & + \\sin{\\left(\\alpha y \\right)} \\nonumber\\\\\n2765     & & - \\cos{\\left(\\log{\\left(y \\right)} \\right)}\n2766     \\end{IEEEeqnarray}\n2767 \n2768     Notes\n2769     =====\n2770 \n2771     All optional parameters from ``latex`` can also be used.\n2772 \n2773     \"\"\"\n2774 \n2775     # Based on code from https://github.com/sympy/sympy/issues/3001\n2776     l = LatexPrinter(**settings)\n2777     if environment == \"eqnarray\":\n2778         result = r'\\begin{eqnarray}' + '\\n'\n2779         first_term = '& = &'\n2780         nonumber = r'\\nonumber'\n2781         end_term = '\\n\\\\end{eqnarray}'\n2782         doubleet = True\n2783     elif environment == \"IEEEeqnarray\":\n2784         result = r'\\begin{IEEEeqnarray}{rCl}' + '\\n'\n2785         first_term = '& = &'\n2786         nonumber = r'\\nonumber'\n2787         end_term = '\\n\\\\end{IEEEeqnarray}'\n2788         doubleet = True\n2789     elif environment == \"align*\":\n2790         result = r'\\begin{align*}' + '\\n'\n2791         first_term = '= &'\n2792         nonumber = ''\n2793         end_term =  '\\n\\\\end{align*}'\n2794         doubleet = False\n2795     else:\n2796         raise ValueError(\"Unknown environment: {}\".format(environment))\n2797     dots = ''\n2798     if use_dots:\n2799         dots=r'\\dots'\n2800     terms = rhs.as_ordered_terms()\n2801     n_terms = len(terms)\n2802     term_count = 1\n2803     for i in range(n_terms):\n2804         term = terms[i]\n2805         term_start = ''\n2806         term_end = ''\n2807         sign = '+'\n2808         if term_count > terms_per_line:\n2809             if doubleet:\n2810                 term_start = '& & '\n2811             else:\n2812                 term_start = '& '\n2813             term_count = 1\n2814         if term_count == terms_per_line:\n2815             # End of line\n2816             if i < n_terms-1:\n2817                 # There are terms remaining\n2818                 term_end = dots + nonumber + r'\\\\' + '\\n'\n2819             else:\n2820                 term_end = ''\n2821 \n2822         if term.as_ordered_factors()[0] == -1:\n2823             term = -1*term\n2824             sign = r'-'\n2825         if i == 0: # beginning\n2826             if sign == '+':\n2827                 sign = ''\n2828             result += r'{:s} {:s}{:s} {:s} {:s}'.format(l.doprint(lhs),\n2829                         first_term, sign, l.doprint(term), term_end)\n2830         else:\n2831             result += r'{:s}{:s} {:s} {:s}'.format(term_start, sign,\n2832                         l.doprint(term), term_end)\n2833         term_count += 1\n2834     result += end_term\n2835     return result\n",
        "intended_behavior": "The intended improvement involves the LaTeX printing system as a whole, specifically in how LaTeX equations are generated and integrated within the documentation (sympy/printing/latex.py and related documentation files). The goal is to create a more automated and error-resistant way of generating LaTeX equations, utilizing the existing LaTeX printing capabilities. This could involve formulating a standardized approach or utility that simplifies the insertion of LaTeX equations into docstrings, potentially reducing manual errors and improving maintainability. For instance, enhancing the LaTeX printer to automatically adapt expressions for documentation purposes or to handle common patterns more efficiently would be a key part of this improvement. This isn't fixing a single bug but proposing a systemic change to improve how equations are documented, aiming to preserve or enhance readability while making maintenance easier."
    }
]