[
    {
        "rel_file_path": "django/db/migrations/operations/models.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.2/django/db/migrations/operations/models.py",
        "start": 1,
        "end": 907,
        "class_name": null,
        "method_name": null,
        "code": "1 from django.db import models\n2 from django.db.migrations.operations.base import Operation\n3 from django.db.migrations.state import ModelState\n4 from django.db.models.options import normalize_together\n5 from django.utils.functional import cached_property\n6 \n7 from .fields import (\n8     AddField, AlterField, FieldOperation, RemoveField, RenameField,\n9 )\n10 from .utils import field_references, get_references, resolve_relation\n11 \n12 \n13 def _check_for_duplicates(arg_name, objs):\n14     used_vals = set()\n15     for val in objs:\n16         if val in used_vals:\n17             raise ValueError(\n18                 \"Found duplicate value %s in CreateModel %s argument.\" % (val, arg_name)\n19             )\n20         used_vals.add(val)\n21 \n22 \n23 class ModelOperation(Operation):\n24     def __init__(self, name):\n25         self.name = name\n26 \n27     @cached_property\n28     def name_lower(self):\n29         return self.name.lower()\n30 \n31     def references_model(self, name, app_label):\n32         return name.lower() == self.name_lower\n33 \n34     def reduce(self, operation, app_label):\n35         return (\n36             super().reduce(operation, app_label) or\n37             not operation.references_model(self.name, app_label)\n38         )\n39 \n40 \n41 class CreateModel(ModelOperation):\n42     \"\"\"Create a model's table.\"\"\"\n43 \n44     serialization_expand_args = ['fields', 'options', 'managers']\n45 \n46     def __init__(self, name, fields, options=None, bases=None, managers=None):\n47         self.fields = fields\n48         self.options = options or {}\n49         self.bases = bases or (models.Model,)\n50         self.managers = managers or []\n51         super().__init__(name)\n52         # Sanity-check that there are no duplicated field names, bases, or\n53         # manager names\n54         _check_for_duplicates('fields', (name for name, _ in self.fields))\n55         _check_for_duplicates('bases', (\n56             base._meta.label_lower if hasattr(base, '_meta') else\n57             base.lower() if isinstance(base, str) else base\n58             for base in self.bases\n59         ))\n60         _check_for_duplicates('managers', (name for name, _ in self.managers))\n61 \n62     def deconstruct(self):\n63         kwargs = {\n64             'name': self.name,\n65             'fields': self.fields,\n66         }\n67         if self.options:\n68             kwargs['options'] = self.options\n69         if self.bases and self.bases != (models.Model,):\n70             kwargs['bases'] = self.bases\n71         if self.managers and self.managers != [('objects', models.Manager())]:\n72             kwargs['managers'] = self.managers\n73         return (\n74             self.__class__.__qualname__,\n75             [],\n76             kwargs\n77         )\n78 \n79     def state_forwards(self, app_label, state):\n80         state.add_model(ModelState(\n81             app_label,\n82             self.name,\n83             list(self.fields),\n84             dict(self.options),\n85             tuple(self.bases),\n86             list(self.managers),\n87         ))\n88 \n89     def database_forwards(self, app_label, schema_editor, from_state, to_state):\n90         model = to_state.apps.get_model(app_label, self.name)\n91         if self.allow_migrate_model(schema_editor.connection.alias, model):\n92             schema_editor.create_model(model)\n93 \n94     def database_backwards(self, app_label, schema_editor, from_state, to_state):\n95         model = from_state.apps.get_model(app_label, self.name)\n96         if self.allow_migrate_model(schema_editor.connection.alias, model):\n97             schema_editor.delete_model(model)\n98 \n99     def describe(self):\n100         return \"Create %smodel %s\" % (\"proxy \" if self.options.get(\"proxy\", False) else \"\", self.name)\n101 \n102     @property\n103     def migration_name_fragment(self):\n104         return self.name_lower\n105 \n106     def references_model(self, name, app_label):\n107         name_lower = name.lower()\n108         if name_lower == self.name_lower:\n109             return True\n110 \n111         # Check we didn't inherit from the model\n112         reference_model_tuple = (app_label, name_lower)\n113         for base in self.bases:\n114             if (base is not models.Model and isinstance(base, (models.base.ModelBase, str)) and\n115                     resolve_relation(base, app_label) == reference_model_tuple):\n116                 return True\n117 \n118         # Check we have no FKs/M2Ms with it\n119         for _name, field in self.fields:\n120             if field_references((app_label, self.name_lower), field, reference_model_tuple):\n121                 return True\n122         return False\n123 \n124     def reduce(self, operation, app_label):\n125         if (isinstance(operation, DeleteModel) and\n126                 self.name_lower == operation.name_lower and\n127                 not self.options.get(\"proxy\", False)):\n128             return []\n129         elif isinstance(operation, RenameModel) and self.name_lower == operation.old_name_lower:\n130             return [\n131                 CreateModel(\n132                     operation.new_name,\n133                     fields=self.fields,\n134                     options=self.options,\n135                     bases=self.bases,\n136                     managers=self.managers,\n137                 ),\n138             ]\n139         elif isinstance(operation, AlterModelOptions) and self.name_lower == operation.name_lower:\n140             return [\n141                 CreateModel(\n142                     self.name,\n143                     fields=self.fields,\n144                     options={**self.options, **operation.options},\n145                     bases=self.bases,\n146                     managers=self.managers,\n147                 ),\n148             ]\n149         elif isinstance(operation, AlterTogetherOptionOperation) and self.name_lower == operation.name_lower:\n150             return [\n151                 CreateModel(\n152                     self.name,\n153                     fields=self.fields,\n154                     options={**self.options, **{operation.option_name: operation.option_value}},\n155                     bases=self.bases,\n156                     managers=self.managers,\n157                 ),\n158             ]\n159         elif isinstance(operation, AlterOrderWithRespectTo) and self.name_lower == operation.name_lower:\n160             return [\n161                 CreateModel(\n162                     self.name,\n163                     fields=self.fields,\n164                     options={**self.options, 'order_with_respect_to': operation.order_with_respect_to},\n165                     bases=self.bases,\n166                     managers=self.managers,\n167                 ),\n168             ]\n169         elif isinstance(operation, FieldOperation) and self.name_lower == operation.model_name_lower:\n170             if isinstance(operation, AddField):\n171                 return [\n172                     CreateModel(\n173                         self.name,\n174                         fields=self.fields + [(operation.name, operation.field)],\n175                         options=self.options,\n176                         bases=self.bases,\n177                         managers=self.managers,\n178                     ),\n179                 ]\n180             elif isinstance(operation, AlterField):\n181                 return [\n182                     CreateModel(\n183                         self.name,\n184                         fields=[\n185                             (n, operation.field if n == operation.name else v)\n186                             for n, v in self.fields\n187                         ],\n188                         options=self.options,\n189                         bases=self.bases,\n190                         managers=self.managers,\n191                     ),\n192                 ]\n193             elif isinstance(operation, RemoveField):\n194                 options = self.options.copy()\n195                 for option_name in ('unique_together', 'index_together'):\n196                     option = options.pop(option_name, None)\n197                     if option:\n198                         option = set(filter(bool, (\n199                             tuple(f for f in fields if f != operation.name_lower) for fields in option\n200                         )))\n201                         if option:\n202                             options[option_name] = option\n203                 order_with_respect_to = options.get('order_with_respect_to')\n204                 if order_with_respect_to == operation.name_lower:\n205                     del options['order_with_respect_to']\n206                 return [\n207                     CreateModel(\n208                         self.name,\n209                         fields=[\n210                             (n, v)\n211                             for n, v in self.fields\n212                             if n.lower() != operation.name_lower\n213                         ],\n214                         options=options,\n215                         bases=self.bases,\n216                         managers=self.managers,\n217                     ),\n218                 ]\n219             elif isinstance(operation, RenameField):\n220                 options = self.options.copy()\n221                 for option_name in ('unique_together', 'index_together'):\n222                     option = options.get(option_name)\n223                     if option:\n224                         options[option_name] = {\n225                             tuple(operation.new_name if f == operation.old_name else f for f in fields)\n226                             for fields in option\n227                         }\n228                 order_with_respect_to = options.get('order_with_respect_to')\n229                 if order_with_respect_to == operation.old_name:\n230                     options['order_with_respect_to'] = operation.new_name\n231                 return [\n232                     CreateModel(\n233                         self.name,\n234                         fields=[\n235                             (operation.new_name if n == operation.old_name else n, v)\n236                             for n, v in self.fields\n237                         ],\n238                         options=options,\n239                         bases=self.bases,\n240                         managers=self.managers,\n241                     ),\n242                 ]\n243         return super().reduce(operation, app_label)\n244 \n245 \n246 class DeleteModel(ModelOperation):\n247     \"\"\"Drop a model's table.\"\"\"\n248 \n249     def deconstruct(self):\n250         kwargs = {\n251             'name': self.name,\n252         }\n253         return (\n254             self.__class__.__qualname__,\n255             [],\n256             kwargs\n257         )\n258 \n259     def state_forwards(self, app_label, state):\n260         state.remove_model(app_label, self.name_lower)\n261 \n262     def database_forwards(self, app_label, schema_editor, from_state, to_state):\n263         model = from_state.apps.get_model(app_label, self.name)\n264         if self.allow_migrate_model(schema_editor.connection.alias, model):\n265             schema_editor.delete_model(model)\n266 \n267     def database_backwards(self, app_label, schema_editor, from_state, to_state):\n268         model = to_state.apps.get_model(app_label, self.name)\n269         if self.allow_migrate_model(schema_editor.connection.alias, model):\n270             schema_editor.create_model(model)\n271 \n272     def references_model(self, name, app_label):\n273         # The deleted model could be referencing the specified model through\n274         # related fields.\n275         return True\n276 \n277     def describe(self):\n278         return \"Delete model %s\" % self.name\n279 \n280     @property\n281     def migration_name_fragment(self):\n282         return 'delete_%s' % self.name_lower\n283 \n284 \n285 class RenameModel(ModelOperation):\n286     \"\"\"Rename a model.\"\"\"\n287 \n288     def __init__(self, old_name, new_name):\n289         self.old_name = old_name\n290         self.new_name = new_name\n291         super().__init__(old_name)\n292 \n293     @cached_property\n294     def old_name_lower(self):\n295         return self.old_name.lower()\n296 \n297     @cached_property\n298     def new_name_lower(self):\n299         return self.new_name.lower()\n300 \n301     def deconstruct(self):\n302         kwargs = {\n303             'old_name': self.old_name,\n304             'new_name': self.new_name,\n305         }\n306         return (\n307             self.__class__.__qualname__,\n308             [],\n309             kwargs\n310         )\n311 \n312     def state_forwards(self, app_label, state):\n313         # Add a new model.\n314         renamed_model = state.models[app_label, self.old_name_lower].clone()\n315         renamed_model.name = self.new_name\n316         state.models[app_label, self.new_name_lower] = renamed_model\n317         # Repoint all fields pointing to the old model to the new one.\n318         old_model_tuple = (app_label, self.old_name_lower)\n319         new_remote_model = '%s.%s' % (app_label, self.new_name)\n320         to_reload = set()\n321         for model_state, name, field, reference in get_references(state, old_model_tuple):\n322             changed_field = None\n323             if reference.to:\n324                 changed_field = field.clone()\n325                 changed_field.remote_field.model = new_remote_model\n326             if reference.through:\n327                 if changed_field is None:\n328                     changed_field = field.clone()\n329                 changed_field.remote_field.through = new_remote_model\n330             if changed_field:\n331                 model_state.fields[name] = changed_field\n332                 to_reload.add((model_state.app_label, model_state.name_lower))\n333         # Reload models related to old model before removing the old model.\n334         state.reload_models(to_reload, delay=True)\n335         # Remove the old model.\n336         state.remove_model(app_label, self.old_name_lower)\n337         state.reload_model(app_label, self.new_name_lower, delay=True)\n338 \n339     def database_forwards(self, app_label, schema_editor, from_state, to_state):\n340         new_model = to_state.apps.get_model(app_label, self.new_name)\n341         if self.allow_migrate_model(schema_editor.connection.alias, new_model):\n342             old_model = from_state.apps.get_model(app_label, self.old_name)\n343             # Move the main table\n344             schema_editor.alter_db_table(\n345                 new_model,\n346                 old_model._meta.db_table,\n347                 new_model._meta.db_table,\n348             )\n349             # Alter the fields pointing to us\n350             for related_object in old_model._meta.related_objects:\n351                 if related_object.related_model == old_model:\n352                     model = new_model\n353                     related_key = (app_label, self.new_name_lower)\n354                 else:\n355                     model = related_object.related_model\n356                     related_key = (\n357                         related_object.related_model._meta.app_label,\n358                         related_object.related_model._meta.model_name,\n359                     )\n360                 to_field = to_state.apps.get_model(\n361                     *related_key\n362                 )._meta.get_field(related_object.field.name)\n363                 schema_editor.alter_field(\n364                     model,\n365                     related_object.field,\n366                     to_field,\n367                 )\n368             # Rename M2M fields whose name is based on this model's name.\n369             fields = zip(old_model._meta.local_many_to_many, new_model._meta.local_many_to_many)\n370             for (old_field, new_field) in fields:\n371                 # Skip self-referential fields as these are renamed above.\n372                 if new_field.model == new_field.related_model or not new_field.remote_field.through._meta.auto_created:\n373                     continue\n374                 # Rename the M2M table that's based on this model's name.\n375                 old_m2m_model = old_field.remote_field.through\n376                 new_m2m_model = new_field.remote_field.through\n377                 schema_editor.alter_db_table(\n378                     new_m2m_model,\n379                     old_m2m_model._meta.db_table,\n380                     new_m2m_model._meta.db_table,\n381                 )\n382                 # Rename the column in the M2M table that's based on this\n383                 # model's name.\n384                 schema_editor.alter_field(\n385                     new_m2m_model,\n386                     old_m2m_model._meta.get_field(old_model._meta.model_name),\n387                     new_m2m_model._meta.get_field(new_model._meta.model_name),\n388                 )\n389 \n390     def database_backwards(self, app_label, schema_editor, from_state, to_state):\n391         self.new_name_lower, self.old_name_lower = self.old_name_lower, self.new_name_lower\n392         self.new_name, self.old_name = self.old_name, self.new_name\n393 \n394         self.database_forwards(app_label, schema_editor, from_state, to_state)\n395 \n396         self.new_name_lower, self.old_name_lower = self.old_name_lower, self.new_name_lower\n397         self.new_name, self.old_name = self.old_name, self.new_name\n398 \n399     def references_model(self, name, app_label):\n400         return (\n401             name.lower() == self.old_name_lower or\n402             name.lower() == self.new_name_lower\n403         )\n404 \n405     def describe(self):\n406         return \"Rename model %s to %s\" % (self.old_name, self.new_name)\n407 \n408     @property\n409     def migration_name_fragment(self):\n410         return 'rename_%s_%s' % (self.old_name_lower, self.new_name_lower)\n411 \n412     def reduce(self, operation, app_label):\n413         if (isinstance(operation, RenameModel) and\n414                 self.new_name_lower == operation.old_name_lower):\n415             return [\n416                 RenameModel(\n417                     self.old_name,\n418                     operation.new_name,\n419                 ),\n420             ]\n421         # Skip `ModelOperation.reduce` as we want to run `references_model`\n422         # against self.new_name.\n423         return (\n424             super(ModelOperation, self).reduce(operation, app_label) or\n425             not operation.references_model(self.new_name, app_label)\n426         )\n427 \n428 \n429 class ModelOptionOperation(ModelOperation):\n430     def reduce(self, operation, app_label):\n431         if isinstance(operation, (self.__class__, DeleteModel)) and self.name_lower == operation.name_lower:\n432             return [operation]\n433         return super().reduce(operation, app_label)\n434 \n435 \n436 class AlterModelTable(ModelOptionOperation):\n437     \"\"\"Rename a model's table.\"\"\"\n438 \n439     def __init__(self, name, table):\n440         self.table = table\n441         super().__init__(name)\n442 \n443     def deconstruct(self):\n444         kwargs = {\n445             'name': self.name,\n446             'table': self.table,\n447         }\n448         return (\n449             self.__class__.__qualname__,\n450             [],\n451             kwargs\n452         )\n453 \n454     def state_forwards(self, app_label, state):\n455         state.models[app_label, self.name_lower].options[\"db_table\"] = self.table\n456         state.reload_model(app_label, self.name_lower, delay=True)\n457 \n458     def database_forwards(self, app_label, schema_editor, from_state, to_state):\n459         new_model = to_state.apps.get_model(app_label, self.name)\n460         if self.allow_migrate_model(schema_editor.connection.alias, new_model):\n461             old_model = from_state.apps.get_model(app_label, self.name)\n462             schema_editor.alter_db_table(\n463                 new_model,\n464                 old_model._meta.db_table,\n465                 new_model._meta.db_table,\n466             )\n467             # Rename M2M fields whose name is based on this model's db_table\n468             for (old_field, new_field) in zip(old_model._meta.local_many_to_many, new_model._meta.local_many_to_many):\n469                 if new_field.remote_field.through._meta.auto_created:\n470                     schema_editor.alter_db_table(\n471                         new_field.remote_field.through,\n472                         old_field.remote_field.through._meta.db_table,\n473                         new_field.remote_field.through._meta.db_table,\n474                     )\n475 \n476     def database_backwards(self, app_label, schema_editor, from_state, to_state):\n477         return self.database_forwards(app_label, schema_editor, from_state, to_state)\n478 \n479     def describe(self):\n480         return \"Rename table for %s to %s\" % (\n481             self.name,\n482             self.table if self.table is not None else \"(default)\"\n483         )\n484 \n485     @property\n486     def migration_name_fragment(self):\n487         return 'alter_%s_table' % self.name_lower\n488 \n489 \n490 class AlterTogetherOptionOperation(ModelOptionOperation):\n491     option_name = None\n492 \n493     def __init__(self, name, option_value):\n494         if option_value:\n495             option_value = set(normalize_together(option_value))\n496         setattr(self, self.option_name, option_value)\n497         super().__init__(name)\n498 \n499     @cached_property\n500     def option_value(self):\n501         return getattr(self, self.option_name)\n502 \n503     def deconstruct(self):\n504         kwargs = {\n505             'name': self.name,\n506             self.option_name: self.option_value,\n507         }\n508         return (\n509             self.__class__.__qualname__,\n510             [],\n511             kwargs\n512         )\n513 \n514     def state_forwards(self, app_label, state):\n515         model_state = state.models[app_label, self.name_lower]\n516         model_state.options[self.option_name] = self.option_value\n517         state.reload_model(app_label, self.name_lower, delay=True)\n518 \n519     def database_forwards(self, app_label, schema_editor, from_state, to_state):\n520         new_model = to_state.apps.get_model(app_label, self.name)\n521         if self.allow_migrate_model(schema_editor.connection.alias, new_model):\n522             old_model = from_state.apps.get_model(app_label, self.name)\n523             alter_together = getattr(schema_editor, 'alter_%s' % self.option_name)\n524             alter_together(\n525                 new_model,\n526                 getattr(old_model._meta, self.option_name, set()),\n527                 getattr(new_model._meta, self.option_name, set()),\n528             )\n529 \n530     def database_backwards(self, app_label, schema_editor, from_state, to_state):\n531         return self.database_forwards(app_label, schema_editor, from_state, to_state)\n532 \n533     def references_field(self, model_name, name, app_label):\n534         return (\n535             self.references_model(model_name, app_label) and\n536             (\n537                 not self.option_value or\n538                 any((name in fields) for fields in self.option_value)\n539             )\n540         )\n541 \n542     def describe(self):\n543         return \"Alter %s for %s (%s constraint(s))\" % (self.option_name, self.name, len(self.option_value or ''))\n544 \n545     @property\n546     def migration_name_fragment(self):\n547         return 'alter_%s_%s' % (self.name_lower, self.option_name)\n548 \n549 \n550 class AlterUniqueTogether(AlterTogetherOptionOperation):\n551     \"\"\"\n552     Change the value of unique_together to the target one.\n553     Input value of unique_together must be a set of tuples.\n554     \"\"\"\n555     option_name = 'unique_together'\n556 \n557     def __init__(self, name, unique_together):\n558         super().__init__(name, unique_together)\n559 \n560 \n561 class AlterIndexTogether(AlterTogetherOptionOperation):\n562     \"\"\"\n563     Change the value of index_together to the target one.\n564     Input value of index_together must be a set of tuples.\n565     \"\"\"\n566     option_name = \"index_together\"\n567 \n568     def __init__(self, name, index_together):\n569         super().__init__(name, index_together)\n570 \n571 \n572 class AlterOrderWithRespectTo(ModelOptionOperation):\n573     \"\"\"Represent a change with the order_with_respect_to option.\"\"\"\n574 \n575     option_name = 'order_with_respect_to'\n576 \n577     def __init__(self, name, order_with_respect_to):\n578         self.order_with_respect_to = order_with_respect_to\n579         super().__init__(name)\n580 \n581     def deconstruct(self):\n582         kwargs = {\n583             'name': self.name,\n584             'order_with_respect_to': self.order_with_respect_to,\n585         }\n586         return (\n587             self.__class__.__qualname__,\n588             [],\n589             kwargs\n590         )\n591 \n592     def state_forwards(self, app_label, state):\n593         model_state = state.models[app_label, self.name_lower]\n594         model_state.options['order_with_respect_to'] = self.order_with_respect_to\n595         state.reload_model(app_label, self.name_lower, delay=True)\n596 \n597     def database_forwards(self, app_label, schema_editor, from_state, to_state):\n598         to_model = to_state.apps.get_model(app_label, self.name)\n599         if self.allow_migrate_model(schema_editor.connection.alias, to_model):\n600             from_model = from_state.apps.get_model(app_label, self.name)\n601             # Remove a field if we need to\n602             if from_model._meta.order_with_respect_to and not to_model._meta.order_with_respect_to:\n603                 schema_editor.remove_field(from_model, from_model._meta.get_field(\"_order\"))\n604             # Add a field if we need to (altering the column is untouched as\n605             # it's likely a rename)\n606             elif to_model._meta.order_with_respect_to and not from_model._meta.order_with_respect_to:\n607                 field = to_model._meta.get_field(\"_order\")\n608                 if not field.has_default():\n609                     field.default = 0\n610                 schema_editor.add_field(\n611                     from_model,\n612                     field,\n613                 )\n614 \n615     def database_backwards(self, app_label, schema_editor, from_state, to_state):\n616         self.database_forwards(app_label, schema_editor, from_state, to_state)\n617 \n618     def references_field(self, model_name, name, app_label):\n619         return (\n620             self.references_model(model_name, app_label) and\n621             (\n622                 self.order_with_respect_to is None or\n623                 name == self.order_with_respect_to\n624             )\n625         )\n626 \n627     def describe(self):\n628         return \"Set order_with_respect_to on %s to %s\" % (self.name, self.order_with_respect_to)\n629 \n630     @property\n631     def migration_name_fragment(self):\n632         return 'alter_%s_order_with_respect_to' % self.name_lower\n633 \n634 \n635 class AlterModelOptions(ModelOptionOperation):\n636     \"\"\"\n637     Set new model options that don't directly affect the database schema\n638     (like verbose_name, permissions, ordering). Python code in migrations\n639     may still need them.\n640     \"\"\"\n641 \n642     # Model options we want to compare and preserve in an AlterModelOptions op\n643     ALTER_OPTION_KEYS = [\n644         \"base_manager_name\",\n645         \"default_manager_name\",\n646         \"default_related_name\",\n647         \"get_latest_by\",\n648         \"managed\",\n649         \"ordering\",\n650         \"permissions\",\n651         \"default_permissions\",\n652         \"select_on_save\",\n653         \"verbose_name\",\n654         \"verbose_name_plural\",\n655     ]\n656 \n657     def __init__(self, name, options):\n658         self.options = options\n659         super().__init__(name)\n660 \n661     def deconstruct(self):\n662         kwargs = {\n663             'name': self.name,\n664             'options': self.options,\n665         }\n666         return (\n667             self.__class__.__qualname__,\n668             [],\n669             kwargs\n670         )\n671 \n672     def state_forwards(self, app_label, state):\n673         model_state = state.models[app_label, self.name_lower]\n674         model_state.options = {**model_state.options, **self.options}\n675         for key in self.ALTER_OPTION_KEYS:\n676             if key not in self.options:\n677                 model_state.options.pop(key, False)\n678         state.reload_model(app_label, self.name_lower, delay=True)\n679 \n680     def database_forwards(self, app_label, schema_editor, from_state, to_state):\n681         pass\n682 \n683     def database_backwards(self, app_label, schema_editor, from_state, to_state):\n684         pass\n685 \n686     def describe(self):\n687         return \"Change Meta options on %s\" % self.name\n688 \n689     @property\n690     def migration_name_fragment(self):\n691         return 'alter_%s_options' % self.name_lower\n692 \n693 \n694 class AlterModelManagers(ModelOptionOperation):\n695     \"\"\"Alter the model's managers.\"\"\"\n696 \n697     serialization_expand_args = ['managers']\n698 \n699     def __init__(self, name, managers):\n700         self.managers = managers\n701         super().__init__(name)\n702 \n703     def deconstruct(self):\n704         return (\n705             self.__class__.__qualname__,\n706             [self.name, self.managers],\n707             {}\n708         )\n709 \n710     def state_forwards(self, app_label, state):\n711         model_state = state.models[app_label, self.name_lower]\n712         model_state.managers = list(self.managers)\n713         state.reload_model(app_label, self.name_lower, delay=True)\n714 \n715     def database_forwards(self, app_label, schema_editor, from_state, to_state):\n716         pass\n717 \n718     def database_backwards(self, app_label, schema_editor, from_state, to_state):\n719         pass\n720 \n721     def describe(self):\n722         return \"Change managers on %s\" % self.name\n723 \n724     @property\n725     def migration_name_fragment(self):\n726         return 'alter_%s_managers' % self.name_lower\n727 \n728 \n729 class IndexOperation(Operation):\n730     option_name = 'indexes'\n731 \n732     @cached_property\n733     def model_name_lower(self):\n734         return self.model_name.lower()\n735 \n736 \n737 class AddIndex(IndexOperation):\n738     \"\"\"Add an index on a model.\"\"\"\n739 \n740     def __init__(self, model_name, index):\n741         self.model_name = model_name\n742         if not index.name:\n743             raise ValueError(\n744                 \"Indexes passed to AddIndex operations require a name \"\n745                 \"argument. %r doesn't have one.\" % index\n746             )\n747         self.index = index\n748 \n749     def state_forwards(self, app_label, state):\n750         model_state = state.models[app_label, self.model_name_lower]\n751         model_state.options[self.option_name] = [*model_state.options[self.option_name], self.index.clone()]\n752         state.reload_model(app_label, self.model_name_lower, delay=True)\n753 \n754     def database_forwards(self, app_label, schema_editor, from_state, to_state):\n755         model = to_state.apps.get_model(app_label, self.model_name)\n756         if self.allow_migrate_model(schema_editor.connection.alias, model):\n757             schema_editor.add_index(model, self.index)\n758 \n759     def database_backwards(self, app_label, schema_editor, from_state, to_state):\n760         model = from_state.apps.get_model(app_label, self.model_name)\n761         if self.allow_migrate_model(schema_editor.connection.alias, model):\n762             schema_editor.remove_index(model, self.index)\n763 \n764     def deconstruct(self):\n765         kwargs = {\n766             'model_name': self.model_name,\n767             'index': self.index,\n768         }\n769         return (\n770             self.__class__.__qualname__,\n771             [],\n772             kwargs,\n773         )\n774 \n775     def describe(self):\n776         return 'Create index %s on field(s) %s of model %s' % (\n777             self.index.name,\n778             ', '.join(self.index.fields),\n779             self.model_name,\n780         )\n781 \n782     @property\n783     def migration_name_fragment(self):\n784         return '%s_%s' % (self.model_name_lower, self.index.name.lower())\n785 \n786 \n787 class RemoveIndex(IndexOperation):\n788     \"\"\"Remove an index from a model.\"\"\"\n789 \n790     def __init__(self, model_name, name):\n791         self.model_name = model_name\n792         self.name = name\n793 \n794     def state_forwards(self, app_label, state):\n795         model_state = state.models[app_label, self.model_name_lower]\n796         indexes = model_state.options[self.option_name]\n797         model_state.options[self.option_name] = [idx for idx in indexes if idx.name != self.name]\n798         state.reload_model(app_label, self.model_name_lower, delay=True)\n799 \n800     def database_forwards(self, app_label, schema_editor, from_state, to_state):\n801         model = from_state.apps.get_model(app_label, self.model_name)\n802         if self.allow_migrate_model(schema_editor.connection.alias, model):\n803             from_model_state = from_state.models[app_label, self.model_name_lower]\n804             index = from_model_state.get_index_by_name(self.name)\n805             schema_editor.remove_index(model, index)\n806 \n807     def database_backwards(self, app_label, schema_editor, from_state, to_state):\n808         model = to_state.apps.get_model(app_label, self.model_name)\n809         if self.allow_migrate_model(schema_editor.connection.alias, model):\n810             to_model_state = to_state.models[app_label, self.model_name_lower]\n811             index = to_model_state.get_index_by_name(self.name)\n812             schema_editor.add_index(model, index)\n813 \n814     def deconstruct(self):\n815         kwargs = {\n816             'model_name': self.model_name,\n817             'name': self.name,\n818         }\n819         return (\n820             self.__class__.__qualname__,\n821             [],\n822             kwargs,\n823         )\n824 \n825     def describe(self):\n826         return 'Remove index %s from %s' % (self.name, self.model_name)\n827 \n828     @property\n829     def migration_name_fragment(self):\n830         return 'remove_%s_%s' % (self.model_name_lower, self.name.lower())\n831 \n832 \n833 class AddConstraint(IndexOperation):\n834     option_name = 'constraints'\n835 \n836     def __init__(self, model_name, constraint):\n837         self.model_name = model_name\n838         self.constraint = constraint\n839 \n840     def state_forwards(self, app_label, state):\n841         model_state = state.models[app_label, self.model_name_lower]\n842         model_state.options[self.option_name] = [*model_state.options[self.option_name], self.constraint]\n843         state.reload_model(app_label, self.model_name_lower, delay=True)\n844 \n845     def database_forwards(self, app_label, schema_editor, from_state, to_state):\n846         model = to_state.apps.get_model(app_label, self.model_name)\n847         if self.allow_migrate_model(schema_editor.connection.alias, model):\n848             schema_editor.add_constraint(model, self.constraint)\n849 \n850     def database_backwards(self, app_label, schema_editor, from_state, to_state):\n851         model = to_state.apps.get_model(app_label, self.model_name)\n852         if self.allow_migrate_model(schema_editor.connection.alias, model):\n853             schema_editor.remove_constraint(model, self.constraint)\n854 \n855     def deconstruct(self):\n856         return self.__class__.__name__, [], {\n857             'model_name': self.model_name,\n858             'constraint': self.constraint,\n859         }\n860 \n861     def describe(self):\n862         return 'Create constraint %s on model %s' % (self.constraint.name, self.model_name)\n863 \n864     @property\n865     def migration_name_fragment(self):\n866         return '%s_%s' % (self.model_name_lower, self.constraint.name.lower())\n867 \n868 \n869 class RemoveConstraint(IndexOperation):\n870     option_name = 'constraints'\n871 \n872     def __init__(self, model_name, name):\n873         self.model_name = model_name\n874         self.name = name\n875 \n876     def state_forwards(self, app_label, state):\n877         model_state = state.models[app_label, self.model_name_lower]\n878         constraints = model_state.options[self.option_name]\n879         model_state.options[self.option_name] = [c for c in constraints if c.name != self.name]\n880         state.reload_model(app_label, self.model_name_lower, delay=True)\n881 \n882     def database_forwards(self, app_label, schema_editor, from_state, to_state):\n883         model = to_state.apps.get_model(app_label, self.model_name)\n884         if self.allow_migrate_model(schema_editor.connection.alias, model):\n885             from_model_state = from_state.models[app_label, self.model_name_lower]\n886             constraint = from_model_state.get_constraint_by_name(self.name)\n887             schema_editor.remove_constraint(model, constraint)\n888 \n889     def database_backwards(self, app_label, schema_editor, from_state, to_state):\n890         model = to_state.apps.get_model(app_label, self.model_name)\n891         if self.allow_migrate_model(schema_editor.connection.alias, model):\n892             to_model_state = to_state.models[app_label, self.model_name_lower]\n893             constraint = to_model_state.get_constraint_by_name(self.name)\n894             schema_editor.add_constraint(model, constraint)\n895 \n896     def deconstruct(self):\n897         return self.__class__.__name__, [], {\n898             'model_name': self.model_name,\n899             'name': self.name,\n900         }\n901 \n902     def describe(self):\n903         return 'Remove constraint %s from model %s' % (self.name, self.model_name)\n904 \n905     @property\n906     def migration_name_fragment(self):\n907         return 'remove_%s_%s' % (self.model_name_lower, self.name.lower())\n",
        "intended_behavior": "The migration operation handling code should ensure that any operations relying on dynamically added fields like `_order` are sequenced in a way that these fields are recognized and handled correctly by the time indexing operations are applied. This could involve altering the migration operation sequence or implementing checks to defer index creation involving the `_order` field until after it is formally added or recognized by the ORM layer."
    }
]