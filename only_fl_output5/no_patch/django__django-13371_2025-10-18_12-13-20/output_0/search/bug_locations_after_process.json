[
    {
        "rel_file_path": "django/db/models/query.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.2/django/db/models/query.py",
        "start": 153,
        "end": 156,
        "class_name": "NamedValuesListIterable",
        "method_name": "create_namedtuple_class",
        "code": "153     def create_namedtuple_class(*names):\n154         # Cache namedtuple() with @lru_cache() since it's too slow to be\n155         # called for every QuerySet evaluation.\n156         return namedtuple('Row', names)\n",
        "intended_behavior": "The methods responsible for generating and iterating over named tuples need to ensure these objects are pickleable. This can be achieved by either ensuring the base namedtuple class used within includes custom pickling methods or by employing a wrapper or factory pattern that explicitly supports pickling of dynamically created named tuples. The overall goal is to preserve the functionality that allows to return informative, named field values through iteration while ensuring those returned objects are compatible with Python's pickle protocol for caching or other serialization needs."
    },
    {
        "rel_file_path": "django/db/models/query.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.2/django/db/models/query.py",
        "start": 145,
        "end": 168,
        "class_name": "NamedValuesListIterable",
        "method_name": null,
        "code": "145 class NamedValuesListIterable(ValuesListIterable):\n146     \"\"\"\n147     Iterable returned by QuerySet.values_list(named=True) that yields a\n148     namedtuple for each row.\n149     \"\"\"\n150 \n151     @staticmethod\n152     @lru_cache()\n153     def create_namedtuple_class(*names):\n154         # Cache namedtuple() with @lru_cache() since it's too slow to be\n155         # called for every QuerySet evaluation.\n156         return namedtuple('Row', names)\n157 \n158     def __iter__(self):\n159         queryset = self.queryset\n160         if queryset._fields:\n161             names = queryset._fields\n162         else:\n163             query = queryset.query\n164             names = [*query.extra_select, *query.values_select, *query.annotation_select]\n165         tuple_class = self.create_namedtuple_class(*names)\n166         new = tuple.__new__\n167         for row in super().__iter__():\n168             yield new(tuple_class, row)\n",
        "intended_behavior": "This class provides additional context to the issue."
    },
    {
        "rel_file_path": "django/db/models/query.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.2/django/db/models/query.py",
        "start": 158,
        "end": 168,
        "class_name": "NamedValuesListIterable",
        "method_name": "__iter__",
        "code": "158     def __iter__(self):\n159         queryset = self.queryset\n160         if queryset._fields:\n161             names = queryset._fields\n162         else:\n163             query = queryset.query\n164             names = [*query.extra_select, *query.values_select, *query.annotation_select]\n165         tuple_class = self.create_namedtuple_class(*names)\n166         new = tuple.__new__\n167         for row in super().__iter__():\n168             yield new(tuple_class, row)\n",
        "intended_behavior": "The methods responsible for generating and iterating over named tuples need to ensure these objects are pickleable. This can be achieved by either ensuring the base namedtuple class used within includes custom pickling methods or by employing a wrapper or factory pattern that explicitly supports pickling of dynamically created named tuples. The overall goal is to preserve the functionality that allows to return informative, named field values through iteration while ensuring those returned objects are compatible with Python's pickle protocol for caching or other serialization needs."
    },
    {
        "rel_file_path": "django/db/models/query.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.2/django/db/models/query.py",
        "start": 145,
        "end": 168,
        "class_name": "NamedValuesListIterable",
        "method_name": null,
        "code": "145 class NamedValuesListIterable(ValuesListIterable):\n146     \"\"\"\n147     Iterable returned by QuerySet.values_list(named=True) that yields a\n148     namedtuple for each row.\n149     \"\"\"\n150 \n151     @staticmethod\n152     @lru_cache()\n153     def create_namedtuple_class(*names):\n154         # Cache namedtuple() with @lru_cache() since it's too slow to be\n155         # called for every QuerySet evaluation.\n156         return namedtuple('Row', names)\n157 \n158     def __iter__(self):\n159         queryset = self.queryset\n160         if queryset._fields:\n161             names = queryset._fields\n162         else:\n163             query = queryset.query\n164             names = [*query.extra_select, *query.values_select, *query.annotation_select]\n165         tuple_class = self.create_namedtuple_class(*names)\n166         new = tuple.__new__\n167         for row in super().__iter__():\n168             yield new(tuple_class, row)\n",
        "intended_behavior": "This class provides additional context to the issue."
    }
]