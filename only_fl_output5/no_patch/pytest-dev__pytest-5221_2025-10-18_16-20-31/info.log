2025-10-18 16:20:31.098 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-18 16:20:33.229 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=137, output_tokens=12, cost=0.001730
2025-10-18 16:20:33.230 | INFO     | Test agent decides that the issue statement does not contain reproduction steps; skipping reproducer tracing
2025-10-18 16:20:33.234 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 16:20:41.633 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=446, output_tokens=250, cost=0.011960
2025-10-18 16:20:41.639 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 16:20:44.116 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=604, output_tokens=45, cost=0.007390
2025-10-18 16:20:44.118 | DEBUG    | Extracted a valid json.
2025-10-18 16:20:44.118 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_method(\"parse_options\")",
        "search_code(\"def pytest_addoption\")",
        "search_class(\"FixtureDef\")"
    ],
    "bug_locations": []
}
2025-10-18 16:20:44.187 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-18 16:20:44.187 | DEBUG    | <Agent search> Analyzing search results.
2025-10-18 16:21:00.596 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1456, output_tokens=683, cost=0.035050
2025-10-18 16:21:00.603 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 16:21:07.245 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2355, output_tokens=280, cost=0.031950
2025-10-18 16:21:07.251 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 16:21:12.436 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=634, output_tokens=234, cost=0.013360
2025-10-18 16:21:12.437 | DEBUG    | Extracted a valid json.
2025-10-18 16:21:12.443 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations":[
        {
            "file": "src/_pytest/python.py",
            "class": "",
            "method": "",
            "intended_behavior": "The code responsible for processing the `--fixtures` command-line argument should be extended to include the fixture's scope in the output. This extension should preserve the current functionality of listing available fixtures but additionally display each fixture's scope (e.g., function, class, module, package, or session) alongside its name and docstring in the output."
        },
        {
            "file": "src/_pytest/fixtures.py",
            "class": "FixtureDef",
            "method": "",
            "intended_behavior": "While the `FixtureDef` class may not require a bug fix per se, any enhancements to support the new feature (displaying fixture scopes) would likely involve accessing the `scope` attribute of this class's instances. The modification would ensure that wherever fixture details are being prepared for the `--fixtures` output, the scope is included by retrieving it from the `FixtureDef` instances corresponding to each fixture."
        }
    ]
}
2025-10-18 16:21:12.455 | DEBUG    | Bug location extracted successfully: [<file>src/_pytest/python.py</file>
<class>None</class>
<method>None</method>
<code>
1 """ Python test discovery, setup and run of test functions. """
2 from __future__ import absolute_import
3 from __future__ import division
4 from __future__ import print_function
5 
6 import collections
7 import fnmatch
8 import inspect
9 import os
10 import sys
11 import warnings
12 from functools import partial
13 from textwrap import dedent
14 
15 import py
16 import six
17 
18 import _pytest
19 from _pytest import deprecated
20 from _pytest import fixtures
21 from _pytest import nodes
22 from _pytest._code import filter_traceback
23 from _pytest.compat import ascii_escaped
24 from _pytest.compat import enum
25 from _pytest.compat import get_default_arg_names
26 from _pytest.compat import get_real_func
27 from _pytest.compat import getfslineno
28 from _pytest.compat import getimfunc
29 from _pytest.compat import getlocation
30 from _pytest.compat import is_generator
31 from _pytest.compat import isclass
32 from _pytest.compat import isfunction
33 from _pytest.compat import NoneType
34 from _pytest.compat import NOTSET
35 from _pytest.compat import REGEX_TYPE
36 from _pytest.compat import safe_getattr
37 from _pytest.compat import safe_isclass
38 from _pytest.compat import safe_str
39 from _pytest.compat import STRING_TYPES
40 from _pytest.config import hookimpl
41 from _pytest.main import FSHookProxy
42 from _pytest.mark import MARK_GEN
43 from _pytest.mark.structures import get_unpacked_marks
44 from _pytest.mark.structures import normalize_mark_list
45 from _pytest.outcomes import fail
46 from _pytest.outcomes import skip
47 from _pytest.pathlib import parts
48 from _pytest.warning_types import PytestCollectionWarning
49 from _pytest.warning_types import PytestUnhandledCoroutineWarning
50 
51 
52 def pyobj_property(name):
53     def get(self):
54         node = self.getparent(getattr(__import__("pytest"), name))
55         if node is not None:
56             return node.obj
57 
58     doc = "python %s object this node was collected from (can be None)." % (
59         name.lower(),
60     )
61     return property(get, None, None, doc)
62 
63 
64 def pytest_addoption(parser):
65     group = parser.getgroup("general")
66     group.addoption(
67         "--fixtures",
68         "--funcargs",
69         action="store_true",
70         dest="showfixtures",
71         default=False,
72         help="show available fixtures, sorted by plugin appearance "
73         "(fixtures with leading '_' are only shown with '-v')",
74     )
75     group.addoption(
76         "--fixtures-per-test",
77         action="store_true",
78         dest="show_fixtures_per_test",
79         default=False,
80         help="show fixtures per test",
81     )
82     parser.addini(
83         "usefixtures",
84         type="args",
85         default=[],
86         help="list of default fixtures to be used with this project",
87     )
88     parser.addini(
89         "python_files",
90         type="args",
91         default=["test_*.py", "*_test.py"],
92         help="glob-style file patterns for Python test module discovery",
93     )
94     parser.addini(
95         "python_classes",
96         type="args",
97         default=["Test"],
98         help="prefixes or glob names for Python test class discovery",
99     )
100     parser.addini(
101         "python_functions",
102         type="args",
103         default=["test"],
104         help="prefixes or glob names for Python test function and method discovery",
105     )
106     parser.addini(
107         "disable_test_id_escaping_and_forfeit_all_rights_to_community_support",
108         type="bool",
109         default=False,
110         help="disable string escape non-ascii characters, might cause unwanted "
111         "side effects(use at your own risk)",
112     )
113 
114     group.addoption(
115         "--import-mode",
116         default="prepend",
117         choices=["prepend", "append"],
118         dest="importmode",
119         help="prepend/append to sys.path when importing test modules, "
120         "default is to prepend.",
121     )
122 
123 
124 def pytest_cmdline_main(config):
125     if config.option.showfixtures:
126         showfixtures(config)
127         return 0
128     if config.option.show_fixtures_per_test:
129         show_fixtures_per_test(config)
130         return 0
131 
132 
133 def pytest_generate_tests(metafunc):
134     # those alternative spellings are common - raise a specific error to alert
135     # the user
136     alt_spellings = ["parameterize", "parametrise", "parameterise"]
137     for mark_name in alt_spellings:
138         if metafunc.definition.get_closest_marker(mark_name):
139             msg = "{0} has '{1}' mark, spelling should be 'parametrize'"
140             fail(msg.format(metafunc.function.__name__, mark_name), pytrace=False)
141     for marker in metafunc.definition.iter_markers(name="parametrize"):
142         metafunc.parametrize(*marker.args, **marker.kwargs)
143 
144 
145 def pytest_configure(config):
146     config.addinivalue_line(
147         "markers",
148         "parametrize(argnames, argvalues): call a test function multiple "
149         "times passing in different arguments in turn. argvalues generally "
150         "needs to be a list of values if argnames specifies only one name "
151         "or a list of tuples of values if argnames specifies multiple names. "
152         "Example: @parametrize('arg1', [1,2]) would lead to two calls of the "
153         "decorated test function, one with arg1=1 and another with arg1=2."
154         "see https://docs.pytest.org/en/latest/parametrize.html for more info "
155         "and examples.",
156     )
157     config.addinivalue_line(
158         "markers",
159         "usefixtures(fixturename1, fixturename2, ...): mark tests as needing "
160         "all of the specified fixtures. see "
161         "https://docs.pytest.org/en/latest/fixture.html#usefixtures ",
162     )
163 
164 
165 @hookimpl(trylast=True)
166 def pytest_pyfunc_call(pyfuncitem):
167     testfunction = pyfuncitem.obj
168     iscoroutinefunction = getattr(inspect, "iscoroutinefunction", None)
169     if iscoroutinefunction is not None and iscoroutinefunction(testfunction):
170         msg = "Coroutine functions are not natively supported and have been skipped.\n"
171         msg += "You need to install a suitable plugin for your async framework, for example:\n"
172         msg += "  - pytest-asyncio\n"
173         msg += "  - pytest-trio\n"
174         msg += "  - pytest-tornasync"
175         warnings.warn(PytestUnhandledCoroutineWarning(msg.format(pyfuncitem.nodeid)))
176         skip(msg="coroutine function and no async plugin installed (see warnings)")
177     funcargs = pyfuncitem.funcargs
178     testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
179     testfunction(**testargs)
180     return True
181 
182 
183 def pytest_collect_file(path, parent):
184     ext = path.ext
185     if ext == ".py":
186         if not parent.session.isinitpath(path):
187             if not path_matches_patterns(
188                 path, parent.config.getini("python_files") + ["__init__.py"]
189             ):
190                 return
191         ihook = parent.session.gethookproxy(path)
192         return ihook.pytest_pycollect_makemodule(path=path, parent=parent)
193 
194 
195 def path_matches_patterns(path, patterns):
196     """Returns True if the given py.path.local matches one of the patterns in the list of globs given"""
197     return any(path.fnmatch(pattern) for pattern in patterns)
198 
199 
200 def pytest_pycollect_makemodule(path, parent):
201     if path.basename == "__init__.py":
202         return Package(path, parent)
203     return Module(path, parent)
204 
205 
206 @hookimpl(hookwrapper=True)
207 def pytest_pycollect_makeitem(collector, name, obj):
208     outcome = yield
209     res = outcome.get_result()
210     if res is not None:
211         return
212     # nothing was collected elsewhere, let's do it here
213     if safe_isclass(obj):
214         if collector.istestclass(obj, name):
215             outcome.force_result(Class(name, parent=collector))
216     elif collector.istestfunction(obj, name):
217         # mock seems to store unbound methods (issue473), normalize it
218         obj = getattr(obj, "__func__", obj)
219         # We need to try and unwrap the function if it's a functools.partial
220         # or a funtools.wrapped.
221         # We musn't if it's been wrapped with mock.patch (python 2 only)
222         if not (isfunction(obj) or isfunction(get_real_func(obj))):
223             filename, lineno = getfslineno(obj)
224             warnings.warn_explicit(
225                 message=PytestCollectionWarning(
226                     "cannot collect %r because it is not a function." % name
227                 ),
228                 category=None,
229                 filename=str(filename),
230                 lineno=lineno + 1,
231             )
232         elif getattr(obj, "__test__", True):
233             if is_generator(obj):
234                 res = Function(name, parent=collector)
235                 reason = deprecated.YIELD_TESTS.format(name=name)
236                 res.add_marker(MARK_GEN.xfail(run=False, reason=reason))
237                 res.warn(PytestCollectionWarning(reason))
238             else:
239                 res = list(collector._genfunctions(name, obj))
240             outcome.force_result(res)
241 
242 
243 def pytest_make_parametrize_id(config, val, argname=None):
244     return None
245 
246 
247 class PyobjContext(object):
248     module = pyobj_property("Module")
249     cls = pyobj_property("Class")
250     instance = pyobj_property("Instance")
251 
252 
253 class PyobjMixin(PyobjContext):
254     _ALLOW_MARKERS = True
255 
256     def __init__(self, *k, **kw):
257         super(PyobjMixin, self).__init__(*k, **kw)
258 
259     @property
260     def obj(self):
261         """Underlying Python object."""
262         obj = getattr(self, "_obj", None)
263         if obj is None:
264             self._obj = obj = self._getobj()
265             # XXX evil hack
266             # used to avoid Instance collector marker duplication
267             if self._ALLOW_MARKERS:
268                 self.own_markers.extend(get_unpacked_marks(self.obj))
269         return obj
270 
271     @obj.setter
272     def obj(self, value):
273         self._obj = value
274 
275     def _getobj(self):
276         """Gets the underlying Python object. May be overwritten by subclasses."""
277         return getattr(self.parent.obj, self.name)
278 
279     def getmodpath(self, stopatmodule=True, includemodule=False):
280         """ return python path relative to the containing module. """
281         chain = self.listchain()
282         chain.reverse()
283         parts = []
284         for node in chain:
285             if isinstance(node, Instance):
286                 continue
287             name = node.name
288             if isinstance(node, Module):
289                 name = os.path.splitext(name)[0]
290                 if stopatmodule:
291                     if includemodule:
292                         parts.append(name)
293                     break
294             parts.append(name)
295         parts.reverse()
296         s = ".".join(parts)
297         return s.replace(".[", "[")
298 
299     def reportinfo(self):
300         # XXX caching?
301         obj = self.obj
302         compat_co_firstlineno = getattr(obj, "compat_co_firstlineno", None)
303         if isinstance(compat_co_firstlineno, int):
304             # nose compatibility
305             fspath = sys.modules[obj.__module__].__file__
306             if fspath.endswith(".pyc"):
307                 fspath = fspath[:-1]
308             lineno = compat_co_firstlineno
309         else:
310             fspath, lineno = getfslineno(obj)
311         modpath = self.getmodpath()
312         assert isinstance(lineno, int)
313         return fspath, lineno, modpath
314 
315 
316 class PyCollector(PyobjMixin, nodes.Collector):
317     def funcnamefilter(self, name):
318         return self._matches_prefix_or_glob_option("python_functions", name)
319 
320     def isnosetest(self, obj):
321         """ Look for the __test__ attribute, which is applied by the
322         @nose.tools.istest decorator
323         """
324         # We explicitly check for "is True" here to not mistakenly treat
325         # classes with a custom __getattr__ returning something truthy (like a
326         # function) as test classes.
327         return safe_getattr(obj, "__test__", False) is True
328 
329     def classnamefilter(self, name):
330         return self._matches_prefix_or_glob_option("python_classes", name)
331 
332     def istestfunction(self, obj, name):
333         if self.funcnamefilter(name) or self.isnosetest(obj):
334             if isinstance(obj, staticmethod):
335                 # static methods need to be unwrapped
336                 obj = safe_getattr(obj, "__func__", False)
337             return (
338                 safe_getattr(obj, "__call__", False)
339                 and fixtures.getfixturemarker(obj) is None
340             )
341         else:
342             return False
343 
344     def istestclass(self, obj, name):
345         return self.classnamefilter(name) or self.isnosetest(obj)
346 
347     def _matches_prefix_or_glob_option(self, option_name, name):
348         """
349         checks if the given name matches the prefix or glob-pattern defined
350         in ini configuration.
351         """
352         for option in self.config.getini(option_name):
353             if name.startswith(option):
354                 return True
355             # check that name looks like a glob-string before calling fnmatch
356             # because this is called for every name in each collected module,
357             # and fnmatch is somewhat expensive to call
358             elif ("*" in option or "?" in option or "[" in option) and fnmatch.fnmatch(
359                 name, option
360             ):
361                 return True
362         return False
363 
364     def collect(self):
365         if not getattr(self.obj, "__test__", True):
366             return []
367 
368         # NB. we avoid random getattrs and peek in the __dict__ instead
369         # (XXX originally introduced from a PyPy need, still true?)
370         dicts = [getattr(self.obj, "__dict__", {})]
371         for basecls in inspect.getmro(self.obj.__class__):
372             dicts.append(basecls.__dict__)
373         seen = {}
374         values = []
375         for dic in dicts:
376             for name, obj in list(dic.items()):
377                 if name in seen:
378                     continue
379                 seen[name] = True
380                 res = self._makeitem(name, obj)
381                 if res is None:
382                     continue
383                 if not isinstance(res, list):
384                     res = [res]
385                 values.extend(res)
386         values.sort(key=lambda item: item.reportinfo()[:2])
387         return values
388 
389     def _makeitem(self, name, obj):
390         # assert self.ihook.fspath == self.fspath, self
391         return self.ihook.pytest_pycollect_makeitem(collector=self, name=name, obj=obj)
392 
393     def _genfunctions(self, name, funcobj):
394         module = self.getparent(Module).obj
395         clscol = self.getparent(Class)
396         cls = clscol and clscol.obj or None
397         fm = self.session._fixturemanager
398 
399         definition = FunctionDefinition(name=name, parent=self, callobj=funcobj)
400         fixtureinfo = fm.getfixtureinfo(definition, funcobj, cls)
401 
402         metafunc = Metafunc(
403             definition, fixtureinfo, self.config, cls=cls, module=module
404         )
405         methods = []
406         if hasattr(module, "pytest_generate_tests"):
407             methods.append(module.pytest_generate_tests)
408         if hasattr(cls, "pytest_generate_tests"):
409             methods.append(cls().pytest_generate_tests)
410         if methods:
411             self.ihook.pytest_generate_tests.call_extra(
412                 methods, dict(metafunc=metafunc)
413             )
414         else:
415             self.ihook.pytest_generate_tests(metafunc=metafunc)
416 
417         if not metafunc._calls:
418             yield Function(name, parent=self, fixtureinfo=fixtureinfo)
419         else:
420             # add funcargs() as fixturedefs to fixtureinfo.arg2fixturedefs
421             fixtures.add_funcarg_pseudo_fixture_def(self, metafunc, fm)
422 
423             # add_funcarg_pseudo_fixture_def may have shadowed some fixtures
424             # with direct parametrization, so make sure we update what the
425             # function really needs.
426             fixtureinfo.prune_dependency_tree()
427 
428             for callspec in metafunc._calls:
429                 subname = "%s[%s]" % (name, callspec.id)
430                 yield Function(
431                     name=subname,
432                     parent=self,
433                     callspec=callspec,
434                     callobj=funcobj,
435                     fixtureinfo=fixtureinfo,
436                     keywords={callspec.id: True},
437                     originalname=name,
438                 )
439 
440 
441 class Module(nodes.File, PyCollector):
442     """ Collector for test classes and functions. """
443 
444     def _getobj(self):
445         return self._importtestmodule()
446 
447     def collect(self):
448         self._inject_setup_module_fixture()
449         self._inject_setup_function_fixture()
450         self.session._fixturemanager.parsefactories(self)
451         return super(Module, self).collect()
452 
453     def _inject_setup_module_fixture(self):
454         """Injects a hidden autouse, module scoped fixture into the collected module object
455         that invokes setUpModule/tearDownModule if either or both are available.
456 
457         Using a fixture to invoke this methods ensures we play nicely and unsurprisingly with
458         other fixtures (#517).
459         """
460         setup_module = _get_non_fixture_func(self.obj, "setUpModule")
461         if setup_module is None:
462             setup_module = _get_non_fixture_func(self.obj, "setup_module")
463 
464         teardown_module = _get_non_fixture_func(self.obj, "tearDownModule")
465         if teardown_module is None:
466             teardown_module = _get_non_fixture_func(self.obj, "teardown_module")
467 
468         if setup_module is None and teardown_module is None:
469             return
470 
471         @fixtures.fixture(autouse=True, scope="module")
472         def xunit_setup_module_fixture(request):
473             if setup_module is not None:
474                 _call_with_optional_argument(setup_module, request.module)
475             yield
476             if teardown_module is not None:
477                 _call_with_optional_argument(teardown_module, request.module)
478 
479         self.obj.__pytest_setup_module = xunit_setup_module_fixture
480 
481     def _inject_setup_function_fixture(self):
482         """Injects a hidden autouse, function scoped fixture into the collected module object
483         that invokes setup_function/teardown_function if either or both are available.
484 
485         Using a fixture to invoke this methods ensures we play nicely and unsurprisingly with
486         other fixtures (#517).
487         """
488         setup_function = _get_non_fixture_func(self.obj, "setup_function")
489         teardown_function = _get_non_fixture_func(self.obj, "teardown_function")
490         if setup_function is None and teardown_function is None:
491             return
492 
493         @fixtures.fixture(autouse=True, scope="function")
494         def xunit_setup_function_fixture(request):
495             if request.instance is not None:
496                 # in this case we are bound to an instance, so we need to let
497                 # setup_method handle this
498                 yield
499                 return
500             if setup_function is not None:
501                 _call_with_optional_argument(setup_function, request.function)
502             yield
503             if teardown_function is not None:
504                 _call_with_optional_argument(teardown_function, request.function)
505 
506         self.obj.__pytest_setup_function = xunit_setup_function_fixture
507 
508     def _importtestmodule(self):
509         # we assume we are only called once per module
510         importmode = self.config.getoption("--import-mode")
511         try:
512             mod = self.fspath.pyimport(ensuresyspath=importmode)
513         except SyntaxError:
514             raise self.CollectError(
515                 _pytest._code.ExceptionInfo.from_current().getrepr(style="short")
516             )
517         except self.fspath.ImportMismatchError:
518             e = sys.exc_info()[1]
519             raise self.CollectError(
520                 "import file mismatch:\n"
521                 "imported module %r has this __file__ attribute:\n"
522                 "  %s\n"
523                 "which is not the same as the test file we want to collect:\n"
524                 "  %s\n"
525                 "HINT: remove __pycache__ / .pyc files and/or use a "
526                 "unique basename for your test file modules" % e.args
527             )
528         except ImportError:
529             from _pytest._code.code import ExceptionInfo
530 
531             exc_info = ExceptionInfo.from_current()
532             if self.config.getoption("verbose") < 2:
533                 exc_info.traceback = exc_info.traceback.filter(filter_traceback)
534             exc_repr = (
535                 exc_info.getrepr(style="short")
536                 if exc_info.traceback
537                 else exc_info.exconly()
538             )
539             formatted_tb = safe_str(exc_repr)
540             raise self.CollectError(
541                 "ImportError while importing test module '{fspath}'.\n"
542                 "Hint: make sure your test modules/packages have valid Python names.\n"
543                 "Traceback:\n"
544                 "{traceback}".format(fspath=self.fspath, traceback=formatted_tb)
545             )
546         except _pytest.runner.Skipped as e:
547             if e.allow_module_level:
548                 raise
549             raise self.CollectError(
550                 "Using pytest.skip outside of a test is not allowed. "
551                 "To decorate a test function, use the @pytest.mark.skip "
552                 "or @pytest.mark.skipif decorators instead, and to skip a "
553                 "module use `pytestmark = pytest.mark.{skip,skipif}."
554             )
555         self.config.pluginmanager.consider_module(mod)
556         return mod
557 
558 
559 class Package(Module):
560     def __init__(self, fspath, parent=None, config=None, session=None, nodeid=None):
561         session = parent.session
562         nodes.FSCollector.__init__(
563             self, fspath, parent=parent, config=config, session=session, nodeid=nodeid
564         )
565         self.name = fspath.dirname
566         self.trace = session.trace
567         self._norecursepatterns = session._norecursepatterns
568         self.fspath = fspath
569 
570     def setup(self):
571         # not using fixtures to call setup_module here because autouse fixtures
572         # from packages are not called automatically (#4085)
573         setup_module = _get_non_fixture_func(self.obj, "setUpModule")
574         if setup_module is None:
575             setup_module = _get_non_fixture_func(self.obj, "setup_module")
576         if setup_module is not None:
577             _call_with_optional_argument(setup_module, self.obj)
578 
579         teardown_module = _get_non_fixture_func(self.obj, "tearDownModule")
580         if teardown_module is None:
581             teardown_module = _get_non_fixture_func(self.obj, "teardown_module")
582         if teardown_module is not None:
583             func = partial(_call_with_optional_argument, teardown_module, self.obj)
584             self.addfinalizer(func)
585 
586     def _recurse(self, dirpath):
587         if dirpath.basename == "__pycache__":
588             return False
589         ihook = self.gethookproxy(dirpath.dirpath())
590         if ihook.pytest_ignore_collect(path=dirpath, config=self.config):
591             return
592         for pat in self._norecursepatterns:
593             if dirpath.check(fnmatch=pat):
594                 return False
595         ihook = self.gethookproxy(dirpath)
596         ihook.pytest_collect_directory(path=dirpath, parent=self)
597         return True
598 
599     def gethookproxy(self, fspath):
600         # check if we have the common case of running
601         # hooks with all conftest.py filesall conftest.py
602         pm = self.config.pluginmanager
603         my_conftestmodules = pm._getconftestmodules(fspath)
604         remove_mods = pm._conftest_plugins.difference(my_conftestmodules)
605         if remove_mods:
606             # one or more conftests are not in use at this fspath
607             proxy = FSHookProxy(fspath, pm, remove_mods)
608         else:
609             # all plugis are active for this fspath
610             proxy = self.config.hook
611         return proxy
612 
613     def _collectfile(self, path, handle_dupes=True):
614         assert path.isfile(), "%r is not a file (isdir=%r, exists=%r, islink=%r)" % (
615             path,
616             path.isdir(),
617             path.exists(),
618             path.islink(),
619         )
620         ihook = self.gethookproxy(path)
621         if not self.isinitpath(path):
622             if ihook.pytest_ignore_collect(path=path, config=self.config):
623                 return ()
624 
625         if handle_dupes:
626             keepduplicates = self.config.getoption("keepduplicates")
627             if not keepduplicates:
628                 duplicate_paths = self.config.pluginmanager._duplicatepaths
629                 if path in duplicate_paths:
630                     return ()
631                 else:
632                     duplicate_paths.add(path)
633 
634         if self.fspath == path:  # __init__.py
635             return [self]
636 
637         return ihook.pytest_collect_file(path=path, parent=self)
638 
639     def isinitpath(self, path):
640         return path in self.session._initialpaths
641 
642     def collect(self):
643         this_path = self.fspath.dirpath()
644         init_module = this_path.join("__init__.py")
645         if init_module.check(file=1) and path_matches_patterns(
646             init_module, self.config.getini("python_files")
647         ):
648             yield Module(init_module, self)
649         pkg_prefixes = set()
650         for path in this_path.visit(rec=self._recurse, bf=True, sort=True):
651             # We will visit our own __init__.py file, in which case we skip it.
652             is_file = path.isfile()
653             if is_file:
654                 if path.basename == "__init__.py" and path.dirpath() == this_path:
655                     continue
656 
657             parts_ = parts(path.strpath)
658             if any(
659                 pkg_prefix in parts_ and pkg_prefix.join("__init__.py") != path
660                 for pkg_prefix in pkg_prefixes
661             ):
662                 continue
663 
664             if is_file:
665                 for x in self._collectfile(path):
666                     yield x
667             elif not path.isdir():
668                 # Broken symlink or invalid/missing file.
669                 continue
670             elif path.join("__init__.py").check(file=1):
671                 pkg_prefixes.add(path)
672 
673 
674 def _get_xunit_setup_teardown(holder, attr_name, param_obj=None):
675     """
676     Return a callable to perform xunit-style setup or teardown if
677     the function exists in the ``holder`` object.
678     The ``param_obj`` parameter is the parameter which will be passed to the function
679     when the callable is called without arguments, defaults to the ``holder`` object.
680     Return ``None`` if a suitable callable is not found.
681     """
682     # TODO: only needed because of Package!
683     param_obj = param_obj if param_obj is not None else holder
684     result = _get_non_fixture_func(holder, attr_name)
685     if result is not None:
686         arg_count = result.__code__.co_argcount
687         if inspect.ismethod(result):
688             arg_count -= 1
689         if arg_count:
690             return lambda: result(param_obj)
691         else:
692             return result
693 
694 
695 def _call_with_optional_argument(func, arg):
696     """Call the given function with the given argument if func accepts one argument, otherwise
697     calls func without arguments"""
698     arg_count = func.__code__.co_argcount
699     if inspect.ismethod(func):
700         arg_count -= 1
701     if arg_count:
702         func(arg)
703     else:
704         func()
705 
706 
707 def _get_non_fixture_func(obj, name):
708     """Return the attribute from the given object to be used as a setup/teardown
709     xunit-style function, but only if not marked as a fixture to
710     avoid calling it twice.
711     """
712     meth = getattr(obj, name, None)
713     if fixtures.getfixturemarker(meth) is None:
714         return meth
715 
716 
717 class Class(PyCollector):
718     """ Collector for test methods. """
719 
720     def collect(self):
721         if not safe_getattr(self.obj, "__test__", True):
722             return []
723         if hasinit(self.obj):
724             self.warn(
725                 PytestCollectionWarning(
726                     "cannot collect test class %r because it has a "
727                     "__init__ constructor" % self.obj.__name__
728                 )
729             )
730             return []
731         elif hasnew(self.obj):
732             self.warn(
733                 PytestCollectionWarning(
734                     "cannot collect test class %r because it has a "
735                     "__new__ constructor" % self.obj.__name__
736                 )
737             )
738             return []
739 
740         self._inject_setup_class_fixture()
741         self._inject_setup_method_fixture()
742 
743         return [Instance(name="()", parent=self)]
744 
745     def _inject_setup_class_fixture(self):
746         """Injects a hidden autouse, class scoped fixture into the collected class object
747         that invokes setup_class/teardown_class if either or both are available.
748 
749         Using a fixture to invoke this methods ensures we play nicely and unsurprisingly with
750         other fixtures (#517).
751         """
752         setup_class = _get_non_fixture_func(self.obj, "setup_class")
753         teardown_class = getattr(self.obj, "teardown_class", None)
754         if setup_class is None and teardown_class is None:
755             return
756 
757         @fixtures.fixture(autouse=True, scope="class")
758         def xunit_setup_class_fixture(cls):
759             if setup_class is not None:
760                 func = getimfunc(setup_class)
761                 _call_with_optional_argument(func, self.obj)
762             yield
763             if teardown_class is not None:
764                 func = getimfunc(teardown_class)
765                 _call_with_optional_argument(func, self.obj)
766 
767         self.obj.__pytest_setup_class = xunit_setup_class_fixture
768 
769     def _inject_setup_method_fixture(self):
770         """Injects a hidden autouse, function scoped fixture into the collected class object
771         that invokes setup_method/teardown_method if either or both are available.
772 
773         Using a fixture to invoke this methods ensures we play nicely and unsurprisingly with
774         other fixtures (#517).
775         """
776         setup_method = _get_non_fixture_func(self.obj, "setup_method")
777         teardown_method = getattr(self.obj, "teardown_method", None)
778         if setup_method is None and teardown_method is None:
779             return
780 
781         @fixtures.fixture(autouse=True, scope="function")
782         def xunit_setup_method_fixture(self, request):
783             method = request.function
784             if setup_method is not None:
785                 func = getattr(self, "setup_method")
786                 _call_with_optional_argument(func, method)
787             yield
788             if teardown_method is not None:
789                 func = getattr(self, "teardown_method")
790                 _call_with_optional_argument(func, method)
791 
792         self.obj.__pytest_setup_method = xunit_setup_method_fixture
793 
794 
795 class Instance(PyCollector):
796     _ALLOW_MARKERS = False  # hack, destroy later
797     # instances share the object with their parents in a way
798     # that duplicates markers instances if not taken out
799     # can be removed at node structure reorganization time
800 
801     def _getobj(self):
802         return self.parent.obj()
803 
804     def collect(self):
805         self.session._fixturemanager.parsefactories(self)
806         return super(Instance, self).collect()
807 
808     def newinstance(self):
809         self.obj = self._getobj()
810         return self.obj
811 
812 
813 class FunctionMixin(PyobjMixin):
814     """ mixin for the code common to Function and Generator.
815     """
816 
817     def setup(self):
818         """ perform setup for this test function. """
819         if isinstance(self.parent, Instance):
820             self.parent.newinstance()
821             self.obj = self._getobj()
822 
823     def _prunetraceback(self, excinfo):
824         if hasattr(self, "_obj") and not self.config.getoption("fulltrace", False):
825             code = _pytest._code.Code(get_real_func(self.obj))
826             path, firstlineno = code.path, code.firstlineno
827             traceback = excinfo.traceback
828             ntraceback = traceback.cut(path=path, firstlineno=firstlineno)
829             if ntraceback == traceback:
830                 ntraceback = ntraceback.cut(path=path)
831                 if ntraceback == traceback:
832                     ntraceback = ntraceback.filter(filter_traceback)
833                     if not ntraceback:
834                         ntraceback = traceback
835 
836             excinfo.traceback = ntraceback.filter()
837             # issue364: mark all but first and last frames to
838             # only show a single-line message for each frame
839             if self.config.getoption("tbstyle", "auto") == "auto":
840                 if len(excinfo.traceback) > 2:
841                     for entry in excinfo.traceback[1:-1]:
842                         entry.set_repr_style("short")
843 
844     def repr_failure(self, excinfo, outerr=None):
845         assert outerr is None, "XXX outerr usage is deprecated"
846         style = self.config.getoption("tbstyle", "auto")
847         if style == "auto":
848             style = "long"
849         return self._repr_failure_py(excinfo, style=style)
850 
851 
852 def hasinit(obj):
853     init = getattr(obj, "__init__", None)
854     if init:
855         return init != object.__init__
856 
857 
858 def hasnew(obj):
859     new = getattr(obj, "__new__", None)
860     if new:
861         return new != object.__new__
862 
863 
864 class CallSpec2(object):
865     def __init__(self, metafunc):
866         self.metafunc = metafunc
867         self.funcargs = {}
868         self._idlist = []
869         self.params = {}
870         self._globalid = NOTSET
871         self._globalparam = NOTSET
872         self._arg2scopenum = {}  # used for sorting parametrized resources
873         self.marks = []
874         self.indices = {}
875 
876     def copy(self):
877         cs = CallSpec2(self.metafunc)
878         cs.funcargs.update(self.funcargs)
879         cs.params.update(self.params)
880         cs.marks.extend(self.marks)
881         cs.indices.update(self.indices)
882         cs._arg2scopenum.update(self._arg2scopenum)
883         cs._idlist = list(self._idlist)
884         cs._globalid = self._globalid
885         cs._globalparam = self._globalparam
886         return cs
887 
888     def _checkargnotcontained(self, arg):
889         if arg in self.params or arg in self.funcargs:
890             raise ValueError("duplicate %r" % (arg,))
891 
892     def getparam(self, name):
893         try:
894             return self.params[name]
895         except KeyError:
896             if self._globalparam is NOTSET:
897                 raise ValueError(name)
898             return self._globalparam
899 
900     @property
901     def id(self):
902         return "-".join(map(str, filter(None, self._idlist)))
903 
904     def setmulti2(self, valtypes, argnames, valset, id, marks, scopenum, param_index):
905         for arg, val in zip(argnames, valset):
906             self._checkargnotcontained(arg)
907             valtype_for_arg = valtypes[arg]
908             getattr(self, valtype_for_arg)[arg] = val
909             self.indices[arg] = param_index
910             self._arg2scopenum[arg] = scopenum
911         self._idlist.append(id)
912         self.marks.extend(normalize_mark_list(marks))
913 
914     def setall(self, funcargs, id, param):
915         for x in funcargs:
916             self._checkargnotcontained(x)
917         self.funcargs.update(funcargs)
918         if id is not NOTSET:
919             self._idlist.append(id)
920         if param is not NOTSET:
921             assert self._globalparam is NOTSET
922             self._globalparam = param
923         for arg in funcargs:
924             self._arg2scopenum[arg] = fixtures.scopenum_function
925 
926 
927 class Metafunc(fixtures.FuncargnamesCompatAttr):
928     """
929     Metafunc objects are passed to the :func:`pytest_generate_tests <_pytest.hookspec.pytest_generate_tests>` hook.
930     They help to inspect a test function and to generate tests according to
931     test configuration or values specified in the class or module where a
932     test function is defined.
933     """
934 
935     def __init__(self, definition, fixtureinfo, config, cls=None, module=None):
936         assert (
937             isinstance(definition, FunctionDefinition)
938             or type(definition).__name__ == "DefinitionMock"
939         )
940         self.definition = definition
941 
942         #: access to the :class:`_pytest.config.Config` object for the test session
943         self.config = config
944 
945         #: the module object where the test function is defined in.
946         self.module = module
947 
948         #: underlying python test function
949         self.function = definition.obj
950 
951         #: set of fixture names required by the test function
952         self.fixturenames = fixtureinfo.names_closure
953 
954         #: class object where the test function is defined in or ``None``.
955         self.cls = cls
956 
957         self._calls = []
958         self._ids = set()
959         self._arg2fixturedefs = fixtureinfo.name2fixturedefs
960 
961     def parametrize(self, argnames, argvalues, indirect=False, ids=None, scope=None):
962         """ Add new invocations to the underlying test function using the list
963         of argvalues for the given argnames.  Parametrization is performed
964         during the collection phase.  If you need to setup expensive resources
965         see about setting indirect to do it rather at test setup time.
966 
967         :arg argnames: a comma-separated string denoting one or more argument
968                        names, or a list/tuple of argument strings.
969 
970         :arg argvalues: The list of argvalues determines how often a
971             test is invoked with different argument values.  If only one
972             argname was specified argvalues is a list of values.  If N
973             argnames were specified, argvalues must be a list of N-tuples,
974             where each tuple-element specifies a value for its respective
975             argname.
976 
977         :arg indirect: The list of argnames or boolean. A list of arguments'
978             names (subset of argnames). If True the list contains all names from
979             the argnames. Each argvalue corresponding to an argname in this list will
980             be passed as request.param to its respective argname fixture
981             function so that it can perform more expensive setups during the
982             setup phase of a test rather than at collection time.
983 
984         :arg ids: list of string ids, or a callable.
985             If strings, each is corresponding to the argvalues so that they are
986             part of the test id. If None is given as id of specific test, the
987             automatically generated id for that argument will be used.
988             If callable, it should take one argument (a single argvalue) and return
989             a string or return None. If None, the automatically generated id for that
990             argument will be used.
991             If no ids are provided they will be generated automatically from
992             the argvalues.
993 
994         :arg scope: if specified it denotes the scope of the parameters.
995             The scope is used for grouping tests by parameter instances.
996             It will also override any fixture-function defined scope, allowing
997             to set a dynamic scope using test context or configuration.
998         """
999         from _pytest.fixtures import scope2index
1000         from _pytest.mark import ParameterSet
1001 
1002         argnames, parameters = ParameterSet._for_parametrize(
1003             argnames,
1004             argvalues,
1005             self.function,
1006             self.config,
1007             function_definition=self.definition,
1008         )
1009         del argvalues
1010 
1011         if scope is None:
1012             scope = _find_parametrized_scope(argnames, self._arg2fixturedefs, indirect)
1013 
1014         self._validate_if_using_arg_names(argnames, indirect)
1015 
1016         arg_values_types = self._resolve_arg_value_types(argnames, indirect)
1017 
1018         ids = self._resolve_arg_ids(argnames, ids, parameters, item=self.definition)
1019 
1020         scopenum = scope2index(
1021             scope, descr="parametrize() call in {}".format(self.function.__name__)
1022         )
1023 
1024         # create the new calls: if we are parametrize() multiple times (by applying the decorator
1025         # more than once) then we accumulate those calls generating the cartesian product
1026         # of all calls
1027         newcalls = []
1028         for callspec in self._calls or [CallSpec2(self)]:
1029             for param_index, (param_id, param_set) in enumerate(zip(ids, parameters)):
1030                 newcallspec = callspec.copy()
1031                 newcallspec.setmulti2(
1032                     arg_values_types,
1033                     argnames,
1034                     param_set.values,
1035                     param_id,
1036                     param_set.marks,
1037                     scopenum,
1038                     param_index,
1039                 )
1040                 newcalls.append(newcallspec)
1041         self._calls = newcalls
1042 
1043     def _resolve_arg_ids(self, argnames, ids, parameters, item):
1044         """Resolves the actual ids for the given argnames, based on the ``ids`` parameter given
1045         to ``parametrize``.
1046 
1047         :param List[str] argnames: list of argument names passed to ``parametrize()``.
1048         :param ids: the ids parameter of the parametrized call (see docs).
1049         :param List[ParameterSet] parameters: the list of parameter values, same size as ``argnames``.
1050         :param Item item: the item that generated this parametrized call.
1051         :rtype: List[str]
1052         :return: the list of ids for each argname given
1053         """
1054         from _pytest._io.saferepr import saferepr
1055 
1056         idfn = None
1057         if callable(ids):
1058             idfn = ids
1059             ids = None
1060         if ids:
1061             func_name = self.function.__name__
1062             if len(ids) != len(parameters):
1063                 msg = "In {}: {} parameter sets specified, with different number of ids: {}"
1064                 fail(msg.format(func_name, len(parameters), len(ids)), pytrace=False)
1065             for id_value in ids:
1066                 if id_value is not None and not isinstance(id_value, six.string_types):
1067                     msg = "In {}: ids must be list of strings, found: {} (type: {!r})"
1068                     fail(
1069                         msg.format(func_name, saferepr(id_value), type(id_value)),
1070                         pytrace=False,
1071                     )
1072         ids = idmaker(argnames, parameters, idfn, ids, self.config, item=item)
1073         return ids
1074 
1075     def _resolve_arg_value_types(self, argnames, indirect):
1076         """Resolves if each parametrized argument must be considered a parameter to a fixture or a "funcarg"
1077         to the function, based on the ``indirect`` parameter of the parametrized() call.
1078 
1079         :param List[str] argnames: list of argument names passed to ``parametrize()``.
1080         :param indirect: same ``indirect`` parameter of ``parametrize()``.
1081         :rtype: Dict[str, str]
1082             A dict mapping each arg name to either:
1083             * "params" if the argname should be the parameter of a fixture of the same name.
1084             * "funcargs" if the argname should be a parameter to the parametrized test function.
1085         """
1086         valtypes = {}
1087         if indirect is True:
1088             valtypes = dict.fromkeys(argnames, "params")
1089         elif indirect is False:
1090             valtypes = dict.fromkeys(argnames, "funcargs")
1091         elif isinstance(indirect, (tuple, list)):
1092             valtypes = dict.fromkeys(argnames, "funcargs")
1093             for arg in indirect:
1094                 if arg not in argnames:
1095                     fail(
1096                         "In {}: indirect fixture '{}' doesn't exist".format(
1097                             self.function.__name__, arg
1098                         ),
1099                         pytrace=False,
1100                     )
1101                 valtypes[arg] = "params"
1102         return valtypes
1103 
1104     def _validate_if_using_arg_names(self, argnames, indirect):
1105         """
1106         Check if all argnames are being used, by default values, or directly/indirectly.
1107 
1108         :param List[str] argnames: list of argument names passed to ``parametrize()``.
1109         :param indirect: same ``indirect`` parameter of ``parametrize()``.
1110         :raise ValueError: if validation fails.
1111         """
1112         default_arg_names = set(get_default_arg_names(self.function))
1113         func_name = self.function.__name__
1114         for arg in argnames:
1115             if arg not in self.fixturenames:
1116                 if arg in default_arg_names:
1117                     fail(
1118                         "In {}: function already takes an argument '{}' with a default value".format(
1119                             func_name, arg
1120                         ),
1121                         pytrace=False,
1122                     )
1123                 else:
1124                     if isinstance(indirect, (tuple, list)):
1125                         name = "fixture" if arg in indirect else "argument"
1126                     else:
1127                         name = "fixture" if indirect else "argument"
1128                     fail(
1129                         "In {}: function uses no {} '{}'".format(func_name, name, arg),
1130                         pytrace=False,
1131                     )
1132 
1133 
1134 def _find_parametrized_scope(argnames, arg2fixturedefs, indirect):
1135     """Find the most appropriate scope for a parametrized call based on its arguments.
1136 
1137     When there's at least one direct argument, always use "function" scope.
1138 
1139     When a test function is parametrized and all its arguments are indirect
1140     (e.g. fixtures), return the most narrow scope based on the fixtures used.
1141 
1142     Related to issue #1832, based on code posted by @Kingdread.
1143     """
1144     from _pytest.fixtures import scopes
1145 
1146     if isinstance(indirect, (list, tuple)):
1147         all_arguments_are_fixtures = len(indirect) == len(argnames)
1148     else:
1149         all_arguments_are_fixtures = bool(indirect)
1150 
1151     if all_arguments_are_fixtures:
1152         fixturedefs = arg2fixturedefs or {}
1153         used_scopes = [
1154             fixturedef[0].scope
1155             for name, fixturedef in fixturedefs.items()
1156             if name in argnames
1157         ]
1158         if used_scopes:
1159             # Takes the most narrow scope from used fixtures
1160             for scope in reversed(scopes):
1161                 if scope in used_scopes:
1162                     return scope
1163 
1164     return "function"
1165 
1166 
1167 def _ascii_escaped_by_config(val, config):
1168     if config is None:
1169         escape_option = False
1170     else:
1171         escape_option = config.getini(
1172             "disable_test_id_escaping_and_forfeit_all_rights_to_community_support"
1173         )
1174     return val if escape_option else ascii_escaped(val)
1175 
1176 
1177 def _idval(val, argname, idx, idfn, item, config):
1178     if idfn:
1179         try:
1180             generated_id = idfn(val)
1181             if generated_id is not None:
1182                 val = generated_id
1183         except Exception as e:
1184             # See issue https://github.com/pytest-dev/pytest/issues/2169
1185             msg = "{}: error raised while trying to determine id of parameter '{}' at position {}\n"
1186             msg = msg.format(item.nodeid, argname, idx)
1187             # we only append the exception type and message because on Python 2 reraise does nothing
1188             msg += "  {}: {}\n".format(type(e).__name__, e)
1189             six.raise_from(ValueError(msg), e)
1190     elif config:
1191         hook_id = config.hook.pytest_make_parametrize_id(
1192             config=config, val=val, argname=argname
1193         )
1194         if hook_id:
1195             return hook_id
1196 
1197     if isinstance(val, STRING_TYPES):
1198         return _ascii_escaped_by_config(val, config)
1199     elif isinstance(val, (float, int, bool, NoneType)):
1200         return str(val)
1201     elif isinstance(val, REGEX_TYPE):
1202         return ascii_escaped(val.pattern)
1203     elif enum is not None and isinstance(val, enum.Enum):
1204         return str(val)
1205     elif (isclass(val) or isfunction(val)) and hasattr(val, "__name__"):
1206         return val.__name__
1207     return str(argname) + str(idx)
1208 
1209 
1210 def _idvalset(idx, parameterset, argnames, idfn, ids, item, config):
1211     if parameterset.id is not None:
1212         return parameterset.id
1213     if ids is None or (idx >= len(ids) or ids[idx] is None):
1214         this_id = [
1215             _idval(val, argname, idx, idfn, item=item, config=config)
1216             for val, argname in zip(parameterset.values, argnames)
1217         ]
1218         return "-".join(this_id)
1219     else:
1220         return ascii_escaped(ids[idx])
1221 
1222 
1223 def idmaker(argnames, parametersets, idfn=None, ids=None, config=None, item=None):
1224     ids = [
1225         _idvalset(valindex, parameterset, argnames, idfn, ids, config=config, item=item)
1226         for valindex, parameterset in enumerate(parametersets)
1227     ]
1228     if len(set(ids)) != len(ids):
1229         # The ids are not unique
1230         duplicates = [testid for testid in ids if ids.count(testid) > 1]
1231         counters = collections.defaultdict(lambda: 0)
1232         for index, testid in enumerate(ids):
1233             if testid in duplicates:
1234                 ids[index] = testid + str(counters[testid])
1235                 counters[testid] += 1
1236     return ids
1237 
1238 
1239 def show_fixtures_per_test(config):
1240     from _pytest.main import wrap_session
1241 
1242     return wrap_session(config, _show_fixtures_per_test)
1243 
1244 
1245 def _show_fixtures_per_test(config, session):
1246     import _pytest.config
1247 
1248     session.perform_collect()
1249     curdir = py.path.local()
1250     tw = _pytest.config.create_terminal_writer(config)
1251     verbose = config.getvalue("verbose")
1252 
1253     def get_best_relpath(func):
1254         loc = getlocation(func, curdir)
1255         return curdir.bestrelpath(loc)
1256 
1257     def write_fixture(fixture_def):
1258         argname = fixture_def.argname
1259         if verbose <= 0 and argname.startswith("_"):
1260             return
1261         if verbose > 0:
1262             bestrel = get_best_relpath(fixture_def.func)
1263             funcargspec = "{} -- {}".format(argname, bestrel)
1264         else:
1265             funcargspec = argname
1266         tw.line(funcargspec, green=True)
1267         fixture_doc = fixture_def.func.__doc__
1268         if fixture_doc:
1269             write_docstring(tw, fixture_doc)
1270         else:
1271             tw.line("    no docstring available", red=True)
1272 
1273     def write_item(item):
1274         try:
1275             info = item._fixtureinfo
1276         except AttributeError:
1277             # doctests items have no _fixtureinfo attribute
1278             return
1279         if not info.name2fixturedefs:
1280             # this test item does not use any fixtures
1281             return
1282         tw.line()
1283         tw.sep("-", "fixtures used by {}".format(item.name))
1284         tw.sep("-", "({})".format(get_best_relpath(item.function)))
1285         # dict key not used in loop but needed for sorting
1286         for _, fixturedefs in sorted(info.name2fixturedefs.items()):
1287             assert fixturedefs is not None
1288             if not fixturedefs:
1289                 continue
1290             # last item is expected to be the one used by the test item
1291             write_fixture(fixturedefs[-1])
1292 
1293     for session_item in session.items:
1294         write_item(session_item)
1295 
1296 
1297 def showfixtures(config):
1298     from _pytest.main import wrap_session
1299 
1300     return wrap_session(config, _showfixtures_main)
1301 
1302 
1303 def _showfixtures_main(config, session):
1304     import _pytest.config
1305 
1306     session.perform_collect()
1307     curdir = py.path.local()
1308     tw = _pytest.config.create_terminal_writer(config)
1309     verbose = config.getvalue("verbose")
1310 
1311     fm = session._fixturemanager
1312 
1313     available = []
1314     seen = set()
1315 
1316     for argname, fixturedefs in fm._arg2fixturedefs.items():
1317         assert fixturedefs is not None
1318         if not fixturedefs:
1319             continue
1320         for fixturedef in fixturedefs:
1321             loc = getlocation(fixturedef.func, curdir)
1322             if (fixturedef.argname, loc) in seen:
1323                 continue
1324             seen.add((fixturedef.argname, loc))
1325             available.append(
1326                 (
1327                     len(fixturedef.baseid),
1328                     fixturedef.func.__module__,
1329                     curdir.bestrelpath(loc),
1330                     fixturedef.argname,
1331                     fixturedef,
1332                 )
1333             )
1334 
1335     available.sort()
1336     currentmodule = None
1337     for baseid, module, bestrel, argname, fixturedef in available:
1338         if currentmodule != module:
1339             if not module.startswith("_pytest."):
1340                 tw.line()
1341                 tw.sep("-", "fixtures defined from %s" % (module,))
1342                 currentmodule = module
1343         if verbose <= 0 and argname[0] == "_":
1344             continue
1345         if verbose > 0:
1346             funcargspec = "%s -- %s" % (argname, bestrel)
1347         else:
1348             funcargspec = argname
1349         tw.line(funcargspec, green=True)
1350         loc = getlocation(fixturedef.func, curdir)
1351         doc = fixturedef.func.__doc__ or ""
1352         if doc:
1353             write_docstring(tw, doc)
1354         else:
1355             tw.line("    %s: no docstring available" % (loc,), red=True)
1356 
1357 
1358 def write_docstring(tw, doc, indent="    "):
1359     doc = doc.rstrip()
1360     if "\n" in doc:
1361         firstline, rest = doc.split("\n", 1)
1362     else:
1363         firstline, rest = doc, ""
1364 
1365     if firstline.strip():
1366         tw.line(indent + firstline.strip())
1367 
1368     if rest:
1369         for line in dedent(rest).split("\n"):
1370             tw.write(indent + line + "\n")
1371 
1372 
1373 class Function(FunctionMixin, nodes.Item, fixtures.FuncargnamesCompatAttr):
1374     """ a Function Item is responsible for setting up and executing a
1375     Python test function.
1376     """
1377 
1378     # disable since functions handle it themselves
1379     _ALLOW_MARKERS = False
1380 
1381     def __init__(
1382         self,
1383         name,
1384         parent,
1385         args=None,
1386         config=None,
1387         callspec=None,
1388         callobj=NOTSET,
1389         keywords=None,
1390         session=None,
1391         fixtureinfo=None,
1392         originalname=None,
1393     ):
1394         super(Function, self).__init__(name, parent, config=config, session=session)
1395         self._args = args
1396         if callobj is not NOTSET:
1397             self.obj = callobj
1398 
1399         self.keywords.update(self.obj.__dict__)
1400         self.own_markers.extend(get_unpacked_marks(self.obj))
1401         if callspec:
1402             self.callspec = callspec
1403             # this is total hostile and a mess
1404             # keywords are broken by design by now
1405             # this will be redeemed later
1406             for mark in callspec.marks:
1407                 # feel free to cry, this was broken for years before
1408                 # and keywords cant fix it per design
1409                 self.keywords[mark.name] = mark
1410             self.own_markers.extend(normalize_mark_list(callspec.marks))
1411         if keywords:
1412             self.keywords.update(keywords)
1413 
1414         # todo: this is a hell of a hack
1415         # https://github.com/pytest-dev/pytest/issues/4569
1416 
1417         self.keywords.update(
1418             dict.fromkeys(
1419                 [
1420                     mark.name
1421                     for mark in self.iter_markers()
1422                     if mark.name not in self.keywords
1423                 ],
1424                 True,
1425             )
1426         )
1427 
1428         if fixtureinfo is None:
1429             fixtureinfo = self.session._fixturemanager.getfixtureinfo(
1430                 self, self.obj, self.cls, funcargs=True
1431             )
1432         self._fixtureinfo = fixtureinfo
1433         self.fixturenames = fixtureinfo.names_closure
1434         self._initrequest()
1435 
1436         #: original function name, without any decorations (for example
1437         #: parametrization adds a ``"[...]"`` suffix to function names).
1438         #:
1439         #: .. versionadded:: 3.0
1440         self.originalname = originalname
1441 
1442     def _initrequest(self):
1443         self.funcargs = {}
1444         self._request = fixtures.FixtureRequest(self)
1445 
1446     @property
1447     def function(self):
1448         "underlying python 'function' object"
1449         return getimfunc(self.obj)
1450 
1451     def _getobj(self):
1452         name = self.name
1453         i = name.find("[")  # parametrization
1454         if i != -1:
1455             name = name[:i]
1456         return getattr(self.parent.obj, name)
1457 
1458     @property
1459     def _pyfuncitem(self):
1460         "(compatonly) for code expecting pytest-2.2 style request objects"
1461         return self
1462 
1463     def runtest(self):
1464         """ execute the underlying test function. """
1465         self.ihook.pytest_pyfunc_call(pyfuncitem=self)
1466 
1467     def setup(self):
1468         super(Function, self).setup()
1469         fixtures.fillfixtures(self)
1470 
1471 
1472 class FunctionDefinition(Function):
1473     """
1474     internal hack until we get actual definition nodes instead of the
1475     crappy metafunc hack
1476     """
1477 
1478     def runtest(self):
1479         raise RuntimeError("function definitions are not supposed to be used")
1480 
1481     setup = runtest

</code><intended_behavior>The code responsible for processing the `--fixtures` command-line argument should be extended to include the fixture's scope in the output. This extension should preserve the current functionality of listing available fixtures but additionally display each fixture's scope (e.g., function, class, module, package, or session) alongside its name and docstring in the output.</intended_behavior>, <file>src/_pytest/fixtures.py</file>
<class>FixtureDef</class>
<method>None</method>
<code>
811 class FixtureDef(object):
812     """ A container for a factory definition. """
813 
814     def __init__(
815         self,
816         fixturemanager,
817         baseid,
818         argname,
819         func,
820         scope,
821         params,
822         unittest=False,
823         ids=None,
824     ):
825         self._fixturemanager = fixturemanager
826         self.baseid = baseid or ""
827         self.has_location = baseid is not None
828         self.func = func
829         self.argname = argname
830         self.scope = scope
831         self.scopenum = scope2index(
832             scope or "function",
833             descr="Fixture '{}'".format(func.__name__),
834             where=baseid,
835         )
836         self.params = params
837         self.argnames = getfuncargnames(func, is_method=unittest)
838         self.unittest = unittest
839         self.ids = ids
840         self._finalizers = []
841 
842     def addfinalizer(self, finalizer):
843         self._finalizers.append(finalizer)
844 
845     def finish(self, request):
846         exceptions = []
847         try:
848             while self._finalizers:
849                 try:
850                     func = self._finalizers.pop()
851                     func()
852                 except:  # noqa
853                     exceptions.append(sys.exc_info())
854             if exceptions:
855                 e = exceptions[0]
856                 del (
857                     exceptions
858                 )  # ensure we don't keep all frames alive because of the traceback
859                 six.reraise(*e)
860 
861         finally:
862             hook = self._fixturemanager.session.gethookproxy(request.node.fspath)
863             hook.pytest_fixture_post_finalizer(fixturedef=self, request=request)
864             # even if finalization fails, we invalidate
865             # the cached fixture value and remove
866             # all finalizers because they may be bound methods which will
867             # keep instances alive
868             if hasattr(self, "cached_result"):
869                 del self.cached_result
870             self._finalizers = []
871 
872     def execute(self, request):
873         # get required arguments and register our own finish()
874         # with their finalization
875         for argname in self.argnames:
876             fixturedef = request._get_active_fixturedef(argname)
877             if argname != "request":
878                 fixturedef.addfinalizer(functools.partial(self.finish, request=request))
879 
880         my_cache_key = request.param_index
881         cached_result = getattr(self, "cached_result", None)
882         if cached_result is not None:
883             result, cache_key, err = cached_result
884             if my_cache_key == cache_key:
885                 if err is not None:
886                     six.reraise(*err)
887                 else:
888                     return result
889             # we have a previous but differently parametrized fixture instance
890             # so we need to tear it down before creating a new one
891             self.finish(request)
892             assert not hasattr(self, "cached_result")
893 
894         hook = self._fixturemanager.session.gethookproxy(request.node.fspath)
895         return hook.pytest_fixture_setup(fixturedef=self, request=request)
896 
897     def __repr__(self):
898         return "<FixtureDef argname=%r scope=%r baseid=%r>" % (
899             self.argname,
900             self.scope,
901             self.baseid,
902         )

</code><intended_behavior>While the `FixtureDef` class may not require a bug fix per se, any enhancements to support the new feature (displaying fixture scopes) would likely involve accessing the `scope` attribute of this class's instances. The modification would ensure that wherever fixture details are being prepared for the `--fixtures` output, the scope is included by retrieving it from the `FixtureDef` instances corresponding to each fixture.</intended_behavior>]
2025-10-18 16:21:12.455 | INFO     | Search completed. Bug locations: [<file>src/_pytest/python.py</file>
<class>None</class>
<method>None</method>
<code>
1 """ Python test discovery, setup and run of test functions. """
2 from __future__ import absolute_import
3 from __future__ import division
4 from __future__ import print_function
5 
6 import collections
7 import fnmatch
8 import inspect
9 import os
10 import sys
11 import warnings
12 from functools import partial
13 from textwrap import dedent
14 
15 import py
16 import six
17 
18 import _pytest
19 from _pytest import deprecated
20 from _pytest import fixtures
21 from _pytest import nodes
22 from _pytest._code import filter_traceback
23 from _pytest.compat import ascii_escaped
24 from _pytest.compat import enum
25 from _pytest.compat import get_default_arg_names
26 from _pytest.compat import get_real_func
27 from _pytest.compat import getfslineno
28 from _pytest.compat import getimfunc
29 from _pytest.compat import getlocation
30 from _pytest.compat import is_generator
31 from _pytest.compat import isclass
32 from _pytest.compat import isfunction
33 from _pytest.compat import NoneType
34 from _pytest.compat import NOTSET
35 from _pytest.compat import REGEX_TYPE
36 from _pytest.compat import safe_getattr
37 from _pytest.compat import safe_isclass
38 from _pytest.compat import safe_str
39 from _pytest.compat import STRING_TYPES
40 from _pytest.config import hookimpl
41 from _pytest.main import FSHookProxy
42 from _pytest.mark import MARK_GEN
43 from _pytest.mark.structures import get_unpacked_marks
44 from _pytest.mark.structures import normalize_mark_list
45 from _pytest.outcomes import fail
46 from _pytest.outcomes import skip
47 from _pytest.pathlib import parts
48 from _pytest.warning_types import PytestCollectionWarning
49 from _pytest.warning_types import PytestUnhandledCoroutineWarning
50 
51 
52 def pyobj_property(name):
53     def get(self):
54         node = self.getparent(getattr(__import__("pytest"), name))
55         if node is not None:
56             return node.obj
57 
58     doc = "python %s object this node was collected from (can be None)." % (
59         name.lower(),
60     )
61     return property(get, None, None, doc)
62 
63 
64 def pytest_addoption(parser):
65     group = parser.getgroup("general")
66     group.addoption(
67         "--fixtures",
68         "--funcargs",
69         action="store_true",
70         dest="showfixtures",
71         default=False,
72         help="show available fixtures, sorted by plugin appearance "
73         "(fixtures with leading '_' are only shown with '-v')",
74     )
75     group.addoption(
76         "--fixtures-per-test",
77         action="store_true",
78         dest="show_fixtures_per_test",
79         default=False,
80         help="show fixtures per test",
81     )
82     parser.addini(
83         "usefixtures",
84         type="args",
85         default=[],
86         help="list of default fixtures to be used with this project",
87     )
88     parser.addini(
89         "python_files",
90         type="args",
91         default=["test_*.py", "*_test.py"],
92         help="glob-style file patterns for Python test module discovery",
93     )
94     parser.addini(
95         "python_classes",
96         type="args",
97         default=["Test"],
98         help="prefixes or glob names for Python test class discovery",
99     )
100     parser.addini(
101         "python_functions",
102         type="args",
103         default=["test"],
104         help="prefixes or glob names for Python test function and method discovery",
105     )
106     parser.addini(
107         "disable_test_id_escaping_and_forfeit_all_rights_to_community_support",
108         type="bool",
109         default=False,
110         help="disable string escape non-ascii characters, might cause unwanted "
111         "side effects(use at your own risk)",
112     )
113 
114     group.addoption(
115         "--import-mode",
116         default="prepend",
117         choices=["prepend", "append"],
118         dest="importmode",
119         help="prepend/append to sys.path when importing test modules, "
120         "default is to prepend.",
121     )
122 
123 
124 def pytest_cmdline_main(config):
125     if config.option.showfixtures:
126         showfixtures(config)
127         return 0
128     if config.option.show_fixtures_per_test:
129         show_fixtures_per_test(config)
130         return 0
131 
132 
133 def pytest_generate_tests(metafunc):
134     # those alternative spellings are common - raise a specific error to alert
135     # the user
136     alt_spellings = ["parameterize", "parametrise", "parameterise"]
137     for mark_name in alt_spellings:
138         if metafunc.definition.get_closest_marker(mark_name):
139             msg = "{0} has '{1}' mark, spelling should be 'parametrize'"
140             fail(msg.format(metafunc.function.__name__, mark_name), pytrace=False)
141     for marker in metafunc.definition.iter_markers(name="parametrize"):
142         metafunc.parametrize(*marker.args, **marker.kwargs)
143 
144 
145 def pytest_configure(config):
146     config.addinivalue_line(
147         "markers",
148         "parametrize(argnames, argvalues): call a test function multiple "
149         "times passing in different arguments in turn. argvalues generally "
150         "needs to be a list of values if argnames specifies only one name "
151         "or a list of tuples of values if argnames specifies multiple names. "
152         "Example: @parametrize('arg1', [1,2]) would lead to two calls of the "
153         "decorated test function, one with arg1=1 and another with arg1=2."
154         "see https://docs.pytest.org/en/latest/parametrize.html for more info "
155         "and examples.",
156     )
157     config.addinivalue_line(
158         "markers",
159         "usefixtures(fixturename1, fixturename2, ...): mark tests as needing "
160         "all of the specified fixtures. see "
161         "https://docs.pytest.org/en/latest/fixture.html#usefixtures ",
162     )
163 
164 
165 @hookimpl(trylast=True)
166 def pytest_pyfunc_call(pyfuncitem):
167     testfunction = pyfuncitem.obj
168     iscoroutinefunction = getattr(inspect, "iscoroutinefunction", None)
169     if iscoroutinefunction is not None and iscoroutinefunction(testfunction):
170         msg = "Coroutine functions are not natively supported and have been skipped.\n"
171         msg += "You need to install a suitable plugin for your async framework, for example:\n"
172         msg += "  - pytest-asyncio\n"
173         msg += "  - pytest-trio\n"
174         msg += "  - pytest-tornasync"
175         warnings.warn(PytestUnhandledCoroutineWarning(msg.format(pyfuncitem.nodeid)))
176         skip(msg="coroutine function and no async plugin installed (see warnings)")
177     funcargs = pyfuncitem.funcargs
178     testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
179     testfunction(**testargs)
180     return True
181 
182 
183 def pytest_collect_file(path, parent):
184     ext = path.ext
185     if ext == ".py":
186         if not parent.session.isinitpath(path):
187             if not path_matches_patterns(
188                 path, parent.config.getini("python_files") + ["__init__.py"]
189             ):
190                 return
191         ihook = parent.session.gethookproxy(path)
192         return ihook.pytest_pycollect_makemodule(path=path, parent=parent)
193 
194 
195 def path_matches_patterns(path, patterns):
196     """Returns True if the given py.path.local matches one of the patterns in the list of globs given"""
197     return any(path.fnmatch(pattern) for pattern in patterns)
198 
199 
200 def pytest_pycollect_makemodule(path, parent):
201     if path.basename == "__init__.py":
202         return Package(path, parent)
203     return Module(path, parent)
204 
205 
206 @hookimpl(hookwrapper=True)
207 def pytest_pycollect_makeitem(collector, name, obj):
208     outcome = yield
209     res = outcome.get_result()
210     if res is not None:
211         return
212     # nothing was collected elsewhere, let's do it here
213     if safe_isclass(obj):
214         if collector.istestclass(obj, name):
215             outcome.force_result(Class(name, parent=collector))
216     elif collector.istestfunction(obj, name):
217         # mock seems to store unbound methods (issue473), normalize it
218         obj = getattr(obj, "__func__", obj)
219         # We need to try and unwrap the function if it's a functools.partial
220         # or a funtools.wrapped.
221         # We musn't if it's been wrapped with mock.patch (python 2 only)
222         if not (isfunction(obj) or isfunction(get_real_func(obj))):
223             filename, lineno = getfslineno(obj)
224             warnings.warn_explicit(
225                 message=PytestCollectionWarning(
226                     "cannot collect %r because it is not a function." % name
227                 ),
228                 category=None,
229                 filename=str(filename),
230                 lineno=lineno + 1,
231             )
232         elif getattr(obj, "__test__", True):
233             if is_generator(obj):
234                 res = Function(name, parent=collector)
235                 reason = deprecated.YIELD_TESTS.format(name=name)
236                 res.add_marker(MARK_GEN.xfail(run=False, reason=reason))
237                 res.warn(PytestCollectionWarning(reason))
238             else:
239                 res = list(collector._genfunctions(name, obj))
240             outcome.force_result(res)
241 
242 
243 def pytest_make_parametrize_id(config, val, argname=None):
244     return None
245 
246 
247 class PyobjContext(object):
248     module = pyobj_property("Module")
249     cls = pyobj_property("Class")
250     instance = pyobj_property("Instance")
251 
252 
253 class PyobjMixin(PyobjContext):
254     _ALLOW_MARKERS = True
255 
256     def __init__(self, *k, **kw):
257         super(PyobjMixin, self).__init__(*k, **kw)
258 
259     @property
260     def obj(self):
261         """Underlying Python object."""
262         obj = getattr(self, "_obj", None)
263         if obj is None:
264             self._obj = obj = self._getobj()
265             # XXX evil hack
266             # used to avoid Instance collector marker duplication
267             if self._ALLOW_MARKERS:
268                 self.own_markers.extend(get_unpacked_marks(self.obj))
269         return obj
270 
271     @obj.setter
272     def obj(self, value):
273         self._obj = value
274 
275     def _getobj(self):
276         """Gets the underlying Python object. May be overwritten by subclasses."""
277         return getattr(self.parent.obj, self.name)
278 
279     def getmodpath(self, stopatmodule=True, includemodule=False):
280         """ return python path relative to the containing module. """
281         chain = self.listchain()
282         chain.reverse()
283         parts = []
284         for node in chain:
285             if isinstance(node, Instance):
286                 continue
287             name = node.name
288             if isinstance(node, Module):
289                 name = os.path.splitext(name)[0]
290                 if stopatmodule:
291                     if includemodule:
292                         parts.append(name)
293                     break
294             parts.append(name)
295         parts.reverse()
296         s = ".".join(parts)
297         return s.replace(".[", "[")
298 
299     def reportinfo(self):
300         # XXX caching?
301         obj = self.obj
302         compat_co_firstlineno = getattr(obj, "compat_co_firstlineno", None)
303         if isinstance(compat_co_firstlineno, int):
304             # nose compatibility
305             fspath = sys.modules[obj.__module__].__file__
306             if fspath.endswith(".pyc"):
307                 fspath = fspath[:-1]
308             lineno = compat_co_firstlineno
309         else:
310             fspath, lineno = getfslineno(obj)
311         modpath = self.getmodpath()
312         assert isinstance(lineno, int)
313         return fspath, lineno, modpath
314 
315 
316 class PyCollector(PyobjMixin, nodes.Collector):
317     def funcnamefilter(self, name):
318         return self._matches_prefix_or_glob_option("python_functions", name)
319 
320     def isnosetest(self, obj):
321         """ Look for the __test__ attribute, which is applied by the
322         @nose.tools.istest decorator
323         """
324         # We explicitly check for "is True" here to not mistakenly treat
325         # classes with a custom __getattr__ returning something truthy (like a
326         # function) as test classes.
327         return safe_getattr(obj, "__test__", False) is True
328 
329     def classnamefilter(self, name):
330         return self._matches_prefix_or_glob_option("python_classes", name)
331 
332     def istestfunction(self, obj, name):
333         if self.funcnamefilter(name) or self.isnosetest(obj):
334             if isinstance(obj, staticmethod):
335                 # static methods need to be unwrapped
336                 obj = safe_getattr(obj, "__func__", False)
337             return (
338                 safe_getattr(obj, "__call__", False)
339                 and fixtures.getfixturemarker(obj) is None
340             )
341         else:
342             return False
343 
344     def istestclass(self, obj, name):
345         return self.classnamefilter(name) or self.isnosetest(obj)
346 
347     def _matches_prefix_or_glob_option(self, option_name, name):
348         """
349         checks if the given name matches the prefix or glob-pattern defined
350         in ini configuration.
351         """
352         for option in self.config.getini(option_name):
353             if name.startswith(option):
354                 return True
355             # check that name looks like a glob-string before calling fnmatch
356             # because this is called for every name in each collected module,
357             # and fnmatch is somewhat expensive to call
358             elif ("*" in option or "?" in option or "[" in option) and fnmatch.fnmatch(
359                 name, option
360             ):
361                 return True
362         return False
363 
364     def collect(self):
365         if not getattr(self.obj, "__test__", True):
366             return []
367 
368         # NB. we avoid random getattrs and peek in the __dict__ instead
369         # (XXX originally introduced from a PyPy need, still true?)
370         dicts = [getattr(self.obj, "__dict__", {})]
371         for basecls in inspect.getmro(self.obj.__class__):
372             dicts.append(basecls.__dict__)
373         seen = {}
374         values = []
375         for dic in dicts:
376             for name, obj in list(dic.items()):
377                 if name in seen:
378                     continue
379                 seen[name] = True
380                 res = self._makeitem(name, obj)
381                 if res is None:
382                     continue
383                 if not isinstance(res, list):
384                     res = [res]
385                 values.extend(res)
386         values.sort(key=lambda item: item.reportinfo()[:2])
387         return values
388 
389     def _makeitem(self, name, obj):
390         # assert self.ihook.fspath == self.fspath, self
391         return self.ihook.pytest_pycollect_makeitem(collector=self, name=name, obj=obj)
392 
393     def _genfunctions(self, name, funcobj):
394         module = self.getparent(Module).obj
395         clscol = self.getparent(Class)
396         cls = clscol and clscol.obj or None
397         fm = self.session._fixturemanager
398 
399         definition = FunctionDefinition(name=name, parent=self, callobj=funcobj)
400         fixtureinfo = fm.getfixtureinfo(definition, funcobj, cls)
401 
402         metafunc = Metafunc(
403             definition, fixtureinfo, self.config, cls=cls, module=module
404         )
405         methods = []
406         if hasattr(module, "pytest_generate_tests"):
407             methods.append(module.pytest_generate_tests)
408         if hasattr(cls, "pytest_generate_tests"):
409             methods.append(cls().pytest_generate_tests)
410         if methods:
411             self.ihook.pytest_generate_tests.call_extra(
412                 methods, dict(metafunc=metafunc)
413             )
414         else:
415             self.ihook.pytest_generate_tests(metafunc=metafunc)
416 
417         if not metafunc._calls:
418             yield Function(name, parent=self, fixtureinfo=fixtureinfo)
419         else:
420             # add funcargs() as fixturedefs to fixtureinfo.arg2fixturedefs
421             fixtures.add_funcarg_pseudo_fixture_def(self, metafunc, fm)
422 
423             # add_funcarg_pseudo_fixture_def may have shadowed some fixtures
424             # with direct parametrization, so make sure we update what the
425             # function really needs.
426             fixtureinfo.prune_dependency_tree()
427 
428             for callspec in metafunc._calls:
429                 subname = "%s[%s]" % (name, callspec.id)
430                 yield Function(
431                     name=subname,
432                     parent=self,
433                     callspec=callspec,
434                     callobj=funcobj,
435                     fixtureinfo=fixtureinfo,
436                     keywords={callspec.id: True},
437                     originalname=name,
438                 )
439 
440 
441 class Module(nodes.File, PyCollector):
442     """ Collector for test classes and functions. """
443 
444     def _getobj(self):
445         return self._importtestmodule()
446 
447     def collect(self):
448         self._inject_setup_module_fixture()
449         self._inject_setup_function_fixture()
450         self.session._fixturemanager.parsefactories(self)
451         return super(Module, self).collect()
452 
453     def _inject_setup_module_fixture(self):
454         """Injects a hidden autouse, module scoped fixture into the collected module object
455         that invokes setUpModule/tearDownModule if either or both are available.
456 
457         Using a fixture to invoke this methods ensures we play nicely and unsurprisingly with
458         other fixtures (#517).
459         """
460         setup_module = _get_non_fixture_func(self.obj, "setUpModule")
461         if setup_module is None:
462             setup_module = _get_non_fixture_func(self.obj, "setup_module")
463 
464         teardown_module = _get_non_fixture_func(self.obj, "tearDownModule")
465         if teardown_module is None:
466             teardown_module = _get_non_fixture_func(self.obj, "teardown_module")
467 
468         if setup_module is None and teardown_module is None:
469             return
470 
471         @fixtures.fixture(autouse=True, scope="module")
472         def xunit_setup_module_fixture(request):
473             if setup_module is not None:
474                 _call_with_optional_argument(setup_module, request.module)
475             yield
476             if teardown_module is not None:
477                 _call_with_optional_argument(teardown_module, request.module)
478 
479         self.obj.__pytest_setup_module = xunit_setup_module_fixture
480 
481     def _inject_setup_function_fixture(self):
482         """Injects a hidden autouse, function scoped fixture into the collected module object
483         that invokes setup_function/teardown_function if either or both are available.
484 
485         Using a fixture to invoke this methods ensures we play nicely and unsurprisingly with
486         other fixtures (#517).
487         """
488         setup_function = _get_non_fixture_func(self.obj, "setup_function")
489         teardown_function = _get_non_fixture_func(self.obj, "teardown_function")
490         if setup_function is None and teardown_function is None:
491             return
492 
493         @fixtures.fixture(autouse=True, scope="function")
494         def xunit_setup_function_fixture(request):
495             if request.instance is not None:
496                 # in this case we are bound to an instance, so we need to let
497                 # setup_method handle this
498                 yield
499                 return
500             if setup_function is not None:
501                 _call_with_optional_argument(setup_function, request.function)
502             yield
503             if teardown_function is not None:
504                 _call_with_optional_argument(teardown_function, request.function)
505 
506         self.obj.__pytest_setup_function = xunit_setup_function_fixture
507 
508     def _importtestmodule(self):
509         # we assume we are only called once per module
510         importmode = self.config.getoption("--import-mode")
511         try:
512             mod = self.fspath.pyimport(ensuresyspath=importmode)
513         except SyntaxError:
514             raise self.CollectError(
515                 _pytest._code.ExceptionInfo.from_current().getrepr(style="short")
516             )
517         except self.fspath.ImportMismatchError:
518             e = sys.exc_info()[1]
519             raise self.CollectError(
520                 "import file mismatch:\n"
521                 "imported module %r has this __file__ attribute:\n"
522                 "  %s\n"
523                 "which is not the same as the test file we want to collect:\n"
524                 "  %s\n"
525                 "HINT: remove __pycache__ / .pyc files and/or use a "
526                 "unique basename for your test file modules" % e.args
527             )
528         except ImportError:
529             from _pytest._code.code import ExceptionInfo
530 
531             exc_info = ExceptionInfo.from_current()
532             if self.config.getoption("verbose") < 2:
533                 exc_info.traceback = exc_info.traceback.filter(filter_traceback)
534             exc_repr = (
535                 exc_info.getrepr(style="short")
536                 if exc_info.traceback
537                 else exc_info.exconly()
538             )
539             formatted_tb = safe_str(exc_repr)
540             raise self.CollectError(
541                 "ImportError while importing test module '{fspath}'.\n"
542                 "Hint: make sure your test modules/packages have valid Python names.\n"
543                 "Traceback:\n"
544                 "{traceback}".format(fspath=self.fspath, traceback=formatted_tb)
545             )
546         except _pytest.runner.Skipped as e:
547             if e.allow_module_level:
548                 raise
549             raise self.CollectError(
550                 "Using pytest.skip outside of a test is not allowed. "
551                 "To decorate a test function, use the @pytest.mark.skip "
552                 "or @pytest.mark.skipif decorators instead, and to skip a "
553                 "module use `pytestmark = pytest.mark.{skip,skipif}."
554             )
555         self.config.pluginmanager.consider_module(mod)
556         return mod
557 
558 
559 class Package(Module):
560     def __init__(self, fspath, parent=None, config=None, session=None, nodeid=None):
561         session = parent.session
562         nodes.FSCollector.__init__(
563             self, fspath, parent=parent, config=config, session=session, nodeid=nodeid
564         )
565         self.name = fspath.dirname
566         self.trace = session.trace
567         self._norecursepatterns = session._norecursepatterns
568         self.fspath = fspath
569 
570     def setup(self):
571         # not using fixtures to call setup_module here because autouse fixtures
572         # from packages are not called automatically (#4085)
573         setup_module = _get_non_fixture_func(self.obj, "setUpModule")
574         if setup_module is None:
575             setup_module = _get_non_fixture_func(self.obj, "setup_module")
576         if setup_module is not None:
577             _call_with_optional_argument(setup_module, self.obj)
578 
579         teardown_module = _get_non_fixture_func(self.obj, "tearDownModule")
580         if teardown_module is None:
581             teardown_module = _get_non_fixture_func(self.obj, "teardown_module")
582         if teardown_module is not None:
583             func = partial(_call_with_optional_argument, teardown_module, self.obj)
584             self.addfinalizer(func)
585 
586     def _recurse(self, dirpath):
587         if dirpath.basename == "__pycache__":
588             return False
589         ihook = self.gethookproxy(dirpath.dirpath())
590         if ihook.pytest_ignore_collect(path=dirpath, config=self.config):
591             return
592         for pat in self._norecursepatterns:
593             if dirpath.check(fnmatch=pat):
594                 return False
595         ihook = self.gethookproxy(dirpath)
596         ihook.pytest_collect_directory(path=dirpath, parent=self)
597         return True
598 
599     def gethookproxy(self, fspath):
600         # check if we have the common case of running
601         # hooks with all conftest.py filesall conftest.py
602         pm = self.config.pluginmanager
603         my_conftestmodules = pm._getconftestmodules(fspath)
604         remove_mods = pm._conftest_plugins.difference(my_conftestmodules)
605         if remove_mods:
606             # one or more conftests are not in use at this fspath
607             proxy = FSHookProxy(fspath, pm, remove_mods)
608         else:
609             # all plugis are active for this fspath
610             proxy = self.config.hook
611         return proxy
612 
613     def _collectfile(self, path, handle_dupes=True):
614         assert path.isfile(), "%r is not a file (isdir=%r, exists=%r, islink=%r)" % (
615             path,
616             path.isdir(),
617             path.exists(),
618             path.islink(),
619         )
620         ihook = self.gethookproxy(path)
621         if not self.isinitpath(path):
622             if ihook.pytest_ignore_collect(path=path, config=self.config):
623                 return ()
624 
625         if handle_dupes:
626             keepduplicates = self.config.getoption("keepduplicates")
627             if not keepduplicates:
628                 duplicate_paths = self.config.pluginmanager._duplicatepaths
629                 if path in duplicate_paths:
630                     return ()
631                 else:
632                     duplicate_paths.add(path)
633 
634         if self.fspath == path:  # __init__.py
635             return [self]
636 
637         return ihook.pytest_collect_file(path=path, parent=self)
638 
639     def isinitpath(self, path):
640         return path in self.session._initialpaths
641 
642     def collect(self):
643         this_path = self.fspath.dirpath()
644         init_module = this_path.join("__init__.py")
645         if init_module.check(file=1) and path_matches_patterns(
646             init_module, self.config.getini("python_files")
647         ):
648             yield Module(init_module, self)
649         pkg_prefixes = set()
650         for path in this_path.visit(rec=self._recurse, bf=True, sort=True):
651             # We will visit our own __init__.py file, in which case we skip it.
652             is_file = path.isfile()
653             if is_file:
654                 if path.basename == "__init__.py" and path.dirpath() == this_path:
655                     continue
656 
657             parts_ = parts(path.strpath)
658             if any(
659                 pkg_prefix in parts_ and pkg_prefix.join("__init__.py") != path
660                 for pkg_prefix in pkg_prefixes
661             ):
662                 continue
663 
664             if is_file:
665                 for x in self._collectfile(path):
666                     yield x
667             elif not path.isdir():
668                 # Broken symlink or invalid/missing file.
669                 continue
670             elif path.join("__init__.py").check(file=1):
671                 pkg_prefixes.add(path)
672 
673 
674 def _get_xunit_setup_teardown(holder, attr_name, param_obj=None):
675     """
676     Return a callable to perform xunit-style setup or teardown if
677     the function exists in the ``holder`` object.
678     The ``param_obj`` parameter is the parameter which will be passed to the function
679     when the callable is called without arguments, defaults to the ``holder`` object.
680     Return ``None`` if a suitable callable is not found.
681     """
682     # TODO: only needed because of Package!
683     param_obj = param_obj if param_obj is not None else holder
684     result = _get_non_fixture_func(holder, attr_name)
685     if result is not None:
686         arg_count = result.__code__.co_argcount
687         if inspect.ismethod(result):
688             arg_count -= 1
689         if arg_count:
690             return lambda: result(param_obj)
691         else:
692             return result
693 
694 
695 def _call_with_optional_argument(func, arg):
696     """Call the given function with the given argument if func accepts one argument, otherwise
697     calls func without arguments"""
698     arg_count = func.__code__.co_argcount
699     if inspect.ismethod(func):
700         arg_count -= 1
701     if arg_count:
702         func(arg)
703     else:
704         func()
705 
706 
707 def _get_non_fixture_func(obj, name):
708     """Return the attribute from the given object to be used as a setup/teardown
709     xunit-style function, but only if not marked as a fixture to
710     avoid calling it twice.
711     """
712     meth = getattr(obj, name, None)
713     if fixtures.getfixturemarker(meth) is None:
714         return meth
715 
716 
717 class Class(PyCollector):
718     """ Collector for test methods. """
719 
720     def collect(self):
721         if not safe_getattr(self.obj, "__test__", True):
722             return []
723         if hasinit(self.obj):
724             self.warn(
725                 PytestCollectionWarning(
726                     "cannot collect test class %r because it has a "
727                     "__init__ constructor" % self.obj.__name__
728                 )
729             )
730             return []
731         elif hasnew(self.obj):
732             self.warn(
733                 PytestCollectionWarning(
734                     "cannot collect test class %r because it has a "
735                     "__new__ constructor" % self.obj.__name__
736                 )
737             )
738             return []
739 
740         self._inject_setup_class_fixture()
741         self._inject_setup_method_fixture()
742 
743         return [Instance(name="()", parent=self)]
744 
745     def _inject_setup_class_fixture(self):
746         """Injects a hidden autouse, class scoped fixture into the collected class object
747         that invokes setup_class/teardown_class if either or both are available.
748 
749         Using a fixture to invoke this methods ensures we play nicely and unsurprisingly with
750         other fixtures (#517).
751         """
752         setup_class = _get_non_fixture_func(self.obj, "setup_class")
753         teardown_class = getattr(self.obj, "teardown_class", None)
754         if setup_class is None and teardown_class is None:
755             return
756 
757         @fixtures.fixture(autouse=True, scope="class")
758         def xunit_setup_class_fixture(cls):
759             if setup_class is not None:
760                 func = getimfunc(setup_class)
761                 _call_with_optional_argument(func, self.obj)
762             yield
763             if teardown_class is not None:
764                 func = getimfunc(teardown_class)
765                 _call_with_optional_argument(func, self.obj)
766 
767         self.obj.__pytest_setup_class = xunit_setup_class_fixture
768 
769     def _inject_setup_method_fixture(self):
770         """Injects a hidden autouse, function scoped fixture into the collected class object
771         that invokes setup_method/teardown_method if either or both are available.
772 
773         Using a fixture to invoke this methods ensures we play nicely and unsurprisingly with
774         other fixtures (#517).
775         """
776         setup_method = _get_non_fixture_func(self.obj, "setup_method")
777         teardown_method = getattr(self.obj, "teardown_method", None)
778         if setup_method is None and teardown_method is None:
779             return
780 
781         @fixtures.fixture(autouse=True, scope="function")
782         def xunit_setup_method_fixture(self, request):
783             method = request.function
784             if setup_method is not None:
785                 func = getattr(self, "setup_method")
786                 _call_with_optional_argument(func, method)
787             yield
788             if teardown_method is not None:
789                 func = getattr(self, "teardown_method")
790                 _call_with_optional_argument(func, method)
791 
792         self.obj.__pytest_setup_method = xunit_setup_method_fixture
793 
794 
795 class Instance(PyCollector):
796     _ALLOW_MARKERS = False  # hack, destroy later
797     # instances share the object with their parents in a way
798     # that duplicates markers instances if not taken out
799     # can be removed at node structure reorganization time
800 
801     def _getobj(self):
802         return self.parent.obj()
803 
804     def collect(self):
805         self.session._fixturemanager.parsefactories(self)
806         return super(Instance, self).collect()
807 
808     def newinstance(self):
809         self.obj = self._getobj()
810         return self.obj
811 
812 
813 class FunctionMixin(PyobjMixin):
814     """ mixin for the code common to Function and Generator.
815     """
816 
817     def setup(self):
818         """ perform setup for this test function. """
819         if isinstance(self.parent, Instance):
820             self.parent.newinstance()
821             self.obj = self._getobj()
822 
823     def _prunetraceback(self, excinfo):
824         if hasattr(self, "_obj") and not self.config.getoption("fulltrace", False):
825             code = _pytest._code.Code(get_real_func(self.obj))
826             path, firstlineno = code.path, code.firstlineno
827             traceback = excinfo.traceback
828             ntraceback = traceback.cut(path=path, firstlineno=firstlineno)
829             if ntraceback == traceback:
830                 ntraceback = ntraceback.cut(path=path)
831                 if ntraceback == traceback:
832                     ntraceback = ntraceback.filter(filter_traceback)
833                     if not ntraceback:
834                         ntraceback = traceback
835 
836             excinfo.traceback = ntraceback.filter()
837             # issue364: mark all but first and last frames to
838             # only show a single-line message for each frame
839             if self.config.getoption("tbstyle", "auto") == "auto":
840                 if len(excinfo.traceback) > 2:
841                     for entry in excinfo.traceback[1:-1]:
842                         entry.set_repr_style("short")
843 
844     def repr_failure(self, excinfo, outerr=None):
845         assert outerr is None, "XXX outerr usage is deprecated"
846         style = self.config.getoption("tbstyle", "auto")
847         if style == "auto":
848             style = "long"
849         return self._repr_failure_py(excinfo, style=style)
850 
851 
852 def hasinit(obj):
853     init = getattr(obj, "__init__", None)
854     if init:
855         return init != object.__init__
856 
857 
858 def hasnew(obj):
859     new = getattr(obj, "__new__", None)
860     if new:
861         return new != object.__new__
862 
863 
864 class CallSpec2(object):
865     def __init__(self, metafunc):
866         self.metafunc = metafunc
867         self.funcargs = {}
868         self._idlist = []
869         self.params = {}
870         self._globalid = NOTSET
871         self._globalparam = NOTSET
872         self._arg2scopenum = {}  # used for sorting parametrized resources
873         self.marks = []
874         self.indices = {}
875 
876     def copy(self):
877         cs = CallSpec2(self.metafunc)
878         cs.funcargs.update(self.funcargs)
879         cs.params.update(self.params)
880         cs.marks.extend(self.marks)
881         cs.indices.update(self.indices)
882         cs._arg2scopenum.update(self._arg2scopenum)
883         cs._idlist = list(self._idlist)
884         cs._globalid = self._globalid
885         cs._globalparam = self._globalparam
886         return cs
887 
888     def _checkargnotcontained(self, arg):
889         if arg in self.params or arg in self.funcargs:
890             raise ValueError("duplicate %r" % (arg,))
891 
892     def getparam(self, name):
893         try:
894             return self.params[name]
895         except KeyError:
896             if self._globalparam is NOTSET:
897                 raise ValueError(name)
898             return self._globalparam
899 
900     @property
901     def id(self):
902         return "-".join(map(str, filter(None, self._idlist)))
903 
904     def setmulti2(self, valtypes, argnames, valset, id, marks, scopenum, param_index):
905         for arg, val in zip(argnames, valset):
906             self._checkargnotcontained(arg)
907             valtype_for_arg = valtypes[arg]
908             getattr(self, valtype_for_arg)[arg] = val
909             self.indices[arg] = param_index
910             self._arg2scopenum[arg] = scopenum
911         self._idlist.append(id)
912         self.marks.extend(normalize_mark_list(marks))
913 
914     def setall(self, funcargs, id, param):
915         for x in funcargs:
916             self._checkargnotcontained(x)
917         self.funcargs.update(funcargs)
918         if id is not NOTSET:
919             self._idlist.append(id)
920         if param is not NOTSET:
921             assert self._globalparam is NOTSET
922             self._globalparam = param
923         for arg in funcargs:
924             self._arg2scopenum[arg] = fixtures.scopenum_function
925 
926 
927 class Metafunc(fixtures.FuncargnamesCompatAttr):
928     """
929     Metafunc objects are passed to the :func:`pytest_generate_tests <_pytest.hookspec.pytest_generate_tests>` hook.
930     They help to inspect a test function and to generate tests according to
931     test configuration or values specified in the class or module where a
932     test function is defined.
933     """
934 
935     def __init__(self, definition, fixtureinfo, config, cls=None, module=None):
936         assert (
937             isinstance(definition, FunctionDefinition)
938             or type(definition).__name__ == "DefinitionMock"
939         )
940         self.definition = definition
941 
942         #: access to the :class:`_pytest.config.Config` object for the test session
943         self.config = config
944 
945         #: the module object where the test function is defined in.
946         self.module = module
947 
948         #: underlying python test function
949         self.function = definition.obj
950 
951         #: set of fixture names required by the test function
952         self.fixturenames = fixtureinfo.names_closure
953 
954         #: class object where the test function is defined in or ``None``.
955         self.cls = cls
956 
957         self._calls = []
958         self._ids = set()
959         self._arg2fixturedefs = fixtureinfo.name2fixturedefs
960 
961     def parametrize(self, argnames, argvalues, indirect=False, ids=None, scope=None):
962         """ Add new invocations to the underlying test function using the list
963         of argvalues for the given argnames.  Parametrization is performed
964         during the collection phase.  If you need to setup expensive resources
965         see about setting indirect to do it rather at test setup time.
966 
967         :arg argnames: a comma-separated string denoting one or more argument
968                        names, or a list/tuple of argument strings.
969 
970         :arg argvalues: The list of argvalues determines how often a
971             test is invoked with different argument values.  If only one
972             argname was specified argvalues is a list of values.  If N
973             argnames were specified, argvalues must be a list of N-tuples,
974             where each tuple-element specifies a value for its respective
975             argname.
976 
977         :arg indirect: The list of argnames or boolean. A list of arguments'
978             names (subset of argnames). If True the list contains all names from
979             the argnames. Each argvalue corresponding to an argname in this list will
980             be passed as request.param to its respective argname fixture
981             function so that it can perform more expensive setups during the
982             setup phase of a test rather than at collection time.
983 
984         :arg ids: list of string ids, or a callable.
985             If strings, each is corresponding to the argvalues so that they are
986             part of the test id. If None is given as id of specific test, the
987             automatically generated id for that argument will be used.
988             If callable, it should take one argument (a single argvalue) and return
989             a string or return None. If None, the automatically generated id for that
990             argument will be used.
991             If no ids are provided they will be generated automatically from
992             the argvalues.
993 
994         :arg scope: if specified it denotes the scope of the parameters.
995             The scope is used for grouping tests by parameter instances.
996             It will also override any fixture-function defined scope, allowing
997             to set a dynamic scope using test context or configuration.
998         """
999         from _pytest.fixtures import scope2index
1000         from _pytest.mark import ParameterSet
1001 
1002         argnames, parameters = ParameterSet._for_parametrize(
1003             argnames,
1004             argvalues,
1005             self.function,
1006             self.config,
1007             function_definition=self.definition,
1008         )
1009         del argvalues
1010 
1011         if scope is None:
1012             scope = _find_parametrized_scope(argnames, self._arg2fixturedefs, indirect)
1013 
1014         self._validate_if_using_arg_names(argnames, indirect)
1015 
1016         arg_values_types = self._resolve_arg_value_types(argnames, indirect)
1017 
1018         ids = self._resolve_arg_ids(argnames, ids, parameters, item=self.definition)
1019 
1020         scopenum = scope2index(
1021             scope, descr="parametrize() call in {}".format(self.function.__name__)
1022         )
1023 
1024         # create the new calls: if we are parametrize() multiple times (by applying the decorator
1025         # more than once) then we accumulate those calls generating the cartesian product
1026         # of all calls
1027         newcalls = []
1028         for callspec in self._calls or [CallSpec2(self)]:
1029             for param_index, (param_id, param_set) in enumerate(zip(ids, parameters)):
1030                 newcallspec = callspec.copy()
1031                 newcallspec.setmulti2(
1032                     arg_values_types,
1033                     argnames,
1034                     param_set.values,
1035                     param_id,
1036                     param_set.marks,
1037                     scopenum,
1038                     param_index,
1039                 )
1040                 newcalls.append(newcallspec)
1041         self._calls = newcalls
1042 
1043     def _resolve_arg_ids(self, argnames, ids, parameters, item):
1044         """Resolves the actual ids for the given argnames, based on the ``ids`` parameter given
1045         to ``parametrize``.
1046 
1047         :param List[str] argnames: list of argument names passed to ``parametrize()``.
1048         :param ids: the ids parameter of the parametrized call (see docs).
1049         :param List[ParameterSet] parameters: the list of parameter values, same size as ``argnames``.
1050         :param Item item: the item that generated this parametrized call.
1051         :rtype: List[str]
1052         :return: the list of ids for each argname given
1053         """
1054         from _pytest._io.saferepr import saferepr
1055 
1056         idfn = None
1057         if callable(ids):
1058             idfn = ids
1059             ids = None
1060         if ids:
1061             func_name = self.function.__name__
1062             if len(ids) != len(parameters):
1063                 msg = "In {}: {} parameter sets specified, with different number of ids: {}"
1064                 fail(msg.format(func_name, len(parameters), len(ids)), pytrace=False)
1065             for id_value in ids:
1066                 if id_value is not None and not isinstance(id_value, six.string_types):
1067                     msg = "In {}: ids must be list of strings, found: {} (type: {!r})"
1068                     fail(
1069                         msg.format(func_name, saferepr(id_value), type(id_value)),
1070                         pytrace=False,
1071                     )
1072         ids = idmaker(argnames, parameters, idfn, ids, self.config, item=item)
1073         return ids
1074 
1075     def _resolve_arg_value_types(self, argnames, indirect):
1076         """Resolves if each parametrized argument must be considered a parameter to a fixture or a "funcarg"
1077         to the function, based on the ``indirect`` parameter of the parametrized() call.
1078 
1079         :param List[str] argnames: list of argument names passed to ``parametrize()``.
1080         :param indirect: same ``indirect`` parameter of ``parametrize()``.
1081         :rtype: Dict[str, str]
1082             A dict mapping each arg name to either:
1083             * "params" if the argname should be the parameter of a fixture of the same name.
1084             * "funcargs" if the argname should be a parameter to the parametrized test function.
1085         """
1086         valtypes = {}
1087         if indirect is True:
1088             valtypes = dict.fromkeys(argnames, "params")
1089         elif indirect is False:
1090             valtypes = dict.fromkeys(argnames, "funcargs")
1091         elif isinstance(indirect, (tuple, list)):
1092             valtypes = dict.fromkeys(argnames, "funcargs")
1093             for arg in indirect:
1094                 if arg not in argnames:
1095                     fail(
1096                         "In {}: indirect fixture '{}' doesn't exist".format(
1097                             self.function.__name__, arg
1098                         ),
1099                         pytrace=False,
1100                     )
1101                 valtypes[arg] = "params"
1102         return valtypes
1103 
1104     def _validate_if_using_arg_names(self, argnames, indirect):
1105         """
1106         Check if all argnames are being used, by default values, or directly/indirectly.
1107 
1108         :param List[str] argnames: list of argument names passed to ``parametrize()``.
1109         :param indirect: same ``indirect`` parameter of ``parametrize()``.
1110         :raise ValueError: if validation fails.
1111         """
1112         default_arg_names = set(get_default_arg_names(self.function))
1113         func_name = self.function.__name__
1114         for arg in argnames:
1115             if arg not in self.fixturenames:
1116                 if arg in default_arg_names:
1117                     fail(
1118                         "In {}: function already takes an argument '{}' with a default value".format(
1119                             func_name, arg
1120                         ),
1121                         pytrace=False,
1122                     )
1123                 else:
1124                     if isinstance(indirect, (tuple, list)):
1125                         name = "fixture" if arg in indirect else "argument"
1126                     else:
1127                         name = "fixture" if indirect else "argument"
1128                     fail(
1129                         "In {}: function uses no {} '{}'".format(func_name, name, arg),
1130                         pytrace=False,
1131                     )
1132 
1133 
1134 def _find_parametrized_scope(argnames, arg2fixturedefs, indirect):
1135     """Find the most appropriate scope for a parametrized call based on its arguments.
1136 
1137     When there's at least one direct argument, always use "function" scope.
1138 
1139     When a test function is parametrized and all its arguments are indirect
1140     (e.g. fixtures), return the most narrow scope based on the fixtures used.
1141 
1142     Related to issue #1832, based on code posted by @Kingdread.
1143     """
1144     from _pytest.fixtures import scopes
1145 
1146     if isinstance(indirect, (list, tuple)):
1147         all_arguments_are_fixtures = len(indirect) == len(argnames)
1148     else:
1149         all_arguments_are_fixtures = bool(indirect)
1150 
1151     if all_arguments_are_fixtures:
1152         fixturedefs = arg2fixturedefs or {}
1153         used_scopes = [
1154             fixturedef[0].scope
1155             for name, fixturedef in fixturedefs.items()
1156             if name in argnames
1157         ]
1158         if used_scopes:
1159             # Takes the most narrow scope from used fixtures
1160             for scope in reversed(scopes):
1161                 if scope in used_scopes:
1162                     return scope
1163 
1164     return "function"
1165 
1166 
1167 def _ascii_escaped_by_config(val, config):
1168     if config is None:
1169         escape_option = False
1170     else:
1171         escape_option = config.getini(
1172             "disable_test_id_escaping_and_forfeit_all_rights_to_community_support"
1173         )
1174     return val if escape_option else ascii_escaped(val)
1175 
1176 
1177 def _idval(val, argname, idx, idfn, item, config):
1178     if idfn:
1179         try:
1180             generated_id = idfn(val)
1181             if generated_id is not None:
1182                 val = generated_id
1183         except Exception as e:
1184             # See issue https://github.com/pytest-dev/pytest/issues/2169
1185             msg = "{}: error raised while trying to determine id of parameter '{}' at position {}\n"
1186             msg = msg.format(item.nodeid, argname, idx)
1187             # we only append the exception type and message because on Python 2 reraise does nothing
1188             msg += "  {}: {}\n".format(type(e).__name__, e)
1189             six.raise_from(ValueError(msg), e)
1190     elif config:
1191         hook_id = config.hook.pytest_make_parametrize_id(
1192             config=config, val=val, argname=argname
1193         )
1194         if hook_id:
1195             return hook_id
1196 
1197     if isinstance(val, STRING_TYPES):
1198         return _ascii_escaped_by_config(val, config)
1199     elif isinstance(val, (float, int, bool, NoneType)):
1200         return str(val)
1201     elif isinstance(val, REGEX_TYPE):
1202         return ascii_escaped(val.pattern)
1203     elif enum is not None and isinstance(val, enum.Enum):
1204         return str(val)
1205     elif (isclass(val) or isfunction(val)) and hasattr(val, "__name__"):
1206         return val.__name__
1207     return str(argname) + str(idx)
1208 
1209 
1210 def _idvalset(idx, parameterset, argnames, idfn, ids, item, config):
1211     if parameterset.id is not None:
1212         return parameterset.id
1213     if ids is None or (idx >= len(ids) or ids[idx] is None):
1214         this_id = [
1215             _idval(val, argname, idx, idfn, item=item, config=config)
1216             for val, argname in zip(parameterset.values, argnames)
1217         ]
1218         return "-".join(this_id)
1219     else:
1220         return ascii_escaped(ids[idx])
1221 
1222 
1223 def idmaker(argnames, parametersets, idfn=None, ids=None, config=None, item=None):
1224     ids = [
1225         _idvalset(valindex, parameterset, argnames, idfn, ids, config=config, item=item)
1226         for valindex, parameterset in enumerate(parametersets)
1227     ]
1228     if len(set(ids)) != len(ids):
1229         # The ids are not unique
1230         duplicates = [testid for testid in ids if ids.count(testid) > 1]
1231         counters = collections.defaultdict(lambda: 0)
1232         for index, testid in enumerate(ids):
1233             if testid in duplicates:
1234                 ids[index] = testid + str(counters[testid])
1235                 counters[testid] += 1
1236     return ids
1237 
1238 
1239 def show_fixtures_per_test(config):
1240     from _pytest.main import wrap_session
1241 
1242     return wrap_session(config, _show_fixtures_per_test)
1243 
1244 
1245 def _show_fixtures_per_test(config, session):
1246     import _pytest.config
1247 
1248     session.perform_collect()
1249     curdir = py.path.local()
1250     tw = _pytest.config.create_terminal_writer(config)
1251     verbose = config.getvalue("verbose")
1252 
1253     def get_best_relpath(func):
1254         loc = getlocation(func, curdir)
1255         return curdir.bestrelpath(loc)
1256 
1257     def write_fixture(fixture_def):
1258         argname = fixture_def.argname
1259         if verbose <= 0 and argname.startswith("_"):
1260             return
1261         if verbose > 0:
1262             bestrel = get_best_relpath(fixture_def.func)
1263             funcargspec = "{} -- {}".format(argname, bestrel)
1264         else:
1265             funcargspec = argname
1266         tw.line(funcargspec, green=True)
1267         fixture_doc = fixture_def.func.__doc__
1268         if fixture_doc:
1269             write_docstring(tw, fixture_doc)
1270         else:
1271             tw.line("    no docstring available", red=True)
1272 
1273     def write_item(item):
1274         try:
1275             info = item._fixtureinfo
1276         except AttributeError:
1277             # doctests items have no _fixtureinfo attribute
1278             return
1279         if not info.name2fixturedefs:
1280             # this test item does not use any fixtures
1281             return
1282         tw.line()
1283         tw.sep("-", "fixtures used by {}".format(item.name))
1284         tw.sep("-", "({})".format(get_best_relpath(item.function)))
1285         # dict key not used in loop but needed for sorting
1286         for _, fixturedefs in sorted(info.name2fixturedefs.items()):
1287             assert fixturedefs is not None
1288             if not fixturedefs:
1289                 continue
1290             # last item is expected to be the one used by the test item
1291             write_fixture(fixturedefs[-1])
1292 
1293     for session_item in session.items:
1294         write_item(session_item)
1295 
1296 
1297 def showfixtures(config):
1298     from _pytest.main import wrap_session
1299 
1300     return wrap_session(config, _showfixtures_main)
1301 
1302 
1303 def _showfixtures_main(config, session):
1304     import _pytest.config
1305 
1306     session.perform_collect()
1307     curdir = py.path.local()
1308     tw = _pytest.config.create_terminal_writer(config)
1309     verbose = config.getvalue("verbose")
1310 
1311     fm = session._fixturemanager
1312 
1313     available = []
1314     seen = set()
1315 
1316     for argname, fixturedefs in fm._arg2fixturedefs.items():
1317         assert fixturedefs is not None
1318         if not fixturedefs:
1319             continue
1320         for fixturedef in fixturedefs:
1321             loc = getlocation(fixturedef.func, curdir)
1322             if (fixturedef.argname, loc) in seen:
1323                 continue
1324             seen.add((fixturedef.argname, loc))
1325             available.append(
1326                 (
1327                     len(fixturedef.baseid),
1328                     fixturedef.func.__module__,
1329                     curdir.bestrelpath(loc),
1330                     fixturedef.argname,
1331                     fixturedef,
1332                 )
1333             )
1334 
1335     available.sort()
1336     currentmodule = None
1337     for baseid, module, bestrel, argname, fixturedef in available:
1338         if currentmodule != module:
1339             if not module.startswith("_pytest."):
1340                 tw.line()
1341                 tw.sep("-", "fixtures defined from %s" % (module,))
1342                 currentmodule = module
1343         if verbose <= 0 and argname[0] == "_":
1344             continue
1345         if verbose > 0:
1346             funcargspec = "%s -- %s" % (argname, bestrel)
1347         else:
1348             funcargspec = argname
1349         tw.line(funcargspec, green=True)
1350         loc = getlocation(fixturedef.func, curdir)
1351         doc = fixturedef.func.__doc__ or ""
1352         if doc:
1353             write_docstring(tw, doc)
1354         else:
1355             tw.line("    %s: no docstring available" % (loc,), red=True)
1356 
1357 
1358 def write_docstring(tw, doc, indent="    "):
1359     doc = doc.rstrip()
1360     if "\n" in doc:
1361         firstline, rest = doc.split("\n", 1)
1362     else:
1363         firstline, rest = doc, ""
1364 
1365     if firstline.strip():
1366         tw.line(indent + firstline.strip())
1367 
1368     if rest:
1369         for line in dedent(rest).split("\n"):
1370             tw.write(indent + line + "\n")
1371 
1372 
1373 class Function(FunctionMixin, nodes.Item, fixtures.FuncargnamesCompatAttr):
1374     """ a Function Item is responsible for setting up and executing a
1375     Python test function.
1376     """
1377 
1378     # disable since functions handle it themselves
1379     _ALLOW_MARKERS = False
1380 
1381     def __init__(
1382         self,
1383         name,
1384         parent,
1385         args=None,
1386         config=None,
1387         callspec=None,
1388         callobj=NOTSET,
1389         keywords=None,
1390         session=None,
1391         fixtureinfo=None,
1392         originalname=None,
1393     ):
1394         super(Function, self).__init__(name, parent, config=config, session=session)
1395         self._args = args
1396         if callobj is not NOTSET:
1397             self.obj = callobj
1398 
1399         self.keywords.update(self.obj.__dict__)
1400         self.own_markers.extend(get_unpacked_marks(self.obj))
1401         if callspec:
1402             self.callspec = callspec
1403             # this is total hostile and a mess
1404             # keywords are broken by design by now
1405             # this will be redeemed later
1406             for mark in callspec.marks:
1407                 # feel free to cry, this was broken for years before
1408                 # and keywords cant fix it per design
1409                 self.keywords[mark.name] = mark
1410             self.own_markers.extend(normalize_mark_list(callspec.marks))
1411         if keywords:
1412             self.keywords.update(keywords)
1413 
1414         # todo: this is a hell of a hack
1415         # https://github.com/pytest-dev/pytest/issues/4569
1416 
1417         self.keywords.update(
1418             dict.fromkeys(
1419                 [
1420                     mark.name
1421                     for mark in self.iter_markers()
1422                     if mark.name not in self.keywords
1423                 ],
1424                 True,
1425             )
1426         )
1427 
1428         if fixtureinfo is None:
1429             fixtureinfo = self.session._fixturemanager.getfixtureinfo(
1430                 self, self.obj, self.cls, funcargs=True
1431             )
1432         self._fixtureinfo = fixtureinfo
1433         self.fixturenames = fixtureinfo.names_closure
1434         self._initrequest()
1435 
1436         #: original function name, without any decorations (for example
1437         #: parametrization adds a ``"[...]"`` suffix to function names).
1438         #:
1439         #: .. versionadded:: 3.0
1440         self.originalname = originalname
1441 
1442     def _initrequest(self):
1443         self.funcargs = {}
1444         self._request = fixtures.FixtureRequest(self)
1445 
1446     @property
1447     def function(self):
1448         "underlying python 'function' object"
1449         return getimfunc(self.obj)
1450 
1451     def _getobj(self):
1452         name = self.name
1453         i = name.find("[")  # parametrization
1454         if i != -1:
1455             name = name[:i]
1456         return getattr(self.parent.obj, name)
1457 
1458     @property
1459     def _pyfuncitem(self):
1460         "(compatonly) for code expecting pytest-2.2 style request objects"
1461         return self
1462 
1463     def runtest(self):
1464         """ execute the underlying test function. """
1465         self.ihook.pytest_pyfunc_call(pyfuncitem=self)
1466 
1467     def setup(self):
1468         super(Function, self).setup()
1469         fixtures.fillfixtures(self)
1470 
1471 
1472 class FunctionDefinition(Function):
1473     """
1474     internal hack until we get actual definition nodes instead of the
1475     crappy metafunc hack
1476     """
1477 
1478     def runtest(self):
1479         raise RuntimeError("function definitions are not supposed to be used")
1480 
1481     setup = runtest

</code><intended_behavior>The code responsible for processing the `--fixtures` command-line argument should be extended to include the fixture's scope in the output. This extension should preserve the current functionality of listing available fixtures but additionally display each fixture's scope (e.g., function, class, module, package, or session) alongside its name and docstring in the output.</intended_behavior>, <file>src/_pytest/fixtures.py</file>
<class>FixtureDef</class>
<method>None</method>
<code>
811 class FixtureDef(object):
812     """ A container for a factory definition. """
813 
814     def __init__(
815         self,
816         fixturemanager,
817         baseid,
818         argname,
819         func,
820         scope,
821         params,
822         unittest=False,
823         ids=None,
824     ):
825         self._fixturemanager = fixturemanager
826         self.baseid = baseid or ""
827         self.has_location = baseid is not None
828         self.func = func
829         self.argname = argname
830         self.scope = scope
831         self.scopenum = scope2index(
832             scope or "function",
833             descr="Fixture '{}'".format(func.__name__),
834             where=baseid,
835         )
836         self.params = params
837         self.argnames = getfuncargnames(func, is_method=unittest)
838         self.unittest = unittest
839         self.ids = ids
840         self._finalizers = []
841 
842     def addfinalizer(self, finalizer):
843         self._finalizers.append(finalizer)
844 
845     def finish(self, request):
846         exceptions = []
847         try:
848             while self._finalizers:
849                 try:
850                     func = self._finalizers.pop()
851                     func()
852                 except:  # noqa
853                     exceptions.append(sys.exc_info())
854             if exceptions:
855                 e = exceptions[0]
856                 del (
857                     exceptions
858                 )  # ensure we don't keep all frames alive because of the traceback
859                 six.reraise(*e)
860 
861         finally:
862             hook = self._fixturemanager.session.gethookproxy(request.node.fspath)
863             hook.pytest_fixture_post_finalizer(fixturedef=self, request=request)
864             # even if finalization fails, we invalidate
865             # the cached fixture value and remove
866             # all finalizers because they may be bound methods which will
867             # keep instances alive
868             if hasattr(self, "cached_result"):
869                 del self.cached_result
870             self._finalizers = []
871 
872     def execute(self, request):
873         # get required arguments and register our own finish()
874         # with their finalization
875         for argname in self.argnames:
876             fixturedef = request._get_active_fixturedef(argname)
877             if argname != "request":
878                 fixturedef.addfinalizer(functools.partial(self.finish, request=request))
879 
880         my_cache_key = request.param_index
881         cached_result = getattr(self, "cached_result", None)
882         if cached_result is not None:
883             result, cache_key, err = cached_result
884             if my_cache_key == cache_key:
885                 if err is not None:
886                     six.reraise(*err)
887                 else:
888                     return result
889             # we have a previous but differently parametrized fixture instance
890             # so we need to tear it down before creating a new one
891             self.finish(request)
892             assert not hasattr(self, "cached_result")
893 
894         hook = self._fixturemanager.session.gethookproxy(request.node.fspath)
895         return hook.pytest_fixture_setup(fixturedef=self, request=request)
896 
897     def __repr__(self):
898         return "<FixtureDef argname=%r scope=%r baseid=%r>" % (
899             self.argname,
900             self.scope,
901             self.baseid,
902         )

</code><intended_behavior>While the `FixtureDef` class may not require a bug fix per se, any enhancements to support the new feature (displaying fixture scopes) would likely involve accessing the `scope` attribute of this class's instances. The modification would ensure that wherever fixture details are being prepared for the `--fixtures` output, the scope is included by retrieving it from the `FixtureDef` instances corresponding to each fixture.</intended_behavior>]
2025-10-18 16:21:12.456 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-18 16:21:12.456 | INFO     | Search-only: skipping patch selection
2025-10-18 16:21:12.526 | INFO     | Task pytest-dev__pytest-5221 completed successfully.
2025-10-18 16:21:12.526 | INFO     | No patch generated. You can try running ACR again.
