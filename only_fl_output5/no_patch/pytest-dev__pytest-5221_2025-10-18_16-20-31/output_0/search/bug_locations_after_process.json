[
    {
        "rel_file_path": "src/_pytest/python.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/pytest-dev__pytest/setup_pytest-dev__pytest__4.4/src/_pytest/python.py",
        "start": 1,
        "end": 1481,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\" Python test discovery, setup and run of test functions. \"\"\"\n2 from __future__ import absolute_import\n3 from __future__ import division\n4 from __future__ import print_function\n5 \n6 import collections\n7 import fnmatch\n8 import inspect\n9 import os\n10 import sys\n11 import warnings\n12 from functools import partial\n13 from textwrap import dedent\n14 \n15 import py\n16 import six\n17 \n18 import _pytest\n19 from _pytest import deprecated\n20 from _pytest import fixtures\n21 from _pytest import nodes\n22 from _pytest._code import filter_traceback\n23 from _pytest.compat import ascii_escaped\n24 from _pytest.compat import enum\n25 from _pytest.compat import get_default_arg_names\n26 from _pytest.compat import get_real_func\n27 from _pytest.compat import getfslineno\n28 from _pytest.compat import getimfunc\n29 from _pytest.compat import getlocation\n30 from _pytest.compat import is_generator\n31 from _pytest.compat import isclass\n32 from _pytest.compat import isfunction\n33 from _pytest.compat import NoneType\n34 from _pytest.compat import NOTSET\n35 from _pytest.compat import REGEX_TYPE\n36 from _pytest.compat import safe_getattr\n37 from _pytest.compat import safe_isclass\n38 from _pytest.compat import safe_str\n39 from _pytest.compat import STRING_TYPES\n40 from _pytest.config import hookimpl\n41 from _pytest.main import FSHookProxy\n42 from _pytest.mark import MARK_GEN\n43 from _pytest.mark.structures import get_unpacked_marks\n44 from _pytest.mark.structures import normalize_mark_list\n45 from _pytest.outcomes import fail\n46 from _pytest.outcomes import skip\n47 from _pytest.pathlib import parts\n48 from _pytest.warning_types import PytestCollectionWarning\n49 from _pytest.warning_types import PytestUnhandledCoroutineWarning\n50 \n51 \n52 def pyobj_property(name):\n53     def get(self):\n54         node = self.getparent(getattr(__import__(\"pytest\"), name))\n55         if node is not None:\n56             return node.obj\n57 \n58     doc = \"python %s object this node was collected from (can be None).\" % (\n59         name.lower(),\n60     )\n61     return property(get, None, None, doc)\n62 \n63 \n64 def pytest_addoption(parser):\n65     group = parser.getgroup(\"general\")\n66     group.addoption(\n67         \"--fixtures\",\n68         \"--funcargs\",\n69         action=\"store_true\",\n70         dest=\"showfixtures\",\n71         default=False,\n72         help=\"show available fixtures, sorted by plugin appearance \"\n73         \"(fixtures with leading '_' are only shown with '-v')\",\n74     )\n75     group.addoption(\n76         \"--fixtures-per-test\",\n77         action=\"store_true\",\n78         dest=\"show_fixtures_per_test\",\n79         default=False,\n80         help=\"show fixtures per test\",\n81     )\n82     parser.addini(\n83         \"usefixtures\",\n84         type=\"args\",\n85         default=[],\n86         help=\"list of default fixtures to be used with this project\",\n87     )\n88     parser.addini(\n89         \"python_files\",\n90         type=\"args\",\n91         default=[\"test_*.py\", \"*_test.py\"],\n92         help=\"glob-style file patterns for Python test module discovery\",\n93     )\n94     parser.addini(\n95         \"python_classes\",\n96         type=\"args\",\n97         default=[\"Test\"],\n98         help=\"prefixes or glob names for Python test class discovery\",\n99     )\n100     parser.addini(\n101         \"python_functions\",\n102         type=\"args\",\n103         default=[\"test\"],\n104         help=\"prefixes or glob names for Python test function and method discovery\",\n105     )\n106     parser.addini(\n107         \"disable_test_id_escaping_and_forfeit_all_rights_to_community_support\",\n108         type=\"bool\",\n109         default=False,\n110         help=\"disable string escape non-ascii characters, might cause unwanted \"\n111         \"side effects(use at your own risk)\",\n112     )\n113 \n114     group.addoption(\n115         \"--import-mode\",\n116         default=\"prepend\",\n117         choices=[\"prepend\", \"append\"],\n118         dest=\"importmode\",\n119         help=\"prepend/append to sys.path when importing test modules, \"\n120         \"default is to prepend.\",\n121     )\n122 \n123 \n124 def pytest_cmdline_main(config):\n125     if config.option.showfixtures:\n126         showfixtures(config)\n127         return 0\n128     if config.option.show_fixtures_per_test:\n129         show_fixtures_per_test(config)\n130         return 0\n131 \n132 \n133 def pytest_generate_tests(metafunc):\n134     # those alternative spellings are common - raise a specific error to alert\n135     # the user\n136     alt_spellings = [\"parameterize\", \"parametrise\", \"parameterise\"]\n137     for mark_name in alt_spellings:\n138         if metafunc.definition.get_closest_marker(mark_name):\n139             msg = \"{0} has '{1}' mark, spelling should be 'parametrize'\"\n140             fail(msg.format(metafunc.function.__name__, mark_name), pytrace=False)\n141     for marker in metafunc.definition.iter_markers(name=\"parametrize\"):\n142         metafunc.parametrize(*marker.args, **marker.kwargs)\n143 \n144 \n145 def pytest_configure(config):\n146     config.addinivalue_line(\n147         \"markers\",\n148         \"parametrize(argnames, argvalues): call a test function multiple \"\n149         \"times passing in different arguments in turn. argvalues generally \"\n150         \"needs to be a list of values if argnames specifies only one name \"\n151         \"or a list of tuples of values if argnames specifies multiple names. \"\n152         \"Example: @parametrize('arg1', [1,2]) would lead to two calls of the \"\n153         \"decorated test function, one with arg1=1 and another with arg1=2.\"\n154         \"see https://docs.pytest.org/en/latest/parametrize.html for more info \"\n155         \"and examples.\",\n156     )\n157     config.addinivalue_line(\n158         \"markers\",\n159         \"usefixtures(fixturename1, fixturename2, ...): mark tests as needing \"\n160         \"all of the specified fixtures. see \"\n161         \"https://docs.pytest.org/en/latest/fixture.html#usefixtures \",\n162     )\n163 \n164 \n165 @hookimpl(trylast=True)\n166 def pytest_pyfunc_call(pyfuncitem):\n167     testfunction = pyfuncitem.obj\n168     iscoroutinefunction = getattr(inspect, \"iscoroutinefunction\", None)\n169     if iscoroutinefunction is not None and iscoroutinefunction(testfunction):\n170         msg = \"Coroutine functions are not natively supported and have been skipped.\\n\"\n171         msg += \"You need to install a suitable plugin for your async framework, for example:\\n\"\n172         msg += \"  - pytest-asyncio\\n\"\n173         msg += \"  - pytest-trio\\n\"\n174         msg += \"  - pytest-tornasync\"\n175         warnings.warn(PytestUnhandledCoroutineWarning(msg.format(pyfuncitem.nodeid)))\n176         skip(msg=\"coroutine function and no async plugin installed (see warnings)\")\n177     funcargs = pyfuncitem.funcargs\n178     testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}\n179     testfunction(**testargs)\n180     return True\n181 \n182 \n183 def pytest_collect_file(path, parent):\n184     ext = path.ext\n185     if ext == \".py\":\n186         if not parent.session.isinitpath(path):\n187             if not path_matches_patterns(\n188                 path, parent.config.getini(\"python_files\") + [\"__init__.py\"]\n189             ):\n190                 return\n191         ihook = parent.session.gethookproxy(path)\n192         return ihook.pytest_pycollect_makemodule(path=path, parent=parent)\n193 \n194 \n195 def path_matches_patterns(path, patterns):\n196     \"\"\"Returns True if the given py.path.local matches one of the patterns in the list of globs given\"\"\"\n197     return any(path.fnmatch(pattern) for pattern in patterns)\n198 \n199 \n200 def pytest_pycollect_makemodule(path, parent):\n201     if path.basename == \"__init__.py\":\n202         return Package(path, parent)\n203     return Module(path, parent)\n204 \n205 \n206 @hookimpl(hookwrapper=True)\n207 def pytest_pycollect_makeitem(collector, name, obj):\n208     outcome = yield\n209     res = outcome.get_result()\n210     if res is not None:\n211         return\n212     # nothing was collected elsewhere, let's do it here\n213     if safe_isclass(obj):\n214         if collector.istestclass(obj, name):\n215             outcome.force_result(Class(name, parent=collector))\n216     elif collector.istestfunction(obj, name):\n217         # mock seems to store unbound methods (issue473), normalize it\n218         obj = getattr(obj, \"__func__\", obj)\n219         # We need to try and unwrap the function if it's a functools.partial\n220         # or a funtools.wrapped.\n221         # We musn't if it's been wrapped with mock.patch (python 2 only)\n222         if not (isfunction(obj) or isfunction(get_real_func(obj))):\n223             filename, lineno = getfslineno(obj)\n224             warnings.warn_explicit(\n225                 message=PytestCollectionWarning(\n226                     \"cannot collect %r because it is not a function.\" % name\n227                 ),\n228                 category=None,\n229                 filename=str(filename),\n230                 lineno=lineno + 1,\n231             )\n232         elif getattr(obj, \"__test__\", True):\n233             if is_generator(obj):\n234                 res = Function(name, parent=collector)\n235                 reason = deprecated.YIELD_TESTS.format(name=name)\n236                 res.add_marker(MARK_GEN.xfail(run=False, reason=reason))\n237                 res.warn(PytestCollectionWarning(reason))\n238             else:\n239                 res = list(collector._genfunctions(name, obj))\n240             outcome.force_result(res)\n241 \n242 \n243 def pytest_make_parametrize_id(config, val, argname=None):\n244     return None\n245 \n246 \n247 class PyobjContext(object):\n248     module = pyobj_property(\"Module\")\n249     cls = pyobj_property(\"Class\")\n250     instance = pyobj_property(\"Instance\")\n251 \n252 \n253 class PyobjMixin(PyobjContext):\n254     _ALLOW_MARKERS = True\n255 \n256     def __init__(self, *k, **kw):\n257         super(PyobjMixin, self).__init__(*k, **kw)\n258 \n259     @property\n260     def obj(self):\n261         \"\"\"Underlying Python object.\"\"\"\n262         obj = getattr(self, \"_obj\", None)\n263         if obj is None:\n264             self._obj = obj = self._getobj()\n265             # XXX evil hack\n266             # used to avoid Instance collector marker duplication\n267             if self._ALLOW_MARKERS:\n268                 self.own_markers.extend(get_unpacked_marks(self.obj))\n269         return obj\n270 \n271     @obj.setter\n272     def obj(self, value):\n273         self._obj = value\n274 \n275     def _getobj(self):\n276         \"\"\"Gets the underlying Python object. May be overwritten by subclasses.\"\"\"\n277         return getattr(self.parent.obj, self.name)\n278 \n279     def getmodpath(self, stopatmodule=True, includemodule=False):\n280         \"\"\" return python path relative to the containing module. \"\"\"\n281         chain = self.listchain()\n282         chain.reverse()\n283         parts = []\n284         for node in chain:\n285             if isinstance(node, Instance):\n286                 continue\n287             name = node.name\n288             if isinstance(node, Module):\n289                 name = os.path.splitext(name)[0]\n290                 if stopatmodule:\n291                     if includemodule:\n292                         parts.append(name)\n293                     break\n294             parts.append(name)\n295         parts.reverse()\n296         s = \".\".join(parts)\n297         return s.replace(\".[\", \"[\")\n298 \n299     def reportinfo(self):\n300         # XXX caching?\n301         obj = self.obj\n302         compat_co_firstlineno = getattr(obj, \"compat_co_firstlineno\", None)\n303         if isinstance(compat_co_firstlineno, int):\n304             # nose compatibility\n305             fspath = sys.modules[obj.__module__].__file__\n306             if fspath.endswith(\".pyc\"):\n307                 fspath = fspath[:-1]\n308             lineno = compat_co_firstlineno\n309         else:\n310             fspath, lineno = getfslineno(obj)\n311         modpath = self.getmodpath()\n312         assert isinstance(lineno, int)\n313         return fspath, lineno, modpath\n314 \n315 \n316 class PyCollector(PyobjMixin, nodes.Collector):\n317     def funcnamefilter(self, name):\n318         return self._matches_prefix_or_glob_option(\"python_functions\", name)\n319 \n320     def isnosetest(self, obj):\n321         \"\"\" Look for the __test__ attribute, which is applied by the\n322         @nose.tools.istest decorator\n323         \"\"\"\n324         # We explicitly check for \"is True\" here to not mistakenly treat\n325         # classes with a custom __getattr__ returning something truthy (like a\n326         # function) as test classes.\n327         return safe_getattr(obj, \"__test__\", False) is True\n328 \n329     def classnamefilter(self, name):\n330         return self._matches_prefix_or_glob_option(\"python_classes\", name)\n331 \n332     def istestfunction(self, obj, name):\n333         if self.funcnamefilter(name) or self.isnosetest(obj):\n334             if isinstance(obj, staticmethod):\n335                 # static methods need to be unwrapped\n336                 obj = safe_getattr(obj, \"__func__\", False)\n337             return (\n338                 safe_getattr(obj, \"__call__\", False)\n339                 and fixtures.getfixturemarker(obj) is None\n340             )\n341         else:\n342             return False\n343 \n344     def istestclass(self, obj, name):\n345         return self.classnamefilter(name) or self.isnosetest(obj)\n346 \n347     def _matches_prefix_or_glob_option(self, option_name, name):\n348         \"\"\"\n349         checks if the given name matches the prefix or glob-pattern defined\n350         in ini configuration.\n351         \"\"\"\n352         for option in self.config.getini(option_name):\n353             if name.startswith(option):\n354                 return True\n355             # check that name looks like a glob-string before calling fnmatch\n356             # because this is called for every name in each collected module,\n357             # and fnmatch is somewhat expensive to call\n358             elif (\"*\" in option or \"?\" in option or \"[\" in option) and fnmatch.fnmatch(\n359                 name, option\n360             ):\n361                 return True\n362         return False\n363 \n364     def collect(self):\n365         if not getattr(self.obj, \"__test__\", True):\n366             return []\n367 \n368         # NB. we avoid random getattrs and peek in the __dict__ instead\n369         # (XXX originally introduced from a PyPy need, still true?)\n370         dicts = [getattr(self.obj, \"__dict__\", {})]\n371         for basecls in inspect.getmro(self.obj.__class__):\n372             dicts.append(basecls.__dict__)\n373         seen = {}\n374         values = []\n375         for dic in dicts:\n376             for name, obj in list(dic.items()):\n377                 if name in seen:\n378                     continue\n379                 seen[name] = True\n380                 res = self._makeitem(name, obj)\n381                 if res is None:\n382                     continue\n383                 if not isinstance(res, list):\n384                     res = [res]\n385                 values.extend(res)\n386         values.sort(key=lambda item: item.reportinfo()[:2])\n387         return values\n388 \n389     def _makeitem(self, name, obj):\n390         # assert self.ihook.fspath == self.fspath, self\n391         return self.ihook.pytest_pycollect_makeitem(collector=self, name=name, obj=obj)\n392 \n393     def _genfunctions(self, name, funcobj):\n394         module = self.getparent(Module).obj\n395         clscol = self.getparent(Class)\n396         cls = clscol and clscol.obj or None\n397         fm = self.session._fixturemanager\n398 \n399         definition = FunctionDefinition(name=name, parent=self, callobj=funcobj)\n400         fixtureinfo = fm.getfixtureinfo(definition, funcobj, cls)\n401 \n402         metafunc = Metafunc(\n403             definition, fixtureinfo, self.config, cls=cls, module=module\n404         )\n405         methods = []\n406         if hasattr(module, \"pytest_generate_tests\"):\n407             methods.append(module.pytest_generate_tests)\n408         if hasattr(cls, \"pytest_generate_tests\"):\n409             methods.append(cls().pytest_generate_tests)\n410         if methods:\n411             self.ihook.pytest_generate_tests.call_extra(\n412                 methods, dict(metafunc=metafunc)\n413             )\n414         else:\n415             self.ihook.pytest_generate_tests(metafunc=metafunc)\n416 \n417         if not metafunc._calls:\n418             yield Function(name, parent=self, fixtureinfo=fixtureinfo)\n419         else:\n420             # add funcargs() as fixturedefs to fixtureinfo.arg2fixturedefs\n421             fixtures.add_funcarg_pseudo_fixture_def(self, metafunc, fm)\n422 \n423             # add_funcarg_pseudo_fixture_def may have shadowed some fixtures\n424             # with direct parametrization, so make sure we update what the\n425             # function really needs.\n426             fixtureinfo.prune_dependency_tree()\n427 \n428             for callspec in metafunc._calls:\n429                 subname = \"%s[%s]\" % (name, callspec.id)\n430                 yield Function(\n431                     name=subname,\n432                     parent=self,\n433                     callspec=callspec,\n434                     callobj=funcobj,\n435                     fixtureinfo=fixtureinfo,\n436                     keywords={callspec.id: True},\n437                     originalname=name,\n438                 )\n439 \n440 \n441 class Module(nodes.File, PyCollector):\n442     \"\"\" Collector for test classes and functions. \"\"\"\n443 \n444     def _getobj(self):\n445         return self._importtestmodule()\n446 \n447     def collect(self):\n448         self._inject_setup_module_fixture()\n449         self._inject_setup_function_fixture()\n450         self.session._fixturemanager.parsefactories(self)\n451         return super(Module, self).collect()\n452 \n453     def _inject_setup_module_fixture(self):\n454         \"\"\"Injects a hidden autouse, module scoped fixture into the collected module object\n455         that invokes setUpModule/tearDownModule if either or both are available.\n456 \n457         Using a fixture to invoke this methods ensures we play nicely and unsurprisingly with\n458         other fixtures (#517).\n459         \"\"\"\n460         setup_module = _get_non_fixture_func(self.obj, \"setUpModule\")\n461         if setup_module is None:\n462             setup_module = _get_non_fixture_func(self.obj, \"setup_module\")\n463 \n464         teardown_module = _get_non_fixture_func(self.obj, \"tearDownModule\")\n465         if teardown_module is None:\n466             teardown_module = _get_non_fixture_func(self.obj, \"teardown_module\")\n467 \n468         if setup_module is None and teardown_module is None:\n469             return\n470 \n471         @fixtures.fixture(autouse=True, scope=\"module\")\n472         def xunit_setup_module_fixture(request):\n473             if setup_module is not None:\n474                 _call_with_optional_argument(setup_module, request.module)\n475             yield\n476             if teardown_module is not None:\n477                 _call_with_optional_argument(teardown_module, request.module)\n478 \n479         self.obj.__pytest_setup_module = xunit_setup_module_fixture\n480 \n481     def _inject_setup_function_fixture(self):\n482         \"\"\"Injects a hidden autouse, function scoped fixture into the collected module object\n483         that invokes setup_function/teardown_function if either or both are available.\n484 \n485         Using a fixture to invoke this methods ensures we play nicely and unsurprisingly with\n486         other fixtures (#517).\n487         \"\"\"\n488         setup_function = _get_non_fixture_func(self.obj, \"setup_function\")\n489         teardown_function = _get_non_fixture_func(self.obj, \"teardown_function\")\n490         if setup_function is None and teardown_function is None:\n491             return\n492 \n493         @fixtures.fixture(autouse=True, scope=\"function\")\n494         def xunit_setup_function_fixture(request):\n495             if request.instance is not None:\n496                 # in this case we are bound to an instance, so we need to let\n497                 # setup_method handle this\n498                 yield\n499                 return\n500             if setup_function is not None:\n501                 _call_with_optional_argument(setup_function, request.function)\n502             yield\n503             if teardown_function is not None:\n504                 _call_with_optional_argument(teardown_function, request.function)\n505 \n506         self.obj.__pytest_setup_function = xunit_setup_function_fixture\n507 \n508     def _importtestmodule(self):\n509         # we assume we are only called once per module\n510         importmode = self.config.getoption(\"--import-mode\")\n511         try:\n512             mod = self.fspath.pyimport(ensuresyspath=importmode)\n513         except SyntaxError:\n514             raise self.CollectError(\n515                 _pytest._code.ExceptionInfo.from_current().getrepr(style=\"short\")\n516             )\n517         except self.fspath.ImportMismatchError:\n518             e = sys.exc_info()[1]\n519             raise self.CollectError(\n520                 \"import file mismatch:\\n\"\n521                 \"imported module %r has this __file__ attribute:\\n\"\n522                 \"  %s\\n\"\n523                 \"which is not the same as the test file we want to collect:\\n\"\n524                 \"  %s\\n\"\n525                 \"HINT: remove __pycache__ / .pyc files and/or use a \"\n526                 \"unique basename for your test file modules\" % e.args\n527             )\n528         except ImportError:\n529             from _pytest._code.code import ExceptionInfo\n530 \n531             exc_info = ExceptionInfo.from_current()\n532             if self.config.getoption(\"verbose\") < 2:\n533                 exc_info.traceback = exc_info.traceback.filter(filter_traceback)\n534             exc_repr = (\n535                 exc_info.getrepr(style=\"short\")\n536                 if exc_info.traceback\n537                 else exc_info.exconly()\n538             )\n539             formatted_tb = safe_str(exc_repr)\n540             raise self.CollectError(\n541                 \"ImportError while importing test module '{fspath}'.\\n\"\n542                 \"Hint: make sure your test modules/packages have valid Python names.\\n\"\n543                 \"Traceback:\\n\"\n544                 \"{traceback}\".format(fspath=self.fspath, traceback=formatted_tb)\n545             )\n546         except _pytest.runner.Skipped as e:\n547             if e.allow_module_level:\n548                 raise\n549             raise self.CollectError(\n550                 \"Using pytest.skip outside of a test is not allowed. \"\n551                 \"To decorate a test function, use the @pytest.mark.skip \"\n552                 \"or @pytest.mark.skipif decorators instead, and to skip a \"\n553                 \"module use `pytestmark = pytest.mark.{skip,skipif}.\"\n554             )\n555         self.config.pluginmanager.consider_module(mod)\n556         return mod\n557 \n558 \n559 class Package(Module):\n560     def __init__(self, fspath, parent=None, config=None, session=None, nodeid=None):\n561         session = parent.session\n562         nodes.FSCollector.__init__(\n563             self, fspath, parent=parent, config=config, session=session, nodeid=nodeid\n564         )\n565         self.name = fspath.dirname\n566         self.trace = session.trace\n567         self._norecursepatterns = session._norecursepatterns\n568         self.fspath = fspath\n569 \n570     def setup(self):\n571         # not using fixtures to call setup_module here because autouse fixtures\n572         # from packages are not called automatically (#4085)\n573         setup_module = _get_non_fixture_func(self.obj, \"setUpModule\")\n574         if setup_module is None:\n575             setup_module = _get_non_fixture_func(self.obj, \"setup_module\")\n576         if setup_module is not None:\n577             _call_with_optional_argument(setup_module, self.obj)\n578 \n579         teardown_module = _get_non_fixture_func(self.obj, \"tearDownModule\")\n580         if teardown_module is None:\n581             teardown_module = _get_non_fixture_func(self.obj, \"teardown_module\")\n582         if teardown_module is not None:\n583             func = partial(_call_with_optional_argument, teardown_module, self.obj)\n584             self.addfinalizer(func)\n585 \n586     def _recurse(self, dirpath):\n587         if dirpath.basename == \"__pycache__\":\n588             return False\n589         ihook = self.gethookproxy(dirpath.dirpath())\n590         if ihook.pytest_ignore_collect(path=dirpath, config=self.config):\n591             return\n592         for pat in self._norecursepatterns:\n593             if dirpath.check(fnmatch=pat):\n594                 return False\n595         ihook = self.gethookproxy(dirpath)\n596         ihook.pytest_collect_directory(path=dirpath, parent=self)\n597         return True\n598 \n599     def gethookproxy(self, fspath):\n600         # check if we have the common case of running\n601         # hooks with all conftest.py filesall conftest.py\n602         pm = self.config.pluginmanager\n603         my_conftestmodules = pm._getconftestmodules(fspath)\n604         remove_mods = pm._conftest_plugins.difference(my_conftestmodules)\n605         if remove_mods:\n606             # one or more conftests are not in use at this fspath\n607             proxy = FSHookProxy(fspath, pm, remove_mods)\n608         else:\n609             # all plugis are active for this fspath\n610             proxy = self.config.hook\n611         return proxy\n612 \n613     def _collectfile(self, path, handle_dupes=True):\n614         assert path.isfile(), \"%r is not a file (isdir=%r, exists=%r, islink=%r)\" % (\n615             path,\n616             path.isdir(),\n617             path.exists(),\n618             path.islink(),\n619         )\n620         ihook = self.gethookproxy(path)\n621         if not self.isinitpath(path):\n622             if ihook.pytest_ignore_collect(path=path, config=self.config):\n623                 return ()\n624 \n625         if handle_dupes:\n626             keepduplicates = self.config.getoption(\"keepduplicates\")\n627             if not keepduplicates:\n628                 duplicate_paths = self.config.pluginmanager._duplicatepaths\n629                 if path in duplicate_paths:\n630                     return ()\n631                 else:\n632                     duplicate_paths.add(path)\n633 \n634         if self.fspath == path:  # __init__.py\n635             return [self]\n636 \n637         return ihook.pytest_collect_file(path=path, parent=self)\n638 \n639     def isinitpath(self, path):\n640         return path in self.session._initialpaths\n641 \n642     def collect(self):\n643         this_path = self.fspath.dirpath()\n644         init_module = this_path.join(\"__init__.py\")\n645         if init_module.check(file=1) and path_matches_patterns(\n646             init_module, self.config.getini(\"python_files\")\n647         ):\n648             yield Module(init_module, self)\n649         pkg_prefixes = set()\n650         for path in this_path.visit(rec=self._recurse, bf=True, sort=True):\n651             # We will visit our own __init__.py file, in which case we skip it.\n652             is_file = path.isfile()\n653             if is_file:\n654                 if path.basename == \"__init__.py\" and path.dirpath() == this_path:\n655                     continue\n656 \n657             parts_ = parts(path.strpath)\n658             if any(\n659                 pkg_prefix in parts_ and pkg_prefix.join(\"__init__.py\") != path\n660                 for pkg_prefix in pkg_prefixes\n661             ):\n662                 continue\n663 \n664             if is_file:\n665                 for x in self._collectfile(path):\n666                     yield x\n667             elif not path.isdir():\n668                 # Broken symlink or invalid/missing file.\n669                 continue\n670             elif path.join(\"__init__.py\").check(file=1):\n671                 pkg_prefixes.add(path)\n672 \n673 \n674 def _get_xunit_setup_teardown(holder, attr_name, param_obj=None):\n675     \"\"\"\n676     Return a callable to perform xunit-style setup or teardown if\n677     the function exists in the ``holder`` object.\n678     The ``param_obj`` parameter is the parameter which will be passed to the function\n679     when the callable is called without arguments, defaults to the ``holder`` object.\n680     Return ``None`` if a suitable callable is not found.\n681     \"\"\"\n682     # TODO: only needed because of Package!\n683     param_obj = param_obj if param_obj is not None else holder\n684     result = _get_non_fixture_func(holder, attr_name)\n685     if result is not None:\n686         arg_count = result.__code__.co_argcount\n687         if inspect.ismethod(result):\n688             arg_count -= 1\n689         if arg_count:\n690             return lambda: result(param_obj)\n691         else:\n692             return result\n693 \n694 \n695 def _call_with_optional_argument(func, arg):\n696     \"\"\"Call the given function with the given argument if func accepts one argument, otherwise\n697     calls func without arguments\"\"\"\n698     arg_count = func.__code__.co_argcount\n699     if inspect.ismethod(func):\n700         arg_count -= 1\n701     if arg_count:\n702         func(arg)\n703     else:\n704         func()\n705 \n706 \n707 def _get_non_fixture_func(obj, name):\n708     \"\"\"Return the attribute from the given object to be used as a setup/teardown\n709     xunit-style function, but only if not marked as a fixture to\n710     avoid calling it twice.\n711     \"\"\"\n712     meth = getattr(obj, name, None)\n713     if fixtures.getfixturemarker(meth) is None:\n714         return meth\n715 \n716 \n717 class Class(PyCollector):\n718     \"\"\" Collector for test methods. \"\"\"\n719 \n720     def collect(self):\n721         if not safe_getattr(self.obj, \"__test__\", True):\n722             return []\n723         if hasinit(self.obj):\n724             self.warn(\n725                 PytestCollectionWarning(\n726                     \"cannot collect test class %r because it has a \"\n727                     \"__init__ constructor\" % self.obj.__name__\n728                 )\n729             )\n730             return []\n731         elif hasnew(self.obj):\n732             self.warn(\n733                 PytestCollectionWarning(\n734                     \"cannot collect test class %r because it has a \"\n735                     \"__new__ constructor\" % self.obj.__name__\n736                 )\n737             )\n738             return []\n739 \n740         self._inject_setup_class_fixture()\n741         self._inject_setup_method_fixture()\n742 \n743         return [Instance(name=\"()\", parent=self)]\n744 \n745     def _inject_setup_class_fixture(self):\n746         \"\"\"Injects a hidden autouse, class scoped fixture into the collected class object\n747         that invokes setup_class/teardown_class if either or both are available.\n748 \n749         Using a fixture to invoke this methods ensures we play nicely and unsurprisingly with\n750         other fixtures (#517).\n751         \"\"\"\n752         setup_class = _get_non_fixture_func(self.obj, \"setup_class\")\n753         teardown_class = getattr(self.obj, \"teardown_class\", None)\n754         if setup_class is None and teardown_class is None:\n755             return\n756 \n757         @fixtures.fixture(autouse=True, scope=\"class\")\n758         def xunit_setup_class_fixture(cls):\n759             if setup_class is not None:\n760                 func = getimfunc(setup_class)\n761                 _call_with_optional_argument(func, self.obj)\n762             yield\n763             if teardown_class is not None:\n764                 func = getimfunc(teardown_class)\n765                 _call_with_optional_argument(func, self.obj)\n766 \n767         self.obj.__pytest_setup_class = xunit_setup_class_fixture\n768 \n769     def _inject_setup_method_fixture(self):\n770         \"\"\"Injects a hidden autouse, function scoped fixture into the collected class object\n771         that invokes setup_method/teardown_method if either or both are available.\n772 \n773         Using a fixture to invoke this methods ensures we play nicely and unsurprisingly with\n774         other fixtures (#517).\n775         \"\"\"\n776         setup_method = _get_non_fixture_func(self.obj, \"setup_method\")\n777         teardown_method = getattr(self.obj, \"teardown_method\", None)\n778         if setup_method is None and teardown_method is None:\n779             return\n780 \n781         @fixtures.fixture(autouse=True, scope=\"function\")\n782         def xunit_setup_method_fixture(self, request):\n783             method = request.function\n784             if setup_method is not None:\n785                 func = getattr(self, \"setup_method\")\n786                 _call_with_optional_argument(func, method)\n787             yield\n788             if teardown_method is not None:\n789                 func = getattr(self, \"teardown_method\")\n790                 _call_with_optional_argument(func, method)\n791 \n792         self.obj.__pytest_setup_method = xunit_setup_method_fixture\n793 \n794 \n795 class Instance(PyCollector):\n796     _ALLOW_MARKERS = False  # hack, destroy later\n797     # instances share the object with their parents in a way\n798     # that duplicates markers instances if not taken out\n799     # can be removed at node structure reorganization time\n800 \n801     def _getobj(self):\n802         return self.parent.obj()\n803 \n804     def collect(self):\n805         self.session._fixturemanager.parsefactories(self)\n806         return super(Instance, self).collect()\n807 \n808     def newinstance(self):\n809         self.obj = self._getobj()\n810         return self.obj\n811 \n812 \n813 class FunctionMixin(PyobjMixin):\n814     \"\"\" mixin for the code common to Function and Generator.\n815     \"\"\"\n816 \n817     def setup(self):\n818         \"\"\" perform setup for this test function. \"\"\"\n819         if isinstance(self.parent, Instance):\n820             self.parent.newinstance()\n821             self.obj = self._getobj()\n822 \n823     def _prunetraceback(self, excinfo):\n824         if hasattr(self, \"_obj\") and not self.config.getoption(\"fulltrace\", False):\n825             code = _pytest._code.Code(get_real_func(self.obj))\n826             path, firstlineno = code.path, code.firstlineno\n827             traceback = excinfo.traceback\n828             ntraceback = traceback.cut(path=path, firstlineno=firstlineno)\n829             if ntraceback == traceback:\n830                 ntraceback = ntraceback.cut(path=path)\n831                 if ntraceback == traceback:\n832                     ntraceback = ntraceback.filter(filter_traceback)\n833                     if not ntraceback:\n834                         ntraceback = traceback\n835 \n836             excinfo.traceback = ntraceback.filter()\n837             # issue364: mark all but first and last frames to\n838             # only show a single-line message for each frame\n839             if self.config.getoption(\"tbstyle\", \"auto\") == \"auto\":\n840                 if len(excinfo.traceback) > 2:\n841                     for entry in excinfo.traceback[1:-1]:\n842                         entry.set_repr_style(\"short\")\n843 \n844     def repr_failure(self, excinfo, outerr=None):\n845         assert outerr is None, \"XXX outerr usage is deprecated\"\n846         style = self.config.getoption(\"tbstyle\", \"auto\")\n847         if style == \"auto\":\n848             style = \"long\"\n849         return self._repr_failure_py(excinfo, style=style)\n850 \n851 \n852 def hasinit(obj):\n853     init = getattr(obj, \"__init__\", None)\n854     if init:\n855         return init != object.__init__\n856 \n857 \n858 def hasnew(obj):\n859     new = getattr(obj, \"__new__\", None)\n860     if new:\n861         return new != object.__new__\n862 \n863 \n864 class CallSpec2(object):\n865     def __init__(self, metafunc):\n866         self.metafunc = metafunc\n867         self.funcargs = {}\n868         self._idlist = []\n869         self.params = {}\n870         self._globalid = NOTSET\n871         self._globalparam = NOTSET\n872         self._arg2scopenum = {}  # used for sorting parametrized resources\n873         self.marks = []\n874         self.indices = {}\n875 \n876     def copy(self):\n877         cs = CallSpec2(self.metafunc)\n878         cs.funcargs.update(self.funcargs)\n879         cs.params.update(self.params)\n880         cs.marks.extend(self.marks)\n881         cs.indices.update(self.indices)\n882         cs._arg2scopenum.update(self._arg2scopenum)\n883         cs._idlist = list(self._idlist)\n884         cs._globalid = self._globalid\n885         cs._globalparam = self._globalparam\n886         return cs\n887 \n888     def _checkargnotcontained(self, arg):\n889         if arg in self.params or arg in self.funcargs:\n890             raise ValueError(\"duplicate %r\" % (arg,))\n891 \n892     def getparam(self, name):\n893         try:\n894             return self.params[name]\n895         except KeyError:\n896             if self._globalparam is NOTSET:\n897                 raise ValueError(name)\n898             return self._globalparam\n899 \n900     @property\n901     def id(self):\n902         return \"-\".join(map(str, filter(None, self._idlist)))\n903 \n904     def setmulti2(self, valtypes, argnames, valset, id, marks, scopenum, param_index):\n905         for arg, val in zip(argnames, valset):\n906             self._checkargnotcontained(arg)\n907             valtype_for_arg = valtypes[arg]\n908             getattr(self, valtype_for_arg)[arg] = val\n909             self.indices[arg] = param_index\n910             self._arg2scopenum[arg] = scopenum\n911         self._idlist.append(id)\n912         self.marks.extend(normalize_mark_list(marks))\n913 \n914     def setall(self, funcargs, id, param):\n915         for x in funcargs:\n916             self._checkargnotcontained(x)\n917         self.funcargs.update(funcargs)\n918         if id is not NOTSET:\n919             self._idlist.append(id)\n920         if param is not NOTSET:\n921             assert self._globalparam is NOTSET\n922             self._globalparam = param\n923         for arg in funcargs:\n924             self._arg2scopenum[arg] = fixtures.scopenum_function\n925 \n926 \n927 class Metafunc(fixtures.FuncargnamesCompatAttr):\n928     \"\"\"\n929     Metafunc objects are passed to the :func:`pytest_generate_tests <_pytest.hookspec.pytest_generate_tests>` hook.\n930     They help to inspect a test function and to generate tests according to\n931     test configuration or values specified in the class or module where a\n932     test function is defined.\n933     \"\"\"\n934 \n935     def __init__(self, definition, fixtureinfo, config, cls=None, module=None):\n936         assert (\n937             isinstance(definition, FunctionDefinition)\n938             or type(definition).__name__ == \"DefinitionMock\"\n939         )\n940         self.definition = definition\n941 \n942         #: access to the :class:`_pytest.config.Config` object for the test session\n943         self.config = config\n944 \n945         #: the module object where the test function is defined in.\n946         self.module = module\n947 \n948         #: underlying python test function\n949         self.function = definition.obj\n950 \n951         #: set of fixture names required by the test function\n952         self.fixturenames = fixtureinfo.names_closure\n953 \n954         #: class object where the test function is defined in or ``None``.\n955         self.cls = cls\n956 \n957         self._calls = []\n958         self._ids = set()\n959         self._arg2fixturedefs = fixtureinfo.name2fixturedefs\n960 \n961     def parametrize(self, argnames, argvalues, indirect=False, ids=None, scope=None):\n962         \"\"\" Add new invocations to the underlying test function using the list\n963         of argvalues for the given argnames.  Parametrization is performed\n964         during the collection phase.  If you need to setup expensive resources\n965         see about setting indirect to do it rather at test setup time.\n966 \n967         :arg argnames: a comma-separated string denoting one or more argument\n968                        names, or a list/tuple of argument strings.\n969 \n970         :arg argvalues: The list of argvalues determines how often a\n971             test is invoked with different argument values.  If only one\n972             argname was specified argvalues is a list of values.  If N\n973             argnames were specified, argvalues must be a list of N-tuples,\n974             where each tuple-element specifies a value for its respective\n975             argname.\n976 \n977         :arg indirect: The list of argnames or boolean. A list of arguments'\n978             names (subset of argnames). If True the list contains all names from\n979             the argnames. Each argvalue corresponding to an argname in this list will\n980             be passed as request.param to its respective argname fixture\n981             function so that it can perform more expensive setups during the\n982             setup phase of a test rather than at collection time.\n983 \n984         :arg ids: list of string ids, or a callable.\n985             If strings, each is corresponding to the argvalues so that they are\n986             part of the test id. If None is given as id of specific test, the\n987             automatically generated id for that argument will be used.\n988             If callable, it should take one argument (a single argvalue) and return\n989             a string or return None. If None, the automatically generated id for that\n990             argument will be used.\n991             If no ids are provided they will be generated automatically from\n992             the argvalues.\n993 \n994         :arg scope: if specified it denotes the scope of the parameters.\n995             The scope is used for grouping tests by parameter instances.\n996             It will also override any fixture-function defined scope, allowing\n997             to set a dynamic scope using test context or configuration.\n998         \"\"\"\n999         from _pytest.fixtures import scope2index\n1000         from _pytest.mark import ParameterSet\n1001 \n1002         argnames, parameters = ParameterSet._for_parametrize(\n1003             argnames,\n1004             argvalues,\n1005             self.function,\n1006             self.config,\n1007             function_definition=self.definition,\n1008         )\n1009         del argvalues\n1010 \n1011         if scope is None:\n1012             scope = _find_parametrized_scope(argnames, self._arg2fixturedefs, indirect)\n1013 \n1014         self._validate_if_using_arg_names(argnames, indirect)\n1015 \n1016         arg_values_types = self._resolve_arg_value_types(argnames, indirect)\n1017 \n1018         ids = self._resolve_arg_ids(argnames, ids, parameters, item=self.definition)\n1019 \n1020         scopenum = scope2index(\n1021             scope, descr=\"parametrize() call in {}\".format(self.function.__name__)\n1022         )\n1023 \n1024         # create the new calls: if we are parametrize() multiple times (by applying the decorator\n1025         # more than once) then we accumulate those calls generating the cartesian product\n1026         # of all calls\n1027         newcalls = []\n1028         for callspec in self._calls or [CallSpec2(self)]:\n1029             for param_index, (param_id, param_set) in enumerate(zip(ids, parameters)):\n1030                 newcallspec = callspec.copy()\n1031                 newcallspec.setmulti2(\n1032                     arg_values_types,\n1033                     argnames,\n1034                     param_set.values,\n1035                     param_id,\n1036                     param_set.marks,\n1037                     scopenum,\n1038                     param_index,\n1039                 )\n1040                 newcalls.append(newcallspec)\n1041         self._calls = newcalls\n1042 \n1043     def _resolve_arg_ids(self, argnames, ids, parameters, item):\n1044         \"\"\"Resolves the actual ids for the given argnames, based on the ``ids`` parameter given\n1045         to ``parametrize``.\n1046 \n1047         :param List[str] argnames: list of argument names passed to ``parametrize()``.\n1048         :param ids: the ids parameter of the parametrized call (see docs).\n1049         :param List[ParameterSet] parameters: the list of parameter values, same size as ``argnames``.\n1050         :param Item item: the item that generated this parametrized call.\n1051         :rtype: List[str]\n1052         :return: the list of ids for each argname given\n1053         \"\"\"\n1054         from _pytest._io.saferepr import saferepr\n1055 \n1056         idfn = None\n1057         if callable(ids):\n1058             idfn = ids\n1059             ids = None\n1060         if ids:\n1061             func_name = self.function.__name__\n1062             if len(ids) != len(parameters):\n1063                 msg = \"In {}: {} parameter sets specified, with different number of ids: {}\"\n1064                 fail(msg.format(func_name, len(parameters), len(ids)), pytrace=False)\n1065             for id_value in ids:\n1066                 if id_value is not None and not isinstance(id_value, six.string_types):\n1067                     msg = \"In {}: ids must be list of strings, found: {} (type: {!r})\"\n1068                     fail(\n1069                         msg.format(func_name, saferepr(id_value), type(id_value)),\n1070                         pytrace=False,\n1071                     )\n1072         ids = idmaker(argnames, parameters, idfn, ids, self.config, item=item)\n1073         return ids\n1074 \n1075     def _resolve_arg_value_types(self, argnames, indirect):\n1076         \"\"\"Resolves if each parametrized argument must be considered a parameter to a fixture or a \"funcarg\"\n1077         to the function, based on the ``indirect`` parameter of the parametrized() call.\n1078 \n1079         :param List[str] argnames: list of argument names passed to ``parametrize()``.\n1080         :param indirect: same ``indirect`` parameter of ``parametrize()``.\n1081         :rtype: Dict[str, str]\n1082             A dict mapping each arg name to either:\n1083             * \"params\" if the argname should be the parameter of a fixture of the same name.\n1084             * \"funcargs\" if the argname should be a parameter to the parametrized test function.\n1085         \"\"\"\n1086         valtypes = {}\n1087         if indirect is True:\n1088             valtypes = dict.fromkeys(argnames, \"params\")\n1089         elif indirect is False:\n1090             valtypes = dict.fromkeys(argnames, \"funcargs\")\n1091         elif isinstance(indirect, (tuple, list)):\n1092             valtypes = dict.fromkeys(argnames, \"funcargs\")\n1093             for arg in indirect:\n1094                 if arg not in argnames:\n1095                     fail(\n1096                         \"In {}: indirect fixture '{}' doesn't exist\".format(\n1097                             self.function.__name__, arg\n1098                         ),\n1099                         pytrace=False,\n1100                     )\n1101                 valtypes[arg] = \"params\"\n1102         return valtypes\n1103 \n1104     def _validate_if_using_arg_names(self, argnames, indirect):\n1105         \"\"\"\n1106         Check if all argnames are being used, by default values, or directly/indirectly.\n1107 \n1108         :param List[str] argnames: list of argument names passed to ``parametrize()``.\n1109         :param indirect: same ``indirect`` parameter of ``parametrize()``.\n1110         :raise ValueError: if validation fails.\n1111         \"\"\"\n1112         default_arg_names = set(get_default_arg_names(self.function))\n1113         func_name = self.function.__name__\n1114         for arg in argnames:\n1115             if arg not in self.fixturenames:\n1116                 if arg in default_arg_names:\n1117                     fail(\n1118                         \"In {}: function already takes an argument '{}' with a default value\".format(\n1119                             func_name, arg\n1120                         ),\n1121                         pytrace=False,\n1122                     )\n1123                 else:\n1124                     if isinstance(indirect, (tuple, list)):\n1125                         name = \"fixture\" if arg in indirect else \"argument\"\n1126                     else:\n1127                         name = \"fixture\" if indirect else \"argument\"\n1128                     fail(\n1129                         \"In {}: function uses no {} '{}'\".format(func_name, name, arg),\n1130                         pytrace=False,\n1131                     )\n1132 \n1133 \n1134 def _find_parametrized_scope(argnames, arg2fixturedefs, indirect):\n1135     \"\"\"Find the most appropriate scope for a parametrized call based on its arguments.\n1136 \n1137     When there's at least one direct argument, always use \"function\" scope.\n1138 \n1139     When a test function is parametrized and all its arguments are indirect\n1140     (e.g. fixtures), return the most narrow scope based on the fixtures used.\n1141 \n1142     Related to issue #1832, based on code posted by @Kingdread.\n1143     \"\"\"\n1144     from _pytest.fixtures import scopes\n1145 \n1146     if isinstance(indirect, (list, tuple)):\n1147         all_arguments_are_fixtures = len(indirect) == len(argnames)\n1148     else:\n1149         all_arguments_are_fixtures = bool(indirect)\n1150 \n1151     if all_arguments_are_fixtures:\n1152         fixturedefs = arg2fixturedefs or {}\n1153         used_scopes = [\n1154             fixturedef[0].scope\n1155             for name, fixturedef in fixturedefs.items()\n1156             if name in argnames\n1157         ]\n1158         if used_scopes:\n1159             # Takes the most narrow scope from used fixtures\n1160             for scope in reversed(scopes):\n1161                 if scope in used_scopes:\n1162                     return scope\n1163 \n1164     return \"function\"\n1165 \n1166 \n1167 def _ascii_escaped_by_config(val, config):\n1168     if config is None:\n1169         escape_option = False\n1170     else:\n1171         escape_option = config.getini(\n1172             \"disable_test_id_escaping_and_forfeit_all_rights_to_community_support\"\n1173         )\n1174     return val if escape_option else ascii_escaped(val)\n1175 \n1176 \n1177 def _idval(val, argname, idx, idfn, item, config):\n1178     if idfn:\n1179         try:\n1180             generated_id = idfn(val)\n1181             if generated_id is not None:\n1182                 val = generated_id\n1183         except Exception as e:\n1184             # See issue https://github.com/pytest-dev/pytest/issues/2169\n1185             msg = \"{}: error raised while trying to determine id of parameter '{}' at position {}\\n\"\n1186             msg = msg.format(item.nodeid, argname, idx)\n1187             # we only append the exception type and message because on Python 2 reraise does nothing\n1188             msg += \"  {}: {}\\n\".format(type(e).__name__, e)\n1189             six.raise_from(ValueError(msg), e)\n1190     elif config:\n1191         hook_id = config.hook.pytest_make_parametrize_id(\n1192             config=config, val=val, argname=argname\n1193         )\n1194         if hook_id:\n1195             return hook_id\n1196 \n1197     if isinstance(val, STRING_TYPES):\n1198         return _ascii_escaped_by_config(val, config)\n1199     elif isinstance(val, (float, int, bool, NoneType)):\n1200         return str(val)\n1201     elif isinstance(val, REGEX_TYPE):\n1202         return ascii_escaped(val.pattern)\n1203     elif enum is not None and isinstance(val, enum.Enum):\n1204         return str(val)\n1205     elif (isclass(val) or isfunction(val)) and hasattr(val, \"__name__\"):\n1206         return val.__name__\n1207     return str(argname) + str(idx)\n1208 \n1209 \n1210 def _idvalset(idx, parameterset, argnames, idfn, ids, item, config):\n1211     if parameterset.id is not None:\n1212         return parameterset.id\n1213     if ids is None or (idx >= len(ids) or ids[idx] is None):\n1214         this_id = [\n1215             _idval(val, argname, idx, idfn, item=item, config=config)\n1216             for val, argname in zip(parameterset.values, argnames)\n1217         ]\n1218         return \"-\".join(this_id)\n1219     else:\n1220         return ascii_escaped(ids[idx])\n1221 \n1222 \n1223 def idmaker(argnames, parametersets, idfn=None, ids=None, config=None, item=None):\n1224     ids = [\n1225         _idvalset(valindex, parameterset, argnames, idfn, ids, config=config, item=item)\n1226         for valindex, parameterset in enumerate(parametersets)\n1227     ]\n1228     if len(set(ids)) != len(ids):\n1229         # The ids are not unique\n1230         duplicates = [testid for testid in ids if ids.count(testid) > 1]\n1231         counters = collections.defaultdict(lambda: 0)\n1232         for index, testid in enumerate(ids):\n1233             if testid in duplicates:\n1234                 ids[index] = testid + str(counters[testid])\n1235                 counters[testid] += 1\n1236     return ids\n1237 \n1238 \n1239 def show_fixtures_per_test(config):\n1240     from _pytest.main import wrap_session\n1241 \n1242     return wrap_session(config, _show_fixtures_per_test)\n1243 \n1244 \n1245 def _show_fixtures_per_test(config, session):\n1246     import _pytest.config\n1247 \n1248     session.perform_collect()\n1249     curdir = py.path.local()\n1250     tw = _pytest.config.create_terminal_writer(config)\n1251     verbose = config.getvalue(\"verbose\")\n1252 \n1253     def get_best_relpath(func):\n1254         loc = getlocation(func, curdir)\n1255         return curdir.bestrelpath(loc)\n1256 \n1257     def write_fixture(fixture_def):\n1258         argname = fixture_def.argname\n1259         if verbose <= 0 and argname.startswith(\"_\"):\n1260             return\n1261         if verbose > 0:\n1262             bestrel = get_best_relpath(fixture_def.func)\n1263             funcargspec = \"{} -- {}\".format(argname, bestrel)\n1264         else:\n1265             funcargspec = argname\n1266         tw.line(funcargspec, green=True)\n1267         fixture_doc = fixture_def.func.__doc__\n1268         if fixture_doc:\n1269             write_docstring(tw, fixture_doc)\n1270         else:\n1271             tw.line(\"    no docstring available\", red=True)\n1272 \n1273     def write_item(item):\n1274         try:\n1275             info = item._fixtureinfo\n1276         except AttributeError:\n1277             # doctests items have no _fixtureinfo attribute\n1278             return\n1279         if not info.name2fixturedefs:\n1280             # this test item does not use any fixtures\n1281             return\n1282         tw.line()\n1283         tw.sep(\"-\", \"fixtures used by {}\".format(item.name))\n1284         tw.sep(\"-\", \"({})\".format(get_best_relpath(item.function)))\n1285         # dict key not used in loop but needed for sorting\n1286         for _, fixturedefs in sorted(info.name2fixturedefs.items()):\n1287             assert fixturedefs is not None\n1288             if not fixturedefs:\n1289                 continue\n1290             # last item is expected to be the one used by the test item\n1291             write_fixture(fixturedefs[-1])\n1292 \n1293     for session_item in session.items:\n1294         write_item(session_item)\n1295 \n1296 \n1297 def showfixtures(config):\n1298     from _pytest.main import wrap_session\n1299 \n1300     return wrap_session(config, _showfixtures_main)\n1301 \n1302 \n1303 def _showfixtures_main(config, session):\n1304     import _pytest.config\n1305 \n1306     session.perform_collect()\n1307     curdir = py.path.local()\n1308     tw = _pytest.config.create_terminal_writer(config)\n1309     verbose = config.getvalue(\"verbose\")\n1310 \n1311     fm = session._fixturemanager\n1312 \n1313     available = []\n1314     seen = set()\n1315 \n1316     for argname, fixturedefs in fm._arg2fixturedefs.items():\n1317         assert fixturedefs is not None\n1318         if not fixturedefs:\n1319             continue\n1320         for fixturedef in fixturedefs:\n1321             loc = getlocation(fixturedef.func, curdir)\n1322             if (fixturedef.argname, loc) in seen:\n1323                 continue\n1324             seen.add((fixturedef.argname, loc))\n1325             available.append(\n1326                 (\n1327                     len(fixturedef.baseid),\n1328                     fixturedef.func.__module__,\n1329                     curdir.bestrelpath(loc),\n1330                     fixturedef.argname,\n1331                     fixturedef,\n1332                 )\n1333             )\n1334 \n1335     available.sort()\n1336     currentmodule = None\n1337     for baseid, module, bestrel, argname, fixturedef in available:\n1338         if currentmodule != module:\n1339             if not module.startswith(\"_pytest.\"):\n1340                 tw.line()\n1341                 tw.sep(\"-\", \"fixtures defined from %s\" % (module,))\n1342                 currentmodule = module\n1343         if verbose <= 0 and argname[0] == \"_\":\n1344             continue\n1345         if verbose > 0:\n1346             funcargspec = \"%s -- %s\" % (argname, bestrel)\n1347         else:\n1348             funcargspec = argname\n1349         tw.line(funcargspec, green=True)\n1350         loc = getlocation(fixturedef.func, curdir)\n1351         doc = fixturedef.func.__doc__ or \"\"\n1352         if doc:\n1353             write_docstring(tw, doc)\n1354         else:\n1355             tw.line(\"    %s: no docstring available\" % (loc,), red=True)\n1356 \n1357 \n1358 def write_docstring(tw, doc, indent=\"    \"):\n1359     doc = doc.rstrip()\n1360     if \"\\n\" in doc:\n1361         firstline, rest = doc.split(\"\\n\", 1)\n1362     else:\n1363         firstline, rest = doc, \"\"\n1364 \n1365     if firstline.strip():\n1366         tw.line(indent + firstline.strip())\n1367 \n1368     if rest:\n1369         for line in dedent(rest).split(\"\\n\"):\n1370             tw.write(indent + line + \"\\n\")\n1371 \n1372 \n1373 class Function(FunctionMixin, nodes.Item, fixtures.FuncargnamesCompatAttr):\n1374     \"\"\" a Function Item is responsible for setting up and executing a\n1375     Python test function.\n1376     \"\"\"\n1377 \n1378     # disable since functions handle it themselves\n1379     _ALLOW_MARKERS = False\n1380 \n1381     def __init__(\n1382         self,\n1383         name,\n1384         parent,\n1385         args=None,\n1386         config=None,\n1387         callspec=None,\n1388         callobj=NOTSET,\n1389         keywords=None,\n1390         session=None,\n1391         fixtureinfo=None,\n1392         originalname=None,\n1393     ):\n1394         super(Function, self).__init__(name, parent, config=config, session=session)\n1395         self._args = args\n1396         if callobj is not NOTSET:\n1397             self.obj = callobj\n1398 \n1399         self.keywords.update(self.obj.__dict__)\n1400         self.own_markers.extend(get_unpacked_marks(self.obj))\n1401         if callspec:\n1402             self.callspec = callspec\n1403             # this is total hostile and a mess\n1404             # keywords are broken by design by now\n1405             # this will be redeemed later\n1406             for mark in callspec.marks:\n1407                 # feel free to cry, this was broken for years before\n1408                 # and keywords cant fix it per design\n1409                 self.keywords[mark.name] = mark\n1410             self.own_markers.extend(normalize_mark_list(callspec.marks))\n1411         if keywords:\n1412             self.keywords.update(keywords)\n1413 \n1414         # todo: this is a hell of a hack\n1415         # https://github.com/pytest-dev/pytest/issues/4569\n1416 \n1417         self.keywords.update(\n1418             dict.fromkeys(\n1419                 [\n1420                     mark.name\n1421                     for mark in self.iter_markers()\n1422                     if mark.name not in self.keywords\n1423                 ],\n1424                 True,\n1425             )\n1426         )\n1427 \n1428         if fixtureinfo is None:\n1429             fixtureinfo = self.session._fixturemanager.getfixtureinfo(\n1430                 self, self.obj, self.cls, funcargs=True\n1431             )\n1432         self._fixtureinfo = fixtureinfo\n1433         self.fixturenames = fixtureinfo.names_closure\n1434         self._initrequest()\n1435 \n1436         #: original function name, without any decorations (for example\n1437         #: parametrization adds a ``\"[...]\"`` suffix to function names).\n1438         #:\n1439         #: .. versionadded:: 3.0\n1440         self.originalname = originalname\n1441 \n1442     def _initrequest(self):\n1443         self.funcargs = {}\n1444         self._request = fixtures.FixtureRequest(self)\n1445 \n1446     @property\n1447     def function(self):\n1448         \"underlying python 'function' object\"\n1449         return getimfunc(self.obj)\n1450 \n1451     def _getobj(self):\n1452         name = self.name\n1453         i = name.find(\"[\")  # parametrization\n1454         if i != -1:\n1455             name = name[:i]\n1456         return getattr(self.parent.obj, name)\n1457 \n1458     @property\n1459     def _pyfuncitem(self):\n1460         \"(compatonly) for code expecting pytest-2.2 style request objects\"\n1461         return self\n1462 \n1463     def runtest(self):\n1464         \"\"\" execute the underlying test function. \"\"\"\n1465         self.ihook.pytest_pyfunc_call(pyfuncitem=self)\n1466 \n1467     def setup(self):\n1468         super(Function, self).setup()\n1469         fixtures.fillfixtures(self)\n1470 \n1471 \n1472 class FunctionDefinition(Function):\n1473     \"\"\"\n1474     internal hack until we get actual definition nodes instead of the\n1475     crappy metafunc hack\n1476     \"\"\"\n1477 \n1478     def runtest(self):\n1479         raise RuntimeError(\"function definitions are not supposed to be used\")\n1480 \n1481     setup = runtest\n",
        "intended_behavior": "The code responsible for processing the `--fixtures` command-line argument should be extended to include the fixture's scope in the output. This extension should preserve the current functionality of listing available fixtures but additionally display each fixture's scope (e.g., function, class, module, package, or session) alongside its name and docstring in the output."
    },
    {
        "rel_file_path": "src/_pytest/fixtures.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/pytest-dev__pytest/setup_pytest-dev__pytest__4.4/src/_pytest/fixtures.py",
        "start": 811,
        "end": 902,
        "class_name": "FixtureDef",
        "method_name": null,
        "code": "811 class FixtureDef(object):\n812     \"\"\" A container for a factory definition. \"\"\"\n813 \n814     def __init__(\n815         self,\n816         fixturemanager,\n817         baseid,\n818         argname,\n819         func,\n820         scope,\n821         params,\n822         unittest=False,\n823         ids=None,\n824     ):\n825         self._fixturemanager = fixturemanager\n826         self.baseid = baseid or \"\"\n827         self.has_location = baseid is not None\n828         self.func = func\n829         self.argname = argname\n830         self.scope = scope\n831         self.scopenum = scope2index(\n832             scope or \"function\",\n833             descr=\"Fixture '{}'\".format(func.__name__),\n834             where=baseid,\n835         )\n836         self.params = params\n837         self.argnames = getfuncargnames(func, is_method=unittest)\n838         self.unittest = unittest\n839         self.ids = ids\n840         self._finalizers = []\n841 \n842     def addfinalizer(self, finalizer):\n843         self._finalizers.append(finalizer)\n844 \n845     def finish(self, request):\n846         exceptions = []\n847         try:\n848             while self._finalizers:\n849                 try:\n850                     func = self._finalizers.pop()\n851                     func()\n852                 except:  # noqa\n853                     exceptions.append(sys.exc_info())\n854             if exceptions:\n855                 e = exceptions[0]\n856                 del (\n857                     exceptions\n858                 )  # ensure we don't keep all frames alive because of the traceback\n859                 six.reraise(*e)\n860 \n861         finally:\n862             hook = self._fixturemanager.session.gethookproxy(request.node.fspath)\n863             hook.pytest_fixture_post_finalizer(fixturedef=self, request=request)\n864             # even if finalization fails, we invalidate\n865             # the cached fixture value and remove\n866             # all finalizers because they may be bound methods which will\n867             # keep instances alive\n868             if hasattr(self, \"cached_result\"):\n869                 del self.cached_result\n870             self._finalizers = []\n871 \n872     def execute(self, request):\n873         # get required arguments and register our own finish()\n874         # with their finalization\n875         for argname in self.argnames:\n876             fixturedef = request._get_active_fixturedef(argname)\n877             if argname != \"request\":\n878                 fixturedef.addfinalizer(functools.partial(self.finish, request=request))\n879 \n880         my_cache_key = request.param_index\n881         cached_result = getattr(self, \"cached_result\", None)\n882         if cached_result is not None:\n883             result, cache_key, err = cached_result\n884             if my_cache_key == cache_key:\n885                 if err is not None:\n886                     six.reraise(*err)\n887                 else:\n888                     return result\n889             # we have a previous but differently parametrized fixture instance\n890             # so we need to tear it down before creating a new one\n891             self.finish(request)\n892             assert not hasattr(self, \"cached_result\")\n893 \n894         hook = self._fixturemanager.session.gethookproxy(request.node.fspath)\n895         return hook.pytest_fixture_setup(fixturedef=self, request=request)\n896 \n897     def __repr__(self):\n898         return \"<FixtureDef argname=%r scope=%r baseid=%r>\" % (\n899             self.argname,\n900             self.scope,\n901             self.baseid,\n902         )\n",
        "intended_behavior": "While the `FixtureDef` class may not require a bug fix per se, any enhancements to support the new feature (displaying fixture scopes) would likely involve accessing the `scope` attribute of this class's instances. The modification would ensure that wherever fixture details are being prepared for the `--fixtures` output, the scope is included by retrieving it from the `FixtureDef` instances corresponding to each fixture."
    }
]