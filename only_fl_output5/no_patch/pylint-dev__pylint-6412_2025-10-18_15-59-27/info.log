2025-10-18 15:59:27.638 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-18 15:59:29.675 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=181, output_tokens=12, cost=0.002170
2025-10-18 15:59:29.683 | INFO     | Test agent decides that the issue statement does not contain reproduction steps; skipping reproducer tracing
2025-10-18 15:59:29.690 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 15:59:38.467 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=490, output_tokens=341, cost=0.015130
2025-10-18 15:59:38.473 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 15:59:40.853 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=695, output_tokens=36, cost=0.008030
2025-10-18 15:59:40.855 | DEBUG    | Extracted a valid json.
2025-10-18 15:59:40.860 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_code(\"__implements__\")",
        "search_class(\"PyLinter\")"
    ],
    "bug_locations": []
}
2025-10-18 15:59:40.926 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-18 15:59:40.927 | DEBUG    | <Agent search> Analyzing search results.
2025-10-18 15:59:56.871 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2794, output_tokens=670, cost=0.048040
2025-10-18 15:59:56.884 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 16:00:06.551 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=3680, output_tokens=380, cost=0.048200
2025-10-18 16:00:06.561 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 16:00:16.103 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=734, output_tokens=332, cost=0.017300
2025-10-18 16:00:16.104 | DEBUG    | Extracted a valid json.
2025-10-18 16:00:16.104 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "pylint/lint/pylinter.py",
            "class": "PyLinter",
            "method": "register_checker, register_reporter",
            "intended_behavior": "In addition to the current functionality, these methods should be enhanced to support `isinstance` checks using `ABCMeta` for categorizing checkers and reporters. This means that when checkers or reporters are registered, the PyLinter should be able to recognize them based on whether they are instances of a specific abstract base class (or classes), without solely relying on the `__implements__` attribute. This requires defining new abstract base classes for checkers and reporters (if not already defined) using `ABCMeta` and adjusting these methods to recognize checkers and reporters based on these new abstract classes. This modification should preserve backward compatibility by still supporting the `__implements__` attribute during a transition period."
        },
        {
            "file": "pylint/interfaces.py",
            "class": "",
            "method": "",
            "intended_behavior": "This file should introduce new abstract base classes for the checkers and reporters using `ABCMeta`. Each checker or reporter class should then be updated to inherit from these new abstract base classes instead of or in addition to using the `__implements__` attribute. The \"implements\" function within interfaces.py could be revised or supplemented with a new mechanism that leverages `isinstance` checks against these new abstract base classes to understand whether a given object conforms to the expected interface."
        }
    ]
}
2025-10-18 16:00:16.118 | DEBUG    | Bug location extracted successfully: [<file>pylint/lint/pylinter.py</file>
<class>PyLinter</class>
<method>None</method>
<code>
191 class PyLinter(
192     _ArgumentsManager,
193     reporters.ReportsHandlerMixIn,
194     checkers.BaseTokenChecker,
195 ):
196     """Lint Python modules using external checkers.
197 
198     This is the main checker controlling the other ones and the reports
199     generation. It is itself both a raw checker and an astroid checker in order
200     to:
201     * handle message activation / deactivation at the module level
202     * handle some basic but necessary stats'data (number of classes, methods...)
203 
204     IDE plugin developers: you may have to call
205     `astroid.builder.MANAGER.astroid_cache.clear()` across runs if you want
206     to ensure the latest code version is actually checked.
207 
208     This class needs to support pickling for parallel linting to work. The exception
209     is reporter member; see check_parallel function for more details.
210     """
211 
212     name = MAIN_CHECKER_NAME
213     msgs = MSGS
214     # Will be used like this : datetime.now().strftime(crash_file_path)
215     crash_file_path: str = "pylint-crash-%Y-%m-%d-%H.txt"
216 
217     option_groups_descs = {
218         "Messages control": "Options controlling analysis messages",
219         "Reports": "Options related to output formatting and reporting",
220     }
221 
222     def __init__(
223         self,
224         options: Options = (),
225         reporter: reporters.BaseReporter | reporters.MultiReporter | None = None,
226         option_groups: tuple[tuple[str, str], ...] = (),
227         # pylint: disable-next=fixme
228         # TODO: Deprecate passing the pylintrc parameter
229         pylintrc: str | None = None,  # pylint: disable=unused-argument
230     ) -> None:
231         _ArgumentsManager.__init__(self, prog="pylint")
232 
233         # Some stuff has to be done before initialization of other ancestors...
234         # messages store / checkers / reporter / astroid manager
235 
236         # Attributes for reporters
237         self.reporter: reporters.BaseReporter | reporters.MultiReporter
238         if reporter:
239             self.set_reporter(reporter)
240         else:
241             self.set_reporter(TextReporter())
242         self._reporters: dict[str, type[reporters.BaseReporter]] = {}
243         """Dictionary of possible but non-initialized reporters."""
244 
245         # Attributes for checkers and plugins
246         self._checkers: defaultdict[
247             str, list[checkers.BaseChecker]
248         ] = collections.defaultdict(list)
249         """Dictionary of registered and initialized checkers."""
250         self._dynamic_plugins: set[str] = set()
251         """Set of loaded plugin names."""
252 
253         # Attributes related to visiting files
254         self.file_state = FileState()
255         self.current_name: str | None = None
256         self.current_file: str | None = None
257         self._ignore_file = False
258         self._pragma_lineno: dict[str, int] = {}
259 
260         # Attributes related to stats
261         self.stats = LinterStats()
262 
263         # Attributes related to (command-line) options and their parsing
264         self.options: Options = options + _make_linter_options(self)
265         for opt_group in option_groups:
266             self.option_groups_descs[opt_group[0]] = opt_group[1]
267         self._option_groups: tuple[tuple[str, str], ...] = option_groups + (
268             ("Messages control", "Options controlling analysis messages"),
269             ("Reports", "Options related to output formatting and reporting"),
270         )
271         self._options_methods = {
272             "enable": self.enable,
273             "disable": self.disable,
274             "disable-next": self.disable_next,
275         }
276         self._bw_options_methods = {
277             "disable-msg": self._options_methods["disable"],
278             "enable-msg": self._options_methods["enable"],
279         }
280         self.fail_on_symbols: list[str] = []
281         """List of message symbols on which pylint should fail, set by --fail-on."""
282         self._error_mode = False
283 
284         # Attributes related to messages (states) and their handling
285         self.msgs_store = MessageDefinitionStore()
286         self.msg_status = 0
287         self._msgs_state: dict[str, bool] = {}
288         self._by_id_managed_msgs: list[ManagedMessage] = []
289 
290         reporters.ReportsHandlerMixIn.__init__(self)
291         checkers.BaseTokenChecker.__init__(self, self)
292         # provided reports
293         self.reports = (
294             ("RP0001", "Messages by category", report_total_messages_stats),
295             (
296                 "RP0002",
297                 "% errors / warnings by module",
298                 report_messages_by_module_stats,
299             ),
300             ("RP0003", "Messages", report_messages_stats),
301         )
302         self.register_checker(self)
303 
304     @property
305     def option_groups(self) -> tuple[tuple[str, str], ...]:
306         # TODO: 3.0: Remove deprecated attribute # pylint: disable=fixme
307         warnings.warn(
308             "The option_groups attribute has been deprecated and will be removed in pylint 3.0",
309             DeprecationWarning,
310         )
311         return self._option_groups
312 
313     @option_groups.setter
314     def option_groups(self, value: tuple[tuple[str, str], ...]) -> None:
315         warnings.warn(
316             "The option_groups attribute has been deprecated and will be removed in pylint 3.0",
317             DeprecationWarning,
318         )
319         self._option_groups = value
320 
321     def load_default_plugins(self) -> None:
322         checkers.initialize(self)
323         reporters.initialize(self)
324 
325     def load_plugin_modules(self, modnames: list[str]) -> None:
326         """Check a list pylint plugins modules, load and register them."""
327         for modname in modnames:
328             if modname in self._dynamic_plugins:
329                 continue
330             self._dynamic_plugins.add(modname)
331             try:
332                 module = astroid.modutils.load_module_from_name(modname)
333                 module.register(self)
334             except ModuleNotFoundError:
335                 pass
336 
337     def load_plugin_configuration(self) -> None:
338         """Call the configuration hook for plugins.
339 
340         This walks through the list of plugins, grabs the "load_configuration"
341         hook, if exposed, and calls it to allow plugins to configure specific
342         settings.
343         """
344         for modname in self._dynamic_plugins:
345             try:
346                 module = astroid.modutils.load_module_from_name(modname)
347                 if hasattr(module, "load_configuration"):
348                     module.load_configuration(self)
349             except ModuleNotFoundError as e:
350                 self.add_message("bad-plugin-value", args=(modname, e), line=0)
351 
352     def _load_reporters(self, reporter_names: str) -> None:
353         """Load the reporters if they are available on _reporters."""
354         if not self._reporters:
355             return
356         sub_reporters = []
357         output_files = []
358         with contextlib.ExitStack() as stack:
359             for reporter_name in reporter_names.split(","):
360                 reporter_name, *reporter_output = reporter_name.split(":", 1)
361 
362                 reporter = self._load_reporter_by_name(reporter_name)
363                 sub_reporters.append(reporter)
364                 if reporter_output:
365                     output_file = stack.enter_context(
366                         open(reporter_output[0], "w", encoding="utf-8")
367                     )
368                     reporter.out = output_file
369                     output_files.append(output_file)
370 
371             # Extend the lifetime of all opened output files
372             close_output_files = stack.pop_all().close
373 
374         if len(sub_reporters) > 1 or output_files:
375             self.set_reporter(
376                 reporters.MultiReporter(
377                     sub_reporters,
378                     close_output_files,
379                 )
380             )
381         else:
382             self.set_reporter(sub_reporters[0])
383 
384     def _load_reporter_by_name(self, reporter_name: str) -> reporters.BaseReporter:
385         name = reporter_name.lower()
386         if name in self._reporters:
387             return self._reporters[name]()
388 
389         try:
390             reporter_class = _load_reporter_by_class(reporter_name)
391         except (ImportError, AttributeError) as e:
392             raise exceptions.InvalidReporterError(name) from e
393         else:
394             return reporter_class()
395 
396     def set_reporter(
397         self, reporter: reporters.BaseReporter | reporters.MultiReporter
398     ) -> None:
399         """Set the reporter used to display messages and reports."""
400         self.reporter = reporter
401         reporter.linter = self
402 
403     def register_reporter(self, reporter_class: type[reporters.BaseReporter]) -> None:
404         """Registers a reporter class on the _reporters attribute."""
405         self._reporters[reporter_class.name] = reporter_class
406 
407     def report_order(self) -> list[BaseChecker]:
408         reports = sorted(self._reports, key=lambda x: getattr(x, "name", ""))
409         try:
410             # Remove the current reporter and add it
411             # at the end of the list.
412             reports.pop(reports.index(self))
413         except ValueError:
414             pass
415         else:
416             reports.append(self)
417         return reports
418 
419     # checkers manipulation methods ############################################
420 
421     def register_checker(self, checker: checkers.BaseChecker) -> None:
422         """This method auto registers the checker."""
423         self._checkers[checker.name].append(checker)
424         for r_id, r_title, r_cb in checker.reports:
425             self.register_report(r_id, r_title, r_cb, checker)
426         if hasattr(checker, "msgs"):
427             self.msgs_store.register_messages_from_checker(checker)
428         # Register the checker, but disable all of its messages.
429         if not getattr(checker, "enabled", True):
430             self.disable(checker.name)
431 
432     def enable_fail_on_messages(self) -> None:
433         """Enable 'fail on' msgs.
434 
435         Convert values in config.fail_on (which might be msg category, msg id,
436         or symbol) to specific msgs, then enable and flag them for later.
437         """
438         fail_on_vals = self.config.fail_on
439         if not fail_on_vals:
440             return
441 
442         fail_on_cats = set()
443         fail_on_msgs = set()
444         for val in fail_on_vals:
445             # If value is a category, add category, else add message
446             if val in MSG_TYPES:
447                 fail_on_cats.add(val)
448             else:
449                 fail_on_msgs.add(val)
450 
451         # For every message in every checker, if cat or msg flagged, enable check
452         for all_checkers in self._checkers.values():
453             for checker in all_checkers:
454                 for msg in checker.messages:
455                     if msg.msgid in fail_on_msgs or msg.symbol in fail_on_msgs:
456                         # message id/symbol matched, enable and flag it
457                         self.enable(msg.msgid)
458                         self.fail_on_symbols.append(msg.symbol)
459                     elif msg.msgid[0] in fail_on_cats:
460                         # message starts with a category value, flag (but do not enable) it
461                         self.fail_on_symbols.append(msg.symbol)
462 
463     def any_fail_on_issues(self):
464         return self.stats and any(
465             x in self.fail_on_symbols for x in self.stats.by_msg.keys()
466         )
467 
468     def disable_noerror_messages(self) -> None:
469         for msgcat, msgids in self.msgs_store._msgs_by_category.items():
470             # enable only messages with 'error' severity and above ('fatal')
471             if msgcat in {"E", "F"}:
472                 for msgid in msgids:
473                     self.enable(msgid)
474             else:
475                 for msgid in msgids:
476                     self.disable(msgid)
477 
478     def disable_reporters(self) -> None:
479         """Disable all reporters."""
480         for _reporters in self._reports.values():
481             for report_id, _, _ in _reporters:
482                 self.disable_report(report_id)
483 
484     def _parse_error_mode(self) -> None:
485         """Parse the current state of the error mode.
486 
487         Error mode: enable only errors; no reports, no persistent.
488         """
489         if not self._error_mode:
490             return
491 
492         self.disable_noerror_messages()
493         self.disable("miscellaneous")
494         self.set_option("reports", False)
495         self.set_option("persistent", False)
496         self.set_option("score", False)
497 
498     def list_messages_enabled(self) -> None:
499         emittable, non_emittable = self.msgs_store.find_emittable_messages()
500         enabled = []
501         disabled = []
502         for message in emittable:
503             if self.is_message_enabled(message.msgid):
504                 enabled.append(f"  {message.symbol} ({message.msgid})")
505             else:
506                 disabled.append(f"  {message.symbol} ({message.msgid})")
507         print("Enabled messages:")
508         for msg in enabled:
509             print(msg)
510         print("\nDisabled messages:")
511         for msg in disabled:
512             print(msg)
513         print("\nNon-emittable messages with current interpreter:")
514         for msg_def in non_emittable:
515             print(f"  {msg_def.symbol} ({msg_def.msgid})")
516         print("")
517 
518     # block level option handling #############################################
519     # see func_block_disable_msg.py test case for expected behaviour
520 
521     def process_tokens(self, tokens: list[tokenize.TokenInfo]) -> None:
522         """Process tokens from the current module to search for module/block level
523         options.
524         """
525         control_pragmas = {"disable", "disable-next", "enable"}
526         prev_line = None
527         saw_newline = True
528         seen_newline = True
529         for (tok_type, content, start, _, _) in tokens:
530             if prev_line and prev_line != start[0]:
531                 saw_newline = seen_newline
532                 seen_newline = False
533 
534             prev_line = start[0]
535             if tok_type in (tokenize.NL, tokenize.NEWLINE):
536                 seen_newline = True
537 
538             if tok_type != tokenize.COMMENT:
539                 continue
540             match = OPTION_PO.search(content)
541             if match is None:
542                 continue
543             try:
544                 for pragma_repr in parse_pragma(match.group(2)):
545                     if pragma_repr.action in {"disable-all", "skip-file"}:
546                         if pragma_repr.action == "disable-all":
547                             self.add_message(
548                                 "deprecated-pragma",
549                                 line=start[0],
550                                 args=("disable-all", "skip-file"),
551                             )
552                         self.add_message("file-ignored", line=start[0])
553                         self._ignore_file = True
554                         return
555                     try:
556                         meth = self._options_methods[pragma_repr.action]
557                     except KeyError:
558                         meth = self._bw_options_methods[pragma_repr.action]
559                         # found a "(dis|en)able-msg" pragma deprecated suppression
560                         self.add_message(
561                             "deprecated-pragma",
562                             line=start[0],
563                             args=(
564                                 pragma_repr.action,
565                                 pragma_repr.action.replace("-msg", ""),
566                             ),
567                         )
568                     for msgid in pragma_repr.messages:
569                         # Add the line where a control pragma was encountered.
570                         if pragma_repr.action in control_pragmas:
571                             self._pragma_lineno[msgid] = start[0]
572 
573                         if (pragma_repr.action, msgid) == ("disable", "all"):
574                             self.add_message(
575                                 "deprecated-pragma",
576                                 line=start[0],
577                                 args=("disable=all", "skip-file"),
578                             )
579                             self.add_message("file-ignored", line=start[0])
580                             self._ignore_file = True
581                             return
582                             # If we did not see a newline between the previous line and now,
583                             # we saw a backslash so treat the two lines as one.
584                         l_start = start[0]
585                         if not saw_newline:
586                             l_start -= 1
587                         try:
588                             meth(msgid, "module", l_start)
589                         except exceptions.UnknownMessageError:
590                             msg = f"{pragma_repr.action}. Don't recognize message {msgid}."
591                             self.add_message(
592                                 "bad-option-value", args=msg, line=start[0]
593                             )
594             except UnRecognizedOptionError as err:
595                 self.add_message(
596                     "unrecognized-inline-option", args=err.token, line=start[0]
597                 )
598                 continue
599             except InvalidPragmaError as err:
600                 self.add_message("bad-inline-option", args=err.token, line=start[0])
601                 continue
602 
603     # code checking methods ###################################################
604 
605     def get_checkers(self) -> list[BaseChecker]:
606         """Return all available checkers as an ordered list."""
607         return sorted(c for _checkers in self._checkers.values() for c in _checkers)
608 
609     def get_checker_names(self) -> list[str]:
610         """Get all the checker names that this linter knows about."""
611         return sorted(
612             {
613                 checker.name
614                 for checker in self.get_checkers()
615                 if checker.name != MAIN_CHECKER_NAME
616             }
617         )
618 
619     def prepare_checkers(self) -> list[BaseChecker]:
620         """Return checkers needed for activated messages and reports."""
621         if not self.config.reports:
622             self.disable_reporters()
623         # get needed checkers
624         needed_checkers: list[BaseChecker] = [self]
625         for checker in self.get_checkers()[1:]:
626             messages = {msg for msg in checker.msgs if self.is_message_enabled(msg)}
627             if messages or any(self.report_is_enabled(r[0]) for r in checker.reports):
628                 needed_checkers.append(checker)
629         return needed_checkers
630 
631     # pylint: disable=unused-argument
632     @staticmethod
633     def should_analyze_file(modname, path, is_argument=False):
634         """Returns whether a module should be checked.
635 
636         This implementation returns True for all python source file, indicating
637         that all files should be linted.
638 
639         Subclasses may override this method to indicate that modules satisfying
640         certain conditions should not be linted.
641 
642         :param str modname: The name of the module to be checked.
643         :param str path: The full path to the source code of the module.
644         :param bool is_argument: Whether the file is an argument to pylint or not.
645                                  Files which respect this property are always
646                                  checked, since the user requested it explicitly.
647         :returns: True if the module should be checked.
648         :rtype: bool
649         """
650         if is_argument:
651             return True
652         return path.endswith(".py")
653 
654     # pylint: enable=unused-argument
655 
656     def initialize(self) -> None:
657         """Initialize linter for linting.
658 
659         This method is called before any linting is done.
660         """
661         # initialize msgs_state now that all messages have been registered into
662         # the store
663         for msg in self.msgs_store.messages:
664             if not msg.may_be_emitted():
665                 self._msgs_state[msg.msgid] = False
666 
667     @staticmethod
668     def _discover_files(files_or_modules: Sequence[str]) -> Iterator[str]:
669         """Discover python modules and packages in subdirectory.
670 
671         Returns iterator of paths to discovered modules and packages.
672         """
673         for something in files_or_modules:
674             if os.path.isdir(something) and not os.path.isfile(
675                 os.path.join(something, "__init__.py")
676             ):
677                 skip_subtrees: list[str] = []
678                 for root, _, files in os.walk(something):
679                     if any(root.startswith(s) for s in skip_subtrees):
680                         # Skip subtree of already discovered package.
681                         continue
682                     if "__init__.py" in files:
683                         skip_subtrees.append(root)
684                         yield root
685                     else:
686                         yield from (
687                             os.path.join(root, file)
688                             for file in files
689                             if file.endswith(".py")
690                         )
691             else:
692                 yield something
693 
694     def check(self, files_or_modules: Sequence[str] | str) -> None:
695         """Main checking entry: check a list of files or modules from their name.
696 
697         files_or_modules is either a string or list of strings presenting modules to check.
698         """
699         self.initialize()
700         if not isinstance(files_or_modules, (list, tuple)):
701             # pylint: disable-next=fixme
702             # TODO: 3.0: Remove deprecated typing and update docstring
703             warnings.warn(
704                 "In pylint 3.0, the checkers check function will only accept sequence of string",
705                 DeprecationWarning,
706             )
707             files_or_modules = (files_or_modules,)  # type: ignore[assignment]
708         if self.config.recursive:
709             files_or_modules = tuple(self._discover_files(files_or_modules))
710         if self.config.from_stdin:
711             if len(files_or_modules) != 1:
712                 raise exceptions.InvalidArgsError(
713                     "Missing filename required for --from-stdin"
714                 )
715 
716             filepath = files_or_modules[0]
717             with fix_import_path(files_or_modules):
718                 self._check_files(
719                     functools.partial(self.get_ast, data=_read_stdin()),
720                     [self._get_file_descr_from_stdin(filepath)],
721                 )
722         elif self.config.jobs == 1:
723             with fix_import_path(files_or_modules):
724                 self._check_files(
725                     self.get_ast, self._iterate_file_descrs(files_or_modules)
726                 )
727         else:
728             check_parallel(
729                 self,
730                 self.config.jobs,
731                 self._iterate_file_descrs(files_or_modules),
732                 files_or_modules,
733             )
734 
735     def check_single_file(self, name: str, filepath: str, modname: str) -> None:
736         warnings.warn(
737             "In pylint 3.0, the checkers check_single_file function will be removed. "
738             "Use check_single_file_item instead.",
739             DeprecationWarning,
740         )
741         self.check_single_file_item(FileItem(name, filepath, modname))
742 
743     def check_single_file_item(self, file: FileItem) -> None:
744         """Check single file item.
745 
746         The arguments are the same that are documented in _check_files
747 
748         initialize() should be called before calling this method
749         """
750         with self._astroid_module_checker() as check_astroid_module:
751             self._check_file(self.get_ast, check_astroid_module, file)
752 
753     def _check_files(
754         self,
755         get_ast,
756         file_descrs: Iterable[FileItem],
757     ) -> None:
758         """Check all files from file_descrs."""
759         with self._astroid_module_checker() as check_astroid_module:
760             for file in file_descrs:
761                 try:
762                     self._check_file(get_ast, check_astroid_module, file)
763                 except Exception as ex:  # pylint: disable=broad-except
764                     template_path = prepare_crash_report(
765                         ex, file.filepath, self.crash_file_path
766                     )
767                     msg = get_fatal_error_message(file.filepath, template_path)
768                     if isinstance(ex, AstroidError):
769                         symbol = "astroid-error"
770                         self.add_message(symbol, args=(file.filepath, msg))
771                     else:
772                         symbol = "fatal"
773                         self.add_message(symbol, args=msg)
774 
775     def _check_file(self, get_ast, check_astroid_module, file: FileItem):
776         """Check a file using the passed utility functions (get_ast and check_astroid_module).
777 
778         :param callable get_ast: callable returning AST from defined file taking the following arguments
779         - filepath: path to the file to check
780         - name: Python module name
781         :param callable check_astroid_module: callable checking an AST taking the following arguments
782         - ast: AST of the module
783         :param FileItem file: data about the file
784         """
785         self.set_current_module(file.name, file.filepath)
786         # get the module representation
787         ast_node = get_ast(file.filepath, file.name)
788         if ast_node is None:
789             return
790 
791         self._ignore_file = False
792 
793         self.file_state = FileState(file.modpath)
794         # fix the current file (if the source file was not available or
795         # if it's actually a c extension)
796         self.current_file = ast_node.file
797         check_astroid_module(ast_node)
798         # warn about spurious inline messages handling
799         spurious_messages = self.file_state.iter_spurious_suppression_messages(
800             self.msgs_store
801         )
802         for msgid, line, args in spurious_messages:
803             self.add_message(msgid, line, None, args)
804 
805     @staticmethod
806     def _get_file_descr_from_stdin(filepath: str) -> FileItem:
807         """Return file description (tuple of module name, file path, base name) from given file path.
808 
809         This method is used for creating suitable file description for _check_files when the
810         source is standard input.
811         """
812         try:
813             # Note that this function does not really perform an
814             # __import__ but may raise an ImportError exception, which
815             # we want to catch here.
816             modname = ".".join(astroid.modutils.modpath_from_file(filepath))
817         except ImportError:
818             modname = os.path.splitext(os.path.basename(filepath))[0]
819 
820         return FileItem(modname, filepath, filepath)
821 
822     def _iterate_file_descrs(self, files_or_modules) -> Iterator[FileItem]:
823         """Return generator yielding file descriptions (tuples of module name, file path, base name).
824 
825         The returned generator yield one item for each Python module that should be linted.
826         """
827         for descr in self._expand_files(files_or_modules):
828             name, filepath, is_arg = descr["name"], descr["path"], descr["isarg"]
829             if self.should_analyze_file(name, filepath, is_argument=is_arg):
830                 yield FileItem(name, filepath, descr["basename"])
831 
832     def _expand_files(self, modules: list[str]) -> list[ModuleDescriptionDict]:
833         """Get modules and errors from a list of modules and handle errors."""
834         result, errors = expand_modules(
835             modules,
836             self.config.ignore,
837             self.config.ignore_patterns,
838             self._ignore_paths,
839         )
840         for error in errors:
841             message = modname = error["mod"]
842             key = error["key"]
843             self.set_current_module(modname)
844             if key == "fatal":
845                 message = str(error["ex"]).replace(os.getcwd() + os.sep, "")
846             self.add_message(key, args=message)
847         return result
848 
849     def set_current_module(self, modname, filepath: str | None = None):
850         """Set the name of the currently analyzed module and
851         init statistics for it
852         """
853         if not modname and filepath is None:
854             return
855         self.reporter.on_set_current_module(modname, filepath)
856         if modname is None:
857             warnings.warn(
858                 (
859                     "In pylint 3.0 modname should be a string so that it can be used to "
860                     "correctly set the current_name attribute of the linter instance. "
861                     "If unknown it should be initialized as an empty string."
862                 ),
863                 DeprecationWarning,
864             )
865         self.current_name = modname
866         self.current_file = filepath or modname
867         self.stats.init_single_module(modname)
868 
869     @contextlib.contextmanager
870     def _astroid_module_checker(self):
871         """Context manager for checking ASTs.
872 
873         The value in the context is callable accepting AST as its only argument.
874         """
875         walker = ASTWalker(self)
876         _checkers = self.prepare_checkers()
877         with warnings.catch_warnings():
878             warnings.filterwarnings("ignore", category=DeprecationWarning)
879             tokencheckers = [
880                 c
881                 for c in _checkers
882                 if (
883                     interfaces.implements(c, interfaces.ITokenChecker)
884                     or isinstance(c, checkers.BaseTokenChecker)
885                 )
886                 and c is not self
887             ]
888         with warnings.catch_warnings():
889             warnings.filterwarnings("ignore", category=DeprecationWarning)
890             rawcheckers = [
891                 c
892                 for c in _checkers
893                 if interfaces.implements(c, interfaces.IRawChecker)
894                 or isinstance(c, checkers.BaseRawFileChecker)
895             ]
896         # notify global begin
897         for checker in _checkers:
898             checker.open()
899             walker.add_checker(checker)
900 
901         yield functools.partial(
902             self.check_astroid_module,
903             walker=walker,
904             tokencheckers=tokencheckers,
905             rawcheckers=rawcheckers,
906         )
907 
908         # notify global end
909         self.stats.statement = walker.nbstatements
910         for checker in reversed(_checkers):
911             checker.close()
912 
913     def get_ast(
914         self, filepath: str, modname: str, data: str | None = None
915     ) -> nodes.Module:
916         """Return an ast(roid) representation of a module or a string.
917 
918         :param str filepath: path to checked file.
919         :param str modname: The name of the module to be checked.
920         :param str data: optional contents of the checked file.
921         :returns: the AST
922         :rtype: astroid.nodes.Module
923         :raises AstroidBuildingError: Whenever we encounter an unexpected exception
924         """
925         try:
926             if data is None:
927                 return MANAGER.ast_from_file(filepath, modname, source=True)
928             return astroid.builder.AstroidBuilder(MANAGER).string_build(
929                 data, modname, filepath
930             )
931         except astroid.AstroidSyntaxError as ex:
932             # pylint: disable=no-member
933             self.add_message(
934                 "syntax-error",
935                 line=getattr(ex.error, "lineno", 0),
936                 col_offset=getattr(ex.error, "offset", None),
937                 args=str(ex.error),
938             )
939         except astroid.AstroidBuildingError as ex:
940             self.add_message("parse-error", args=ex)
941         except Exception as ex:
942             traceback.print_exc()
943             # We raise BuildingError here as this is essentially an astroid issue
944             # Creating an issue template and adding the 'astroid-error' message is handled
945             # by caller: _check_files
946             raise astroid.AstroidBuildingError(
947                 "Building error when trying to create ast representation of module '{modname}'",
948                 modname=modname,
949             ) from ex
950         return None
951 
952     def check_astroid_module(self, ast_node, walker, rawcheckers, tokencheckers):
953         """Check a module from its astroid representation.
954 
955         For return value see _check_astroid_module
956         """
957         before_check_statements = walker.nbstatements
958 
959         retval = self._check_astroid_module(
960             ast_node, walker, rawcheckers, tokencheckers
961         )
962 
963         self.stats.by_module[self.current_name]["statement"] = (
964             walker.nbstatements - before_check_statements
965         )
966 
967         return retval
968 
969     def _check_astroid_module(
970         self, node: nodes.Module, walker, rawcheckers, tokencheckers
971     ):
972         """Check given AST node with given walker and checkers.
973 
974         :param astroid.nodes.Module node: AST node of the module to check
975         :param pylint.utils.ast_walker.ASTWalker walker: AST walker
976         :param list rawcheckers: List of token checkers to use
977         :param list tokencheckers: List of raw checkers to use
978 
979         :returns: True if the module was checked, False if ignored,
980             None if the module contents could not be parsed
981         :rtype: bool
982         """
983         try:
984             tokens = utils.tokenize_module(node)
985         except tokenize.TokenError as ex:
986             self.add_message("syntax-error", line=ex.args[1][0], args=ex.args[0])
987             return None
988 
989         if not node.pure_python:
990             self.add_message("raw-checker-failed", args=node.name)
991         else:
992             # assert astroid.file.endswith('.py')
993             # invoke ITokenChecker interface on self to fetch module/block
994             # level options
995             self.process_tokens(tokens)
996             if self._ignore_file:
997                 return False
998             # walk ast to collect line numbers
999             self.file_state.collect_block_lines(self.msgs_store, node)
1000             # run raw and tokens checkers
1001             for checker in rawcheckers:
1002                 checker.process_module(node)
1003             for checker in tokencheckers:
1004                 checker.process_tokens(tokens)
1005         # generate events to astroid checkers
1006         walker.walk(node)
1007         return True
1008 
1009     def open(self):
1010         """Initialize counters."""
1011         self.stats = LinterStats()
1012         MANAGER.always_load_extensions = self.config.unsafe_load_any_extension
1013         MANAGER.max_inferable_values = self.config.limit_inference_results
1014         MANAGER.extension_package_whitelist.update(self.config.extension_pkg_allow_list)
1015         if self.config.extension_pkg_whitelist:
1016             MANAGER.extension_package_whitelist.update(
1017                 self.config.extension_pkg_whitelist
1018             )
1019         self.stats.reset_message_count()
1020         self._ignore_paths = self.linter.config.ignore_paths
1021 
1022     def generate_reports(self) -> int | None:
1023         """Close the whole package /module, it's time to make reports !
1024 
1025         if persistent run, pickle results for later comparison
1026         """
1027         # Display whatever messages are left on the reporter.
1028         self.reporter.display_messages(report_nodes.Section())
1029 
1030         if self.file_state.base_name is not None:
1031             # load previous results if any
1032             previous_stats = config.load_results(self.file_state.base_name)
1033             self.reporter.on_close(self.stats, previous_stats)
1034             if self.config.reports:
1035                 sect = self.make_reports(self.stats, previous_stats)
1036             else:
1037                 sect = report_nodes.Section()
1038 
1039             if self.config.reports:
1040                 self.reporter.display_reports(sect)
1041             score_value = self._report_evaluation()
1042             # save results if persistent run
1043             if self.config.persistent:
1044                 config.save_results(self.stats, self.file_state.base_name)
1045         else:
1046             self.reporter.on_close(self.stats, LinterStats())
1047             score_value = None
1048         return score_value
1049 
1050     def _report_evaluation(self) -> int | None:
1051         """Make the global evaluation report."""
1052         # check with at least check 1 statements (usually 0 when there is a
1053         # syntax error preventing pylint from further processing)
1054         note = None
1055         previous_stats = config.load_results(self.file_state.base_name)
1056         if self.stats.statement == 0:
1057             return note
1058 
1059         # get a global note for the code
1060         evaluation = self.config.evaluation
1061         try:
1062             stats_dict = {
1063                 "fatal": self.stats.fatal,
1064                 "error": self.stats.error,
1065                 "warning": self.stats.warning,
1066                 "refactor": self.stats.refactor,
1067                 "convention": self.stats.convention,
1068                 "statement": self.stats.statement,
1069                 "info": self.stats.info,
1070             }
1071             note = eval(evaluation, {}, stats_dict)  # pylint: disable=eval-used
1072         except Exception as ex:  # pylint: disable=broad-except
1073             msg = f"An exception occurred while rating: {ex}"
1074         else:
1075             self.stats.global_note = note
1076             msg = f"Your code has been rated at {note:.2f}/10"
1077             if previous_stats:
1078                 pnote = previous_stats.global_note
1079                 if pnote is not None:
1080                     msg += f" (previous run: {pnote:.2f}/10, {note - pnote:+.2f})"
1081 
1082         if self.config.score:
1083             sect = report_nodes.EvaluationSection(msg)
1084             self.reporter.display_reports(sect)
1085         return note
1086 
1087     # Adding (ignored) messages to the Message Reporter
1088 
1089     def _get_message_state_scope(
1090         self,
1091         msgid: str,
1092         line: int | None = None,
1093         confidence: interfaces.Confidence | None = None,
1094     ) -> Literal[0, 1, 2] | None:
1095         """Returns the scope at which a message was enabled/disabled."""
1096         if confidence is None:
1097             confidence = interfaces.UNDEFINED
1098         if confidence.name not in self.config.confidence:
1099             return MSG_STATE_CONFIDENCE  # type: ignore[return-value] # mypy does not infer Literal correctly
1100         try:
1101             if line in self.file_state._module_msgs_state[msgid]:
1102                 return MSG_STATE_SCOPE_MODULE  # type: ignore[return-value]
1103         except (KeyError, TypeError):
1104             return MSG_STATE_SCOPE_CONFIG  # type: ignore[return-value]
1105         return None
1106 
1107     def _is_one_message_enabled(self, msgid: str, line: int | None) -> bool:
1108         """Checks state of a single message for the current file.
1109 
1110         This function can't be cached as it depends on self.file_state which can
1111         change.
1112         """
1113         if line is None:
1114             return self._msgs_state.get(msgid, True)
1115         try:
1116             return self.file_state._module_msgs_state[msgid][line]
1117         except KeyError:
1118             # Check if the message's line is after the maximum line existing in ast tree.
1119             # This line won't appear in the ast tree and won't be referred in
1120             # self.file_state._module_msgs_state
1121             # This happens for example with a commented line at the end of a module.
1122             max_line_number = self.file_state.get_effective_max_line_number()
1123             if max_line_number and line > max_line_number:
1124                 fallback = True
1125                 lines = self.file_state._raw_module_msgs_state.get(msgid, {})
1126 
1127                 # Doesn't consider scopes, as a 'disable' can be in a
1128                 # different scope than that of the current line.
1129                 closest_lines = reversed(
1130                     [
1131                         (message_line, enable)
1132                         for message_line, enable in lines.items()
1133                         if message_line <= line
1134                     ]
1135                 )
1136                 _, fallback_iter = next(closest_lines, (None, None))
1137                 if fallback_iter is not None:
1138                     fallback = fallback_iter
1139 
1140                 return self._msgs_state.get(msgid, fallback)
1141             return self._msgs_state.get(msgid, True)
1142 
1143     def is_message_enabled(
1144         self,
1145         msg_descr: str,
1146         line: int | None = None,
1147         confidence: interfaces.Confidence | None = None,
1148     ) -> bool:
1149         """Return whether this message is enabled for the current file, line and confidence level.
1150 
1151         This function can't be cached right now as the line is the line of
1152         the currently analysed file (self.file_state), if it changes, then the
1153         result for the same msg_descr/line might need to change.
1154 
1155         :param msg_descr: Either the msgid or the symbol for a MessageDefinition
1156         :param line: The line of the currently analysed file
1157         :param confidence: The confidence of the message
1158         """
1159         if confidence and confidence.name not in self.config.confidence:
1160             return False
1161         try:
1162             msgids = self.msgs_store.message_id_store.get_active_msgids(msg_descr)
1163         except exceptions.UnknownMessageError:
1164             # The linter checks for messages that are not registered
1165             # due to version mismatch, just treat them as message IDs
1166             # for now.
1167             msgids = [msg_descr]
1168         return any(self._is_one_message_enabled(msgid, line) for msgid in msgids)
1169 
1170     def _add_one_message(
1171         self,
1172         message_definition: MessageDefinition,
1173         line: int | None,
1174         node: nodes.NodeNG | None,
1175         args: Any | None,
1176         confidence: interfaces.Confidence | None,
1177         col_offset: int | None,
1178         end_lineno: int | None,
1179         end_col_offset: int | None,
1180     ) -> None:
1181         """After various checks have passed a single Message is
1182         passed to the reporter and added to stats
1183         """
1184         message_definition.check_message_definition(line, node)
1185 
1186         # Look up "location" data of node if not yet supplied
1187         if node:
1188             if node.position:
1189                 if not line:
1190                     line = node.position.lineno
1191                 if not col_offset:
1192                     col_offset = node.position.col_offset
1193                 if not end_lineno:
1194                     end_lineno = node.position.end_lineno
1195                 if not end_col_offset:
1196                     end_col_offset = node.position.end_col_offset
1197             else:
1198                 if not line:
1199                     line = node.fromlineno
1200                 if not col_offset:
1201                     col_offset = node.col_offset
1202                 if not end_lineno:
1203                     end_lineno = node.end_lineno
1204                 if not end_col_offset:
1205                     end_col_offset = node.end_col_offset
1206 
1207         # should this message be displayed
1208         if not self.is_message_enabled(message_definition.msgid, line, confidence):
1209             self.file_state.handle_ignored_message(
1210                 self._get_message_state_scope(
1211                     message_definition.msgid, line, confidence
1212                 ),
1213                 message_definition.msgid,
1214                 line,
1215             )
1216             return
1217 
1218         # update stats
1219         msg_cat = MSG_TYPES[message_definition.msgid[0]]
1220         self.msg_status |= MSG_TYPES_STATUS[message_definition.msgid[0]]
1221         self.stats.increase_single_message_count(msg_cat, 1)
1222         self.stats.increase_single_module_message_count(
1223             self.current_name,  # type: ignore[arg-type] # Should be removable after https://github.com/PyCQA/pylint/pull/5580
1224             msg_cat,
1225             1,
1226         )
1227         try:
1228             self.stats.by_msg[message_definition.symbol] += 1
1229         except KeyError:
1230             self.stats.by_msg[message_definition.symbol] = 1
1231         # Interpolate arguments into message string
1232         msg = message_definition.msg
1233         if args is not None:
1234             msg %= args
1235         # get module and object
1236         if node is None:
1237             module, obj = self.current_name, ""
1238             abspath = self.current_file
1239         else:
1240             module, obj = utils.get_module_and_frameid(node)
1241             abspath = node.root().file
1242         if abspath is not None:
1243             path = abspath.replace(self.reporter.path_strip_prefix, "", 1)
1244         else:
1245             path = "configuration"
1246         # add the message
1247         self.reporter.handle_message(
1248             Message(
1249                 message_definition.msgid,
1250                 message_definition.symbol,
1251                 MessageLocationTuple(
1252                     abspath or "",
1253                     path,
1254                     module or "",
1255                     obj,
1256                     line or 1,
1257                     col_offset or 0,
1258                     end_lineno,
1259                     end_col_offset,
1260                 ),
1261                 msg,
1262                 confidence,
1263             )
1264         )
1265 
1266     def add_message(
1267         self,
1268         msgid: str,
1269         line: int | None = None,
1270         node: nodes.NodeNG | None = None,
1271         args: Any | None = None,
1272         confidence: interfaces.Confidence | None = None,
1273         col_offset: int | None = None,
1274         end_lineno: int | None = None,
1275         end_col_offset: int | None = None,
1276     ) -> None:
1277         """Adds a message given by ID or name.
1278 
1279         If provided, the message string is expanded using args.
1280 
1281         AST checkers must provide the node argument (but may optionally
1282         provide line if the line number is different), raw and token checkers
1283         must provide the line argument.
1284         """
1285         if confidence is None:
1286             confidence = interfaces.UNDEFINED
1287         message_definitions = self.msgs_store.get_message_definitions(msgid)
1288         for message_definition in message_definitions:
1289             self._add_one_message(
1290                 message_definition,
1291                 line,
1292                 node,
1293                 args,
1294                 confidence,
1295                 col_offset,
1296                 end_lineno,
1297                 end_col_offset,
1298             )
1299 
1300     def add_ignored_message(
1301         self,
1302         msgid: str,
1303         line: int,
1304         node: nodes.NodeNG | None = None,
1305         confidence: interfaces.Confidence | None = interfaces.UNDEFINED,
1306     ) -> None:
1307         """Prepares a message to be added to the ignored message storage.
1308 
1309         Some checks return early in special cases and never reach add_message(),
1310         even though they would normally issue a message.
1311         This creates false positives for useless-suppression.
1312         This function avoids this by adding those message to the ignored msgs attribute
1313         """
1314         message_definitions = self.msgs_store.get_message_definitions(msgid)
1315         for message_definition in message_definitions:
1316             message_definition.check_message_definition(line, node)
1317             self.file_state.handle_ignored_message(
1318                 self._get_message_state_scope(
1319                     message_definition.msgid, line, confidence
1320                 ),
1321                 message_definition.msgid,
1322                 line,
1323             )
1324 
1325     # Setting the state (disabled/enabled) of messages and registering them
1326 
1327     def _set_one_msg_status(
1328         self, scope: str, msg: MessageDefinition, line: int | None, enable: bool
1329     ) -> None:
1330         """Set the status of an individual message."""
1331         if scope == "module":
1332             assert isinstance(line, int)  # should always be int inside module scope
1333 
1334             self.file_state.set_msg_status(msg, line, enable)
1335             if not enable and msg.symbol != "locally-disabled":
1336                 self.add_message(
1337                     "locally-disabled", line=line, args=(msg.symbol, msg.msgid)
1338                 )
1339         else:
1340             msgs = self._msgs_state
1341             msgs[msg.msgid] = enable
1342 
1343     def _get_messages_to_set(
1344         self, msgid: str, enable: bool, ignore_unknown: bool = False
1345     ) -> list[MessageDefinition]:
1346         """Do some tests and find the actual messages of which the status should be set."""
1347         message_definitions = []
1348         if msgid == "all":
1349             for _msgid in MSG_TYPES:
1350                 message_definitions.extend(
1351                     self._get_messages_to_set(_msgid, enable, ignore_unknown)
1352                 )
1353             return message_definitions
1354 
1355         # msgid is a category?
1356         category_id = msgid.upper()
1357         if category_id not in MSG_TYPES:
1358             category_id_formatted = MSG_TYPES_LONG.get(category_id)
1359         else:
1360             category_id_formatted = category_id
1361         if category_id_formatted is not None:
1362             for _msgid in self.msgs_store._msgs_by_category[category_id_formatted]:
1363                 message_definitions.extend(
1364                     self._get_messages_to_set(_msgid, enable, ignore_unknown)
1365                 )
1366             return message_definitions
1367 
1368         # msgid is a checker name?
1369         if msgid.lower() in self._checkers:
1370             for checker in self._checkers[msgid.lower()]:
1371                 for _msgid in checker.msgs:
1372                     message_definitions.extend(
1373                         self._get_messages_to_set(_msgid, enable, ignore_unknown)
1374                     )
1375             return message_definitions
1376 
1377         # msgid is report id?
1378         if msgid.lower().startswith("rp"):
1379             if enable:
1380                 self.enable_report(msgid)
1381             else:
1382                 self.disable_report(msgid)
1383             return message_definitions
1384 
1385         try:
1386             # msgid is a symbolic or numeric msgid.
1387             message_definitions = self.msgs_store.get_message_definitions(msgid)
1388         except exceptions.UnknownMessageError:
1389             if not ignore_unknown:
1390                 raise
1391         return message_definitions
1392 
1393     def _set_msg_status(
1394         self,
1395         msgid: str,
1396         enable: bool,
1397         scope: str = "package",
1398         line: int | None = None,
1399         ignore_unknown: bool = False,
1400     ) -> None:
1401         """Do some tests and then iterate over message definitions to set state."""
1402         assert scope in {"package", "module"}
1403 
1404         message_definitions = self._get_messages_to_set(msgid, enable, ignore_unknown)
1405 
1406         for message_definition in message_definitions:
1407             self._set_one_msg_status(scope, message_definition, line, enable)
1408 
1409         # sync configuration object
1410         self.config.enable = []
1411         self.config.disable = []
1412         for msgid_or_symbol, is_enabled in self._msgs_state.items():
1413             symbols = [
1414                 m.symbol
1415                 for m in self.msgs_store.get_message_definitions(msgid_or_symbol)
1416             ]
1417             if is_enabled:
1418                 self.config.enable += symbols
1419             else:
1420                 self.config.disable += symbols
1421 
1422     def _register_by_id_managed_msg(
1423         self, msgid_or_symbol: str, line: int | None, is_disabled: bool = True
1424     ) -> None:
1425         """If the msgid is a numeric one, then register it to inform the user
1426         it could furnish instead a symbolic msgid.
1427         """
1428         if msgid_or_symbol[1:].isdigit():
1429             try:
1430                 symbol = self.msgs_store.message_id_store.get_symbol(
1431                     msgid=msgid_or_symbol
1432                 )
1433             except exceptions.UnknownMessageError:
1434                 return
1435             managed = ManagedMessage(
1436                 self.current_name, msgid_or_symbol, symbol, line, is_disabled
1437             )
1438             self._by_id_managed_msgs.append(managed)
1439 
1440     def disable(
1441         self,
1442         msgid: str,
1443         scope: str = "package",
1444         line: int | None = None,
1445         ignore_unknown: bool = False,
1446     ) -> None:
1447         """Disable a message for a scope."""
1448         self._set_msg_status(
1449             msgid, enable=False, scope=scope, line=line, ignore_unknown=ignore_unknown
1450         )
1451         self._register_by_id_managed_msg(msgid, line)
1452 
1453     def disable_next(
1454         self,
1455         msgid: str,
1456         scope: str = "package",
1457         line: int | None = None,
1458         ignore_unknown: bool = False,
1459     ) -> None:
1460         """Disable a message for the next line."""
1461         if not line:
1462             raise exceptions.NoLineSuppliedError
1463         self._set_msg_status(
1464             msgid,
1465             enable=False,
1466             scope=scope,
1467             line=line + 1,
1468             ignore_unknown=ignore_unknown,
1469         )
1470         self._register_by_id_managed_msg(msgid, line + 1)
1471 
1472     def enable(
1473         self,
1474         msgid: str,
1475         scope: str = "package",
1476         line: int | None = None,
1477         ignore_unknown: bool = False,
1478     ) -> None:
1479         """Enable a message for a scope."""
1480         self._set_msg_status(
1481             msgid, enable=True, scope=scope, line=line, ignore_unknown=ignore_unknown
1482         )
1483         self._register_by_id_managed_msg(msgid, line, is_disabled=False)

</code><intended_behavior>In addition to the current functionality, these methods should be enhanced to support `isinstance` checks using `ABCMeta` for categorizing checkers and reporters. This means that when checkers or reporters are registered, the PyLinter should be able to recognize them based on whether they are instances of a specific abstract base class (or classes), without solely relying on the `__implements__` attribute. This requires defining new abstract base classes for checkers and reporters (if not already defined) using `ABCMeta` and adjusting these methods to recognize checkers and reporters based on these new abstract classes. This modification should preserve backward compatibility by still supporting the `__implements__` attribute during a transition period.</intended_behavior>, <file>pylint/interfaces.py</file>
<class>None</class>
<method>None</method>
<code>
1 # Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
2 # For details: https://github.com/PyCQA/pylint/blob/main/LICENSE
3 # Copyright (c) https://github.com/PyCQA/pylint/blob/main/CONTRIBUTORS.txt
4 
5 """Interfaces for Pylint objects."""
6 
7 from __future__ import annotations
8 
9 import warnings
10 from collections import namedtuple
11 from tokenize import TokenInfo
12 from typing import TYPE_CHECKING
13 
14 from astroid import nodes
15 
16 if TYPE_CHECKING:
17     from pylint.checkers import BaseChecker
18     from pylint.reporters.ureports.nodes import Section
19 
20 __all__ = (
21     "IRawChecker",
22     "IAstroidChecker",
23     "ITokenChecker",
24     "IReporter",
25     "IChecker",
26     "HIGH",
27     "CONTROL_FLOW",
28     "INFERENCE",
29     "INFERENCE_FAILURE",
30     "UNDEFINED",
31     "CONFIDENCE_LEVELS",
32     "CONFIDENCE_LEVEL_NAMES",
33 )
34 
35 Confidence = namedtuple("Confidence", ["name", "description"])
36 # Warning Certainties
37 HIGH = Confidence("HIGH", "Warning that is not based on inference result.")
38 CONTROL_FLOW = Confidence(
39     "CONTROL_FLOW", "Warning based on assumptions about control flow."
40 )
41 INFERENCE = Confidence("INFERENCE", "Warning based on inference result.")
42 INFERENCE_FAILURE = Confidence(
43     "INFERENCE_FAILURE", "Warning based on inference with failures."
44 )
45 UNDEFINED = Confidence("UNDEFINED", "Warning without any associated confidence level.")
46 
47 CONFIDENCE_LEVELS = [HIGH, CONTROL_FLOW, INFERENCE, INFERENCE_FAILURE, UNDEFINED]
48 CONFIDENCE_LEVEL_NAMES = [i.name for i in CONFIDENCE_LEVELS]
49 
50 
51 class Interface:
52     """Base class for interfaces."""
53 
54     @classmethod
55     def is_implemented_by(cls, instance):
56         with warnings.catch_warnings():
57             warnings.filterwarnings("ignore", category=DeprecationWarning)
58             return implements(instance, cls)
59 
60 
61 def implements(
62     obj: BaseChecker,
63     interface: type[Interface] | tuple[type[Interface], ...],
64 ) -> bool:
65     """Does the given object (maybe an instance or class) implement the interface."""
66     # TODO: 3.0: Remove deprecated function # pylint: disable=fixme
67     warnings.warn(
68         "implements has been deprecated in favour of using basic "
69         "inheritance patterns without using __implements__.",
70         DeprecationWarning,
71     )
72     implements_ = getattr(obj, "__implements__", ())
73     if not isinstance(implements_, (list, tuple)):
74         implements_ = (implements_,)
75     return any(issubclass(i, interface) for i in implements_)
76 
77 
78 class IChecker(Interface):
79     """Base interface, to be used only for sub interfaces definition."""
80 
81     def open(self):
82         """Called before visiting project (i.e. set of modules)."""
83 
84     def close(self):
85         """Called after visiting project (i.e. set of modules)."""
86 
87 
88 class IRawChecker(IChecker):
89     """Interface for checker which need to parse the raw file."""
90 
91     def process_module(self, node: nodes.Module) -> None:
92         """Process a module.
93 
94         The module's content is accessible via ``astroid.stream``
95         """
96 
97 
98 class ITokenChecker(IChecker):
99     """Interface for checkers that need access to the token list."""
100 
101     def process_tokens(self, tokens: list[TokenInfo]) -> None:
102         """Process a module.
103 
104         Tokens is a list of all source code tokens in the file.
105         """
106 
107 
108 class IAstroidChecker(IChecker):
109     """Interface for checker which prefers receive events according to
110     statement type
111     """
112 
113 
114 class IReporter(Interface):
115     """Reporter collect messages and display results encapsulated in a layout."""
116 
117     def handle_message(self, msg) -> None:
118         """Handle the given message object."""
119 
120     def display_reports(self, layout: Section) -> None:
121         """Display results encapsulated in the layout tree."""

</code><intended_behavior>This file should introduce new abstract base classes for the checkers and reporters using `ABCMeta`. Each checker or reporter class should then be updated to inherit from these new abstract base classes instead of or in addition to using the `__implements__` attribute. The "implements" function within interfaces.py could be revised or supplemented with a new mechanism that leverages `isinstance` checks against these new abstract base classes to understand whether a given object conforms to the expected interface.</intended_behavior>]
2025-10-18 16:00:16.118 | INFO     | Search completed. Bug locations: [<file>pylint/lint/pylinter.py</file>
<class>PyLinter</class>
<method>None</method>
<code>
191 class PyLinter(
192     _ArgumentsManager,
193     reporters.ReportsHandlerMixIn,
194     checkers.BaseTokenChecker,
195 ):
196     """Lint Python modules using external checkers.
197 
198     This is the main checker controlling the other ones and the reports
199     generation. It is itself both a raw checker and an astroid checker in order
200     to:
201     * handle message activation / deactivation at the module level
202     * handle some basic but necessary stats'data (number of classes, methods...)
203 
204     IDE plugin developers: you may have to call
205     `astroid.builder.MANAGER.astroid_cache.clear()` across runs if you want
206     to ensure the latest code version is actually checked.
207 
208     This class needs to support pickling for parallel linting to work. The exception
209     is reporter member; see check_parallel function for more details.
210     """
211 
212     name = MAIN_CHECKER_NAME
213     msgs = MSGS
214     # Will be used like this : datetime.now().strftime(crash_file_path)
215     crash_file_path: str = "pylint-crash-%Y-%m-%d-%H.txt"
216 
217     option_groups_descs = {
218         "Messages control": "Options controlling analysis messages",
219         "Reports": "Options related to output formatting and reporting",
220     }
221 
222     def __init__(
223         self,
224         options: Options = (),
225         reporter: reporters.BaseReporter | reporters.MultiReporter | None = None,
226         option_groups: tuple[tuple[str, str], ...] = (),
227         # pylint: disable-next=fixme
228         # TODO: Deprecate passing the pylintrc parameter
229         pylintrc: str | None = None,  # pylint: disable=unused-argument
230     ) -> None:
231         _ArgumentsManager.__init__(self, prog="pylint")
232 
233         # Some stuff has to be done before initialization of other ancestors...
234         # messages store / checkers / reporter / astroid manager
235 
236         # Attributes for reporters
237         self.reporter: reporters.BaseReporter | reporters.MultiReporter
238         if reporter:
239             self.set_reporter(reporter)
240         else:
241             self.set_reporter(TextReporter())
242         self._reporters: dict[str, type[reporters.BaseReporter]] = {}
243         """Dictionary of possible but non-initialized reporters."""
244 
245         # Attributes for checkers and plugins
246         self._checkers: defaultdict[
247             str, list[checkers.BaseChecker]
248         ] = collections.defaultdict(list)
249         """Dictionary of registered and initialized checkers."""
250         self._dynamic_plugins: set[str] = set()
251         """Set of loaded plugin names."""
252 
253         # Attributes related to visiting files
254         self.file_state = FileState()
255         self.current_name: str | None = None
256         self.current_file: str | None = None
257         self._ignore_file = False
258         self._pragma_lineno: dict[str, int] = {}
259 
260         # Attributes related to stats
261         self.stats = LinterStats()
262 
263         # Attributes related to (command-line) options and their parsing
264         self.options: Options = options + _make_linter_options(self)
265         for opt_group in option_groups:
266             self.option_groups_descs[opt_group[0]] = opt_group[1]
267         self._option_groups: tuple[tuple[str, str], ...] = option_groups + (
268             ("Messages control", "Options controlling analysis messages"),
269             ("Reports", "Options related to output formatting and reporting"),
270         )
271         self._options_methods = {
272             "enable": self.enable,
273             "disable": self.disable,
274             "disable-next": self.disable_next,
275         }
276         self._bw_options_methods = {
277             "disable-msg": self._options_methods["disable"],
278             "enable-msg": self._options_methods["enable"],
279         }
280         self.fail_on_symbols: list[str] = []
281         """List of message symbols on which pylint should fail, set by --fail-on."""
282         self._error_mode = False
283 
284         # Attributes related to messages (states) and their handling
285         self.msgs_store = MessageDefinitionStore()
286         self.msg_status = 0
287         self._msgs_state: dict[str, bool] = {}
288         self._by_id_managed_msgs: list[ManagedMessage] = []
289 
290         reporters.ReportsHandlerMixIn.__init__(self)
291         checkers.BaseTokenChecker.__init__(self, self)
292         # provided reports
293         self.reports = (
294             ("RP0001", "Messages by category", report_total_messages_stats),
295             (
296                 "RP0002",
297                 "% errors / warnings by module",
298                 report_messages_by_module_stats,
299             ),
300             ("RP0003", "Messages", report_messages_stats),
301         )
302         self.register_checker(self)
303 
304     @property
305     def option_groups(self) -> tuple[tuple[str, str], ...]:
306         # TODO: 3.0: Remove deprecated attribute # pylint: disable=fixme
307         warnings.warn(
308             "The option_groups attribute has been deprecated and will be removed in pylint 3.0",
309             DeprecationWarning,
310         )
311         return self._option_groups
312 
313     @option_groups.setter
314     def option_groups(self, value: tuple[tuple[str, str], ...]) -> None:
315         warnings.warn(
316             "The option_groups attribute has been deprecated and will be removed in pylint 3.0",
317             DeprecationWarning,
318         )
319         self._option_groups = value
320 
321     def load_default_plugins(self) -> None:
322         checkers.initialize(self)
323         reporters.initialize(self)
324 
325     def load_plugin_modules(self, modnames: list[str]) -> None:
326         """Check a list pylint plugins modules, load and register them."""
327         for modname in modnames:
328             if modname in self._dynamic_plugins:
329                 continue
330             self._dynamic_plugins.add(modname)
331             try:
332                 module = astroid.modutils.load_module_from_name(modname)
333                 module.register(self)
334             except ModuleNotFoundError:
335                 pass
336 
337     def load_plugin_configuration(self) -> None:
338         """Call the configuration hook for plugins.
339 
340         This walks through the list of plugins, grabs the "load_configuration"
341         hook, if exposed, and calls it to allow plugins to configure specific
342         settings.
343         """
344         for modname in self._dynamic_plugins:
345             try:
346                 module = astroid.modutils.load_module_from_name(modname)
347                 if hasattr(module, "load_configuration"):
348                     module.load_configuration(self)
349             except ModuleNotFoundError as e:
350                 self.add_message("bad-plugin-value", args=(modname, e), line=0)
351 
352     def _load_reporters(self, reporter_names: str) -> None:
353         """Load the reporters if they are available on _reporters."""
354         if not self._reporters:
355             return
356         sub_reporters = []
357         output_files = []
358         with contextlib.ExitStack() as stack:
359             for reporter_name in reporter_names.split(","):
360                 reporter_name, *reporter_output = reporter_name.split(":", 1)
361 
362                 reporter = self._load_reporter_by_name(reporter_name)
363                 sub_reporters.append(reporter)
364                 if reporter_output:
365                     output_file = stack.enter_context(
366                         open(reporter_output[0], "w", encoding="utf-8")
367                     )
368                     reporter.out = output_file
369                     output_files.append(output_file)
370 
371             # Extend the lifetime of all opened output files
372             close_output_files = stack.pop_all().close
373 
374         if len(sub_reporters) > 1 or output_files:
375             self.set_reporter(
376                 reporters.MultiReporter(
377                     sub_reporters,
378                     close_output_files,
379                 )
380             )
381         else:
382             self.set_reporter(sub_reporters[0])
383 
384     def _load_reporter_by_name(self, reporter_name: str) -> reporters.BaseReporter:
385         name = reporter_name.lower()
386         if name in self._reporters:
387             return self._reporters[name]()
388 
389         try:
390             reporter_class = _load_reporter_by_class(reporter_name)
391         except (ImportError, AttributeError) as e:
392             raise exceptions.InvalidReporterError(name) from e
393         else:
394             return reporter_class()
395 
396     def set_reporter(
397         self, reporter: reporters.BaseReporter | reporters.MultiReporter
398     ) -> None:
399         """Set the reporter used to display messages and reports."""
400         self.reporter = reporter
401         reporter.linter = self
402 
403     def register_reporter(self, reporter_class: type[reporters.BaseReporter]) -> None:
404         """Registers a reporter class on the _reporters attribute."""
405         self._reporters[reporter_class.name] = reporter_class
406 
407     def report_order(self) -> list[BaseChecker]:
408         reports = sorted(self._reports, key=lambda x: getattr(x, "name", ""))
409         try:
410             # Remove the current reporter and add it
411             # at the end of the list.
412             reports.pop(reports.index(self))
413         except ValueError:
414             pass
415         else:
416             reports.append(self)
417         return reports
418 
419     # checkers manipulation methods ############################################
420 
421     def register_checker(self, checker: checkers.BaseChecker) -> None:
422         """This method auto registers the checker."""
423         self._checkers[checker.name].append(checker)
424         for r_id, r_title, r_cb in checker.reports:
425             self.register_report(r_id, r_title, r_cb, checker)
426         if hasattr(checker, "msgs"):
427             self.msgs_store.register_messages_from_checker(checker)
428         # Register the checker, but disable all of its messages.
429         if not getattr(checker, "enabled", True):
430             self.disable(checker.name)
431 
432     def enable_fail_on_messages(self) -> None:
433         """Enable 'fail on' msgs.
434 
435         Convert values in config.fail_on (which might be msg category, msg id,
436         or symbol) to specific msgs, then enable and flag them for later.
437         """
438         fail_on_vals = self.config.fail_on
439         if not fail_on_vals:
440             return
441 
442         fail_on_cats = set()
443         fail_on_msgs = set()
444         for val in fail_on_vals:
445             # If value is a category, add category, else add message
446             if val in MSG_TYPES:
447                 fail_on_cats.add(val)
448             else:
449                 fail_on_msgs.add(val)
450 
451         # For every message in every checker, if cat or msg flagged, enable check
452         for all_checkers in self._checkers.values():
453             for checker in all_checkers:
454                 for msg in checker.messages:
455                     if msg.msgid in fail_on_msgs or msg.symbol in fail_on_msgs:
456                         # message id/symbol matched, enable and flag it
457                         self.enable(msg.msgid)
458                         self.fail_on_symbols.append(msg.symbol)
459                     elif msg.msgid[0] in fail_on_cats:
460                         # message starts with a category value, flag (but do not enable) it
461                         self.fail_on_symbols.append(msg.symbol)
462 
463     def any_fail_on_issues(self):
464         return self.stats and any(
465             x in self.fail_on_symbols for x in self.stats.by_msg.keys()
466         )
467 
468     def disable_noerror_messages(self) -> None:
469         for msgcat, msgids in self.msgs_store._msgs_by_category.items():
470             # enable only messages with 'error' severity and above ('fatal')
471             if msgcat in {"E", "F"}:
472                 for msgid in msgids:
473                     self.enable(msgid)
474             else:
475                 for msgid in msgids:
476                     self.disable(msgid)
477 
478     def disable_reporters(self) -> None:
479         """Disable all reporters."""
480         for _reporters in self._reports.values():
481             for report_id, _, _ in _reporters:
482                 self.disable_report(report_id)
483 
484     def _parse_error_mode(self) -> None:
485         """Parse the current state of the error mode.
486 
487         Error mode: enable only errors; no reports, no persistent.
488         """
489         if not self._error_mode:
490             return
491 
492         self.disable_noerror_messages()
493         self.disable("miscellaneous")
494         self.set_option("reports", False)
495         self.set_option("persistent", False)
496         self.set_option("score", False)
497 
498     def list_messages_enabled(self) -> None:
499         emittable, non_emittable = self.msgs_store.find_emittable_messages()
500         enabled = []
501         disabled = []
502         for message in emittable:
503             if self.is_message_enabled(message.msgid):
504                 enabled.append(f"  {message.symbol} ({message.msgid})")
505             else:
506                 disabled.append(f"  {message.symbol} ({message.msgid})")
507         print("Enabled messages:")
508         for msg in enabled:
509             print(msg)
510         print("\nDisabled messages:")
511         for msg in disabled:
512             print(msg)
513         print("\nNon-emittable messages with current interpreter:")
514         for msg_def in non_emittable:
515             print(f"  {msg_def.symbol} ({msg_def.msgid})")
516         print("")
517 
518     # block level option handling #############################################
519     # see func_block_disable_msg.py test case for expected behaviour
520 
521     def process_tokens(self, tokens: list[tokenize.TokenInfo]) -> None:
522         """Process tokens from the current module to search for module/block level
523         options.
524         """
525         control_pragmas = {"disable", "disable-next", "enable"}
526         prev_line = None
527         saw_newline = True
528         seen_newline = True
529         for (tok_type, content, start, _, _) in tokens:
530             if prev_line and prev_line != start[0]:
531                 saw_newline = seen_newline
532                 seen_newline = False
533 
534             prev_line = start[0]
535             if tok_type in (tokenize.NL, tokenize.NEWLINE):
536                 seen_newline = True
537 
538             if tok_type != tokenize.COMMENT:
539                 continue
540             match = OPTION_PO.search(content)
541             if match is None:
542                 continue
543             try:
544                 for pragma_repr in parse_pragma(match.group(2)):
545                     if pragma_repr.action in {"disable-all", "skip-file"}:
546                         if pragma_repr.action == "disable-all":
547                             self.add_message(
548                                 "deprecated-pragma",
549                                 line=start[0],
550                                 args=("disable-all", "skip-file"),
551                             )
552                         self.add_message("file-ignored", line=start[0])
553                         self._ignore_file = True
554                         return
555                     try:
556                         meth = self._options_methods[pragma_repr.action]
557                     except KeyError:
558                         meth = self._bw_options_methods[pragma_repr.action]
559                         # found a "(dis|en)able-msg" pragma deprecated suppression
560                         self.add_message(
561                             "deprecated-pragma",
562                             line=start[0],
563                             args=(
564                                 pragma_repr.action,
565                                 pragma_repr.action.replace("-msg", ""),
566                             ),
567                         )
568                     for msgid in pragma_repr.messages:
569                         # Add the line where a control pragma was encountered.
570                         if pragma_repr.action in control_pragmas:
571                             self._pragma_lineno[msgid] = start[0]
572 
573                         if (pragma_repr.action, msgid) == ("disable", "all"):
574                             self.add_message(
575                                 "deprecated-pragma",
576                                 line=start[0],
577                                 args=("disable=all", "skip-file"),
578                             )
579                             self.add_message("file-ignored", line=start[0])
580                             self._ignore_file = True
581                             return
582                             # If we did not see a newline between the previous line and now,
583                             # we saw a backslash so treat the two lines as one.
584                         l_start = start[0]
585                         if not saw_newline:
586                             l_start -= 1
587                         try:
588                             meth(msgid, "module", l_start)
589                         except exceptions.UnknownMessageError:
590                             msg = f"{pragma_repr.action}. Don't recognize message {msgid}."
591                             self.add_message(
592                                 "bad-option-value", args=msg, line=start[0]
593                             )
594             except UnRecognizedOptionError as err:
595                 self.add_message(
596                     "unrecognized-inline-option", args=err.token, line=start[0]
597                 )
598                 continue
599             except InvalidPragmaError as err:
600                 self.add_message("bad-inline-option", args=err.token, line=start[0])
601                 continue
602 
603     # code checking methods ###################################################
604 
605     def get_checkers(self) -> list[BaseChecker]:
606         """Return all available checkers as an ordered list."""
607         return sorted(c for _checkers in self._checkers.values() for c in _checkers)
608 
609     def get_checker_names(self) -> list[str]:
610         """Get all the checker names that this linter knows about."""
611         return sorted(
612             {
613                 checker.name
614                 for checker in self.get_checkers()
615                 if checker.name != MAIN_CHECKER_NAME
616             }
617         )
618 
619     def prepare_checkers(self) -> list[BaseChecker]:
620         """Return checkers needed for activated messages and reports."""
621         if not self.config.reports:
622             self.disable_reporters()
623         # get needed checkers
624         needed_checkers: list[BaseChecker] = [self]
625         for checker in self.get_checkers()[1:]:
626             messages = {msg for msg in checker.msgs if self.is_message_enabled(msg)}
627             if messages or any(self.report_is_enabled(r[0]) for r in checker.reports):
628                 needed_checkers.append(checker)
629         return needed_checkers
630 
631     # pylint: disable=unused-argument
632     @staticmethod
633     def should_analyze_file(modname, path, is_argument=False):
634         """Returns whether a module should be checked.
635 
636         This implementation returns True for all python source file, indicating
637         that all files should be linted.
638 
639         Subclasses may override this method to indicate that modules satisfying
640         certain conditions should not be linted.
641 
642         :param str modname: The name of the module to be checked.
643         :param str path: The full path to the source code of the module.
644         :param bool is_argument: Whether the file is an argument to pylint or not.
645                                  Files which respect this property are always
646                                  checked, since the user requested it explicitly.
647         :returns: True if the module should be checked.
648         :rtype: bool
649         """
650         if is_argument:
651             return True
652         return path.endswith(".py")
653 
654     # pylint: enable=unused-argument
655 
656     def initialize(self) -> None:
657         """Initialize linter for linting.
658 
659         This method is called before any linting is done.
660         """
661         # initialize msgs_state now that all messages have been registered into
662         # the store
663         for msg in self.msgs_store.messages:
664             if not msg.may_be_emitted():
665                 self._msgs_state[msg.msgid] = False
666 
667     @staticmethod
668     def _discover_files(files_or_modules: Sequence[str]) -> Iterator[str]:
669         """Discover python modules and packages in subdirectory.
670 
671         Returns iterator of paths to discovered modules and packages.
672         """
673         for something in files_or_modules:
674             if os.path.isdir(something) and not os.path.isfile(
675                 os.path.join(something, "__init__.py")
676             ):
677                 skip_subtrees: list[str] = []
678                 for root, _, files in os.walk(something):
679                     if any(root.startswith(s) for s in skip_subtrees):
680                         # Skip subtree of already discovered package.
681                         continue
682                     if "__init__.py" in files:
683                         skip_subtrees.append(root)
684                         yield root
685                     else:
686                         yield from (
687                             os.path.join(root, file)
688                             for file in files
689                             if file.endswith(".py")
690                         )
691             else:
692                 yield something
693 
694     def check(self, files_or_modules: Sequence[str] | str) -> None:
695         """Main checking entry: check a list of files or modules from their name.
696 
697         files_or_modules is either a string or list of strings presenting modules to check.
698         """
699         self.initialize()
700         if not isinstance(files_or_modules, (list, tuple)):
701             # pylint: disable-next=fixme
702             # TODO: 3.0: Remove deprecated typing and update docstring
703             warnings.warn(
704                 "In pylint 3.0, the checkers check function will only accept sequence of string",
705                 DeprecationWarning,
706             )
707             files_or_modules = (files_or_modules,)  # type: ignore[assignment]
708         if self.config.recursive:
709             files_or_modules = tuple(self._discover_files(files_or_modules))
710         if self.config.from_stdin:
711             if len(files_or_modules) != 1:
712                 raise exceptions.InvalidArgsError(
713                     "Missing filename required for --from-stdin"
714                 )
715 
716             filepath = files_or_modules[0]
717             with fix_import_path(files_or_modules):
718                 self._check_files(
719                     functools.partial(self.get_ast, data=_read_stdin()),
720                     [self._get_file_descr_from_stdin(filepath)],
721                 )
722         elif self.config.jobs == 1:
723             with fix_import_path(files_or_modules):
724                 self._check_files(
725                     self.get_ast, self._iterate_file_descrs(files_or_modules)
726                 )
727         else:
728             check_parallel(
729                 self,
730                 self.config.jobs,
731                 self._iterate_file_descrs(files_or_modules),
732                 files_or_modules,
733             )
734 
735     def check_single_file(self, name: str, filepath: str, modname: str) -> None:
736         warnings.warn(
737             "In pylint 3.0, the checkers check_single_file function will be removed. "
738             "Use check_single_file_item instead.",
739             DeprecationWarning,
740         )
741         self.check_single_file_item(FileItem(name, filepath, modname))
742 
743     def check_single_file_item(self, file: FileItem) -> None:
744         """Check single file item.
745 
746         The arguments are the same that are documented in _check_files
747 
748         initialize() should be called before calling this method
749         """
750         with self._astroid_module_checker() as check_astroid_module:
751             self._check_file(self.get_ast, check_astroid_module, file)
752 
753     def _check_files(
754         self,
755         get_ast,
756         file_descrs: Iterable[FileItem],
757     ) -> None:
758         """Check all files from file_descrs."""
759         with self._astroid_module_checker() as check_astroid_module:
760             for file in file_descrs:
761                 try:
762                     self._check_file(get_ast, check_astroid_module, file)
763                 except Exception as ex:  # pylint: disable=broad-except
764                     template_path = prepare_crash_report(
765                         ex, file.filepath, self.crash_file_path
766                     )
767                     msg = get_fatal_error_message(file.filepath, template_path)
768                     if isinstance(ex, AstroidError):
769                         symbol = "astroid-error"
770                         self.add_message(symbol, args=(file.filepath, msg))
771                     else:
772                         symbol = "fatal"
773                         self.add_message(symbol, args=msg)
774 
775     def _check_file(self, get_ast, check_astroid_module, file: FileItem):
776         """Check a file using the passed utility functions (get_ast and check_astroid_module).
777 
778         :param callable get_ast: callable returning AST from defined file taking the following arguments
779         - filepath: path to the file to check
780         - name: Python module name
781         :param callable check_astroid_module: callable checking an AST taking the following arguments
782         - ast: AST of the module
783         :param FileItem file: data about the file
784         """
785         self.set_current_module(file.name, file.filepath)
786         # get the module representation
787         ast_node = get_ast(file.filepath, file.name)
788         if ast_node is None:
789             return
790 
791         self._ignore_file = False
792 
793         self.file_state = FileState(file.modpath)
794         # fix the current file (if the source file was not available or
795         # if it's actually a c extension)
796         self.current_file = ast_node.file
797         check_astroid_module(ast_node)
798         # warn about spurious inline messages handling
799         spurious_messages = self.file_state.iter_spurious_suppression_messages(
800             self.msgs_store
801         )
802         for msgid, line, args in spurious_messages:
803             self.add_message(msgid, line, None, args)
804 
805     @staticmethod
806     def _get_file_descr_from_stdin(filepath: str) -> FileItem:
807         """Return file description (tuple of module name, file path, base name) from given file path.
808 
809         This method is used for creating suitable file description for _check_files when the
810         source is standard input.
811         """
812         try:
813             # Note that this function does not really perform an
814             # __import__ but may raise an ImportError exception, which
815             # we want to catch here.
816             modname = ".".join(astroid.modutils.modpath_from_file(filepath))
817         except ImportError:
818             modname = os.path.splitext(os.path.basename(filepath))[0]
819 
820         return FileItem(modname, filepath, filepath)
821 
822     def _iterate_file_descrs(self, files_or_modules) -> Iterator[FileItem]:
823         """Return generator yielding file descriptions (tuples of module name, file path, base name).
824 
825         The returned generator yield one item for each Python module that should be linted.
826         """
827         for descr in self._expand_files(files_or_modules):
828             name, filepath, is_arg = descr["name"], descr["path"], descr["isarg"]
829             if self.should_analyze_file(name, filepath, is_argument=is_arg):
830                 yield FileItem(name, filepath, descr["basename"])
831 
832     def _expand_files(self, modules: list[str]) -> list[ModuleDescriptionDict]:
833         """Get modules and errors from a list of modules and handle errors."""
834         result, errors = expand_modules(
835             modules,
836             self.config.ignore,
837             self.config.ignore_patterns,
838             self._ignore_paths,
839         )
840         for error in errors:
841             message = modname = error["mod"]
842             key = error["key"]
843             self.set_current_module(modname)
844             if key == "fatal":
845                 message = str(error["ex"]).replace(os.getcwd() + os.sep, "")
846             self.add_message(key, args=message)
847         return result
848 
849     def set_current_module(self, modname, filepath: str | None = None):
850         """Set the name of the currently analyzed module and
851         init statistics for it
852         """
853         if not modname and filepath is None:
854             return
855         self.reporter.on_set_current_module(modname, filepath)
856         if modname is None:
857             warnings.warn(
858                 (
859                     "In pylint 3.0 modname should be a string so that it can be used to "
860                     "correctly set the current_name attribute of the linter instance. "
861                     "If unknown it should be initialized as an empty string."
862                 ),
863                 DeprecationWarning,
864             )
865         self.current_name = modname
866         self.current_file = filepath or modname
867         self.stats.init_single_module(modname)
868 
869     @contextlib.contextmanager
870     def _astroid_module_checker(self):
871         """Context manager for checking ASTs.
872 
873         The value in the context is callable accepting AST as its only argument.
874         """
875         walker = ASTWalker(self)
876         _checkers = self.prepare_checkers()
877         with warnings.catch_warnings():
878             warnings.filterwarnings("ignore", category=DeprecationWarning)
879             tokencheckers = [
880                 c
881                 for c in _checkers
882                 if (
883                     interfaces.implements(c, interfaces.ITokenChecker)
884                     or isinstance(c, checkers.BaseTokenChecker)
885                 )
886                 and c is not self
887             ]
888         with warnings.catch_warnings():
889             warnings.filterwarnings("ignore", category=DeprecationWarning)
890             rawcheckers = [
891                 c
892                 for c in _checkers
893                 if interfaces.implements(c, interfaces.IRawChecker)
894                 or isinstance(c, checkers.BaseRawFileChecker)
895             ]
896         # notify global begin
897         for checker in _checkers:
898             checker.open()
899             walker.add_checker(checker)
900 
901         yield functools.partial(
902             self.check_astroid_module,
903             walker=walker,
904             tokencheckers=tokencheckers,
905             rawcheckers=rawcheckers,
906         )
907 
908         # notify global end
909         self.stats.statement = walker.nbstatements
910         for checker in reversed(_checkers):
911             checker.close()
912 
913     def get_ast(
914         self, filepath: str, modname: str, data: str | None = None
915     ) -> nodes.Module:
916         """Return an ast(roid) representation of a module or a string.
917 
918         :param str filepath: path to checked file.
919         :param str modname: The name of the module to be checked.
920         :param str data: optional contents of the checked file.
921         :returns: the AST
922         :rtype: astroid.nodes.Module
923         :raises AstroidBuildingError: Whenever we encounter an unexpected exception
924         """
925         try:
926             if data is None:
927                 return MANAGER.ast_from_file(filepath, modname, source=True)
928             return astroid.builder.AstroidBuilder(MANAGER).string_build(
929                 data, modname, filepath
930             )
931         except astroid.AstroidSyntaxError as ex:
932             # pylint: disable=no-member
933             self.add_message(
934                 "syntax-error",
935                 line=getattr(ex.error, "lineno", 0),
936                 col_offset=getattr(ex.error, "offset", None),
937                 args=str(ex.error),
938             )
939         except astroid.AstroidBuildingError as ex:
940             self.add_message("parse-error", args=ex)
941         except Exception as ex:
942             traceback.print_exc()
943             # We raise BuildingError here as this is essentially an astroid issue
944             # Creating an issue template and adding the 'astroid-error' message is handled
945             # by caller: _check_files
946             raise astroid.AstroidBuildingError(
947                 "Building error when trying to create ast representation of module '{modname}'",
948                 modname=modname,
949             ) from ex
950         return None
951 
952     def check_astroid_module(self, ast_node, walker, rawcheckers, tokencheckers):
953         """Check a module from its astroid representation.
954 
955         For return value see _check_astroid_module
956         """
957         before_check_statements = walker.nbstatements
958 
959         retval = self._check_astroid_module(
960             ast_node, walker, rawcheckers, tokencheckers
961         )
962 
963         self.stats.by_module[self.current_name]["statement"] = (
964             walker.nbstatements - before_check_statements
965         )
966 
967         return retval
968 
969     def _check_astroid_module(
970         self, node: nodes.Module, walker, rawcheckers, tokencheckers
971     ):
972         """Check given AST node with given walker and checkers.
973 
974         :param astroid.nodes.Module node: AST node of the module to check
975         :param pylint.utils.ast_walker.ASTWalker walker: AST walker
976         :param list rawcheckers: List of token checkers to use
977         :param list tokencheckers: List of raw checkers to use
978 
979         :returns: True if the module was checked, False if ignored,
980             None if the module contents could not be parsed
981         :rtype: bool
982         """
983         try:
984             tokens = utils.tokenize_module(node)
985         except tokenize.TokenError as ex:
986             self.add_message("syntax-error", line=ex.args[1][0], args=ex.args[0])
987             return None
988 
989         if not node.pure_python:
990             self.add_message("raw-checker-failed", args=node.name)
991         else:
992             # assert astroid.file.endswith('.py')
993             # invoke ITokenChecker interface on self to fetch module/block
994             # level options
995             self.process_tokens(tokens)
996             if self._ignore_file:
997                 return False
998             # walk ast to collect line numbers
999             self.file_state.collect_block_lines(self.msgs_store, node)
1000             # run raw and tokens checkers
1001             for checker in rawcheckers:
1002                 checker.process_module(node)
1003             for checker in tokencheckers:
1004                 checker.process_tokens(tokens)
1005         # generate events to astroid checkers
1006         walker.walk(node)
1007         return True
1008 
1009     def open(self):
1010         """Initialize counters."""
1011         self.stats = LinterStats()
1012         MANAGER.always_load_extensions = self.config.unsafe_load_any_extension
1013         MANAGER.max_inferable_values = self.config.limit_inference_results
1014         MANAGER.extension_package_whitelist.update(self.config.extension_pkg_allow_list)
1015         if self.config.extension_pkg_whitelist:
1016             MANAGER.extension_package_whitelist.update(
1017                 self.config.extension_pkg_whitelist
1018             )
1019         self.stats.reset_message_count()
1020         self._ignore_paths = self.linter.config.ignore_paths
1021 
1022     def generate_reports(self) -> int | None:
1023         """Close the whole package /module, it's time to make reports !
1024 
1025         if persistent run, pickle results for later comparison
1026         """
1027         # Display whatever messages are left on the reporter.
1028         self.reporter.display_messages(report_nodes.Section())
1029 
1030         if self.file_state.base_name is not None:
1031             # load previous results if any
1032             previous_stats = config.load_results(self.file_state.base_name)
1033             self.reporter.on_close(self.stats, previous_stats)
1034             if self.config.reports:
1035                 sect = self.make_reports(self.stats, previous_stats)
1036             else:
1037                 sect = report_nodes.Section()
1038 
1039             if self.config.reports:
1040                 self.reporter.display_reports(sect)
1041             score_value = self._report_evaluation()
1042             # save results if persistent run
1043             if self.config.persistent:
1044                 config.save_results(self.stats, self.file_state.base_name)
1045         else:
1046             self.reporter.on_close(self.stats, LinterStats())
1047             score_value = None
1048         return score_value
1049 
1050     def _report_evaluation(self) -> int | None:
1051         """Make the global evaluation report."""
1052         # check with at least check 1 statements (usually 0 when there is a
1053         # syntax error preventing pylint from further processing)
1054         note = None
1055         previous_stats = config.load_results(self.file_state.base_name)
1056         if self.stats.statement == 0:
1057             return note
1058 
1059         # get a global note for the code
1060         evaluation = self.config.evaluation
1061         try:
1062             stats_dict = {
1063                 "fatal": self.stats.fatal,
1064                 "error": self.stats.error,
1065                 "warning": self.stats.warning,
1066                 "refactor": self.stats.refactor,
1067                 "convention": self.stats.convention,
1068                 "statement": self.stats.statement,
1069                 "info": self.stats.info,
1070             }
1071             note = eval(evaluation, {}, stats_dict)  # pylint: disable=eval-used
1072         except Exception as ex:  # pylint: disable=broad-except
1073             msg = f"An exception occurred while rating: {ex}"
1074         else:
1075             self.stats.global_note = note
1076             msg = f"Your code has been rated at {note:.2f}/10"
1077             if previous_stats:
1078                 pnote = previous_stats.global_note
1079                 if pnote is not None:
1080                     msg += f" (previous run: {pnote:.2f}/10, {note - pnote:+.2f})"
1081 
1082         if self.config.score:
1083             sect = report_nodes.EvaluationSection(msg)
1084             self.reporter.display_reports(sect)
1085         return note
1086 
1087     # Adding (ignored) messages to the Message Reporter
1088 
1089     def _get_message_state_scope(
1090         self,
1091         msgid: str,
1092         line: int | None = None,
1093         confidence: interfaces.Confidence | None = None,
1094     ) -> Literal[0, 1, 2] | None:
1095         """Returns the scope at which a message was enabled/disabled."""
1096         if confidence is None:
1097             confidence = interfaces.UNDEFINED
1098         if confidence.name not in self.config.confidence:
1099             return MSG_STATE_CONFIDENCE  # type: ignore[return-value] # mypy does not infer Literal correctly
1100         try:
1101             if line in self.file_state._module_msgs_state[msgid]:
1102                 return MSG_STATE_SCOPE_MODULE  # type: ignore[return-value]
1103         except (KeyError, TypeError):
1104             return MSG_STATE_SCOPE_CONFIG  # type: ignore[return-value]
1105         return None
1106 
1107     def _is_one_message_enabled(self, msgid: str, line: int | None) -> bool:
1108         """Checks state of a single message for the current file.
1109 
1110         This function can't be cached as it depends on self.file_state which can
1111         change.
1112         """
1113         if line is None:
1114             return self._msgs_state.get(msgid, True)
1115         try:
1116             return self.file_state._module_msgs_state[msgid][line]
1117         except KeyError:
1118             # Check if the message's line is after the maximum line existing in ast tree.
1119             # This line won't appear in the ast tree and won't be referred in
1120             # self.file_state._module_msgs_state
1121             # This happens for example with a commented line at the end of a module.
1122             max_line_number = self.file_state.get_effective_max_line_number()
1123             if max_line_number and line > max_line_number:
1124                 fallback = True
1125                 lines = self.file_state._raw_module_msgs_state.get(msgid, {})
1126 
1127                 # Doesn't consider scopes, as a 'disable' can be in a
1128                 # different scope than that of the current line.
1129                 closest_lines = reversed(
1130                     [
1131                         (message_line, enable)
1132                         for message_line, enable in lines.items()
1133                         if message_line <= line
1134                     ]
1135                 )
1136                 _, fallback_iter = next(closest_lines, (None, None))
1137                 if fallback_iter is not None:
1138                     fallback = fallback_iter
1139 
1140                 return self._msgs_state.get(msgid, fallback)
1141             return self._msgs_state.get(msgid, True)
1142 
1143     def is_message_enabled(
1144         self,
1145         msg_descr: str,
1146         line: int | None = None,
1147         confidence: interfaces.Confidence | None = None,
1148     ) -> bool:
1149         """Return whether this message is enabled for the current file, line and confidence level.
1150 
1151         This function can't be cached right now as the line is the line of
1152         the currently analysed file (self.file_state), if it changes, then the
1153         result for the same msg_descr/line might need to change.
1154 
1155         :param msg_descr: Either the msgid or the symbol for a MessageDefinition
1156         :param line: The line of the currently analysed file
1157         :param confidence: The confidence of the message
1158         """
1159         if confidence and confidence.name not in self.config.confidence:
1160             return False
1161         try:
1162             msgids = self.msgs_store.message_id_store.get_active_msgids(msg_descr)
1163         except exceptions.UnknownMessageError:
1164             # The linter checks for messages that are not registered
1165             # due to version mismatch, just treat them as message IDs
1166             # for now.
1167             msgids = [msg_descr]
1168         return any(self._is_one_message_enabled(msgid, line) for msgid in msgids)
1169 
1170     def _add_one_message(
1171         self,
1172         message_definition: MessageDefinition,
1173         line: int | None,
1174         node: nodes.NodeNG | None,
1175         args: Any | None,
1176         confidence: interfaces.Confidence | None,
1177         col_offset: int | None,
1178         end_lineno: int | None,
1179         end_col_offset: int | None,
1180     ) -> None:
1181         """After various checks have passed a single Message is
1182         passed to the reporter and added to stats
1183         """
1184         message_definition.check_message_definition(line, node)
1185 
1186         # Look up "location" data of node if not yet supplied
1187         if node:
1188             if node.position:
1189                 if not line:
1190                     line = node.position.lineno
1191                 if not col_offset:
1192                     col_offset = node.position.col_offset
1193                 if not end_lineno:
1194                     end_lineno = node.position.end_lineno
1195                 if not end_col_offset:
1196                     end_col_offset = node.position.end_col_offset
1197             else:
1198                 if not line:
1199                     line = node.fromlineno
1200                 if not col_offset:
1201                     col_offset = node.col_offset
1202                 if not end_lineno:
1203                     end_lineno = node.end_lineno
1204                 if not end_col_offset:
1205                     end_col_offset = node.end_col_offset
1206 
1207         # should this message be displayed
1208         if not self.is_message_enabled(message_definition.msgid, line, confidence):
1209             self.file_state.handle_ignored_message(
1210                 self._get_message_state_scope(
1211                     message_definition.msgid, line, confidence
1212                 ),
1213                 message_definition.msgid,
1214                 line,
1215             )
1216             return
1217 
1218         # update stats
1219         msg_cat = MSG_TYPES[message_definition.msgid[0]]
1220         self.msg_status |= MSG_TYPES_STATUS[message_definition.msgid[0]]
1221         self.stats.increase_single_message_count(msg_cat, 1)
1222         self.stats.increase_single_module_message_count(
1223             self.current_name,  # type: ignore[arg-type] # Should be removable after https://github.com/PyCQA/pylint/pull/5580
1224             msg_cat,
1225             1,
1226         )
1227         try:
1228             self.stats.by_msg[message_definition.symbol] += 1
1229         except KeyError:
1230             self.stats.by_msg[message_definition.symbol] = 1
1231         # Interpolate arguments into message string
1232         msg = message_definition.msg
1233         if args is not None:
1234             msg %= args
1235         # get module and object
1236         if node is None:
1237             module, obj = self.current_name, ""
1238             abspath = self.current_file
1239         else:
1240             module, obj = utils.get_module_and_frameid(node)
1241             abspath = node.root().file
1242         if abspath is not None:
1243             path = abspath.replace(self.reporter.path_strip_prefix, "", 1)
1244         else:
1245             path = "configuration"
1246         # add the message
1247         self.reporter.handle_message(
1248             Message(
1249                 message_definition.msgid,
1250                 message_definition.symbol,
1251                 MessageLocationTuple(
1252                     abspath or "",
1253                     path,
1254                     module or "",
1255                     obj,
1256                     line or 1,
1257                     col_offset or 0,
1258                     end_lineno,
1259                     end_col_offset,
1260                 ),
1261                 msg,
1262                 confidence,
1263             )
1264         )
1265 
1266     def add_message(
1267         self,
1268         msgid: str,
1269         line: int | None = None,
1270         node: nodes.NodeNG | None = None,
1271         args: Any | None = None,
1272         confidence: interfaces.Confidence | None = None,
1273         col_offset: int | None = None,
1274         end_lineno: int | None = None,
1275         end_col_offset: int | None = None,
1276     ) -> None:
1277         """Adds a message given by ID or name.
1278 
1279         If provided, the message string is expanded using args.
1280 
1281         AST checkers must provide the node argument (but may optionally
1282         provide line if the line number is different), raw and token checkers
1283         must provide the line argument.
1284         """
1285         if confidence is None:
1286             confidence = interfaces.UNDEFINED
1287         message_definitions = self.msgs_store.get_message_definitions(msgid)
1288         for message_definition in message_definitions:
1289             self._add_one_message(
1290                 message_definition,
1291                 line,
1292                 node,
1293                 args,
1294                 confidence,
1295                 col_offset,
1296                 end_lineno,
1297                 end_col_offset,
1298             )
1299 
1300     def add_ignored_message(
1301         self,
1302         msgid: str,
1303         line: int,
1304         node: nodes.NodeNG | None = None,
1305         confidence: interfaces.Confidence | None = interfaces.UNDEFINED,
1306     ) -> None:
1307         """Prepares a message to be added to the ignored message storage.
1308 
1309         Some checks return early in special cases and never reach add_message(),
1310         even though they would normally issue a message.
1311         This creates false positives for useless-suppression.
1312         This function avoids this by adding those message to the ignored msgs attribute
1313         """
1314         message_definitions = self.msgs_store.get_message_definitions(msgid)
1315         for message_definition in message_definitions:
1316             message_definition.check_message_definition(line, node)
1317             self.file_state.handle_ignored_message(
1318                 self._get_message_state_scope(
1319                     message_definition.msgid, line, confidence
1320                 ),
1321                 message_definition.msgid,
1322                 line,
1323             )
1324 
1325     # Setting the state (disabled/enabled) of messages and registering them
1326 
1327     def _set_one_msg_status(
1328         self, scope: str, msg: MessageDefinition, line: int | None, enable: bool
1329     ) -> None:
1330         """Set the status of an individual message."""
1331         if scope == "module":
1332             assert isinstance(line, int)  # should always be int inside module scope
1333 
1334             self.file_state.set_msg_status(msg, line, enable)
1335             if not enable and msg.symbol != "locally-disabled":
1336                 self.add_message(
1337                     "locally-disabled", line=line, args=(msg.symbol, msg.msgid)
1338                 )
1339         else:
1340             msgs = self._msgs_state
1341             msgs[msg.msgid] = enable
1342 
1343     def _get_messages_to_set(
1344         self, msgid: str, enable: bool, ignore_unknown: bool = False
1345     ) -> list[MessageDefinition]:
1346         """Do some tests and find the actual messages of which the status should be set."""
1347         message_definitions = []
1348         if msgid == "all":
1349             for _msgid in MSG_TYPES:
1350                 message_definitions.extend(
1351                     self._get_messages_to_set(_msgid, enable, ignore_unknown)
1352                 )
1353             return message_definitions
1354 
1355         # msgid is a category?
1356         category_id = msgid.upper()
1357         if category_id not in MSG_TYPES:
1358             category_id_formatted = MSG_TYPES_LONG.get(category_id)
1359         else:
1360             category_id_formatted = category_id
1361         if category_id_formatted is not None:
1362             for _msgid in self.msgs_store._msgs_by_category[category_id_formatted]:
1363                 message_definitions.extend(
1364                     self._get_messages_to_set(_msgid, enable, ignore_unknown)
1365                 )
1366             return message_definitions
1367 
1368         # msgid is a checker name?
1369         if msgid.lower() in self._checkers:
1370             for checker in self._checkers[msgid.lower()]:
1371                 for _msgid in checker.msgs:
1372                     message_definitions.extend(
1373                         self._get_messages_to_set(_msgid, enable, ignore_unknown)
1374                     )
1375             return message_definitions
1376 
1377         # msgid is report id?
1378         if msgid.lower().startswith("rp"):
1379             if enable:
1380                 self.enable_report(msgid)
1381             else:
1382                 self.disable_report(msgid)
1383             return message_definitions
1384 
1385         try:
1386             # msgid is a symbolic or numeric msgid.
1387             message_definitions = self.msgs_store.get_message_definitions(msgid)
1388         except exceptions.UnknownMessageError:
1389             if not ignore_unknown:
1390                 raise
1391         return message_definitions
1392 
1393     def _set_msg_status(
1394         self,
1395         msgid: str,
1396         enable: bool,
1397         scope: str = "package",
1398         line: int | None = None,
1399         ignore_unknown: bool = False,
1400     ) -> None:
1401         """Do some tests and then iterate over message definitions to set state."""
1402         assert scope in {"package", "module"}
1403 
1404         message_definitions = self._get_messages_to_set(msgid, enable, ignore_unknown)
1405 
1406         for message_definition in message_definitions:
1407             self._set_one_msg_status(scope, message_definition, line, enable)
1408 
1409         # sync configuration object
1410         self.config.enable = []
1411         self.config.disable = []
1412         for msgid_or_symbol, is_enabled in self._msgs_state.items():
1413             symbols = [
1414                 m.symbol
1415                 for m in self.msgs_store.get_message_definitions(msgid_or_symbol)
1416             ]
1417             if is_enabled:
1418                 self.config.enable += symbols
1419             else:
1420                 self.config.disable += symbols
1421 
1422     def _register_by_id_managed_msg(
1423         self, msgid_or_symbol: str, line: int | None, is_disabled: bool = True
1424     ) -> None:
1425         """If the msgid is a numeric one, then register it to inform the user
1426         it could furnish instead a symbolic msgid.
1427         """
1428         if msgid_or_symbol[1:].isdigit():
1429             try:
1430                 symbol = self.msgs_store.message_id_store.get_symbol(
1431                     msgid=msgid_or_symbol
1432                 )
1433             except exceptions.UnknownMessageError:
1434                 return
1435             managed = ManagedMessage(
1436                 self.current_name, msgid_or_symbol, symbol, line, is_disabled
1437             )
1438             self._by_id_managed_msgs.append(managed)
1439 
1440     def disable(
1441         self,
1442         msgid: str,
1443         scope: str = "package",
1444         line: int | None = None,
1445         ignore_unknown: bool = False,
1446     ) -> None:
1447         """Disable a message for a scope."""
1448         self._set_msg_status(
1449             msgid, enable=False, scope=scope, line=line, ignore_unknown=ignore_unknown
1450         )
1451         self._register_by_id_managed_msg(msgid, line)
1452 
1453     def disable_next(
1454         self,
1455         msgid: str,
1456         scope: str = "package",
1457         line: int | None = None,
1458         ignore_unknown: bool = False,
1459     ) -> None:
1460         """Disable a message for the next line."""
1461         if not line:
1462             raise exceptions.NoLineSuppliedError
1463         self._set_msg_status(
1464             msgid,
1465             enable=False,
1466             scope=scope,
1467             line=line + 1,
1468             ignore_unknown=ignore_unknown,
1469         )
1470         self._register_by_id_managed_msg(msgid, line + 1)
1471 
1472     def enable(
1473         self,
1474         msgid: str,
1475         scope: str = "package",
1476         line: int | None = None,
1477         ignore_unknown: bool = False,
1478     ) -> None:
1479         """Enable a message for a scope."""
1480         self._set_msg_status(
1481             msgid, enable=True, scope=scope, line=line, ignore_unknown=ignore_unknown
1482         )
1483         self._register_by_id_managed_msg(msgid, line, is_disabled=False)

</code><intended_behavior>In addition to the current functionality, these methods should be enhanced to support `isinstance` checks using `ABCMeta` for categorizing checkers and reporters. This means that when checkers or reporters are registered, the PyLinter should be able to recognize them based on whether they are instances of a specific abstract base class (or classes), without solely relying on the `__implements__` attribute. This requires defining new abstract base classes for checkers and reporters (if not already defined) using `ABCMeta` and adjusting these methods to recognize checkers and reporters based on these new abstract classes. This modification should preserve backward compatibility by still supporting the `__implements__` attribute during a transition period.</intended_behavior>, <file>pylint/interfaces.py</file>
<class>None</class>
<method>None</method>
<code>
1 # Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
2 # For details: https://github.com/PyCQA/pylint/blob/main/LICENSE
3 # Copyright (c) https://github.com/PyCQA/pylint/blob/main/CONTRIBUTORS.txt
4 
5 """Interfaces for Pylint objects."""
6 
7 from __future__ import annotations
8 
9 import warnings
10 from collections import namedtuple
11 from tokenize import TokenInfo
12 from typing import TYPE_CHECKING
13 
14 from astroid import nodes
15 
16 if TYPE_CHECKING:
17     from pylint.checkers import BaseChecker
18     from pylint.reporters.ureports.nodes import Section
19 
20 __all__ = (
21     "IRawChecker",
22     "IAstroidChecker",
23     "ITokenChecker",
24     "IReporter",
25     "IChecker",
26     "HIGH",
27     "CONTROL_FLOW",
28     "INFERENCE",
29     "INFERENCE_FAILURE",
30     "UNDEFINED",
31     "CONFIDENCE_LEVELS",
32     "CONFIDENCE_LEVEL_NAMES",
33 )
34 
35 Confidence = namedtuple("Confidence", ["name", "description"])
36 # Warning Certainties
37 HIGH = Confidence("HIGH", "Warning that is not based on inference result.")
38 CONTROL_FLOW = Confidence(
39     "CONTROL_FLOW", "Warning based on assumptions about control flow."
40 )
41 INFERENCE = Confidence("INFERENCE", "Warning based on inference result.")
42 INFERENCE_FAILURE = Confidence(
43     "INFERENCE_FAILURE", "Warning based on inference with failures."
44 )
45 UNDEFINED = Confidence("UNDEFINED", "Warning without any associated confidence level.")
46 
47 CONFIDENCE_LEVELS = [HIGH, CONTROL_FLOW, INFERENCE, INFERENCE_FAILURE, UNDEFINED]
48 CONFIDENCE_LEVEL_NAMES = [i.name for i in CONFIDENCE_LEVELS]
49 
50 
51 class Interface:
52     """Base class for interfaces."""
53 
54     @classmethod
55     def is_implemented_by(cls, instance):
56         with warnings.catch_warnings():
57             warnings.filterwarnings("ignore", category=DeprecationWarning)
58             return implements(instance, cls)
59 
60 
61 def implements(
62     obj: BaseChecker,
63     interface: type[Interface] | tuple[type[Interface], ...],
64 ) -> bool:
65     """Does the given object (maybe an instance or class) implement the interface."""
66     # TODO: 3.0: Remove deprecated function # pylint: disable=fixme
67     warnings.warn(
68         "implements has been deprecated in favour of using basic "
69         "inheritance patterns without using __implements__.",
70         DeprecationWarning,
71     )
72     implements_ = getattr(obj, "__implements__", ())
73     if not isinstance(implements_, (list, tuple)):
74         implements_ = (implements_,)
75     return any(issubclass(i, interface) for i in implements_)
76 
77 
78 class IChecker(Interface):
79     """Base interface, to be used only for sub interfaces definition."""
80 
81     def open(self):
82         """Called before visiting project (i.e. set of modules)."""
83 
84     def close(self):
85         """Called after visiting project (i.e. set of modules)."""
86 
87 
88 class IRawChecker(IChecker):
89     """Interface for checker which need to parse the raw file."""
90 
91     def process_module(self, node: nodes.Module) -> None:
92         """Process a module.
93 
94         The module's content is accessible via ``astroid.stream``
95         """
96 
97 
98 class ITokenChecker(IChecker):
99     """Interface for checkers that need access to the token list."""
100 
101     def process_tokens(self, tokens: list[TokenInfo]) -> None:
102         """Process a module.
103 
104         Tokens is a list of all source code tokens in the file.
105         """
106 
107 
108 class IAstroidChecker(IChecker):
109     """Interface for checker which prefers receive events according to
110     statement type
111     """
112 
113 
114 class IReporter(Interface):
115     """Reporter collect messages and display results encapsulated in a layout."""
116 
117     def handle_message(self, msg) -> None:
118         """Handle the given message object."""
119 
120     def display_reports(self, layout: Section) -> None:
121         """Display results encapsulated in the layout tree."""

</code><intended_behavior>This file should introduce new abstract base classes for the checkers and reporters using `ABCMeta`. Each checker or reporter class should then be updated to inherit from these new abstract base classes instead of or in addition to using the `__implements__` attribute. The "implements" function within interfaces.py could be revised or supplemented with a new mechanism that leverages `isinstance` checks against these new abstract base classes to understand whether a given object conforms to the expected interface.</intended_behavior>]
2025-10-18 16:00:16.119 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-18 16:00:16.119 | INFO     | Search-only: skipping patch selection
2025-10-18 16:00:16.205 | INFO     | Task pylint-dev__pylint-6412 completed successfully.
2025-10-18 16:00:16.206 | INFO     | No patch generated. You can try running ACR again.
