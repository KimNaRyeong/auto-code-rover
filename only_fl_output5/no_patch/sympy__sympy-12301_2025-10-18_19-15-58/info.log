2025-10-18 19:15:58.424 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-18 19:16:04.674 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=304, output_tokens=12, cost=0.003400
2025-10-18 19:16:15.429 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=484, output_tokens=441, cost=0.018070
2025-10-18 19:18:15.601 | INFO     | registered non reproducing test 0
2025-10-18 19:18:27.238 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1198, output_tokens=521, cost=0.027610
2025-10-18 19:18:28.484 | INFO     | registered non reproducing test 1
2025-10-18 19:18:44.539 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1474, output_tokens=753, cost=0.037330
2025-10-18 19:18:45.717 | INFO     | registered non reproducing test 2
2025-10-18 19:18:45.717 | WARNING  | Failed to write a reproducer test; skipping reproducer tracing
2025-10-18 19:18:45.720 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 19:18:51.647 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=611, output_tokens=211, cost=0.012440
2025-10-18 19:18:51.652 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 19:18:56.007 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=565, output_tokens=53, cost=0.007240
2025-10-18 19:18:56.009 | INFO     | Refactored invocation argument parsing gives different result on 'get_code_around_line("sympy/simplify/tests/test_cse.py", 433, 10)': old result is ['sympy/simplify/tests/test_cse.py', '433', '10'], new result  is ['sympy/simplify/tests/test_cse.py', 433, 10]
2025-10-18 19:18:56.010 | DEBUG    | Extracted a valid json.
2025-10-18 19:18:56.010 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_code(\"test_issue_11230\")",
        "get_code_around_line(\"sympy/simplify/tests/test_cse.py\", 433, 10)"
    ],
    "bug_locations": []
}
2025-10-18 19:18:56.047 | INFO     | Refactored invocation argument parsing gives different result on 'get_code_around_line("sympy/simplify/tests/test_cse.py", 433, 10)': old result is ['sympy/simplify/tests/test_cse.py', '433', '10'], new result  is ['sympy/simplify/tests/test_cse.py', 433, 10]
2025-10-18 19:18:56.050 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-18 19:18:56.051 | DEBUG    | <Agent search> Analyzing search results.
2025-10-18 19:19:04.754 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1002, output_tokens=370, cost=0.021120
2025-10-18 19:19:04.764 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 19:19:12.291 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1588, output_tokens=338, cost=0.026020
2025-10-18 19:19:12.297 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 19:19:16.079 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=692, output_tokens=34, cost=0.007940
2025-10-18 19:19:16.081 | DEBUG    | Extracted a valid json.
2025-10-18 19:19:16.081 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_method_in_file(\"is_Mul\", \"test_cse.py\")"
    ],
    "bug_locations": []
}
2025-10-18 19:19:16.084 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-18 19:19:16.085 | DEBUG    | <Agent search> Analyzing search results.
2025-10-18 19:19:26.817 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2068, output_tokens=457, cost=0.034390
2025-10-18 19:19:26.826 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 19:19:32.385 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2741, output_tokens=215, cost=0.033860
2025-10-18 19:19:32.390 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 19:19:35.445 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=569, output_tokens=14, cost=0.006110
2025-10-18 19:19:35.446 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-18 19:19:35.446 | DEBUG    | Trying to convert API calls/bug locations into json. Try 2 of 5.
2025-10-18 19:19:37.965 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=569, output_tokens=14, cost=0.006110
2025-10-18 19:19:37.966 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-18 19:19:37.967 | DEBUG    | Trying to convert API calls/bug locations into json. Try 3 of 5.
2025-10-18 19:19:39.296 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=569, output_tokens=14, cost=0.006110
2025-10-18 19:19:39.297 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-18 19:19:39.297 | DEBUG    | Trying to convert API calls/bug locations into json. Try 4 of 5.
2025-10-18 19:19:42.312 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=569, output_tokens=14, cost=0.006110
2025-10-18 19:19:42.313 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-18 19:19:42.313 | DEBUG    | Trying to convert API calls/bug locations into json. Try 5 of 5.
2025-10-18 19:19:45.630 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=569, output_tokens=14, cost=0.006110
2025-10-18 19:19:45.631 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-18 19:19:45.632 | DEBUG    | Agent proxy return the following json: None
2025-10-18 19:19:45.632 | DEBUG    | Could not extract API calls from agent search response, asking search agent to re-generate response.
2025-10-18 19:19:45.633 | DEBUG    | <Agent search> Downstream could not consume our last response. Will retry.
2025-10-18 19:19:45.633 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 19:19:50.405 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2983, output_tokens=185, cost=0.035380
2025-10-18 19:19:50.410 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 19:19:51.853 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=539, output_tokens=14, cost=0.005810
2025-10-18 19:19:51.854 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-18 19:19:51.854 | DEBUG    | Trying to convert API calls/bug locations into json. Try 2 of 5.
2025-10-18 19:19:53.764 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=539, output_tokens=14, cost=0.005810
2025-10-18 19:19:53.765 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-18 19:19:53.771 | DEBUG    | Trying to convert API calls/bug locations into json. Try 3 of 5.
2025-10-18 19:19:54.913 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=539, output_tokens=14, cost=0.005810
2025-10-18 19:19:54.914 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-18 19:19:54.914 | DEBUG    | Trying to convert API calls/bug locations into json. Try 4 of 5.
2025-10-18 19:19:56.595 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=539, output_tokens=14, cost=0.005810
2025-10-18 19:19:56.596 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-18 19:19:56.596 | DEBUG    | Trying to convert API calls/bug locations into json. Try 5 of 5.
2025-10-18 19:19:59.678 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=539, output_tokens=14, cost=0.005810
2025-10-18 19:19:59.679 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-18 19:19:59.679 | DEBUG    | Agent proxy return the following json: None
2025-10-18 19:19:59.680 | DEBUG    | Could not extract API calls from agent search response, asking search agent to re-generate response.
2025-10-18 19:19:59.680 | DEBUG    | <Agent search> Downstream could not consume our last response. Will retry.
2025-10-18 19:19:59.681 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 19:20:12.782 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=3195, output_tokens=502, cost=0.047010
2025-10-18 19:20:12.792 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 19:20:14.682 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=856, output_tokens=34, cost=0.009580
2025-10-18 19:20:14.683 | DEBUG    | Extracted a valid json.
2025-10-18 19:20:14.683 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_code(\"test_cse\")",
        "search_method(\"test\")"
    ],
    "bug_locations": []
}
2025-10-18 19:20:14.726 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-18 19:20:14.726 | DEBUG    | <Agent search> Analyzing search results.
2025-10-18 19:20:30.018 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=3898, output_tokens=683, cost=0.059470
2025-10-18 19:20:30.029 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 19:20:40.934 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=4797, output_tokens=477, cost=0.062280
2025-10-18 19:20:40.942 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 19:20:43.554 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=831, output_tokens=98, cost=0.011250
2025-10-18 19:20:43.555 | DEBUG    | Extracted a valid json.
2025-10-18 19:20:43.556 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "test_cse.py",
            "class": "",
            "method": "test_issue_11230",
            "intended_behavior": "Ensure that the assertion properly reflects the test's objectives. Adjust the assertion to precisely identify and check for the conditions meant to be tested. Verify test accuracy, adjust for specific scenarios, and ensure environmental setup does not affect outcomes."
        }
    ]
}
2025-10-18 19:20:43.559 | DEBUG    | Failed to retrieve code from all bug locations. Asking search agent to re-generate response.
2025-10-18 19:20:43.560 | DEBUG    | <Agent search> Downstream could not consume our last response. Will retry.
2025-10-18 19:20:43.560 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 19:20:54.958 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=5308, output_tokens=446, cost=0.066460
2025-10-18 19:20:54.966 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 19:20:57.458 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=800, output_tokens=37, cost=0.009110
2025-10-18 19:20:57.460 | DEBUG    | Extracted a valid json.
2025-10-18 19:20:57.460 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_code(\"CSE\")",
        "search_code(\"Common Subexpression Elimination\")"
    ],
    "bug_locations": []
}
2025-10-18 19:20:57.535 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-18 19:20:57.535 | DEBUG    | <Agent search> Analyzing search results.
2025-10-18 19:21:13.327 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=6069, output_tokens=654, cost=0.080310
2025-10-18 19:21:13.333 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 19:21:25.801 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=6939, output_tokens=573, cost=0.086580
2025-10-18 19:21:25.811 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 19:21:31.048 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=927, output_tokens=196, cost=0.015150
2025-10-18 19:21:31.049 | DEBUG    | Extracted a valid json.
2025-10-18 19:21:31.049 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "sympy/simplify/cse_main.py",
            "class": "",
            "method": "",
            "intended_behavior": "to accurately perform common subexpression elimination, ensuring all mathematical expressions are simplified correctly without altering their equivalence. Any fix should ensure that the specific case leading to the test failure is addressed, either by refining how expressions are analyzed and simplified or by fixing a specific logic flaw that fails to handle certain expressions correctly."
        },
        {
            "file": "sympy/simplify/cse_opts.py",
            "class": "",
            "method": "",
            "intended_behavior": "to offer flexible yet consistent optimization strategies that do not compromise the correctness of CSE outcomes. Any adjustments here should preserve existing functionality while ensuring that optimization strategies do not inadvertently lead to simplification errors or inconsistencies, especially in edge cases possibly overlooked."
        }
    ]
}
2025-10-18 19:21:31.054 | DEBUG    | Bug location extracted successfully: [<file>sympy/simplify/cse_main.py</file>
<class>None</class>
<method>None</method>
<code>
1 """ Tools for doing common subexpression elimination.
2 """
3 from __future__ import print_function, division
4 
5 from sympy.core import Basic, Mul, Add, Pow, sympify, Symbol, Tuple, igcd
6 from sympy.core.numbers import Integer
7 from sympy.core.singleton import S
8 from sympy.core.function import _coeff_isneg
9 from sympy.core.exprtools import factor_terms
10 from sympy.core.compatibility import iterable, range, as_int
11 from sympy.utilities.iterables import filter_symbols, \
12     numbered_symbols, sift, topological_sort, ordered, subsets
13 
14 from . import cse_opts
15 
16 # (preprocessor, postprocessor) pairs which are commonly useful. They should
17 # each take a sympy expression and return a possibly transformed expression.
18 # When used in the function ``cse()``, the target expressions will be transformed
19 # by each of the preprocessor functions in order. After the common
20 # subexpressions are eliminated, each resulting expression will have the
21 # postprocessor functions transform them in *reverse* order in order to undo the
22 # transformation if necessary. This allows the algorithm to operate on
23 # a representation of the expressions that allows for more optimization
24 # opportunities.
25 # ``None`` can be used to specify no transformation for either the preprocessor or
26 # postprocessor.
27 
28 
29 basic_optimizations = [(cse_opts.sub_pre, cse_opts.sub_post),
30                        (factor_terms, None)]
31 
32 # sometimes we want the output in a different format; non-trivial
33 # transformations can be put here for users
34 # ===============================================================
35 
36 
37 def reps_toposort(r):
38     """Sort replacements `r` so (k1, v1) appears before (k2, v2)
39     if k2 is in v1's free symbols. This orders items in the
40     way that cse returns its results (hence, in order to use the
41     replacements in a substitution option it would make sense
42     to reverse the order).
43 
44     Examples
45     ========
46 
47     >>> from sympy.simplify.cse_main import reps_toposort
48     >>> from sympy.abc import x, y
49     >>> from sympy import Eq
50     >>> for l, r in reps_toposort([(x, y + 1), (y, 2)]):
51     ...     print(Eq(l, r))
52     ...
53     Eq(y, 2)
54     Eq(x, y + 1)
55 
56     """
57     r = sympify(r)
58     E = []
59     for c1, (k1, v1) in enumerate(r):
60         for c2, (k2, v2) in enumerate(r):
61             if k1 in v2.free_symbols:
62                 E.append((c1, c2))
63     return [r[i] for i in topological_sort((range(len(r)), E))]
64 
65 
66 def cse_separate(r, e):
67     """Move expressions that are in the form (symbol, expr) out of the
68     expressions and sort them into the replacements using the reps_toposort.
69 
70     Examples
71     ========
72 
73     >>> from sympy.simplify.cse_main import cse_separate
74     >>> from sympy.abc import x, y, z
75     >>> from sympy import cos, exp, cse, Eq, symbols
76     >>> x0, x1 = symbols('x:2')
77     >>> eq = (x + 1 + exp((x + 1)/(y + 1)) + cos(y + 1))
78     >>> cse([eq, Eq(x, z + 1), z - 2], postprocess=cse_separate) in [
79     ... [[(x0, y + 1), (x, z + 1), (x1, x + 1)],
80     ...  [x1 + exp(x1/x0) + cos(x0), z - 2]],
81     ... [[(x1, y + 1), (x, z + 1), (x0, x + 1)],
82     ...  [x0 + exp(x0/x1) + cos(x1), z - 2]]]
83     ...
84     True
85     """
86     d = sift(e, lambda w: w.is_Equality and w.lhs.is_Symbol)
87     r = r + [w.args for w in d[True]]
88     e = d[False]
89     return [reps_toposort(r), e]
90 
91 # ====end of cse postprocess idioms===========================
92 
93 
94 def preprocess_for_cse(expr, optimizations):
95     """ Preprocess an expression to optimize for common subexpression
96     elimination.
97 
98     Parameters
99     ----------
100     expr : sympy expression
101         The target expression to optimize.
102     optimizations : list of (callable, callable) pairs
103         The (preprocessor, postprocessor) pairs.
104 
105     Returns
106     -------
107     expr : sympy expression
108         The transformed expression.
109     """
110     for pre, post in optimizations:
111         if pre is not None:
112             expr = pre(expr)
113     return expr
114 
115 
116 def postprocess_for_cse(expr, optimizations):
117     """ Postprocess an expression after common subexpression elimination to
118     return the expression to canonical sympy form.
119 
120     Parameters
121     ----------
122     expr : sympy expression
123         The target expression to transform.
124     optimizations : list of (callable, callable) pairs, optional
125         The (preprocessor, postprocessor) pairs.  The postprocessors will be
126         applied in reversed order to undo the effects of the preprocessors
127         correctly.
128 
129     Returns
130     -------
131     expr : sympy expression
132         The transformed expression.
133     """
134     for pre, post in reversed(optimizations):
135         if post is not None:
136             expr = post(expr)
137     return expr
138 
139 
140 def pairwise_most_common(sets):
141     """Return a list of `(s, L)` tuples where `s` is the largest subset
142     of elements that appear in pairs of sets given by `sets` and `L`
143     is a list of tuples giving the indices of the pairs of sets in
144     which those elements appeared. All `s` will be of the same length.
145 
146     Examples
147     ========
148 
149     >>> from sympy.simplify.cse_main import pairwise_most_common
150     >>> pairwise_most_common((
151     ...     {1,2,3},
152     ...     {1,3,5},
153     ...     {1,2,3,4,5},
154     ...     {1,2,3,6}))
155     [({1, 3, 5}, [(1, 2)]), ({1, 2, 3}, [(0, 2), (0, 3), (2, 3)])]
156     >>>
157     """
158     from sympy.utilities.iterables import subsets
159     from collections import defaultdict
160     most = -1
161     for i, j in subsets(list(range(len(sets))), 2):
162         com = sets[i] & sets[j]
163         if com and len(com) > most:
164             best = defaultdict(list)
165             best_keys = []
166             most = len(com)
167         if len(com) == most:
168             if com not in best_keys:
169                 best_keys.append(com)
170             best[best_keys.index(com)].append((i,j))
171     if most == -1:
172         return []
173     for k in range(len(best)):
174         best_keys[k] = (best_keys[k], best[k])
175     best_keys.sort(key=lambda x: len(x[1]))
176     return best_keys
177 
178 
179 def opt_cse(exprs, order='canonical', verbose=False):
180     """Find optimization opportunities in Adds, Muls, Pows and negative
181     coefficient Muls
182 
183     Parameters
184     ----------
185     exprs : list of sympy expressions
186         The expressions to optimize.
187     order : string, 'none' or 'canonical'
188         The order by which Mul and Add arguments are processed. For large
189         expressions where speed is a concern, use the setting order='none'.
190     verbose : bool
191         Print debug information (default=False)
192 
193     Returns
194     -------
195     opt_subs : dictionary of expression substitutions
196         The expression substitutions which can be useful to optimize CSE.
197 
198     Examples
199     ========
200 
201     >>> from sympy.simplify.cse_main import opt_cse
202     >>> from sympy.abc import x
203     >>> opt_subs = opt_cse([x**-2])
204     >>> print(opt_subs)
205     {x**(-2): 1/(x**2)}
206     """
207     from sympy.matrices.expressions import MatAdd, MatMul, MatPow
208     opt_subs = dict()
209 
210     adds = set()
211     muls = set()
212 
213     seen_subexp = set()
214 
215     def _find_opts(expr):
216 
217         if not isinstance(expr, Basic):
218             return
219 
220         if expr.is_Atom or expr.is_Order:
221             return
222 
223         if iterable(expr):
224             list(map(_find_opts, expr))
225             return
226 
227         if expr in seen_subexp:
228             return expr
229         seen_subexp.add(expr)
230 
231         list(map(_find_opts, expr.args))
232 
233         if _coeff_isneg(expr):
234             neg_expr = -expr
235             if not neg_expr.is_Atom:
236                 opt_subs[expr] = Mul(S.NegativeOne, neg_expr, evaluate=False)
237                 seen_subexp.add(neg_expr)
238                 expr = neg_expr
239 
240         if isinstance(expr, (Mul, MatMul)):
241             muls.add(expr)
242 
243         elif isinstance(expr, (Add, MatAdd)):
244             adds.add(expr)
245 
246         elif isinstance(expr, (Pow, MatPow)):
247             if _coeff_isneg(expr.exp):
248                 opt_subs[expr] = Pow(Pow(expr.base, -expr.exp), S.NegativeOne,
249                                      evaluate=False)
250 
251     for e in exprs:
252         if isinstance(e, Basic):
253             _find_opts(e)
254 
255     ## Process Adds and commutative Muls
256 
257     def _match_common_args(Func, funcs):
258         if order != 'none':
259             funcs = list(ordered(funcs))
260         else:
261             funcs = sorted(funcs, key=lambda x: len(x.args))
262 
263         if Func is Mul:
264             F = Pow
265             meth = 'as_powers_dict'
266             from sympy.core.add import _addsort as inplace_sorter
267         elif Func is Add:
268             F = Mul
269             meth = 'as_coefficients_dict'
270             from sympy.core.mul import _mulsort as inplace_sorter
271         else:
272             assert None  # expected Mul or Add
273 
274         # ----------------- helpers ---------------------------
275         def ufunc(*args):
276             # return a well formed unevaluated function from the args
277             # SHARES Func, inplace_sorter
278             args = list(args)
279             inplace_sorter(args)
280             return Func(*args, evaluate=False)
281 
282         def as_dict(e):
283             # creates a dictionary of the expression using either
284             # as_coefficients_dict or as_powers_dict, depending on Func
285             # SHARES meth
286             d = getattr(e, meth, lambda: {a: S.One for a in e.args})()
287             for k in list(d.keys()):
288                 try:
289                     as_int(d[k])
290                 except ValueError:
291                     d[F(k, d.pop(k))] = S.One
292             return d
293 
294         def from_dict(d):
295             # build expression from dict from
296             # as_coefficients_dict or as_powers_dict
297             # SHARES F
298             return ufunc(*[F(k, v) for k, v in d.items()])
299 
300         def update(k):
301             # updates all of the info associated with k using
302             # the com_dict: func_dicts, func_args, opt_subs
303             # returns True if all values were updated, else None
304             # SHARES com_dict, com_func, func_dicts, func_args,
305             #        opt_subs, funcs, verbose
306             for di in com_dict:
307                 # don't allow a sign to change
308                 if com_dict[di] > func_dicts[k][di]:
309                     return
310             # remove it
311             if Func is Add:
312                 take = min(func_dicts[k][i] for i in com_dict)
313                 com_func_take = Mul(take, from_dict(com_dict), evaluate=False)
314             else:
315                 take = igcd(*[func_dicts[k][i] for i in com_dict])
316                 com_func_take = Pow(from_dict(com_dict), take, evaluate=False)
317             for di in com_dict:
318                 func_dicts[k][di] -= take*com_dict[di]
319             # compute the remaining expression
320             rem = from_dict(func_dicts[k])
321             # reject hollow change, e.g extracting x + 1 from x + 3
322             if Func is Add and rem and rem.is_Integer and 1 in com_dict:
323                 return
324             if verbose:
325                 print('\nfunc %s (%s) \ncontains %s \nas %s \nleaving %s' %
326                     (funcs[k], func_dicts[k], com_func, com_func_take, rem))
327             # recompute the dict since some keys may now
328             # have corresponding values of 0; one could
329             # keep track of which ones went to zero but
330             # this seems cleaner
331             func_dicts[k] = as_dict(rem)
332             # update associated info
333             func_dicts[k][com_func] = take
334             func_args[k] = set(func_dicts[k])
335             # keep the constant separate from the remaining
336             # part of the expression, e.g. 2*(a*b) rather than 2*a*b
337             opt_subs[funcs[k]] = ufunc(rem, com_func_take)
338             # everything was updated
339             return True
340 
341         def get_copy(i):
342             return [func_dicts[i].copy(), func_args[i].copy(), funcs[i], i]
343 
344         def restore(dafi):
345             i = dafi.pop()
346             func_dicts[i], func_args[i], funcs[i] = dafi
347 
348         # ----------------- end helpers -----------------------
349 
350         func_dicts = [as_dict(f) for f in funcs]
351         func_args = [set(d) for d in func_dicts]
352         while True:
353             hit = pairwise_most_common(func_args)
354             if not hit or len(hit[0][0]) <= 1:
355                 break
356             changed = False
357             for com_args, ij in hit:
358                 take = len(com_args)
359                 ALL = list(ordered(com_args))
360                 while take >= 2:
361                     for com_args in subsets(ALL, take):
362                         com_func = Func(*com_args)
363                         com_dict = as_dict(com_func)
364                         for i, j in ij:
365                             dafi = None
366                             if com_func != funcs[i]:
367                                 dafi = get_copy(i)
368                                 ch = update(i)
369                                 if not ch:
370                                     restore(dafi)
371                                     continue
372                             if com_func != funcs[j]:
373                                 dafj = get_copy(j)
374                                 ch = update(j)
375                                 if not ch:
376                                     if dafi is not None:
377                                         restore(dafi)
378                                     restore(dafj)
379                                     continue
380                             changed = True
381                         if changed:
382                             break
383                     else:
384                         take -= 1
385                         continue
386                     break
387                 else:
388                     continue
389                 break
390             if not changed:
391                 break
392 
393     # split muls into commutative
394     commutative_muls = set()
395     for m in muls:
396         c, nc = m.args_cnc(cset=True)
397         if c:
398             c_mul = m.func(*c)
399             if nc:
400                 opt_subs[m] = m.func(c_mul, m.func(*nc), evaluate=False)
401             if len(c) > 1:
402                 commutative_muls.add(c_mul)
403 
404     _match_common_args(Add, adds)
405     _match_common_args(Mul, commutative_muls)
406 
407     return opt_subs
408 
409 
410 def tree_cse(exprs, symbols, opt_subs=None, order='canonical', ignore=()):
411     """Perform raw CSE on expression tree, taking opt_subs into account.
412 
413     Parameters
414     ==========
415 
416     exprs : list of sympy expressions
417         The expressions to reduce.
418     symbols : infinite iterator yielding unique Symbols
419         The symbols used to label the common subexpressions which are pulled
420         out.
421     opt_subs : dictionary of expression substitutions
422         The expressions to be substituted before any CSE action is performed.
423     order : string, 'none' or 'canonical'
424         The order by which Mul and Add arguments are processed. For large
425         expressions where speed is a concern, use the setting order='none'.
426     ignore : iterable of Symbols
427         Substitutions containing any Symbol from ``ignore`` will be ignored.
428     """
429     from sympy.matrices.expressions import MatrixExpr, MatrixSymbol, MatMul, MatAdd
430 
431     if opt_subs is None:
432         opt_subs = dict()
433 
434     ## Find repeated sub-expressions
435 
436     to_eliminate = set()
437 
438     seen_subexp = set()
439 
440     def _find_repeated(expr):
441         if not isinstance(expr, Basic):
442             return
443 
444         if expr.is_Atom or expr.is_Order:
445             return
446 
447         if iterable(expr):
448             args = expr
449 
450         else:
451             if expr in seen_subexp:
452                 for ign in ignore:
453                     if ign in expr.free_symbols:
454                         break
455                 else:
456                     to_eliminate.add(expr)
457                     return
458 
459             seen_subexp.add(expr)
460 
461             if expr in opt_subs:
462                 expr = opt_subs[expr]
463 
464             args = expr.args
465 
466         list(map(_find_repeated, args))
467 
468     for e in exprs:
469         if isinstance(e, Basic):
470             _find_repeated(e)
471 
472     ## Rebuild tree
473 
474     replacements = []
475 
476     subs = dict()
477 
478     def _rebuild(expr):
479         if not isinstance(expr, Basic):
480             return expr
481 
482         if not expr.args:
483             return expr
484 
485         if iterable(expr):
486             new_args = [_rebuild(arg) for arg in expr]
487             return expr.func(*new_args)
488 
489         if expr in subs:
490             return subs[expr]
491 
492         orig_expr = expr
493         if expr in opt_subs:
494             expr = opt_subs[expr]
495 
496         # If enabled, parse Muls and Adds arguments by order to ensure
497         # replacement order independent from hashes
498         if order != 'none':
499             if isinstance(expr, (Mul, MatMul)):
500                 c, nc = expr.args_cnc()
501                 if c == [1]:
502                     args = nc
503                 else:
504                     args = list(ordered(c)) + nc
505             elif isinstance(expr, (Add, MatAdd)):
506                 args = list(ordered(expr.args))
507             else:
508                 args = expr.args
509         else:
510             args = expr.args
511 
512         new_args = list(map(_rebuild, args))
513         if new_args != args:
514             new_expr = expr.func(*new_args)
515         else:
516             new_expr = expr
517 
518         if orig_expr in to_eliminate:
519             try:
520                 sym = next(symbols)
521             except StopIteration:
522                 raise ValueError("Symbols iterator ran out of symbols.")
523 
524             if isinstance(orig_expr, MatrixExpr):
525                 sym = MatrixSymbol(sym.name, orig_expr.rows,
526                     orig_expr.cols)
527 
528             subs[orig_expr] = sym
529             replacements.append((sym, new_expr))
530             return sym
531 
532         else:
533             return new_expr
534 
535     reduced_exprs = []
536     for e in exprs:
537         if isinstance(e, Basic):
538             reduced_e = _rebuild(e)
539         else:
540             reduced_e = e
541         reduced_exprs.append(reduced_e)
542 
543     # don't allow hollow nesting
544     # e.g if p = [b + 2*d + e + f, b + 2*d + f + g, a + c + d + f + g]
545     # and R, C = cse(p) then
546     #     R = [(x0, d + f), (x1, b + d)]
547     #     C = [e + x0 + x1, g + x0 + x1, a + c + d + f + g]
548     # but the args of C[-1] should not be `(a + c, d + f + g)`
549     nested = [[i for i in f.args if isinstance(i, f.func)] for f in exprs]
550     for i in range(len(exprs)):
551         F = reduced_exprs[i].func
552         if not (F is Mul or F is Add):
553             continue
554         nested = [a for a in exprs[i].args if isinstance(a, F)]
555         args = []
556         for a in reduced_exprs[i].args:
557             if isinstance(a, F):
558                 for ai in a.args:
559                     if isinstance(ai, F) and ai not in nested:
560                         args.extend(ai.args)
561                     else:
562                         args.append(ai)
563             else:
564                 args.append(a)
565         reduced_exprs[i] = F(*args)
566 
567     return replacements, reduced_exprs
568 
569 
570 def cse(exprs, symbols=None, optimizations=None, postprocess=None,
571         order='canonical', ignore=()):
572     """ Perform common subexpression elimination on an expression.
573 
574     Parameters
575     ==========
576 
577     exprs : list of sympy expressions, or a single sympy expression
578         The expressions to reduce.
579     symbols : infinite iterator yielding unique Symbols
580         The symbols used to label the common subexpressions which are pulled
581         out. The ``numbered_symbols`` generator is useful. The default is a
582         stream of symbols of the form "x0", "x1", etc. This must be an
583         infinite iterator.
584     optimizations : list of (callable, callable) pairs
585         The (preprocessor, postprocessor) pairs of external optimization
586         functions. Optionally 'basic' can be passed for a set of predefined
587         basic optimizations. Such 'basic' optimizations were used by default
588         in old implementation, however they can be really slow on larger
589         expressions. Now, no pre or post optimizations are made by default.
590     postprocess : a function which accepts the two return values of cse and
591         returns the desired form of output from cse, e.g. if you want the
592         replacements reversed the function might be the following lambda:
593         lambda r, e: return reversed(r), e
594     order : string, 'none' or 'canonical'
595         The order by which Mul and Add arguments are processed. If set to
596         'canonical', arguments will be canonically ordered. If set to 'none',
597         ordering will be faster but dependent on expressions hashes, thus
598         machine dependent and variable. For large expressions where speed is a
599         concern, use the setting order='none'.
600     ignore : iterable of Symbols
601         Substitutions containing any Symbol from ``ignore`` will be ignored.
602 
603     Returns
604     =======
605 
606     replacements : list of (Symbol, expression) pairs
607         All of the common subexpressions that were replaced. Subexpressions
608         earlier in this list might show up in subexpressions later in this
609         list.
610     reduced_exprs : list of sympy expressions
611         The reduced expressions with all of the replacements above.
612 
613     Examples
614     ========
615 
616     >>> from sympy import cse, SparseMatrix
617     >>> from sympy.abc import x, y, z, w
618     >>> cse(((w + x + y + z)*(w + y + z))/(w + x)**3)
619     ([(x0, w + y + z)], [x0*(x + x0)/(w + x)**3])
620 
621     Note that currently, y + z will not get substituted if -y - z is used.
622 
623      >>> cse(((w + x + y + z)*(w - y - z))/(w + x)**3)
624      ([(x0, w + x)], [(w - y - z)*(x0 + y + z)/x0**3])
625 
626     List of expressions with recursive substitutions:
627 
628     >>> m = SparseMatrix([x + y, x + y + z])
629     >>> cse([(x+y)**2, x + y + z, y + z, x + z + y, m])
630     ([(x0, x + y), (x1, x0 + z)], [x0**2, x1, y + z, x1, Matrix([
631     [x0],
632     [x1]])])
633 
634     Note: the type and mutability of input matrices is retained.
635 
636     >>> isinstance(_[1][-1], SparseMatrix)
637     True
638 
639     The user may disallow substitutions containing certain symbols:
640     >>> cse([y**2*(x + 1), 3*y**2*(x + 1)], ignore=(y,))
641     ([(x0, x + 1)], [x0*y**2, 3*x0*y**2])
642 
643     """
644     from sympy.matrices import (MatrixBase, Matrix, ImmutableMatrix,
645                                 SparseMatrix, ImmutableSparseMatrix)
646 
647     # Handle the case if just one expression was passed.
648     if isinstance(exprs, (Basic, MatrixBase)):
649         exprs = [exprs]
650 
651     copy = exprs
652     temp = []
653     for e in exprs:
654         if isinstance(e, (Matrix, ImmutableMatrix)):
655             temp.append(Tuple(*e._mat))
656         elif isinstance(e, (SparseMatrix, ImmutableSparseMatrix)):
657             temp.append(Tuple(*e._smat.items()))
658         else:
659             temp.append(e)
660     exprs = temp
661     del temp
662 
663     if optimizations is None:
664         optimizations = list()
665     elif optimizations == 'basic':
666         optimizations = basic_optimizations
667 
668     # Preprocess the expressions to give us better optimization opportunities.
669     reduced_exprs = [preprocess_for_cse(e, optimizations) for e in exprs]
670 
671     excluded_symbols = set().union(*[expr.atoms(Symbol)
672                                    for expr in reduced_exprs])
673 
674     if symbols is None:
675         symbols = numbered_symbols()
676     else:
677         # In case we get passed an iterable with an __iter__ method instead of
678         # an actual iterator.
679         symbols = iter(symbols)
680 
681     symbols = filter_symbols(symbols, excluded_symbols)
682 
683     # Find other optimization opportunities.
684     opt_subs = opt_cse(reduced_exprs, order)
685 
686     # Main CSE algorithm.
687     replacements, reduced_exprs = tree_cse(reduced_exprs, symbols, opt_subs,
688                                            order, ignore)
689 
690     # Postprocess the expressions to return the expressions to canonical form.
691     exprs = copy
692     for i, (sym, subtree) in enumerate(replacements):
693         subtree = postprocess_for_cse(subtree, optimizations)
694         replacements[i] = (sym, subtree)
695     reduced_exprs = [postprocess_for_cse(e, optimizations)
696                      for e in reduced_exprs]
697 
698     # Get the matrices back
699     for i, e in enumerate(exprs):
700         if isinstance(e, (Matrix, ImmutableMatrix)):
701             reduced_exprs[i] = Matrix(e.rows, e.cols, reduced_exprs[i])
702             if isinstance(e, ImmutableMatrix):
703                 reduced_exprs[i] = reduced_exprs[i].as_immutable()
704         elif isinstance(e, (SparseMatrix, ImmutableSparseMatrix)):
705             m = SparseMatrix(e.rows, e.cols, {})
706             for k, v in reduced_exprs[i]:
707                 m[k] = v
708             if isinstance(e, ImmutableSparseMatrix):
709                 m = m.as_immutable()
710             reduced_exprs[i] = m
711 
712     if postprocess is None:
713         return replacements, reduced_exprs
714 
715     return postprocess(replacements, reduced_exprs)

</code><intended_behavior>to accurately perform common subexpression elimination, ensuring all mathematical expressions are simplified correctly without altering their equivalence. Any fix should ensure that the specific case leading to the test failure is addressed, either by refining how expressions are analyzed and simplified or by fixing a specific logic flaw that fails to handle certain expressions correctly.</intended_behavior>, <file>sympy/simplify/cse_opts.py</file>
<class>None</class>
<method>None</method>
<code>
1 """ Optimizations of the expression tree representation for better CSE
2 opportunities.
3 """
4 from __future__ import print_function, division
5 
6 from sympy.core import Add, Basic, Mul
7 from sympy.core.basic import preorder_traversal
8 from sympy.core.singleton import S
9 from sympy.utilities.iterables import default_sort_key
10 
11 
12 def sub_pre(e):
13     """ Replace y - x with -(x - y) if -1 can be extracted from y - x.
14     """
15     reps = [a for a in e.atoms(Add) if a.could_extract_minus_sign()]
16 
17     # make it canonical
18     reps.sort(key=default_sort_key)
19 
20     e = e.xreplace(dict((a, Mul._from_args([S.NegativeOne, -a])) for a in reps))
21     # repeat again for persisting Adds but mark these with a leading 1, -1
22     # e.g. y - x -> 1*-1*(x - y)
23     if isinstance(e, Basic):
24         negs = {}
25         for a in sorted(e.atoms(Add), key=default_sort_key):
26             if a in reps or a.could_extract_minus_sign():
27                 negs[a] = Mul._from_args([S.One, S.NegativeOne, -a])
28         e = e.xreplace(negs)
29     return e
30 
31 
32 def sub_post(e):
33     """ Replace 1*-1*x with -x.
34     """
35     replacements = []
36     for node in preorder_traversal(e):
37         if isinstance(node, Mul) and \
38             node.args[0] is S.One and node.args[1] is S.NegativeOne:
39             replacements.append((node, -Mul._from_args(node.args[2:])))
40     for node, replacement in replacements:
41         e = e.xreplace({node: replacement})
42 
43     return e

</code><intended_behavior>to offer flexible yet consistent optimization strategies that do not compromise the correctness of CSE outcomes. Any adjustments here should preserve existing functionality while ensuring that optimization strategies do not inadvertently lead to simplification errors or inconsistencies, especially in edge cases possibly overlooked.</intended_behavior>]
2025-10-18 19:21:31.055 | INFO     | Search completed. Bug locations: [<file>sympy/simplify/cse_main.py</file>
<class>None</class>
<method>None</method>
<code>
1 """ Tools for doing common subexpression elimination.
2 """
3 from __future__ import print_function, division
4 
5 from sympy.core import Basic, Mul, Add, Pow, sympify, Symbol, Tuple, igcd
6 from sympy.core.numbers import Integer
7 from sympy.core.singleton import S
8 from sympy.core.function import _coeff_isneg
9 from sympy.core.exprtools import factor_terms
10 from sympy.core.compatibility import iterable, range, as_int
11 from sympy.utilities.iterables import filter_symbols, \
12     numbered_symbols, sift, topological_sort, ordered, subsets
13 
14 from . import cse_opts
15 
16 # (preprocessor, postprocessor) pairs which are commonly useful. They should
17 # each take a sympy expression and return a possibly transformed expression.
18 # When used in the function ``cse()``, the target expressions will be transformed
19 # by each of the preprocessor functions in order. After the common
20 # subexpressions are eliminated, each resulting expression will have the
21 # postprocessor functions transform them in *reverse* order in order to undo the
22 # transformation if necessary. This allows the algorithm to operate on
23 # a representation of the expressions that allows for more optimization
24 # opportunities.
25 # ``None`` can be used to specify no transformation for either the preprocessor or
26 # postprocessor.
27 
28 
29 basic_optimizations = [(cse_opts.sub_pre, cse_opts.sub_post),
30                        (factor_terms, None)]
31 
32 # sometimes we want the output in a different format; non-trivial
33 # transformations can be put here for users
34 # ===============================================================
35 
36 
37 def reps_toposort(r):
38     """Sort replacements `r` so (k1, v1) appears before (k2, v2)
39     if k2 is in v1's free symbols. This orders items in the
40     way that cse returns its results (hence, in order to use the
41     replacements in a substitution option it would make sense
42     to reverse the order).
43 
44     Examples
45     ========
46 
47     >>> from sympy.simplify.cse_main import reps_toposort
48     >>> from sympy.abc import x, y
49     >>> from sympy import Eq
50     >>> for l, r in reps_toposort([(x, y + 1), (y, 2)]):
51     ...     print(Eq(l, r))
52     ...
53     Eq(y, 2)
54     Eq(x, y + 1)
55 
56     """
57     r = sympify(r)
58     E = []
59     for c1, (k1, v1) in enumerate(r):
60         for c2, (k2, v2) in enumerate(r):
61             if k1 in v2.free_symbols:
62                 E.append((c1, c2))
63     return [r[i] for i in topological_sort((range(len(r)), E))]
64 
65 
66 def cse_separate(r, e):
67     """Move expressions that are in the form (symbol, expr) out of the
68     expressions and sort them into the replacements using the reps_toposort.
69 
70     Examples
71     ========
72 
73     >>> from sympy.simplify.cse_main import cse_separate
74     >>> from sympy.abc import x, y, z
75     >>> from sympy import cos, exp, cse, Eq, symbols
76     >>> x0, x1 = symbols('x:2')
77     >>> eq = (x + 1 + exp((x + 1)/(y + 1)) + cos(y + 1))
78     >>> cse([eq, Eq(x, z + 1), z - 2], postprocess=cse_separate) in [
79     ... [[(x0, y + 1), (x, z + 1), (x1, x + 1)],
80     ...  [x1 + exp(x1/x0) + cos(x0), z - 2]],
81     ... [[(x1, y + 1), (x, z + 1), (x0, x + 1)],
82     ...  [x0 + exp(x0/x1) + cos(x1), z - 2]]]
83     ...
84     True
85     """
86     d = sift(e, lambda w: w.is_Equality and w.lhs.is_Symbol)
87     r = r + [w.args for w in d[True]]
88     e = d[False]
89     return [reps_toposort(r), e]
90 
91 # ====end of cse postprocess idioms===========================
92 
93 
94 def preprocess_for_cse(expr, optimizations):
95     """ Preprocess an expression to optimize for common subexpression
96     elimination.
97 
98     Parameters
99     ----------
100     expr : sympy expression
101         The target expression to optimize.
102     optimizations : list of (callable, callable) pairs
103         The (preprocessor, postprocessor) pairs.
104 
105     Returns
106     -------
107     expr : sympy expression
108         The transformed expression.
109     """
110     for pre, post in optimizations:
111         if pre is not None:
112             expr = pre(expr)
113     return expr
114 
115 
116 def postprocess_for_cse(expr, optimizations):
117     """ Postprocess an expression after common subexpression elimination to
118     return the expression to canonical sympy form.
119 
120     Parameters
121     ----------
122     expr : sympy expression
123         The target expression to transform.
124     optimizations : list of (callable, callable) pairs, optional
125         The (preprocessor, postprocessor) pairs.  The postprocessors will be
126         applied in reversed order to undo the effects of the preprocessors
127         correctly.
128 
129     Returns
130     -------
131     expr : sympy expression
132         The transformed expression.
133     """
134     for pre, post in reversed(optimizations):
135         if post is not None:
136             expr = post(expr)
137     return expr
138 
139 
140 def pairwise_most_common(sets):
141     """Return a list of `(s, L)` tuples where `s` is the largest subset
142     of elements that appear in pairs of sets given by `sets` and `L`
143     is a list of tuples giving the indices of the pairs of sets in
144     which those elements appeared. All `s` will be of the same length.
145 
146     Examples
147     ========
148 
149     >>> from sympy.simplify.cse_main import pairwise_most_common
150     >>> pairwise_most_common((
151     ...     {1,2,3},
152     ...     {1,3,5},
153     ...     {1,2,3,4,5},
154     ...     {1,2,3,6}))
155     [({1, 3, 5}, [(1, 2)]), ({1, 2, 3}, [(0, 2), (0, 3), (2, 3)])]
156     >>>
157     """
158     from sympy.utilities.iterables import subsets
159     from collections import defaultdict
160     most = -1
161     for i, j in subsets(list(range(len(sets))), 2):
162         com = sets[i] & sets[j]
163         if com and len(com) > most:
164             best = defaultdict(list)
165             best_keys = []
166             most = len(com)
167         if len(com) == most:
168             if com not in best_keys:
169                 best_keys.append(com)
170             best[best_keys.index(com)].append((i,j))
171     if most == -1:
172         return []
173     for k in range(len(best)):
174         best_keys[k] = (best_keys[k], best[k])
175     best_keys.sort(key=lambda x: len(x[1]))
176     return best_keys
177 
178 
179 def opt_cse(exprs, order='canonical', verbose=False):
180     """Find optimization opportunities in Adds, Muls, Pows and negative
181     coefficient Muls
182 
183     Parameters
184     ----------
185     exprs : list of sympy expressions
186         The expressions to optimize.
187     order : string, 'none' or 'canonical'
188         The order by which Mul and Add arguments are processed. For large
189         expressions where speed is a concern, use the setting order='none'.
190     verbose : bool
191         Print debug information (default=False)
192 
193     Returns
194     -------
195     opt_subs : dictionary of expression substitutions
196         The expression substitutions which can be useful to optimize CSE.
197 
198     Examples
199     ========
200 
201     >>> from sympy.simplify.cse_main import opt_cse
202     >>> from sympy.abc import x
203     >>> opt_subs = opt_cse([x**-2])
204     >>> print(opt_subs)
205     {x**(-2): 1/(x**2)}
206     """
207     from sympy.matrices.expressions import MatAdd, MatMul, MatPow
208     opt_subs = dict()
209 
210     adds = set()
211     muls = set()
212 
213     seen_subexp = set()
214 
215     def _find_opts(expr):
216 
217         if not isinstance(expr, Basic):
218             return
219 
220         if expr.is_Atom or expr.is_Order:
221             return
222 
223         if iterable(expr):
224             list(map(_find_opts, expr))
225             return
226 
227         if expr in seen_subexp:
228             return expr
229         seen_subexp.add(expr)
230 
231         list(map(_find_opts, expr.args))
232 
233         if _coeff_isneg(expr):
234             neg_expr = -expr
235             if not neg_expr.is_Atom:
236                 opt_subs[expr] = Mul(S.NegativeOne, neg_expr, evaluate=False)
237                 seen_subexp.add(neg_expr)
238                 expr = neg_expr
239 
240         if isinstance(expr, (Mul, MatMul)):
241             muls.add(expr)
242 
243         elif isinstance(expr, (Add, MatAdd)):
244             adds.add(expr)
245 
246         elif isinstance(expr, (Pow, MatPow)):
247             if _coeff_isneg(expr.exp):
248                 opt_subs[expr] = Pow(Pow(expr.base, -expr.exp), S.NegativeOne,
249                                      evaluate=False)
250 
251     for e in exprs:
252         if isinstance(e, Basic):
253             _find_opts(e)
254 
255     ## Process Adds and commutative Muls
256 
257     def _match_common_args(Func, funcs):
258         if order != 'none':
259             funcs = list(ordered(funcs))
260         else:
261             funcs = sorted(funcs, key=lambda x: len(x.args))
262 
263         if Func is Mul:
264             F = Pow
265             meth = 'as_powers_dict'
266             from sympy.core.add import _addsort as inplace_sorter
267         elif Func is Add:
268             F = Mul
269             meth = 'as_coefficients_dict'
270             from sympy.core.mul import _mulsort as inplace_sorter
271         else:
272             assert None  # expected Mul or Add
273 
274         # ----------------- helpers ---------------------------
275         def ufunc(*args):
276             # return a well formed unevaluated function from the args
277             # SHARES Func, inplace_sorter
278             args = list(args)
279             inplace_sorter(args)
280             return Func(*args, evaluate=False)
281 
282         def as_dict(e):
283             # creates a dictionary of the expression using either
284             # as_coefficients_dict or as_powers_dict, depending on Func
285             # SHARES meth
286             d = getattr(e, meth, lambda: {a: S.One for a in e.args})()
287             for k in list(d.keys()):
288                 try:
289                     as_int(d[k])
290                 except ValueError:
291                     d[F(k, d.pop(k))] = S.One
292             return d
293 
294         def from_dict(d):
295             # build expression from dict from
296             # as_coefficients_dict or as_powers_dict
297             # SHARES F
298             return ufunc(*[F(k, v) for k, v in d.items()])
299 
300         def update(k):
301             # updates all of the info associated with k using
302             # the com_dict: func_dicts, func_args, opt_subs
303             # returns True if all values were updated, else None
304             # SHARES com_dict, com_func, func_dicts, func_args,
305             #        opt_subs, funcs, verbose
306             for di in com_dict:
307                 # don't allow a sign to change
308                 if com_dict[di] > func_dicts[k][di]:
309                     return
310             # remove it
311             if Func is Add:
312                 take = min(func_dicts[k][i] for i in com_dict)
313                 com_func_take = Mul(take, from_dict(com_dict), evaluate=False)
314             else:
315                 take = igcd(*[func_dicts[k][i] for i in com_dict])
316                 com_func_take = Pow(from_dict(com_dict), take, evaluate=False)
317             for di in com_dict:
318                 func_dicts[k][di] -= take*com_dict[di]
319             # compute the remaining expression
320             rem = from_dict(func_dicts[k])
321             # reject hollow change, e.g extracting x + 1 from x + 3
322             if Func is Add and rem and rem.is_Integer and 1 in com_dict:
323                 return
324             if verbose:
325                 print('\nfunc %s (%s) \ncontains %s \nas %s \nleaving %s' %
326                     (funcs[k], func_dicts[k], com_func, com_func_take, rem))
327             # recompute the dict since some keys may now
328             # have corresponding values of 0; one could
329             # keep track of which ones went to zero but
330             # this seems cleaner
331             func_dicts[k] = as_dict(rem)
332             # update associated info
333             func_dicts[k][com_func] = take
334             func_args[k] = set(func_dicts[k])
335             # keep the constant separate from the remaining
336             # part of the expression, e.g. 2*(a*b) rather than 2*a*b
337             opt_subs[funcs[k]] = ufunc(rem, com_func_take)
338             # everything was updated
339             return True
340 
341         def get_copy(i):
342             return [func_dicts[i].copy(), func_args[i].copy(), funcs[i], i]
343 
344         def restore(dafi):
345             i = dafi.pop()
346             func_dicts[i], func_args[i], funcs[i] = dafi
347 
348         # ----------------- end helpers -----------------------
349 
350         func_dicts = [as_dict(f) for f in funcs]
351         func_args = [set(d) for d in func_dicts]
352         while True:
353             hit = pairwise_most_common(func_args)
354             if not hit or len(hit[0][0]) <= 1:
355                 break
356             changed = False
357             for com_args, ij in hit:
358                 take = len(com_args)
359                 ALL = list(ordered(com_args))
360                 while take >= 2:
361                     for com_args in subsets(ALL, take):
362                         com_func = Func(*com_args)
363                         com_dict = as_dict(com_func)
364                         for i, j in ij:
365                             dafi = None
366                             if com_func != funcs[i]:
367                                 dafi = get_copy(i)
368                                 ch = update(i)
369                                 if not ch:
370                                     restore(dafi)
371                                     continue
372                             if com_func != funcs[j]:
373                                 dafj = get_copy(j)
374                                 ch = update(j)
375                                 if not ch:
376                                     if dafi is not None:
377                                         restore(dafi)
378                                     restore(dafj)
379                                     continue
380                             changed = True
381                         if changed:
382                             break
383                     else:
384                         take -= 1
385                         continue
386                     break
387                 else:
388                     continue
389                 break
390             if not changed:
391                 break
392 
393     # split muls into commutative
394     commutative_muls = set()
395     for m in muls:
396         c, nc = m.args_cnc(cset=True)
397         if c:
398             c_mul = m.func(*c)
399             if nc:
400                 opt_subs[m] = m.func(c_mul, m.func(*nc), evaluate=False)
401             if len(c) > 1:
402                 commutative_muls.add(c_mul)
403 
404     _match_common_args(Add, adds)
405     _match_common_args(Mul, commutative_muls)
406 
407     return opt_subs
408 
409 
410 def tree_cse(exprs, symbols, opt_subs=None, order='canonical', ignore=()):
411     """Perform raw CSE on expression tree, taking opt_subs into account.
412 
413     Parameters
414     ==========
415 
416     exprs : list of sympy expressions
417         The expressions to reduce.
418     symbols : infinite iterator yielding unique Symbols
419         The symbols used to label the common subexpressions which are pulled
420         out.
421     opt_subs : dictionary of expression substitutions
422         The expressions to be substituted before any CSE action is performed.
423     order : string, 'none' or 'canonical'
424         The order by which Mul and Add arguments are processed. For large
425         expressions where speed is a concern, use the setting order='none'.
426     ignore : iterable of Symbols
427         Substitutions containing any Symbol from ``ignore`` will be ignored.
428     """
429     from sympy.matrices.expressions import MatrixExpr, MatrixSymbol, MatMul, MatAdd
430 
431     if opt_subs is None:
432         opt_subs = dict()
433 
434     ## Find repeated sub-expressions
435 
436     to_eliminate = set()
437 
438     seen_subexp = set()
439 
440     def _find_repeated(expr):
441         if not isinstance(expr, Basic):
442             return
443 
444         if expr.is_Atom or expr.is_Order:
445             return
446 
447         if iterable(expr):
448             args = expr
449 
450         else:
451             if expr in seen_subexp:
452                 for ign in ignore:
453                     if ign in expr.free_symbols:
454                         break
455                 else:
456                     to_eliminate.add(expr)
457                     return
458 
459             seen_subexp.add(expr)
460 
461             if expr in opt_subs:
462                 expr = opt_subs[expr]
463 
464             args = expr.args
465 
466         list(map(_find_repeated, args))
467 
468     for e in exprs:
469         if isinstance(e, Basic):
470             _find_repeated(e)
471 
472     ## Rebuild tree
473 
474     replacements = []
475 
476     subs = dict()
477 
478     def _rebuild(expr):
479         if not isinstance(expr, Basic):
480             return expr
481 
482         if not expr.args:
483             return expr
484 
485         if iterable(expr):
486             new_args = [_rebuild(arg) for arg in expr]
487             return expr.func(*new_args)
488 
489         if expr in subs:
490             return subs[expr]
491 
492         orig_expr = expr
493         if expr in opt_subs:
494             expr = opt_subs[expr]
495 
496         # If enabled, parse Muls and Adds arguments by order to ensure
497         # replacement order independent from hashes
498         if order != 'none':
499             if isinstance(expr, (Mul, MatMul)):
500                 c, nc = expr.args_cnc()
501                 if c == [1]:
502                     args = nc
503                 else:
504                     args = list(ordered(c)) + nc
505             elif isinstance(expr, (Add, MatAdd)):
506                 args = list(ordered(expr.args))
507             else:
508                 args = expr.args
509         else:
510             args = expr.args
511 
512         new_args = list(map(_rebuild, args))
513         if new_args != args:
514             new_expr = expr.func(*new_args)
515         else:
516             new_expr = expr
517 
518         if orig_expr in to_eliminate:
519             try:
520                 sym = next(symbols)
521             except StopIteration:
522                 raise ValueError("Symbols iterator ran out of symbols.")
523 
524             if isinstance(orig_expr, MatrixExpr):
525                 sym = MatrixSymbol(sym.name, orig_expr.rows,
526                     orig_expr.cols)
527 
528             subs[orig_expr] = sym
529             replacements.append((sym, new_expr))
530             return sym
531 
532         else:
533             return new_expr
534 
535     reduced_exprs = []
536     for e in exprs:
537         if isinstance(e, Basic):
538             reduced_e = _rebuild(e)
539         else:
540             reduced_e = e
541         reduced_exprs.append(reduced_e)
542 
543     # don't allow hollow nesting
544     # e.g if p = [b + 2*d + e + f, b + 2*d + f + g, a + c + d + f + g]
545     # and R, C = cse(p) then
546     #     R = [(x0, d + f), (x1, b + d)]
547     #     C = [e + x0 + x1, g + x0 + x1, a + c + d + f + g]
548     # but the args of C[-1] should not be `(a + c, d + f + g)`
549     nested = [[i for i in f.args if isinstance(i, f.func)] for f in exprs]
550     for i in range(len(exprs)):
551         F = reduced_exprs[i].func
552         if not (F is Mul or F is Add):
553             continue
554         nested = [a for a in exprs[i].args if isinstance(a, F)]
555         args = []
556         for a in reduced_exprs[i].args:
557             if isinstance(a, F):
558                 for ai in a.args:
559                     if isinstance(ai, F) and ai not in nested:
560                         args.extend(ai.args)
561                     else:
562                         args.append(ai)
563             else:
564                 args.append(a)
565         reduced_exprs[i] = F(*args)
566 
567     return replacements, reduced_exprs
568 
569 
570 def cse(exprs, symbols=None, optimizations=None, postprocess=None,
571         order='canonical', ignore=()):
572     """ Perform common subexpression elimination on an expression.
573 
574     Parameters
575     ==========
576 
577     exprs : list of sympy expressions, or a single sympy expression
578         The expressions to reduce.
579     symbols : infinite iterator yielding unique Symbols
580         The symbols used to label the common subexpressions which are pulled
581         out. The ``numbered_symbols`` generator is useful. The default is a
582         stream of symbols of the form "x0", "x1", etc. This must be an
583         infinite iterator.
584     optimizations : list of (callable, callable) pairs
585         The (preprocessor, postprocessor) pairs of external optimization
586         functions. Optionally 'basic' can be passed for a set of predefined
587         basic optimizations. Such 'basic' optimizations were used by default
588         in old implementation, however they can be really slow on larger
589         expressions. Now, no pre or post optimizations are made by default.
590     postprocess : a function which accepts the two return values of cse and
591         returns the desired form of output from cse, e.g. if you want the
592         replacements reversed the function might be the following lambda:
593         lambda r, e: return reversed(r), e
594     order : string, 'none' or 'canonical'
595         The order by which Mul and Add arguments are processed. If set to
596         'canonical', arguments will be canonically ordered. If set to 'none',
597         ordering will be faster but dependent on expressions hashes, thus
598         machine dependent and variable. For large expressions where speed is a
599         concern, use the setting order='none'.
600     ignore : iterable of Symbols
601         Substitutions containing any Symbol from ``ignore`` will be ignored.
602 
603     Returns
604     =======
605 
606     replacements : list of (Symbol, expression) pairs
607         All of the common subexpressions that were replaced. Subexpressions
608         earlier in this list might show up in subexpressions later in this
609         list.
610     reduced_exprs : list of sympy expressions
611         The reduced expressions with all of the replacements above.
612 
613     Examples
614     ========
615 
616     >>> from sympy import cse, SparseMatrix
617     >>> from sympy.abc import x, y, z, w
618     >>> cse(((w + x + y + z)*(w + y + z))/(w + x)**3)
619     ([(x0, w + y + z)], [x0*(x + x0)/(w + x)**3])
620 
621     Note that currently, y + z will not get substituted if -y - z is used.
622 
623      >>> cse(((w + x + y + z)*(w - y - z))/(w + x)**3)
624      ([(x0, w + x)], [(w - y - z)*(x0 + y + z)/x0**3])
625 
626     List of expressions with recursive substitutions:
627 
628     >>> m = SparseMatrix([x + y, x + y + z])
629     >>> cse([(x+y)**2, x + y + z, y + z, x + z + y, m])
630     ([(x0, x + y), (x1, x0 + z)], [x0**2, x1, y + z, x1, Matrix([
631     [x0],
632     [x1]])])
633 
634     Note: the type and mutability of input matrices is retained.
635 
636     >>> isinstance(_[1][-1], SparseMatrix)
637     True
638 
639     The user may disallow substitutions containing certain symbols:
640     >>> cse([y**2*(x + 1), 3*y**2*(x + 1)], ignore=(y,))
641     ([(x0, x + 1)], [x0*y**2, 3*x0*y**2])
642 
643     """
644     from sympy.matrices import (MatrixBase, Matrix, ImmutableMatrix,
645                                 SparseMatrix, ImmutableSparseMatrix)
646 
647     # Handle the case if just one expression was passed.
648     if isinstance(exprs, (Basic, MatrixBase)):
649         exprs = [exprs]
650 
651     copy = exprs
652     temp = []
653     for e in exprs:
654         if isinstance(e, (Matrix, ImmutableMatrix)):
655             temp.append(Tuple(*e._mat))
656         elif isinstance(e, (SparseMatrix, ImmutableSparseMatrix)):
657             temp.append(Tuple(*e._smat.items()))
658         else:
659             temp.append(e)
660     exprs = temp
661     del temp
662 
663     if optimizations is None:
664         optimizations = list()
665     elif optimizations == 'basic':
666         optimizations = basic_optimizations
667 
668     # Preprocess the expressions to give us better optimization opportunities.
669     reduced_exprs = [preprocess_for_cse(e, optimizations) for e in exprs]
670 
671     excluded_symbols = set().union(*[expr.atoms(Symbol)
672                                    for expr in reduced_exprs])
673 
674     if symbols is None:
675         symbols = numbered_symbols()
676     else:
677         # In case we get passed an iterable with an __iter__ method instead of
678         # an actual iterator.
679         symbols = iter(symbols)
680 
681     symbols = filter_symbols(symbols, excluded_symbols)
682 
683     # Find other optimization opportunities.
684     opt_subs = opt_cse(reduced_exprs, order)
685 
686     # Main CSE algorithm.
687     replacements, reduced_exprs = tree_cse(reduced_exprs, symbols, opt_subs,
688                                            order, ignore)
689 
690     # Postprocess the expressions to return the expressions to canonical form.
691     exprs = copy
692     for i, (sym, subtree) in enumerate(replacements):
693         subtree = postprocess_for_cse(subtree, optimizations)
694         replacements[i] = (sym, subtree)
695     reduced_exprs = [postprocess_for_cse(e, optimizations)
696                      for e in reduced_exprs]
697 
698     # Get the matrices back
699     for i, e in enumerate(exprs):
700         if isinstance(e, (Matrix, ImmutableMatrix)):
701             reduced_exprs[i] = Matrix(e.rows, e.cols, reduced_exprs[i])
702             if isinstance(e, ImmutableMatrix):
703                 reduced_exprs[i] = reduced_exprs[i].as_immutable()
704         elif isinstance(e, (SparseMatrix, ImmutableSparseMatrix)):
705             m = SparseMatrix(e.rows, e.cols, {})
706             for k, v in reduced_exprs[i]:
707                 m[k] = v
708             if isinstance(e, ImmutableSparseMatrix):
709                 m = m.as_immutable()
710             reduced_exprs[i] = m
711 
712     if postprocess is None:
713         return replacements, reduced_exprs
714 
715     return postprocess(replacements, reduced_exprs)

</code><intended_behavior>to accurately perform common subexpression elimination, ensuring all mathematical expressions are simplified correctly without altering their equivalence. Any fix should ensure that the specific case leading to the test failure is addressed, either by refining how expressions are analyzed and simplified or by fixing a specific logic flaw that fails to handle certain expressions correctly.</intended_behavior>, <file>sympy/simplify/cse_opts.py</file>
<class>None</class>
<method>None</method>
<code>
1 """ Optimizations of the expression tree representation for better CSE
2 opportunities.
3 """
4 from __future__ import print_function, division
5 
6 from sympy.core import Add, Basic, Mul
7 from sympy.core.basic import preorder_traversal
8 from sympy.core.singleton import S
9 from sympy.utilities.iterables import default_sort_key
10 
11 
12 def sub_pre(e):
13     """ Replace y - x with -(x - y) if -1 can be extracted from y - x.
14     """
15     reps = [a for a in e.atoms(Add) if a.could_extract_minus_sign()]
16 
17     # make it canonical
18     reps.sort(key=default_sort_key)
19 
20     e = e.xreplace(dict((a, Mul._from_args([S.NegativeOne, -a])) for a in reps))
21     # repeat again for persisting Adds but mark these with a leading 1, -1
22     # e.g. y - x -> 1*-1*(x - y)
23     if isinstance(e, Basic):
24         negs = {}
25         for a in sorted(e.atoms(Add), key=default_sort_key):
26             if a in reps or a.could_extract_minus_sign():
27                 negs[a] = Mul._from_args([S.One, S.NegativeOne, -a])
28         e = e.xreplace(negs)
29     return e
30 
31 
32 def sub_post(e):
33     """ Replace 1*-1*x with -x.
34     """
35     replacements = []
36     for node in preorder_traversal(e):
37         if isinstance(node, Mul) and \
38             node.args[0] is S.One and node.args[1] is S.NegativeOne:
39             replacements.append((node, -Mul._from_args(node.args[2:])))
40     for node, replacement in replacements:
41         e = e.xreplace({node: replacement})
42 
43     return e

</code><intended_behavior>to offer flexible yet consistent optimization strategies that do not compromise the correctness of CSE outcomes. Any adjustments here should preserve existing functionality while ensuring that optimization strategies do not inadvertently lead to simplification errors or inconsistencies, especially in edge cases possibly overlooked.</intended_behavior>]
2025-10-18 19:21:31.055 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-18 19:21:31.055 | INFO     | Search-only: skipping patch selection
2025-10-18 19:21:31.132 | INFO     | Task sympy__sympy-12301 completed successfully.
2025-10-18 19:21:31.133 | INFO     | No patch generated. You can try running ACR again.
