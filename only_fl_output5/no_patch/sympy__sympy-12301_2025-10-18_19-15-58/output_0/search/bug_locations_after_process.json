[
    {
        "rel_file_path": "sympy/simplify/cse_main.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sympy__sympy/setup_sympy__sympy__1.0/sympy/simplify/cse_main.py",
        "start": 1,
        "end": 715,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\" Tools for doing common subexpression elimination.\n2 \"\"\"\n3 from __future__ import print_function, division\n4 \n5 from sympy.core import Basic, Mul, Add, Pow, sympify, Symbol, Tuple, igcd\n6 from sympy.core.numbers import Integer\n7 from sympy.core.singleton import S\n8 from sympy.core.function import _coeff_isneg\n9 from sympy.core.exprtools import factor_terms\n10 from sympy.core.compatibility import iterable, range, as_int\n11 from sympy.utilities.iterables import filter_symbols, \\\n12     numbered_symbols, sift, topological_sort, ordered, subsets\n13 \n14 from . import cse_opts\n15 \n16 # (preprocessor, postprocessor) pairs which are commonly useful. They should\n17 # each take a sympy expression and return a possibly transformed expression.\n18 # When used in the function ``cse()``, the target expressions will be transformed\n19 # by each of the preprocessor functions in order. After the common\n20 # subexpressions are eliminated, each resulting expression will have the\n21 # postprocessor functions transform them in *reverse* order in order to undo the\n22 # transformation if necessary. This allows the algorithm to operate on\n23 # a representation of the expressions that allows for more optimization\n24 # opportunities.\n25 # ``None`` can be used to specify no transformation for either the preprocessor or\n26 # postprocessor.\n27 \n28 \n29 basic_optimizations = [(cse_opts.sub_pre, cse_opts.sub_post),\n30                        (factor_terms, None)]\n31 \n32 # sometimes we want the output in a different format; non-trivial\n33 # transformations can be put here for users\n34 # ===============================================================\n35 \n36 \n37 def reps_toposort(r):\n38     \"\"\"Sort replacements `r` so (k1, v1) appears before (k2, v2)\n39     if k2 is in v1's free symbols. This orders items in the\n40     way that cse returns its results (hence, in order to use the\n41     replacements in a substitution option it would make sense\n42     to reverse the order).\n43 \n44     Examples\n45     ========\n46 \n47     >>> from sympy.simplify.cse_main import reps_toposort\n48     >>> from sympy.abc import x, y\n49     >>> from sympy import Eq\n50     >>> for l, r in reps_toposort([(x, y + 1), (y, 2)]):\n51     ...     print(Eq(l, r))\n52     ...\n53     Eq(y, 2)\n54     Eq(x, y + 1)\n55 \n56     \"\"\"\n57     r = sympify(r)\n58     E = []\n59     for c1, (k1, v1) in enumerate(r):\n60         for c2, (k2, v2) in enumerate(r):\n61             if k1 in v2.free_symbols:\n62                 E.append((c1, c2))\n63     return [r[i] for i in topological_sort((range(len(r)), E))]\n64 \n65 \n66 def cse_separate(r, e):\n67     \"\"\"Move expressions that are in the form (symbol, expr) out of the\n68     expressions and sort them into the replacements using the reps_toposort.\n69 \n70     Examples\n71     ========\n72 \n73     >>> from sympy.simplify.cse_main import cse_separate\n74     >>> from sympy.abc import x, y, z\n75     >>> from sympy import cos, exp, cse, Eq, symbols\n76     >>> x0, x1 = symbols('x:2')\n77     >>> eq = (x + 1 + exp((x + 1)/(y + 1)) + cos(y + 1))\n78     >>> cse([eq, Eq(x, z + 1), z - 2], postprocess=cse_separate) in [\n79     ... [[(x0, y + 1), (x, z + 1), (x1, x + 1)],\n80     ...  [x1 + exp(x1/x0) + cos(x0), z - 2]],\n81     ... [[(x1, y + 1), (x, z + 1), (x0, x + 1)],\n82     ...  [x0 + exp(x0/x1) + cos(x1), z - 2]]]\n83     ...\n84     True\n85     \"\"\"\n86     d = sift(e, lambda w: w.is_Equality and w.lhs.is_Symbol)\n87     r = r + [w.args for w in d[True]]\n88     e = d[False]\n89     return [reps_toposort(r), e]\n90 \n91 # ====end of cse postprocess idioms===========================\n92 \n93 \n94 def preprocess_for_cse(expr, optimizations):\n95     \"\"\" Preprocess an expression to optimize for common subexpression\n96     elimination.\n97 \n98     Parameters\n99     ----------\n100     expr : sympy expression\n101         The target expression to optimize.\n102     optimizations : list of (callable, callable) pairs\n103         The (preprocessor, postprocessor) pairs.\n104 \n105     Returns\n106     -------\n107     expr : sympy expression\n108         The transformed expression.\n109     \"\"\"\n110     for pre, post in optimizations:\n111         if pre is not None:\n112             expr = pre(expr)\n113     return expr\n114 \n115 \n116 def postprocess_for_cse(expr, optimizations):\n117     \"\"\" Postprocess an expression after common subexpression elimination to\n118     return the expression to canonical sympy form.\n119 \n120     Parameters\n121     ----------\n122     expr : sympy expression\n123         The target expression to transform.\n124     optimizations : list of (callable, callable) pairs, optional\n125         The (preprocessor, postprocessor) pairs.  The postprocessors will be\n126         applied in reversed order to undo the effects of the preprocessors\n127         correctly.\n128 \n129     Returns\n130     -------\n131     expr : sympy expression\n132         The transformed expression.\n133     \"\"\"\n134     for pre, post in reversed(optimizations):\n135         if post is not None:\n136             expr = post(expr)\n137     return expr\n138 \n139 \n140 def pairwise_most_common(sets):\n141     \"\"\"Return a list of `(s, L)` tuples where `s` is the largest subset\n142     of elements that appear in pairs of sets given by `sets` and `L`\n143     is a list of tuples giving the indices of the pairs of sets in\n144     which those elements appeared. All `s` will be of the same length.\n145 \n146     Examples\n147     ========\n148 \n149     >>> from sympy.simplify.cse_main import pairwise_most_common\n150     >>> pairwise_most_common((\n151     ...     {1,2,3},\n152     ...     {1,3,5},\n153     ...     {1,2,3,4,5},\n154     ...     {1,2,3,6}))\n155     [({1, 3, 5}, [(1, 2)]), ({1, 2, 3}, [(0, 2), (0, 3), (2, 3)])]\n156     >>>\n157     \"\"\"\n158     from sympy.utilities.iterables import subsets\n159     from collections import defaultdict\n160     most = -1\n161     for i, j in subsets(list(range(len(sets))), 2):\n162         com = sets[i] & sets[j]\n163         if com and len(com) > most:\n164             best = defaultdict(list)\n165             best_keys = []\n166             most = len(com)\n167         if len(com) == most:\n168             if com not in best_keys:\n169                 best_keys.append(com)\n170             best[best_keys.index(com)].append((i,j))\n171     if most == -1:\n172         return []\n173     for k in range(len(best)):\n174         best_keys[k] = (best_keys[k], best[k])\n175     best_keys.sort(key=lambda x: len(x[1]))\n176     return best_keys\n177 \n178 \n179 def opt_cse(exprs, order='canonical', verbose=False):\n180     \"\"\"Find optimization opportunities in Adds, Muls, Pows and negative\n181     coefficient Muls\n182 \n183     Parameters\n184     ----------\n185     exprs : list of sympy expressions\n186         The expressions to optimize.\n187     order : string, 'none' or 'canonical'\n188         The order by which Mul and Add arguments are processed. For large\n189         expressions where speed is a concern, use the setting order='none'.\n190     verbose : bool\n191         Print debug information (default=False)\n192 \n193     Returns\n194     -------\n195     opt_subs : dictionary of expression substitutions\n196         The expression substitutions which can be useful to optimize CSE.\n197 \n198     Examples\n199     ========\n200 \n201     >>> from sympy.simplify.cse_main import opt_cse\n202     >>> from sympy.abc import x\n203     >>> opt_subs = opt_cse([x**-2])\n204     >>> print(opt_subs)\n205     {x**(-2): 1/(x**2)}\n206     \"\"\"\n207     from sympy.matrices.expressions import MatAdd, MatMul, MatPow\n208     opt_subs = dict()\n209 \n210     adds = set()\n211     muls = set()\n212 \n213     seen_subexp = set()\n214 \n215     def _find_opts(expr):\n216 \n217         if not isinstance(expr, Basic):\n218             return\n219 \n220         if expr.is_Atom or expr.is_Order:\n221             return\n222 \n223         if iterable(expr):\n224             list(map(_find_opts, expr))\n225             return\n226 \n227         if expr in seen_subexp:\n228             return expr\n229         seen_subexp.add(expr)\n230 \n231         list(map(_find_opts, expr.args))\n232 \n233         if _coeff_isneg(expr):\n234             neg_expr = -expr\n235             if not neg_expr.is_Atom:\n236                 opt_subs[expr] = Mul(S.NegativeOne, neg_expr, evaluate=False)\n237                 seen_subexp.add(neg_expr)\n238                 expr = neg_expr\n239 \n240         if isinstance(expr, (Mul, MatMul)):\n241             muls.add(expr)\n242 \n243         elif isinstance(expr, (Add, MatAdd)):\n244             adds.add(expr)\n245 \n246         elif isinstance(expr, (Pow, MatPow)):\n247             if _coeff_isneg(expr.exp):\n248                 opt_subs[expr] = Pow(Pow(expr.base, -expr.exp), S.NegativeOne,\n249                                      evaluate=False)\n250 \n251     for e in exprs:\n252         if isinstance(e, Basic):\n253             _find_opts(e)\n254 \n255     ## Process Adds and commutative Muls\n256 \n257     def _match_common_args(Func, funcs):\n258         if order != 'none':\n259             funcs = list(ordered(funcs))\n260         else:\n261             funcs = sorted(funcs, key=lambda x: len(x.args))\n262 \n263         if Func is Mul:\n264             F = Pow\n265             meth = 'as_powers_dict'\n266             from sympy.core.add import _addsort as inplace_sorter\n267         elif Func is Add:\n268             F = Mul\n269             meth = 'as_coefficients_dict'\n270             from sympy.core.mul import _mulsort as inplace_sorter\n271         else:\n272             assert None  # expected Mul or Add\n273 \n274         # ----------------- helpers ---------------------------\n275         def ufunc(*args):\n276             # return a well formed unevaluated function from the args\n277             # SHARES Func, inplace_sorter\n278             args = list(args)\n279             inplace_sorter(args)\n280             return Func(*args, evaluate=False)\n281 \n282         def as_dict(e):\n283             # creates a dictionary of the expression using either\n284             # as_coefficients_dict or as_powers_dict, depending on Func\n285             # SHARES meth\n286             d = getattr(e, meth, lambda: {a: S.One for a in e.args})()\n287             for k in list(d.keys()):\n288                 try:\n289                     as_int(d[k])\n290                 except ValueError:\n291                     d[F(k, d.pop(k))] = S.One\n292             return d\n293 \n294         def from_dict(d):\n295             # build expression from dict from\n296             # as_coefficients_dict or as_powers_dict\n297             # SHARES F\n298             return ufunc(*[F(k, v) for k, v in d.items()])\n299 \n300         def update(k):\n301             # updates all of the info associated with k using\n302             # the com_dict: func_dicts, func_args, opt_subs\n303             # returns True if all values were updated, else None\n304             # SHARES com_dict, com_func, func_dicts, func_args,\n305             #        opt_subs, funcs, verbose\n306             for di in com_dict:\n307                 # don't allow a sign to change\n308                 if com_dict[di] > func_dicts[k][di]:\n309                     return\n310             # remove it\n311             if Func is Add:\n312                 take = min(func_dicts[k][i] for i in com_dict)\n313                 com_func_take = Mul(take, from_dict(com_dict), evaluate=False)\n314             else:\n315                 take = igcd(*[func_dicts[k][i] for i in com_dict])\n316                 com_func_take = Pow(from_dict(com_dict), take, evaluate=False)\n317             for di in com_dict:\n318                 func_dicts[k][di] -= take*com_dict[di]\n319             # compute the remaining expression\n320             rem = from_dict(func_dicts[k])\n321             # reject hollow change, e.g extracting x + 1 from x + 3\n322             if Func is Add and rem and rem.is_Integer and 1 in com_dict:\n323                 return\n324             if verbose:\n325                 print('\\nfunc %s (%s) \\ncontains %s \\nas %s \\nleaving %s' %\n326                     (funcs[k], func_dicts[k], com_func, com_func_take, rem))\n327             # recompute the dict since some keys may now\n328             # have corresponding values of 0; one could\n329             # keep track of which ones went to zero but\n330             # this seems cleaner\n331             func_dicts[k] = as_dict(rem)\n332             # update associated info\n333             func_dicts[k][com_func] = take\n334             func_args[k] = set(func_dicts[k])\n335             # keep the constant separate from the remaining\n336             # part of the expression, e.g. 2*(a*b) rather than 2*a*b\n337             opt_subs[funcs[k]] = ufunc(rem, com_func_take)\n338             # everything was updated\n339             return True\n340 \n341         def get_copy(i):\n342             return [func_dicts[i].copy(), func_args[i].copy(), funcs[i], i]\n343 \n344         def restore(dafi):\n345             i = dafi.pop()\n346             func_dicts[i], func_args[i], funcs[i] = dafi\n347 \n348         # ----------------- end helpers -----------------------\n349 \n350         func_dicts = [as_dict(f) for f in funcs]\n351         func_args = [set(d) for d in func_dicts]\n352         while True:\n353             hit = pairwise_most_common(func_args)\n354             if not hit or len(hit[0][0]) <= 1:\n355                 break\n356             changed = False\n357             for com_args, ij in hit:\n358                 take = len(com_args)\n359                 ALL = list(ordered(com_args))\n360                 while take >= 2:\n361                     for com_args in subsets(ALL, take):\n362                         com_func = Func(*com_args)\n363                         com_dict = as_dict(com_func)\n364                         for i, j in ij:\n365                             dafi = None\n366                             if com_func != funcs[i]:\n367                                 dafi = get_copy(i)\n368                                 ch = update(i)\n369                                 if not ch:\n370                                     restore(dafi)\n371                                     continue\n372                             if com_func != funcs[j]:\n373                                 dafj = get_copy(j)\n374                                 ch = update(j)\n375                                 if not ch:\n376                                     if dafi is not None:\n377                                         restore(dafi)\n378                                     restore(dafj)\n379                                     continue\n380                             changed = True\n381                         if changed:\n382                             break\n383                     else:\n384                         take -= 1\n385                         continue\n386                     break\n387                 else:\n388                     continue\n389                 break\n390             if not changed:\n391                 break\n392 \n393     # split muls into commutative\n394     commutative_muls = set()\n395     for m in muls:\n396         c, nc = m.args_cnc(cset=True)\n397         if c:\n398             c_mul = m.func(*c)\n399             if nc:\n400                 opt_subs[m] = m.func(c_mul, m.func(*nc), evaluate=False)\n401             if len(c) > 1:\n402                 commutative_muls.add(c_mul)\n403 \n404     _match_common_args(Add, adds)\n405     _match_common_args(Mul, commutative_muls)\n406 \n407     return opt_subs\n408 \n409 \n410 def tree_cse(exprs, symbols, opt_subs=None, order='canonical', ignore=()):\n411     \"\"\"Perform raw CSE on expression tree, taking opt_subs into account.\n412 \n413     Parameters\n414     ==========\n415 \n416     exprs : list of sympy expressions\n417         The expressions to reduce.\n418     symbols : infinite iterator yielding unique Symbols\n419         The symbols used to label the common subexpressions which are pulled\n420         out.\n421     opt_subs : dictionary of expression substitutions\n422         The expressions to be substituted before any CSE action is performed.\n423     order : string, 'none' or 'canonical'\n424         The order by which Mul and Add arguments are processed. For large\n425         expressions where speed is a concern, use the setting order='none'.\n426     ignore : iterable of Symbols\n427         Substitutions containing any Symbol from ``ignore`` will be ignored.\n428     \"\"\"\n429     from sympy.matrices.expressions import MatrixExpr, MatrixSymbol, MatMul, MatAdd\n430 \n431     if opt_subs is None:\n432         opt_subs = dict()\n433 \n434     ## Find repeated sub-expressions\n435 \n436     to_eliminate = set()\n437 \n438     seen_subexp = set()\n439 \n440     def _find_repeated(expr):\n441         if not isinstance(expr, Basic):\n442             return\n443 \n444         if expr.is_Atom or expr.is_Order:\n445             return\n446 \n447         if iterable(expr):\n448             args = expr\n449 \n450         else:\n451             if expr in seen_subexp:\n452                 for ign in ignore:\n453                     if ign in expr.free_symbols:\n454                         break\n455                 else:\n456                     to_eliminate.add(expr)\n457                     return\n458 \n459             seen_subexp.add(expr)\n460 \n461             if expr in opt_subs:\n462                 expr = opt_subs[expr]\n463 \n464             args = expr.args\n465 \n466         list(map(_find_repeated, args))\n467 \n468     for e in exprs:\n469         if isinstance(e, Basic):\n470             _find_repeated(e)\n471 \n472     ## Rebuild tree\n473 \n474     replacements = []\n475 \n476     subs = dict()\n477 \n478     def _rebuild(expr):\n479         if not isinstance(expr, Basic):\n480             return expr\n481 \n482         if not expr.args:\n483             return expr\n484 \n485         if iterable(expr):\n486             new_args = [_rebuild(arg) for arg in expr]\n487             return expr.func(*new_args)\n488 \n489         if expr in subs:\n490             return subs[expr]\n491 \n492         orig_expr = expr\n493         if expr in opt_subs:\n494             expr = opt_subs[expr]\n495 \n496         # If enabled, parse Muls and Adds arguments by order to ensure\n497         # replacement order independent from hashes\n498         if order != 'none':\n499             if isinstance(expr, (Mul, MatMul)):\n500                 c, nc = expr.args_cnc()\n501                 if c == [1]:\n502                     args = nc\n503                 else:\n504                     args = list(ordered(c)) + nc\n505             elif isinstance(expr, (Add, MatAdd)):\n506                 args = list(ordered(expr.args))\n507             else:\n508                 args = expr.args\n509         else:\n510             args = expr.args\n511 \n512         new_args = list(map(_rebuild, args))\n513         if new_args != args:\n514             new_expr = expr.func(*new_args)\n515         else:\n516             new_expr = expr\n517 \n518         if orig_expr in to_eliminate:\n519             try:\n520                 sym = next(symbols)\n521             except StopIteration:\n522                 raise ValueError(\"Symbols iterator ran out of symbols.\")\n523 \n524             if isinstance(orig_expr, MatrixExpr):\n525                 sym = MatrixSymbol(sym.name, orig_expr.rows,\n526                     orig_expr.cols)\n527 \n528             subs[orig_expr] = sym\n529             replacements.append((sym, new_expr))\n530             return sym\n531 \n532         else:\n533             return new_expr\n534 \n535     reduced_exprs = []\n536     for e in exprs:\n537         if isinstance(e, Basic):\n538             reduced_e = _rebuild(e)\n539         else:\n540             reduced_e = e\n541         reduced_exprs.append(reduced_e)\n542 \n543     # don't allow hollow nesting\n544     # e.g if p = [b + 2*d + e + f, b + 2*d + f + g, a + c + d + f + g]\n545     # and R, C = cse(p) then\n546     #     R = [(x0, d + f), (x1, b + d)]\n547     #     C = [e + x0 + x1, g + x0 + x1, a + c + d + f + g]\n548     # but the args of C[-1] should not be `(a + c, d + f + g)`\n549     nested = [[i for i in f.args if isinstance(i, f.func)] for f in exprs]\n550     for i in range(len(exprs)):\n551         F = reduced_exprs[i].func\n552         if not (F is Mul or F is Add):\n553             continue\n554         nested = [a for a in exprs[i].args if isinstance(a, F)]\n555         args = []\n556         for a in reduced_exprs[i].args:\n557             if isinstance(a, F):\n558                 for ai in a.args:\n559                     if isinstance(ai, F) and ai not in nested:\n560                         args.extend(ai.args)\n561                     else:\n562                         args.append(ai)\n563             else:\n564                 args.append(a)\n565         reduced_exprs[i] = F(*args)\n566 \n567     return replacements, reduced_exprs\n568 \n569 \n570 def cse(exprs, symbols=None, optimizations=None, postprocess=None,\n571         order='canonical', ignore=()):\n572     \"\"\" Perform common subexpression elimination on an expression.\n573 \n574     Parameters\n575     ==========\n576 \n577     exprs : list of sympy expressions, or a single sympy expression\n578         The expressions to reduce.\n579     symbols : infinite iterator yielding unique Symbols\n580         The symbols used to label the common subexpressions which are pulled\n581         out. The ``numbered_symbols`` generator is useful. The default is a\n582         stream of symbols of the form \"x0\", \"x1\", etc. This must be an\n583         infinite iterator.\n584     optimizations : list of (callable, callable) pairs\n585         The (preprocessor, postprocessor) pairs of external optimization\n586         functions. Optionally 'basic' can be passed for a set of predefined\n587         basic optimizations. Such 'basic' optimizations were used by default\n588         in old implementation, however they can be really slow on larger\n589         expressions. Now, no pre or post optimizations are made by default.\n590     postprocess : a function which accepts the two return values of cse and\n591         returns the desired form of output from cse, e.g. if you want the\n592         replacements reversed the function might be the following lambda:\n593         lambda r, e: return reversed(r), e\n594     order : string, 'none' or 'canonical'\n595         The order by which Mul and Add arguments are processed. If set to\n596         'canonical', arguments will be canonically ordered. If set to 'none',\n597         ordering will be faster but dependent on expressions hashes, thus\n598         machine dependent and variable. For large expressions where speed is a\n599         concern, use the setting order='none'.\n600     ignore : iterable of Symbols\n601         Substitutions containing any Symbol from ``ignore`` will be ignored.\n602 \n603     Returns\n604     =======\n605 \n606     replacements : list of (Symbol, expression) pairs\n607         All of the common subexpressions that were replaced. Subexpressions\n608         earlier in this list might show up in subexpressions later in this\n609         list.\n610     reduced_exprs : list of sympy expressions\n611         The reduced expressions with all of the replacements above.\n612 \n613     Examples\n614     ========\n615 \n616     >>> from sympy import cse, SparseMatrix\n617     >>> from sympy.abc import x, y, z, w\n618     >>> cse(((w + x + y + z)*(w + y + z))/(w + x)**3)\n619     ([(x0, w + y + z)], [x0*(x + x0)/(w + x)**3])\n620 \n621     Note that currently, y + z will not get substituted if -y - z is used.\n622 \n623      >>> cse(((w + x + y + z)*(w - y - z))/(w + x)**3)\n624      ([(x0, w + x)], [(w - y - z)*(x0 + y + z)/x0**3])\n625 \n626     List of expressions with recursive substitutions:\n627 \n628     >>> m = SparseMatrix([x + y, x + y + z])\n629     >>> cse([(x+y)**2, x + y + z, y + z, x + z + y, m])\n630     ([(x0, x + y), (x1, x0 + z)], [x0**2, x1, y + z, x1, Matrix([\n631     [x0],\n632     [x1]])])\n633 \n634     Note: the type and mutability of input matrices is retained.\n635 \n636     >>> isinstance(_[1][-1], SparseMatrix)\n637     True\n638 \n639     The user may disallow substitutions containing certain symbols:\n640     >>> cse([y**2*(x + 1), 3*y**2*(x + 1)], ignore=(y,))\n641     ([(x0, x + 1)], [x0*y**2, 3*x0*y**2])\n642 \n643     \"\"\"\n644     from sympy.matrices import (MatrixBase, Matrix, ImmutableMatrix,\n645                                 SparseMatrix, ImmutableSparseMatrix)\n646 \n647     # Handle the case if just one expression was passed.\n648     if isinstance(exprs, (Basic, MatrixBase)):\n649         exprs = [exprs]\n650 \n651     copy = exprs\n652     temp = []\n653     for e in exprs:\n654         if isinstance(e, (Matrix, ImmutableMatrix)):\n655             temp.append(Tuple(*e._mat))\n656         elif isinstance(e, (SparseMatrix, ImmutableSparseMatrix)):\n657             temp.append(Tuple(*e._smat.items()))\n658         else:\n659             temp.append(e)\n660     exprs = temp\n661     del temp\n662 \n663     if optimizations is None:\n664         optimizations = list()\n665     elif optimizations == 'basic':\n666         optimizations = basic_optimizations\n667 \n668     # Preprocess the expressions to give us better optimization opportunities.\n669     reduced_exprs = [preprocess_for_cse(e, optimizations) for e in exprs]\n670 \n671     excluded_symbols = set().union(*[expr.atoms(Symbol)\n672                                    for expr in reduced_exprs])\n673 \n674     if symbols is None:\n675         symbols = numbered_symbols()\n676     else:\n677         # In case we get passed an iterable with an __iter__ method instead of\n678         # an actual iterator.\n679         symbols = iter(symbols)\n680 \n681     symbols = filter_symbols(symbols, excluded_symbols)\n682 \n683     # Find other optimization opportunities.\n684     opt_subs = opt_cse(reduced_exprs, order)\n685 \n686     # Main CSE algorithm.\n687     replacements, reduced_exprs = tree_cse(reduced_exprs, symbols, opt_subs,\n688                                            order, ignore)\n689 \n690     # Postprocess the expressions to return the expressions to canonical form.\n691     exprs = copy\n692     for i, (sym, subtree) in enumerate(replacements):\n693         subtree = postprocess_for_cse(subtree, optimizations)\n694         replacements[i] = (sym, subtree)\n695     reduced_exprs = [postprocess_for_cse(e, optimizations)\n696                      for e in reduced_exprs]\n697 \n698     # Get the matrices back\n699     for i, e in enumerate(exprs):\n700         if isinstance(e, (Matrix, ImmutableMatrix)):\n701             reduced_exprs[i] = Matrix(e.rows, e.cols, reduced_exprs[i])\n702             if isinstance(e, ImmutableMatrix):\n703                 reduced_exprs[i] = reduced_exprs[i].as_immutable()\n704         elif isinstance(e, (SparseMatrix, ImmutableSparseMatrix)):\n705             m = SparseMatrix(e.rows, e.cols, {})\n706             for k, v in reduced_exprs[i]:\n707                 m[k] = v\n708             if isinstance(e, ImmutableSparseMatrix):\n709                 m = m.as_immutable()\n710             reduced_exprs[i] = m\n711 \n712     if postprocess is None:\n713         return replacements, reduced_exprs\n714 \n715     return postprocess(replacements, reduced_exprs)\n",
        "intended_behavior": "to accurately perform common subexpression elimination, ensuring all mathematical expressions are simplified correctly without altering their equivalence. Any fix should ensure that the specific case leading to the test failure is addressed, either by refining how expressions are analyzed and simplified or by fixing a specific logic flaw that fails to handle certain expressions correctly."
    },
    {
        "rel_file_path": "sympy/simplify/cse_opts.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sympy__sympy/setup_sympy__sympy__1.0/sympy/simplify/cse_opts.py",
        "start": 1,
        "end": 43,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\" Optimizations of the expression tree representation for better CSE\n2 opportunities.\n3 \"\"\"\n4 from __future__ import print_function, division\n5 \n6 from sympy.core import Add, Basic, Mul\n7 from sympy.core.basic import preorder_traversal\n8 from sympy.core.singleton import S\n9 from sympy.utilities.iterables import default_sort_key\n10 \n11 \n12 def sub_pre(e):\n13     \"\"\" Replace y - x with -(x - y) if -1 can be extracted from y - x.\n14     \"\"\"\n15     reps = [a for a in e.atoms(Add) if a.could_extract_minus_sign()]\n16 \n17     # make it canonical\n18     reps.sort(key=default_sort_key)\n19 \n20     e = e.xreplace(dict((a, Mul._from_args([S.NegativeOne, -a])) for a in reps))\n21     # repeat again for persisting Adds but mark these with a leading 1, -1\n22     # e.g. y - x -> 1*-1*(x - y)\n23     if isinstance(e, Basic):\n24         negs = {}\n25         for a in sorted(e.atoms(Add), key=default_sort_key):\n26             if a in reps or a.could_extract_minus_sign():\n27                 negs[a] = Mul._from_args([S.One, S.NegativeOne, -a])\n28         e = e.xreplace(negs)\n29     return e\n30 \n31 \n32 def sub_post(e):\n33     \"\"\" Replace 1*-1*x with -x.\n34     \"\"\"\n35     replacements = []\n36     for node in preorder_traversal(e):\n37         if isinstance(node, Mul) and \\\n38             node.args[0] is S.One and node.args[1] is S.NegativeOne:\n39             replacements.append((node, -Mul._from_args(node.args[2:])))\n40     for node, replacement in replacements:\n41         e = e.xreplace({node: replacement})\n42 \n43     return e\n",
        "intended_behavior": "to offer flexible yet consistent optimization strategies that do not compromise the correctness of CSE outcomes. Any adjustments here should preserve existing functionality while ensuring that optimization strategies do not inadvertently lead to simplification errors or inconsistencies, especially in edge cases possibly overlooked."
    }
]