[
    {
        "rel_file_path": "src/_pytest/deprecated.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/pytest-dev__pytest/setup_pytest-dev__pytest__7.2/src/_pytest/deprecated.py",
        "start": 1,
        "end": 131,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\"Deprecation messages and bits of code used elsewhere in the codebase that\n2 is planned to be removed in the next pytest release.\n3 \n4 Keeping it in a central location makes it easy to track what is deprecated and should\n5 be removed when the time comes.\n6 \n7 All constants defined in this module should be either instances of\n8 :class:`PytestWarning`, or :class:`UnformattedWarning`\n9 in case of warnings which need to format their messages.\n10 \"\"\"\n11 from warnings import warn\n12 \n13 from _pytest.warning_types import PytestDeprecationWarning\n14 from _pytest.warning_types import PytestRemovedIn8Warning\n15 from _pytest.warning_types import UnformattedWarning\n16 \n17 # set of plugins which have been integrated into the core; we use this list to ignore\n18 # them during registration to avoid conflicts\n19 DEPRECATED_EXTERNAL_PLUGINS = {\n20     \"pytest_catchlog\",\n21     \"pytest_capturelog\",\n22     \"pytest_faulthandler\",\n23 }\n24 \n25 \n26 # This can be* removed pytest 8, but it's harmless and common, so no rush to remove.\n27 # * If you're in the future: \"could have been\".\n28 YIELD_FIXTURE = PytestDeprecationWarning(\n29     \"@pytest.yield_fixture is deprecated.\\n\"\n30     \"Use @pytest.fixture instead; they are the same.\"\n31 )\n32 \n33 WARNING_CMDLINE_PREPARSE_HOOK = PytestRemovedIn8Warning(\n34     \"The pytest_cmdline_preparse hook is deprecated and will be removed in a future release. \\n\"\n35     \"Please use pytest_load_initial_conftests hook instead.\"\n36 )\n37 \n38 FSCOLLECTOR_GETHOOKPROXY_ISINITPATH = PytestRemovedIn8Warning(\n39     \"The gethookproxy() and isinitpath() methods of FSCollector and Package are deprecated; \"\n40     \"use self.session.gethookproxy() and self.session.isinitpath() instead. \"\n41 )\n42 \n43 STRICT_OPTION = PytestRemovedIn8Warning(\n44     \"The --strict option is deprecated, use --strict-markers instead.\"\n45 )\n46 \n47 # This deprecation is never really meant to be removed.\n48 PRIVATE = PytestDeprecationWarning(\"A private pytest class or function was used.\")\n49 \n50 ARGUMENT_PERCENT_DEFAULT = PytestRemovedIn8Warning(\n51     'pytest now uses argparse. \"%default\" should be changed to \"%(default)s\"',\n52 )\n53 \n54 ARGUMENT_TYPE_STR_CHOICE = UnformattedWarning(\n55     PytestRemovedIn8Warning,\n56     \"`type` argument to addoption() is the string {typ!r}.\"\n57     \" For choices this is optional and can be omitted, \"\n58     \" but when supplied should be a type (for example `str` or `int`).\"\n59     \" (options: {names})\",\n60 )\n61 \n62 ARGUMENT_TYPE_STR = UnformattedWarning(\n63     PytestRemovedIn8Warning,\n64     \"`type` argument to addoption() is the string {typ!r}, \"\n65     \" but when supplied should be a type (for example `str` or `int`).\"\n66     \" (options: {names})\",\n67 )\n68 \n69 \n70 HOOK_LEGACY_PATH_ARG = UnformattedWarning(\n71     PytestRemovedIn8Warning,\n72     \"The ({pylib_path_arg}: py.path.local) argument is deprecated, please use ({pathlib_path_arg}: pathlib.Path)\\n\"\n73     \"see https://docs.pytest.org/en/latest/deprecations.html\"\n74     \"#py-path-local-arguments-for-hooks-replaced-with-pathlib-path\",\n75 )\n76 \n77 NODE_CTOR_FSPATH_ARG = UnformattedWarning(\n78     PytestRemovedIn8Warning,\n79     \"The (fspath: py.path.local) argument to {node_type_name} is deprecated. \"\n80     \"Please use the (path: pathlib.Path) argument instead.\\n\"\n81     \"See https://docs.pytest.org/en/latest/deprecations.html\"\n82     \"#fspath-argument-for-node-constructors-replaced-with-pathlib-path\",\n83 )\n84 \n85 WARNS_NONE_ARG = PytestRemovedIn8Warning(\n86     \"Passing None has been deprecated.\\n\"\n87     \"See https://docs.pytest.org/en/latest/how-to/capture-warnings.html\"\n88     \"#additional-use-cases-of-warnings-in-tests\"\n89     \" for alternatives in common use cases.\"\n90 )\n91 \n92 KEYWORD_MSG_ARG = UnformattedWarning(\n93     PytestRemovedIn8Warning,\n94     \"pytest.{func}(msg=...) is now deprecated, use pytest.{func}(reason=...) instead\",\n95 )\n96 \n97 INSTANCE_COLLECTOR = PytestRemovedIn8Warning(\n98     \"The pytest.Instance collector type is deprecated and is no longer used. \"\n99     \"See https://docs.pytest.org/en/latest/deprecations.html#the-pytest-instance-collector\",\n100 )\n101 HOOK_LEGACY_MARKING = UnformattedWarning(\n102     PytestDeprecationWarning,\n103     \"The hook{type} {fullname} uses old-style configuration options (marks or attributes).\\n\"\n104     \"Please use the pytest.hook{type}({hook_opts}) decorator instead\\n\"\n105     \" to configure the hooks.\\n\"\n106     \" See https://docs.pytest.org/en/latest/deprecations.html\"\n107     \"#configuring-hook-specs-impls-using-markers\",\n108 )\n109 \n110 # You want to make some `__init__` or function \"private\".\n111 #\n112 #   def my_private_function(some, args):\n113 #       ...\n114 #\n115 # Do this:\n116 #\n117 #   def my_private_function(some, args, *, _ispytest: bool = False):\n118 #       check_ispytest(_ispytest)\n119 #       ...\n120 #\n121 # Change all internal/allowed calls to\n122 #\n123 #   my_private_function(some, args, _ispytest=True)\n124 #\n125 # All other calls will get the default _ispytest=False and trigger\n126 # the warning (possibly error in the future).\n127 \n128 \n129 def check_ispytest(ispytest: bool) -> None:\n130     if not ispytest:\n131         warn(PRIVATE, stacklevel=3)\n",
        "intended_behavior": "This file likely contains definitions and usages of `PytestDeprecationWarning`. To resolve the issue, when raising a `PytestDeprecationWarning` for old-style `hookimpl`, the code at this location should be extended to include the source (file path and possibly line number) of the deprecated usage. This enhancement should preserve the functionality of emitting warnings but augment them with additional context to help users locate and address the deprecated configurations within their plugins or test suites."
    },
    {
        "rel_file_path": "src/_pytest/logging.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/pytest-dev__pytest/setup_pytest-dev__pytest__7.2/src/_pytest/logging.py",
        "start": 1,
        "end": 830,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\"Access and control log capturing.\"\"\"\n2 import io\n3 import logging\n4 import os\n5 import re\n6 from contextlib import contextmanager\n7 from contextlib import nullcontext\n8 from io import StringIO\n9 from pathlib import Path\n10 from typing import AbstractSet\n11 from typing import Dict\n12 from typing import Generator\n13 from typing import List\n14 from typing import Mapping\n15 from typing import Optional\n16 from typing import Tuple\n17 from typing import TYPE_CHECKING\n18 from typing import TypeVar\n19 from typing import Union\n20 \n21 from _pytest import nodes\n22 from _pytest._io import TerminalWriter\n23 from _pytest.capture import CaptureManager\n24 from _pytest.compat import final\n25 from _pytest.config import _strtobool\n26 from _pytest.config import Config\n27 from _pytest.config import create_terminal_writer\n28 from _pytest.config import hookimpl\n29 from _pytest.config import UsageError\n30 from _pytest.config.argparsing import Parser\n31 from _pytest.deprecated import check_ispytest\n32 from _pytest.fixtures import fixture\n33 from _pytest.fixtures import FixtureRequest\n34 from _pytest.main import Session\n35 from _pytest.stash import StashKey\n36 from _pytest.terminal import TerminalReporter\n37 \n38 if TYPE_CHECKING:\n39     logging_StreamHandler = logging.StreamHandler[StringIO]\n40 \n41     from typing_extensions import Literal\n42 else:\n43     logging_StreamHandler = logging.StreamHandler\n44 \n45 DEFAULT_LOG_FORMAT = \"%(levelname)-8s %(name)s:%(filename)s:%(lineno)d %(message)s\"\n46 DEFAULT_LOG_DATE_FORMAT = \"%H:%M:%S\"\n47 _ANSI_ESCAPE_SEQ = re.compile(r\"\\x1b\\[[\\d;]+m\")\n48 caplog_handler_key = StashKey[\"LogCaptureHandler\"]()\n49 caplog_records_key = StashKey[Dict[str, List[logging.LogRecord]]]()\n50 \n51 \n52 def _remove_ansi_escape_sequences(text: str) -> str:\n53     return _ANSI_ESCAPE_SEQ.sub(\"\", text)\n54 \n55 \n56 class ColoredLevelFormatter(logging.Formatter):\n57     \"\"\"A logging formatter which colorizes the %(levelname)..s part of the\n58     log format passed to __init__.\"\"\"\n59 \n60     LOGLEVEL_COLOROPTS: Mapping[int, AbstractSet[str]] = {\n61         logging.CRITICAL: {\"red\"},\n62         logging.ERROR: {\"red\", \"bold\"},\n63         logging.WARNING: {\"yellow\"},\n64         logging.WARN: {\"yellow\"},\n65         logging.INFO: {\"green\"},\n66         logging.DEBUG: {\"purple\"},\n67         logging.NOTSET: set(),\n68     }\n69     LEVELNAME_FMT_REGEX = re.compile(r\"%\\(levelname\\)([+-.]?\\d*(?:\\.\\d+)?s)\")\n70 \n71     def __init__(self, terminalwriter: TerminalWriter, *args, **kwargs) -> None:\n72         super().__init__(*args, **kwargs)\n73         self._terminalwriter = terminalwriter\n74         self._original_fmt = self._style._fmt\n75         self._level_to_fmt_mapping: Dict[int, str] = {}\n76 \n77         for level, color_opts in self.LOGLEVEL_COLOROPTS.items():\n78             self.add_color_level(level, *color_opts)\n79 \n80     def add_color_level(self, level: int, *color_opts: str) -> None:\n81         \"\"\"Add or update color opts for a log level.\n82 \n83         :param level:\n84             Log level to apply a style to, e.g. ``logging.INFO``.\n85         :param color_opts:\n86             ANSI escape sequence color options. Capitalized colors indicates\n87             background color, i.e. ``'green', 'Yellow', 'bold'`` will give bold\n88             green text on yellow background.\n89 \n90         .. warning::\n91             This is an experimental API.\n92         \"\"\"\n93 \n94         assert self._fmt is not None\n95         levelname_fmt_match = self.LEVELNAME_FMT_REGEX.search(self._fmt)\n96         if not levelname_fmt_match:\n97             return\n98         levelname_fmt = levelname_fmt_match.group()\n99 \n100         formatted_levelname = levelname_fmt % {\"levelname\": logging.getLevelName(level)}\n101 \n102         # add ANSI escape sequences around the formatted levelname\n103         color_kwargs = {name: True for name in color_opts}\n104         colorized_formatted_levelname = self._terminalwriter.markup(\n105             formatted_levelname, **color_kwargs\n106         )\n107         self._level_to_fmt_mapping[level] = self.LEVELNAME_FMT_REGEX.sub(\n108             colorized_formatted_levelname, self._fmt\n109         )\n110 \n111     def format(self, record: logging.LogRecord) -> str:\n112         fmt = self._level_to_fmt_mapping.get(record.levelno, self._original_fmt)\n113         self._style._fmt = fmt\n114         return super().format(record)\n115 \n116 \n117 class PercentStyleMultiline(logging.PercentStyle):\n118     \"\"\"A logging style with special support for multiline messages.\n119 \n120     If the message of a record consists of multiple lines, this style\n121     formats the message as if each line were logged separately.\n122     \"\"\"\n123 \n124     def __init__(self, fmt: str, auto_indent: Union[int, str, bool, None]) -> None:\n125         super().__init__(fmt)\n126         self._auto_indent = self._get_auto_indent(auto_indent)\n127 \n128     @staticmethod\n129     def _get_auto_indent(auto_indent_option: Union[int, str, bool, None]) -> int:\n130         \"\"\"Determine the current auto indentation setting.\n131 \n132         Specify auto indent behavior (on/off/fixed) by passing in\n133         extra={\"auto_indent\": [value]} to the call to logging.log() or\n134         using a --log-auto-indent [value] command line or the\n135         log_auto_indent [value] config option.\n136 \n137         Default behavior is auto-indent off.\n138 \n139         Using the string \"True\" or \"on\" or the boolean True as the value\n140         turns auto indent on, using the string \"False\" or \"off\" or the\n141         boolean False or the int 0 turns it off, and specifying a\n142         positive integer fixes the indentation position to the value\n143         specified.\n144 \n145         Any other values for the option are invalid, and will silently be\n146         converted to the default.\n147 \n148         :param None|bool|int|str auto_indent_option:\n149             User specified option for indentation from command line, config\n150             or extra kwarg. Accepts int, bool or str. str option accepts the\n151             same range of values as boolean config options, as well as\n152             positive integers represented in str form.\n153 \n154         :returns:\n155             Indentation value, which can be\n156             -1 (automatically determine indentation) or\n157             0 (auto-indent turned off) or\n158             >0 (explicitly set indentation position).\n159         \"\"\"\n160 \n161         if auto_indent_option is None:\n162             return 0\n163         elif isinstance(auto_indent_option, bool):\n164             if auto_indent_option:\n165                 return -1\n166             else:\n167                 return 0\n168         elif isinstance(auto_indent_option, int):\n169             return int(auto_indent_option)\n170         elif isinstance(auto_indent_option, str):\n171             try:\n172                 return int(auto_indent_option)\n173             except ValueError:\n174                 pass\n175             try:\n176                 if _strtobool(auto_indent_option):\n177                     return -1\n178             except ValueError:\n179                 return 0\n180 \n181         return 0\n182 \n183     def format(self, record: logging.LogRecord) -> str:\n184         if \"\\n\" in record.message:\n185             if hasattr(record, \"auto_indent\"):\n186                 # Passed in from the \"extra={}\" kwarg on the call to logging.log().\n187                 auto_indent = self._get_auto_indent(record.auto_indent)  # type: ignore[attr-defined]\n188             else:\n189                 auto_indent = self._auto_indent\n190 \n191             if auto_indent:\n192                 lines = record.message.splitlines()\n193                 formatted = self._fmt % {**record.__dict__, \"message\": lines[0]}\n194 \n195                 if auto_indent < 0:\n196                     indentation = _remove_ansi_escape_sequences(formatted).find(\n197                         lines[0]\n198                     )\n199                 else:\n200                     # Optimizes logging by allowing a fixed indentation.\n201                     indentation = auto_indent\n202                 lines[0] = formatted\n203                 return (\"\\n\" + \" \" * indentation).join(lines)\n204         return self._fmt % record.__dict__\n205 \n206 \n207 def get_option_ini(config: Config, *names: str):\n208     for name in names:\n209         ret = config.getoption(name)  # 'default' arg won't work as expected\n210         if ret is None:\n211             ret = config.getini(name)\n212         if ret:\n213             return ret\n214 \n215 \n216 def pytest_addoption(parser: Parser) -> None:\n217     \"\"\"Add options to control log capturing.\"\"\"\n218     group = parser.getgroup(\"logging\")\n219 \n220     def add_option_ini(option, dest, default=None, type=None, **kwargs):\n221         parser.addini(\n222             dest, default=default, type=type, help=\"Default value for \" + option\n223         )\n224         group.addoption(option, dest=dest, **kwargs)\n225 \n226     add_option_ini(\n227         \"--log-level\",\n228         dest=\"log_level\",\n229         default=None,\n230         metavar=\"LEVEL\",\n231         help=(\n232             \"Level of messages to catch/display.\"\n233             \" Not set by default, so it depends on the root/parent log handler's\"\n234             ' effective level, where it is \"WARNING\" by default.'\n235         ),\n236     )\n237     add_option_ini(\n238         \"--log-format\",\n239         dest=\"log_format\",\n240         default=DEFAULT_LOG_FORMAT,\n241         help=\"Log format used by the logging module\",\n242     )\n243     add_option_ini(\n244         \"--log-date-format\",\n245         dest=\"log_date_format\",\n246         default=DEFAULT_LOG_DATE_FORMAT,\n247         help=\"Log date format used by the logging module\",\n248     )\n249     parser.addini(\n250         \"log_cli\",\n251         default=False,\n252         type=\"bool\",\n253         help='Enable log display during test run (also known as \"live logging\")',\n254     )\n255     add_option_ini(\n256         \"--log-cli-level\", dest=\"log_cli_level\", default=None, help=\"CLI logging level\"\n257     )\n258     add_option_ini(\n259         \"--log-cli-format\",\n260         dest=\"log_cli_format\",\n261         default=None,\n262         help=\"Log format used by the logging module\",\n263     )\n264     add_option_ini(\n265         \"--log-cli-date-format\",\n266         dest=\"log_cli_date_format\",\n267         default=None,\n268         help=\"Log date format used by the logging module\",\n269     )\n270     add_option_ini(\n271         \"--log-file\",\n272         dest=\"log_file\",\n273         default=None,\n274         help=\"Path to a file when logging will be written to\",\n275     )\n276     add_option_ini(\n277         \"--log-file-level\",\n278         dest=\"log_file_level\",\n279         default=None,\n280         help=\"Log file logging level\",\n281     )\n282     add_option_ini(\n283         \"--log-file-format\",\n284         dest=\"log_file_format\",\n285         default=DEFAULT_LOG_FORMAT,\n286         help=\"Log format used by the logging module\",\n287     )\n288     add_option_ini(\n289         \"--log-file-date-format\",\n290         dest=\"log_file_date_format\",\n291         default=DEFAULT_LOG_DATE_FORMAT,\n292         help=\"Log date format used by the logging module\",\n293     )\n294     add_option_ini(\n295         \"--log-auto-indent\",\n296         dest=\"log_auto_indent\",\n297         default=None,\n298         help=\"Auto-indent multiline messages passed to the logging module. Accepts true|on, false|off or an integer.\",\n299     )\n300 \n301 \n302 _HandlerType = TypeVar(\"_HandlerType\", bound=logging.Handler)\n303 \n304 \n305 # Not using @contextmanager for performance reasons.\n306 class catching_logs:\n307     \"\"\"Context manager that prepares the whole logging machinery properly.\"\"\"\n308 \n309     __slots__ = (\"handler\", \"level\", \"orig_level\")\n310 \n311     def __init__(self, handler: _HandlerType, level: Optional[int] = None) -> None:\n312         self.handler = handler\n313         self.level = level\n314 \n315     def __enter__(self):\n316         root_logger = logging.getLogger()\n317         if self.level is not None:\n318             self.handler.setLevel(self.level)\n319         root_logger.addHandler(self.handler)\n320         if self.level is not None:\n321             self.orig_level = root_logger.level\n322             root_logger.setLevel(min(self.orig_level, self.level))\n323         return self.handler\n324 \n325     def __exit__(self, type, value, traceback):\n326         root_logger = logging.getLogger()\n327         if self.level is not None:\n328             root_logger.setLevel(self.orig_level)\n329         root_logger.removeHandler(self.handler)\n330 \n331 \n332 class LogCaptureHandler(logging_StreamHandler):\n333     \"\"\"A logging handler that stores log records and the log text.\"\"\"\n334 \n335     def __init__(self) -> None:\n336         \"\"\"Create a new log handler.\"\"\"\n337         super().__init__(StringIO())\n338         self.records: List[logging.LogRecord] = []\n339 \n340     def emit(self, record: logging.LogRecord) -> None:\n341         \"\"\"Keep the log records in a list in addition to the log text.\"\"\"\n342         self.records.append(record)\n343         super().emit(record)\n344 \n345     def reset(self) -> None:\n346         self.records = []\n347         self.stream = StringIO()\n348 \n349     def clear(self) -> None:\n350         self.records.clear()\n351         self.stream = StringIO()\n352 \n353     def handleError(self, record: logging.LogRecord) -> None:\n354         if logging.raiseExceptions:\n355             # Fail the test if the log message is bad (emit failed).\n356             # The default behavior of logging is to print \"Logging error\"\n357             # to stderr with the call stack and some extra details.\n358             # pytest wants to make such mistakes visible during testing.\n359             raise\n360 \n361 \n362 @final\n363 class LogCaptureFixture:\n364     \"\"\"Provides access and control of log capturing.\"\"\"\n365 \n366     def __init__(self, item: nodes.Node, *, _ispytest: bool = False) -> None:\n367         check_ispytest(_ispytest)\n368         self._item = item\n369         self._initial_handler_level: Optional[int] = None\n370         # Dict of log name -> log level.\n371         self._initial_logger_levels: Dict[Optional[str], int] = {}\n372 \n373     def _finalize(self) -> None:\n374         \"\"\"Finalize the fixture.\n375 \n376         This restores the log levels changed by :meth:`set_level`.\n377         \"\"\"\n378         # Restore log levels.\n379         if self._initial_handler_level is not None:\n380             self.handler.setLevel(self._initial_handler_level)\n381         for logger_name, level in self._initial_logger_levels.items():\n382             logger = logging.getLogger(logger_name)\n383             logger.setLevel(level)\n384 \n385     @property\n386     def handler(self) -> LogCaptureHandler:\n387         \"\"\"Get the logging handler used by the fixture.\"\"\"\n388         return self._item.stash[caplog_handler_key]\n389 \n390     def get_records(\n391         self, when: \"Literal['setup', 'call', 'teardown']\"\n392     ) -> List[logging.LogRecord]:\n393         \"\"\"Get the logging records for one of the possible test phases.\n394 \n395         :param when:\n396             Which test phase to obtain the records from.\n397             Valid values are: \"setup\", \"call\" and \"teardown\".\n398 \n399         :returns: The list of captured records at the given stage.\n400 \n401         .. versionadded:: 3.4\n402         \"\"\"\n403         return self._item.stash[caplog_records_key].get(when, [])\n404 \n405     @property\n406     def text(self) -> str:\n407         \"\"\"The formatted log text.\"\"\"\n408         return _remove_ansi_escape_sequences(self.handler.stream.getvalue())\n409 \n410     @property\n411     def records(self) -> List[logging.LogRecord]:\n412         \"\"\"The list of log records.\"\"\"\n413         return self.handler.records\n414 \n415     @property\n416     def record_tuples(self) -> List[Tuple[str, int, str]]:\n417         \"\"\"A list of a stripped down version of log records intended\n418         for use in assertion comparison.\n419 \n420         The format of the tuple is:\n421 \n422             (logger_name, log_level, message)\n423         \"\"\"\n424         return [(r.name, r.levelno, r.getMessage()) for r in self.records]\n425 \n426     @property\n427     def messages(self) -> List[str]:\n428         \"\"\"A list of format-interpolated log messages.\n429 \n430         Unlike 'records', which contains the format string and parameters for\n431         interpolation, log messages in this list are all interpolated.\n432 \n433         Unlike 'text', which contains the output from the handler, log\n434         messages in this list are unadorned with levels, timestamps, etc,\n435         making exact comparisons more reliable.\n436 \n437         Note that traceback or stack info (from :func:`logging.exception` or\n438         the `exc_info` or `stack_info` arguments to the logging functions) is\n439         not included, as this is added by the formatter in the handler.\n440 \n441         .. versionadded:: 3.7\n442         \"\"\"\n443         return [r.getMessage() for r in self.records]\n444 \n445     def clear(self) -> None:\n446         \"\"\"Reset the list of log records and the captured log text.\"\"\"\n447         self.handler.clear()\n448 \n449     def set_level(self, level: Union[int, str], logger: Optional[str] = None) -> None:\n450         \"\"\"Set the level of a logger for the duration of a test.\n451 \n452         .. versionchanged:: 3.4\n453             The levels of the loggers changed by this function will be\n454             restored to their initial values at the end of the test.\n455 \n456         :param level: The level.\n457         :param logger: The logger to update. If not given, the root logger.\n458         \"\"\"\n459         logger_obj = logging.getLogger(logger)\n460         # Save the original log-level to restore it during teardown.\n461         self._initial_logger_levels.setdefault(logger, logger_obj.level)\n462         logger_obj.setLevel(level)\n463         if self._initial_handler_level is None:\n464             self._initial_handler_level = self.handler.level\n465         self.handler.setLevel(level)\n466 \n467     @contextmanager\n468     def at_level(\n469         self, level: Union[int, str], logger: Optional[str] = None\n470     ) -> Generator[None, None, None]:\n471         \"\"\"Context manager that sets the level for capturing of logs. After\n472         the end of the 'with' statement the level is restored to its original\n473         value.\n474 \n475         :param level: The level.\n476         :param logger: The logger to update. If not given, the root logger.\n477         \"\"\"\n478         logger_obj = logging.getLogger(logger)\n479         orig_level = logger_obj.level\n480         logger_obj.setLevel(level)\n481         handler_orig_level = self.handler.level\n482         self.handler.setLevel(level)\n483         try:\n484             yield\n485         finally:\n486             logger_obj.setLevel(orig_level)\n487             self.handler.setLevel(handler_orig_level)\n488 \n489 \n490 @fixture\n491 def caplog(request: FixtureRequest) -> Generator[LogCaptureFixture, None, None]:\n492     \"\"\"Access and control log capturing.\n493 \n494     Captured logs are available through the following properties/methods::\n495 \n496     * caplog.messages        -> list of format-interpolated log messages\n497     * caplog.text            -> string containing formatted log output\n498     * caplog.records         -> list of logging.LogRecord instances\n499     * caplog.record_tuples   -> list of (logger_name, level, message) tuples\n500     * caplog.clear()         -> clear captured records and formatted log output string\n501     \"\"\"\n502     result = LogCaptureFixture(request.node, _ispytest=True)\n503     yield result\n504     result._finalize()\n505 \n506 \n507 def get_log_level_for_setting(config: Config, *setting_names: str) -> Optional[int]:\n508     for setting_name in setting_names:\n509         log_level = config.getoption(setting_name)\n510         if log_level is None:\n511             log_level = config.getini(setting_name)\n512         if log_level:\n513             break\n514     else:\n515         return None\n516 \n517     if isinstance(log_level, str):\n518         log_level = log_level.upper()\n519     try:\n520         return int(getattr(logging, log_level, log_level))\n521     except ValueError as e:\n522         # Python logging does not recognise this as a logging level\n523         raise UsageError(\n524             \"'{}' is not recognized as a logging level name for \"\n525             \"'{}'. Please consider passing the \"\n526             \"logging level num instead.\".format(log_level, setting_name)\n527         ) from e\n528 \n529 \n530 # run after terminalreporter/capturemanager are configured\n531 @hookimpl(trylast=True)\n532 def pytest_configure(config: Config) -> None:\n533     config.pluginmanager.register(LoggingPlugin(config), \"logging-plugin\")\n534 \n535 \n536 class LoggingPlugin:\n537     \"\"\"Attaches to the logging module and captures log messages for each test.\"\"\"\n538 \n539     def __init__(self, config: Config) -> None:\n540         \"\"\"Create a new plugin to capture log messages.\n541 \n542         The formatter can be safely shared across all handlers so\n543         create a single one for the entire test session here.\n544         \"\"\"\n545         self._config = config\n546 \n547         # Report logging.\n548         self.formatter = self._create_formatter(\n549             get_option_ini(config, \"log_format\"),\n550             get_option_ini(config, \"log_date_format\"),\n551             get_option_ini(config, \"log_auto_indent\"),\n552         )\n553         self.log_level = get_log_level_for_setting(config, \"log_level\")\n554         self.caplog_handler = LogCaptureHandler()\n555         self.caplog_handler.setFormatter(self.formatter)\n556         self.report_handler = LogCaptureHandler()\n557         self.report_handler.setFormatter(self.formatter)\n558 \n559         # File logging.\n560         self.log_file_level = get_log_level_for_setting(config, \"log_file_level\")\n561         log_file = get_option_ini(config, \"log_file\") or os.devnull\n562         if log_file != os.devnull:\n563             directory = os.path.dirname(os.path.abspath(log_file))\n564             if not os.path.isdir(directory):\n565                 os.makedirs(directory)\n566 \n567         self.log_file_handler = _FileHandler(log_file, mode=\"w\", encoding=\"UTF-8\")\n568         log_file_format = get_option_ini(config, \"log_file_format\", \"log_format\")\n569         log_file_date_format = get_option_ini(\n570             config, \"log_file_date_format\", \"log_date_format\"\n571         )\n572 \n573         log_file_formatter = logging.Formatter(\n574             log_file_format, datefmt=log_file_date_format\n575         )\n576         self.log_file_handler.setFormatter(log_file_formatter)\n577 \n578         # CLI/live logging.\n579         self.log_cli_level = get_log_level_for_setting(\n580             config, \"log_cli_level\", \"log_level\"\n581         )\n582         if self._log_cli_enabled():\n583             terminal_reporter = config.pluginmanager.get_plugin(\"terminalreporter\")\n584             capture_manager = config.pluginmanager.get_plugin(\"capturemanager\")\n585             # if capturemanager plugin is disabled, live logging still works.\n586             self.log_cli_handler: Union[\n587                 _LiveLoggingStreamHandler, _LiveLoggingNullHandler\n588             ] = _LiveLoggingStreamHandler(terminal_reporter, capture_manager)\n589         else:\n590             self.log_cli_handler = _LiveLoggingNullHandler()\n591         log_cli_formatter = self._create_formatter(\n592             get_option_ini(config, \"log_cli_format\", \"log_format\"),\n593             get_option_ini(config, \"log_cli_date_format\", \"log_date_format\"),\n594             get_option_ini(config, \"log_auto_indent\"),\n595         )\n596         self.log_cli_handler.setFormatter(log_cli_formatter)\n597 \n598     def _create_formatter(self, log_format, log_date_format, auto_indent):\n599         # Color option doesn't exist if terminal plugin is disabled.\n600         color = getattr(self._config.option, \"color\", \"no\")\n601         if color != \"no\" and ColoredLevelFormatter.LEVELNAME_FMT_REGEX.search(\n602             log_format\n603         ):\n604             formatter: logging.Formatter = ColoredLevelFormatter(\n605                 create_terminal_writer(self._config), log_format, log_date_format\n606             )\n607         else:\n608             formatter = logging.Formatter(log_format, log_date_format)\n609 \n610         formatter._style = PercentStyleMultiline(\n611             formatter._style._fmt, auto_indent=auto_indent\n612         )\n613 \n614         return formatter\n615 \n616     def set_log_path(self, fname: str) -> None:\n617         \"\"\"Set the filename parameter for Logging.FileHandler().\n618 \n619         Creates parent directory if it does not exist.\n620 \n621         .. warning::\n622             This is an experimental API.\n623         \"\"\"\n624         fpath = Path(fname)\n625 \n626         if not fpath.is_absolute():\n627             fpath = self._config.rootpath / fpath\n628 \n629         if not fpath.parent.exists():\n630             fpath.parent.mkdir(exist_ok=True, parents=True)\n631 \n632         # https://github.com/python/mypy/issues/11193\n633         stream: io.TextIOWrapper = fpath.open(mode=\"w\", encoding=\"UTF-8\")  # type: ignore[assignment]\n634         old_stream = self.log_file_handler.setStream(stream)\n635         if old_stream:\n636             old_stream.close()\n637 \n638     def _log_cli_enabled(self):\n639         \"\"\"Return whether live logging is enabled.\"\"\"\n640         enabled = self._config.getoption(\n641             \"--log-cli-level\"\n642         ) is not None or self._config.getini(\"log_cli\")\n643         if not enabled:\n644             return False\n645 \n646         terminal_reporter = self._config.pluginmanager.get_plugin(\"terminalreporter\")\n647         if terminal_reporter is None:\n648             # terminal reporter is disabled e.g. by pytest-xdist.\n649             return False\n650 \n651         return True\n652 \n653     @hookimpl(hookwrapper=True, tryfirst=True)\n654     def pytest_sessionstart(self) -> Generator[None, None, None]:\n655         self.log_cli_handler.set_when(\"sessionstart\")\n656 \n657         with catching_logs(self.log_cli_handler, level=self.log_cli_level):\n658             with catching_logs(self.log_file_handler, level=self.log_file_level):\n659                 yield\n660 \n661     @hookimpl(hookwrapper=True, tryfirst=True)\n662     def pytest_collection(self) -> Generator[None, None, None]:\n663         self.log_cli_handler.set_when(\"collection\")\n664 \n665         with catching_logs(self.log_cli_handler, level=self.log_cli_level):\n666             with catching_logs(self.log_file_handler, level=self.log_file_level):\n667                 yield\n668 \n669     @hookimpl(hookwrapper=True)\n670     def pytest_runtestloop(self, session: Session) -> Generator[None, None, None]:\n671         if session.config.option.collectonly:\n672             yield\n673             return\n674 \n675         if self._log_cli_enabled() and self._config.getoption(\"verbose\") < 1:\n676             # The verbose flag is needed to avoid messy test progress output.\n677             self._config.option.verbose = 1\n678 \n679         with catching_logs(self.log_cli_handler, level=self.log_cli_level):\n680             with catching_logs(self.log_file_handler, level=self.log_file_level):\n681                 yield  # Run all the tests.\n682 \n683     @hookimpl\n684     def pytest_runtest_logstart(self) -> None:\n685         self.log_cli_handler.reset()\n686         self.log_cli_handler.set_when(\"start\")\n687 \n688     @hookimpl\n689     def pytest_runtest_logreport(self) -> None:\n690         self.log_cli_handler.set_when(\"logreport\")\n691 \n692     def _runtest_for(self, item: nodes.Item, when: str) -> Generator[None, None, None]:\n693         \"\"\"Implement the internals of the pytest_runtest_xxx() hooks.\"\"\"\n694         with catching_logs(\n695             self.caplog_handler,\n696             level=self.log_level,\n697         ) as caplog_handler, catching_logs(\n698             self.report_handler,\n699             level=self.log_level,\n700         ) as report_handler:\n701             caplog_handler.reset()\n702             report_handler.reset()\n703             item.stash[caplog_records_key][when] = caplog_handler.records\n704             item.stash[caplog_handler_key] = caplog_handler\n705 \n706             yield\n707 \n708             log = report_handler.stream.getvalue().strip()\n709             item.add_report_section(when, \"log\", log)\n710 \n711     @hookimpl(hookwrapper=True)\n712     def pytest_runtest_setup(self, item: nodes.Item) -> Generator[None, None, None]:\n713         self.log_cli_handler.set_when(\"setup\")\n714 \n715         empty: Dict[str, List[logging.LogRecord]] = {}\n716         item.stash[caplog_records_key] = empty\n717         yield from self._runtest_for(item, \"setup\")\n718 \n719     @hookimpl(hookwrapper=True)\n720     def pytest_runtest_call(self, item: nodes.Item) -> Generator[None, None, None]:\n721         self.log_cli_handler.set_when(\"call\")\n722 \n723         yield from self._runtest_for(item, \"call\")\n724 \n725     @hookimpl(hookwrapper=True)\n726     def pytest_runtest_teardown(self, item: nodes.Item) -> Generator[None, None, None]:\n727         self.log_cli_handler.set_when(\"teardown\")\n728 \n729         yield from self._runtest_for(item, \"teardown\")\n730         del item.stash[caplog_records_key]\n731         del item.stash[caplog_handler_key]\n732 \n733     @hookimpl\n734     def pytest_runtest_logfinish(self) -> None:\n735         self.log_cli_handler.set_when(\"finish\")\n736 \n737     @hookimpl(hookwrapper=True, tryfirst=True)\n738     def pytest_sessionfinish(self) -> Generator[None, None, None]:\n739         self.log_cli_handler.set_when(\"sessionfinish\")\n740 \n741         with catching_logs(self.log_cli_handler, level=self.log_cli_level):\n742             with catching_logs(self.log_file_handler, level=self.log_file_level):\n743                 yield\n744 \n745     @hookimpl\n746     def pytest_unconfigure(self) -> None:\n747         # Close the FileHandler explicitly.\n748         # (logging.shutdown might have lost the weakref?!)\n749         self.log_file_handler.close()\n750 \n751 \n752 class _FileHandler(logging.FileHandler):\n753     \"\"\"A logging FileHandler with pytest tweaks.\"\"\"\n754 \n755     def handleError(self, record: logging.LogRecord) -> None:\n756         # Handled by LogCaptureHandler.\n757         pass\n758 \n759 \n760 class _LiveLoggingStreamHandler(logging_StreamHandler):\n761     \"\"\"A logging StreamHandler used by the live logging feature: it will\n762     write a newline before the first log message in each test.\n763 \n764     During live logging we must also explicitly disable stdout/stderr\n765     capturing otherwise it will get captured and won't appear in the\n766     terminal.\n767     \"\"\"\n768 \n769     # Officially stream needs to be a IO[str], but TerminalReporter\n770     # isn't. So force it.\n771     stream: TerminalReporter = None  # type: ignore\n772 \n773     def __init__(\n774         self,\n775         terminal_reporter: TerminalReporter,\n776         capture_manager: Optional[CaptureManager],\n777     ) -> None:\n778         super().__init__(stream=terminal_reporter)  # type: ignore[arg-type]\n779         self.capture_manager = capture_manager\n780         self.reset()\n781         self.set_when(None)\n782         self._test_outcome_written = False\n783 \n784     def reset(self) -> None:\n785         \"\"\"Reset the handler; should be called before the start of each test.\"\"\"\n786         self._first_record_emitted = False\n787 \n788     def set_when(self, when: Optional[str]) -> None:\n789         \"\"\"Prepare for the given test phase (setup/call/teardown).\"\"\"\n790         self._when = when\n791         self._section_name_shown = False\n792         if when == \"start\":\n793             self._test_outcome_written = False\n794 \n795     def emit(self, record: logging.LogRecord) -> None:\n796         ctx_manager = (\n797             self.capture_manager.global_and_fixture_disabled()\n798             if self.capture_manager\n799             else nullcontext()\n800         )\n801         with ctx_manager:\n802             if not self._first_record_emitted:\n803                 self.stream.write(\"\\n\")\n804                 self._first_record_emitted = True\n805             elif self._when in (\"teardown\", \"finish\"):\n806                 if not self._test_outcome_written:\n807                     self._test_outcome_written = True\n808                     self.stream.write(\"\\n\")\n809             if not self._section_name_shown and self._when:\n810                 self.stream.section(\"live log \" + self._when, sep=\"-\", bold=True)\n811                 self._section_name_shown = True\n812             super().emit(record)\n813 \n814     def handleError(self, record: logging.LogRecord) -> None:\n815         # Handled by LogCaptureHandler.\n816         pass\n817 \n818 \n819 class _LiveLoggingNullHandler(logging.NullHandler):\n820     \"\"\"A logging handler used when live logging is disabled.\"\"\"\n821 \n822     def reset(self) -> None:\n823         pass\n824 \n825     def set_when(self, when: str) -> None:\n826         pass\n827 \n828     def handleError(self, record: logging.LogRecord) -> None:\n829         # Handled by LogCaptureHandler.\n830         pass\n",
        "intended_behavior": "In files where the `@hookimpl` decorator is used for registering hooks, particularly those related to the `pytest_configure` hook implementation, an update or wrapper around the registration process may be needed to capture and store the source location (e.g., using introspection or modifying the `@hookimpl` decorator functionality). When a deprecated hook implementation is identified, the system should then be able to use this stored location information to provide a detailed warning. This solution requires careful consideration to ensure that performance implications are minimal and that the additional context does not interfere with the normal operation and flexibility of the plugin system."
    }
]