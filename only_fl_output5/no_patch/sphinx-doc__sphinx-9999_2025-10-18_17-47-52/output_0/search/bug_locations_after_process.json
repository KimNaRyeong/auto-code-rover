[
    {
        "rel_file_path": "sphinx/writers/latex.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sphinx-doc__sphinx/setup_sphinx-doc__sphinx__5.0/sphinx/writers/latex.py",
        "start": 560,
        "end": 561,
        "class_name": null,
        "method_name": "visit_glossary",
        "code": "560     def visit_glossary(self, node: Element) -> None:\n561         pass\n",
        "intended_behavior": "The `visit_glossary` method should ensure that any terms processed are output with appropriate spacing or newline separation in the LaTeX output. This might involve adjusting the method to insert newlines or ensuring that appropriate LaTeX newline commands (`\\\\` or `\\newline`) are used between terms or glossary entries to reflect the expected spacing as seen in other output formats such as HTML. The change should ensure that the LaTeX rendering of glossary terms (and potentially other lists like the example list of file extensions) maintains visual and structural consistency with their representation in reStructuredText source and other output formats."
    },
    {
        "rel_file_path": "sphinx/writers/latex.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sphinx-doc__sphinx/setup_sphinx-doc__sphinx__5.0/sphinx/writers/latex.py",
        "start": 560,
        "end": 561,
        "class_name": "LaTeXTranslator",
        "method_name": "visit_glossary",
        "code": "560     def visit_glossary(self, node: Element) -> None:\n561         pass\n",
        "intended_behavior": "The `visit_glossary` method should ensure that any terms processed are output with appropriate spacing or newline separation in the LaTeX output. This might involve adjusting the method to insert newlines or ensuring that appropriate LaTeX newline commands (`\\\\` or `\\newline`) are used between terms or glossary entries to reflect the expected spacing as seen in other output formats such as HTML. The change should ensure that the LaTeX rendering of glossary terms (and potentially other lists like the example list of file extensions) maintains visual and structural consistency with their representation in reStructuredText source and other output formats."
    },
    {
        "rel_file_path": "sphinx/builders/latex/__init__.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sphinx-doc__sphinx/setup_sphinx-doc__sphinx__5.0/sphinx/builders/latex/__init__.py",
        "start": 261,
        "end": 306,
        "class_name": "LaTeXBuilder",
        "method_name": "write",
        "code": "261     def write(self, *ignored: Any) -> None:\n262         docwriter = LaTeXWriter(self)\n263         docsettings: Any = OptionParser(\n264             defaults=self.env.settings,\n265             components=(docwriter,),\n266             read_config_files=True).get_default_values()\n267 \n268         self.init_document_data()\n269         self.write_stylesheet()\n270 \n271         for entry in self.document_data:\n272             docname, targetname, title, author, themename = entry[:5]\n273             theme = self.themes.get(themename)\n274             toctree_only = False\n275             if len(entry) > 5:\n276                 toctree_only = entry[5]\n277             destination = SphinxFileOutput(destination_path=path.join(self.outdir, targetname),\n278                                            encoding='utf-8', overwrite_if_changed=True)\n279             with progress_message(__(\"processing %s\") % targetname):\n280                 doctree = self.env.get_doctree(docname)\n281                 toctree = next(iter(doctree.traverse(addnodes.toctree)), None)\n282                 if toctree and toctree.get('maxdepth') > 0:\n283                     tocdepth = toctree.get('maxdepth')\n284                 else:\n285                     tocdepth = None\n286 \n287                 doctree = self.assemble_doctree(\n288                     docname, toctree_only,\n289                     appendices=(self.config.latex_appendices if theme.name != 'howto' else []))\n290                 doctree['docclass'] = theme.docclass\n291                 doctree['contentsname'] = self.get_contentsname(docname)\n292                 doctree['tocdepth'] = tocdepth\n293                 self.post_process_images(doctree)\n294                 self.update_doc_context(title, author, theme)\n295                 self.update_context()\n296 \n297             with progress_message(__(\"writing\")):\n298                 docsettings._author = author\n299                 docsettings._title = title\n300                 docsettings._contentsname = doctree['contentsname']\n301                 docsettings._docname = docname\n302                 docsettings._docclass = theme.name\n303 \n304                 doctree.settings = docsettings\n305                 docwriter.theme = theme\n306                 docwriter.write(doctree, destination)\n",
        "intended_behavior": "This method's handling of document conversion to LaTeX should preserve explicit line breaks or spacing directives found in source reST documents or those implied by structure (like lists or glossary entries). While the current handling likely focuses on document structure and general formatting, special attention might be needed to ensure inline text roles and structures like glossaries correctly reflect intended spacing in the output. The goal will be to review and possibly enhance how such elements are processed, ensuring that LaTeX syntax for preserving or introducing newlines is correctly applied when generating the final LaTeX documents. This adjustment should maintain existing functionality while correcting the issue with term separation in the generated LaTeX output."
    },
    {
        "rel_file_path": "sphinx/builders/latex/__init__.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sphinx-doc__sphinx/setup_sphinx-doc__sphinx__5.0/sphinx/builders/latex/__init__.py",
        "start": 106,
        "end": 448,
        "class_name": "LaTeXBuilder",
        "method_name": null,
        "code": "106 class LaTeXBuilder(Builder):\n107     \"\"\"\n108     Builds LaTeX output to create PDF.\n109     \"\"\"\n110     name = 'latex'\n111     format = 'latex'\n112     epilog = __('The LaTeX files are in %(outdir)s.')\n113     if os.name == 'posix':\n114         epilog += __(\"\\nRun 'make' in that directory to run these through \"\n115                      \"(pdf)latex\\n\"\n116                      \"(use `make latexpdf' here to do that automatically).\")\n117 \n118     supported_image_types = ['application/pdf', 'image/png', 'image/jpeg']\n119     supported_remote_images = False\n120     default_translator_class = LaTeXTranslator\n121 \n122     def init(self) -> None:\n123         self.babel: ExtBabel = None\n124         self.context: Dict[str, Any] = {}\n125         self.docnames: Iterable[str] = {}\n126         self.document_data: List[Tuple[str, str, str, str, str, bool]] = []\n127         self.themes = ThemeFactory(self.app)\n128         texescape.init()\n129 \n130         self.init_context()\n131         self.init_babel()\n132         self.init_multilingual()\n133 \n134     def get_outdated_docs(self) -> Union[str, List[str]]:\n135         return 'all documents'  # for now\n136 \n137     def get_target_uri(self, docname: str, typ: str = None) -> str:\n138         if docname not in self.docnames:\n139             raise NoUri(docname, typ)\n140         else:\n141             return '%' + docname\n142 \n143     def get_relative_uri(self, from_: str, to: str, typ: str = None) -> str:\n144         # ignore source path\n145         return self.get_target_uri(to, typ)\n146 \n147     def init_document_data(self) -> None:\n148         preliminary_document_data = [list(x) for x in self.config.latex_documents]\n149         if not preliminary_document_data:\n150             logger.warning(__('no \"latex_documents\" config value found; no documents '\n151                               'will be written'))\n152             return\n153         # assign subdirs to titles\n154         self.titles: List[Tuple[str, str]] = []\n155         for entry in preliminary_document_data:\n156             docname = entry[0]\n157             if docname not in self.env.all_docs:\n158                 logger.warning(__('\"latex_documents\" config value references unknown '\n159                                   'document %s'), docname)\n160                 continue\n161             self.document_data.append(entry)  # type: ignore\n162             if docname.endswith(SEP + 'index'):\n163                 docname = docname[:-5]\n164             self.titles.append((docname, entry[2]))\n165 \n166     def init_context(self) -> None:\n167         self.context = DEFAULT_SETTINGS.copy()\n168 \n169         # Add special settings for latex_engine\n170         self.context.update(ADDITIONAL_SETTINGS.get(self.config.latex_engine, {}))\n171 \n172         # Add special settings for (latex_engine, language_code)\n173         if self.config.language:\n174             key = (self.config.latex_engine, self.config.language[:2])\n175             self.context.update(ADDITIONAL_SETTINGS.get(key, {}))\n176 \n177         # Apply user settings to context\n178         self.context.update(self.config.latex_elements)\n179         self.context['release'] = self.config.release\n180         self.context['use_xindy'] = self.config.latex_use_xindy\n181 \n182         if self.config.today:\n183             self.context['date'] = self.config.today\n184         else:\n185             self.context['date'] = format_date(self.config.today_fmt or _('%b %d, %Y'),\n186                                                language=self.config.language)\n187 \n188         if self.config.latex_logo:\n189             self.context['logofilename'] = path.basename(self.config.latex_logo)\n190 \n191         # for compatibilities\n192         self.context['indexname'] = _('Index')\n193         if self.config.release:\n194             # Show the release label only if release value exists\n195             self.context.setdefault('releasename', _('Release'))\n196 \n197     def update_context(self) -> None:\n198         \"\"\"Update template variables for .tex file just before writing.\"\"\"\n199         # Apply extension settings to context\n200         registry = self.app.registry\n201         self.context['packages'] = registry.latex_packages\n202         self.context['packages_after_hyperref'] = registry.latex_packages_after_hyperref\n203 \n204     def init_babel(self) -> None:\n205         self.babel = ExtBabel(self.config.language, not self.context['babel'])\n206         if self.config.language and not self.babel.is_supported_language():\n207             # emit warning if specified language is invalid\n208             # (only emitting, nothing changed to processing)\n209             logger.warning(__('no Babel option known for language %r'),\n210                            self.config.language)\n211 \n212     def init_multilingual(self) -> None:\n213         if self.context['latex_engine'] == 'pdflatex':\n214             if not self.babel.uses_cyrillic():\n215                 if 'X2' in self.context['fontenc']:\n216                     self.context['substitutefont'] = '\\\\usepackage{substitutefont}'\n217                     self.context['textcyrillic'] = ('\\\\usepackage[Xtwo]'\n218                                                     '{sphinxpackagecyrillic}')\n219                 elif 'T2A' in self.context['fontenc']:\n220                     self.context['substitutefont'] = '\\\\usepackage{substitutefont}'\n221                     self.context['textcyrillic'] = ('\\\\usepackage[TtwoA]'\n222                                                     '{sphinxpackagecyrillic}')\n223             if 'LGR' in self.context['fontenc']:\n224                 self.context['substitutefont'] = '\\\\usepackage{substitutefont}'\n225             else:\n226                 self.context['textgreek'] = ''\n227             if self.context['substitutefont'] == '':\n228                 self.context['fontsubstitution'] = ''\n229 \n230         # 'babel' key is public and user setting must be obeyed\n231         if self.context['babel']:\n232             self.context['classoptions'] += ',' + self.babel.get_language()\n233             # this branch is not taken for xelatex/lualatex if default settings\n234             self.context['multilingual'] = self.context['babel']\n235             if self.config.language:\n236                 self.context['shorthandoff'] = SHORTHANDOFF\n237 \n238                 # Times fonts don't work with Cyrillic languages\n239                 if self.babel.uses_cyrillic() and 'fontpkg' not in self.config.latex_elements:\n240                     self.context['fontpkg'] = ''\n241         elif self.context['polyglossia']:\n242             self.context['classoptions'] += ',' + self.babel.get_language()\n243             options = self.babel.get_mainlanguage_options()\n244             if options:\n245                 language = r'\\setmainlanguage[%s]{%s}' % (options, self.babel.get_language())\n246             else:\n247                 language = r'\\setmainlanguage{%s}' % self.babel.get_language()\n248 \n249             self.context['multilingual'] = '%s\\n%s' % (self.context['polyglossia'], language)\n250 \n251     def write_stylesheet(self) -> None:\n252         highlighter = highlighting.PygmentsBridge('latex', self.config.pygments_style)\n253         stylesheet = path.join(self.outdir, 'sphinxhighlight.sty')\n254         with open(stylesheet, 'w') as f:\n255             f.write('\\\\NeedsTeXFormat{LaTeX2e}[1995/12/01]\\n')\n256             f.write('\\\\ProvidesPackage{sphinxhighlight}'\n257                     '[2016/05/29 stylesheet for highlighting with pygments]\\n')\n258             f.write('% Its contents depend on pygments_style configuration variable.\\n\\n')\n259             f.write(highlighter.get_stylesheet())\n260 \n261     def write(self, *ignored: Any) -> None:\n262         docwriter = LaTeXWriter(self)\n263         docsettings: Any = OptionParser(\n264             defaults=self.env.settings,\n265             components=(docwriter,),\n266             read_config_files=True).get_default_values()\n267 \n268         self.init_document_data()\n269         self.write_stylesheet()\n270 \n271         for entry in self.document_data:\n272             docname, targetname, title, author, themename = entry[:5]\n273             theme = self.themes.get(themename)\n274             toctree_only = False\n275             if len(entry) > 5:\n276                 toctree_only = entry[5]\n277             destination = SphinxFileOutput(destination_path=path.join(self.outdir, targetname),\n278                                            encoding='utf-8', overwrite_if_changed=True)\n279             with progress_message(__(\"processing %s\") % targetname):\n280                 doctree = self.env.get_doctree(docname)\n281                 toctree = next(iter(doctree.traverse(addnodes.toctree)), None)\n282                 if toctree and toctree.get('maxdepth') > 0:\n283                     tocdepth = toctree.get('maxdepth')\n284                 else:\n285                     tocdepth = None\n286 \n287                 doctree = self.assemble_doctree(\n288                     docname, toctree_only,\n289                     appendices=(self.config.latex_appendices if theme.name != 'howto' else []))\n290                 doctree['docclass'] = theme.docclass\n291                 doctree['contentsname'] = self.get_contentsname(docname)\n292                 doctree['tocdepth'] = tocdepth\n293                 self.post_process_images(doctree)\n294                 self.update_doc_context(title, author, theme)\n295                 self.update_context()\n296 \n297             with progress_message(__(\"writing\")):\n298                 docsettings._author = author\n299                 docsettings._title = title\n300                 docsettings._contentsname = doctree['contentsname']\n301                 docsettings._docname = docname\n302                 docsettings._docclass = theme.name\n303 \n304                 doctree.settings = docsettings\n305                 docwriter.theme = theme\n306                 docwriter.write(doctree, destination)\n307 \n308     def get_contentsname(self, indexfile: str) -> str:\n309         tree = self.env.get_doctree(indexfile)\n310         contentsname = None\n311         for toctree in tree.traverse(addnodes.toctree):\n312             if 'caption' in toctree:\n313                 contentsname = toctree['caption']\n314                 break\n315 \n316         return contentsname\n317 \n318     def update_doc_context(self, title: str, author: str, theme: Theme) -> None:\n319         self.context['title'] = title\n320         self.context['author'] = author\n321         self.context['docclass'] = theme.docclass\n322         self.context['papersize'] = theme.papersize\n323         self.context['pointsize'] = theme.pointsize\n324         self.context['wrapperclass'] = theme.wrapperclass\n325 \n326     def assemble_doctree(self, indexfile: str, toctree_only: bool, appendices: List[str]) -> nodes.document:  # NOQA\n327         self.docnames = set([indexfile] + appendices)\n328         logger.info(darkgreen(indexfile) + \" \", nonl=True)\n329         tree = self.env.get_doctree(indexfile)\n330         tree['docname'] = indexfile\n331         if toctree_only:\n332             # extract toctree nodes from the tree and put them in a\n333             # fresh document\n334             new_tree = new_document('<latex output>')\n335             new_sect = nodes.section()\n336             new_sect += nodes.title('<Set title in conf.py>',\n337                                     '<Set title in conf.py>')\n338             new_tree += new_sect\n339             for node in tree.traverse(addnodes.toctree):\n340                 new_sect += node\n341             tree = new_tree\n342         largetree = inline_all_toctrees(self, self.docnames, indexfile, tree,\n343                                         darkgreen, [indexfile])\n344         largetree['docname'] = indexfile\n345         for docname in appendices:\n346             appendix = self.env.get_doctree(docname)\n347             appendix['docname'] = docname\n348             largetree.append(appendix)\n349         logger.info('')\n350         logger.info(__(\"resolving references...\"))\n351         self.env.resolve_references(largetree, indexfile, self)\n352         # resolve :ref:s to distant tex files -- we can't add a cross-reference,\n353         # but append the document name\n354         for pendingnode in largetree.traverse(addnodes.pending_xref):\n355             docname = pendingnode['refdocname']\n356             sectname = pendingnode['refsectname']\n357             newnodes: List[Node] = [nodes.emphasis(sectname, sectname)]\n358             for subdir, title in self.titles:\n359                 if docname.startswith(subdir):\n360                     newnodes.append(nodes.Text(_(' (in '), _(' (in ')))\n361                     newnodes.append(nodes.emphasis(title, title))\n362                     newnodes.append(nodes.Text(')', ')'))\n363                     break\n364             else:\n365                 pass\n366             pendingnode.replace_self(newnodes)\n367         return largetree\n368 \n369     def finish(self) -> None:\n370         self.copy_image_files()\n371         self.write_message_catalog()\n372         self.copy_support_files()\n373 \n374         if self.config.latex_additional_files:\n375             self.copy_latex_additional_files()\n376 \n377     @progress_message(__('copying TeX support files'))\n378     def copy_support_files(self) -> None:\n379         \"\"\"copy TeX support files from texinputs.\"\"\"\n380         # configure usage of xindy (impacts Makefile and latexmkrc)\n381         # FIXME: convert this rather to a confval with suitable default\n382         #        according to language ? but would require extra documentation\n383         if self.config.language:\n384             xindy_lang_option = \\\n385                 XINDY_LANG_OPTIONS.get(self.config.language[:2],\n386                                        '-L general -C utf8 ')\n387             xindy_cyrillic = self.config.language[:2] in XINDY_CYRILLIC_SCRIPTS\n388         else:\n389             xindy_lang_option = '-L english -C utf8 '\n390             xindy_cyrillic = False\n391         context = {\n392             'latex_engine':      self.config.latex_engine,\n393             'xindy_use':         self.config.latex_use_xindy,\n394             'xindy_lang_option': xindy_lang_option,\n395             'xindy_cyrillic':    xindy_cyrillic,\n396         }\n397         logger.info(bold(__('copying TeX support files...')))\n398         staticdirname = path.join(package_dir, 'texinputs')\n399         for filename in os.listdir(staticdirname):\n400             if not filename.startswith('.'):\n401                 copy_asset_file(path.join(staticdirname, filename),\n402                                 self.outdir, context=context)\n403 \n404         # use pre-1.6.x Makefile for make latexpdf on Windows\n405         if os.name == 'nt':\n406             staticdirname = path.join(package_dir, 'texinputs_win')\n407             copy_asset_file(path.join(staticdirname, 'Makefile_t'),\n408                             self.outdir, context=context)\n409 \n410     @progress_message(__('copying additional files'))\n411     def copy_latex_additional_files(self) -> None:\n412         for filename in self.config.latex_additional_files:\n413             logger.info(' ' + filename, nonl=True)\n414             copy_asset_file(path.join(self.confdir, filename), self.outdir)\n415 \n416     def copy_image_files(self) -> None:\n417         if self.images:\n418             stringify_func = ImageAdapter(self.app.env).get_original_image_uri\n419             for src in status_iterator(self.images, __('copying images... '), \"brown\",\n420                                        len(self.images), self.app.verbosity,\n421                                        stringify_func=stringify_func):\n422                 dest = self.images[src]\n423                 try:\n424                     copy_asset_file(path.join(self.srcdir, src),\n425                                     path.join(self.outdir, dest))\n426                 except Exception as err:\n427                     logger.warning(__('cannot copy image file %r: %s'),\n428                                    path.join(self.srcdir, src), err)\n429         if self.config.latex_logo:\n430             if not path.isfile(path.join(self.confdir, self.config.latex_logo)):\n431                 raise SphinxError(__('logo file %r does not exist') % self.config.latex_logo)\n432             else:\n433                 copy_asset_file(path.join(self.confdir, self.config.latex_logo), self.outdir)\n434 \n435     def write_message_catalog(self) -> None:\n436         formats = self.config.numfig_format\n437         context = {\n438             'addtocaptions': r'\\@iden',\n439             'figurename': formats.get('figure', '').split('%s', 1),\n440             'tablename': formats.get('table', '').split('%s', 1),\n441             'literalblockname': formats.get('code-block', '').split('%s', 1)\n442         }\n443 \n444         if self.context['babel'] or self.context['polyglossia']:\n445             context['addtocaptions'] = r'\\addto\\captions%s' % self.babel.get_language()\n446 \n447         filename = path.join(package_dir, 'templates', 'latex', 'sphinxmessages.sty_t')\n448         copy_asset_file(filename, self.outdir, context=context, renderer=LaTeXRenderer())\n",
        "intended_behavior": "This class provides additional context to the issue."
    }
]