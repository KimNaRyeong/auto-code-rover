[
    {
        "rel_file_path": "src/_pytest/logging.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/pytest-dev__pytest/setup_pytest-dev__pytest__6.3/src/_pytest/logging.py",
        "start": 49,
        "end": 92,
        "class_name": "ColoredLevelFormatter",
        "method_name": null,
        "code": "49 class ColoredLevelFormatter(logging.Formatter):\n50     \"\"\"A logging formatter which colorizes the %(levelname)..s part of the\n51     log format passed to __init__.\"\"\"\n52 \n53     LOGLEVEL_COLOROPTS: Mapping[int, AbstractSet[str]] = {\n54         logging.CRITICAL: {\"red\"},\n55         logging.ERROR: {\"red\", \"bold\"},\n56         logging.WARNING: {\"yellow\"},\n57         logging.WARN: {\"yellow\"},\n58         logging.INFO: {\"green\"},\n59         logging.DEBUG: {\"purple\"},\n60         logging.NOTSET: set(),\n61     }\n62     LEVELNAME_FMT_REGEX = re.compile(r\"%\\(levelname\\)([+-.]?\\d*s)\")\n63 \n64     def __init__(self, terminalwriter: TerminalWriter, *args, **kwargs) -> None:\n65         super().__init__(*args, **kwargs)\n66         self._original_fmt = self._style._fmt\n67         self._level_to_fmt_mapping: Dict[int, str] = {}\n68 \n69         assert self._fmt is not None\n70         levelname_fmt_match = self.LEVELNAME_FMT_REGEX.search(self._fmt)\n71         if not levelname_fmt_match:\n72             return\n73         levelname_fmt = levelname_fmt_match.group()\n74 \n75         for level, color_opts in self.LOGLEVEL_COLOROPTS.items():\n76             formatted_levelname = levelname_fmt % {\n77                 \"levelname\": logging.getLevelName(level)\n78             }\n79 \n80             # add ANSI escape sequences around the formatted levelname\n81             color_kwargs = {name: True for name in color_opts}\n82             colorized_formatted_levelname = terminalwriter.markup(\n83                 formatted_levelname, **color_kwargs\n84             )\n85             self._level_to_fmt_mapping[level] = self.LEVELNAME_FMT_REGEX.sub(\n86                 colorized_formatted_levelname, self._fmt\n87             )\n88 \n89     def format(self, record: logging.LogRecord) -> str:\n90         fmt = self._level_to_fmt_mapping.get(record.levelno, self._original_fmt)\n91         self._style._fmt = fmt\n92         return super().format(record)\n",
        "intended_behavior": "To address the issue detailed\u2014the failure of 'ColoredLevelFormatter' to correctly apply color output when the log format string includes a precision-formatted 'levelname'\u2014the behavior of how 'LEVELNAME_FMT_REGEX' is defined or utilized needs modification. This is not tied to a specific method identified through the search but rather to how the regex pattern is constructed or the logic preceding the use of 'format' method where this regex is applied. The intended behavior should allow the 'LEVELNAME_FMT_REGEX' to successfully match 'levelname' placeholders in the log format strings even when they contain precision specifiers. This means enhancing 'LEVELNAME_FMT_REGEX' to account for optional precision bits in the format strings. Doing so would necessitate: Updating 'LEVELNAME_FMT_REGEX' to correctly identify placeholders that include precision along with width and alignment specifiers. Ensuring any pre-formatting logic that uses 'LEVELNAME_FMT_REGEX' to identify 'levelname' for styling or other purposes can handle these more complex placeholders without failing or ignoring the precision part. These changes should be carefully applied to ensure that existing functionality for format strings without precision specifiers remains unaffected, preserving backward compatibility and maintaining the utility of the 'ColoredLevelFormatter' across various logging scenarios."
    }
]