2025-10-18 14:14:06.845 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-18 14:14:12.298 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=349, output_tokens=12, cost=0.003850
2025-10-18 14:14:24.618 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=529, output_tokens=538, cost=0.021430
2025-10-18 14:14:26.135 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 14:14:34.795 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=655, output_tokens=354, cost=0.017170
2025-10-18 14:14:34.800 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 14:14:38.094 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=708, output_tokens=82, cost=0.009540
2025-10-18 14:14:38.095 | DEBUG    | Extracted a valid json.
2025-10-18 14:14:38.096 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_class(\"Figure\")",
        "search_class(\"Subplot\")",
        "search_method_in_class(\"suptitle\", \"Figure\")",
        "search_method_in_class(\"set_title\", \"Axes\")",
        "search_method(\"get_tightbbox\")",
        "search_code(\"wrap=True\")"
    ],
    "bug_locations": []
}
2025-10-18 14:14:38.157 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-18 14:14:38.157 | DEBUG    | <Agent search> Analyzing search results.
2025-10-18 14:14:57.519 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=3080, output_tokens=967, cost=0.059810
2025-10-18 14:14:57.529 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 14:15:09.056 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=4263, output_tokens=501, cost=0.057660
2025-10-18 14:15:09.061 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 14:15:15.515 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=855, output_tokens=198, cost=0.014490
2025-10-18 14:15:15.515 | DEBUG    | Extracted a valid json.
2025-10-18 14:15:15.515 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "lib/matplotlib/figure.py",
            "class": "Figure",
            "method": "",
            "intended_behavior": "The constrained layout system within the Figure class might need updates or adjustments to better account for wrapped text in titles. This might involve implementing a more dynamic calculation of bounding boxes for titles when wrap=True is set, ensuring that ample space is automatically allocated to prevent overlap and ensure visibility."
        },
        {
            "file": "lib/matplotlib/axes/_axes.py",
            "class": "Axes",
            "method": "set_title",
            "intended_behavior": "This method should ensure that when a title is set with wrap=True, the height calculation for the wrapped title is accurately communicated to the layout engine. This may require extending the functionality to better notify the constrained layout engine of the adjusted size necessary for the wrapped text."
        }
    ]
}
2025-10-18 14:15:15.532 | DEBUG    | Bug location extracted successfully: [<file>lib/matplotlib/figure.py</file>
<class>Figure</class>
<method>None</method>
<code>
2334 class Figure(FigureBase):
2335     """
2336     The top level container for all the plot elements.
2337 
2338     Attributes
2339     ----------
2340     patch
2341         The `.Rectangle` instance representing the figure background patch.
2342 
2343     suppressComposite
2344         For multiple images, the figure will make composite images
2345         depending on the renderer option_image_nocomposite function.  If
2346         *suppressComposite* is a boolean, this will override the renderer.
2347     """
2348     # Remove the self._fig_callbacks properties on figure and subfigure
2349     # after the deprecation expires.
2350     callbacks = _api.deprecated(
2351         "3.6", alternative=("the 'resize_event' signal in "
2352                             "Figure.canvas.callbacks")
2353         )(property(lambda self: self._fig_callbacks))
2354 
2355     def __str__(self):
2356         return "Figure(%gx%g)" % tuple(self.bbox.size)
2357 
2358     def __repr__(self):
2359         return "<{clsname} size {h:g}x{w:g} with {naxes} Axes>".format(
2360             clsname=self.__class__.__name__,
2361             h=self.bbox.size[0], w=self.bbox.size[1],
2362             naxes=len(self.axes),
2363         )
2364 
2365     @_api.make_keyword_only("3.6", "facecolor")
2366     def __init__(self,
2367                  figsize=None,
2368                  dpi=None,
2369                  facecolor=None,
2370                  edgecolor=None,
2371                  linewidth=0.0,
2372                  frameon=None,
2373                  subplotpars=None,  # rc figure.subplot.*
2374                  tight_layout=None,  # rc figure.autolayout
2375                  constrained_layout=None,  # rc figure.constrained_layout.use
2376                  *,
2377                  layout=None,
2378                  **kwargs
2379                  ):
2380         """
2381         Parameters
2382         ----------
2383         figsize : 2-tuple of floats, default: :rc:`figure.figsize`
2384             Figure dimension ``(width, height)`` in inches.
2385 
2386         dpi : float, default: :rc:`figure.dpi`
2387             Dots per inch.
2388 
2389         facecolor : default: :rc:`figure.facecolor`
2390             The figure patch facecolor.
2391 
2392         edgecolor : default: :rc:`figure.edgecolor`
2393             The figure patch edge color.
2394 
2395         linewidth : float
2396             The linewidth of the frame (i.e. the edge linewidth of the figure
2397             patch).
2398 
2399         frameon : bool, default: :rc:`figure.frameon`
2400             If ``False``, suppress drawing the figure background patch.
2401 
2402         subplotpars : `SubplotParams`
2403             Subplot parameters. If not given, the default subplot
2404             parameters :rc:`figure.subplot.*` are used.
2405 
2406         tight_layout : bool or dict, default: :rc:`figure.autolayout`
2407             Whether to use the tight layout mechanism. See `.set_tight_layout`.
2408 
2409             .. admonition:: Discouraged
2410 
2411                 The use of this parameter is discouraged. Please use
2412                 ``layout='tight'`` instead for the common case of
2413                 ``tight_layout=True`` and use `.set_tight_layout` otherwise.
2414 
2415         constrained_layout : bool, default: :rc:`figure.constrained_layout.use`
2416             This is equal to ``layout='constrained'``.
2417 
2418             .. admonition:: Discouraged
2419 
2420                 The use of this parameter is discouraged. Please use
2421                 ``layout='constrained'`` instead.
2422 
2423         layout : {'constrained', 'compressed', 'tight', 'none', `.LayoutEngine`, \
2424 None}, default: None
2425             The layout mechanism for positioning of plot elements to avoid
2426             overlapping Axes decorations (labels, ticks, etc). Note that
2427             layout managers can have significant performance penalties.
2428 
2429             - 'constrained': The constrained layout solver adjusts axes sizes
2430               to avoid overlapping axes decorations.  Can handle complex plot
2431               layouts and colorbars, and is thus recommended.
2432 
2433               See :doc:`/tutorials/intermediate/constrainedlayout_guide`
2434               for examples.
2435 
2436             - 'compressed': uses the same algorithm as 'constrained', but
2437               removes extra space between fixed-aspect-ratio Axes.  Best for
2438               simple grids of axes.
2439 
2440             - 'tight': Use the tight layout mechanism. This is a relatively
2441               simple algorithm that adjusts the subplot parameters so that
2442               decorations do not overlap. See `.Figure.set_tight_layout` for
2443               further details.
2444 
2445             - 'none': Do not use a layout engine.
2446 
2447             - A `.LayoutEngine` instance. Builtin layout classes are
2448               `.ConstrainedLayoutEngine` and `.TightLayoutEngine`, more easily
2449               accessible by 'constrained' and 'tight'.  Passing an instance
2450               allows third parties to provide their own layout engine.
2451 
2452             If not given, fall back to using the parameters *tight_layout* and
2453             *constrained_layout*, including their config defaults
2454             :rc:`figure.autolayout` and :rc:`figure.constrained_layout.use`.
2455 
2456         Other Parameters
2457         ----------------
2458         **kwargs : `.Figure` properties, optional
2459 
2460             %(Figure:kwdoc)s
2461         """
2462         super().__init__(**kwargs)
2463         self._layout_engine = None
2464 
2465         if layout is not None:
2466             if (tight_layout is not None):
2467                 _api.warn_external(
2468                     "The Figure parameters 'layout' and 'tight_layout' cannot "
2469                     "be used together. Please use 'layout' only.")
2470             if (constrained_layout is not None):
2471                 _api.warn_external(
2472                     "The Figure parameters 'layout' and 'constrained_layout' "
2473                     "cannot be used together. Please use 'layout' only.")
2474             self.set_layout_engine(layout=layout)
2475         elif tight_layout is not None:
2476             if constrained_layout is not None:
2477                 _api.warn_external(
2478                     "The Figure parameters 'tight_layout' and "
2479                     "'constrained_layout' cannot be used together. Please use "
2480                     "'layout' parameter")
2481             self.set_layout_engine(layout='tight')
2482             if isinstance(tight_layout, dict):
2483                 self.get_layout_engine().set(**tight_layout)
2484         elif constrained_layout is not None:
2485             if isinstance(constrained_layout, dict):
2486                 self.set_layout_engine(layout='constrained')
2487                 self.get_layout_engine().set(**constrained_layout)
2488             elif constrained_layout:
2489                 self.set_layout_engine(layout='constrained')
2490 
2491         else:
2492             # everything is None, so use default:
2493             self.set_layout_engine(layout=layout)
2494 
2495         self._fig_callbacks = cbook.CallbackRegistry(signals=["dpi_changed"])
2496         # Callbacks traditionally associated with the canvas (and exposed with
2497         # a proxy property), but that actually need to be on the figure for
2498         # pickling.
2499         self._canvas_callbacks = cbook.CallbackRegistry(
2500             signals=FigureCanvasBase.events)
2501         connect = self._canvas_callbacks._connect_picklable
2502         self._mouse_key_ids = [
2503             connect('key_press_event', backend_bases._key_handler),
2504             connect('key_release_event', backend_bases._key_handler),
2505             connect('key_release_event', backend_bases._key_handler),
2506             connect('button_press_event', backend_bases._mouse_handler),
2507             connect('button_release_event', backend_bases._mouse_handler),
2508             connect('scroll_event', backend_bases._mouse_handler),
2509             connect('motion_notify_event', backend_bases._mouse_handler),
2510         ]
2511         self._button_pick_id = connect('button_press_event', self.pick)
2512         self._scroll_pick_id = connect('scroll_event', self.pick)
2513 
2514         if figsize is None:
2515             figsize = mpl.rcParams['figure.figsize']
2516         if dpi is None:
2517             dpi = mpl.rcParams['figure.dpi']
2518         if facecolor is None:
2519             facecolor = mpl.rcParams['figure.facecolor']
2520         if edgecolor is None:
2521             edgecolor = mpl.rcParams['figure.edgecolor']
2522         if frameon is None:
2523             frameon = mpl.rcParams['figure.frameon']
2524 
2525         if not np.isfinite(figsize).all() or (np.array(figsize) < 0).any():
2526             raise ValueError('figure size must be positive finite not '
2527                              f'{figsize}')
2528         self.bbox_inches = Bbox.from_bounds(0, 0, *figsize)
2529 
2530         self.dpi_scale_trans = Affine2D().scale(dpi)
2531         # do not use property as it will trigger
2532         self._dpi = dpi
2533         self.bbox = TransformedBbox(self.bbox_inches, self.dpi_scale_trans)
2534         self.figbbox = self.bbox
2535         self.transFigure = BboxTransformTo(self.bbox)
2536         self.transSubfigure = self.transFigure
2537 
2538         self.patch = Rectangle(
2539             xy=(0, 0), width=1, height=1, visible=frameon,
2540             facecolor=facecolor, edgecolor=edgecolor, linewidth=linewidth,
2541             # Don't let the figure patch influence bbox calculation.
2542             in_layout=False)
2543         self._set_artist_props(self.patch)
2544         self.patch.set_antialiased(False)
2545 
2546         FigureCanvasBase(self)  # Set self.canvas.
2547 
2548         if subplotpars is None:
2549             subplotpars = SubplotParams()
2550 
2551         self.subplotpars = subplotpars
2552 
2553         self._axstack = _AxesStack()  # track all figure axes and current axes
2554         self.clear()
2555 
2556     def pick(self, mouseevent):
2557         if not self.canvas.widgetlock.locked():
2558             super().pick(mouseevent)
2559 
2560     def _check_layout_engines_compat(self, old, new):
2561         """
2562         Helper for set_layout engine
2563 
2564         If the figure has used the old engine and added a colorbar then the
2565         value of colorbar_gridspec must be the same on the new engine.
2566         """
2567         if old is None or new is None:
2568             return True
2569         if old.colorbar_gridspec == new.colorbar_gridspec:
2570             return True
2571         # colorbar layout different, so check if any colorbars are on the
2572         # figure...
2573         for ax in self.axes:
2574             if hasattr(ax, '_colorbar'):
2575                 # colorbars list themselves as a colorbar.
2576                 return False
2577         return True
2578 
2579     def set_layout_engine(self, layout=None, **kwargs):
2580         """
2581         Set the layout engine for this figure.
2582 
2583         Parameters
2584         ----------
2585         layout: {'constrained', 'compressed', 'tight', 'none'} or \
2586 `LayoutEngine` or None
2587 
2588             - 'constrained' will use `~.ConstrainedLayoutEngine`
2589             - 'compressed' will also use `~.ConstrainedLayoutEngine`, but with
2590               a correction that attempts to make a good layout for fixed-aspect
2591               ratio Axes.
2592             - 'tight' uses `~.TightLayoutEngine`
2593             - 'none' removes layout engine.
2594 
2595             If `None`, the behavior is controlled by :rc:`figure.autolayout`
2596             (which if `True` behaves as if 'tight' was passed) and
2597             :rc:`figure.constrained_layout.use` (which if `True` behaves as if
2598             'constrained' was passed).  If both are `True`,
2599             :rc:`figure.autolayout` takes priority.
2600 
2601             Users and libraries can define their own layout engines and pass
2602             the instance directly as well.
2603 
2604         kwargs: dict
2605             The keyword arguments are passed to the layout engine to set things
2606             like padding and margin sizes.  Only used if *layout* is a string.
2607 
2608         """
2609         if layout is None:
2610             if mpl.rcParams['figure.autolayout']:
2611                 layout = 'tight'
2612             elif mpl.rcParams['figure.constrained_layout.use']:
2613                 layout = 'constrained'
2614             else:
2615                 self._layout_engine = None
2616                 return
2617         if layout == 'tight':
2618             new_layout_engine = TightLayoutEngine(**kwargs)
2619         elif layout == 'constrained':
2620             new_layout_engine = ConstrainedLayoutEngine(**kwargs)
2621         elif layout == 'compressed':
2622             new_layout_engine = ConstrainedLayoutEngine(compress=True,
2623                                                         **kwargs)
2624         elif layout == 'none':
2625             if self._layout_engine is not None:
2626                 new_layout_engine = PlaceHolderLayoutEngine(
2627                     self._layout_engine.adjust_compatible,
2628                     self._layout_engine.colorbar_gridspec
2629                 )
2630             else:
2631                 new_layout_engine = None
2632         elif isinstance(layout, LayoutEngine):
2633             new_layout_engine = layout
2634         else:
2635             raise ValueError(f"Invalid value for 'layout': {layout!r}")
2636 
2637         if self._check_layout_engines_compat(self._layout_engine,
2638                                              new_layout_engine):
2639             self._layout_engine = new_layout_engine
2640         else:
2641             raise RuntimeError('Colorbar layout of new layout engine not '
2642                                'compatible with old engine, and a colorbar '
2643                                'has been created.  Engine not changed.')
2644 
2645     def get_layout_engine(self):
2646         return self._layout_engine
2647 
2648     # TODO: I'd like to dynamically add the _repr_html_ method
2649     # to the figure in the right context, but then IPython doesn't
2650     # use it, for some reason.
2651 
2652     def _repr_html_(self):
2653         # We can't use "isinstance" here, because then we'd end up importing
2654         # webagg unconditionally.
2655         if 'WebAgg' in type(self.canvas).__name__:
2656             from matplotlib.backends import backend_webagg
2657             return backend_webagg.ipython_inline_display(self)
2658 
2659     def show(self, warn=True):
2660         """
2661         If using a GUI backend with pyplot, display the figure window.
2662 
2663         If the figure was not created using `~.pyplot.figure`, it will lack
2664         a `~.backend_bases.FigureManagerBase`, and this method will raise an
2665         AttributeError.
2666 
2667         .. warning::
2668 
2669             This does not manage an GUI event loop. Consequently, the figure
2670             may only be shown briefly or not shown at all if you or your
2671             environment are not managing an event loop.
2672 
2673             Use cases for `.Figure.show` include running this from a GUI
2674             application (where there is persistently an event loop running) or
2675             from a shell, like IPython, that install an input hook to allow the
2676             interactive shell to accept input while the figure is also being
2677             shown and interactive.  Some, but not all, GUI toolkits will
2678             register an input hook on import.  See :ref:`cp_integration` for
2679             more details.
2680 
2681             If you're in a shell without input hook integration or executing a
2682             python script, you should use `matplotlib.pyplot.show` with
2683             ``block=True`` instead, which takes care of starting and running
2684             the event loop for you.
2685 
2686         Parameters
2687         ----------
2688         warn : bool, default: True
2689             If ``True`` and we are not running headless (i.e. on Linux with an
2690             unset DISPLAY), issue warning when called on a non-GUI backend.
2691 
2692         """
2693         if self.canvas.manager is None:
2694             raise AttributeError(
2695                 "Figure.show works only for figures managed by pyplot, "
2696                 "normally created by pyplot.figure()")
2697         try:
2698             self.canvas.manager.show()
2699         except NonGuiException as exc:
2700             if warn:
2701                 _api.warn_external(str(exc))
2702 
2703     @property
2704     def axes(self):
2705         """
2706         List of Axes in the Figure. You can access and modify the Axes in the
2707         Figure through this list.
2708 
2709         Do not modify the list itself. Instead, use `~Figure.add_axes`,
2710         `~.Figure.add_subplot` or `~.Figure.delaxes` to add or remove an Axes.
2711 
2712         Note: The `.Figure.axes` property and `~.Figure.get_axes` method are
2713         equivalent.
2714         """
2715         return self._axstack.as_list()
2716 
2717     get_axes = axes.fget
2718 
2719     def _get_renderer(self):
2720         if hasattr(self.canvas, 'get_renderer'):
2721             return self.canvas.get_renderer()
2722         else:
2723             return _get_renderer(self)
2724 
2725     def _get_dpi(self):
2726         return self._dpi
2727 
2728     def _set_dpi(self, dpi, forward=True):
2729         """
2730         Parameters
2731         ----------
2732         dpi : float
2733 
2734         forward : bool
2735             Passed on to `~.Figure.set_size_inches`
2736         """
2737         if dpi == self._dpi:
2738             # We don't want to cause undue events in backends.
2739             return
2740         self._dpi = dpi
2741         self.dpi_scale_trans.clear().scale(dpi)
2742         w, h = self.get_size_inches()
2743         self.set_size_inches(w, h, forward=forward)
2744         self._fig_callbacks.process('dpi_changed', self)
2745 
2746     dpi = property(_get_dpi, _set_dpi, doc="The resolution in dots per inch.")
2747 
2748     def get_tight_layout(self):
2749         """Return whether `.tight_layout` is called when drawing."""
2750         return isinstance(self.get_layout_engine(), TightLayoutEngine)
2751 
2752     @_api.deprecated("3.6", alternative="set_layout_engine",
2753                      pending=True)
2754     def set_tight_layout(self, tight):
2755         """
2756         [*Discouraged*] Set whether and how `.tight_layout` is called when
2757         drawing.
2758 
2759         .. admonition:: Discouraged
2760 
2761             This method is discouraged in favor of `~.set_layout_engine`.
2762 
2763         Parameters
2764         ----------
2765         tight : bool or dict with keys "pad", "w_pad", "h_pad", "rect" or None
2766             If a bool, sets whether to call `.tight_layout` upon drawing.
2767             If ``None``, use :rc:`figure.autolayout` instead.
2768             If a dict, pass it as kwargs to `.tight_layout`, overriding the
2769             default paddings.
2770         """
2771         if tight is None:
2772             tight = mpl.rcParams['figure.autolayout']
2773         _tight = 'tight' if bool(tight) else 'none'
2774         _tight_parameters = tight if isinstance(tight, dict) else {}
2775         self.set_layout_engine(_tight, **_tight_parameters)
2776         self.stale = True
2777 
2778     def get_constrained_layout(self):
2779         """
2780         Return whether constrained layout is being used.
2781 
2782         See :doc:`/tutorials/intermediate/constrainedlayout_guide`.
2783         """
2784         return isinstance(self.get_layout_engine(), ConstrainedLayoutEngine)
2785 
2786     @_api.deprecated("3.6", alternative="set_layout_engine('constrained')",
2787                      pending=True)
2788     def set_constrained_layout(self, constrained):
2789         """
2790         [*Discouraged*] Set whether ``constrained_layout`` is used upon
2791         drawing.
2792 
2793         If None, :rc:`figure.constrained_layout.use` value will be used.
2794 
2795         When providing a dict containing the keys ``w_pad``, ``h_pad``
2796         the default ``constrained_layout`` paddings will be
2797         overridden.  These pads are in inches and default to 3.0/72.0.
2798         ``w_pad`` is the width padding and ``h_pad`` is the height padding.
2799 
2800         .. admonition:: Discouraged
2801 
2802             This method is discouraged in favor of `~.set_layout_engine`.
2803 
2804         Parameters
2805         ----------
2806         constrained : bool or dict or None
2807         """
2808         if constrained is None:
2809             constrained = mpl.rcParams['figure.constrained_layout.use']
2810         _constrained = 'constrained' if bool(constrained) else 'none'
2811         _parameters = constrained if isinstance(constrained, dict) else {}
2812         self.set_layout_engine(_constrained, **_parameters)
2813         self.stale = True
2814 
2815     @_api.deprecated(
2816          "3.6", alternative="figure.get_layout_engine().set()",
2817          pending=True)
2818     def set_constrained_layout_pads(self, **kwargs):
2819         """
2820         Set padding for ``constrained_layout``.
2821 
2822         Tip: The parameters can be passed from a dictionary by using
2823         ``fig.set_constrained_layout(**pad_dict)``.
2824 
2825         See :doc:`/tutorials/intermediate/constrainedlayout_guide`.
2826 
2827         Parameters
2828         ----------
2829         w_pad : float, default: :rc:`figure.constrained_layout.w_pad`
2830             Width padding in inches.  This is the pad around Axes
2831             and is meant to make sure there is enough room for fonts to
2832             look good.  Defaults to 3 pts = 0.04167 inches
2833 
2834         h_pad : float, default: :rc:`figure.constrained_layout.h_pad`
2835             Height padding in inches. Defaults to 3 pts.
2836 
2837         wspace : float, default: :rc:`figure.constrained_layout.wspace`
2838             Width padding between subplots, expressed as a fraction of the
2839             subplot width.  The total padding ends up being w_pad + wspace.
2840 
2841         hspace : float, default: :rc:`figure.constrained_layout.hspace`
2842             Height padding between subplots, expressed as a fraction of the
2843             subplot width. The total padding ends up being h_pad + hspace.
2844 
2845         """
2846         if isinstance(self.get_layout_engine(), ConstrainedLayoutEngine):
2847             self.get_layout_engine().set(**kwargs)
2848 
2849     @_api.deprecated("3.6", alternative="fig.get_layout_engine().get()",
2850                      pending=True)
2851     def get_constrained_layout_pads(self, relative=False):
2852         """
2853         Get padding for ``constrained_layout``.
2854 
2855         Returns a list of ``w_pad, h_pad`` in inches and
2856         ``wspace`` and ``hspace`` as fractions of the subplot.
2857         All values are None if ``constrained_layout`` is not used.
2858 
2859         See :doc:`/tutorials/intermediate/constrainedlayout_guide`.
2860 
2861         Parameters
2862         ----------
2863         relative : bool
2864             If `True`, then convert from inches to figure relative.
2865         """
2866         if not isinstance(self.get_layout_engine(), ConstrainedLayoutEngine):
2867             return None, None, None, None
2868         info = self.get_layout_engine().get_info()
2869         w_pad = info['w_pad']
2870         h_pad = info['h_pad']
2871         wspace = info['wspace']
2872         hspace = info['hspace']
2873 
2874         if relative and (w_pad is not None or h_pad is not None):
2875             renderer = self._get_renderer()
2876             dpi = renderer.dpi
2877             w_pad = w_pad * dpi / renderer.width
2878             h_pad = h_pad * dpi / renderer.height
2879 
2880         return w_pad, h_pad, wspace, hspace
2881 
2882     def set_canvas(self, canvas):
2883         """
2884         Set the canvas that contains the figure
2885 
2886         Parameters
2887         ----------
2888         canvas : FigureCanvas
2889         """
2890         self.canvas = canvas
2891 
2892     @_docstring.interpd
2893     def figimage(self, X, xo=0, yo=0, alpha=None, norm=None, cmap=None,
2894                  vmin=None, vmax=None, origin=None, resize=False, **kwargs):
2895         """
2896         Add a non-resampled image to the figure.
2897 
2898         The image is attached to the lower or upper left corner depending on
2899         *origin*.
2900 
2901         Parameters
2902         ----------
2903         X
2904             The image data. This is an array of one of the following shapes:
2905 
2906             - (M, N): an image with scalar data.  Color-mapping is controlled
2907               by *cmap*, *norm*, *vmin*, and *vmax*.
2908             - (M, N, 3): an image with RGB values (0-1 float or 0-255 int).
2909             - (M, N, 4): an image with RGBA values (0-1 float or 0-255 int),
2910               i.e. including transparency.
2911 
2912         xo, yo : int
2913             The *x*/*y* image offset in pixels.
2914 
2915         alpha : None or float
2916             The alpha blending value.
2917 
2918         %(cmap_doc)s
2919 
2920             This parameter is ignored if *X* is RGB(A).
2921 
2922         %(norm_doc)s
2923 
2924             This parameter is ignored if *X* is RGB(A).
2925 
2926         %(vmin_vmax_doc)s
2927 
2928             This parameter is ignored if *X* is RGB(A).
2929 
2930         origin : {'upper', 'lower'}, default: :rc:`image.origin`
2931             Indicates where the [0, 0] index of the array is in the upper left
2932             or lower left corner of the axes.
2933 
2934         resize : bool
2935             If *True*, resize the figure to match the given image size.
2936 
2937         Returns
2938         -------
2939         `matplotlib.image.FigureImage`
2940 
2941         Other Parameters
2942         ----------------
2943         **kwargs
2944             Additional kwargs are `.Artist` kwargs passed on to `.FigureImage`.
2945 
2946         Notes
2947         -----
2948         figimage complements the Axes image (`~matplotlib.axes.Axes.imshow`)
2949         which will be resampled to fit the current Axes.  If you want
2950         a resampled image to fill the entire figure, you can define an
2951         `~matplotlib.axes.Axes` with extent [0, 0, 1, 1].
2952 
2953         Examples
2954         --------
2955         ::
2956 
2957             f = plt.figure()
2958             nx = int(f.get_figwidth() * f.dpi)
2959             ny = int(f.get_figheight() * f.dpi)
2960             data = np.random.random((ny, nx))
2961             f.figimage(data)
2962             plt.show()
2963         """
2964         if resize:
2965             dpi = self.get_dpi()
2966             figsize = [x / dpi for x in (X.shape[1], X.shape[0])]
2967             self.set_size_inches(figsize, forward=True)
2968 
2969         im = mimage.FigureImage(self, cmap=cmap, norm=norm,
2970                                 offsetx=xo, offsety=yo,
2971                                 origin=origin, **kwargs)
2972         im.stale_callback = _stale_figure_callback
2973 
2974         im.set_array(X)
2975         im.set_alpha(alpha)
2976         if norm is None:
2977             im.set_clim(vmin, vmax)
2978         self.images.append(im)
2979         im._remove_method = self.images.remove
2980         self.stale = True
2981         return im
2982 
2983     def set_size_inches(self, w, h=None, forward=True):
2984         """
2985         Set the figure size in inches.
2986 
2987         Call signatures::
2988 
2989              fig.set_size_inches(w, h)  # OR
2990              fig.set_size_inches((w, h))
2991 
2992         Parameters
2993         ----------
2994         w : (float, float) or float
2995             Width and height in inches (if height not specified as a separate
2996             argument) or width.
2997         h : float
2998             Height in inches.
2999         forward : bool, default: True
3000             If ``True``, the canvas size is automatically updated, e.g.,
3001             you can resize the figure window from the shell.
3002 
3003         See Also
3004         --------
3005         matplotlib.figure.Figure.get_size_inches
3006         matplotlib.figure.Figure.set_figwidth
3007         matplotlib.figure.Figure.set_figheight
3008 
3009         Notes
3010         -----
3011         To transform from pixels to inches divide by `Figure.dpi`.
3012         """
3013         if h is None:  # Got called with a single pair as argument.
3014             w, h = w
3015         size = np.array([w, h])
3016         if not np.isfinite(size).all() or (size < 0).any():
3017             raise ValueError(f'figure size must be positive finite not {size}')
3018         self.bbox_inches.p1 = size
3019         if forward:
3020             manager = self.canvas.manager
3021             if manager is not None:
3022                 manager.resize(*(size * self.dpi).astype(int))
3023         self.stale = True
3024 
3025     def get_size_inches(self):
3026         """
3027         Return the current size of the figure in inches.
3028 
3029         Returns
3030         -------
3031         ndarray
3032            The size (width, height) of the figure in inches.
3033 
3034         See Also
3035         --------
3036         matplotlib.figure.Figure.set_size_inches
3037         matplotlib.figure.Figure.get_figwidth
3038         matplotlib.figure.Figure.get_figheight
3039 
3040         Notes
3041         -----
3042         The size in pixels can be obtained by multiplying with `Figure.dpi`.
3043         """
3044         return np.array(self.bbox_inches.p1)
3045 
3046     def get_figwidth(self):
3047         """Return the figure width in inches."""
3048         return self.bbox_inches.width
3049 
3050     def get_figheight(self):
3051         """Return the figure height in inches."""
3052         return self.bbox_inches.height
3053 
3054     def get_dpi(self):
3055         """Return the resolution in dots per inch as a float."""
3056         return self.dpi
3057 
3058     def set_dpi(self, val):
3059         """
3060         Set the resolution of the figure in dots-per-inch.
3061 
3062         Parameters
3063         ----------
3064         val : float
3065         """
3066         self.dpi = val
3067         self.stale = True
3068 
3069     def set_figwidth(self, val, forward=True):
3070         """
3071         Set the width of the figure in inches.
3072 
3073         Parameters
3074         ----------
3075         val : float
3076         forward : bool
3077             See `set_size_inches`.
3078 
3079         See Also
3080         --------
3081         matplotlib.figure.Figure.set_figheight
3082         matplotlib.figure.Figure.set_size_inches
3083         """
3084         self.set_size_inches(val, self.get_figheight(), forward=forward)
3085 
3086     def set_figheight(self, val, forward=True):
3087         """
3088         Set the height of the figure in inches.
3089 
3090         Parameters
3091         ----------
3092         val : float
3093         forward : bool
3094             See `set_size_inches`.
3095 
3096         See Also
3097         --------
3098         matplotlib.figure.Figure.set_figwidth
3099         matplotlib.figure.Figure.set_size_inches
3100         """
3101         self.set_size_inches(self.get_figwidth(), val, forward=forward)
3102 
3103     def clear(self, keep_observers=False):
3104         # docstring inherited
3105         super().clear(keep_observers=keep_observers)
3106         # FigureBase.clear does not clear toolbars, as
3107         # only Figure can have toolbars
3108         toolbar = self.canvas.toolbar
3109         if toolbar is not None:
3110             toolbar.update()
3111 
3112     @_finalize_rasterization
3113     @allow_rasterization
3114     def draw(self, renderer):
3115         # docstring inherited
3116 
3117         # draw the figure bounding box, perhaps none for white figure
3118         if not self.get_visible():
3119             return
3120 
3121         artists = self._get_draw_artists(renderer)
3122         try:
3123             renderer.open_group('figure', gid=self.get_gid())
3124             if self.axes and self.get_layout_engine() is not None:
3125                 try:
3126                     self.get_layout_engine().execute(self)
3127                 except ValueError:
3128                     pass
3129                     # ValueError can occur when resizing a window.
3130 
3131             self.patch.draw(renderer)
3132             mimage._draw_list_compositing_images(
3133                 renderer, self, artists, self.suppressComposite)
3134 
3135             for sfig in self.subfigs:
3136                 sfig.draw(renderer)
3137 
3138             renderer.close_group('figure')
3139         finally:
3140             self.stale = False
3141 
3142         DrawEvent("draw_event", self.canvas, renderer)._process()
3143 
3144     def draw_without_rendering(self):
3145         """
3146         Draw the figure with no output.  Useful to get the final size of
3147         artists that require a draw before their size is known (e.g. text).
3148         """
3149         renderer = _get_renderer(self)
3150         with renderer._draw_disabled():
3151             self.draw(renderer)
3152 
3153     def draw_artist(self, a):
3154         """
3155         Draw `.Artist` *a* only.
3156         """
3157         a.draw(self.canvas.get_renderer())
3158 
3159     def __getstate__(self):
3160         state = super().__getstate__()
3161 
3162         # The canvas cannot currently be pickled, but this has the benefit
3163         # of meaning that a figure can be detached from one canvas, and
3164         # re-attached to another.
3165         state.pop("canvas")
3166 
3167         # discard any changes to the dpi due to pixel ratio changes
3168         state["_dpi"] = state.get('_original_dpi', state['_dpi'])
3169 
3170         # add version information to the state
3171         state['__mpl_version__'] = mpl.__version__
3172 
3173         # check whether the figure manager (if any) is registered with pyplot
3174         from matplotlib import _pylab_helpers
3175         if self.canvas.manager in _pylab_helpers.Gcf.figs.values():
3176             state['_restore_to_pylab'] = True
3177         return state
3178 
3179     def __setstate__(self, state):
3180         version = state.pop('__mpl_version__')
3181         restore_to_pylab = state.pop('_restore_to_pylab', False)
3182 
3183         if version != mpl.__version__:
3184             _api.warn_external(
3185                 f"This figure was saved with matplotlib version {version} and "
3186                 f"is unlikely to function correctly.")
3187 
3188         self.__dict__ = state
3189 
3190         # re-initialise some of the unstored state information
3191         FigureCanvasBase(self)  # Set self.canvas.
3192 
3193         if restore_to_pylab:
3194             # lazy import to avoid circularity
3195             import matplotlib.pyplot as plt
3196             import matplotlib._pylab_helpers as pylab_helpers
3197             allnums = plt.get_fignums()
3198             num = max(allnums) + 1 if allnums else 1
3199             backend = plt._get_backend_mod()
3200             mgr = backend.new_figure_manager_given_figure(num, self)
3201             pylab_helpers.Gcf._set_new_active_manager(mgr)
3202             plt.draw_if_interactive()
3203 
3204         self.stale = True
3205 
3206     def add_axobserver(self, func):
3207         """Whenever the Axes state change, ``func(self)`` will be called."""
3208         # Connect a wrapper lambda and not func itself, to avoid it being
3209         # weakref-collected.
3210         self._axobservers.connect("_axes_change_event", lambda arg: func(arg))
3211 
3212     def savefig(self, fname, *, transparent=None, **kwargs):
3213         """
3214         Save the current figure.
3215 
3216         Call signature::
3217 
3218           savefig(fname, *, dpi='figure', format=None, metadata=None,
3219                   bbox_inches=None, pad_inches=0.1,
3220                   facecolor='auto', edgecolor='auto',
3221                   backend=None, **kwargs
3222                  )
3223 
3224         The available output formats depend on the backend being used.
3225 
3226         Parameters
3227         ----------
3228         fname : str or path-like or binary file-like
3229             A path, or a Python file-like object, or
3230             possibly some backend-dependent object such as
3231             `matplotlib.backends.backend_pdf.PdfPages`.
3232 
3233             If *format* is set, it determines the output format, and the file
3234             is saved as *fname*.  Note that *fname* is used verbatim, and there
3235             is no attempt to make the extension, if any, of *fname* match
3236             *format*, and no extension is appended.
3237 
3238             If *format* is not set, then the format is inferred from the
3239             extension of *fname*, if there is one.  If *format* is not
3240             set and *fname* has no extension, then the file is saved with
3241             :rc:`savefig.format` and the appropriate extension is appended to
3242             *fname*.
3243 
3244         Other Parameters
3245         ----------------
3246         dpi : float or 'figure', default: :rc:`savefig.dpi`
3247             The resolution in dots per inch.  If 'figure', use the figure's
3248             dpi value.
3249 
3250         format : str
3251             The file format, e.g. 'png', 'pdf', 'svg', ... The behavior when
3252             this is unset is documented under *fname*.
3253 
3254         metadata : dict, optional
3255             Key/value pairs to store in the image metadata. The supported keys
3256             and defaults depend on the image format and backend:
3257 
3258             - 'png' with Agg backend: See the parameter ``metadata`` of
3259               `~.FigureCanvasAgg.print_png`.
3260             - 'pdf' with pdf backend: See the parameter ``metadata`` of
3261               `~.backend_pdf.PdfPages`.
3262             - 'svg' with svg backend: See the parameter ``metadata`` of
3263               `~.FigureCanvasSVG.print_svg`.
3264             - 'eps' and 'ps' with PS backend: Only 'Creator' is supported.
3265 
3266         bbox_inches : str or `.Bbox`, default: :rc:`savefig.bbox`
3267             Bounding box in inches: only the given portion of the figure is
3268             saved.  If 'tight', try to figure out the tight bbox of the figure.
3269 
3270         pad_inches : float or 'layout', default: :rc:`savefig.pad_inches`
3271             Amount of padding in inches around the figure when bbox_inches is
3272             'tight'. If 'layout' use the padding from the constrained or
3273             compressed layout engine; ignored if one of those engines is not in
3274             use.
3275 
3276         facecolor : color or 'auto', default: :rc:`savefig.facecolor`
3277             The facecolor of the figure.  If 'auto', use the current figure
3278             facecolor.
3279 
3280         edgecolor : color or 'auto', default: :rc:`savefig.edgecolor`
3281             The edgecolor of the figure.  If 'auto', use the current figure
3282             edgecolor.
3283 
3284         backend : str, optional
3285             Use a non-default backend to render the file, e.g. to render a
3286             png file with the "cairo" backend rather than the default "agg",
3287             or a pdf file with the "pgf" backend rather than the default
3288             "pdf".  Note that the default backend is normally sufficient.  See
3289             :ref:`the-builtin-backends` for a list of valid backends for each
3290             file format.  Custom backends can be referenced as "module://...".
3291 
3292         orientation : {'landscape', 'portrait'}
3293             Currently only supported by the postscript backend.
3294 
3295         papertype : str
3296             One of 'letter', 'legal', 'executive', 'ledger', 'a0' through
3297             'a10', 'b0' through 'b10'. Only supported for postscript
3298             output.
3299 
3300         transparent : bool
3301             If *True*, the Axes patches will all be transparent; the
3302             Figure patch will also be transparent unless *facecolor*
3303             and/or *edgecolor* are specified via kwargs.
3304 
3305             If *False* has no effect and the color of the Axes and
3306             Figure patches are unchanged (unless the Figure patch
3307             is specified via the *facecolor* and/or *edgecolor* keyword
3308             arguments in which case those colors are used).
3309 
3310             The transparency of these patches will be restored to their
3311             original values upon exit of this function.
3312 
3313             This is useful, for example, for displaying
3314             a plot on top of a colored background on a web page.
3315 
3316         bbox_extra_artists : list of `~matplotlib.artist.Artist`, optional
3317             A list of extra artists that will be considered when the
3318             tight bbox is calculated.
3319 
3320         pil_kwargs : dict, optional
3321             Additional keyword arguments that are passed to
3322             `PIL.Image.Image.save` when saving the figure.
3323 
3324         """
3325 
3326         kwargs.setdefault('dpi', mpl.rcParams['savefig.dpi'])
3327         if transparent is None:
3328             transparent = mpl.rcParams['savefig.transparent']
3329 
3330         with ExitStack() as stack:
3331             if transparent:
3332                 def _recursively_make_subfig_transparent(exit_stack, subfig):
3333                     exit_stack.enter_context(
3334                         subfig.patch._cm_set(
3335                             facecolor="none", edgecolor="none"))
3336                     for ax in subfig.axes:
3337                         exit_stack.enter_context(
3338                             ax.patch._cm_set(
3339                                 facecolor="none", edgecolor="none"))
3340                     for sub_subfig in subfig.subfigs:
3341                         _recursively_make_subfig_transparent(
3342                             exit_stack, sub_subfig)
3343 
3344                 def _recursively_make_axes_transparent(exit_stack, ax):
3345                     exit_stack.enter_context(
3346                         ax.patch._cm_set(facecolor="none", edgecolor="none"))
3347                     for child_ax in ax.child_axes:
3348                         exit_stack.enter_context(
3349                             child_ax.patch._cm_set(
3350                                 facecolor="none", edgecolor="none"))
3351                     for child_childax in ax.child_axes:
3352                         _recursively_make_axes_transparent(
3353                             exit_stack, child_childax)
3354 
3355                 kwargs.setdefault('facecolor', 'none')
3356                 kwargs.setdefault('edgecolor', 'none')
3357                 # set subfigure to appear transparent in printed image
3358                 for subfig in self.subfigs:
3359                     _recursively_make_subfig_transparent(stack, subfig)
3360                 # set axes to be transparent
3361                 for ax in self.axes:
3362                     _recursively_make_axes_transparent(stack, ax)
3363             self.canvas.print_figure(fname, **kwargs)
3364 
3365     def ginput(self, n=1, timeout=30, show_clicks=True,
3366                mouse_add=MouseButton.LEFT,
3367                mouse_pop=MouseButton.RIGHT,
3368                mouse_stop=MouseButton.MIDDLE):
3369         """
3370         Blocking call to interact with a figure.
3371 
3372         Wait until the user clicks *n* times on the figure, and return the
3373         coordinates of each click in a list.
3374 
3375         There are three possible interactions:
3376 
3377         - Add a point.
3378         - Remove the most recently added point.
3379         - Stop the interaction and return the points added so far.
3380 
3381         The actions are assigned to mouse buttons via the arguments
3382         *mouse_add*, *mouse_pop* and *mouse_stop*.
3383 
3384         Parameters
3385         ----------
3386         n : int, default: 1
3387             Number of mouse clicks to accumulate. If negative, accumulate
3388             clicks until the input is terminated manually.
3389         timeout : float, default: 30 seconds
3390             Number of seconds to wait before timing out. If zero or negative
3391             will never time out.
3392         show_clicks : bool, default: True
3393             If True, show a red cross at the location of each click.
3394         mouse_add : `.MouseButton` or None, default: `.MouseButton.LEFT`
3395             Mouse button used to add points.
3396         mouse_pop : `.MouseButton` or None, default: `.MouseButton.RIGHT`
3397             Mouse button used to remove the most recently added point.
3398         mouse_stop : `.MouseButton` or None, default: `.MouseButton.MIDDLE`
3399             Mouse button used to stop input.
3400 
3401         Returns
3402         -------
3403         list of tuples
3404             A list of the clicked (x, y) coordinates.
3405 
3406         Notes
3407         -----
3408         The keyboard can also be used to select points in case your mouse
3409         does not have one or more of the buttons.  The delete and backspace
3410         keys act like right-clicking (i.e., remove last point), the enter key
3411         terminates input and any other key (not already used by the window
3412         manager) selects a point.
3413         """
3414         clicks = []
3415         marks = []
3416 
3417         def handler(event):
3418             is_button = event.name == "button_press_event"
3419             is_key = event.name == "key_press_event"
3420             # Quit (even if not in infinite mode; this is consistent with
3421             # MATLAB and sometimes quite useful, but will require the user to
3422             # test how many points were actually returned before using data).
3423             if (is_button and event.button == mouse_stop
3424                     or is_key and event.key in ["escape", "enter"]):
3425                 self.canvas.stop_event_loop()
3426             # Pop last click.
3427             elif (is_button and event.button == mouse_pop
3428                   or is_key and event.key in ["backspace", "delete"]):
3429                 if clicks:
3430                     clicks.pop()
3431                     if show_clicks:
3432                         marks.pop().remove()
3433                         self.canvas.draw()
3434             # Add new click.
3435             elif (is_button and event.button == mouse_add
3436                   # On macOS/gtk, some keys return None.
3437                   or is_key and event.key is not None):
3438                 if event.inaxes:
3439                     clicks.append((event.xdata, event.ydata))
3440                     _log.info("input %i: %f, %f",
3441                               len(clicks), event.xdata, event.ydata)
3442                     if show_clicks:
3443                         line = mpl.lines.Line2D([event.xdata], [event.ydata],
3444                                                 marker="+", color="r")
3445                         event.inaxes.add_line(line)
3446                         marks.append(line)
3447                         self.canvas.draw()
3448             if len(clicks) == n and n > 0:
3449                 self.canvas.stop_event_loop()
3450 
3451         _blocking_input.blocking_input_loop(
3452             self, ["button_press_event", "key_press_event"], timeout, handler)
3453 
3454         # Cleanup.
3455         for mark in marks:
3456             mark.remove()
3457         self.canvas.draw()
3458 
3459         return clicks
3460 
3461     def waitforbuttonpress(self, timeout=-1):
3462         """
3463         Blocking call to interact with the figure.
3464 
3465         Wait for user input and return True if a key was pressed, False if a
3466         mouse button was pressed and None if no input was given within
3467         *timeout* seconds.  Negative values deactivate *timeout*.
3468         """
3469         event = None
3470 
3471         def handler(ev):
3472             nonlocal event
3473             event = ev
3474             self.canvas.stop_event_loop()
3475 
3476         _blocking_input.blocking_input_loop(
3477             self, ["button_press_event", "key_press_event"], timeout, handler)
3478 
3479         return None if event is None else event.name == "key_press_event"
3480 
3481     @_api.deprecated("3.6", alternative="figure.get_layout_engine().execute()")
3482     def execute_constrained_layout(self, renderer=None):
3483         """
3484         Use ``layoutgrid`` to determine pos positions within Axes.
3485 
3486         See also `.set_constrained_layout_pads`.
3487 
3488         Returns
3489         -------
3490         layoutgrid : private debugging object
3491         """
3492         if not isinstance(self.get_layout_engine(), ConstrainedLayoutEngine):
3493             return None
3494         return self.get_layout_engine().execute(self)
3495 
3496     def tight_layout(self, *, pad=1.08, h_pad=None, w_pad=None, rect=None):
3497         """
3498         Adjust the padding between and around subplots.
3499 
3500         To exclude an artist on the Axes from the bounding box calculation
3501         that determines the subplot parameters (i.e. legend, or annotation),
3502         set ``a.set_in_layout(False)`` for that artist.
3503 
3504         Parameters
3505         ----------
3506         pad : float, default: 1.08
3507             Padding between the figure edge and the edges of subplots,
3508             as a fraction of the font size.
3509         h_pad, w_pad : float, default: *pad*
3510             Padding (height/width) between edges of adjacent subplots,
3511             as a fraction of the font size.
3512         rect : tuple (left, bottom, right, top), default: (0, 0, 1, 1)
3513             A rectangle in normalized figure coordinates into which the whole
3514             subplots area (including labels) will fit.
3515 
3516         See Also
3517         --------
3518         .Figure.set_layout_engine
3519         .pyplot.tight_layout
3520         """
3521         # note that here we do not permanently set the figures engine to
3522         # tight_layout but rather just perform the layout in place and remove
3523         # any previous engines.
3524         engine = TightLayoutEngine(pad=pad, h_pad=h_pad, w_pad=w_pad,
3525                                    rect=rect)
3526         try:
3527             previous_engine = self.get_layout_engine()
3528             self.set_layout_engine(engine)
3529             engine.execute(self)
3530             if not isinstance(previous_engine, TightLayoutEngine) \
3531                     and previous_engine is not None:
3532                 _api.warn_external('The figure layout has changed to tight')
3533         finally:
3534             self.set_layout_engine(None)

</code><intended_behavior>The constrained layout system within the Figure class might need updates or adjustments to better account for wrapped text in titles. This might involve implementing a more dynamic calculation of bounding boxes for titles when wrap=True is set, ensuring that ample space is automatically allocated to prevent overlap and ensure visibility.</intended_behavior>, <file>lib/matplotlib/axes/_axes.py</file>
<class>Axes</class>
<method>set_title</method>
<code>
104     def set_title(self, label, fontdict=None, loc=None, pad=None, *, y=None,
105                   **kwargs):
106         """
107         Set a title for the Axes.
108 
109         Set one of the three available Axes titles. The available titles
110         are positioned above the Axes in the center, flush with the left
111         edge, and flush with the right edge.
112 
113         Parameters
114         ----------
115         label : str
116             Text to use for the title
117 
118         fontdict : dict
119             A dictionary controlling the appearance of the title text,
120             the default *fontdict* is::
121 
122                {'fontsize': rcParams['axes.titlesize'],
123                 'fontweight': rcParams['axes.titleweight'],
124                 'color': rcParams['axes.titlecolor'],
125                 'verticalalignment': 'baseline',
126                 'horizontalalignment': loc}
127 
128         loc : {'center', 'left', 'right'}, default: :rc:`axes.titlelocation`
129             Which title to set.
130 
131         y : float, default: :rc:`axes.titley`
132             Vertical Axes location for the title (1.0 is the top).  If
133             None (the default) and :rc:`axes.titley` is also None, y is
134             determined automatically to avoid decorators on the Axes.
135 
136         pad : float, default: :rc:`axes.titlepad`
137             The offset of the title from the top of the Axes, in points.
138 
139         Returns
140         -------
141         `.Text`
142             The matplotlib text instance representing the title
143 
144         Other Parameters
145         ----------------
146         **kwargs : `.Text` properties
147             Other keyword arguments are text properties, see `.Text` for a list
148             of valid text properties.
149         """
150         if loc is None:
151             loc = mpl.rcParams['axes.titlelocation']
152 
153         if y is None:
154             y = mpl.rcParams['axes.titley']
155         if y is None:
156             y = 1.0
157         else:
158             self._autotitlepos = False
159         kwargs['y'] = y
160 
161         titles = {'left': self._left_title,
162                   'center': self.title,
163                   'right': self._right_title}
164         title = _api.check_getitem(titles, loc=loc.lower())
165         default = {
166             'fontsize': mpl.rcParams['axes.titlesize'],
167             'fontweight': mpl.rcParams['axes.titleweight'],
168             'verticalalignment': 'baseline',
169             'horizontalalignment': loc.lower()}
170         titlecolor = mpl.rcParams['axes.titlecolor']
171         if not cbook._str_lower_equal(titlecolor, 'auto'):
172             default["color"] = titlecolor
173         if pad is None:
174             pad = mpl.rcParams['axes.titlepad']
175         self._set_title_offset_trans(float(pad))
176         title.set_text(label)
177         title.update(default)
178         if fontdict is not None:
179             title.update(fontdict)
180         title._internal_update(kwargs)
181         return title

</code><intended_behavior>This method should ensure that when a title is set with wrap=True, the height calculation for the wrapped title is accurately communicated to the layout engine. This may require extending the functionality to better notify the constrained layout engine of the adjusted size necessary for the wrapped text.</intended_behavior>, <file>lib/matplotlib/axes/_axes.py</file>
<class>Axes</class>
<method>None</method>
<code>
47 class Axes(_AxesBase):
48     """
49     An Axes object encapsulates all the elements of an individual (sub-)plot in
50     a figure.
51 
52     It contains most of the (sub-)plot elements: `~.axis.Axis`,
53     `~.axis.Tick`, `~.lines.Line2D`, `~.text.Text`, `~.patches.Polygon`, etc.,
54     and sets the coordinate system.
55 
56     Like all visible elements in a figure, Axes is an `.Artist` subclass.
57 
58     The `Axes` instance supports callbacks through a callbacks attribute which
59     is a `~.cbook.CallbackRegistry` instance.  The events you can connect to
60     are 'xlim_changed' and 'ylim_changed' and the callback will be called with
61     func(*ax*) where *ax* is the `Axes` instance.
62 
63     .. note::
64 
65         As a user, you do not instantiate Axes directly, but use Axes creation
66         methods instead; e.g. from `.pyplot` or `.Figure`:
67         `~.pyplot.subplots`, `~.pyplot.subplot_mosaic` or `.Figure.add_axes`.
68 
69     Attributes
70     ----------
71     dataLim : `.Bbox`
72         The bounding box enclosing all data displayed in the Axes.
73     viewLim : `.Bbox`
74         The view limits in data coordinates.
75 
76     """
77     ### Labelling, legend and texts
78 
79     def get_title(self, loc="center"):
80         """
81         Get an Axes title.
82 
83         Get one of the three available Axes titles. The available titles
84         are positioned above the Axes in the center, flush with the left
85         edge, and flush with the right edge.
86 
87         Parameters
88         ----------
89         loc : {'center', 'left', 'right'}, str, default: 'center'
90             Which title to return.
91 
92         Returns
93         -------
94         str
95             The title text string.
96 
97         """
98         titles = {'left': self._left_title,
99                   'center': self.title,
100                   'right': self._right_title}
101         title = _api.check_getitem(titles, loc=loc.lower())
102         return title.get_text()
103 
104     def set_title(self, label, fontdict=None, loc=None, pad=None, *, y=None,
105                   **kwargs):
106         """
107         Set a title for the Axes.
108 
109         Set one of the three available Axes titles. The available titles
110         are positioned above the Axes in the center, flush with the left
111         edge, and flush with the right edge.
112 
113         Parameters
114         ----------
115         label : str
116             Text to use for the title
117 
118         fontdict : dict
119             A dictionary controlling the appearance of the title text,
120             the default *fontdict* is::
121 
122                {'fontsize': rcParams['axes.titlesize'],
123                 'fontweight': rcParams['axes.titleweight'],
124                 'color': rcParams['axes.titlecolor'],
125                 'verticalalignment': 'baseline',
126                 'horizontalalignment': loc}
127 
128         loc : {'center', 'left', 'right'}, default: :rc:`axes.titlelocation`
129             Which title to set.
130 
131         y : float, default: :rc:`axes.titley`
132             Vertical Axes location for the title (1.0 is the top).  If
133             None (the default) and :rc:`axes.titley` is also None, y is
134             determined automatically to avoid decorators on the Axes.
135 
136         pad : float, default: :rc:`axes.titlepad`
137             The offset of the title from the top of the Axes, in points.
138 
139         Returns
140         -------
141         `.Text`
142             The matplotlib text instance representing the title
143 
144         Other Parameters
145         ----------------
146         **kwargs : `.Text` properties
147             Other keyword arguments are text properties, see `.Text` for a list
148             of valid text properties.
149         """
150         if loc is None:
151             loc = mpl.rcParams['axes.titlelocation']
152 
153         if y is None:
154             y = mpl.rcParams['axes.titley']
155         if y is None:
156             y = 1.0
157         else:
158             self._autotitlepos = False
159         kwargs['y'] = y
160 
161         titles = {'left': self._left_title,
162                   'center': self.title,
163                   'right': self._right_title}
164         title = _api.check_getitem(titles, loc=loc.lower())
165         default = {
166             'fontsize': mpl.rcParams['axes.titlesize'],
167             'fontweight': mpl.rcParams['axes.titleweight'],
168             'verticalalignment': 'baseline',
169             'horizontalalignment': loc.lower()}
170         titlecolor = mpl.rcParams['axes.titlecolor']
171         if not cbook._str_lower_equal(titlecolor, 'auto'):
172             default["color"] = titlecolor
173         if pad is None:
174             pad = mpl.rcParams['axes.titlepad']
175         self._set_title_offset_trans(float(pad))
176         title.set_text(label)
177         title.update(default)
178         if fontdict is not None:
179             title.update(fontdict)
180         title._internal_update(kwargs)
181         return title
182 
183     def get_legend_handles_labels(self, legend_handler_map=None):
184         """
185         Return handles and labels for legend
186 
187         ``ax.legend()`` is equivalent to ::
188 
189           h, l = ax.get_legend_handles_labels()
190           ax.legend(h, l)
191         """
192         # pass through to legend.
193         handles, labels = mlegend._get_legend_handles_labels(
194             [self], legend_handler_map)
195         return handles, labels
196 
197     @_docstring.dedent_interpd
198     def legend(self, *args, **kwargs):
199         """
200         Place a legend on the Axes.
201 
202         Call signatures::
203 
204             legend()
205             legend(handles, labels)
206             legend(handles=handles)
207             legend(labels)
208 
209         The call signatures correspond to the following different ways to use
210         this method:
211 
212         **1. Automatic detection of elements to be shown in the legend**
213 
214         The elements to be added to the legend are automatically determined,
215         when you do not pass in any extra arguments.
216 
217         In this case, the labels are taken from the artist. You can specify
218         them either at artist creation or by calling the
219         :meth:`~.Artist.set_label` method on the artist::
220 
221             ax.plot([1, 2, 3], label='Inline label')
222             ax.legend()
223 
224         or::
225 
226             line, = ax.plot([1, 2, 3])
227             line.set_label('Label via method')
228             ax.legend()
229 
230         .. note::
231             Specific artists can be excluded from the automatic legend element
232             selection by using a label starting with an underscore, "_".
233             A string starting with an underscore is the default label for all
234             artists, so calling `.Axes.legend` without any arguments and
235             without setting the labels manually will result in no legend being
236             drawn.
237 
238 
239         **2. Explicitly listing the artists and labels in the legend**
240 
241         For full control of which artists have a legend entry, it is possible
242         to pass an iterable of legend artists followed by an iterable of
243         legend labels respectively::
244 
245             ax.legend([line1, line2, line3], ['label1', 'label2', 'label3'])
246 
247 
248         **3. Explicitly listing the artists in the legend**
249 
250         This is similar to 2, but the labels are taken from the artists'
251         label properties. Example::
252 
253             line1, = ax.plot([1, 2, 3], label='label1')
254             line2, = ax.plot([1, 2, 3], label='label2')
255             ax.legend(handles=[line1, line2])
256 
257 
258         **4. Labeling existing plot elements**
259 
260         .. admonition:: Discouraged
261 
262             This call signature is discouraged, because the relation between
263             plot elements and labels is only implicit by their order and can
264             easily be mixed up.
265 
266         To make a legend for all artists on an Axes, call this function with
267         an iterable of strings, one for each legend item. For example::
268 
269             ax.plot([1, 2, 3])
270             ax.plot([5, 6, 7])
271             ax.legend(['First line', 'Second line'])
272 
273 
274         Parameters
275         ----------
276         handles : sequence of `.Artist`, optional
277             A list of Artists (lines, patches) to be added to the legend.
278             Use this together with *labels*, if you need full control on what
279             is shown in the legend and the automatic mechanism described above
280             is not sufficient.
281 
282             The length of handles and labels should be the same in this
283             case. If they are not, they are truncated to the smaller length.
284 
285         labels : list of str, optional
286             A list of labels to show next to the artists.
287             Use this together with *handles*, if you need full control on what
288             is shown in the legend and the automatic mechanism described above
289             is not sufficient.
290 
291         Returns
292         -------
293         `~matplotlib.legend.Legend`
294 
295         Other Parameters
296         ----------------
297         %(_legend_kw_axes)s
298 
299         See Also
300         --------
301         .Figure.legend
302 
303         Notes
304         -----
305         Some artists are not supported by this function.  See
306         :doc:`/tutorials/intermediate/legend_guide` for details.
307 
308         Examples
309         --------
310         .. plot:: gallery/text_labels_and_annotations/legend.py
311         """
312         handles, labels, extra_args, kwargs = mlegend._parse_legend_args(
313                 [self],
314                 *args,
315                 **kwargs)
316         if len(extra_args):
317             raise TypeError('legend only accepts two non-keyword arguments')
318         self.legend_ = mlegend.Legend(self, handles, labels, **kwargs)
319         self.legend_._remove_method = self._remove_legend
320         return self.legend_
321 
322     def _remove_legend(self, legend):
323         self.legend_ = None
324 
325     def inset_axes(self, bounds, *, transform=None, zorder=5, **kwargs):
326         """
327         Add a child inset Axes to this existing Axes.
328 
329         Warnings
330         --------
331         This method is experimental as of 3.0, and the API may change.
332 
333         Parameters
334         ----------
335         bounds : [x0, y0, width, height]
336             Lower-left corner of inset Axes, and its width and height.
337 
338         transform : `.Transform`
339             Defaults to `ax.transAxes`, i.e. the units of *rect* are in
340             Axes-relative coordinates.
341 
342         projection : {None, 'aitoff', 'hammer', 'lambert', 'mollweide', \
343 'polar', 'rectilinear', str}, optional
344             The projection type of the inset `~.axes.Axes`. *str* is the name
345             of a custom projection, see `~matplotlib.projections`. The default
346             None results in a 'rectilinear' projection.
347 
348         polar : bool, default: False
349             If True, equivalent to projection='polar'.
350 
351         axes_class : subclass type of `~.axes.Axes`, optional
352             The `.axes.Axes` subclass that is instantiated.  This parameter
353             is incompatible with *projection* and *polar*.  See
354             :ref:`axisartist_users-guide-index` for examples.
355 
356         zorder : number
357             Defaults to 5 (same as `.Axes.legend`).  Adjust higher or lower
358             to change whether it is above or below data plotted on the
359             parent Axes.
360 
361         **kwargs
362             Other keyword arguments are passed on to the inset Axes class.
363 
364         Returns
365         -------
366         ax
367             The created `~.axes.Axes` instance.
368 
369         Examples
370         --------
371         This example makes two inset Axes, the first is in Axes-relative
372         coordinates, and the second in data-coordinates::
373 
374             fig, ax = plt.subplots()
375             ax.plot(range(10))
376             axin1 = ax.inset_axes([0.8, 0.1, 0.15, 0.15])
377             axin2 = ax.inset_axes(
378                     [5, 7, 2.3, 2.3], transform=ax.transData)
379 
380         """
381         if transform is None:
382             transform = self.transAxes
383         kwargs.setdefault('label', 'inset_axes')
384 
385         # This puts the rectangle into figure-relative coordinates.
386         inset_locator = _TransformedBoundsLocator(bounds, transform)
387         bounds = inset_locator(self, None).bounds
388         projection_class, pkw = self.figure._process_projection_requirements(
389                 bounds, **kwargs)
390         inset_ax = projection_class(self.figure, bounds, zorder=zorder, **pkw)
391 
392         # this locator lets the axes move if in data coordinates.
393         # it gets called in `ax.apply_aspect() (of all places)
394         inset_ax.set_axes_locator(inset_locator)
395 
396         self.add_child_axes(inset_ax)
397 
398         return inset_ax
399 
400     @_docstring.dedent_interpd
401     def indicate_inset(self, bounds, inset_ax=None, *, transform=None,
402                        facecolor='none', edgecolor='0.5', alpha=0.5,
403                        zorder=4.99, **kwargs):
404         """
405         Add an inset indicator to the Axes.  This is a rectangle on the plot
406         at the position indicated by *bounds* that optionally has lines that
407         connect the rectangle to an inset Axes (`.Axes.inset_axes`).
408 
409         Warnings
410         --------
411         This method is experimental as of 3.0, and the API may change.
412 
413         Parameters
414         ----------
415         bounds : [x0, y0, width, height]
416             Lower-left corner of rectangle to be marked, and its width
417             and height.
418 
419         inset_ax : `.Axes`
420             An optional inset Axes to draw connecting lines to.  Two lines are
421             drawn connecting the indicator box to the inset Axes on corners
422             chosen so as to not overlap with the indicator box.
423 
424         transform : `.Transform`
425             Transform for the rectangle coordinates. Defaults to
426             `ax.transAxes`, i.e. the units of *rect* are in Axes-relative
427             coordinates.
428 
429         facecolor : color, default: 'none'
430             Facecolor of the rectangle.
431 
432         edgecolor : color, default: '0.5'
433             Color of the rectangle and color of the connecting lines.
434 
435         alpha : float, default: 0.5
436             Transparency of the rectangle and connector lines.
437 
438         zorder : float, default: 4.99
439             Drawing order of the rectangle and connector lines.  The default,
440             4.99, is just below the default level of inset Axes.
441 
442         **kwargs
443             Other keyword arguments are passed on to the `.Rectangle` patch:
444 
445             %(Rectangle:kwdoc)s
446 
447         Returns
448         -------
449         rectangle_patch : `.patches.Rectangle`
450              The indicator frame.
451 
452         connector_lines : 4-tuple of `.patches.ConnectionPatch`
453             The four connector lines connecting to (lower_left, upper_left,
454             lower_right upper_right) corners of *inset_ax*. Two lines are
455             set with visibility to *False*,  but the user can set the
456             visibility to True if the automatic choice is not deemed correct.
457 
458         """
459         # to make the axes connectors work, we need to apply the aspect to
460         # the parent axes.
461         self.apply_aspect()
462 
463         if transform is None:
464             transform = self.transData
465         kwargs.setdefault('label', '_indicate_inset')
466 
467         x, y, width, height = bounds
468         rectangle_patch = mpatches.Rectangle(
469             (x, y), width, height,
470             facecolor=facecolor, edgecolor=edgecolor, alpha=alpha,
471             zorder=zorder, transform=transform, **kwargs)
472         self.add_patch(rectangle_patch)
473 
474         connects = []
475 
476         if inset_ax is not None:
477             # connect the inset_axes to the rectangle
478             for xy_inset_ax in [(0, 0), (0, 1), (1, 0), (1, 1)]:
479                 # inset_ax positions are in axes coordinates
480                 # The 0, 1 values define the four edges if the inset_ax
481                 # lower_left, upper_left, lower_right upper_right.
482                 ex, ey = xy_inset_ax
483                 if self.xaxis.get_inverted():
484                     ex = 1 - ex
485                 if self.yaxis.get_inverted():
486                     ey = 1 - ey
487                 xy_data = x + ex * width, y + ey * height
488                 p = mpatches.ConnectionPatch(
489                     xyA=xy_inset_ax, coordsA=inset_ax.transAxes,
490                     xyB=xy_data, coordsB=self.transData,
491                     arrowstyle="-", zorder=zorder,
492                     edgecolor=edgecolor, alpha=alpha)
493                 connects.append(p)
494                 self.add_patch(p)
495 
496             # decide which two of the lines to keep visible....
497             pos = inset_ax.get_position()
498             bboxins = pos.transformed(self.figure.transSubfigure)
499             rectbbox = mtransforms.Bbox.from_bounds(
500                 *bounds
501             ).transformed(transform)
502             x0 = rectbbox.x0 < bboxins.x0
503             x1 = rectbbox.x1 < bboxins.x1
504             y0 = rectbbox.y0 < bboxins.y0
505             y1 = rectbbox.y1 < bboxins.y1
506             connects[0].set_visible(x0 ^ y0)
507             connects[1].set_visible(x0 == y1)
508             connects[2].set_visible(x1 == y0)
509             connects[3].set_visible(x1 ^ y1)
510 
511         return rectangle_patch, tuple(connects) if connects else None
512 
513     def indicate_inset_zoom(self, inset_ax, **kwargs):
514         """
515         Add an inset indicator rectangle to the Axes based on the axis
516         limits for an *inset_ax* and draw connectors between *inset_ax*
517         and the rectangle.
518 
519         Warnings
520         --------
521         This method is experimental as of 3.0, and the API may change.
522 
523         Parameters
524         ----------
525         inset_ax : `.Axes`
526             Inset Axes to draw connecting lines to.  Two lines are
527             drawn connecting the indicator box to the inset Axes on corners
528             chosen so as to not overlap with the indicator box.
529 
530         **kwargs
531             Other keyword arguments are passed on to `.Axes.indicate_inset`
532 
533         Returns
534         -------
535         rectangle_patch : `.patches.Rectangle`
536              Rectangle artist.
537 
538         connector_lines : 4-tuple of `.patches.ConnectionPatch`
539             Each of four connector lines coming from the rectangle drawn on
540             this axis, in the order lower left, upper left, lower right,
541             upper right.
542             Two are set with visibility to *False*,  but the user can
543             set the visibility to *True* if the automatic choice is not deemed
544             correct.
545         """
546 
547         xlim = inset_ax.get_xlim()
548         ylim = inset_ax.get_ylim()
549         rect = (xlim[0], ylim[0], xlim[1] - xlim[0], ylim[1] - ylim[0])
550         return self.indicate_inset(rect, inset_ax, **kwargs)
551 
552     @_docstring.dedent_interpd
553     def secondary_xaxis(self, location, *, functions=None, **kwargs):
554         """
555         Add a second x-axis to this `~.axes.Axes`.
556 
557         For example if we want to have a second scale for the data plotted on
558         the xaxis.
559 
560         %(_secax_docstring)s
561 
562         Examples
563         --------
564         The main axis shows frequency, and the secondary axis shows period.
565 
566         .. plot::
567 
568             fig, ax = plt.subplots()
569             ax.loglog(range(1, 360, 5), range(1, 360, 5))
570             ax.set_xlabel('frequency [Hz]')
571 
572             def invert(x):
573                 # 1/x with special treatment of x == 0
574                 x = np.array(x).astype(float)
575                 near_zero = np.isclose(x, 0)
576                 x[near_zero] = np.inf
577                 x[~near_zero] = 1 / x[~near_zero]
578                 return x
579 
580             # the inverse of 1/x is itself
581             secax = ax.secondary_xaxis('top', functions=(invert, invert))
582             secax.set_xlabel('Period [s]')
583             plt.show()
584         """
585         if location in ['top', 'bottom'] or isinstance(location, Real):
586             secondary_ax = SecondaryAxis(self, 'x', location, functions,
587                                          **kwargs)
588             self.add_child_axes(secondary_ax)
589             return secondary_ax
590         else:
591             raise ValueError('secondary_xaxis location must be either '
592                              'a float or "top"/"bottom"')
593 
594     @_docstring.dedent_interpd
595     def secondary_yaxis(self, location, *, functions=None, **kwargs):
596         """
597         Add a second y-axis to this `~.axes.Axes`.
598 
599         For example if we want to have a second scale for the data plotted on
600         the yaxis.
601 
602         %(_secax_docstring)s
603 
604         Examples
605         --------
606         Add a secondary Axes that converts from radians to degrees
607 
608         .. plot::
609 
610             fig, ax = plt.subplots()
611             ax.plot(range(1, 360, 5), range(1, 360, 5))
612             ax.set_ylabel('degrees')
613             secax = ax.secondary_yaxis('right', functions=(np.deg2rad,
614                                                            np.rad2deg))
615             secax.set_ylabel('radians')
616         """
617         if location in ['left', 'right'] or isinstance(location, Real):
618             secondary_ax = SecondaryAxis(self, 'y', location,
619                                          functions, **kwargs)
620             self.add_child_axes(secondary_ax)
621             return secondary_ax
622         else:
623             raise ValueError('secondary_yaxis location must be either '
624                              'a float or "left"/"right"')
625 
626     @_docstring.dedent_interpd
627     def text(self, x, y, s, fontdict=None, **kwargs):
628         """
629         Add text to the Axes.
630 
631         Add the text *s* to the Axes at location *x*, *y* in data coordinates.
632 
633         Parameters
634         ----------
635         x, y : float
636             The position to place the text. By default, this is in data
637             coordinates. The coordinate system can be changed using the
638             *transform* parameter.
639 
640         s : str
641             The text.
642 
643         fontdict : dict, default: None
644             A dictionary to override the default text properties. If fontdict
645             is None, the defaults are determined by `.rcParams`.
646 
647         Returns
648         -------
649         `.Text`
650             The created `.Text` instance.
651 
652         Other Parameters
653         ----------------
654         **kwargs : `~matplotlib.text.Text` properties.
655             Other miscellaneous text parameters.
656 
657             %(Text:kwdoc)s
658 
659         Examples
660         --------
661         Individual keyword arguments can be used to override any given
662         parameter::
663 
664             >>> text(x, y, s, fontsize=12)
665 
666         The default transform specifies that text is in data coords,
667         alternatively, you can specify text in axis coords ((0, 0) is
668         lower-left and (1, 1) is upper-right).  The example below places
669         text in the center of the Axes::
670 
671             >>> text(0.5, 0.5, 'matplotlib', horizontalalignment='center',
672             ...      verticalalignment='center', transform=ax.transAxes)
673 
674         You can put a rectangular box around the text instance (e.g., to
675         set a background color) by using the keyword *bbox*.  *bbox* is
676         a dictionary of `~matplotlib.patches.Rectangle`
677         properties.  For example::
678 
679             >>> text(x, y, s, bbox=dict(facecolor='red', alpha=0.5))
680         """
681         effective_kwargs = {
682             'verticalalignment': 'baseline',
683             'horizontalalignment': 'left',
684             'transform': self.transData,
685             'clip_on': False,
686             **(fontdict if fontdict is not None else {}),
687             **kwargs,
688         }
689         t = mtext.Text(x, y, text=s, **effective_kwargs)
690         t.set_clip_path(self.patch)
691         self._add_text(t)
692         return t
693 
694     @_docstring.dedent_interpd
695     def annotate(self, text, xy, xytext=None, xycoords='data', textcoords=None,
696                  arrowprops=None, annotation_clip=None, **kwargs):
697         # Signature must match Annotation. This is verified in
698         # test_annotate_signature().
699         a = mtext.Annotation(text, xy, xytext=xytext, xycoords=xycoords,
700                              textcoords=textcoords, arrowprops=arrowprops,
701                              annotation_clip=annotation_clip, **kwargs)
702         a.set_transform(mtransforms.IdentityTransform())
703         if 'clip_on' in kwargs:
704             a.set_clip_path(self.patch)
705         self._add_text(a)
706         return a
707     annotate.__doc__ = mtext.Annotation.__init__.__doc__
708     #### Lines and spans
709 
710     @_docstring.dedent_interpd
711     def axhline(self, y=0, xmin=0, xmax=1, **kwargs):
712         """
713         Add a horizontal line across the Axes.
714 
715         Parameters
716         ----------
717         y : float, default: 0
718             y position in data coordinates of the horizontal line.
719 
720         xmin : float, default: 0
721             Should be between 0 and 1, 0 being the far left of the plot, 1 the
722             far right of the plot.
723 
724         xmax : float, default: 1
725             Should be between 0 and 1, 0 being the far left of the plot, 1 the
726             far right of the plot.
727 
728         Returns
729         -------
730         `~matplotlib.lines.Line2D`
731 
732         Other Parameters
733         ----------------
734         **kwargs
735             Valid keyword arguments are `.Line2D` properties, except for
736             'transform':
737 
738             %(Line2D:kwdoc)s
739 
740         See Also
741         --------
742         hlines : Add horizontal lines in data coordinates.
743         axhspan : Add a horizontal span (rectangle) across the axis.
744         axline : Add a line with an arbitrary slope.
745 
746         Examples
747         --------
748         * draw a thick red hline at 'y' = 0 that spans the xrange::
749 
750             >>> axhline(linewidth=4, color='r')
751 
752         * draw a default hline at 'y' = 1 that spans the xrange::
753 
754             >>> axhline(y=1)
755 
756         * draw a default hline at 'y' = .5 that spans the middle half of
757           the xrange::
758 
759             >>> axhline(y=.5, xmin=0.25, xmax=0.75)
760         """
761         self._check_no_units([xmin, xmax], ['xmin', 'xmax'])
762         if "transform" in kwargs:
763             raise ValueError("'transform' is not allowed as a keyword "
764                              "argument; axhline generates its own transform.")
765         ymin, ymax = self.get_ybound()
766 
767         # Strip away the units for comparison with non-unitized bounds.
768         yy, = self._process_unit_info([("y", y)], kwargs)
769         scaley = (yy < ymin) or (yy > ymax)
770 
771         trans = self.get_yaxis_transform(which='grid')
772         l = mlines.Line2D([xmin, xmax], [y, y], transform=trans, **kwargs)
773         self.add_line(l)
774         if scaley:
775             self._request_autoscale_view("y")
776         return l
777 
778     @_docstring.dedent_interpd
779     def axvline(self, x=0, ymin=0, ymax=1, **kwargs):
780         """
781         Add a vertical line across the Axes.
782 
783         Parameters
784         ----------
785         x : float, default: 0
786             x position in data coordinates of the vertical line.
787 
788         ymin : float, default: 0
789             Should be between 0 and 1, 0 being the bottom of the plot, 1 the
790             top of the plot.
791 
792         ymax : float, default: 1
793             Should be between 0 and 1, 0 being the bottom of the plot, 1 the
794             top of the plot.
795 
796         Returns
797         -------
798         `~matplotlib.lines.Line2D`
799 
800         Other Parameters
801         ----------------
802         **kwargs
803             Valid keyword arguments are `.Line2D` properties, except for
804             'transform':
805 
806             %(Line2D:kwdoc)s
807 
808         See Also
809         --------
810         vlines : Add vertical lines in data coordinates.
811         axvspan : Add a vertical span (rectangle) across the axis.
812         axline : Add a line with an arbitrary slope.
813 
814         Examples
815         --------
816         * draw a thick red vline at *x* = 0 that spans the yrange::
817 
818             >>> axvline(linewidth=4, color='r')
819 
820         * draw a default vline at *x* = 1 that spans the yrange::
821 
822             >>> axvline(x=1)
823 
824         * draw a default vline at *x* = .5 that spans the middle half of
825           the yrange::
826 
827             >>> axvline(x=.5, ymin=0.25, ymax=0.75)
828         """
829         self._check_no_units([ymin, ymax], ['ymin', 'ymax'])
830         if "transform" in kwargs:
831             raise ValueError("'transform' is not allowed as a keyword "
832                              "argument; axvline generates its own transform.")
833         xmin, xmax = self.get_xbound()
834 
835         # Strip away the units for comparison with non-unitized bounds.
836         xx, = self._process_unit_info([("x", x)], kwargs)
837         scalex = (xx < xmin) or (xx > xmax)
838 
839         trans = self.get_xaxis_transform(which='grid')
840         l = mlines.Line2D([x, x], [ymin, ymax], transform=trans, **kwargs)
841         self.add_line(l)
842         if scalex:
843             self._request_autoscale_view("x")
844         return l
845 
846     @staticmethod
847     def _check_no_units(vals, names):
848         # Helper method to check that vals are not unitized
849         for val, name in zip(vals, names):
850             if not munits._is_natively_supported(val):
851                 raise ValueError(f"{name} must be a single scalar value, "
852                                  f"but got {val}")
853 
854     @_docstring.dedent_interpd
855     def axline(self, xy1, xy2=None, *, slope=None, **kwargs):
856         """
857         Add an infinitely long straight line.
858 
859         The line can be defined either by two points *xy1* and *xy2*, or
860         by one point *xy1* and a *slope*.
861 
862         This draws a straight line "on the screen", regardless of the x and y
863         scales, and is thus also suitable for drawing exponential decays in
864         semilog plots, power laws in loglog plots, etc. However, *slope*
865         should only be used with linear scales; It has no clear meaning for
866         all other scales, and thus the behavior is undefined. Please specify
867         the line using the points *xy1*, *xy2* for non-linear scales.
868 
869         The *transform* keyword argument only applies to the points *xy1*,
870         *xy2*. The *slope* (if given) is always in data coordinates. This can
871         be used e.g. with ``ax.transAxes`` for drawing grid lines with a fixed
872         slope.
873 
874         Parameters
875         ----------
876         xy1, xy2 : (float, float)
877             Points for the line to pass through.
878             Either *xy2* or *slope* has to be given.
879         slope : float, optional
880             The slope of the line. Either *xy2* or *slope* has to be given.
881 
882         Returns
883         -------
884         `.Line2D`
885 
886         Other Parameters
887         ----------------
888         **kwargs
889             Valid kwargs are `.Line2D` properties
890 
891             %(Line2D:kwdoc)s
892 
893         See Also
894         --------
895         axhline : for horizontal lines
896         axvline : for vertical lines
897 
898         Examples
899         --------
900         Draw a thick red line passing through (0, 0) and (1, 1)::
901 
902             >>> axline((0, 0), (1, 1), linewidth=4, color='r')
903         """
904         if slope is not None and (self.get_xscale() != 'linear' or
905                                   self.get_yscale() != 'linear'):
906             raise TypeError("'slope' cannot be used with non-linear scales")
907 
908         datalim = [xy1] if xy2 is None else [xy1, xy2]
909         if "transform" in kwargs:
910             # if a transform is passed (i.e. line points not in data space),
911             # data limits should not be adjusted.
912             datalim = []
913 
914         line = mlines._AxLine(xy1, xy2, slope, **kwargs)
915         # Like add_line, but correctly handling data limits.
916         self._set_artist_props(line)
917         if line.get_clip_path() is None:
918             line.set_clip_path(self.patch)
919         if not line.get_label():
920             line.set_label(f"_child{len(self._children)}")
921         self._children.append(line)
922         line._remove_method = self._children.remove
923         self.update_datalim(datalim)
924 
925         self._request_autoscale_view()
926         return line
927 
928     @_docstring.dedent_interpd
929     def axhspan(self, ymin, ymax, xmin=0, xmax=1, **kwargs):
930         """
931         Add a horizontal span (rectangle) across the Axes.
932 
933         The rectangle spans from *ymin* to *ymax* vertically, and, by default,
934         the whole x-axis horizontally.  The x-span can be set using *xmin*
935         (default: 0) and *xmax* (default: 1) which are in axis units; e.g.
936         ``xmin = 0.5`` always refers to the middle of the x-axis regardless of
937         the limits set by `~.Axes.set_xlim`.
938 
939         Parameters
940         ----------
941         ymin : float
942             Lower y-coordinate of the span, in data units.
943         ymax : float
944             Upper y-coordinate of the span, in data units.
945         xmin : float, default: 0
946             Lower x-coordinate of the span, in x-axis (0-1) units.
947         xmax : float, default: 1
948             Upper x-coordinate of the span, in x-axis (0-1) units.
949 
950         Returns
951         -------
952         `~matplotlib.patches.Polygon`
953             Horizontal span (rectangle) from (xmin, ymin) to (xmax, ymax).
954 
955         Other Parameters
956         ----------------
957         **kwargs : `~matplotlib.patches.Polygon` properties
958 
959         %(Polygon:kwdoc)s
960 
961         See Also
962         --------
963         axvspan : Add a vertical span across the Axes.
964         """
965         # Strip units away.
966         self._check_no_units([xmin, xmax], ['xmin', 'xmax'])
967         (ymin, ymax), = self._process_unit_info([("y", [ymin, ymax])], kwargs)
968 
969         verts = (xmin, ymin), (xmin, ymax), (xmax, ymax), (xmax, ymin)
970         p = mpatches.Polygon(verts, **kwargs)
971         p.set_transform(self.get_yaxis_transform(which="grid"))
972         self.add_patch(p)
973         self._request_autoscale_view("y")
974         return p
975 
976     @_docstring.dedent_interpd
977     def axvspan(self, xmin, xmax, ymin=0, ymax=1, **kwargs):
978         """
979         Add a vertical span (rectangle) across the Axes.
980 
981         The rectangle spans from *xmin* to *xmax* horizontally, and, by
982         default, the whole y-axis vertically.  The y-span can be set using
983         *ymin* (default: 0) and *ymax* (default: 1) which are in axis units;
984         e.g. ``ymin = 0.5`` always refers to the middle of the y-axis
985         regardless of the limits set by `~.Axes.set_ylim`.
986 
987         Parameters
988         ----------
989         xmin : float
990             Lower x-coordinate of the span, in data units.
991         xmax : float
992             Upper x-coordinate of the span, in data units.
993         ymin : float, default: 0
994             Lower y-coordinate of the span, in y-axis units (0-1).
995         ymax : float, default: 1
996             Upper y-coordinate of the span, in y-axis units (0-1).
997 
998         Returns
999         -------
1000         `~matplotlib.patches.Polygon`
1001             Vertical span (rectangle) from (xmin, ymin) to (xmax, ymax).
1002 
1003         Other Parameters
1004         ----------------
1005         **kwargs : `~matplotlib.patches.Polygon` properties
1006 
1007         %(Polygon:kwdoc)s
1008 
1009         See Also
1010         --------
1011         axhspan : Add a horizontal span across the Axes.
1012 
1013         Examples
1014         --------
1015         Draw a vertical, green, translucent rectangle from x = 1.25 to
1016         x = 1.55 that spans the yrange of the Axes.
1017 
1018         >>> axvspan(1.25, 1.55, facecolor='g', alpha=0.5)
1019 
1020         """
1021         # Strip units away.
1022         self._check_no_units([ymin, ymax], ['ymin', 'ymax'])
1023         (xmin, xmax), = self._process_unit_info([("x", [xmin, xmax])], kwargs)
1024 
1025         verts = [(xmin, ymin), (xmin, ymax), (xmax, ymax), (xmax, ymin)]
1026         p = mpatches.Polygon(verts, **kwargs)
1027         p.set_transform(self.get_xaxis_transform(which="grid"))
1028         p.get_path()._interpolation_steps = 100
1029         self.add_patch(p)
1030         self._request_autoscale_view("x")
1031         return p
1032 
1033     @_preprocess_data(replace_names=["y", "xmin", "xmax", "colors"],
1034                       label_namer="y")
1035     def hlines(self, y, xmin, xmax, colors=None, linestyles='solid',
1036                label='', **kwargs):
1037         """
1038         Plot horizontal lines at each *y* from *xmin* to *xmax*.
1039 
1040         Parameters
1041         ----------
1042         y : float or array-like
1043             y-indexes where to plot the lines.
1044 
1045         xmin, xmax : float or array-like
1046             Respective beginning and end of each line. If scalars are
1047             provided, all lines will have the same length.
1048 
1049         colors : list of colors, default: :rc:`lines.color`
1050 
1051         linestyles : {'solid', 'dashed', 'dashdot', 'dotted'}, optional
1052 
1053         label : str, default: ''
1054 
1055         Returns
1056         -------
1057         `~matplotlib.collections.LineCollection`
1058 
1059         Other Parameters
1060         ----------------
1061         data : indexable object, optional
1062             DATA_PARAMETER_PLACEHOLDER
1063         **kwargs :  `~matplotlib.collections.LineCollection` properties.
1064 
1065         See Also
1066         --------
1067         vlines : vertical lines
1068         axhline : horizontal line across the Axes
1069         """
1070 
1071         # We do the conversion first since not all unitized data is uniform
1072         xmin, xmax, y = self._process_unit_info(
1073             [("x", xmin), ("x", xmax), ("y", y)], kwargs)
1074 
1075         if not np.iterable(y):
1076             y = [y]
1077         if not np.iterable(xmin):
1078             xmin = [xmin]
1079         if not np.iterable(xmax):
1080             xmax = [xmax]
1081 
1082         # Create and combine masked_arrays from input
1083         y, xmin, xmax = cbook._combine_masks(y, xmin, xmax)
1084         y = np.ravel(y)
1085         xmin = np.ravel(xmin)
1086         xmax = np.ravel(xmax)
1087 
1088         masked_verts = np.ma.empty((len(y), 2, 2))
1089         masked_verts[:, 0, 0] = xmin
1090         masked_verts[:, 0, 1] = y
1091         masked_verts[:, 1, 0] = xmax
1092         masked_verts[:, 1, 1] = y
1093 
1094         lines = mcoll.LineCollection(masked_verts, colors=colors,
1095                                      linestyles=linestyles, label=label)
1096         self.add_collection(lines, autolim=False)
1097         lines._internal_update(kwargs)
1098 
1099         if len(y) > 0:
1100             # Extreme values of xmin/xmax/y.  Using masked_verts here handles
1101             # the case of y being a masked *object* array (as can be generated
1102             # e.g. by errorbar()), which would make nanmin/nanmax stumble.
1103             minx = np.nanmin(masked_verts[..., 0])
1104             maxx = np.nanmax(masked_verts[..., 0])
1105             miny = np.nanmin(masked_verts[..., 1])
1106             maxy = np.nanmax(masked_verts[..., 1])
1107             corners = (minx, miny), (maxx, maxy)
1108             self.update_datalim(corners)
1109             self._request_autoscale_view()
1110 
1111         return lines
1112 
1113     @_preprocess_data(replace_names=["x", "ymin", "ymax", "colors"],
1114                       label_namer="x")
1115     def vlines(self, x, ymin, ymax, colors=None, linestyles='solid',
1116                label='', **kwargs):
1117         """
1118         Plot vertical lines at each *x* from *ymin* to *ymax*.
1119 
1120         Parameters
1121         ----------
1122         x : float or array-like
1123             x-indexes where to plot the lines.
1124 
1125         ymin, ymax : float or array-like
1126             Respective beginning and end of each line. If scalars are
1127             provided, all lines will have the same length.
1128 
1129         colors : list of colors, default: :rc:`lines.color`
1130 
1131         linestyles : {'solid', 'dashed', 'dashdot', 'dotted'}, optional
1132 
1133         label : str, default: ''
1134 
1135         Returns
1136         -------
1137         `~matplotlib.collections.LineCollection`
1138 
1139         Other Parameters
1140         ----------------
1141         data : indexable object, optional
1142             DATA_PARAMETER_PLACEHOLDER
1143         **kwargs : `~matplotlib.collections.LineCollection` properties.
1144 
1145         See Also
1146         --------
1147         hlines : horizontal lines
1148         axvline : vertical line across the Axes
1149         """
1150 
1151         # We do the conversion first since not all unitized data is uniform
1152         x, ymin, ymax = self._process_unit_info(
1153             [("x", x), ("y", ymin), ("y", ymax)], kwargs)
1154 
1155         if not np.iterable(x):
1156             x = [x]
1157         if not np.iterable(ymin):
1158             ymin = [ymin]
1159         if not np.iterable(ymax):
1160             ymax = [ymax]
1161 
1162         # Create and combine masked_arrays from input
1163         x, ymin, ymax = cbook._combine_masks(x, ymin, ymax)
1164         x = np.ravel(x)
1165         ymin = np.ravel(ymin)
1166         ymax = np.ravel(ymax)
1167 
1168         masked_verts = np.ma.empty((len(x), 2, 2))
1169         masked_verts[:, 0, 0] = x
1170         masked_verts[:, 0, 1] = ymin
1171         masked_verts[:, 1, 0] = x
1172         masked_verts[:, 1, 1] = ymax
1173 
1174         lines = mcoll.LineCollection(masked_verts, colors=colors,
1175                                      linestyles=linestyles, label=label)
1176         self.add_collection(lines, autolim=False)
1177         lines._internal_update(kwargs)
1178 
1179         if len(x) > 0:
1180             # Extreme values of x/ymin/ymax.  Using masked_verts here handles
1181             # the case of x being a masked *object* array (as can be generated
1182             # e.g. by errorbar()), which would make nanmin/nanmax stumble.
1183             minx = np.nanmin(masked_verts[..., 0])
1184             maxx = np.nanmax(masked_verts[..., 0])
1185             miny = np.nanmin(masked_verts[..., 1])
1186             maxy = np.nanmax(masked_verts[..., 1])
1187             corners = (minx, miny), (maxx, maxy)
1188             self.update_datalim(corners)
1189             self._request_autoscale_view()
1190 
1191         return lines
1192 
1193     @_preprocess_data(replace_names=["positions", "lineoffsets",
1194                                      "linelengths", "linewidths",
1195                                      "colors", "linestyles"])
1196     @_docstring.dedent_interpd
1197     def eventplot(self, positions, orientation='horizontal', lineoffsets=1,
1198                   linelengths=1, linewidths=None, colors=None, alpha=None,
1199                   linestyles='solid', **kwargs):
1200         """
1201         Plot identical parallel lines at the given positions.
1202 
1203         This type of plot is commonly used in neuroscience for representing
1204         neural events, where it is usually called a spike raster, dot raster,
1205         or raster plot.
1206 
1207         However, it is useful in any situation where you wish to show the
1208         timing or position of multiple sets of discrete events, such as the
1209         arrival times of people to a business on each day of the month or the
1210         date of hurricanes each year of the last century.
1211 
1212         Parameters
1213         ----------
1214         positions : array-like or list of array-like
1215             A 1D array-like defines the positions of one sequence of events.
1216 
1217             Multiple groups of events may be passed as a list of array-likes.
1218             Each group can be styled independently by passing lists of values
1219             to *lineoffsets*, *linelengths*, *linewidths*, *colors* and
1220             *linestyles*.
1221 
1222             Note that *positions* can be a 2D array, but in practice different
1223             event groups usually have different counts so that one will use a
1224             list of different-length arrays rather than a 2D array.
1225 
1226         orientation : {'horizontal', 'vertical'}, default: 'horizontal'
1227             The direction of the event sequence:
1228 
1229             - 'horizontal': the events are arranged horizontally.
1230               The indicator lines are vertical.
1231             - 'vertical': the events are arranged vertically.
1232               The indicator lines are horizontal.
1233 
1234         lineoffsets : float or array-like, default: 1
1235             The offset of the center of the lines from the origin, in the
1236             direction orthogonal to *orientation*.
1237 
1238             If *positions* is 2D, this can be a sequence with length matching
1239             the length of *positions*.
1240 
1241         linelengths : float or array-like, default: 1
1242             The total height of the lines (i.e. the lines stretches from
1243             ``lineoffset - linelength/2`` to ``lineoffset + linelength/2``).
1244 
1245             If *positions* is 2D, this can be a sequence with length matching
1246             the length of *positions*.
1247 
1248         linewidths : float or array-like, default: :rc:`lines.linewidth`
1249             The line width(s) of the event lines, in points.
1250 
1251             If *positions* is 2D, this can be a sequence with length matching
1252             the length of *positions*.
1253 
1254         colors : color or list of colors, default: :rc:`lines.color`
1255             The color(s) of the event lines.
1256 
1257             If *positions* is 2D, this can be a sequence with length matching
1258             the length of *positions*.
1259 
1260         alpha : float or array-like, default: 1
1261             The alpha blending value(s), between 0 (transparent) and 1
1262             (opaque).
1263 
1264             If *positions* is 2D, this can be a sequence with length matching
1265             the length of *positions*.
1266 
1267         linestyles : str or tuple or list of such values, default: 'solid'
1268             Default is 'solid'. Valid strings are ['solid', 'dashed',
1269             'dashdot', 'dotted', '-', '--', '-.', ':']. Dash tuples
1270             should be of the form::
1271 
1272                 (offset, onoffseq),
1273 
1274             where *onoffseq* is an even length tuple of on and off ink
1275             in points.
1276 
1277             If *positions* is 2D, this can be a sequence with length matching
1278             the length of *positions*.
1279 
1280         data : indexable object, optional
1281             DATA_PARAMETER_PLACEHOLDER
1282 
1283         **kwargs
1284             Other keyword arguments are line collection properties.  See
1285             `.LineCollection` for a list of the valid properties.
1286 
1287         Returns
1288         -------
1289         list of `.EventCollection`
1290             The `.EventCollection` that were added.
1291 
1292         Notes
1293         -----
1294         For *linelengths*, *linewidths*, *colors*, *alpha* and *linestyles*, if
1295         only a single value is given, that value is applied to all lines. If an
1296         array-like is given, it must have the same length as *positions*, and
1297         each value will be applied to the corresponding row of the array.
1298 
1299         Examples
1300         --------
1301         .. plot:: gallery/lines_bars_and_markers/eventplot_demo.py
1302         """
1303 
1304         lineoffsets, linelengths = self._process_unit_info(
1305                 [("y", lineoffsets), ("y", linelengths)], kwargs)
1306 
1307         # fix positions, noting that it can be a list of lists:
1308         if not np.iterable(positions):
1309             positions = [positions]
1310         elif any(np.iterable(position) for position in positions):
1311             positions = [np.asanyarray(position) for position in positions]
1312         else:
1313             positions = [np.asanyarray(positions)]
1314 
1315         if len(positions) == 0:
1316             return []
1317 
1318         poss = []
1319         for position in positions:
1320             poss += self._process_unit_info([("x", position)], kwargs)
1321         positions = poss
1322 
1323         # prevent 'singular' keys from **kwargs dict from overriding the effect
1324         # of 'plural' keyword arguments (e.g. 'color' overriding 'colors')
1325         colors = cbook._local_over_kwdict(colors, kwargs, 'color')
1326         linewidths = cbook._local_over_kwdict(linewidths, kwargs, 'linewidth')
1327         linestyles = cbook._local_over_kwdict(linestyles, kwargs, 'linestyle')
1328 
1329         if not np.iterable(lineoffsets):
1330             lineoffsets = [lineoffsets]
1331         if not np.iterable(linelengths):
1332             linelengths = [linelengths]
1333         if not np.iterable(linewidths):
1334             linewidths = [linewidths]
1335         if not np.iterable(colors):
1336             colors = [colors]
1337         if not np.iterable(alpha):
1338             alpha = [alpha]
1339         if hasattr(linestyles, 'lower') or not np.iterable(linestyles):
1340             linestyles = [linestyles]
1341 
1342         lineoffsets = np.asarray(lineoffsets)
1343         linelengths = np.asarray(linelengths)
1344         linewidths = np.asarray(linewidths)
1345 
1346         if len(lineoffsets) == 0:
1347             lineoffsets = [None]
1348         if len(linelengths) == 0:
1349             linelengths = [None]
1350         if len(linewidths) == 0:
1351             lineoffsets = [None]
1352         if len(linewidths) == 0:
1353             lineoffsets = [None]
1354         if len(colors) == 0:
1355             colors = [None]
1356         try:
1357             # Early conversion of the colors into RGBA values to take care
1358             # of cases like colors='0.5' or colors='C1'.  (Issue #8193)
1359             colors = mcolors.to_rgba_array(colors)
1360         except ValueError:
1361             # Will fail if any element of *colors* is None. But as long
1362             # as len(colors) == 1 or len(positions), the rest of the
1363             # code should process *colors* properly.
1364             pass
1365 
1366         if len(lineoffsets) == 1 and len(positions) != 1:
1367             lineoffsets = np.tile(lineoffsets, len(positions))
1368             lineoffsets[0] = 0
1369             lineoffsets = np.cumsum(lineoffsets)
1370         if len(linelengths) == 1:
1371             linelengths = np.tile(linelengths, len(positions))
1372         if len(linewidths) == 1:
1373             linewidths = np.tile(linewidths, len(positions))
1374         if len(colors) == 1:
1375             colors = list(colors) * len(positions)
1376         if len(alpha) == 1:
1377             alpha = list(alpha) * len(positions)
1378         if len(linestyles) == 1:
1379             linestyles = [linestyles] * len(positions)
1380 
1381         if len(lineoffsets) != len(positions):
1382             raise ValueError('lineoffsets and positions are unequal sized '
1383                              'sequences')
1384         if len(linelengths) != len(positions):
1385             raise ValueError('linelengths and positions are unequal sized '
1386                              'sequences')
1387         if len(linewidths) != len(positions):
1388             raise ValueError('linewidths and positions are unequal sized '
1389                              'sequences')
1390         if len(colors) != len(positions):
1391             raise ValueError('colors and positions are unequal sized '
1392                              'sequences')
1393         if len(alpha) != len(positions):
1394             raise ValueError('alpha and positions are unequal sized '
1395                              'sequences')
1396         if len(linestyles) != len(positions):
1397             raise ValueError('linestyles and positions are unequal sized '
1398                              'sequences')
1399 
1400         colls = []
1401         for position, lineoffset, linelength, linewidth, color, alpha_, \
1402             linestyle in \
1403                 zip(positions, lineoffsets, linelengths, linewidths,
1404                     colors, alpha, linestyles):
1405             coll = mcoll.EventCollection(position,
1406                                          orientation=orientation,
1407                                          lineoffset=lineoffset,
1408                                          linelength=linelength,
1409                                          linewidth=linewidth,
1410                                          color=color,
1411                                          alpha=alpha_,
1412                                          linestyle=linestyle)
1413             self.add_collection(coll, autolim=False)
1414             coll._internal_update(kwargs)
1415             colls.append(coll)
1416 
1417         if len(positions) > 0:
1418             # try to get min/max
1419             min_max = [(np.min(_p), np.max(_p)) for _p in positions
1420                        if len(_p) > 0]
1421             # if we have any non-empty positions, try to autoscale
1422             if len(min_max) > 0:
1423                 mins, maxes = zip(*min_max)
1424                 minpos = np.min(mins)
1425                 maxpos = np.max(maxes)
1426 
1427                 minline = (lineoffsets - linelengths).min()
1428                 maxline = (lineoffsets + linelengths).max()
1429 
1430                 if orientation == "vertical":
1431                     corners = (minline, minpos), (maxline, maxpos)
1432                 else:  # "horizontal"
1433                     corners = (minpos, minline), (maxpos, maxline)
1434                 self.update_datalim(corners)
1435                 self._request_autoscale_view()
1436 
1437         return colls
1438 
1439     #### Basic plotting
1440 
1441     # Uses a custom implementation of data-kwarg handling in
1442     # _process_plot_var_args.
1443     @_docstring.dedent_interpd
1444     def plot(self, *args, scalex=True, scaley=True, data=None, **kwargs):
1445         """
1446         Plot y versus x as lines and/or markers.
1447 
1448         Call signatures::
1449 
1450             plot([x], y, [fmt], *, data=None, **kwargs)
1451             plot([x], y, [fmt], [x2], y2, [fmt2], ..., **kwargs)
1452 
1453         The coordinates of the points or line nodes are given by *x*, *y*.
1454 
1455         The optional parameter *fmt* is a convenient way for defining basic
1456         formatting like color, marker and linestyle. It's a shortcut string
1457         notation described in the *Notes* section below.
1458 
1459         >>> plot(x, y)        # plot x and y using default line style and color
1460         >>> plot(x, y, 'bo')  # plot x and y using blue circle markers
1461         >>> plot(y)           # plot y using x as index array 0..N-1
1462         >>> plot(y, 'r+')     # ditto, but with red plusses
1463 
1464         You can use `.Line2D` properties as keyword arguments for more
1465         control on the appearance. Line properties and *fmt* can be mixed.
1466         The following two calls yield identical results:
1467 
1468         >>> plot(x, y, 'go--', linewidth=2, markersize=12)
1469         >>> plot(x, y, color='green', marker='o', linestyle='dashed',
1470         ...      linewidth=2, markersize=12)
1471 
1472         When conflicting with *fmt*, keyword arguments take precedence.
1473 
1474 
1475         **Plotting labelled data**
1476 
1477         There's a convenient way for plotting objects with labelled data (i.e.
1478         data that can be accessed by index ``obj['y']``). Instead of giving
1479         the data in *x* and *y*, you can provide the object in the *data*
1480         parameter and just give the labels for *x* and *y*::
1481 
1482         >>> plot('xlabel', 'ylabel', data=obj)
1483 
1484         All indexable objects are supported. This could e.g. be a `dict`, a
1485         `pandas.DataFrame` or a structured numpy array.
1486 
1487 
1488         **Plotting multiple sets of data**
1489 
1490         There are various ways to plot multiple sets of data.
1491 
1492         - The most straight forward way is just to call `plot` multiple times.
1493           Example:
1494 
1495           >>> plot(x1, y1, 'bo')
1496           >>> plot(x2, y2, 'go')
1497 
1498         - If *x* and/or *y* are 2D arrays a separate data set will be drawn
1499           for every column. If both *x* and *y* are 2D, they must have the
1500           same shape. If only one of them is 2D with shape (N, m) the other
1501           must have length N and will be used for every data set m.
1502 
1503           Example:
1504 
1505           >>> x = [1, 2, 3]
1506           >>> y = np.array([[1, 2], [3, 4], [5, 6]])
1507           >>> plot(x, y)
1508 
1509           is equivalent to:
1510 
1511           >>> for col in range(y.shape[1]):
1512           ...     plot(x, y[:, col])
1513 
1514         - The third way is to specify multiple sets of *[x]*, *y*, *[fmt]*
1515           groups::
1516 
1517           >>> plot(x1, y1, 'g^', x2, y2, 'g-')
1518 
1519           In this case, any additional keyword argument applies to all
1520           datasets. Also, this syntax cannot be combined with the *data*
1521           parameter.
1522 
1523         By default, each line is assigned a different style specified by a
1524         'style cycle'. The *fmt* and line property parameters are only
1525         necessary if you want explicit deviations from these defaults.
1526         Alternatively, you can also change the style cycle using
1527         :rc:`axes.prop_cycle`.
1528 
1529 
1530         Parameters
1531         ----------
1532         x, y : array-like or scalar
1533             The horizontal / vertical coordinates of the data points.
1534             *x* values are optional and default to ``range(len(y))``.
1535 
1536             Commonly, these parameters are 1D arrays.
1537 
1538             They can also be scalars, or two-dimensional (in that case, the
1539             columns represent separate data sets).
1540 
1541             These arguments cannot be passed as keywords.
1542 
1543         fmt : str, optional
1544             A format string, e.g. 'ro' for red circles. See the *Notes*
1545             section for a full description of the format strings.
1546 
1547             Format strings are just an abbreviation for quickly setting
1548             basic line properties. All of these and more can also be
1549             controlled by keyword arguments.
1550 
1551             This argument cannot be passed as keyword.
1552 
1553         data : indexable object, optional
1554             An object with labelled data. If given, provide the label names to
1555             plot in *x* and *y*.
1556 
1557             .. note::
1558                 Technically there's a slight ambiguity in calls where the
1559                 second label is a valid *fmt*. ``plot('n', 'o', data=obj)``
1560                 could be ``plt(x, y)`` or ``plt(y, fmt)``. In such cases,
1561                 the former interpretation is chosen, but a warning is issued.
1562                 You may suppress the warning by adding an empty format string
1563                 ``plot('n', 'o', '', data=obj)``.
1564 
1565         Returns
1566         -------
1567         list of `.Line2D`
1568             A list of lines representing the plotted data.
1569 
1570         Other Parameters
1571         ----------------
1572         scalex, scaley : bool, default: True
1573             These parameters determine if the view limits are adapted to the
1574             data limits. The values are passed on to
1575             `~.axes.Axes.autoscale_view`.
1576 
1577         **kwargs : `.Line2D` properties, optional
1578             *kwargs* are used to specify properties like a line label (for
1579             auto legends), linewidth, antialiasing, marker face color.
1580             Example::
1581 
1582             >>> plot([1, 2, 3], [1, 2, 3], 'go-', label='line 1', linewidth=2)
1583             >>> plot([1, 2, 3], [1, 4, 9], 'rs', label='line 2')
1584 
1585             If you specify multiple lines with one plot call, the kwargs apply
1586             to all those lines. In case the label object is iterable, each
1587             element is used as labels for each set of data.
1588 
1589             Here is a list of available `.Line2D` properties:
1590 
1591             %(Line2D:kwdoc)s
1592 
1593         See Also
1594         --------
1595         scatter : XY scatter plot with markers of varying size and/or color (
1596             sometimes also called bubble chart).
1597 
1598         Notes
1599         -----
1600         **Format Strings**
1601 
1602         A format string consists of a part for color, marker and line::
1603 
1604             fmt = '[marker][line][color]'
1605 
1606         Each of them is optional. If not provided, the value from the style
1607         cycle is used. Exception: If ``line`` is given, but no ``marker``,
1608         the data will be a line without markers.
1609 
1610         Other combinations such as ``[color][marker][line]`` are also
1611         supported, but note that their parsing may be ambiguous.
1612 
1613         **Markers**
1614 
1615         =============   ===============================
1616         character       description
1617         =============   ===============================
1618         ``'.'``         point marker
1619         ``','``         pixel marker
1620         ``'o'``         circle marker
1621         ``'v'``         triangle_down marker
1622         ``'^'``         triangle_up marker
1623         ``'<'``         triangle_left marker
1624         ``'>'``         triangle_right marker
1625         ``'1'``         tri_down marker
1626         ``'2'``         tri_up marker
1627         ``'3'``         tri_left marker
1628         ``'4'``         tri_right marker
1629         ``'8'``         octagon marker
1630         ``'s'``         square marker
1631         ``'p'``         pentagon marker
1632         ``'P'``         plus (filled) marker
1633         ``'*'``         star marker
1634         ``'h'``         hexagon1 marker
1635         ``'H'``         hexagon2 marker
1636         ``'+'``         plus marker
1637         ``'x'``         x marker
1638         ``'X'``         x (filled) marker
1639         ``'D'``         diamond marker
1640         ``'d'``         thin_diamond marker
1641         ``'|'``         vline marker
1642         ``'_'``         hline marker
1643         =============   ===============================
1644 
1645         **Line Styles**
1646 
1647         =============    ===============================
1648         character        description
1649         =============    ===============================
1650         ``'-'``          solid line style
1651         ``'--'``         dashed line style
1652         ``'-.'``         dash-dot line style
1653         ``':'``          dotted line style
1654         =============    ===============================
1655 
1656         Example format strings::
1657 
1658             'b'    # blue markers with default shape
1659             'or'   # red circles
1660             '-g'   # green solid line
1661             '--'   # dashed line with default color
1662             '^k:'  # black triangle_up markers connected by a dotted line
1663 
1664         **Colors**
1665 
1666         The supported color abbreviations are the single letter codes
1667 
1668         =============    ===============================
1669         character        color
1670         =============    ===============================
1671         ``'b'``          blue
1672         ``'g'``          green
1673         ``'r'``          red
1674         ``'c'``          cyan
1675         ``'m'``          magenta
1676         ``'y'``          yellow
1677         ``'k'``          black
1678         ``'w'``          white
1679         =============    ===============================
1680 
1681         and the ``'CN'`` colors that index into the default property cycle.
1682 
1683         If the color is the only part of the format string, you can
1684         additionally use any  `matplotlib.colors` spec, e.g. full names
1685         (``'green'``) or hex strings (``'#008000'``).
1686         """
1687         kwargs = cbook.normalize_kwargs(kwargs, mlines.Line2D)
1688         lines = [*self._get_lines(*args, data=data, **kwargs)]
1689         for line in lines:
1690             self.add_line(line)
1691         if scalex:
1692             self._request_autoscale_view("x")
1693         if scaley:
1694             self._request_autoscale_view("y")
1695         return lines
1696 
1697     @_preprocess_data(replace_names=["x", "y"], label_namer="y")
1698     @_docstring.dedent_interpd
1699     def plot_date(self, x, y, fmt='o', tz=None, xdate=True, ydate=False,
1700                   **kwargs):
1701         """
1702         [*Discouraged*] Plot coercing the axis to treat floats as dates.
1703 
1704         .. admonition:: Discouraged
1705 
1706             This method exists for historic reasons and will be deprecated in
1707             the future.
1708 
1709             - ``datetime``-like data should directly be plotted using
1710               `~.Axes.plot`.
1711             -  If you need to plot plain numeric data as :ref:`date-format` or
1712                need to set a timezone, call ``ax.xaxis.axis_date`` /
1713                ``ax.yaxis.axis_date`` before `~.Axes.plot`. See
1714                `.Axis.axis_date`.
1715 
1716         Similar to `.plot`, this plots *y* vs. *x* as lines or markers.
1717         However, the axis labels are formatted as dates depending on *xdate*
1718         and *ydate*.  Note that `.plot` will work with `datetime` and
1719         `numpy.datetime64` objects without resorting to this method.
1720 
1721         Parameters
1722         ----------
1723         x, y : array-like
1724             The coordinates of the data points. If *xdate* or *ydate* is
1725             *True*, the respective values *x* or *y* are interpreted as
1726             :ref:`Matplotlib dates <date-format>`.
1727 
1728         fmt : str, optional
1729             The plot format string. For details, see the corresponding
1730             parameter in `.plot`.
1731 
1732         tz : timezone string or `datetime.tzinfo`, default: :rc:`timezone`
1733             The time zone to use in labeling dates.
1734 
1735         xdate : bool, default: True
1736             If *True*, the *x*-axis will be interpreted as Matplotlib dates.
1737 
1738         ydate : bool, default: False
1739             If *True*, the *y*-axis will be interpreted as Matplotlib dates.
1740 
1741         Returns
1742         -------
1743         list of `.Line2D`
1744             Objects representing the plotted data.
1745 
1746         Other Parameters
1747         ----------------
1748         data : indexable object, optional
1749             DATA_PARAMETER_PLACEHOLDER
1750         **kwargs
1751             Keyword arguments control the `.Line2D` properties:
1752 
1753             %(Line2D:kwdoc)s
1754 
1755         See Also
1756         --------
1757         matplotlib.dates : Helper functions on dates.
1758         matplotlib.dates.date2num : Convert dates to num.
1759         matplotlib.dates.num2date : Convert num to dates.
1760         matplotlib.dates.drange : Create an equally spaced sequence of dates.
1761 
1762         Notes
1763         -----
1764         If you are using custom date tickers and formatters, it may be
1765         necessary to set the formatters/locators after the call to
1766         `.plot_date`. `.plot_date` will set the default tick locator to
1767         `.AutoDateLocator` (if the tick locator is not already set to a
1768         `.DateLocator` instance) and the default tick formatter to
1769         `.AutoDateFormatter` (if the tick formatter is not already set to a
1770         `.DateFormatter` instance).
1771         """
1772         if xdate:
1773             self.xaxis_date(tz)
1774         if ydate:
1775             self.yaxis_date(tz)
1776         return self.plot(x, y, fmt, **kwargs)
1777 
1778     # @_preprocess_data() # let 'plot' do the unpacking..
1779     @_docstring.dedent_interpd
1780     def loglog(self, *args, **kwargs):
1781         """
1782         Make a plot with log scaling on both the x- and y-axis.
1783 
1784         Call signatures::
1785 
1786             loglog([x], y, [fmt], data=None, **kwargs)
1787             loglog([x], y, [fmt], [x2], y2, [fmt2], ..., **kwargs)
1788 
1789         This is just a thin wrapper around `.plot` which additionally changes
1790         both the x-axis and the y-axis to log scaling. All the concepts and
1791         parameters of plot can be used here as well.
1792 
1793         The additional parameters *base*, *subs* and *nonpositive* control the
1794         x/y-axis properties. They are just forwarded to `.Axes.set_xscale` and
1795         `.Axes.set_yscale`. To use different properties on the x-axis and the
1796         y-axis, use e.g.
1797         ``ax.set_xscale("log", base=10); ax.set_yscale("log", base=2)``.
1798 
1799         Parameters
1800         ----------
1801         base : float, default: 10
1802             Base of the logarithm.
1803 
1804         subs : sequence, optional
1805             The location of the minor ticks. If *None*, reasonable locations
1806             are automatically chosen depending on the number of decades in the
1807             plot. See `.Axes.set_xscale`/`.Axes.set_yscale` for details.
1808 
1809         nonpositive : {'mask', 'clip'}, default: 'mask'
1810             Non-positive values can be masked as invalid, or clipped to a very
1811             small positive number.
1812 
1813         **kwargs
1814             All parameters supported by `.plot`.
1815 
1816         Returns
1817         -------
1818         list of `.Line2D`
1819             Objects representing the plotted data.
1820         """
1821         dx = {k: v for k, v in kwargs.items()
1822               if k in ['base', 'subs', 'nonpositive',
1823                        'basex', 'subsx', 'nonposx']}
1824         self.set_xscale('log', **dx)
1825         dy = {k: v for k, v in kwargs.items()
1826               if k in ['base', 'subs', 'nonpositive',
1827                        'basey', 'subsy', 'nonposy']}
1828         self.set_yscale('log', **dy)
1829         return self.plot(
1830             *args, **{k: v for k, v in kwargs.items() if k not in {*dx, *dy}})
1831 
1832     # @_preprocess_data() # let 'plot' do the unpacking..
1833     @_docstring.dedent_interpd
1834     def semilogx(self, *args, **kwargs):
1835         """
1836         Make a plot with log scaling on the x-axis.
1837 
1838         Call signatures::
1839 
1840             semilogx([x], y, [fmt], data=None, **kwargs)
1841             semilogx([x], y, [fmt], [x2], y2, [fmt2], ..., **kwargs)
1842 
1843         This is just a thin wrapper around `.plot` which additionally changes
1844         the x-axis to log scaling. All the concepts and parameters of plot can
1845         be used here as well.
1846 
1847         The additional parameters *base*, *subs*, and *nonpositive* control the
1848         x-axis properties. They are just forwarded to `.Axes.set_xscale`.
1849 
1850         Parameters
1851         ----------
1852         base : float, default: 10
1853             Base of the x logarithm.
1854 
1855         subs : array-like, optional
1856             The location of the minor xticks. If *None*, reasonable locations
1857             are automatically chosen depending on the number of decades in the
1858             plot. See `.Axes.set_xscale` for details.
1859 
1860         nonpositive : {'mask', 'clip'}, default: 'mask'
1861             Non-positive values in x can be masked as invalid, or clipped to a
1862             very small positive number.
1863 
1864         **kwargs
1865             All parameters supported by `.plot`.
1866 
1867         Returns
1868         -------
1869         list of `.Line2D`
1870             Objects representing the plotted data.
1871         """
1872         d = {k: v for k, v in kwargs.items()
1873              if k in ['base', 'subs', 'nonpositive',
1874                       'basex', 'subsx', 'nonposx']}
1875         self.set_xscale('log', **d)
1876         return self.plot(
1877             *args, **{k: v for k, v in kwargs.items() if k not in d})
1878 
1879     # @_preprocess_data() # let 'plot' do the unpacking..
1880     @_docstring.dedent_interpd
1881     def semilogy(self, *args, **kwargs):
1882         """
1883         Make a plot with log scaling on the y-axis.
1884 
1885         Call signatures::
1886 
1887             semilogy([x], y, [fmt], data=None, **kwargs)
1888             semilogy([x], y, [fmt], [x2], y2, [fmt2], ..., **kwargs)
1889 
1890         This is just a thin wrapper around `.plot` which additionally changes
1891         the y-axis to log scaling. All the concepts and parameters of plot can
1892         be used here as well.
1893 
1894         The additional parameters *base*, *subs*, and *nonpositive* control the
1895         y-axis properties. They are just forwarded to `.Axes.set_yscale`.
1896 
1897         Parameters
1898         ----------
1899         base : float, default: 10
1900             Base of the y logarithm.
1901 
1902         subs : array-like, optional
1903             The location of the minor yticks. If *None*, reasonable locations
1904             are automatically chosen depending on the number of decades in the
1905             plot. See `.Axes.set_yscale` for details.
1906 
1907         nonpositive : {'mask', 'clip'}, default: 'mask'
1908             Non-positive values in y can be masked as invalid, or clipped to a
1909             very small positive number.
1910 
1911         **kwargs
1912             All parameters supported by `.plot`.
1913 
1914         Returns
1915         -------
1916         list of `.Line2D`
1917             Objects representing the plotted data.
1918         """
1919         d = {k: v for k, v in kwargs.items()
1920              if k in ['base', 'subs', 'nonpositive',
1921                       'basey', 'subsy', 'nonposy']}
1922         self.set_yscale('log', **d)
1923         return self.plot(
1924             *args, **{k: v for k, v in kwargs.items() if k not in d})
1925 
1926     @_preprocess_data(replace_names=["x"], label_namer="x")
1927     def acorr(self, x, **kwargs):
1928         """
1929         Plot the autocorrelation of *x*.
1930 
1931         Parameters
1932         ----------
1933         x : array-like
1934 
1935         detrend : callable, default: `.mlab.detrend_none` (no detrending)
1936             A detrending function applied to *x*.  It must have the
1937             signature ::
1938 
1939                 detrend(x: np.ndarray) -> np.ndarray
1940 
1941         normed : bool, default: True
1942             If ``True``, input vectors are normalised to unit length.
1943 
1944         usevlines : bool, default: True
1945             Determines the plot style.
1946 
1947             If ``True``, vertical lines are plotted from 0 to the acorr value
1948             using `.Axes.vlines`. Additionally, a horizontal line is plotted
1949             at y=0 using `.Axes.axhline`.
1950 
1951             If ``False``, markers are plotted at the acorr values using
1952             `.Axes.plot`.
1953 
1954         maxlags : int, default: 10
1955             Number of lags to show. If ``None``, will return all
1956             ``2 * len(x) - 1`` lags.
1957 
1958         Returns
1959         -------
1960         lags : array (length ``2*maxlags+1``)
1961             The lag vector.
1962         c : array  (length ``2*maxlags+1``)
1963             The auto correlation vector.
1964         line : `.LineCollection` or `.Line2D`
1965             `.Artist` added to the Axes of the correlation:
1966 
1967             - `.LineCollection` if *usevlines* is True.
1968             - `.Line2D` if *usevlines* is False.
1969         b : `.Line2D` or None
1970             Horizontal line at 0 if *usevlines* is True
1971             None *usevlines* is False.
1972 
1973         Other Parameters
1974         ----------------
1975         linestyle : `.Line2D` property, optional
1976             The linestyle for plotting the data points.
1977             Only used if *usevlines* is ``False``.
1978 
1979         marker : str, default: 'o'
1980             The marker for plotting the data points.
1981             Only used if *usevlines* is ``False``.
1982 
1983         data : indexable object, optional
1984             DATA_PARAMETER_PLACEHOLDER
1985 
1986         **kwargs
1987             Additional parameters are passed to `.Axes.vlines` and
1988             `.Axes.axhline` if *usevlines* is ``True``; otherwise they are
1989             passed to `.Axes.plot`.
1990 
1991         Notes
1992         -----
1993         The cross correlation is performed with `numpy.correlate` with
1994         ``mode = "full"``.
1995         """
1996         return self.xcorr(x, x, **kwargs)
1997 
1998     @_preprocess_data(replace_names=["x", "y"], label_namer="y")
1999     def xcorr(self, x, y, normed=True, detrend=mlab.detrend_none,
2000               usevlines=True, maxlags=10, **kwargs):
2001         r"""
2002         Plot the cross correlation between *x* and *y*.
2003 
2004         The correlation with lag k is defined as
2005         :math:`\sum_n x[n+k] \cdot y^*[n]`, where :math:`y^*` is the complex
2006         conjugate of :math:`y`.
2007 
2008         Parameters
2009         ----------
2010         x, y : array-like of length n
2011 
2012         detrend : callable, default: `.mlab.detrend_none` (no detrending)
2013             A detrending function applied to *x* and *y*.  It must have the
2014             signature ::
2015 
2016                 detrend(x: np.ndarray) -> np.ndarray
2017 
2018         normed : bool, default: True
2019             If ``True``, input vectors are normalised to unit length.
2020 
2021         usevlines : bool, default: True
2022             Determines the plot style.
2023 
2024             If ``True``, vertical lines are plotted from 0 to the xcorr value
2025             using `.Axes.vlines`. Additionally, a horizontal line is plotted
2026             at y=0 using `.Axes.axhline`.
2027 
2028             If ``False``, markers are plotted at the xcorr values using
2029             `.Axes.plot`.
2030 
2031         maxlags : int, default: 10
2032             Number of lags to show. If None, will return all ``2 * len(x) - 1``
2033             lags.
2034 
2035         Returns
2036         -------
2037         lags : array (length ``2*maxlags+1``)
2038             The lag vector.
2039         c : array  (length ``2*maxlags+1``)
2040             The auto correlation vector.
2041         line : `.LineCollection` or `.Line2D`
2042             `.Artist` added to the Axes of the correlation:
2043 
2044             - `.LineCollection` if *usevlines* is True.
2045             - `.Line2D` if *usevlines* is False.
2046         b : `.Line2D` or None
2047             Horizontal line at 0 if *usevlines* is True
2048             None *usevlines* is False.
2049 
2050         Other Parameters
2051         ----------------
2052         linestyle : `.Line2D` property, optional
2053             The linestyle for plotting the data points.
2054             Only used if *usevlines* is ``False``.
2055 
2056         marker : str, default: 'o'
2057             The marker for plotting the data points.
2058             Only used if *usevlines* is ``False``.
2059 
2060         data : indexable object, optional
2061             DATA_PARAMETER_PLACEHOLDER
2062 
2063         **kwargs
2064             Additional parameters are passed to `.Axes.vlines` and
2065             `.Axes.axhline` if *usevlines* is ``True``; otherwise they are
2066             passed to `.Axes.plot`.
2067 
2068         Notes
2069         -----
2070         The cross correlation is performed with `numpy.correlate` with
2071         ``mode = "full"``.
2072         """
2073         Nx = len(x)
2074         if Nx != len(y):
2075             raise ValueError('x and y must be equal length')
2076 
2077         x = detrend(np.asarray(x))
2078         y = detrend(np.asarray(y))
2079 
2080         correls = np.correlate(x, y, mode="full")
2081 
2082         if normed:
2083             correls /= np.sqrt(np.dot(x, x) * np.dot(y, y))
2084 
2085         if maxlags is None:
2086             maxlags = Nx - 1
2087 
2088         if maxlags >= Nx or maxlags < 1:
2089             raise ValueError('maxlags must be None or strictly '
2090                              'positive < %d' % Nx)
2091 
2092         lags = np.arange(-maxlags, maxlags + 1)
2093         correls = correls[Nx - 1 - maxlags:Nx + maxlags]
2094 
2095         if usevlines:
2096             a = self.vlines(lags, [0], correls, **kwargs)
2097             # Make label empty so only vertical lines get a legend entry
2098             kwargs.pop('label', '')
2099             b = self.axhline(**kwargs)
2100         else:
2101             kwargs.setdefault('marker', 'o')
2102             kwargs.setdefault('linestyle', 'None')
2103             a, = self.plot(lags, correls, **kwargs)
2104             b = None
2105         return lags, correls, a, b
2106 
2107     #### Specialized plotting
2108 
2109     # @_preprocess_data() # let 'plot' do the unpacking..
2110     def step(self, x, y, *args, where='pre', data=None, **kwargs):
2111         """
2112         Make a step plot.
2113 
2114         Call signatures::
2115 
2116             step(x, y, [fmt], *, data=None, where='pre', **kwargs)
2117             step(x, y, [fmt], x2, y2, [fmt2], ..., *, where='pre', **kwargs)
2118 
2119         This is just a thin wrapper around `.plot` which changes some
2120         formatting options. Most of the concepts and parameters of plot can be
2121         used here as well.
2122 
2123         .. note::
2124 
2125             This method uses a standard plot with a step drawstyle: The *x*
2126             values are the reference positions and steps extend left/right/both
2127             directions depending on *where*.
2128 
2129             For the common case where you know the values and edges of the
2130             steps, use `~.Axes.stairs` instead.
2131 
2132         Parameters
2133         ----------
2134         x : array-like
2135             1D sequence of x positions. It is assumed, but not checked, that
2136             it is uniformly increasing.
2137 
2138         y : array-like
2139             1D sequence of y levels.
2140 
2141         fmt : str, optional
2142             A format string, e.g. 'g' for a green line. See `.plot` for a more
2143             detailed description.
2144 
2145             Note: While full format strings are accepted, it is recommended to
2146             only specify the color. Line styles are currently ignored (use
2147             the keyword argument *linestyle* instead). Markers are accepted
2148             and plotted on the given positions, however, this is a rarely
2149             needed feature for step plots.
2150 
2151         where : {'pre', 'post', 'mid'}, default: 'pre'
2152             Define where the steps should be placed:
2153 
2154             - 'pre': The y value is continued constantly to the left from
2155               every *x* position, i.e. the interval ``(x[i-1], x[i]]`` has the
2156               value ``y[i]``.
2157             - 'post': The y value is continued constantly to the right from
2158               every *x* position, i.e. the interval ``[x[i], x[i+1])`` has the
2159               value ``y[i]``.
2160             - 'mid': Steps occur half-way between the *x* positions.
2161 
2162         data : indexable object, optional
2163             An object with labelled data. If given, provide the label names to
2164             plot in *x* and *y*.
2165 
2166         **kwargs
2167             Additional parameters are the same as those for `.plot`.
2168 
2169         Returns
2170         -------
2171         list of `.Line2D`
2172             Objects representing the plotted data.
2173         """
2174         _api.check_in_list(('pre', 'post', 'mid'), where=where)
2175         kwargs['drawstyle'] = 'steps-' + where
2176         return self.plot(x, y, *args, data=data, **kwargs)
2177 
2178     @staticmethod
2179     def _convert_dx(dx, x0, xconv, convert):
2180         """
2181         Small helper to do logic of width conversion flexibly.
2182 
2183         *dx* and *x0* have units, but *xconv* has already been converted
2184         to unitless (and is an ndarray).  This allows the *dx* to have units
2185         that are different from *x0*, but are still accepted by the
2186         ``__add__`` operator of *x0*.
2187         """
2188 
2189         # x should be an array...
2190         assert type(xconv) is np.ndarray
2191 
2192         if xconv.size == 0:
2193             # xconv has already been converted, but maybe empty...
2194             return convert(dx)
2195 
2196         try:
2197             # attempt to add the width to x0; this works for
2198             # datetime+timedelta, for instance
2199 
2200             # only use the first element of x and x0.  This saves
2201             # having to be sure addition works across the whole
2202             # vector.  This is particularly an issue if
2203             # x0 and dx are lists so x0 + dx just concatenates the lists.
2204             # We can't just cast x0 and dx to numpy arrays because that
2205             # removes the units from unit packages like `pint` that
2206             # wrap numpy arrays.
2207             try:
2208                 x0 = cbook._safe_first_finite(x0)
2209             except (TypeError, IndexError, KeyError):
2210                 pass
2211             except StopIteration:
2212                 # this means we found no finite element, fall back to first
2213                 # element unconditionally
2214                 x0 = cbook.safe_first_element(x0)
2215 
2216             try:
2217                 x = cbook._safe_first_finite(xconv)
2218             except (TypeError, IndexError, KeyError):
2219                 x = xconv
2220             except StopIteration:
2221                 # this means we found no finite element, fall back to first
2222                 # element unconditionally
2223                 x = cbook.safe_first_element(xconv)
2224 
2225             delist = False
2226             if not np.iterable(dx):
2227                 dx = [dx]
2228                 delist = True
2229             dx = [convert(x0 + ddx) - x for ddx in dx]
2230             if delist:
2231                 dx = dx[0]
2232         except (ValueError, TypeError, AttributeError):
2233             # if the above fails (for any reason) just fallback to what
2234             # we do by default and convert dx by itself.
2235             dx = convert(dx)
2236         return dx
2237 
2238     @_preprocess_data()
2239     @_docstring.dedent_interpd
2240     def bar(self, x, height, width=0.8, bottom=None, *, align="center",
2241             **kwargs):
2242         r"""
2243         Make a bar plot.
2244 
2245         The bars are positioned at *x* with the given *align*\ment. Their
2246         dimensions are given by *height* and *width*. The vertical baseline
2247         is *bottom* (default 0).
2248 
2249         Many parameters can take either a single value applying to all bars
2250         or a sequence of values, one for each bar.
2251 
2252         Parameters
2253         ----------
2254         x : float or array-like
2255             The x coordinates of the bars. See also *align* for the
2256             alignment of the bars to the coordinates.
2257 
2258         height : float or array-like
2259             The height(s) of the bars.
2260 
2261         width : float or array-like, default: 0.8
2262             The width(s) of the bars.
2263 
2264         bottom : float or array-like, default: 0
2265             The y coordinate(s) of the bottom side(s) of the bars.
2266 
2267         align : {'center', 'edge'}, default: 'center'
2268             Alignment of the bars to the *x* coordinates:
2269 
2270             - 'center': Center the base on the *x* positions.
2271             - 'edge': Align the left edges of the bars with the *x* positions.
2272 
2273             To align the bars on the right edge pass a negative *width* and
2274             ``align='edge'``.
2275 
2276         Returns
2277         -------
2278         `.BarContainer`
2279             Container with all the bars and optionally errorbars.
2280 
2281         Other Parameters
2282         ----------------
2283         color : color or list of color, optional
2284             The colors of the bar faces.
2285 
2286         edgecolor : color or list of color, optional
2287             The colors of the bar edges.
2288 
2289         linewidth : float or array-like, optional
2290             Width of the bar edge(s). If 0, don't draw edges.
2291 
2292         tick_label : str or list of str, optional
2293             The tick labels of the bars.
2294             Default: None (Use default numeric labels.)
2295 
2296         label : str or list of str, optional
2297             A single label is attached to the resulting `.BarContainer` as a
2298             label for the whole dataset.
2299             If a list is provided, it must be the same length as *x* and
2300             labels the individual bars. Repeated labels are not de-duplicated
2301             and will cause repeated label entries, so this is best used when
2302             bars also differ in style (e.g., by passing a list to *color*.)
2303 
2304         xerr, yerr : float or array-like of shape(N,) or shape(2, N), optional
2305             If not *None*, add horizontal / vertical errorbars to the bar tips.
2306             The values are +/- sizes relative to the data:
2307 
2308             - scalar: symmetric +/- values for all bars
2309             - shape(N,): symmetric +/- values for each bar
2310             - shape(2, N): Separate - and + values for each bar. First row
2311               contains the lower errors, the second row contains the upper
2312               errors.
2313             - *None*: No errorbar. (Default)
2314 
2315             See :doc:`/gallery/statistics/errorbar_features` for an example on
2316             the usage of *xerr* and *yerr*.
2317 
2318         ecolor : color or list of color, default: 'black'
2319             The line color of the errorbars.
2320 
2321         capsize : float, default: :rc:`errorbar.capsize`
2322            The length of the error bar caps in points.
2323 
2324         error_kw : dict, optional
2325             Dictionary of keyword arguments to be passed to the
2326             `~.Axes.errorbar` method. Values of *ecolor* or *capsize* defined
2327             here take precedence over the independent keyword arguments.
2328 
2329         log : bool, default: False
2330             If *True*, set the y-axis to be log scale.
2331 
2332         data : indexable object, optional
2333             DATA_PARAMETER_PLACEHOLDER
2334 
2335         **kwargs : `.Rectangle` properties
2336 
2337         %(Rectangle:kwdoc)s
2338 
2339         See Also
2340         --------
2341         barh : Plot a horizontal bar plot.
2342 
2343         Notes
2344         -----
2345         Stacked bars can be achieved by passing individual *bottom* values per
2346         bar. See :doc:`/gallery/lines_bars_and_markers/bar_stacked`.
2347         """
2348         kwargs = cbook.normalize_kwargs(kwargs, mpatches.Patch)
2349         color = kwargs.pop('color', None)
2350         if color is None:
2351             color = self._get_patches_for_fill.get_next_color()
2352         edgecolor = kwargs.pop('edgecolor', None)
2353         linewidth = kwargs.pop('linewidth', None)
2354         hatch = kwargs.pop('hatch', None)
2355 
2356         # Because xerr and yerr will be passed to errorbar, most dimension
2357         # checking and processing will be left to the errorbar method.
2358         xerr = kwargs.pop('xerr', None)
2359         yerr = kwargs.pop('yerr', None)
2360         error_kw = kwargs.pop('error_kw', {})
2361         ezorder = error_kw.pop('zorder', None)
2362         if ezorder is None:
2363             ezorder = kwargs.get('zorder', None)
2364             if ezorder is not None:
2365                 # If using the bar zorder, increment slightly to make sure
2366                 # errorbars are drawn on top of bars
2367                 ezorder += 0.01
2368         error_kw.setdefault('zorder', ezorder)
2369         ecolor = kwargs.pop('ecolor', 'k')
2370         capsize = kwargs.pop('capsize', mpl.rcParams["errorbar.capsize"])
2371         error_kw.setdefault('ecolor', ecolor)
2372         error_kw.setdefault('capsize', capsize)
2373 
2374         # The keyword argument *orientation* is used by barh() to defer all
2375         # logic and drawing to bar(). It is considered internal and is
2376         # intentionally not mentioned in the docstring.
2377         orientation = kwargs.pop('orientation', 'vertical')
2378         _api.check_in_list(['vertical', 'horizontal'], orientation=orientation)
2379         log = kwargs.pop('log', False)
2380         label = kwargs.pop('label', '')
2381         tick_labels = kwargs.pop('tick_label', None)
2382 
2383         y = bottom  # Matches barh call signature.
2384         if orientation == 'vertical':
2385             if y is None:
2386                 y = 0
2387         else:  # horizontal
2388             if x is None:
2389                 x = 0
2390 
2391         if orientation == 'vertical':
2392             self._process_unit_info(
2393                 [("x", x), ("y", height)], kwargs, convert=False)
2394             if log:
2395                 self.set_yscale('log', nonpositive='clip')
2396         else:  # horizontal
2397             self._process_unit_info(
2398                 [("x", width), ("y", y)], kwargs, convert=False)
2399             if log:
2400                 self.set_xscale('log', nonpositive='clip')
2401 
2402         # lets do some conversions now since some types cannot be
2403         # subtracted uniformly
2404         if self.xaxis is not None:
2405             x0 = x
2406             x = np.asarray(self.convert_xunits(x))
2407             width = self._convert_dx(width, x0, x, self.convert_xunits)
2408             if xerr is not None:
2409                 xerr = self._convert_dx(xerr, x0, x, self.convert_xunits)
2410         if self.yaxis is not None:
2411             y0 = y
2412             y = np.asarray(self.convert_yunits(y))
2413             height = self._convert_dx(height, y0, y, self.convert_yunits)
2414             if yerr is not None:
2415                 yerr = self._convert_dx(yerr, y0, y, self.convert_yunits)
2416 
2417         x, height, width, y, linewidth, hatch = np.broadcast_arrays(
2418             # Make args iterable too.
2419             np.atleast_1d(x), height, width, y, linewidth, hatch)
2420 
2421         # Now that units have been converted, set the tick locations.
2422         if orientation == 'vertical':
2423             tick_label_axis = self.xaxis
2424             tick_label_position = x
2425         else:  # horizontal
2426             tick_label_axis = self.yaxis
2427             tick_label_position = y
2428 
2429         if not isinstance(label, str) and np.iterable(label):
2430             bar_container_label = '_nolegend_'
2431             patch_labels = label
2432         else:
2433             bar_container_label = label
2434             patch_labels = ['_nolegend_'] * len(x)
2435         if len(patch_labels) != len(x):
2436             raise ValueError(f'number of labels ({len(patch_labels)}) '
2437                              f'does not match number of bars ({len(x)}).')
2438 
2439         linewidth = itertools.cycle(np.atleast_1d(linewidth))
2440         hatch = itertools.cycle(np.atleast_1d(hatch))
2441         color = itertools.chain(itertools.cycle(mcolors.to_rgba_array(color)),
2442                                 # Fallback if color == "none".
2443                                 itertools.repeat('none'))
2444         if edgecolor is None:
2445             edgecolor = itertools.repeat(None)
2446         else:
2447             edgecolor = itertools.chain(
2448                 itertools.cycle(mcolors.to_rgba_array(edgecolor)),
2449                 # Fallback if edgecolor == "none".
2450                 itertools.repeat('none'))
2451 
2452         # We will now resolve the alignment and really have
2453         # left, bottom, width, height vectors
2454         _api.check_in_list(['center', 'edge'], align=align)
2455         if align == 'center':
2456             if orientation == 'vertical':
2457                 try:
2458                     left = x - width / 2
2459                 except TypeError as e:
2460                     raise TypeError(f'the dtypes of parameters x ({x.dtype}) '
2461                                     f'and width ({width.dtype}) '
2462                                     f'are incompatible') from e
2463                 bottom = y
2464             else:  # horizontal
2465                 try:
2466                     bottom = y - height / 2
2467                 except TypeError as e:
2468                     raise TypeError(f'the dtypes of parameters y ({y.dtype}) '
2469                                     f'and height ({height.dtype}) '
2470                                     f'are incompatible') from e
2471                 left = x
2472         else:  # edge
2473             left = x
2474             bottom = y
2475 
2476         patches = []
2477         args = zip(left, bottom, width, height, color, edgecolor, linewidth,
2478                    hatch, patch_labels)
2479         for l, b, w, h, c, e, lw, htch, lbl in args:
2480             r = mpatches.Rectangle(
2481                 xy=(l, b), width=w, height=h,
2482                 facecolor=c,
2483                 edgecolor=e,
2484                 linewidth=lw,
2485                 label=lbl,
2486                 hatch=htch,
2487                 )
2488             r._internal_update(kwargs)
2489             r.get_path()._interpolation_steps = 100
2490             if orientation == 'vertical':
2491                 r.sticky_edges.y.append(b)
2492             else:  # horizontal
2493                 r.sticky_edges.x.append(l)
2494             self.add_patch(r)
2495             patches.append(r)
2496 
2497         if xerr is not None or yerr is not None:
2498             if orientation == 'vertical':
2499                 # using list comps rather than arrays to preserve unit info
2500                 ex = [l + 0.5 * w for l, w in zip(left, width)]
2501                 ey = [b + h for b, h in zip(bottom, height)]
2502 
2503             else:  # horizontal
2504                 # using list comps rather than arrays to preserve unit info
2505                 ex = [l + w for l, w in zip(left, width)]
2506                 ey = [b + 0.5 * h for b, h in zip(bottom, height)]
2507 
2508             error_kw.setdefault("label", '_nolegend_')
2509 
2510             errorbar = self.errorbar(ex, ey,
2511                                      yerr=yerr, xerr=xerr,
2512                                      fmt='none', **error_kw)
2513         else:
2514             errorbar = None
2515 
2516         self._request_autoscale_view()
2517 
2518         if orientation == 'vertical':
2519             datavalues = height
2520         else:  # horizontal
2521             datavalues = width
2522 
2523         bar_container = BarContainer(patches, errorbar, datavalues=datavalues,
2524                                      orientation=orientation,
2525                                      label=bar_container_label)
2526         self.add_container(bar_container)
2527 
2528         if tick_labels is not None:
2529             tick_labels = np.broadcast_to(tick_labels, len(patches))
2530             tick_label_axis.set_ticks(tick_label_position)
2531             tick_label_axis.set_ticklabels(tick_labels)
2532 
2533         return bar_container
2534 
2535     # @_preprocess_data() # let 'bar' do the unpacking..
2536     @_docstring.dedent_interpd
2537     def barh(self, y, width, height=0.8, left=None, *, align="center",
2538              data=None, **kwargs):
2539         r"""
2540         Make a horizontal bar plot.
2541 
2542         The bars are positioned at *y* with the given *align*\ment. Their
2543         dimensions are given by *width* and *height*. The horizontal baseline
2544         is *left* (default 0).
2545 
2546         Many parameters can take either a single value applying to all bars
2547         or a sequence of values, one for each bar.
2548 
2549         Parameters
2550         ----------
2551         y : float or array-like
2552             The y coordinates of the bars. See also *align* for the
2553             alignment of the bars to the coordinates.
2554 
2555         width : float or array-like
2556             The width(s) of the bars.
2557 
2558         height : float or array-like, default: 0.8
2559             The heights of the bars.
2560 
2561         left : float or array-like, default: 0
2562             The x coordinates of the left side(s) of the bars.
2563 
2564         align : {'center', 'edge'}, default: 'center'
2565             Alignment of the base to the *y* coordinates*:
2566 
2567             - 'center': Center the bars on the *y* positions.
2568             - 'edge': Align the bottom edges of the bars with the *y*
2569               positions.
2570 
2571             To align the bars on the top edge pass a negative *height* and
2572             ``align='edge'``.
2573 
2574         Returns
2575         -------
2576         `.BarContainer`
2577             Container with all the bars and optionally errorbars.
2578 
2579         Other Parameters
2580         ----------------
2581         color : color or list of color, optional
2582             The colors of the bar faces.
2583 
2584         edgecolor : color or list of color, optional
2585             The colors of the bar edges.
2586 
2587         linewidth : float or array-like, optional
2588             Width of the bar edge(s). If 0, don't draw edges.
2589 
2590         tick_label : str or list of str, optional
2591             The tick labels of the bars.
2592             Default: None (Use default numeric labels.)
2593 
2594         label : str or list of str, optional
2595             A single label is attached to the resulting `.BarContainer` as a
2596             label for the whole dataset.
2597             If a list is provided, it must be the same length as *y* and
2598             labels the individual bars. Repeated labels are not de-duplicated
2599             and will cause repeated label entries, so this is best used when
2600             bars also differ in style (e.g., by passing a list to *color*.)
2601 
2602         xerr, yerr : float or array-like of shape(N,) or shape(2, N), optional
2603             If not *None*, add horizontal / vertical errorbars to the bar tips.
2604             The values are +/- sizes relative to the data:
2605 
2606             - scalar: symmetric +/- values for all bars
2607             - shape(N,): symmetric +/- values for each bar
2608             - shape(2, N): Separate - and + values for each bar. First row
2609               contains the lower errors, the second row contains the upper
2610               errors.
2611             - *None*: No errorbar. (default)
2612 
2613             See :doc:`/gallery/statistics/errorbar_features` for an example on
2614             the usage of *xerr* and *yerr*.
2615 
2616         ecolor : color or list of color, default: 'black'
2617             The line color of the errorbars.
2618 
2619         capsize : float, default: :rc:`errorbar.capsize`
2620            The length of the error bar caps in points.
2621 
2622         error_kw : dict, optional
2623             Dictionary of keyword arguments to be passed to the
2624             `~.Axes.errorbar` method. Values of *ecolor* or *capsize* defined
2625             here take precedence over the independent keyword arguments.
2626 
2627         log : bool, default: False
2628             If ``True``, set the x-axis to be log scale.
2629 
2630         data : indexable object, optional
2631             If given, all parameters also accept a string ``s``, which is
2632             interpreted as ``data[s]`` (unless this raises an exception).
2633 
2634         **kwargs : `.Rectangle` properties
2635 
2636         %(Rectangle:kwdoc)s
2637 
2638         See Also
2639         --------
2640         bar : Plot a vertical bar plot.
2641 
2642         Notes
2643         -----
2644         Stacked bars can be achieved by passing individual *left* values per
2645         bar. See
2646         :doc:`/gallery/lines_bars_and_markers/horizontal_barchart_distribution`.
2647         """
2648         kwargs.setdefault('orientation', 'horizontal')
2649         patches = self.bar(x=left, height=height, width=width, bottom=y,
2650                            align=align, data=data, **kwargs)
2651         return patches
2652 
2653     def bar_label(self, container, labels=None, *, fmt="%g", label_type="edge",
2654                   padding=0, **kwargs):
2655         """
2656         Label a bar plot.
2657 
2658         Adds labels to bars in the given `.BarContainer`.
2659         You may need to adjust the axis limits to fit the labels.
2660 
2661         Parameters
2662         ----------
2663         container : `.BarContainer`
2664             Container with all the bars and optionally errorbars, likely
2665             returned from `.bar` or `.barh`.
2666 
2667         labels : array-like, optional
2668             A list of label texts, that should be displayed. If not given, the
2669             label texts will be the data values formatted with *fmt*.
2670 
2671         fmt : str or callable, default: '%g'
2672             An unnamed %-style or {}-style format string for the label or a
2673             function to call with the value as the first argument.
2674             When *fmt* is a string and can be interpreted in both formats,
2675             %-style takes precedence over {}-style.
2676 
2677             .. versionadded:: 3.7
2678                Support for {}-style format string and callables.
2679 
2680         label_type : {'edge', 'center'}, default: 'edge'
2681             The label type. Possible values:
2682 
2683             - 'edge': label placed at the end-point of the bar segment, and the
2684               value displayed will be the position of that end-point.
2685             - 'center': label placed in the center of the bar segment, and the
2686               value displayed will be the length of that segment.
2687               (useful for stacked bars, i.e.,
2688               :doc:`/gallery/lines_bars_and_markers/bar_label_demo`)
2689 
2690         padding : float, default: 0
2691             Distance of label from the end of the bar, in points.
2692 
2693         **kwargs
2694             Any remaining keyword arguments are passed through to
2695             `.Axes.annotate`. The alignment parameters (
2696             *horizontalalignment* / *ha*, *verticalalignment* / *va*) are
2697             not supported because the labels are automatically aligned to
2698             the bars.
2699 
2700         Returns
2701         -------
2702         list of `.Text`
2703             A list of `.Text` instances for the labels.
2704         """
2705         for key in ['horizontalalignment', 'ha', 'verticalalignment', 'va']:
2706             if key in kwargs:
2707                 raise ValueError(
2708                     f"Passing {key!r} to bar_label() is not supported.")
2709 
2710         a, b = self.yaxis.get_view_interval()
2711         y_inverted = a > b
2712         c, d = self.xaxis.get_view_interval()
2713         x_inverted = c > d
2714 
2715         # want to know whether to put label on positive or negative direction
2716         # cannot use np.sign here because it will return 0 if x == 0
2717         def sign(x):
2718             return 1 if x >= 0 else -1
2719 
2720         _api.check_in_list(['edge', 'center'], label_type=label_type)
2721 
2722         bars = container.patches
2723         errorbar = container.errorbar
2724         datavalues = container.datavalues
2725         orientation = container.orientation
2726 
2727         if errorbar:
2728             # check "ErrorbarContainer" for the definition of these elements
2729             lines = errorbar.lines  # attribute of "ErrorbarContainer" (tuple)
2730             barlinecols = lines[2]  # 0: data_line, 1: caplines, 2: barlinecols
2731             barlinecol = barlinecols[0]  # the "LineCollection" of error bars
2732             errs = barlinecol.get_segments()
2733         else:
2734             errs = []
2735 
2736         if labels is None:
2737             labels = []
2738 
2739         annotations = []
2740 
2741         for bar, err, dat, lbl in itertools.zip_longest(
2742                 bars, errs, datavalues, labels
2743         ):
2744             (x0, y0), (x1, y1) = bar.get_bbox().get_points()
2745             xc, yc = (x0 + x1) / 2, (y0 + y1) / 2
2746 
2747             if orientation == "vertical":
2748                 extrema = max(y0, y1) if dat >= 0 else min(y0, y1)
2749                 length = abs(y0 - y1)
2750             else:  # horizontal
2751                 extrema = max(x0, x1) if dat >= 0 else min(x0, x1)
2752                 length = abs(x0 - x1)
2753 
2754             if err is None or np.size(err) == 0:
2755                 endpt = extrema
2756             elif orientation == "vertical":
2757                 endpt = err[:, 1].max() if dat >= 0 else err[:, 1].min()
2758             else:  # horizontal
2759                 endpt = err[:, 0].max() if dat >= 0 else err[:, 0].min()
2760 
2761             if label_type == "center":
2762                 value = sign(dat) * length
2763             else:  # edge
2764                 value = extrema
2765 
2766             if label_type == "center":
2767                 xy = (0.5, 0.5)
2768                 kwargs["xycoords"] = (
2769                     lambda r, b=bar:
2770                         mtransforms.Bbox.intersection(
2771                             b.get_window_extent(r), b.get_clip_box()
2772                         )
2773                 )
2774             else:  # edge
2775                 if orientation == "vertical":
2776                     xy = xc, endpt
2777                 else:  # horizontal
2778                     xy = endpt, yc
2779 
2780             if orientation == "vertical":
2781                 y_direction = -1 if y_inverted else 1
2782                 xytext = 0, y_direction * sign(dat) * padding
2783             else:  # horizontal
2784                 x_direction = -1 if x_inverted else 1
2785                 xytext = x_direction * sign(dat) * padding, 0
2786 
2787             if label_type == "center":
2788                 ha, va = "center", "center"
2789             else:  # edge
2790                 if orientation == "vertical":
2791                     ha = 'center'
2792                     if y_inverted:
2793                         va = 'top' if dat > 0 else 'bottom'  # also handles NaN
2794                     else:
2795                         va = 'top' if dat < 0 else 'bottom'  # also handles NaN
2796                 else:  # horizontal
2797                     if x_inverted:
2798                         ha = 'right' if dat > 0 else 'left'  # also handles NaN
2799                     else:
2800                         ha = 'right' if dat < 0 else 'left'  # also handles NaN
2801                     va = 'center'
2802 
2803             if np.isnan(dat):
2804                 lbl = ''
2805 
2806             if lbl is None:
2807                 if isinstance(fmt, str):
2808                     lbl = cbook._auto_format_str(fmt, value)
2809                 elif callable(fmt):
2810                     lbl = fmt(value)
2811                 else:
2812                     raise TypeError("fmt must be a str or callable")
2813             annotation = self.annotate(lbl,
2814                                        xy, xytext, textcoords="offset points",
2815                                        ha=ha, va=va, **kwargs)
2816             annotations.append(annotation)
2817 
2818         return annotations
2819 
2820     @_preprocess_data()
2821     @_docstring.dedent_interpd
2822     def broken_barh(self, xranges, yrange, **kwargs):
2823         """
2824         Plot a horizontal sequence of rectangles.
2825 
2826         A rectangle is drawn for each element of *xranges*. All rectangles
2827         have the same vertical position and size defined by *yrange*.
2828 
2829         Parameters
2830         ----------
2831         xranges : sequence of tuples (*xmin*, *xwidth*)
2832             The x-positions and extends of the rectangles. For each tuple
2833             (*xmin*, *xwidth*) a rectangle is drawn from *xmin* to *xmin* +
2834             *xwidth*.
2835         yrange : (*ymin*, *yheight*)
2836             The y-position and extend for all the rectangles.
2837 
2838         Returns
2839         -------
2840         `~.collections.PolyCollection`
2841 
2842         Other Parameters
2843         ----------------
2844         data : indexable object, optional
2845             DATA_PARAMETER_PLACEHOLDER
2846         **kwargs : `.PolyCollection` properties
2847 
2848             Each *kwarg* can be either a single argument applying to all
2849             rectangles, e.g.::
2850 
2851                 facecolors='black'
2852 
2853             or a sequence of arguments over which is cycled, e.g.::
2854 
2855                 facecolors=('black', 'blue')
2856 
2857             would create interleaving black and blue rectangles.
2858 
2859             Supported keywords:
2860 
2861             %(PolyCollection:kwdoc)s
2862         """
2863         # process the unit information
2864         xdata = cbook._safe_first_finite(xranges) if len(xranges) else None
2865         ydata = cbook._safe_first_finite(yrange) if len(yrange) else None
2866         self._process_unit_info(
2867             [("x", xdata), ("y", ydata)], kwargs, convert=False)
2868 
2869         vertices = []
2870         y0, dy = yrange
2871         y0, y1 = self.convert_yunits((y0, y0 + dy))
2872         for xr in xranges:  # convert the absolute values, not the x and dx
2873             try:
2874                 x0, dx = xr
2875             except Exception:
2876                 raise ValueError(
2877                     "each range in xrange must be a sequence with two "
2878                     "elements (i.e. xrange must be an (N, 2) array)") from None
2879             x0, x1 = self.convert_xunits((x0, x0 + dx))
2880             vertices.append([(x0, y0), (x0, y1), (x1, y1), (x1, y0)])
2881 
2882         col = mcoll.PolyCollection(np.array(vertices), **kwargs)
2883         self.add_collection(col, autolim=True)
2884         self._request_autoscale_view()
2885 
2886         return col
2887 
2888     @_preprocess_data()
2889     @_api.delete_parameter("3.6", "use_line_collection")
2890     def stem(self, *args, linefmt=None, markerfmt=None, basefmt=None, bottom=0,
2891              label=None, use_line_collection=True, orientation='vertical'):
2892         """
2893         Create a stem plot.
2894 
2895         A stem plot draws lines perpendicular to a baseline at each location
2896         *locs* from the baseline to *heads*, and places a marker there. For
2897         vertical stem plots (the default), the *locs* are *x* positions, and
2898         the *heads* are *y* values. For horizontal stem plots, the *locs* are
2899         *y* positions, and the *heads* are *x* values.
2900 
2901         Call signature::
2902 
2903           stem([locs,] heads, linefmt=None, markerfmt=None, basefmt=None)
2904 
2905         The *locs*-positions are optional. *linefmt* may be provided as
2906         positional, but all other formats must be provided as keyword
2907         arguments.
2908 
2909         Parameters
2910         ----------
2911         locs : array-like, default: (0, 1, ..., len(heads) - 1)
2912             For vertical stem plots, the x-positions of the stems.
2913             For horizontal stem plots, the y-positions of the stems.
2914 
2915         heads : array-like
2916             For vertical stem plots, the y-values of the stem heads.
2917             For horizontal stem plots, the x-values of the stem heads.
2918 
2919         linefmt : str, optional
2920             A string defining the color and/or linestyle of the vertical lines:
2921 
2922             =========  =============
2923             Character  Line Style
2924             =========  =============
2925             ``'-'``    solid line
2926             ``'--'``   dashed line
2927             ``'-.'``   dash-dot line
2928             ``':'``    dotted line
2929             =========  =============
2930 
2931             Default: 'C0-', i.e. solid line with the first color of the color
2932             cycle.
2933 
2934             Note: Markers specified through this parameter (e.g. 'x') will be
2935             silently ignored (unless using ``use_line_collection=False``).
2936             Instead, markers should be specified using *markerfmt*.
2937 
2938         markerfmt : str, optional
2939             A string defining the color and/or shape of the markers at the stem
2940             heads. If the marker is not given, use the marker 'o', i.e. filled
2941             circles. If the color is not given, use the color from *linefmt*.
2942 
2943         basefmt : str, default: 'C3-' ('C2-' in classic mode)
2944             A format string defining the properties of the baseline.
2945 
2946         orientation : {'vertical', 'horizontal'}, default: 'vertical'
2947             If 'vertical', will produce a plot with stems oriented vertically,
2948             If 'horizontal', the stems will be oriented horizontally.
2949 
2950         bottom : float, default: 0
2951             The y/x-position of the baseline (depending on orientation).
2952 
2953         label : str, default: None
2954             The label to use for the stems in legends.
2955 
2956         use_line_collection : bool, default: True
2957             *Deprecated since 3.6*
2958 
2959             If ``True``, store and plot the stem lines as a
2960             `~.collections.LineCollection` instead of individual lines, which
2961             significantly increases performance.  If ``False``, defaults to the
2962             old behavior of using a list of `.Line2D` objects.
2963 
2964         data : indexable object, optional
2965             DATA_PARAMETER_PLACEHOLDER
2966 
2967         Returns
2968         -------
2969         `.StemContainer`
2970             The container may be treated like a tuple
2971             (*markerline*, *stemlines*, *baseline*)
2972 
2973         Notes
2974         -----
2975         .. seealso::
2976             The MATLAB function
2977             `stem <https://www.mathworks.com/help/matlab/ref/stem.html>`_
2978             which inspired this method.
2979         """
2980         if not 1 <= len(args) <= 3:
2981             raise TypeError('stem expected between 1 or 3 positional '
2982                             f'arguments, got {args}')
2983         _api.check_in_list(['horizontal', 'vertical'], orientation=orientation)
2984 
2985         if len(args) == 1:
2986             heads, = args
2987             locs = np.arange(len(heads))
2988             args = ()
2989         elif isinstance(args[1], str):
2990             heads, *args = args
2991             locs = np.arange(len(heads))
2992         else:
2993             locs, heads, *args = args
2994 
2995         if orientation == 'vertical':
2996             locs, heads = self._process_unit_info([("x", locs), ("y", heads)])
2997         else:  # horizontal
2998             heads, locs = self._process_unit_info([("x", heads), ("y", locs)])
2999 
3000         # resolve line format
3001         if linefmt is None:
3002             linefmt = args[0] if len(args) > 0 else "C0-"
3003         linestyle, linemarker, linecolor = _process_plot_format(linefmt)
3004 
3005         # resolve marker format
3006         if markerfmt is None:
3007             # if not given as kwarg, fall back to 'o'
3008             markerfmt = "o"
3009         if markerfmt == '':
3010             markerfmt = ' '  # = empty line style; '' would resolve rcParams
3011         markerstyle, markermarker, markercolor = \
3012             _process_plot_format(markerfmt)
3013         if markermarker is None:
3014             markermarker = 'o'
3015         if markerstyle is None:
3016             markerstyle = 'None'
3017         if markercolor is None:
3018             markercolor = linecolor
3019 
3020         # resolve baseline format
3021         if basefmt is None:
3022             basefmt = ("C2-" if mpl.rcParams["_internal.classic_mode"] else
3023                        "C3-")
3024         basestyle, basemarker, basecolor = _process_plot_format(basefmt)
3025 
3026         # New behaviour in 3.1 is to use a LineCollection for the stemlines
3027         if use_line_collection:
3028             if linestyle is None:
3029                 linestyle = mpl.rcParams['lines.linestyle']
3030             xlines = self.vlines if orientation == "vertical" else self.hlines
3031             stemlines = xlines(
3032                 locs, bottom, heads,
3033                 colors=linecolor, linestyles=linestyle, label="_nolegend_")
3034         # Old behaviour is to plot each of the lines individually
3035         else:
3036             stemlines = []
3037             for loc, head in zip(locs, heads):
3038                 if orientation == 'horizontal':
3039                     xs = [bottom, head]
3040                     ys = [loc, loc]
3041                 else:
3042                     xs = [loc, loc]
3043                     ys = [bottom, head]
3044                 l, = self.plot(xs, ys,
3045                                color=linecolor, linestyle=linestyle,
3046                                marker=linemarker, label="_nolegend_")
3047                 stemlines.append(l)
3048 
3049         if orientation == 'horizontal':
3050             marker_x = heads
3051             marker_y = locs
3052             baseline_x = [bottom, bottom]
3053             baseline_y = [np.min(locs), np.max(locs)]
3054         else:
3055             marker_x = locs
3056             marker_y = heads
3057             baseline_x = [np.min(locs), np.max(locs)]
3058             baseline_y = [bottom, bottom]
3059 
3060         markerline, = self.plot(marker_x, marker_y,
3061                                 color=markercolor, linestyle=markerstyle,
3062                                 marker=markermarker, label="_nolegend_")
3063 
3064         baseline, = self.plot(baseline_x, baseline_y,
3065                               color=basecolor, linestyle=basestyle,
3066                               marker=basemarker, label="_nolegend_")
3067 
3068         stem_container = StemContainer((markerline, stemlines, baseline),
3069                                        label=label)
3070         self.add_container(stem_container)
3071         return stem_container
3072 
3073     @_preprocess_data(replace_names=["x", "explode", "labels", "colors"])
3074     def pie(self, x, explode=None, labels=None, colors=None,
3075             autopct=None, pctdistance=0.6, shadow=False, labeldistance=1.1,
3076             startangle=0, radius=1, counterclock=True,
3077             wedgeprops=None, textprops=None, center=(0, 0),
3078             frame=False, rotatelabels=False, *, normalize=True, hatch=None):
3079         """
3080         Plot a pie chart.
3081 
3082         Make a pie chart of array *x*.  The fractional area of each wedge is
3083         given by ``x/sum(x)``.
3084 
3085         The wedges are plotted counterclockwise, by default starting from the
3086         x-axis.
3087 
3088         Parameters
3089         ----------
3090         x : 1D array-like
3091             The wedge sizes.
3092 
3093         explode : array-like, default: None
3094             If not *None*, is a ``len(x)`` array which specifies the fraction
3095             of the radius with which to offset each wedge.
3096 
3097         labels : list, default: None
3098             A sequence of strings providing the labels for each wedge
3099 
3100         colors : array-like, default: None
3101             A sequence of colors through which the pie chart will cycle.  If
3102             *None*, will use the colors in the currently active cycle.
3103 
3104         hatch : str or list, default: None
3105             Hatching pattern applied to all pie wedges or sequence of patterns
3106             through which the chart will cycle. For a list of valid patterns,
3107             see :doc:`/gallery/shapes_and_collections/hatch_style_reference`.
3108 
3109             .. versionadded:: 3.7
3110 
3111         autopct : None or str or callable, default: None
3112             If not *None*, *autopct* is a string or function used to label the
3113             wedges with their numeric value. The label will be placed inside
3114             the wedge. If *autopct* is a format string, the label will be
3115             ``fmt % pct``. If *autopct* is a function, then it will be called.
3116 
3117         pctdistance : float, default: 0.6
3118             The relative distance along the radius at which the the text
3119             generated by *autopct* is drawn. To draw the text outside the pie,
3120             set *pctdistance* > 1. This parameter is ignored if *autopct* is
3121             ``None``.
3122 
3123         labeldistance : float or None, default: 1.1
3124             The relative distance along the radius at which the labels are
3125             drawn. To draw the labels inside the pie, set  *labeldistance* < 1.
3126             If set to ``None``, labels are not drawn but are still stored for
3127             use in `.legend`.
3128 
3129         shadow : bool, default: False
3130             Draw a shadow beneath the pie.
3131 
3132         startangle : float, default: 0 degrees
3133             The angle by which the start of the pie is rotated,
3134             counterclockwise from the x-axis.
3135 
3136         radius : float, default: 1
3137             The radius of the pie.
3138 
3139         counterclock : bool, default: True
3140             Specify fractions direction, clockwise or counterclockwise.
3141 
3142         wedgeprops : dict, default: None
3143             Dict of arguments passed to each `.patches.Wedge` of the pie.
3144             For example, ``wedgeprops = {'linewidth': 3}`` sets the width of
3145             the wedge border lines equal to 3. By default, ``clip_on=False``.
3146             When there is a conflict between these properties and other
3147             keywords, properties passed to *wedgeprops* take precedence.
3148 
3149         textprops : dict, default: None
3150             Dict of arguments to pass to the text objects.
3151 
3152         center : (float, float), default: (0, 0)
3153             The coordinates of the center of the chart.
3154 
3155         frame : bool, default: False
3156             Plot Axes frame with the chart if true.
3157 
3158         rotatelabels : bool, default: False
3159             Rotate each label to the angle of the corresponding slice if true.
3160 
3161         normalize : bool, default: True
3162             When *True*, always make a full pie by normalizing x so that
3163             ``sum(x) == 1``. *False* makes a partial pie if ``sum(x) <= 1``
3164             and raises a `ValueError` for ``sum(x) > 1``.
3165 
3166         data : indexable object, optional
3167             DATA_PARAMETER_PLACEHOLDER
3168 
3169         Returns
3170         -------
3171         patches : list
3172             A sequence of `matplotlib.patches.Wedge` instances
3173 
3174         texts : list
3175             A list of the label `.Text` instances.
3176 
3177         autotexts : list
3178             A list of `.Text` instances for the numeric labels. This will only
3179             be returned if the parameter *autopct* is not *None*.
3180 
3181         Notes
3182         -----
3183         The pie chart will probably look best if the figure and Axes are
3184         square, or the Axes aspect is equal.
3185         This method sets the aspect ratio of the axis to "equal".
3186         The Axes aspect ratio can be controlled with `.Axes.set_aspect`.
3187         """
3188         self.set_aspect('equal')
3189         # The use of float32 is "historical", but can't be changed without
3190         # regenerating the test baselines.
3191         x = np.asarray(x, np.float32)
3192         if x.ndim > 1:
3193             raise ValueError("x must be 1D")
3194 
3195         if np.any(x < 0):
3196             raise ValueError("Wedge sizes 'x' must be non negative values")
3197 
3198         sx = x.sum()
3199 
3200         if normalize:
3201             x = x / sx
3202         elif sx > 1:
3203             raise ValueError('Cannot plot an unnormalized pie with sum(x) > 1')
3204         if labels is None:
3205             labels = [''] * len(x)
3206         if explode is None:
3207             explode = [0] * len(x)
3208         if len(x) != len(labels):
3209             raise ValueError("'label' must be of length 'x'")
3210         if len(x) != len(explode):
3211             raise ValueError("'explode' must be of length 'x'")
3212         if colors is None:
3213             get_next_color = self._get_patches_for_fill.get_next_color
3214         else:
3215             color_cycle = itertools.cycle(colors)
3216 
3217             def get_next_color():
3218                 return next(color_cycle)
3219 
3220         hatch_cycle = itertools.cycle(np.atleast_1d(hatch))
3221 
3222         _api.check_isinstance(Real, radius=radius, startangle=startangle)
3223         if radius <= 0:
3224             raise ValueError(f'radius must be a positive number, not {radius}')
3225 
3226         # Starting theta1 is the start fraction of the circle
3227         theta1 = startangle / 360
3228 
3229         if wedgeprops is None:
3230             wedgeprops = {}
3231         if textprops is None:
3232             textprops = {}
3233 
3234         texts = []
3235         slices = []
3236         autotexts = []
3237 
3238         for frac, label, expl in zip(x, labels, explode):
3239             x, y = center
3240             theta2 = (theta1 + frac) if counterclock else (theta1 - frac)
3241             thetam = 2 * np.pi * 0.5 * (theta1 + theta2)
3242             x += expl * math.cos(thetam)
3243             y += expl * math.sin(thetam)
3244 
3245             w = mpatches.Wedge((x, y), radius, 360. * min(theta1, theta2),
3246                                360. * max(theta1, theta2),
3247                                facecolor=get_next_color(),
3248                                hatch=next(hatch_cycle),
3249                                clip_on=False,
3250                                label=label)
3251             w.set(**wedgeprops)
3252             slices.append(w)
3253             self.add_patch(w)
3254 
3255             if shadow:
3256                 # Make sure to add a shadow after the call to add_patch so the
3257                 # figure and transform props will be set.
3258                 shad = mpatches.Shadow(w, -0.02, -0.02, label='_nolegend_')
3259                 self.add_patch(shad)
3260 
3261             if labeldistance is not None:
3262                 xt = x + labeldistance * radius * math.cos(thetam)
3263                 yt = y + labeldistance * radius * math.sin(thetam)
3264                 label_alignment_h = 'left' if xt > 0 else 'right'
3265                 label_alignment_v = 'center'
3266                 label_rotation = 'horizontal'
3267                 if rotatelabels:
3268                     label_alignment_v = 'bottom' if yt > 0 else 'top'
3269                     label_rotation = (np.rad2deg(thetam)
3270                                       + (0 if xt > 0 else 180))
3271                 t = self.text(xt, yt, label,
3272                               clip_on=False,
3273                               horizontalalignment=label_alignment_h,
3274                               verticalalignment=label_alignment_v,
3275                               rotation=label_rotation,
3276                               size=mpl.rcParams['xtick.labelsize'])
3277                 t.set(**textprops)
3278                 texts.append(t)
3279 
3280             if autopct is not None:
3281                 xt = x + pctdistance * radius * math.cos(thetam)
3282                 yt = y + pctdistance * radius * math.sin(thetam)
3283                 if isinstance(autopct, str):
3284                     s = autopct % (100. * frac)
3285                 elif callable(autopct):
3286                     s = autopct(100. * frac)
3287                 else:
3288                     raise TypeError(
3289                         'autopct must be callable or a format string')
3290                 t = self.text(xt, yt, s,
3291                               clip_on=False,
3292                               horizontalalignment='center',
3293                               verticalalignment='center')
3294                 t.set(**textprops)
3295                 autotexts.append(t)
3296 
3297             theta1 = theta2
3298 
3299         if frame:
3300             self._request_autoscale_view()
3301         else:
3302             self.set(frame_on=False, xticks=[], yticks=[],
3303                      xlim=(-1.25 + center[0], 1.25 + center[0]),
3304                      ylim=(-1.25 + center[1], 1.25 + center[1]))
3305 
3306         if autopct is None:
3307             return slices, texts
3308         else:
3309             return slices, texts, autotexts
3310 
3311     @staticmethod
3312     def _errorevery_to_mask(x, errorevery):
3313         """
3314         Normalize `errorbar`'s *errorevery* to be a boolean mask for data *x*.
3315 
3316         This function is split out to be usable both by 2D and 3D errorbars.
3317         """
3318         if isinstance(errorevery, Integral):
3319             errorevery = (0, errorevery)
3320         if isinstance(errorevery, tuple):
3321             if (len(errorevery) == 2 and
3322                     isinstance(errorevery[0], Integral) and
3323                     isinstance(errorevery[1], Integral)):
3324                 errorevery = slice(errorevery[0], None, errorevery[1])
3325             else:
3326                 raise ValueError(
3327                     f'{errorevery=!r} is a not a tuple of two integers')
3328         elif isinstance(errorevery, slice):
3329             pass
3330         elif not isinstance(errorevery, str) and np.iterable(errorevery):
3331             try:
3332                 x[errorevery]  # fancy indexing
3333             except (ValueError, IndexError) as err:
3334                 raise ValueError(
3335                     f"{errorevery=!r} is iterable but not a valid NumPy fancy "
3336                     "index to match 'xerr'/'yerr'") from err
3337         else:
3338             raise ValueError(f"{errorevery=!r} is not a recognized value")
3339         everymask = np.zeros(len(x), bool)
3340         everymask[errorevery] = True
3341         return everymask
3342 
3343     @_preprocess_data(replace_names=["x", "y", "xerr", "yerr"],
3344                       label_namer="y")
3345     @_docstring.dedent_interpd
3346     def errorbar(self, x, y, yerr=None, xerr=None,
3347                  fmt='', ecolor=None, elinewidth=None, capsize=None,
3348                  barsabove=False, lolims=False, uplims=False,
3349                  xlolims=False, xuplims=False, errorevery=1, capthick=None,
3350                  **kwargs):
3351         """
3352         Plot y versus x as lines and/or markers with attached errorbars.
3353 
3354         *x*, *y* define the data locations, *xerr*, *yerr* define the errorbar
3355         sizes. By default, this draws the data markers/lines as well the
3356         errorbars. Use fmt='none' to draw errorbars without any data markers.
3357 
3358         .. versionadded:: 3.7
3359            Caps and error lines are drawn in polar coordinates on polar plots.
3360 
3361 
3362         Parameters
3363         ----------
3364         x, y : float or array-like
3365             The data positions.
3366 
3367         xerr, yerr : float or array-like, shape(N,) or shape(2, N), optional
3368             The errorbar sizes:
3369 
3370             - scalar: Symmetric +/- values for all data points.
3371             - shape(N,): Symmetric +/-values for each data point.
3372             - shape(2, N): Separate - and + values for each bar. First row
3373               contains the lower errors, the second row contains the upper
3374               errors.
3375             - *None*: No errorbar.
3376 
3377             All values must be >= 0.
3378 
3379             See :doc:`/gallery/statistics/errorbar_features`
3380             for an example on the usage of ``xerr`` and ``yerr``.
3381 
3382         fmt : str, default: ''
3383             The format for the data points / data lines. See `.plot` for
3384             details.
3385 
3386             Use 'none' (case-insensitive) to plot errorbars without any data
3387             markers.
3388 
3389         ecolor : color, default: None
3390             The color of the errorbar lines.  If None, use the color of the
3391             line connecting the markers.
3392 
3393         elinewidth : float, default: None
3394             The linewidth of the errorbar lines. If None, the linewidth of
3395             the current style is used.
3396 
3397         capsize : float, default: :rc:`errorbar.capsize`
3398             The length of the error bar caps in points.
3399 
3400         capthick : float, default: None
3401             An alias to the keyword argument *markeredgewidth* (a.k.a. *mew*).
3402             This setting is a more sensible name for the property that
3403             controls the thickness of the error bar cap in points. For
3404             backwards compatibility, if *mew* or *markeredgewidth* are given,
3405             then they will over-ride *capthick*. This may change in future
3406             releases.
3407 
3408         barsabove : bool, default: False
3409             If True, will plot the errorbars above the plot
3410             symbols. Default is below.
3411 
3412         lolims, uplims, xlolims, xuplims : bool, default: False
3413             These arguments can be used to indicate that a value gives only
3414             upper/lower limits.  In that case a caret symbol is used to
3415             indicate this. *lims*-arguments may be scalars, or array-likes of
3416             the same length as *xerr* and *yerr*.  To use limits with inverted
3417             axes, `~.Axes.set_xlim` or `~.Axes.set_ylim` must be called before
3418             :meth:`errorbar`.  Note the tricky parameter names: setting e.g.
3419             *lolims* to True means that the y-value is a *lower* limit of the
3420             True value, so, only an *upward*-pointing arrow will be drawn!
3421 
3422         errorevery : int or (int, int), default: 1
3423             draws error bars on a subset of the data. *errorevery* =N draws
3424             error bars on the points (x[::N], y[::N]).
3425             *errorevery* =(start, N) draws error bars on the points
3426             (x[start::N], y[start::N]). e.g. errorevery=(6, 3)
3427             adds error bars to the data at (x[6], x[9], x[12], x[15], ...).
3428             Used to avoid overlapping error bars when two series share x-axis
3429             values.
3430 
3431         Returns
3432         -------
3433         `.ErrorbarContainer`
3434             The container contains:
3435 
3436             - plotline: `.Line2D` instance of x, y plot markers and/or line.
3437             - caplines: A tuple of `.Line2D` instances of the error bar caps.
3438             - barlinecols: A tuple of `.LineCollection` with the horizontal and
3439               vertical error ranges.
3440 
3441         Other Parameters
3442         ----------------
3443         data : indexable object, optional
3444             DATA_PARAMETER_PLACEHOLDER
3445 
3446         **kwargs
3447             All other keyword arguments are passed on to the `~.Axes.plot` call
3448             drawing the markers. For example, this code makes big red squares
3449             with thick green edges::
3450 
3451                 x, y, yerr = rand(3, 10)
3452                 errorbar(x, y, yerr, marker='s', mfc='red',
3453                          mec='green', ms=20, mew=4)
3454 
3455             where *mfc*, *mec*, *ms* and *mew* are aliases for the longer
3456             property names, *markerfacecolor*, *markeredgecolor*, *markersize*
3457             and *markeredgewidth*.
3458 
3459             Valid kwargs for the marker properties are:
3460 
3461             - *dashes*
3462             - *dash_capstyle*
3463             - *dash_joinstyle*
3464             - *drawstyle*
3465             - *fillstyle*
3466             - *linestyle*
3467             - *marker*
3468             - *markeredgecolor*
3469             - *markeredgewidth*
3470             - *markerfacecolor*
3471             - *markerfacecoloralt*
3472             - *markersize*
3473             - *markevery*
3474             - *solid_capstyle*
3475             - *solid_joinstyle*
3476 
3477             Refer to the corresponding `.Line2D` property for more details:
3478 
3479             %(Line2D:kwdoc)s
3480         """
3481         kwargs = cbook.normalize_kwargs(kwargs, mlines.Line2D)
3482         # Drop anything that comes in as None to use the default instead.
3483         kwargs = {k: v for k, v in kwargs.items() if v is not None}
3484         kwargs.setdefault('zorder', 2)
3485 
3486         # Casting to object arrays preserves units.
3487         if not isinstance(x, np.ndarray):
3488             x = np.asarray(x, dtype=object)
3489         if not isinstance(y, np.ndarray):
3490             y = np.asarray(y, dtype=object)
3491 
3492         def _upcast_err(err):
3493             """
3494             Safely handle tuple of containers that carry units.
3495 
3496             This function covers the case where the input to the xerr/yerr is a
3497             length 2 tuple of equal length ndarray-subclasses that carry the
3498             unit information in the container.
3499 
3500             If we have a tuple of nested numpy array (subclasses), we defer
3501             coercing the units to be consistent to the underlying unit
3502             library (and implicitly the broadcasting).
3503 
3504             Otherwise, fallback to casting to an object array.
3505             """
3506 
3507             if (
3508                     # make sure it is not a scalar
3509                     np.iterable(err) and
3510                     # and it is not empty
3511                     len(err) > 0 and
3512                     # and the first element is an array sub-class use
3513                     # safe_first_element because getitem is index-first not
3514                     # location first on pandas objects so err[0] almost always
3515                     # fails.
3516                     isinstance(cbook._safe_first_finite(err), np.ndarray)
3517             ):
3518                 # Get the type of the first element
3519                 atype = type(cbook._safe_first_finite(err))
3520                 # Promote the outer container to match the inner container
3521                 if atype is np.ndarray:
3522                     # Converts using np.asarray, because data cannot
3523                     # be directly passed to init of np.ndarray
3524                     return np.asarray(err, dtype=object)
3525                 # If atype is not np.ndarray, directly pass data to init.
3526                 # This works for types such as unyts and astropy units
3527                 return atype(err)
3528             # Otherwise wrap it in an object array
3529             return np.asarray(err, dtype=object)
3530 
3531         if xerr is not None and not isinstance(xerr, np.ndarray):
3532             xerr = _upcast_err(xerr)
3533         if yerr is not None and not isinstance(yerr, np.ndarray):
3534             yerr = _upcast_err(yerr)
3535         x, y = np.atleast_1d(x, y)  # Make sure all the args are iterable.
3536         if len(x) != len(y):
3537             raise ValueError("'x' and 'y' must have the same size")
3538 
3539         everymask = self._errorevery_to_mask(x, errorevery)
3540 
3541         label = kwargs.pop("label", None)
3542         kwargs['label'] = '_nolegend_'
3543 
3544         # Create the main line and determine overall kwargs for child artists.
3545         # We avoid calling self.plot() directly, or self._get_lines(), because
3546         # that would call self._process_unit_info again, and do other indirect
3547         # data processing.
3548         (data_line, base_style), = self._get_lines._plot_args(
3549             (x, y) if fmt == '' else (x, y, fmt), kwargs, return_kwargs=True)
3550 
3551         # Do this after creating `data_line` to avoid modifying `base_style`.
3552         if barsabove:
3553             data_line.set_zorder(kwargs['zorder'] - .1)
3554         else:
3555             data_line.set_zorder(kwargs['zorder'] + .1)
3556 
3557         # Add line to plot, or throw it away and use it to determine kwargs.
3558         if fmt.lower() != 'none':
3559             self.add_line(data_line)
3560         else:
3561             data_line = None
3562             # Remove alpha=0 color that _get_lines._plot_args returns for
3563             # 'none' format, and replace it with user-specified color, if
3564             # supplied.
3565             base_style.pop('color')
3566             if 'color' in kwargs:
3567                 base_style['color'] = kwargs.pop('color')
3568 
3569         if 'color' not in base_style:
3570             base_style['color'] = 'C0'
3571         if ecolor is None:
3572             ecolor = base_style['color']
3573 
3574         # Eject any line-specific information from format string, as it's not
3575         # needed for bars or caps.
3576         for key in ['marker', 'markersize', 'markerfacecolor',
3577                     'markerfacecoloralt',
3578                     'markeredgewidth', 'markeredgecolor', 'markevery',
3579                     'linestyle', 'fillstyle', 'drawstyle', 'dash_capstyle',
3580                     'dash_joinstyle', 'solid_capstyle', 'solid_joinstyle',
3581                     'dashes']:
3582             base_style.pop(key, None)
3583 
3584         # Make the style dict for the line collections (the bars).
3585         eb_lines_style = {**base_style, 'color': ecolor}
3586 
3587         if elinewidth is not None:
3588             eb_lines_style['linewidth'] = elinewidth
3589         elif 'linewidth' in kwargs:
3590             eb_lines_style['linewidth'] = kwargs['linewidth']
3591 
3592         for key in ('transform', 'alpha', 'zorder', 'rasterized'):
3593             if key in kwargs:
3594                 eb_lines_style[key] = kwargs[key]
3595 
3596         # Make the style dict for caps (the "hats").
3597         eb_cap_style = {**base_style, 'linestyle': 'none'}
3598         if capsize is None:
3599             capsize = mpl.rcParams["errorbar.capsize"]
3600         if capsize > 0:
3601             eb_cap_style['markersize'] = 2. * capsize
3602         if capthick is not None:
3603             eb_cap_style['markeredgewidth'] = capthick
3604 
3605         # For backwards-compat, allow explicit setting of
3606         # 'markeredgewidth' to over-ride capthick.
3607         for key in ('markeredgewidth', 'transform', 'alpha',
3608                     'zorder', 'rasterized'):
3609             if key in kwargs:
3610                 eb_cap_style[key] = kwargs[key]
3611         eb_cap_style['color'] = ecolor
3612 
3613         barcols = []
3614         caplines = {'x': [], 'y': []}
3615 
3616         # Vectorized fancy-indexer.
3617         def apply_mask(arrays, mask):
3618             return [array[mask] for array in arrays]
3619 
3620         # dep: dependent dataset, indep: independent dataset
3621         for (dep_axis, dep, err, lolims, uplims, indep, lines_func,
3622              marker, lomarker, himarker) in [
3623                 ("x", x, xerr, xlolims, xuplims, y, self.hlines,
3624                  "|", mlines.CARETRIGHTBASE, mlines.CARETLEFTBASE),
3625                 ("y", y, yerr, lolims, uplims, x, self.vlines,
3626                  "_", mlines.CARETUPBASE, mlines.CARETDOWNBASE),
3627         ]:
3628             if err is None:
3629                 continue
3630             lolims = np.broadcast_to(lolims, len(dep)).astype(bool)
3631             uplims = np.broadcast_to(uplims, len(dep)).astype(bool)
3632             try:
3633                 np.broadcast_to(err, (2, len(dep)))
3634             except ValueError:
3635                 raise ValueError(
3636                     f"'{dep_axis}err' (shape: {np.shape(err)}) must be a "
3637                     f"scalar or a 1D or (2, n) array-like whose shape matches "
3638                     f"'{dep_axis}' (shape: {np.shape(dep)})") from None
3639             res = np.zeros(err.shape, dtype=bool)  # Default in case of nan
3640             if np.any(np.less(err, -err, out=res, where=(err == err))):
3641                 # like err<0, but also works for timedelta and nan.
3642                 raise ValueError(
3643                     f"'{dep_axis}err' must not contain negative values")
3644             # This is like
3645             #     elow, ehigh = np.broadcast_to(...)
3646             #     return dep - elow * ~lolims, dep + ehigh * ~uplims
3647             # except that broadcast_to would strip units.
3648             low, high = dep + np.row_stack([-(1 - lolims), 1 - uplims]) * err
3649             barcols.append(lines_func(
3650                 *apply_mask([indep, low, high], everymask), **eb_lines_style))
3651             if self.name == "polar" and dep_axis == "x":
3652                 for b in barcols:
3653                     for p in b.get_paths():
3654                         p._interpolation_steps = 2
3655             # Normal errorbars for points without upper/lower limits.
3656             nolims = ~(lolims | uplims)
3657             if nolims.any() and capsize > 0:
3658                 indep_masked, lo_masked, hi_masked = apply_mask(
3659                     [indep, low, high], nolims & everymask)
3660                 for lh_masked in [lo_masked, hi_masked]:
3661                     # Since this has to work for x and y as dependent data, we
3662                     # first set both x and y to the independent variable and
3663                     # overwrite the respective dependent data in a second step.
3664                     line = mlines.Line2D(indep_masked, indep_masked,
3665                                          marker=marker, **eb_cap_style)
3666                     line.set(**{f"{dep_axis}data": lh_masked})
3667                     caplines[dep_axis].append(line)
3668             for idx, (lims, hl) in enumerate([(lolims, high), (uplims, low)]):
3669                 if not lims.any():
3670                     continue
3671                 hlmarker = (
3672                     himarker
3673                     if self._axis_map[dep_axis].get_inverted() ^ idx
3674                     else lomarker)
3675                 x_masked, y_masked, hl_masked = apply_mask(
3676                     [x, y, hl], lims & everymask)
3677                 # As above, we set the dependent data in a second step.
3678                 line = mlines.Line2D(x_masked, y_masked,
3679                                      marker=hlmarker, **eb_cap_style)
3680                 line.set(**{f"{dep_axis}data": hl_masked})
3681                 caplines[dep_axis].append(line)
3682                 if capsize > 0:
3683                     caplines[dep_axis].append(mlines.Line2D(
3684                         x_masked, y_masked, marker=marker, **eb_cap_style))
3685         if self.name == 'polar':
3686             for axis in caplines:
3687                 for l in caplines[axis]:
3688                     # Rotate caps to be perpendicular to the error bars
3689                     for theta, r in zip(l.get_xdata(), l.get_ydata()):
3690                         rotation = mtransforms.Affine2D().rotate(theta)
3691                         if axis == 'y':
3692                             rotation.rotate(-np.pi / 2)
3693                         ms = mmarkers.MarkerStyle(marker=marker,
3694                                                   transform=rotation)
3695                         self.add_line(mlines.Line2D([theta], [r], marker=ms,
3696                                                     **eb_cap_style))
3697         else:
3698             for axis in caplines:
3699                 for l in caplines[axis]:
3700                     self.add_line(l)
3701 
3702         self._request_autoscale_view()
3703         caplines = caplines['x'] + caplines['y']
3704         errorbar_container = ErrorbarContainer(
3705             (data_line, tuple(caplines), tuple(barcols)),
3706             has_xerr=(xerr is not None), has_yerr=(yerr is not None),
3707             label=label)
3708         self.containers.append(errorbar_container)
3709 
3710         return errorbar_container  # (l0, caplines, barcols)
3711 
3712     @_preprocess_data()
3713     def boxplot(self, x, notch=None, sym=None, vert=None, whis=None,
3714                 positions=None, widths=None, patch_artist=None,
3715                 bootstrap=None, usermedians=None, conf_intervals=None,
3716                 meanline=None, showmeans=None, showcaps=None,
3717                 showbox=None, showfliers=None, boxprops=None,
3718                 labels=None, flierprops=None, medianprops=None,
3719                 meanprops=None, capprops=None, whiskerprops=None,
3720                 manage_ticks=True, autorange=False, zorder=None,
3721                 capwidths=None):
3722         """
3723         Draw a box and whisker plot.
3724 
3725         The box extends from the first quartile (Q1) to the third
3726         quartile (Q3) of the data, with a line at the median.
3727         The whiskers extend from the box to the farthest data point
3728         lying within 1.5x the inter-quartile range (IQR) from the box.
3729         Flier points are those past the end of the whiskers.
3730         See https://en.wikipedia.org/wiki/Box_plot for reference.
3731 
3732         .. code-block:: none
3733 
3734                   Q1-1.5IQR   Q1   median  Q3   Q3+1.5IQR
3735                                |-----:-----|
3736                o      |--------|     :     |--------|    o  o
3737                                |-----:-----|
3738              flier             <----------->            fliers
3739                                     IQR
3740 
3741 
3742         Parameters
3743         ----------
3744         x : Array or a sequence of vectors.
3745             The input data.  If a 2D array, a boxplot is drawn for each column
3746             in *x*.  If a sequence of 1D arrays, a boxplot is drawn for each
3747             array in *x*.
3748 
3749         notch : bool, default: False
3750             Whether to draw a notched boxplot (`True`), or a rectangular
3751             boxplot (`False`).  The notches represent the confidence interval
3752             (CI) around the median.  The documentation for *bootstrap*
3753             describes how the locations of the notches are computed by
3754             default, but their locations may also be overridden by setting the
3755             *conf_intervals* parameter.
3756 
3757             .. note::
3758 
3759                 In cases where the values of the CI are less than the
3760                 lower quartile or greater than the upper quartile, the
3761                 notches will extend beyond the box, giving it a
3762                 distinctive "flipped" appearance. This is expected
3763                 behavior and consistent with other statistical
3764                 visualization packages.
3765 
3766         sym : str, optional
3767             The default symbol for flier points.  An empty string ('') hides
3768             the fliers.  If `None`, then the fliers default to 'b+'.  More
3769             control is provided by the *flierprops* parameter.
3770 
3771         vert : bool, default: True
3772             If `True`, draws vertical boxes.
3773             If `False`, draw horizontal boxes.
3774 
3775         whis : float or (float, float), default: 1.5
3776             The position of the whiskers.
3777 
3778             If a float, the lower whisker is at the lowest datum above
3779             ``Q1 - whis*(Q3-Q1)``, and the upper whisker at the highest datum
3780             below ``Q3 + whis*(Q3-Q1)``, where Q1 and Q3 are the first and
3781             third quartiles.  The default value of ``whis = 1.5`` corresponds
3782             to Tukey's original definition of boxplots.
3783 
3784             If a pair of floats, they indicate the percentiles at which to
3785             draw the whiskers (e.g., (5, 95)).  In particular, setting this to
3786             (0, 100) results in whiskers covering the whole range of the data.
3787 
3788             In the edge case where ``Q1 == Q3``, *whis* is automatically set
3789             to (0, 100) (cover the whole range of the data) if *autorange* is
3790             True.
3791 
3792             Beyond the whiskers, data are considered outliers and are plotted
3793             as individual points.
3794 
3795         bootstrap : int, optional
3796             Specifies whether to bootstrap the confidence intervals
3797             around the median for notched boxplots. If *bootstrap* is
3798             None, no bootstrapping is performed, and notches are
3799             calculated using a Gaussian-based asymptotic approximation
3800             (see McGill, R., Tukey, J.W., and Larsen, W.A., 1978, and
3801             Kendall and Stuart, 1967). Otherwise, bootstrap specifies
3802             the number of times to bootstrap the median to determine its
3803             95% confidence intervals. Values between 1000 and 10000 are
3804             recommended.
3805 
3806         usermedians : 1D array-like, optional
3807             A 1D array-like of length ``len(x)``.  Each entry that is not
3808             `None` forces the value of the median for the corresponding
3809             dataset.  For entries that are `None`, the medians are computed
3810             by Matplotlib as normal.
3811 
3812         conf_intervals : array-like, optional
3813             A 2D array-like of shape ``(len(x), 2)``.  Each entry that is not
3814             None forces the location of the corresponding notch (which is
3815             only drawn if *notch* is `True`).  For entries that are `None`,
3816             the notches are computed by the method specified by the other
3817             parameters (e.g., *bootstrap*).
3818 
3819         positions : array-like, optional
3820             The positions of the boxes. The ticks and limits are
3821             automatically set to match the positions. Defaults to
3822             ``range(1, N+1)`` where N is the number of boxes to be drawn.
3823 
3824         widths : float or array-like
3825             The widths of the boxes.  The default is 0.5, or ``0.15*(distance
3826             between extreme positions)``, if that is smaller.
3827 
3828         patch_artist : bool, default: False
3829             If `False` produces boxes with the Line2D artist. Otherwise,
3830             boxes are drawn with Patch artists.
3831 
3832         labels : sequence, optional
3833             Labels for each dataset (one per dataset).
3834 
3835         manage_ticks : bool, default: True
3836             If True, the tick locations and labels will be adjusted to match
3837             the boxplot positions.
3838 
3839         autorange : bool, default: False
3840             When `True` and the data are distributed such that the 25th and
3841             75th percentiles are equal, *whis* is set to (0, 100) such
3842             that the whisker ends are at the minimum and maximum of the data.
3843 
3844         meanline : bool, default: False
3845             If `True` (and *showmeans* is `True`), will try to render the
3846             mean as a line spanning the full width of the box according to
3847             *meanprops* (see below).  Not recommended if *shownotches* is also
3848             True.  Otherwise, means will be shown as points.
3849 
3850         zorder : float, default: ``Line2D.zorder = 2``
3851             The zorder of the boxplot.
3852 
3853         Returns
3854         -------
3855         dict
3856           A dictionary mapping each component of the boxplot to a list
3857           of the `.Line2D` instances created. That dictionary has the
3858           following keys (assuming vertical boxplots):
3859 
3860           - ``boxes``: the main body of the boxplot showing the
3861             quartiles and the median's confidence intervals if
3862             enabled.
3863 
3864           - ``medians``: horizontal lines at the median of each box.
3865 
3866           - ``whiskers``: the vertical lines extending to the most
3867             extreme, non-outlier data points.
3868 
3869           - ``caps``: the horizontal lines at the ends of the
3870             whiskers.
3871 
3872           - ``fliers``: points representing data that extend beyond
3873             the whiskers (fliers).
3874 
3875           - ``means``: points or lines representing the means.
3876 
3877         Other Parameters
3878         ----------------
3879         showcaps : bool, default: True
3880             Show the caps on the ends of whiskers.
3881         showbox : bool, default: True
3882             Show the central box.
3883         showfliers : bool, default: True
3884             Show the outliers beyond the caps.
3885         showmeans : bool, default: False
3886             Show the arithmetic means.
3887         capprops : dict, default: None
3888             The style of the caps.
3889         capwidths : float or array, default: None
3890             The widths of the caps.
3891         boxprops : dict, default: None
3892             The style of the box.
3893         whiskerprops : dict, default: None
3894             The style of the whiskers.
3895         flierprops : dict, default: None
3896             The style of the fliers.
3897         medianprops : dict, default: None
3898             The style of the median.
3899         meanprops : dict, default: None
3900             The style of the mean.
3901         data : indexable object, optional
3902             DATA_PARAMETER_PLACEHOLDER
3903 
3904         See Also
3905         --------
3906         violinplot : Draw an estimate of the probability density function.
3907         """
3908 
3909         # Missing arguments default to rcParams.
3910         if whis is None:
3911             whis = mpl.rcParams['boxplot.whiskers']
3912         if bootstrap is None:
3913             bootstrap = mpl.rcParams['boxplot.bootstrap']
3914 
3915         bxpstats = cbook.boxplot_stats(x, whis=whis, bootstrap=bootstrap,
3916                                        labels=labels, autorange=autorange)
3917         if notch is None:
3918             notch = mpl.rcParams['boxplot.notch']
3919         if vert is None:
3920             vert = mpl.rcParams['boxplot.vertical']
3921         if patch_artist is None:
3922             patch_artist = mpl.rcParams['boxplot.patchartist']
3923         if meanline is None:
3924             meanline = mpl.rcParams['boxplot.meanline']
3925         if showmeans is None:
3926             showmeans = mpl.rcParams['boxplot.showmeans']
3927         if showcaps is None:
3928             showcaps = mpl.rcParams['boxplot.showcaps']
3929         if showbox is None:
3930             showbox = mpl.rcParams['boxplot.showbox']
3931         if showfliers is None:
3932             showfliers = mpl.rcParams['boxplot.showfliers']
3933 
3934         if boxprops is None:
3935             boxprops = {}
3936         if whiskerprops is None:
3937             whiskerprops = {}
3938         if capprops is None:
3939             capprops = {}
3940         if medianprops is None:
3941             medianprops = {}
3942         if meanprops is None:
3943             meanprops = {}
3944         if flierprops is None:
3945             flierprops = {}
3946 
3947         if patch_artist:
3948             boxprops['linestyle'] = 'solid'  # Not consistent with bxp.
3949             if 'color' in boxprops:
3950                 boxprops['edgecolor'] = boxprops.pop('color')
3951 
3952         # if non-default sym value, put it into the flier dictionary
3953         # the logic for providing the default symbol ('b+') now lives
3954         # in bxp in the initial value of flierkw
3955         # handle all of the *sym* related logic here so we only have to pass
3956         # on the flierprops dict.
3957         if sym is not None:
3958             # no-flier case, which should really be done with
3959             # 'showfliers=False' but none-the-less deal with it to keep back
3960             # compatibility
3961             if sym == '':
3962                 # blow away existing dict and make one for invisible markers
3963                 flierprops = dict(linestyle='none', marker='', color='none')
3964                 # turn the fliers off just to be safe
3965                 showfliers = False
3966             # now process the symbol string
3967             else:
3968                 # process the symbol string
3969                 # discarded linestyle
3970                 _, marker, color = _process_plot_format(sym)
3971                 # if we have a marker, use it
3972                 if marker is not None:
3973                     flierprops['marker'] = marker
3974                 # if we have a color, use it
3975                 if color is not None:
3976                     # assume that if color is passed in the user want
3977                     # filled symbol, if the users want more control use
3978                     # flierprops
3979                     flierprops['color'] = color
3980                     flierprops['markerfacecolor'] = color
3981                     flierprops['markeredgecolor'] = color
3982 
3983         # replace medians if necessary:
3984         if usermedians is not None:
3985             if (len(np.ravel(usermedians)) != len(bxpstats) or
3986                     np.shape(usermedians)[0] != len(bxpstats)):
3987                 raise ValueError(
3988                     "'usermedians' and 'x' have different lengths")
3989             else:
3990                 # reassign medians as necessary
3991                 for stats, med in zip(bxpstats, usermedians):
3992                     if med is not None:
3993                         stats['med'] = med
3994 
3995         if conf_intervals is not None:
3996             if len(conf_intervals) != len(bxpstats):
3997                 raise ValueError(
3998                     "'conf_intervals' and 'x' have different lengths")
3999             else:
4000                 for stats, ci in zip(bxpstats, conf_intervals):
4001                     if ci is not None:
4002                         if len(ci) != 2:
4003                             raise ValueError('each confidence interval must '
4004                                              'have two values')
4005                         else:
4006                             if ci[0] is not None:
4007                                 stats['cilo'] = ci[0]
4008                             if ci[1] is not None:
4009                                 stats['cihi'] = ci[1]
4010 
4011         artists = self.bxp(bxpstats, positions=positions, widths=widths,
4012                            vert=vert, patch_artist=patch_artist,
4013                            shownotches=notch, showmeans=showmeans,
4014                            showcaps=showcaps, showbox=showbox,
4015                            boxprops=boxprops, flierprops=flierprops,
4016                            medianprops=medianprops, meanprops=meanprops,
4017                            meanline=meanline, showfliers=showfliers,
4018                            capprops=capprops, whiskerprops=whiskerprops,
4019                            manage_ticks=manage_ticks, zorder=zorder,
4020                            capwidths=capwidths)
4021         return artists
4022 
4023     def bxp(self, bxpstats, positions=None, widths=None, vert=True,
4024             patch_artist=False, shownotches=False, showmeans=False,
4025             showcaps=True, showbox=True, showfliers=True,
4026             boxprops=None, whiskerprops=None, flierprops=None,
4027             medianprops=None, capprops=None, meanprops=None,
4028             meanline=False, manage_ticks=True, zorder=None,
4029             capwidths=None):
4030         """
4031         Drawing function for box and whisker plots.
4032 
4033         Make a box and whisker plot for each column of *x* or each
4034         vector in sequence *x*.  The box extends from the lower to
4035         upper quartile values of the data, with a line at the median.
4036         The whiskers extend from the box to show the range of the
4037         data.  Flier points are those past the end of the whiskers.
4038 
4039         Parameters
4040         ----------
4041         bxpstats : list of dicts
4042           A list of dictionaries containing stats for each boxplot.
4043           Required keys are:
4044 
4045           - ``med``: Median (scalar).
4046           - ``q1``, ``q3``: First & third quartiles (scalars).
4047           - ``whislo``, ``whishi``: Lower & upper whisker positions (scalars).
4048 
4049           Optional keys are:
4050 
4051           - ``mean``: Mean (scalar).  Needed if ``showmeans=True``.
4052           - ``fliers``: Data beyond the whiskers (array-like).
4053             Needed if ``showfliers=True``.
4054           - ``cilo``, ``cihi``: Lower & upper confidence intervals
4055             about the median. Needed if ``shownotches=True``.
4056           - ``label``: Name of the dataset (str).  If available,
4057             this will be used a tick label for the boxplot
4058 
4059         positions : array-like, default: [1, 2, ..., n]
4060           The positions of the boxes. The ticks and limits
4061           are automatically set to match the positions.
4062 
4063         widths : float or array-like, default: None
4064           The widths of the boxes.  The default is
4065           ``clip(0.15*(distance between extreme positions), 0.15, 0.5)``.
4066 
4067         capwidths : float or array-like, default: None
4068           Either a scalar or a vector and sets the width of each cap.
4069           The default is ``0.5*(with of the box)``, see *widths*.
4070 
4071         vert : bool, default: True
4072           If `True` (default), makes the boxes vertical.
4073           If `False`, makes horizontal boxes.
4074 
4075         patch_artist : bool, default: False
4076           If `False` produces boxes with the `.Line2D` artist.
4077           If `True` produces boxes with the `~matplotlib.patches.Patch` artist.
4078 
4079         shownotches, showmeans, showcaps, showbox, showfliers : bool
4080           Whether to draw the CI notches, the mean value (both default to
4081           False), the caps, the box, and the fliers (all three default to
4082           True).
4083 
4084         boxprops, whiskerprops, capprops, flierprops, medianprops, meanprops :\
4085  dict, optional
4086           Artist properties for the boxes, whiskers, caps, fliers, medians, and
4087           means.
4088 
4089         meanline : bool, default: False
4090           If `True` (and *showmeans* is `True`), will try to render the mean
4091           as a line spanning the full width of the box according to
4092           *meanprops*. Not recommended if *shownotches* is also True.
4093           Otherwise, means will be shown as points.
4094 
4095         manage_ticks : bool, default: True
4096           If True, the tick locations and labels will be adjusted to match the
4097           boxplot positions.
4098 
4099         zorder : float, default: ``Line2D.zorder = 2``
4100           The zorder of the resulting boxplot.
4101 
4102         Returns
4103         -------
4104         dict
4105           A dictionary mapping each component of the boxplot to a list
4106           of the `.Line2D` instances created. That dictionary has the
4107           following keys (assuming vertical boxplots):
4108 
4109           - ``boxes``: main bodies of the boxplot showing the quartiles, and
4110             the median's confidence intervals if enabled.
4111           - ``medians``: horizontal lines at the median of each box.
4112           - ``whiskers``: vertical lines up to the last non-outlier data.
4113           - ``caps``: horizontal lines at the ends of the whiskers.
4114           - ``fliers``: points representing data beyond the whiskers (fliers).
4115           - ``means``: points or lines representing the means.
4116 
4117         Examples
4118         --------
4119         .. plot:: gallery/statistics/bxp.py
4120         """
4121 
4122         # lists of artists to be output
4123         whiskers = []
4124         caps = []
4125         boxes = []
4126         medians = []
4127         means = []
4128         fliers = []
4129 
4130         # empty list of xticklabels
4131         datalabels = []
4132 
4133         # Use default zorder if none specified
4134         if zorder is None:
4135             zorder = mlines.Line2D.zorder
4136 
4137         zdelta = 0.1
4138 
4139         def merge_kw_rc(subkey, explicit, zdelta=0, usemarker=True):
4140             d = {k.split('.')[-1]: v for k, v in mpl.rcParams.items()
4141                  if k.startswith(f'boxplot.{subkey}props')}
4142             d['zorder'] = zorder + zdelta
4143             if not usemarker:
4144                 d['marker'] = ''
4145             d.update(cbook.normalize_kwargs(explicit, mlines.Line2D))
4146             return d
4147 
4148         box_kw = {
4149             'linestyle': mpl.rcParams['boxplot.boxprops.linestyle'],
4150             'linewidth': mpl.rcParams['boxplot.boxprops.linewidth'],
4151             'edgecolor': mpl.rcParams['boxplot.boxprops.color'],
4152             'facecolor': ('white' if mpl.rcParams['_internal.classic_mode']
4153                           else mpl.rcParams['patch.facecolor']),
4154             'zorder': zorder,
4155             **cbook.normalize_kwargs(boxprops, mpatches.PathPatch)
4156         } if patch_artist else merge_kw_rc('box', boxprops, usemarker=False)
4157         whisker_kw = merge_kw_rc('whisker', whiskerprops, usemarker=False)
4158         cap_kw = merge_kw_rc('cap', capprops, usemarker=False)
4159         flier_kw = merge_kw_rc('flier', flierprops)
4160         median_kw = merge_kw_rc('median', medianprops, zdelta, usemarker=False)
4161         mean_kw = merge_kw_rc('mean', meanprops, zdelta)
4162         removed_prop = 'marker' if meanline else 'linestyle'
4163         # Only remove the property if it's not set explicitly as a parameter.
4164         if meanprops is None or removed_prop not in meanprops:
4165             mean_kw[removed_prop] = ''
4166 
4167         # vertical or horizontal plot?
4168         maybe_swap = slice(None) if vert else slice(None, None, -1)
4169 
4170         def do_plot(xs, ys, **kwargs):
4171             return self.plot(*[xs, ys][maybe_swap], **kwargs)[0]
4172 
4173         def do_patch(xs, ys, **kwargs):
4174             path = mpath.Path._create_closed(
4175                 np.column_stack([xs, ys][maybe_swap]))
4176             patch = mpatches.PathPatch(path, **kwargs)
4177             self.add_artist(patch)
4178             return patch
4179 
4180         # input validation
4181         N = len(bxpstats)
4182         datashape_message = ("List of boxplot statistics and `{0}` "
4183                              "values must have same the length")
4184         # check position
4185         if positions is None:
4186             positions = list(range(1, N + 1))
4187         elif len(positions) != N:
4188             raise ValueError(datashape_message.format("positions"))
4189 
4190         positions = np.array(positions)
4191         if len(positions) > 0 and not all(isinstance(p, Real) for p in positions):
4192             raise TypeError("positions should be an iterable of numbers")
4193 
4194         # width
4195         if widths is None:
4196             widths = [np.clip(0.15 * np.ptp(positions), 0.15, 0.5)] * N
4197         elif np.isscalar(widths):
4198             widths = [widths] * N
4199         elif len(widths) != N:
4200             raise ValueError(datashape_message.format("widths"))
4201 
4202         # capwidth
4203         if capwidths is None:
4204             capwidths = 0.5 * np.array(widths)
4205         elif np.isscalar(capwidths):
4206             capwidths = [capwidths] * N
4207         elif len(capwidths) != N:
4208             raise ValueError(datashape_message.format("capwidths"))
4209 
4210         for pos, width, stats, capwidth in zip(positions, widths, bxpstats,
4211                                                capwidths):
4212             # try to find a new label
4213             datalabels.append(stats.get('label', pos))
4214 
4215             # whisker coords
4216             whis_x = [pos, pos]
4217             whislo_y = [stats['q1'], stats['whislo']]
4218             whishi_y = [stats['q3'], stats['whishi']]
4219             # cap coords
4220             cap_left = pos - capwidth * 0.5
4221             cap_right = pos + capwidth * 0.5
4222             cap_x = [cap_left, cap_right]
4223             cap_lo = np.full(2, stats['whislo'])
4224             cap_hi = np.full(2, stats['whishi'])
4225             # box and median coords
4226             box_left = pos - width * 0.5
4227             box_right = pos + width * 0.5
4228             med_y = [stats['med'], stats['med']]
4229             # notched boxes
4230             if shownotches:
4231                 notch_left = pos - width * 0.25
4232                 notch_right = pos + width * 0.25
4233                 box_x = [box_left, box_right, box_right, notch_right,
4234                          box_right, box_right, box_left, box_left, notch_left,
4235                          box_left, box_left]
4236                 box_y = [stats['q1'], stats['q1'], stats['cilo'],
4237                          stats['med'], stats['cihi'], stats['q3'],
4238                          stats['q3'], stats['cihi'], stats['med'],
4239                          stats['cilo'], stats['q1']]
4240                 med_x = [notch_left, notch_right]
4241             # plain boxes
4242             else:
4243                 box_x = [box_left, box_right, box_right, box_left, box_left]
4244                 box_y = [stats['q1'], stats['q1'], stats['q3'], stats['q3'],
4245                          stats['q1']]
4246                 med_x = [box_left, box_right]
4247 
4248             # maybe draw the box
4249             if showbox:
4250                 do_box = do_patch if patch_artist else do_plot
4251                 boxes.append(do_box(box_x, box_y, **box_kw))
4252             # draw the whiskers
4253             whiskers.append(do_plot(whis_x, whislo_y, **whisker_kw))
4254             whiskers.append(do_plot(whis_x, whishi_y, **whisker_kw))
4255             # maybe draw the caps
4256             if showcaps:
4257                 caps.append(do_plot(cap_x, cap_lo, **cap_kw))
4258                 caps.append(do_plot(cap_x, cap_hi, **cap_kw))
4259             # draw the medians
4260             medians.append(do_plot(med_x, med_y, **median_kw))
4261             # maybe draw the means
4262             if showmeans:
4263                 if meanline:
4264                     means.append(do_plot(
4265                         [box_left, box_right], [stats['mean'], stats['mean']],
4266                         **mean_kw
4267                     ))
4268                 else:
4269                     means.append(do_plot([pos], [stats['mean']], **mean_kw))
4270             # maybe draw the fliers
4271             if showfliers:
4272                 flier_x = np.full(len(stats['fliers']), pos, dtype=np.float64)
4273                 flier_y = stats['fliers']
4274                 fliers.append(do_plot(flier_x, flier_y, **flier_kw))
4275 
4276         if manage_ticks:
4277             axis_name = "x" if vert else "y"
4278             interval = getattr(self.dataLim, f"interval{axis_name}")
4279             axis = self._axis_map[axis_name]
4280             positions = axis.convert_units(positions)
4281             # The 0.5 additional padding ensures reasonable-looking boxes
4282             # even when drawing a single box.  We set the sticky edge to
4283             # prevent margins expansion, in order to match old behavior (back
4284             # when separate calls to boxplot() would completely reset the axis
4285             # limits regardless of what was drawn before).  The sticky edges
4286             # are attached to the median lines, as they are always present.
4287             interval[:] = (min(interval[0], min(positions) - .5),
4288                            max(interval[1], max(positions) + .5))
4289             for median, position in zip(medians, positions):
4290                 getattr(median.sticky_edges, axis_name).extend(
4291                     [position - .5, position + .5])
4292             # Modified from Axis.set_ticks and Axis.set_ticklabels.
4293             locator = axis.get_major_locator()
4294             if not isinstance(axis.get_major_locator(),
4295                               mticker.FixedLocator):
4296                 locator = mticker.FixedLocator([])
4297                 axis.set_major_locator(locator)
4298             locator.locs = np.array([*locator.locs, *positions])
4299             formatter = axis.get_major_formatter()
4300             if not isinstance(axis.get_major_formatter(),
4301                               mticker.FixedFormatter):
4302                 formatter = mticker.FixedFormatter([])
4303                 axis.set_major_formatter(formatter)
4304             formatter.seq = [*formatter.seq, *datalabels]
4305 
4306             self._request_autoscale_view()
4307 
4308         return dict(whiskers=whiskers, caps=caps, boxes=boxes,
4309                     medians=medians, fliers=fliers, means=means)
4310 
4311     @staticmethod
4312     def _parse_scatter_color_args(c, edgecolors, kwargs, xsize,
4313                                   get_next_color_func):
4314         """
4315         Helper function to process color related arguments of `.Axes.scatter`.
4316 
4317         Argument precedence for facecolors:
4318 
4319         - c (if not None)
4320         - kwargs['facecolor']
4321         - kwargs['facecolors']
4322         - kwargs['color'] (==kwcolor)
4323         - 'b' if in classic mode else the result of ``get_next_color_func()``
4324 
4325         Argument precedence for edgecolors:
4326 
4327         - kwargs['edgecolor']
4328         - edgecolors (is an explicit kw argument in scatter())
4329         - kwargs['color'] (==kwcolor)
4330         - 'face' if not in classic mode else None
4331 
4332         Parameters
4333         ----------
4334         c : color or sequence or sequence of color or None
4335             See argument description of `.Axes.scatter`.
4336         edgecolors : color or sequence of color or {'face', 'none'} or None
4337             See argument description of `.Axes.scatter`.
4338         kwargs : dict
4339             Additional kwargs. If these keys exist, we pop and process them:
4340             'facecolors', 'facecolor', 'edgecolor', 'color'
4341             Note: The dict is modified by this function.
4342         xsize : int
4343             The size of the x and y arrays passed to `.Axes.scatter`.
4344         get_next_color_func : callable
4345             A callable that returns a color. This color is used as facecolor
4346             if no other color is provided.
4347 
4348             Note, that this is a function rather than a fixed color value to
4349             support conditional evaluation of the next color.  As of the
4350             current implementation obtaining the next color from the
4351             property cycle advances the cycle. This must only happen if we
4352             actually use the color, which will only be decided within this
4353             method.
4354 
4355         Returns
4356         -------
4357         c
4358             The input *c* if it was not *None*, else a color derived from the
4359             other inputs or defaults.
4360         colors : array(N, 4) or None
4361             The facecolors as RGBA values, or *None* if a colormap is used.
4362         edgecolors
4363             The edgecolor.
4364 
4365         """
4366         facecolors = kwargs.pop('facecolors', None)
4367         facecolors = kwargs.pop('facecolor', facecolors)
4368         edgecolors = kwargs.pop('edgecolor', edgecolors)
4369 
4370         kwcolor = kwargs.pop('color', None)
4371 
4372         if kwcolor is not None and c is not None:
4373             raise ValueError("Supply a 'c' argument or a 'color'"
4374                              " kwarg but not both; they differ but"
4375                              " their functionalities overlap.")
4376 
4377         if kwcolor is not None:
4378             try:
4379                 mcolors.to_rgba_array(kwcolor)
4380             except ValueError as err:
4381                 raise ValueError(
4382                     "'color' kwarg must be a color or sequence of color "
4383                     "specs.  For a sequence of values to be color-mapped, use "
4384                     "the 'c' argument instead.") from err
4385             if edgecolors is None:
4386                 edgecolors = kwcolor
4387             if facecolors is None:
4388                 facecolors = kwcolor
4389 
4390         if edgecolors is None and not mpl.rcParams['_internal.classic_mode']:
4391             edgecolors = mpl.rcParams['scatter.edgecolors']
4392 
4393         c_was_none = c is None
4394         if c is None:
4395             c = (facecolors if facecolors is not None
4396                  else "b" if mpl.rcParams['_internal.classic_mode']
4397                  else get_next_color_func())
4398         c_is_string_or_strings = (
4399             isinstance(c, str)
4400             or (np.iterable(c) and len(c) > 0
4401                 and isinstance(cbook._safe_first_finite(c), str)))
4402 
4403         def invalid_shape_exception(csize, xsize):
4404             return ValueError(
4405                 f"'c' argument has {csize} elements, which is inconsistent "
4406                 f"with 'x' and 'y' with size {xsize}.")
4407 
4408         c_is_mapped = False  # Unless proven otherwise below.
4409         valid_shape = True  # Unless proven otherwise below.
4410         if not c_was_none and kwcolor is None and not c_is_string_or_strings:
4411             try:  # First, does 'c' look suitable for value-mapping?
4412                 c = np.asanyarray(c, dtype=float)
4413             except ValueError:
4414                 pass  # Failed to convert to float array; must be color specs.
4415             else:
4416                 # handle the documented special case of a 2D array with 1
4417                 # row which as RGB(A) to broadcast.
4418                 if c.shape == (1, 4) or c.shape == (1, 3):
4419                     c_is_mapped = False
4420                     if c.size != xsize:
4421                         valid_shape = False
4422                 # If c can be either mapped values or an RGB(A) color, prefer
4423                 # the former if shapes match, the latter otherwise.
4424                 elif c.size == xsize:
4425                     c = c.ravel()
4426                     c_is_mapped = True
4427                 else:  # Wrong size; it must not be intended for mapping.
4428                     if c.shape in ((3,), (4,)):
4429                         _api.warn_external(
4430                             "*c* argument looks like a single numeric RGB or "
4431                             "RGBA sequence, which should be avoided as value-"
4432                             "mapping will have precedence in case its length "
4433                             "matches with *x* & *y*.  Please use the *color* "
4434                             "keyword-argument or provide a 2D array "
4435                             "with a single row if you intend to specify "
4436                             "the same RGB or RGBA value for all points.")
4437                     valid_shape = False
4438         if not c_is_mapped:
4439             try:  # Is 'c' acceptable as PathCollection facecolors?
4440                 colors = mcolors.to_rgba_array(c)
4441             except (TypeError, ValueError) as err:
4442                 if "RGBA values should be within 0-1 range" in str(err):
4443                     raise
4444                 else:
4445                     if not valid_shape:
4446                         raise invalid_shape_exception(c.size, xsize) from err
4447                     # Both the mapping *and* the RGBA conversion failed: pretty
4448                     # severe failure => one may appreciate a verbose feedback.
4449                     raise ValueError(
4450                         f"'c' argument must be a color, a sequence of colors, "
4451                         f"or a sequence of numbers, not {c!r}") from err
4452             else:
4453                 if len(colors) not in (0, 1, xsize):
4454                     # NB: remember that a single color is also acceptable.
4455                     # Besides *colors* will be an empty array if c == 'none'.
4456                     raise invalid_shape_exception(len(colors), xsize)
4457         else:
4458             colors = None  # use cmap, norm after collection is created
4459         return c, colors, edgecolors
4460 
4461     @_preprocess_data(replace_names=["x", "y", "s", "linewidths",
4462                                      "edgecolors", "c", "facecolor",
4463                                      "facecolors", "color"],
4464                       label_namer="y")
4465     @_docstring.interpd
4466     def scatter(self, x, y, s=None, c=None, marker=None, cmap=None, norm=None,
4467                 vmin=None, vmax=None, alpha=None, linewidths=None, *,
4468                 edgecolors=None, plotnonfinite=False, **kwargs):
4469         """
4470         A scatter plot of *y* vs. *x* with varying marker size and/or color.
4471 
4472         Parameters
4473         ----------
4474         x, y : float or array-like, shape (n, )
4475             The data positions.
4476 
4477         s : float or array-like, shape (n, ), optional
4478             The marker size in points**2 (typographic points are 1/72 in.).
4479             Default is ``rcParams['lines.markersize'] ** 2``.
4480 
4481         c : array-like or list of colors or color, optional
4482             The marker colors. Possible values:
4483 
4484             - A scalar or sequence of n numbers to be mapped to colors using
4485               *cmap* and *norm*.
4486             - A 2D array in which the rows are RGB or RGBA.
4487             - A sequence of colors of length n.
4488             - A single color format string.
4489 
4490             Note that *c* should not be a single numeric RGB or RGBA sequence
4491             because that is indistinguishable from an array of values to be
4492             colormapped. If you want to specify the same RGB or RGBA value for
4493             all points, use a 2D array with a single row.  Otherwise,
4494             value-matching will have precedence in case of a size matching with
4495             *x* and *y*.
4496 
4497             If you wish to specify a single color for all points
4498             prefer the *color* keyword argument.
4499 
4500             Defaults to `None`. In that case the marker color is determined
4501             by the value of *color*, *facecolor* or *facecolors*. In case
4502             those are not specified or `None`, the marker color is determined
4503             by the next color of the ``Axes``' current "shape and fill" color
4504             cycle. This cycle defaults to :rc:`axes.prop_cycle`.
4505 
4506         marker : `~.markers.MarkerStyle`, default: :rc:`scatter.marker`
4507             The marker style. *marker* can be either an instance of the class
4508             or the text shorthand for a particular marker.
4509             See :mod:`matplotlib.markers` for more information about marker
4510             styles.
4511 
4512         %(cmap_doc)s
4513 
4514             This parameter is ignored if *c* is RGB(A).
4515 
4516         %(norm_doc)s
4517 
4518             This parameter is ignored if *c* is RGB(A).
4519 
4520         %(vmin_vmax_doc)s
4521 
4522             This parameter is ignored if *c* is RGB(A).
4523 
4524         alpha : float, default: None
4525             The alpha blending value, between 0 (transparent) and 1 (opaque).
4526 
4527         linewidths : float or array-like, default: :rc:`lines.linewidth`
4528             The linewidth of the marker edges. Note: The default *edgecolors*
4529             is 'face'. You may want to change this as well.
4530 
4531         edgecolors : {'face', 'none', *None*} or color or sequence of color, \
4532 default: :rc:`scatter.edgecolors`
4533             The edge color of the marker. Possible values:
4534 
4535             - 'face': The edge color will always be the same as the face color.
4536             - 'none': No patch boundary will be drawn.
4537             - A color or sequence of colors.
4538 
4539             For non-filled markers, *edgecolors* is ignored. Instead, the color
4540             is determined like with 'face', i.e. from *c*, *colors*, or
4541             *facecolors*.
4542 
4543         plotnonfinite : bool, default: False
4544             Whether to plot points with nonfinite *c* (i.e. ``inf``, ``-inf``
4545             or ``nan``). If ``True`` the points are drawn with the *bad*
4546             colormap color (see `.Colormap.set_bad`).
4547 
4548         Returns
4549         -------
4550         `~matplotlib.collections.PathCollection`
4551 
4552         Other Parameters
4553         ----------------
4554         data : indexable object, optional
4555             DATA_PARAMETER_PLACEHOLDER
4556         **kwargs : `~matplotlib.collections.Collection` properties
4557 
4558         See Also
4559         --------
4560         plot : To plot scatter plots when markers are identical in size and
4561             color.
4562 
4563         Notes
4564         -----
4565         * The `.plot` function will be faster for scatterplots where markers
4566           don't vary in size or color.
4567 
4568         * Any or all of *x*, *y*, *s*, and *c* may be masked arrays, in which
4569           case all masks will be combined and only unmasked points will be
4570           plotted.
4571 
4572         * Fundamentally, scatter works with 1D arrays; *x*, *y*, *s*, and *c*
4573           may be input as N-D arrays, but within scatter they will be
4574           flattened. The exception is *c*, which will be flattened only if its
4575           size matches the size of *x* and *y*.
4576 
4577         """
4578         # Process **kwargs to handle aliases, conflicts with explicit kwargs:
4579         x, y = self._process_unit_info([("x", x), ("y", y)], kwargs)
4580         # np.ma.ravel yields an ndarray, not a masked array,
4581         # unless its argument is a masked array.
4582         x = np.ma.ravel(x)
4583         y = np.ma.ravel(y)
4584         if x.size != y.size:
4585             raise ValueError("x and y must be the same size")
4586 
4587         if s is None:
4588             s = (20 if mpl.rcParams['_internal.classic_mode'] else
4589                  mpl.rcParams['lines.markersize'] ** 2.0)
4590         s = np.ma.ravel(s)
4591         if (len(s) not in (1, x.size) or
4592                 (not np.issubdtype(s.dtype, np.floating) and
4593                  not np.issubdtype(s.dtype, np.integer))):
4594             raise ValueError(
4595                 "s must be a scalar, "
4596                 "or float array-like with the same size as x and y")
4597 
4598         # get the original edgecolor the user passed before we normalize
4599         orig_edgecolor = edgecolors
4600         if edgecolors is None:
4601             orig_edgecolor = kwargs.get('edgecolor', None)
4602         c, colors, edgecolors = \
4603             self._parse_scatter_color_args(
4604                 c, edgecolors, kwargs, x.size,
4605                 get_next_color_func=self._get_patches_for_fill.get_next_color)
4606 
4607         if plotnonfinite and colors is None:
4608             c = np.ma.masked_invalid(c)
4609             x, y, s, edgecolors, linewidths = \
4610                 cbook._combine_masks(x, y, s, edgecolors, linewidths)
4611         else:
4612             x, y, s, c, colors, edgecolors, linewidths = \
4613                 cbook._combine_masks(
4614                     x, y, s, c, colors, edgecolors, linewidths)
4615         # Unmask edgecolors if it was actually a single RGB or RGBA.
4616         if (x.size in (3, 4)
4617                 and np.ma.is_masked(edgecolors)
4618                 and not np.ma.is_masked(orig_edgecolor)):
4619             edgecolors = edgecolors.data
4620 
4621         scales = s   # Renamed for readability below.
4622 
4623         # load default marker from rcParams
4624         if marker is None:
4625             marker = mpl.rcParams['scatter.marker']
4626 
4627         if isinstance(marker, mmarkers.MarkerStyle):
4628             marker_obj = marker
4629         else:
4630             marker_obj = mmarkers.MarkerStyle(marker)
4631 
4632         path = marker_obj.get_path().transformed(
4633             marker_obj.get_transform())
4634         if not marker_obj.is_filled():
4635             if orig_edgecolor is not None:
4636                 _api.warn_external(
4637                     f"You passed a edgecolor/edgecolors ({orig_edgecolor!r}) "
4638                     f"for an unfilled marker ({marker!r}).  Matplotlib is "
4639                     "ignoring the edgecolor in favor of the facecolor.  This "
4640                     "behavior may change in the future."
4641                 )
4642             # We need to handle markers that can not be filled (like
4643             # '+' and 'x') differently than markers that can be
4644             # filled, but have their fillstyle set to 'none'.  This is
4645             # to get:
4646             #
4647             #  - respecting the fillestyle if set
4648             #  - maintaining back-compatibility for querying the facecolor of
4649             #    the un-fillable markers.
4650             #
4651             # While not an ideal situation, but is better than the
4652             # alternatives.
4653             if marker_obj.get_fillstyle() == 'none':
4654                 # promote the facecolor to be the edgecolor
4655                 edgecolors = colors
4656                 # set the facecolor to 'none' (at the last chance) because
4657                 # we can not fill a path if the facecolor is non-null
4658                 # (which is defendable at the renderer level).
4659                 colors = 'none'
4660             else:
4661                 # if we are not nulling the face color we can do this
4662                 # simpler
4663                 edgecolors = 'face'
4664 
4665             if linewidths is None:
4666                 linewidths = mpl.rcParams['lines.linewidth']
4667             elif np.iterable(linewidths):
4668                 linewidths = [
4669                     lw if lw is not None else mpl.rcParams['lines.linewidth']
4670                     for lw in linewidths]
4671 
4672         offsets = np.ma.column_stack([x, y])
4673 
4674         collection = mcoll.PathCollection(
4675             (path,), scales,
4676             facecolors=colors,
4677             edgecolors=edgecolors,
4678             linewidths=linewidths,
4679             offsets=offsets,
4680             offset_transform=kwargs.pop('transform', self.transData),
4681             alpha=alpha,
4682         )
4683         collection.set_transform(mtransforms.IdentityTransform())
4684         if colors is None:
4685             collection.set_array(c)
4686             collection.set_cmap(cmap)
4687             collection.set_norm(norm)
4688             collection._scale_norm(norm, vmin, vmax)
4689         else:
4690             extra_kwargs = {
4691                     'cmap': cmap, 'norm': norm, 'vmin': vmin, 'vmax': vmax
4692                     }
4693             extra_keys = [k for k, v in extra_kwargs.items() if v is not None]
4694             if any(extra_keys):
4695                 keys_str = ", ".join(f"'{k}'" for k in extra_keys)
4696                 _api.warn_external(
4697                     "No data for colormapping provided via 'c'. "
4698                     f"Parameters {keys_str} will be ignored")
4699         collection._internal_update(kwargs)
4700 
4701         # Classic mode only:
4702         # ensure there are margins to allow for the
4703         # finite size of the symbols.  In v2.x, margins
4704         # are present by default, so we disable this
4705         # scatter-specific override.
4706         if mpl.rcParams['_internal.classic_mode']:
4707             if self._xmargin < 0.05 and x.size > 0:
4708                 self.set_xmargin(0.05)
4709             if self._ymargin < 0.05 and x.size > 0:
4710                 self.set_ymargin(0.05)
4711 
4712         self.add_collection(collection)
4713         self._request_autoscale_view()
4714 
4715         return collection
4716 
4717     @_preprocess_data(replace_names=["x", "y", "C"], label_namer="y")
4718     @_docstring.dedent_interpd
4719     def hexbin(self, x, y, C=None, gridsize=100, bins=None,
4720                xscale='linear', yscale='linear', extent=None,
4721                cmap=None, norm=None, vmin=None, vmax=None,
4722                alpha=None, linewidths=None, edgecolors='face',
4723                reduce_C_function=np.mean, mincnt=None, marginals=False,
4724                **kwargs):
4725         """
4726         Make a 2D hexagonal binning plot of points *x*, *y*.
4727 
4728         If *C* is *None*, the value of the hexagon is determined by the number
4729         of points in the hexagon. Otherwise, *C* specifies values at the
4730         coordinate (x[i], y[i]). For each hexagon, these values are reduced
4731         using *reduce_C_function*.
4732 
4733         Parameters
4734         ----------
4735         x, y : array-like
4736             The data positions. *x* and *y* must be of the same length.
4737 
4738         C : array-like, optional
4739             If given, these values are accumulated in the bins. Otherwise,
4740             every point has a value of 1. Must be of the same length as *x*
4741             and *y*.
4742 
4743         gridsize : int or (int, int), default: 100
4744             If a single int, the number of hexagons in the *x*-direction.
4745             The number of hexagons in the *y*-direction is chosen such that
4746             the hexagons are approximately regular.
4747 
4748             Alternatively, if a tuple (*nx*, *ny*), the number of hexagons
4749             in the *x*-direction and the *y*-direction. In the
4750             *y*-direction, counting is done along vertically aligned
4751             hexagons, not along the zig-zag chains of hexagons; see the
4752             following illustration.
4753 
4754             .. plot::
4755 
4756                import numpy
4757                import matplotlib.pyplot as plt
4758 
4759                np.random.seed(19680801)
4760                n= 300
4761                x = np.random.standard_normal(n)
4762                y = np.random.standard_normal(n)
4763 
4764                fig, ax = plt.subplots(figsize=(4, 4))
4765                h = ax.hexbin(x, y, gridsize=(5, 3))
4766                hx, hy = h.get_offsets().T
4767                ax.plot(hx[24::3], hy[24::3], 'ro-')
4768                ax.plot(hx[-3:], hy[-3:], 'ro-')
4769                ax.set_title('gridsize=(5, 3)')
4770                ax.axis('off')
4771 
4772             To get approximately regular hexagons, choose
4773             :math:`n_x = \\sqrt{3}\\,n_y`.
4774 
4775         bins : 'log' or int or sequence, default: None
4776             Discretization of the hexagon values.
4777 
4778             - If *None*, no binning is applied; the color of each hexagon
4779               directly corresponds to its count value.
4780             - If 'log', use a logarithmic scale for the colormap.
4781               Internally, :math:`log_{10}(i+1)` is used to determine the
4782               hexagon color. This is equivalent to ``norm=LogNorm()``.
4783             - If an integer, divide the counts in the specified number
4784               of bins, and color the hexagons accordingly.
4785             - If a sequence of values, the values of the lower bound of
4786               the bins to be used.
4787 
4788         xscale : {'linear', 'log'}, default: 'linear'
4789             Use a linear or log10 scale on the horizontal axis.
4790 
4791         yscale : {'linear', 'log'}, default: 'linear'
4792             Use a linear or log10 scale on the vertical axis.
4793 
4794         mincnt : int > 0, default: *None*
4795             If not *None*, only display cells with more than *mincnt*
4796             number of points in the cell.
4797 
4798         marginals : bool, default: *False*
4799             If marginals is *True*, plot the marginal density as
4800             colormapped rectangles along the bottom of the x-axis and
4801             left of the y-axis.
4802 
4803         extent : 4-tuple of float, default: *None*
4804             The limits of the bins (xmin, xmax, ymin, ymax).
4805             The default assigns the limits based on
4806             *gridsize*, *x*, *y*, *xscale* and *yscale*.
4807 
4808             If *xscale* or *yscale* is set to 'log', the limits are
4809             expected to be the exponent for a power of 10. E.g. for
4810             x-limits of 1 and 50 in 'linear' scale and y-limits
4811             of 10 and 1000 in 'log' scale, enter (1, 50, 1, 3).
4812 
4813         Returns
4814         -------
4815         `~matplotlib.collections.PolyCollection`
4816             A `.PolyCollection` defining the hexagonal bins.
4817 
4818             - `.PolyCollection.get_offsets` contains a Mx2 array containing
4819               the x, y positions of the M hexagon centers.
4820             - `.PolyCollection.get_array` contains the values of the M
4821               hexagons.
4822 
4823             If *marginals* is *True*, horizontal
4824             bar and vertical bar (both PolyCollections) will be attached
4825             to the return collection as attributes *hbar* and *vbar*.
4826 
4827         Other Parameters
4828         ----------------
4829         %(cmap_doc)s
4830 
4831         %(norm_doc)s
4832 
4833         %(vmin_vmax_doc)s
4834 
4835         alpha : float between 0 and 1, optional
4836             The alpha blending value, between 0 (transparent) and 1 (opaque).
4837 
4838         linewidths : float, default: *None*
4839             If *None*, defaults to 1.0.
4840 
4841         edgecolors : {'face', 'none', *None*} or color, default: 'face'
4842             The color of the hexagon edges. Possible values are:
4843 
4844             - 'face': Draw the edges in the same color as the fill color.
4845             - 'none': No edges are drawn. This can sometimes lead to unsightly
4846               unpainted pixels between the hexagons.
4847             - *None*: Draw outlines in the default color.
4848             - An explicit color.
4849 
4850         reduce_C_function : callable, default: `numpy.mean`
4851             The function to aggregate *C* within the bins. It is ignored if
4852             *C* is not given. This must have the signature::
4853 
4854                 def reduce_C_function(C: array) -> float
4855 
4856             Commonly used functions are:
4857 
4858             - `numpy.mean`: average of the points
4859             - `numpy.sum`: integral of the point values
4860             - `numpy.amax`: value taken from the largest point
4861 
4862         data : indexable object, optional
4863             DATA_PARAMETER_PLACEHOLDER
4864 
4865         **kwargs : `~matplotlib.collections.PolyCollection` properties
4866             All other keyword arguments are passed on to `.PolyCollection`:
4867 
4868             %(PolyCollection:kwdoc)s
4869 
4870         See Also
4871         --------
4872         hist2d : 2D histogram rectangular bins
4873         """
4874         self._process_unit_info([("x", x), ("y", y)], kwargs, convert=False)
4875 
4876         x, y, C = cbook.delete_masked_points(x, y, C)
4877 
4878         # Set the size of the hexagon grid
4879         if np.iterable(gridsize):
4880             nx, ny = gridsize
4881         else:
4882             nx = gridsize
4883             ny = int(nx / math.sqrt(3))
4884         # Count the number of data in each hexagon
4885         x = np.asarray(x, float)
4886         y = np.asarray(y, float)
4887 
4888         # Will be log()'d if necessary, and then rescaled.
4889         tx = x
4890         ty = y
4891 
4892         if xscale == 'log':
4893             if np.any(x <= 0.0):
4894                 raise ValueError("x contains non-positive values, so can not "
4895                                  "be log-scaled")
4896             tx = np.log10(tx)
4897         if yscale == 'log':
4898             if np.any(y <= 0.0):
4899                 raise ValueError("y contains non-positive values, so can not "
4900                                  "be log-scaled")
4901             ty = np.log10(ty)
4902         if extent is not None:
4903             xmin, xmax, ymin, ymax = extent
4904         else:
4905             xmin, xmax = (tx.min(), tx.max()) if len(x) else (0, 1)
4906             ymin, ymax = (ty.min(), ty.max()) if len(y) else (0, 1)
4907 
4908             # to avoid issues with singular data, expand the min/max pairs
4909             xmin, xmax = mtransforms.nonsingular(xmin, xmax, expander=0.1)
4910             ymin, ymax = mtransforms.nonsingular(ymin, ymax, expander=0.1)
4911 
4912         nx1 = nx + 1
4913         ny1 = ny + 1
4914         nx2 = nx
4915         ny2 = ny
4916         n = nx1 * ny1 + nx2 * ny2
4917 
4918         # In the x-direction, the hexagons exactly cover the region from
4919         # xmin to xmax. Need some padding to avoid roundoff errors.
4920         padding = 1.e-9 * (xmax - xmin)
4921         xmin -= padding
4922         xmax += padding
4923         sx = (xmax - xmin) / nx
4924         sy = (ymax - ymin) / ny
4925         # Positions in hexagon index coordinates.
4926         ix = (tx - xmin) / sx
4927         iy = (ty - ymin) / sy
4928         ix1 = np.round(ix).astype(int)
4929         iy1 = np.round(iy).astype(int)
4930         ix2 = np.floor(ix).astype(int)
4931         iy2 = np.floor(iy).astype(int)
4932         # flat indices, plus one so that out-of-range points go to position 0.
4933         i1 = np.where((0 <= ix1) & (ix1 < nx1) & (0 <= iy1) & (iy1 < ny1),
4934                       ix1 * ny1 + iy1 + 1, 0)
4935         i2 = np.where((0 <= ix2) & (ix2 < nx2) & (0 <= iy2) & (iy2 < ny2),
4936                       ix2 * ny2 + iy2 + 1, 0)
4937 
4938         d1 = (ix - ix1) ** 2 + 3.0 * (iy - iy1) ** 2
4939         d2 = (ix - ix2 - 0.5) ** 2 + 3.0 * (iy - iy2 - 0.5) ** 2
4940         bdist = (d1 < d2)
4941 
4942         if C is None:  # [1:] drops out-of-range points.
4943             counts1 = np.bincount(i1[bdist], minlength=1 + nx1 * ny1)[1:]
4944             counts2 = np.bincount(i2[~bdist], minlength=1 + nx2 * ny2)[1:]
4945             accum = np.concatenate([counts1, counts2]).astype(float)
4946             if mincnt is not None:
4947                 accum[accum < mincnt] = np.nan
4948             C = np.ones(len(x))
4949         else:
4950             # store the C values in a list per hexagon index
4951             Cs_at_i1 = [[] for _ in range(1 + nx1 * ny1)]
4952             Cs_at_i2 = [[] for _ in range(1 + nx2 * ny2)]
4953             for i in range(len(x)):
4954                 if bdist[i]:
4955                     Cs_at_i1[i1[i]].append(C[i])
4956                 else:
4957                     Cs_at_i2[i2[i]].append(C[i])
4958             if mincnt is None:
4959                 mincnt = 0
4960             accum = np.array(
4961                 [reduce_C_function(acc) if len(acc) > mincnt else np.nan
4962                  for Cs_at_i in [Cs_at_i1, Cs_at_i2]
4963                  for acc in Cs_at_i[1:]],  # [1:] drops out-of-range points.
4964                 float)
4965 
4966         good_idxs = ~np.isnan(accum)
4967 
4968         offsets = np.zeros((n, 2), float)
4969         offsets[:nx1 * ny1, 0] = np.repeat(np.arange(nx1), ny1)
4970         offsets[:nx1 * ny1, 1] = np.tile(np.arange(ny1), nx1)
4971         offsets[nx1 * ny1:, 0] = np.repeat(np.arange(nx2) + 0.5, ny2)
4972         offsets[nx1 * ny1:, 1] = np.tile(np.arange(ny2), nx2) + 0.5
4973         offsets[:, 0] *= sx
4974         offsets[:, 1] *= sy
4975         offsets[:, 0] += xmin
4976         offsets[:, 1] += ymin
4977         # remove accumulation bins with no data
4978         offsets = offsets[good_idxs, :]
4979         accum = accum[good_idxs]
4980 
4981         polygon = [sx, sy / 3] * np.array(
4982             [[.5, -.5], [.5, .5], [0., 1.], [-.5, .5], [-.5, -.5], [0., -1.]])
4983 
4984         if linewidths is None:
4985             linewidths = [1.0]
4986 
4987         if xscale == 'log' or yscale == 'log':
4988             polygons = np.expand_dims(polygon, 0) + np.expand_dims(offsets, 1)
4989             if xscale == 'log':
4990                 polygons[:, :, 0] = 10.0 ** polygons[:, :, 0]
4991                 xmin = 10.0 ** xmin
4992                 xmax = 10.0 ** xmax
4993                 self.set_xscale(xscale)
4994             if yscale == 'log':
4995                 polygons[:, :, 1] = 10.0 ** polygons[:, :, 1]
4996                 ymin = 10.0 ** ymin
4997                 ymax = 10.0 ** ymax
4998                 self.set_yscale(yscale)
4999             collection = mcoll.PolyCollection(
5000                 polygons,
5001                 edgecolors=edgecolors,
5002                 linewidths=linewidths,
5003                 )
5004         else:
5005             collection = mcoll.PolyCollection(
5006                 [polygon],
5007                 edgecolors=edgecolors,
5008                 linewidths=linewidths,
5009                 offsets=offsets,
5010                 offset_transform=mtransforms.AffineDeltaTransform(
5011                     self.transData),
5012             )
5013 
5014         # Set normalizer if bins is 'log'
5015         if bins == 'log':
5016             if norm is not None:
5017                 _api.warn_external("Only one of 'bins' and 'norm' arguments "
5018                                    f"can be supplied, ignoring bins={bins}")
5019             else:
5020                 norm = mcolors.LogNorm(vmin=vmin, vmax=vmax)
5021                 vmin = vmax = None
5022             bins = None
5023 
5024         # autoscale the norm with current accum values if it hasn't been set
5025         if norm is not None:
5026             if norm.vmin is None and norm.vmax is None:
5027                 norm.autoscale(accum)
5028 
5029         if bins is not None:
5030             if not np.iterable(bins):
5031                 minimum, maximum = min(accum), max(accum)
5032                 bins -= 1  # one less edge than bins
5033                 bins = minimum + (maximum - minimum) * np.arange(bins) / bins
5034             bins = np.sort(bins)
5035             accum = bins.searchsorted(accum)
5036 
5037         collection.set_array(accum)
5038         collection.set_cmap(cmap)
5039         collection.set_norm(norm)
5040         collection.set_alpha(alpha)
5041         collection._internal_update(kwargs)
5042         collection._scale_norm(norm, vmin, vmax)
5043 
5044         corners = ((xmin, ymin), (xmax, ymax))
5045         self.update_datalim(corners)
5046         self._request_autoscale_view(tight=True)
5047 
5048         # add the collection last
5049         self.add_collection(collection, autolim=False)
5050         if not marginals:
5051             return collection
5052 
5053         # Process marginals
5054         bars = []
5055         for zname, z, zmin, zmax, zscale, nbins in [
5056                 ("x", x, xmin, xmax, xscale, nx),
5057                 ("y", y, ymin, ymax, yscale, 2 * ny),
5058         ]:
5059 
5060             if zscale == "log":
5061                 bin_edges = np.geomspace(zmin, zmax, nbins + 1)
5062             else:
5063                 bin_edges = np.linspace(zmin, zmax, nbins + 1)
5064 
5065             verts = np.empty((nbins, 4, 2))
5066             verts[:, 0, 0] = verts[:, 1, 0] = bin_edges[:-1]
5067             verts[:, 2, 0] = verts[:, 3, 0] = bin_edges[1:]
5068             verts[:, 0, 1] = verts[:, 3, 1] = .00
5069             verts[:, 1, 1] = verts[:, 2, 1] = .05
5070             if zname == "y":
5071                 verts = verts[:, :, ::-1]  # Swap x and y.
5072 
5073             # Sort z-values into bins defined by bin_edges.
5074             bin_idxs = np.searchsorted(bin_edges, z) - 1
5075             values = np.empty(nbins)
5076             for i in range(nbins):
5077                 # Get C-values for each bin, and compute bin value with
5078                 # reduce_C_function.
5079                 ci = C[bin_idxs == i]
5080                 values[i] = reduce_C_function(ci) if len(ci) > 0 else np.nan
5081 
5082             mask = ~np.isnan(values)
5083             verts = verts[mask]
5084             values = values[mask]
5085 
5086             trans = getattr(self, f"get_{zname}axis_transform")(which="grid")
5087             bar = mcoll.PolyCollection(
5088                 verts, transform=trans, edgecolors="face")
5089             bar.set_array(values)
5090             bar.set_cmap(cmap)
5091             bar.set_norm(norm)
5092             bar.set_alpha(alpha)
5093             bar._internal_update(kwargs)
5094             bars.append(self.add_collection(bar, autolim=False))
5095 
5096         collection.hbar, collection.vbar = bars
5097 
5098         def on_changed(collection):
5099             collection.hbar.set_cmap(collection.get_cmap())
5100             collection.hbar.set_cmap(collection.get_cmap())
5101             collection.vbar.set_clim(collection.get_clim())
5102             collection.vbar.set_clim(collection.get_clim())
5103 
5104         collection.callbacks.connect('changed', on_changed)
5105 
5106         return collection
5107 
5108     @_docstring.dedent_interpd
5109     def arrow(self, x, y, dx, dy, **kwargs):
5110         """
5111         Add an arrow to the Axes.
5112 
5113         This draws an arrow from ``(x, y)`` to ``(x+dx, y+dy)``.
5114 
5115         Parameters
5116         ----------
5117         %(FancyArrow)s
5118 
5119         Returns
5120         -------
5121         `.FancyArrow`
5122             The created `.FancyArrow` object.
5123 
5124         Notes
5125         -----
5126         The resulting arrow is affected by the Axes aspect ratio and limits.
5127         This may produce an arrow whose head is not square with its stem. To
5128         create an arrow whose head is square with its stem,
5129         use :meth:`annotate` for example:
5130 
5131         >>> ax.annotate("", xy=(0.5, 0.5), xytext=(0, 0),
5132         ...             arrowprops=dict(arrowstyle="->"))
5133 
5134         """
5135         # Strip away units for the underlying patch since units
5136         # do not make sense to most patch-like code
5137         x = self.convert_xunits(x)
5138         y = self.convert_yunits(y)
5139         dx = self.convert_xunits(dx)
5140         dy = self.convert_yunits(dy)
5141 
5142         a = mpatches.FancyArrow(x, y, dx, dy, **kwargs)
5143         self.add_patch(a)
5144         self._request_autoscale_view()
5145         return a
5146 
5147     @_docstring.copy(mquiver.QuiverKey.__init__)
5148     def quiverkey(self, Q, X, Y, U, label, **kwargs):
5149         qk = mquiver.QuiverKey(Q, X, Y, U, label, **kwargs)
5150         self.add_artist(qk)
5151         return qk
5152 
5153     # Handle units for x and y, if they've been passed
5154     def _quiver_units(self, args, kwargs):
5155         if len(args) > 3:
5156             x, y = args[0:2]
5157             x, y = self._process_unit_info([("x", x), ("y", y)], kwargs)
5158             return (x, y) + args[2:]
5159         return args
5160 
5161     # args can be a combination of X, Y, U, V, C and all should be replaced
5162     @_preprocess_data()
5163     @_docstring.dedent_interpd
5164     def quiver(self, *args, **kwargs):
5165         """%(quiver_doc)s"""
5166         # Make sure units are handled for x and y values
5167         args = self._quiver_units(args, kwargs)
5168         q = mquiver.Quiver(self, *args, **kwargs)
5169         self.add_collection(q, autolim=True)
5170         self._request_autoscale_view()
5171         return q
5172 
5173     # args can be some combination of X, Y, U, V, C and all should be replaced
5174     @_preprocess_data()
5175     @_docstring.dedent_interpd
5176     def barbs(self, *args, **kwargs):
5177         """%(barbs_doc)s"""
5178         # Make sure units are handled for x and y values
5179         args = self._quiver_units(args, kwargs)
5180         b = mquiver.Barbs(self, *args, **kwargs)
5181         self.add_collection(b, autolim=True)
5182         self._request_autoscale_view()
5183         return b
5184 
5185     # Uses a custom implementation of data-kwarg handling in
5186     # _process_plot_var_args.
5187     def fill(self, *args, data=None, **kwargs):
5188         """
5189         Plot filled polygons.
5190 
5191         Parameters
5192         ----------
5193         *args : sequence of x, y, [color]
5194             Each polygon is defined by the lists of *x* and *y* positions of
5195             its nodes, optionally followed by a *color* specifier. See
5196             :mod:`matplotlib.colors` for supported color specifiers. The
5197             standard color cycle is used for polygons without a color
5198             specifier.
5199 
5200             You can plot multiple polygons by providing multiple *x*, *y*,
5201             *[color]* groups.
5202 
5203             For example, each of the following is legal::
5204 
5205                 ax.fill(x, y)                    # a polygon with default color
5206                 ax.fill(x, y, "b")               # a blue polygon
5207                 ax.fill(x, y, x2, y2)            # two polygons
5208                 ax.fill(x, y, "b", x2, y2, "r")  # a blue and a red polygon
5209 
5210         data : indexable object, optional
5211             An object with labelled data. If given, provide the label names to
5212             plot in *x* and *y*, e.g.::
5213 
5214                 ax.fill("time", "signal",
5215                         data={"time": [0, 1, 2], "signal": [0, 1, 0]})
5216 
5217         Returns
5218         -------
5219         list of `~matplotlib.patches.Polygon`
5220 
5221         Other Parameters
5222         ----------------
5223         **kwargs : `~matplotlib.patches.Polygon` properties
5224 
5225         Notes
5226         -----
5227         Use :meth:`fill_between` if you would like to fill the region between
5228         two curves.
5229         """
5230         # For compatibility(!), get aliases from Line2D rather than Patch.
5231         kwargs = cbook.normalize_kwargs(kwargs, mlines.Line2D)
5232         # _get_patches_for_fill returns a generator, convert it to a list.
5233         patches = [*self._get_patches_for_fill(*args, data=data, **kwargs)]
5234         for poly in patches:
5235             self.add_patch(poly)
5236         self._request_autoscale_view()
5237         return patches
5238 
5239     def _fill_between_x_or_y(
5240             self, ind_dir, ind, dep1, dep2=0, *,
5241             where=None, interpolate=False, step=None, **kwargs):
5242         # Common implementation between fill_between (*ind_dir*="x") and
5243         # fill_betweenx (*ind_dir*="y").  *ind* is the independent variable,
5244         # *dep* the dependent variable.  The docstring below is interpolated
5245         # to generate both methods' docstrings.
5246         """
5247         Fill the area between two {dir} curves.
5248 
5249         The curves are defined by the points (*{ind}*, *{dep}1*) and (*{ind}*,
5250         *{dep}2*).  This creates one or multiple polygons describing the filled
5251         area.
5252 
5253         You may exclude some {dir} sections from filling using *where*.
5254 
5255         By default, the edges connect the given points directly.  Use *step*
5256         if the filling should be a step function, i.e. constant in between
5257         *{ind}*.
5258 
5259         Parameters
5260         ----------
5261         {ind} : array (length N)
5262             The {ind} coordinates of the nodes defining the curves.
5263 
5264         {dep}1 : array (length N) or scalar
5265             The {dep} coordinates of the nodes defining the first curve.
5266 
5267         {dep}2 : array (length N) or scalar, default: 0
5268             The {dep} coordinates of the nodes defining the second curve.
5269 
5270         where : array of bool (length N), optional
5271             Define *where* to exclude some {dir} regions from being filled.
5272             The filled regions are defined by the coordinates ``{ind}[where]``.
5273             More precisely, fill between ``{ind}[i]`` and ``{ind}[i+1]`` if
5274             ``where[i] and where[i+1]``.  Note that this definition implies
5275             that an isolated *True* value between two *False* values in *where*
5276             will not result in filling.  Both sides of the *True* position
5277             remain unfilled due to the adjacent *False* values.
5278 
5279         interpolate : bool, default: False
5280             This option is only relevant if *where* is used and the two curves
5281             are crossing each other.
5282 
5283             Semantically, *where* is often used for *{dep}1* > *{dep}2* or
5284             similar.  By default, the nodes of the polygon defining the filled
5285             region will only be placed at the positions in the *{ind}* array.
5286             Such a polygon cannot describe the above semantics close to the
5287             intersection.  The {ind}-sections containing the intersection are
5288             simply clipped.
5289 
5290             Setting *interpolate* to *True* will calculate the actual
5291             intersection point and extend the filled region up to this point.
5292 
5293         step : {{'pre', 'post', 'mid'}}, optional
5294             Define *step* if the filling should be a step function,
5295             i.e. constant in between *{ind}*.  The value determines where the
5296             step will occur:
5297 
5298             - 'pre': The y value is continued constantly to the left from
5299               every *x* position, i.e. the interval ``(x[i-1], x[i]]`` has the
5300               value ``y[i]``.
5301             - 'post': The y value is continued constantly to the right from
5302               every *x* position, i.e. the interval ``[x[i], x[i+1])`` has the
5303               value ``y[i]``.
5304             - 'mid': Steps occur half-way between the *x* positions.
5305 
5306         Returns
5307         -------
5308         `.PolyCollection`
5309             A `.PolyCollection` containing the plotted polygons.
5310 
5311         Other Parameters
5312         ----------------
5313         data : indexable object, optional
5314             DATA_PARAMETER_PLACEHOLDER
5315 
5316         **kwargs
5317             All other keyword arguments are passed on to `.PolyCollection`.
5318             They control the `.Polygon` properties:
5319 
5320             %(PolyCollection:kwdoc)s
5321 
5322         See Also
5323         --------
5324         fill_between : Fill between two sets of y-values.
5325         fill_betweenx : Fill between two sets of x-values.
5326         """
5327 
5328         dep_dir = {"x": "y", "y": "x"}[ind_dir]
5329 
5330         if not mpl.rcParams["_internal.classic_mode"]:
5331             kwargs = cbook.normalize_kwargs(kwargs, mcoll.Collection)
5332             if not any(c in kwargs for c in ("color", "facecolor")):
5333                 kwargs["facecolor"] = \
5334                     self._get_patches_for_fill.get_next_color()
5335 
5336         # Handle united data, such as dates
5337         ind, dep1, dep2 = map(
5338             ma.masked_invalid, self._process_unit_info(
5339                 [(ind_dir, ind), (dep_dir, dep1), (dep_dir, dep2)], kwargs))
5340 
5341         for name, array in [
5342                 (ind_dir, ind), (f"{dep_dir}1", dep1), (f"{dep_dir}2", dep2)]:
5343             if array.ndim > 1:
5344                 raise ValueError(f"{name!r} is not 1-dimensional")
5345 
5346         if where is None:
5347             where = True
5348         else:
5349             where = np.asarray(where, dtype=bool)
5350             if where.size != ind.size:
5351                 raise ValueError(f"where size ({where.size}) does not match "
5352                                  f"{ind_dir} size ({ind.size})")
5353         where = where & ~functools.reduce(
5354             np.logical_or, map(np.ma.getmaskarray, [ind, dep1, dep2]))
5355 
5356         ind, dep1, dep2 = np.broadcast_arrays(
5357             np.atleast_1d(ind), dep1, dep2, subok=True)
5358 
5359         polys = []
5360         for idx0, idx1 in cbook.contiguous_regions(where):
5361             indslice = ind[idx0:idx1]
5362             dep1slice = dep1[idx0:idx1]
5363             dep2slice = dep2[idx0:idx1]
5364             if step is not None:
5365                 step_func = cbook.STEP_LOOKUP_MAP["steps-" + step]
5366                 indslice, dep1slice, dep2slice = \
5367                     step_func(indslice, dep1slice, dep2slice)
5368 
5369             if not len(indslice):
5370                 continue
5371 
5372             N = len(indslice)
5373             pts = np.zeros((2 * N + 2, 2))
5374 
5375             if interpolate:
5376                 def get_interp_point(idx):
5377                     im1 = max(idx - 1, 0)
5378                     ind_values = ind[im1:idx+1]
5379                     diff_values = dep1[im1:idx+1] - dep2[im1:idx+1]
5380                     dep1_values = dep1[im1:idx+1]
5381 
5382                     if len(diff_values) == 2:
5383                         if np.ma.is_masked(diff_values[1]):
5384                             return ind[im1], dep1[im1]
5385                         elif np.ma.is_masked(diff_values[0]):
5386                             return ind[idx], dep1[idx]
5387 
5388                     diff_order = diff_values.argsort()
5389                     diff_root_ind = np.interp(
5390                         0, diff_values[diff_order], ind_values[diff_order])
5391                     ind_order = ind_values.argsort()
5392                     diff_root_dep = np.interp(
5393                         diff_root_ind,
5394                         ind_values[ind_order], dep1_values[ind_order])
5395                     return diff_root_ind, diff_root_dep
5396 
5397                 start = get_interp_point(idx0)
5398                 end = get_interp_point(idx1)
5399             else:
5400                 # Handle scalar dep2 (e.g. 0): the fill should go all
5401                 # the way down to 0 even if none of the dep1 sample points do.
5402                 start = indslice[0], dep2slice[0]
5403                 end = indslice[-1], dep2slice[-1]
5404 
5405             pts[0] = start
5406             pts[N + 1] = end
5407 
5408             pts[1:N+1, 0] = indslice
5409             pts[1:N+1, 1] = dep1slice
5410             pts[N+2:, 0] = indslice[::-1]
5411             pts[N+2:, 1] = dep2slice[::-1]
5412 
5413             if ind_dir == "y":
5414                 pts = pts[:, ::-1]
5415 
5416             polys.append(pts)
5417 
5418         collection = mcoll.PolyCollection(polys, **kwargs)
5419 
5420         # now update the datalim and autoscale
5421         pts = np.row_stack([np.column_stack([ind[where], dep1[where]]),
5422                             np.column_stack([ind[where], dep2[where]])])
5423         if ind_dir == "y":
5424             pts = pts[:, ::-1]
5425         self.update_datalim(pts, updatex=True, updatey=True)
5426         self.add_collection(collection, autolim=False)
5427         self._request_autoscale_view()
5428         return collection
5429 
5430     def fill_between(self, x, y1, y2=0, where=None, interpolate=False,
5431                      step=None, **kwargs):
5432         return self._fill_between_x_or_y(
5433             "x", x, y1, y2,
5434             where=where, interpolate=interpolate, step=step, **kwargs)
5435 
5436     if _fill_between_x_or_y.__doc__:
5437         fill_between.__doc__ = _fill_between_x_or_y.__doc__.format(
5438             dir="horizontal", ind="x", dep="y"
5439         )
5440     fill_between = _preprocess_data(
5441         _docstring.dedent_interpd(fill_between),
5442         replace_names=["x", "y1", "y2", "where"])
5443 
5444     def fill_betweenx(self, y, x1, x2=0, where=None,
5445                       step=None, interpolate=False, **kwargs):
5446         return self._fill_between_x_or_y(
5447             "y", y, x1, x2,
5448             where=where, interpolate=interpolate, step=step, **kwargs)
5449 
5450     if _fill_between_x_or_y.__doc__:
5451         fill_betweenx.__doc__ = _fill_between_x_or_y.__doc__.format(
5452             dir="vertical", ind="y", dep="x"
5453         )
5454     fill_betweenx = _preprocess_data(
5455         _docstring.dedent_interpd(fill_betweenx),
5456         replace_names=["y", "x1", "x2", "where"])
5457 
5458     #### plotting z(x, y): imshow, pcolor and relatives, contour
5459 
5460     @_preprocess_data()
5461     @_docstring.interpd
5462     def imshow(self, X, cmap=None, norm=None, *, aspect=None,
5463                interpolation=None, alpha=None,
5464                vmin=None, vmax=None, origin=None, extent=None,
5465                interpolation_stage=None, filternorm=True, filterrad=4.0,
5466                resample=None, url=None, **kwargs):
5467         """
5468         Display data as an image, i.e., on a 2D regular raster.
5469 
5470         The input may either be actual RGB(A) data, or 2D scalar data, which
5471         will be rendered as a pseudocolor image. For displaying a grayscale
5472         image set up the colormapping using the parameters
5473         ``cmap='gray', vmin=0, vmax=255``.
5474 
5475         The number of pixels used to render an image is set by the Axes size
5476         and the *dpi* of the figure. This can lead to aliasing artifacts when
5477         the image is resampled because the displayed image size will usually
5478         not match the size of *X* (see
5479         :doc:`/gallery/images_contours_and_fields/image_antialiasing`).
5480         The resampling can be controlled via the *interpolation* parameter
5481         and/or :rc:`image.interpolation`.
5482 
5483         Parameters
5484         ----------
5485         X : array-like or PIL image
5486             The image data. Supported array shapes are:
5487 
5488             - (M, N): an image with scalar data. The values are mapped to
5489               colors using normalization and a colormap. See parameters *norm*,
5490               *cmap*, *vmin*, *vmax*.
5491             - (M, N, 3): an image with RGB values (0-1 float or 0-255 int).
5492             - (M, N, 4): an image with RGBA values (0-1 float or 0-255 int),
5493               i.e. including transparency.
5494 
5495             The first two dimensions (M, N) define the rows and columns of
5496             the image.
5497 
5498             Out-of-range RGB(A) values are clipped.
5499 
5500         %(cmap_doc)s
5501 
5502             This parameter is ignored if *X* is RGB(A).
5503 
5504         %(norm_doc)s
5505 
5506             This parameter is ignored if *X* is RGB(A).
5507 
5508         %(vmin_vmax_doc)s
5509 
5510             This parameter is ignored if *X* is RGB(A).
5511 
5512         aspect : {'equal', 'auto'} or float, default: :rc:`image.aspect`
5513             The aspect ratio of the Axes.  This parameter is particularly
5514             relevant for images since it determines whether data pixels are
5515             square.
5516 
5517             This parameter is a shortcut for explicitly calling
5518             `.Axes.set_aspect`. See there for further details.
5519 
5520             - 'equal': Ensures an aspect ratio of 1. Pixels will be square
5521               (unless pixel sizes are explicitly made non-square in data
5522               coordinates using *extent*).
5523             - 'auto': The Axes is kept fixed and the aspect is adjusted so
5524               that the data fit in the Axes. In general, this will result in
5525               non-square pixels.
5526 
5527         interpolation : str, default: :rc:`image.interpolation`
5528             The interpolation method used.
5529 
5530             Supported values are 'none', 'antialiased', 'nearest', 'bilinear',
5531             'bicubic', 'spline16', 'spline36', 'hanning', 'hamming', 'hermite',
5532             'kaiser', 'quadric', 'catrom', 'gaussian', 'bessel', 'mitchell',
5533             'sinc', 'lanczos', 'blackman'.
5534 
5535             If *interpolation* is 'none', then no interpolation is performed
5536             on the Agg, ps, pdf and svg backends. Other backends will fall back
5537             to 'nearest'. Note that most SVG renderers perform interpolation at
5538             rendering and that the default interpolation method they implement
5539             may differ.
5540 
5541             If *interpolation* is the default 'antialiased', then 'nearest'
5542             interpolation is used if the image is upsampled by more than a
5543             factor of three (i.e. the number of display pixels is at least
5544             three times the size of the data array).  If the upsampling rate is
5545             smaller than 3, or the image is downsampled, then 'hanning'
5546             interpolation is used to act as an anti-aliasing filter, unless the
5547             image happens to be upsampled by exactly a factor of two or one.
5548 
5549             See
5550             :doc:`/gallery/images_contours_and_fields/interpolation_methods`
5551             for an overview of the supported interpolation methods, and
5552             :doc:`/gallery/images_contours_and_fields/image_antialiasing` for
5553             a discussion of image antialiasing.
5554 
5555             Some interpolation methods require an additional radius parameter,
5556             which can be set by *filterrad*. Additionally, the antigrain image
5557             resize filter is controlled by the parameter *filternorm*.
5558 
5559         interpolation_stage : {'data', 'rgba'}, default: 'data'
5560             If 'data', interpolation
5561             is carried out on the data provided by the user.  If 'rgba', the
5562             interpolation is carried out after the colormapping has been
5563             applied (visual interpolation).
5564 
5565         alpha : float or array-like, optional
5566             The alpha blending value, between 0 (transparent) and 1 (opaque).
5567             If *alpha* is an array, the alpha blending values are applied pixel
5568             by pixel, and *alpha* must have the same shape as *X*.
5569 
5570         origin : {'upper', 'lower'}, default: :rc:`image.origin`
5571             Place the [0, 0] index of the array in the upper left or lower
5572             left corner of the Axes. The convention (the default) 'upper' is
5573             typically used for matrices and images.
5574 
5575             Note that the vertical axis points upward for 'lower'
5576             but downward for 'upper'.
5577 
5578             See the :doc:`/tutorials/intermediate/imshow_extent` tutorial for
5579             examples and a more detailed description.
5580 
5581         extent : floats (left, right, bottom, top), optional
5582             The bounding box in data coordinates that the image will fill.
5583             These values may be unitful and match the units of the Axes.
5584             The image is stretched individually along x and y to fill the box.
5585 
5586             The default extent is determined by the following conditions.
5587             Pixels have unit size in data coordinates. Their centers are on
5588             integer coordinates, and their center coordinates range from 0 to
5589             columns-1 horizontally and from 0 to rows-1 vertically.
5590 
5591             Note that the direction of the vertical axis and thus the default
5592             values for top and bottom depend on *origin*:
5593 
5594             - For ``origin == 'upper'`` the default is
5595               ``(-0.5, numcols-0.5, numrows-0.5, -0.5)``.
5596             - For ``origin == 'lower'`` the default is
5597               ``(-0.5, numcols-0.5, -0.5, numrows-0.5)``.
5598 
5599             See the :doc:`/tutorials/intermediate/imshow_extent` tutorial for
5600             examples and a more detailed description.
5601 
5602         filternorm : bool, default: True
5603             A parameter for the antigrain image resize filter (see the
5604             antigrain documentation).  If *filternorm* is set, the filter
5605             normalizes integer values and corrects the rounding errors. It
5606             doesn't do anything with the source floating point values, it
5607             corrects only integers according to the rule of 1.0 which means
5608             that any sum of pixel weights must be equal to 1.0.  So, the
5609             filter function must produce a graph of the proper shape.
5610 
5611         filterrad : float > 0, default: 4.0
5612             The filter radius for filters that have a radius parameter, i.e.
5613             when interpolation is one of: 'sinc', 'lanczos' or 'blackman'.
5614 
5615         resample : bool, default: :rc:`image.resample`
5616             When *True*, use a full resampling method.  When *False*, only
5617             resample when the output image is larger than the input image.
5618 
5619         url : str, optional
5620             Set the url of the created `.AxesImage`. See `.Artist.set_url`.
5621 
5622         Returns
5623         -------
5624         `~matplotlib.image.AxesImage`
5625 
5626         Other Parameters
5627         ----------------
5628         data : indexable object, optional
5629             DATA_PARAMETER_PLACEHOLDER
5630 
5631         **kwargs : `~matplotlib.artist.Artist` properties
5632             These parameters are passed on to the constructor of the
5633             `.AxesImage` artist.
5634 
5635         See Also
5636         --------
5637         matshow : Plot a matrix or an array as an image.
5638 
5639         Notes
5640         -----
5641         Unless *extent* is used, pixel centers will be located at integer
5642         coordinates. In other words: the origin will coincide with the center
5643         of pixel (0, 0).
5644 
5645         There are two common representations for RGB images with an alpha
5646         channel:
5647 
5648         -   Straight (unassociated) alpha: R, G, and B channels represent the
5649             color of the pixel, disregarding its opacity.
5650         -   Premultiplied (associated) alpha: R, G, and B channels represent
5651             the color of the pixel, adjusted for its opacity by multiplication.
5652 
5653         `~matplotlib.pyplot.imshow` expects RGB images adopting the straight
5654         (unassociated) alpha representation.
5655         """
5656         if aspect is None:
5657             aspect = mpl.rcParams['image.aspect']
5658         self.set_aspect(aspect)
5659         im = mimage.AxesImage(self, cmap=cmap, norm=norm,
5660                               interpolation=interpolation, origin=origin,
5661                               extent=extent, filternorm=filternorm,
5662                               filterrad=filterrad, resample=resample,
5663                               interpolation_stage=interpolation_stage,
5664                               **kwargs)
5665 
5666         im.set_data(X)
5667         im.set_alpha(alpha)
5668         if im.get_clip_path() is None:
5669             # image does not already have clipping set, clip to axes patch
5670             im.set_clip_path(self.patch)
5671         im._scale_norm(norm, vmin, vmax)
5672         im.set_url(url)
5673 
5674         # update ax.dataLim, and, if autoscaling, set viewLim
5675         # to tightly fit the image, regardless of dataLim.
5676         im.set_extent(im.get_extent())
5677 
5678         self.add_image(im)
5679         return im
5680 
5681     def _pcolorargs(self, funcname, *args, shading='auto', **kwargs):
5682         # - create X and Y if not present;
5683         # - reshape X and Y as needed if they are 1-D;
5684         # - check for proper sizes based on `shading` kwarg;
5685         # - reset shading if shading='auto' to flat or nearest
5686         #   depending on size;
5687 
5688         _valid_shading = ['gouraud', 'nearest', 'flat', 'auto']
5689         try:
5690             _api.check_in_list(_valid_shading, shading=shading)
5691         except ValueError:
5692             _api.warn_external(f"shading value '{shading}' not in list of "
5693                                f"valid values {_valid_shading}. Setting "
5694                                "shading='auto'.")
5695             shading = 'auto'
5696 
5697         if len(args) == 1:
5698             C = np.asanyarray(args[0])
5699             nrows, ncols = C.shape[:2]
5700             if shading in ['gouraud', 'nearest']:
5701                 X, Y = np.meshgrid(np.arange(ncols), np.arange(nrows))
5702             else:
5703                 X, Y = np.meshgrid(np.arange(ncols + 1), np.arange(nrows + 1))
5704                 shading = 'flat'
5705             C = cbook.safe_masked_invalid(C)
5706             return X, Y, C, shading
5707 
5708         if len(args) == 3:
5709             # Check x and y for bad data...
5710             C = np.asanyarray(args[2])
5711             # unit conversion allows e.g. datetime objects as axis values
5712             X, Y = args[:2]
5713             X, Y = self._process_unit_info([("x", X), ("y", Y)], kwargs)
5714             X, Y = [cbook.safe_masked_invalid(a) for a in [X, Y]]
5715 
5716             if funcname == 'pcolormesh':
5717                 if np.ma.is_masked(X) or np.ma.is_masked(Y):
5718                     raise ValueError(
5719                         'x and y arguments to pcolormesh cannot have '
5720                         'non-finite values or be of type '
5721                         'numpy.ma.core.MaskedArray with masked values')
5722                 # safe_masked_invalid() returns an ndarray for dtypes other
5723                 # than floating point.
5724                 if isinstance(X, np.ma.core.MaskedArray):
5725                     X = X.data  # strip mask as downstream doesn't like it...
5726                 if isinstance(Y, np.ma.core.MaskedArray):
5727                     Y = Y.data
5728             nrows, ncols = C.shape[:2]
5729         else:
5730             raise _api.nargs_error(funcname, takes="1 or 3", given=len(args))
5731 
5732         Nx = X.shape[-1]
5733         Ny = Y.shape[0]
5734         if X.ndim != 2 or X.shape[0] == 1:
5735             x = X.reshape(1, Nx)
5736             X = x.repeat(Ny, axis=0)
5737         if Y.ndim != 2 or Y.shape[1] == 1:
5738             y = Y.reshape(Ny, 1)
5739             Y = y.repeat(Nx, axis=1)
5740         if X.shape != Y.shape:
5741             raise TypeError(f'Incompatible X, Y inputs to {funcname}; '
5742                             f'see help({funcname})')
5743 
5744         if shading == 'auto':
5745             if ncols == Nx and nrows == Ny:
5746                 shading = 'nearest'
5747             else:
5748                 shading = 'flat'
5749 
5750         if shading == 'flat':
5751             if (Nx, Ny) != (ncols + 1, nrows + 1):
5752                 raise TypeError(f"Dimensions of C {C.shape} should"
5753                                 f" be one smaller than X({Nx}) and Y({Ny})"
5754                                 f" while using shading='flat'"
5755                                 f" see help({funcname})")
5756         else:    # ['nearest', 'gouraud']:
5757             if (Nx, Ny) != (ncols, nrows):
5758                 raise TypeError('Dimensions of C %s are incompatible with'
5759                                 ' X (%d) and/or Y (%d); see help(%s)' % (
5760                                     C.shape, Nx, Ny, funcname))
5761             if shading == 'nearest':
5762                 # grid is specified at the center, so define corners
5763                 # at the midpoints between the grid centers and then use the
5764                 # flat algorithm.
5765                 def _interp_grid(X):
5766                     # helper for below
5767                     if np.shape(X)[1] > 1:
5768                         dX = np.diff(X, axis=1)/2.
5769                         if not (np.all(dX >= 0) or np.all(dX <= 0)):
5770                             _api.warn_external(
5771                                 f"The input coordinates to {funcname} are "
5772                                 "interpreted as cell centers, but are not "
5773                                 "monotonically increasing or decreasing. "
5774                                 "This may lead to incorrectly calculated cell "
5775                                 "edges, in which case, please supply "
5776                                 f"explicit cell edges to {funcname}.")
5777                         X = np.hstack((X[:, [0]] - dX[:, [0]],
5778                                        X[:, :-1] + dX,
5779                                        X[:, [-1]] + dX[:, [-1]]))
5780                     else:
5781                         # This is just degenerate, but we can't reliably guess
5782                         # a dX if there is just one value.
5783                         X = np.hstack((X, X))
5784                     return X
5785 
5786                 if ncols == Nx:
5787                     X = _interp_grid(X)
5788                     Y = _interp_grid(Y)
5789                 if nrows == Ny:
5790                     X = _interp_grid(X.T).T
5791                     Y = _interp_grid(Y.T).T
5792                 shading = 'flat'
5793 
5794         C = cbook.safe_masked_invalid(C)
5795         return X, Y, C, shading
5796 
5797     @_preprocess_data()
5798     @_docstring.dedent_interpd
5799     def pcolor(self, *args, shading=None, alpha=None, norm=None, cmap=None,
5800                vmin=None, vmax=None, **kwargs):
5801         r"""
5802         Create a pseudocolor plot with a non-regular rectangular grid.
5803 
5804         Call signature::
5805 
5806             pcolor([X, Y,] C, **kwargs)
5807 
5808         *X* and *Y* can be used to specify the corners of the quadrilaterals.
5809 
5810         .. hint::
5811 
5812             ``pcolor()`` can be very slow for large arrays. In most
5813             cases you should use the similar but much faster
5814             `~.Axes.pcolormesh` instead. See
5815             :ref:`Differences between pcolor() and pcolormesh()
5816             <differences-pcolor-pcolormesh>` for a discussion of the
5817             differences.
5818 
5819         Parameters
5820         ----------
5821         C : 2D array-like
5822             The color-mapped values.  Color-mapping is controlled by *cmap*,
5823             *norm*, *vmin*, and *vmax*.
5824 
5825         X, Y : array-like, optional
5826             The coordinates of the corners of quadrilaterals of a pcolormesh::
5827 
5828                 (X[i+1, j], Y[i+1, j])       (X[i+1, j+1], Y[i+1, j+1])
5829                                       
5830                                            
5831                                       
5832                     (X[i, j], Y[i, j])       (X[i, j+1], Y[i, j+1])
5833 
5834             Note that the column index corresponds to the x-coordinate, and
5835             the row index corresponds to y. For details, see the
5836             :ref:`Notes <axes-pcolormesh-grid-orientation>` section below.
5837 
5838             If ``shading='flat'`` the dimensions of *X* and *Y* should be one
5839             greater than those of *C*, and the quadrilateral is colored due
5840             to the value at ``C[i, j]``.  If *X*, *Y* and *C* have equal
5841             dimensions, a warning will be raised and the last row and column
5842             of *C* will be ignored.
5843 
5844             If ``shading='nearest'``, the dimensions of *X* and *Y* should be
5845             the same as those of *C* (if not, a ValueError will be raised). The
5846             color ``C[i, j]`` will be centered on ``(X[i, j], Y[i, j])``.
5847 
5848             If *X* and/or *Y* are 1-D arrays or column vectors they will be
5849             expanded as needed into the appropriate 2D arrays, making a
5850             rectangular grid.
5851 
5852         shading : {'flat', 'nearest', 'auto'}, default: :rc:`pcolor.shading`
5853             The fill style for the quadrilateral. Possible values:
5854 
5855             - 'flat': A solid color is used for each quad. The color of the
5856               quad (i, j), (i+1, j), (i, j+1), (i+1, j+1) is given by
5857               ``C[i, j]``. The dimensions of *X* and *Y* should be
5858               one greater than those of *C*; if they are the same as *C*,
5859               then a deprecation warning is raised, and the last row
5860               and column of *C* are dropped.
5861             - 'nearest': Each grid point will have a color centered on it,
5862               extending halfway between the adjacent grid centers.  The
5863               dimensions of *X* and *Y* must be the same as *C*.
5864             - 'auto': Choose 'flat' if dimensions of *X* and *Y* are one
5865               larger than *C*.  Choose 'nearest' if dimensions are the same.
5866 
5867             See :doc:`/gallery/images_contours_and_fields/pcolormesh_grids`
5868             for more description.
5869 
5870         %(cmap_doc)s
5871 
5872         %(norm_doc)s
5873 
5874         %(vmin_vmax_doc)s
5875 
5876         edgecolors : {'none', None, 'face', color, color sequence}, optional
5877             The color of the edges. Defaults to 'none'. Possible values:
5878 
5879             - 'none' or '': No edge.
5880             - *None*: :rc:`patch.edgecolor` will be used. Note that currently
5881               :rc:`patch.force_edgecolor` has to be True for this to work.
5882             - 'face': Use the adjacent face color.
5883             - A color or sequence of colors will set the edge color.
5884 
5885             The singular form *edgecolor* works as an alias.
5886 
5887         alpha : float, default: None
5888             The alpha blending value of the face color, between 0 (transparent)
5889             and 1 (opaque). Note: The edgecolor is currently not affected by
5890             this.
5891 
5892         snap : bool, default: False
5893             Whether to snap the mesh to pixel boundaries.
5894 
5895         Returns
5896         -------
5897         `matplotlib.collections.Collection`
5898 
5899         Other Parameters
5900         ----------------
5901         antialiaseds : bool, default: False
5902             The default *antialiaseds* is False if the default
5903             *edgecolors*\ ="none" is used.  This eliminates artificial lines
5904             at patch boundaries, and works regardless of the value of alpha.
5905             If *edgecolors* is not "none", then the default *antialiaseds*
5906             is taken from :rc:`patch.antialiased`.
5907             Stroking the edges may be preferred if *alpha* is 1, but will
5908             cause artifacts otherwise.
5909 
5910         data : indexable object, optional
5911             DATA_PARAMETER_PLACEHOLDER
5912 
5913         **kwargs
5914             Additionally, the following arguments are allowed. They are passed
5915             along to the `~matplotlib.collections.PolyCollection` constructor:
5916 
5917         %(PolyCollection:kwdoc)s
5918 
5919         See Also
5920         --------
5921         pcolormesh : for an explanation of the differences between
5922             pcolor and pcolormesh.
5923         imshow : If *X* and *Y* are each equidistant, `~.Axes.imshow` can be a
5924             faster alternative.
5925 
5926         Notes
5927         -----
5928         **Masked arrays**
5929 
5930         *X*, *Y* and *C* may be masked arrays. If either ``C[i, j]``, or one
5931         of the vertices surrounding ``C[i, j]`` (*X* or *Y* at
5932         ``[i, j], [i+1, j], [i, j+1], [i+1, j+1]``) is masked, nothing is
5933         plotted.
5934 
5935         .. _axes-pcolor-grid-orientation:
5936 
5937         **Grid orientation**
5938 
5939         The grid orientation follows the standard matrix convention: An array
5940         *C* with shape (nrows, ncolumns) is plotted with the column number as
5941         *X* and the row number as *Y*.
5942         """
5943 
5944         if shading is None:
5945             shading = mpl.rcParams['pcolor.shading']
5946         shading = shading.lower()
5947         X, Y, C, shading = self._pcolorargs('pcolor', *args, shading=shading,
5948                                             kwargs=kwargs)
5949         Ny, Nx = X.shape
5950 
5951         # convert to MA, if necessary.
5952         C = ma.asarray(C)
5953         X = ma.asarray(X)
5954         Y = ma.asarray(Y)
5955 
5956         mask = ma.getmaskarray(X) + ma.getmaskarray(Y)
5957         xymask = (mask[0:-1, 0:-1] + mask[1:, 1:] +
5958                   mask[0:-1, 1:] + mask[1:, 0:-1])
5959         # don't plot if C or any of the surrounding vertices are masked.
5960         mask = ma.getmaskarray(C) + xymask
5961 
5962         unmask = ~mask
5963         X1 = ma.filled(X[:-1, :-1])[unmask]
5964         Y1 = ma.filled(Y[:-1, :-1])[unmask]
5965         X2 = ma.filled(X[1:, :-1])[unmask]
5966         Y2 = ma.filled(Y[1:, :-1])[unmask]
5967         X3 = ma.filled(X[1:, 1:])[unmask]
5968         Y3 = ma.filled(Y[1:, 1:])[unmask]
5969         X4 = ma.filled(X[:-1, 1:])[unmask]
5970         Y4 = ma.filled(Y[:-1, 1:])[unmask]
5971         npoly = len(X1)
5972 
5973         xy = np.stack([X1, Y1, X2, Y2, X3, Y3, X4, Y4, X1, Y1], axis=-1)
5974         verts = xy.reshape((npoly, 5, 2))
5975 
5976         C = ma.filled(C[:Ny - 1, :Nx - 1])[unmask]
5977 
5978         linewidths = (0.25,)
5979         if 'linewidth' in kwargs:
5980             kwargs['linewidths'] = kwargs.pop('linewidth')
5981         kwargs.setdefault('linewidths', linewidths)
5982 
5983         if 'edgecolor' in kwargs:
5984             kwargs['edgecolors'] = kwargs.pop('edgecolor')
5985         ec = kwargs.setdefault('edgecolors', 'none')
5986 
5987         # aa setting will default via collections to patch.antialiased
5988         # unless the boundary is not stroked, in which case the
5989         # default will be False; with unstroked boundaries, aa
5990         # makes artifacts that are often disturbing.
5991         if 'antialiased' in kwargs:
5992             kwargs['antialiaseds'] = kwargs.pop('antialiased')
5993         if 'antialiaseds' not in kwargs and cbook._str_lower_equal(ec, "none"):
5994             kwargs['antialiaseds'] = False
5995 
5996         kwargs.setdefault('snap', False)
5997 
5998         collection = mcoll.PolyCollection(
5999             verts, array=C, cmap=cmap, norm=norm, alpha=alpha, **kwargs)
6000         collection._scale_norm(norm, vmin, vmax)
6001 
6002         x = X.compressed()
6003         y = Y.compressed()
6004 
6005         # Transform from native to data coordinates?
6006         t = collection._transform
6007         if (not isinstance(t, mtransforms.Transform) and
6008                 hasattr(t, '_as_mpl_transform')):
6009             t = t._as_mpl_transform(self.axes)
6010 
6011         if t and any(t.contains_branch_seperately(self.transData)):
6012             trans_to_data = t - self.transData
6013             pts = np.vstack([x, y]).T.astype(float)
6014             transformed_pts = trans_to_data.transform(pts)
6015             x = transformed_pts[..., 0]
6016             y = transformed_pts[..., 1]
6017 
6018         self.add_collection(collection, autolim=False)
6019 
6020         minx = np.min(x)
6021         maxx = np.max(x)
6022         miny = np.min(y)
6023         maxy = np.max(y)
6024         collection.sticky_edges.x[:] = [minx, maxx]
6025         collection.sticky_edges.y[:] = [miny, maxy]
6026         corners = (minx, miny), (maxx, maxy)
6027         self.update_datalim(corners)
6028         self._request_autoscale_view()
6029         return collection
6030 
6031     @_preprocess_data()
6032     @_docstring.dedent_interpd
6033     def pcolormesh(self, *args, alpha=None, norm=None, cmap=None, vmin=None,
6034                    vmax=None, shading=None, antialiased=False, **kwargs):
6035         """
6036         Create a pseudocolor plot with a non-regular rectangular grid.
6037 
6038         Call signature::
6039 
6040             pcolormesh([X, Y,] C, **kwargs)
6041 
6042         *X* and *Y* can be used to specify the corners of the quadrilaterals.
6043 
6044         .. hint::
6045 
6046            `~.Axes.pcolormesh` is similar to `~.Axes.pcolor`. It is much faster
6047            and preferred in most cases. For a detailed discussion on the
6048            differences see :ref:`Differences between pcolor() and pcolormesh()
6049            <differences-pcolor-pcolormesh>`.
6050 
6051         Parameters
6052         ----------
6053         C : array-like
6054             The mesh data. Supported array shapes are:
6055 
6056             - (M, N) or M*N: a mesh with scalar data. The values are mapped to
6057               colors using normalization and a colormap. See parameters *norm*,
6058               *cmap*, *vmin*, *vmax*.
6059             - (M, N, 3): an image with RGB values (0-1 float or 0-255 int).
6060             - (M, N, 4): an image with RGBA values (0-1 float or 0-255 int),
6061               i.e. including transparency.
6062 
6063             The first two dimensions (M, N) define the rows and columns of
6064             the mesh data.
6065 
6066         X, Y : array-like, optional
6067             The coordinates of the corners of quadrilaterals of a pcolormesh::
6068 
6069                 (X[i+1, j], Y[i+1, j])       (X[i+1, j+1], Y[i+1, j+1])
6070                                       
6071                                            
6072                                       
6073                     (X[i, j], Y[i, j])       (X[i, j+1], Y[i, j+1])
6074 
6075             Note that the column index corresponds to the x-coordinate, and
6076             the row index corresponds to y. For details, see the
6077             :ref:`Notes <axes-pcolormesh-grid-orientation>` section below.
6078 
6079             If ``shading='flat'`` the dimensions of *X* and *Y* should be one
6080             greater than those of *C*, and the quadrilateral is colored due
6081             to the value at ``C[i, j]``.  If *X*, *Y* and *C* have equal
6082             dimensions, a warning will be raised and the last row and column
6083             of *C* will be ignored.
6084 
6085             If ``shading='nearest'`` or ``'gouraud'``, the dimensions of *X*
6086             and *Y* should be the same as those of *C* (if not, a ValueError
6087             will be raised).  For ``'nearest'`` the color ``C[i, j]`` is
6088             centered on ``(X[i, j], Y[i, j])``.  For ``'gouraud'``, a smooth
6089             interpolation is caried out between the quadrilateral corners.
6090 
6091             If *X* and/or *Y* are 1-D arrays or column vectors they will be
6092             expanded as needed into the appropriate 2D arrays, making a
6093             rectangular grid.
6094 
6095         %(cmap_doc)s
6096 
6097         %(norm_doc)s
6098 
6099         %(vmin_vmax_doc)s
6100 
6101         edgecolors : {'none', None, 'face', color, color sequence}, optional
6102             The color of the edges. Defaults to 'none'. Possible values:
6103 
6104             - 'none' or '': No edge.
6105             - *None*: :rc:`patch.edgecolor` will be used. Note that currently
6106               :rc:`patch.force_edgecolor` has to be True for this to work.
6107             - 'face': Use the adjacent face color.
6108             - A color or sequence of colors will set the edge color.
6109 
6110             The singular form *edgecolor* works as an alias.
6111 
6112         alpha : float, default: None
6113             The alpha blending value, between 0 (transparent) and 1 (opaque).
6114 
6115         shading : {'flat', 'nearest', 'gouraud', 'auto'}, optional
6116             The fill style for the quadrilateral; defaults to
6117             :rc:`pcolor.shading`. Possible values:
6118 
6119             - 'flat': A solid color is used for each quad. The color of the
6120               quad (i, j), (i+1, j), (i, j+1), (i+1, j+1) is given by
6121               ``C[i, j]``. The dimensions of *X* and *Y* should be
6122               one greater than those of *C*; if they are the same as *C*,
6123               then a deprecation warning is raised, and the last row
6124               and column of *C* are dropped.
6125             - 'nearest': Each grid point will have a color centered on it,
6126               extending halfway between the adjacent grid centers.  The
6127               dimensions of *X* and *Y* must be the same as *C*.
6128             - 'gouraud': Each quad will be Gouraud shaded: The color of the
6129               corners (i', j') are given by ``C[i', j']``. The color values of
6130               the area in between is interpolated from the corner values.
6131               The dimensions of *X* and *Y* must be the same as *C*. When
6132               Gouraud shading is used, *edgecolors* is ignored.
6133             - 'auto': Choose 'flat' if dimensions of *X* and *Y* are one
6134               larger than *C*.  Choose 'nearest' if dimensions are the same.
6135 
6136             See :doc:`/gallery/images_contours_and_fields/pcolormesh_grids`
6137             for more description.
6138 
6139         snap : bool, default: False
6140             Whether to snap the mesh to pixel boundaries.
6141 
6142         rasterized : bool, optional
6143             Rasterize the pcolormesh when drawing vector graphics.  This can
6144             speed up rendering and produce smaller files for large data sets.
6145             See also :doc:`/gallery/misc/rasterization_demo`.
6146 
6147         Returns
6148         -------
6149         `matplotlib.collections.QuadMesh`
6150 
6151         Other Parameters
6152         ----------------
6153         data : indexable object, optional
6154             DATA_PARAMETER_PLACEHOLDER
6155 
6156         **kwargs
6157             Additionally, the following arguments are allowed. They are passed
6158             along to the `~matplotlib.collections.QuadMesh` constructor:
6159 
6160         %(QuadMesh:kwdoc)s
6161 
6162         See Also
6163         --------
6164         pcolor : An alternative implementation with slightly different
6165             features. For a detailed discussion on the differences see
6166             :ref:`Differences between pcolor() and pcolormesh()
6167             <differences-pcolor-pcolormesh>`.
6168         imshow : If *X* and *Y* are each equidistant, `~.Axes.imshow` can be a
6169             faster alternative.
6170 
6171         Notes
6172         -----
6173         **Masked arrays**
6174 
6175         *C* may be a masked array. If ``C[i, j]`` is masked, the corresponding
6176         quadrilateral will be transparent. Masking of *X* and *Y* is not
6177         supported. Use `~.Axes.pcolor` if you need this functionality.
6178 
6179         .. _axes-pcolormesh-grid-orientation:
6180 
6181         **Grid orientation**
6182 
6183         The grid orientation follows the standard matrix convention: An array
6184         *C* with shape (nrows, ncolumns) is plotted with the column number as
6185         *X* and the row number as *Y*.
6186 
6187         .. _differences-pcolor-pcolormesh:
6188 
6189         **Differences between pcolor() and pcolormesh()**
6190 
6191         Both methods are used to create a pseudocolor plot of a 2D array
6192         using quadrilaterals.
6193 
6194         The main difference lies in the created object and internal data
6195         handling:
6196         While `~.Axes.pcolor` returns a `.PolyCollection`, `~.Axes.pcolormesh`
6197         returns a `.QuadMesh`. The latter is more specialized for the given
6198         purpose and thus is faster. It should almost always be preferred.
6199 
6200         There is also a slight difference in the handling of masked arrays.
6201         Both `~.Axes.pcolor` and `~.Axes.pcolormesh` support masked arrays
6202         for *C*. However, only `~.Axes.pcolor` supports masked arrays for *X*
6203         and *Y*. The reason lies in the internal handling of the masked values.
6204         `~.Axes.pcolor` leaves out the respective polygons from the
6205         PolyCollection. `~.Axes.pcolormesh` sets the facecolor of the masked
6206         elements to transparent. You can see the difference when using
6207         edgecolors. While all edges are drawn irrespective of masking in a
6208         QuadMesh, the edge between two adjacent masked quadrilaterals in
6209         `~.Axes.pcolor` is not drawn as the corresponding polygons do not
6210         exist in the PolyCollection.
6211 
6212         Another difference is the support of Gouraud shading in
6213         `~.Axes.pcolormesh`, which is not available with `~.Axes.pcolor`.
6214 
6215         """
6216         if shading is None:
6217             shading = mpl.rcParams['pcolor.shading']
6218         shading = shading.lower()
6219         kwargs.setdefault('edgecolors', 'none')
6220 
6221         X, Y, C, shading = self._pcolorargs('pcolormesh', *args,
6222                                             shading=shading, kwargs=kwargs)
6223         coords = np.stack([X, Y], axis=-1)
6224 
6225         kwargs.setdefault('snap', mpl.rcParams['pcolormesh.snap'])
6226 
6227         collection = mcoll.QuadMesh(
6228             coords, antialiased=antialiased, shading=shading,
6229             array=C, cmap=cmap, norm=norm, alpha=alpha, **kwargs)
6230         collection._scale_norm(norm, vmin, vmax)
6231 
6232         coords = coords.reshape(-1, 2)  # flatten the grid structure; keep x, y
6233 
6234         # Transform from native to data coordinates?
6235         t = collection._transform
6236         if (not isinstance(t, mtransforms.Transform) and
6237                 hasattr(t, '_as_mpl_transform')):
6238             t = t._as_mpl_transform(self.axes)
6239 
6240         if t and any(t.contains_branch_seperately(self.transData)):
6241             trans_to_data = t - self.transData
6242             coords = trans_to_data.transform(coords)
6243 
6244         self.add_collection(collection, autolim=False)
6245 
6246         minx, miny = np.min(coords, axis=0)
6247         maxx, maxy = np.max(coords, axis=0)
6248         collection.sticky_edges.x[:] = [minx, maxx]
6249         collection.sticky_edges.y[:] = [miny, maxy]
6250         corners = (minx, miny), (maxx, maxy)
6251         self.update_datalim(corners)
6252         self._request_autoscale_view()
6253         return collection
6254 
6255     @_preprocess_data()
6256     @_docstring.dedent_interpd
6257     def pcolorfast(self, *args, alpha=None, norm=None, cmap=None, vmin=None,
6258                    vmax=None, **kwargs):
6259         """
6260         Create a pseudocolor plot with a non-regular rectangular grid.
6261 
6262         Call signature::
6263 
6264           ax.pcolorfast([X, Y], C, /, **kwargs)
6265 
6266         This method is similar to `~.Axes.pcolor` and `~.Axes.pcolormesh`.
6267         It's designed to provide the fastest pcolor-type plotting with the
6268         Agg backend. To achieve this, it uses different algorithms internally
6269         depending on the complexity of the input grid (regular rectangular,
6270         non-regular rectangular or arbitrary quadrilateral).
6271 
6272         .. warning::
6273 
6274            This method is experimental. Compared to `~.Axes.pcolor` or
6275            `~.Axes.pcolormesh` it has some limitations:
6276 
6277            - It supports only flat shading (no outlines)
6278            - It lacks support for log scaling of the axes.
6279            - It does not have a pyplot wrapper.
6280 
6281         Parameters
6282         ----------
6283         C : array-like
6284             The image data. Supported array shapes are:
6285 
6286             - (M, N): an image with scalar data.  Color-mapping is controlled
6287               by *cmap*, *norm*, *vmin*, and *vmax*.
6288             - (M, N, 3): an image with RGB values (0-1 float or 0-255 int).
6289             - (M, N, 4): an image with RGBA values (0-1 float or 0-255 int),
6290               i.e. including transparency.
6291 
6292             The first two dimensions (M, N) define the rows and columns of
6293             the image.
6294 
6295             This parameter can only be passed positionally.
6296 
6297         X, Y : tuple or array-like, default: ``(0, N)``, ``(0, M)``
6298             *X* and *Y* are used to specify the coordinates of the
6299             quadrilaterals. There are different ways to do this:
6300 
6301             - Use tuples ``X=(xmin, xmax)`` and ``Y=(ymin, ymax)`` to define
6302               a *uniform rectangular grid*.
6303 
6304               The tuples define the outer edges of the grid. All individual
6305               quadrilaterals will be of the same size. This is the fastest
6306               version.
6307 
6308             - Use 1D arrays *X*, *Y* to specify a *non-uniform rectangular
6309               grid*.
6310 
6311               In this case *X* and *Y* have to be monotonic 1D arrays of length
6312               *N+1* and *M+1*, specifying the x and y boundaries of the cells.
6313 
6314               The speed is intermediate. Note: The grid is checked, and if
6315               found to be uniform the fast version is used.
6316 
6317             - Use 2D arrays *X*, *Y* if you need an *arbitrary quadrilateral
6318               grid* (i.e. if the quadrilaterals are not rectangular).
6319 
6320               In this case *X* and *Y* are 2D arrays with shape (M + 1, N + 1),
6321               specifying the x and y coordinates of the corners of the colored
6322               quadrilaterals.
6323 
6324               This is the most general, but the slowest to render.  It may
6325               produce faster and more compact output using ps, pdf, and
6326               svg backends, however.
6327 
6328             These arguments can only be passed positionally.
6329 
6330         %(cmap_doc)s
6331 
6332             This parameter is ignored if *C* is RGB(A).
6333 
6334         %(norm_doc)s
6335 
6336             This parameter is ignored if *C* is RGB(A).
6337 
6338         %(vmin_vmax_doc)s
6339 
6340             This parameter is ignored if *C* is RGB(A).
6341 
6342         alpha : float, default: None
6343             The alpha blending value, between 0 (transparent) and 1 (opaque).
6344 
6345         snap : bool, default: False
6346             Whether to snap the mesh to pixel boundaries.
6347 
6348         Returns
6349         -------
6350         `.AxesImage` or `.PcolorImage` or `.QuadMesh`
6351             The return type depends on the type of grid:
6352 
6353             - `.AxesImage` for a regular rectangular grid.
6354             - `.PcolorImage` for a non-regular rectangular grid.
6355             - `.QuadMesh` for a non-rectangular grid.
6356 
6357         Other Parameters
6358         ----------------
6359         data : indexable object, optional
6360             DATA_PARAMETER_PLACEHOLDER
6361 
6362         **kwargs
6363             Supported additional parameters depend on the type of grid.
6364             See return types of *image* for further description.
6365         """
6366 
6367         C = args[-1]
6368         nr, nc = np.shape(C)[:2]
6369         if len(args) == 1:
6370             style = "image"
6371             x = [0, nc]
6372             y = [0, nr]
6373         elif len(args) == 3:
6374             x, y = args[:2]
6375             x = np.asarray(x)
6376             y = np.asarray(y)
6377             if x.ndim == 1 and y.ndim == 1:
6378                 if x.size == 2 and y.size == 2:
6379                     style = "image"
6380                 else:
6381                     dx = np.diff(x)
6382                     dy = np.diff(y)
6383                     if (np.ptp(dx) < 0.01 * abs(dx.mean()) and
6384                             np.ptp(dy) < 0.01 * abs(dy.mean())):
6385                         style = "image"
6386                     else:
6387                         style = "pcolorimage"
6388             elif x.ndim == 2 and y.ndim == 2:
6389                 style = "quadmesh"
6390             else:
6391                 raise TypeError("arguments do not match valid signatures")
6392         else:
6393             raise TypeError("need 1 argument or 3 arguments")
6394 
6395         if style == "quadmesh":
6396             # data point in each cell is value at lower left corner
6397             coords = np.stack([x, y], axis=-1)
6398             if np.ndim(C) not in {2, 3}:
6399                 raise ValueError("C must be 2D or 3D")
6400             collection = mcoll.QuadMesh(
6401                 coords, array=C,
6402                 alpha=alpha, cmap=cmap, norm=norm,
6403                 antialiased=False, edgecolors="none")
6404             self.add_collection(collection, autolim=False)
6405             xl, xr, yb, yt = x.min(), x.max(), y.min(), y.max()
6406             ret = collection
6407 
6408         else:  # It's one of the two image styles.
6409             extent = xl, xr, yb, yt = x[0], x[-1], y[0], y[-1]
6410             if style == "image":
6411                 im = mimage.AxesImage(
6412                     self, cmap=cmap, norm=norm,
6413                     data=C, alpha=alpha, extent=extent,
6414                     interpolation='nearest', origin='lower',
6415                     **kwargs)
6416             elif style == "pcolorimage":
6417                 im = mimage.PcolorImage(
6418                     self, x, y, C,
6419                     cmap=cmap, norm=norm, alpha=alpha, extent=extent,
6420                     **kwargs)
6421             self.add_image(im)
6422             ret = im
6423 
6424         if np.ndim(C) == 2:  # C.ndim == 3 is RGB(A) so doesn't need scaling.
6425             ret._scale_norm(norm, vmin, vmax)
6426 
6427         if ret.get_clip_path() is None:
6428             # image does not already have clipping set, clip to axes patch
6429             ret.set_clip_path(self.patch)
6430 
6431         ret.sticky_edges.x[:] = [xl, xr]
6432         ret.sticky_edges.y[:] = [yb, yt]
6433         self.update_datalim(np.array([[xl, yb], [xr, yt]]))
6434         self._request_autoscale_view(tight=True)
6435         return ret
6436 
6437     @_preprocess_data()
6438     @_docstring.dedent_interpd
6439     def contour(self, *args, **kwargs):
6440         """
6441         Plot contour lines.
6442 
6443         Call signature::
6444 
6445             contour([X, Y,] Z, [levels], **kwargs)
6446         %(contour_doc)s
6447         """
6448         kwargs['filled'] = False
6449         contours = mcontour.QuadContourSet(self, *args, **kwargs)
6450         self._request_autoscale_view()
6451         return contours
6452 
6453     @_preprocess_data()
6454     @_docstring.dedent_interpd
6455     def contourf(self, *args, **kwargs):
6456         """
6457         Plot filled contours.
6458 
6459         Call signature::
6460 
6461             contourf([X, Y,] Z, [levels], **kwargs)
6462         %(contour_doc)s
6463         """
6464         kwargs['filled'] = True
6465         contours = mcontour.QuadContourSet(self, *args, **kwargs)
6466         self._request_autoscale_view()
6467         return contours
6468 
6469     def clabel(self, CS, levels=None, **kwargs):
6470         """
6471         Label a contour plot.
6472 
6473         Adds labels to line contours in given `.ContourSet`.
6474 
6475         Parameters
6476         ----------
6477         CS : `.ContourSet` instance
6478             Line contours to label.
6479 
6480         levels : array-like, optional
6481             A list of level values, that should be labeled. The list must be
6482             a subset of ``CS.levels``. If not given, all levels are labeled.
6483 
6484         **kwargs
6485             All other parameters are documented in `~.ContourLabeler.clabel`.
6486         """
6487         return CS.clabel(levels, **kwargs)
6488 
6489     #### Data analysis
6490 
6491     @_preprocess_data(replace_names=["x", 'weights'], label_namer="x")
6492     def hist(self, x, bins=None, range=None, density=False, weights=None,
6493              cumulative=False, bottom=None, histtype='bar', align='mid',
6494              orientation='vertical', rwidth=None, log=False,
6495              color=None, label=None, stacked=False, **kwargs):
6496         """
6497         Compute and plot a histogram.
6498 
6499         This method uses `numpy.histogram` to bin the data in *x* and count the
6500         number of values in each bin, then draws the distribution either as a
6501         `.BarContainer` or `.Polygon`. The *bins*, *range*, *density*, and
6502         *weights* parameters are forwarded to `numpy.histogram`.
6503 
6504         If the data has already been binned and counted, use `~.bar` or
6505         `~.stairs` to plot the distribution::
6506 
6507             counts, bins = np.histogram(x)
6508             plt.stairs(counts, bins)
6509 
6510         Alternatively, plot pre-computed bins and counts using ``hist()`` by
6511         treating each bin as a single point with a weight equal to its count::
6512 
6513             plt.hist(bins[:-1], bins, weights=counts)
6514 
6515         The data input *x* can be a singular array, a list of datasets of
6516         potentially different lengths ([*x0*, *x1*, ...]), or a 2D ndarray in
6517         which each column is a dataset. Note that the ndarray form is
6518         transposed relative to the list form. If the input is an array, then
6519         the return value is a tuple (*n*, *bins*, *patches*); if the input is a
6520         sequence of arrays, then the return value is a tuple
6521         ([*n0*, *n1*, ...], *bins*, [*patches0*, *patches1*, ...]).
6522 
6523         Masked arrays are not supported.
6524 
6525         Parameters
6526         ----------
6527         x : (n,) array or sequence of (n,) arrays
6528             Input values, this takes either a single array or a sequence of
6529             arrays which are not required to be of the same length.
6530 
6531         bins : int or sequence or str, default: :rc:`hist.bins`
6532             If *bins* is an integer, it defines the number of equal-width bins
6533             in the range.
6534 
6535             If *bins* is a sequence, it defines the bin edges, including the
6536             left edge of the first bin and the right edge of the last bin;
6537             in this case, bins may be unequally spaced.  All but the last
6538             (righthand-most) bin is half-open.  In other words, if *bins* is::
6539 
6540                 [1, 2, 3, 4]
6541 
6542             then the first bin is ``[1, 2)`` (including 1, but excluding 2) and
6543             the second ``[2, 3)``.  The last bin, however, is ``[3, 4]``, which
6544             *includes* 4.
6545 
6546             If *bins* is a string, it is one of the binning strategies
6547             supported by `numpy.histogram_bin_edges`: 'auto', 'fd', 'doane',
6548             'scott', 'stone', 'rice', 'sturges', or 'sqrt'.
6549 
6550         range : tuple or None, default: None
6551             The lower and upper range of the bins. Lower and upper outliers
6552             are ignored. If not provided, *range* is ``(x.min(), x.max())``.
6553             Range has no effect if *bins* is a sequence.
6554 
6555             If *bins* is a sequence or *range* is specified, autoscaling
6556             is based on the specified bin range instead of the
6557             range of x.
6558 
6559         density : bool, default: False
6560             If ``True``, draw and return a probability density: each bin
6561             will display the bin's raw count divided by the total number of
6562             counts *and the bin width*
6563             (``density = counts / (sum(counts) * np.diff(bins))``),
6564             so that the area under the histogram integrates to 1
6565             (``np.sum(density * np.diff(bins)) == 1``).
6566 
6567             If *stacked* is also ``True``, the sum of the histograms is
6568             normalized to 1.
6569 
6570         weights : (n,) array-like or None, default: None
6571             An array of weights, of the same shape as *x*.  Each value in
6572             *x* only contributes its associated weight towards the bin count
6573             (instead of 1).  If *density* is ``True``, the weights are
6574             normalized, so that the integral of the density over the range
6575             remains 1.
6576 
6577         cumulative : bool or -1, default: False
6578             If ``True``, then a histogram is computed where each bin gives the
6579             counts in that bin plus all bins for smaller values. The last bin
6580             gives the total number of datapoints.
6581 
6582             If *density* is also ``True`` then the histogram is normalized such
6583             that the last bin equals 1.
6584 
6585             If *cumulative* is a number less than 0 (e.g., -1), the direction
6586             of accumulation is reversed.  In this case, if *density* is also
6587             ``True``, then the histogram is normalized such that the first bin
6588             equals 1.
6589 
6590         bottom : array-like, scalar, or None, default: None
6591             Location of the bottom of each bin, i.e. bins are drawn from
6592             ``bottom`` to ``bottom + hist(x, bins)`` If a scalar, the bottom
6593             of each bin is shifted by the same amount. If an array, each bin
6594             is shifted independently and the length of bottom must match the
6595             number of bins. If None, defaults to 0.
6596 
6597         histtype : {'bar', 'barstacked', 'step', 'stepfilled'}, default: 'bar'
6598             The type of histogram to draw.
6599 
6600             - 'bar' is a traditional bar-type histogram.  If multiple data
6601               are given the bars are arranged side by side.
6602             - 'barstacked' is a bar-type histogram where multiple
6603               data are stacked on top of each other.
6604             - 'step' generates a lineplot that is by default unfilled.
6605             - 'stepfilled' generates a lineplot that is by default filled.
6606 
6607         align : {'left', 'mid', 'right'}, default: 'mid'
6608             The horizontal alignment of the histogram bars.
6609 
6610             - 'left': bars are centered on the left bin edges.
6611             - 'mid': bars are centered between the bin edges.
6612             - 'right': bars are centered on the right bin edges.
6613 
6614         orientation : {'vertical', 'horizontal'}, default: 'vertical'
6615             If 'horizontal', `~.Axes.barh` will be used for bar-type histograms
6616             and the *bottom* kwarg will be the left edges.
6617 
6618         rwidth : float or None, default: None
6619             The relative width of the bars as a fraction of the bin width.  If
6620             ``None``, automatically compute the width.
6621 
6622             Ignored if *histtype* is 'step' or 'stepfilled'.
6623 
6624         log : bool, default: False
6625             If ``True``, the histogram axis will be set to a log scale.
6626 
6627         color : color or array-like of colors or None, default: None
6628             Color or sequence of colors, one per dataset.  Default (``None``)
6629             uses the standard line color sequence.
6630 
6631         label : str or None, default: None
6632             String, or sequence of strings to match multiple datasets.  Bar
6633             charts yield multiple patches per dataset, but only the first gets
6634             the label, so that `~.Axes.legend` will work as expected.
6635 
6636         stacked : bool, default: False
6637             If ``True``, multiple data are stacked on top of each other If
6638             ``False`` multiple data are arranged side by side if histtype is
6639             'bar' or on top of each other if histtype is 'step'
6640 
6641         Returns
6642         -------
6643         n : array or list of arrays
6644             The values of the histogram bins. See *density* and *weights* for a
6645             description of the possible semantics.  If input *x* is an array,
6646             then this is an array of length *nbins*. If input is a sequence of
6647             arrays ``[data1, data2, ...]``, then this is a list of arrays with
6648             the values of the histograms for each of the arrays in the same
6649             order.  The dtype of the array *n* (or of its element arrays) will
6650             always be float even if no weighting or normalization is used.
6651 
6652         bins : array
6653             The edges of the bins. Length nbins + 1 (nbins left edges and right
6654             edge of last bin).  Always a single array even when multiple data
6655             sets are passed in.
6656 
6657         patches : `.BarContainer` or list of a single `.Polygon` or list of \
6658 such objects
6659             Container of individual artists used to create the histogram
6660             or list of such containers if there are multiple input datasets.
6661 
6662         Other Parameters
6663         ----------------
6664         data : indexable object, optional
6665             DATA_PARAMETER_PLACEHOLDER
6666 
6667         **kwargs
6668             `~matplotlib.patches.Patch` properties
6669 
6670         See Also
6671         --------
6672         hist2d : 2D histogram with rectangular bins
6673         hexbin : 2D histogram with hexagonal bins
6674 
6675         Notes
6676         -----
6677         For large numbers of bins (>1000), plotting can be significantly faster
6678         if *histtype* is set to 'step' or 'stepfilled' rather than 'bar' or
6679         'barstacked'.
6680         """
6681         # Avoid shadowing the builtin.
6682         bin_range = range
6683         from builtins import range
6684 
6685         if np.isscalar(x):
6686             x = [x]
6687 
6688         if bins is None:
6689             bins = mpl.rcParams['hist.bins']
6690 
6691         # Validate string inputs here to avoid cluttering subsequent code.
6692         _api.check_in_list(['bar', 'barstacked', 'step', 'stepfilled'],
6693                            histtype=histtype)
6694         _api.check_in_list(['left', 'mid', 'right'], align=align)
6695         _api.check_in_list(['horizontal', 'vertical'], orientation=orientation)
6696 
6697         if histtype == 'barstacked' and not stacked:
6698             stacked = True
6699 
6700         # Massage 'x' for processing.
6701         x = cbook._reshape_2D(x, 'x')
6702         nx = len(x)  # number of datasets
6703 
6704         # Process unit information.  _process_unit_info sets the unit and
6705         # converts the first dataset; then we convert each following dataset
6706         # one at a time.
6707         if orientation == "vertical":
6708             convert_units = self.convert_xunits
6709             x = [*self._process_unit_info([("x", x[0])], kwargs),
6710                  *map(convert_units, x[1:])]
6711         else:  # horizontal
6712             convert_units = self.convert_yunits
6713             x = [*self._process_unit_info([("y", x[0])], kwargs),
6714                  *map(convert_units, x[1:])]
6715 
6716         if bin_range is not None:
6717             bin_range = convert_units(bin_range)
6718 
6719         if not cbook.is_scalar_or_string(bins):
6720             bins = convert_units(bins)
6721 
6722         # We need to do to 'weights' what was done to 'x'
6723         if weights is not None:
6724             w = cbook._reshape_2D(weights, 'weights')
6725         else:
6726             w = [None] * nx
6727 
6728         if len(w) != nx:
6729             raise ValueError('weights should have the same shape as x')
6730 
6731         input_empty = True
6732         for xi, wi in zip(x, w):
6733             len_xi = len(xi)
6734             if wi is not None and len(wi) != len_xi:
6735                 raise ValueError('weights should have the same shape as x')
6736             if len_xi:
6737                 input_empty = False
6738 
6739         if color is None:
6740             colors = [self._get_lines.get_next_color() for i in range(nx)]
6741         else:
6742             colors = mcolors.to_rgba_array(color)
6743             if len(colors) != nx:
6744                 raise ValueError(f"The 'color' keyword argument must have one "
6745                                  f"color per dataset, but {nx} datasets and "
6746                                  f"{len(colors)} colors were provided")
6747 
6748         hist_kwargs = dict()
6749 
6750         # if the bin_range is not given, compute without nan numpy
6751         # does not do this for us when guessing the range (but will
6752         # happily ignore nans when computing the histogram).
6753         if bin_range is None:
6754             xmin = np.inf
6755             xmax = -np.inf
6756             for xi in x:
6757                 if len(xi):
6758                     # python's min/max ignore nan,
6759                     # np.minnan returns nan for all nan input
6760                     xmin = min(xmin, np.nanmin(xi))
6761                     xmax = max(xmax, np.nanmax(xi))
6762             if xmin <= xmax:  # Only happens if we have seen a finite value.
6763                 bin_range = (xmin, xmax)
6764 
6765         # If bins are not specified either explicitly or via range,
6766         # we need to figure out the range required for all datasets,
6767         # and supply that to np.histogram.
6768         if not input_empty and len(x) > 1:
6769             if weights is not None:
6770                 _w = np.concatenate(w)
6771             else:
6772                 _w = None
6773             bins = np.histogram_bin_edges(
6774                 np.concatenate(x), bins, bin_range, _w)
6775         else:
6776             hist_kwargs['range'] = bin_range
6777 
6778         density = bool(density)
6779         if density and not stacked:
6780             hist_kwargs['density'] = density
6781 
6782         # List to store all the top coordinates of the histograms
6783         tops = []  # Will have shape (n_datasets, n_bins).
6784         # Loop through datasets
6785         for i in range(nx):
6786             # this will automatically overwrite bins,
6787             # so that each histogram uses the same bins
6788             m, bins = np.histogram(x[i], bins, weights=w[i], **hist_kwargs)
6789             tops.append(m)
6790         tops = np.array(tops, float)  # causes problems later if it's an int
6791         bins = np.array(bins, float)  # causes problems if float16
6792         if stacked:
6793             tops = tops.cumsum(axis=0)
6794             # If a stacked density plot, normalize so the area of all the
6795             # stacked histograms together is 1
6796             if density:
6797                 tops = (tops / np.diff(bins)) / tops[-1].sum()
6798         if cumulative:
6799             slc = slice(None)
6800             if isinstance(cumulative, Number) and cumulative < 0:
6801                 slc = slice(None, None, -1)
6802             if density:
6803                 tops = (tops * np.diff(bins))[:, slc].cumsum(axis=1)[:, slc]
6804             else:
6805                 tops = tops[:, slc].cumsum(axis=1)[:, slc]
6806 
6807         patches = []
6808 
6809         if histtype.startswith('bar'):
6810 
6811             totwidth = np.diff(bins)
6812 
6813             if rwidth is not None:
6814                 dr = np.clip(rwidth, 0, 1)
6815             elif (len(tops) > 1 and
6816                   ((not stacked) or mpl.rcParams['_internal.classic_mode'])):
6817                 dr = 0.8
6818             else:
6819                 dr = 1.0
6820 
6821             if histtype == 'bar' and not stacked:
6822                 width = dr * totwidth / nx
6823                 dw = width
6824                 boffset = -0.5 * dr * totwidth * (1 - 1 / nx)
6825             elif histtype == 'barstacked' or stacked:
6826                 width = dr * totwidth
6827                 boffset, dw = 0.0, 0.0
6828 
6829             if align == 'mid':
6830                 boffset += 0.5 * totwidth
6831             elif align == 'right':
6832                 boffset += totwidth
6833 
6834             if orientation == 'horizontal':
6835                 _barfunc = self.barh
6836                 bottom_kwarg = 'left'
6837             else:  # orientation == 'vertical'
6838                 _barfunc = self.bar
6839                 bottom_kwarg = 'bottom'
6840 
6841             for top, color in zip(tops, colors):
6842                 if bottom is None:
6843                     bottom = np.zeros(len(top))
6844                 if stacked:
6845                     height = top - bottom
6846                 else:
6847                     height = top
6848                 bars = _barfunc(bins[:-1]+boffset, height, width,
6849                                 align='center', log=log,
6850                                 color=color, **{bottom_kwarg: bottom})
6851                 patches.append(bars)
6852                 if stacked:
6853                     bottom = top
6854                 boffset += dw
6855             # Remove stickies from all bars but the lowest ones, as otherwise
6856             # margin expansion would be unable to cross the stickies in the
6857             # middle of the bars.
6858             for bars in patches[1:]:
6859                 for patch in bars:
6860                     patch.sticky_edges.x[:] = patch.sticky_edges.y[:] = []
6861 
6862         elif histtype.startswith('step'):
6863             # these define the perimeter of the polygon
6864             x = np.zeros(4 * len(bins) - 3)
6865             y = np.zeros(4 * len(bins) - 3)
6866 
6867             x[0:2*len(bins)-1:2], x[1:2*len(bins)-1:2] = bins, bins[:-1]
6868             x[2*len(bins)-1:] = x[1:2*len(bins)-1][::-1]
6869 
6870             if bottom is None:
6871                 bottom = 0
6872 
6873             y[1:2*len(bins)-1:2] = y[2:2*len(bins):2] = bottom
6874             y[2*len(bins)-1:] = y[1:2*len(bins)-1][::-1]
6875 
6876             if log:
6877                 if orientation == 'horizontal':
6878                     self.set_xscale('log', nonpositive='clip')
6879                 else:  # orientation == 'vertical'
6880                     self.set_yscale('log', nonpositive='clip')
6881 
6882             if align == 'left':
6883                 x -= 0.5*(bins[1]-bins[0])
6884             elif align == 'right':
6885                 x += 0.5*(bins[1]-bins[0])
6886 
6887             # If fill kwarg is set, it will be passed to the patch collection,
6888             # overriding this
6889             fill = (histtype == 'stepfilled')
6890 
6891             xvals, yvals = [], []
6892             for top in tops:
6893                 if stacked:
6894                     # top of the previous polygon becomes the bottom
6895                     y[2*len(bins)-1:] = y[1:2*len(bins)-1][::-1]
6896                 # set the top of this polygon
6897                 y[1:2*len(bins)-1:2] = y[2:2*len(bins):2] = top + bottom
6898 
6899                 # The starting point of the polygon has not yet been
6900                 # updated. So far only the endpoint was adjusted. This
6901                 # assignment closes the polygon. The redundant endpoint is
6902                 # later discarded (for step and stepfilled).
6903                 y[0] = y[-1]
6904 
6905                 if orientation == 'horizontal':
6906                     xvals.append(y.copy())
6907                     yvals.append(x.copy())
6908                 else:
6909                     xvals.append(x.copy())
6910                     yvals.append(y.copy())
6911 
6912             # stepfill is closed, step is not
6913             split = -1 if fill else 2 * len(bins)
6914             # add patches in reverse order so that when stacking,
6915             # items lower in the stack are plotted on top of
6916             # items higher in the stack
6917             for x, y, color in reversed(list(zip(xvals, yvals, colors))):
6918                 patches.append(self.fill(
6919                     x[:split], y[:split],
6920                     closed=True if fill else None,
6921                     facecolor=color,
6922                     edgecolor=None if fill else color,
6923                     fill=fill if fill else None,
6924                     zorder=None if fill else mlines.Line2D.zorder))
6925             for patch_list in patches:
6926                 for patch in patch_list:
6927                     if orientation == 'vertical':
6928                         patch.sticky_edges.y.append(0)
6929                     elif orientation == 'horizontal':
6930                         patch.sticky_edges.x.append(0)
6931 
6932             # we return patches, so put it back in the expected order
6933             patches.reverse()
6934 
6935         # If None, make all labels None (via zip_longest below); otherwise,
6936         # cast each element to str, but keep a single str as it.
6937         labels = [] if label is None else np.atleast_1d(np.asarray(label, str))
6938         for patch, lbl in itertools.zip_longest(patches, labels):
6939             if patch:
6940                 p = patch[0]
6941                 p._internal_update(kwargs)
6942                 if lbl is not None:
6943                     p.set_label(lbl)
6944                 for p in patch[1:]:
6945                     p._internal_update(kwargs)
6946                     p.set_label('_nolegend_')
6947 
6948         if nx == 1:
6949             return tops[0], bins, patches[0]
6950         else:
6951             patch_type = ("BarContainer" if histtype.startswith("bar")
6952                           else "list[Polygon]")
6953             return tops, bins, cbook.silent_list(patch_type, patches)
6954 
6955     @_preprocess_data()
6956     def stairs(self, values, edges=None, *,
6957                orientation='vertical', baseline=0, fill=False, **kwargs):
6958         """
6959         A stepwise constant function as a line with bounding edges
6960         or a filled plot.
6961 
6962         Parameters
6963         ----------
6964         values : array-like
6965             The step heights.
6966 
6967         edges : array-like
6968             The edge positions, with ``len(edges) == len(vals) + 1``,
6969             between which the curve takes on vals values.
6970 
6971         orientation : {'vertical', 'horizontal'}, default: 'vertical'
6972             The direction of the steps. Vertical means that *values* are along
6973             the y-axis, and edges are along the x-axis.
6974 
6975         baseline : float, array-like or None, default: 0
6976             The bottom value of the bounding edges or when
6977             ``fill=True``, position of lower edge. If *fill* is
6978             True or an array is passed to *baseline*, a closed
6979             path is drawn.
6980 
6981         fill : bool, default: False
6982             Whether the area under the step curve should be filled.
6983 
6984         Returns
6985         -------
6986         StepPatch : `matplotlib.patches.StepPatch`
6987 
6988         Other Parameters
6989         ----------------
6990         data : indexable object, optional
6991             DATA_PARAMETER_PLACEHOLDER
6992 
6993         **kwargs
6994             `~matplotlib.patches.StepPatch` properties
6995 
6996         """
6997 
6998         if 'color' in kwargs:
6999             _color = kwargs.pop('color')
7000         else:
7001             _color = self._get_lines.get_next_color()
7002         if fill:
7003             kwargs.setdefault('linewidth', 0)
7004             kwargs.setdefault('facecolor', _color)
7005         else:
7006             kwargs.setdefault('edgecolor', _color)
7007 
7008         if edges is None:
7009             edges = np.arange(len(values) + 1)
7010 
7011         edges, values, baseline = self._process_unit_info(
7012             [("x", edges), ("y", values), ("y", baseline)], kwargs)
7013 
7014         patch = mpatches.StepPatch(values,
7015                                    edges,
7016                                    baseline=baseline,
7017                                    orientation=orientation,
7018                                    fill=fill,
7019                                    **kwargs)
7020         self.add_patch(patch)
7021         if baseline is None:
7022             baseline = 0
7023         if orientation == 'vertical':
7024             patch.sticky_edges.y.append(np.min(baseline))
7025             self.update_datalim([(edges[0], np.min(baseline))])
7026         else:
7027             patch.sticky_edges.x.append(np.min(baseline))
7028             self.update_datalim([(np.min(baseline), edges[0])])
7029         self._request_autoscale_view()
7030         return patch
7031 
7032     @_preprocess_data(replace_names=["x", "y", "weights"])
7033     @_docstring.dedent_interpd
7034     def hist2d(self, x, y, bins=10, range=None, density=False, weights=None,
7035                cmin=None, cmax=None, **kwargs):
7036         """
7037         Make a 2D histogram plot.
7038 
7039         Parameters
7040         ----------
7041         x, y : array-like, shape (n, )
7042             Input values
7043 
7044         bins : None or int or [int, int] or array-like or [array, array]
7045 
7046             The bin specification:
7047 
7048             - If int, the number of bins for the two dimensions
7049               (nx=ny=bins).
7050             - If ``[int, int]``, the number of bins in each dimension
7051               (nx, ny = bins).
7052             - If array-like, the bin edges for the two dimensions
7053               (x_edges=y_edges=bins).
7054             - If ``[array, array]``, the bin edges in each dimension
7055               (x_edges, y_edges = bins).
7056 
7057             The default value is 10.
7058 
7059         range : array-like shape(2, 2), optional
7060             The leftmost and rightmost edges of the bins along each dimension
7061             (if not specified explicitly in the bins parameters): ``[[xmin,
7062             xmax], [ymin, ymax]]``. All values outside of this range will be
7063             considered outliers and not tallied in the histogram.
7064 
7065         density : bool, default: False
7066             Normalize histogram.  See the documentation for the *density*
7067             parameter of `~.Axes.hist` for more details.
7068 
7069         weights : array-like, shape (n, ), optional
7070             An array of values w_i weighing each sample (x_i, y_i).
7071 
7072         cmin, cmax : float, default: None
7073             All bins that has count less than *cmin* or more than *cmax* will
7074             not be displayed (set to NaN before passing to imshow) and these
7075             count values in the return value count histogram will also be set
7076             to nan upon return.
7077 
7078         Returns
7079         -------
7080         h : 2D array
7081             The bi-dimensional histogram of samples x and y. Values in x are
7082             histogrammed along the first dimension and values in y are
7083             histogrammed along the second dimension.
7084         xedges : 1D array
7085             The bin edges along the x-axis.
7086         yedges : 1D array
7087             The bin edges along the y-axis.
7088         image : `~.matplotlib.collections.QuadMesh`
7089 
7090         Other Parameters
7091         ----------------
7092         %(cmap_doc)s
7093 
7094         %(norm_doc)s
7095 
7096         %(vmin_vmax_doc)s
7097 
7098         alpha : ``0 <= scalar <= 1`` or ``None``, optional
7099             The alpha blending value.
7100 
7101         data : indexable object, optional
7102             DATA_PARAMETER_PLACEHOLDER
7103 
7104         **kwargs
7105             Additional parameters are passed along to the
7106             `~.Axes.pcolormesh` method and `~matplotlib.collections.QuadMesh`
7107             constructor.
7108 
7109         See Also
7110         --------
7111         hist : 1D histogram plotting
7112         hexbin : 2D histogram with hexagonal bins
7113 
7114         Notes
7115         -----
7116         - Currently ``hist2d`` calculates its own axis limits, and any limits
7117           previously set are ignored.
7118         - Rendering the histogram with a logarithmic color scale is
7119           accomplished by passing a `.colors.LogNorm` instance to the *norm*
7120           keyword argument. Likewise, power-law normalization (similar
7121           in effect to gamma correction) can be accomplished with
7122           `.colors.PowerNorm`.
7123         """
7124 
7125         h, xedges, yedges = np.histogram2d(x, y, bins=bins, range=range,
7126                                            density=density, weights=weights)
7127 
7128         if cmin is not None:
7129             h[h < cmin] = None
7130         if cmax is not None:
7131             h[h > cmax] = None
7132 
7133         pc = self.pcolormesh(xedges, yedges, h.T, **kwargs)
7134         self.set_xlim(xedges[0], xedges[-1])
7135         self.set_ylim(yedges[0], yedges[-1])
7136 
7137         return h, xedges, yedges, pc
7138 
7139     @_preprocess_data(replace_names=["x"])
7140     @_docstring.dedent_interpd
7141     def psd(self, x, NFFT=None, Fs=None, Fc=None, detrend=None,
7142             window=None, noverlap=None, pad_to=None,
7143             sides=None, scale_by_freq=None, return_line=None, **kwargs):
7144         r"""
7145         Plot the power spectral density.
7146 
7147         The power spectral density :math:`P_{xx}` by Welch's average
7148         periodogram method.  The vector *x* is divided into *NFFT* length
7149         segments.  Each segment is detrended by function *detrend* and
7150         windowed by function *window*.  *noverlap* gives the length of
7151         the overlap between segments.  The :math:`|\mathrm{fft}(i)|^2`
7152         of each segment :math:`i` are averaged to compute :math:`P_{xx}`,
7153         with a scaling to correct for power loss due to windowing.
7154 
7155         If len(*x*) < *NFFT*, it will be zero padded to *NFFT*.
7156 
7157         Parameters
7158         ----------
7159         x : 1-D array or sequence
7160             Array or sequence containing the data
7161 
7162         %(Spectral)s
7163 
7164         %(PSD)s
7165 
7166         noverlap : int, default: 0 (no overlap)
7167             The number of points of overlap between segments.
7168 
7169         Fc : int, default: 0
7170             The center frequency of *x*, which offsets the x extents of the
7171             plot to reflect the frequency range used when a signal is acquired
7172             and then filtered and downsampled to baseband.
7173 
7174         return_line : bool, default: False
7175             Whether to include the line object plotted in the returned values.
7176 
7177         Returns
7178         -------
7179         Pxx : 1-D array
7180             The values for the power spectrum :math:`P_{xx}` before scaling
7181             (real valued).
7182 
7183         freqs : 1-D array
7184             The frequencies corresponding to the elements in *Pxx*.
7185 
7186         line : `~matplotlib.lines.Line2D`
7187             The line created by this function.
7188             Only returned if *return_line* is True.
7189 
7190         Other Parameters
7191         ----------------
7192         data : indexable object, optional
7193             DATA_PARAMETER_PLACEHOLDER
7194 
7195         **kwargs
7196             Keyword arguments control the `.Line2D` properties:
7197 
7198             %(Line2D:kwdoc)s
7199 
7200         See Also
7201         --------
7202         specgram
7203             Differs in the default overlap; in not returning the mean of the
7204             segment periodograms; in returning the times of the segments; and
7205             in plotting a colormap instead of a line.
7206         magnitude_spectrum
7207             Plots the magnitude spectrum.
7208         csd
7209             Plots the spectral density between two signals.
7210 
7211         Notes
7212         -----
7213         For plotting, the power is plotted as
7214         :math:`10\log_{10}(P_{xx})` for decibels, though *Pxx* itself
7215         is returned.
7216 
7217         References
7218         ----------
7219         Bendat & Piersol -- Random Data: Analysis and Measurement Procedures,
7220         John Wiley & Sons (1986)
7221         """
7222         if Fc is None:
7223             Fc = 0
7224 
7225         pxx, freqs = mlab.psd(x=x, NFFT=NFFT, Fs=Fs, detrend=detrend,
7226                               window=window, noverlap=noverlap, pad_to=pad_to,
7227                               sides=sides, scale_by_freq=scale_by_freq)
7228         freqs += Fc
7229 
7230         if scale_by_freq in (None, True):
7231             psd_units = 'dB/Hz'
7232         else:
7233             psd_units = 'dB'
7234 
7235         line = self.plot(freqs, 10 * np.log10(pxx), **kwargs)
7236         self.set_xlabel('Frequency')
7237         self.set_ylabel('Power Spectral Density (%s)' % psd_units)
7238         self.grid(True)
7239 
7240         vmin, vmax = self.get_ybound()
7241         step = max(10 * int(np.log10(vmax - vmin)), 1)
7242         ticks = np.arange(math.floor(vmin), math.ceil(vmax) + 1, step)
7243         self.set_yticks(ticks)
7244 
7245         if return_line is None or not return_line:
7246             return pxx, freqs
7247         else:
7248             return pxx, freqs, line
7249 
7250     @_preprocess_data(replace_names=["x", "y"], label_namer="y")
7251     @_docstring.dedent_interpd
7252     def csd(self, x, y, NFFT=None, Fs=None, Fc=None, detrend=None,
7253             window=None, noverlap=None, pad_to=None,
7254             sides=None, scale_by_freq=None, return_line=None, **kwargs):
7255         r"""
7256         Plot the cross-spectral density.
7257 
7258         The cross spectral density :math:`P_{xy}` by Welch's average
7259         periodogram method.  The vectors *x* and *y* are divided into
7260         *NFFT* length segments.  Each segment is detrended by function
7261         *detrend* and windowed by function *window*.  *noverlap* gives
7262         the length of the overlap between segments.  The product of
7263         the direct FFTs of *x* and *y* are averaged over each segment
7264         to compute :math:`P_{xy}`, with a scaling to correct for power
7265         loss due to windowing.
7266 
7267         If len(*x*) < *NFFT* or len(*y*) < *NFFT*, they will be zero
7268         padded to *NFFT*.
7269 
7270         Parameters
7271         ----------
7272         x, y : 1-D arrays or sequences
7273             Arrays or sequences containing the data.
7274 
7275         %(Spectral)s
7276 
7277         %(PSD)s
7278 
7279         noverlap : int, default: 0 (no overlap)
7280             The number of points of overlap between segments.
7281 
7282         Fc : int, default: 0
7283             The center frequency of *x*, which offsets the x extents of the
7284             plot to reflect the frequency range used when a signal is acquired
7285             and then filtered and downsampled to baseband.
7286 
7287         return_line : bool, default: False
7288             Whether to include the line object plotted in the returned values.
7289 
7290         Returns
7291         -------
7292         Pxy : 1-D array
7293             The values for the cross spectrum :math:`P_{xy}` before scaling
7294             (complex valued).
7295 
7296         freqs : 1-D array
7297             The frequencies corresponding to the elements in *Pxy*.
7298 
7299         line : `~matplotlib.lines.Line2D`
7300             The line created by this function.
7301             Only returned if *return_line* is True.
7302 
7303         Other Parameters
7304         ----------------
7305         data : indexable object, optional
7306             DATA_PARAMETER_PLACEHOLDER
7307 
7308         **kwargs
7309             Keyword arguments control the `.Line2D` properties:
7310 
7311             %(Line2D:kwdoc)s
7312 
7313         See Also
7314         --------
7315         psd : is equivalent to setting ``y = x``.
7316 
7317         Notes
7318         -----
7319         For plotting, the power is plotted as
7320         :math:`10 \log_{10}(P_{xy})` for decibels, though :math:`P_{xy}` itself
7321         is returned.
7322 
7323         References
7324         ----------
7325         Bendat & Piersol -- Random Data: Analysis and Measurement Procedures,
7326         John Wiley & Sons (1986)
7327         """
7328         if Fc is None:
7329             Fc = 0
7330 
7331         pxy, freqs = mlab.csd(x=x, y=y, NFFT=NFFT, Fs=Fs, detrend=detrend,
7332                               window=window, noverlap=noverlap, pad_to=pad_to,
7333                               sides=sides, scale_by_freq=scale_by_freq)
7334         # pxy is complex
7335         freqs += Fc
7336 
7337         line = self.plot(freqs, 10 * np.log10(np.abs(pxy)), **kwargs)
7338         self.set_xlabel('Frequency')
7339         self.set_ylabel('Cross Spectrum Magnitude (dB)')
7340         self.grid(True)
7341 
7342         vmin, vmax = self.get_ybound()
7343         step = max(10 * int(np.log10(vmax - vmin)), 1)
7344         ticks = np.arange(math.floor(vmin), math.ceil(vmax) + 1, step)
7345         self.set_yticks(ticks)
7346 
7347         if return_line is None or not return_line:
7348             return pxy, freqs
7349         else:
7350             return pxy, freqs, line
7351 
7352     @_preprocess_data(replace_names=["x"])
7353     @_docstring.dedent_interpd
7354     def magnitude_spectrum(self, x, Fs=None, Fc=None, window=None,
7355                            pad_to=None, sides=None, scale=None,
7356                            **kwargs):
7357         """
7358         Plot the magnitude spectrum.
7359 
7360         Compute the magnitude spectrum of *x*.  Data is padded to a
7361         length of *pad_to* and the windowing function *window* is applied to
7362         the signal.
7363 
7364         Parameters
7365         ----------
7366         x : 1-D array or sequence
7367             Array or sequence containing the data.
7368 
7369         %(Spectral)s
7370 
7371         %(Single_Spectrum)s
7372 
7373         scale : {'default', 'linear', 'dB'}
7374             The scaling of the values in the *spec*.  'linear' is no scaling.
7375             'dB' returns the values in dB scale, i.e., the dB amplitude
7376             (20 * log10). 'default' is 'linear'.
7377 
7378         Fc : int, default: 0
7379             The center frequency of *x*, which offsets the x extents of the
7380             plot to reflect the frequency range used when a signal is acquired
7381             and then filtered and downsampled to baseband.
7382 
7383         Returns
7384         -------
7385         spectrum : 1-D array
7386             The values for the magnitude spectrum before scaling (real valued).
7387 
7388         freqs : 1-D array
7389             The frequencies corresponding to the elements in *spectrum*.
7390 
7391         line : `~matplotlib.lines.Line2D`
7392             The line created by this function.
7393 
7394         Other Parameters
7395         ----------------
7396         data : indexable object, optional
7397             DATA_PARAMETER_PLACEHOLDER
7398 
7399         **kwargs
7400             Keyword arguments control the `.Line2D` properties:
7401 
7402             %(Line2D:kwdoc)s
7403 
7404         See Also
7405         --------
7406         psd
7407             Plots the power spectral density.
7408         angle_spectrum
7409             Plots the angles of the corresponding frequencies.
7410         phase_spectrum
7411             Plots the phase (unwrapped angle) of the corresponding frequencies.
7412         specgram
7413             Can plot the magnitude spectrum of segments within the signal in a
7414             colormap.
7415         """
7416         if Fc is None:
7417             Fc = 0
7418 
7419         spec, freqs = mlab.magnitude_spectrum(x=x, Fs=Fs, window=window,
7420                                               pad_to=pad_to, sides=sides)
7421         freqs += Fc
7422 
7423         yunits = _api.check_getitem(
7424             {None: 'energy', 'default': 'energy', 'linear': 'energy',
7425              'dB': 'dB'},
7426             scale=scale)
7427         if yunits == 'energy':
7428             Z = spec
7429         else:  # yunits == 'dB'
7430             Z = 20. * np.log10(spec)
7431 
7432         line, = self.plot(freqs, Z, **kwargs)
7433         self.set_xlabel('Frequency')
7434         self.set_ylabel('Magnitude (%s)' % yunits)
7435 
7436         return spec, freqs, line
7437 
7438     @_preprocess_data(replace_names=["x"])
7439     @_docstring.dedent_interpd
7440     def angle_spectrum(self, x, Fs=None, Fc=None, window=None,
7441                        pad_to=None, sides=None, **kwargs):
7442         """
7443         Plot the angle spectrum.
7444 
7445         Compute the angle spectrum (wrapped phase spectrum) of *x*.
7446         Data is padded to a length of *pad_to* and the windowing function
7447         *window* is applied to the signal.
7448 
7449         Parameters
7450         ----------
7451         x : 1-D array or sequence
7452             Array or sequence containing the data.
7453 
7454         %(Spectral)s
7455 
7456         %(Single_Spectrum)s
7457 
7458         Fc : int, default: 0
7459             The center frequency of *x*, which offsets the x extents of the
7460             plot to reflect the frequency range used when a signal is acquired
7461             and then filtered and downsampled to baseband.
7462 
7463         Returns
7464         -------
7465         spectrum : 1-D array
7466             The values for the angle spectrum in radians (real valued).
7467 
7468         freqs : 1-D array
7469             The frequencies corresponding to the elements in *spectrum*.
7470 
7471         line : `~matplotlib.lines.Line2D`
7472             The line created by this function.
7473 
7474         Other Parameters
7475         ----------------
7476         data : indexable object, optional
7477             DATA_PARAMETER_PLACEHOLDER
7478 
7479         **kwargs
7480             Keyword arguments control the `.Line2D` properties:
7481 
7482             %(Line2D:kwdoc)s
7483 
7484         See Also
7485         --------
7486         magnitude_spectrum
7487             Plots the magnitudes of the corresponding frequencies.
7488         phase_spectrum
7489             Plots the unwrapped version of this function.
7490         specgram
7491             Can plot the angle spectrum of segments within the signal in a
7492             colormap.
7493         """
7494         if Fc is None:
7495             Fc = 0
7496 
7497         spec, freqs = mlab.angle_spectrum(x=x, Fs=Fs, window=window,
7498                                           pad_to=pad_to, sides=sides)
7499         freqs += Fc
7500 
7501         lines = self.plot(freqs, spec, **kwargs)
7502         self.set_xlabel('Frequency')
7503         self.set_ylabel('Angle (radians)')
7504 
7505         return spec, freqs, lines[0]
7506 
7507     @_preprocess_data(replace_names=["x"])
7508     @_docstring.dedent_interpd
7509     def phase_spectrum(self, x, Fs=None, Fc=None, window=None,
7510                        pad_to=None, sides=None, **kwargs):
7511         """
7512         Plot the phase spectrum.
7513 
7514         Compute the phase spectrum (unwrapped angle spectrum) of *x*.
7515         Data is padded to a length of *pad_to* and the windowing function
7516         *window* is applied to the signal.
7517 
7518         Parameters
7519         ----------
7520         x : 1-D array or sequence
7521             Array or sequence containing the data
7522 
7523         %(Spectral)s
7524 
7525         %(Single_Spectrum)s
7526 
7527         Fc : int, default: 0
7528             The center frequency of *x*, which offsets the x extents of the
7529             plot to reflect the frequency range used when a signal is acquired
7530             and then filtered and downsampled to baseband.
7531 
7532         Returns
7533         -------
7534         spectrum : 1-D array
7535             The values for the phase spectrum in radians (real valued).
7536 
7537         freqs : 1-D array
7538             The frequencies corresponding to the elements in *spectrum*.
7539 
7540         line : `~matplotlib.lines.Line2D`
7541             The line created by this function.
7542 
7543         Other Parameters
7544         ----------------
7545         data : indexable object, optional
7546             DATA_PARAMETER_PLACEHOLDER
7547 
7548         **kwargs
7549             Keyword arguments control the `.Line2D` properties:
7550 
7551             %(Line2D:kwdoc)s
7552 
7553         See Also
7554         --------
7555         magnitude_spectrum
7556             Plots the magnitudes of the corresponding frequencies.
7557         angle_spectrum
7558             Plots the wrapped version of this function.
7559         specgram
7560             Can plot the phase spectrum of segments within the signal in a
7561             colormap.
7562         """
7563         if Fc is None:
7564             Fc = 0
7565 
7566         spec, freqs = mlab.phase_spectrum(x=x, Fs=Fs, window=window,
7567                                           pad_to=pad_to, sides=sides)
7568         freqs += Fc
7569 
7570         lines = self.plot(freqs, spec, **kwargs)
7571         self.set_xlabel('Frequency')
7572         self.set_ylabel('Phase (radians)')
7573 
7574         return spec, freqs, lines[0]
7575 
7576     @_preprocess_data(replace_names=["x", "y"])
7577     @_docstring.dedent_interpd
7578     def cohere(self, x, y, NFFT=256, Fs=2, Fc=0, detrend=mlab.detrend_none,
7579                window=mlab.window_hanning, noverlap=0, pad_to=None,
7580                sides='default', scale_by_freq=None, **kwargs):
7581         r"""
7582         Plot the coherence between *x* and *y*.
7583 
7584         Coherence is the normalized cross spectral density:
7585 
7586         .. math::
7587 
7588           C_{xy} = \frac{|P_{xy}|^2}{P_{xx}P_{yy}}
7589 
7590         Parameters
7591         ----------
7592         %(Spectral)s
7593 
7594         %(PSD)s
7595 
7596         noverlap : int, default: 0 (no overlap)
7597             The number of points of overlap between blocks.
7598 
7599         Fc : int, default: 0
7600             The center frequency of *x*, which offsets the x extents of the
7601             plot to reflect the frequency range used when a signal is acquired
7602             and then filtered and downsampled to baseband.
7603 
7604         Returns
7605         -------
7606         Cxy : 1-D array
7607             The coherence vector.
7608 
7609         freqs : 1-D array
7610             The frequencies for the elements in *Cxy*.
7611 
7612         Other Parameters
7613         ----------------
7614         data : indexable object, optional
7615             DATA_PARAMETER_PLACEHOLDER
7616 
7617         **kwargs
7618             Keyword arguments control the `.Line2D` properties:
7619 
7620             %(Line2D:kwdoc)s
7621 
7622         References
7623         ----------
7624         Bendat & Piersol -- Random Data: Analysis and Measurement Procedures,
7625         John Wiley & Sons (1986)
7626         """
7627         cxy, freqs = mlab.cohere(x=x, y=y, NFFT=NFFT, Fs=Fs, detrend=detrend,
7628                                  window=window, noverlap=noverlap,
7629                                  scale_by_freq=scale_by_freq, sides=sides,
7630                                  pad_to=pad_to)
7631         freqs += Fc
7632 
7633         self.plot(freqs, cxy, **kwargs)
7634         self.set_xlabel('Frequency')
7635         self.set_ylabel('Coherence')
7636         self.grid(True)
7637 
7638         return cxy, freqs
7639 
7640     @_preprocess_data(replace_names=["x"])
7641     @_docstring.dedent_interpd
7642     def specgram(self, x, NFFT=None, Fs=None, Fc=None, detrend=None,
7643                  window=None, noverlap=None,
7644                  cmap=None, xextent=None, pad_to=None, sides=None,
7645                  scale_by_freq=None, mode=None, scale=None,
7646                  vmin=None, vmax=None, **kwargs):
7647         """
7648         Plot a spectrogram.
7649 
7650         Compute and plot a spectrogram of data in *x*.  Data are split into
7651         *NFFT* length segments and the spectrum of each section is
7652         computed.  The windowing function *window* is applied to each
7653         segment, and the amount of overlap of each segment is
7654         specified with *noverlap*. The spectrogram is plotted as a colormap
7655         (using imshow).
7656 
7657         Parameters
7658         ----------
7659         x : 1-D array or sequence
7660             Array or sequence containing the data.
7661 
7662         %(Spectral)s
7663 
7664         %(PSD)s
7665 
7666         mode : {'default', 'psd', 'magnitude', 'angle', 'phase'}
7667             What sort of spectrum to use.  Default is 'psd', which takes the
7668             power spectral density.  'magnitude' returns the magnitude
7669             spectrum.  'angle' returns the phase spectrum without unwrapping.
7670             'phase' returns the phase spectrum with unwrapping.
7671 
7672         noverlap : int, default: 128
7673             The number of points of overlap between blocks.
7674 
7675         scale : {'default', 'linear', 'dB'}
7676             The scaling of the values in the *spec*.  'linear' is no scaling.
7677             'dB' returns the values in dB scale.  When *mode* is 'psd',
7678             this is dB power (10 * log10).  Otherwise, this is dB amplitude
7679             (20 * log10). 'default' is 'dB' if *mode* is 'psd' or
7680             'magnitude' and 'linear' otherwise.  This must be 'linear'
7681             if *mode* is 'angle' or 'phase'.
7682 
7683         Fc : int, default: 0
7684             The center frequency of *x*, which offsets the x extents of the
7685             plot to reflect the frequency range used when a signal is acquired
7686             and then filtered and downsampled to baseband.
7687 
7688         cmap : `.Colormap`, default: :rc:`image.cmap`
7689 
7690         xextent : *None* or (xmin, xmax)
7691             The image extent along the x-axis. The default sets *xmin* to the
7692             left border of the first bin (*spectrum* column) and *xmax* to the
7693             right border of the last bin. Note that for *noverlap>0* the width
7694             of the bins is smaller than those of the segments.
7695 
7696         data : indexable object, optional
7697             DATA_PARAMETER_PLACEHOLDER
7698 
7699         **kwargs
7700             Additional keyword arguments are passed on to `~.axes.Axes.imshow`
7701             which makes the specgram image. The origin keyword argument
7702             is not supported.
7703 
7704         Returns
7705         -------
7706         spectrum : 2D array
7707             Columns are the periodograms of successive segments.
7708 
7709         freqs : 1-D array
7710             The frequencies corresponding to the rows in *spectrum*.
7711 
7712         t : 1-D array
7713             The times corresponding to midpoints of segments (i.e., the columns
7714             in *spectrum*).
7715 
7716         im : `.AxesImage`
7717             The image created by imshow containing the spectrogram.
7718 
7719         See Also
7720         --------
7721         psd
7722             Differs in the default overlap; in returning the mean of the
7723             segment periodograms; in not returning times; and in generating a
7724             line plot instead of colormap.
7725         magnitude_spectrum
7726             A single spectrum, similar to having a single segment when *mode*
7727             is 'magnitude'. Plots a line instead of a colormap.
7728         angle_spectrum
7729             A single spectrum, similar to having a single segment when *mode*
7730             is 'angle'. Plots a line instead of a colormap.
7731         phase_spectrum
7732             A single spectrum, similar to having a single segment when *mode*
7733             is 'phase'. Plots a line instead of a colormap.
7734 
7735         Notes
7736         -----
7737         The parameters *detrend* and *scale_by_freq* do only apply when *mode*
7738         is set to 'psd'.
7739         """
7740         if NFFT is None:
7741             NFFT = 256  # same default as in mlab.specgram()
7742         if Fc is None:
7743             Fc = 0  # same default as in mlab._spectral_helper()
7744         if noverlap is None:
7745             noverlap = 128  # same default as in mlab.specgram()
7746         if Fs is None:
7747             Fs = 2  # same default as in mlab._spectral_helper()
7748 
7749         if mode == 'complex':
7750             raise ValueError('Cannot plot a complex specgram')
7751 
7752         if scale is None or scale == 'default':
7753             if mode in ['angle', 'phase']:
7754                 scale = 'linear'
7755             else:
7756                 scale = 'dB'
7757         elif mode in ['angle', 'phase'] and scale == 'dB':
7758             raise ValueError('Cannot use dB scale with angle or phase mode')
7759 
7760         spec, freqs, t = mlab.specgram(x=x, NFFT=NFFT, Fs=Fs,
7761                                        detrend=detrend, window=window,
7762                                        noverlap=noverlap, pad_to=pad_to,
7763                                        sides=sides,
7764                                        scale_by_freq=scale_by_freq,
7765                                        mode=mode)
7766 
7767         if scale == 'linear':
7768             Z = spec
7769         elif scale == 'dB':
7770             if mode is None or mode == 'default' or mode == 'psd':
7771                 Z = 10. * np.log10(spec)
7772             else:
7773                 Z = 20. * np.log10(spec)
7774         else:
7775             raise ValueError(f'Unknown scale {scale!r}')
7776 
7777         Z = np.flipud(Z)
7778 
7779         if xextent is None:
7780             # padding is needed for first and last segment:
7781             pad_xextent = (NFFT-noverlap) / Fs / 2
7782             xextent = np.min(t) - pad_xextent, np.max(t) + pad_xextent
7783         xmin, xmax = xextent
7784         freqs += Fc
7785         extent = xmin, xmax, freqs[0], freqs[-1]
7786 
7787         if 'origin' in kwargs:
7788             raise _api.kwarg_error("specgram", "origin")
7789 
7790         im = self.imshow(Z, cmap, extent=extent, vmin=vmin, vmax=vmax,
7791                          origin='upper', **kwargs)
7792         self.axis('auto')
7793 
7794         return spec, freqs, t, im
7795 
7796     @_docstring.dedent_interpd
7797     def spy(self, Z, precision=0, marker=None, markersize=None,
7798             aspect='equal', origin="upper", **kwargs):
7799         """
7800         Plot the sparsity pattern of a 2D array.
7801 
7802         This visualizes the non-zero values of the array.
7803 
7804         Two plotting styles are available: image and marker. Both
7805         are available for full arrays, but only the marker style
7806         works for `scipy.sparse.spmatrix` instances.
7807 
7808         **Image style**
7809 
7810         If *marker* and *markersize* are *None*, `~.Axes.imshow` is used. Any
7811         extra remaining keyword arguments are passed to this method.
7812 
7813         **Marker style**
7814 
7815         If *Z* is a `scipy.sparse.spmatrix` or *marker* or *markersize* are
7816         *None*, a `.Line2D` object will be returned with the value of marker
7817         determining the marker type, and any remaining keyword arguments
7818         passed to `~.Axes.plot`.
7819 
7820         Parameters
7821         ----------
7822         Z : (M, N) array-like
7823             The array to be plotted.
7824 
7825         precision : float or 'present', default: 0
7826             If *precision* is 0, any non-zero value will be plotted. Otherwise,
7827             values of :math:`|Z| > precision` will be plotted.
7828 
7829             For `scipy.sparse.spmatrix` instances, you can also
7830             pass 'present'. In this case any value present in the array
7831             will be plotted, even if it is identically zero.
7832 
7833         aspect : {'equal', 'auto', None} or float, default: 'equal'
7834             The aspect ratio of the Axes.  This parameter is particularly
7835             relevant for images since it determines whether data pixels are
7836             square.
7837 
7838             This parameter is a shortcut for explicitly calling
7839             `.Axes.set_aspect`. See there for further details.
7840 
7841             - 'equal': Ensures an aspect ratio of 1. Pixels will be square.
7842             - 'auto': The Axes is kept fixed and the aspect is adjusted so
7843               that the data fit in the Axes. In general, this will result in
7844               non-square pixels.
7845             - *None*: Use :rc:`image.aspect`.
7846 
7847         origin : {'upper', 'lower'}, default: :rc:`image.origin`
7848             Place the [0, 0] index of the array in the upper left or lower left
7849             corner of the Axes. The convention 'upper' is typically used for
7850             matrices and images.
7851 
7852         Returns
7853         -------
7854         `~matplotlib.image.AxesImage` or `.Line2D`
7855             The return type depends on the plotting style (see above).
7856 
7857         Other Parameters
7858         ----------------
7859         **kwargs
7860             The supported additional parameters depend on the plotting style.
7861 
7862             For the image style, you can pass the following additional
7863             parameters of `~.Axes.imshow`:
7864 
7865             - *cmap*
7866             - *alpha*
7867             - *url*
7868             - any `.Artist` properties (passed on to the `.AxesImage`)
7869 
7870             For the marker style, you can pass any `.Line2D` property except
7871             for *linestyle*:
7872 
7873             %(Line2D:kwdoc)s
7874         """
7875         if marker is None and markersize is None and hasattr(Z, 'tocoo'):
7876             marker = 's'
7877         _api.check_in_list(["upper", "lower"], origin=origin)
7878         if marker is None and markersize is None:
7879             Z = np.asarray(Z)
7880             mask = np.abs(Z) > precision
7881 
7882             if 'cmap' not in kwargs:
7883                 kwargs['cmap'] = mcolors.ListedColormap(['w', 'k'],
7884                                                         name='binary')
7885             if 'interpolation' in kwargs:
7886                 raise _api.kwarg_error("spy", "interpolation")
7887             if 'norm' not in kwargs:
7888                 kwargs['norm'] = mcolors.NoNorm()
7889             ret = self.imshow(mask, interpolation='nearest',
7890                               aspect=aspect, origin=origin,
7891                               **kwargs)
7892         else:
7893             if hasattr(Z, 'tocoo'):
7894                 c = Z.tocoo()
7895                 if precision == 'present':
7896                     y = c.row
7897                     x = c.col
7898                 else:
7899                     nonzero = np.abs(c.data) > precision
7900                     y = c.row[nonzero]
7901                     x = c.col[nonzero]
7902             else:
7903                 Z = np.asarray(Z)
7904                 nonzero = np.abs(Z) > precision
7905                 y, x = np.nonzero(nonzero)
7906             if marker is None:
7907                 marker = 's'
7908             if markersize is None:
7909                 markersize = 10
7910             if 'linestyle' in kwargs:
7911                 raise _api.kwarg_error("spy", "linestyle")
7912             ret = mlines.Line2D(
7913                 x, y, linestyle='None', marker=marker, markersize=markersize,
7914                 **kwargs)
7915             self.add_line(ret)
7916             nr, nc = Z.shape
7917             self.set_xlim(-0.5, nc - 0.5)
7918             if origin == "upper":
7919                 self.set_ylim(nr - 0.5, -0.5)
7920             else:
7921                 self.set_ylim(-0.5, nr - 0.5)
7922             self.set_aspect(aspect)
7923         self.title.set_y(1.05)
7924         if origin == "upper":
7925             self.xaxis.tick_top()
7926         else:  # lower
7927             self.xaxis.tick_bottom()
7928         self.xaxis.set_ticks_position('both')
7929         self.xaxis.set_major_locator(
7930             mticker.MaxNLocator(nbins=9, steps=[1, 2, 5, 10], integer=True))
7931         self.yaxis.set_major_locator(
7932             mticker.MaxNLocator(nbins=9, steps=[1, 2, 5, 10], integer=True))
7933         return ret
7934 
7935     def matshow(self, Z, **kwargs):
7936         """
7937         Plot the values of a 2D matrix or array as color-coded image.
7938 
7939         The matrix will be shown the way it would be printed, with the first
7940         row at the top.  Row and column numbering is zero-based.
7941 
7942         Parameters
7943         ----------
7944         Z : (M, N) array-like
7945             The matrix to be displayed.
7946 
7947         Returns
7948         -------
7949         `~matplotlib.image.AxesImage`
7950 
7951         Other Parameters
7952         ----------------
7953         **kwargs : `~matplotlib.axes.Axes.imshow` arguments
7954 
7955         See Also
7956         --------
7957         imshow : More general function to plot data on a 2D regular raster.
7958 
7959         Notes
7960         -----
7961         This is just a convenience function wrapping `.imshow` to set useful
7962         defaults for displaying a matrix. In particular:
7963 
7964         - Set ``origin='upper'``.
7965         - Set ``interpolation='nearest'``.
7966         - Set ``aspect='equal'``.
7967         - Ticks are placed to the left and above.
7968         - Ticks are formatted to show integer indices.
7969 
7970         """
7971         Z = np.asanyarray(Z)
7972         kw = {'origin': 'upper',
7973               'interpolation': 'nearest',
7974               'aspect': 'equal',          # (already the imshow default)
7975               **kwargs}
7976         im = self.imshow(Z, **kw)
7977         self.title.set_y(1.05)
7978         self.xaxis.tick_top()
7979         self.xaxis.set_ticks_position('both')
7980         self.xaxis.set_major_locator(
7981             mticker.MaxNLocator(nbins=9, steps=[1, 2, 5, 10], integer=True))
7982         self.yaxis.set_major_locator(
7983             mticker.MaxNLocator(nbins=9, steps=[1, 2, 5, 10], integer=True))
7984         return im
7985 
7986     @_preprocess_data(replace_names=["dataset"])
7987     def violinplot(self, dataset, positions=None, vert=True, widths=0.5,
7988                    showmeans=False, showextrema=True, showmedians=False,
7989                    quantiles=None, points=100, bw_method=None):
7990         """
7991         Make a violin plot.
7992 
7993         Make a violin plot for each column of *dataset* or each vector in
7994         sequence *dataset*.  Each filled area extends to represent the
7995         entire data range, with optional lines at the mean, the median,
7996         the minimum, the maximum, and user-specified quantiles.
7997 
7998         Parameters
7999         ----------
8000         dataset : Array or a sequence of vectors.
8001           The input data.
8002 
8003         positions : array-like, default: [1, 2, ..., n]
8004           The positions of the violins. The ticks and limits are
8005           automatically set to match the positions.
8006 
8007         vert : bool, default: True.
8008           If true, creates a vertical violin plot.
8009           Otherwise, creates a horizontal violin plot.
8010 
8011         widths : array-like, default: 0.5
8012           Either a scalar or a vector that sets the maximal width of
8013           each violin. The default is 0.5, which uses about half of the
8014           available horizontal space.
8015 
8016         showmeans : bool, default: False
8017           If `True`, will toggle rendering of the means.
8018 
8019         showextrema : bool, default: True
8020           If `True`, will toggle rendering of the extrema.
8021 
8022         showmedians : bool, default: False
8023           If `True`, will toggle rendering of the medians.
8024 
8025         quantiles : array-like, default: None
8026           If not None, set a list of floats in interval [0, 1] for each violin,
8027           which stands for the quantiles that will be rendered for that
8028           violin.
8029 
8030         points : int, default: 100
8031           Defines the number of points to evaluate each of the
8032           gaussian kernel density estimations at.
8033 
8034         bw_method : str, scalar or callable, optional
8035           The method used to calculate the estimator bandwidth.  This can be
8036           'scott', 'silverman', a scalar constant or a callable.  If a
8037           scalar, this will be used directly as `kde.factor`.  If a
8038           callable, it should take a `matplotlib.mlab.GaussianKDE` instance as
8039           its only parameter and return a scalar. If None (default), 'scott'
8040           is used.
8041 
8042         data : indexable object, optional
8043             DATA_PARAMETER_PLACEHOLDER
8044 
8045         Returns
8046         -------
8047         dict
8048           A dictionary mapping each component of the violinplot to a
8049           list of the corresponding collection instances created. The
8050           dictionary has the following keys:
8051 
8052           - ``bodies``: A list of the `~.collections.PolyCollection`
8053             instances containing the filled area of each violin.
8054 
8055           - ``cmeans``: A `~.collections.LineCollection` instance that marks
8056             the mean values of each of the violin's distribution.
8057 
8058           - ``cmins``: A `~.collections.LineCollection` instance that marks
8059             the bottom of each violin's distribution.
8060 
8061           - ``cmaxes``: A `~.collections.LineCollection` instance that marks
8062             the top of each violin's distribution.
8063 
8064           - ``cbars``: A `~.collections.LineCollection` instance that marks
8065             the centers of each violin's distribution.
8066 
8067           - ``cmedians``: A `~.collections.LineCollection` instance that
8068             marks the median values of each of the violin's distribution.
8069 
8070           - ``cquantiles``: A `~.collections.LineCollection` instance created
8071             to identify the quantile values of each of the violin's
8072             distribution.
8073 
8074         """
8075 
8076         def _kde_method(X, coords):
8077             # Unpack in case of e.g. Pandas or xarray object
8078             X = cbook._unpack_to_numpy(X)
8079             # fallback gracefully if the vector contains only one value
8080             if np.all(X[0] == X):
8081                 return (X[0] == coords).astype(float)
8082             kde = mlab.GaussianKDE(X, bw_method)
8083             return kde.evaluate(coords)
8084 
8085         vpstats = cbook.violin_stats(dataset, _kde_method, points=points,
8086                                      quantiles=quantiles)
8087         return self.violin(vpstats, positions=positions, vert=vert,
8088                            widths=widths, showmeans=showmeans,
8089                            showextrema=showextrema, showmedians=showmedians)
8090 
8091     def violin(self, vpstats, positions=None, vert=True, widths=0.5,
8092                showmeans=False, showextrema=True, showmedians=False):
8093         """
8094         Drawing function for violin plots.
8095 
8096         Draw a violin plot for each column of *vpstats*. Each filled area
8097         extends to represent the entire data range, with optional lines at the
8098         mean, the median, the minimum, the maximum, and the quantiles values.
8099 
8100         Parameters
8101         ----------
8102         vpstats : list of dicts
8103           A list of dictionaries containing stats for each violin plot.
8104           Required keys are:
8105 
8106           - ``coords``: A list of scalars containing the coordinates that
8107             the violin's kernel density estimate were evaluated at.
8108 
8109           - ``vals``: A list of scalars containing the values of the
8110             kernel density estimate at each of the coordinates given
8111             in *coords*.
8112 
8113           - ``mean``: The mean value for this violin's dataset.
8114 
8115           - ``median``: The median value for this violin's dataset.
8116 
8117           - ``min``: The minimum value for this violin's dataset.
8118 
8119           - ``max``: The maximum value for this violin's dataset.
8120 
8121           Optional keys are:
8122 
8123           - ``quantiles``: A list of scalars containing the quantile values
8124             for this violin's dataset.
8125 
8126         positions : array-like, default: [1, 2, ..., n]
8127           The positions of the violins. The ticks and limits are
8128           automatically set to match the positions.
8129 
8130         vert : bool, default: True.
8131           If true, plots the violins vertically.
8132           Otherwise, plots the violins horizontally.
8133 
8134         widths : array-like, default: 0.5
8135           Either a scalar or a vector that sets the maximal width of
8136           each violin. The default is 0.5, which uses about half of the
8137           available horizontal space.
8138 
8139         showmeans : bool, default: False
8140           If true, will toggle rendering of the means.
8141 
8142         showextrema : bool, default: True
8143           If true, will toggle rendering of the extrema.
8144 
8145         showmedians : bool, default: False
8146           If true, will toggle rendering of the medians.
8147 
8148         Returns
8149         -------
8150         dict
8151           A dictionary mapping each component of the violinplot to a
8152           list of the corresponding collection instances created. The
8153           dictionary has the following keys:
8154 
8155           - ``bodies``: A list of the `~.collections.PolyCollection`
8156             instances containing the filled area of each violin.
8157 
8158           - ``cmeans``: A `~.collections.LineCollection` instance that marks
8159             the mean values of each of the violin's distribution.
8160 
8161           - ``cmins``: A `~.collections.LineCollection` instance that marks
8162             the bottom of each violin's distribution.
8163 
8164           - ``cmaxes``: A `~.collections.LineCollection` instance that marks
8165             the top of each violin's distribution.
8166 
8167           - ``cbars``: A `~.collections.LineCollection` instance that marks
8168             the centers of each violin's distribution.
8169 
8170           - ``cmedians``: A `~.collections.LineCollection` instance that
8171             marks the median values of each of the violin's distribution.
8172 
8173           - ``cquantiles``: A `~.collections.LineCollection` instance created
8174             to identify the quantiles values of each of the violin's
8175             distribution.
8176         """
8177 
8178         # Statistical quantities to be plotted on the violins
8179         means = []
8180         mins = []
8181         maxes = []
8182         medians = []
8183         quantiles = []
8184 
8185         qlens = []  # Number of quantiles in each dataset.
8186 
8187         artists = {}  # Collections to be returned
8188 
8189         N = len(vpstats)
8190         datashape_message = ("List of violinplot statistics and `{0}` "
8191                              "values must have the same length")
8192 
8193         # Validate positions
8194         if positions is None:
8195             positions = range(1, N + 1)
8196         elif len(positions) != N:
8197             raise ValueError(datashape_message.format("positions"))
8198 
8199         # Validate widths
8200         if np.isscalar(widths):
8201             widths = [widths] * N
8202         elif len(widths) != N:
8203             raise ValueError(datashape_message.format("widths"))
8204 
8205         # Calculate ranges for statistics lines (shape (2, N)).
8206         line_ends = [[-0.25], [0.25]] * np.array(widths) + positions
8207 
8208         # Colors.
8209         if mpl.rcParams['_internal.classic_mode']:
8210             fillcolor = 'y'
8211             linecolor = 'r'
8212         else:
8213             fillcolor = linecolor = self._get_lines.get_next_color()
8214 
8215         # Check whether we are rendering vertically or horizontally
8216         if vert:
8217             fill = self.fill_betweenx
8218             perp_lines = functools.partial(self.hlines, colors=linecolor)
8219             par_lines = functools.partial(self.vlines, colors=linecolor)
8220         else:
8221             fill = self.fill_between
8222             perp_lines = functools.partial(self.vlines, colors=linecolor)
8223             par_lines = functools.partial(self.hlines, colors=linecolor)
8224 
8225         # Render violins
8226         bodies = []
8227         for stats, pos, width in zip(vpstats, positions, widths):
8228             # The 0.5 factor reflects the fact that we plot from v-p to v+p.
8229             vals = np.array(stats['vals'])
8230             vals = 0.5 * width * vals / vals.max()
8231             bodies += [fill(stats['coords'], -vals + pos, vals + pos,
8232                             facecolor=fillcolor, alpha=0.3)]
8233             means.append(stats['mean'])
8234             mins.append(stats['min'])
8235             maxes.append(stats['max'])
8236             medians.append(stats['median'])
8237             q = stats.get('quantiles')  # a list of floats, or None
8238             if q is None:
8239                 q = []
8240             quantiles.extend(q)
8241             qlens.append(len(q))
8242         artists['bodies'] = bodies
8243 
8244         if showmeans:  # Render means
8245             artists['cmeans'] = perp_lines(means, *line_ends)
8246         if showextrema:  # Render extrema
8247             artists['cmaxes'] = perp_lines(maxes, *line_ends)
8248             artists['cmins'] = perp_lines(mins, *line_ends)
8249             artists['cbars'] = par_lines(positions, mins, maxes)
8250         if showmedians:  # Render medians
8251             artists['cmedians'] = perp_lines(medians, *line_ends)
8252         if quantiles:  # Render quantiles: each width is repeated qlen times.
8253             artists['cquantiles'] = perp_lines(
8254                 quantiles, *np.repeat(line_ends, qlens, axis=1))
8255 
8256         return artists
8257 
8258     # Methods that are entirely implemented in other modules.
8259 
8260     table = mtable.table
8261 
8262     # args can be either Y or y1, y2, ... and all should be replaced
8263     stackplot = _preprocess_data()(mstack.stackplot)
8264 
8265     streamplot = _preprocess_data(
8266         replace_names=["x", "y", "u", "v", "start_points"])(mstream.streamplot)
8267 
8268     tricontour = mtri.tricontour
8269     tricontourf = mtri.tricontourf
8270     tripcolor = mtri.tripcolor
8271     triplot = mtri.triplot
8272 
8273     def _get_aspect_ratio(self):
8274         """
8275         Convenience method to calculate the aspect ratio of the axes in
8276         the display coordinate system.
8277         """
8278         figure_size = self.get_figure().get_size_inches()
8279         ll, ur = self.get_position() * figure_size
8280         width, height = ur - ll
8281         return height / (width * self.get_data_ratio())

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>]
2025-10-18 14:15:15.533 | INFO     | Search completed. Bug locations: [<file>lib/matplotlib/figure.py</file>
<class>Figure</class>
<method>None</method>
<code>
2334 class Figure(FigureBase):
2335     """
2336     The top level container for all the plot elements.
2337 
2338     Attributes
2339     ----------
2340     patch
2341         The `.Rectangle` instance representing the figure background patch.
2342 
2343     suppressComposite
2344         For multiple images, the figure will make composite images
2345         depending on the renderer option_image_nocomposite function.  If
2346         *suppressComposite* is a boolean, this will override the renderer.
2347     """
2348     # Remove the self._fig_callbacks properties on figure and subfigure
2349     # after the deprecation expires.
2350     callbacks = _api.deprecated(
2351         "3.6", alternative=("the 'resize_event' signal in "
2352                             "Figure.canvas.callbacks")
2353         )(property(lambda self: self._fig_callbacks))
2354 
2355     def __str__(self):
2356         return "Figure(%gx%g)" % tuple(self.bbox.size)
2357 
2358     def __repr__(self):
2359         return "<{clsname} size {h:g}x{w:g} with {naxes} Axes>".format(
2360             clsname=self.__class__.__name__,
2361             h=self.bbox.size[0], w=self.bbox.size[1],
2362             naxes=len(self.axes),
2363         )
2364 
2365     @_api.make_keyword_only("3.6", "facecolor")
2366     def __init__(self,
2367                  figsize=None,
2368                  dpi=None,
2369                  facecolor=None,
2370                  edgecolor=None,
2371                  linewidth=0.0,
2372                  frameon=None,
2373                  subplotpars=None,  # rc figure.subplot.*
2374                  tight_layout=None,  # rc figure.autolayout
2375                  constrained_layout=None,  # rc figure.constrained_layout.use
2376                  *,
2377                  layout=None,
2378                  **kwargs
2379                  ):
2380         """
2381         Parameters
2382         ----------
2383         figsize : 2-tuple of floats, default: :rc:`figure.figsize`
2384             Figure dimension ``(width, height)`` in inches.
2385 
2386         dpi : float, default: :rc:`figure.dpi`
2387             Dots per inch.
2388 
2389         facecolor : default: :rc:`figure.facecolor`
2390             The figure patch facecolor.
2391 
2392         edgecolor : default: :rc:`figure.edgecolor`
2393             The figure patch edge color.
2394 
2395         linewidth : float
2396             The linewidth of the frame (i.e. the edge linewidth of the figure
2397             patch).
2398 
2399         frameon : bool, default: :rc:`figure.frameon`
2400             If ``False``, suppress drawing the figure background patch.
2401 
2402         subplotpars : `SubplotParams`
2403             Subplot parameters. If not given, the default subplot
2404             parameters :rc:`figure.subplot.*` are used.
2405 
2406         tight_layout : bool or dict, default: :rc:`figure.autolayout`
2407             Whether to use the tight layout mechanism. See `.set_tight_layout`.
2408 
2409             .. admonition:: Discouraged
2410 
2411                 The use of this parameter is discouraged. Please use
2412                 ``layout='tight'`` instead for the common case of
2413                 ``tight_layout=True`` and use `.set_tight_layout` otherwise.
2414 
2415         constrained_layout : bool, default: :rc:`figure.constrained_layout.use`
2416             This is equal to ``layout='constrained'``.
2417 
2418             .. admonition:: Discouraged
2419 
2420                 The use of this parameter is discouraged. Please use
2421                 ``layout='constrained'`` instead.
2422 
2423         layout : {'constrained', 'compressed', 'tight', 'none', `.LayoutEngine`, \
2424 None}, default: None
2425             The layout mechanism for positioning of plot elements to avoid
2426             overlapping Axes decorations (labels, ticks, etc). Note that
2427             layout managers can have significant performance penalties.
2428 
2429             - 'constrained': The constrained layout solver adjusts axes sizes
2430               to avoid overlapping axes decorations.  Can handle complex plot
2431               layouts and colorbars, and is thus recommended.
2432 
2433               See :doc:`/tutorials/intermediate/constrainedlayout_guide`
2434               for examples.
2435 
2436             - 'compressed': uses the same algorithm as 'constrained', but
2437               removes extra space between fixed-aspect-ratio Axes.  Best for
2438               simple grids of axes.
2439 
2440             - 'tight': Use the tight layout mechanism. This is a relatively
2441               simple algorithm that adjusts the subplot parameters so that
2442               decorations do not overlap. See `.Figure.set_tight_layout` for
2443               further details.
2444 
2445             - 'none': Do not use a layout engine.
2446 
2447             - A `.LayoutEngine` instance. Builtin layout classes are
2448               `.ConstrainedLayoutEngine` and `.TightLayoutEngine`, more easily
2449               accessible by 'constrained' and 'tight'.  Passing an instance
2450               allows third parties to provide their own layout engine.
2451 
2452             If not given, fall back to using the parameters *tight_layout* and
2453             *constrained_layout*, including their config defaults
2454             :rc:`figure.autolayout` and :rc:`figure.constrained_layout.use`.
2455 
2456         Other Parameters
2457         ----------------
2458         **kwargs : `.Figure` properties, optional
2459 
2460             %(Figure:kwdoc)s
2461         """
2462         super().__init__(**kwargs)
2463         self._layout_engine = None
2464 
2465         if layout is not None:
2466             if (tight_layout is not None):
2467                 _api.warn_external(
2468                     "The Figure parameters 'layout' and 'tight_layout' cannot "
2469                     "be used together. Please use 'layout' only.")
2470             if (constrained_layout is not None):
2471                 _api.warn_external(
2472                     "The Figure parameters 'layout' and 'constrained_layout' "
2473                     "cannot be used together. Please use 'layout' only.")
2474             self.set_layout_engine(layout=layout)
2475         elif tight_layout is not None:
2476             if constrained_layout is not None:
2477                 _api.warn_external(
2478                     "The Figure parameters 'tight_layout' and "
2479                     "'constrained_layout' cannot be used together. Please use "
2480                     "'layout' parameter")
2481             self.set_layout_engine(layout='tight')
2482             if isinstance(tight_layout, dict):
2483                 self.get_layout_engine().set(**tight_layout)
2484         elif constrained_layout is not None:
2485             if isinstance(constrained_layout, dict):
2486                 self.set_layout_engine(layout='constrained')
2487                 self.get_layout_engine().set(**constrained_layout)
2488             elif constrained_layout:
2489                 self.set_layout_engine(layout='constrained')
2490 
2491         else:
2492             # everything is None, so use default:
2493             self.set_layout_engine(layout=layout)
2494 
2495         self._fig_callbacks = cbook.CallbackRegistry(signals=["dpi_changed"])
2496         # Callbacks traditionally associated with the canvas (and exposed with
2497         # a proxy property), but that actually need to be on the figure for
2498         # pickling.
2499         self._canvas_callbacks = cbook.CallbackRegistry(
2500             signals=FigureCanvasBase.events)
2501         connect = self._canvas_callbacks._connect_picklable
2502         self._mouse_key_ids = [
2503             connect('key_press_event', backend_bases._key_handler),
2504             connect('key_release_event', backend_bases._key_handler),
2505             connect('key_release_event', backend_bases._key_handler),
2506             connect('button_press_event', backend_bases._mouse_handler),
2507             connect('button_release_event', backend_bases._mouse_handler),
2508             connect('scroll_event', backend_bases._mouse_handler),
2509             connect('motion_notify_event', backend_bases._mouse_handler),
2510         ]
2511         self._button_pick_id = connect('button_press_event', self.pick)
2512         self._scroll_pick_id = connect('scroll_event', self.pick)
2513 
2514         if figsize is None:
2515             figsize = mpl.rcParams['figure.figsize']
2516         if dpi is None:
2517             dpi = mpl.rcParams['figure.dpi']
2518         if facecolor is None:
2519             facecolor = mpl.rcParams['figure.facecolor']
2520         if edgecolor is None:
2521             edgecolor = mpl.rcParams['figure.edgecolor']
2522         if frameon is None:
2523             frameon = mpl.rcParams['figure.frameon']
2524 
2525         if not np.isfinite(figsize).all() or (np.array(figsize) < 0).any():
2526             raise ValueError('figure size must be positive finite not '
2527                              f'{figsize}')
2528         self.bbox_inches = Bbox.from_bounds(0, 0, *figsize)
2529 
2530         self.dpi_scale_trans = Affine2D().scale(dpi)
2531         # do not use property as it will trigger
2532         self._dpi = dpi
2533         self.bbox = TransformedBbox(self.bbox_inches, self.dpi_scale_trans)
2534         self.figbbox = self.bbox
2535         self.transFigure = BboxTransformTo(self.bbox)
2536         self.transSubfigure = self.transFigure
2537 
2538         self.patch = Rectangle(
2539             xy=(0, 0), width=1, height=1, visible=frameon,
2540             facecolor=facecolor, edgecolor=edgecolor, linewidth=linewidth,
2541             # Don't let the figure patch influence bbox calculation.
2542             in_layout=False)
2543         self._set_artist_props(self.patch)
2544         self.patch.set_antialiased(False)
2545 
2546         FigureCanvasBase(self)  # Set self.canvas.
2547 
2548         if subplotpars is None:
2549             subplotpars = SubplotParams()
2550 
2551         self.subplotpars = subplotpars
2552 
2553         self._axstack = _AxesStack()  # track all figure axes and current axes
2554         self.clear()
2555 
2556     def pick(self, mouseevent):
2557         if not self.canvas.widgetlock.locked():
2558             super().pick(mouseevent)
2559 
2560     def _check_layout_engines_compat(self, old, new):
2561         """
2562         Helper for set_layout engine
2563 
2564         If the figure has used the old engine and added a colorbar then the
2565         value of colorbar_gridspec must be the same on the new engine.
2566         """
2567         if old is None or new is None:
2568             return True
2569         if old.colorbar_gridspec == new.colorbar_gridspec:
2570             return True
2571         # colorbar layout different, so check if any colorbars are on the
2572         # figure...
2573         for ax in self.axes:
2574             if hasattr(ax, '_colorbar'):
2575                 # colorbars list themselves as a colorbar.
2576                 return False
2577         return True
2578 
2579     def set_layout_engine(self, layout=None, **kwargs):
2580         """
2581         Set the layout engine for this figure.
2582 
2583         Parameters
2584         ----------
2585         layout: {'constrained', 'compressed', 'tight', 'none'} or \
2586 `LayoutEngine` or None
2587 
2588             - 'constrained' will use `~.ConstrainedLayoutEngine`
2589             - 'compressed' will also use `~.ConstrainedLayoutEngine`, but with
2590               a correction that attempts to make a good layout for fixed-aspect
2591               ratio Axes.
2592             - 'tight' uses `~.TightLayoutEngine`
2593             - 'none' removes layout engine.
2594 
2595             If `None`, the behavior is controlled by :rc:`figure.autolayout`
2596             (which if `True` behaves as if 'tight' was passed) and
2597             :rc:`figure.constrained_layout.use` (which if `True` behaves as if
2598             'constrained' was passed).  If both are `True`,
2599             :rc:`figure.autolayout` takes priority.
2600 
2601             Users and libraries can define their own layout engines and pass
2602             the instance directly as well.
2603 
2604         kwargs: dict
2605             The keyword arguments are passed to the layout engine to set things
2606             like padding and margin sizes.  Only used if *layout* is a string.
2607 
2608         """
2609         if layout is None:
2610             if mpl.rcParams['figure.autolayout']:
2611                 layout = 'tight'
2612             elif mpl.rcParams['figure.constrained_layout.use']:
2613                 layout = 'constrained'
2614             else:
2615                 self._layout_engine = None
2616                 return
2617         if layout == 'tight':
2618             new_layout_engine = TightLayoutEngine(**kwargs)
2619         elif layout == 'constrained':
2620             new_layout_engine = ConstrainedLayoutEngine(**kwargs)
2621         elif layout == 'compressed':
2622             new_layout_engine = ConstrainedLayoutEngine(compress=True,
2623                                                         **kwargs)
2624         elif layout == 'none':
2625             if self._layout_engine is not None:
2626                 new_layout_engine = PlaceHolderLayoutEngine(
2627                     self._layout_engine.adjust_compatible,
2628                     self._layout_engine.colorbar_gridspec
2629                 )
2630             else:
2631                 new_layout_engine = None
2632         elif isinstance(layout, LayoutEngine):
2633             new_layout_engine = layout
2634         else:
2635             raise ValueError(f"Invalid value for 'layout': {layout!r}")
2636 
2637         if self._check_layout_engines_compat(self._layout_engine,
2638                                              new_layout_engine):
2639             self._layout_engine = new_layout_engine
2640         else:
2641             raise RuntimeError('Colorbar layout of new layout engine not '
2642                                'compatible with old engine, and a colorbar '
2643                                'has been created.  Engine not changed.')
2644 
2645     def get_layout_engine(self):
2646         return self._layout_engine
2647 
2648     # TODO: I'd like to dynamically add the _repr_html_ method
2649     # to the figure in the right context, but then IPython doesn't
2650     # use it, for some reason.
2651 
2652     def _repr_html_(self):
2653         # We can't use "isinstance" here, because then we'd end up importing
2654         # webagg unconditionally.
2655         if 'WebAgg' in type(self.canvas).__name__:
2656             from matplotlib.backends import backend_webagg
2657             return backend_webagg.ipython_inline_display(self)
2658 
2659     def show(self, warn=True):
2660         """
2661         If using a GUI backend with pyplot, display the figure window.
2662 
2663         If the figure was not created using `~.pyplot.figure`, it will lack
2664         a `~.backend_bases.FigureManagerBase`, and this method will raise an
2665         AttributeError.
2666 
2667         .. warning::
2668 
2669             This does not manage an GUI event loop. Consequently, the figure
2670             may only be shown briefly or not shown at all if you or your
2671             environment are not managing an event loop.
2672 
2673             Use cases for `.Figure.show` include running this from a GUI
2674             application (where there is persistently an event loop running) or
2675             from a shell, like IPython, that install an input hook to allow the
2676             interactive shell to accept input while the figure is also being
2677             shown and interactive.  Some, but not all, GUI toolkits will
2678             register an input hook on import.  See :ref:`cp_integration` for
2679             more details.
2680 
2681             If you're in a shell without input hook integration or executing a
2682             python script, you should use `matplotlib.pyplot.show` with
2683             ``block=True`` instead, which takes care of starting and running
2684             the event loop for you.
2685 
2686         Parameters
2687         ----------
2688         warn : bool, default: True
2689             If ``True`` and we are not running headless (i.e. on Linux with an
2690             unset DISPLAY), issue warning when called on a non-GUI backend.
2691 
2692         """
2693         if self.canvas.manager is None:
2694             raise AttributeError(
2695                 "Figure.show works only for figures managed by pyplot, "
2696                 "normally created by pyplot.figure()")
2697         try:
2698             self.canvas.manager.show()
2699         except NonGuiException as exc:
2700             if warn:
2701                 _api.warn_external(str(exc))
2702 
2703     @property
2704     def axes(self):
2705         """
2706         List of Axes in the Figure. You can access and modify the Axes in the
2707         Figure through this list.
2708 
2709         Do not modify the list itself. Instead, use `~Figure.add_axes`,
2710         `~.Figure.add_subplot` or `~.Figure.delaxes` to add or remove an Axes.
2711 
2712         Note: The `.Figure.axes` property and `~.Figure.get_axes` method are
2713         equivalent.
2714         """
2715         return self._axstack.as_list()
2716 
2717     get_axes = axes.fget
2718 
2719     def _get_renderer(self):
2720         if hasattr(self.canvas, 'get_renderer'):
2721             return self.canvas.get_renderer()
2722         else:
2723             return _get_renderer(self)
2724 
2725     def _get_dpi(self):
2726         return self._dpi
2727 
2728     def _set_dpi(self, dpi, forward=True):
2729         """
2730         Parameters
2731         ----------
2732         dpi : float
2733 
2734         forward : bool
2735             Passed on to `~.Figure.set_size_inches`
2736         """
2737         if dpi == self._dpi:
2738             # We don't want to cause undue events in backends.
2739             return
2740         self._dpi = dpi
2741         self.dpi_scale_trans.clear().scale(dpi)
2742         w, h = self.get_size_inches()
2743         self.set_size_inches(w, h, forward=forward)
2744         self._fig_callbacks.process('dpi_changed', self)
2745 
2746     dpi = property(_get_dpi, _set_dpi, doc="The resolution in dots per inch.")
2747 
2748     def get_tight_layout(self):
2749         """Return whether `.tight_layout` is called when drawing."""
2750         return isinstance(self.get_layout_engine(), TightLayoutEngine)
2751 
2752     @_api.deprecated("3.6", alternative="set_layout_engine",
2753                      pending=True)
2754     def set_tight_layout(self, tight):
2755         """
2756         [*Discouraged*] Set whether and how `.tight_layout` is called when
2757         drawing.
2758 
2759         .. admonition:: Discouraged
2760 
2761             This method is discouraged in favor of `~.set_layout_engine`.
2762 
2763         Parameters
2764         ----------
2765         tight : bool or dict with keys "pad", "w_pad", "h_pad", "rect" or None
2766             If a bool, sets whether to call `.tight_layout` upon drawing.
2767             If ``None``, use :rc:`figure.autolayout` instead.
2768             If a dict, pass it as kwargs to `.tight_layout`, overriding the
2769             default paddings.
2770         """
2771         if tight is None:
2772             tight = mpl.rcParams['figure.autolayout']
2773         _tight = 'tight' if bool(tight) else 'none'
2774         _tight_parameters = tight if isinstance(tight, dict) else {}
2775         self.set_layout_engine(_tight, **_tight_parameters)
2776         self.stale = True
2777 
2778     def get_constrained_layout(self):
2779         """
2780         Return whether constrained layout is being used.
2781 
2782         See :doc:`/tutorials/intermediate/constrainedlayout_guide`.
2783         """
2784         return isinstance(self.get_layout_engine(), ConstrainedLayoutEngine)
2785 
2786     @_api.deprecated("3.6", alternative="set_layout_engine('constrained')",
2787                      pending=True)
2788     def set_constrained_layout(self, constrained):
2789         """
2790         [*Discouraged*] Set whether ``constrained_layout`` is used upon
2791         drawing.
2792 
2793         If None, :rc:`figure.constrained_layout.use` value will be used.
2794 
2795         When providing a dict containing the keys ``w_pad``, ``h_pad``
2796         the default ``constrained_layout`` paddings will be
2797         overridden.  These pads are in inches and default to 3.0/72.0.
2798         ``w_pad`` is the width padding and ``h_pad`` is the height padding.
2799 
2800         .. admonition:: Discouraged
2801 
2802             This method is discouraged in favor of `~.set_layout_engine`.
2803 
2804         Parameters
2805         ----------
2806         constrained : bool or dict or None
2807         """
2808         if constrained is None:
2809             constrained = mpl.rcParams['figure.constrained_layout.use']
2810         _constrained = 'constrained' if bool(constrained) else 'none'
2811         _parameters = constrained if isinstance(constrained, dict) else {}
2812         self.set_layout_engine(_constrained, **_parameters)
2813         self.stale = True
2814 
2815     @_api.deprecated(
2816          "3.6", alternative="figure.get_layout_engine().set()",
2817          pending=True)
2818     def set_constrained_layout_pads(self, **kwargs):
2819         """
2820         Set padding for ``constrained_layout``.
2821 
2822         Tip: The parameters can be passed from a dictionary by using
2823         ``fig.set_constrained_layout(**pad_dict)``.
2824 
2825         See :doc:`/tutorials/intermediate/constrainedlayout_guide`.
2826 
2827         Parameters
2828         ----------
2829         w_pad : float, default: :rc:`figure.constrained_layout.w_pad`
2830             Width padding in inches.  This is the pad around Axes
2831             and is meant to make sure there is enough room for fonts to
2832             look good.  Defaults to 3 pts = 0.04167 inches
2833 
2834         h_pad : float, default: :rc:`figure.constrained_layout.h_pad`
2835             Height padding in inches. Defaults to 3 pts.
2836 
2837         wspace : float, default: :rc:`figure.constrained_layout.wspace`
2838             Width padding between subplots, expressed as a fraction of the
2839             subplot width.  The total padding ends up being w_pad + wspace.
2840 
2841         hspace : float, default: :rc:`figure.constrained_layout.hspace`
2842             Height padding between subplots, expressed as a fraction of the
2843             subplot width. The total padding ends up being h_pad + hspace.
2844 
2845         """
2846         if isinstance(self.get_layout_engine(), ConstrainedLayoutEngine):
2847             self.get_layout_engine().set(**kwargs)
2848 
2849     @_api.deprecated("3.6", alternative="fig.get_layout_engine().get()",
2850                      pending=True)
2851     def get_constrained_layout_pads(self, relative=False):
2852         """
2853         Get padding for ``constrained_layout``.
2854 
2855         Returns a list of ``w_pad, h_pad`` in inches and
2856         ``wspace`` and ``hspace`` as fractions of the subplot.
2857         All values are None if ``constrained_layout`` is not used.
2858 
2859         See :doc:`/tutorials/intermediate/constrainedlayout_guide`.
2860 
2861         Parameters
2862         ----------
2863         relative : bool
2864             If `True`, then convert from inches to figure relative.
2865         """
2866         if not isinstance(self.get_layout_engine(), ConstrainedLayoutEngine):
2867             return None, None, None, None
2868         info = self.get_layout_engine().get_info()
2869         w_pad = info['w_pad']
2870         h_pad = info['h_pad']
2871         wspace = info['wspace']
2872         hspace = info['hspace']
2873 
2874         if relative and (w_pad is not None or h_pad is not None):
2875             renderer = self._get_renderer()
2876             dpi = renderer.dpi
2877             w_pad = w_pad * dpi / renderer.width
2878             h_pad = h_pad * dpi / renderer.height
2879 
2880         return w_pad, h_pad, wspace, hspace
2881 
2882     def set_canvas(self, canvas):
2883         """
2884         Set the canvas that contains the figure
2885 
2886         Parameters
2887         ----------
2888         canvas : FigureCanvas
2889         """
2890         self.canvas = canvas
2891 
2892     @_docstring.interpd
2893     def figimage(self, X, xo=0, yo=0, alpha=None, norm=None, cmap=None,
2894                  vmin=None, vmax=None, origin=None, resize=False, **kwargs):
2895         """
2896         Add a non-resampled image to the figure.
2897 
2898         The image is attached to the lower or upper left corner depending on
2899         *origin*.
2900 
2901         Parameters
2902         ----------
2903         X
2904             The image data. This is an array of one of the following shapes:
2905 
2906             - (M, N): an image with scalar data.  Color-mapping is controlled
2907               by *cmap*, *norm*, *vmin*, and *vmax*.
2908             - (M, N, 3): an image with RGB values (0-1 float or 0-255 int).
2909             - (M, N, 4): an image with RGBA values (0-1 float or 0-255 int),
2910               i.e. including transparency.
2911 
2912         xo, yo : int
2913             The *x*/*y* image offset in pixels.
2914 
2915         alpha : None or float
2916             The alpha blending value.
2917 
2918         %(cmap_doc)s
2919 
2920             This parameter is ignored if *X* is RGB(A).
2921 
2922         %(norm_doc)s
2923 
2924             This parameter is ignored if *X* is RGB(A).
2925 
2926         %(vmin_vmax_doc)s
2927 
2928             This parameter is ignored if *X* is RGB(A).
2929 
2930         origin : {'upper', 'lower'}, default: :rc:`image.origin`
2931             Indicates where the [0, 0] index of the array is in the upper left
2932             or lower left corner of the axes.
2933 
2934         resize : bool
2935             If *True*, resize the figure to match the given image size.
2936 
2937         Returns
2938         -------
2939         `matplotlib.image.FigureImage`
2940 
2941         Other Parameters
2942         ----------------
2943         **kwargs
2944             Additional kwargs are `.Artist` kwargs passed on to `.FigureImage`.
2945 
2946         Notes
2947         -----
2948         figimage complements the Axes image (`~matplotlib.axes.Axes.imshow`)
2949         which will be resampled to fit the current Axes.  If you want
2950         a resampled image to fill the entire figure, you can define an
2951         `~matplotlib.axes.Axes` with extent [0, 0, 1, 1].
2952 
2953         Examples
2954         --------
2955         ::
2956 
2957             f = plt.figure()
2958             nx = int(f.get_figwidth() * f.dpi)
2959             ny = int(f.get_figheight() * f.dpi)
2960             data = np.random.random((ny, nx))
2961             f.figimage(data)
2962             plt.show()
2963         """
2964         if resize:
2965             dpi = self.get_dpi()
2966             figsize = [x / dpi for x in (X.shape[1], X.shape[0])]
2967             self.set_size_inches(figsize, forward=True)
2968 
2969         im = mimage.FigureImage(self, cmap=cmap, norm=norm,
2970                                 offsetx=xo, offsety=yo,
2971                                 origin=origin, **kwargs)
2972         im.stale_callback = _stale_figure_callback
2973 
2974         im.set_array(X)
2975         im.set_alpha(alpha)
2976         if norm is None:
2977             im.set_clim(vmin, vmax)
2978         self.images.append(im)
2979         im._remove_method = self.images.remove
2980         self.stale = True
2981         return im
2982 
2983     def set_size_inches(self, w, h=None, forward=True):
2984         """
2985         Set the figure size in inches.
2986 
2987         Call signatures::
2988 
2989              fig.set_size_inches(w, h)  # OR
2990              fig.set_size_inches((w, h))
2991 
2992         Parameters
2993         ----------
2994         w : (float, float) or float
2995             Width and height in inches (if height not specified as a separate
2996             argument) or width.
2997         h : float
2998             Height in inches.
2999         forward : bool, default: True
3000             If ``True``, the canvas size is automatically updated, e.g.,
3001             you can resize the figure window from the shell.
3002 
3003         See Also
3004         --------
3005         matplotlib.figure.Figure.get_size_inches
3006         matplotlib.figure.Figure.set_figwidth
3007         matplotlib.figure.Figure.set_figheight
3008 
3009         Notes
3010         -----
3011         To transform from pixels to inches divide by `Figure.dpi`.
3012         """
3013         if h is None:  # Got called with a single pair as argument.
3014             w, h = w
3015         size = np.array([w, h])
3016         if not np.isfinite(size).all() or (size < 0).any():
3017             raise ValueError(f'figure size must be positive finite not {size}')
3018         self.bbox_inches.p1 = size
3019         if forward:
3020             manager = self.canvas.manager
3021             if manager is not None:
3022                 manager.resize(*(size * self.dpi).astype(int))
3023         self.stale = True
3024 
3025     def get_size_inches(self):
3026         """
3027         Return the current size of the figure in inches.
3028 
3029         Returns
3030         -------
3031         ndarray
3032            The size (width, height) of the figure in inches.
3033 
3034         See Also
3035         --------
3036         matplotlib.figure.Figure.set_size_inches
3037         matplotlib.figure.Figure.get_figwidth
3038         matplotlib.figure.Figure.get_figheight
3039 
3040         Notes
3041         -----
3042         The size in pixels can be obtained by multiplying with `Figure.dpi`.
3043         """
3044         return np.array(self.bbox_inches.p1)
3045 
3046     def get_figwidth(self):
3047         """Return the figure width in inches."""
3048         return self.bbox_inches.width
3049 
3050     def get_figheight(self):
3051         """Return the figure height in inches."""
3052         return self.bbox_inches.height
3053 
3054     def get_dpi(self):
3055         """Return the resolution in dots per inch as a float."""
3056         return self.dpi
3057 
3058     def set_dpi(self, val):
3059         """
3060         Set the resolution of the figure in dots-per-inch.
3061 
3062         Parameters
3063         ----------
3064         val : float
3065         """
3066         self.dpi = val
3067         self.stale = True
3068 
3069     def set_figwidth(self, val, forward=True):
3070         """
3071         Set the width of the figure in inches.
3072 
3073         Parameters
3074         ----------
3075         val : float
3076         forward : bool
3077             See `set_size_inches`.
3078 
3079         See Also
3080         --------
3081         matplotlib.figure.Figure.set_figheight
3082         matplotlib.figure.Figure.set_size_inches
3083         """
3084         self.set_size_inches(val, self.get_figheight(), forward=forward)
3085 
3086     def set_figheight(self, val, forward=True):
3087         """
3088         Set the height of the figure in inches.
3089 
3090         Parameters
3091         ----------
3092         val : float
3093         forward : bool
3094             See `set_size_inches`.
3095 
3096         See Also
3097         --------
3098         matplotlib.figure.Figure.set_figwidth
3099         matplotlib.figure.Figure.set_size_inches
3100         """
3101         self.set_size_inches(self.get_figwidth(), val, forward=forward)
3102 
3103     def clear(self, keep_observers=False):
3104         # docstring inherited
3105         super().clear(keep_observers=keep_observers)
3106         # FigureBase.clear does not clear toolbars, as
3107         # only Figure can have toolbars
3108         toolbar = self.canvas.toolbar
3109         if toolbar is not None:
3110             toolbar.update()
3111 
3112     @_finalize_rasterization
3113     @allow_rasterization
3114     def draw(self, renderer):
3115         # docstring inherited
3116 
3117         # draw the figure bounding box, perhaps none for white figure
3118         if not self.get_visible():
3119             return
3120 
3121         artists = self._get_draw_artists(renderer)
3122         try:
3123             renderer.open_group('figure', gid=self.get_gid())
3124             if self.axes and self.get_layout_engine() is not None:
3125                 try:
3126                     self.get_layout_engine().execute(self)
3127                 except ValueError:
3128                     pass
3129                     # ValueError can occur when resizing a window.
3130 
3131             self.patch.draw(renderer)
3132             mimage._draw_list_compositing_images(
3133                 renderer, self, artists, self.suppressComposite)
3134 
3135             for sfig in self.subfigs:
3136                 sfig.draw(renderer)
3137 
3138             renderer.close_group('figure')
3139         finally:
3140             self.stale = False
3141 
3142         DrawEvent("draw_event", self.canvas, renderer)._process()
3143 
3144     def draw_without_rendering(self):
3145         """
3146         Draw the figure with no output.  Useful to get the final size of
3147         artists that require a draw before their size is known (e.g. text).
3148         """
3149         renderer = _get_renderer(self)
3150         with renderer._draw_disabled():
3151             self.draw(renderer)
3152 
3153     def draw_artist(self, a):
3154         """
3155         Draw `.Artist` *a* only.
3156         """
3157         a.draw(self.canvas.get_renderer())
3158 
3159     def __getstate__(self):
3160         state = super().__getstate__()
3161 
3162         # The canvas cannot currently be pickled, but this has the benefit
3163         # of meaning that a figure can be detached from one canvas, and
3164         # re-attached to another.
3165         state.pop("canvas")
3166 
3167         # discard any changes to the dpi due to pixel ratio changes
3168         state["_dpi"] = state.get('_original_dpi', state['_dpi'])
3169 
3170         # add version information to the state
3171         state['__mpl_version__'] = mpl.__version__
3172 
3173         # check whether the figure manager (if any) is registered with pyplot
3174         from matplotlib import _pylab_helpers
3175         if self.canvas.manager in _pylab_helpers.Gcf.figs.values():
3176             state['_restore_to_pylab'] = True
3177         return state
3178 
3179     def __setstate__(self, state):
3180         version = state.pop('__mpl_version__')
3181         restore_to_pylab = state.pop('_restore_to_pylab', False)
3182 
3183         if version != mpl.__version__:
3184             _api.warn_external(
3185                 f"This figure was saved with matplotlib version {version} and "
3186                 f"is unlikely to function correctly.")
3187 
3188         self.__dict__ = state
3189 
3190         # re-initialise some of the unstored state information
3191         FigureCanvasBase(self)  # Set self.canvas.
3192 
3193         if restore_to_pylab:
3194             # lazy import to avoid circularity
3195             import matplotlib.pyplot as plt
3196             import matplotlib._pylab_helpers as pylab_helpers
3197             allnums = plt.get_fignums()
3198             num = max(allnums) + 1 if allnums else 1
3199             backend = plt._get_backend_mod()
3200             mgr = backend.new_figure_manager_given_figure(num, self)
3201             pylab_helpers.Gcf._set_new_active_manager(mgr)
3202             plt.draw_if_interactive()
3203 
3204         self.stale = True
3205 
3206     def add_axobserver(self, func):
3207         """Whenever the Axes state change, ``func(self)`` will be called."""
3208         # Connect a wrapper lambda and not func itself, to avoid it being
3209         # weakref-collected.
3210         self._axobservers.connect("_axes_change_event", lambda arg: func(arg))
3211 
3212     def savefig(self, fname, *, transparent=None, **kwargs):
3213         """
3214         Save the current figure.
3215 
3216         Call signature::
3217 
3218           savefig(fname, *, dpi='figure', format=None, metadata=None,
3219                   bbox_inches=None, pad_inches=0.1,
3220                   facecolor='auto', edgecolor='auto',
3221                   backend=None, **kwargs
3222                  )
3223 
3224         The available output formats depend on the backend being used.
3225 
3226         Parameters
3227         ----------
3228         fname : str or path-like or binary file-like
3229             A path, or a Python file-like object, or
3230             possibly some backend-dependent object such as
3231             `matplotlib.backends.backend_pdf.PdfPages`.
3232 
3233             If *format* is set, it determines the output format, and the file
3234             is saved as *fname*.  Note that *fname* is used verbatim, and there
3235             is no attempt to make the extension, if any, of *fname* match
3236             *format*, and no extension is appended.
3237 
3238             If *format* is not set, then the format is inferred from the
3239             extension of *fname*, if there is one.  If *format* is not
3240             set and *fname* has no extension, then the file is saved with
3241             :rc:`savefig.format` and the appropriate extension is appended to
3242             *fname*.
3243 
3244         Other Parameters
3245         ----------------
3246         dpi : float or 'figure', default: :rc:`savefig.dpi`
3247             The resolution in dots per inch.  If 'figure', use the figure's
3248             dpi value.
3249 
3250         format : str
3251             The file format, e.g. 'png', 'pdf', 'svg', ... The behavior when
3252             this is unset is documented under *fname*.
3253 
3254         metadata : dict, optional
3255             Key/value pairs to store in the image metadata. The supported keys
3256             and defaults depend on the image format and backend:
3257 
3258             - 'png' with Agg backend: See the parameter ``metadata`` of
3259               `~.FigureCanvasAgg.print_png`.
3260             - 'pdf' with pdf backend: See the parameter ``metadata`` of
3261               `~.backend_pdf.PdfPages`.
3262             - 'svg' with svg backend: See the parameter ``metadata`` of
3263               `~.FigureCanvasSVG.print_svg`.
3264             - 'eps' and 'ps' with PS backend: Only 'Creator' is supported.
3265 
3266         bbox_inches : str or `.Bbox`, default: :rc:`savefig.bbox`
3267             Bounding box in inches: only the given portion of the figure is
3268             saved.  If 'tight', try to figure out the tight bbox of the figure.
3269 
3270         pad_inches : float or 'layout', default: :rc:`savefig.pad_inches`
3271             Amount of padding in inches around the figure when bbox_inches is
3272             'tight'. If 'layout' use the padding from the constrained or
3273             compressed layout engine; ignored if one of those engines is not in
3274             use.
3275 
3276         facecolor : color or 'auto', default: :rc:`savefig.facecolor`
3277             The facecolor of the figure.  If 'auto', use the current figure
3278             facecolor.
3279 
3280         edgecolor : color or 'auto', default: :rc:`savefig.edgecolor`
3281             The edgecolor of the figure.  If 'auto', use the current figure
3282             edgecolor.
3283 
3284         backend : str, optional
3285             Use a non-default backend to render the file, e.g. to render a
3286             png file with the "cairo" backend rather than the default "agg",
3287             or a pdf file with the "pgf" backend rather than the default
3288             "pdf".  Note that the default backend is normally sufficient.  See
3289             :ref:`the-builtin-backends` for a list of valid backends for each
3290             file format.  Custom backends can be referenced as "module://...".
3291 
3292         orientation : {'landscape', 'portrait'}
3293             Currently only supported by the postscript backend.
3294 
3295         papertype : str
3296             One of 'letter', 'legal', 'executive', 'ledger', 'a0' through
3297             'a10', 'b0' through 'b10'. Only supported for postscript
3298             output.
3299 
3300         transparent : bool
3301             If *True*, the Axes patches will all be transparent; the
3302             Figure patch will also be transparent unless *facecolor*
3303             and/or *edgecolor* are specified via kwargs.
3304 
3305             If *False* has no effect and the color of the Axes and
3306             Figure patches are unchanged (unless the Figure patch
3307             is specified via the *facecolor* and/or *edgecolor* keyword
3308             arguments in which case those colors are used).
3309 
3310             The transparency of these patches will be restored to their
3311             original values upon exit of this function.
3312 
3313             This is useful, for example, for displaying
3314             a plot on top of a colored background on a web page.
3315 
3316         bbox_extra_artists : list of `~matplotlib.artist.Artist`, optional
3317             A list of extra artists that will be considered when the
3318             tight bbox is calculated.
3319 
3320         pil_kwargs : dict, optional
3321             Additional keyword arguments that are passed to
3322             `PIL.Image.Image.save` when saving the figure.
3323 
3324         """
3325 
3326         kwargs.setdefault('dpi', mpl.rcParams['savefig.dpi'])
3327         if transparent is None:
3328             transparent = mpl.rcParams['savefig.transparent']
3329 
3330         with ExitStack() as stack:
3331             if transparent:
3332                 def _recursively_make_subfig_transparent(exit_stack, subfig):
3333                     exit_stack.enter_context(
3334                         subfig.patch._cm_set(
3335                             facecolor="none", edgecolor="none"))
3336                     for ax in subfig.axes:
3337                         exit_stack.enter_context(
3338                             ax.patch._cm_set(
3339                                 facecolor="none", edgecolor="none"))
3340                     for sub_subfig in subfig.subfigs:
3341                         _recursively_make_subfig_transparent(
3342                             exit_stack, sub_subfig)
3343 
3344                 def _recursively_make_axes_transparent(exit_stack, ax):
3345                     exit_stack.enter_context(
3346                         ax.patch._cm_set(facecolor="none", edgecolor="none"))
3347                     for child_ax in ax.child_axes:
3348                         exit_stack.enter_context(
3349                             child_ax.patch._cm_set(
3350                                 facecolor="none", edgecolor="none"))
3351                     for child_childax in ax.child_axes:
3352                         _recursively_make_axes_transparent(
3353                             exit_stack, child_childax)
3354 
3355                 kwargs.setdefault('facecolor', 'none')
3356                 kwargs.setdefault('edgecolor', 'none')
3357                 # set subfigure to appear transparent in printed image
3358                 for subfig in self.subfigs:
3359                     _recursively_make_subfig_transparent(stack, subfig)
3360                 # set axes to be transparent
3361                 for ax in self.axes:
3362                     _recursively_make_axes_transparent(stack, ax)
3363             self.canvas.print_figure(fname, **kwargs)
3364 
3365     def ginput(self, n=1, timeout=30, show_clicks=True,
3366                mouse_add=MouseButton.LEFT,
3367                mouse_pop=MouseButton.RIGHT,
3368                mouse_stop=MouseButton.MIDDLE):
3369         """
3370         Blocking call to interact with a figure.
3371 
3372         Wait until the user clicks *n* times on the figure, and return the
3373         coordinates of each click in a list.
3374 
3375         There are three possible interactions:
3376 
3377         - Add a point.
3378         - Remove the most recently added point.
3379         - Stop the interaction and return the points added so far.
3380 
3381         The actions are assigned to mouse buttons via the arguments
3382         *mouse_add*, *mouse_pop* and *mouse_stop*.
3383 
3384         Parameters
3385         ----------
3386         n : int, default: 1
3387             Number of mouse clicks to accumulate. If negative, accumulate
3388             clicks until the input is terminated manually.
3389         timeout : float, default: 30 seconds
3390             Number of seconds to wait before timing out. If zero or negative
3391             will never time out.
3392         show_clicks : bool, default: True
3393             If True, show a red cross at the location of each click.
3394         mouse_add : `.MouseButton` or None, default: `.MouseButton.LEFT`
3395             Mouse button used to add points.
3396         mouse_pop : `.MouseButton` or None, default: `.MouseButton.RIGHT`
3397             Mouse button used to remove the most recently added point.
3398         mouse_stop : `.MouseButton` or None, default: `.MouseButton.MIDDLE`
3399             Mouse button used to stop input.
3400 
3401         Returns
3402         -------
3403         list of tuples
3404             A list of the clicked (x, y) coordinates.
3405 
3406         Notes
3407         -----
3408         The keyboard can also be used to select points in case your mouse
3409         does not have one or more of the buttons.  The delete and backspace
3410         keys act like right-clicking (i.e., remove last point), the enter key
3411         terminates input and any other key (not already used by the window
3412         manager) selects a point.
3413         """
3414         clicks = []
3415         marks = []
3416 
3417         def handler(event):
3418             is_button = event.name == "button_press_event"
3419             is_key = event.name == "key_press_event"
3420             # Quit (even if not in infinite mode; this is consistent with
3421             # MATLAB and sometimes quite useful, but will require the user to
3422             # test how many points were actually returned before using data).
3423             if (is_button and event.button == mouse_stop
3424                     or is_key and event.key in ["escape", "enter"]):
3425                 self.canvas.stop_event_loop()
3426             # Pop last click.
3427             elif (is_button and event.button == mouse_pop
3428                   or is_key and event.key in ["backspace", "delete"]):
3429                 if clicks:
3430                     clicks.pop()
3431                     if show_clicks:
3432                         marks.pop().remove()
3433                         self.canvas.draw()
3434             # Add new click.
3435             elif (is_button and event.button == mouse_add
3436                   # On macOS/gtk, some keys return None.
3437                   or is_key and event.key is not None):
3438                 if event.inaxes:
3439                     clicks.append((event.xdata, event.ydata))
3440                     _log.info("input %i: %f, %f",
3441                               len(clicks), event.xdata, event.ydata)
3442                     if show_clicks:
3443                         line = mpl.lines.Line2D([event.xdata], [event.ydata],
3444                                                 marker="+", color="r")
3445                         event.inaxes.add_line(line)
3446                         marks.append(line)
3447                         self.canvas.draw()
3448             if len(clicks) == n and n > 0:
3449                 self.canvas.stop_event_loop()
3450 
3451         _blocking_input.blocking_input_loop(
3452             self, ["button_press_event", "key_press_event"], timeout, handler)
3453 
3454         # Cleanup.
3455         for mark in marks:
3456             mark.remove()
3457         self.canvas.draw()
3458 
3459         return clicks
3460 
3461     def waitforbuttonpress(self, timeout=-1):
3462         """
3463         Blocking call to interact with the figure.
3464 
3465         Wait for user input and return True if a key was pressed, False if a
3466         mouse button was pressed and None if no input was given within
3467         *timeout* seconds.  Negative values deactivate *timeout*.
3468         """
3469         event = None
3470 
3471         def handler(ev):
3472             nonlocal event
3473             event = ev
3474             self.canvas.stop_event_loop()
3475 
3476         _blocking_input.blocking_input_loop(
3477             self, ["button_press_event", "key_press_event"], timeout, handler)
3478 
3479         return None if event is None else event.name == "key_press_event"
3480 
3481     @_api.deprecated("3.6", alternative="figure.get_layout_engine().execute()")
3482     def execute_constrained_layout(self, renderer=None):
3483         """
3484         Use ``layoutgrid`` to determine pos positions within Axes.
3485 
3486         See also `.set_constrained_layout_pads`.
3487 
3488         Returns
3489         -------
3490         layoutgrid : private debugging object
3491         """
3492         if not isinstance(self.get_layout_engine(), ConstrainedLayoutEngine):
3493             return None
3494         return self.get_layout_engine().execute(self)
3495 
3496     def tight_layout(self, *, pad=1.08, h_pad=None, w_pad=None, rect=None):
3497         """
3498         Adjust the padding between and around subplots.
3499 
3500         To exclude an artist on the Axes from the bounding box calculation
3501         that determines the subplot parameters (i.e. legend, or annotation),
3502         set ``a.set_in_layout(False)`` for that artist.
3503 
3504         Parameters
3505         ----------
3506         pad : float, default: 1.08
3507             Padding between the figure edge and the edges of subplots,
3508             as a fraction of the font size.
3509         h_pad, w_pad : float, default: *pad*
3510             Padding (height/width) between edges of adjacent subplots,
3511             as a fraction of the font size.
3512         rect : tuple (left, bottom, right, top), default: (0, 0, 1, 1)
3513             A rectangle in normalized figure coordinates into which the whole
3514             subplots area (including labels) will fit.
3515 
3516         See Also
3517         --------
3518         .Figure.set_layout_engine
3519         .pyplot.tight_layout
3520         """
3521         # note that here we do not permanently set the figures engine to
3522         # tight_layout but rather just perform the layout in place and remove
3523         # any previous engines.
3524         engine = TightLayoutEngine(pad=pad, h_pad=h_pad, w_pad=w_pad,
3525                                    rect=rect)
3526         try:
3527             previous_engine = self.get_layout_engine()
3528             self.set_layout_engine(engine)
3529             engine.execute(self)
3530             if not isinstance(previous_engine, TightLayoutEngine) \
3531                     and previous_engine is not None:
3532                 _api.warn_external('The figure layout has changed to tight')
3533         finally:
3534             self.set_layout_engine(None)

</code><intended_behavior>The constrained layout system within the Figure class might need updates or adjustments to better account for wrapped text in titles. This might involve implementing a more dynamic calculation of bounding boxes for titles when wrap=True is set, ensuring that ample space is automatically allocated to prevent overlap and ensure visibility.</intended_behavior>, <file>lib/matplotlib/axes/_axes.py</file>
<class>Axes</class>
<method>set_title</method>
<code>
104     def set_title(self, label, fontdict=None, loc=None, pad=None, *, y=None,
105                   **kwargs):
106         """
107         Set a title for the Axes.
108 
109         Set one of the three available Axes titles. The available titles
110         are positioned above the Axes in the center, flush with the left
111         edge, and flush with the right edge.
112 
113         Parameters
114         ----------
115         label : str
116             Text to use for the title
117 
118         fontdict : dict
119             A dictionary controlling the appearance of the title text,
120             the default *fontdict* is::
121 
122                {'fontsize': rcParams['axes.titlesize'],
123                 'fontweight': rcParams['axes.titleweight'],
124                 'color': rcParams['axes.titlecolor'],
125                 'verticalalignment': 'baseline',
126                 'horizontalalignment': loc}
127 
128         loc : {'center', 'left', 'right'}, default: :rc:`axes.titlelocation`
129             Which title to set.
130 
131         y : float, default: :rc:`axes.titley`
132             Vertical Axes location for the title (1.0 is the top).  If
133             None (the default) and :rc:`axes.titley` is also None, y is
134             determined automatically to avoid decorators on the Axes.
135 
136         pad : float, default: :rc:`axes.titlepad`
137             The offset of the title from the top of the Axes, in points.
138 
139         Returns
140         -------
141         `.Text`
142             The matplotlib text instance representing the title
143 
144         Other Parameters
145         ----------------
146         **kwargs : `.Text` properties
147             Other keyword arguments are text properties, see `.Text` for a list
148             of valid text properties.
149         """
150         if loc is None:
151             loc = mpl.rcParams['axes.titlelocation']
152 
153         if y is None:
154             y = mpl.rcParams['axes.titley']
155         if y is None:
156             y = 1.0
157         else:
158             self._autotitlepos = False
159         kwargs['y'] = y
160 
161         titles = {'left': self._left_title,
162                   'center': self.title,
163                   'right': self._right_title}
164         title = _api.check_getitem(titles, loc=loc.lower())
165         default = {
166             'fontsize': mpl.rcParams['axes.titlesize'],
167             'fontweight': mpl.rcParams['axes.titleweight'],
168             'verticalalignment': 'baseline',
169             'horizontalalignment': loc.lower()}
170         titlecolor = mpl.rcParams['axes.titlecolor']
171         if not cbook._str_lower_equal(titlecolor, 'auto'):
172             default["color"] = titlecolor
173         if pad is None:
174             pad = mpl.rcParams['axes.titlepad']
175         self._set_title_offset_trans(float(pad))
176         title.set_text(label)
177         title.update(default)
178         if fontdict is not None:
179             title.update(fontdict)
180         title._internal_update(kwargs)
181         return title

</code><intended_behavior>This method should ensure that when a title is set with wrap=True, the height calculation for the wrapped title is accurately communicated to the layout engine. This may require extending the functionality to better notify the constrained layout engine of the adjusted size necessary for the wrapped text.</intended_behavior>, <file>lib/matplotlib/axes/_axes.py</file>
<class>Axes</class>
<method>None</method>
<code>
47 class Axes(_AxesBase):
48     """
49     An Axes object encapsulates all the elements of an individual (sub-)plot in
50     a figure.
51 
52     It contains most of the (sub-)plot elements: `~.axis.Axis`,
53     `~.axis.Tick`, `~.lines.Line2D`, `~.text.Text`, `~.patches.Polygon`, etc.,
54     and sets the coordinate system.
55 
56     Like all visible elements in a figure, Axes is an `.Artist` subclass.
57 
58     The `Axes` instance supports callbacks through a callbacks attribute which
59     is a `~.cbook.CallbackRegistry` instance.  The events you can connect to
60     are 'xlim_changed' and 'ylim_changed' and the callback will be called with
61     func(*ax*) where *ax* is the `Axes` instance.
62 
63     .. note::
64 
65         As a user, you do not instantiate Axes directly, but use Axes creation
66         methods instead; e.g. from `.pyplot` or `.Figure`:
67         `~.pyplot.subplots`, `~.pyplot.subplot_mosaic` or `.Figure.add_axes`.
68 
69     Attributes
70     ----------
71     dataLim : `.Bbox`
72         The bounding box enclosing all data displayed in the Axes.
73     viewLim : `.Bbox`
74         The view limits in data coordinates.
75 
76     """
77     ### Labelling, legend and texts
78 
79     def get_title(self, loc="center"):
80         """
81         Get an Axes title.
82 
83         Get one of the three available Axes titles. The available titles
84         are positioned above the Axes in the center, flush with the left
85         edge, and flush with the right edge.
86 
87         Parameters
88         ----------
89         loc : {'center', 'left', 'right'}, str, default: 'center'
90             Which title to return.
91 
92         Returns
93         -------
94         str
95             The title text string.
96 
97         """
98         titles = {'left': self._left_title,
99                   'center': self.title,
100                   'right': self._right_title}
101         title = _api.check_getitem(titles, loc=loc.lower())
102         return title.get_text()
103 
104     def set_title(self, label, fontdict=None, loc=None, pad=None, *, y=None,
105                   **kwargs):
106         """
107         Set a title for the Axes.
108 
109         Set one of the three available Axes titles. The available titles
110         are positioned above the Axes in the center, flush with the left
111         edge, and flush with the right edge.
112 
113         Parameters
114         ----------
115         label : str
116             Text to use for the title
117 
118         fontdict : dict
119             A dictionary controlling the appearance of the title text,
120             the default *fontdict* is::
121 
122                {'fontsize': rcParams['axes.titlesize'],
123                 'fontweight': rcParams['axes.titleweight'],
124                 'color': rcParams['axes.titlecolor'],
125                 'verticalalignment': 'baseline',
126                 'horizontalalignment': loc}
127 
128         loc : {'center', 'left', 'right'}, default: :rc:`axes.titlelocation`
129             Which title to set.
130 
131         y : float, default: :rc:`axes.titley`
132             Vertical Axes location for the title (1.0 is the top).  If
133             None (the default) and :rc:`axes.titley` is also None, y is
134             determined automatically to avoid decorators on the Axes.
135 
136         pad : float, default: :rc:`axes.titlepad`
137             The offset of the title from the top of the Axes, in points.
138 
139         Returns
140         -------
141         `.Text`
142             The matplotlib text instance representing the title
143 
144         Other Parameters
145         ----------------
146         **kwargs : `.Text` properties
147             Other keyword arguments are text properties, see `.Text` for a list
148             of valid text properties.
149         """
150         if loc is None:
151             loc = mpl.rcParams['axes.titlelocation']
152 
153         if y is None:
154             y = mpl.rcParams['axes.titley']
155         if y is None:
156             y = 1.0
157         else:
158             self._autotitlepos = False
159         kwargs['y'] = y
160 
161         titles = {'left': self._left_title,
162                   'center': self.title,
163                   'right': self._right_title}
164         title = _api.check_getitem(titles, loc=loc.lower())
165         default = {
166             'fontsize': mpl.rcParams['axes.titlesize'],
167             'fontweight': mpl.rcParams['axes.titleweight'],
168             'verticalalignment': 'baseline',
169             'horizontalalignment': loc.lower()}
170         titlecolor = mpl.rcParams['axes.titlecolor']
171         if not cbook._str_lower_equal(titlecolor, 'auto'):
172             default["color"] = titlecolor
173         if pad is None:
174             pad = mpl.rcParams['axes.titlepad']
175         self._set_title_offset_trans(float(pad))
176         title.set_text(label)
177         title.update(default)
178         if fontdict is not None:
179             title.update(fontdict)
180         title._internal_update(kwargs)
181         return title
182 
183     def get_legend_handles_labels(self, legend_handler_map=None):
184         """
185         Return handles and labels for legend
186 
187         ``ax.legend()`` is equivalent to ::
188 
189           h, l = ax.get_legend_handles_labels()
190           ax.legend(h, l)
191         """
192         # pass through to legend.
193         handles, labels = mlegend._get_legend_handles_labels(
194             [self], legend_handler_map)
195         return handles, labels
196 
197     @_docstring.dedent_interpd
198     def legend(self, *args, **kwargs):
199         """
200         Place a legend on the Axes.
201 
202         Call signatures::
203 
204             legend()
205             legend(handles, labels)
206             legend(handles=handles)
207             legend(labels)
208 
209         The call signatures correspond to the following different ways to use
210         this method:
211 
212         **1. Automatic detection of elements to be shown in the legend**
213 
214         The elements to be added to the legend are automatically determined,
215         when you do not pass in any extra arguments.
216 
217         In this case, the labels are taken from the artist. You can specify
218         them either at artist creation or by calling the
219         :meth:`~.Artist.set_label` method on the artist::
220 
221             ax.plot([1, 2, 3], label='Inline label')
222             ax.legend()
223 
224         or::
225 
226             line, = ax.plot([1, 2, 3])
227             line.set_label('Label via method')
228             ax.legend()
229 
230         .. note::
231             Specific artists can be excluded from the automatic legend element
232             selection by using a label starting with an underscore, "_".
233             A string starting with an underscore is the default label for all
234             artists, so calling `.Axes.legend` without any arguments and
235             without setting the labels manually will result in no legend being
236             drawn.
237 
238 
239         **2. Explicitly listing the artists and labels in the legend**
240 
241         For full control of which artists have a legend entry, it is possible
242         to pass an iterable of legend artists followed by an iterable of
243         legend labels respectively::
244 
245             ax.legend([line1, line2, line3], ['label1', 'label2', 'label3'])
246 
247 
248         **3. Explicitly listing the artists in the legend**
249 
250         This is similar to 2, but the labels are taken from the artists'
251         label properties. Example::
252 
253             line1, = ax.plot([1, 2, 3], label='label1')
254             line2, = ax.plot([1, 2, 3], label='label2')
255             ax.legend(handles=[line1, line2])
256 
257 
258         **4. Labeling existing plot elements**
259 
260         .. admonition:: Discouraged
261 
262             This call signature is discouraged, because the relation between
263             plot elements and labels is only implicit by their order and can
264             easily be mixed up.
265 
266         To make a legend for all artists on an Axes, call this function with
267         an iterable of strings, one for each legend item. For example::
268 
269             ax.plot([1, 2, 3])
270             ax.plot([5, 6, 7])
271             ax.legend(['First line', 'Second line'])
272 
273 
274         Parameters
275         ----------
276         handles : sequence of `.Artist`, optional
277             A list of Artists (lines, patches) to be added to the legend.
278             Use this together with *labels*, if you need full control on what
279             is shown in the legend and the automatic mechanism described above
280             is not sufficient.
281 
282             The length of handles and labels should be the same in this
283             case. If they are not, they are truncated to the smaller length.
284 
285         labels : list of str, optional
286             A list of labels to show next to the artists.
287             Use this together with *handles*, if you need full control on what
288             is shown in the legend and the automatic mechanism described above
289             is not sufficient.
290 
291         Returns
292         -------
293         `~matplotlib.legend.Legend`
294 
295         Other Parameters
296         ----------------
297         %(_legend_kw_axes)s
298 
299         See Also
300         --------
301         .Figure.legend
302 
303         Notes
304         -----
305         Some artists are not supported by this function.  See
306         :doc:`/tutorials/intermediate/legend_guide` for details.
307 
308         Examples
309         --------
310         .. plot:: gallery/text_labels_and_annotations/legend.py
311         """
312         handles, labels, extra_args, kwargs = mlegend._parse_legend_args(
313                 [self],
314                 *args,
315                 **kwargs)
316         if len(extra_args):
317             raise TypeError('legend only accepts two non-keyword arguments')
318         self.legend_ = mlegend.Legend(self, handles, labels, **kwargs)
319         self.legend_._remove_method = self._remove_legend
320         return self.legend_
321 
322     def _remove_legend(self, legend):
323         self.legend_ = None
324 
325     def inset_axes(self, bounds, *, transform=None, zorder=5, **kwargs):
326         """
327         Add a child inset Axes to this existing Axes.
328 
329         Warnings
330         --------
331         This method is experimental as of 3.0, and the API may change.
332 
333         Parameters
334         ----------
335         bounds : [x0, y0, width, height]
336             Lower-left corner of inset Axes, and its width and height.
337 
338         transform : `.Transform`
339             Defaults to `ax.transAxes`, i.e. the units of *rect* are in
340             Axes-relative coordinates.
341 
342         projection : {None, 'aitoff', 'hammer', 'lambert', 'mollweide', \
343 'polar', 'rectilinear', str}, optional
344             The projection type of the inset `~.axes.Axes`. *str* is the name
345             of a custom projection, see `~matplotlib.projections`. The default
346             None results in a 'rectilinear' projection.
347 
348         polar : bool, default: False
349             If True, equivalent to projection='polar'.
350 
351         axes_class : subclass type of `~.axes.Axes`, optional
352             The `.axes.Axes` subclass that is instantiated.  This parameter
353             is incompatible with *projection* and *polar*.  See
354             :ref:`axisartist_users-guide-index` for examples.
355 
356         zorder : number
357             Defaults to 5 (same as `.Axes.legend`).  Adjust higher or lower
358             to change whether it is above or below data plotted on the
359             parent Axes.
360 
361         **kwargs
362             Other keyword arguments are passed on to the inset Axes class.
363 
364         Returns
365         -------
366         ax
367             The created `~.axes.Axes` instance.
368 
369         Examples
370         --------
371         This example makes two inset Axes, the first is in Axes-relative
372         coordinates, and the second in data-coordinates::
373 
374             fig, ax = plt.subplots()
375             ax.plot(range(10))
376             axin1 = ax.inset_axes([0.8, 0.1, 0.15, 0.15])
377             axin2 = ax.inset_axes(
378                     [5, 7, 2.3, 2.3], transform=ax.transData)
379 
380         """
381         if transform is None:
382             transform = self.transAxes
383         kwargs.setdefault('label', 'inset_axes')
384 
385         # This puts the rectangle into figure-relative coordinates.
386         inset_locator = _TransformedBoundsLocator(bounds, transform)
387         bounds = inset_locator(self, None).bounds
388         projection_class, pkw = self.figure._process_projection_requirements(
389                 bounds, **kwargs)
390         inset_ax = projection_class(self.figure, bounds, zorder=zorder, **pkw)
391 
392         # this locator lets the axes move if in data coordinates.
393         # it gets called in `ax.apply_aspect() (of all places)
394         inset_ax.set_axes_locator(inset_locator)
395 
396         self.add_child_axes(inset_ax)
397 
398         return inset_ax
399 
400     @_docstring.dedent_interpd
401     def indicate_inset(self, bounds, inset_ax=None, *, transform=None,
402                        facecolor='none', edgecolor='0.5', alpha=0.5,
403                        zorder=4.99, **kwargs):
404         """
405         Add an inset indicator to the Axes.  This is a rectangle on the plot
406         at the position indicated by *bounds* that optionally has lines that
407         connect the rectangle to an inset Axes (`.Axes.inset_axes`).
408 
409         Warnings
410         --------
411         This method is experimental as of 3.0, and the API may change.
412 
413         Parameters
414         ----------
415         bounds : [x0, y0, width, height]
416             Lower-left corner of rectangle to be marked, and its width
417             and height.
418 
419         inset_ax : `.Axes`
420             An optional inset Axes to draw connecting lines to.  Two lines are
421             drawn connecting the indicator box to the inset Axes on corners
422             chosen so as to not overlap with the indicator box.
423 
424         transform : `.Transform`
425             Transform for the rectangle coordinates. Defaults to
426             `ax.transAxes`, i.e. the units of *rect* are in Axes-relative
427             coordinates.
428 
429         facecolor : color, default: 'none'
430             Facecolor of the rectangle.
431 
432         edgecolor : color, default: '0.5'
433             Color of the rectangle and color of the connecting lines.
434 
435         alpha : float, default: 0.5
436             Transparency of the rectangle and connector lines.
437 
438         zorder : float, default: 4.99
439             Drawing order of the rectangle and connector lines.  The default,
440             4.99, is just below the default level of inset Axes.
441 
442         **kwargs
443             Other keyword arguments are passed on to the `.Rectangle` patch:
444 
445             %(Rectangle:kwdoc)s
446 
447         Returns
448         -------
449         rectangle_patch : `.patches.Rectangle`
450              The indicator frame.
451 
452         connector_lines : 4-tuple of `.patches.ConnectionPatch`
453             The four connector lines connecting to (lower_left, upper_left,
454             lower_right upper_right) corners of *inset_ax*. Two lines are
455             set with visibility to *False*,  but the user can set the
456             visibility to True if the automatic choice is not deemed correct.
457 
458         """
459         # to make the axes connectors work, we need to apply the aspect to
460         # the parent axes.
461         self.apply_aspect()
462 
463         if transform is None:
464             transform = self.transData
465         kwargs.setdefault('label', '_indicate_inset')
466 
467         x, y, width, height = bounds
468         rectangle_patch = mpatches.Rectangle(
469             (x, y), width, height,
470             facecolor=facecolor, edgecolor=edgecolor, alpha=alpha,
471             zorder=zorder, transform=transform, **kwargs)
472         self.add_patch(rectangle_patch)
473 
474         connects = []
475 
476         if inset_ax is not None:
477             # connect the inset_axes to the rectangle
478             for xy_inset_ax in [(0, 0), (0, 1), (1, 0), (1, 1)]:
479                 # inset_ax positions are in axes coordinates
480                 # The 0, 1 values define the four edges if the inset_ax
481                 # lower_left, upper_left, lower_right upper_right.
482                 ex, ey = xy_inset_ax
483                 if self.xaxis.get_inverted():
484                     ex = 1 - ex
485                 if self.yaxis.get_inverted():
486                     ey = 1 - ey
487                 xy_data = x + ex * width, y + ey * height
488                 p = mpatches.ConnectionPatch(
489                     xyA=xy_inset_ax, coordsA=inset_ax.transAxes,
490                     xyB=xy_data, coordsB=self.transData,
491                     arrowstyle="-", zorder=zorder,
492                     edgecolor=edgecolor, alpha=alpha)
493                 connects.append(p)
494                 self.add_patch(p)
495 
496             # decide which two of the lines to keep visible....
497             pos = inset_ax.get_position()
498             bboxins = pos.transformed(self.figure.transSubfigure)
499             rectbbox = mtransforms.Bbox.from_bounds(
500                 *bounds
501             ).transformed(transform)
502             x0 = rectbbox.x0 < bboxins.x0
503             x1 = rectbbox.x1 < bboxins.x1
504             y0 = rectbbox.y0 < bboxins.y0
505             y1 = rectbbox.y1 < bboxins.y1
506             connects[0].set_visible(x0 ^ y0)
507             connects[1].set_visible(x0 == y1)
508             connects[2].set_visible(x1 == y0)
509             connects[3].set_visible(x1 ^ y1)
510 
511         return rectangle_patch, tuple(connects) if connects else None
512 
513     def indicate_inset_zoom(self, inset_ax, **kwargs):
514         """
515         Add an inset indicator rectangle to the Axes based on the axis
516         limits for an *inset_ax* and draw connectors between *inset_ax*
517         and the rectangle.
518 
519         Warnings
520         --------
521         This method is experimental as of 3.0, and the API may change.
522 
523         Parameters
524         ----------
525         inset_ax : `.Axes`
526             Inset Axes to draw connecting lines to.  Two lines are
527             drawn connecting the indicator box to the inset Axes on corners
528             chosen so as to not overlap with the indicator box.
529 
530         **kwargs
531             Other keyword arguments are passed on to `.Axes.indicate_inset`
532 
533         Returns
534         -------
535         rectangle_patch : `.patches.Rectangle`
536              Rectangle artist.
537 
538         connector_lines : 4-tuple of `.patches.ConnectionPatch`
539             Each of four connector lines coming from the rectangle drawn on
540             this axis, in the order lower left, upper left, lower right,
541             upper right.
542             Two are set with visibility to *False*,  but the user can
543             set the visibility to *True* if the automatic choice is not deemed
544             correct.
545         """
546 
547         xlim = inset_ax.get_xlim()
548         ylim = inset_ax.get_ylim()
549         rect = (xlim[0], ylim[0], xlim[1] - xlim[0], ylim[1] - ylim[0])
550         return self.indicate_inset(rect, inset_ax, **kwargs)
551 
552     @_docstring.dedent_interpd
553     def secondary_xaxis(self, location, *, functions=None, **kwargs):
554         """
555         Add a second x-axis to this `~.axes.Axes`.
556 
557         For example if we want to have a second scale for the data plotted on
558         the xaxis.
559 
560         %(_secax_docstring)s
561 
562         Examples
563         --------
564         The main axis shows frequency, and the secondary axis shows period.
565 
566         .. plot::
567 
568             fig, ax = plt.subplots()
569             ax.loglog(range(1, 360, 5), range(1, 360, 5))
570             ax.set_xlabel('frequency [Hz]')
571 
572             def invert(x):
573                 # 1/x with special treatment of x == 0
574                 x = np.array(x).astype(float)
575                 near_zero = np.isclose(x, 0)
576                 x[near_zero] = np.inf
577                 x[~near_zero] = 1 / x[~near_zero]
578                 return x
579 
580             # the inverse of 1/x is itself
581             secax = ax.secondary_xaxis('top', functions=(invert, invert))
582             secax.set_xlabel('Period [s]')
583             plt.show()
584         """
585         if location in ['top', 'bottom'] or isinstance(location, Real):
586             secondary_ax = SecondaryAxis(self, 'x', location, functions,
587                                          **kwargs)
588             self.add_child_axes(secondary_ax)
589             return secondary_ax
590         else:
591             raise ValueError('secondary_xaxis location must be either '
592                              'a float or "top"/"bottom"')
593 
594     @_docstring.dedent_interpd
595     def secondary_yaxis(self, location, *, functions=None, **kwargs):
596         """
597         Add a second y-axis to this `~.axes.Axes`.
598 
599         For example if we want to have a second scale for the data plotted on
600         the yaxis.
601 
602         %(_secax_docstring)s
603 
604         Examples
605         --------
606         Add a secondary Axes that converts from radians to degrees
607 
608         .. plot::
609 
610             fig, ax = plt.subplots()
611             ax.plot(range(1, 360, 5), range(1, 360, 5))
612             ax.set_ylabel('degrees')
613             secax = ax.secondary_yaxis('right', functions=(np.deg2rad,
614                                                            np.rad2deg))
615             secax.set_ylabel('radians')
616         """
617         if location in ['left', 'right'] or isinstance(location, Real):
618             secondary_ax = SecondaryAxis(self, 'y', location,
619                                          functions, **kwargs)
620             self.add_child_axes(secondary_ax)
621             return secondary_ax
622         else:
623             raise ValueError('secondary_yaxis location must be either '
624                              'a float or "left"/"right"')
625 
626     @_docstring.dedent_interpd
627     def text(self, x, y, s, fontdict=None, **kwargs):
628         """
629         Add text to the Axes.
630 
631         Add the text *s* to the Axes at location *x*, *y* in data coordinates.
632 
633         Parameters
634         ----------
635         x, y : float
636             The position to place the text. By default, this is in data
637             coordinates. The coordinate system can be changed using the
638             *transform* parameter.
639 
640         s : str
641             The text.
642 
643         fontdict : dict, default: None
644             A dictionary to override the default text properties. If fontdict
645             is None, the defaults are determined by `.rcParams`.
646 
647         Returns
648         -------
649         `.Text`
650             The created `.Text` instance.
651 
652         Other Parameters
653         ----------------
654         **kwargs : `~matplotlib.text.Text` properties.
655             Other miscellaneous text parameters.
656 
657             %(Text:kwdoc)s
658 
659         Examples
660         --------
661         Individual keyword arguments can be used to override any given
662         parameter::
663 
664             >>> text(x, y, s, fontsize=12)
665 
666         The default transform specifies that text is in data coords,
667         alternatively, you can specify text in axis coords ((0, 0) is
668         lower-left and (1, 1) is upper-right).  The example below places
669         text in the center of the Axes::
670 
671             >>> text(0.5, 0.5, 'matplotlib', horizontalalignment='center',
672             ...      verticalalignment='center', transform=ax.transAxes)
673 
674         You can put a rectangular box around the text instance (e.g., to
675         set a background color) by using the keyword *bbox*.  *bbox* is
676         a dictionary of `~matplotlib.patches.Rectangle`
677         properties.  For example::
678 
679             >>> text(x, y, s, bbox=dict(facecolor='red', alpha=0.5))
680         """
681         effective_kwargs = {
682             'verticalalignment': 'baseline',
683             'horizontalalignment': 'left',
684             'transform': self.transData,
685             'clip_on': False,
686             **(fontdict if fontdict is not None else {}),
687             **kwargs,
688         }
689         t = mtext.Text(x, y, text=s, **effective_kwargs)
690         t.set_clip_path(self.patch)
691         self._add_text(t)
692         return t
693 
694     @_docstring.dedent_interpd
695     def annotate(self, text, xy, xytext=None, xycoords='data', textcoords=None,
696                  arrowprops=None, annotation_clip=None, **kwargs):
697         # Signature must match Annotation. This is verified in
698         # test_annotate_signature().
699         a = mtext.Annotation(text, xy, xytext=xytext, xycoords=xycoords,
700                              textcoords=textcoords, arrowprops=arrowprops,
701                              annotation_clip=annotation_clip, **kwargs)
702         a.set_transform(mtransforms.IdentityTransform())
703         if 'clip_on' in kwargs:
704             a.set_clip_path(self.patch)
705         self._add_text(a)
706         return a
707     annotate.__doc__ = mtext.Annotation.__init__.__doc__
708     #### Lines and spans
709 
710     @_docstring.dedent_interpd
711     def axhline(self, y=0, xmin=0, xmax=1, **kwargs):
712         """
713         Add a horizontal line across the Axes.
714 
715         Parameters
716         ----------
717         y : float, default: 0
718             y position in data coordinates of the horizontal line.
719 
720         xmin : float, default: 0
721             Should be between 0 and 1, 0 being the far left of the plot, 1 the
722             far right of the plot.
723 
724         xmax : float, default: 1
725             Should be between 0 and 1, 0 being the far left of the plot, 1 the
726             far right of the plot.
727 
728         Returns
729         -------
730         `~matplotlib.lines.Line2D`
731 
732         Other Parameters
733         ----------------
734         **kwargs
735             Valid keyword arguments are `.Line2D` properties, except for
736             'transform':
737 
738             %(Line2D:kwdoc)s
739 
740         See Also
741         --------
742         hlines : Add horizontal lines in data coordinates.
743         axhspan : Add a horizontal span (rectangle) across the axis.
744         axline : Add a line with an arbitrary slope.
745 
746         Examples
747         --------
748         * draw a thick red hline at 'y' = 0 that spans the xrange::
749 
750             >>> axhline(linewidth=4, color='r')
751 
752         * draw a default hline at 'y' = 1 that spans the xrange::
753 
754             >>> axhline(y=1)
755 
756         * draw a default hline at 'y' = .5 that spans the middle half of
757           the xrange::
758 
759             >>> axhline(y=.5, xmin=0.25, xmax=0.75)
760         """
761         self._check_no_units([xmin, xmax], ['xmin', 'xmax'])
762         if "transform" in kwargs:
763             raise ValueError("'transform' is not allowed as a keyword "
764                              "argument; axhline generates its own transform.")
765         ymin, ymax = self.get_ybound()
766 
767         # Strip away the units for comparison with non-unitized bounds.
768         yy, = self._process_unit_info([("y", y)], kwargs)
769         scaley = (yy < ymin) or (yy > ymax)
770 
771         trans = self.get_yaxis_transform(which='grid')
772         l = mlines.Line2D([xmin, xmax], [y, y], transform=trans, **kwargs)
773         self.add_line(l)
774         if scaley:
775             self._request_autoscale_view("y")
776         return l
777 
778     @_docstring.dedent_interpd
779     def axvline(self, x=0, ymin=0, ymax=1, **kwargs):
780         """
781         Add a vertical line across the Axes.
782 
783         Parameters
784         ----------
785         x : float, default: 0
786             x position in data coordinates of the vertical line.
787 
788         ymin : float, default: 0
789             Should be between 0 and 1, 0 being the bottom of the plot, 1 the
790             top of the plot.
791 
792         ymax : float, default: 1
793             Should be between 0 and 1, 0 being the bottom of the plot, 1 the
794             top of the plot.
795 
796         Returns
797         -------
798         `~matplotlib.lines.Line2D`
799 
800         Other Parameters
801         ----------------
802         **kwargs
803             Valid keyword arguments are `.Line2D` properties, except for
804             'transform':
805 
806             %(Line2D:kwdoc)s
807 
808         See Also
809         --------
810         vlines : Add vertical lines in data coordinates.
811         axvspan : Add a vertical span (rectangle) across the axis.
812         axline : Add a line with an arbitrary slope.
813 
814         Examples
815         --------
816         * draw a thick red vline at *x* = 0 that spans the yrange::
817 
818             >>> axvline(linewidth=4, color='r')
819 
820         * draw a default vline at *x* = 1 that spans the yrange::
821 
822             >>> axvline(x=1)
823 
824         * draw a default vline at *x* = .5 that spans the middle half of
825           the yrange::
826 
827             >>> axvline(x=.5, ymin=0.25, ymax=0.75)
828         """
829         self._check_no_units([ymin, ymax], ['ymin', 'ymax'])
830         if "transform" in kwargs:
831             raise ValueError("'transform' is not allowed as a keyword "
832                              "argument; axvline generates its own transform.")
833         xmin, xmax = self.get_xbound()
834 
835         # Strip away the units for comparison with non-unitized bounds.
836         xx, = self._process_unit_info([("x", x)], kwargs)
837         scalex = (xx < xmin) or (xx > xmax)
838 
839         trans = self.get_xaxis_transform(which='grid')
840         l = mlines.Line2D([x, x], [ymin, ymax], transform=trans, **kwargs)
841         self.add_line(l)
842         if scalex:
843             self._request_autoscale_view("x")
844         return l
845 
846     @staticmethod
847     def _check_no_units(vals, names):
848         # Helper method to check that vals are not unitized
849         for val, name in zip(vals, names):
850             if not munits._is_natively_supported(val):
851                 raise ValueError(f"{name} must be a single scalar value, "
852                                  f"but got {val}")
853 
854     @_docstring.dedent_interpd
855     def axline(self, xy1, xy2=None, *, slope=None, **kwargs):
856         """
857         Add an infinitely long straight line.
858 
859         The line can be defined either by two points *xy1* and *xy2*, or
860         by one point *xy1* and a *slope*.
861 
862         This draws a straight line "on the screen", regardless of the x and y
863         scales, and is thus also suitable for drawing exponential decays in
864         semilog plots, power laws in loglog plots, etc. However, *slope*
865         should only be used with linear scales; It has no clear meaning for
866         all other scales, and thus the behavior is undefined. Please specify
867         the line using the points *xy1*, *xy2* for non-linear scales.
868 
869         The *transform* keyword argument only applies to the points *xy1*,
870         *xy2*. The *slope* (if given) is always in data coordinates. This can
871         be used e.g. with ``ax.transAxes`` for drawing grid lines with a fixed
872         slope.
873 
874         Parameters
875         ----------
876         xy1, xy2 : (float, float)
877             Points for the line to pass through.
878             Either *xy2* or *slope* has to be given.
879         slope : float, optional
880             The slope of the line. Either *xy2* or *slope* has to be given.
881 
882         Returns
883         -------
884         `.Line2D`
885 
886         Other Parameters
887         ----------------
888         **kwargs
889             Valid kwargs are `.Line2D` properties
890 
891             %(Line2D:kwdoc)s
892 
893         See Also
894         --------
895         axhline : for horizontal lines
896         axvline : for vertical lines
897 
898         Examples
899         --------
900         Draw a thick red line passing through (0, 0) and (1, 1)::
901 
902             >>> axline((0, 0), (1, 1), linewidth=4, color='r')
903         """
904         if slope is not None and (self.get_xscale() != 'linear' or
905                                   self.get_yscale() != 'linear'):
906             raise TypeError("'slope' cannot be used with non-linear scales")
907 
908         datalim = [xy1] if xy2 is None else [xy1, xy2]
909         if "transform" in kwargs:
910             # if a transform is passed (i.e. line points not in data space),
911             # data limits should not be adjusted.
912             datalim = []
913 
914         line = mlines._AxLine(xy1, xy2, slope, **kwargs)
915         # Like add_line, but correctly handling data limits.
916         self._set_artist_props(line)
917         if line.get_clip_path() is None:
918             line.set_clip_path(self.patch)
919         if not line.get_label():
920             line.set_label(f"_child{len(self._children)}")
921         self._children.append(line)
922         line._remove_method = self._children.remove
923         self.update_datalim(datalim)
924 
925         self._request_autoscale_view()
926         return line
927 
928     @_docstring.dedent_interpd
929     def axhspan(self, ymin, ymax, xmin=0, xmax=1, **kwargs):
930         """
931         Add a horizontal span (rectangle) across the Axes.
932 
933         The rectangle spans from *ymin* to *ymax* vertically, and, by default,
934         the whole x-axis horizontally.  The x-span can be set using *xmin*
935         (default: 0) and *xmax* (default: 1) which are in axis units; e.g.
936         ``xmin = 0.5`` always refers to the middle of the x-axis regardless of
937         the limits set by `~.Axes.set_xlim`.
938 
939         Parameters
940         ----------
941         ymin : float
942             Lower y-coordinate of the span, in data units.
943         ymax : float
944             Upper y-coordinate of the span, in data units.
945         xmin : float, default: 0
946             Lower x-coordinate of the span, in x-axis (0-1) units.
947         xmax : float, default: 1
948             Upper x-coordinate of the span, in x-axis (0-1) units.
949 
950         Returns
951         -------
952         `~matplotlib.patches.Polygon`
953             Horizontal span (rectangle) from (xmin, ymin) to (xmax, ymax).
954 
955         Other Parameters
956         ----------------
957         **kwargs : `~matplotlib.patches.Polygon` properties
958 
959         %(Polygon:kwdoc)s
960 
961         See Also
962         --------
963         axvspan : Add a vertical span across the Axes.
964         """
965         # Strip units away.
966         self._check_no_units([xmin, xmax], ['xmin', 'xmax'])
967         (ymin, ymax), = self._process_unit_info([("y", [ymin, ymax])], kwargs)
968 
969         verts = (xmin, ymin), (xmin, ymax), (xmax, ymax), (xmax, ymin)
970         p = mpatches.Polygon(verts, **kwargs)
971         p.set_transform(self.get_yaxis_transform(which="grid"))
972         self.add_patch(p)
973         self._request_autoscale_view("y")
974         return p
975 
976     @_docstring.dedent_interpd
977     def axvspan(self, xmin, xmax, ymin=0, ymax=1, **kwargs):
978         """
979         Add a vertical span (rectangle) across the Axes.
980 
981         The rectangle spans from *xmin* to *xmax* horizontally, and, by
982         default, the whole y-axis vertically.  The y-span can be set using
983         *ymin* (default: 0) and *ymax* (default: 1) which are in axis units;
984         e.g. ``ymin = 0.5`` always refers to the middle of the y-axis
985         regardless of the limits set by `~.Axes.set_ylim`.
986 
987         Parameters
988         ----------
989         xmin : float
990             Lower x-coordinate of the span, in data units.
991         xmax : float
992             Upper x-coordinate of the span, in data units.
993         ymin : float, default: 0
994             Lower y-coordinate of the span, in y-axis units (0-1).
995         ymax : float, default: 1
996             Upper y-coordinate of the span, in y-axis units (0-1).
997 
998         Returns
999         -------
1000         `~matplotlib.patches.Polygon`
1001             Vertical span (rectangle) from (xmin, ymin) to (xmax, ymax).
1002 
1003         Other Parameters
1004         ----------------
1005         **kwargs : `~matplotlib.patches.Polygon` properties
1006 
1007         %(Polygon:kwdoc)s
1008 
1009         See Also
1010         --------
1011         axhspan : Add a horizontal span across the Axes.
1012 
1013         Examples
1014         --------
1015         Draw a vertical, green, translucent rectangle from x = 1.25 to
1016         x = 1.55 that spans the yrange of the Axes.
1017 
1018         >>> axvspan(1.25, 1.55, facecolor='g', alpha=0.5)
1019 
1020         """
1021         # Strip units away.
1022         self._check_no_units([ymin, ymax], ['ymin', 'ymax'])
1023         (xmin, xmax), = self._process_unit_info([("x", [xmin, xmax])], kwargs)
1024 
1025         verts = [(xmin, ymin), (xmin, ymax), (xmax, ymax), (xmax, ymin)]
1026         p = mpatches.Polygon(verts, **kwargs)
1027         p.set_transform(self.get_xaxis_transform(which="grid"))
1028         p.get_path()._interpolation_steps = 100
1029         self.add_patch(p)
1030         self._request_autoscale_view("x")
1031         return p
1032 
1033     @_preprocess_data(replace_names=["y", "xmin", "xmax", "colors"],
1034                       label_namer="y")
1035     def hlines(self, y, xmin, xmax, colors=None, linestyles='solid',
1036                label='', **kwargs):
1037         """
1038         Plot horizontal lines at each *y* from *xmin* to *xmax*.
1039 
1040         Parameters
1041         ----------
1042         y : float or array-like
1043             y-indexes where to plot the lines.
1044 
1045         xmin, xmax : float or array-like
1046             Respective beginning and end of each line. If scalars are
1047             provided, all lines will have the same length.
1048 
1049         colors : list of colors, default: :rc:`lines.color`
1050 
1051         linestyles : {'solid', 'dashed', 'dashdot', 'dotted'}, optional
1052 
1053         label : str, default: ''
1054 
1055         Returns
1056         -------
1057         `~matplotlib.collections.LineCollection`
1058 
1059         Other Parameters
1060         ----------------
1061         data : indexable object, optional
1062             DATA_PARAMETER_PLACEHOLDER
1063         **kwargs :  `~matplotlib.collections.LineCollection` properties.
1064 
1065         See Also
1066         --------
1067         vlines : vertical lines
1068         axhline : horizontal line across the Axes
1069         """
1070 
1071         # We do the conversion first since not all unitized data is uniform
1072         xmin, xmax, y = self._process_unit_info(
1073             [("x", xmin), ("x", xmax), ("y", y)], kwargs)
1074 
1075         if not np.iterable(y):
1076             y = [y]
1077         if not np.iterable(xmin):
1078             xmin = [xmin]
1079         if not np.iterable(xmax):
1080             xmax = [xmax]
1081 
1082         # Create and combine masked_arrays from input
1083         y, xmin, xmax = cbook._combine_masks(y, xmin, xmax)
1084         y = np.ravel(y)
1085         xmin = np.ravel(xmin)
1086         xmax = np.ravel(xmax)
1087 
1088         masked_verts = np.ma.empty((len(y), 2, 2))
1089         masked_verts[:, 0, 0] = xmin
1090         masked_verts[:, 0, 1] = y
1091         masked_verts[:, 1, 0] = xmax
1092         masked_verts[:, 1, 1] = y
1093 
1094         lines = mcoll.LineCollection(masked_verts, colors=colors,
1095                                      linestyles=linestyles, label=label)
1096         self.add_collection(lines, autolim=False)
1097         lines._internal_update(kwargs)
1098 
1099         if len(y) > 0:
1100             # Extreme values of xmin/xmax/y.  Using masked_verts here handles
1101             # the case of y being a masked *object* array (as can be generated
1102             # e.g. by errorbar()), which would make nanmin/nanmax stumble.
1103             minx = np.nanmin(masked_verts[..., 0])
1104             maxx = np.nanmax(masked_verts[..., 0])
1105             miny = np.nanmin(masked_verts[..., 1])
1106             maxy = np.nanmax(masked_verts[..., 1])
1107             corners = (minx, miny), (maxx, maxy)
1108             self.update_datalim(corners)
1109             self._request_autoscale_view()
1110 
1111         return lines
1112 
1113     @_preprocess_data(replace_names=["x", "ymin", "ymax", "colors"],
1114                       label_namer="x")
1115     def vlines(self, x, ymin, ymax, colors=None, linestyles='solid',
1116                label='', **kwargs):
1117         """
1118         Plot vertical lines at each *x* from *ymin* to *ymax*.
1119 
1120         Parameters
1121         ----------
1122         x : float or array-like
1123             x-indexes where to plot the lines.
1124 
1125         ymin, ymax : float or array-like
1126             Respective beginning and end of each line. If scalars are
1127             provided, all lines will have the same length.
1128 
1129         colors : list of colors, default: :rc:`lines.color`
1130 
1131         linestyles : {'solid', 'dashed', 'dashdot', 'dotted'}, optional
1132 
1133         label : str, default: ''
1134 
1135         Returns
1136         -------
1137         `~matplotlib.collections.LineCollection`
1138 
1139         Other Parameters
1140         ----------------
1141         data : indexable object, optional
1142             DATA_PARAMETER_PLACEHOLDER
1143         **kwargs : `~matplotlib.collections.LineCollection` properties.
1144 
1145         See Also
1146         --------
1147         hlines : horizontal lines
1148         axvline : vertical line across the Axes
1149         """
1150 
1151         # We do the conversion first since not all unitized data is uniform
1152         x, ymin, ymax = self._process_unit_info(
1153             [("x", x), ("y", ymin), ("y", ymax)], kwargs)
1154 
1155         if not np.iterable(x):
1156             x = [x]
1157         if not np.iterable(ymin):
1158             ymin = [ymin]
1159         if not np.iterable(ymax):
1160             ymax = [ymax]
1161 
1162         # Create and combine masked_arrays from input
1163         x, ymin, ymax = cbook._combine_masks(x, ymin, ymax)
1164         x = np.ravel(x)
1165         ymin = np.ravel(ymin)
1166         ymax = np.ravel(ymax)
1167 
1168         masked_verts = np.ma.empty((len(x), 2, 2))
1169         masked_verts[:, 0, 0] = x
1170         masked_verts[:, 0, 1] = ymin
1171         masked_verts[:, 1, 0] = x
1172         masked_verts[:, 1, 1] = ymax
1173 
1174         lines = mcoll.LineCollection(masked_verts, colors=colors,
1175                                      linestyles=linestyles, label=label)
1176         self.add_collection(lines, autolim=False)
1177         lines._internal_update(kwargs)
1178 
1179         if len(x) > 0:
1180             # Extreme values of x/ymin/ymax.  Using masked_verts here handles
1181             # the case of x being a masked *object* array (as can be generated
1182             # e.g. by errorbar()), which would make nanmin/nanmax stumble.
1183             minx = np.nanmin(masked_verts[..., 0])
1184             maxx = np.nanmax(masked_verts[..., 0])
1185             miny = np.nanmin(masked_verts[..., 1])
1186             maxy = np.nanmax(masked_verts[..., 1])
1187             corners = (minx, miny), (maxx, maxy)
1188             self.update_datalim(corners)
1189             self._request_autoscale_view()
1190 
1191         return lines
1192 
1193     @_preprocess_data(replace_names=["positions", "lineoffsets",
1194                                      "linelengths", "linewidths",
1195                                      "colors", "linestyles"])
1196     @_docstring.dedent_interpd
1197     def eventplot(self, positions, orientation='horizontal', lineoffsets=1,
1198                   linelengths=1, linewidths=None, colors=None, alpha=None,
1199                   linestyles='solid', **kwargs):
1200         """
1201         Plot identical parallel lines at the given positions.
1202 
1203         This type of plot is commonly used in neuroscience for representing
1204         neural events, where it is usually called a spike raster, dot raster,
1205         or raster plot.
1206 
1207         However, it is useful in any situation where you wish to show the
1208         timing or position of multiple sets of discrete events, such as the
1209         arrival times of people to a business on each day of the month or the
1210         date of hurricanes each year of the last century.
1211 
1212         Parameters
1213         ----------
1214         positions : array-like or list of array-like
1215             A 1D array-like defines the positions of one sequence of events.
1216 
1217             Multiple groups of events may be passed as a list of array-likes.
1218             Each group can be styled independently by passing lists of values
1219             to *lineoffsets*, *linelengths*, *linewidths*, *colors* and
1220             *linestyles*.
1221 
1222             Note that *positions* can be a 2D array, but in practice different
1223             event groups usually have different counts so that one will use a
1224             list of different-length arrays rather than a 2D array.
1225 
1226         orientation : {'horizontal', 'vertical'}, default: 'horizontal'
1227             The direction of the event sequence:
1228 
1229             - 'horizontal': the events are arranged horizontally.
1230               The indicator lines are vertical.
1231             - 'vertical': the events are arranged vertically.
1232               The indicator lines are horizontal.
1233 
1234         lineoffsets : float or array-like, default: 1
1235             The offset of the center of the lines from the origin, in the
1236             direction orthogonal to *orientation*.
1237 
1238             If *positions* is 2D, this can be a sequence with length matching
1239             the length of *positions*.
1240 
1241         linelengths : float or array-like, default: 1
1242             The total height of the lines (i.e. the lines stretches from
1243             ``lineoffset - linelength/2`` to ``lineoffset + linelength/2``).
1244 
1245             If *positions* is 2D, this can be a sequence with length matching
1246             the length of *positions*.
1247 
1248         linewidths : float or array-like, default: :rc:`lines.linewidth`
1249             The line width(s) of the event lines, in points.
1250 
1251             If *positions* is 2D, this can be a sequence with length matching
1252             the length of *positions*.
1253 
1254         colors : color or list of colors, default: :rc:`lines.color`
1255             The color(s) of the event lines.
1256 
1257             If *positions* is 2D, this can be a sequence with length matching
1258             the length of *positions*.
1259 
1260         alpha : float or array-like, default: 1
1261             The alpha blending value(s), between 0 (transparent) and 1
1262             (opaque).
1263 
1264             If *positions* is 2D, this can be a sequence with length matching
1265             the length of *positions*.
1266 
1267         linestyles : str or tuple or list of such values, default: 'solid'
1268             Default is 'solid'. Valid strings are ['solid', 'dashed',
1269             'dashdot', 'dotted', '-', '--', '-.', ':']. Dash tuples
1270             should be of the form::
1271 
1272                 (offset, onoffseq),
1273 
1274             where *onoffseq* is an even length tuple of on and off ink
1275             in points.
1276 
1277             If *positions* is 2D, this can be a sequence with length matching
1278             the length of *positions*.
1279 
1280         data : indexable object, optional
1281             DATA_PARAMETER_PLACEHOLDER
1282 
1283         **kwargs
1284             Other keyword arguments are line collection properties.  See
1285             `.LineCollection` for a list of the valid properties.
1286 
1287         Returns
1288         -------
1289         list of `.EventCollection`
1290             The `.EventCollection` that were added.
1291 
1292         Notes
1293         -----
1294         For *linelengths*, *linewidths*, *colors*, *alpha* and *linestyles*, if
1295         only a single value is given, that value is applied to all lines. If an
1296         array-like is given, it must have the same length as *positions*, and
1297         each value will be applied to the corresponding row of the array.
1298 
1299         Examples
1300         --------
1301         .. plot:: gallery/lines_bars_and_markers/eventplot_demo.py
1302         """
1303 
1304         lineoffsets, linelengths = self._process_unit_info(
1305                 [("y", lineoffsets), ("y", linelengths)], kwargs)
1306 
1307         # fix positions, noting that it can be a list of lists:
1308         if not np.iterable(positions):
1309             positions = [positions]
1310         elif any(np.iterable(position) for position in positions):
1311             positions = [np.asanyarray(position) for position in positions]
1312         else:
1313             positions = [np.asanyarray(positions)]
1314 
1315         if len(positions) == 0:
1316             return []
1317 
1318         poss = []
1319         for position in positions:
1320             poss += self._process_unit_info([("x", position)], kwargs)
1321         positions = poss
1322 
1323         # prevent 'singular' keys from **kwargs dict from overriding the effect
1324         # of 'plural' keyword arguments (e.g. 'color' overriding 'colors')
1325         colors = cbook._local_over_kwdict(colors, kwargs, 'color')
1326         linewidths = cbook._local_over_kwdict(linewidths, kwargs, 'linewidth')
1327         linestyles = cbook._local_over_kwdict(linestyles, kwargs, 'linestyle')
1328 
1329         if not np.iterable(lineoffsets):
1330             lineoffsets = [lineoffsets]
1331         if not np.iterable(linelengths):
1332             linelengths = [linelengths]
1333         if not np.iterable(linewidths):
1334             linewidths = [linewidths]
1335         if not np.iterable(colors):
1336             colors = [colors]
1337         if not np.iterable(alpha):
1338             alpha = [alpha]
1339         if hasattr(linestyles, 'lower') or not np.iterable(linestyles):
1340             linestyles = [linestyles]
1341 
1342         lineoffsets = np.asarray(lineoffsets)
1343         linelengths = np.asarray(linelengths)
1344         linewidths = np.asarray(linewidths)
1345 
1346         if len(lineoffsets) == 0:
1347             lineoffsets = [None]
1348         if len(linelengths) == 0:
1349             linelengths = [None]
1350         if len(linewidths) == 0:
1351             lineoffsets = [None]
1352         if len(linewidths) == 0:
1353             lineoffsets = [None]
1354         if len(colors) == 0:
1355             colors = [None]
1356         try:
1357             # Early conversion of the colors into RGBA values to take care
1358             # of cases like colors='0.5' or colors='C1'.  (Issue #8193)
1359             colors = mcolors.to_rgba_array(colors)
1360         except ValueError:
1361             # Will fail if any element of *colors* is None. But as long
1362             # as len(colors) == 1 or len(positions), the rest of the
1363             # code should process *colors* properly.
1364             pass
1365 
1366         if len(lineoffsets) == 1 and len(positions) != 1:
1367             lineoffsets = np.tile(lineoffsets, len(positions))
1368             lineoffsets[0] = 0
1369             lineoffsets = np.cumsum(lineoffsets)
1370         if len(linelengths) == 1:
1371             linelengths = np.tile(linelengths, len(positions))
1372         if len(linewidths) == 1:
1373             linewidths = np.tile(linewidths, len(positions))
1374         if len(colors) == 1:
1375             colors = list(colors) * len(positions)
1376         if len(alpha) == 1:
1377             alpha = list(alpha) * len(positions)
1378         if len(linestyles) == 1:
1379             linestyles = [linestyles] * len(positions)
1380 
1381         if len(lineoffsets) != len(positions):
1382             raise ValueError('lineoffsets and positions are unequal sized '
1383                              'sequences')
1384         if len(linelengths) != len(positions):
1385             raise ValueError('linelengths and positions are unequal sized '
1386                              'sequences')
1387         if len(linewidths) != len(positions):
1388             raise ValueError('linewidths and positions are unequal sized '
1389                              'sequences')
1390         if len(colors) != len(positions):
1391             raise ValueError('colors and positions are unequal sized '
1392                              'sequences')
1393         if len(alpha) != len(positions):
1394             raise ValueError('alpha and positions are unequal sized '
1395                              'sequences')
1396         if len(linestyles) != len(positions):
1397             raise ValueError('linestyles and positions are unequal sized '
1398                              'sequences')
1399 
1400         colls = []
1401         for position, lineoffset, linelength, linewidth, color, alpha_, \
1402             linestyle in \
1403                 zip(positions, lineoffsets, linelengths, linewidths,
1404                     colors, alpha, linestyles):
1405             coll = mcoll.EventCollection(position,
1406                                          orientation=orientation,
1407                                          lineoffset=lineoffset,
1408                                          linelength=linelength,
1409                                          linewidth=linewidth,
1410                                          color=color,
1411                                          alpha=alpha_,
1412                                          linestyle=linestyle)
1413             self.add_collection(coll, autolim=False)
1414             coll._internal_update(kwargs)
1415             colls.append(coll)
1416 
1417         if len(positions) > 0:
1418             # try to get min/max
1419             min_max = [(np.min(_p), np.max(_p)) for _p in positions
1420                        if len(_p) > 0]
1421             # if we have any non-empty positions, try to autoscale
1422             if len(min_max) > 0:
1423                 mins, maxes = zip(*min_max)
1424                 minpos = np.min(mins)
1425                 maxpos = np.max(maxes)
1426 
1427                 minline = (lineoffsets - linelengths).min()
1428                 maxline = (lineoffsets + linelengths).max()
1429 
1430                 if orientation == "vertical":
1431                     corners = (minline, minpos), (maxline, maxpos)
1432                 else:  # "horizontal"
1433                     corners = (minpos, minline), (maxpos, maxline)
1434                 self.update_datalim(corners)
1435                 self._request_autoscale_view()
1436 
1437         return colls
1438 
1439     #### Basic plotting
1440 
1441     # Uses a custom implementation of data-kwarg handling in
1442     # _process_plot_var_args.
1443     @_docstring.dedent_interpd
1444     def plot(self, *args, scalex=True, scaley=True, data=None, **kwargs):
1445         """
1446         Plot y versus x as lines and/or markers.
1447 
1448         Call signatures::
1449 
1450             plot([x], y, [fmt], *, data=None, **kwargs)
1451             plot([x], y, [fmt], [x2], y2, [fmt2], ..., **kwargs)
1452 
1453         The coordinates of the points or line nodes are given by *x*, *y*.
1454 
1455         The optional parameter *fmt* is a convenient way for defining basic
1456         formatting like color, marker and linestyle. It's a shortcut string
1457         notation described in the *Notes* section below.
1458 
1459         >>> plot(x, y)        # plot x and y using default line style and color
1460         >>> plot(x, y, 'bo')  # plot x and y using blue circle markers
1461         >>> plot(y)           # plot y using x as index array 0..N-1
1462         >>> plot(y, 'r+')     # ditto, but with red plusses
1463 
1464         You can use `.Line2D` properties as keyword arguments for more
1465         control on the appearance. Line properties and *fmt* can be mixed.
1466         The following two calls yield identical results:
1467 
1468         >>> plot(x, y, 'go--', linewidth=2, markersize=12)
1469         >>> plot(x, y, color='green', marker='o', linestyle='dashed',
1470         ...      linewidth=2, markersize=12)
1471 
1472         When conflicting with *fmt*, keyword arguments take precedence.
1473 
1474 
1475         **Plotting labelled data**
1476 
1477         There's a convenient way for plotting objects with labelled data (i.e.
1478         data that can be accessed by index ``obj['y']``). Instead of giving
1479         the data in *x* and *y*, you can provide the object in the *data*
1480         parameter and just give the labels for *x* and *y*::
1481 
1482         >>> plot('xlabel', 'ylabel', data=obj)
1483 
1484         All indexable objects are supported. This could e.g. be a `dict`, a
1485         `pandas.DataFrame` or a structured numpy array.
1486 
1487 
1488         **Plotting multiple sets of data**
1489 
1490         There are various ways to plot multiple sets of data.
1491 
1492         - The most straight forward way is just to call `plot` multiple times.
1493           Example:
1494 
1495           >>> plot(x1, y1, 'bo')
1496           >>> plot(x2, y2, 'go')
1497 
1498         - If *x* and/or *y* are 2D arrays a separate data set will be drawn
1499           for every column. If both *x* and *y* are 2D, they must have the
1500           same shape. If only one of them is 2D with shape (N, m) the other
1501           must have length N and will be used for every data set m.
1502 
1503           Example:
1504 
1505           >>> x = [1, 2, 3]
1506           >>> y = np.array([[1, 2], [3, 4], [5, 6]])
1507           >>> plot(x, y)
1508 
1509           is equivalent to:
1510 
1511           >>> for col in range(y.shape[1]):
1512           ...     plot(x, y[:, col])
1513 
1514         - The third way is to specify multiple sets of *[x]*, *y*, *[fmt]*
1515           groups::
1516 
1517           >>> plot(x1, y1, 'g^', x2, y2, 'g-')
1518 
1519           In this case, any additional keyword argument applies to all
1520           datasets. Also, this syntax cannot be combined with the *data*
1521           parameter.
1522 
1523         By default, each line is assigned a different style specified by a
1524         'style cycle'. The *fmt* and line property parameters are only
1525         necessary if you want explicit deviations from these defaults.
1526         Alternatively, you can also change the style cycle using
1527         :rc:`axes.prop_cycle`.
1528 
1529 
1530         Parameters
1531         ----------
1532         x, y : array-like or scalar
1533             The horizontal / vertical coordinates of the data points.
1534             *x* values are optional and default to ``range(len(y))``.
1535 
1536             Commonly, these parameters are 1D arrays.
1537 
1538             They can also be scalars, or two-dimensional (in that case, the
1539             columns represent separate data sets).
1540 
1541             These arguments cannot be passed as keywords.
1542 
1543         fmt : str, optional
1544             A format string, e.g. 'ro' for red circles. See the *Notes*
1545             section for a full description of the format strings.
1546 
1547             Format strings are just an abbreviation for quickly setting
1548             basic line properties. All of these and more can also be
1549             controlled by keyword arguments.
1550 
1551             This argument cannot be passed as keyword.
1552 
1553         data : indexable object, optional
1554             An object with labelled data. If given, provide the label names to
1555             plot in *x* and *y*.
1556 
1557             .. note::
1558                 Technically there's a slight ambiguity in calls where the
1559                 second label is a valid *fmt*. ``plot('n', 'o', data=obj)``
1560                 could be ``plt(x, y)`` or ``plt(y, fmt)``. In such cases,
1561                 the former interpretation is chosen, but a warning is issued.
1562                 You may suppress the warning by adding an empty format string
1563                 ``plot('n', 'o', '', data=obj)``.
1564 
1565         Returns
1566         -------
1567         list of `.Line2D`
1568             A list of lines representing the plotted data.
1569 
1570         Other Parameters
1571         ----------------
1572         scalex, scaley : bool, default: True
1573             These parameters determine if the view limits are adapted to the
1574             data limits. The values are passed on to
1575             `~.axes.Axes.autoscale_view`.
1576 
1577         **kwargs : `.Line2D` properties, optional
1578             *kwargs* are used to specify properties like a line label (for
1579             auto legends), linewidth, antialiasing, marker face color.
1580             Example::
1581 
1582             >>> plot([1, 2, 3], [1, 2, 3], 'go-', label='line 1', linewidth=2)
1583             >>> plot([1, 2, 3], [1, 4, 9], 'rs', label='line 2')
1584 
1585             If you specify multiple lines with one plot call, the kwargs apply
1586             to all those lines. In case the label object is iterable, each
1587             element is used as labels for each set of data.
1588 
1589             Here is a list of available `.Line2D` properties:
1590 
1591             %(Line2D:kwdoc)s
1592 
1593         See Also
1594         --------
1595         scatter : XY scatter plot with markers of varying size and/or color (
1596             sometimes also called bubble chart).
1597 
1598         Notes
1599         -----
1600         **Format Strings**
1601 
1602         A format string consists of a part for color, marker and line::
1603 
1604             fmt = '[marker][line][color]'
1605 
1606         Each of them is optional. If not provided, the value from the style
1607         cycle is used. Exception: If ``line`` is given, but no ``marker``,
1608         the data will be a line without markers.
1609 
1610         Other combinations such as ``[color][marker][line]`` are also
1611         supported, but note that their parsing may be ambiguous.
1612 
1613         **Markers**
1614 
1615         =============   ===============================
1616         character       description
1617         =============   ===============================
1618         ``'.'``         point marker
1619         ``','``         pixel marker
1620         ``'o'``         circle marker
1621         ``'v'``         triangle_down marker
1622         ``'^'``         triangle_up marker
1623         ``'<'``         triangle_left marker
1624         ``'>'``         triangle_right marker
1625         ``'1'``         tri_down marker
1626         ``'2'``         tri_up marker
1627         ``'3'``         tri_left marker
1628         ``'4'``         tri_right marker
1629         ``'8'``         octagon marker
1630         ``'s'``         square marker
1631         ``'p'``         pentagon marker
1632         ``'P'``         plus (filled) marker
1633         ``'*'``         star marker
1634         ``'h'``         hexagon1 marker
1635         ``'H'``         hexagon2 marker
1636         ``'+'``         plus marker
1637         ``'x'``         x marker
1638         ``'X'``         x (filled) marker
1639         ``'D'``         diamond marker
1640         ``'d'``         thin_diamond marker
1641         ``'|'``         vline marker
1642         ``'_'``         hline marker
1643         =============   ===============================
1644 
1645         **Line Styles**
1646 
1647         =============    ===============================
1648         character        description
1649         =============    ===============================
1650         ``'-'``          solid line style
1651         ``'--'``         dashed line style
1652         ``'-.'``         dash-dot line style
1653         ``':'``          dotted line style
1654         =============    ===============================
1655 
1656         Example format strings::
1657 
1658             'b'    # blue markers with default shape
1659             'or'   # red circles
1660             '-g'   # green solid line
1661             '--'   # dashed line with default color
1662             '^k:'  # black triangle_up markers connected by a dotted line
1663 
1664         **Colors**
1665 
1666         The supported color abbreviations are the single letter codes
1667 
1668         =============    ===============================
1669         character        color
1670         =============    ===============================
1671         ``'b'``          blue
1672         ``'g'``          green
1673         ``'r'``          red
1674         ``'c'``          cyan
1675         ``'m'``          magenta
1676         ``'y'``          yellow
1677         ``'k'``          black
1678         ``'w'``          white
1679         =============    ===============================
1680 
1681         and the ``'CN'`` colors that index into the default property cycle.
1682 
1683         If the color is the only part of the format string, you can
1684         additionally use any  `matplotlib.colors` spec, e.g. full names
1685         (``'green'``) or hex strings (``'#008000'``).
1686         """
1687         kwargs = cbook.normalize_kwargs(kwargs, mlines.Line2D)
1688         lines = [*self._get_lines(*args, data=data, **kwargs)]
1689         for line in lines:
1690             self.add_line(line)
1691         if scalex:
1692             self._request_autoscale_view("x")
1693         if scaley:
1694             self._request_autoscale_view("y")
1695         return lines
1696 
1697     @_preprocess_data(replace_names=["x", "y"], label_namer="y")
1698     @_docstring.dedent_interpd
1699     def plot_date(self, x, y, fmt='o', tz=None, xdate=True, ydate=False,
1700                   **kwargs):
1701         """
1702         [*Discouraged*] Plot coercing the axis to treat floats as dates.
1703 
1704         .. admonition:: Discouraged
1705 
1706             This method exists for historic reasons and will be deprecated in
1707             the future.
1708 
1709             - ``datetime``-like data should directly be plotted using
1710               `~.Axes.plot`.
1711             -  If you need to plot plain numeric data as :ref:`date-format` or
1712                need to set a timezone, call ``ax.xaxis.axis_date`` /
1713                ``ax.yaxis.axis_date`` before `~.Axes.plot`. See
1714                `.Axis.axis_date`.
1715 
1716         Similar to `.plot`, this plots *y* vs. *x* as lines or markers.
1717         However, the axis labels are formatted as dates depending on *xdate*
1718         and *ydate*.  Note that `.plot` will work with `datetime` and
1719         `numpy.datetime64` objects without resorting to this method.
1720 
1721         Parameters
1722         ----------
1723         x, y : array-like
1724             The coordinates of the data points. If *xdate* or *ydate* is
1725             *True*, the respective values *x* or *y* are interpreted as
1726             :ref:`Matplotlib dates <date-format>`.
1727 
1728         fmt : str, optional
1729             The plot format string. For details, see the corresponding
1730             parameter in `.plot`.
1731 
1732         tz : timezone string or `datetime.tzinfo`, default: :rc:`timezone`
1733             The time zone to use in labeling dates.
1734 
1735         xdate : bool, default: True
1736             If *True*, the *x*-axis will be interpreted as Matplotlib dates.
1737 
1738         ydate : bool, default: False
1739             If *True*, the *y*-axis will be interpreted as Matplotlib dates.
1740 
1741         Returns
1742         -------
1743         list of `.Line2D`
1744             Objects representing the plotted data.
1745 
1746         Other Parameters
1747         ----------------
1748         data : indexable object, optional
1749             DATA_PARAMETER_PLACEHOLDER
1750         **kwargs
1751             Keyword arguments control the `.Line2D` properties:
1752 
1753             %(Line2D:kwdoc)s
1754 
1755         See Also
1756         --------
1757         matplotlib.dates : Helper functions on dates.
1758         matplotlib.dates.date2num : Convert dates to num.
1759         matplotlib.dates.num2date : Convert num to dates.
1760         matplotlib.dates.drange : Create an equally spaced sequence of dates.
1761 
1762         Notes
1763         -----
1764         If you are using custom date tickers and formatters, it may be
1765         necessary to set the formatters/locators after the call to
1766         `.plot_date`. `.plot_date` will set the default tick locator to
1767         `.AutoDateLocator` (if the tick locator is not already set to a
1768         `.DateLocator` instance) and the default tick formatter to
1769         `.AutoDateFormatter` (if the tick formatter is not already set to a
1770         `.DateFormatter` instance).
1771         """
1772         if xdate:
1773             self.xaxis_date(tz)
1774         if ydate:
1775             self.yaxis_date(tz)
1776         return self.plot(x, y, fmt, **kwargs)
1777 
1778     # @_preprocess_data() # let 'plot' do the unpacking..
1779     @_docstring.dedent_interpd
1780     def loglog(self, *args, **kwargs):
1781         """
1782         Make a plot with log scaling on both the x- and y-axis.
1783 
1784         Call signatures::
1785 
1786             loglog([x], y, [fmt], data=None, **kwargs)
1787             loglog([x], y, [fmt], [x2], y2, [fmt2], ..., **kwargs)
1788 
1789         This is just a thin wrapper around `.plot` which additionally changes
1790         both the x-axis and the y-axis to log scaling. All the concepts and
1791         parameters of plot can be used here as well.
1792 
1793         The additional parameters *base*, *subs* and *nonpositive* control the
1794         x/y-axis properties. They are just forwarded to `.Axes.set_xscale` and
1795         `.Axes.set_yscale`. To use different properties on the x-axis and the
1796         y-axis, use e.g.
1797         ``ax.set_xscale("log", base=10); ax.set_yscale("log", base=2)``.
1798 
1799         Parameters
1800         ----------
1801         base : float, default: 10
1802             Base of the logarithm.
1803 
1804         subs : sequence, optional
1805             The location of the minor ticks. If *None*, reasonable locations
1806             are automatically chosen depending on the number of decades in the
1807             plot. See `.Axes.set_xscale`/`.Axes.set_yscale` for details.
1808 
1809         nonpositive : {'mask', 'clip'}, default: 'mask'
1810             Non-positive values can be masked as invalid, or clipped to a very
1811             small positive number.
1812 
1813         **kwargs
1814             All parameters supported by `.plot`.
1815 
1816         Returns
1817         -------
1818         list of `.Line2D`
1819             Objects representing the plotted data.
1820         """
1821         dx = {k: v for k, v in kwargs.items()
1822               if k in ['base', 'subs', 'nonpositive',
1823                        'basex', 'subsx', 'nonposx']}
1824         self.set_xscale('log', **dx)
1825         dy = {k: v for k, v in kwargs.items()
1826               if k in ['base', 'subs', 'nonpositive',
1827                        'basey', 'subsy', 'nonposy']}
1828         self.set_yscale('log', **dy)
1829         return self.plot(
1830             *args, **{k: v for k, v in kwargs.items() if k not in {*dx, *dy}})
1831 
1832     # @_preprocess_data() # let 'plot' do the unpacking..
1833     @_docstring.dedent_interpd
1834     def semilogx(self, *args, **kwargs):
1835         """
1836         Make a plot with log scaling on the x-axis.
1837 
1838         Call signatures::
1839 
1840             semilogx([x], y, [fmt], data=None, **kwargs)
1841             semilogx([x], y, [fmt], [x2], y2, [fmt2], ..., **kwargs)
1842 
1843         This is just a thin wrapper around `.plot` which additionally changes
1844         the x-axis to log scaling. All the concepts and parameters of plot can
1845         be used here as well.
1846 
1847         The additional parameters *base*, *subs*, and *nonpositive* control the
1848         x-axis properties. They are just forwarded to `.Axes.set_xscale`.
1849 
1850         Parameters
1851         ----------
1852         base : float, default: 10
1853             Base of the x logarithm.
1854 
1855         subs : array-like, optional
1856             The location of the minor xticks. If *None*, reasonable locations
1857             are automatically chosen depending on the number of decades in the
1858             plot. See `.Axes.set_xscale` for details.
1859 
1860         nonpositive : {'mask', 'clip'}, default: 'mask'
1861             Non-positive values in x can be masked as invalid, or clipped to a
1862             very small positive number.
1863 
1864         **kwargs
1865             All parameters supported by `.plot`.
1866 
1867         Returns
1868         -------
1869         list of `.Line2D`
1870             Objects representing the plotted data.
1871         """
1872         d = {k: v for k, v in kwargs.items()
1873              if k in ['base', 'subs', 'nonpositive',
1874                       'basex', 'subsx', 'nonposx']}
1875         self.set_xscale('log', **d)
1876         return self.plot(
1877             *args, **{k: v for k, v in kwargs.items() if k not in d})
1878 
1879     # @_preprocess_data() # let 'plot' do the unpacking..
1880     @_docstring.dedent_interpd
1881     def semilogy(self, *args, **kwargs):
1882         """
1883         Make a plot with log scaling on the y-axis.
1884 
1885         Call signatures::
1886 
1887             semilogy([x], y, [fmt], data=None, **kwargs)
1888             semilogy([x], y, [fmt], [x2], y2, [fmt2], ..., **kwargs)
1889 
1890         This is just a thin wrapper around `.plot` which additionally changes
1891         the y-axis to log scaling. All the concepts and parameters of plot can
1892         be used here as well.
1893 
1894         The additional parameters *base*, *subs*, and *nonpositive* control the
1895         y-axis properties. They are just forwarded to `.Axes.set_yscale`.
1896 
1897         Parameters
1898         ----------
1899         base : float, default: 10
1900             Base of the y logarithm.
1901 
1902         subs : array-like, optional
1903             The location of the minor yticks. If *None*, reasonable locations
1904             are automatically chosen depending on the number of decades in the
1905             plot. See `.Axes.set_yscale` for details.
1906 
1907         nonpositive : {'mask', 'clip'}, default: 'mask'
1908             Non-positive values in y can be masked as invalid, or clipped to a
1909             very small positive number.
1910 
1911         **kwargs
1912             All parameters supported by `.plot`.
1913 
1914         Returns
1915         -------
1916         list of `.Line2D`
1917             Objects representing the plotted data.
1918         """
1919         d = {k: v for k, v in kwargs.items()
1920              if k in ['base', 'subs', 'nonpositive',
1921                       'basey', 'subsy', 'nonposy']}
1922         self.set_yscale('log', **d)
1923         return self.plot(
1924             *args, **{k: v for k, v in kwargs.items() if k not in d})
1925 
1926     @_preprocess_data(replace_names=["x"], label_namer="x")
1927     def acorr(self, x, **kwargs):
1928         """
1929         Plot the autocorrelation of *x*.
1930 
1931         Parameters
1932         ----------
1933         x : array-like
1934 
1935         detrend : callable, default: `.mlab.detrend_none` (no detrending)
1936             A detrending function applied to *x*.  It must have the
1937             signature ::
1938 
1939                 detrend(x: np.ndarray) -> np.ndarray
1940 
1941         normed : bool, default: True
1942             If ``True``, input vectors are normalised to unit length.
1943 
1944         usevlines : bool, default: True
1945             Determines the plot style.
1946 
1947             If ``True``, vertical lines are plotted from 0 to the acorr value
1948             using `.Axes.vlines`. Additionally, a horizontal line is plotted
1949             at y=0 using `.Axes.axhline`.
1950 
1951             If ``False``, markers are plotted at the acorr values using
1952             `.Axes.plot`.
1953 
1954         maxlags : int, default: 10
1955             Number of lags to show. If ``None``, will return all
1956             ``2 * len(x) - 1`` lags.
1957 
1958         Returns
1959         -------
1960         lags : array (length ``2*maxlags+1``)
1961             The lag vector.
1962         c : array  (length ``2*maxlags+1``)
1963             The auto correlation vector.
1964         line : `.LineCollection` or `.Line2D`
1965             `.Artist` added to the Axes of the correlation:
1966 
1967             - `.LineCollection` if *usevlines* is True.
1968             - `.Line2D` if *usevlines* is False.
1969         b : `.Line2D` or None
1970             Horizontal line at 0 if *usevlines* is True
1971             None *usevlines* is False.
1972 
1973         Other Parameters
1974         ----------------
1975         linestyle : `.Line2D` property, optional
1976             The linestyle for plotting the data points.
1977             Only used if *usevlines* is ``False``.
1978 
1979         marker : str, default: 'o'
1980             The marker for plotting the data points.
1981             Only used if *usevlines* is ``False``.
1982 
1983         data : indexable object, optional
1984             DATA_PARAMETER_PLACEHOLDER
1985 
1986         **kwargs
1987             Additional parameters are passed to `.Axes.vlines` and
1988             `.Axes.axhline` if *usevlines* is ``True``; otherwise they are
1989             passed to `.Axes.plot`.
1990 
1991         Notes
1992         -----
1993         The cross correlation is performed with `numpy.correlate` with
1994         ``mode = "full"``.
1995         """
1996         return self.xcorr(x, x, **kwargs)
1997 
1998     @_preprocess_data(replace_names=["x", "y"], label_namer="y")
1999     def xcorr(self, x, y, normed=True, detrend=mlab.detrend_none,
2000               usevlines=True, maxlags=10, **kwargs):
2001         r"""
2002         Plot the cross correlation between *x* and *y*.
2003 
2004         The correlation with lag k is defined as
2005         :math:`\sum_n x[n+k] \cdot y^*[n]`, where :math:`y^*` is the complex
2006         conjugate of :math:`y`.
2007 
2008         Parameters
2009         ----------
2010         x, y : array-like of length n
2011 
2012         detrend : callable, default: `.mlab.detrend_none` (no detrending)
2013             A detrending function applied to *x* and *y*.  It must have the
2014             signature ::
2015 
2016                 detrend(x: np.ndarray) -> np.ndarray
2017 
2018         normed : bool, default: True
2019             If ``True``, input vectors are normalised to unit length.
2020 
2021         usevlines : bool, default: True
2022             Determines the plot style.
2023 
2024             If ``True``, vertical lines are plotted from 0 to the xcorr value
2025             using `.Axes.vlines`. Additionally, a horizontal line is plotted
2026             at y=0 using `.Axes.axhline`.
2027 
2028             If ``False``, markers are plotted at the xcorr values using
2029             `.Axes.plot`.
2030 
2031         maxlags : int, default: 10
2032             Number of lags to show. If None, will return all ``2 * len(x) - 1``
2033             lags.
2034 
2035         Returns
2036         -------
2037         lags : array (length ``2*maxlags+1``)
2038             The lag vector.
2039         c : array  (length ``2*maxlags+1``)
2040             The auto correlation vector.
2041         line : `.LineCollection` or `.Line2D`
2042             `.Artist` added to the Axes of the correlation:
2043 
2044             - `.LineCollection` if *usevlines* is True.
2045             - `.Line2D` if *usevlines* is False.
2046         b : `.Line2D` or None
2047             Horizontal line at 0 if *usevlines* is True
2048             None *usevlines* is False.
2049 
2050         Other Parameters
2051         ----------------
2052         linestyle : `.Line2D` property, optional
2053             The linestyle for plotting the data points.
2054             Only used if *usevlines* is ``False``.
2055 
2056         marker : str, default: 'o'
2057             The marker for plotting the data points.
2058             Only used if *usevlines* is ``False``.
2059 
2060         data : indexable object, optional
2061             DATA_PARAMETER_PLACEHOLDER
2062 
2063         **kwargs
2064             Additional parameters are passed to `.Axes.vlines` and
2065             `.Axes.axhline` if *usevlines* is ``True``; otherwise they are
2066             passed to `.Axes.plot`.
2067 
2068         Notes
2069         -----
2070         The cross correlation is performed with `numpy.correlate` with
2071         ``mode = "full"``.
2072         """
2073         Nx = len(x)
2074         if Nx != len(y):
2075             raise ValueError('x and y must be equal length')
2076 
2077         x = detrend(np.asarray(x))
2078         y = detrend(np.asarray(y))
2079 
2080         correls = np.correlate(x, y, mode="full")
2081 
2082         if normed:
2083             correls /= np.sqrt(np.dot(x, x) * np.dot(y, y))
2084 
2085         if maxlags is None:
2086             maxlags = Nx - 1
2087 
2088         if maxlags >= Nx or maxlags < 1:
2089             raise ValueError('maxlags must be None or strictly '
2090                              'positive < %d' % Nx)
2091 
2092         lags = np.arange(-maxlags, maxlags + 1)
2093         correls = correls[Nx - 1 - maxlags:Nx + maxlags]
2094 
2095         if usevlines:
2096             a = self.vlines(lags, [0], correls, **kwargs)
2097             # Make label empty so only vertical lines get a legend entry
2098             kwargs.pop('label', '')
2099             b = self.axhline(**kwargs)
2100         else:
2101             kwargs.setdefault('marker', 'o')
2102             kwargs.setdefault('linestyle', 'None')
2103             a, = self.plot(lags, correls, **kwargs)
2104             b = None
2105         return lags, correls, a, b
2106 
2107     #### Specialized plotting
2108 
2109     # @_preprocess_data() # let 'plot' do the unpacking..
2110     def step(self, x, y, *args, where='pre', data=None, **kwargs):
2111         """
2112         Make a step plot.
2113 
2114         Call signatures::
2115 
2116             step(x, y, [fmt], *, data=None, where='pre', **kwargs)
2117             step(x, y, [fmt], x2, y2, [fmt2], ..., *, where='pre', **kwargs)
2118 
2119         This is just a thin wrapper around `.plot` which changes some
2120         formatting options. Most of the concepts and parameters of plot can be
2121         used here as well.
2122 
2123         .. note::
2124 
2125             This method uses a standard plot with a step drawstyle: The *x*
2126             values are the reference positions and steps extend left/right/both
2127             directions depending on *where*.
2128 
2129             For the common case where you know the values and edges of the
2130             steps, use `~.Axes.stairs` instead.
2131 
2132         Parameters
2133         ----------
2134         x : array-like
2135             1D sequence of x positions. It is assumed, but not checked, that
2136             it is uniformly increasing.
2137 
2138         y : array-like
2139             1D sequence of y levels.
2140 
2141         fmt : str, optional
2142             A format string, e.g. 'g' for a green line. See `.plot` for a more
2143             detailed description.
2144 
2145             Note: While full format strings are accepted, it is recommended to
2146             only specify the color. Line styles are currently ignored (use
2147             the keyword argument *linestyle* instead). Markers are accepted
2148             and plotted on the given positions, however, this is a rarely
2149             needed feature for step plots.
2150 
2151         where : {'pre', 'post', 'mid'}, default: 'pre'
2152             Define where the steps should be placed:
2153 
2154             - 'pre': The y value is continued constantly to the left from
2155               every *x* position, i.e. the interval ``(x[i-1], x[i]]`` has the
2156               value ``y[i]``.
2157             - 'post': The y value is continued constantly to the right from
2158               every *x* position, i.e. the interval ``[x[i], x[i+1])`` has the
2159               value ``y[i]``.
2160             - 'mid': Steps occur half-way between the *x* positions.
2161 
2162         data : indexable object, optional
2163             An object with labelled data. If given, provide the label names to
2164             plot in *x* and *y*.
2165 
2166         **kwargs
2167             Additional parameters are the same as those for `.plot`.
2168 
2169         Returns
2170         -------
2171         list of `.Line2D`
2172             Objects representing the plotted data.
2173         """
2174         _api.check_in_list(('pre', 'post', 'mid'), where=where)
2175         kwargs['drawstyle'] = 'steps-' + where
2176         return self.plot(x, y, *args, data=data, **kwargs)
2177 
2178     @staticmethod
2179     def _convert_dx(dx, x0, xconv, convert):
2180         """
2181         Small helper to do logic of width conversion flexibly.
2182 
2183         *dx* and *x0* have units, but *xconv* has already been converted
2184         to unitless (and is an ndarray).  This allows the *dx* to have units
2185         that are different from *x0*, but are still accepted by the
2186         ``__add__`` operator of *x0*.
2187         """
2188 
2189         # x should be an array...
2190         assert type(xconv) is np.ndarray
2191 
2192         if xconv.size == 0:
2193             # xconv has already been converted, but maybe empty...
2194             return convert(dx)
2195 
2196         try:
2197             # attempt to add the width to x0; this works for
2198             # datetime+timedelta, for instance
2199 
2200             # only use the first element of x and x0.  This saves
2201             # having to be sure addition works across the whole
2202             # vector.  This is particularly an issue if
2203             # x0 and dx are lists so x0 + dx just concatenates the lists.
2204             # We can't just cast x0 and dx to numpy arrays because that
2205             # removes the units from unit packages like `pint` that
2206             # wrap numpy arrays.
2207             try:
2208                 x0 = cbook._safe_first_finite(x0)
2209             except (TypeError, IndexError, KeyError):
2210                 pass
2211             except StopIteration:
2212                 # this means we found no finite element, fall back to first
2213                 # element unconditionally
2214                 x0 = cbook.safe_first_element(x0)
2215 
2216             try:
2217                 x = cbook._safe_first_finite(xconv)
2218             except (TypeError, IndexError, KeyError):
2219                 x = xconv
2220             except StopIteration:
2221                 # this means we found no finite element, fall back to first
2222                 # element unconditionally
2223                 x = cbook.safe_first_element(xconv)
2224 
2225             delist = False
2226             if not np.iterable(dx):
2227                 dx = [dx]
2228                 delist = True
2229             dx = [convert(x0 + ddx) - x for ddx in dx]
2230             if delist:
2231                 dx = dx[0]
2232         except (ValueError, TypeError, AttributeError):
2233             # if the above fails (for any reason) just fallback to what
2234             # we do by default and convert dx by itself.
2235             dx = convert(dx)
2236         return dx
2237 
2238     @_preprocess_data()
2239     @_docstring.dedent_interpd
2240     def bar(self, x, height, width=0.8, bottom=None, *, align="center",
2241             **kwargs):
2242         r"""
2243         Make a bar plot.
2244 
2245         The bars are positioned at *x* with the given *align*\ment. Their
2246         dimensions are given by *height* and *width*. The vertical baseline
2247         is *bottom* (default 0).
2248 
2249         Many parameters can take either a single value applying to all bars
2250         or a sequence of values, one for each bar.
2251 
2252         Parameters
2253         ----------
2254         x : float or array-like
2255             The x coordinates of the bars. See also *align* for the
2256             alignment of the bars to the coordinates.
2257 
2258         height : float or array-like
2259             The height(s) of the bars.
2260 
2261         width : float or array-like, default: 0.8
2262             The width(s) of the bars.
2263 
2264         bottom : float or array-like, default: 0
2265             The y coordinate(s) of the bottom side(s) of the bars.
2266 
2267         align : {'center', 'edge'}, default: 'center'
2268             Alignment of the bars to the *x* coordinates:
2269 
2270             - 'center': Center the base on the *x* positions.
2271             - 'edge': Align the left edges of the bars with the *x* positions.
2272 
2273             To align the bars on the right edge pass a negative *width* and
2274             ``align='edge'``.
2275 
2276         Returns
2277         -------
2278         `.BarContainer`
2279             Container with all the bars and optionally errorbars.
2280 
2281         Other Parameters
2282         ----------------
2283         color : color or list of color, optional
2284             The colors of the bar faces.
2285 
2286         edgecolor : color or list of color, optional
2287             The colors of the bar edges.
2288 
2289         linewidth : float or array-like, optional
2290             Width of the bar edge(s). If 0, don't draw edges.
2291 
2292         tick_label : str or list of str, optional
2293             The tick labels of the bars.
2294             Default: None (Use default numeric labels.)
2295 
2296         label : str or list of str, optional
2297             A single label is attached to the resulting `.BarContainer` as a
2298             label for the whole dataset.
2299             If a list is provided, it must be the same length as *x* and
2300             labels the individual bars. Repeated labels are not de-duplicated
2301             and will cause repeated label entries, so this is best used when
2302             bars also differ in style (e.g., by passing a list to *color*.)
2303 
2304         xerr, yerr : float or array-like of shape(N,) or shape(2, N), optional
2305             If not *None*, add horizontal / vertical errorbars to the bar tips.
2306             The values are +/- sizes relative to the data:
2307 
2308             - scalar: symmetric +/- values for all bars
2309             - shape(N,): symmetric +/- values for each bar
2310             - shape(2, N): Separate - and + values for each bar. First row
2311               contains the lower errors, the second row contains the upper
2312               errors.
2313             - *None*: No errorbar. (Default)
2314 
2315             See :doc:`/gallery/statistics/errorbar_features` for an example on
2316             the usage of *xerr* and *yerr*.
2317 
2318         ecolor : color or list of color, default: 'black'
2319             The line color of the errorbars.
2320 
2321         capsize : float, default: :rc:`errorbar.capsize`
2322            The length of the error bar caps in points.
2323 
2324         error_kw : dict, optional
2325             Dictionary of keyword arguments to be passed to the
2326             `~.Axes.errorbar` method. Values of *ecolor* or *capsize* defined
2327             here take precedence over the independent keyword arguments.
2328 
2329         log : bool, default: False
2330             If *True*, set the y-axis to be log scale.
2331 
2332         data : indexable object, optional
2333             DATA_PARAMETER_PLACEHOLDER
2334 
2335         **kwargs : `.Rectangle` properties
2336 
2337         %(Rectangle:kwdoc)s
2338 
2339         See Also
2340         --------
2341         barh : Plot a horizontal bar plot.
2342 
2343         Notes
2344         -----
2345         Stacked bars can be achieved by passing individual *bottom* values per
2346         bar. See :doc:`/gallery/lines_bars_and_markers/bar_stacked`.
2347         """
2348         kwargs = cbook.normalize_kwargs(kwargs, mpatches.Patch)
2349         color = kwargs.pop('color', None)
2350         if color is None:
2351             color = self._get_patches_for_fill.get_next_color()
2352         edgecolor = kwargs.pop('edgecolor', None)
2353         linewidth = kwargs.pop('linewidth', None)
2354         hatch = kwargs.pop('hatch', None)
2355 
2356         # Because xerr and yerr will be passed to errorbar, most dimension
2357         # checking and processing will be left to the errorbar method.
2358         xerr = kwargs.pop('xerr', None)
2359         yerr = kwargs.pop('yerr', None)
2360         error_kw = kwargs.pop('error_kw', {})
2361         ezorder = error_kw.pop('zorder', None)
2362         if ezorder is None:
2363             ezorder = kwargs.get('zorder', None)
2364             if ezorder is not None:
2365                 # If using the bar zorder, increment slightly to make sure
2366                 # errorbars are drawn on top of bars
2367                 ezorder += 0.01
2368         error_kw.setdefault('zorder', ezorder)
2369         ecolor = kwargs.pop('ecolor', 'k')
2370         capsize = kwargs.pop('capsize', mpl.rcParams["errorbar.capsize"])
2371         error_kw.setdefault('ecolor', ecolor)
2372         error_kw.setdefault('capsize', capsize)
2373 
2374         # The keyword argument *orientation* is used by barh() to defer all
2375         # logic and drawing to bar(). It is considered internal and is
2376         # intentionally not mentioned in the docstring.
2377         orientation = kwargs.pop('orientation', 'vertical')
2378         _api.check_in_list(['vertical', 'horizontal'], orientation=orientation)
2379         log = kwargs.pop('log', False)
2380         label = kwargs.pop('label', '')
2381         tick_labels = kwargs.pop('tick_label', None)
2382 
2383         y = bottom  # Matches barh call signature.
2384         if orientation == 'vertical':
2385             if y is None:
2386                 y = 0
2387         else:  # horizontal
2388             if x is None:
2389                 x = 0
2390 
2391         if orientation == 'vertical':
2392             self._process_unit_info(
2393                 [("x", x), ("y", height)], kwargs, convert=False)
2394             if log:
2395                 self.set_yscale('log', nonpositive='clip')
2396         else:  # horizontal
2397             self._process_unit_info(
2398                 [("x", width), ("y", y)], kwargs, convert=False)
2399             if log:
2400                 self.set_xscale('log', nonpositive='clip')
2401 
2402         # lets do some conversions now since some types cannot be
2403         # subtracted uniformly
2404         if self.xaxis is not None:
2405             x0 = x
2406             x = np.asarray(self.convert_xunits(x))
2407             width = self._convert_dx(width, x0, x, self.convert_xunits)
2408             if xerr is not None:
2409                 xerr = self._convert_dx(xerr, x0, x, self.convert_xunits)
2410         if self.yaxis is not None:
2411             y0 = y
2412             y = np.asarray(self.convert_yunits(y))
2413             height = self._convert_dx(height, y0, y, self.convert_yunits)
2414             if yerr is not None:
2415                 yerr = self._convert_dx(yerr, y0, y, self.convert_yunits)
2416 
2417         x, height, width, y, linewidth, hatch = np.broadcast_arrays(
2418             # Make args iterable too.
2419             np.atleast_1d(x), height, width, y, linewidth, hatch)
2420 
2421         # Now that units have been converted, set the tick locations.
2422         if orientation == 'vertical':
2423             tick_label_axis = self.xaxis
2424             tick_label_position = x
2425         else:  # horizontal
2426             tick_label_axis = self.yaxis
2427             tick_label_position = y
2428 
2429         if not isinstance(label, str) and np.iterable(label):
2430             bar_container_label = '_nolegend_'
2431             patch_labels = label
2432         else:
2433             bar_container_label = label
2434             patch_labels = ['_nolegend_'] * len(x)
2435         if len(patch_labels) != len(x):
2436             raise ValueError(f'number of labels ({len(patch_labels)}) '
2437                              f'does not match number of bars ({len(x)}).')
2438 
2439         linewidth = itertools.cycle(np.atleast_1d(linewidth))
2440         hatch = itertools.cycle(np.atleast_1d(hatch))
2441         color = itertools.chain(itertools.cycle(mcolors.to_rgba_array(color)),
2442                                 # Fallback if color == "none".
2443                                 itertools.repeat('none'))
2444         if edgecolor is None:
2445             edgecolor = itertools.repeat(None)
2446         else:
2447             edgecolor = itertools.chain(
2448                 itertools.cycle(mcolors.to_rgba_array(edgecolor)),
2449                 # Fallback if edgecolor == "none".
2450                 itertools.repeat('none'))
2451 
2452         # We will now resolve the alignment and really have
2453         # left, bottom, width, height vectors
2454         _api.check_in_list(['center', 'edge'], align=align)
2455         if align == 'center':
2456             if orientation == 'vertical':
2457                 try:
2458                     left = x - width / 2
2459                 except TypeError as e:
2460                     raise TypeError(f'the dtypes of parameters x ({x.dtype}) '
2461                                     f'and width ({width.dtype}) '
2462                                     f'are incompatible') from e
2463                 bottom = y
2464             else:  # horizontal
2465                 try:
2466                     bottom = y - height / 2
2467                 except TypeError as e:
2468                     raise TypeError(f'the dtypes of parameters y ({y.dtype}) '
2469                                     f'and height ({height.dtype}) '
2470                                     f'are incompatible') from e
2471                 left = x
2472         else:  # edge
2473             left = x
2474             bottom = y
2475 
2476         patches = []
2477         args = zip(left, bottom, width, height, color, edgecolor, linewidth,
2478                    hatch, patch_labels)
2479         for l, b, w, h, c, e, lw, htch, lbl in args:
2480             r = mpatches.Rectangle(
2481                 xy=(l, b), width=w, height=h,
2482                 facecolor=c,
2483                 edgecolor=e,
2484                 linewidth=lw,
2485                 label=lbl,
2486                 hatch=htch,
2487                 )
2488             r._internal_update(kwargs)
2489             r.get_path()._interpolation_steps = 100
2490             if orientation == 'vertical':
2491                 r.sticky_edges.y.append(b)
2492             else:  # horizontal
2493                 r.sticky_edges.x.append(l)
2494             self.add_patch(r)
2495             patches.append(r)
2496 
2497         if xerr is not None or yerr is not None:
2498             if orientation == 'vertical':
2499                 # using list comps rather than arrays to preserve unit info
2500                 ex = [l + 0.5 * w for l, w in zip(left, width)]
2501                 ey = [b + h for b, h in zip(bottom, height)]
2502 
2503             else:  # horizontal
2504                 # using list comps rather than arrays to preserve unit info
2505                 ex = [l + w for l, w in zip(left, width)]
2506                 ey = [b + 0.5 * h for b, h in zip(bottom, height)]
2507 
2508             error_kw.setdefault("label", '_nolegend_')
2509 
2510             errorbar = self.errorbar(ex, ey,
2511                                      yerr=yerr, xerr=xerr,
2512                                      fmt='none', **error_kw)
2513         else:
2514             errorbar = None
2515 
2516         self._request_autoscale_view()
2517 
2518         if orientation == 'vertical':
2519             datavalues = height
2520         else:  # horizontal
2521             datavalues = width
2522 
2523         bar_container = BarContainer(patches, errorbar, datavalues=datavalues,
2524                                      orientation=orientation,
2525                                      label=bar_container_label)
2526         self.add_container(bar_container)
2527 
2528         if tick_labels is not None:
2529             tick_labels = np.broadcast_to(tick_labels, len(patches))
2530             tick_label_axis.set_ticks(tick_label_position)
2531             tick_label_axis.set_ticklabels(tick_labels)
2532 
2533         return bar_container
2534 
2535     # @_preprocess_data() # let 'bar' do the unpacking..
2536     @_docstring.dedent_interpd
2537     def barh(self, y, width, height=0.8, left=None, *, align="center",
2538              data=None, **kwargs):
2539         r"""
2540         Make a horizontal bar plot.
2541 
2542         The bars are positioned at *y* with the given *align*\ment. Their
2543         dimensions are given by *width* and *height*. The horizontal baseline
2544         is *left* (default 0).
2545 
2546         Many parameters can take either a single value applying to all bars
2547         or a sequence of values, one for each bar.
2548 
2549         Parameters
2550         ----------
2551         y : float or array-like
2552             The y coordinates of the bars. See also *align* for the
2553             alignment of the bars to the coordinates.
2554 
2555         width : float or array-like
2556             The width(s) of the bars.
2557 
2558         height : float or array-like, default: 0.8
2559             The heights of the bars.
2560 
2561         left : float or array-like, default: 0
2562             The x coordinates of the left side(s) of the bars.
2563 
2564         align : {'center', 'edge'}, default: 'center'
2565             Alignment of the base to the *y* coordinates*:
2566 
2567             - 'center': Center the bars on the *y* positions.
2568             - 'edge': Align the bottom edges of the bars with the *y*
2569               positions.
2570 
2571             To align the bars on the top edge pass a negative *height* and
2572             ``align='edge'``.
2573 
2574         Returns
2575         -------
2576         `.BarContainer`
2577             Container with all the bars and optionally errorbars.
2578 
2579         Other Parameters
2580         ----------------
2581         color : color or list of color, optional
2582             The colors of the bar faces.
2583 
2584         edgecolor : color or list of color, optional
2585             The colors of the bar edges.
2586 
2587         linewidth : float or array-like, optional
2588             Width of the bar edge(s). If 0, don't draw edges.
2589 
2590         tick_label : str or list of str, optional
2591             The tick labels of the bars.
2592             Default: None (Use default numeric labels.)
2593 
2594         label : str or list of str, optional
2595             A single label is attached to the resulting `.BarContainer` as a
2596             label for the whole dataset.
2597             If a list is provided, it must be the same length as *y* and
2598             labels the individual bars. Repeated labels are not de-duplicated
2599             and will cause repeated label entries, so this is best used when
2600             bars also differ in style (e.g., by passing a list to *color*.)
2601 
2602         xerr, yerr : float or array-like of shape(N,) or shape(2, N), optional
2603             If not *None*, add horizontal / vertical errorbars to the bar tips.
2604             The values are +/- sizes relative to the data:
2605 
2606             - scalar: symmetric +/- values for all bars
2607             - shape(N,): symmetric +/- values for each bar
2608             - shape(2, N): Separate - and + values for each bar. First row
2609               contains the lower errors, the second row contains the upper
2610               errors.
2611             - *None*: No errorbar. (default)
2612 
2613             See :doc:`/gallery/statistics/errorbar_features` for an example on
2614             the usage of *xerr* and *yerr*.
2615 
2616         ecolor : color or list of color, default: 'black'
2617             The line color of the errorbars.
2618 
2619         capsize : float, default: :rc:`errorbar.capsize`
2620            The length of the error bar caps in points.
2621 
2622         error_kw : dict, optional
2623             Dictionary of keyword arguments to be passed to the
2624             `~.Axes.errorbar` method. Values of *ecolor* or *capsize* defined
2625             here take precedence over the independent keyword arguments.
2626 
2627         log : bool, default: False
2628             If ``True``, set the x-axis to be log scale.
2629 
2630         data : indexable object, optional
2631             If given, all parameters also accept a string ``s``, which is
2632             interpreted as ``data[s]`` (unless this raises an exception).
2633 
2634         **kwargs : `.Rectangle` properties
2635 
2636         %(Rectangle:kwdoc)s
2637 
2638         See Also
2639         --------
2640         bar : Plot a vertical bar plot.
2641 
2642         Notes
2643         -----
2644         Stacked bars can be achieved by passing individual *left* values per
2645         bar. See
2646         :doc:`/gallery/lines_bars_and_markers/horizontal_barchart_distribution`.
2647         """
2648         kwargs.setdefault('orientation', 'horizontal')
2649         patches = self.bar(x=left, height=height, width=width, bottom=y,
2650                            align=align, data=data, **kwargs)
2651         return patches
2652 
2653     def bar_label(self, container, labels=None, *, fmt="%g", label_type="edge",
2654                   padding=0, **kwargs):
2655         """
2656         Label a bar plot.
2657 
2658         Adds labels to bars in the given `.BarContainer`.
2659         You may need to adjust the axis limits to fit the labels.
2660 
2661         Parameters
2662         ----------
2663         container : `.BarContainer`
2664             Container with all the bars and optionally errorbars, likely
2665             returned from `.bar` or `.barh`.
2666 
2667         labels : array-like, optional
2668             A list of label texts, that should be displayed. If not given, the
2669             label texts will be the data values formatted with *fmt*.
2670 
2671         fmt : str or callable, default: '%g'
2672             An unnamed %-style or {}-style format string for the label or a
2673             function to call with the value as the first argument.
2674             When *fmt* is a string and can be interpreted in both formats,
2675             %-style takes precedence over {}-style.
2676 
2677             .. versionadded:: 3.7
2678                Support for {}-style format string and callables.
2679 
2680         label_type : {'edge', 'center'}, default: 'edge'
2681             The label type. Possible values:
2682 
2683             - 'edge': label placed at the end-point of the bar segment, and the
2684               value displayed will be the position of that end-point.
2685             - 'center': label placed in the center of the bar segment, and the
2686               value displayed will be the length of that segment.
2687               (useful for stacked bars, i.e.,
2688               :doc:`/gallery/lines_bars_and_markers/bar_label_demo`)
2689 
2690         padding : float, default: 0
2691             Distance of label from the end of the bar, in points.
2692 
2693         **kwargs
2694             Any remaining keyword arguments are passed through to
2695             `.Axes.annotate`. The alignment parameters (
2696             *horizontalalignment* / *ha*, *verticalalignment* / *va*) are
2697             not supported because the labels are automatically aligned to
2698             the bars.
2699 
2700         Returns
2701         -------
2702         list of `.Text`
2703             A list of `.Text` instances for the labels.
2704         """
2705         for key in ['horizontalalignment', 'ha', 'verticalalignment', 'va']:
2706             if key in kwargs:
2707                 raise ValueError(
2708                     f"Passing {key!r} to bar_label() is not supported.")
2709 
2710         a, b = self.yaxis.get_view_interval()
2711         y_inverted = a > b
2712         c, d = self.xaxis.get_view_interval()
2713         x_inverted = c > d
2714 
2715         # want to know whether to put label on positive or negative direction
2716         # cannot use np.sign here because it will return 0 if x == 0
2717         def sign(x):
2718             return 1 if x >= 0 else -1
2719 
2720         _api.check_in_list(['edge', 'center'], label_type=label_type)
2721 
2722         bars = container.patches
2723         errorbar = container.errorbar
2724         datavalues = container.datavalues
2725         orientation = container.orientation
2726 
2727         if errorbar:
2728             # check "ErrorbarContainer" for the definition of these elements
2729             lines = errorbar.lines  # attribute of "ErrorbarContainer" (tuple)
2730             barlinecols = lines[2]  # 0: data_line, 1: caplines, 2: barlinecols
2731             barlinecol = barlinecols[0]  # the "LineCollection" of error bars
2732             errs = barlinecol.get_segments()
2733         else:
2734             errs = []
2735 
2736         if labels is None:
2737             labels = []
2738 
2739         annotations = []
2740 
2741         for bar, err, dat, lbl in itertools.zip_longest(
2742                 bars, errs, datavalues, labels
2743         ):
2744             (x0, y0), (x1, y1) = bar.get_bbox().get_points()
2745             xc, yc = (x0 + x1) / 2, (y0 + y1) / 2
2746 
2747             if orientation == "vertical":
2748                 extrema = max(y0, y1) if dat >= 0 else min(y0, y1)
2749                 length = abs(y0 - y1)
2750             else:  # horizontal
2751                 extrema = max(x0, x1) if dat >= 0 else min(x0, x1)
2752                 length = abs(x0 - x1)
2753 
2754             if err is None or np.size(err) == 0:
2755                 endpt = extrema
2756             elif orientation == "vertical":
2757                 endpt = err[:, 1].max() if dat >= 0 else err[:, 1].min()
2758             else:  # horizontal
2759                 endpt = err[:, 0].max() if dat >= 0 else err[:, 0].min()
2760 
2761             if label_type == "center":
2762                 value = sign(dat) * length
2763             else:  # edge
2764                 value = extrema
2765 
2766             if label_type == "center":
2767                 xy = (0.5, 0.5)
2768                 kwargs["xycoords"] = (
2769                     lambda r, b=bar:
2770                         mtransforms.Bbox.intersection(
2771                             b.get_window_extent(r), b.get_clip_box()
2772                         )
2773                 )
2774             else:  # edge
2775                 if orientation == "vertical":
2776                     xy = xc, endpt
2777                 else:  # horizontal
2778                     xy = endpt, yc
2779 
2780             if orientation == "vertical":
2781                 y_direction = -1 if y_inverted else 1
2782                 xytext = 0, y_direction * sign(dat) * padding
2783             else:  # horizontal
2784                 x_direction = -1 if x_inverted else 1
2785                 xytext = x_direction * sign(dat) * padding, 0
2786 
2787             if label_type == "center":
2788                 ha, va = "center", "center"
2789             else:  # edge
2790                 if orientation == "vertical":
2791                     ha = 'center'
2792                     if y_inverted:
2793                         va = 'top' if dat > 0 else 'bottom'  # also handles NaN
2794                     else:
2795                         va = 'top' if dat < 0 else 'bottom'  # also handles NaN
2796                 else:  # horizontal
2797                     if x_inverted:
2798                         ha = 'right' if dat > 0 else 'left'  # also handles NaN
2799                     else:
2800                         ha = 'right' if dat < 0 else 'left'  # also handles NaN
2801                     va = 'center'
2802 
2803             if np.isnan(dat):
2804                 lbl = ''
2805 
2806             if lbl is None:
2807                 if isinstance(fmt, str):
2808                     lbl = cbook._auto_format_str(fmt, value)
2809                 elif callable(fmt):
2810                     lbl = fmt(value)
2811                 else:
2812                     raise TypeError("fmt must be a str or callable")
2813             annotation = self.annotate(lbl,
2814                                        xy, xytext, textcoords="offset points",
2815                                        ha=ha, va=va, **kwargs)
2816             annotations.append(annotation)
2817 
2818         return annotations
2819 
2820     @_preprocess_data()
2821     @_docstring.dedent_interpd
2822     def broken_barh(self, xranges, yrange, **kwargs):
2823         """
2824         Plot a horizontal sequence of rectangles.
2825 
2826         A rectangle is drawn for each element of *xranges*. All rectangles
2827         have the same vertical position and size defined by *yrange*.
2828 
2829         Parameters
2830         ----------
2831         xranges : sequence of tuples (*xmin*, *xwidth*)
2832             The x-positions and extends of the rectangles. For each tuple
2833             (*xmin*, *xwidth*) a rectangle is drawn from *xmin* to *xmin* +
2834             *xwidth*.
2835         yrange : (*ymin*, *yheight*)
2836             The y-position and extend for all the rectangles.
2837 
2838         Returns
2839         -------
2840         `~.collections.PolyCollection`
2841 
2842         Other Parameters
2843         ----------------
2844         data : indexable object, optional
2845             DATA_PARAMETER_PLACEHOLDER
2846         **kwargs : `.PolyCollection` properties
2847 
2848             Each *kwarg* can be either a single argument applying to all
2849             rectangles, e.g.::
2850 
2851                 facecolors='black'
2852 
2853             or a sequence of arguments over which is cycled, e.g.::
2854 
2855                 facecolors=('black', 'blue')
2856 
2857             would create interleaving black and blue rectangles.
2858 
2859             Supported keywords:
2860 
2861             %(PolyCollection:kwdoc)s
2862         """
2863         # process the unit information
2864         xdata = cbook._safe_first_finite(xranges) if len(xranges) else None
2865         ydata = cbook._safe_first_finite(yrange) if len(yrange) else None
2866         self._process_unit_info(
2867             [("x", xdata), ("y", ydata)], kwargs, convert=False)
2868 
2869         vertices = []
2870         y0, dy = yrange
2871         y0, y1 = self.convert_yunits((y0, y0 + dy))
2872         for xr in xranges:  # convert the absolute values, not the x and dx
2873             try:
2874                 x0, dx = xr
2875             except Exception:
2876                 raise ValueError(
2877                     "each range in xrange must be a sequence with two "
2878                     "elements (i.e. xrange must be an (N, 2) array)") from None
2879             x0, x1 = self.convert_xunits((x0, x0 + dx))
2880             vertices.append([(x0, y0), (x0, y1), (x1, y1), (x1, y0)])
2881 
2882         col = mcoll.PolyCollection(np.array(vertices), **kwargs)
2883         self.add_collection(col, autolim=True)
2884         self._request_autoscale_view()
2885 
2886         return col
2887 
2888     @_preprocess_data()
2889     @_api.delete_parameter("3.6", "use_line_collection")
2890     def stem(self, *args, linefmt=None, markerfmt=None, basefmt=None, bottom=0,
2891              label=None, use_line_collection=True, orientation='vertical'):
2892         """
2893         Create a stem plot.
2894 
2895         A stem plot draws lines perpendicular to a baseline at each location
2896         *locs* from the baseline to *heads*, and places a marker there. For
2897         vertical stem plots (the default), the *locs* are *x* positions, and
2898         the *heads* are *y* values. For horizontal stem plots, the *locs* are
2899         *y* positions, and the *heads* are *x* values.
2900 
2901         Call signature::
2902 
2903           stem([locs,] heads, linefmt=None, markerfmt=None, basefmt=None)
2904 
2905         The *locs*-positions are optional. *linefmt* may be provided as
2906         positional, but all other formats must be provided as keyword
2907         arguments.
2908 
2909         Parameters
2910         ----------
2911         locs : array-like, default: (0, 1, ..., len(heads) - 1)
2912             For vertical stem plots, the x-positions of the stems.
2913             For horizontal stem plots, the y-positions of the stems.
2914 
2915         heads : array-like
2916             For vertical stem plots, the y-values of the stem heads.
2917             For horizontal stem plots, the x-values of the stem heads.
2918 
2919         linefmt : str, optional
2920             A string defining the color and/or linestyle of the vertical lines:
2921 
2922             =========  =============
2923             Character  Line Style
2924             =========  =============
2925             ``'-'``    solid line
2926             ``'--'``   dashed line
2927             ``'-.'``   dash-dot line
2928             ``':'``    dotted line
2929             =========  =============
2930 
2931             Default: 'C0-', i.e. solid line with the first color of the color
2932             cycle.
2933 
2934             Note: Markers specified through this parameter (e.g. 'x') will be
2935             silently ignored (unless using ``use_line_collection=False``).
2936             Instead, markers should be specified using *markerfmt*.
2937 
2938         markerfmt : str, optional
2939             A string defining the color and/or shape of the markers at the stem
2940             heads. If the marker is not given, use the marker 'o', i.e. filled
2941             circles. If the color is not given, use the color from *linefmt*.
2942 
2943         basefmt : str, default: 'C3-' ('C2-' in classic mode)
2944             A format string defining the properties of the baseline.
2945 
2946         orientation : {'vertical', 'horizontal'}, default: 'vertical'
2947             If 'vertical', will produce a plot with stems oriented vertically,
2948             If 'horizontal', the stems will be oriented horizontally.
2949 
2950         bottom : float, default: 0
2951             The y/x-position of the baseline (depending on orientation).
2952 
2953         label : str, default: None
2954             The label to use for the stems in legends.
2955 
2956         use_line_collection : bool, default: True
2957             *Deprecated since 3.6*
2958 
2959             If ``True``, store and plot the stem lines as a
2960             `~.collections.LineCollection` instead of individual lines, which
2961             significantly increases performance.  If ``False``, defaults to the
2962             old behavior of using a list of `.Line2D` objects.
2963 
2964         data : indexable object, optional
2965             DATA_PARAMETER_PLACEHOLDER
2966 
2967         Returns
2968         -------
2969         `.StemContainer`
2970             The container may be treated like a tuple
2971             (*markerline*, *stemlines*, *baseline*)
2972 
2973         Notes
2974         -----
2975         .. seealso::
2976             The MATLAB function
2977             `stem <https://www.mathworks.com/help/matlab/ref/stem.html>`_
2978             which inspired this method.
2979         """
2980         if not 1 <= len(args) <= 3:
2981             raise TypeError('stem expected between 1 or 3 positional '
2982                             f'arguments, got {args}')
2983         _api.check_in_list(['horizontal', 'vertical'], orientation=orientation)
2984 
2985         if len(args) == 1:
2986             heads, = args
2987             locs = np.arange(len(heads))
2988             args = ()
2989         elif isinstance(args[1], str):
2990             heads, *args = args
2991             locs = np.arange(len(heads))
2992         else:
2993             locs, heads, *args = args
2994 
2995         if orientation == 'vertical':
2996             locs, heads = self._process_unit_info([("x", locs), ("y", heads)])
2997         else:  # horizontal
2998             heads, locs = self._process_unit_info([("x", heads), ("y", locs)])
2999 
3000         # resolve line format
3001         if linefmt is None:
3002             linefmt = args[0] if len(args) > 0 else "C0-"
3003         linestyle, linemarker, linecolor = _process_plot_format(linefmt)
3004 
3005         # resolve marker format
3006         if markerfmt is None:
3007             # if not given as kwarg, fall back to 'o'
3008             markerfmt = "o"
3009         if markerfmt == '':
3010             markerfmt = ' '  # = empty line style; '' would resolve rcParams
3011         markerstyle, markermarker, markercolor = \
3012             _process_plot_format(markerfmt)
3013         if markermarker is None:
3014             markermarker = 'o'
3015         if markerstyle is None:
3016             markerstyle = 'None'
3017         if markercolor is None:
3018             markercolor = linecolor
3019 
3020         # resolve baseline format
3021         if basefmt is None:
3022             basefmt = ("C2-" if mpl.rcParams["_internal.classic_mode"] else
3023                        "C3-")
3024         basestyle, basemarker, basecolor = _process_plot_format(basefmt)
3025 
3026         # New behaviour in 3.1 is to use a LineCollection for the stemlines
3027         if use_line_collection:
3028             if linestyle is None:
3029                 linestyle = mpl.rcParams['lines.linestyle']
3030             xlines = self.vlines if orientation == "vertical" else self.hlines
3031             stemlines = xlines(
3032                 locs, bottom, heads,
3033                 colors=linecolor, linestyles=linestyle, label="_nolegend_")
3034         # Old behaviour is to plot each of the lines individually
3035         else:
3036             stemlines = []
3037             for loc, head in zip(locs, heads):
3038                 if orientation == 'horizontal':
3039                     xs = [bottom, head]
3040                     ys = [loc, loc]
3041                 else:
3042                     xs = [loc, loc]
3043                     ys = [bottom, head]
3044                 l, = self.plot(xs, ys,
3045                                color=linecolor, linestyle=linestyle,
3046                                marker=linemarker, label="_nolegend_")
3047                 stemlines.append(l)
3048 
3049         if orientation == 'horizontal':
3050             marker_x = heads
3051             marker_y = locs
3052             baseline_x = [bottom, bottom]
3053             baseline_y = [np.min(locs), np.max(locs)]
3054         else:
3055             marker_x = locs
3056             marker_y = heads
3057             baseline_x = [np.min(locs), np.max(locs)]
3058             baseline_y = [bottom, bottom]
3059 
3060         markerline, = self.plot(marker_x, marker_y,
3061                                 color=markercolor, linestyle=markerstyle,
3062                                 marker=markermarker, label="_nolegend_")
3063 
3064         baseline, = self.plot(baseline_x, baseline_y,
3065                               color=basecolor, linestyle=basestyle,
3066                               marker=basemarker, label="_nolegend_")
3067 
3068         stem_container = StemContainer((markerline, stemlines, baseline),
3069                                        label=label)
3070         self.add_container(stem_container)
3071         return stem_container
3072 
3073     @_preprocess_data(replace_names=["x", "explode", "labels", "colors"])
3074     def pie(self, x, explode=None, labels=None, colors=None,
3075             autopct=None, pctdistance=0.6, shadow=False, labeldistance=1.1,
3076             startangle=0, radius=1, counterclock=True,
3077             wedgeprops=None, textprops=None, center=(0, 0),
3078             frame=False, rotatelabels=False, *, normalize=True, hatch=None):
3079         """
3080         Plot a pie chart.
3081 
3082         Make a pie chart of array *x*.  The fractional area of each wedge is
3083         given by ``x/sum(x)``.
3084 
3085         The wedges are plotted counterclockwise, by default starting from the
3086         x-axis.
3087 
3088         Parameters
3089         ----------
3090         x : 1D array-like
3091             The wedge sizes.
3092 
3093         explode : array-like, default: None
3094             If not *None*, is a ``len(x)`` array which specifies the fraction
3095             of the radius with which to offset each wedge.
3096 
3097         labels : list, default: None
3098             A sequence of strings providing the labels for each wedge
3099 
3100         colors : array-like, default: None
3101             A sequence of colors through which the pie chart will cycle.  If
3102             *None*, will use the colors in the currently active cycle.
3103 
3104         hatch : str or list, default: None
3105             Hatching pattern applied to all pie wedges or sequence of patterns
3106             through which the chart will cycle. For a list of valid patterns,
3107             see :doc:`/gallery/shapes_and_collections/hatch_style_reference`.
3108 
3109             .. versionadded:: 3.7
3110 
3111         autopct : None or str or callable, default: None
3112             If not *None*, *autopct* is a string or function used to label the
3113             wedges with their numeric value. The label will be placed inside
3114             the wedge. If *autopct* is a format string, the label will be
3115             ``fmt % pct``. If *autopct* is a function, then it will be called.
3116 
3117         pctdistance : float, default: 0.6
3118             The relative distance along the radius at which the the text
3119             generated by *autopct* is drawn. To draw the text outside the pie,
3120             set *pctdistance* > 1. This parameter is ignored if *autopct* is
3121             ``None``.
3122 
3123         labeldistance : float or None, default: 1.1
3124             The relative distance along the radius at which the labels are
3125             drawn. To draw the labels inside the pie, set  *labeldistance* < 1.
3126             If set to ``None``, labels are not drawn but are still stored for
3127             use in `.legend`.
3128 
3129         shadow : bool, default: False
3130             Draw a shadow beneath the pie.
3131 
3132         startangle : float, default: 0 degrees
3133             The angle by which the start of the pie is rotated,
3134             counterclockwise from the x-axis.
3135 
3136         radius : float, default: 1
3137             The radius of the pie.
3138 
3139         counterclock : bool, default: True
3140             Specify fractions direction, clockwise or counterclockwise.
3141 
3142         wedgeprops : dict, default: None
3143             Dict of arguments passed to each `.patches.Wedge` of the pie.
3144             For example, ``wedgeprops = {'linewidth': 3}`` sets the width of
3145             the wedge border lines equal to 3. By default, ``clip_on=False``.
3146             When there is a conflict between these properties and other
3147             keywords, properties passed to *wedgeprops* take precedence.
3148 
3149         textprops : dict, default: None
3150             Dict of arguments to pass to the text objects.
3151 
3152         center : (float, float), default: (0, 0)
3153             The coordinates of the center of the chart.
3154 
3155         frame : bool, default: False
3156             Plot Axes frame with the chart if true.
3157 
3158         rotatelabels : bool, default: False
3159             Rotate each label to the angle of the corresponding slice if true.
3160 
3161         normalize : bool, default: True
3162             When *True*, always make a full pie by normalizing x so that
3163             ``sum(x) == 1``. *False* makes a partial pie if ``sum(x) <= 1``
3164             and raises a `ValueError` for ``sum(x) > 1``.
3165 
3166         data : indexable object, optional
3167             DATA_PARAMETER_PLACEHOLDER
3168 
3169         Returns
3170         -------
3171         patches : list
3172             A sequence of `matplotlib.patches.Wedge` instances
3173 
3174         texts : list
3175             A list of the label `.Text` instances.
3176 
3177         autotexts : list
3178             A list of `.Text` instances for the numeric labels. This will only
3179             be returned if the parameter *autopct* is not *None*.
3180 
3181         Notes
3182         -----
3183         The pie chart will probably look best if the figure and Axes are
3184         square, or the Axes aspect is equal.
3185         This method sets the aspect ratio of the axis to "equal".
3186         The Axes aspect ratio can be controlled with `.Axes.set_aspect`.
3187         """
3188         self.set_aspect('equal')
3189         # The use of float32 is "historical", but can't be changed without
3190         # regenerating the test baselines.
3191         x = np.asarray(x, np.float32)
3192         if x.ndim > 1:
3193             raise ValueError("x must be 1D")
3194 
3195         if np.any(x < 0):
3196             raise ValueError("Wedge sizes 'x' must be non negative values")
3197 
3198         sx = x.sum()
3199 
3200         if normalize:
3201             x = x / sx
3202         elif sx > 1:
3203             raise ValueError('Cannot plot an unnormalized pie with sum(x) > 1')
3204         if labels is None:
3205             labels = [''] * len(x)
3206         if explode is None:
3207             explode = [0] * len(x)
3208         if len(x) != len(labels):
3209             raise ValueError("'label' must be of length 'x'")
3210         if len(x) != len(explode):
3211             raise ValueError("'explode' must be of length 'x'")
3212         if colors is None:
3213             get_next_color = self._get_patches_for_fill.get_next_color
3214         else:
3215             color_cycle = itertools.cycle(colors)
3216 
3217             def get_next_color():
3218                 return next(color_cycle)
3219 
3220         hatch_cycle = itertools.cycle(np.atleast_1d(hatch))
3221 
3222         _api.check_isinstance(Real, radius=radius, startangle=startangle)
3223         if radius <= 0:
3224             raise ValueError(f'radius must be a positive number, not {radius}')
3225 
3226         # Starting theta1 is the start fraction of the circle
3227         theta1 = startangle / 360
3228 
3229         if wedgeprops is None:
3230             wedgeprops = {}
3231         if textprops is None:
3232             textprops = {}
3233 
3234         texts = []
3235         slices = []
3236         autotexts = []
3237 
3238         for frac, label, expl in zip(x, labels, explode):
3239             x, y = center
3240             theta2 = (theta1 + frac) if counterclock else (theta1 - frac)
3241             thetam = 2 * np.pi * 0.5 * (theta1 + theta2)
3242             x += expl * math.cos(thetam)
3243             y += expl * math.sin(thetam)
3244 
3245             w = mpatches.Wedge((x, y), radius, 360. * min(theta1, theta2),
3246                                360. * max(theta1, theta2),
3247                                facecolor=get_next_color(),
3248                                hatch=next(hatch_cycle),
3249                                clip_on=False,
3250                                label=label)
3251             w.set(**wedgeprops)
3252             slices.append(w)
3253             self.add_patch(w)
3254 
3255             if shadow:
3256                 # Make sure to add a shadow after the call to add_patch so the
3257                 # figure and transform props will be set.
3258                 shad = mpatches.Shadow(w, -0.02, -0.02, label='_nolegend_')
3259                 self.add_patch(shad)
3260 
3261             if labeldistance is not None:
3262                 xt = x + labeldistance * radius * math.cos(thetam)
3263                 yt = y + labeldistance * radius * math.sin(thetam)
3264                 label_alignment_h = 'left' if xt > 0 else 'right'
3265                 label_alignment_v = 'center'
3266                 label_rotation = 'horizontal'
3267                 if rotatelabels:
3268                     label_alignment_v = 'bottom' if yt > 0 else 'top'
3269                     label_rotation = (np.rad2deg(thetam)
3270                                       + (0 if xt > 0 else 180))
3271                 t = self.text(xt, yt, label,
3272                               clip_on=False,
3273                               horizontalalignment=label_alignment_h,
3274                               verticalalignment=label_alignment_v,
3275                               rotation=label_rotation,
3276                               size=mpl.rcParams['xtick.labelsize'])
3277                 t.set(**textprops)
3278                 texts.append(t)
3279 
3280             if autopct is not None:
3281                 xt = x + pctdistance * radius * math.cos(thetam)
3282                 yt = y + pctdistance * radius * math.sin(thetam)
3283                 if isinstance(autopct, str):
3284                     s = autopct % (100. * frac)
3285                 elif callable(autopct):
3286                     s = autopct(100. * frac)
3287                 else:
3288                     raise TypeError(
3289                         'autopct must be callable or a format string')
3290                 t = self.text(xt, yt, s,
3291                               clip_on=False,
3292                               horizontalalignment='center',
3293                               verticalalignment='center')
3294                 t.set(**textprops)
3295                 autotexts.append(t)
3296 
3297             theta1 = theta2
3298 
3299         if frame:
3300             self._request_autoscale_view()
3301         else:
3302             self.set(frame_on=False, xticks=[], yticks=[],
3303                      xlim=(-1.25 + center[0], 1.25 + center[0]),
3304                      ylim=(-1.25 + center[1], 1.25 + center[1]))
3305 
3306         if autopct is None:
3307             return slices, texts
3308         else:
3309             return slices, texts, autotexts
3310 
3311     @staticmethod
3312     def _errorevery_to_mask(x, errorevery):
3313         """
3314         Normalize `errorbar`'s *errorevery* to be a boolean mask for data *x*.
3315 
3316         This function is split out to be usable both by 2D and 3D errorbars.
3317         """
3318         if isinstance(errorevery, Integral):
3319             errorevery = (0, errorevery)
3320         if isinstance(errorevery, tuple):
3321             if (len(errorevery) == 2 and
3322                     isinstance(errorevery[0], Integral) and
3323                     isinstance(errorevery[1], Integral)):
3324                 errorevery = slice(errorevery[0], None, errorevery[1])
3325             else:
3326                 raise ValueError(
3327                     f'{errorevery=!r} is a not a tuple of two integers')
3328         elif isinstance(errorevery, slice):
3329             pass
3330         elif not isinstance(errorevery, str) and np.iterable(errorevery):
3331             try:
3332                 x[errorevery]  # fancy indexing
3333             except (ValueError, IndexError) as err:
3334                 raise ValueError(
3335                     f"{errorevery=!r} is iterable but not a valid NumPy fancy "
3336                     "index to match 'xerr'/'yerr'") from err
3337         else:
3338             raise ValueError(f"{errorevery=!r} is not a recognized value")
3339         everymask = np.zeros(len(x), bool)
3340         everymask[errorevery] = True
3341         return everymask
3342 
3343     @_preprocess_data(replace_names=["x", "y", "xerr", "yerr"],
3344                       label_namer="y")
3345     @_docstring.dedent_interpd
3346     def errorbar(self, x, y, yerr=None, xerr=None,
3347                  fmt='', ecolor=None, elinewidth=None, capsize=None,
3348                  barsabove=False, lolims=False, uplims=False,
3349                  xlolims=False, xuplims=False, errorevery=1, capthick=None,
3350                  **kwargs):
3351         """
3352         Plot y versus x as lines and/or markers with attached errorbars.
3353 
3354         *x*, *y* define the data locations, *xerr*, *yerr* define the errorbar
3355         sizes. By default, this draws the data markers/lines as well the
3356         errorbars. Use fmt='none' to draw errorbars without any data markers.
3357 
3358         .. versionadded:: 3.7
3359            Caps and error lines are drawn in polar coordinates on polar plots.
3360 
3361 
3362         Parameters
3363         ----------
3364         x, y : float or array-like
3365             The data positions.
3366 
3367         xerr, yerr : float or array-like, shape(N,) or shape(2, N), optional
3368             The errorbar sizes:
3369 
3370             - scalar: Symmetric +/- values for all data points.
3371             - shape(N,): Symmetric +/-values for each data point.
3372             - shape(2, N): Separate - and + values for each bar. First row
3373               contains the lower errors, the second row contains the upper
3374               errors.
3375             - *None*: No errorbar.
3376 
3377             All values must be >= 0.
3378 
3379             See :doc:`/gallery/statistics/errorbar_features`
3380             for an example on the usage of ``xerr`` and ``yerr``.
3381 
3382         fmt : str, default: ''
3383             The format for the data points / data lines. See `.plot` for
3384             details.
3385 
3386             Use 'none' (case-insensitive) to plot errorbars without any data
3387             markers.
3388 
3389         ecolor : color, default: None
3390             The color of the errorbar lines.  If None, use the color of the
3391             line connecting the markers.
3392 
3393         elinewidth : float, default: None
3394             The linewidth of the errorbar lines. If None, the linewidth of
3395             the current style is used.
3396 
3397         capsize : float, default: :rc:`errorbar.capsize`
3398             The length of the error bar caps in points.
3399 
3400         capthick : float, default: None
3401             An alias to the keyword argument *markeredgewidth* (a.k.a. *mew*).
3402             This setting is a more sensible name for the property that
3403             controls the thickness of the error bar cap in points. For
3404             backwards compatibility, if *mew* or *markeredgewidth* are given,
3405             then they will over-ride *capthick*. This may change in future
3406             releases.
3407 
3408         barsabove : bool, default: False
3409             If True, will plot the errorbars above the plot
3410             symbols. Default is below.
3411 
3412         lolims, uplims, xlolims, xuplims : bool, default: False
3413             These arguments can be used to indicate that a value gives only
3414             upper/lower limits.  In that case a caret symbol is used to
3415             indicate this. *lims*-arguments may be scalars, or array-likes of
3416             the same length as *xerr* and *yerr*.  To use limits with inverted
3417             axes, `~.Axes.set_xlim` or `~.Axes.set_ylim` must be called before
3418             :meth:`errorbar`.  Note the tricky parameter names: setting e.g.
3419             *lolims* to True means that the y-value is a *lower* limit of the
3420             True value, so, only an *upward*-pointing arrow will be drawn!
3421 
3422         errorevery : int or (int, int), default: 1
3423             draws error bars on a subset of the data. *errorevery* =N draws
3424             error bars on the points (x[::N], y[::N]).
3425             *errorevery* =(start, N) draws error bars on the points
3426             (x[start::N], y[start::N]). e.g. errorevery=(6, 3)
3427             adds error bars to the data at (x[6], x[9], x[12], x[15], ...).
3428             Used to avoid overlapping error bars when two series share x-axis
3429             values.
3430 
3431         Returns
3432         -------
3433         `.ErrorbarContainer`
3434             The container contains:
3435 
3436             - plotline: `.Line2D` instance of x, y plot markers and/or line.
3437             - caplines: A tuple of `.Line2D` instances of the error bar caps.
3438             - barlinecols: A tuple of `.LineCollection` with the horizontal and
3439               vertical error ranges.
3440 
3441         Other Parameters
3442         ----------------
3443         data : indexable object, optional
3444             DATA_PARAMETER_PLACEHOLDER
3445 
3446         **kwargs
3447             All other keyword arguments are passed on to the `~.Axes.plot` call
3448             drawing the markers. For example, this code makes big red squares
3449             with thick green edges::
3450 
3451                 x, y, yerr = rand(3, 10)
3452                 errorbar(x, y, yerr, marker='s', mfc='red',
3453                          mec='green', ms=20, mew=4)
3454 
3455             where *mfc*, *mec*, *ms* and *mew* are aliases for the longer
3456             property names, *markerfacecolor*, *markeredgecolor*, *markersize*
3457             and *markeredgewidth*.
3458 
3459             Valid kwargs for the marker properties are:
3460 
3461             - *dashes*
3462             - *dash_capstyle*
3463             - *dash_joinstyle*
3464             - *drawstyle*
3465             - *fillstyle*
3466             - *linestyle*
3467             - *marker*
3468             - *markeredgecolor*
3469             - *markeredgewidth*
3470             - *markerfacecolor*
3471             - *markerfacecoloralt*
3472             - *markersize*
3473             - *markevery*
3474             - *solid_capstyle*
3475             - *solid_joinstyle*
3476 
3477             Refer to the corresponding `.Line2D` property for more details:
3478 
3479             %(Line2D:kwdoc)s
3480         """
3481         kwargs = cbook.normalize_kwargs(kwargs, mlines.Line2D)
3482         # Drop anything that comes in as None to use the default instead.
3483         kwargs = {k: v for k, v in kwargs.items() if v is not None}
3484         kwargs.setdefault('zorder', 2)
3485 
3486         # Casting to object arrays preserves units.
3487         if not isinstance(x, np.ndarray):
3488             x = np.asarray(x, dtype=object)
3489         if not isinstance(y, np.ndarray):
3490             y = np.asarray(y, dtype=object)
3491 
3492         def _upcast_err(err):
3493             """
3494             Safely handle tuple of containers that carry units.
3495 
3496             This function covers the case where the input to the xerr/yerr is a
3497             length 2 tuple of equal length ndarray-subclasses that carry the
3498             unit information in the container.
3499 
3500             If we have a tuple of nested numpy array (subclasses), we defer
3501             coercing the units to be consistent to the underlying unit
3502             library (and implicitly the broadcasting).
3503 
3504             Otherwise, fallback to casting to an object array.
3505             """
3506 
3507             if (
3508                     # make sure it is not a scalar
3509                     np.iterable(err) and
3510                     # and it is not empty
3511                     len(err) > 0 and
3512                     # and the first element is an array sub-class use
3513                     # safe_first_element because getitem is index-first not
3514                     # location first on pandas objects so err[0] almost always
3515                     # fails.
3516                     isinstance(cbook._safe_first_finite(err), np.ndarray)
3517             ):
3518                 # Get the type of the first element
3519                 atype = type(cbook._safe_first_finite(err))
3520                 # Promote the outer container to match the inner container
3521                 if atype is np.ndarray:
3522                     # Converts using np.asarray, because data cannot
3523                     # be directly passed to init of np.ndarray
3524                     return np.asarray(err, dtype=object)
3525                 # If atype is not np.ndarray, directly pass data to init.
3526                 # This works for types such as unyts and astropy units
3527                 return atype(err)
3528             # Otherwise wrap it in an object array
3529             return np.asarray(err, dtype=object)
3530 
3531         if xerr is not None and not isinstance(xerr, np.ndarray):
3532             xerr = _upcast_err(xerr)
3533         if yerr is not None and not isinstance(yerr, np.ndarray):
3534             yerr = _upcast_err(yerr)
3535         x, y = np.atleast_1d(x, y)  # Make sure all the args are iterable.
3536         if len(x) != len(y):
3537             raise ValueError("'x' and 'y' must have the same size")
3538 
3539         everymask = self._errorevery_to_mask(x, errorevery)
3540 
3541         label = kwargs.pop("label", None)
3542         kwargs['label'] = '_nolegend_'
3543 
3544         # Create the main line and determine overall kwargs for child artists.
3545         # We avoid calling self.plot() directly, or self._get_lines(), because
3546         # that would call self._process_unit_info again, and do other indirect
3547         # data processing.
3548         (data_line, base_style), = self._get_lines._plot_args(
3549             (x, y) if fmt == '' else (x, y, fmt), kwargs, return_kwargs=True)
3550 
3551         # Do this after creating `data_line` to avoid modifying `base_style`.
3552         if barsabove:
3553             data_line.set_zorder(kwargs['zorder'] - .1)
3554         else:
3555             data_line.set_zorder(kwargs['zorder'] + .1)
3556 
3557         # Add line to plot, or throw it away and use it to determine kwargs.
3558         if fmt.lower() != 'none':
3559             self.add_line(data_line)
3560         else:
3561             data_line = None
3562             # Remove alpha=0 color that _get_lines._plot_args returns for
3563             # 'none' format, and replace it with user-specified color, if
3564             # supplied.
3565             base_style.pop('color')
3566             if 'color' in kwargs:
3567                 base_style['color'] = kwargs.pop('color')
3568 
3569         if 'color' not in base_style:
3570             base_style['color'] = 'C0'
3571         if ecolor is None:
3572             ecolor = base_style['color']
3573 
3574         # Eject any line-specific information from format string, as it's not
3575         # needed for bars or caps.
3576         for key in ['marker', 'markersize', 'markerfacecolor',
3577                     'markerfacecoloralt',
3578                     'markeredgewidth', 'markeredgecolor', 'markevery',
3579                     'linestyle', 'fillstyle', 'drawstyle', 'dash_capstyle',
3580                     'dash_joinstyle', 'solid_capstyle', 'solid_joinstyle',
3581                     'dashes']:
3582             base_style.pop(key, None)
3583 
3584         # Make the style dict for the line collections (the bars).
3585         eb_lines_style = {**base_style, 'color': ecolor}
3586 
3587         if elinewidth is not None:
3588             eb_lines_style['linewidth'] = elinewidth
3589         elif 'linewidth' in kwargs:
3590             eb_lines_style['linewidth'] = kwargs['linewidth']
3591 
3592         for key in ('transform', 'alpha', 'zorder', 'rasterized'):
3593             if key in kwargs:
3594                 eb_lines_style[key] = kwargs[key]
3595 
3596         # Make the style dict for caps (the "hats").
3597         eb_cap_style = {**base_style, 'linestyle': 'none'}
3598         if capsize is None:
3599             capsize = mpl.rcParams["errorbar.capsize"]
3600         if capsize > 0:
3601             eb_cap_style['markersize'] = 2. * capsize
3602         if capthick is not None:
3603             eb_cap_style['markeredgewidth'] = capthick
3604 
3605         # For backwards-compat, allow explicit setting of
3606         # 'markeredgewidth' to over-ride capthick.
3607         for key in ('markeredgewidth', 'transform', 'alpha',
3608                     'zorder', 'rasterized'):
3609             if key in kwargs:
3610                 eb_cap_style[key] = kwargs[key]
3611         eb_cap_style['color'] = ecolor
3612 
3613         barcols = []
3614         caplines = {'x': [], 'y': []}
3615 
3616         # Vectorized fancy-indexer.
3617         def apply_mask(arrays, mask):
3618             return [array[mask] for array in arrays]
3619 
3620         # dep: dependent dataset, indep: independent dataset
3621         for (dep_axis, dep, err, lolims, uplims, indep, lines_func,
3622              marker, lomarker, himarker) in [
3623                 ("x", x, xerr, xlolims, xuplims, y, self.hlines,
3624                  "|", mlines.CARETRIGHTBASE, mlines.CARETLEFTBASE),
3625                 ("y", y, yerr, lolims, uplims, x, self.vlines,
3626                  "_", mlines.CARETUPBASE, mlines.CARETDOWNBASE),
3627         ]:
3628             if err is None:
3629                 continue
3630             lolims = np.broadcast_to(lolims, len(dep)).astype(bool)
3631             uplims = np.broadcast_to(uplims, len(dep)).astype(bool)
3632             try:
3633                 np.broadcast_to(err, (2, len(dep)))
3634             except ValueError:
3635                 raise ValueError(
3636                     f"'{dep_axis}err' (shape: {np.shape(err)}) must be a "
3637                     f"scalar or a 1D or (2, n) array-like whose shape matches "
3638                     f"'{dep_axis}' (shape: {np.shape(dep)})") from None
3639             res = np.zeros(err.shape, dtype=bool)  # Default in case of nan
3640             if np.any(np.less(err, -err, out=res, where=(err == err))):
3641                 # like err<0, but also works for timedelta and nan.
3642                 raise ValueError(
3643                     f"'{dep_axis}err' must not contain negative values")
3644             # This is like
3645             #     elow, ehigh = np.broadcast_to(...)
3646             #     return dep - elow * ~lolims, dep + ehigh * ~uplims
3647             # except that broadcast_to would strip units.
3648             low, high = dep + np.row_stack([-(1 - lolims), 1 - uplims]) * err
3649             barcols.append(lines_func(
3650                 *apply_mask([indep, low, high], everymask), **eb_lines_style))
3651             if self.name == "polar" and dep_axis == "x":
3652                 for b in barcols:
3653                     for p in b.get_paths():
3654                         p._interpolation_steps = 2
3655             # Normal errorbars for points without upper/lower limits.
3656             nolims = ~(lolims | uplims)
3657             if nolims.any() and capsize > 0:
3658                 indep_masked, lo_masked, hi_masked = apply_mask(
3659                     [indep, low, high], nolims & everymask)
3660                 for lh_masked in [lo_masked, hi_masked]:
3661                     # Since this has to work for x and y as dependent data, we
3662                     # first set both x and y to the independent variable and
3663                     # overwrite the respective dependent data in a second step.
3664                     line = mlines.Line2D(indep_masked, indep_masked,
3665                                          marker=marker, **eb_cap_style)
3666                     line.set(**{f"{dep_axis}data": lh_masked})
3667                     caplines[dep_axis].append(line)
3668             for idx, (lims, hl) in enumerate([(lolims, high), (uplims, low)]):
3669                 if not lims.any():
3670                     continue
3671                 hlmarker = (
3672                     himarker
3673                     if self._axis_map[dep_axis].get_inverted() ^ idx
3674                     else lomarker)
3675                 x_masked, y_masked, hl_masked = apply_mask(
3676                     [x, y, hl], lims & everymask)
3677                 # As above, we set the dependent data in a second step.
3678                 line = mlines.Line2D(x_masked, y_masked,
3679                                      marker=hlmarker, **eb_cap_style)
3680                 line.set(**{f"{dep_axis}data": hl_masked})
3681                 caplines[dep_axis].append(line)
3682                 if capsize > 0:
3683                     caplines[dep_axis].append(mlines.Line2D(
3684                         x_masked, y_masked, marker=marker, **eb_cap_style))
3685         if self.name == 'polar':
3686             for axis in caplines:
3687                 for l in caplines[axis]:
3688                     # Rotate caps to be perpendicular to the error bars
3689                     for theta, r in zip(l.get_xdata(), l.get_ydata()):
3690                         rotation = mtransforms.Affine2D().rotate(theta)
3691                         if axis == 'y':
3692                             rotation.rotate(-np.pi / 2)
3693                         ms = mmarkers.MarkerStyle(marker=marker,
3694                                                   transform=rotation)
3695                         self.add_line(mlines.Line2D([theta], [r], marker=ms,
3696                                                     **eb_cap_style))
3697         else:
3698             for axis in caplines:
3699                 for l in caplines[axis]:
3700                     self.add_line(l)
3701 
3702         self._request_autoscale_view()
3703         caplines = caplines['x'] + caplines['y']
3704         errorbar_container = ErrorbarContainer(
3705             (data_line, tuple(caplines), tuple(barcols)),
3706             has_xerr=(xerr is not None), has_yerr=(yerr is not None),
3707             label=label)
3708         self.containers.append(errorbar_container)
3709 
3710         return errorbar_container  # (l0, caplines, barcols)
3711 
3712     @_preprocess_data()
3713     def boxplot(self, x, notch=None, sym=None, vert=None, whis=None,
3714                 positions=None, widths=None, patch_artist=None,
3715                 bootstrap=None, usermedians=None, conf_intervals=None,
3716                 meanline=None, showmeans=None, showcaps=None,
3717                 showbox=None, showfliers=None, boxprops=None,
3718                 labels=None, flierprops=None, medianprops=None,
3719                 meanprops=None, capprops=None, whiskerprops=None,
3720                 manage_ticks=True, autorange=False, zorder=None,
3721                 capwidths=None):
3722         """
3723         Draw a box and whisker plot.
3724 
3725         The box extends from the first quartile (Q1) to the third
3726         quartile (Q3) of the data, with a line at the median.
3727         The whiskers extend from the box to the farthest data point
3728         lying within 1.5x the inter-quartile range (IQR) from the box.
3729         Flier points are those past the end of the whiskers.
3730         See https://en.wikipedia.org/wiki/Box_plot for reference.
3731 
3732         .. code-block:: none
3733 
3734                   Q1-1.5IQR   Q1   median  Q3   Q3+1.5IQR
3735                                |-----:-----|
3736                o      |--------|     :     |--------|    o  o
3737                                |-----:-----|
3738              flier             <----------->            fliers
3739                                     IQR
3740 
3741 
3742         Parameters
3743         ----------
3744         x : Array or a sequence of vectors.
3745             The input data.  If a 2D array, a boxplot is drawn for each column
3746             in *x*.  If a sequence of 1D arrays, a boxplot is drawn for each
3747             array in *x*.
3748 
3749         notch : bool, default: False
3750             Whether to draw a notched boxplot (`True`), or a rectangular
3751             boxplot (`False`).  The notches represent the confidence interval
3752             (CI) around the median.  The documentation for *bootstrap*
3753             describes how the locations of the notches are computed by
3754             default, but their locations may also be overridden by setting the
3755             *conf_intervals* parameter.
3756 
3757             .. note::
3758 
3759                 In cases where the values of the CI are less than the
3760                 lower quartile or greater than the upper quartile, the
3761                 notches will extend beyond the box, giving it a
3762                 distinctive "flipped" appearance. This is expected
3763                 behavior and consistent with other statistical
3764                 visualization packages.
3765 
3766         sym : str, optional
3767             The default symbol for flier points.  An empty string ('') hides
3768             the fliers.  If `None`, then the fliers default to 'b+'.  More
3769             control is provided by the *flierprops* parameter.
3770 
3771         vert : bool, default: True
3772             If `True`, draws vertical boxes.
3773             If `False`, draw horizontal boxes.
3774 
3775         whis : float or (float, float), default: 1.5
3776             The position of the whiskers.
3777 
3778             If a float, the lower whisker is at the lowest datum above
3779             ``Q1 - whis*(Q3-Q1)``, and the upper whisker at the highest datum
3780             below ``Q3 + whis*(Q3-Q1)``, where Q1 and Q3 are the first and
3781             third quartiles.  The default value of ``whis = 1.5`` corresponds
3782             to Tukey's original definition of boxplots.
3783 
3784             If a pair of floats, they indicate the percentiles at which to
3785             draw the whiskers (e.g., (5, 95)).  In particular, setting this to
3786             (0, 100) results in whiskers covering the whole range of the data.
3787 
3788             In the edge case where ``Q1 == Q3``, *whis* is automatically set
3789             to (0, 100) (cover the whole range of the data) if *autorange* is
3790             True.
3791 
3792             Beyond the whiskers, data are considered outliers and are plotted
3793             as individual points.
3794 
3795         bootstrap : int, optional
3796             Specifies whether to bootstrap the confidence intervals
3797             around the median for notched boxplots. If *bootstrap* is
3798             None, no bootstrapping is performed, and notches are
3799             calculated using a Gaussian-based asymptotic approximation
3800             (see McGill, R., Tukey, J.W., and Larsen, W.A., 1978, and
3801             Kendall and Stuart, 1967). Otherwise, bootstrap specifies
3802             the number of times to bootstrap the median to determine its
3803             95% confidence intervals. Values between 1000 and 10000 are
3804             recommended.
3805 
3806         usermedians : 1D array-like, optional
3807             A 1D array-like of length ``len(x)``.  Each entry that is not
3808             `None` forces the value of the median for the corresponding
3809             dataset.  For entries that are `None`, the medians are computed
3810             by Matplotlib as normal.
3811 
3812         conf_intervals : array-like, optional
3813             A 2D array-like of shape ``(len(x), 2)``.  Each entry that is not
3814             None forces the location of the corresponding notch (which is
3815             only drawn if *notch* is `True`).  For entries that are `None`,
3816             the notches are computed by the method specified by the other
3817             parameters (e.g., *bootstrap*).
3818 
3819         positions : array-like, optional
3820             The positions of the boxes. The ticks and limits are
3821             automatically set to match the positions. Defaults to
3822             ``range(1, N+1)`` where N is the number of boxes to be drawn.
3823 
3824         widths : float or array-like
3825             The widths of the boxes.  The default is 0.5, or ``0.15*(distance
3826             between extreme positions)``, if that is smaller.
3827 
3828         patch_artist : bool, default: False
3829             If `False` produces boxes with the Line2D artist. Otherwise,
3830             boxes are drawn with Patch artists.
3831 
3832         labels : sequence, optional
3833             Labels for each dataset (one per dataset).
3834 
3835         manage_ticks : bool, default: True
3836             If True, the tick locations and labels will be adjusted to match
3837             the boxplot positions.
3838 
3839         autorange : bool, default: False
3840             When `True` and the data are distributed such that the 25th and
3841             75th percentiles are equal, *whis* is set to (0, 100) such
3842             that the whisker ends are at the minimum and maximum of the data.
3843 
3844         meanline : bool, default: False
3845             If `True` (and *showmeans* is `True`), will try to render the
3846             mean as a line spanning the full width of the box according to
3847             *meanprops* (see below).  Not recommended if *shownotches* is also
3848             True.  Otherwise, means will be shown as points.
3849 
3850         zorder : float, default: ``Line2D.zorder = 2``
3851             The zorder of the boxplot.
3852 
3853         Returns
3854         -------
3855         dict
3856           A dictionary mapping each component of the boxplot to a list
3857           of the `.Line2D` instances created. That dictionary has the
3858           following keys (assuming vertical boxplots):
3859 
3860           - ``boxes``: the main body of the boxplot showing the
3861             quartiles and the median's confidence intervals if
3862             enabled.
3863 
3864           - ``medians``: horizontal lines at the median of each box.
3865 
3866           - ``whiskers``: the vertical lines extending to the most
3867             extreme, non-outlier data points.
3868 
3869           - ``caps``: the horizontal lines at the ends of the
3870             whiskers.
3871 
3872           - ``fliers``: points representing data that extend beyond
3873             the whiskers (fliers).
3874 
3875           - ``means``: points or lines representing the means.
3876 
3877         Other Parameters
3878         ----------------
3879         showcaps : bool, default: True
3880             Show the caps on the ends of whiskers.
3881         showbox : bool, default: True
3882             Show the central box.
3883         showfliers : bool, default: True
3884             Show the outliers beyond the caps.
3885         showmeans : bool, default: False
3886             Show the arithmetic means.
3887         capprops : dict, default: None
3888             The style of the caps.
3889         capwidths : float or array, default: None
3890             The widths of the caps.
3891         boxprops : dict, default: None
3892             The style of the box.
3893         whiskerprops : dict, default: None
3894             The style of the whiskers.
3895         flierprops : dict, default: None
3896             The style of the fliers.
3897         medianprops : dict, default: None
3898             The style of the median.
3899         meanprops : dict, default: None
3900             The style of the mean.
3901         data : indexable object, optional
3902             DATA_PARAMETER_PLACEHOLDER
3903 
3904         See Also
3905         --------
3906         violinplot : Draw an estimate of the probability density function.
3907         """
3908 
3909         # Missing arguments default to rcParams.
3910         if whis is None:
3911             whis = mpl.rcParams['boxplot.whiskers']
3912         if bootstrap is None:
3913             bootstrap = mpl.rcParams['boxplot.bootstrap']
3914 
3915         bxpstats = cbook.boxplot_stats(x, whis=whis, bootstrap=bootstrap,
3916                                        labels=labels, autorange=autorange)
3917         if notch is None:
3918             notch = mpl.rcParams['boxplot.notch']
3919         if vert is None:
3920             vert = mpl.rcParams['boxplot.vertical']
3921         if patch_artist is None:
3922             patch_artist = mpl.rcParams['boxplot.patchartist']
3923         if meanline is None:
3924             meanline = mpl.rcParams['boxplot.meanline']
3925         if showmeans is None:
3926             showmeans = mpl.rcParams['boxplot.showmeans']
3927         if showcaps is None:
3928             showcaps = mpl.rcParams['boxplot.showcaps']
3929         if showbox is None:
3930             showbox = mpl.rcParams['boxplot.showbox']
3931         if showfliers is None:
3932             showfliers = mpl.rcParams['boxplot.showfliers']
3933 
3934         if boxprops is None:
3935             boxprops = {}
3936         if whiskerprops is None:
3937             whiskerprops = {}
3938         if capprops is None:
3939             capprops = {}
3940         if medianprops is None:
3941             medianprops = {}
3942         if meanprops is None:
3943             meanprops = {}
3944         if flierprops is None:
3945             flierprops = {}
3946 
3947         if patch_artist:
3948             boxprops['linestyle'] = 'solid'  # Not consistent with bxp.
3949             if 'color' in boxprops:
3950                 boxprops['edgecolor'] = boxprops.pop('color')
3951 
3952         # if non-default sym value, put it into the flier dictionary
3953         # the logic for providing the default symbol ('b+') now lives
3954         # in bxp in the initial value of flierkw
3955         # handle all of the *sym* related logic here so we only have to pass
3956         # on the flierprops dict.
3957         if sym is not None:
3958             # no-flier case, which should really be done with
3959             # 'showfliers=False' but none-the-less deal with it to keep back
3960             # compatibility
3961             if sym == '':
3962                 # blow away existing dict and make one for invisible markers
3963                 flierprops = dict(linestyle='none', marker='', color='none')
3964                 # turn the fliers off just to be safe
3965                 showfliers = False
3966             # now process the symbol string
3967             else:
3968                 # process the symbol string
3969                 # discarded linestyle
3970                 _, marker, color = _process_plot_format(sym)
3971                 # if we have a marker, use it
3972                 if marker is not None:
3973                     flierprops['marker'] = marker
3974                 # if we have a color, use it
3975                 if color is not None:
3976                     # assume that if color is passed in the user want
3977                     # filled symbol, if the users want more control use
3978                     # flierprops
3979                     flierprops['color'] = color
3980                     flierprops['markerfacecolor'] = color
3981                     flierprops['markeredgecolor'] = color
3982 
3983         # replace medians if necessary:
3984         if usermedians is not None:
3985             if (len(np.ravel(usermedians)) != len(bxpstats) or
3986                     np.shape(usermedians)[0] != len(bxpstats)):
3987                 raise ValueError(
3988                     "'usermedians' and 'x' have different lengths")
3989             else:
3990                 # reassign medians as necessary
3991                 for stats, med in zip(bxpstats, usermedians):
3992                     if med is not None:
3993                         stats['med'] = med
3994 
3995         if conf_intervals is not None:
3996             if len(conf_intervals) != len(bxpstats):
3997                 raise ValueError(
3998                     "'conf_intervals' and 'x' have different lengths")
3999             else:
4000                 for stats, ci in zip(bxpstats, conf_intervals):
4001                     if ci is not None:
4002                         if len(ci) != 2:
4003                             raise ValueError('each confidence interval must '
4004                                              'have two values')
4005                         else:
4006                             if ci[0] is not None:
4007                                 stats['cilo'] = ci[0]
4008                             if ci[1] is not None:
4009                                 stats['cihi'] = ci[1]
4010 
4011         artists = self.bxp(bxpstats, positions=positions, widths=widths,
4012                            vert=vert, patch_artist=patch_artist,
4013                            shownotches=notch, showmeans=showmeans,
4014                            showcaps=showcaps, showbox=showbox,
4015                            boxprops=boxprops, flierprops=flierprops,
4016                            medianprops=medianprops, meanprops=meanprops,
4017                            meanline=meanline, showfliers=showfliers,
4018                            capprops=capprops, whiskerprops=whiskerprops,
4019                            manage_ticks=manage_ticks, zorder=zorder,
4020                            capwidths=capwidths)
4021         return artists
4022 
4023     def bxp(self, bxpstats, positions=None, widths=None, vert=True,
4024             patch_artist=False, shownotches=False, showmeans=False,
4025             showcaps=True, showbox=True, showfliers=True,
4026             boxprops=None, whiskerprops=None, flierprops=None,
4027             medianprops=None, capprops=None, meanprops=None,
4028             meanline=False, manage_ticks=True, zorder=None,
4029             capwidths=None):
4030         """
4031         Drawing function for box and whisker plots.
4032 
4033         Make a box and whisker plot for each column of *x* or each
4034         vector in sequence *x*.  The box extends from the lower to
4035         upper quartile values of the data, with a line at the median.
4036         The whiskers extend from the box to show the range of the
4037         data.  Flier points are those past the end of the whiskers.
4038 
4039         Parameters
4040         ----------
4041         bxpstats : list of dicts
4042           A list of dictionaries containing stats for each boxplot.
4043           Required keys are:
4044 
4045           - ``med``: Median (scalar).
4046           - ``q1``, ``q3``: First & third quartiles (scalars).
4047           - ``whislo``, ``whishi``: Lower & upper whisker positions (scalars).
4048 
4049           Optional keys are:
4050 
4051           - ``mean``: Mean (scalar).  Needed if ``showmeans=True``.
4052           - ``fliers``: Data beyond the whiskers (array-like).
4053             Needed if ``showfliers=True``.
4054           - ``cilo``, ``cihi``: Lower & upper confidence intervals
4055             about the median. Needed if ``shownotches=True``.
4056           - ``label``: Name of the dataset (str).  If available,
4057             this will be used a tick label for the boxplot
4058 
4059         positions : array-like, default: [1, 2, ..., n]
4060           The positions of the boxes. The ticks and limits
4061           are automatically set to match the positions.
4062 
4063         widths : float or array-like, default: None
4064           The widths of the boxes.  The default is
4065           ``clip(0.15*(distance between extreme positions), 0.15, 0.5)``.
4066 
4067         capwidths : float or array-like, default: None
4068           Either a scalar or a vector and sets the width of each cap.
4069           The default is ``0.5*(with of the box)``, see *widths*.
4070 
4071         vert : bool, default: True
4072           If `True` (default), makes the boxes vertical.
4073           If `False`, makes horizontal boxes.
4074 
4075         patch_artist : bool, default: False
4076           If `False` produces boxes with the `.Line2D` artist.
4077           If `True` produces boxes with the `~matplotlib.patches.Patch` artist.
4078 
4079         shownotches, showmeans, showcaps, showbox, showfliers : bool
4080           Whether to draw the CI notches, the mean value (both default to
4081           False), the caps, the box, and the fliers (all three default to
4082           True).
4083 
4084         boxprops, whiskerprops, capprops, flierprops, medianprops, meanprops :\
4085  dict, optional
4086           Artist properties for the boxes, whiskers, caps, fliers, medians, and
4087           means.
4088 
4089         meanline : bool, default: False
4090           If `True` (and *showmeans* is `True`), will try to render the mean
4091           as a line spanning the full width of the box according to
4092           *meanprops*. Not recommended if *shownotches* is also True.
4093           Otherwise, means will be shown as points.
4094 
4095         manage_ticks : bool, default: True
4096           If True, the tick locations and labels will be adjusted to match the
4097           boxplot positions.
4098 
4099         zorder : float, default: ``Line2D.zorder = 2``
4100           The zorder of the resulting boxplot.
4101 
4102         Returns
4103         -------
4104         dict
4105           A dictionary mapping each component of the boxplot to a list
4106           of the `.Line2D` instances created. That dictionary has the
4107           following keys (assuming vertical boxplots):
4108 
4109           - ``boxes``: main bodies of the boxplot showing the quartiles, and
4110             the median's confidence intervals if enabled.
4111           - ``medians``: horizontal lines at the median of each box.
4112           - ``whiskers``: vertical lines up to the last non-outlier data.
4113           - ``caps``: horizontal lines at the ends of the whiskers.
4114           - ``fliers``: points representing data beyond the whiskers (fliers).
4115           - ``means``: points or lines representing the means.
4116 
4117         Examples
4118         --------
4119         .. plot:: gallery/statistics/bxp.py
4120         """
4121 
4122         # lists of artists to be output
4123         whiskers = []
4124         caps = []
4125         boxes = []
4126         medians = []
4127         means = []
4128         fliers = []
4129 
4130         # empty list of xticklabels
4131         datalabels = []
4132 
4133         # Use default zorder if none specified
4134         if zorder is None:
4135             zorder = mlines.Line2D.zorder
4136 
4137         zdelta = 0.1
4138 
4139         def merge_kw_rc(subkey, explicit, zdelta=0, usemarker=True):
4140             d = {k.split('.')[-1]: v for k, v in mpl.rcParams.items()
4141                  if k.startswith(f'boxplot.{subkey}props')}
4142             d['zorder'] = zorder + zdelta
4143             if not usemarker:
4144                 d['marker'] = ''
4145             d.update(cbook.normalize_kwargs(explicit, mlines.Line2D))
4146             return d
4147 
4148         box_kw = {
4149             'linestyle': mpl.rcParams['boxplot.boxprops.linestyle'],
4150             'linewidth': mpl.rcParams['boxplot.boxprops.linewidth'],
4151             'edgecolor': mpl.rcParams['boxplot.boxprops.color'],
4152             'facecolor': ('white' if mpl.rcParams['_internal.classic_mode']
4153                           else mpl.rcParams['patch.facecolor']),
4154             'zorder': zorder,
4155             **cbook.normalize_kwargs(boxprops, mpatches.PathPatch)
4156         } if patch_artist else merge_kw_rc('box', boxprops, usemarker=False)
4157         whisker_kw = merge_kw_rc('whisker', whiskerprops, usemarker=False)
4158         cap_kw = merge_kw_rc('cap', capprops, usemarker=False)
4159         flier_kw = merge_kw_rc('flier', flierprops)
4160         median_kw = merge_kw_rc('median', medianprops, zdelta, usemarker=False)
4161         mean_kw = merge_kw_rc('mean', meanprops, zdelta)
4162         removed_prop = 'marker' if meanline else 'linestyle'
4163         # Only remove the property if it's not set explicitly as a parameter.
4164         if meanprops is None or removed_prop not in meanprops:
4165             mean_kw[removed_prop] = ''
4166 
4167         # vertical or horizontal plot?
4168         maybe_swap = slice(None) if vert else slice(None, None, -1)
4169 
4170         def do_plot(xs, ys, **kwargs):
4171             return self.plot(*[xs, ys][maybe_swap], **kwargs)[0]
4172 
4173         def do_patch(xs, ys, **kwargs):
4174             path = mpath.Path._create_closed(
4175                 np.column_stack([xs, ys][maybe_swap]))
4176             patch = mpatches.PathPatch(path, **kwargs)
4177             self.add_artist(patch)
4178             return patch
4179 
4180         # input validation
4181         N = len(bxpstats)
4182         datashape_message = ("List of boxplot statistics and `{0}` "
4183                              "values must have same the length")
4184         # check position
4185         if positions is None:
4186             positions = list(range(1, N + 1))
4187         elif len(positions) != N:
4188             raise ValueError(datashape_message.format("positions"))
4189 
4190         positions = np.array(positions)
4191         if len(positions) > 0 and not all(isinstance(p, Real) for p in positions):
4192             raise TypeError("positions should be an iterable of numbers")
4193 
4194         # width
4195         if widths is None:
4196             widths = [np.clip(0.15 * np.ptp(positions), 0.15, 0.5)] * N
4197         elif np.isscalar(widths):
4198             widths = [widths] * N
4199         elif len(widths) != N:
4200             raise ValueError(datashape_message.format("widths"))
4201 
4202         # capwidth
4203         if capwidths is None:
4204             capwidths = 0.5 * np.array(widths)
4205         elif np.isscalar(capwidths):
4206             capwidths = [capwidths] * N
4207         elif len(capwidths) != N:
4208             raise ValueError(datashape_message.format("capwidths"))
4209 
4210         for pos, width, stats, capwidth in zip(positions, widths, bxpstats,
4211                                                capwidths):
4212             # try to find a new label
4213             datalabels.append(stats.get('label', pos))
4214 
4215             # whisker coords
4216             whis_x = [pos, pos]
4217             whislo_y = [stats['q1'], stats['whislo']]
4218             whishi_y = [stats['q3'], stats['whishi']]
4219             # cap coords
4220             cap_left = pos - capwidth * 0.5
4221             cap_right = pos + capwidth * 0.5
4222             cap_x = [cap_left, cap_right]
4223             cap_lo = np.full(2, stats['whislo'])
4224             cap_hi = np.full(2, stats['whishi'])
4225             # box and median coords
4226             box_left = pos - width * 0.5
4227             box_right = pos + width * 0.5
4228             med_y = [stats['med'], stats['med']]
4229             # notched boxes
4230             if shownotches:
4231                 notch_left = pos - width * 0.25
4232                 notch_right = pos + width * 0.25
4233                 box_x = [box_left, box_right, box_right, notch_right,
4234                          box_right, box_right, box_left, box_left, notch_left,
4235                          box_left, box_left]
4236                 box_y = [stats['q1'], stats['q1'], stats['cilo'],
4237                          stats['med'], stats['cihi'], stats['q3'],
4238                          stats['q3'], stats['cihi'], stats['med'],
4239                          stats['cilo'], stats['q1']]
4240                 med_x = [notch_left, notch_right]
4241             # plain boxes
4242             else:
4243                 box_x = [box_left, box_right, box_right, box_left, box_left]
4244                 box_y = [stats['q1'], stats['q1'], stats['q3'], stats['q3'],
4245                          stats['q1']]
4246                 med_x = [box_left, box_right]
4247 
4248             # maybe draw the box
4249             if showbox:
4250                 do_box = do_patch if patch_artist else do_plot
4251                 boxes.append(do_box(box_x, box_y, **box_kw))
4252             # draw the whiskers
4253             whiskers.append(do_plot(whis_x, whislo_y, **whisker_kw))
4254             whiskers.append(do_plot(whis_x, whishi_y, **whisker_kw))
4255             # maybe draw the caps
4256             if showcaps:
4257                 caps.append(do_plot(cap_x, cap_lo, **cap_kw))
4258                 caps.append(do_plot(cap_x, cap_hi, **cap_kw))
4259             # draw the medians
4260             medians.append(do_plot(med_x, med_y, **median_kw))
4261             # maybe draw the means
4262             if showmeans:
4263                 if meanline:
4264                     means.append(do_plot(
4265                         [box_left, box_right], [stats['mean'], stats['mean']],
4266                         **mean_kw
4267                     ))
4268                 else:
4269                     means.append(do_plot([pos], [stats['mean']], **mean_kw))
4270             # maybe draw the fliers
4271             if showfliers:
4272                 flier_x = np.full(len(stats['fliers']), pos, dtype=np.float64)
4273                 flier_y = stats['fliers']
4274                 fliers.append(do_plot(flier_x, flier_y, **flier_kw))
4275 
4276         if manage_ticks:
4277             axis_name = "x" if vert else "y"
4278             interval = getattr(self.dataLim, f"interval{axis_name}")
4279             axis = self._axis_map[axis_name]
4280             positions = axis.convert_units(positions)
4281             # The 0.5 additional padding ensures reasonable-looking boxes
4282             # even when drawing a single box.  We set the sticky edge to
4283             # prevent margins expansion, in order to match old behavior (back
4284             # when separate calls to boxplot() would completely reset the axis
4285             # limits regardless of what was drawn before).  The sticky edges
4286             # are attached to the median lines, as they are always present.
4287             interval[:] = (min(interval[0], min(positions) - .5),
4288                            max(interval[1], max(positions) + .5))
4289             for median, position in zip(medians, positions):
4290                 getattr(median.sticky_edges, axis_name).extend(
4291                     [position - .5, position + .5])
4292             # Modified from Axis.set_ticks and Axis.set_ticklabels.
4293             locator = axis.get_major_locator()
4294             if not isinstance(axis.get_major_locator(),
4295                               mticker.FixedLocator):
4296                 locator = mticker.FixedLocator([])
4297                 axis.set_major_locator(locator)
4298             locator.locs = np.array([*locator.locs, *positions])
4299             formatter = axis.get_major_formatter()
4300             if not isinstance(axis.get_major_formatter(),
4301                               mticker.FixedFormatter):
4302                 formatter = mticker.FixedFormatter([])
4303                 axis.set_major_formatter(formatter)
4304             formatter.seq = [*formatter.seq, *datalabels]
4305 
4306             self._request_autoscale_view()
4307 
4308         return dict(whiskers=whiskers, caps=caps, boxes=boxes,
4309                     medians=medians, fliers=fliers, means=means)
4310 
4311     @staticmethod
4312     def _parse_scatter_color_args(c, edgecolors, kwargs, xsize,
4313                                   get_next_color_func):
4314         """
4315         Helper function to process color related arguments of `.Axes.scatter`.
4316 
4317         Argument precedence for facecolors:
4318 
4319         - c (if not None)
4320         - kwargs['facecolor']
4321         - kwargs['facecolors']
4322         - kwargs['color'] (==kwcolor)
4323         - 'b' if in classic mode else the result of ``get_next_color_func()``
4324 
4325         Argument precedence for edgecolors:
4326 
4327         - kwargs['edgecolor']
4328         - edgecolors (is an explicit kw argument in scatter())
4329         - kwargs['color'] (==kwcolor)
4330         - 'face' if not in classic mode else None
4331 
4332         Parameters
4333         ----------
4334         c : color or sequence or sequence of color or None
4335             See argument description of `.Axes.scatter`.
4336         edgecolors : color or sequence of color or {'face', 'none'} or None
4337             See argument description of `.Axes.scatter`.
4338         kwargs : dict
4339             Additional kwargs. If these keys exist, we pop and process them:
4340             'facecolors', 'facecolor', 'edgecolor', 'color'
4341             Note: The dict is modified by this function.
4342         xsize : int
4343             The size of the x and y arrays passed to `.Axes.scatter`.
4344         get_next_color_func : callable
4345             A callable that returns a color. This color is used as facecolor
4346             if no other color is provided.
4347 
4348             Note, that this is a function rather than a fixed color value to
4349             support conditional evaluation of the next color.  As of the
4350             current implementation obtaining the next color from the
4351             property cycle advances the cycle. This must only happen if we
4352             actually use the color, which will only be decided within this
4353             method.
4354 
4355         Returns
4356         -------
4357         c
4358             The input *c* if it was not *None*, else a color derived from the
4359             other inputs or defaults.
4360         colors : array(N, 4) or None
4361             The facecolors as RGBA values, or *None* if a colormap is used.
4362         edgecolors
4363             The edgecolor.
4364 
4365         """
4366         facecolors = kwargs.pop('facecolors', None)
4367         facecolors = kwargs.pop('facecolor', facecolors)
4368         edgecolors = kwargs.pop('edgecolor', edgecolors)
4369 
4370         kwcolor = kwargs.pop('color', None)
4371 
4372         if kwcolor is not None and c is not None:
4373             raise ValueError("Supply a 'c' argument or a 'color'"
4374                              " kwarg but not both; they differ but"
4375                              " their functionalities overlap.")
4376 
4377         if kwcolor is not None:
4378             try:
4379                 mcolors.to_rgba_array(kwcolor)
4380             except ValueError as err:
4381                 raise ValueError(
4382                     "'color' kwarg must be a color or sequence of color "
4383                     "specs.  For a sequence of values to be color-mapped, use "
4384                     "the 'c' argument instead.") from err
4385             if edgecolors is None:
4386                 edgecolors = kwcolor
4387             if facecolors is None:
4388                 facecolors = kwcolor
4389 
4390         if edgecolors is None and not mpl.rcParams['_internal.classic_mode']:
4391             edgecolors = mpl.rcParams['scatter.edgecolors']
4392 
4393         c_was_none = c is None
4394         if c is None:
4395             c = (facecolors if facecolors is not None
4396                  else "b" if mpl.rcParams['_internal.classic_mode']
4397                  else get_next_color_func())
4398         c_is_string_or_strings = (
4399             isinstance(c, str)
4400             or (np.iterable(c) and len(c) > 0
4401                 and isinstance(cbook._safe_first_finite(c), str)))
4402 
4403         def invalid_shape_exception(csize, xsize):
4404             return ValueError(
4405                 f"'c' argument has {csize} elements, which is inconsistent "
4406                 f"with 'x' and 'y' with size {xsize}.")
4407 
4408         c_is_mapped = False  # Unless proven otherwise below.
4409         valid_shape = True  # Unless proven otherwise below.
4410         if not c_was_none and kwcolor is None and not c_is_string_or_strings:
4411             try:  # First, does 'c' look suitable for value-mapping?
4412                 c = np.asanyarray(c, dtype=float)
4413             except ValueError:
4414                 pass  # Failed to convert to float array; must be color specs.
4415             else:
4416                 # handle the documented special case of a 2D array with 1
4417                 # row which as RGB(A) to broadcast.
4418                 if c.shape == (1, 4) or c.shape == (1, 3):
4419                     c_is_mapped = False
4420                     if c.size != xsize:
4421                         valid_shape = False
4422                 # If c can be either mapped values or an RGB(A) color, prefer
4423                 # the former if shapes match, the latter otherwise.
4424                 elif c.size == xsize:
4425                     c = c.ravel()
4426                     c_is_mapped = True
4427                 else:  # Wrong size; it must not be intended for mapping.
4428                     if c.shape in ((3,), (4,)):
4429                         _api.warn_external(
4430                             "*c* argument looks like a single numeric RGB or "
4431                             "RGBA sequence, which should be avoided as value-"
4432                             "mapping will have precedence in case its length "
4433                             "matches with *x* & *y*.  Please use the *color* "
4434                             "keyword-argument or provide a 2D array "
4435                             "with a single row if you intend to specify "
4436                             "the same RGB or RGBA value for all points.")
4437                     valid_shape = False
4438         if not c_is_mapped:
4439             try:  # Is 'c' acceptable as PathCollection facecolors?
4440                 colors = mcolors.to_rgba_array(c)
4441             except (TypeError, ValueError) as err:
4442                 if "RGBA values should be within 0-1 range" in str(err):
4443                     raise
4444                 else:
4445                     if not valid_shape:
4446                         raise invalid_shape_exception(c.size, xsize) from err
4447                     # Both the mapping *and* the RGBA conversion failed: pretty
4448                     # severe failure => one may appreciate a verbose feedback.
4449                     raise ValueError(
4450                         f"'c' argument must be a color, a sequence of colors, "
4451                         f"or a sequence of numbers, not {c!r}") from err
4452             else:
4453                 if len(colors) not in (0, 1, xsize):
4454                     # NB: remember that a single color is also acceptable.
4455                     # Besides *colors* will be an empty array if c == 'none'.
4456                     raise invalid_shape_exception(len(colors), xsize)
4457         else:
4458             colors = None  # use cmap, norm after collection is created
4459         return c, colors, edgecolors
4460 
4461     @_preprocess_data(replace_names=["x", "y", "s", "linewidths",
4462                                      "edgecolors", "c", "facecolor",
4463                                      "facecolors", "color"],
4464                       label_namer="y")
4465     @_docstring.interpd
4466     def scatter(self, x, y, s=None, c=None, marker=None, cmap=None, norm=None,
4467                 vmin=None, vmax=None, alpha=None, linewidths=None, *,
4468                 edgecolors=None, plotnonfinite=False, **kwargs):
4469         """
4470         A scatter plot of *y* vs. *x* with varying marker size and/or color.
4471 
4472         Parameters
4473         ----------
4474         x, y : float or array-like, shape (n, )
4475             The data positions.
4476 
4477         s : float or array-like, shape (n, ), optional
4478             The marker size in points**2 (typographic points are 1/72 in.).
4479             Default is ``rcParams['lines.markersize'] ** 2``.
4480 
4481         c : array-like or list of colors or color, optional
4482             The marker colors. Possible values:
4483 
4484             - A scalar or sequence of n numbers to be mapped to colors using
4485               *cmap* and *norm*.
4486             - A 2D array in which the rows are RGB or RGBA.
4487             - A sequence of colors of length n.
4488             - A single color format string.
4489 
4490             Note that *c* should not be a single numeric RGB or RGBA sequence
4491             because that is indistinguishable from an array of values to be
4492             colormapped. If you want to specify the same RGB or RGBA value for
4493             all points, use a 2D array with a single row.  Otherwise,
4494             value-matching will have precedence in case of a size matching with
4495             *x* and *y*.
4496 
4497             If you wish to specify a single color for all points
4498             prefer the *color* keyword argument.
4499 
4500             Defaults to `None`. In that case the marker color is determined
4501             by the value of *color*, *facecolor* or *facecolors*. In case
4502             those are not specified or `None`, the marker color is determined
4503             by the next color of the ``Axes``' current "shape and fill" color
4504             cycle. This cycle defaults to :rc:`axes.prop_cycle`.
4505 
4506         marker : `~.markers.MarkerStyle`, default: :rc:`scatter.marker`
4507             The marker style. *marker* can be either an instance of the class
4508             or the text shorthand for a particular marker.
4509             See :mod:`matplotlib.markers` for more information about marker
4510             styles.
4511 
4512         %(cmap_doc)s
4513 
4514             This parameter is ignored if *c* is RGB(A).
4515 
4516         %(norm_doc)s
4517 
4518             This parameter is ignored if *c* is RGB(A).
4519 
4520         %(vmin_vmax_doc)s
4521 
4522             This parameter is ignored if *c* is RGB(A).
4523 
4524         alpha : float, default: None
4525             The alpha blending value, between 0 (transparent) and 1 (opaque).
4526 
4527         linewidths : float or array-like, default: :rc:`lines.linewidth`
4528             The linewidth of the marker edges. Note: The default *edgecolors*
4529             is 'face'. You may want to change this as well.
4530 
4531         edgecolors : {'face', 'none', *None*} or color or sequence of color, \
4532 default: :rc:`scatter.edgecolors`
4533             The edge color of the marker. Possible values:
4534 
4535             - 'face': The edge color will always be the same as the face color.
4536             - 'none': No patch boundary will be drawn.
4537             - A color or sequence of colors.
4538 
4539             For non-filled markers, *edgecolors* is ignored. Instead, the color
4540             is determined like with 'face', i.e. from *c*, *colors*, or
4541             *facecolors*.
4542 
4543         plotnonfinite : bool, default: False
4544             Whether to plot points with nonfinite *c* (i.e. ``inf``, ``-inf``
4545             or ``nan``). If ``True`` the points are drawn with the *bad*
4546             colormap color (see `.Colormap.set_bad`).
4547 
4548         Returns
4549         -------
4550         `~matplotlib.collections.PathCollection`
4551 
4552         Other Parameters
4553         ----------------
4554         data : indexable object, optional
4555             DATA_PARAMETER_PLACEHOLDER
4556         **kwargs : `~matplotlib.collections.Collection` properties
4557 
4558         See Also
4559         --------
4560         plot : To plot scatter plots when markers are identical in size and
4561             color.
4562 
4563         Notes
4564         -----
4565         * The `.plot` function will be faster for scatterplots where markers
4566           don't vary in size or color.
4567 
4568         * Any or all of *x*, *y*, *s*, and *c* may be masked arrays, in which
4569           case all masks will be combined and only unmasked points will be
4570           plotted.
4571 
4572         * Fundamentally, scatter works with 1D arrays; *x*, *y*, *s*, and *c*
4573           may be input as N-D arrays, but within scatter they will be
4574           flattened. The exception is *c*, which will be flattened only if its
4575           size matches the size of *x* and *y*.
4576 
4577         """
4578         # Process **kwargs to handle aliases, conflicts with explicit kwargs:
4579         x, y = self._process_unit_info([("x", x), ("y", y)], kwargs)
4580         # np.ma.ravel yields an ndarray, not a masked array,
4581         # unless its argument is a masked array.
4582         x = np.ma.ravel(x)
4583         y = np.ma.ravel(y)
4584         if x.size != y.size:
4585             raise ValueError("x and y must be the same size")
4586 
4587         if s is None:
4588             s = (20 if mpl.rcParams['_internal.classic_mode'] else
4589                  mpl.rcParams['lines.markersize'] ** 2.0)
4590         s = np.ma.ravel(s)
4591         if (len(s) not in (1, x.size) or
4592                 (not np.issubdtype(s.dtype, np.floating) and
4593                  not np.issubdtype(s.dtype, np.integer))):
4594             raise ValueError(
4595                 "s must be a scalar, "
4596                 "or float array-like with the same size as x and y")
4597 
4598         # get the original edgecolor the user passed before we normalize
4599         orig_edgecolor = edgecolors
4600         if edgecolors is None:
4601             orig_edgecolor = kwargs.get('edgecolor', None)
4602         c, colors, edgecolors = \
4603             self._parse_scatter_color_args(
4604                 c, edgecolors, kwargs, x.size,
4605                 get_next_color_func=self._get_patches_for_fill.get_next_color)
4606 
4607         if plotnonfinite and colors is None:
4608             c = np.ma.masked_invalid(c)
4609             x, y, s, edgecolors, linewidths = \
4610                 cbook._combine_masks(x, y, s, edgecolors, linewidths)
4611         else:
4612             x, y, s, c, colors, edgecolors, linewidths = \
4613                 cbook._combine_masks(
4614                     x, y, s, c, colors, edgecolors, linewidths)
4615         # Unmask edgecolors if it was actually a single RGB or RGBA.
4616         if (x.size in (3, 4)
4617                 and np.ma.is_masked(edgecolors)
4618                 and not np.ma.is_masked(orig_edgecolor)):
4619             edgecolors = edgecolors.data
4620 
4621         scales = s   # Renamed for readability below.
4622 
4623         # load default marker from rcParams
4624         if marker is None:
4625             marker = mpl.rcParams['scatter.marker']
4626 
4627         if isinstance(marker, mmarkers.MarkerStyle):
4628             marker_obj = marker
4629         else:
4630             marker_obj = mmarkers.MarkerStyle(marker)
4631 
4632         path = marker_obj.get_path().transformed(
4633             marker_obj.get_transform())
4634         if not marker_obj.is_filled():
4635             if orig_edgecolor is not None:
4636                 _api.warn_external(
4637                     f"You passed a edgecolor/edgecolors ({orig_edgecolor!r}) "
4638                     f"for an unfilled marker ({marker!r}).  Matplotlib is "
4639                     "ignoring the edgecolor in favor of the facecolor.  This "
4640                     "behavior may change in the future."
4641                 )
4642             # We need to handle markers that can not be filled (like
4643             # '+' and 'x') differently than markers that can be
4644             # filled, but have their fillstyle set to 'none'.  This is
4645             # to get:
4646             #
4647             #  - respecting the fillestyle if set
4648             #  - maintaining back-compatibility for querying the facecolor of
4649             #    the un-fillable markers.
4650             #
4651             # While not an ideal situation, but is better than the
4652             # alternatives.
4653             if marker_obj.get_fillstyle() == 'none':
4654                 # promote the facecolor to be the edgecolor
4655                 edgecolors = colors
4656                 # set the facecolor to 'none' (at the last chance) because
4657                 # we can not fill a path if the facecolor is non-null
4658                 # (which is defendable at the renderer level).
4659                 colors = 'none'
4660             else:
4661                 # if we are not nulling the face color we can do this
4662                 # simpler
4663                 edgecolors = 'face'
4664 
4665             if linewidths is None:
4666                 linewidths = mpl.rcParams['lines.linewidth']
4667             elif np.iterable(linewidths):
4668                 linewidths = [
4669                     lw if lw is not None else mpl.rcParams['lines.linewidth']
4670                     for lw in linewidths]
4671 
4672         offsets = np.ma.column_stack([x, y])
4673 
4674         collection = mcoll.PathCollection(
4675             (path,), scales,
4676             facecolors=colors,
4677             edgecolors=edgecolors,
4678             linewidths=linewidths,
4679             offsets=offsets,
4680             offset_transform=kwargs.pop('transform', self.transData),
4681             alpha=alpha,
4682         )
4683         collection.set_transform(mtransforms.IdentityTransform())
4684         if colors is None:
4685             collection.set_array(c)
4686             collection.set_cmap(cmap)
4687             collection.set_norm(norm)
4688             collection._scale_norm(norm, vmin, vmax)
4689         else:
4690             extra_kwargs = {
4691                     'cmap': cmap, 'norm': norm, 'vmin': vmin, 'vmax': vmax
4692                     }
4693             extra_keys = [k for k, v in extra_kwargs.items() if v is not None]
4694             if any(extra_keys):
4695                 keys_str = ", ".join(f"'{k}'" for k in extra_keys)
4696                 _api.warn_external(
4697                     "No data for colormapping provided via 'c'. "
4698                     f"Parameters {keys_str} will be ignored")
4699         collection._internal_update(kwargs)
4700 
4701         # Classic mode only:
4702         # ensure there are margins to allow for the
4703         # finite size of the symbols.  In v2.x, margins
4704         # are present by default, so we disable this
4705         # scatter-specific override.
4706         if mpl.rcParams['_internal.classic_mode']:
4707             if self._xmargin < 0.05 and x.size > 0:
4708                 self.set_xmargin(0.05)
4709             if self._ymargin < 0.05 and x.size > 0:
4710                 self.set_ymargin(0.05)
4711 
4712         self.add_collection(collection)
4713         self._request_autoscale_view()
4714 
4715         return collection
4716 
4717     @_preprocess_data(replace_names=["x", "y", "C"], label_namer="y")
4718     @_docstring.dedent_interpd
4719     def hexbin(self, x, y, C=None, gridsize=100, bins=None,
4720                xscale='linear', yscale='linear', extent=None,
4721                cmap=None, norm=None, vmin=None, vmax=None,
4722                alpha=None, linewidths=None, edgecolors='face',
4723                reduce_C_function=np.mean, mincnt=None, marginals=False,
4724                **kwargs):
4725         """
4726         Make a 2D hexagonal binning plot of points *x*, *y*.
4727 
4728         If *C* is *None*, the value of the hexagon is determined by the number
4729         of points in the hexagon. Otherwise, *C* specifies values at the
4730         coordinate (x[i], y[i]). For each hexagon, these values are reduced
4731         using *reduce_C_function*.
4732 
4733         Parameters
4734         ----------
4735         x, y : array-like
4736             The data positions. *x* and *y* must be of the same length.
4737 
4738         C : array-like, optional
4739             If given, these values are accumulated in the bins. Otherwise,
4740             every point has a value of 1. Must be of the same length as *x*
4741             and *y*.
4742 
4743         gridsize : int or (int, int), default: 100
4744             If a single int, the number of hexagons in the *x*-direction.
4745             The number of hexagons in the *y*-direction is chosen such that
4746             the hexagons are approximately regular.
4747 
4748             Alternatively, if a tuple (*nx*, *ny*), the number of hexagons
4749             in the *x*-direction and the *y*-direction. In the
4750             *y*-direction, counting is done along vertically aligned
4751             hexagons, not along the zig-zag chains of hexagons; see the
4752             following illustration.
4753 
4754             .. plot::
4755 
4756                import numpy
4757                import matplotlib.pyplot as plt
4758 
4759                np.random.seed(19680801)
4760                n= 300
4761                x = np.random.standard_normal(n)
4762                y = np.random.standard_normal(n)
4763 
4764                fig, ax = plt.subplots(figsize=(4, 4))
4765                h = ax.hexbin(x, y, gridsize=(5, 3))
4766                hx, hy = h.get_offsets().T
4767                ax.plot(hx[24::3], hy[24::3], 'ro-')
4768                ax.plot(hx[-3:], hy[-3:], 'ro-')
4769                ax.set_title('gridsize=(5, 3)')
4770                ax.axis('off')
4771 
4772             To get approximately regular hexagons, choose
4773             :math:`n_x = \\sqrt{3}\\,n_y`.
4774 
4775         bins : 'log' or int or sequence, default: None
4776             Discretization of the hexagon values.
4777 
4778             - If *None*, no binning is applied; the color of each hexagon
4779               directly corresponds to its count value.
4780             - If 'log', use a logarithmic scale for the colormap.
4781               Internally, :math:`log_{10}(i+1)` is used to determine the
4782               hexagon color. This is equivalent to ``norm=LogNorm()``.
4783             - If an integer, divide the counts in the specified number
4784               of bins, and color the hexagons accordingly.
4785             - If a sequence of values, the values of the lower bound of
4786               the bins to be used.
4787 
4788         xscale : {'linear', 'log'}, default: 'linear'
4789             Use a linear or log10 scale on the horizontal axis.
4790 
4791         yscale : {'linear', 'log'}, default: 'linear'
4792             Use a linear or log10 scale on the vertical axis.
4793 
4794         mincnt : int > 0, default: *None*
4795             If not *None*, only display cells with more than *mincnt*
4796             number of points in the cell.
4797 
4798         marginals : bool, default: *False*
4799             If marginals is *True*, plot the marginal density as
4800             colormapped rectangles along the bottom of the x-axis and
4801             left of the y-axis.
4802 
4803         extent : 4-tuple of float, default: *None*
4804             The limits of the bins (xmin, xmax, ymin, ymax).
4805             The default assigns the limits based on
4806             *gridsize*, *x*, *y*, *xscale* and *yscale*.
4807 
4808             If *xscale* or *yscale* is set to 'log', the limits are
4809             expected to be the exponent for a power of 10. E.g. for
4810             x-limits of 1 and 50 in 'linear' scale and y-limits
4811             of 10 and 1000 in 'log' scale, enter (1, 50, 1, 3).
4812 
4813         Returns
4814         -------
4815         `~matplotlib.collections.PolyCollection`
4816             A `.PolyCollection` defining the hexagonal bins.
4817 
4818             - `.PolyCollection.get_offsets` contains a Mx2 array containing
4819               the x, y positions of the M hexagon centers.
4820             - `.PolyCollection.get_array` contains the values of the M
4821               hexagons.
4822 
4823             If *marginals* is *True*, horizontal
4824             bar and vertical bar (both PolyCollections) will be attached
4825             to the return collection as attributes *hbar* and *vbar*.
4826 
4827         Other Parameters
4828         ----------------
4829         %(cmap_doc)s
4830 
4831         %(norm_doc)s
4832 
4833         %(vmin_vmax_doc)s
4834 
4835         alpha : float between 0 and 1, optional
4836             The alpha blending value, between 0 (transparent) and 1 (opaque).
4837 
4838         linewidths : float, default: *None*
4839             If *None*, defaults to 1.0.
4840 
4841         edgecolors : {'face', 'none', *None*} or color, default: 'face'
4842             The color of the hexagon edges. Possible values are:
4843 
4844             - 'face': Draw the edges in the same color as the fill color.
4845             - 'none': No edges are drawn. This can sometimes lead to unsightly
4846               unpainted pixels between the hexagons.
4847             - *None*: Draw outlines in the default color.
4848             - An explicit color.
4849 
4850         reduce_C_function : callable, default: `numpy.mean`
4851             The function to aggregate *C* within the bins. It is ignored if
4852             *C* is not given. This must have the signature::
4853 
4854                 def reduce_C_function(C: array) -> float
4855 
4856             Commonly used functions are:
4857 
4858             - `numpy.mean`: average of the points
4859             - `numpy.sum`: integral of the point values
4860             - `numpy.amax`: value taken from the largest point
4861 
4862         data : indexable object, optional
4863             DATA_PARAMETER_PLACEHOLDER
4864 
4865         **kwargs : `~matplotlib.collections.PolyCollection` properties
4866             All other keyword arguments are passed on to `.PolyCollection`:
4867 
4868             %(PolyCollection:kwdoc)s
4869 
4870         See Also
4871         --------
4872         hist2d : 2D histogram rectangular bins
4873         """
4874         self._process_unit_info([("x", x), ("y", y)], kwargs, convert=False)
4875 
4876         x, y, C = cbook.delete_masked_points(x, y, C)
4877 
4878         # Set the size of the hexagon grid
4879         if np.iterable(gridsize):
4880             nx, ny = gridsize
4881         else:
4882             nx = gridsize
4883             ny = int(nx / math.sqrt(3))
4884         # Count the number of data in each hexagon
4885         x = np.asarray(x, float)
4886         y = np.asarray(y, float)
4887 
4888         # Will be log()'d if necessary, and then rescaled.
4889         tx = x
4890         ty = y
4891 
4892         if xscale == 'log':
4893             if np.any(x <= 0.0):
4894                 raise ValueError("x contains non-positive values, so can not "
4895                                  "be log-scaled")
4896             tx = np.log10(tx)
4897         if yscale == 'log':
4898             if np.any(y <= 0.0):
4899                 raise ValueError("y contains non-positive values, so can not "
4900                                  "be log-scaled")
4901             ty = np.log10(ty)
4902         if extent is not None:
4903             xmin, xmax, ymin, ymax = extent
4904         else:
4905             xmin, xmax = (tx.min(), tx.max()) if len(x) else (0, 1)
4906             ymin, ymax = (ty.min(), ty.max()) if len(y) else (0, 1)
4907 
4908             # to avoid issues with singular data, expand the min/max pairs
4909             xmin, xmax = mtransforms.nonsingular(xmin, xmax, expander=0.1)
4910             ymin, ymax = mtransforms.nonsingular(ymin, ymax, expander=0.1)
4911 
4912         nx1 = nx + 1
4913         ny1 = ny + 1
4914         nx2 = nx
4915         ny2 = ny
4916         n = nx1 * ny1 + nx2 * ny2
4917 
4918         # In the x-direction, the hexagons exactly cover the region from
4919         # xmin to xmax. Need some padding to avoid roundoff errors.
4920         padding = 1.e-9 * (xmax - xmin)
4921         xmin -= padding
4922         xmax += padding
4923         sx = (xmax - xmin) / nx
4924         sy = (ymax - ymin) / ny
4925         # Positions in hexagon index coordinates.
4926         ix = (tx - xmin) / sx
4927         iy = (ty - ymin) / sy
4928         ix1 = np.round(ix).astype(int)
4929         iy1 = np.round(iy).astype(int)
4930         ix2 = np.floor(ix).astype(int)
4931         iy2 = np.floor(iy).astype(int)
4932         # flat indices, plus one so that out-of-range points go to position 0.
4933         i1 = np.where((0 <= ix1) & (ix1 < nx1) & (0 <= iy1) & (iy1 < ny1),
4934                       ix1 * ny1 + iy1 + 1, 0)
4935         i2 = np.where((0 <= ix2) & (ix2 < nx2) & (0 <= iy2) & (iy2 < ny2),
4936                       ix2 * ny2 + iy2 + 1, 0)
4937 
4938         d1 = (ix - ix1) ** 2 + 3.0 * (iy - iy1) ** 2
4939         d2 = (ix - ix2 - 0.5) ** 2 + 3.0 * (iy - iy2 - 0.5) ** 2
4940         bdist = (d1 < d2)
4941 
4942         if C is None:  # [1:] drops out-of-range points.
4943             counts1 = np.bincount(i1[bdist], minlength=1 + nx1 * ny1)[1:]
4944             counts2 = np.bincount(i2[~bdist], minlength=1 + nx2 * ny2)[1:]
4945             accum = np.concatenate([counts1, counts2]).astype(float)
4946             if mincnt is not None:
4947                 accum[accum < mincnt] = np.nan
4948             C = np.ones(len(x))
4949         else:
4950             # store the C values in a list per hexagon index
4951             Cs_at_i1 = [[] for _ in range(1 + nx1 * ny1)]
4952             Cs_at_i2 = [[] for _ in range(1 + nx2 * ny2)]
4953             for i in range(len(x)):
4954                 if bdist[i]:
4955                     Cs_at_i1[i1[i]].append(C[i])
4956                 else:
4957                     Cs_at_i2[i2[i]].append(C[i])
4958             if mincnt is None:
4959                 mincnt = 0
4960             accum = np.array(
4961                 [reduce_C_function(acc) if len(acc) > mincnt else np.nan
4962                  for Cs_at_i in [Cs_at_i1, Cs_at_i2]
4963                  for acc in Cs_at_i[1:]],  # [1:] drops out-of-range points.
4964                 float)
4965 
4966         good_idxs = ~np.isnan(accum)
4967 
4968         offsets = np.zeros((n, 2), float)
4969         offsets[:nx1 * ny1, 0] = np.repeat(np.arange(nx1), ny1)
4970         offsets[:nx1 * ny1, 1] = np.tile(np.arange(ny1), nx1)
4971         offsets[nx1 * ny1:, 0] = np.repeat(np.arange(nx2) + 0.5, ny2)
4972         offsets[nx1 * ny1:, 1] = np.tile(np.arange(ny2), nx2) + 0.5
4973         offsets[:, 0] *= sx
4974         offsets[:, 1] *= sy
4975         offsets[:, 0] += xmin
4976         offsets[:, 1] += ymin
4977         # remove accumulation bins with no data
4978         offsets = offsets[good_idxs, :]
4979         accum = accum[good_idxs]
4980 
4981         polygon = [sx, sy / 3] * np.array(
4982             [[.5, -.5], [.5, .5], [0., 1.], [-.5, .5], [-.5, -.5], [0., -1.]])
4983 
4984         if linewidths is None:
4985             linewidths = [1.0]
4986 
4987         if xscale == 'log' or yscale == 'log':
4988             polygons = np.expand_dims(polygon, 0) + np.expand_dims(offsets, 1)
4989             if xscale == 'log':
4990                 polygons[:, :, 0] = 10.0 ** polygons[:, :, 0]
4991                 xmin = 10.0 ** xmin
4992                 xmax = 10.0 ** xmax
4993                 self.set_xscale(xscale)
4994             if yscale == 'log':
4995                 polygons[:, :, 1] = 10.0 ** polygons[:, :, 1]
4996                 ymin = 10.0 ** ymin
4997                 ymax = 10.0 ** ymax
4998                 self.set_yscale(yscale)
4999             collection = mcoll.PolyCollection(
5000                 polygons,
5001                 edgecolors=edgecolors,
5002                 linewidths=linewidths,
5003                 )
5004         else:
5005             collection = mcoll.PolyCollection(
5006                 [polygon],
5007                 edgecolors=edgecolors,
5008                 linewidths=linewidths,
5009                 offsets=offsets,
5010                 offset_transform=mtransforms.AffineDeltaTransform(
5011                     self.transData),
5012             )
5013 
5014         # Set normalizer if bins is 'log'
5015         if bins == 'log':
5016             if norm is not None:
5017                 _api.warn_external("Only one of 'bins' and 'norm' arguments "
5018                                    f"can be supplied, ignoring bins={bins}")
5019             else:
5020                 norm = mcolors.LogNorm(vmin=vmin, vmax=vmax)
5021                 vmin = vmax = None
5022             bins = None
5023 
5024         # autoscale the norm with current accum values if it hasn't been set
5025         if norm is not None:
5026             if norm.vmin is None and norm.vmax is None:
5027                 norm.autoscale(accum)
5028 
5029         if bins is not None:
5030             if not np.iterable(bins):
5031                 minimum, maximum = min(accum), max(accum)
5032                 bins -= 1  # one less edge than bins
5033                 bins = minimum + (maximum - minimum) * np.arange(bins) / bins
5034             bins = np.sort(bins)
5035             accum = bins.searchsorted(accum)
5036 
5037         collection.set_array(accum)
5038         collection.set_cmap(cmap)
5039         collection.set_norm(norm)
5040         collection.set_alpha(alpha)
5041         collection._internal_update(kwargs)
5042         collection._scale_norm(norm, vmin, vmax)
5043 
5044         corners = ((xmin, ymin), (xmax, ymax))
5045         self.update_datalim(corners)
5046         self._request_autoscale_view(tight=True)
5047 
5048         # add the collection last
5049         self.add_collection(collection, autolim=False)
5050         if not marginals:
5051             return collection
5052 
5053         # Process marginals
5054         bars = []
5055         for zname, z, zmin, zmax, zscale, nbins in [
5056                 ("x", x, xmin, xmax, xscale, nx),
5057                 ("y", y, ymin, ymax, yscale, 2 * ny),
5058         ]:
5059 
5060             if zscale == "log":
5061                 bin_edges = np.geomspace(zmin, zmax, nbins + 1)
5062             else:
5063                 bin_edges = np.linspace(zmin, zmax, nbins + 1)
5064 
5065             verts = np.empty((nbins, 4, 2))
5066             verts[:, 0, 0] = verts[:, 1, 0] = bin_edges[:-1]
5067             verts[:, 2, 0] = verts[:, 3, 0] = bin_edges[1:]
5068             verts[:, 0, 1] = verts[:, 3, 1] = .00
5069             verts[:, 1, 1] = verts[:, 2, 1] = .05
5070             if zname == "y":
5071                 verts = verts[:, :, ::-1]  # Swap x and y.
5072 
5073             # Sort z-values into bins defined by bin_edges.
5074             bin_idxs = np.searchsorted(bin_edges, z) - 1
5075             values = np.empty(nbins)
5076             for i in range(nbins):
5077                 # Get C-values for each bin, and compute bin value with
5078                 # reduce_C_function.
5079                 ci = C[bin_idxs == i]
5080                 values[i] = reduce_C_function(ci) if len(ci) > 0 else np.nan
5081 
5082             mask = ~np.isnan(values)
5083             verts = verts[mask]
5084             values = values[mask]
5085 
5086             trans = getattr(self, f"get_{zname}axis_transform")(which="grid")
5087             bar = mcoll.PolyCollection(
5088                 verts, transform=trans, edgecolors="face")
5089             bar.set_array(values)
5090             bar.set_cmap(cmap)
5091             bar.set_norm(norm)
5092             bar.set_alpha(alpha)
5093             bar._internal_update(kwargs)
5094             bars.append(self.add_collection(bar, autolim=False))
5095 
5096         collection.hbar, collection.vbar = bars
5097 
5098         def on_changed(collection):
5099             collection.hbar.set_cmap(collection.get_cmap())
5100             collection.hbar.set_cmap(collection.get_cmap())
5101             collection.vbar.set_clim(collection.get_clim())
5102             collection.vbar.set_clim(collection.get_clim())
5103 
5104         collection.callbacks.connect('changed', on_changed)
5105 
5106         return collection
5107 
5108     @_docstring.dedent_interpd
5109     def arrow(self, x, y, dx, dy, **kwargs):
5110         """
5111         Add an arrow to the Axes.
5112 
5113         This draws an arrow from ``(x, y)`` to ``(x+dx, y+dy)``.
5114 
5115         Parameters
5116         ----------
5117         %(FancyArrow)s
5118 
5119         Returns
5120         -------
5121         `.FancyArrow`
5122             The created `.FancyArrow` object.
5123 
5124         Notes
5125         -----
5126         The resulting arrow is affected by the Axes aspect ratio and limits.
5127         This may produce an arrow whose head is not square with its stem. To
5128         create an arrow whose head is square with its stem,
5129         use :meth:`annotate` for example:
5130 
5131         >>> ax.annotate("", xy=(0.5, 0.5), xytext=(0, 0),
5132         ...             arrowprops=dict(arrowstyle="->"))
5133 
5134         """
5135         # Strip away units for the underlying patch since units
5136         # do not make sense to most patch-like code
5137         x = self.convert_xunits(x)
5138         y = self.convert_yunits(y)
5139         dx = self.convert_xunits(dx)
5140         dy = self.convert_yunits(dy)
5141 
5142         a = mpatches.FancyArrow(x, y, dx, dy, **kwargs)
5143         self.add_patch(a)
5144         self._request_autoscale_view()
5145         return a
5146 
5147     @_docstring.copy(mquiver.QuiverKey.__init__)
5148     def quiverkey(self, Q, X, Y, U, label, **kwargs):
5149         qk = mquiver.QuiverKey(Q, X, Y, U, label, **kwargs)
5150         self.add_artist(qk)
5151         return qk
5152 
5153     # Handle units for x and y, if they've been passed
5154     def _quiver_units(self, args, kwargs):
5155         if len(args) > 3:
5156             x, y = args[0:2]
5157             x, y = self._process_unit_info([("x", x), ("y", y)], kwargs)
5158             return (x, y) + args[2:]
5159         return args
5160 
5161     # args can be a combination of X, Y, U, V, C and all should be replaced
5162     @_preprocess_data()
5163     @_docstring.dedent_interpd
5164     def quiver(self, *args, **kwargs):
5165         """%(quiver_doc)s"""
5166         # Make sure units are handled for x and y values
5167         args = self._quiver_units(args, kwargs)
5168         q = mquiver.Quiver(self, *args, **kwargs)
5169         self.add_collection(q, autolim=True)
5170         self._request_autoscale_view()
5171         return q
5172 
5173     # args can be some combination of X, Y, U, V, C and all should be replaced
5174     @_preprocess_data()
5175     @_docstring.dedent_interpd
5176     def barbs(self, *args, **kwargs):
5177         """%(barbs_doc)s"""
5178         # Make sure units are handled for x and y values
5179         args = self._quiver_units(args, kwargs)
5180         b = mquiver.Barbs(self, *args, **kwargs)
5181         self.add_collection(b, autolim=True)
5182         self._request_autoscale_view()
5183         return b
5184 
5185     # Uses a custom implementation of data-kwarg handling in
5186     # _process_plot_var_args.
5187     def fill(self, *args, data=None, **kwargs):
5188         """
5189         Plot filled polygons.
5190 
5191         Parameters
5192         ----------
5193         *args : sequence of x, y, [color]
5194             Each polygon is defined by the lists of *x* and *y* positions of
5195             its nodes, optionally followed by a *color* specifier. See
5196             :mod:`matplotlib.colors` for supported color specifiers. The
5197             standard color cycle is used for polygons without a color
5198             specifier.
5199 
5200             You can plot multiple polygons by providing multiple *x*, *y*,
5201             *[color]* groups.
5202 
5203             For example, each of the following is legal::
5204 
5205                 ax.fill(x, y)                    # a polygon with default color
5206                 ax.fill(x, y, "b")               # a blue polygon
5207                 ax.fill(x, y, x2, y2)            # two polygons
5208                 ax.fill(x, y, "b", x2, y2, "r")  # a blue and a red polygon
5209 
5210         data : indexable object, optional
5211             An object with labelled data. If given, provide the label names to
5212             plot in *x* and *y*, e.g.::
5213 
5214                 ax.fill("time", "signal",
5215                         data={"time": [0, 1, 2], "signal": [0, 1, 0]})
5216 
5217         Returns
5218         -------
5219         list of `~matplotlib.patches.Polygon`
5220 
5221         Other Parameters
5222         ----------------
5223         **kwargs : `~matplotlib.patches.Polygon` properties
5224 
5225         Notes
5226         -----
5227         Use :meth:`fill_between` if you would like to fill the region between
5228         two curves.
5229         """
5230         # For compatibility(!), get aliases from Line2D rather than Patch.
5231         kwargs = cbook.normalize_kwargs(kwargs, mlines.Line2D)
5232         # _get_patches_for_fill returns a generator, convert it to a list.
5233         patches = [*self._get_patches_for_fill(*args, data=data, **kwargs)]
5234         for poly in patches:
5235             self.add_patch(poly)
5236         self._request_autoscale_view()
5237         return patches
5238 
5239     def _fill_between_x_or_y(
5240             self, ind_dir, ind, dep1, dep2=0, *,
5241             where=None, interpolate=False, step=None, **kwargs):
5242         # Common implementation between fill_between (*ind_dir*="x") and
5243         # fill_betweenx (*ind_dir*="y").  *ind* is the independent variable,
5244         # *dep* the dependent variable.  The docstring below is interpolated
5245         # to generate both methods' docstrings.
5246         """
5247         Fill the area between two {dir} curves.
5248 
5249         The curves are defined by the points (*{ind}*, *{dep}1*) and (*{ind}*,
5250         *{dep}2*).  This creates one or multiple polygons describing the filled
5251         area.
5252 
5253         You may exclude some {dir} sections from filling using *where*.
5254 
5255         By default, the edges connect the given points directly.  Use *step*
5256         if the filling should be a step function, i.e. constant in between
5257         *{ind}*.
5258 
5259         Parameters
5260         ----------
5261         {ind} : array (length N)
5262             The {ind} coordinates of the nodes defining the curves.
5263 
5264         {dep}1 : array (length N) or scalar
5265             The {dep} coordinates of the nodes defining the first curve.
5266 
5267         {dep}2 : array (length N) or scalar, default: 0
5268             The {dep} coordinates of the nodes defining the second curve.
5269 
5270         where : array of bool (length N), optional
5271             Define *where* to exclude some {dir} regions from being filled.
5272             The filled regions are defined by the coordinates ``{ind}[where]``.
5273             More precisely, fill between ``{ind}[i]`` and ``{ind}[i+1]`` if
5274             ``where[i] and where[i+1]``.  Note that this definition implies
5275             that an isolated *True* value between two *False* values in *where*
5276             will not result in filling.  Both sides of the *True* position
5277             remain unfilled due to the adjacent *False* values.
5278 
5279         interpolate : bool, default: False
5280             This option is only relevant if *where* is used and the two curves
5281             are crossing each other.
5282 
5283             Semantically, *where* is often used for *{dep}1* > *{dep}2* or
5284             similar.  By default, the nodes of the polygon defining the filled
5285             region will only be placed at the positions in the *{ind}* array.
5286             Such a polygon cannot describe the above semantics close to the
5287             intersection.  The {ind}-sections containing the intersection are
5288             simply clipped.
5289 
5290             Setting *interpolate* to *True* will calculate the actual
5291             intersection point and extend the filled region up to this point.
5292 
5293         step : {{'pre', 'post', 'mid'}}, optional
5294             Define *step* if the filling should be a step function,
5295             i.e. constant in between *{ind}*.  The value determines where the
5296             step will occur:
5297 
5298             - 'pre': The y value is continued constantly to the left from
5299               every *x* position, i.e. the interval ``(x[i-1], x[i]]`` has the
5300               value ``y[i]``.
5301             - 'post': The y value is continued constantly to the right from
5302               every *x* position, i.e. the interval ``[x[i], x[i+1])`` has the
5303               value ``y[i]``.
5304             - 'mid': Steps occur half-way between the *x* positions.
5305 
5306         Returns
5307         -------
5308         `.PolyCollection`
5309             A `.PolyCollection` containing the plotted polygons.
5310 
5311         Other Parameters
5312         ----------------
5313         data : indexable object, optional
5314             DATA_PARAMETER_PLACEHOLDER
5315 
5316         **kwargs
5317             All other keyword arguments are passed on to `.PolyCollection`.
5318             They control the `.Polygon` properties:
5319 
5320             %(PolyCollection:kwdoc)s
5321 
5322         See Also
5323         --------
5324         fill_between : Fill between two sets of y-values.
5325         fill_betweenx : Fill between two sets of x-values.
5326         """
5327 
5328         dep_dir = {"x": "y", "y": "x"}[ind_dir]
5329 
5330         if not mpl.rcParams["_internal.classic_mode"]:
5331             kwargs = cbook.normalize_kwargs(kwargs, mcoll.Collection)
5332             if not any(c in kwargs for c in ("color", "facecolor")):
5333                 kwargs["facecolor"] = \
5334                     self._get_patches_for_fill.get_next_color()
5335 
5336         # Handle united data, such as dates
5337         ind, dep1, dep2 = map(
5338             ma.masked_invalid, self._process_unit_info(
5339                 [(ind_dir, ind), (dep_dir, dep1), (dep_dir, dep2)], kwargs))
5340 
5341         for name, array in [
5342                 (ind_dir, ind), (f"{dep_dir}1", dep1), (f"{dep_dir}2", dep2)]:
5343             if array.ndim > 1:
5344                 raise ValueError(f"{name!r} is not 1-dimensional")
5345 
5346         if where is None:
5347             where = True
5348         else:
5349             where = np.asarray(where, dtype=bool)
5350             if where.size != ind.size:
5351                 raise ValueError(f"where size ({where.size}) does not match "
5352                                  f"{ind_dir} size ({ind.size})")
5353         where = where & ~functools.reduce(
5354             np.logical_or, map(np.ma.getmaskarray, [ind, dep1, dep2]))
5355 
5356         ind, dep1, dep2 = np.broadcast_arrays(
5357             np.atleast_1d(ind), dep1, dep2, subok=True)
5358 
5359         polys = []
5360         for idx0, idx1 in cbook.contiguous_regions(where):
5361             indslice = ind[idx0:idx1]
5362             dep1slice = dep1[idx0:idx1]
5363             dep2slice = dep2[idx0:idx1]
5364             if step is not None:
5365                 step_func = cbook.STEP_LOOKUP_MAP["steps-" + step]
5366                 indslice, dep1slice, dep2slice = \
5367                     step_func(indslice, dep1slice, dep2slice)
5368 
5369             if not len(indslice):
5370                 continue
5371 
5372             N = len(indslice)
5373             pts = np.zeros((2 * N + 2, 2))
5374 
5375             if interpolate:
5376                 def get_interp_point(idx):
5377                     im1 = max(idx - 1, 0)
5378                     ind_values = ind[im1:idx+1]
5379                     diff_values = dep1[im1:idx+1] - dep2[im1:idx+1]
5380                     dep1_values = dep1[im1:idx+1]
5381 
5382                     if len(diff_values) == 2:
5383                         if np.ma.is_masked(diff_values[1]):
5384                             return ind[im1], dep1[im1]
5385                         elif np.ma.is_masked(diff_values[0]):
5386                             return ind[idx], dep1[idx]
5387 
5388                     diff_order = diff_values.argsort()
5389                     diff_root_ind = np.interp(
5390                         0, diff_values[diff_order], ind_values[diff_order])
5391                     ind_order = ind_values.argsort()
5392                     diff_root_dep = np.interp(
5393                         diff_root_ind,
5394                         ind_values[ind_order], dep1_values[ind_order])
5395                     return diff_root_ind, diff_root_dep
5396 
5397                 start = get_interp_point(idx0)
5398                 end = get_interp_point(idx1)
5399             else:
5400                 # Handle scalar dep2 (e.g. 0): the fill should go all
5401                 # the way down to 0 even if none of the dep1 sample points do.
5402                 start = indslice[0], dep2slice[0]
5403                 end = indslice[-1], dep2slice[-1]
5404 
5405             pts[0] = start
5406             pts[N + 1] = end
5407 
5408             pts[1:N+1, 0] = indslice
5409             pts[1:N+1, 1] = dep1slice
5410             pts[N+2:, 0] = indslice[::-1]
5411             pts[N+2:, 1] = dep2slice[::-1]
5412 
5413             if ind_dir == "y":
5414                 pts = pts[:, ::-1]
5415 
5416             polys.append(pts)
5417 
5418         collection = mcoll.PolyCollection(polys, **kwargs)
5419 
5420         # now update the datalim and autoscale
5421         pts = np.row_stack([np.column_stack([ind[where], dep1[where]]),
5422                             np.column_stack([ind[where], dep2[where]])])
5423         if ind_dir == "y":
5424             pts = pts[:, ::-1]
5425         self.update_datalim(pts, updatex=True, updatey=True)
5426         self.add_collection(collection, autolim=False)
5427         self._request_autoscale_view()
5428         return collection
5429 
5430     def fill_between(self, x, y1, y2=0, where=None, interpolate=False,
5431                      step=None, **kwargs):
5432         return self._fill_between_x_or_y(
5433             "x", x, y1, y2,
5434             where=where, interpolate=interpolate, step=step, **kwargs)
5435 
5436     if _fill_between_x_or_y.__doc__:
5437         fill_between.__doc__ = _fill_between_x_or_y.__doc__.format(
5438             dir="horizontal", ind="x", dep="y"
5439         )
5440     fill_between = _preprocess_data(
5441         _docstring.dedent_interpd(fill_between),
5442         replace_names=["x", "y1", "y2", "where"])
5443 
5444     def fill_betweenx(self, y, x1, x2=0, where=None,
5445                       step=None, interpolate=False, **kwargs):
5446         return self._fill_between_x_or_y(
5447             "y", y, x1, x2,
5448             where=where, interpolate=interpolate, step=step, **kwargs)
5449 
5450     if _fill_between_x_or_y.__doc__:
5451         fill_betweenx.__doc__ = _fill_between_x_or_y.__doc__.format(
5452             dir="vertical", ind="y", dep="x"
5453         )
5454     fill_betweenx = _preprocess_data(
5455         _docstring.dedent_interpd(fill_betweenx),
5456         replace_names=["y", "x1", "x2", "where"])
5457 
5458     #### plotting z(x, y): imshow, pcolor and relatives, contour
5459 
5460     @_preprocess_data()
5461     @_docstring.interpd
5462     def imshow(self, X, cmap=None, norm=None, *, aspect=None,
5463                interpolation=None, alpha=None,
5464                vmin=None, vmax=None, origin=None, extent=None,
5465                interpolation_stage=None, filternorm=True, filterrad=4.0,
5466                resample=None, url=None, **kwargs):
5467         """
5468         Display data as an image, i.e., on a 2D regular raster.
5469 
5470         The input may either be actual RGB(A) data, or 2D scalar data, which
5471         will be rendered as a pseudocolor image. For displaying a grayscale
5472         image set up the colormapping using the parameters
5473         ``cmap='gray', vmin=0, vmax=255``.
5474 
5475         The number of pixels used to render an image is set by the Axes size
5476         and the *dpi* of the figure. This can lead to aliasing artifacts when
5477         the image is resampled because the displayed image size will usually
5478         not match the size of *X* (see
5479         :doc:`/gallery/images_contours_and_fields/image_antialiasing`).
5480         The resampling can be controlled via the *interpolation* parameter
5481         and/or :rc:`image.interpolation`.
5482 
5483         Parameters
5484         ----------
5485         X : array-like or PIL image
5486             The image data. Supported array shapes are:
5487 
5488             - (M, N): an image with scalar data. The values are mapped to
5489               colors using normalization and a colormap. See parameters *norm*,
5490               *cmap*, *vmin*, *vmax*.
5491             - (M, N, 3): an image with RGB values (0-1 float or 0-255 int).
5492             - (M, N, 4): an image with RGBA values (0-1 float or 0-255 int),
5493               i.e. including transparency.
5494 
5495             The first two dimensions (M, N) define the rows and columns of
5496             the image.
5497 
5498             Out-of-range RGB(A) values are clipped.
5499 
5500         %(cmap_doc)s
5501 
5502             This parameter is ignored if *X* is RGB(A).
5503 
5504         %(norm_doc)s
5505 
5506             This parameter is ignored if *X* is RGB(A).
5507 
5508         %(vmin_vmax_doc)s
5509 
5510             This parameter is ignored if *X* is RGB(A).
5511 
5512         aspect : {'equal', 'auto'} or float, default: :rc:`image.aspect`
5513             The aspect ratio of the Axes.  This parameter is particularly
5514             relevant for images since it determines whether data pixels are
5515             square.
5516 
5517             This parameter is a shortcut for explicitly calling
5518             `.Axes.set_aspect`. See there for further details.
5519 
5520             - 'equal': Ensures an aspect ratio of 1. Pixels will be square
5521               (unless pixel sizes are explicitly made non-square in data
5522               coordinates using *extent*).
5523             - 'auto': The Axes is kept fixed and the aspect is adjusted so
5524               that the data fit in the Axes. In general, this will result in
5525               non-square pixels.
5526 
5527         interpolation : str, default: :rc:`image.interpolation`
5528             The interpolation method used.
5529 
5530             Supported values are 'none', 'antialiased', 'nearest', 'bilinear',
5531             'bicubic', 'spline16', 'spline36', 'hanning', 'hamming', 'hermite',
5532             'kaiser', 'quadric', 'catrom', 'gaussian', 'bessel', 'mitchell',
5533             'sinc', 'lanczos', 'blackman'.
5534 
5535             If *interpolation* is 'none', then no interpolation is performed
5536             on the Agg, ps, pdf and svg backends. Other backends will fall back
5537             to 'nearest'. Note that most SVG renderers perform interpolation at
5538             rendering and that the default interpolation method they implement
5539             may differ.
5540 
5541             If *interpolation* is the default 'antialiased', then 'nearest'
5542             interpolation is used if the image is upsampled by more than a
5543             factor of three (i.e. the number of display pixels is at least
5544             three times the size of the data array).  If the upsampling rate is
5545             smaller than 3, or the image is downsampled, then 'hanning'
5546             interpolation is used to act as an anti-aliasing filter, unless the
5547             image happens to be upsampled by exactly a factor of two or one.
5548 
5549             See
5550             :doc:`/gallery/images_contours_and_fields/interpolation_methods`
5551             for an overview of the supported interpolation methods, and
5552             :doc:`/gallery/images_contours_and_fields/image_antialiasing` for
5553             a discussion of image antialiasing.
5554 
5555             Some interpolation methods require an additional radius parameter,
5556             which can be set by *filterrad*. Additionally, the antigrain image
5557             resize filter is controlled by the parameter *filternorm*.
5558 
5559         interpolation_stage : {'data', 'rgba'}, default: 'data'
5560             If 'data', interpolation
5561             is carried out on the data provided by the user.  If 'rgba', the
5562             interpolation is carried out after the colormapping has been
5563             applied (visual interpolation).
5564 
5565         alpha : float or array-like, optional
5566             The alpha blending value, between 0 (transparent) and 1 (opaque).
5567             If *alpha* is an array, the alpha blending values are applied pixel
5568             by pixel, and *alpha* must have the same shape as *X*.
5569 
5570         origin : {'upper', 'lower'}, default: :rc:`image.origin`
5571             Place the [0, 0] index of the array in the upper left or lower
5572             left corner of the Axes. The convention (the default) 'upper' is
5573             typically used for matrices and images.
5574 
5575             Note that the vertical axis points upward for 'lower'
5576             but downward for 'upper'.
5577 
5578             See the :doc:`/tutorials/intermediate/imshow_extent` tutorial for
5579             examples and a more detailed description.
5580 
5581         extent : floats (left, right, bottom, top), optional
5582             The bounding box in data coordinates that the image will fill.
5583             These values may be unitful and match the units of the Axes.
5584             The image is stretched individually along x and y to fill the box.
5585 
5586             The default extent is determined by the following conditions.
5587             Pixels have unit size in data coordinates. Their centers are on
5588             integer coordinates, and their center coordinates range from 0 to
5589             columns-1 horizontally and from 0 to rows-1 vertically.
5590 
5591             Note that the direction of the vertical axis and thus the default
5592             values for top and bottom depend on *origin*:
5593 
5594             - For ``origin == 'upper'`` the default is
5595               ``(-0.5, numcols-0.5, numrows-0.5, -0.5)``.
5596             - For ``origin == 'lower'`` the default is
5597               ``(-0.5, numcols-0.5, -0.5, numrows-0.5)``.
5598 
5599             See the :doc:`/tutorials/intermediate/imshow_extent` tutorial for
5600             examples and a more detailed description.
5601 
5602         filternorm : bool, default: True
5603             A parameter for the antigrain image resize filter (see the
5604             antigrain documentation).  If *filternorm* is set, the filter
5605             normalizes integer values and corrects the rounding errors. It
5606             doesn't do anything with the source floating point values, it
5607             corrects only integers according to the rule of 1.0 which means
5608             that any sum of pixel weights must be equal to 1.0.  So, the
5609             filter function must produce a graph of the proper shape.
5610 
5611         filterrad : float > 0, default: 4.0
5612             The filter radius for filters that have a radius parameter, i.e.
5613             when interpolation is one of: 'sinc', 'lanczos' or 'blackman'.
5614 
5615         resample : bool, default: :rc:`image.resample`
5616             When *True*, use a full resampling method.  When *False*, only
5617             resample when the output image is larger than the input image.
5618 
5619         url : str, optional
5620             Set the url of the created `.AxesImage`. See `.Artist.set_url`.
5621 
5622         Returns
5623         -------
5624         `~matplotlib.image.AxesImage`
5625 
5626         Other Parameters
5627         ----------------
5628         data : indexable object, optional
5629             DATA_PARAMETER_PLACEHOLDER
5630 
5631         **kwargs : `~matplotlib.artist.Artist` properties
5632             These parameters are passed on to the constructor of the
5633             `.AxesImage` artist.
5634 
5635         See Also
5636         --------
5637         matshow : Plot a matrix or an array as an image.
5638 
5639         Notes
5640         -----
5641         Unless *extent* is used, pixel centers will be located at integer
5642         coordinates. In other words: the origin will coincide with the center
5643         of pixel (0, 0).
5644 
5645         There are two common representations for RGB images with an alpha
5646         channel:
5647 
5648         -   Straight (unassociated) alpha: R, G, and B channels represent the
5649             color of the pixel, disregarding its opacity.
5650         -   Premultiplied (associated) alpha: R, G, and B channels represent
5651             the color of the pixel, adjusted for its opacity by multiplication.
5652 
5653         `~matplotlib.pyplot.imshow` expects RGB images adopting the straight
5654         (unassociated) alpha representation.
5655         """
5656         if aspect is None:
5657             aspect = mpl.rcParams['image.aspect']
5658         self.set_aspect(aspect)
5659         im = mimage.AxesImage(self, cmap=cmap, norm=norm,
5660                               interpolation=interpolation, origin=origin,
5661                               extent=extent, filternorm=filternorm,
5662                               filterrad=filterrad, resample=resample,
5663                               interpolation_stage=interpolation_stage,
5664                               **kwargs)
5665 
5666         im.set_data(X)
5667         im.set_alpha(alpha)
5668         if im.get_clip_path() is None:
5669             # image does not already have clipping set, clip to axes patch
5670             im.set_clip_path(self.patch)
5671         im._scale_norm(norm, vmin, vmax)
5672         im.set_url(url)
5673 
5674         # update ax.dataLim, and, if autoscaling, set viewLim
5675         # to tightly fit the image, regardless of dataLim.
5676         im.set_extent(im.get_extent())
5677 
5678         self.add_image(im)
5679         return im
5680 
5681     def _pcolorargs(self, funcname, *args, shading='auto', **kwargs):
5682         # - create X and Y if not present;
5683         # - reshape X and Y as needed if they are 1-D;
5684         # - check for proper sizes based on `shading` kwarg;
5685         # - reset shading if shading='auto' to flat or nearest
5686         #   depending on size;
5687 
5688         _valid_shading = ['gouraud', 'nearest', 'flat', 'auto']
5689         try:
5690             _api.check_in_list(_valid_shading, shading=shading)
5691         except ValueError:
5692             _api.warn_external(f"shading value '{shading}' not in list of "
5693                                f"valid values {_valid_shading}. Setting "
5694                                "shading='auto'.")
5695             shading = 'auto'
5696 
5697         if len(args) == 1:
5698             C = np.asanyarray(args[0])
5699             nrows, ncols = C.shape[:2]
5700             if shading in ['gouraud', 'nearest']:
5701                 X, Y = np.meshgrid(np.arange(ncols), np.arange(nrows))
5702             else:
5703                 X, Y = np.meshgrid(np.arange(ncols + 1), np.arange(nrows + 1))
5704                 shading = 'flat'
5705             C = cbook.safe_masked_invalid(C)
5706             return X, Y, C, shading
5707 
5708         if len(args) == 3:
5709             # Check x and y for bad data...
5710             C = np.asanyarray(args[2])
5711             # unit conversion allows e.g. datetime objects as axis values
5712             X, Y = args[:2]
5713             X, Y = self._process_unit_info([("x", X), ("y", Y)], kwargs)
5714             X, Y = [cbook.safe_masked_invalid(a) for a in [X, Y]]
5715 
5716             if funcname == 'pcolormesh':
5717                 if np.ma.is_masked(X) or np.ma.is_masked(Y):
5718                     raise ValueError(
5719                         'x and y arguments to pcolormesh cannot have '
5720                         'non-finite values or be of type '
5721                         'numpy.ma.core.MaskedArray with masked values')
5722                 # safe_masked_invalid() returns an ndarray for dtypes other
5723                 # than floating point.
5724                 if isinstance(X, np.ma.core.MaskedArray):
5725                     X = X.data  # strip mask as downstream doesn't like it...
5726                 if isinstance(Y, np.ma.core.MaskedArray):
5727                     Y = Y.data
5728             nrows, ncols = C.shape[:2]
5729         else:
5730             raise _api.nargs_error(funcname, takes="1 or 3", given=len(args))
5731 
5732         Nx = X.shape[-1]
5733         Ny = Y.shape[0]
5734         if X.ndim != 2 or X.shape[0] == 1:
5735             x = X.reshape(1, Nx)
5736             X = x.repeat(Ny, axis=0)
5737         if Y.ndim != 2 or Y.shape[1] == 1:
5738             y = Y.reshape(Ny, 1)
5739             Y = y.repeat(Nx, axis=1)
5740         if X.shape != Y.shape:
5741             raise TypeError(f'Incompatible X, Y inputs to {funcname}; '
5742                             f'see help({funcname})')
5743 
5744         if shading == 'auto':
5745             if ncols == Nx and nrows == Ny:
5746                 shading = 'nearest'
5747             else:
5748                 shading = 'flat'
5749 
5750         if shading == 'flat':
5751             if (Nx, Ny) != (ncols + 1, nrows + 1):
5752                 raise TypeError(f"Dimensions of C {C.shape} should"
5753                                 f" be one smaller than X({Nx}) and Y({Ny})"
5754                                 f" while using shading='flat'"
5755                                 f" see help({funcname})")
5756         else:    # ['nearest', 'gouraud']:
5757             if (Nx, Ny) != (ncols, nrows):
5758                 raise TypeError('Dimensions of C %s are incompatible with'
5759                                 ' X (%d) and/or Y (%d); see help(%s)' % (
5760                                     C.shape, Nx, Ny, funcname))
5761             if shading == 'nearest':
5762                 # grid is specified at the center, so define corners
5763                 # at the midpoints between the grid centers and then use the
5764                 # flat algorithm.
5765                 def _interp_grid(X):
5766                     # helper for below
5767                     if np.shape(X)[1] > 1:
5768                         dX = np.diff(X, axis=1)/2.
5769                         if not (np.all(dX >= 0) or np.all(dX <= 0)):
5770                             _api.warn_external(
5771                                 f"The input coordinates to {funcname} are "
5772                                 "interpreted as cell centers, but are not "
5773                                 "monotonically increasing or decreasing. "
5774                                 "This may lead to incorrectly calculated cell "
5775                                 "edges, in which case, please supply "
5776                                 f"explicit cell edges to {funcname}.")
5777                         X = np.hstack((X[:, [0]] - dX[:, [0]],
5778                                        X[:, :-1] + dX,
5779                                        X[:, [-1]] + dX[:, [-1]]))
5780                     else:
5781                         # This is just degenerate, but we can't reliably guess
5782                         # a dX if there is just one value.
5783                         X = np.hstack((X, X))
5784                     return X
5785 
5786                 if ncols == Nx:
5787                     X = _interp_grid(X)
5788                     Y = _interp_grid(Y)
5789                 if nrows == Ny:
5790                     X = _interp_grid(X.T).T
5791                     Y = _interp_grid(Y.T).T
5792                 shading = 'flat'
5793 
5794         C = cbook.safe_masked_invalid(C)
5795         return X, Y, C, shading
5796 
5797     @_preprocess_data()
5798     @_docstring.dedent_interpd
5799     def pcolor(self, *args, shading=None, alpha=None, norm=None, cmap=None,
5800                vmin=None, vmax=None, **kwargs):
5801         r"""
5802         Create a pseudocolor plot with a non-regular rectangular grid.
5803 
5804         Call signature::
5805 
5806             pcolor([X, Y,] C, **kwargs)
5807 
5808         *X* and *Y* can be used to specify the corners of the quadrilaterals.
5809 
5810         .. hint::
5811 
5812             ``pcolor()`` can be very slow for large arrays. In most
5813             cases you should use the similar but much faster
5814             `~.Axes.pcolormesh` instead. See
5815             :ref:`Differences between pcolor() and pcolormesh()
5816             <differences-pcolor-pcolormesh>` for a discussion of the
5817             differences.
5818 
5819         Parameters
5820         ----------
5821         C : 2D array-like
5822             The color-mapped values.  Color-mapping is controlled by *cmap*,
5823             *norm*, *vmin*, and *vmax*.
5824 
5825         X, Y : array-like, optional
5826             The coordinates of the corners of quadrilaterals of a pcolormesh::
5827 
5828                 (X[i+1, j], Y[i+1, j])       (X[i+1, j+1], Y[i+1, j+1])
5829                                       
5830                                            
5831                                       
5832                     (X[i, j], Y[i, j])       (X[i, j+1], Y[i, j+1])
5833 
5834             Note that the column index corresponds to the x-coordinate, and
5835             the row index corresponds to y. For details, see the
5836             :ref:`Notes <axes-pcolormesh-grid-orientation>` section below.
5837 
5838             If ``shading='flat'`` the dimensions of *X* and *Y* should be one
5839             greater than those of *C*, and the quadrilateral is colored due
5840             to the value at ``C[i, j]``.  If *X*, *Y* and *C* have equal
5841             dimensions, a warning will be raised and the last row and column
5842             of *C* will be ignored.
5843 
5844             If ``shading='nearest'``, the dimensions of *X* and *Y* should be
5845             the same as those of *C* (if not, a ValueError will be raised). The
5846             color ``C[i, j]`` will be centered on ``(X[i, j], Y[i, j])``.
5847 
5848             If *X* and/or *Y* are 1-D arrays or column vectors they will be
5849             expanded as needed into the appropriate 2D arrays, making a
5850             rectangular grid.
5851 
5852         shading : {'flat', 'nearest', 'auto'}, default: :rc:`pcolor.shading`
5853             The fill style for the quadrilateral. Possible values:
5854 
5855             - 'flat': A solid color is used for each quad. The color of the
5856               quad (i, j), (i+1, j), (i, j+1), (i+1, j+1) is given by
5857               ``C[i, j]``. The dimensions of *X* and *Y* should be
5858               one greater than those of *C*; if they are the same as *C*,
5859               then a deprecation warning is raised, and the last row
5860               and column of *C* are dropped.
5861             - 'nearest': Each grid point will have a color centered on it,
5862               extending halfway between the adjacent grid centers.  The
5863               dimensions of *X* and *Y* must be the same as *C*.
5864             - 'auto': Choose 'flat' if dimensions of *X* and *Y* are one
5865               larger than *C*.  Choose 'nearest' if dimensions are the same.
5866 
5867             See :doc:`/gallery/images_contours_and_fields/pcolormesh_grids`
5868             for more description.
5869 
5870         %(cmap_doc)s
5871 
5872         %(norm_doc)s
5873 
5874         %(vmin_vmax_doc)s
5875 
5876         edgecolors : {'none', None, 'face', color, color sequence}, optional
5877             The color of the edges. Defaults to 'none'. Possible values:
5878 
5879             - 'none' or '': No edge.
5880             - *None*: :rc:`patch.edgecolor` will be used. Note that currently
5881               :rc:`patch.force_edgecolor` has to be True for this to work.
5882             - 'face': Use the adjacent face color.
5883             - A color or sequence of colors will set the edge color.
5884 
5885             The singular form *edgecolor* works as an alias.
5886 
5887         alpha : float, default: None
5888             The alpha blending value of the face color, between 0 (transparent)
5889             and 1 (opaque). Note: The edgecolor is currently not affected by
5890             this.
5891 
5892         snap : bool, default: False
5893             Whether to snap the mesh to pixel boundaries.
5894 
5895         Returns
5896         -------
5897         `matplotlib.collections.Collection`
5898 
5899         Other Parameters
5900         ----------------
5901         antialiaseds : bool, default: False
5902             The default *antialiaseds* is False if the default
5903             *edgecolors*\ ="none" is used.  This eliminates artificial lines
5904             at patch boundaries, and works regardless of the value of alpha.
5905             If *edgecolors* is not "none", then the default *antialiaseds*
5906             is taken from :rc:`patch.antialiased`.
5907             Stroking the edges may be preferred if *alpha* is 1, but will
5908             cause artifacts otherwise.
5909 
5910         data : indexable object, optional
5911             DATA_PARAMETER_PLACEHOLDER
5912 
5913         **kwargs
5914             Additionally, the following arguments are allowed. They are passed
5915             along to the `~matplotlib.collections.PolyCollection` constructor:
5916 
5917         %(PolyCollection:kwdoc)s
5918 
5919         See Also
5920         --------
5921         pcolormesh : for an explanation of the differences between
5922             pcolor and pcolormesh.
5923         imshow : If *X* and *Y* are each equidistant, `~.Axes.imshow` can be a
5924             faster alternative.
5925 
5926         Notes
5927         -----
5928         **Masked arrays**
5929 
5930         *X*, *Y* and *C* may be masked arrays. If either ``C[i, j]``, or one
5931         of the vertices surrounding ``C[i, j]`` (*X* or *Y* at
5932         ``[i, j], [i+1, j], [i, j+1], [i+1, j+1]``) is masked, nothing is
5933         plotted.
5934 
5935         .. _axes-pcolor-grid-orientation:
5936 
5937         **Grid orientation**
5938 
5939         The grid orientation follows the standard matrix convention: An array
5940         *C* with shape (nrows, ncolumns) is plotted with the column number as
5941         *X* and the row number as *Y*.
5942         """
5943 
5944         if shading is None:
5945             shading = mpl.rcParams['pcolor.shading']
5946         shading = shading.lower()
5947         X, Y, C, shading = self._pcolorargs('pcolor', *args, shading=shading,
5948                                             kwargs=kwargs)
5949         Ny, Nx = X.shape
5950 
5951         # convert to MA, if necessary.
5952         C = ma.asarray(C)
5953         X = ma.asarray(X)
5954         Y = ma.asarray(Y)
5955 
5956         mask = ma.getmaskarray(X) + ma.getmaskarray(Y)
5957         xymask = (mask[0:-1, 0:-1] + mask[1:, 1:] +
5958                   mask[0:-1, 1:] + mask[1:, 0:-1])
5959         # don't plot if C or any of the surrounding vertices are masked.
5960         mask = ma.getmaskarray(C) + xymask
5961 
5962         unmask = ~mask
5963         X1 = ma.filled(X[:-1, :-1])[unmask]
5964         Y1 = ma.filled(Y[:-1, :-1])[unmask]
5965         X2 = ma.filled(X[1:, :-1])[unmask]
5966         Y2 = ma.filled(Y[1:, :-1])[unmask]
5967         X3 = ma.filled(X[1:, 1:])[unmask]
5968         Y3 = ma.filled(Y[1:, 1:])[unmask]
5969         X4 = ma.filled(X[:-1, 1:])[unmask]
5970         Y4 = ma.filled(Y[:-1, 1:])[unmask]
5971         npoly = len(X1)
5972 
5973         xy = np.stack([X1, Y1, X2, Y2, X3, Y3, X4, Y4, X1, Y1], axis=-1)
5974         verts = xy.reshape((npoly, 5, 2))
5975 
5976         C = ma.filled(C[:Ny - 1, :Nx - 1])[unmask]
5977 
5978         linewidths = (0.25,)
5979         if 'linewidth' in kwargs:
5980             kwargs['linewidths'] = kwargs.pop('linewidth')
5981         kwargs.setdefault('linewidths', linewidths)
5982 
5983         if 'edgecolor' in kwargs:
5984             kwargs['edgecolors'] = kwargs.pop('edgecolor')
5985         ec = kwargs.setdefault('edgecolors', 'none')
5986 
5987         # aa setting will default via collections to patch.antialiased
5988         # unless the boundary is not stroked, in which case the
5989         # default will be False; with unstroked boundaries, aa
5990         # makes artifacts that are often disturbing.
5991         if 'antialiased' in kwargs:
5992             kwargs['antialiaseds'] = kwargs.pop('antialiased')
5993         if 'antialiaseds' not in kwargs and cbook._str_lower_equal(ec, "none"):
5994             kwargs['antialiaseds'] = False
5995 
5996         kwargs.setdefault('snap', False)
5997 
5998         collection = mcoll.PolyCollection(
5999             verts, array=C, cmap=cmap, norm=norm, alpha=alpha, **kwargs)
6000         collection._scale_norm(norm, vmin, vmax)
6001 
6002         x = X.compressed()
6003         y = Y.compressed()
6004 
6005         # Transform from native to data coordinates?
6006         t = collection._transform
6007         if (not isinstance(t, mtransforms.Transform) and
6008                 hasattr(t, '_as_mpl_transform')):
6009             t = t._as_mpl_transform(self.axes)
6010 
6011         if t and any(t.contains_branch_seperately(self.transData)):
6012             trans_to_data = t - self.transData
6013             pts = np.vstack([x, y]).T.astype(float)
6014             transformed_pts = trans_to_data.transform(pts)
6015             x = transformed_pts[..., 0]
6016             y = transformed_pts[..., 1]
6017 
6018         self.add_collection(collection, autolim=False)
6019 
6020         minx = np.min(x)
6021         maxx = np.max(x)
6022         miny = np.min(y)
6023         maxy = np.max(y)
6024         collection.sticky_edges.x[:] = [minx, maxx]
6025         collection.sticky_edges.y[:] = [miny, maxy]
6026         corners = (minx, miny), (maxx, maxy)
6027         self.update_datalim(corners)
6028         self._request_autoscale_view()
6029         return collection
6030 
6031     @_preprocess_data()
6032     @_docstring.dedent_interpd
6033     def pcolormesh(self, *args, alpha=None, norm=None, cmap=None, vmin=None,
6034                    vmax=None, shading=None, antialiased=False, **kwargs):
6035         """
6036         Create a pseudocolor plot with a non-regular rectangular grid.
6037 
6038         Call signature::
6039 
6040             pcolormesh([X, Y,] C, **kwargs)
6041 
6042         *X* and *Y* can be used to specify the corners of the quadrilaterals.
6043 
6044         .. hint::
6045 
6046            `~.Axes.pcolormesh` is similar to `~.Axes.pcolor`. It is much faster
6047            and preferred in most cases. For a detailed discussion on the
6048            differences see :ref:`Differences between pcolor() and pcolormesh()
6049            <differences-pcolor-pcolormesh>`.
6050 
6051         Parameters
6052         ----------
6053         C : array-like
6054             The mesh data. Supported array shapes are:
6055 
6056             - (M, N) or M*N: a mesh with scalar data. The values are mapped to
6057               colors using normalization and a colormap. See parameters *norm*,
6058               *cmap*, *vmin*, *vmax*.
6059             - (M, N, 3): an image with RGB values (0-1 float or 0-255 int).
6060             - (M, N, 4): an image with RGBA values (0-1 float or 0-255 int),
6061               i.e. including transparency.
6062 
6063             The first two dimensions (M, N) define the rows and columns of
6064             the mesh data.
6065 
6066         X, Y : array-like, optional
6067             The coordinates of the corners of quadrilaterals of a pcolormesh::
6068 
6069                 (X[i+1, j], Y[i+1, j])       (X[i+1, j+1], Y[i+1, j+1])
6070                                       
6071                                            
6072                                       
6073                     (X[i, j], Y[i, j])       (X[i, j+1], Y[i, j+1])
6074 
6075             Note that the column index corresponds to the x-coordinate, and
6076             the row index corresponds to y. For details, see the
6077             :ref:`Notes <axes-pcolormesh-grid-orientation>` section below.
6078 
6079             If ``shading='flat'`` the dimensions of *X* and *Y* should be one
6080             greater than those of *C*, and the quadrilateral is colored due
6081             to the value at ``C[i, j]``.  If *X*, *Y* and *C* have equal
6082             dimensions, a warning will be raised and the last row and column
6083             of *C* will be ignored.
6084 
6085             If ``shading='nearest'`` or ``'gouraud'``, the dimensions of *X*
6086             and *Y* should be the same as those of *C* (if not, a ValueError
6087             will be raised).  For ``'nearest'`` the color ``C[i, j]`` is
6088             centered on ``(X[i, j], Y[i, j])``.  For ``'gouraud'``, a smooth
6089             interpolation is caried out between the quadrilateral corners.
6090 
6091             If *X* and/or *Y* are 1-D arrays or column vectors they will be
6092             expanded as needed into the appropriate 2D arrays, making a
6093             rectangular grid.
6094 
6095         %(cmap_doc)s
6096 
6097         %(norm_doc)s
6098 
6099         %(vmin_vmax_doc)s
6100 
6101         edgecolors : {'none', None, 'face', color, color sequence}, optional
6102             The color of the edges. Defaults to 'none'. Possible values:
6103 
6104             - 'none' or '': No edge.
6105             - *None*: :rc:`patch.edgecolor` will be used. Note that currently
6106               :rc:`patch.force_edgecolor` has to be True for this to work.
6107             - 'face': Use the adjacent face color.
6108             - A color or sequence of colors will set the edge color.
6109 
6110             The singular form *edgecolor* works as an alias.
6111 
6112         alpha : float, default: None
6113             The alpha blending value, between 0 (transparent) and 1 (opaque).
6114 
6115         shading : {'flat', 'nearest', 'gouraud', 'auto'}, optional
6116             The fill style for the quadrilateral; defaults to
6117             :rc:`pcolor.shading`. Possible values:
6118 
6119             - 'flat': A solid color is used for each quad. The color of the
6120               quad (i, j), (i+1, j), (i, j+1), (i+1, j+1) is given by
6121               ``C[i, j]``. The dimensions of *X* and *Y* should be
6122               one greater than those of *C*; if they are the same as *C*,
6123               then a deprecation warning is raised, and the last row
6124               and column of *C* are dropped.
6125             - 'nearest': Each grid point will have a color centered on it,
6126               extending halfway between the adjacent grid centers.  The
6127               dimensions of *X* and *Y* must be the same as *C*.
6128             - 'gouraud': Each quad will be Gouraud shaded: The color of the
6129               corners (i', j') are given by ``C[i', j']``. The color values of
6130               the area in between is interpolated from the corner values.
6131               The dimensions of *X* and *Y* must be the same as *C*. When
6132               Gouraud shading is used, *edgecolors* is ignored.
6133             - 'auto': Choose 'flat' if dimensions of *X* and *Y* are one
6134               larger than *C*.  Choose 'nearest' if dimensions are the same.
6135 
6136             See :doc:`/gallery/images_contours_and_fields/pcolormesh_grids`
6137             for more description.
6138 
6139         snap : bool, default: False
6140             Whether to snap the mesh to pixel boundaries.
6141 
6142         rasterized : bool, optional
6143             Rasterize the pcolormesh when drawing vector graphics.  This can
6144             speed up rendering and produce smaller files for large data sets.
6145             See also :doc:`/gallery/misc/rasterization_demo`.
6146 
6147         Returns
6148         -------
6149         `matplotlib.collections.QuadMesh`
6150 
6151         Other Parameters
6152         ----------------
6153         data : indexable object, optional
6154             DATA_PARAMETER_PLACEHOLDER
6155 
6156         **kwargs
6157             Additionally, the following arguments are allowed. They are passed
6158             along to the `~matplotlib.collections.QuadMesh` constructor:
6159 
6160         %(QuadMesh:kwdoc)s
6161 
6162         See Also
6163         --------
6164         pcolor : An alternative implementation with slightly different
6165             features. For a detailed discussion on the differences see
6166             :ref:`Differences between pcolor() and pcolormesh()
6167             <differences-pcolor-pcolormesh>`.
6168         imshow : If *X* and *Y* are each equidistant, `~.Axes.imshow` can be a
6169             faster alternative.
6170 
6171         Notes
6172         -----
6173         **Masked arrays**
6174 
6175         *C* may be a masked array. If ``C[i, j]`` is masked, the corresponding
6176         quadrilateral will be transparent. Masking of *X* and *Y* is not
6177         supported. Use `~.Axes.pcolor` if you need this functionality.
6178 
6179         .. _axes-pcolormesh-grid-orientation:
6180 
6181         **Grid orientation**
6182 
6183         The grid orientation follows the standard matrix convention: An array
6184         *C* with shape (nrows, ncolumns) is plotted with the column number as
6185         *X* and the row number as *Y*.
6186 
6187         .. _differences-pcolor-pcolormesh:
6188 
6189         **Differences between pcolor() and pcolormesh()**
6190 
6191         Both methods are used to create a pseudocolor plot of a 2D array
6192         using quadrilaterals.
6193 
6194         The main difference lies in the created object and internal data
6195         handling:
6196         While `~.Axes.pcolor` returns a `.PolyCollection`, `~.Axes.pcolormesh`
6197         returns a `.QuadMesh`. The latter is more specialized for the given
6198         purpose and thus is faster. It should almost always be preferred.
6199 
6200         There is also a slight difference in the handling of masked arrays.
6201         Both `~.Axes.pcolor` and `~.Axes.pcolormesh` support masked arrays
6202         for *C*. However, only `~.Axes.pcolor` supports masked arrays for *X*
6203         and *Y*. The reason lies in the internal handling of the masked values.
6204         `~.Axes.pcolor` leaves out the respective polygons from the
6205         PolyCollection. `~.Axes.pcolormesh` sets the facecolor of the masked
6206         elements to transparent. You can see the difference when using
6207         edgecolors. While all edges are drawn irrespective of masking in a
6208         QuadMesh, the edge between two adjacent masked quadrilaterals in
6209         `~.Axes.pcolor` is not drawn as the corresponding polygons do not
6210         exist in the PolyCollection.
6211 
6212         Another difference is the support of Gouraud shading in
6213         `~.Axes.pcolormesh`, which is not available with `~.Axes.pcolor`.
6214 
6215         """
6216         if shading is None:
6217             shading = mpl.rcParams['pcolor.shading']
6218         shading = shading.lower()
6219         kwargs.setdefault('edgecolors', 'none')
6220 
6221         X, Y, C, shading = self._pcolorargs('pcolormesh', *args,
6222                                             shading=shading, kwargs=kwargs)
6223         coords = np.stack([X, Y], axis=-1)
6224 
6225         kwargs.setdefault('snap', mpl.rcParams['pcolormesh.snap'])
6226 
6227         collection = mcoll.QuadMesh(
6228             coords, antialiased=antialiased, shading=shading,
6229             array=C, cmap=cmap, norm=norm, alpha=alpha, **kwargs)
6230         collection._scale_norm(norm, vmin, vmax)
6231 
6232         coords = coords.reshape(-1, 2)  # flatten the grid structure; keep x, y
6233 
6234         # Transform from native to data coordinates?
6235         t = collection._transform
6236         if (not isinstance(t, mtransforms.Transform) and
6237                 hasattr(t, '_as_mpl_transform')):
6238             t = t._as_mpl_transform(self.axes)
6239 
6240         if t and any(t.contains_branch_seperately(self.transData)):
6241             trans_to_data = t - self.transData
6242             coords = trans_to_data.transform(coords)
6243 
6244         self.add_collection(collection, autolim=False)
6245 
6246         minx, miny = np.min(coords, axis=0)
6247         maxx, maxy = np.max(coords, axis=0)
6248         collection.sticky_edges.x[:] = [minx, maxx]
6249         collection.sticky_edges.y[:] = [miny, maxy]
6250         corners = (minx, miny), (maxx, maxy)
6251         self.update_datalim(corners)
6252         self._request_autoscale_view()
6253         return collection
6254 
6255     @_preprocess_data()
6256     @_docstring.dedent_interpd
6257     def pcolorfast(self, *args, alpha=None, norm=None, cmap=None, vmin=None,
6258                    vmax=None, **kwargs):
6259         """
6260         Create a pseudocolor plot with a non-regular rectangular grid.
6261 
6262         Call signature::
6263 
6264           ax.pcolorfast([X, Y], C, /, **kwargs)
6265 
6266         This method is similar to `~.Axes.pcolor` and `~.Axes.pcolormesh`.
6267         It's designed to provide the fastest pcolor-type plotting with the
6268         Agg backend. To achieve this, it uses different algorithms internally
6269         depending on the complexity of the input grid (regular rectangular,
6270         non-regular rectangular or arbitrary quadrilateral).
6271 
6272         .. warning::
6273 
6274            This method is experimental. Compared to `~.Axes.pcolor` or
6275            `~.Axes.pcolormesh` it has some limitations:
6276 
6277            - It supports only flat shading (no outlines)
6278            - It lacks support for log scaling of the axes.
6279            - It does not have a pyplot wrapper.
6280 
6281         Parameters
6282         ----------
6283         C : array-like
6284             The image data. Supported array shapes are:
6285 
6286             - (M, N): an image with scalar data.  Color-mapping is controlled
6287               by *cmap*, *norm*, *vmin*, and *vmax*.
6288             - (M, N, 3): an image with RGB values (0-1 float or 0-255 int).
6289             - (M, N, 4): an image with RGBA values (0-1 float or 0-255 int),
6290               i.e. including transparency.
6291 
6292             The first two dimensions (M, N) define the rows and columns of
6293             the image.
6294 
6295             This parameter can only be passed positionally.
6296 
6297         X, Y : tuple or array-like, default: ``(0, N)``, ``(0, M)``
6298             *X* and *Y* are used to specify the coordinates of the
6299             quadrilaterals. There are different ways to do this:
6300 
6301             - Use tuples ``X=(xmin, xmax)`` and ``Y=(ymin, ymax)`` to define
6302               a *uniform rectangular grid*.
6303 
6304               The tuples define the outer edges of the grid. All individual
6305               quadrilaterals will be of the same size. This is the fastest
6306               version.
6307 
6308             - Use 1D arrays *X*, *Y* to specify a *non-uniform rectangular
6309               grid*.
6310 
6311               In this case *X* and *Y* have to be monotonic 1D arrays of length
6312               *N+1* and *M+1*, specifying the x and y boundaries of the cells.
6313 
6314               The speed is intermediate. Note: The grid is checked, and if
6315               found to be uniform the fast version is used.
6316 
6317             - Use 2D arrays *X*, *Y* if you need an *arbitrary quadrilateral
6318               grid* (i.e. if the quadrilaterals are not rectangular).
6319 
6320               In this case *X* and *Y* are 2D arrays with shape (M + 1, N + 1),
6321               specifying the x and y coordinates of the corners of the colored
6322               quadrilaterals.
6323 
6324               This is the most general, but the slowest to render.  It may
6325               produce faster and more compact output using ps, pdf, and
6326               svg backends, however.
6327 
6328             These arguments can only be passed positionally.
6329 
6330         %(cmap_doc)s
6331 
6332             This parameter is ignored if *C* is RGB(A).
6333 
6334         %(norm_doc)s
6335 
6336             This parameter is ignored if *C* is RGB(A).
6337 
6338         %(vmin_vmax_doc)s
6339 
6340             This parameter is ignored if *C* is RGB(A).
6341 
6342         alpha : float, default: None
6343             The alpha blending value, between 0 (transparent) and 1 (opaque).
6344 
6345         snap : bool, default: False
6346             Whether to snap the mesh to pixel boundaries.
6347 
6348         Returns
6349         -------
6350         `.AxesImage` or `.PcolorImage` or `.QuadMesh`
6351             The return type depends on the type of grid:
6352 
6353             - `.AxesImage` for a regular rectangular grid.
6354             - `.PcolorImage` for a non-regular rectangular grid.
6355             - `.QuadMesh` for a non-rectangular grid.
6356 
6357         Other Parameters
6358         ----------------
6359         data : indexable object, optional
6360             DATA_PARAMETER_PLACEHOLDER
6361 
6362         **kwargs
6363             Supported additional parameters depend on the type of grid.
6364             See return types of *image* for further description.
6365         """
6366 
6367         C = args[-1]
6368         nr, nc = np.shape(C)[:2]
6369         if len(args) == 1:
6370             style = "image"
6371             x = [0, nc]
6372             y = [0, nr]
6373         elif len(args) == 3:
6374             x, y = args[:2]
6375             x = np.asarray(x)
6376             y = np.asarray(y)
6377             if x.ndim == 1 and y.ndim == 1:
6378                 if x.size == 2 and y.size == 2:
6379                     style = "image"
6380                 else:
6381                     dx = np.diff(x)
6382                     dy = np.diff(y)
6383                     if (np.ptp(dx) < 0.01 * abs(dx.mean()) and
6384                             np.ptp(dy) < 0.01 * abs(dy.mean())):
6385                         style = "image"
6386                     else:
6387                         style = "pcolorimage"
6388             elif x.ndim == 2 and y.ndim == 2:
6389                 style = "quadmesh"
6390             else:
6391                 raise TypeError("arguments do not match valid signatures")
6392         else:
6393             raise TypeError("need 1 argument or 3 arguments")
6394 
6395         if style == "quadmesh":
6396             # data point in each cell is value at lower left corner
6397             coords = np.stack([x, y], axis=-1)
6398             if np.ndim(C) not in {2, 3}:
6399                 raise ValueError("C must be 2D or 3D")
6400             collection = mcoll.QuadMesh(
6401                 coords, array=C,
6402                 alpha=alpha, cmap=cmap, norm=norm,
6403                 antialiased=False, edgecolors="none")
6404             self.add_collection(collection, autolim=False)
6405             xl, xr, yb, yt = x.min(), x.max(), y.min(), y.max()
6406             ret = collection
6407 
6408         else:  # It's one of the two image styles.
6409             extent = xl, xr, yb, yt = x[0], x[-1], y[0], y[-1]
6410             if style == "image":
6411                 im = mimage.AxesImage(
6412                     self, cmap=cmap, norm=norm,
6413                     data=C, alpha=alpha, extent=extent,
6414                     interpolation='nearest', origin='lower',
6415                     **kwargs)
6416             elif style == "pcolorimage":
6417                 im = mimage.PcolorImage(
6418                     self, x, y, C,
6419                     cmap=cmap, norm=norm, alpha=alpha, extent=extent,
6420                     **kwargs)
6421             self.add_image(im)
6422             ret = im
6423 
6424         if np.ndim(C) == 2:  # C.ndim == 3 is RGB(A) so doesn't need scaling.
6425             ret._scale_norm(norm, vmin, vmax)
6426 
6427         if ret.get_clip_path() is None:
6428             # image does not already have clipping set, clip to axes patch
6429             ret.set_clip_path(self.patch)
6430 
6431         ret.sticky_edges.x[:] = [xl, xr]
6432         ret.sticky_edges.y[:] = [yb, yt]
6433         self.update_datalim(np.array([[xl, yb], [xr, yt]]))
6434         self._request_autoscale_view(tight=True)
6435         return ret
6436 
6437     @_preprocess_data()
6438     @_docstring.dedent_interpd
6439     def contour(self, *args, **kwargs):
6440         """
6441         Plot contour lines.
6442 
6443         Call signature::
6444 
6445             contour([X, Y,] Z, [levels], **kwargs)
6446         %(contour_doc)s
6447         """
6448         kwargs['filled'] = False
6449         contours = mcontour.QuadContourSet(self, *args, **kwargs)
6450         self._request_autoscale_view()
6451         return contours
6452 
6453     @_preprocess_data()
6454     @_docstring.dedent_interpd
6455     def contourf(self, *args, **kwargs):
6456         """
6457         Plot filled contours.
6458 
6459         Call signature::
6460 
6461             contourf([X, Y,] Z, [levels], **kwargs)
6462         %(contour_doc)s
6463         """
6464         kwargs['filled'] = True
6465         contours = mcontour.QuadContourSet(self, *args, **kwargs)
6466         self._request_autoscale_view()
6467         return contours
6468 
6469     def clabel(self, CS, levels=None, **kwargs):
6470         """
6471         Label a contour plot.
6472 
6473         Adds labels to line contours in given `.ContourSet`.
6474 
6475         Parameters
6476         ----------
6477         CS : `.ContourSet` instance
6478             Line contours to label.
6479 
6480         levels : array-like, optional
6481             A list of level values, that should be labeled. The list must be
6482             a subset of ``CS.levels``. If not given, all levels are labeled.
6483 
6484         **kwargs
6485             All other parameters are documented in `~.ContourLabeler.clabel`.
6486         """
6487         return CS.clabel(levels, **kwargs)
6488 
6489     #### Data analysis
6490 
6491     @_preprocess_data(replace_names=["x", 'weights'], label_namer="x")
6492     def hist(self, x, bins=None, range=None, density=False, weights=None,
6493              cumulative=False, bottom=None, histtype='bar', align='mid',
6494              orientation='vertical', rwidth=None, log=False,
6495              color=None, label=None, stacked=False, **kwargs):
6496         """
6497         Compute and plot a histogram.
6498 
6499         This method uses `numpy.histogram` to bin the data in *x* and count the
6500         number of values in each bin, then draws the distribution either as a
6501         `.BarContainer` or `.Polygon`. The *bins*, *range*, *density*, and
6502         *weights* parameters are forwarded to `numpy.histogram`.
6503 
6504         If the data has already been binned and counted, use `~.bar` or
6505         `~.stairs` to plot the distribution::
6506 
6507             counts, bins = np.histogram(x)
6508             plt.stairs(counts, bins)
6509 
6510         Alternatively, plot pre-computed bins and counts using ``hist()`` by
6511         treating each bin as a single point with a weight equal to its count::
6512 
6513             plt.hist(bins[:-1], bins, weights=counts)
6514 
6515         The data input *x* can be a singular array, a list of datasets of
6516         potentially different lengths ([*x0*, *x1*, ...]), or a 2D ndarray in
6517         which each column is a dataset. Note that the ndarray form is
6518         transposed relative to the list form. If the input is an array, then
6519         the return value is a tuple (*n*, *bins*, *patches*); if the input is a
6520         sequence of arrays, then the return value is a tuple
6521         ([*n0*, *n1*, ...], *bins*, [*patches0*, *patches1*, ...]).
6522 
6523         Masked arrays are not supported.
6524 
6525         Parameters
6526         ----------
6527         x : (n,) array or sequence of (n,) arrays
6528             Input values, this takes either a single array or a sequence of
6529             arrays which are not required to be of the same length.
6530 
6531         bins : int or sequence or str, default: :rc:`hist.bins`
6532             If *bins* is an integer, it defines the number of equal-width bins
6533             in the range.
6534 
6535             If *bins* is a sequence, it defines the bin edges, including the
6536             left edge of the first bin and the right edge of the last bin;
6537             in this case, bins may be unequally spaced.  All but the last
6538             (righthand-most) bin is half-open.  In other words, if *bins* is::
6539 
6540                 [1, 2, 3, 4]
6541 
6542             then the first bin is ``[1, 2)`` (including 1, but excluding 2) and
6543             the second ``[2, 3)``.  The last bin, however, is ``[3, 4]``, which
6544             *includes* 4.
6545 
6546             If *bins* is a string, it is one of the binning strategies
6547             supported by `numpy.histogram_bin_edges`: 'auto', 'fd', 'doane',
6548             'scott', 'stone', 'rice', 'sturges', or 'sqrt'.
6549 
6550         range : tuple or None, default: None
6551             The lower and upper range of the bins. Lower and upper outliers
6552             are ignored. If not provided, *range* is ``(x.min(), x.max())``.
6553             Range has no effect if *bins* is a sequence.
6554 
6555             If *bins* is a sequence or *range* is specified, autoscaling
6556             is based on the specified bin range instead of the
6557             range of x.
6558 
6559         density : bool, default: False
6560             If ``True``, draw and return a probability density: each bin
6561             will display the bin's raw count divided by the total number of
6562             counts *and the bin width*
6563             (``density = counts / (sum(counts) * np.diff(bins))``),
6564             so that the area under the histogram integrates to 1
6565             (``np.sum(density * np.diff(bins)) == 1``).
6566 
6567             If *stacked* is also ``True``, the sum of the histograms is
6568             normalized to 1.
6569 
6570         weights : (n,) array-like or None, default: None
6571             An array of weights, of the same shape as *x*.  Each value in
6572             *x* only contributes its associated weight towards the bin count
6573             (instead of 1).  If *density* is ``True``, the weights are
6574             normalized, so that the integral of the density over the range
6575             remains 1.
6576 
6577         cumulative : bool or -1, default: False
6578             If ``True``, then a histogram is computed where each bin gives the
6579             counts in that bin plus all bins for smaller values. The last bin
6580             gives the total number of datapoints.
6581 
6582             If *density* is also ``True`` then the histogram is normalized such
6583             that the last bin equals 1.
6584 
6585             If *cumulative* is a number less than 0 (e.g., -1), the direction
6586             of accumulation is reversed.  In this case, if *density* is also
6587             ``True``, then the histogram is normalized such that the first bin
6588             equals 1.
6589 
6590         bottom : array-like, scalar, or None, default: None
6591             Location of the bottom of each bin, i.e. bins are drawn from
6592             ``bottom`` to ``bottom + hist(x, bins)`` If a scalar, the bottom
6593             of each bin is shifted by the same amount. If an array, each bin
6594             is shifted independently and the length of bottom must match the
6595             number of bins. If None, defaults to 0.
6596 
6597         histtype : {'bar', 'barstacked', 'step', 'stepfilled'}, default: 'bar'
6598             The type of histogram to draw.
6599 
6600             - 'bar' is a traditional bar-type histogram.  If multiple data
6601               are given the bars are arranged side by side.
6602             - 'barstacked' is a bar-type histogram where multiple
6603               data are stacked on top of each other.
6604             - 'step' generates a lineplot that is by default unfilled.
6605             - 'stepfilled' generates a lineplot that is by default filled.
6606 
6607         align : {'left', 'mid', 'right'}, default: 'mid'
6608             The horizontal alignment of the histogram bars.
6609 
6610             - 'left': bars are centered on the left bin edges.
6611             - 'mid': bars are centered between the bin edges.
6612             - 'right': bars are centered on the right bin edges.
6613 
6614         orientation : {'vertical', 'horizontal'}, default: 'vertical'
6615             If 'horizontal', `~.Axes.barh` will be used for bar-type histograms
6616             and the *bottom* kwarg will be the left edges.
6617 
6618         rwidth : float or None, default: None
6619             The relative width of the bars as a fraction of the bin width.  If
6620             ``None``, automatically compute the width.
6621 
6622             Ignored if *histtype* is 'step' or 'stepfilled'.
6623 
6624         log : bool, default: False
6625             If ``True``, the histogram axis will be set to a log scale.
6626 
6627         color : color or array-like of colors or None, default: None
6628             Color or sequence of colors, one per dataset.  Default (``None``)
6629             uses the standard line color sequence.
6630 
6631         label : str or None, default: None
6632             String, or sequence of strings to match multiple datasets.  Bar
6633             charts yield multiple patches per dataset, but only the first gets
6634             the label, so that `~.Axes.legend` will work as expected.
6635 
6636         stacked : bool, default: False
6637             If ``True``, multiple data are stacked on top of each other If
6638             ``False`` multiple data are arranged side by side if histtype is
6639             'bar' or on top of each other if histtype is 'step'
6640 
6641         Returns
6642         -------
6643         n : array or list of arrays
6644             The values of the histogram bins. See *density* and *weights* for a
6645             description of the possible semantics.  If input *x* is an array,
6646             then this is an array of length *nbins*. If input is a sequence of
6647             arrays ``[data1, data2, ...]``, then this is a list of arrays with
6648             the values of the histograms for each of the arrays in the same
6649             order.  The dtype of the array *n* (or of its element arrays) will
6650             always be float even if no weighting or normalization is used.
6651 
6652         bins : array
6653             The edges of the bins. Length nbins + 1 (nbins left edges and right
6654             edge of last bin).  Always a single array even when multiple data
6655             sets are passed in.
6656 
6657         patches : `.BarContainer` or list of a single `.Polygon` or list of \
6658 such objects
6659             Container of individual artists used to create the histogram
6660             or list of such containers if there are multiple input datasets.
6661 
6662         Other Parameters
6663         ----------------
6664         data : indexable object, optional
6665             DATA_PARAMETER_PLACEHOLDER
6666 
6667         **kwargs
6668             `~matplotlib.patches.Patch` properties
6669 
6670         See Also
6671         --------
6672         hist2d : 2D histogram with rectangular bins
6673         hexbin : 2D histogram with hexagonal bins
6674 
6675         Notes
6676         -----
6677         For large numbers of bins (>1000), plotting can be significantly faster
6678         if *histtype* is set to 'step' or 'stepfilled' rather than 'bar' or
6679         'barstacked'.
6680         """
6681         # Avoid shadowing the builtin.
6682         bin_range = range
6683         from builtins import range
6684 
6685         if np.isscalar(x):
6686             x = [x]
6687 
6688         if bins is None:
6689             bins = mpl.rcParams['hist.bins']
6690 
6691         # Validate string inputs here to avoid cluttering subsequent code.
6692         _api.check_in_list(['bar', 'barstacked', 'step', 'stepfilled'],
6693                            histtype=histtype)
6694         _api.check_in_list(['left', 'mid', 'right'], align=align)
6695         _api.check_in_list(['horizontal', 'vertical'], orientation=orientation)
6696 
6697         if histtype == 'barstacked' and not stacked:
6698             stacked = True
6699 
6700         # Massage 'x' for processing.
6701         x = cbook._reshape_2D(x, 'x')
6702         nx = len(x)  # number of datasets
6703 
6704         # Process unit information.  _process_unit_info sets the unit and
6705         # converts the first dataset; then we convert each following dataset
6706         # one at a time.
6707         if orientation == "vertical":
6708             convert_units = self.convert_xunits
6709             x = [*self._process_unit_info([("x", x[0])], kwargs),
6710                  *map(convert_units, x[1:])]
6711         else:  # horizontal
6712             convert_units = self.convert_yunits
6713             x = [*self._process_unit_info([("y", x[0])], kwargs),
6714                  *map(convert_units, x[1:])]
6715 
6716         if bin_range is not None:
6717             bin_range = convert_units(bin_range)
6718 
6719         if not cbook.is_scalar_or_string(bins):
6720             bins = convert_units(bins)
6721 
6722         # We need to do to 'weights' what was done to 'x'
6723         if weights is not None:
6724             w = cbook._reshape_2D(weights, 'weights')
6725         else:
6726             w = [None] * nx
6727 
6728         if len(w) != nx:
6729             raise ValueError('weights should have the same shape as x')
6730 
6731         input_empty = True
6732         for xi, wi in zip(x, w):
6733             len_xi = len(xi)
6734             if wi is not None and len(wi) != len_xi:
6735                 raise ValueError('weights should have the same shape as x')
6736             if len_xi:
6737                 input_empty = False
6738 
6739         if color is None:
6740             colors = [self._get_lines.get_next_color() for i in range(nx)]
6741         else:
6742             colors = mcolors.to_rgba_array(color)
6743             if len(colors) != nx:
6744                 raise ValueError(f"The 'color' keyword argument must have one "
6745                                  f"color per dataset, but {nx} datasets and "
6746                                  f"{len(colors)} colors were provided")
6747 
6748         hist_kwargs = dict()
6749 
6750         # if the bin_range is not given, compute without nan numpy
6751         # does not do this for us when guessing the range (but will
6752         # happily ignore nans when computing the histogram).
6753         if bin_range is None:
6754             xmin = np.inf
6755             xmax = -np.inf
6756             for xi in x:
6757                 if len(xi):
6758                     # python's min/max ignore nan,
6759                     # np.minnan returns nan for all nan input
6760                     xmin = min(xmin, np.nanmin(xi))
6761                     xmax = max(xmax, np.nanmax(xi))
6762             if xmin <= xmax:  # Only happens if we have seen a finite value.
6763                 bin_range = (xmin, xmax)
6764 
6765         # If bins are not specified either explicitly or via range,
6766         # we need to figure out the range required for all datasets,
6767         # and supply that to np.histogram.
6768         if not input_empty and len(x) > 1:
6769             if weights is not None:
6770                 _w = np.concatenate(w)
6771             else:
6772                 _w = None
6773             bins = np.histogram_bin_edges(
6774                 np.concatenate(x), bins, bin_range, _w)
6775         else:
6776             hist_kwargs['range'] = bin_range
6777 
6778         density = bool(density)
6779         if density and not stacked:
6780             hist_kwargs['density'] = density
6781 
6782         # List to store all the top coordinates of the histograms
6783         tops = []  # Will have shape (n_datasets, n_bins).
6784         # Loop through datasets
6785         for i in range(nx):
6786             # this will automatically overwrite bins,
6787             # so that each histogram uses the same bins
6788             m, bins = np.histogram(x[i], bins, weights=w[i], **hist_kwargs)
6789             tops.append(m)
6790         tops = np.array(tops, float)  # causes problems later if it's an int
6791         bins = np.array(bins, float)  # causes problems if float16
6792         if stacked:
6793             tops = tops.cumsum(axis=0)
6794             # If a stacked density plot, normalize so the area of all the
6795             # stacked histograms together is 1
6796             if density:
6797                 tops = (tops / np.diff(bins)) / tops[-1].sum()
6798         if cumulative:
6799             slc = slice(None)
6800             if isinstance(cumulative, Number) and cumulative < 0:
6801                 slc = slice(None, None, -1)
6802             if density:
6803                 tops = (tops * np.diff(bins))[:, slc].cumsum(axis=1)[:, slc]
6804             else:
6805                 tops = tops[:, slc].cumsum(axis=1)[:, slc]
6806 
6807         patches = []
6808 
6809         if histtype.startswith('bar'):
6810 
6811             totwidth = np.diff(bins)
6812 
6813             if rwidth is not None:
6814                 dr = np.clip(rwidth, 0, 1)
6815             elif (len(tops) > 1 and
6816                   ((not stacked) or mpl.rcParams['_internal.classic_mode'])):
6817                 dr = 0.8
6818             else:
6819                 dr = 1.0
6820 
6821             if histtype == 'bar' and not stacked:
6822                 width = dr * totwidth / nx
6823                 dw = width
6824                 boffset = -0.5 * dr * totwidth * (1 - 1 / nx)
6825             elif histtype == 'barstacked' or stacked:
6826                 width = dr * totwidth
6827                 boffset, dw = 0.0, 0.0
6828 
6829             if align == 'mid':
6830                 boffset += 0.5 * totwidth
6831             elif align == 'right':
6832                 boffset += totwidth
6833 
6834             if orientation == 'horizontal':
6835                 _barfunc = self.barh
6836                 bottom_kwarg = 'left'
6837             else:  # orientation == 'vertical'
6838                 _barfunc = self.bar
6839                 bottom_kwarg = 'bottom'
6840 
6841             for top, color in zip(tops, colors):
6842                 if bottom is None:
6843                     bottom = np.zeros(len(top))
6844                 if stacked:
6845                     height = top - bottom
6846                 else:
6847                     height = top
6848                 bars = _barfunc(bins[:-1]+boffset, height, width,
6849                                 align='center', log=log,
6850                                 color=color, **{bottom_kwarg: bottom})
6851                 patches.append(bars)
6852                 if stacked:
6853                     bottom = top
6854                 boffset += dw
6855             # Remove stickies from all bars but the lowest ones, as otherwise
6856             # margin expansion would be unable to cross the stickies in the
6857             # middle of the bars.
6858             for bars in patches[1:]:
6859                 for patch in bars:
6860                     patch.sticky_edges.x[:] = patch.sticky_edges.y[:] = []
6861 
6862         elif histtype.startswith('step'):
6863             # these define the perimeter of the polygon
6864             x = np.zeros(4 * len(bins) - 3)
6865             y = np.zeros(4 * len(bins) - 3)
6866 
6867             x[0:2*len(bins)-1:2], x[1:2*len(bins)-1:2] = bins, bins[:-1]
6868             x[2*len(bins)-1:] = x[1:2*len(bins)-1][::-1]
6869 
6870             if bottom is None:
6871                 bottom = 0
6872 
6873             y[1:2*len(bins)-1:2] = y[2:2*len(bins):2] = bottom
6874             y[2*len(bins)-1:] = y[1:2*len(bins)-1][::-1]
6875 
6876             if log:
6877                 if orientation == 'horizontal':
6878                     self.set_xscale('log', nonpositive='clip')
6879                 else:  # orientation == 'vertical'
6880                     self.set_yscale('log', nonpositive='clip')
6881 
6882             if align == 'left':
6883                 x -= 0.5*(bins[1]-bins[0])
6884             elif align == 'right':
6885                 x += 0.5*(bins[1]-bins[0])
6886 
6887             # If fill kwarg is set, it will be passed to the patch collection,
6888             # overriding this
6889             fill = (histtype == 'stepfilled')
6890 
6891             xvals, yvals = [], []
6892             for top in tops:
6893                 if stacked:
6894                     # top of the previous polygon becomes the bottom
6895                     y[2*len(bins)-1:] = y[1:2*len(bins)-1][::-1]
6896                 # set the top of this polygon
6897                 y[1:2*len(bins)-1:2] = y[2:2*len(bins):2] = top + bottom
6898 
6899                 # The starting point of the polygon has not yet been
6900                 # updated. So far only the endpoint was adjusted. This
6901                 # assignment closes the polygon. The redundant endpoint is
6902                 # later discarded (for step and stepfilled).
6903                 y[0] = y[-1]
6904 
6905                 if orientation == 'horizontal':
6906                     xvals.append(y.copy())
6907                     yvals.append(x.copy())
6908                 else:
6909                     xvals.append(x.copy())
6910                     yvals.append(y.copy())
6911 
6912             # stepfill is closed, step is not
6913             split = -1 if fill else 2 * len(bins)
6914             # add patches in reverse order so that when stacking,
6915             # items lower in the stack are plotted on top of
6916             # items higher in the stack
6917             for x, y, color in reversed(list(zip(xvals, yvals, colors))):
6918                 patches.append(self.fill(
6919                     x[:split], y[:split],
6920                     closed=True if fill else None,
6921                     facecolor=color,
6922                     edgecolor=None if fill else color,
6923                     fill=fill if fill else None,
6924                     zorder=None if fill else mlines.Line2D.zorder))
6925             for patch_list in patches:
6926                 for patch in patch_list:
6927                     if orientation == 'vertical':
6928                         patch.sticky_edges.y.append(0)
6929                     elif orientation == 'horizontal':
6930                         patch.sticky_edges.x.append(0)
6931 
6932             # we return patches, so put it back in the expected order
6933             patches.reverse()
6934 
6935         # If None, make all labels None (via zip_longest below); otherwise,
6936         # cast each element to str, but keep a single str as it.
6937         labels = [] if label is None else np.atleast_1d(np.asarray(label, str))
6938         for patch, lbl in itertools.zip_longest(patches, labels):
6939             if patch:
6940                 p = patch[0]
6941                 p._internal_update(kwargs)
6942                 if lbl is not None:
6943                     p.set_label(lbl)
6944                 for p in patch[1:]:
6945                     p._internal_update(kwargs)
6946                     p.set_label('_nolegend_')
6947 
6948         if nx == 1:
6949             return tops[0], bins, patches[0]
6950         else:
6951             patch_type = ("BarContainer" if histtype.startswith("bar")
6952                           else "list[Polygon]")
6953             return tops, bins, cbook.silent_list(patch_type, patches)
6954 
6955     @_preprocess_data()
6956     def stairs(self, values, edges=None, *,
6957                orientation='vertical', baseline=0, fill=False, **kwargs):
6958         """
6959         A stepwise constant function as a line with bounding edges
6960         or a filled plot.
6961 
6962         Parameters
6963         ----------
6964         values : array-like
6965             The step heights.
6966 
6967         edges : array-like
6968             The edge positions, with ``len(edges) == len(vals) + 1``,
6969             between which the curve takes on vals values.
6970 
6971         orientation : {'vertical', 'horizontal'}, default: 'vertical'
6972             The direction of the steps. Vertical means that *values* are along
6973             the y-axis, and edges are along the x-axis.
6974 
6975         baseline : float, array-like or None, default: 0
6976             The bottom value of the bounding edges or when
6977             ``fill=True``, position of lower edge. If *fill* is
6978             True or an array is passed to *baseline*, a closed
6979             path is drawn.
6980 
6981         fill : bool, default: False
6982             Whether the area under the step curve should be filled.
6983 
6984         Returns
6985         -------
6986         StepPatch : `matplotlib.patches.StepPatch`
6987 
6988         Other Parameters
6989         ----------------
6990         data : indexable object, optional
6991             DATA_PARAMETER_PLACEHOLDER
6992 
6993         **kwargs
6994             `~matplotlib.patches.StepPatch` properties
6995 
6996         """
6997 
6998         if 'color' in kwargs:
6999             _color = kwargs.pop('color')
7000         else:
7001             _color = self._get_lines.get_next_color()
7002         if fill:
7003             kwargs.setdefault('linewidth', 0)
7004             kwargs.setdefault('facecolor', _color)
7005         else:
7006             kwargs.setdefault('edgecolor', _color)
7007 
7008         if edges is None:
7009             edges = np.arange(len(values) + 1)
7010 
7011         edges, values, baseline = self._process_unit_info(
7012             [("x", edges), ("y", values), ("y", baseline)], kwargs)
7013 
7014         patch = mpatches.StepPatch(values,
7015                                    edges,
7016                                    baseline=baseline,
7017                                    orientation=orientation,
7018                                    fill=fill,
7019                                    **kwargs)
7020         self.add_patch(patch)
7021         if baseline is None:
7022             baseline = 0
7023         if orientation == 'vertical':
7024             patch.sticky_edges.y.append(np.min(baseline))
7025             self.update_datalim([(edges[0], np.min(baseline))])
7026         else:
7027             patch.sticky_edges.x.append(np.min(baseline))
7028             self.update_datalim([(np.min(baseline), edges[0])])
7029         self._request_autoscale_view()
7030         return patch
7031 
7032     @_preprocess_data(replace_names=["x", "y", "weights"])
7033     @_docstring.dedent_interpd
7034     def hist2d(self, x, y, bins=10, range=None, density=False, weights=None,
7035                cmin=None, cmax=None, **kwargs):
7036         """
7037         Make a 2D histogram plot.
7038 
7039         Parameters
7040         ----------
7041         x, y : array-like, shape (n, )
7042             Input values
7043 
7044         bins : None or int or [int, int] or array-like or [array, array]
7045 
7046             The bin specification:
7047 
7048             - If int, the number of bins for the two dimensions
7049               (nx=ny=bins).
7050             - If ``[int, int]``, the number of bins in each dimension
7051               (nx, ny = bins).
7052             - If array-like, the bin edges for the two dimensions
7053               (x_edges=y_edges=bins).
7054             - If ``[array, array]``, the bin edges in each dimension
7055               (x_edges, y_edges = bins).
7056 
7057             The default value is 10.
7058 
7059         range : array-like shape(2, 2), optional
7060             The leftmost and rightmost edges of the bins along each dimension
7061             (if not specified explicitly in the bins parameters): ``[[xmin,
7062             xmax], [ymin, ymax]]``. All values outside of this range will be
7063             considered outliers and not tallied in the histogram.
7064 
7065         density : bool, default: False
7066             Normalize histogram.  See the documentation for the *density*
7067             parameter of `~.Axes.hist` for more details.
7068 
7069         weights : array-like, shape (n, ), optional
7070             An array of values w_i weighing each sample (x_i, y_i).
7071 
7072         cmin, cmax : float, default: None
7073             All bins that has count less than *cmin* or more than *cmax* will
7074             not be displayed (set to NaN before passing to imshow) and these
7075             count values in the return value count histogram will also be set
7076             to nan upon return.
7077 
7078         Returns
7079         -------
7080         h : 2D array
7081             The bi-dimensional histogram of samples x and y. Values in x are
7082             histogrammed along the first dimension and values in y are
7083             histogrammed along the second dimension.
7084         xedges : 1D array
7085             The bin edges along the x-axis.
7086         yedges : 1D array
7087             The bin edges along the y-axis.
7088         image : `~.matplotlib.collections.QuadMesh`
7089 
7090         Other Parameters
7091         ----------------
7092         %(cmap_doc)s
7093 
7094         %(norm_doc)s
7095 
7096         %(vmin_vmax_doc)s
7097 
7098         alpha : ``0 <= scalar <= 1`` or ``None``, optional
7099             The alpha blending value.
7100 
7101         data : indexable object, optional
7102             DATA_PARAMETER_PLACEHOLDER
7103 
7104         **kwargs
7105             Additional parameters are passed along to the
7106             `~.Axes.pcolormesh` method and `~matplotlib.collections.QuadMesh`
7107             constructor.
7108 
7109         See Also
7110         --------
7111         hist : 1D histogram plotting
7112         hexbin : 2D histogram with hexagonal bins
7113 
7114         Notes
7115         -----
7116         - Currently ``hist2d`` calculates its own axis limits, and any limits
7117           previously set are ignored.
7118         - Rendering the histogram with a logarithmic color scale is
7119           accomplished by passing a `.colors.LogNorm` instance to the *norm*
7120           keyword argument. Likewise, power-law normalization (similar
7121           in effect to gamma correction) can be accomplished with
7122           `.colors.PowerNorm`.
7123         """
7124 
7125         h, xedges, yedges = np.histogram2d(x, y, bins=bins, range=range,
7126                                            density=density, weights=weights)
7127 
7128         if cmin is not None:
7129             h[h < cmin] = None
7130         if cmax is not None:
7131             h[h > cmax] = None
7132 
7133         pc = self.pcolormesh(xedges, yedges, h.T, **kwargs)
7134         self.set_xlim(xedges[0], xedges[-1])
7135         self.set_ylim(yedges[0], yedges[-1])
7136 
7137         return h, xedges, yedges, pc
7138 
7139     @_preprocess_data(replace_names=["x"])
7140     @_docstring.dedent_interpd
7141     def psd(self, x, NFFT=None, Fs=None, Fc=None, detrend=None,
7142             window=None, noverlap=None, pad_to=None,
7143             sides=None, scale_by_freq=None, return_line=None, **kwargs):
7144         r"""
7145         Plot the power spectral density.
7146 
7147         The power spectral density :math:`P_{xx}` by Welch's average
7148         periodogram method.  The vector *x* is divided into *NFFT* length
7149         segments.  Each segment is detrended by function *detrend* and
7150         windowed by function *window*.  *noverlap* gives the length of
7151         the overlap between segments.  The :math:`|\mathrm{fft}(i)|^2`
7152         of each segment :math:`i` are averaged to compute :math:`P_{xx}`,
7153         with a scaling to correct for power loss due to windowing.
7154 
7155         If len(*x*) < *NFFT*, it will be zero padded to *NFFT*.
7156 
7157         Parameters
7158         ----------
7159         x : 1-D array or sequence
7160             Array or sequence containing the data
7161 
7162         %(Spectral)s
7163 
7164         %(PSD)s
7165 
7166         noverlap : int, default: 0 (no overlap)
7167             The number of points of overlap between segments.
7168 
7169         Fc : int, default: 0
7170             The center frequency of *x*, which offsets the x extents of the
7171             plot to reflect the frequency range used when a signal is acquired
7172             and then filtered and downsampled to baseband.
7173 
7174         return_line : bool, default: False
7175             Whether to include the line object plotted in the returned values.
7176 
7177         Returns
7178         -------
7179         Pxx : 1-D array
7180             The values for the power spectrum :math:`P_{xx}` before scaling
7181             (real valued).
7182 
7183         freqs : 1-D array
7184             The frequencies corresponding to the elements in *Pxx*.
7185 
7186         line : `~matplotlib.lines.Line2D`
7187             The line created by this function.
7188             Only returned if *return_line* is True.
7189 
7190         Other Parameters
7191         ----------------
7192         data : indexable object, optional
7193             DATA_PARAMETER_PLACEHOLDER
7194 
7195         **kwargs
7196             Keyword arguments control the `.Line2D` properties:
7197 
7198             %(Line2D:kwdoc)s
7199 
7200         See Also
7201         --------
7202         specgram
7203             Differs in the default overlap; in not returning the mean of the
7204             segment periodograms; in returning the times of the segments; and
7205             in plotting a colormap instead of a line.
7206         magnitude_spectrum
7207             Plots the magnitude spectrum.
7208         csd
7209             Plots the spectral density between two signals.
7210 
7211         Notes
7212         -----
7213         For plotting, the power is plotted as
7214         :math:`10\log_{10}(P_{xx})` for decibels, though *Pxx* itself
7215         is returned.
7216 
7217         References
7218         ----------
7219         Bendat & Piersol -- Random Data: Analysis and Measurement Procedures,
7220         John Wiley & Sons (1986)
7221         """
7222         if Fc is None:
7223             Fc = 0
7224 
7225         pxx, freqs = mlab.psd(x=x, NFFT=NFFT, Fs=Fs, detrend=detrend,
7226                               window=window, noverlap=noverlap, pad_to=pad_to,
7227                               sides=sides, scale_by_freq=scale_by_freq)
7228         freqs += Fc
7229 
7230         if scale_by_freq in (None, True):
7231             psd_units = 'dB/Hz'
7232         else:
7233             psd_units = 'dB'
7234 
7235         line = self.plot(freqs, 10 * np.log10(pxx), **kwargs)
7236         self.set_xlabel('Frequency')
7237         self.set_ylabel('Power Spectral Density (%s)' % psd_units)
7238         self.grid(True)
7239 
7240         vmin, vmax = self.get_ybound()
7241         step = max(10 * int(np.log10(vmax - vmin)), 1)
7242         ticks = np.arange(math.floor(vmin), math.ceil(vmax) + 1, step)
7243         self.set_yticks(ticks)
7244 
7245         if return_line is None or not return_line:
7246             return pxx, freqs
7247         else:
7248             return pxx, freqs, line
7249 
7250     @_preprocess_data(replace_names=["x", "y"], label_namer="y")
7251     @_docstring.dedent_interpd
7252     def csd(self, x, y, NFFT=None, Fs=None, Fc=None, detrend=None,
7253             window=None, noverlap=None, pad_to=None,
7254             sides=None, scale_by_freq=None, return_line=None, **kwargs):
7255         r"""
7256         Plot the cross-spectral density.
7257 
7258         The cross spectral density :math:`P_{xy}` by Welch's average
7259         periodogram method.  The vectors *x* and *y* are divided into
7260         *NFFT* length segments.  Each segment is detrended by function
7261         *detrend* and windowed by function *window*.  *noverlap* gives
7262         the length of the overlap between segments.  The product of
7263         the direct FFTs of *x* and *y* are averaged over each segment
7264         to compute :math:`P_{xy}`, with a scaling to correct for power
7265         loss due to windowing.
7266 
7267         If len(*x*) < *NFFT* or len(*y*) < *NFFT*, they will be zero
7268         padded to *NFFT*.
7269 
7270         Parameters
7271         ----------
7272         x, y : 1-D arrays or sequences
7273             Arrays or sequences containing the data.
7274 
7275         %(Spectral)s
7276 
7277         %(PSD)s
7278 
7279         noverlap : int, default: 0 (no overlap)
7280             The number of points of overlap between segments.
7281 
7282         Fc : int, default: 0
7283             The center frequency of *x*, which offsets the x extents of the
7284             plot to reflect the frequency range used when a signal is acquired
7285             and then filtered and downsampled to baseband.
7286 
7287         return_line : bool, default: False
7288             Whether to include the line object plotted in the returned values.
7289 
7290         Returns
7291         -------
7292         Pxy : 1-D array
7293             The values for the cross spectrum :math:`P_{xy}` before scaling
7294             (complex valued).
7295 
7296         freqs : 1-D array
7297             The frequencies corresponding to the elements in *Pxy*.
7298 
7299         line : `~matplotlib.lines.Line2D`
7300             The line created by this function.
7301             Only returned if *return_line* is True.
7302 
7303         Other Parameters
7304         ----------------
7305         data : indexable object, optional
7306             DATA_PARAMETER_PLACEHOLDER
7307 
7308         **kwargs
7309             Keyword arguments control the `.Line2D` properties:
7310 
7311             %(Line2D:kwdoc)s
7312 
7313         See Also
7314         --------
7315         psd : is equivalent to setting ``y = x``.
7316 
7317         Notes
7318         -----
7319         For plotting, the power is plotted as
7320         :math:`10 \log_{10}(P_{xy})` for decibels, though :math:`P_{xy}` itself
7321         is returned.
7322 
7323         References
7324         ----------
7325         Bendat & Piersol -- Random Data: Analysis and Measurement Procedures,
7326         John Wiley & Sons (1986)
7327         """
7328         if Fc is None:
7329             Fc = 0
7330 
7331         pxy, freqs = mlab.csd(x=x, y=y, NFFT=NFFT, Fs=Fs, detrend=detrend,
7332                               window=window, noverlap=noverlap, pad_to=pad_to,
7333                               sides=sides, scale_by_freq=scale_by_freq)
7334         # pxy is complex
7335         freqs += Fc
7336 
7337         line = self.plot(freqs, 10 * np.log10(np.abs(pxy)), **kwargs)
7338         self.set_xlabel('Frequency')
7339         self.set_ylabel('Cross Spectrum Magnitude (dB)')
7340         self.grid(True)
7341 
7342         vmin, vmax = self.get_ybound()
7343         step = max(10 * int(np.log10(vmax - vmin)), 1)
7344         ticks = np.arange(math.floor(vmin), math.ceil(vmax) + 1, step)
7345         self.set_yticks(ticks)
7346 
7347         if return_line is None or not return_line:
7348             return pxy, freqs
7349         else:
7350             return pxy, freqs, line
7351 
7352     @_preprocess_data(replace_names=["x"])
7353     @_docstring.dedent_interpd
7354     def magnitude_spectrum(self, x, Fs=None, Fc=None, window=None,
7355                            pad_to=None, sides=None, scale=None,
7356                            **kwargs):
7357         """
7358         Plot the magnitude spectrum.
7359 
7360         Compute the magnitude spectrum of *x*.  Data is padded to a
7361         length of *pad_to* and the windowing function *window* is applied to
7362         the signal.
7363 
7364         Parameters
7365         ----------
7366         x : 1-D array or sequence
7367             Array or sequence containing the data.
7368 
7369         %(Spectral)s
7370 
7371         %(Single_Spectrum)s
7372 
7373         scale : {'default', 'linear', 'dB'}
7374             The scaling of the values in the *spec*.  'linear' is no scaling.
7375             'dB' returns the values in dB scale, i.e., the dB amplitude
7376             (20 * log10). 'default' is 'linear'.
7377 
7378         Fc : int, default: 0
7379             The center frequency of *x*, which offsets the x extents of the
7380             plot to reflect the frequency range used when a signal is acquired
7381             and then filtered and downsampled to baseband.
7382 
7383         Returns
7384         -------
7385         spectrum : 1-D array
7386             The values for the magnitude spectrum before scaling (real valued).
7387 
7388         freqs : 1-D array
7389             The frequencies corresponding to the elements in *spectrum*.
7390 
7391         line : `~matplotlib.lines.Line2D`
7392             The line created by this function.
7393 
7394         Other Parameters
7395         ----------------
7396         data : indexable object, optional
7397             DATA_PARAMETER_PLACEHOLDER
7398 
7399         **kwargs
7400             Keyword arguments control the `.Line2D` properties:
7401 
7402             %(Line2D:kwdoc)s
7403 
7404         See Also
7405         --------
7406         psd
7407             Plots the power spectral density.
7408         angle_spectrum
7409             Plots the angles of the corresponding frequencies.
7410         phase_spectrum
7411             Plots the phase (unwrapped angle) of the corresponding frequencies.
7412         specgram
7413             Can plot the magnitude spectrum of segments within the signal in a
7414             colormap.
7415         """
7416         if Fc is None:
7417             Fc = 0
7418 
7419         spec, freqs = mlab.magnitude_spectrum(x=x, Fs=Fs, window=window,
7420                                               pad_to=pad_to, sides=sides)
7421         freqs += Fc
7422 
7423         yunits = _api.check_getitem(
7424             {None: 'energy', 'default': 'energy', 'linear': 'energy',
7425              'dB': 'dB'},
7426             scale=scale)
7427         if yunits == 'energy':
7428             Z = spec
7429         else:  # yunits == 'dB'
7430             Z = 20. * np.log10(spec)
7431 
7432         line, = self.plot(freqs, Z, **kwargs)
7433         self.set_xlabel('Frequency')
7434         self.set_ylabel('Magnitude (%s)' % yunits)
7435 
7436         return spec, freqs, line
7437 
7438     @_preprocess_data(replace_names=["x"])
7439     @_docstring.dedent_interpd
7440     def angle_spectrum(self, x, Fs=None, Fc=None, window=None,
7441                        pad_to=None, sides=None, **kwargs):
7442         """
7443         Plot the angle spectrum.
7444 
7445         Compute the angle spectrum (wrapped phase spectrum) of *x*.
7446         Data is padded to a length of *pad_to* and the windowing function
7447         *window* is applied to the signal.
7448 
7449         Parameters
7450         ----------
7451         x : 1-D array or sequence
7452             Array or sequence containing the data.
7453 
7454         %(Spectral)s
7455 
7456         %(Single_Spectrum)s
7457 
7458         Fc : int, default: 0
7459             The center frequency of *x*, which offsets the x extents of the
7460             plot to reflect the frequency range used when a signal is acquired
7461             and then filtered and downsampled to baseband.
7462 
7463         Returns
7464         -------
7465         spectrum : 1-D array
7466             The values for the angle spectrum in radians (real valued).
7467 
7468         freqs : 1-D array
7469             The frequencies corresponding to the elements in *spectrum*.
7470 
7471         line : `~matplotlib.lines.Line2D`
7472             The line created by this function.
7473 
7474         Other Parameters
7475         ----------------
7476         data : indexable object, optional
7477             DATA_PARAMETER_PLACEHOLDER
7478 
7479         **kwargs
7480             Keyword arguments control the `.Line2D` properties:
7481 
7482             %(Line2D:kwdoc)s
7483 
7484         See Also
7485         --------
7486         magnitude_spectrum
7487             Plots the magnitudes of the corresponding frequencies.
7488         phase_spectrum
7489             Plots the unwrapped version of this function.
7490         specgram
7491             Can plot the angle spectrum of segments within the signal in a
7492             colormap.
7493         """
7494         if Fc is None:
7495             Fc = 0
7496 
7497         spec, freqs = mlab.angle_spectrum(x=x, Fs=Fs, window=window,
7498                                           pad_to=pad_to, sides=sides)
7499         freqs += Fc
7500 
7501         lines = self.plot(freqs, spec, **kwargs)
7502         self.set_xlabel('Frequency')
7503         self.set_ylabel('Angle (radians)')
7504 
7505         return spec, freqs, lines[0]
7506 
7507     @_preprocess_data(replace_names=["x"])
7508     @_docstring.dedent_interpd
7509     def phase_spectrum(self, x, Fs=None, Fc=None, window=None,
7510                        pad_to=None, sides=None, **kwargs):
7511         """
7512         Plot the phase spectrum.
7513 
7514         Compute the phase spectrum (unwrapped angle spectrum) of *x*.
7515         Data is padded to a length of *pad_to* and the windowing function
7516         *window* is applied to the signal.
7517 
7518         Parameters
7519         ----------
7520         x : 1-D array or sequence
7521             Array or sequence containing the data
7522 
7523         %(Spectral)s
7524 
7525         %(Single_Spectrum)s
7526 
7527         Fc : int, default: 0
7528             The center frequency of *x*, which offsets the x extents of the
7529             plot to reflect the frequency range used when a signal is acquired
7530             and then filtered and downsampled to baseband.
7531 
7532         Returns
7533         -------
7534         spectrum : 1-D array
7535             The values for the phase spectrum in radians (real valued).
7536 
7537         freqs : 1-D array
7538             The frequencies corresponding to the elements in *spectrum*.
7539 
7540         line : `~matplotlib.lines.Line2D`
7541             The line created by this function.
7542 
7543         Other Parameters
7544         ----------------
7545         data : indexable object, optional
7546             DATA_PARAMETER_PLACEHOLDER
7547 
7548         **kwargs
7549             Keyword arguments control the `.Line2D` properties:
7550 
7551             %(Line2D:kwdoc)s
7552 
7553         See Also
7554         --------
7555         magnitude_spectrum
7556             Plots the magnitudes of the corresponding frequencies.
7557         angle_spectrum
7558             Plots the wrapped version of this function.
7559         specgram
7560             Can plot the phase spectrum of segments within the signal in a
7561             colormap.
7562         """
7563         if Fc is None:
7564             Fc = 0
7565 
7566         spec, freqs = mlab.phase_spectrum(x=x, Fs=Fs, window=window,
7567                                           pad_to=pad_to, sides=sides)
7568         freqs += Fc
7569 
7570         lines = self.plot(freqs, spec, **kwargs)
7571         self.set_xlabel('Frequency')
7572         self.set_ylabel('Phase (radians)')
7573 
7574         return spec, freqs, lines[0]
7575 
7576     @_preprocess_data(replace_names=["x", "y"])
7577     @_docstring.dedent_interpd
7578     def cohere(self, x, y, NFFT=256, Fs=2, Fc=0, detrend=mlab.detrend_none,
7579                window=mlab.window_hanning, noverlap=0, pad_to=None,
7580                sides='default', scale_by_freq=None, **kwargs):
7581         r"""
7582         Plot the coherence between *x* and *y*.
7583 
7584         Coherence is the normalized cross spectral density:
7585 
7586         .. math::
7587 
7588           C_{xy} = \frac{|P_{xy}|^2}{P_{xx}P_{yy}}
7589 
7590         Parameters
7591         ----------
7592         %(Spectral)s
7593 
7594         %(PSD)s
7595 
7596         noverlap : int, default: 0 (no overlap)
7597             The number of points of overlap between blocks.
7598 
7599         Fc : int, default: 0
7600             The center frequency of *x*, which offsets the x extents of the
7601             plot to reflect the frequency range used when a signal is acquired
7602             and then filtered and downsampled to baseband.
7603 
7604         Returns
7605         -------
7606         Cxy : 1-D array
7607             The coherence vector.
7608 
7609         freqs : 1-D array
7610             The frequencies for the elements in *Cxy*.
7611 
7612         Other Parameters
7613         ----------------
7614         data : indexable object, optional
7615             DATA_PARAMETER_PLACEHOLDER
7616 
7617         **kwargs
7618             Keyword arguments control the `.Line2D` properties:
7619 
7620             %(Line2D:kwdoc)s
7621 
7622         References
7623         ----------
7624         Bendat & Piersol -- Random Data: Analysis and Measurement Procedures,
7625         John Wiley & Sons (1986)
7626         """
7627         cxy, freqs = mlab.cohere(x=x, y=y, NFFT=NFFT, Fs=Fs, detrend=detrend,
7628                                  window=window, noverlap=noverlap,
7629                                  scale_by_freq=scale_by_freq, sides=sides,
7630                                  pad_to=pad_to)
7631         freqs += Fc
7632 
7633         self.plot(freqs, cxy, **kwargs)
7634         self.set_xlabel('Frequency')
7635         self.set_ylabel('Coherence')
7636         self.grid(True)
7637 
7638         return cxy, freqs
7639 
7640     @_preprocess_data(replace_names=["x"])
7641     @_docstring.dedent_interpd
7642     def specgram(self, x, NFFT=None, Fs=None, Fc=None, detrend=None,
7643                  window=None, noverlap=None,
7644                  cmap=None, xextent=None, pad_to=None, sides=None,
7645                  scale_by_freq=None, mode=None, scale=None,
7646                  vmin=None, vmax=None, **kwargs):
7647         """
7648         Plot a spectrogram.
7649 
7650         Compute and plot a spectrogram of data in *x*.  Data are split into
7651         *NFFT* length segments and the spectrum of each section is
7652         computed.  The windowing function *window* is applied to each
7653         segment, and the amount of overlap of each segment is
7654         specified with *noverlap*. The spectrogram is plotted as a colormap
7655         (using imshow).
7656 
7657         Parameters
7658         ----------
7659         x : 1-D array or sequence
7660             Array or sequence containing the data.
7661 
7662         %(Spectral)s
7663 
7664         %(PSD)s
7665 
7666         mode : {'default', 'psd', 'magnitude', 'angle', 'phase'}
7667             What sort of spectrum to use.  Default is 'psd', which takes the
7668             power spectral density.  'magnitude' returns the magnitude
7669             spectrum.  'angle' returns the phase spectrum without unwrapping.
7670             'phase' returns the phase spectrum with unwrapping.
7671 
7672         noverlap : int, default: 128
7673             The number of points of overlap between blocks.
7674 
7675         scale : {'default', 'linear', 'dB'}
7676             The scaling of the values in the *spec*.  'linear' is no scaling.
7677             'dB' returns the values in dB scale.  When *mode* is 'psd',
7678             this is dB power (10 * log10).  Otherwise, this is dB amplitude
7679             (20 * log10). 'default' is 'dB' if *mode* is 'psd' or
7680             'magnitude' and 'linear' otherwise.  This must be 'linear'
7681             if *mode* is 'angle' or 'phase'.
7682 
7683         Fc : int, default: 0
7684             The center frequency of *x*, which offsets the x extents of the
7685             plot to reflect the frequency range used when a signal is acquired
7686             and then filtered and downsampled to baseband.
7687 
7688         cmap : `.Colormap`, default: :rc:`image.cmap`
7689 
7690         xextent : *None* or (xmin, xmax)
7691             The image extent along the x-axis. The default sets *xmin* to the
7692             left border of the first bin (*spectrum* column) and *xmax* to the
7693             right border of the last bin. Note that for *noverlap>0* the width
7694             of the bins is smaller than those of the segments.
7695 
7696         data : indexable object, optional
7697             DATA_PARAMETER_PLACEHOLDER
7698 
7699         **kwargs
7700             Additional keyword arguments are passed on to `~.axes.Axes.imshow`
7701             which makes the specgram image. The origin keyword argument
7702             is not supported.
7703 
7704         Returns
7705         -------
7706         spectrum : 2D array
7707             Columns are the periodograms of successive segments.
7708 
7709         freqs : 1-D array
7710             The frequencies corresponding to the rows in *spectrum*.
7711 
7712         t : 1-D array
7713             The times corresponding to midpoints of segments (i.e., the columns
7714             in *spectrum*).
7715 
7716         im : `.AxesImage`
7717             The image created by imshow containing the spectrogram.
7718 
7719         See Also
7720         --------
7721         psd
7722             Differs in the default overlap; in returning the mean of the
7723             segment periodograms; in not returning times; and in generating a
7724             line plot instead of colormap.
7725         magnitude_spectrum
7726             A single spectrum, similar to having a single segment when *mode*
7727             is 'magnitude'. Plots a line instead of a colormap.
7728         angle_spectrum
7729             A single spectrum, similar to having a single segment when *mode*
7730             is 'angle'. Plots a line instead of a colormap.
7731         phase_spectrum
7732             A single spectrum, similar to having a single segment when *mode*
7733             is 'phase'. Plots a line instead of a colormap.
7734 
7735         Notes
7736         -----
7737         The parameters *detrend* and *scale_by_freq* do only apply when *mode*
7738         is set to 'psd'.
7739         """
7740         if NFFT is None:
7741             NFFT = 256  # same default as in mlab.specgram()
7742         if Fc is None:
7743             Fc = 0  # same default as in mlab._spectral_helper()
7744         if noverlap is None:
7745             noverlap = 128  # same default as in mlab.specgram()
7746         if Fs is None:
7747             Fs = 2  # same default as in mlab._spectral_helper()
7748 
7749         if mode == 'complex':
7750             raise ValueError('Cannot plot a complex specgram')
7751 
7752         if scale is None or scale == 'default':
7753             if mode in ['angle', 'phase']:
7754                 scale = 'linear'
7755             else:
7756                 scale = 'dB'
7757         elif mode in ['angle', 'phase'] and scale == 'dB':
7758             raise ValueError('Cannot use dB scale with angle or phase mode')
7759 
7760         spec, freqs, t = mlab.specgram(x=x, NFFT=NFFT, Fs=Fs,
7761                                        detrend=detrend, window=window,
7762                                        noverlap=noverlap, pad_to=pad_to,
7763                                        sides=sides,
7764                                        scale_by_freq=scale_by_freq,
7765                                        mode=mode)
7766 
7767         if scale == 'linear':
7768             Z = spec
7769         elif scale == 'dB':
7770             if mode is None or mode == 'default' or mode == 'psd':
7771                 Z = 10. * np.log10(spec)
7772             else:
7773                 Z = 20. * np.log10(spec)
7774         else:
7775             raise ValueError(f'Unknown scale {scale!r}')
7776 
7777         Z = np.flipud(Z)
7778 
7779         if xextent is None:
7780             # padding is needed for first and last segment:
7781             pad_xextent = (NFFT-noverlap) / Fs / 2
7782             xextent = np.min(t) - pad_xextent, np.max(t) + pad_xextent
7783         xmin, xmax = xextent
7784         freqs += Fc
7785         extent = xmin, xmax, freqs[0], freqs[-1]
7786 
7787         if 'origin' in kwargs:
7788             raise _api.kwarg_error("specgram", "origin")
7789 
7790         im = self.imshow(Z, cmap, extent=extent, vmin=vmin, vmax=vmax,
7791                          origin='upper', **kwargs)
7792         self.axis('auto')
7793 
7794         return spec, freqs, t, im
7795 
7796     @_docstring.dedent_interpd
7797     def spy(self, Z, precision=0, marker=None, markersize=None,
7798             aspect='equal', origin="upper", **kwargs):
7799         """
7800         Plot the sparsity pattern of a 2D array.
7801 
7802         This visualizes the non-zero values of the array.
7803 
7804         Two plotting styles are available: image and marker. Both
7805         are available for full arrays, but only the marker style
7806         works for `scipy.sparse.spmatrix` instances.
7807 
7808         **Image style**
7809 
7810         If *marker* and *markersize* are *None*, `~.Axes.imshow` is used. Any
7811         extra remaining keyword arguments are passed to this method.
7812 
7813         **Marker style**
7814 
7815         If *Z* is a `scipy.sparse.spmatrix` or *marker* or *markersize* are
7816         *None*, a `.Line2D` object will be returned with the value of marker
7817         determining the marker type, and any remaining keyword arguments
7818         passed to `~.Axes.plot`.
7819 
7820         Parameters
7821         ----------
7822         Z : (M, N) array-like
7823             The array to be plotted.
7824 
7825         precision : float or 'present', default: 0
7826             If *precision* is 0, any non-zero value will be plotted. Otherwise,
7827             values of :math:`|Z| > precision` will be plotted.
7828 
7829             For `scipy.sparse.spmatrix` instances, you can also
7830             pass 'present'. In this case any value present in the array
7831             will be plotted, even if it is identically zero.
7832 
7833         aspect : {'equal', 'auto', None} or float, default: 'equal'
7834             The aspect ratio of the Axes.  This parameter is particularly
7835             relevant for images since it determines whether data pixels are
7836             square.
7837 
7838             This parameter is a shortcut for explicitly calling
7839             `.Axes.set_aspect`. See there for further details.
7840 
7841             - 'equal': Ensures an aspect ratio of 1. Pixels will be square.
7842             - 'auto': The Axes is kept fixed and the aspect is adjusted so
7843               that the data fit in the Axes. In general, this will result in
7844               non-square pixels.
7845             - *None*: Use :rc:`image.aspect`.
7846 
7847         origin : {'upper', 'lower'}, default: :rc:`image.origin`
7848             Place the [0, 0] index of the array in the upper left or lower left
7849             corner of the Axes. The convention 'upper' is typically used for
7850             matrices and images.
7851 
7852         Returns
7853         -------
7854         `~matplotlib.image.AxesImage` or `.Line2D`
7855             The return type depends on the plotting style (see above).
7856 
7857         Other Parameters
7858         ----------------
7859         **kwargs
7860             The supported additional parameters depend on the plotting style.
7861 
7862             For the image style, you can pass the following additional
7863             parameters of `~.Axes.imshow`:
7864 
7865             - *cmap*
7866             - *alpha*
7867             - *url*
7868             - any `.Artist` properties (passed on to the `.AxesImage`)
7869 
7870             For the marker style, you can pass any `.Line2D` property except
7871             for *linestyle*:
7872 
7873             %(Line2D:kwdoc)s
7874         """
7875         if marker is None and markersize is None and hasattr(Z, 'tocoo'):
7876             marker = 's'
7877         _api.check_in_list(["upper", "lower"], origin=origin)
7878         if marker is None and markersize is None:
7879             Z = np.asarray(Z)
7880             mask = np.abs(Z) > precision
7881 
7882             if 'cmap' not in kwargs:
7883                 kwargs['cmap'] = mcolors.ListedColormap(['w', 'k'],
7884                                                         name='binary')
7885             if 'interpolation' in kwargs:
7886                 raise _api.kwarg_error("spy", "interpolation")
7887             if 'norm' not in kwargs:
7888                 kwargs['norm'] = mcolors.NoNorm()
7889             ret = self.imshow(mask, interpolation='nearest',
7890                               aspect=aspect, origin=origin,
7891                               **kwargs)
7892         else:
7893             if hasattr(Z, 'tocoo'):
7894                 c = Z.tocoo()
7895                 if precision == 'present':
7896                     y = c.row
7897                     x = c.col
7898                 else:
7899                     nonzero = np.abs(c.data) > precision
7900                     y = c.row[nonzero]
7901                     x = c.col[nonzero]
7902             else:
7903                 Z = np.asarray(Z)
7904                 nonzero = np.abs(Z) > precision
7905                 y, x = np.nonzero(nonzero)
7906             if marker is None:
7907                 marker = 's'
7908             if markersize is None:
7909                 markersize = 10
7910             if 'linestyle' in kwargs:
7911                 raise _api.kwarg_error("spy", "linestyle")
7912             ret = mlines.Line2D(
7913                 x, y, linestyle='None', marker=marker, markersize=markersize,
7914                 **kwargs)
7915             self.add_line(ret)
7916             nr, nc = Z.shape
7917             self.set_xlim(-0.5, nc - 0.5)
7918             if origin == "upper":
7919                 self.set_ylim(nr - 0.5, -0.5)
7920             else:
7921                 self.set_ylim(-0.5, nr - 0.5)
7922             self.set_aspect(aspect)
7923         self.title.set_y(1.05)
7924         if origin == "upper":
7925             self.xaxis.tick_top()
7926         else:  # lower
7927             self.xaxis.tick_bottom()
7928         self.xaxis.set_ticks_position('both')
7929         self.xaxis.set_major_locator(
7930             mticker.MaxNLocator(nbins=9, steps=[1, 2, 5, 10], integer=True))
7931         self.yaxis.set_major_locator(
7932             mticker.MaxNLocator(nbins=9, steps=[1, 2, 5, 10], integer=True))
7933         return ret
7934 
7935     def matshow(self, Z, **kwargs):
7936         """
7937         Plot the values of a 2D matrix or array as color-coded image.
7938 
7939         The matrix will be shown the way it would be printed, with the first
7940         row at the top.  Row and column numbering is zero-based.
7941 
7942         Parameters
7943         ----------
7944         Z : (M, N) array-like
7945             The matrix to be displayed.
7946 
7947         Returns
7948         -------
7949         `~matplotlib.image.AxesImage`
7950 
7951         Other Parameters
7952         ----------------
7953         **kwargs : `~matplotlib.axes.Axes.imshow` arguments
7954 
7955         See Also
7956         --------
7957         imshow : More general function to plot data on a 2D regular raster.
7958 
7959         Notes
7960         -----
7961         This is just a convenience function wrapping `.imshow` to set useful
7962         defaults for displaying a matrix. In particular:
7963 
7964         - Set ``origin='upper'``.
7965         - Set ``interpolation='nearest'``.
7966         - Set ``aspect='equal'``.
7967         - Ticks are placed to the left and above.
7968         - Ticks are formatted to show integer indices.
7969 
7970         """
7971         Z = np.asanyarray(Z)
7972         kw = {'origin': 'upper',
7973               'interpolation': 'nearest',
7974               'aspect': 'equal',          # (already the imshow default)
7975               **kwargs}
7976         im = self.imshow(Z, **kw)
7977         self.title.set_y(1.05)
7978         self.xaxis.tick_top()
7979         self.xaxis.set_ticks_position('both')
7980         self.xaxis.set_major_locator(
7981             mticker.MaxNLocator(nbins=9, steps=[1, 2, 5, 10], integer=True))
7982         self.yaxis.set_major_locator(
7983             mticker.MaxNLocator(nbins=9, steps=[1, 2, 5, 10], integer=True))
7984         return im
7985 
7986     @_preprocess_data(replace_names=["dataset"])
7987     def violinplot(self, dataset, positions=None, vert=True, widths=0.5,
7988                    showmeans=False, showextrema=True, showmedians=False,
7989                    quantiles=None, points=100, bw_method=None):
7990         """
7991         Make a violin plot.
7992 
7993         Make a violin plot for each column of *dataset* or each vector in
7994         sequence *dataset*.  Each filled area extends to represent the
7995         entire data range, with optional lines at the mean, the median,
7996         the minimum, the maximum, and user-specified quantiles.
7997 
7998         Parameters
7999         ----------
8000         dataset : Array or a sequence of vectors.
8001           The input data.
8002 
8003         positions : array-like, default: [1, 2, ..., n]
8004           The positions of the violins. The ticks and limits are
8005           automatically set to match the positions.
8006 
8007         vert : bool, default: True.
8008           If true, creates a vertical violin plot.
8009           Otherwise, creates a horizontal violin plot.
8010 
8011         widths : array-like, default: 0.5
8012           Either a scalar or a vector that sets the maximal width of
8013           each violin. The default is 0.5, which uses about half of the
8014           available horizontal space.
8015 
8016         showmeans : bool, default: False
8017           If `True`, will toggle rendering of the means.
8018 
8019         showextrema : bool, default: True
8020           If `True`, will toggle rendering of the extrema.
8021 
8022         showmedians : bool, default: False
8023           If `True`, will toggle rendering of the medians.
8024 
8025         quantiles : array-like, default: None
8026           If not None, set a list of floats in interval [0, 1] for each violin,
8027           which stands for the quantiles that will be rendered for that
8028           violin.
8029 
8030         points : int, default: 100
8031           Defines the number of points to evaluate each of the
8032           gaussian kernel density estimations at.
8033 
8034         bw_method : str, scalar or callable, optional
8035           The method used to calculate the estimator bandwidth.  This can be
8036           'scott', 'silverman', a scalar constant or a callable.  If a
8037           scalar, this will be used directly as `kde.factor`.  If a
8038           callable, it should take a `matplotlib.mlab.GaussianKDE` instance as
8039           its only parameter and return a scalar. If None (default), 'scott'
8040           is used.
8041 
8042         data : indexable object, optional
8043             DATA_PARAMETER_PLACEHOLDER
8044 
8045         Returns
8046         -------
8047         dict
8048           A dictionary mapping each component of the violinplot to a
8049           list of the corresponding collection instances created. The
8050           dictionary has the following keys:
8051 
8052           - ``bodies``: A list of the `~.collections.PolyCollection`
8053             instances containing the filled area of each violin.
8054 
8055           - ``cmeans``: A `~.collections.LineCollection` instance that marks
8056             the mean values of each of the violin's distribution.
8057 
8058           - ``cmins``: A `~.collections.LineCollection` instance that marks
8059             the bottom of each violin's distribution.
8060 
8061           - ``cmaxes``: A `~.collections.LineCollection` instance that marks
8062             the top of each violin's distribution.
8063 
8064           - ``cbars``: A `~.collections.LineCollection` instance that marks
8065             the centers of each violin's distribution.
8066 
8067           - ``cmedians``: A `~.collections.LineCollection` instance that
8068             marks the median values of each of the violin's distribution.
8069 
8070           - ``cquantiles``: A `~.collections.LineCollection` instance created
8071             to identify the quantile values of each of the violin's
8072             distribution.
8073 
8074         """
8075 
8076         def _kde_method(X, coords):
8077             # Unpack in case of e.g. Pandas or xarray object
8078             X = cbook._unpack_to_numpy(X)
8079             # fallback gracefully if the vector contains only one value
8080             if np.all(X[0] == X):
8081                 return (X[0] == coords).astype(float)
8082             kde = mlab.GaussianKDE(X, bw_method)
8083             return kde.evaluate(coords)
8084 
8085         vpstats = cbook.violin_stats(dataset, _kde_method, points=points,
8086                                      quantiles=quantiles)
8087         return self.violin(vpstats, positions=positions, vert=vert,
8088                            widths=widths, showmeans=showmeans,
8089                            showextrema=showextrema, showmedians=showmedians)
8090 
8091     def violin(self, vpstats, positions=None, vert=True, widths=0.5,
8092                showmeans=False, showextrema=True, showmedians=False):
8093         """
8094         Drawing function for violin plots.
8095 
8096         Draw a violin plot for each column of *vpstats*. Each filled area
8097         extends to represent the entire data range, with optional lines at the
8098         mean, the median, the minimum, the maximum, and the quantiles values.
8099 
8100         Parameters
8101         ----------
8102         vpstats : list of dicts
8103           A list of dictionaries containing stats for each violin plot.
8104           Required keys are:
8105 
8106           - ``coords``: A list of scalars containing the coordinates that
8107             the violin's kernel density estimate were evaluated at.
8108 
8109           - ``vals``: A list of scalars containing the values of the
8110             kernel density estimate at each of the coordinates given
8111             in *coords*.
8112 
8113           - ``mean``: The mean value for this violin's dataset.
8114 
8115           - ``median``: The median value for this violin's dataset.
8116 
8117           - ``min``: The minimum value for this violin's dataset.
8118 
8119           - ``max``: The maximum value for this violin's dataset.
8120 
8121           Optional keys are:
8122 
8123           - ``quantiles``: A list of scalars containing the quantile values
8124             for this violin's dataset.
8125 
8126         positions : array-like, default: [1, 2, ..., n]
8127           The positions of the violins. The ticks and limits are
8128           automatically set to match the positions.
8129 
8130         vert : bool, default: True.
8131           If true, plots the violins vertically.
8132           Otherwise, plots the violins horizontally.
8133 
8134         widths : array-like, default: 0.5
8135           Either a scalar or a vector that sets the maximal width of
8136           each violin. The default is 0.5, which uses about half of the
8137           available horizontal space.
8138 
8139         showmeans : bool, default: False
8140           If true, will toggle rendering of the means.
8141 
8142         showextrema : bool, default: True
8143           If true, will toggle rendering of the extrema.
8144 
8145         showmedians : bool, default: False
8146           If true, will toggle rendering of the medians.
8147 
8148         Returns
8149         -------
8150         dict
8151           A dictionary mapping each component of the violinplot to a
8152           list of the corresponding collection instances created. The
8153           dictionary has the following keys:
8154 
8155           - ``bodies``: A list of the `~.collections.PolyCollection`
8156             instances containing the filled area of each violin.
8157 
8158           - ``cmeans``: A `~.collections.LineCollection` instance that marks
8159             the mean values of each of the violin's distribution.
8160 
8161           - ``cmins``: A `~.collections.LineCollection` instance that marks
8162             the bottom of each violin's distribution.
8163 
8164           - ``cmaxes``: A `~.collections.LineCollection` instance that marks
8165             the top of each violin's distribution.
8166 
8167           - ``cbars``: A `~.collections.LineCollection` instance that marks
8168             the centers of each violin's distribution.
8169 
8170           - ``cmedians``: A `~.collections.LineCollection` instance that
8171             marks the median values of each of the violin's distribution.
8172 
8173           - ``cquantiles``: A `~.collections.LineCollection` instance created
8174             to identify the quantiles values of each of the violin's
8175             distribution.
8176         """
8177 
8178         # Statistical quantities to be plotted on the violins
8179         means = []
8180         mins = []
8181         maxes = []
8182         medians = []
8183         quantiles = []
8184 
8185         qlens = []  # Number of quantiles in each dataset.
8186 
8187         artists = {}  # Collections to be returned
8188 
8189         N = len(vpstats)
8190         datashape_message = ("List of violinplot statistics and `{0}` "
8191                              "values must have the same length")
8192 
8193         # Validate positions
8194         if positions is None:
8195             positions = range(1, N + 1)
8196         elif len(positions) != N:
8197             raise ValueError(datashape_message.format("positions"))
8198 
8199         # Validate widths
8200         if np.isscalar(widths):
8201             widths = [widths] * N
8202         elif len(widths) != N:
8203             raise ValueError(datashape_message.format("widths"))
8204 
8205         # Calculate ranges for statistics lines (shape (2, N)).
8206         line_ends = [[-0.25], [0.25]] * np.array(widths) + positions
8207 
8208         # Colors.
8209         if mpl.rcParams['_internal.classic_mode']:
8210             fillcolor = 'y'
8211             linecolor = 'r'
8212         else:
8213             fillcolor = linecolor = self._get_lines.get_next_color()
8214 
8215         # Check whether we are rendering vertically or horizontally
8216         if vert:
8217             fill = self.fill_betweenx
8218             perp_lines = functools.partial(self.hlines, colors=linecolor)
8219             par_lines = functools.partial(self.vlines, colors=linecolor)
8220         else:
8221             fill = self.fill_between
8222             perp_lines = functools.partial(self.vlines, colors=linecolor)
8223             par_lines = functools.partial(self.hlines, colors=linecolor)
8224 
8225         # Render violins
8226         bodies = []
8227         for stats, pos, width in zip(vpstats, positions, widths):
8228             # The 0.5 factor reflects the fact that we plot from v-p to v+p.
8229             vals = np.array(stats['vals'])
8230             vals = 0.5 * width * vals / vals.max()
8231             bodies += [fill(stats['coords'], -vals + pos, vals + pos,
8232                             facecolor=fillcolor, alpha=0.3)]
8233             means.append(stats['mean'])
8234             mins.append(stats['min'])
8235             maxes.append(stats['max'])
8236             medians.append(stats['median'])
8237             q = stats.get('quantiles')  # a list of floats, or None
8238             if q is None:
8239                 q = []
8240             quantiles.extend(q)
8241             qlens.append(len(q))
8242         artists['bodies'] = bodies
8243 
8244         if showmeans:  # Render means
8245             artists['cmeans'] = perp_lines(means, *line_ends)
8246         if showextrema:  # Render extrema
8247             artists['cmaxes'] = perp_lines(maxes, *line_ends)
8248             artists['cmins'] = perp_lines(mins, *line_ends)
8249             artists['cbars'] = par_lines(positions, mins, maxes)
8250         if showmedians:  # Render medians
8251             artists['cmedians'] = perp_lines(medians, *line_ends)
8252         if quantiles:  # Render quantiles: each width is repeated qlen times.
8253             artists['cquantiles'] = perp_lines(
8254                 quantiles, *np.repeat(line_ends, qlens, axis=1))
8255 
8256         return artists
8257 
8258     # Methods that are entirely implemented in other modules.
8259 
8260     table = mtable.table
8261 
8262     # args can be either Y or y1, y2, ... and all should be replaced
8263     stackplot = _preprocess_data()(mstack.stackplot)
8264 
8265     streamplot = _preprocess_data(
8266         replace_names=["x", "y", "u", "v", "start_points"])(mstream.streamplot)
8267 
8268     tricontour = mtri.tricontour
8269     tricontourf = mtri.tricontourf
8270     tripcolor = mtri.tripcolor
8271     triplot = mtri.triplot
8272 
8273     def _get_aspect_ratio(self):
8274         """
8275         Convenience method to calculate the aspect ratio of the axes in
8276         the display coordinate system.
8277         """
8278         figure_size = self.get_figure().get_size_inches()
8279         ll, ur = self.get_position() * figure_size
8280         width, height = ur - ll
8281         return height / (width * self.get_data_ratio())

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>]
2025-10-18 14:15:15.534 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-18 14:15:15.534 | INFO     | Search-only: skipping patch selection
2025-10-18 14:15:15.678 | INFO     | Task matplotlib__matplotlib-25346 completed successfully.
2025-10-18 14:15:15.679 | INFO     | No patch generated. You can try running ACR again.
