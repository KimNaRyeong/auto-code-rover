[
    {
        "rel_file_path": "django/core/files/storage.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.0/django/core/files/storage.py",
        "start": 226,
        "end": 287,
        "class_name": "FileSystemStorage",
        "method_name": "_save",
        "code": "226     def _save(self, name, content):\n227         full_path = self.path(name)\n228 \n229         # Create any intermediate directories that do not exist.\n230         directory = os.path.dirname(full_path)\n231         try:\n232             if self.directory_permissions_mode is not None:\n233                 # os.makedirs applies the global umask, so we reset it,\n234                 # for consistency with file_permissions_mode behavior.\n235                 old_umask = os.umask(0)\n236                 try:\n237                     os.makedirs(directory, self.directory_permissions_mode, exist_ok=True)\n238                 finally:\n239                     os.umask(old_umask)\n240             else:\n241                 os.makedirs(directory, exist_ok=True)\n242         except FileExistsError:\n243             raise FileExistsError('%s exists and is not a directory.' % directory)\n244 \n245         # There's a potential race condition between get_available_name and\n246         # saving the file; it's possible that two threads might return the\n247         # same name, at which point all sorts of fun happens. So we need to\n248         # try to create the file, but if it already exists we have to go back\n249         # to get_available_name() and try again.\n250 \n251         while True:\n252             try:\n253                 # This file has a file path that we can move.\n254                 if hasattr(content, 'temporary_file_path'):\n255                     file_move_safe(content.temporary_file_path(), full_path)\n256 \n257                 # This is a normal uploadedfile that we can stream.\n258                 else:\n259                     # The current umask value is masked out by os.open!\n260                     fd = os.open(full_path, self.OS_OPEN_FLAGS, 0o666)\n261                     _file = None\n262                     try:\n263                         locks.lock(fd, locks.LOCK_EX)\n264                         for chunk in content.chunks():\n265                             if _file is None:\n266                                 mode = 'wb' if isinstance(chunk, bytes) else 'wt'\n267                                 _file = os.fdopen(fd, mode)\n268                             _file.write(chunk)\n269                     finally:\n270                         locks.unlock(fd)\n271                         if _file is not None:\n272                             _file.close()\n273                         else:\n274                             os.close(fd)\n275             except FileExistsError:\n276                 # A new name is needed if the file exists.\n277                 name = self.get_available_name(name)\n278                 full_path = self.path(name)\n279             else:\n280                 # OK, the file save worked. Break out of the loop.\n281                 break\n282 \n283         if self.file_permissions_mode is not None:\n284             os.chmod(full_path, self.file_permissions_mode)\n285 \n286         # Store filenames with forward slashes, even on Windows.\n287         return name.replace('\\\\', '/')\n",
        "intended_behavior": "To resolve the issue, `_save` should ensure that after a file is moved from temporary storage to its final destination, the file permissions should be explicitly set to `0o644` (or whatever is configured in `FILE_UPLOAD_PERMISSIONS`). This ensures consistency regardless of the temporary storage mechanism used (`MemoryUploadedFile` or `TemporaryUploadedFile`). The existing functionality of `_save`, which includes handling file saving and integrity checks, should remain intact. After moving a file using `os.rename` or any similar method, an additional step should be added to enforce the permissions as specified."
    },
    {
        "rel_file_path": "django/core/files/storage.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.0/django/core/files/storage.py",
        "start": 170,
        "end": 348,
        "class_name": "FileSystemStorage",
        "method_name": null,
        "code": "170 class FileSystemStorage(Storage):\n171     \"\"\"\n172     Standard filesystem storage\n173     \"\"\"\n174     # The combination of O_CREAT and O_EXCL makes os.open() raise OSError if\n175     # the file already exists before it's opened.\n176     OS_OPEN_FLAGS = os.O_WRONLY | os.O_CREAT | os.O_EXCL | getattr(os, 'O_BINARY', 0)\n177 \n178     def __init__(self, location=None, base_url=None, file_permissions_mode=None,\n179                  directory_permissions_mode=None):\n180         self._location = location\n181         self._base_url = base_url\n182         self._file_permissions_mode = file_permissions_mode\n183         self._directory_permissions_mode = directory_permissions_mode\n184         setting_changed.connect(self._clear_cached_properties)\n185 \n186     def _clear_cached_properties(self, setting, **kwargs):\n187         \"\"\"Reset setting based property values.\"\"\"\n188         if setting == 'MEDIA_ROOT':\n189             self.__dict__.pop('base_location', None)\n190             self.__dict__.pop('location', None)\n191         elif setting == 'MEDIA_URL':\n192             self.__dict__.pop('base_url', None)\n193         elif setting == 'FILE_UPLOAD_PERMISSIONS':\n194             self.__dict__.pop('file_permissions_mode', None)\n195         elif setting == 'FILE_UPLOAD_DIRECTORY_PERMISSIONS':\n196             self.__dict__.pop('directory_permissions_mode', None)\n197 \n198     def _value_or_setting(self, value, setting):\n199         return setting if value is None else value\n200 \n201     @cached_property\n202     def base_location(self):\n203         return self._value_or_setting(self._location, settings.MEDIA_ROOT)\n204 \n205     @cached_property\n206     def location(self):\n207         return os.path.abspath(self.base_location)\n208 \n209     @cached_property\n210     def base_url(self):\n211         if self._base_url is not None and not self._base_url.endswith('/'):\n212             self._base_url += '/'\n213         return self._value_or_setting(self._base_url, settings.MEDIA_URL)\n214 \n215     @cached_property\n216     def file_permissions_mode(self):\n217         return self._value_or_setting(self._file_permissions_mode, settings.FILE_UPLOAD_PERMISSIONS)\n218 \n219     @cached_property\n220     def directory_permissions_mode(self):\n221         return self._value_or_setting(self._directory_permissions_mode, settings.FILE_UPLOAD_DIRECTORY_PERMISSIONS)\n222 \n223     def _open(self, name, mode='rb'):\n224         return File(open(self.path(name), mode))\n225 \n226     def _save(self, name, content):\n227         full_path = self.path(name)\n228 \n229         # Create any intermediate directories that do not exist.\n230         directory = os.path.dirname(full_path)\n231         try:\n232             if self.directory_permissions_mode is not None:\n233                 # os.makedirs applies the global umask, so we reset it,\n234                 # for consistency with file_permissions_mode behavior.\n235                 old_umask = os.umask(0)\n236                 try:\n237                     os.makedirs(directory, self.directory_permissions_mode, exist_ok=True)\n238                 finally:\n239                     os.umask(old_umask)\n240             else:\n241                 os.makedirs(directory, exist_ok=True)\n242         except FileExistsError:\n243             raise FileExistsError('%s exists and is not a directory.' % directory)\n244 \n245         # There's a potential race condition between get_available_name and\n246         # saving the file; it's possible that two threads might return the\n247         # same name, at which point all sorts of fun happens. So we need to\n248         # try to create the file, but if it already exists we have to go back\n249         # to get_available_name() and try again.\n250 \n251         while True:\n252             try:\n253                 # This file has a file path that we can move.\n254                 if hasattr(content, 'temporary_file_path'):\n255                     file_move_safe(content.temporary_file_path(), full_path)\n256 \n257                 # This is a normal uploadedfile that we can stream.\n258                 else:\n259                     # The current umask value is masked out by os.open!\n260                     fd = os.open(full_path, self.OS_OPEN_FLAGS, 0o666)\n261                     _file = None\n262                     try:\n263                         locks.lock(fd, locks.LOCK_EX)\n264                         for chunk in content.chunks():\n265                             if _file is None:\n266                                 mode = 'wb' if isinstance(chunk, bytes) else 'wt'\n267                                 _file = os.fdopen(fd, mode)\n268                             _file.write(chunk)\n269                     finally:\n270                         locks.unlock(fd)\n271                         if _file is not None:\n272                             _file.close()\n273                         else:\n274                             os.close(fd)\n275             except FileExistsError:\n276                 # A new name is needed if the file exists.\n277                 name = self.get_available_name(name)\n278                 full_path = self.path(name)\n279             else:\n280                 # OK, the file save worked. Break out of the loop.\n281                 break\n282 \n283         if self.file_permissions_mode is not None:\n284             os.chmod(full_path, self.file_permissions_mode)\n285 \n286         # Store filenames with forward slashes, even on Windows.\n287         return name.replace('\\\\', '/')\n288 \n289     def delete(self, name):\n290         assert name, \"The name argument is not allowed to be empty.\"\n291         name = self.path(name)\n292         # If the file or directory exists, delete it from the filesystem.\n293         try:\n294             if os.path.isdir(name):\n295                 os.rmdir(name)\n296             else:\n297                 os.remove(name)\n298         except FileNotFoundError:\n299             # FileNotFoundError is raised if the file or directory was removed\n300             # concurrently.\n301             pass\n302 \n303     def exists(self, name):\n304         return os.path.exists(self.path(name))\n305 \n306     def listdir(self, path):\n307         path = self.path(path)\n308         directories, files = [], []\n309         for entry in os.scandir(path):\n310             if entry.is_dir():\n311                 directories.append(entry.name)\n312             else:\n313                 files.append(entry.name)\n314         return directories, files\n315 \n316     def path(self, name):\n317         return safe_join(self.location, name)\n318 \n319     def size(self, name):\n320         return os.path.getsize(self.path(name))\n321 \n322     def url(self, name):\n323         if self.base_url is None:\n324             raise ValueError(\"This file is not accessible via a URL.\")\n325         url = filepath_to_uri(name)\n326         if url is not None:\n327             url = url.lstrip('/')\n328         return urljoin(self.base_url, url)\n329 \n330     def _datetime_from_timestamp(self, ts):\n331         \"\"\"\n332         If timezone support is enabled, make an aware datetime object in UTC;\n333         otherwise make a naive one in the local timezone.\n334         \"\"\"\n335         if settings.USE_TZ:\n336             # Safe to use .replace() because UTC doesn't have DST\n337             return datetime.utcfromtimestamp(ts).replace(tzinfo=timezone.utc)\n338         else:\n339             return datetime.fromtimestamp(ts)\n340 \n341     def get_accessed_time(self, name):\n342         return self._datetime_from_timestamp(os.path.getatime(self.path(name)))\n343 \n344     def get_created_time(self, name):\n345         return self._datetime_from_timestamp(os.path.getctime(self.path(name)))\n346 \n347     def get_modified_time(self, name):\n348         return self._datetime_from_timestamp(os.path.getmtime(self.path(name)))\n",
        "intended_behavior": "This class provides additional context to the issue."
    },
    {
        "rel_file_path": "django/core/files/move.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.0/django/core/files/move.py",
        "start": 1,
        "end": 87,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\"\n2 Move a file in the safest way possible::\n3 \n4     >>> from django.core.files.move import file_move_safe\n5     >>> file_move_safe(\"/tmp/old_file\", \"/tmp/new_file\")\n6 \"\"\"\n7 \n8 import errno\n9 import os\n10 from shutil import copystat\n11 \n12 from django.core.files import locks\n13 \n14 __all__ = ['file_move_safe']\n15 \n16 \n17 def _samefile(src, dst):\n18     # Macintosh, Unix.\n19     if hasattr(os.path, 'samefile'):\n20         try:\n21             return os.path.samefile(src, dst)\n22         except OSError:\n23             return False\n24 \n25     # All other platforms: check for same pathname.\n26     return (os.path.normcase(os.path.abspath(src)) ==\n27             os.path.normcase(os.path.abspath(dst)))\n28 \n29 \n30 def file_move_safe(old_file_name, new_file_name, chunk_size=1024 * 64, allow_overwrite=False):\n31     \"\"\"\n32     Move a file from one location to another in the safest way possible.\n33 \n34     First, try ``os.rename``, which is simple but will break across filesystems.\n35     If that fails, stream manually from one file to another in pure Python.\n36 \n37     If the destination file exists and ``allow_overwrite`` is ``False``, raise\n38     ``FileExistsError``.\n39     \"\"\"\n40     # There's no reason to move if we don't have to.\n41     if _samefile(old_file_name, new_file_name):\n42         return\n43 \n44     try:\n45         if not allow_overwrite and os.access(new_file_name, os.F_OK):\n46             raise FileExistsError('Destination file %s exists and allow_overwrite is False.' % new_file_name)\n47 \n48         os.rename(old_file_name, new_file_name)\n49         return\n50     except OSError:\n51         # OSError happens with os.rename() if moving to another filesystem or\n52         # when moving opened files on certain operating systems.\n53         pass\n54 \n55     # first open the old file, so that it won't go away\n56     with open(old_file_name, 'rb') as old_file:\n57         # now open the new file, not forgetting allow_overwrite\n58         fd = os.open(new_file_name, (os.O_WRONLY | os.O_CREAT | getattr(os, 'O_BINARY', 0) |\n59                                      (os.O_EXCL if not allow_overwrite else 0)))\n60         try:\n61             locks.lock(fd, locks.LOCK_EX)\n62             current_chunk = None\n63             while current_chunk != b'':\n64                 current_chunk = old_file.read(chunk_size)\n65                 os.write(fd, current_chunk)\n66         finally:\n67             locks.unlock(fd)\n68             os.close(fd)\n69 \n70     try:\n71         copystat(old_file_name, new_file_name)\n72     except PermissionError as e:\n73         # Certain filesystems (e.g. CIFS) fail to copy the file's metadata if\n74         # the type of the destination filesystem isn't the same as the source\n75         # filesystem; ignore that.\n76         if e.errno != errno.EPERM:\n77             raise\n78 \n79     try:\n80         os.remove(old_file_name)\n81     except PermissionError as e:\n82         # Certain operating systems (Cygwin and Windows)\n83         # fail when deleting opened files, ignore it.  (For the\n84         # systems where this happens, temporary files will be auto-deleted\n85         # on close anyway.)\n86         if getattr(e, 'winerror', 0) != 32:\n87             raise\n",
        "intended_behavior": "Wherever `os.rename` is used for moving the uploaded file from temporary to permanent storage, the operation should be followed up by setting the file permissions explicitly to maintain the permissions consistency. If permissions are not actively managed post `os.rename`, there should be a mechanism or wrapper around `os.rename` to ensure file permissions are set according to the `FILE_UPLOAD_PERMISSIONS` setting or default to `0o644` immediately following the move. This adjustment will prevent the permissions from being inadvertently restricted due to the defaults applied by `tempfile.NamedTemporaryFile` and maintained by `os.rename`."
    }
]