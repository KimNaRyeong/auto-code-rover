[
    {
        "rel_file_path": "django/db/migrations/writer.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.2/django/db/migrations/writer.py",
        "start": 1,
        "end": 300,
        "class_name": null,
        "method_name": null,
        "code": "1 \n2 import os\n3 import re\n4 from importlib import import_module\n5 \n6 from django import get_version\n7 from django.apps import apps\n8 # SettingsReference imported for backwards compatibility in Django 2.2.\n9 from django.conf import SettingsReference  # NOQA\n10 from django.db import migrations\n11 from django.db.migrations.loader import MigrationLoader\n12 from django.db.migrations.serializer import Serializer, serializer_factory\n13 from django.utils.inspect import get_func_args\n14 from django.utils.module_loading import module_dir\n15 from django.utils.timezone import now\n16 \n17 \n18 class OperationWriter:\n19     def __init__(self, operation, indentation=2):\n20         self.operation = operation\n21         self.buff = []\n22         self.indentation = indentation\n23 \n24     def serialize(self):\n25 \n26         def _write(_arg_name, _arg_value):\n27             if (_arg_name in self.operation.serialization_expand_args and\n28                     isinstance(_arg_value, (list, tuple, dict))):\n29                 if isinstance(_arg_value, dict):\n30                     self.feed('%s={' % _arg_name)\n31                     self.indent()\n32                     for key, value in _arg_value.items():\n33                         key_string, key_imports = MigrationWriter.serialize(key)\n34                         arg_string, arg_imports = MigrationWriter.serialize(value)\n35                         args = arg_string.splitlines()\n36                         if len(args) > 1:\n37                             self.feed('%s: %s' % (key_string, args[0]))\n38                             for arg in args[1:-1]:\n39                                 self.feed(arg)\n40                             self.feed('%s,' % args[-1])\n41                         else:\n42                             self.feed('%s: %s,' % (key_string, arg_string))\n43                         imports.update(key_imports)\n44                         imports.update(arg_imports)\n45                     self.unindent()\n46                     self.feed('},')\n47                 else:\n48                     self.feed('%s=[' % _arg_name)\n49                     self.indent()\n50                     for item in _arg_value:\n51                         arg_string, arg_imports = MigrationWriter.serialize(item)\n52                         args = arg_string.splitlines()\n53                         if len(args) > 1:\n54                             for arg in args[:-1]:\n55                                 self.feed(arg)\n56                             self.feed('%s,' % args[-1])\n57                         else:\n58                             self.feed('%s,' % arg_string)\n59                         imports.update(arg_imports)\n60                     self.unindent()\n61                     self.feed('],')\n62             else:\n63                 arg_string, arg_imports = MigrationWriter.serialize(_arg_value)\n64                 args = arg_string.splitlines()\n65                 if len(args) > 1:\n66                     self.feed('%s=%s' % (_arg_name, args[0]))\n67                     for arg in args[1:-1]:\n68                         self.feed(arg)\n69                     self.feed('%s,' % args[-1])\n70                 else:\n71                     self.feed('%s=%s,' % (_arg_name, arg_string))\n72                 imports.update(arg_imports)\n73 \n74         imports = set()\n75         name, args, kwargs = self.operation.deconstruct()\n76         operation_args = get_func_args(self.operation.__init__)\n77 \n78         # See if this operation is in django.db.migrations. If it is,\n79         # We can just use the fact we already have that imported,\n80         # otherwise, we need to add an import for the operation class.\n81         if getattr(migrations, name, None) == self.operation.__class__:\n82             self.feed('migrations.%s(' % name)\n83         else:\n84             imports.add('import %s' % (self.operation.__class__.__module__))\n85             self.feed('%s.%s(' % (self.operation.__class__.__module__, name))\n86 \n87         self.indent()\n88 \n89         for i, arg in enumerate(args):\n90             arg_value = arg\n91             arg_name = operation_args[i]\n92             _write(arg_name, arg_value)\n93 \n94         i = len(args)\n95         # Only iterate over remaining arguments\n96         for arg_name in operation_args[i:]:\n97             if arg_name in kwargs:  # Don't sort to maintain signature order\n98                 arg_value = kwargs[arg_name]\n99                 _write(arg_name, arg_value)\n100 \n101         self.unindent()\n102         self.feed('),')\n103         return self.render(), imports\n104 \n105     def indent(self):\n106         self.indentation += 1\n107 \n108     def unindent(self):\n109         self.indentation -= 1\n110 \n111     def feed(self, line):\n112         self.buff.append(' ' * (self.indentation * 4) + line)\n113 \n114     def render(self):\n115         return '\\n'.join(self.buff)\n116 \n117 \n118 class MigrationWriter:\n119     \"\"\"\n120     Take a Migration instance and is able to produce the contents\n121     of the migration file from it.\n122     \"\"\"\n123 \n124     def __init__(self, migration, include_header=True):\n125         self.migration = migration\n126         self.include_header = include_header\n127         self.needs_manual_porting = False\n128 \n129     def as_string(self):\n130         \"\"\"Return a string of the file contents.\"\"\"\n131         items = {\n132             \"replaces_str\": \"\",\n133             \"initial_str\": \"\",\n134         }\n135 \n136         imports = set()\n137 \n138         # Deconstruct operations\n139         operations = []\n140         for operation in self.migration.operations:\n141             operation_string, operation_imports = OperationWriter(operation).serialize()\n142             imports.update(operation_imports)\n143             operations.append(operation_string)\n144         items[\"operations\"] = \"\\n\".join(operations) + \"\\n\" if operations else \"\"\n145 \n146         # Format dependencies and write out swappable dependencies right\n147         dependencies = []\n148         for dependency in self.migration.dependencies:\n149             if dependency[0] == \"__setting__\":\n150                 dependencies.append(\"        migrations.swappable_dependency(settings.%s),\" % dependency[1])\n151                 imports.add(\"from django.conf import settings\")\n152             else:\n153                 dependencies.append(\"        %s,\" % self.serialize(dependency)[0])\n154         items[\"dependencies\"] = \"\\n\".join(dependencies) + \"\\n\" if dependencies else \"\"\n155 \n156         # Format imports nicely, swapping imports of functions from migration files\n157         # for comments\n158         migration_imports = set()\n159         for line in list(imports):\n160             if re.match(r\"^import (.*)\\.\\d+[^\\s]*$\", line):\n161                 migration_imports.add(line.split(\"import\")[1].strip())\n162                 imports.remove(line)\n163                 self.needs_manual_porting = True\n164 \n165         # django.db.migrations is always used, but models import may not be.\n166         # If models import exists, merge it with migrations import.\n167         if \"from django.db import models\" in imports:\n168             imports.discard(\"from django.db import models\")\n169             imports.add(\"from django.db import migrations, models\")\n170         else:\n171             imports.add(\"from django.db import migrations\")\n172 \n173         # Sort imports by the package / module to be imported (the part after\n174         # \"from\" in \"from ... import ...\" or after \"import\" in \"import ...\").\n175         sorted_imports = sorted(imports, key=lambda i: i.split()[1])\n176         items[\"imports\"] = \"\\n\".join(sorted_imports) + \"\\n\" if imports else \"\"\n177         if migration_imports:\n178             items[\"imports\"] += (\n179                 \"\\n\\n# Functions from the following migrations need manual \"\n180                 \"copying.\\n# Move them and any dependencies into this file, \"\n181                 \"then update the\\n# RunPython operations to refer to the local \"\n182                 \"versions:\\n# %s\"\n183             ) % \"\\n# \".join(sorted(migration_imports))\n184         # If there's a replaces, make a string for it\n185         if self.migration.replaces:\n186             items['replaces_str'] = \"\\n    replaces = %s\\n\" % self.serialize(self.migration.replaces)[0]\n187         # Hinting that goes into comment\n188         if self.include_header:\n189             items['migration_header'] = MIGRATION_HEADER_TEMPLATE % {\n190                 'version': get_version(),\n191                 'timestamp': now().strftime(\"%Y-%m-%d %H:%M\"),\n192             }\n193         else:\n194             items['migration_header'] = \"\"\n195 \n196         if self.migration.initial:\n197             items['initial_str'] = \"\\n    initial = True\\n\"\n198 \n199         return MIGRATION_TEMPLATE % items\n200 \n201     @property\n202     def basedir(self):\n203         migrations_package_name, _ = MigrationLoader.migrations_module(self.migration.app_label)\n204 \n205         if migrations_package_name is None:\n206             raise ValueError(\n207                 \"Django can't create migrations for app '%s' because \"\n208                 \"migrations have been disabled via the MIGRATION_MODULES \"\n209                 \"setting.\" % self.migration.app_label\n210             )\n211 \n212         # See if we can import the migrations module directly\n213         try:\n214             migrations_module = import_module(migrations_package_name)\n215         except ImportError:\n216             pass\n217         else:\n218             try:\n219                 return module_dir(migrations_module)\n220             except ValueError:\n221                 pass\n222 \n223         # Alright, see if it's a direct submodule of the app\n224         app_config = apps.get_app_config(self.migration.app_label)\n225         maybe_app_name, _, migrations_package_basename = migrations_package_name.rpartition(\".\")\n226         if app_config.name == maybe_app_name:\n227             return os.path.join(app_config.path, migrations_package_basename)\n228 \n229         # In case of using MIGRATION_MODULES setting and the custom package\n230         # doesn't exist, create one, starting from an existing package\n231         existing_dirs, missing_dirs = migrations_package_name.split(\".\"), []\n232         while existing_dirs:\n233             missing_dirs.insert(0, existing_dirs.pop(-1))\n234             try:\n235                 base_module = import_module(\".\".join(existing_dirs))\n236             except (ImportError, ValueError):\n237                 continue\n238             else:\n239                 try:\n240                     base_dir = module_dir(base_module)\n241                 except ValueError:\n242                     continue\n243                 else:\n244                     break\n245         else:\n246             raise ValueError(\n247                 \"Could not locate an appropriate location to create \"\n248                 \"migrations package %s. Make sure the toplevel \"\n249                 \"package exists and can be imported.\" %\n250                 migrations_package_name)\n251 \n252         final_dir = os.path.join(base_dir, *missing_dirs)\n253         os.makedirs(final_dir, exist_ok=True)\n254         for missing_dir in missing_dirs:\n255             base_dir = os.path.join(base_dir, missing_dir)\n256             with open(os.path.join(base_dir, \"__init__.py\"), \"w\"):\n257                 pass\n258 \n259         return final_dir\n260 \n261     @property\n262     def filename(self):\n263         return \"%s.py\" % self.migration.name\n264 \n265     @property\n266     def path(self):\n267         return os.path.join(self.basedir, self.filename)\n268 \n269     @classmethod\n270     def serialize(cls, value):\n271         return serializer_factory(value).serialize()\n272 \n273     @classmethod\n274     def register_serializer(cls, type_, serializer):\n275         Serializer.register(type_, serializer)\n276 \n277     @classmethod\n278     def unregister_serializer(cls, type_):\n279         Serializer.unregister(type_)\n280 \n281 \n282 MIGRATION_HEADER_TEMPLATE = \"\"\"\\\n283 # Generated by Django %(version)s on %(timestamp)s\n284 \n285 \"\"\"\n286 \n287 \n288 MIGRATION_TEMPLATE = \"\"\"\\\n289 %(migration_header)s%(imports)s\n290 \n291 class Migration(migrations.Migration):\n292 %(replaces_str)s%(initial_str)s\n293     dependencies = [\n294 %(dependencies)s\\\n295     ]\n296 \n297     operations = [\n298 %(operations)s\\\n299     ]\n300 \"\"\"\n",
        "intended_behavior": "The new implementation should construct filenames by combining the names of the migrations being merged, ensuring the generated name provides clearer insight into the nature of the merge without needing to inspect the file's content."
    },
    {
        "rel_file_path": "django/db/migrations/migration.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.2/django/db/migrations/migration.py",
        "start": 1,
        "end": 213,
        "class_name": null,
        "method_name": null,
        "code": "1 from django.db.migrations import operations\n2 from django.db.migrations.utils import get_migration_name_timestamp\n3 from django.db.transaction import atomic\n4 \n5 from .exceptions import IrreversibleError\n6 \n7 \n8 class Migration:\n9     \"\"\"\n10     The base class for all migrations.\n11 \n12     Migration files will import this from django.db.migrations.Migration\n13     and subclass it as a class called Migration. It will have one or more\n14     of the following attributes:\n15 \n16      - operations: A list of Operation instances, probably from django.db.migrations.operations\n17      - dependencies: A list of tuples of (app_path, migration_name)\n18      - run_before: A list of tuples of (app_path, migration_name)\n19      - replaces: A list of migration_names\n20 \n21     Note that all migrations come out of migrations and into the Loader or\n22     Graph as instances, having been initialized with their app label and name.\n23     \"\"\"\n24 \n25     # Operations to apply during this migration, in order.\n26     operations = []\n27 \n28     # Other migrations that should be run before this migration.\n29     # Should be a list of (app, migration_name).\n30     dependencies = []\n31 \n32     # Other migrations that should be run after this one (i.e. have\n33     # this migration added to their dependencies). Useful to make third-party\n34     # apps' migrations run after your AUTH_USER replacement, for example.\n35     run_before = []\n36 \n37     # Migration names in this app that this migration replaces. If this is\n38     # non-empty, this migration will only be applied if all these migrations\n39     # are not applied.\n40     replaces = []\n41 \n42     # Is this an initial migration? Initial migrations are skipped on\n43     # --fake-initial if the table or fields already exist. If None, check if\n44     # the migration has any dependencies to determine if there are dependencies\n45     # to tell if db introspection needs to be done. If True, always perform\n46     # introspection. If False, never perform introspection.\n47     initial = None\n48 \n49     # Whether to wrap the whole migration in a transaction. Only has an effect\n50     # on database backends which support transactional DDL.\n51     atomic = True\n52 \n53     def __init__(self, name, app_label):\n54         self.name = name\n55         self.app_label = app_label\n56         # Copy dependencies & other attrs as we might mutate them at runtime\n57         self.operations = list(self.__class__.operations)\n58         self.dependencies = list(self.__class__.dependencies)\n59         self.run_before = list(self.__class__.run_before)\n60         self.replaces = list(self.__class__.replaces)\n61 \n62     def __eq__(self, other):\n63         return (\n64             isinstance(other, Migration) and\n65             self.name == other.name and\n66             self.app_label == other.app_label\n67         )\n68 \n69     def __repr__(self):\n70         return \"<Migration %s.%s>\" % (self.app_label, self.name)\n71 \n72     def __str__(self):\n73         return \"%s.%s\" % (self.app_label, self.name)\n74 \n75     def __hash__(self):\n76         return hash(\"%s.%s\" % (self.app_label, self.name))\n77 \n78     def mutate_state(self, project_state, preserve=True):\n79         \"\"\"\n80         Take a ProjectState and return a new one with the migration's\n81         operations applied to it. Preserve the original object state by\n82         default and return a mutated state from a copy.\n83         \"\"\"\n84         new_state = project_state\n85         if preserve:\n86             new_state = project_state.clone()\n87 \n88         for operation in self.operations:\n89             operation.state_forwards(self.app_label, new_state)\n90         return new_state\n91 \n92     def apply(self, project_state, schema_editor, collect_sql=False):\n93         \"\"\"\n94         Take a project_state representing all migrations prior to this one\n95         and a schema_editor for a live database and apply the migration\n96         in a forwards order.\n97 \n98         Return the resulting project state for efficient reuse by following\n99         Migrations.\n100         \"\"\"\n101         for operation in self.operations:\n102             # If this operation cannot be represented as SQL, place a comment\n103             # there instead\n104             if collect_sql:\n105                 schema_editor.collected_sql.append(\"--\")\n106                 if not operation.reduces_to_sql:\n107                     schema_editor.collected_sql.append(\n108                         \"-- MIGRATION NOW PERFORMS OPERATION THAT CANNOT BE WRITTEN AS SQL:\"\n109                     )\n110                 schema_editor.collected_sql.append(\"-- %s\" % operation.describe())\n111                 schema_editor.collected_sql.append(\"--\")\n112                 if not operation.reduces_to_sql:\n113                     continue\n114             # Save the state before the operation has run\n115             old_state = project_state.clone()\n116             operation.state_forwards(self.app_label, project_state)\n117             # Run the operation\n118             atomic_operation = operation.atomic or (self.atomic and operation.atomic is not False)\n119             if not schema_editor.atomic_migration and atomic_operation:\n120                 # Force a transaction on a non-transactional-DDL backend or an\n121                 # atomic operation inside a non-atomic migration.\n122                 with atomic(schema_editor.connection.alias):\n123                     operation.database_forwards(self.app_label, schema_editor, old_state, project_state)\n124             else:\n125                 # Normal behaviour\n126                 operation.database_forwards(self.app_label, schema_editor, old_state, project_state)\n127         return project_state\n128 \n129     def unapply(self, project_state, schema_editor, collect_sql=False):\n130         \"\"\"\n131         Take a project_state representing all migrations prior to this one\n132         and a schema_editor for a live database and apply the migration\n133         in a reverse order.\n134 \n135         The backwards migration process consists of two phases:\n136 \n137         1. The intermediate states from right before the first until right\n138            after the last operation inside this migration are preserved.\n139         2. The operations are applied in reverse order using the states\n140            recorded in step 1.\n141         \"\"\"\n142         # Construct all the intermediate states we need for a reverse migration\n143         to_run = []\n144         new_state = project_state\n145         # Phase 1\n146         for operation in self.operations:\n147             # If it's irreversible, error out\n148             if not operation.reversible:\n149                 raise IrreversibleError(\"Operation %s in %s is not reversible\" % (operation, self))\n150             # Preserve new state from previous run to not tamper the same state\n151             # over all operations\n152             new_state = new_state.clone()\n153             old_state = new_state.clone()\n154             operation.state_forwards(self.app_label, new_state)\n155             to_run.insert(0, (operation, old_state, new_state))\n156 \n157         # Phase 2\n158         for operation, to_state, from_state in to_run:\n159             if collect_sql:\n160                 schema_editor.collected_sql.append(\"--\")\n161                 if not operation.reduces_to_sql:\n162                     schema_editor.collected_sql.append(\n163                         \"-- MIGRATION NOW PERFORMS OPERATION THAT CANNOT BE WRITTEN AS SQL:\"\n164                     )\n165                 schema_editor.collected_sql.append(\"-- %s\" % operation.describe())\n166                 schema_editor.collected_sql.append(\"--\")\n167                 if not operation.reduces_to_sql:\n168                     continue\n169             atomic_operation = operation.atomic or (self.atomic and operation.atomic is not False)\n170             if not schema_editor.atomic_migration and atomic_operation:\n171                 # Force a transaction on a non-transactional-DDL backend or an\n172                 # atomic operation inside a non-atomic migration.\n173                 with atomic(schema_editor.connection.alias):\n174                     operation.database_backwards(self.app_label, schema_editor, from_state, to_state)\n175             else:\n176                 # Normal behaviour\n177                 operation.database_backwards(self.app_label, schema_editor, from_state, to_state)\n178         return project_state\n179 \n180     def suggest_name(self):\n181         \"\"\"\n182         Suggest a name for the operations this migration might represent. Names\n183         are not guaranteed to be unique, but put some effort into the fallback\n184         name to avoid VCS conflicts if possible.\n185         \"\"\"\n186         name = None\n187         if len(self.operations) == 1:\n188             name = self.operations[0].migration_name_fragment\n189         elif (\n190             len(self.operations) > 1 and\n191             all(isinstance(o, operations.CreateModel) for o in self.operations)\n192         ):\n193             name = '_'.join(sorted(o.migration_name_fragment for o in self.operations))\n194         if name is None:\n195             name = 'initial' if self.initial else 'auto_%s' % get_migration_name_timestamp()\n196         return name\n197 \n198 \n199 class SwappableTuple(tuple):\n200     \"\"\"\n201     Subclass of tuple so Django can tell this was originally a swappable\n202     dependency when it reads the migration file.\n203     \"\"\"\n204 \n205     def __new__(cls, value, setting):\n206         self = tuple.__new__(cls, value)\n207         self.setting = setting\n208         return self\n209 \n210 \n211 def swappable_dependency(value):\n212     \"\"\"Turn a setting value into a dependency.\"\"\"\n213     return SwappableTuple((value.split(\".\", 1)[0], \"__first__\"), value)\n",
        "intended_behavior": "Ensure the structures in this file can handle, recognize, and work with the new naming scheme without disrupting the functionality of migrations."
    }
]