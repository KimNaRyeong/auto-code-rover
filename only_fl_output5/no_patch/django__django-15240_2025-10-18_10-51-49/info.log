2025-10-18 10:51:50.077 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-18 10:51:53.080 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=474, output_tokens=12, cost=0.005100
2025-10-18 10:51:53.080 | INFO     | Test agent decides that the issue statement does not contain reproduction steps; skipping reproducer tracing
2025-10-18 10:51:53.084 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 10:52:00.912 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=782, output_tokens=321, cost=0.017450
2025-10-18 10:52:00.920 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 10:52:03.086 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=675, output_tokens=61, cost=0.008580
2025-10-18 10:52:03.087 | DEBUG    | Extracted a valid json.
2025-10-18 10:52:03.087 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_class(\"MigrationExecutor\")",
        "search_method_in_class(\"apply_migration\", \"MigrationExecutor\")",
        "search_method(\"squashmigrations\")",
        "search_code(\"django_migrations\")"
    ],
    "bug_locations": []
}
2025-10-18 10:52:03.141 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-18 10:52:03.142 | DEBUG    | <Agent search> Analyzing search results.
2025-10-18 10:52:20.116 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1821, output_tokens=779, cost=0.041580
2025-10-18 10:52:20.130 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 10:52:30.614 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2816, output_tokens=496, cost=0.043040
2025-10-18 10:52:30.623 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 10:52:39.687 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=850, output_tokens=390, cost=0.020200
2025-10-18 10:52:39.688 | DEBUG    | Extracted a valid json.
2025-10-18 10:52:39.688 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_method_in_class(\"record_migration\", \"MigrationExecutor\")",
        "search_class(\"MigrationRecorder\")"
    ],
    "bug_locations":[
        {
            "file": "django/db/migrations/executor.py",
            "class": "MigrationExecutor",
            "method": "apply_migration",
            "intended_behavior": "This method should be modified to include a check after applying a migration: before recording a migration as applied, verify if the migration file exists in the project. If the file does not exist but the migration is still about to be recorded (ideal for squashed migrations that are replaced), it should check if the migration is listed as a replacement (replaces attribute in a migration file). If it's a case of naming conflict (identical naming as a previously squashed and deleted migration), then extra care should be taken not to skip applying it by mistake. Additionally, there could be an automatic cleanup process either before or after migrations are applied to remove any records from django_migrations that do not have a corresponding migration file in the project and are not mentioned in the replaces list of an existing migration."
        },
        {
            "file": "django/db/migrations/recorder.py",
            "class": "MigrationRecorder",
            "method": "",
            "intended_behavior": "Introduce a new method or adjust existing logic to facilitate the cleanup of the django_migrations table to only include migrations that either exist in the Django project or are referenced in the replaces attribute of squashed migrations. This method should be carefully designed to run as part of the migration application process without causing disruptive behavior, such as accidentally re-applying squashed migrations. Ideally, it would be a part of the migration application process (possibly hooked in the MigrationExecutor workflow) to ensure the database reflects only the migrations that are relevant to the current state of the project."
        }
    ]
}
2025-10-18 10:52:39.703 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-18 10:52:39.704 | DEBUG    | <Agent search> Analyzing search results.
2025-10-18 10:52:53.914 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=3712, output_tokens=660, cost=0.056920
2025-10-18 10:52:53.926 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 10:53:03.205 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=4588, output_tokens=385, cost=0.057430
2025-10-18 10:53:03.214 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 10:53:11.144 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=739, output_tokens=316, cost=0.016870
2025-10-18 10:53:11.145 | DEBUG    | Extracted a valid json.
2025-10-18 10:53:11.145 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations":[
        {
            "file": "django/db/migrations/executor.py",
            "class": "MigrationExecutor",
            "method": "record_migration",
            "intended_behavior": "Enhance the 'record_migration' method to include a verification step before recording migrations as applied. This step should check whether each migration mentioned in the 'replaces' list still exists within the migration directory. If a migration file does not exist (and is not part of a squashed migration's 'replaces' list), the method should not record it in the 'django_migrations' table. This preserves the functionality of accurately tracking applied migrations while preventing inaccuracies due to deleted migration files."
        },
        {
            "file": "django/db/migrations/recorder.py",
            "class": "",
            "method": "",
            "intended_behavior": "Implement a new method within 'MigrationRecorder' named something like 'cleanup_nonexistent_migrations'. This method should iterate over entries in the 'django_migrations' table, compare them with the migration files present in the project, and remove any entries that do not have a corresponding migration file and are not listed in the 'replaces' attribute of squashed migrations. This method could be called from the 'MigrationExecutor' before or after the migration process to ensure the 'django_migrations' table remains accurate, facilitating the automatic cleanup of the table to reflect only extant migrations or those explicitly replaced in the context of squashed migrations."
        }
    ]
}
2025-10-18 10:53:11.151 | DEBUG    | Bug location extracted successfully: [<file>django/db/migrations/executor.py</file>
<class>MigrationExecutor</class>
<method>record_migration</method>
<code>
251     def record_migration(self, migration):
252         # For replacement migrations, record individual statuses
253         if migration.replaces:
254             for app_label, name in migration.replaces:
255                 self.recorder.record_applied(app_label, name)
256         else:
257             self.recorder.record_applied(migration.app_label, migration.name)

</code><intended_behavior>Enhance the 'record_migration' method to include a verification step before recording migrations as applied. This step should check whether each migration mentioned in the 'replaces' list still exists within the migration directory. If a migration file does not exist (and is not part of a squashed migration's 'replaces' list), the method should not record it in the 'django_migrations' table. This preserves the functionality of accurately tracking applied migrations while preventing inaccuracies due to deleted migration files.</intended_behavior>, <file>django/db/migrations/executor.py</file>
<class>MigrationExecutor</class>
<method>None</method>
<code>
10 class MigrationExecutor:
11     """
12     End-to-end migration execution - load migrations and run them up or down
13     to a specified set of targets.
14     """
15 
16     def __init__(self, connection, progress_callback=None):
17         self.connection = connection
18         self.loader = MigrationLoader(self.connection)
19         self.recorder = MigrationRecorder(self.connection)
20         self.progress_callback = progress_callback
21 
22     def migration_plan(self, targets, clean_start=False):
23         """
24         Given a set of targets, return a list of (Migration instance, backwards?).
25         """
26         plan = []
27         if clean_start:
28             applied = {}
29         else:
30             applied = dict(self.loader.applied_migrations)
31         for target in targets:
32             # If the target is (app_label, None), that means unmigrate everything
33             if target[1] is None:
34                 for root in self.loader.graph.root_nodes():
35                     if root[0] == target[0]:
36                         for migration in self.loader.graph.backwards_plan(root):
37                             if migration in applied:
38                                 plan.append((self.loader.graph.nodes[migration], True))
39                                 applied.pop(migration)
40             # If the migration is already applied, do backwards mode,
41             # otherwise do forwards mode.
42             elif target in applied:
43                 # If the target is missing, it's likely a replaced migration.
44                 # Reload the graph without replacements.
45                 if (
46                     self.loader.replace_migrations and
47                     target not in self.loader.graph.node_map
48                 ):
49                     self.loader.replace_migrations = False
50                     self.loader.build_graph()
51                     return self.migration_plan(targets, clean_start=clean_start)
52                 # Don't migrate backwards all the way to the target node (that
53                 # may roll back dependencies in other apps that don't need to
54                 # be rolled back); instead roll back through target's immediate
55                 # child(ren) in the same app, and no further.
56                 next_in_app = sorted(
57                     n for n in
58                     self.loader.graph.node_map[target].children
59                     if n[0] == target[0]
60                 )
61                 for node in next_in_app:
62                     for migration in self.loader.graph.backwards_plan(node):
63                         if migration in applied:
64                             plan.append((self.loader.graph.nodes[migration], True))
65                             applied.pop(migration)
66             else:
67                 for migration in self.loader.graph.forwards_plan(target):
68                     if migration not in applied:
69                         plan.append((self.loader.graph.nodes[migration], False))
70                         applied[migration] = self.loader.graph.nodes[migration]
71         return plan
72 
73     def _create_project_state(self, with_applied_migrations=False):
74         """
75         Create a project state including all the applications without
76         migrations and applied migrations if with_applied_migrations=True.
77         """
78         state = ProjectState(real_apps=self.loader.unmigrated_apps)
79         if with_applied_migrations:
80             # Create the forwards plan Django would follow on an empty database
81             full_plan = self.migration_plan(self.loader.graph.leaf_nodes(), clean_start=True)
82             applied_migrations = {
83                 self.loader.graph.nodes[key] for key in self.loader.applied_migrations
84                 if key in self.loader.graph.nodes
85             }
86             for migration, _ in full_plan:
87                 if migration in applied_migrations:
88                     migration.mutate_state(state, preserve=False)
89         return state
90 
91     def migrate(self, targets, plan=None, state=None, fake=False, fake_initial=False):
92         """
93         Migrate the database up to the given targets.
94 
95         Django first needs to create all project states before a migration is
96         (un)applied and in a second step run all the database operations.
97         """
98         # The django_migrations table must be present to record applied
99         # migrations, but don't create it if there are no migrations to apply.
100         if plan == []:
101             if not self.recorder.has_table():
102                 return self._create_project_state(with_applied_migrations=False)
103         else:
104             self.recorder.ensure_schema()
105 
106         if plan is None:
107             plan = self.migration_plan(targets)
108         # Create the forwards plan Django would follow on an empty database
109         full_plan = self.migration_plan(self.loader.graph.leaf_nodes(), clean_start=True)
110 
111         all_forwards = all(not backwards for mig, backwards in plan)
112         all_backwards = all(backwards for mig, backwards in plan)
113 
114         if not plan:
115             if state is None:
116                 # The resulting state should include applied migrations.
117                 state = self._create_project_state(with_applied_migrations=True)
118         elif all_forwards == all_backwards:
119             # This should only happen if there's a mixed plan
120             raise InvalidMigrationPlan(
121                 "Migration plans with both forwards and backwards migrations "
122                 "are not supported. Please split your migration process into "
123                 "separate plans of only forwards OR backwards migrations.",
124                 plan
125             )
126         elif all_forwards:
127             if state is None:
128                 # The resulting state should still include applied migrations.
129                 state = self._create_project_state(with_applied_migrations=True)
130             state = self._migrate_all_forwards(state, plan, full_plan, fake=fake, fake_initial=fake_initial)
131         else:
132             # No need to check for `elif all_backwards` here, as that condition
133             # would always evaluate to true.
134             state = self._migrate_all_backwards(plan, full_plan, fake=fake)
135 
136         self.check_replacements()
137 
138         return state
139 
140     def _migrate_all_forwards(self, state, plan, full_plan, fake, fake_initial):
141         """
142         Take a list of 2-tuples of the form (migration instance, False) and
143         apply them in the order they occur in the full_plan.
144         """
145         migrations_to_run = {m[0] for m in plan}
146         for migration, _ in full_plan:
147             if not migrations_to_run:
148                 # We remove every migration that we applied from these sets so
149                 # that we can bail out once the last migration has been applied
150                 # and don't always run until the very end of the migration
151                 # process.
152                 break
153             if migration in migrations_to_run:
154                 if 'apps' not in state.__dict__:
155                     if self.progress_callback:
156                         self.progress_callback("render_start")
157                     state.apps  # Render all -- performance critical
158                     if self.progress_callback:
159                         self.progress_callback("render_success")
160                 state = self.apply_migration(state, migration, fake=fake, fake_initial=fake_initial)
161                 migrations_to_run.remove(migration)
162 
163         return state
164 
165     def _migrate_all_backwards(self, plan, full_plan, fake):
166         """
167         Take a list of 2-tuples of the form (migration instance, True) and
168         unapply them in reverse order they occur in the full_plan.
169 
170         Since unapplying a migration requires the project state prior to that
171         migration, Django will compute the migration states before each of them
172         in a first run over the plan and then unapply them in a second run over
173         the plan.
174         """
175         migrations_to_run = {m[0] for m in plan}
176         # Holds all migration states prior to the migrations being unapplied
177         states = {}
178         state = self._create_project_state()
179         applied_migrations = {
180             self.loader.graph.nodes[key] for key in self.loader.applied_migrations
181             if key in self.loader.graph.nodes
182         }
183         if self.progress_callback:
184             self.progress_callback("render_start")
185         for migration, _ in full_plan:
186             if not migrations_to_run:
187                 # We remove every migration that we applied from this set so
188                 # that we can bail out once the last migration has been applied
189                 # and don't always run until the very end of the migration
190                 # process.
191                 break
192             if migration in migrations_to_run:
193                 if 'apps' not in state.__dict__:
194                     state.apps  # Render all -- performance critical
195                 # The state before this migration
196                 states[migration] = state
197                 # The old state keeps as-is, we continue with the new state
198                 state = migration.mutate_state(state, preserve=True)
199                 migrations_to_run.remove(migration)
200             elif migration in applied_migrations:
201                 # Only mutate the state if the migration is actually applied
202                 # to make sure the resulting state doesn't include changes
203                 # from unrelated migrations.
204                 migration.mutate_state(state, preserve=False)
205         if self.progress_callback:
206             self.progress_callback("render_success")
207 
208         for migration, _ in plan:
209             self.unapply_migration(states[migration], migration, fake=fake)
210             applied_migrations.remove(migration)
211 
212         # Generate the post migration state by starting from the state before
213         # the last migration is unapplied and mutating it to include all the
214         # remaining applied migrations.
215         last_unapplied_migration = plan[-1][0]
216         state = states[last_unapplied_migration]
217         for index, (migration, _) in enumerate(full_plan):
218             if migration == last_unapplied_migration:
219                 for migration, _ in full_plan[index:]:
220                     if migration in applied_migrations:
221                         migration.mutate_state(state, preserve=False)
222                 break
223 
224         return state
225 
226     def apply_migration(self, state, migration, fake=False, fake_initial=False):
227         """Run a migration forwards."""
228         migration_recorded = False
229         if self.progress_callback:
230             self.progress_callback("apply_start", migration, fake)
231         if not fake:
232             if fake_initial:
233                 # Test to see if this is an already-applied initial migration
234                 applied, state = self.detect_soft_applied(state, migration)
235                 if applied:
236                     fake = True
237             if not fake:
238                 # Alright, do it normally
239                 with self.connection.schema_editor(atomic=migration.atomic) as schema_editor:
240                     state = migration.apply(state, schema_editor)
241                     if not schema_editor.deferred_sql:
242                         self.record_migration(migration)
243                         migration_recorded = True
244         if not migration_recorded:
245             self.record_migration(migration)
246         # Report progress
247         if self.progress_callback:
248             self.progress_callback("apply_success", migration, fake)
249         return state
250 
251     def record_migration(self, migration):
252         # For replacement migrations, record individual statuses
253         if migration.replaces:
254             for app_label, name in migration.replaces:
255                 self.recorder.record_applied(app_label, name)
256         else:
257             self.recorder.record_applied(migration.app_label, migration.name)
258 
259     def unapply_migration(self, state, migration, fake=False):
260         """Run a migration backwards."""
261         if self.progress_callback:
262             self.progress_callback("unapply_start", migration, fake)
263         if not fake:
264             with self.connection.schema_editor(atomic=migration.atomic) as schema_editor:
265                 state = migration.unapply(state, schema_editor)
266         # For replacement migrations, also record individual statuses.
267         if migration.replaces:
268             for app_label, name in migration.replaces:
269                 self.recorder.record_unapplied(app_label, name)
270         self.recorder.record_unapplied(migration.app_label, migration.name)
271         # Report progress
272         if self.progress_callback:
273             self.progress_callback("unapply_success", migration, fake)
274         return state
275 
276     def check_replacements(self):
277         """
278         Mark replacement migrations applied if their replaced set all are.
279 
280         Do this unconditionally on every migrate, rather than just when
281         migrations are applied or unapplied, to correctly handle the case
282         when a new squash migration is pushed to a deployment that already had
283         all its replaced migrations applied. In this case no new migration will
284         be applied, but the applied state of the squashed migration must be
285         maintained.
286         """
287         applied = self.recorder.applied_migrations()
288         for key, migration in self.loader.replacements.items():
289             all_applied = all(m in applied for m in migration.replaces)
290             if all_applied and key not in applied:
291                 self.recorder.record_applied(*key)
292 
293     def detect_soft_applied(self, project_state, migration):
294         """
295         Test whether a migration has been implicitly applied - that the
296         tables or columns it would create exist. This is intended only for use
297         on initial migrations (as it only looks for CreateModel and AddField).
298         """
299         def should_skip_detecting_model(migration, model):
300             """
301             No need to detect tables for proxy models, unmanaged models, or
302             models that can't be migrated on the current database.
303             """
304             return (
305                 model._meta.proxy or not model._meta.managed or not
306                 router.allow_migrate(
307                     self.connection.alias, migration.app_label,
308                     model_name=model._meta.model_name,
309                 )
310             )
311 
312         if migration.initial is None:
313             # Bail if the migration isn't the first one in its app
314             if any(app == migration.app_label for app, name in migration.dependencies):
315                 return False, project_state
316         elif migration.initial is False:
317             # Bail if it's NOT an initial migration
318             return False, project_state
319 
320         if project_state is None:
321             after_state = self.loader.project_state((migration.app_label, migration.name), at_end=True)
322         else:
323             after_state = migration.mutate_state(project_state)
324         apps = after_state.apps
325         found_create_model_migration = False
326         found_add_field_migration = False
327         fold_identifier_case = self.connection.features.ignores_table_name_case
328         with self.connection.cursor() as cursor:
329             existing_table_names = set(self.connection.introspection.table_names(cursor))
330             if fold_identifier_case:
331                 existing_table_names = {name.casefold() for name in existing_table_names}
332         # Make sure all create model and add field operations are done
333         for operation in migration.operations:
334             if isinstance(operation, migrations.CreateModel):
335                 model = apps.get_model(migration.app_label, operation.name)
336                 if model._meta.swapped:
337                     # We have to fetch the model to test with from the
338                     # main app cache, as it's not a direct dependency.
339                     model = global_apps.get_model(model._meta.swapped)
340                 if should_skip_detecting_model(migration, model):
341                     continue
342                 db_table = model._meta.db_table
343                 if fold_identifier_case:
344                     db_table = db_table.casefold()
345                 if db_table not in existing_table_names:
346                     return False, project_state
347                 found_create_model_migration = True
348             elif isinstance(operation, migrations.AddField):
349                 model = apps.get_model(migration.app_label, operation.model_name)
350                 if model._meta.swapped:
351                     # We have to fetch the model to test with from the
352                     # main app cache, as it's not a direct dependency.
353                     model = global_apps.get_model(model._meta.swapped)
354                 if should_skip_detecting_model(migration, model):
355                     continue
356 
357                 table = model._meta.db_table
358                 field = model._meta.get_field(operation.name)
359 
360                 # Handle implicit many-to-many tables created by AddField.
361                 if field.many_to_many:
362                     through_db_table = field.remote_field.through._meta.db_table
363                     if fold_identifier_case:
364                         through_db_table = through_db_table.casefold()
365                     if through_db_table not in existing_table_names:
366                         return False, project_state
367                     else:
368                         found_add_field_migration = True
369                         continue
370                 with self.connection.cursor() as cursor:
371                     columns = self.connection.introspection.get_table_description(cursor, table)
372                 for column in columns:
373                     field_column = field.column
374                     column_name = column.name
375                     if fold_identifier_case:
376                         column_name = column_name.casefold()
377                         field_column = field_column.casefold()
378                     if column_name == field_column:
379                         found_add_field_migration = True
380                         break
381                 else:
382                     return False, project_state
383         # If we get this far and we found at least one CreateModel or AddField migration,
384         # the migration is considered implicitly applied.
385         return (found_create_model_migration or found_add_field_migration), after_state

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>, <file>django/db/migrations/recorder.py</file>
<class>None</class>
<method>None</method>
<code>
1 from django.apps.registry import Apps
2 from django.db import DatabaseError, models
3 from django.utils.functional import classproperty
4 from django.utils.timezone import now
5 
6 from .exceptions import MigrationSchemaMissing
7 
8 
9 class MigrationRecorder:
10     """
11     Deal with storing migration records in the database.
12 
13     Because this table is actually itself used for dealing with model
14     creation, it's the one thing we can't do normally via migrations.
15     We manually handle table creation/schema updating (using schema backend)
16     and then have a floating model to do queries with.
17 
18     If a migration is unapplied its row is removed from the table. Having
19     a row in the table always means a migration is applied.
20     """
21     _migration_class = None
22 
23     @classproperty
24     def Migration(cls):
25         """
26         Lazy load to avoid AppRegistryNotReady if installed apps import
27         MigrationRecorder.
28         """
29         if cls._migration_class is None:
30             class Migration(models.Model):
31                 app = models.CharField(max_length=255)
32                 name = models.CharField(max_length=255)
33                 applied = models.DateTimeField(default=now)
34 
35                 class Meta:
36                     apps = Apps()
37                     app_label = 'migrations'
38                     db_table = 'django_migrations'
39 
40                 def __str__(self):
41                     return 'Migration %s for %s' % (self.name, self.app)
42 
43             cls._migration_class = Migration
44         return cls._migration_class
45 
46     def __init__(self, connection):
47         self.connection = connection
48 
49     @property
50     def migration_qs(self):
51         return self.Migration.objects.using(self.connection.alias)
52 
53     def has_table(self):
54         """Return True if the django_migrations table exists."""
55         with self.connection.cursor() as cursor:
56             tables = self.connection.introspection.table_names(cursor)
57         return self.Migration._meta.db_table in tables
58 
59     def ensure_schema(self):
60         """Ensure the table exists and has the correct schema."""
61         # If the table's there, that's fine - we've never changed its schema
62         # in the codebase.
63         if self.has_table():
64             return
65         # Make the table
66         try:
67             with self.connection.schema_editor() as editor:
68                 editor.create_model(self.Migration)
69         except DatabaseError as exc:
70             raise MigrationSchemaMissing("Unable to create the django_migrations table (%s)" % exc)
71 
72     def applied_migrations(self):
73         """
74         Return a dict mapping (app_name, migration_name) to Migration instances
75         for all applied migrations.
76         """
77         if self.has_table():
78             return {(migration.app, migration.name): migration for migration in self.migration_qs}
79         else:
80             # If the django_migrations table doesn't exist, then no migrations
81             # are applied.
82             return {}
83 
84     def record_applied(self, app, name):
85         """Record that a migration was applied."""
86         self.ensure_schema()
87         self.migration_qs.create(app=app, name=name)
88 
89     def record_unapplied(self, app, name):
90         """Record that a migration was unapplied."""
91         self.ensure_schema()
92         self.migration_qs.filter(app=app, name=name).delete()
93 
94     def flush(self):
95         """Delete all migration records. Useful for testing migrations."""
96         self.migration_qs.all().delete()

</code><intended_behavior>Implement a new method within 'MigrationRecorder' named something like 'cleanup_nonexistent_migrations'. This method should iterate over entries in the 'django_migrations' table, compare them with the migration files present in the project, and remove any entries that do not have a corresponding migration file and are not listed in the 'replaces' attribute of squashed migrations. This method could be called from the 'MigrationExecutor' before or after the migration process to ensure the 'django_migrations' table remains accurate, facilitating the automatic cleanup of the table to reflect only extant migrations or those explicitly replaced in the context of squashed migrations.</intended_behavior>]
2025-10-18 10:53:11.151 | INFO     | Search completed. Bug locations: [<file>django/db/migrations/executor.py</file>
<class>MigrationExecutor</class>
<method>record_migration</method>
<code>
251     def record_migration(self, migration):
252         # For replacement migrations, record individual statuses
253         if migration.replaces:
254             for app_label, name in migration.replaces:
255                 self.recorder.record_applied(app_label, name)
256         else:
257             self.recorder.record_applied(migration.app_label, migration.name)

</code><intended_behavior>Enhance the 'record_migration' method to include a verification step before recording migrations as applied. This step should check whether each migration mentioned in the 'replaces' list still exists within the migration directory. If a migration file does not exist (and is not part of a squashed migration's 'replaces' list), the method should not record it in the 'django_migrations' table. This preserves the functionality of accurately tracking applied migrations while preventing inaccuracies due to deleted migration files.</intended_behavior>, <file>django/db/migrations/executor.py</file>
<class>MigrationExecutor</class>
<method>None</method>
<code>
10 class MigrationExecutor:
11     """
12     End-to-end migration execution - load migrations and run them up or down
13     to a specified set of targets.
14     """
15 
16     def __init__(self, connection, progress_callback=None):
17         self.connection = connection
18         self.loader = MigrationLoader(self.connection)
19         self.recorder = MigrationRecorder(self.connection)
20         self.progress_callback = progress_callback
21 
22     def migration_plan(self, targets, clean_start=False):
23         """
24         Given a set of targets, return a list of (Migration instance, backwards?).
25         """
26         plan = []
27         if clean_start:
28             applied = {}
29         else:
30             applied = dict(self.loader.applied_migrations)
31         for target in targets:
32             # If the target is (app_label, None), that means unmigrate everything
33             if target[1] is None:
34                 for root in self.loader.graph.root_nodes():
35                     if root[0] == target[0]:
36                         for migration in self.loader.graph.backwards_plan(root):
37                             if migration in applied:
38                                 plan.append((self.loader.graph.nodes[migration], True))
39                                 applied.pop(migration)
40             # If the migration is already applied, do backwards mode,
41             # otherwise do forwards mode.
42             elif target in applied:
43                 # If the target is missing, it's likely a replaced migration.
44                 # Reload the graph without replacements.
45                 if (
46                     self.loader.replace_migrations and
47                     target not in self.loader.graph.node_map
48                 ):
49                     self.loader.replace_migrations = False
50                     self.loader.build_graph()
51                     return self.migration_plan(targets, clean_start=clean_start)
52                 # Don't migrate backwards all the way to the target node (that
53                 # may roll back dependencies in other apps that don't need to
54                 # be rolled back); instead roll back through target's immediate
55                 # child(ren) in the same app, and no further.
56                 next_in_app = sorted(
57                     n for n in
58                     self.loader.graph.node_map[target].children
59                     if n[0] == target[0]
60                 )
61                 for node in next_in_app:
62                     for migration in self.loader.graph.backwards_plan(node):
63                         if migration in applied:
64                             plan.append((self.loader.graph.nodes[migration], True))
65                             applied.pop(migration)
66             else:
67                 for migration in self.loader.graph.forwards_plan(target):
68                     if migration not in applied:
69                         plan.append((self.loader.graph.nodes[migration], False))
70                         applied[migration] = self.loader.graph.nodes[migration]
71         return plan
72 
73     def _create_project_state(self, with_applied_migrations=False):
74         """
75         Create a project state including all the applications without
76         migrations and applied migrations if with_applied_migrations=True.
77         """
78         state = ProjectState(real_apps=self.loader.unmigrated_apps)
79         if with_applied_migrations:
80             # Create the forwards plan Django would follow on an empty database
81             full_plan = self.migration_plan(self.loader.graph.leaf_nodes(), clean_start=True)
82             applied_migrations = {
83                 self.loader.graph.nodes[key] for key in self.loader.applied_migrations
84                 if key in self.loader.graph.nodes
85             }
86             for migration, _ in full_plan:
87                 if migration in applied_migrations:
88                     migration.mutate_state(state, preserve=False)
89         return state
90 
91     def migrate(self, targets, plan=None, state=None, fake=False, fake_initial=False):
92         """
93         Migrate the database up to the given targets.
94 
95         Django first needs to create all project states before a migration is
96         (un)applied and in a second step run all the database operations.
97         """
98         # The django_migrations table must be present to record applied
99         # migrations, but don't create it if there are no migrations to apply.
100         if plan == []:
101             if not self.recorder.has_table():
102                 return self._create_project_state(with_applied_migrations=False)
103         else:
104             self.recorder.ensure_schema()
105 
106         if plan is None:
107             plan = self.migration_plan(targets)
108         # Create the forwards plan Django would follow on an empty database
109         full_plan = self.migration_plan(self.loader.graph.leaf_nodes(), clean_start=True)
110 
111         all_forwards = all(not backwards for mig, backwards in plan)
112         all_backwards = all(backwards for mig, backwards in plan)
113 
114         if not plan:
115             if state is None:
116                 # The resulting state should include applied migrations.
117                 state = self._create_project_state(with_applied_migrations=True)
118         elif all_forwards == all_backwards:
119             # This should only happen if there's a mixed plan
120             raise InvalidMigrationPlan(
121                 "Migration plans with both forwards and backwards migrations "
122                 "are not supported. Please split your migration process into "
123                 "separate plans of only forwards OR backwards migrations.",
124                 plan
125             )
126         elif all_forwards:
127             if state is None:
128                 # The resulting state should still include applied migrations.
129                 state = self._create_project_state(with_applied_migrations=True)
130             state = self._migrate_all_forwards(state, plan, full_plan, fake=fake, fake_initial=fake_initial)
131         else:
132             # No need to check for `elif all_backwards` here, as that condition
133             # would always evaluate to true.
134             state = self._migrate_all_backwards(plan, full_plan, fake=fake)
135 
136         self.check_replacements()
137 
138         return state
139 
140     def _migrate_all_forwards(self, state, plan, full_plan, fake, fake_initial):
141         """
142         Take a list of 2-tuples of the form (migration instance, False) and
143         apply them in the order they occur in the full_plan.
144         """
145         migrations_to_run = {m[0] for m in plan}
146         for migration, _ in full_plan:
147             if not migrations_to_run:
148                 # We remove every migration that we applied from these sets so
149                 # that we can bail out once the last migration has been applied
150                 # and don't always run until the very end of the migration
151                 # process.
152                 break
153             if migration in migrations_to_run:
154                 if 'apps' not in state.__dict__:
155                     if self.progress_callback:
156                         self.progress_callback("render_start")
157                     state.apps  # Render all -- performance critical
158                     if self.progress_callback:
159                         self.progress_callback("render_success")
160                 state = self.apply_migration(state, migration, fake=fake, fake_initial=fake_initial)
161                 migrations_to_run.remove(migration)
162 
163         return state
164 
165     def _migrate_all_backwards(self, plan, full_plan, fake):
166         """
167         Take a list of 2-tuples of the form (migration instance, True) and
168         unapply them in reverse order they occur in the full_plan.
169 
170         Since unapplying a migration requires the project state prior to that
171         migration, Django will compute the migration states before each of them
172         in a first run over the plan and then unapply them in a second run over
173         the plan.
174         """
175         migrations_to_run = {m[0] for m in plan}
176         # Holds all migration states prior to the migrations being unapplied
177         states = {}
178         state = self._create_project_state()
179         applied_migrations = {
180             self.loader.graph.nodes[key] for key in self.loader.applied_migrations
181             if key in self.loader.graph.nodes
182         }
183         if self.progress_callback:
184             self.progress_callback("render_start")
185         for migration, _ in full_plan:
186             if not migrations_to_run:
187                 # We remove every migration that we applied from this set so
188                 # that we can bail out once the last migration has been applied
189                 # and don't always run until the very end of the migration
190                 # process.
191                 break
192             if migration in migrations_to_run:
193                 if 'apps' not in state.__dict__:
194                     state.apps  # Render all -- performance critical
195                 # The state before this migration
196                 states[migration] = state
197                 # The old state keeps as-is, we continue with the new state
198                 state = migration.mutate_state(state, preserve=True)
199                 migrations_to_run.remove(migration)
200             elif migration in applied_migrations:
201                 # Only mutate the state if the migration is actually applied
202                 # to make sure the resulting state doesn't include changes
203                 # from unrelated migrations.
204                 migration.mutate_state(state, preserve=False)
205         if self.progress_callback:
206             self.progress_callback("render_success")
207 
208         for migration, _ in plan:
209             self.unapply_migration(states[migration], migration, fake=fake)
210             applied_migrations.remove(migration)
211 
212         # Generate the post migration state by starting from the state before
213         # the last migration is unapplied and mutating it to include all the
214         # remaining applied migrations.
215         last_unapplied_migration = plan[-1][0]
216         state = states[last_unapplied_migration]
217         for index, (migration, _) in enumerate(full_plan):
218             if migration == last_unapplied_migration:
219                 for migration, _ in full_plan[index:]:
220                     if migration in applied_migrations:
221                         migration.mutate_state(state, preserve=False)
222                 break
223 
224         return state
225 
226     def apply_migration(self, state, migration, fake=False, fake_initial=False):
227         """Run a migration forwards."""
228         migration_recorded = False
229         if self.progress_callback:
230             self.progress_callback("apply_start", migration, fake)
231         if not fake:
232             if fake_initial:
233                 # Test to see if this is an already-applied initial migration
234                 applied, state = self.detect_soft_applied(state, migration)
235                 if applied:
236                     fake = True
237             if not fake:
238                 # Alright, do it normally
239                 with self.connection.schema_editor(atomic=migration.atomic) as schema_editor:
240                     state = migration.apply(state, schema_editor)
241                     if not schema_editor.deferred_sql:
242                         self.record_migration(migration)
243                         migration_recorded = True
244         if not migration_recorded:
245             self.record_migration(migration)
246         # Report progress
247         if self.progress_callback:
248             self.progress_callback("apply_success", migration, fake)
249         return state
250 
251     def record_migration(self, migration):
252         # For replacement migrations, record individual statuses
253         if migration.replaces:
254             for app_label, name in migration.replaces:
255                 self.recorder.record_applied(app_label, name)
256         else:
257             self.recorder.record_applied(migration.app_label, migration.name)
258 
259     def unapply_migration(self, state, migration, fake=False):
260         """Run a migration backwards."""
261         if self.progress_callback:
262             self.progress_callback("unapply_start", migration, fake)
263         if not fake:
264             with self.connection.schema_editor(atomic=migration.atomic) as schema_editor:
265                 state = migration.unapply(state, schema_editor)
266         # For replacement migrations, also record individual statuses.
267         if migration.replaces:
268             for app_label, name in migration.replaces:
269                 self.recorder.record_unapplied(app_label, name)
270         self.recorder.record_unapplied(migration.app_label, migration.name)
271         # Report progress
272         if self.progress_callback:
273             self.progress_callback("unapply_success", migration, fake)
274         return state
275 
276     def check_replacements(self):
277         """
278         Mark replacement migrations applied if their replaced set all are.
279 
280         Do this unconditionally on every migrate, rather than just when
281         migrations are applied or unapplied, to correctly handle the case
282         when a new squash migration is pushed to a deployment that already had
283         all its replaced migrations applied. In this case no new migration will
284         be applied, but the applied state of the squashed migration must be
285         maintained.
286         """
287         applied = self.recorder.applied_migrations()
288         for key, migration in self.loader.replacements.items():
289             all_applied = all(m in applied for m in migration.replaces)
290             if all_applied and key not in applied:
291                 self.recorder.record_applied(*key)
292 
293     def detect_soft_applied(self, project_state, migration):
294         """
295         Test whether a migration has been implicitly applied - that the
296         tables or columns it would create exist. This is intended only for use
297         on initial migrations (as it only looks for CreateModel and AddField).
298         """
299         def should_skip_detecting_model(migration, model):
300             """
301             No need to detect tables for proxy models, unmanaged models, or
302             models that can't be migrated on the current database.
303             """
304             return (
305                 model._meta.proxy or not model._meta.managed or not
306                 router.allow_migrate(
307                     self.connection.alias, migration.app_label,
308                     model_name=model._meta.model_name,
309                 )
310             )
311 
312         if migration.initial is None:
313             # Bail if the migration isn't the first one in its app
314             if any(app == migration.app_label for app, name in migration.dependencies):
315                 return False, project_state
316         elif migration.initial is False:
317             # Bail if it's NOT an initial migration
318             return False, project_state
319 
320         if project_state is None:
321             after_state = self.loader.project_state((migration.app_label, migration.name), at_end=True)
322         else:
323             after_state = migration.mutate_state(project_state)
324         apps = after_state.apps
325         found_create_model_migration = False
326         found_add_field_migration = False
327         fold_identifier_case = self.connection.features.ignores_table_name_case
328         with self.connection.cursor() as cursor:
329             existing_table_names = set(self.connection.introspection.table_names(cursor))
330             if fold_identifier_case:
331                 existing_table_names = {name.casefold() for name in existing_table_names}
332         # Make sure all create model and add field operations are done
333         for operation in migration.operations:
334             if isinstance(operation, migrations.CreateModel):
335                 model = apps.get_model(migration.app_label, operation.name)
336                 if model._meta.swapped:
337                     # We have to fetch the model to test with from the
338                     # main app cache, as it's not a direct dependency.
339                     model = global_apps.get_model(model._meta.swapped)
340                 if should_skip_detecting_model(migration, model):
341                     continue
342                 db_table = model._meta.db_table
343                 if fold_identifier_case:
344                     db_table = db_table.casefold()
345                 if db_table not in existing_table_names:
346                     return False, project_state
347                 found_create_model_migration = True
348             elif isinstance(operation, migrations.AddField):
349                 model = apps.get_model(migration.app_label, operation.model_name)
350                 if model._meta.swapped:
351                     # We have to fetch the model to test with from the
352                     # main app cache, as it's not a direct dependency.
353                     model = global_apps.get_model(model._meta.swapped)
354                 if should_skip_detecting_model(migration, model):
355                     continue
356 
357                 table = model._meta.db_table
358                 field = model._meta.get_field(operation.name)
359 
360                 # Handle implicit many-to-many tables created by AddField.
361                 if field.many_to_many:
362                     through_db_table = field.remote_field.through._meta.db_table
363                     if fold_identifier_case:
364                         through_db_table = through_db_table.casefold()
365                     if through_db_table not in existing_table_names:
366                         return False, project_state
367                     else:
368                         found_add_field_migration = True
369                         continue
370                 with self.connection.cursor() as cursor:
371                     columns = self.connection.introspection.get_table_description(cursor, table)
372                 for column in columns:
373                     field_column = field.column
374                     column_name = column.name
375                     if fold_identifier_case:
376                         column_name = column_name.casefold()
377                         field_column = field_column.casefold()
378                     if column_name == field_column:
379                         found_add_field_migration = True
380                         break
381                 else:
382                     return False, project_state
383         # If we get this far and we found at least one CreateModel or AddField migration,
384         # the migration is considered implicitly applied.
385         return (found_create_model_migration or found_add_field_migration), after_state

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>, <file>django/db/migrations/recorder.py</file>
<class>None</class>
<method>None</method>
<code>
1 from django.apps.registry import Apps
2 from django.db import DatabaseError, models
3 from django.utils.functional import classproperty
4 from django.utils.timezone import now
5 
6 from .exceptions import MigrationSchemaMissing
7 
8 
9 class MigrationRecorder:
10     """
11     Deal with storing migration records in the database.
12 
13     Because this table is actually itself used for dealing with model
14     creation, it's the one thing we can't do normally via migrations.
15     We manually handle table creation/schema updating (using schema backend)
16     and then have a floating model to do queries with.
17 
18     If a migration is unapplied its row is removed from the table. Having
19     a row in the table always means a migration is applied.
20     """
21     _migration_class = None
22 
23     @classproperty
24     def Migration(cls):
25         """
26         Lazy load to avoid AppRegistryNotReady if installed apps import
27         MigrationRecorder.
28         """
29         if cls._migration_class is None:
30             class Migration(models.Model):
31                 app = models.CharField(max_length=255)
32                 name = models.CharField(max_length=255)
33                 applied = models.DateTimeField(default=now)
34 
35                 class Meta:
36                     apps = Apps()
37                     app_label = 'migrations'
38                     db_table = 'django_migrations'
39 
40                 def __str__(self):
41                     return 'Migration %s for %s' % (self.name, self.app)
42 
43             cls._migration_class = Migration
44         return cls._migration_class
45 
46     def __init__(self, connection):
47         self.connection = connection
48 
49     @property
50     def migration_qs(self):
51         return self.Migration.objects.using(self.connection.alias)
52 
53     def has_table(self):
54         """Return True if the django_migrations table exists."""
55         with self.connection.cursor() as cursor:
56             tables = self.connection.introspection.table_names(cursor)
57         return self.Migration._meta.db_table in tables
58 
59     def ensure_schema(self):
60         """Ensure the table exists and has the correct schema."""
61         # If the table's there, that's fine - we've never changed its schema
62         # in the codebase.
63         if self.has_table():
64             return
65         # Make the table
66         try:
67             with self.connection.schema_editor() as editor:
68                 editor.create_model(self.Migration)
69         except DatabaseError as exc:
70             raise MigrationSchemaMissing("Unable to create the django_migrations table (%s)" % exc)
71 
72     def applied_migrations(self):
73         """
74         Return a dict mapping (app_name, migration_name) to Migration instances
75         for all applied migrations.
76         """
77         if self.has_table():
78             return {(migration.app, migration.name): migration for migration in self.migration_qs}
79         else:
80             # If the django_migrations table doesn't exist, then no migrations
81             # are applied.
82             return {}
83 
84     def record_applied(self, app, name):
85         """Record that a migration was applied."""
86         self.ensure_schema()
87         self.migration_qs.create(app=app, name=name)
88 
89     def record_unapplied(self, app, name):
90         """Record that a migration was unapplied."""
91         self.ensure_schema()
92         self.migration_qs.filter(app=app, name=name).delete()
93 
94     def flush(self):
95         """Delete all migration records. Useful for testing migrations."""
96         self.migration_qs.all().delete()

</code><intended_behavior>Implement a new method within 'MigrationRecorder' named something like 'cleanup_nonexistent_migrations'. This method should iterate over entries in the 'django_migrations' table, compare them with the migration files present in the project, and remove any entries that do not have a corresponding migration file and are not listed in the 'replaces' attribute of squashed migrations. This method could be called from the 'MigrationExecutor' before or after the migration process to ensure the 'django_migrations' table remains accurate, facilitating the automatic cleanup of the table to reflect only extant migrations or those explicitly replaced in the context of squashed migrations.</intended_behavior>]
2025-10-18 10:53:11.152 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-18 10:53:11.152 | INFO     | Search-only: skipping patch selection
2025-10-18 10:53:11.287 | INFO     | Task django__django-15240 completed successfully.
2025-10-18 10:53:11.288 | INFO     | No patch generated. You can try running ACR again.
