[
    {
        "rel_file_path": "lib/mpl_toolkits/axes_grid1/axes_grid.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/matplotlib__matplotlib/setup_matplotlib__matplotlib__3.7/lib/mpl_toolkits/axes_grid1/axes_grid.py",
        "start": 13,
        "end": 17,
        "class_name": null,
        "method_name": "_tick_only",
        "code": "13 def _tick_only(ax, bottom_on, left_on):\n14     bottom_off = not bottom_on\n15     left_off = not left_on\n16     ax.axis[\"bottom\"].toggle(ticklabels=bottom_off, label=bottom_off)\n17     ax.axis[\"left\"].toggle(ticklabels=left_off, label=left_off)\n",
        "intended_behavior": "The method `_tick_only` is intended to toggle the visibility of tick labels and the axis label for the bottom and left axes. To resolve the issue, this method should be updated to handle both cases where `ax.axis` is a method (likely providing an interface to manipulate axes properties) and where it's a subscriptable object (dictionary-like behavior). A conditional check should be implemented to call `ax.axis` as a method if it's not subscriptable, possibly using a strategy to handle arguments in a manner consistent with the expected outcomes (e.g., manipulating visibility of tick labels and axis labels). This ensures compatibility with `GeoAxes` or any other axes class that implements `axis` as a method rather than an attribute."
    },
    {
        "rel_file_path": "lib/matplotlib/projections/geo.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/matplotlib__matplotlib/setup_matplotlib__matplotlib__3.7/lib/matplotlib/projections/geo.py",
        "start": 15,
        "end": 222,
        "class_name": "GeoAxes",
        "method_name": null,
        "code": "15 class GeoAxes(Axes):\n16     \"\"\"An abstract base class for geographic projections.\"\"\"\n17 \n18     class ThetaFormatter(Formatter):\n19         \"\"\"\n20         Used to format the theta tick labels.  Converts the native\n21         unit of radians into degrees and adds a degree symbol.\n22         \"\"\"\n23         def __init__(self, round_to=1.0):\n24             self._round_to = round_to\n25 \n26         def __call__(self, x, pos=None):\n27             degrees = round(np.rad2deg(x) / self._round_to) * self._round_to\n28             return f\"{degrees:0.0f}\\N{DEGREE SIGN}\"\n29 \n30     RESOLUTION = 75\n31 \n32     def _init_axis(self):\n33         self.xaxis = maxis.XAxis(self)\n34         self.yaxis = maxis.YAxis(self)\n35         # Do not register xaxis or yaxis with spines -- as done in\n36         # Axes._init_axis() -- until GeoAxes.xaxis.clear() works.\n37         # self.spines['geo'].register_axis(self.yaxis)\n38 \n39     def clear(self):\n40         # docstring inherited\n41         super().clear()\n42 \n43         self.set_longitude_grid(30)\n44         self.set_latitude_grid(15)\n45         self.set_longitude_grid_ends(75)\n46         self.xaxis.set_minor_locator(NullLocator())\n47         self.yaxis.set_minor_locator(NullLocator())\n48         self.xaxis.set_ticks_position('none')\n49         self.yaxis.set_ticks_position('none')\n50         self.yaxis.set_tick_params(label1On=True)\n51         # Why do we need to turn on yaxis tick labels, but\n52         # xaxis tick labels are already on?\n53 \n54         self.grid(mpl.rcParams['axes.grid'])\n55 \n56         Axes.set_xlim(self, -np.pi, np.pi)\n57         Axes.set_ylim(self, -np.pi / 2.0, np.pi / 2.0)\n58 \n59     def _set_lim_and_transforms(self):\n60         # A (possibly non-linear) projection on the (already scaled) data\n61         self.transProjection = self._get_core_transform(self.RESOLUTION)\n62 \n63         self.transAffine = self._get_affine_transform()\n64 \n65         self.transAxes = BboxTransformTo(self.bbox)\n66 \n67         # The complete data transformation stack -- from data all the\n68         # way to display coordinates\n69         self.transData = \\\n70             self.transProjection + \\\n71             self.transAffine + \\\n72             self.transAxes\n73 \n74         # This is the transform for longitude ticks.\n75         self._xaxis_pretransform = \\\n76             Affine2D() \\\n77             .scale(1, self._longitude_cap * 2) \\\n78             .translate(0, -self._longitude_cap)\n79         self._xaxis_transform = \\\n80             self._xaxis_pretransform + \\\n81             self.transData\n82         self._xaxis_text1_transform = \\\n83             Affine2D().scale(1, 0) + \\\n84             self.transData + \\\n85             Affine2D().translate(0, 4)\n86         self._xaxis_text2_transform = \\\n87             Affine2D().scale(1, 0) + \\\n88             self.transData + \\\n89             Affine2D().translate(0, -4)\n90 \n91         # This is the transform for latitude ticks.\n92         yaxis_stretch = Affine2D().scale(np.pi * 2, 1).translate(-np.pi, 0)\n93         yaxis_space = Affine2D().scale(1, 1.1)\n94         self._yaxis_transform = \\\n95             yaxis_stretch + \\\n96             self.transData\n97         yaxis_text_base = \\\n98             yaxis_stretch + \\\n99             self.transProjection + \\\n100             (yaxis_space +\n101              self.transAffine +\n102              self.transAxes)\n103         self._yaxis_text1_transform = \\\n104             yaxis_text_base + \\\n105             Affine2D().translate(-8, 0)\n106         self._yaxis_text2_transform = \\\n107             yaxis_text_base + \\\n108             Affine2D().translate(8, 0)\n109 \n110     def _get_affine_transform(self):\n111         transform = self._get_core_transform(1)\n112         xscale, _ = transform.transform((np.pi, 0))\n113         _, yscale = transform.transform((0, np.pi/2))\n114         return Affine2D() \\\n115             .scale(0.5 / xscale, 0.5 / yscale) \\\n116             .translate(0.5, 0.5)\n117 \n118     def get_xaxis_transform(self, which='grid'):\n119         _api.check_in_list(['tick1', 'tick2', 'grid'], which=which)\n120         return self._xaxis_transform\n121 \n122     def get_xaxis_text1_transform(self, pad):\n123         return self._xaxis_text1_transform, 'bottom', 'center'\n124 \n125     def get_xaxis_text2_transform(self, pad):\n126         return self._xaxis_text2_transform, 'top', 'center'\n127 \n128     def get_yaxis_transform(self, which='grid'):\n129         _api.check_in_list(['tick1', 'tick2', 'grid'], which=which)\n130         return self._yaxis_transform\n131 \n132     def get_yaxis_text1_transform(self, pad):\n133         return self._yaxis_text1_transform, 'center', 'right'\n134 \n135     def get_yaxis_text2_transform(self, pad):\n136         return self._yaxis_text2_transform, 'center', 'left'\n137 \n138     def _gen_axes_patch(self):\n139         return Circle((0.5, 0.5), 0.5)\n140 \n141     def _gen_axes_spines(self):\n142         return {'geo': mspines.Spine.circular_spine(self, (0.5, 0.5), 0.5)}\n143 \n144     def set_yscale(self, *args, **kwargs):\n145         if args[0] != 'linear':\n146             raise NotImplementedError\n147 \n148     set_xscale = set_yscale\n149 \n150     def set_xlim(self, *args, **kwargs):\n151         \"\"\"Not supported. Please consider using Cartopy.\"\"\"\n152         raise TypeError(\"Changing axes limits of a geographic projection is \"\n153                         \"not supported.  Please consider using Cartopy.\")\n154 \n155     set_ylim = set_xlim\n156 \n157     def format_coord(self, lon, lat):\n158         \"\"\"Return a format string formatting the coordinate.\"\"\"\n159         lon, lat = np.rad2deg([lon, lat])\n160         ns = 'N' if lat >= 0.0 else 'S'\n161         ew = 'E' if lon >= 0.0 else 'W'\n162         return ('%f\\N{DEGREE SIGN}%s, %f\\N{DEGREE SIGN}%s'\n163                 % (abs(lat), ns, abs(lon), ew))\n164 \n165     def set_longitude_grid(self, degrees):\n166         \"\"\"\n167         Set the number of degrees between each longitude grid.\n168         \"\"\"\n169         # Skip -180 and 180, which are the fixed limits.\n170         grid = np.arange(-180 + degrees, 180, degrees)\n171         self.xaxis.set_major_locator(FixedLocator(np.deg2rad(grid)))\n172         self.xaxis.set_major_formatter(self.ThetaFormatter(degrees))\n173 \n174     def set_latitude_grid(self, degrees):\n175         \"\"\"\n176         Set the number of degrees between each latitude grid.\n177         \"\"\"\n178         # Skip -90 and 90, which are the fixed limits.\n179         grid = np.arange(-90 + degrees, 90, degrees)\n180         self.yaxis.set_major_locator(FixedLocator(np.deg2rad(grid)))\n181         self.yaxis.set_major_formatter(self.ThetaFormatter(degrees))\n182 \n183     def set_longitude_grid_ends(self, degrees):\n184         \"\"\"\n185         Set the latitude(s) at which to stop drawing the longitude grids.\n186         \"\"\"\n187         self._longitude_cap = np.deg2rad(degrees)\n188         self._xaxis_pretransform \\\n189             .clear() \\\n190             .scale(1.0, self._longitude_cap * 2.0) \\\n191             .translate(0.0, -self._longitude_cap)\n192 \n193     def get_data_ratio(self):\n194         \"\"\"Return the aspect ratio of the data itself.\"\"\"\n195         return 1.0\n196 \n197     ### Interactive panning\n198 \n199     def can_zoom(self):\n200         \"\"\"\n201         Return whether this Axes supports the zoom box button functionality.\n202 \n203         This Axes object does not support interactive zoom box.\n204         \"\"\"\n205         return False\n206 \n207     def can_pan(self):\n208         \"\"\"\n209         Return whether this Axes supports the pan/zoom button functionality.\n210 \n211         This Axes object does not support interactive pan/zoom.\n212         \"\"\"\n213         return False\n214 \n215     def start_pan(self, x, y, button):\n216         pass\n217 \n218     def end_pan(self):\n219         pass\n220 \n221     def drag_pan(self, button, key, x, y):\n222         pass\n",
        "intended_behavior": "While `GeoAxes` may not be directly \"buggy,\" an adjustment or addition could be made to ensure it behaves consistently with expectations from utilities like `_tick_only`. This could involve adding a wrapper or adapter method within `GeoAxes` that allows its `axis` method to be accessed in a manner consistent with subscriptable `axis` attributes found in other axes classes. Alternatively, ensuring that `GeoAxes` and similar classes provide a compatible interface for manipulating axis properties could also resolve the issue. This might include implementing dictionary-like access patterns or providing clear documentation and utilities for converting between the different `axis` interfaces."
    }
]