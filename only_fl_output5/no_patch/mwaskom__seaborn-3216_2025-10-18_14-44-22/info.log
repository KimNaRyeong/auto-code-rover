2025-10-18 14:44:22.834 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-18 14:44:24.332 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=405, output_tokens=12, cost=0.004410
2025-10-18 14:44:35.241 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=585, output_tokens=448, cost=0.019290
2025-10-18 14:44:36.244 | INFO     | registered non reproducing test 0
2025-10-18 14:44:52.173 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1337, output_tokens=680, cost=0.033770
2025-10-18 14:44:53.137 | INFO     | registered non reproducing test 1
2025-10-18 14:45:06.926 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1654, output_tokens=650, cost=0.036040
2025-10-18 14:45:07.889 | INFO     | registered non reproducing test 2
2025-10-18 14:45:07.889 | WARNING  | Failed to write a reproducer test; skipping reproducer tracing
2025-10-18 14:45:07.895 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 14:45:15.688 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=710, output_tokens=340, cost=0.017300
2025-10-18 14:45:15.695 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 14:45:17.724 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=694, output_tokens=52, cost=0.008500
2025-10-18 14:45:17.726 | DEBUG    | Extracted a valid json.
2025-10-18 14:45:17.726 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_code_in_file(\"figure = target.figure\", \"_core/subplots.py\")",
        "search_class(\"Plot\")",
        "search_class(\"Bars\")"
    ],
    "bug_locations": []
}
2025-10-18 14:45:17.770 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-18 14:45:17.771 | DEBUG    | <Agent search> Analyzing search results.
2025-10-18 14:45:34.242 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2020, output_tokens=738, cost=0.042340
2025-10-18 14:45:34.258 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 14:45:41.206 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2974, output_tokens=250, cost=0.037240
2025-10-18 14:45:41.213 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 14:45:46.976 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=604, output_tokens=225, cost=0.012790
2025-10-18 14:45:46.977 | DEBUG    | Extracted a valid json.
2025-10-18 14:45:46.983 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations":[{"file": "seaborn/_core/subplots.py", "class": "Subplots", "method": "init_figure", "intended_behavior": "Currently, the method assigns figure = target.figure for SubFigure targets, resulting in seaborn improperly linking to the parent figure instead of the subfigure itself. This is what's causing the figure title to be lost when using seaborn's plotting functions on subfigures. The intended behavior should instead recognize SubFigure instances as valid figure contexts on their own, not merely as proxies for their parent figures. Therefore, the assignment should be altered to treat SubFigure instances same as Figure, by directly assigning figure = target in cases where target is an instance of SubFigure. This will ensure seaborn properly integrates with matplotlib's hierarchy, preserving figure-level attributes (such as titles) when working with subfigures. This change aligns with the fix suggested in the issue description and respects the design philosophy of SubFigures being akin to Figures for the purpose of plotting, thus ensuring compatibility and functionality with existing and future seaborn functionalities."}]
}
2025-10-18 14:45:46.989 | DEBUG    | Bug location extracted successfully: [<file>seaborn/_core/subplots.py</file>
<class>Subplots</class>
<method>init_figure</method>
<code>
142     def init_figure(
143         self,
144         pair_spec: PairSpec,
145         pyplot: bool = False,
146         figure_kws: dict | None = None,
147         target: Axes | Figure | SubFigure = None,
148     ) -> Figure:
149         """Initialize matplotlib objects and add seaborn-relevant metadata."""
150         # TODO reduce need to pass pair_spec here?
151 
152         if figure_kws is None:
153             figure_kws = {}
154 
155         if isinstance(target, mpl.axes.Axes):
156 
157             if max(self.subplot_spec["nrows"], self.subplot_spec["ncols"]) > 1:
158                 err = " ".join([
159                     "Cannot create multiple subplots after calling `Plot.on` with",
160                     f"a {mpl.axes.Axes} object.",
161                 ])
162                 try:
163                     err += f" You may want to use a {mpl.figure.SubFigure} instead."
164                 except AttributeError:  # SubFigure added in mpl 3.4
165                     pass
166                 raise RuntimeError(err)
167 
168             self._subplot_list = [{
169                 "ax": target,
170                 "left": True,
171                 "right": True,
172                 "top": True,
173                 "bottom": True,
174                 "col": None,
175                 "row": None,
176                 "x": "x",
177                 "y": "y",
178             }]
179             self._figure = target.figure
180             return self._figure
181 
182         elif (
183             hasattr(mpl.figure, "SubFigure")  # Added in mpl 3.4
184             and isinstance(target, mpl.figure.SubFigure)
185         ):
186             figure = target.figure
187         elif isinstance(target, mpl.figure.Figure):
188             figure = target
189         else:
190             if pyplot:
191                 figure = plt.figure(**figure_kws)
192             else:
193                 figure = mpl.figure.Figure(**figure_kws)
194             target = figure
195         self._figure = figure
196 
197         axs = target.subplots(**self.subplot_spec, squeeze=False)
198 
199         if self.wrap:
200             # Remove unused Axes and flatten the rest into a (2D) vector
201             axs_flat = axs.ravel({"col": "C", "row": "F"}[self.wrap_dim])
202             axs, extra = np.split(axs_flat, [self.n_subplots])
203             for ax in extra:
204                 ax.remove()
205             if self.wrap_dim == "col":
206                 axs = axs[np.newaxis, :]
207             else:
208                 axs = axs[:, np.newaxis]
209 
210         # Get i, j coordinates for each Axes object
211         # Note that i, j are with respect to faceting/pairing,
212         # not the subplot grid itself, (which only matters in the case of wrapping).
213         iter_axs: np.ndenumerate | zip
214         if not pair_spec.get("cross", True):
215             indices = np.arange(self.n_subplots)
216             iter_axs = zip(zip(indices, indices), axs.flat)
217         else:
218             iter_axs = np.ndenumerate(axs)
219 
220         self._subplot_list = []
221         for (i, j), ax in iter_axs:
222 
223             info = {"ax": ax}
224 
225             nrows, ncols = self.subplot_spec["nrows"], self.subplot_spec["ncols"]
226             if not self.wrap:
227                 info["left"] = j % ncols == 0
228                 info["right"] = (j + 1) % ncols == 0
229                 info["top"] = i == 0
230                 info["bottom"] = i == nrows - 1
231             elif self.wrap_dim == "col":
232                 info["left"] = j % ncols == 0
233                 info["right"] = ((j + 1) % ncols == 0) or ((j + 1) == self.n_subplots)
234                 info["top"] = j < ncols
235                 info["bottom"] = j >= (self.n_subplots - ncols)
236             elif self.wrap_dim == "row":
237                 info["left"] = i < nrows
238                 info["right"] = i >= self.n_subplots - nrows
239                 info["top"] = i % nrows == 0
240                 info["bottom"] = ((i + 1) % nrows == 0) or ((i + 1) == self.n_subplots)
241 
242             if not pair_spec.get("cross", True):
243                 info["top"] = j < ncols
244                 info["bottom"] = j >= self.n_subplots - ncols
245 
246             for dim in ["row", "col"]:
247                 idx = {"row": i, "col": j}[dim]
248                 info[dim] = self.grid_dimensions[dim][idx]
249 
250             for axis in "xy":
251 
252                 idx = {"x": j, "y": i}[axis]
253                 if axis in pair_spec.get("structure", {}):
254                     key = f"{axis}{idx}"
255                 else:
256                     key = axis
257                 info[axis] = key
258 
259             self._subplot_list.append(info)
260 
261         return figure

</code><intended_behavior>Currently, the method assigns figure = target.figure for SubFigure targets, resulting in seaborn improperly linking to the parent figure instead of the subfigure itself. This is what's causing the figure title to be lost when using seaborn's plotting functions on subfigures. The intended behavior should instead recognize SubFigure instances as valid figure contexts on their own, not merely as proxies for their parent figures. Therefore, the assignment should be altered to treat SubFigure instances same as Figure, by directly assigning figure = target in cases where target is an instance of SubFigure. This will ensure seaborn properly integrates with matplotlib's hierarchy, preserving figure-level attributes (such as titles) when working with subfigures. This change aligns with the fix suggested in the issue description and respects the design philosophy of SubFigures being akin to Figures for the purpose of plotting, thus ensuring compatibility and functionality with existing and future seaborn functionalities.</intended_behavior>, <file>seaborn/_core/subplots.py</file>
<class>Subplots</class>
<method>None</method>
<code>
16 class Subplots:
17     """
18     Interface for creating and using matplotlib subplots based on seaborn parameters.
19 
20     Parameters
21     ----------
22     subplot_spec : dict
23         Keyword args for :meth:`matplotlib.figure.Figure.subplots`.
24     facet_spec : dict
25         Parameters that control subplot faceting.
26     pair_spec : dict
27         Parameters that control subplot pairing.
28     data : PlotData
29         Data used to define figure setup.
30 
31     """
32     def __init__(
33         self,
34         subplot_spec: dict,  # TODO define as TypedDict
35         facet_spec: FacetSpec,
36         pair_spec: PairSpec,
37     ):
38 
39         self.subplot_spec = subplot_spec
40 
41         self._check_dimension_uniqueness(facet_spec, pair_spec)
42         self._determine_grid_dimensions(facet_spec, pair_spec)
43         self._handle_wrapping(facet_spec, pair_spec)
44         self._determine_axis_sharing(pair_spec)
45 
46     def _check_dimension_uniqueness(
47         self, facet_spec: FacetSpec, pair_spec: PairSpec
48     ) -> None:
49         """Reject specs that pair and facet on (or wrap to) same figure dimension."""
50         err = None
51 
52         facet_vars = facet_spec.get("variables", {})
53 
54         if facet_spec.get("wrap") and {"col", "row"} <= set(facet_vars):
55             err = "Cannot wrap facets when specifying both `col` and `row`."
56         elif (
57             pair_spec.get("wrap")
58             and pair_spec.get("cross", True)
59             and len(pair_spec.get("structure", {}).get("x", [])) > 1
60             and len(pair_spec.get("structure", {}).get("y", [])) > 1
61         ):
62             err = "Cannot wrap subplots when pairing on both `x` and `y`."
63 
64         collisions = {"x": ["columns", "rows"], "y": ["rows", "columns"]}
65         for pair_axis, (multi_dim, wrap_dim) in collisions.items():
66             if pair_axis not in pair_spec.get("structure", {}):
67                 continue
68             elif multi_dim[:3] in facet_vars:
69                 err = f"Cannot facet the {multi_dim} while pairing on `{pair_axis}``."
70             elif wrap_dim[:3] in facet_vars and facet_spec.get("wrap"):
71                 err = f"Cannot wrap the {wrap_dim} while pairing on `{pair_axis}``."
72             elif wrap_dim[:3] in facet_vars and pair_spec.get("wrap"):
73                 err = f"Cannot wrap the {multi_dim} while faceting the {wrap_dim}."
74 
75         if err is not None:
76             raise RuntimeError(err)  # TODO what err class? Define PlotSpecError?
77 
78     def _determine_grid_dimensions(
79         self, facet_spec: FacetSpec, pair_spec: PairSpec
80     ) -> None:
81         """Parse faceting and pairing information to define figure structure."""
82         self.grid_dimensions: dict[str, list] = {}
83         for dim, axis in zip(["col", "row"], ["x", "y"]):
84 
85             facet_vars = facet_spec.get("variables", {})
86             if dim in facet_vars:
87                 self.grid_dimensions[dim] = facet_spec["structure"][dim]
88             elif axis in pair_spec.get("structure", {}):
89                 self.grid_dimensions[dim] = [
90                     None for _ in pair_spec.get("structure", {})[axis]
91                 ]
92             else:
93                 self.grid_dimensions[dim] = [None]
94 
95             self.subplot_spec[f"n{dim}s"] = len(self.grid_dimensions[dim])
96 
97         if not pair_spec.get("cross", True):
98             self.subplot_spec["nrows"] = 1
99 
100         self.n_subplots = self.subplot_spec["ncols"] * self.subplot_spec["nrows"]
101 
102     def _handle_wrapping(
103         self, facet_spec: FacetSpec, pair_spec: PairSpec
104     ) -> None:
105         """Update figure structure parameters based on facet/pair wrapping."""
106         self.wrap = wrap = facet_spec.get("wrap") or pair_spec.get("wrap")
107         if not wrap:
108             return
109 
110         wrap_dim = "row" if self.subplot_spec["nrows"] > 1 else "col"
111         flow_dim = {"row": "col", "col": "row"}[wrap_dim]
112         n_subplots = self.subplot_spec[f"n{wrap_dim}s"]
113         flow = int(np.ceil(n_subplots / wrap))
114 
115         if wrap < self.subplot_spec[f"n{wrap_dim}s"]:
116             self.subplot_spec[f"n{wrap_dim}s"] = wrap
117         self.subplot_spec[f"n{flow_dim}s"] = flow
118         self.n_subplots = n_subplots
119         self.wrap_dim = wrap_dim
120 
121     def _determine_axis_sharing(self, pair_spec: PairSpec) -> None:
122         """Update subplot spec with default or specified axis sharing parameters."""
123         axis_to_dim = {"x": "col", "y": "row"}
124         key: str
125         val: str | bool
126         for axis in "xy":
127             key = f"share{axis}"
128             # Always use user-specified value, if present
129             if key not in self.subplot_spec:
130                 if axis in pair_spec.get("structure", {}):
131                     # Paired axes are shared along one dimension by default
132                     if self.wrap is None and pair_spec.get("cross", True):
133                         val = axis_to_dim[axis]
134                     else:
135                         val = False
136                 else:
137                     # This will pick up faceted plots, as well as single subplot
138                     # figures, where the value doesn't really matter
139                     val = True
140                 self.subplot_spec[key] = val
141 
142     def init_figure(
143         self,
144         pair_spec: PairSpec,
145         pyplot: bool = False,
146         figure_kws: dict | None = None,
147         target: Axes | Figure | SubFigure = None,
148     ) -> Figure:
149         """Initialize matplotlib objects and add seaborn-relevant metadata."""
150         # TODO reduce need to pass pair_spec here?
151 
152         if figure_kws is None:
153             figure_kws = {}
154 
155         if isinstance(target, mpl.axes.Axes):
156 
157             if max(self.subplot_spec["nrows"], self.subplot_spec["ncols"]) > 1:
158                 err = " ".join([
159                     "Cannot create multiple subplots after calling `Plot.on` with",
160                     f"a {mpl.axes.Axes} object.",
161                 ])
162                 try:
163                     err += f" You may want to use a {mpl.figure.SubFigure} instead."
164                 except AttributeError:  # SubFigure added in mpl 3.4
165                     pass
166                 raise RuntimeError(err)
167 
168             self._subplot_list = [{
169                 "ax": target,
170                 "left": True,
171                 "right": True,
172                 "top": True,
173                 "bottom": True,
174                 "col": None,
175                 "row": None,
176                 "x": "x",
177                 "y": "y",
178             }]
179             self._figure = target.figure
180             return self._figure
181 
182         elif (
183             hasattr(mpl.figure, "SubFigure")  # Added in mpl 3.4
184             and isinstance(target, mpl.figure.SubFigure)
185         ):
186             figure = target.figure
187         elif isinstance(target, mpl.figure.Figure):
188             figure = target
189         else:
190             if pyplot:
191                 figure = plt.figure(**figure_kws)
192             else:
193                 figure = mpl.figure.Figure(**figure_kws)
194             target = figure
195         self._figure = figure
196 
197         axs = target.subplots(**self.subplot_spec, squeeze=False)
198 
199         if self.wrap:
200             # Remove unused Axes and flatten the rest into a (2D) vector
201             axs_flat = axs.ravel({"col": "C", "row": "F"}[self.wrap_dim])
202             axs, extra = np.split(axs_flat, [self.n_subplots])
203             for ax in extra:
204                 ax.remove()
205             if self.wrap_dim == "col":
206                 axs = axs[np.newaxis, :]
207             else:
208                 axs = axs[:, np.newaxis]
209 
210         # Get i, j coordinates for each Axes object
211         # Note that i, j are with respect to faceting/pairing,
212         # not the subplot grid itself, (which only matters in the case of wrapping).
213         iter_axs: np.ndenumerate | zip
214         if not pair_spec.get("cross", True):
215             indices = np.arange(self.n_subplots)
216             iter_axs = zip(zip(indices, indices), axs.flat)
217         else:
218             iter_axs = np.ndenumerate(axs)
219 
220         self._subplot_list = []
221         for (i, j), ax in iter_axs:
222 
223             info = {"ax": ax}
224 
225             nrows, ncols = self.subplot_spec["nrows"], self.subplot_spec["ncols"]
226             if not self.wrap:
227                 info["left"] = j % ncols == 0
228                 info["right"] = (j + 1) % ncols == 0
229                 info["top"] = i == 0
230                 info["bottom"] = i == nrows - 1
231             elif self.wrap_dim == "col":
232                 info["left"] = j % ncols == 0
233                 info["right"] = ((j + 1) % ncols == 0) or ((j + 1) == self.n_subplots)
234                 info["top"] = j < ncols
235                 info["bottom"] = j >= (self.n_subplots - ncols)
236             elif self.wrap_dim == "row":
237                 info["left"] = i < nrows
238                 info["right"] = i >= self.n_subplots - nrows
239                 info["top"] = i % nrows == 0
240                 info["bottom"] = ((i + 1) % nrows == 0) or ((i + 1) == self.n_subplots)
241 
242             if not pair_spec.get("cross", True):
243                 info["top"] = j < ncols
244                 info["bottom"] = j >= self.n_subplots - ncols
245 
246             for dim in ["row", "col"]:
247                 idx = {"row": i, "col": j}[dim]
248                 info[dim] = self.grid_dimensions[dim][idx]
249 
250             for axis in "xy":
251 
252                 idx = {"x": j, "y": i}[axis]
253                 if axis in pair_spec.get("structure", {}):
254                     key = f"{axis}{idx}"
255                 else:
256                     key = axis
257                 info[axis] = key
258 
259             self._subplot_list.append(info)
260 
261         return figure
262 
263     def __iter__(self) -> Generator[dict, None, None]:  # TODO TypedDict?
264         """Yield each subplot dictionary with Axes object and metadata."""
265         yield from self._subplot_list
266 
267     def __len__(self) -> int:
268         """Return the number of subplots in this figure."""
269         return len(self._subplot_list)

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>]
2025-10-18 14:45:46.989 | INFO     | Search completed. Bug locations: [<file>seaborn/_core/subplots.py</file>
<class>Subplots</class>
<method>init_figure</method>
<code>
142     def init_figure(
143         self,
144         pair_spec: PairSpec,
145         pyplot: bool = False,
146         figure_kws: dict | None = None,
147         target: Axes | Figure | SubFigure = None,
148     ) -> Figure:
149         """Initialize matplotlib objects and add seaborn-relevant metadata."""
150         # TODO reduce need to pass pair_spec here?
151 
152         if figure_kws is None:
153             figure_kws = {}
154 
155         if isinstance(target, mpl.axes.Axes):
156 
157             if max(self.subplot_spec["nrows"], self.subplot_spec["ncols"]) > 1:
158                 err = " ".join([
159                     "Cannot create multiple subplots after calling `Plot.on` with",
160                     f"a {mpl.axes.Axes} object.",
161                 ])
162                 try:
163                     err += f" You may want to use a {mpl.figure.SubFigure} instead."
164                 except AttributeError:  # SubFigure added in mpl 3.4
165                     pass
166                 raise RuntimeError(err)
167 
168             self._subplot_list = [{
169                 "ax": target,
170                 "left": True,
171                 "right": True,
172                 "top": True,
173                 "bottom": True,
174                 "col": None,
175                 "row": None,
176                 "x": "x",
177                 "y": "y",
178             }]
179             self._figure = target.figure
180             return self._figure
181 
182         elif (
183             hasattr(mpl.figure, "SubFigure")  # Added in mpl 3.4
184             and isinstance(target, mpl.figure.SubFigure)
185         ):
186             figure = target.figure
187         elif isinstance(target, mpl.figure.Figure):
188             figure = target
189         else:
190             if pyplot:
191                 figure = plt.figure(**figure_kws)
192             else:
193                 figure = mpl.figure.Figure(**figure_kws)
194             target = figure
195         self._figure = figure
196 
197         axs = target.subplots(**self.subplot_spec, squeeze=False)
198 
199         if self.wrap:
200             # Remove unused Axes and flatten the rest into a (2D) vector
201             axs_flat = axs.ravel({"col": "C", "row": "F"}[self.wrap_dim])
202             axs, extra = np.split(axs_flat, [self.n_subplots])
203             for ax in extra:
204                 ax.remove()
205             if self.wrap_dim == "col":
206                 axs = axs[np.newaxis, :]
207             else:
208                 axs = axs[:, np.newaxis]
209 
210         # Get i, j coordinates for each Axes object
211         # Note that i, j are with respect to faceting/pairing,
212         # not the subplot grid itself, (which only matters in the case of wrapping).
213         iter_axs: np.ndenumerate | zip
214         if not pair_spec.get("cross", True):
215             indices = np.arange(self.n_subplots)
216             iter_axs = zip(zip(indices, indices), axs.flat)
217         else:
218             iter_axs = np.ndenumerate(axs)
219 
220         self._subplot_list = []
221         for (i, j), ax in iter_axs:
222 
223             info = {"ax": ax}
224 
225             nrows, ncols = self.subplot_spec["nrows"], self.subplot_spec["ncols"]
226             if not self.wrap:
227                 info["left"] = j % ncols == 0
228                 info["right"] = (j + 1) % ncols == 0
229                 info["top"] = i == 0
230                 info["bottom"] = i == nrows - 1
231             elif self.wrap_dim == "col":
232                 info["left"] = j % ncols == 0
233                 info["right"] = ((j + 1) % ncols == 0) or ((j + 1) == self.n_subplots)
234                 info["top"] = j < ncols
235                 info["bottom"] = j >= (self.n_subplots - ncols)
236             elif self.wrap_dim == "row":
237                 info["left"] = i < nrows
238                 info["right"] = i >= self.n_subplots - nrows
239                 info["top"] = i % nrows == 0
240                 info["bottom"] = ((i + 1) % nrows == 0) or ((i + 1) == self.n_subplots)
241 
242             if not pair_spec.get("cross", True):
243                 info["top"] = j < ncols
244                 info["bottom"] = j >= self.n_subplots - ncols
245 
246             for dim in ["row", "col"]:
247                 idx = {"row": i, "col": j}[dim]
248                 info[dim] = self.grid_dimensions[dim][idx]
249 
250             for axis in "xy":
251 
252                 idx = {"x": j, "y": i}[axis]
253                 if axis in pair_spec.get("structure", {}):
254                     key = f"{axis}{idx}"
255                 else:
256                     key = axis
257                 info[axis] = key
258 
259             self._subplot_list.append(info)
260 
261         return figure

</code><intended_behavior>Currently, the method assigns figure = target.figure for SubFigure targets, resulting in seaborn improperly linking to the parent figure instead of the subfigure itself. This is what's causing the figure title to be lost when using seaborn's plotting functions on subfigures. The intended behavior should instead recognize SubFigure instances as valid figure contexts on their own, not merely as proxies for their parent figures. Therefore, the assignment should be altered to treat SubFigure instances same as Figure, by directly assigning figure = target in cases where target is an instance of SubFigure. This will ensure seaborn properly integrates with matplotlib's hierarchy, preserving figure-level attributes (such as titles) when working with subfigures. This change aligns with the fix suggested in the issue description and respects the design philosophy of SubFigures being akin to Figures for the purpose of plotting, thus ensuring compatibility and functionality with existing and future seaborn functionalities.</intended_behavior>, <file>seaborn/_core/subplots.py</file>
<class>Subplots</class>
<method>None</method>
<code>
16 class Subplots:
17     """
18     Interface for creating and using matplotlib subplots based on seaborn parameters.
19 
20     Parameters
21     ----------
22     subplot_spec : dict
23         Keyword args for :meth:`matplotlib.figure.Figure.subplots`.
24     facet_spec : dict
25         Parameters that control subplot faceting.
26     pair_spec : dict
27         Parameters that control subplot pairing.
28     data : PlotData
29         Data used to define figure setup.
30 
31     """
32     def __init__(
33         self,
34         subplot_spec: dict,  # TODO define as TypedDict
35         facet_spec: FacetSpec,
36         pair_spec: PairSpec,
37     ):
38 
39         self.subplot_spec = subplot_spec
40 
41         self._check_dimension_uniqueness(facet_spec, pair_spec)
42         self._determine_grid_dimensions(facet_spec, pair_spec)
43         self._handle_wrapping(facet_spec, pair_spec)
44         self._determine_axis_sharing(pair_spec)
45 
46     def _check_dimension_uniqueness(
47         self, facet_spec: FacetSpec, pair_spec: PairSpec
48     ) -> None:
49         """Reject specs that pair and facet on (or wrap to) same figure dimension."""
50         err = None
51 
52         facet_vars = facet_spec.get("variables", {})
53 
54         if facet_spec.get("wrap") and {"col", "row"} <= set(facet_vars):
55             err = "Cannot wrap facets when specifying both `col` and `row`."
56         elif (
57             pair_spec.get("wrap")
58             and pair_spec.get("cross", True)
59             and len(pair_spec.get("structure", {}).get("x", [])) > 1
60             and len(pair_spec.get("structure", {}).get("y", [])) > 1
61         ):
62             err = "Cannot wrap subplots when pairing on both `x` and `y`."
63 
64         collisions = {"x": ["columns", "rows"], "y": ["rows", "columns"]}
65         for pair_axis, (multi_dim, wrap_dim) in collisions.items():
66             if pair_axis not in pair_spec.get("structure", {}):
67                 continue
68             elif multi_dim[:3] in facet_vars:
69                 err = f"Cannot facet the {multi_dim} while pairing on `{pair_axis}``."
70             elif wrap_dim[:3] in facet_vars and facet_spec.get("wrap"):
71                 err = f"Cannot wrap the {wrap_dim} while pairing on `{pair_axis}``."
72             elif wrap_dim[:3] in facet_vars and pair_spec.get("wrap"):
73                 err = f"Cannot wrap the {multi_dim} while faceting the {wrap_dim}."
74 
75         if err is not None:
76             raise RuntimeError(err)  # TODO what err class? Define PlotSpecError?
77 
78     def _determine_grid_dimensions(
79         self, facet_spec: FacetSpec, pair_spec: PairSpec
80     ) -> None:
81         """Parse faceting and pairing information to define figure structure."""
82         self.grid_dimensions: dict[str, list] = {}
83         for dim, axis in zip(["col", "row"], ["x", "y"]):
84 
85             facet_vars = facet_spec.get("variables", {})
86             if dim in facet_vars:
87                 self.grid_dimensions[dim] = facet_spec["structure"][dim]
88             elif axis in pair_spec.get("structure", {}):
89                 self.grid_dimensions[dim] = [
90                     None for _ in pair_spec.get("structure", {})[axis]
91                 ]
92             else:
93                 self.grid_dimensions[dim] = [None]
94 
95             self.subplot_spec[f"n{dim}s"] = len(self.grid_dimensions[dim])
96 
97         if not pair_spec.get("cross", True):
98             self.subplot_spec["nrows"] = 1
99 
100         self.n_subplots = self.subplot_spec["ncols"] * self.subplot_spec["nrows"]
101 
102     def _handle_wrapping(
103         self, facet_spec: FacetSpec, pair_spec: PairSpec
104     ) -> None:
105         """Update figure structure parameters based on facet/pair wrapping."""
106         self.wrap = wrap = facet_spec.get("wrap") or pair_spec.get("wrap")
107         if not wrap:
108             return
109 
110         wrap_dim = "row" if self.subplot_spec["nrows"] > 1 else "col"
111         flow_dim = {"row": "col", "col": "row"}[wrap_dim]
112         n_subplots = self.subplot_spec[f"n{wrap_dim}s"]
113         flow = int(np.ceil(n_subplots / wrap))
114 
115         if wrap < self.subplot_spec[f"n{wrap_dim}s"]:
116             self.subplot_spec[f"n{wrap_dim}s"] = wrap
117         self.subplot_spec[f"n{flow_dim}s"] = flow
118         self.n_subplots = n_subplots
119         self.wrap_dim = wrap_dim
120 
121     def _determine_axis_sharing(self, pair_spec: PairSpec) -> None:
122         """Update subplot spec with default or specified axis sharing parameters."""
123         axis_to_dim = {"x": "col", "y": "row"}
124         key: str
125         val: str | bool
126         for axis in "xy":
127             key = f"share{axis}"
128             # Always use user-specified value, if present
129             if key not in self.subplot_spec:
130                 if axis in pair_spec.get("structure", {}):
131                     # Paired axes are shared along one dimension by default
132                     if self.wrap is None and pair_spec.get("cross", True):
133                         val = axis_to_dim[axis]
134                     else:
135                         val = False
136                 else:
137                     # This will pick up faceted plots, as well as single subplot
138                     # figures, where the value doesn't really matter
139                     val = True
140                 self.subplot_spec[key] = val
141 
142     def init_figure(
143         self,
144         pair_spec: PairSpec,
145         pyplot: bool = False,
146         figure_kws: dict | None = None,
147         target: Axes | Figure | SubFigure = None,
148     ) -> Figure:
149         """Initialize matplotlib objects and add seaborn-relevant metadata."""
150         # TODO reduce need to pass pair_spec here?
151 
152         if figure_kws is None:
153             figure_kws = {}
154 
155         if isinstance(target, mpl.axes.Axes):
156 
157             if max(self.subplot_spec["nrows"], self.subplot_spec["ncols"]) > 1:
158                 err = " ".join([
159                     "Cannot create multiple subplots after calling `Plot.on` with",
160                     f"a {mpl.axes.Axes} object.",
161                 ])
162                 try:
163                     err += f" You may want to use a {mpl.figure.SubFigure} instead."
164                 except AttributeError:  # SubFigure added in mpl 3.4
165                     pass
166                 raise RuntimeError(err)
167 
168             self._subplot_list = [{
169                 "ax": target,
170                 "left": True,
171                 "right": True,
172                 "top": True,
173                 "bottom": True,
174                 "col": None,
175                 "row": None,
176                 "x": "x",
177                 "y": "y",
178             }]
179             self._figure = target.figure
180             return self._figure
181 
182         elif (
183             hasattr(mpl.figure, "SubFigure")  # Added in mpl 3.4
184             and isinstance(target, mpl.figure.SubFigure)
185         ):
186             figure = target.figure
187         elif isinstance(target, mpl.figure.Figure):
188             figure = target
189         else:
190             if pyplot:
191                 figure = plt.figure(**figure_kws)
192             else:
193                 figure = mpl.figure.Figure(**figure_kws)
194             target = figure
195         self._figure = figure
196 
197         axs = target.subplots(**self.subplot_spec, squeeze=False)
198 
199         if self.wrap:
200             # Remove unused Axes and flatten the rest into a (2D) vector
201             axs_flat = axs.ravel({"col": "C", "row": "F"}[self.wrap_dim])
202             axs, extra = np.split(axs_flat, [self.n_subplots])
203             for ax in extra:
204                 ax.remove()
205             if self.wrap_dim == "col":
206                 axs = axs[np.newaxis, :]
207             else:
208                 axs = axs[:, np.newaxis]
209 
210         # Get i, j coordinates for each Axes object
211         # Note that i, j are with respect to faceting/pairing,
212         # not the subplot grid itself, (which only matters in the case of wrapping).
213         iter_axs: np.ndenumerate | zip
214         if not pair_spec.get("cross", True):
215             indices = np.arange(self.n_subplots)
216             iter_axs = zip(zip(indices, indices), axs.flat)
217         else:
218             iter_axs = np.ndenumerate(axs)
219 
220         self._subplot_list = []
221         for (i, j), ax in iter_axs:
222 
223             info = {"ax": ax}
224 
225             nrows, ncols = self.subplot_spec["nrows"], self.subplot_spec["ncols"]
226             if not self.wrap:
227                 info["left"] = j % ncols == 0
228                 info["right"] = (j + 1) % ncols == 0
229                 info["top"] = i == 0
230                 info["bottom"] = i == nrows - 1
231             elif self.wrap_dim == "col":
232                 info["left"] = j % ncols == 0
233                 info["right"] = ((j + 1) % ncols == 0) or ((j + 1) == self.n_subplots)
234                 info["top"] = j < ncols
235                 info["bottom"] = j >= (self.n_subplots - ncols)
236             elif self.wrap_dim == "row":
237                 info["left"] = i < nrows
238                 info["right"] = i >= self.n_subplots - nrows
239                 info["top"] = i % nrows == 0
240                 info["bottom"] = ((i + 1) % nrows == 0) or ((i + 1) == self.n_subplots)
241 
242             if not pair_spec.get("cross", True):
243                 info["top"] = j < ncols
244                 info["bottom"] = j >= self.n_subplots - ncols
245 
246             for dim in ["row", "col"]:
247                 idx = {"row": i, "col": j}[dim]
248                 info[dim] = self.grid_dimensions[dim][idx]
249 
250             for axis in "xy":
251 
252                 idx = {"x": j, "y": i}[axis]
253                 if axis in pair_spec.get("structure", {}):
254                     key = f"{axis}{idx}"
255                 else:
256                     key = axis
257                 info[axis] = key
258 
259             self._subplot_list.append(info)
260 
261         return figure
262 
263     def __iter__(self) -> Generator[dict, None, None]:  # TODO TypedDict?
264         """Yield each subplot dictionary with Axes object and metadata."""
265         yield from self._subplot_list
266 
267     def __len__(self) -> int:
268         """Return the number of subplots in this figure."""
269         return len(self._subplot_list)

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>]
2025-10-18 14:45:46.989 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-18 14:45:46.989 | INFO     | Search-only: skipping patch selection
2025-10-18 14:45:47.060 | INFO     | Task mwaskom__seaborn-3216 completed successfully.
2025-10-18 14:45:47.060 | INFO     | No patch generated. You can try running ACR again.
