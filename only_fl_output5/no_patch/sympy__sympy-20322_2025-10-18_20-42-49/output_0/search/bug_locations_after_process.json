[
    {
        "rel_file_path": "sympy/core/sympify.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sympy__sympy/setup_sympy__sympy__1.8/sympy/core/sympify.py",
        "start": 92,
        "end": 484,
        "class_name": null,
        "method_name": "sympify",
        "code": "92 def sympify(a, locals=None, convert_xor=True, strict=False, rational=False,\n93         evaluate=None):\n94     \"\"\"\n95     Converts an arbitrary expression to a type that can be used inside SymPy.\n96 \n97     Explanation\n98     ===========\n99 \n100     It will convert Python ints into instances of sympy.Integer,\n101     floats into instances of sympy.Float, etc. It is also able to coerce symbolic\n102     expressions which inherit from Basic. This can be useful in cooperation\n103     with SAGE.\n104 \n105     .. warning::\n106         Note that this function uses ``eval``, and thus shouldn't be used on\n107         unsanitized input.\n108 \n109     If the argument is already a type that SymPy understands, it will do\n110     nothing but return that value. This can be used at the beginning of a\n111     function to ensure you are working with the correct type.\n112 \n113     Examples\n114     ========\n115 \n116     >>> from sympy import sympify\n117 \n118     >>> sympify(2).is_integer\n119     True\n120     >>> sympify(2).is_real\n121     True\n122 \n123     >>> sympify(2.0).is_real\n124     True\n125     >>> sympify(\"2.0\").is_real\n126     True\n127     >>> sympify(\"2e-45\").is_real\n128     True\n129 \n130     If the expression could not be converted, a SympifyError is raised.\n131 \n132     >>> sympify(\"x***2\")\n133     Traceback (most recent call last):\n134     ...\n135     SympifyError: SympifyError: \"could not parse 'x***2'\"\n136 \n137     Locals\n138     ------\n139 \n140     The sympification happens with access to everything that is loaded\n141     by ``from sympy import *``; anything used in a string that is not\n142     defined by that import will be converted to a symbol. In the following,\n143     the ``bitcount`` function is treated as a symbol and the ``O`` is\n144     interpreted as the Order object (used with series) and it raises\n145     an error when used improperly:\n146 \n147     >>> s = 'bitcount(42)'\n148     >>> sympify(s)\n149     bitcount(42)\n150     >>> sympify(\"O(x)\")\n151     O(x)\n152     >>> sympify(\"O + 1\")\n153     Traceback (most recent call last):\n154     ...\n155     TypeError: unbound method...\n156 \n157     In order to have ``bitcount`` be recognized it can be imported into a\n158     namespace dictionary and passed as locals:\n159 \n160     >>> from sympy.core.compatibility import exec_\n161     >>> ns = {}\n162     >>> exec_('from sympy.core.evalf import bitcount', ns)\n163     >>> sympify(s, locals=ns)\n164     6\n165 \n166     In order to have the ``O`` interpreted as a Symbol, identify it as such\n167     in the namespace dictionary. This can be done in a variety of ways; all\n168     three of the following are possibilities:\n169 \n170     >>> from sympy import Symbol\n171     >>> ns[\"O\"] = Symbol(\"O\")  # method 1\n172     >>> exec_('from sympy.abc import O', ns)  # method 2\n173     >>> ns.update(dict(O=Symbol(\"O\")))  # method 3\n174     >>> sympify(\"O + 1\", locals=ns)\n175     O + 1\n176 \n177     If you want *all* single-letter and Greek-letter variables to be symbols\n178     then you can use the clashing-symbols dictionaries that have been defined\n179     there as private variables: _clash1 (single-letter variables), _clash2\n180     (the multi-letter Greek names) or _clash (both single and multi-letter\n181     names that are defined in abc).\n182 \n183     >>> from sympy.abc import _clash1\n184     >>> _clash1\n185     {'C': C, 'E': E, 'I': I, 'N': N, 'O': O, 'Q': Q, 'S': S}\n186     >>> sympify('I & Q', _clash1)\n187     I & Q\n188 \n189     Strict\n190     ------\n191 \n192     If the option ``strict`` is set to ``True``, only the types for which an\n193     explicit conversion has been defined are converted. In the other\n194     cases, a SympifyError is raised.\n195 \n196     >>> print(sympify(None))\n197     None\n198     >>> sympify(None, strict=True)\n199     Traceback (most recent call last):\n200     ...\n201     SympifyError: SympifyError: None\n202 \n203     Evaluation\n204     ----------\n205 \n206     If the option ``evaluate`` is set to ``False``, then arithmetic and\n207     operators will be converted into their SymPy equivalents and the\n208     ``evaluate=False`` option will be added. Nested ``Add`` or ``Mul`` will\n209     be denested first. This is done via an AST transformation that replaces\n210     operators with their SymPy equivalents, so if an operand redefines any\n211     of those operations, the redefined operators will not be used. If\n212     argument a is not a string, the mathematical expression is evaluated\n213     before being passed to sympify, so adding evaluate=False will still\n214     return the evaluated result of expression.\n215 \n216     >>> sympify('2**2 / 3 + 5')\n217     19/3\n218     >>> sympify('2**2 / 3 + 5', evaluate=False)\n219     2**2/3 + 5\n220     >>> sympify('4/2+7', evaluate=True)\n221     9\n222     >>> sympify('4/2+7', evaluate=False)\n223     4/2 + 7\n224     >>> sympify(4/2+7, evaluate=False)\n225     9.00000000000000\n226 \n227     Extending\n228     ---------\n229 \n230     To extend ``sympify`` to convert custom objects (not derived from ``Basic``),\n231     just define a ``_sympy_`` method to your class. You can do that even to\n232     classes that you do not own by subclassing or adding the method at runtime.\n233 \n234     >>> from sympy import Matrix\n235     >>> class MyList1(object):\n236     ...     def __iter__(self):\n237     ...         yield 1\n238     ...         yield 2\n239     ...         return\n240     ...     def __getitem__(self, i): return list(self)[i]\n241     ...     def _sympy_(self): return Matrix(self)\n242     >>> sympify(MyList1())\n243     Matrix([\n244     [1],\n245     [2]])\n246 \n247     If you do not have control over the class definition you could also use the\n248     ``converter`` global dictionary. The key is the class and the value is a\n249     function that takes a single argument and returns the desired SymPy\n250     object, e.g. ``converter[MyList] = lambda x: Matrix(x)``.\n251 \n252     >>> class MyList2(object):   # XXX Do not do this if you control the class!\n253     ...     def __iter__(self):  #     Use _sympy_!\n254     ...         yield 1\n255     ...         yield 2\n256     ...         return\n257     ...     def __getitem__(self, i): return list(self)[i]\n258     >>> from sympy.core.sympify import converter\n259     >>> converter[MyList2] = lambda x: Matrix(x)\n260     >>> sympify(MyList2())\n261     Matrix([\n262     [1],\n263     [2]])\n264 \n265     Notes\n266     =====\n267 \n268     The keywords ``rational`` and ``convert_xor`` are only used\n269     when the input is a string.\n270 \n271     convert_xor\n272     -----------\n273 \n274     >>> sympify('x^y',convert_xor=True)\n275     x**y\n276     >>> sympify('x^y',convert_xor=False)\n277     x ^ y\n278 \n279     rational\n280     --------\n281 \n282     >>> sympify('0.1',rational=False)\n283     0.1\n284     >>> sympify('0.1',rational=True)\n285     1/10\n286 \n287     Sometimes autosimplification during sympification results in expressions\n288     that are very different in structure than what was entered. Until such\n289     autosimplification is no longer done, the ``kernS`` function might be of\n290     some use. In the example below you can see how an expression reduces to\n291     -1 by autosimplification, but does not do so when ``kernS`` is used.\n292 \n293     >>> from sympy.core.sympify import kernS\n294     >>> from sympy.abc import x\n295     >>> -2*(-(-x + 1/x)/(x*(x - 1/x)**2) - 1/(x*(x - 1/x))) - 1\n296     -1\n297     >>> s = '-2*(-(-x + 1/x)/(x*(x - 1/x)**2) - 1/(x*(x - 1/x))) - 1'\n298     >>> sympify(s)\n299     -1\n300     >>> kernS(s)\n301     -2*(-(-x + 1/x)/(x*(x - 1/x)**2) - 1/(x*(x - 1/x))) - 1\n302 \n303     Parameters\n304     ==========\n305 \n306     a :\n307         - any object defined in SymPy\n308         - standard numeric python types: int, long, float, Decimal\n309         - strings (like \"0.09\", \"2e-19\" or 'sin(x)')\n310         - booleans, including ``None`` (will leave ``None`` unchanged)\n311         - dict, lists, sets or tuples containing any of the above\n312 \n313     convert_xor : boolean, optional\n314         If true, treats XOR as exponentiation.\n315         If False, treats XOR as XOR itself.\n316         Used only when input is a string.\n317 \n318     locals : any object defined in SymPy, optional\n319         In order to have strings be recognized it can be imported\n320         into a namespace dictionary and passed as locals.\n321 \n322     strict : boolean, optional\n323         If the option strict is set to True, only the types for which\n324         an explicit conversion has been defined are converted. In the\n325         other cases, a SympifyError is raised.\n326 \n327     rational : boolean, optional\n328         If true, converts floats into Rational.\n329         If false, it lets floats remain as it is.\n330         Used only when input is a string.\n331 \n332     evaluate : boolean, optional\n333         If False, then arithmetic and operators will be converted into\n334         their SymPy equivalents. If True the expression will be evaluated\n335         and the result will be returned.\n336 \n337     \"\"\"\n338     # XXX: If a is a Basic subclass rather than instance (e.g. sin rather than\n339     # sin(x)) then a.__sympy__ will be the property. Only on the instance will\n340     # a.__sympy__ give the *value* of the property (True). Since sympify(sin)\n341     # was used for a long time we allow it to pass. However if strict=True as\n342     # is the case in internal calls to _sympify then we only allow\n343     # is_sympy=True.\n344     #\n345     # https://github.com/sympy/sympy/issues/20124\n346     is_sympy = getattr(a, '__sympy__', None)\n347     if is_sympy is True:\n348         return a\n349     elif is_sympy is not None:\n350         if not strict:\n351             return a\n352         else:\n353             raise SympifyError(a)\n354 \n355     if isinstance(a, CantSympify):\n356         raise SympifyError(a)\n357     cls = getattr(a, \"__class__\", None)\n358     if cls is None:\n359         cls = type(a)  # Probably an old-style class\n360     conv = converter.get(cls, None)\n361     if conv is not None:\n362         return conv(a)\n363 \n364     for superclass in getmro(cls):\n365         try:\n366             return converter[superclass](a)\n367         except KeyError:\n368             continue\n369 \n370     if cls is type(None):\n371         if strict:\n372             raise SympifyError(a)\n373         else:\n374             return a\n375 \n376     if evaluate is None:\n377         evaluate = global_parameters.evaluate\n378 \n379     # Support for basic numpy datatypes\n380     if _is_numpy_instance(a):\n381         import numpy as np\n382         if np.isscalar(a):\n383             return _convert_numpy_types(a, locals=locals,\n384                 convert_xor=convert_xor, strict=strict, rational=rational,\n385                 evaluate=evaluate)\n386 \n387     _sympy_ = getattr(a, \"_sympy_\", None)\n388     if _sympy_ is not None:\n389         try:\n390             return a._sympy_()\n391         # XXX: Catches AttributeError: 'SympyConverter' object has no\n392         # attribute 'tuple'\n393         # This is probably a bug somewhere but for now we catch it here.\n394         except AttributeError:\n395             pass\n396 \n397     if not strict:\n398         # Put numpy array conversion _before_ float/int, see\n399         # <https://github.com/sympy/sympy/issues/13924>.\n400         flat = getattr(a, \"flat\", None)\n401         if flat is not None:\n402             shape = getattr(a, \"shape\", None)\n403             if shape is not None:\n404                 from ..tensor.array import Array\n405                 return Array(a.flat, a.shape)  # works with e.g. NumPy arrays\n406 \n407     if not isinstance(a, str):\n408         if _is_numpy_instance(a):\n409             import numpy as np\n410             assert not isinstance(a, np.number)\n411             if isinstance(a, np.ndarray):\n412                 # Scalar arrays (those with zero dimensions) have sympify\n413                 # called on the scalar element.\n414                 if a.ndim == 0:\n415                     try:\n416                         return sympify(a.item(),\n417                                        locals=locals,\n418                                        convert_xor=convert_xor,\n419                                        strict=strict,\n420                                        rational=rational,\n421                                        evaluate=evaluate)\n422                     except SympifyError:\n423                         pass\n424         else:\n425             # float and int can coerce size-one numpy arrays to their lone\n426             # element.  See issue https://github.com/numpy/numpy/issues/10404.\n427             for coerce in (float, int):\n428                 try:\n429                     return sympify(coerce(a))\n430                 except (TypeError, ValueError, AttributeError, SympifyError):\n431                     continue\n432 \n433     if strict:\n434         raise SympifyError(a)\n435 \n436     if iterable(a):\n437         try:\n438             return type(a)([sympify(x, locals=locals, convert_xor=convert_xor,\n439                 rational=rational) for x in a])\n440         except TypeError:\n441             # Not all iterables are rebuildable with their type.\n442             pass\n443     if isinstance(a, dict):\n444         try:\n445             return type(a)([sympify(x, locals=locals, convert_xor=convert_xor,\n446                 rational=rational) for x in a.items()])\n447         except TypeError:\n448             # Not all iterables are rebuildable with their type.\n449             pass\n450 \n451     if not isinstance(a, str):\n452         try:\n453             a = str(a)\n454         except Exception as exc:\n455             raise SympifyError(a, exc)\n456         from sympy.utilities.exceptions import SymPyDeprecationWarning\n457         SymPyDeprecationWarning(\n458             feature=\"String fallback in sympify\",\n459             useinstead= \\\n460                 'sympify(str(obj)) or ' + \\\n461                 'sympy.core.sympify.converter or obj._sympy_',\n462             issue=18066,\n463             deprecated_since_version='1.6'\n464         ).warn()\n465 \n466     from sympy.parsing.sympy_parser import (parse_expr, TokenError,\n467                                             standard_transformations)\n468     from sympy.parsing.sympy_parser import convert_xor as t_convert_xor\n469     from sympy.parsing.sympy_parser import rationalize as t_rationalize\n470 \n471     transformations = standard_transformations\n472 \n473     if rational:\n474         transformations += (t_rationalize,)\n475     if convert_xor:\n476         transformations += (t_convert_xor,)\n477 \n478     try:\n479         a = a.replace('\\n', '')\n480         expr = parse_expr(a, local_dict=locals, transformations=transformations, evaluate=evaluate)\n481     except (TokenError, SyntaxError) as exc:\n482         raise SympifyError('could not parse %r' % a, exc)\n483 \n484     return expr\n",
        "intended_behavior": "The `sympify` method needs to ensure consistent handling of the `evaluate` parameter, especially in cases involving functions like `ceiling`. The intended behavior here would be to ensure that when `evaluate=False`, expressions like `4*ceiling(x/4 - 3/4)` are kept unevaluated in a consistent manner across versions. This could involve inspecting how the AST transformation is applied when `evaluate=False` and ensuring that the logic does not inadvertently simplify or alter the structure of expressions involving `ceiling`. Additionally, it would be crucial to preserve existing functionalities for all other expressions and use cases, ensuring that any adjustments made do not affect the broader utility of `sympify`."
    },
    {
        "rel_file_path": "sympy/simplify/simplify.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sympy__sympy/setup_sympy__sympy__1.8/sympy/simplify/simplify.py",
        "start": 1,
        "end": 2167,
        "class_name": null,
        "method_name": null,
        "code": "1 from __future__ import print_function, division\n2 \n3 from collections import defaultdict\n4 \n5 from sympy.core import (Basic, S, Add, Mul, Pow, Symbol, sympify,\n6                         expand_func, Function, Dummy, Expr, factor_terms,\n7                         expand_power_exp, Eq)\n8 from sympy.core.compatibility import iterable, ordered, as_int\n9 from sympy.core.parameters import global_parameters\n10 from sympy.core.function import (expand_log, count_ops, _mexpand, _coeff_isneg,\n11     nfloat, expand_mul)\n12 from sympy.core.numbers import Float, I, pi, Rational, Integer\n13 from sympy.core.relational import Relational\n14 from sympy.core.rules import Transform\n15 from sympy.core.sympify import _sympify\n16 from sympy.functions import gamma, exp, sqrt, log, exp_polar, re\n17 from sympy.functions.combinatorial.factorials import CombinatorialFunction\n18 from sympy.functions.elementary.complexes import unpolarify, Abs\n19 from sympy.functions.elementary.exponential import ExpBase\n20 from sympy.functions.elementary.hyperbolic import HyperbolicFunction\n21 from sympy.functions.elementary.integers import ceiling\n22 from sympy.functions.elementary.piecewise import Piecewise, piecewise_fold\n23 from sympy.functions.elementary.trigonometric import TrigonometricFunction\n24 from sympy.functions.special.bessel import besselj, besseli, besselk, jn, bessely\n25 from sympy.functions.special.tensor_functions import KroneckerDelta\n26 from sympy.polys import together, cancel, factor\n27 from sympy.simplify.combsimp import combsimp\n28 from sympy.simplify.cse_opts import sub_pre, sub_post\n29 from sympy.simplify.powsimp import powsimp\n30 from sympy.simplify.radsimp import radsimp, fraction, collect_abs\n31 from sympy.simplify.sqrtdenest import sqrtdenest\n32 from sympy.simplify.trigsimp import trigsimp, exptrigsimp\n33 from sympy.utilities.iterables import has_variety, sift\n34 \n35 \n36 import mpmath\n37 \n38 \n39 \n40 def separatevars(expr, symbols=[], dict=False, force=False):\n41     \"\"\"\n42     Separates variables in an expression, if possible.  By\n43     default, it separates with respect to all symbols in an\n44     expression and collects constant coefficients that are\n45     independent of symbols.\n46 \n47     Explanation\n48     ===========\n49 \n50     If ``dict=True`` then the separated terms will be returned\n51     in a dictionary keyed to their corresponding symbols.\n52     By default, all symbols in the expression will appear as\n53     keys; if symbols are provided, then all those symbols will\n54     be used as keys, and any terms in the expression containing\n55     other symbols or non-symbols will be returned keyed to the\n56     string 'coeff'. (Passing None for symbols will return the\n57     expression in a dictionary keyed to 'coeff'.)\n58 \n59     If ``force=True``, then bases of powers will be separated regardless\n60     of assumptions on the symbols involved.\n61 \n62     Notes\n63     =====\n64 \n65     The order of the factors is determined by Mul, so that the\n66     separated expressions may not necessarily be grouped together.\n67 \n68     Although factoring is necessary to separate variables in some\n69     expressions, it is not necessary in all cases, so one should not\n70     count on the returned factors being factored.\n71 \n72     Examples\n73     ========\n74 \n75     >>> from sympy.abc import x, y, z, alpha\n76     >>> from sympy import separatevars, sin\n77     >>> separatevars((x*y)**y)\n78     (x*y)**y\n79     >>> separatevars((x*y)**y, force=True)\n80     x**y*y**y\n81 \n82     >>> e = 2*x**2*z*sin(y)+2*z*x**2\n83     >>> separatevars(e)\n84     2*x**2*z*(sin(y) + 1)\n85     >>> separatevars(e, symbols=(x, y), dict=True)\n86     {'coeff': 2*z, x: x**2, y: sin(y) + 1}\n87     >>> separatevars(e, [x, y, alpha], dict=True)\n88     {'coeff': 2*z, alpha: 1, x: x**2, y: sin(y) + 1}\n89 \n90     If the expression is not really separable, or is only partially\n91     separable, separatevars will do the best it can to separate it\n92     by using factoring.\n93 \n94     >>> separatevars(x + x*y - 3*x**2)\n95     -x*(3*x - y - 1)\n96 \n97     If the expression is not separable then expr is returned unchanged\n98     or (if dict=True) then None is returned.\n99 \n100     >>> eq = 2*x + y*sin(x)\n101     >>> separatevars(eq) == eq\n102     True\n103     >>> separatevars(2*x + y*sin(x), symbols=(x, y), dict=True) is None\n104     True\n105 \n106     \"\"\"\n107     expr = sympify(expr)\n108     if dict:\n109         return _separatevars_dict(_separatevars(expr, force), symbols)\n110     else:\n111         return _separatevars(expr, force)\n112 \n113 \n114 def _separatevars(expr, force):\n115     if isinstance(expr, Abs):\n116         arg = expr.args[0]\n117         if arg.is_Mul and not arg.is_number:\n118             s = separatevars(arg, dict=True, force=force)\n119             if s is not None:\n120                 return Mul(*map(expr.func, s.values()))\n121             else:\n122                 return expr\n123 \n124     if len(expr.free_symbols) < 2:\n125         return expr\n126 \n127     # don't destroy a Mul since much of the work may already be done\n128     if expr.is_Mul:\n129         args = list(expr.args)\n130         changed = False\n131         for i, a in enumerate(args):\n132             args[i] = separatevars(a, force)\n133             changed = changed or args[i] != a\n134         if changed:\n135             expr = expr.func(*args)\n136         return expr\n137 \n138     # get a Pow ready for expansion\n139     if expr.is_Pow:\n140         expr = Pow(separatevars(expr.base, force=force), expr.exp)\n141 \n142     # First try other expansion methods\n143     expr = expr.expand(mul=False, multinomial=False, force=force)\n144 \n145     _expr, reps = posify(expr) if force else (expr, {})\n146     expr = factor(_expr).subs(reps)\n147 \n148     if not expr.is_Add:\n149         return expr\n150 \n151     # Find any common coefficients to pull out\n152     args = list(expr.args)\n153     commonc = args[0].args_cnc(cset=True, warn=False)[0]\n154     for i in args[1:]:\n155         commonc &= i.args_cnc(cset=True, warn=False)[0]\n156     commonc = Mul(*commonc)\n157     commonc = commonc.as_coeff_Mul()[1]  # ignore constants\n158     commonc_set = commonc.args_cnc(cset=True, warn=False)[0]\n159 \n160     # remove them\n161     for i, a in enumerate(args):\n162         c, nc = a.args_cnc(cset=True, warn=False)\n163         c = c - commonc_set\n164         args[i] = Mul(*c)*Mul(*nc)\n165     nonsepar = Add(*args)\n166 \n167     if len(nonsepar.free_symbols) > 1:\n168         _expr = nonsepar\n169         _expr, reps = posify(_expr) if force else (_expr, {})\n170         _expr = (factor(_expr)).subs(reps)\n171 \n172         if not _expr.is_Add:\n173             nonsepar = _expr\n174 \n175     return commonc*nonsepar\n176 \n177 \n178 def _separatevars_dict(expr, symbols):\n179     if symbols:\n180         if not all((t.is_Atom for t in symbols)):\n181             raise ValueError(\"symbols must be Atoms.\")\n182         symbols = list(symbols)\n183     elif symbols is None:\n184         return {'coeff': expr}\n185     else:\n186         symbols = list(expr.free_symbols)\n187         if not symbols:\n188             return None\n189 \n190     ret = dict(((i, []) for i in symbols + ['coeff']))\n191 \n192     for i in Mul.make_args(expr):\n193         expsym = i.free_symbols\n194         intersection = set(symbols).intersection(expsym)\n195         if len(intersection) > 1:\n196             return None\n197         if len(intersection) == 0:\n198             # There are no symbols, so it is part of the coefficient\n199             ret['coeff'].append(i)\n200         else:\n201             ret[intersection.pop()].append(i)\n202 \n203     # rebuild\n204     for k, v in ret.items():\n205         ret[k] = Mul(*v)\n206 \n207     return ret\n208 \n209 \n210 def _is_sum_surds(p):\n211     args = p.args if p.is_Add else [p]\n212     for y in args:\n213         if not ((y**2).is_Rational and y.is_extended_real):\n214             return False\n215     return True\n216 \n217 \n218 def posify(eq):\n219     \"\"\"Return ``eq`` (with generic symbols made positive) and a\n220     dictionary containing the mapping between the old and new\n221     symbols.\n222 \n223     Explanation\n224     ===========\n225 \n226     Any symbol that has positive=None will be replaced with a positive dummy\n227     symbol having the same name. This replacement will allow more symbolic\n228     processing of expressions, especially those involving powers and\n229     logarithms.\n230 \n231     A dictionary that can be sent to subs to restore ``eq`` to its original\n232     symbols is also returned.\n233 \n234     >>> from sympy import posify, Symbol, log, solve\n235     >>> from sympy.abc import x\n236     >>> posify(x + Symbol('p', positive=True) + Symbol('n', negative=True))\n237     (_x + n + p, {_x: x})\n238 \n239     >>> eq = 1/x\n240     >>> log(eq).expand()\n241     log(1/x)\n242     >>> log(posify(eq)[0]).expand()\n243     -log(_x)\n244     >>> p, rep = posify(eq)\n245     >>> log(p).expand().subs(rep)\n246     -log(x)\n247 \n248     It is possible to apply the same transformations to an iterable\n249     of expressions:\n250 \n251     >>> eq = x**2 - 4\n252     >>> solve(eq, x)\n253     [-2, 2]\n254     >>> eq_x, reps = posify([eq, x]); eq_x\n255     [_x**2 - 4, _x]\n256     >>> solve(*eq_x)\n257     [2]\n258     \"\"\"\n259     eq = sympify(eq)\n260     if iterable(eq):\n261         f = type(eq)\n262         eq = list(eq)\n263         syms = set()\n264         for e in eq:\n265             syms = syms.union(e.atoms(Symbol))\n266         reps = {}\n267         for s in syms:\n268             reps.update(dict((v, k) for k, v in posify(s)[1].items()))\n269         for i, e in enumerate(eq):\n270             eq[i] = e.subs(reps)\n271         return f(eq), {r: s for s, r in reps.items()}\n272 \n273     reps = {s: Dummy(s.name, positive=True, **s.assumptions0)\n274                  for s in eq.free_symbols if s.is_positive is None}\n275     eq = eq.subs(reps)\n276     return eq, {r: s for s, r in reps.items()}\n277 \n278 \n279 def hypersimp(f, k):\n280     \"\"\"Given combinatorial term f(k) simplify its consecutive term ratio\n281        i.e. f(k+1)/f(k).  The input term can be composed of functions and\n282        integer sequences which have equivalent representation in terms\n283        of gamma special function.\n284 \n285        Explanation\n286        ===========\n287 \n288        The algorithm performs three basic steps:\n289 \n290        1. Rewrite all functions in terms of gamma, if possible.\n291 \n292        2. Rewrite all occurrences of gamma in terms of products\n293           of gamma and rising factorial with integer,  absolute\n294           constant exponent.\n295 \n296        3. Perform simplification of nested fractions, powers\n297           and if the resulting expression is a quotient of\n298           polynomials, reduce their total degree.\n299 \n300        If f(k) is hypergeometric then as result we arrive with a\n301        quotient of polynomials of minimal degree. Otherwise None\n302        is returned.\n303 \n304        For more information on the implemented algorithm refer to:\n305 \n306        1. W. Koepf, Algorithms for m-fold Hypergeometric Summation,\n307           Journal of Symbolic Computation (1995) 20, 399-417\n308     \"\"\"\n309     f = sympify(f)\n310 \n311     g = f.subs(k, k + 1) / f\n312 \n313     g = g.rewrite(gamma)\n314     if g.has(Piecewise):\n315         g = piecewise_fold(g)\n316         g = g.args[-1][0]\n317     g = expand_func(g)\n318     g = powsimp(g, deep=True, combine='exp')\n319 \n320     if g.is_rational_function(k):\n321         return simplify(g, ratio=S.Infinity)\n322     else:\n323         return None\n324 \n325 \n326 def hypersimilar(f, g, k):\n327     \"\"\"\n328     Returns True if ``f`` and ``g`` are hyper-similar.\n329 \n330     Explanation\n331     ===========\n332 \n333     Similarity in hypergeometric sense means that a quotient of\n334     f(k) and g(k) is a rational function in ``k``. This procedure\n335     is useful in solving recurrence relations.\n336 \n337     For more information see hypersimp().\n338 \n339     \"\"\"\n340     f, g = list(map(sympify, (f, g)))\n341 \n342     h = (f/g).rewrite(gamma)\n343     h = h.expand(func=True, basic=False)\n344 \n345     return h.is_rational_function(k)\n346 \n347 \n348 def signsimp(expr, evaluate=None):\n349     \"\"\"Make all Add sub-expressions canonical wrt sign.\n350 \n351     Explanation\n352     ===========\n353 \n354     If an Add subexpression, ``a``, can have a sign extracted,\n355     as determined by could_extract_minus_sign, it is replaced\n356     with Mul(-1, a, evaluate=False). This allows signs to be\n357     extracted from powers and products.\n358 \n359     Examples\n360     ========\n361 \n362     >>> from sympy import signsimp, exp, symbols\n363     >>> from sympy.abc import x, y\n364     >>> i = symbols('i', odd=True)\n365     >>> n = -1 + 1/x\n366     >>> n/x/(-n)**2 - 1/n/x\n367     (-1 + 1/x)/(x*(1 - 1/x)**2) - 1/(x*(-1 + 1/x))\n368     >>> signsimp(_)\n369     0\n370     >>> x*n + x*-n\n371     x*(-1 + 1/x) + x*(1 - 1/x)\n372     >>> signsimp(_)\n373     0\n374 \n375     Since powers automatically handle leading signs\n376 \n377     >>> (-2)**i\n378     -2**i\n379 \n380     signsimp can be used to put the base of a power with an integer\n381     exponent into canonical form:\n382 \n383     >>> n**i\n384     (-1 + 1/x)**i\n385 \n386     By default, signsimp doesn't leave behind any hollow simplification:\n387     if making an Add canonical wrt sign didn't change the expression, the\n388     original Add is restored. If this is not desired then the keyword\n389     ``evaluate`` can be set to False:\n390 \n391     >>> e = exp(y - x)\n392     >>> signsimp(e) == e\n393     True\n394     >>> signsimp(e, evaluate=False)\n395     exp(-(x - y))\n396 \n397     \"\"\"\n398     if evaluate is None:\n399         evaluate = global_parameters.evaluate\n400     expr = sympify(expr)\n401     if not isinstance(expr, (Expr, Relational)) or expr.is_Atom:\n402         return expr\n403     e = sub_post(sub_pre(expr))\n404     if not isinstance(e, (Expr, Relational)) or e.is_Atom:\n405         return e\n406     if e.is_Add:\n407         return e.func(*[signsimp(a, evaluate) for a in e.args])\n408     if evaluate:\n409         e = e.xreplace({m: -(-m) for m in e.atoms(Mul) if -(-m) != m})\n410     return e\n411 \n412 \n413 def simplify(expr, ratio=1.7, measure=count_ops, rational=False, inverse=False, doit=True, **kwargs):\n414     \"\"\"Simplifies the given expression.\n415 \n416     Explanation\n417     ===========\n418 \n419     Simplification is not a well defined term and the exact strategies\n420     this function tries can change in the future versions of SymPy. If\n421     your algorithm relies on \"simplification\" (whatever it is), try to\n422     determine what you need exactly  -  is it powsimp()?, radsimp()?,\n423     together()?, logcombine()?, or something else? And use this particular\n424     function directly, because those are well defined and thus your algorithm\n425     will be robust.\n426 \n427     Nonetheless, especially for interactive use, or when you don't know\n428     anything about the structure of the expression, simplify() tries to apply\n429     intelligent heuristics to make the input expression \"simpler\".  For\n430     example:\n431 \n432     >>> from sympy import simplify, cos, sin\n433     >>> from sympy.abc import x, y\n434     >>> a = (x + x**2)/(x*sin(y)**2 + x*cos(y)**2)\n435     >>> a\n436     (x**2 + x)/(x*sin(y)**2 + x*cos(y)**2)\n437     >>> simplify(a)\n438     x + 1\n439 \n440     Note that we could have obtained the same result by using specific\n441     simplification functions:\n442 \n443     >>> from sympy import trigsimp, cancel\n444     >>> trigsimp(a)\n445     (x**2 + x)/x\n446     >>> cancel(_)\n447     x + 1\n448 \n449     In some cases, applying :func:`simplify` may actually result in some more\n450     complicated expression. The default ``ratio=1.7`` prevents more extreme\n451     cases: if (result length)/(input length) > ratio, then input is returned\n452     unmodified.  The ``measure`` parameter lets you specify the function used\n453     to determine how complex an expression is.  The function should take a\n454     single argument as an expression and return a number such that if\n455     expression ``a`` is more complex than expression ``b``, then\n456     ``measure(a) > measure(b)``.  The default measure function is\n457     :func:`~.count_ops`, which returns the total number of operations in the\n458     expression.\n459 \n460     For example, if ``ratio=1``, ``simplify`` output can't be longer\n461     than input.\n462 \n463     ::\n464 \n465         >>> from sympy import sqrt, simplify, count_ops, oo\n466         >>> root = 1/(sqrt(2)+3)\n467 \n468     Since ``simplify(root)`` would result in a slightly longer expression,\n469     root is returned unchanged instead::\n470 \n471        >>> simplify(root, ratio=1) == root\n472        True\n473 \n474     If ``ratio=oo``, simplify will be applied anyway::\n475 \n476         >>> count_ops(simplify(root, ratio=oo)) > count_ops(root)\n477         True\n478 \n479     Note that the shortest expression is not necessary the simplest, so\n480     setting ``ratio`` to 1 may not be a good idea.\n481     Heuristically, the default value ``ratio=1.7`` seems like a reasonable\n482     choice.\n483 \n484     You can easily define your own measure function based on what you feel\n485     should represent the \"size\" or \"complexity\" of the input expression.  Note\n486     that some choices, such as ``lambda expr: len(str(expr))`` may appear to be\n487     good metrics, but have other problems (in this case, the measure function\n488     may slow down simplify too much for very large expressions).  If you don't\n489     know what a good metric would be, the default, ``count_ops``, is a good\n490     one.\n491 \n492     For example:\n493 \n494     >>> from sympy import symbols, log\n495     >>> a, b = symbols('a b', positive=True)\n496     >>> g = log(a) + log(b) + log(a)*log(1/b)\n497     >>> h = simplify(g)\n498     >>> h\n499     log(a*b**(1 - log(a)))\n500     >>> count_ops(g)\n501     8\n502     >>> count_ops(h)\n503     5\n504 \n505     So you can see that ``h`` is simpler than ``g`` using the count_ops metric.\n506     However, we may not like how ``simplify`` (in this case, using\n507     ``logcombine``) has created the ``b**(log(1/a) + 1)`` term.  A simple way\n508     to reduce this would be to give more weight to powers as operations in\n509     ``count_ops``.  We can do this by using the ``visual=True`` option:\n510 \n511     >>> print(count_ops(g, visual=True))\n512     2*ADD + DIV + 4*LOG + MUL\n513     >>> print(count_ops(h, visual=True))\n514     2*LOG + MUL + POW + SUB\n515 \n516     >>> from sympy import Symbol, S\n517     >>> def my_measure(expr):\n518     ...     POW = Symbol('POW')\n519     ...     # Discourage powers by giving POW a weight of 10\n520     ...     count = count_ops(expr, visual=True).subs(POW, 10)\n521     ...     # Every other operation gets a weight of 1 (the default)\n522     ...     count = count.replace(Symbol, type(S.One))\n523     ...     return count\n524     >>> my_measure(g)\n525     8\n526     >>> my_measure(h)\n527     14\n528     >>> 15./8 > 1.7 # 1.7 is the default ratio\n529     True\n530     >>> simplify(g, measure=my_measure)\n531     -log(a)*log(b) + log(a) + log(b)\n532 \n533     Note that because ``simplify()`` internally tries many different\n534     simplification strategies and then compares them using the measure\n535     function, we get a completely different result that is still different\n536     from the input expression by doing this.\n537 \n538     If ``rational=True``, Floats will be recast as Rationals before simplification.\n539     If ``rational=None``, Floats will be recast as Rationals but the result will\n540     be recast as Floats. If rational=False(default) then nothing will be done\n541     to the Floats.\n542 \n543     If ``inverse=True``, it will be assumed that a composition of inverse\n544     functions, such as sin and asin, can be cancelled in any order.\n545     For example, ``asin(sin(x))`` will yield ``x`` without checking whether\n546     x belongs to the set where this relation is true. The default is\n547     False.\n548 \n549     Note that ``simplify()`` automatically calls ``doit()`` on the final\n550     expression. You can avoid this behavior by passing ``doit=False`` as\n551     an argument.\n552     \"\"\"\n553 \n554     def shorter(*choices):\n555         \"\"\"\n556         Return the choice that has the fewest ops. In case of a tie,\n557         the expression listed first is selected.\n558         \"\"\"\n559         if not has_variety(choices):\n560             return choices[0]\n561         return min(choices, key=measure)\n562 \n563     def done(e):\n564         rv = e.doit() if doit else e\n565         return shorter(rv, collect_abs(rv))\n566 \n567     expr = sympify(expr)\n568     kwargs = dict(\n569         ratio=kwargs.get('ratio', ratio),\n570         measure=kwargs.get('measure', measure),\n571         rational=kwargs.get('rational', rational),\n572         inverse=kwargs.get('inverse', inverse),\n573         doit=kwargs.get('doit', doit))\n574     # no routine for Expr needs to check for is_zero\n575     if isinstance(expr, Expr) and expr.is_zero:\n576         return S.Zero\n577 \n578     _eval_simplify = getattr(expr, '_eval_simplify', None)\n579     if _eval_simplify is not None:\n580         return _eval_simplify(**kwargs)\n581 \n582     original_expr = expr = collect_abs(signsimp(expr))\n583 \n584     if not isinstance(expr, Basic) or not expr.args:  # XXX: temporary hack\n585         return expr\n586 \n587     if inverse and expr.has(Function):\n588         expr = inversecombine(expr)\n589         if not expr.args:  # simplified to atomic\n590             return expr\n591 \n592     # do deep simplification\n593     handled = Add, Mul, Pow, ExpBase\n594     expr = expr.replace(\n595         # here, checking for x.args is not enough because Basic has\n596         # args but Basic does not always play well with replace, e.g.\n597         # when simultaneous is True found expressions will be masked\n598         # off with a Dummy but not all Basic objects in an expression\n599         # can be replaced with a Dummy\n600         lambda x: isinstance(x, Expr) and x.args and not isinstance(\n601             x, handled),\n602         lambda x: x.func(*[simplify(i, **kwargs) for i in x.args]),\n603         simultaneous=False)\n604     if not isinstance(expr, handled):\n605         return done(expr)\n606 \n607     if not expr.is_commutative:\n608         expr = nc_simplify(expr)\n609 \n610     # TODO: Apply different strategies, considering expression pattern:\n611     # is it a purely rational function? Is there any trigonometric function?...\n612     # See also https://github.com/sympy/sympy/pull/185.\n613 \n614 \n615     # rationalize Floats\n616     floats = False\n617     if rational is not False and expr.has(Float):\n618         floats = True\n619         expr = nsimplify(expr, rational=True)\n620 \n621     expr = bottom_up(expr, lambda w: getattr(w, 'normal', lambda: w)())\n622     expr = Mul(*powsimp(expr).as_content_primitive())\n623     _e = cancel(expr)\n624     expr1 = shorter(_e, _mexpand(_e).cancel())  # issue 6829\n625     expr2 = shorter(together(expr, deep=True), together(expr1, deep=True))\n626 \n627     if ratio is S.Infinity:\n628         expr = expr2\n629     else:\n630         expr = shorter(expr2, expr1, expr)\n631     if not isinstance(expr, Basic):  # XXX: temporary hack\n632         return expr\n633 \n634     expr = factor_terms(expr, sign=False)\n635 \n636     from sympy.simplify.hyperexpand import hyperexpand\n637     from sympy.functions.special.bessel import BesselBase\n638     from sympy import Sum, Product, Integral\n639     from sympy.functions.elementary.complexes import sign\n640 \n641     # must come before `Piecewise` since this introduces more `Piecewise` terms\n642     if expr.has(sign):\n643         expr = expr.rewrite(Abs)\n644 \n645     # Deal with Piecewise separately to avoid recursive growth of expressions\n646     if expr.has(Piecewise):\n647         # Fold into a single Piecewise\n648         expr = piecewise_fold(expr)\n649         # Apply doit, if doit=True\n650         expr = done(expr)\n651         # Still a Piecewise?\n652         if expr.has(Piecewise):\n653             # Fold into a single Piecewise, in case doit lead to some\n654             # expressions being Piecewise\n655             expr = piecewise_fold(expr)\n656             # kroneckersimp also affects Piecewise\n657             if expr.has(KroneckerDelta):\n658                 expr = kroneckersimp(expr)\n659             # Still a Piecewise?\n660             if expr.has(Piecewise):\n661                 from sympy.functions.elementary.piecewise import piecewise_simplify\n662                 # Do not apply doit on the segments as it has already\n663                 # been done above, but simplify\n664                 expr = piecewise_simplify(expr, deep=True, doit=False)\n665                 # Still a Piecewise?\n666                 if expr.has(Piecewise):\n667                     # Try factor common terms\n668                     expr = shorter(expr, factor_terms(expr))\n669                     # As all expressions have been simplified above with the\n670                     # complete simplify, nothing more needs to be done here\n671                     return expr\n672 \n673     # hyperexpand automatically only works on hypergeometric terms\n674     # Do this after the Piecewise part to avoid recursive expansion\n675     expr = hyperexpand(expr)\n676 \n677     if expr.has(KroneckerDelta):\n678         expr = kroneckersimp(expr)\n679 \n680     if expr.has(BesselBase):\n681         expr = besselsimp(expr)\n682 \n683     if expr.has(TrigonometricFunction, HyperbolicFunction):\n684         expr = trigsimp(expr, deep=True)\n685 \n686     if expr.has(log):\n687         expr = shorter(expand_log(expr, deep=True), logcombine(expr))\n688 \n689     if expr.has(CombinatorialFunction, gamma):\n690         # expression with gamma functions or non-integer arguments is\n691         # automatically passed to gammasimp\n692         expr = combsimp(expr)\n693 \n694     if expr.has(Sum):\n695         expr = sum_simplify(expr, **kwargs)\n696 \n697     if expr.has(Integral):\n698         expr = expr.xreplace(dict([\n699             (i, factor_terms(i)) for i in expr.atoms(Integral)]))\n700 \n701     if expr.has(Product):\n702         expr = product_simplify(expr)\n703 \n704     from sympy.physics.units import Quantity\n705     from sympy.physics.units.util import quantity_simplify\n706 \n707     if expr.has(Quantity):\n708         expr = quantity_simplify(expr)\n709 \n710     short = shorter(powsimp(expr, combine='exp', deep=True), powsimp(expr), expr)\n711     short = shorter(short, cancel(short))\n712     short = shorter(short, factor_terms(short), expand_power_exp(expand_mul(short)))\n713     if short.has(TrigonometricFunction, HyperbolicFunction, ExpBase):\n714         short = exptrigsimp(short)\n715 \n716     # get rid of hollow 2-arg Mul factorization\n717     hollow_mul = Transform(\n718         lambda x: Mul(*x.args),\n719         lambda x:\n720         x.is_Mul and\n721         len(x.args) == 2 and\n722         x.args[0].is_Number and\n723         x.args[1].is_Add and\n724         x.is_commutative)\n725     expr = short.xreplace(hollow_mul)\n726 \n727     numer, denom = expr.as_numer_denom()\n728     if denom.is_Add:\n729         n, d = fraction(radsimp(1/denom, symbolic=False, max_terms=1))\n730         if n is not S.One:\n731             expr = (numer*n).expand()/d\n732 \n733     if expr.could_extract_minus_sign():\n734         n, d = fraction(expr)\n735         if d != 0:\n736             expr = signsimp(-n/(-d))\n737 \n738     if measure(expr) > ratio*measure(original_expr):\n739         expr = original_expr\n740 \n741     # restore floats\n742     if floats and rational is None:\n743         expr = nfloat(expr, exponent=False)\n744 \n745     return done(expr)\n746 \n747 \n748 def sum_simplify(s, **kwargs):\n749     \"\"\"Main function for Sum simplification\"\"\"\n750     from sympy.concrete.summations import Sum\n751     from sympy.core.function import expand\n752 \n753     if not isinstance(s, Add):\n754         s = s.xreplace(dict([(a, sum_simplify(a, **kwargs))\n755             for a in s.atoms(Add) if a.has(Sum)]))\n756     s = expand(s)\n757     if not isinstance(s, Add):\n758         return s\n759 \n760     terms = s.args\n761     s_t = [] # Sum Terms\n762     o_t = [] # Other Terms\n763 \n764     for term in terms:\n765         sum_terms, other = sift(Mul.make_args(term),\n766             lambda i: isinstance(i, Sum), binary=True)\n767         if not sum_terms:\n768             o_t.append(term)\n769             continue\n770         other = [Mul(*other)]\n771         s_t.append(Mul(*(other + [s._eval_simplify(**kwargs) for s in sum_terms])))\n772 \n773     result = Add(sum_combine(s_t), *o_t)\n774 \n775     return result\n776 \n777 \n778 def sum_combine(s_t):\n779     \"\"\"Helper function for Sum simplification\n780 \n781        Attempts to simplify a list of sums, by combining limits / sum function's\n782        returns the simplified sum\n783     \"\"\"\n784     from sympy.concrete.summations import Sum\n785 \n786     used = [False] * len(s_t)\n787 \n788     for method in range(2):\n789         for i, s_term1 in enumerate(s_t):\n790             if not used[i]:\n791                 for j, s_term2 in enumerate(s_t):\n792                     if not used[j] and i != j:\n793                         temp = sum_add(s_term1, s_term2, method)\n794                         if isinstance(temp, Sum) or isinstance(temp, Mul):\n795                             s_t[i] = temp\n796                             s_term1 = s_t[i]\n797                             used[j] = True\n798 \n799     result = S.Zero\n800     for i, s_term in enumerate(s_t):\n801         if not used[i]:\n802             result = Add(result, s_term)\n803 \n804     return result\n805 \n806 \n807 def factor_sum(self, limits=None, radical=False, clear=False, fraction=False, sign=True):\n808     \"\"\"Return Sum with constant factors extracted.\n809 \n810     If ``limits`` is specified then ``self`` is the summand; the other\n811     keywords are passed to ``factor_terms``.\n812 \n813     Examples\n814     ========\n815 \n816     >>> from sympy import Sum\n817     >>> from sympy.abc import x, y\n818     >>> from sympy.simplify.simplify import factor_sum\n819     >>> s = Sum(x*y, (x, 1, 3))\n820     >>> factor_sum(s)\n821     y*Sum(x, (x, 1, 3))\n822     >>> factor_sum(s.function, s.limits)\n823     y*Sum(x, (x, 1, 3))\n824     \"\"\"\n825     # XXX deprecate in favor of direct call to factor_terms\n826     from sympy.concrete.summations import Sum\n827     kwargs = dict(radical=radical, clear=clear,\n828         fraction=fraction, sign=sign)\n829     expr = Sum(self, *limits) if limits else self\n830     return factor_terms(expr, **kwargs)\n831 \n832 \n833 def sum_add(self, other, method=0):\n834     \"\"\"Helper function for Sum simplification\"\"\"\n835     from sympy.concrete.summations import Sum\n836     from sympy import Mul\n837 \n838     #we know this is something in terms of a constant * a sum\n839     #so we temporarily put the constants inside for simplification\n840     #then simplify the result\n841     def __refactor(val):\n842         args = Mul.make_args(val)\n843         sumv = next(x for x in args if isinstance(x, Sum))\n844         constant = Mul(*[x for x in args if x != sumv])\n845         return Sum(constant * sumv.function, *sumv.limits)\n846 \n847     if isinstance(self, Mul):\n848         rself = __refactor(self)\n849     else:\n850         rself = self\n851 \n852     if isinstance(other, Mul):\n853         rother = __refactor(other)\n854     else:\n855         rother = other\n856 \n857     if type(rself) == type(rother):\n858         if method == 0:\n859             if rself.limits == rother.limits:\n860                 return factor_sum(Sum(rself.function + rother.function, *rself.limits))\n861         elif method == 1:\n862             if simplify(rself.function - rother.function) == 0:\n863                 if len(rself.limits) == len(rother.limits) == 1:\n864                     i = rself.limits[0][0]\n865                     x1 = rself.limits[0][1]\n866                     y1 = rself.limits[0][2]\n867                     j = rother.limits[0][0]\n868                     x2 = rother.limits[0][1]\n869                     y2 = rother.limits[0][2]\n870 \n871                     if i == j:\n872                         if x2 == y1 + 1:\n873                             return factor_sum(Sum(rself.function, (i, x1, y2)))\n874                         elif x1 == y2 + 1:\n875                             return factor_sum(Sum(rself.function, (i, x2, y1)))\n876 \n877     return Add(self, other)\n878 \n879 \n880 def product_simplify(s):\n881     \"\"\"Main function for Product simplification\"\"\"\n882     from sympy.concrete.products import Product\n883 \n884     terms = Mul.make_args(s)\n885     p_t = [] # Product Terms\n886     o_t = [] # Other Terms\n887 \n888     for term in terms:\n889         if isinstance(term, Product):\n890             p_t.append(term)\n891         else:\n892             o_t.append(term)\n893 \n894     used = [False] * len(p_t)\n895 \n896     for method in range(2):\n897         for i, p_term1 in enumerate(p_t):\n898             if not used[i]:\n899                 for j, p_term2 in enumerate(p_t):\n900                     if not used[j] and i != j:\n901                         if isinstance(product_mul(p_term1, p_term2, method), Product):\n902                             p_t[i] = product_mul(p_term1, p_term2, method)\n903                             used[j] = True\n904 \n905     result = Mul(*o_t)\n906 \n907     for i, p_term in enumerate(p_t):\n908         if not used[i]:\n909             result = Mul(result, p_term)\n910 \n911     return result\n912 \n913 \n914 def product_mul(self, other, method=0):\n915     \"\"\"Helper function for Product simplification\"\"\"\n916     from sympy.concrete.products import Product\n917 \n918     if type(self) == type(other):\n919         if method == 0:\n920             if self.limits == other.limits:\n921                 return Product(self.function * other.function, *self.limits)\n922         elif method == 1:\n923             if simplify(self.function - other.function) == 0:\n924                 if len(self.limits) == len(other.limits) == 1:\n925                     i = self.limits[0][0]\n926                     x1 = self.limits[0][1]\n927                     y1 = self.limits[0][2]\n928                     j = other.limits[0][0]\n929                     x2 = other.limits[0][1]\n930                     y2 = other.limits[0][2]\n931 \n932                     if i == j:\n933                         if x2 == y1 + 1:\n934                             return Product(self.function, (i, x1, y2))\n935                         elif x1 == y2 + 1:\n936                             return Product(self.function, (i, x2, y1))\n937 \n938     return Mul(self, other)\n939 \n940 \n941 def _nthroot_solve(p, n, prec):\n942     \"\"\"\n943      helper function for ``nthroot``\n944      It denests ``p**Rational(1, n)`` using its minimal polynomial\n945     \"\"\"\n946     from sympy.polys.numberfields import _minimal_polynomial_sq\n947     from sympy.solvers import solve\n948     while n % 2 == 0:\n949         p = sqrtdenest(sqrt(p))\n950         n = n // 2\n951     if n == 1:\n952         return p\n953     pn = p**Rational(1, n)\n954     x = Symbol('x')\n955     f = _minimal_polynomial_sq(p, n, x)\n956     if f is None:\n957         return None\n958     sols = solve(f, x)\n959     for sol in sols:\n960         if abs(sol - pn).n() < 1./10**prec:\n961             sol = sqrtdenest(sol)\n962             if _mexpand(sol**n) == p:\n963                 return sol\n964 \n965 \n966 def logcombine(expr, force=False):\n967     \"\"\"\n968     Takes logarithms and combines them using the following rules:\n969 \n970     - log(x) + log(y) == log(x*y) if both are positive\n971     - a*log(x) == log(x**a) if x is positive and a is real\n972 \n973     If ``force`` is ``True`` then the assumptions above will be assumed to hold if\n974     there is no assumption already in place on a quantity. For example, if\n975     ``a`` is imaginary or the argument negative, force will not perform a\n976     combination but if ``a`` is a symbol with no assumptions the change will\n977     take place.\n978 \n979     Examples\n980     ========\n981 \n982     >>> from sympy import Symbol, symbols, log, logcombine, I\n983     >>> from sympy.abc import a, x, y, z\n984     >>> logcombine(a*log(x) + log(y) - log(z))\n985     a*log(x) + log(y) - log(z)\n986     >>> logcombine(a*log(x) + log(y) - log(z), force=True)\n987     log(x**a*y/z)\n988     >>> x,y,z = symbols('x,y,z', positive=True)\n989     >>> a = Symbol('a', real=True)\n990     >>> logcombine(a*log(x) + log(y) - log(z))\n991     log(x**a*y/z)\n992 \n993     The transformation is limited to factors and/or terms that\n994     contain logs, so the result depends on the initial state of\n995     expansion:\n996 \n997     >>> eq = (2 + 3*I)*log(x)\n998     >>> logcombine(eq, force=True) == eq\n999     True\n1000     >>> logcombine(eq.expand(), force=True)\n1001     log(x**2) + I*log(x**3)\n1002 \n1003     See Also\n1004     ========\n1005 \n1006     posify: replace all symbols with symbols having positive assumptions\n1007     sympy.core.function.expand_log: expand the logarithms of products\n1008         and powers; the opposite of logcombine\n1009 \n1010     \"\"\"\n1011 \n1012     def f(rv):\n1013         if not (rv.is_Add or rv.is_Mul):\n1014             return rv\n1015 \n1016         def gooda(a):\n1017             # bool to tell whether the leading ``a`` in ``a*log(x)``\n1018             # could appear as log(x**a)\n1019             return (a is not S.NegativeOne and  # -1 *could* go, but we disallow\n1020                 (a.is_extended_real or force and a.is_extended_real is not False))\n1021 \n1022         def goodlog(l):\n1023             # bool to tell whether log ``l``'s argument can combine with others\n1024             a = l.args[0]\n1025             return a.is_positive or force and a.is_nonpositive is not False\n1026 \n1027         other = []\n1028         logs = []\n1029         log1 = defaultdict(list)\n1030         for a in Add.make_args(rv):\n1031             if isinstance(a, log) and goodlog(a):\n1032                 log1[()].append(([], a))\n1033             elif not a.is_Mul:\n1034                 other.append(a)\n1035             else:\n1036                 ot = []\n1037                 co = []\n1038                 lo = []\n1039                 for ai in a.args:\n1040                     if ai.is_Rational and ai < 0:\n1041                         ot.append(S.NegativeOne)\n1042                         co.append(-ai)\n1043                     elif isinstance(ai, log) and goodlog(ai):\n1044                         lo.append(ai)\n1045                     elif gooda(ai):\n1046                         co.append(ai)\n1047                     else:\n1048                         ot.append(ai)\n1049                 if len(lo) > 1:\n1050                     logs.append((ot, co, lo))\n1051                 elif lo:\n1052                     log1[tuple(ot)].append((co, lo[0]))\n1053                 else:\n1054                     other.append(a)\n1055 \n1056         # if there is only one log in other, put it with the\n1057         # good logs\n1058         if len(other) == 1 and isinstance(other[0], log):\n1059             log1[()].append(([], other.pop()))\n1060         # if there is only one log at each coefficient and none have\n1061         # an exponent to place inside the log then there is nothing to do\n1062         if not logs and all(len(log1[k]) == 1 and log1[k][0] == [] for k in log1):\n1063             return rv\n1064 \n1065         # collapse multi-logs as far as possible in a canonical way\n1066         # TODO: see if x*log(a)+x*log(a)*log(b) -> x*log(a)*(1+log(b))?\n1067         # -- in this case, it's unambiguous, but if it were were a log(c) in\n1068         # each term then it's arbitrary whether they are grouped by log(a) or\n1069         # by log(c). So for now, just leave this alone; it's probably better to\n1070         # let the user decide\n1071         for o, e, l in logs:\n1072             l = list(ordered(l))\n1073             e = log(l.pop(0).args[0]**Mul(*e))\n1074             while l:\n1075                 li = l.pop(0)\n1076                 e = log(li.args[0]**e)\n1077             c, l = Mul(*o), e\n1078             if isinstance(l, log):  # it should be, but check to be sure\n1079                 log1[(c,)].append(([], l))\n1080             else:\n1081                 other.append(c*l)\n1082 \n1083         # logs that have the same coefficient can multiply\n1084         for k in list(log1.keys()):\n1085             log1[Mul(*k)] = log(logcombine(Mul(*[\n1086                 l.args[0]**Mul(*c) for c, l in log1.pop(k)]),\n1087                 force=force), evaluate=False)\n1088 \n1089         # logs that have oppositely signed coefficients can divide\n1090         for k in ordered(list(log1.keys())):\n1091             if not k in log1:  # already popped as -k\n1092                 continue\n1093             if -k in log1:\n1094                 # figure out which has the minus sign; the one with\n1095                 # more op counts should be the one\n1096                 num, den = k, -k\n1097                 if num.count_ops() > den.count_ops():\n1098                     num, den = den, num\n1099                 other.append(\n1100                     num*log(log1.pop(num).args[0]/log1.pop(den).args[0],\n1101                             evaluate=False))\n1102             else:\n1103                 other.append(k*log1.pop(k))\n1104 \n1105         return Add(*other)\n1106 \n1107     return bottom_up(expr, f)\n1108 \n1109 \n1110 def inversecombine(expr):\n1111     \"\"\"Simplify the composition of a function and its inverse.\n1112 \n1113     Explanation\n1114     ===========\n1115 \n1116     No attention is paid to whether the inverse is a left inverse or a\n1117     right inverse; thus, the result will in general not be equivalent\n1118     to the original expression.\n1119 \n1120     Examples\n1121     ========\n1122 \n1123     >>> from sympy.simplify.simplify import inversecombine\n1124     >>> from sympy import asin, sin, log, exp\n1125     >>> from sympy.abc import x\n1126     >>> inversecombine(asin(sin(x)))\n1127     x\n1128     >>> inversecombine(2*log(exp(3*x)))\n1129     6*x\n1130     \"\"\"\n1131 \n1132     def f(rv):\n1133         if rv.is_Function and hasattr(rv, \"inverse\"):\n1134             if (len(rv.args) == 1 and len(rv.args[0].args) == 1 and\n1135                 isinstance(rv.args[0], rv.inverse(argindex=1))):\n1136                     rv = rv.args[0].args[0]\n1137         return rv\n1138 \n1139     return bottom_up(expr, f)\n1140 \n1141 \n1142 def walk(e, *target):\n1143     \"\"\"Iterate through the args that are the given types (target) and\n1144     return a list of the args that were traversed; arguments\n1145     that are not of the specified types are not traversed.\n1146 \n1147     Examples\n1148     ========\n1149 \n1150     >>> from sympy.simplify.simplify import walk\n1151     >>> from sympy import Min, Max\n1152     >>> from sympy.abc import x, y, z\n1153     >>> list(walk(Min(x, Max(y, Min(1, z))), Min))\n1154     [Min(x, Max(y, Min(1, z)))]\n1155     >>> list(walk(Min(x, Max(y, Min(1, z))), Min, Max))\n1156     [Min(x, Max(y, Min(1, z))), Max(y, Min(1, z)), Min(1, z)]\n1157 \n1158     See Also\n1159     ========\n1160 \n1161     bottom_up\n1162     \"\"\"\n1163     if isinstance(e, target):\n1164         yield e\n1165         for i in e.args:\n1166             for w in walk(i, *target):\n1167                 yield w\n1168 \n1169 \n1170 def bottom_up(rv, F, atoms=False, nonbasic=False):\n1171     \"\"\"Apply ``F`` to all expressions in an expression tree from the\n1172     bottom up. If ``atoms`` is True, apply ``F`` even if there are no args;\n1173     if ``nonbasic`` is True, try to apply ``F`` to non-Basic objects.\n1174     \"\"\"\n1175     args = getattr(rv, 'args', None)\n1176     if args is not None:\n1177         if args:\n1178             args = tuple([bottom_up(a, F, atoms, nonbasic) for a in args])\n1179             if args != rv.args:\n1180                 rv = rv.func(*args)\n1181             rv = F(rv)\n1182         elif atoms:\n1183             rv = F(rv)\n1184     else:\n1185         if nonbasic:\n1186             try:\n1187                 rv = F(rv)\n1188             except TypeError:\n1189                 pass\n1190 \n1191     return rv\n1192 \n1193 \n1194 def kroneckersimp(expr):\n1195     \"\"\"\n1196     Simplify expressions with KroneckerDelta.\n1197 \n1198     The only simplification currently attempted is to identify multiplicative cancellation:\n1199 \n1200     Examples\n1201     ========\n1202 \n1203     >>> from sympy import KroneckerDelta, kroneckersimp\n1204     >>> from sympy.abc import i\n1205     >>> kroneckersimp(1 + KroneckerDelta(0, i) * KroneckerDelta(1, i))\n1206     1\n1207     \"\"\"\n1208     def args_cancel(args1, args2):\n1209         for i1 in range(2):\n1210             for i2 in range(2):\n1211                 a1 = args1[i1]\n1212                 a2 = args2[i2]\n1213                 a3 = args1[(i1 + 1) % 2]\n1214                 a4 = args2[(i2 + 1) % 2]\n1215                 if Eq(a1, a2) is S.true and Eq(a3, a4) is S.false:\n1216                     return True\n1217         return False\n1218 \n1219     def cancel_kronecker_mul(m):\n1220         from sympy.utilities.iterables import subsets\n1221 \n1222         args = m.args\n1223         deltas = [a for a in args if isinstance(a, KroneckerDelta)]\n1224         for delta1, delta2 in subsets(deltas, 2):\n1225             args1 = delta1.args\n1226             args2 = delta2.args\n1227             if args_cancel(args1, args2):\n1228                 return 0*m\n1229         return m\n1230 \n1231     if not expr.has(KroneckerDelta):\n1232         return expr\n1233 \n1234     if expr.has(Piecewise):\n1235         expr = expr.rewrite(KroneckerDelta)\n1236 \n1237     newexpr = expr\n1238     expr = None\n1239 \n1240     while newexpr != expr:\n1241         expr = newexpr\n1242         newexpr = expr.replace(lambda e: isinstance(e, Mul), cancel_kronecker_mul)\n1243 \n1244     return expr\n1245 \n1246 \n1247 def besselsimp(expr):\n1248     \"\"\"\n1249     Simplify bessel-type functions.\n1250 \n1251     Explanation\n1252     ===========\n1253 \n1254     This routine tries to simplify bessel-type functions. Currently it only\n1255     works on the Bessel J and I functions, however. It works by looking at all\n1256     such functions in turn, and eliminating factors of \"I\" and \"-1\" (actually\n1257     their polar equivalents) in front of the argument. Then, functions of\n1258     half-integer order are rewritten using strigonometric functions and\n1259     functions of integer order (> 1) are rewritten using functions\n1260     of low order.  Finally, if the expression was changed, compute\n1261     factorization of the result with factor().\n1262 \n1263     >>> from sympy import besselj, besseli, besselsimp, polar_lift, I, S\n1264     >>> from sympy.abc import z, nu\n1265     >>> besselsimp(besselj(nu, z*polar_lift(-1)))\n1266     exp(I*pi*nu)*besselj(nu, z)\n1267     >>> besselsimp(besseli(nu, z*polar_lift(-I)))\n1268     exp(-I*pi*nu/2)*besselj(nu, z)\n1269     >>> besselsimp(besseli(S(-1)/2, z))\n1270     sqrt(2)*cosh(z)/(sqrt(pi)*sqrt(z))\n1271     >>> besselsimp(z*besseli(0, z) + z*(besseli(2, z))/2 + besseli(1, z))\n1272     3*z*besseli(0, z)/2\n1273     \"\"\"\n1274     # TODO\n1275     # - better algorithm?\n1276     # - simplify (cos(pi*b)*besselj(b,z) - besselj(-b,z))/sin(pi*b) ...\n1277     # - use contiguity relations?\n1278 \n1279     def replacer(fro, to, factors):\n1280         factors = set(factors)\n1281 \n1282         def repl(nu, z):\n1283             if factors.intersection(Mul.make_args(z)):\n1284                 return to(nu, z)\n1285             return fro(nu, z)\n1286         return repl\n1287 \n1288     def torewrite(fro, to):\n1289         def tofunc(nu, z):\n1290             return fro(nu, z).rewrite(to)\n1291         return tofunc\n1292 \n1293     def tominus(fro):\n1294         def tofunc(nu, z):\n1295             return exp(I*pi*nu)*fro(nu, exp_polar(-I*pi)*z)\n1296         return tofunc\n1297 \n1298     orig_expr = expr\n1299 \n1300     ifactors = [I, exp_polar(I*pi/2), exp_polar(-I*pi/2)]\n1301     expr = expr.replace(\n1302         besselj, replacer(besselj,\n1303         torewrite(besselj, besseli), ifactors))\n1304     expr = expr.replace(\n1305         besseli, replacer(besseli,\n1306         torewrite(besseli, besselj), ifactors))\n1307 \n1308     minusfactors = [-1, exp_polar(I*pi)]\n1309     expr = expr.replace(\n1310         besselj, replacer(besselj, tominus(besselj), minusfactors))\n1311     expr = expr.replace(\n1312         besseli, replacer(besseli, tominus(besseli), minusfactors))\n1313 \n1314     z0 = Dummy('z')\n1315 \n1316     def expander(fro):\n1317         def repl(nu, z):\n1318             if (nu % 1) == S.Half:\n1319                 return simplify(trigsimp(unpolarify(\n1320                         fro(nu, z0).rewrite(besselj).rewrite(jn).expand(\n1321                             func=True)).subs(z0, z)))\n1322             elif nu.is_Integer and nu > 1:\n1323                 return fro(nu, z).expand(func=True)\n1324             return fro(nu, z)\n1325         return repl\n1326 \n1327     expr = expr.replace(besselj, expander(besselj))\n1328     expr = expr.replace(bessely, expander(bessely))\n1329     expr = expr.replace(besseli, expander(besseli))\n1330     expr = expr.replace(besselk, expander(besselk))\n1331 \n1332     def _bessel_simp_recursion(expr):\n1333 \n1334         def _use_recursion(bessel, expr):\n1335             while True:\n1336                 bessels = expr.find(lambda x: isinstance(x, bessel))\n1337                 try:\n1338                     for ba in sorted(bessels, key=lambda x: re(x.args[0])):\n1339                         a, x = ba.args\n1340                         bap1 = bessel(a+1, x)\n1341                         bap2 = bessel(a+2, x)\n1342                         if expr.has(bap1) and expr.has(bap2):\n1343                             expr = expr.subs(ba, 2*(a+1)/x*bap1 - bap2)\n1344                             break\n1345                     else:\n1346                         return expr\n1347                 except (ValueError, TypeError):\n1348                     return expr\n1349         if expr.has(besselj):\n1350             expr = _use_recursion(besselj, expr)\n1351         if expr.has(bessely):\n1352             expr = _use_recursion(bessely, expr)\n1353         return expr\n1354 \n1355     expr = _bessel_simp_recursion(expr)\n1356     if expr != orig_expr:\n1357         expr = expr.factor()\n1358 \n1359     return expr\n1360 \n1361 \n1362 def nthroot(expr, n, max_len=4, prec=15):\n1363     \"\"\"\n1364     Compute a real nth-root of a sum of surds.\n1365 \n1366     Parameters\n1367     ==========\n1368 \n1369     expr : sum of surds\n1370     n : integer\n1371     max_len : maximum number of surds passed as constants to ``nsimplify``\n1372 \n1373     Algorithm\n1374     =========\n1375 \n1376     First ``nsimplify`` is used to get a candidate root; if it is not a\n1377     root the minimal polynomial is computed; the answer is one of its\n1378     roots.\n1379 \n1380     Examples\n1381     ========\n1382 \n1383     >>> from sympy.simplify.simplify import nthroot\n1384     >>> from sympy import sqrt\n1385     >>> nthroot(90 + 34*sqrt(7), 3)\n1386     sqrt(7) + 3\n1387 \n1388     \"\"\"\n1389     expr = sympify(expr)\n1390     n = sympify(n)\n1391     p = expr**Rational(1, n)\n1392     if not n.is_integer:\n1393         return p\n1394     if not _is_sum_surds(expr):\n1395         return p\n1396     surds = []\n1397     coeff_muls = [x.as_coeff_Mul() for x in expr.args]\n1398     for x, y in coeff_muls:\n1399         if not x.is_rational:\n1400             return p\n1401         if y is S.One:\n1402             continue\n1403         if not (y.is_Pow and y.exp == S.Half and y.base.is_integer):\n1404             return p\n1405         surds.append(y)\n1406     surds.sort()\n1407     surds = surds[:max_len]\n1408     if expr < 0 and n % 2 == 1:\n1409         p = (-expr)**Rational(1, n)\n1410         a = nsimplify(p, constants=surds)\n1411         res = a if _mexpand(a**n) == _mexpand(-expr) else p\n1412         return -res\n1413     a = nsimplify(p, constants=surds)\n1414     if _mexpand(a) is not _mexpand(p) and _mexpand(a**n) == _mexpand(expr):\n1415         return _mexpand(a)\n1416     expr = _nthroot_solve(expr, n, prec)\n1417     if expr is None:\n1418         return p\n1419     return expr\n1420 \n1421 \n1422 def nsimplify(expr, constants=(), tolerance=None, full=False, rational=None,\n1423     rational_conversion='base10'):\n1424     \"\"\"\n1425     Find a simple representation for a number or, if there are free symbols or\n1426     if ``rational=True``, then replace Floats with their Rational equivalents. If\n1427     no change is made and rational is not False then Floats will at least be\n1428     converted to Rationals.\n1429 \n1430     Explanation\n1431     ===========\n1432 \n1433     For numerical expressions, a simple formula that numerically matches the\n1434     given numerical expression is sought (and the input should be possible\n1435     to evalf to a precision of at least 30 digits).\n1436 \n1437     Optionally, a list of (rationally independent) constants to\n1438     include in the formula may be given.\n1439 \n1440     A lower tolerance may be set to find less exact matches. If no tolerance\n1441     is given then the least precise value will set the tolerance (e.g. Floats\n1442     default to 15 digits of precision, so would be tolerance=10**-15).\n1443 \n1444     With ``full=True``, a more extensive search is performed\n1445     (this is useful to find simpler numbers when the tolerance\n1446     is set low).\n1447 \n1448     When converting to rational, if rational_conversion='base10' (the default), then\n1449     convert floats to rationals using their base-10 (string) representation.\n1450     When rational_conversion='exact' it uses the exact, base-2 representation.\n1451 \n1452     Examples\n1453     ========\n1454 \n1455     >>> from sympy import nsimplify, sqrt, GoldenRatio, exp, I, pi\n1456     >>> nsimplify(4/(1+sqrt(5)), [GoldenRatio])\n1457     -2 + 2*GoldenRatio\n1458     >>> nsimplify((1/(exp(3*pi*I/5)+1)))\n1459     1/2 - I*sqrt(sqrt(5)/10 + 1/4)\n1460     >>> nsimplify(I**I, [pi])\n1461     exp(-pi/2)\n1462     >>> nsimplify(pi, tolerance=0.01)\n1463     22/7\n1464 \n1465     >>> nsimplify(0.333333333333333, rational=True, rational_conversion='exact')\n1466     6004799503160655/18014398509481984\n1467     >>> nsimplify(0.333333333333333, rational=True)\n1468     1/3\n1469 \n1470     See Also\n1471     ========\n1472 \n1473     sympy.core.function.nfloat\n1474 \n1475     \"\"\"\n1476     try:\n1477         return sympify(as_int(expr))\n1478     except (TypeError, ValueError):\n1479         pass\n1480     expr = sympify(expr).xreplace({\n1481         Float('inf'): S.Infinity,\n1482         Float('-inf'): S.NegativeInfinity,\n1483         })\n1484     if expr is S.Infinity or expr is S.NegativeInfinity:\n1485         return expr\n1486     if rational or expr.free_symbols:\n1487         return _real_to_rational(expr, tolerance, rational_conversion)\n1488 \n1489     # SymPy's default tolerance for Rationals is 15; other numbers may have\n1490     # lower tolerances set, so use them to pick the largest tolerance if None\n1491     # was given\n1492     if tolerance is None:\n1493         tolerance = 10**-min([15] +\n1494              [mpmath.libmp.libmpf.prec_to_dps(n._prec)\n1495              for n in expr.atoms(Float)])\n1496     # XXX should prec be set independent of tolerance or should it be computed\n1497     # from tolerance?\n1498     prec = 30\n1499     bprec = int(prec*3.33)\n1500 \n1501     constants_dict = {}\n1502     for constant in constants:\n1503         constant = sympify(constant)\n1504         v = constant.evalf(prec)\n1505         if not v.is_Float:\n1506             raise ValueError(\"constants must be real-valued\")\n1507         constants_dict[str(constant)] = v._to_mpmath(bprec)\n1508 \n1509     exprval = expr.evalf(prec, chop=True)\n1510     re, im = exprval.as_real_imag()\n1511 \n1512     # safety check to make sure that this evaluated to a number\n1513     if not (re.is_Number and im.is_Number):\n1514         return expr\n1515 \n1516     def nsimplify_real(x):\n1517         orig = mpmath.mp.dps\n1518         xv = x._to_mpmath(bprec)\n1519         try:\n1520             # We'll be happy with low precision if a simple fraction\n1521             if not (tolerance or full):\n1522                 mpmath.mp.dps = 15\n1523                 rat = mpmath.pslq([xv, 1])\n1524                 if rat is not None:\n1525                     return Rational(-int(rat[1]), int(rat[0]))\n1526             mpmath.mp.dps = prec\n1527             newexpr = mpmath.identify(xv, constants=constants_dict,\n1528                 tol=tolerance, full=full)\n1529             if not newexpr:\n1530                 raise ValueError\n1531             if full:\n1532                 newexpr = newexpr[0]\n1533             expr = sympify(newexpr)\n1534             if x and not expr:  # don't let x become 0\n1535                 raise ValueError\n1536             if expr.is_finite is False and not xv in [mpmath.inf, mpmath.ninf]:\n1537                 raise ValueError\n1538             return expr\n1539         finally:\n1540             # even though there are returns above, this is executed\n1541             # before leaving\n1542             mpmath.mp.dps = orig\n1543     try:\n1544         if re:\n1545             re = nsimplify_real(re)\n1546         if im:\n1547             im = nsimplify_real(im)\n1548     except ValueError:\n1549         if rational is None:\n1550             return _real_to_rational(expr, rational_conversion=rational_conversion)\n1551         return expr\n1552 \n1553     rv = re + im*S.ImaginaryUnit\n1554     # if there was a change or rational is explicitly not wanted\n1555     # return the value, else return the Rational representation\n1556     if rv != expr or rational is False:\n1557         return rv\n1558     return _real_to_rational(expr, rational_conversion=rational_conversion)\n1559 \n1560 \n1561 def _real_to_rational(expr, tolerance=None, rational_conversion='base10'):\n1562     \"\"\"\n1563     Replace all reals in expr with rationals.\n1564 \n1565     Examples\n1566     ========\n1567 \n1568     >>> from sympy.simplify.simplify import _real_to_rational\n1569     >>> from sympy.abc import x\n1570 \n1571     >>> _real_to_rational(.76 + .1*x**.5)\n1572     sqrt(x)/10 + 19/25\n1573 \n1574     If rational_conversion='base10', this uses the base-10 string. If\n1575     rational_conversion='exact', the exact, base-2 representation is used.\n1576 \n1577     >>> _real_to_rational(0.333333333333333, rational_conversion='exact')\n1578     6004799503160655/18014398509481984\n1579     >>> _real_to_rational(0.333333333333333)\n1580     1/3\n1581 \n1582     \"\"\"\n1583     expr = _sympify(expr)\n1584     inf = Float('inf')\n1585     p = expr\n1586     reps = {}\n1587     reduce_num = None\n1588     if tolerance is not None and tolerance < 1:\n1589         reduce_num = ceiling(1/tolerance)\n1590     for fl in p.atoms(Float):\n1591         key = fl\n1592         if reduce_num is not None:\n1593             r = Rational(fl).limit_denominator(reduce_num)\n1594         elif (tolerance is not None and tolerance >= 1 and\n1595                 fl.is_Integer is False):\n1596             r = Rational(tolerance*round(fl/tolerance)\n1597                 ).limit_denominator(int(tolerance))\n1598         else:\n1599             if rational_conversion == 'exact':\n1600                 r = Rational(fl)\n1601                 reps[key] = r\n1602                 continue\n1603             elif rational_conversion != 'base10':\n1604                 raise ValueError(\"rational_conversion must be 'base10' or 'exact'\")\n1605 \n1606             r = nsimplify(fl, rational=False)\n1607             # e.g. log(3).n() -> log(3) instead of a Rational\n1608             if fl and not r:\n1609                 r = Rational(fl)\n1610             elif not r.is_Rational:\n1611                 if fl == inf or fl == -inf:\n1612                     r = S.ComplexInfinity\n1613                 elif fl < 0:\n1614                     fl = -fl\n1615                     d = Pow(10, int((mpmath.log(fl)/mpmath.log(10))))\n1616                     r = -Rational(str(fl/d))*d\n1617                 elif fl > 0:\n1618                     d = Pow(10, int((mpmath.log(fl)/mpmath.log(10))))\n1619                     r = Rational(str(fl/d))*d\n1620                 else:\n1621                     r = Integer(0)\n1622         reps[key] = r\n1623     return p.subs(reps, simultaneous=True)\n1624 \n1625 \n1626 def clear_coefficients(expr, rhs=S.Zero):\n1627     \"\"\"Return `p, r` where `p` is the expression obtained when Rational\n1628     additive and multiplicative coefficients of `expr` have been stripped\n1629     away in a naive fashion (i.e. without simplification). The operations\n1630     needed to remove the coefficients will be applied to `rhs` and returned\n1631     as `r`.\n1632 \n1633     Examples\n1634     ========\n1635 \n1636     >>> from sympy.simplify.simplify import clear_coefficients\n1637     >>> from sympy.abc import x, y\n1638     >>> from sympy import Dummy\n1639     >>> expr = 4*y*(6*x + 3)\n1640     >>> clear_coefficients(expr - 2)\n1641     (y*(2*x + 1), 1/6)\n1642 \n1643     When solving 2 or more expressions like `expr = a`,\n1644     `expr = b`, etc..., it is advantageous to provide a Dummy symbol\n1645     for `rhs` and  simply replace it with `a`, `b`, etc... in `r`.\n1646 \n1647     >>> rhs = Dummy('rhs')\n1648     >>> clear_coefficients(expr, rhs)\n1649     (y*(2*x + 1), _rhs/12)\n1650     >>> _[1].subs(rhs, 2)\n1651     1/6\n1652     \"\"\"\n1653     was = None\n1654     free = expr.free_symbols\n1655     if expr.is_Rational:\n1656         return (S.Zero, rhs - expr)\n1657     while expr and was != expr:\n1658         was = expr\n1659         m, expr = (\n1660             expr.as_content_primitive()\n1661             if free else\n1662             factor_terms(expr).as_coeff_Mul(rational=True))\n1663         rhs /= m\n1664         c, expr = expr.as_coeff_Add(rational=True)\n1665         rhs -= c\n1666     expr = signsimp(expr, evaluate = False)\n1667     if _coeff_isneg(expr):\n1668         expr = -expr\n1669         rhs = -rhs\n1670     return expr, rhs\n1671 \n1672 def nc_simplify(expr, deep=True):\n1673     '''\n1674     Simplify a non-commutative expression composed of multiplication\n1675     and raising to a power by grouping repeated subterms into one power.\n1676     Priority is given to simplifications that give the fewest number\n1677     of arguments in the end (for example, in a*b*a*b*c*a*b*c simplifying\n1678     to (a*b)**2*c*a*b*c gives 5 arguments while a*b*(a*b*c)**2 has 3).\n1679     If ``expr`` is a sum of such terms, the sum of the simplified terms\n1680     is returned.\n1681 \n1682     Keyword argument ``deep`` controls whether or not subexpressions\n1683     nested deeper inside the main expression are simplified. See examples\n1684     below. Setting `deep` to `False` can save time on nested expressions\n1685     that don't need simplifying on all levels.\n1686 \n1687     Examples\n1688     ========\n1689 \n1690     >>> from sympy import symbols\n1691     >>> from sympy.simplify.simplify import nc_simplify\n1692     >>> a, b, c = symbols(\"a b c\", commutative=False)\n1693     >>> nc_simplify(a*b*a*b*c*a*b*c)\n1694     a*b*(a*b*c)**2\n1695     >>> expr = a**2*b*a**4*b*a**4\n1696     >>> nc_simplify(expr)\n1697     a**2*(b*a**4)**2\n1698     >>> nc_simplify(a*b*a*b*c**2*(a*b)**2*c**2)\n1699     ((a*b)**2*c**2)**2\n1700     >>> nc_simplify(a*b*a*b + 2*a*c*a**2*c*a**2*c*a)\n1701     (a*b)**2 + 2*(a*c*a)**3\n1702     >>> nc_simplify(b**-1*a**-1*(a*b)**2)\n1703     a*b\n1704     >>> nc_simplify(a**-1*b**-1*c*a)\n1705     (b*a)**(-1)*c*a\n1706     >>> expr = (a*b*a*b)**2*a*c*a*c\n1707     >>> nc_simplify(expr)\n1708     (a*b)**4*(a*c)**2\n1709     >>> nc_simplify(expr, deep=False)\n1710     (a*b*a*b)**2*(a*c)**2\n1711 \n1712     '''\n1713     from sympy.matrices.expressions import (MatrixExpr, MatAdd, MatMul,\n1714                                                 MatPow, MatrixSymbol)\n1715     from sympy.core.exprtools import factor_nc\n1716 \n1717     if isinstance(expr, MatrixExpr):\n1718         expr = expr.doit(inv_expand=False)\n1719         _Add, _Mul, _Pow, _Symbol = MatAdd, MatMul, MatPow, MatrixSymbol\n1720     else:\n1721         _Add, _Mul, _Pow, _Symbol = Add, Mul, Pow, Symbol\n1722 \n1723     # =========== Auxiliary functions ========================\n1724     def _overlaps(args):\n1725         # Calculate a list of lists m such that m[i][j] contains the lengths\n1726         # of all possible overlaps between args[:i+1] and args[i+1+j:].\n1727         # An overlap is a suffix of the prefix that matches a prefix\n1728         # of the suffix.\n1729         # For example, let expr=c*a*b*a*b*a*b*a*b. Then m[3][0] contains\n1730         # the lengths of overlaps of c*a*b*a*b with a*b*a*b. The overlaps\n1731         # are a*b*a*b, a*b and the empty word so that m[3][0]=[4,2,0].\n1732         # All overlaps rather than only the longest one are recorded\n1733         # because this information helps calculate other overlap lengths.\n1734         m = [[([1, 0] if a == args[0] else [0]) for a in args[1:]]]\n1735         for i in range(1, len(args)):\n1736             overlaps = []\n1737             j = 0\n1738             for j in range(len(args) - i - 1):\n1739                 overlap = []\n1740                 for v in m[i-1][j+1]:\n1741                     if j + i + 1 + v < len(args) and args[i] == args[j+i+1+v]:\n1742                         overlap.append(v + 1)\n1743                 overlap += [0]\n1744                 overlaps.append(overlap)\n1745             m.append(overlaps)\n1746         return m\n1747 \n1748     def _reduce_inverses(_args):\n1749         # replace consecutive negative powers by an inverse\n1750         # of a product of positive powers, e.g. a**-1*b**-1*c\n1751         # will simplify to (a*b)**-1*c;\n1752         # return that new args list and the number of negative\n1753         # powers in it (inv_tot)\n1754         inv_tot = 0 # total number of inverses\n1755         inverses = []\n1756         args = []\n1757         for arg in _args:\n1758             if isinstance(arg, _Pow) and arg.args[1] < 0:\n1759                 inverses = [arg**-1] + inverses\n1760                 inv_tot += 1\n1761             else:\n1762                 if len(inverses) == 1:\n1763                     args.append(inverses[0]**-1)\n1764                 elif len(inverses) > 1:\n1765                     args.append(_Pow(_Mul(*inverses), -1))\n1766                     inv_tot -= len(inverses) - 1\n1767                 inverses = []\n1768                 args.append(arg)\n1769         if inverses:\n1770             args.append(_Pow(_Mul(*inverses), -1))\n1771             inv_tot -= len(inverses) - 1\n1772         return inv_tot, tuple(args)\n1773 \n1774     def get_score(s):\n1775         # compute the number of arguments of s\n1776         # (including in nested expressions) overall\n1777         # but ignore exponents\n1778         if isinstance(s, _Pow):\n1779             return get_score(s.args[0])\n1780         elif isinstance(s, (_Add, _Mul)):\n1781             return sum([get_score(a) for a in s.args])\n1782         return 1\n1783 \n1784     def compare(s, alt_s):\n1785         # compare two possible simplifications and return a\n1786         # \"better\" one\n1787         if s != alt_s and get_score(alt_s) < get_score(s):\n1788             return alt_s\n1789         return s\n1790     # ========================================================\n1791 \n1792     if not isinstance(expr, (_Add, _Mul, _Pow)) or expr.is_commutative:\n1793         return expr\n1794     args = expr.args[:]\n1795     if isinstance(expr, _Pow):\n1796         if deep:\n1797             return _Pow(nc_simplify(args[0]), args[1]).doit()\n1798         else:\n1799             return expr\n1800     elif isinstance(expr, _Add):\n1801         return _Add(*[nc_simplify(a, deep=deep) for a in args]).doit()\n1802     else:\n1803         # get the non-commutative part\n1804         c_args, args = expr.args_cnc()\n1805         com_coeff = Mul(*c_args)\n1806         if com_coeff != 1:\n1807             return com_coeff*nc_simplify(expr/com_coeff, deep=deep)\n1808 \n1809     inv_tot, args = _reduce_inverses(args)\n1810     # if most arguments are negative, work with the inverse\n1811     # of the expression, e.g. a**-1*b*a**-1*c**-1 will become\n1812     # (c*a*b**-1*a)**-1 at the end so can work with c*a*b**-1*a\n1813     invert = False\n1814     if inv_tot > len(args)/2:\n1815         invert = True\n1816         args = [a**-1 for a in args[::-1]]\n1817 \n1818     if deep:\n1819         args = tuple(nc_simplify(a) for a in args)\n1820 \n1821     m = _overlaps(args)\n1822 \n1823     # simps will be {subterm: end} where `end` is the ending\n1824     # index of a sequence of repetitions of subterm;\n1825     # this is for not wasting time with subterms that are part\n1826     # of longer, already considered sequences\n1827     simps = {}\n1828 \n1829     post = 1\n1830     pre = 1\n1831 \n1832     # the simplification coefficient is the number of\n1833     # arguments by which contracting a given sequence\n1834     # would reduce the word; e.g. in a*b*a*b*c*a*b*c,\n1835     # contracting a*b*a*b to (a*b)**2 removes 3 arguments\n1836     # while a*b*c*a*b*c to (a*b*c)**2 removes 6. It's\n1837     # better to contract the latter so simplification\n1838     # with a maximum simplification coefficient will be chosen\n1839     max_simp_coeff = 0\n1840     simp = None # information about future simplification\n1841 \n1842     for i in range(1, len(args)):\n1843         simp_coeff = 0\n1844         l = 0 # length of a subterm\n1845         p = 0 # the power of a subterm\n1846         if i < len(args) - 1:\n1847             rep = m[i][0]\n1848         start = i # starting index of the repeated sequence\n1849         end = i+1 # ending index of the repeated sequence\n1850         if i == len(args)-1 or rep == [0]:\n1851             # no subterm is repeated at this stage, at least as\n1852             # far as the arguments are concerned - there may be\n1853             # a repetition if powers are taken into account\n1854             if (isinstance(args[i], _Pow) and\n1855                             not isinstance(args[i].args[0], _Symbol)):\n1856                 subterm = args[i].args[0].args\n1857                 l = len(subterm)\n1858                 if args[i-l:i] == subterm:\n1859                     # e.g. a*b in a*b*(a*b)**2 is not repeated\n1860                     # in args (= [a, b, (a*b)**2]) but it\n1861                     # can be matched here\n1862                     p += 1\n1863                     start -= l\n1864                 if args[i+1:i+1+l] == subterm:\n1865                     # e.g. a*b in (a*b)**2*a*b\n1866                     p += 1\n1867                     end += l\n1868             if p:\n1869                 p += args[i].args[1]\n1870             else:\n1871                 continue\n1872         else:\n1873             l = rep[0] # length of the longest repeated subterm at this point\n1874             start -= l - 1\n1875             subterm = args[start:end]\n1876             p = 2\n1877             end += l\n1878 \n1879         if subterm in simps and simps[subterm] >= start:\n1880             # the subterm is part of a sequence that\n1881             # has already been considered\n1882             continue\n1883 \n1884         # count how many times it's repeated\n1885         while end < len(args):\n1886             if l in m[end-1][0]:\n1887                 p += 1\n1888                 end += l\n1889             elif isinstance(args[end], _Pow) and args[end].args[0].args == subterm:\n1890                 # for cases like a*b*a*b*(a*b)**2*a*b\n1891                 p += args[end].args[1]\n1892                 end += 1\n1893             else:\n1894                 break\n1895 \n1896         # see if another match can be made, e.g.\n1897         # for b*a**2 in b*a**2*b*a**3 or a*b in\n1898         # a**2*b*a*b\n1899 \n1900         pre_exp = 0\n1901         pre_arg = 1\n1902         if start - l >= 0 and args[start-l+1:start] == subterm[1:]:\n1903             if isinstance(subterm[0], _Pow):\n1904                 pre_arg = subterm[0].args[0]\n1905                 exp = subterm[0].args[1]\n1906             else:\n1907                 pre_arg = subterm[0]\n1908                 exp = 1\n1909             if isinstance(args[start-l], _Pow) and args[start-l].args[0] == pre_arg:\n1910                 pre_exp = args[start-l].args[1] - exp\n1911                 start -= l\n1912                 p += 1\n1913             elif args[start-l] == pre_arg:\n1914                 pre_exp = 1 - exp\n1915                 start -= l\n1916                 p += 1\n1917 \n1918         post_exp = 0\n1919         post_arg = 1\n1920         if end + l - 1 < len(args) and args[end:end+l-1] == subterm[:-1]:\n1921             if isinstance(subterm[-1], _Pow):\n1922                 post_arg = subterm[-1].args[0]\n1923                 exp = subterm[-1].args[1]\n1924             else:\n1925                 post_arg = subterm[-1]\n1926                 exp = 1\n1927             if isinstance(args[end+l-1], _Pow) and args[end+l-1].args[0] == post_arg:\n1928                 post_exp = args[end+l-1].args[1] - exp\n1929                 end += l\n1930                 p += 1\n1931             elif args[end+l-1] == post_arg:\n1932                 post_exp = 1 - exp\n1933                 end += l\n1934                 p += 1\n1935 \n1936         # Consider a*b*a**2*b*a**2*b*a:\n1937         # b*a**2 is explicitly repeated, but note\n1938         # that in this case a*b*a is also repeated\n1939         # so there are two possible simplifications:\n1940         # a*(b*a**2)**3*a**-1 or (a*b*a)**3\n1941         # The latter is obviously simpler.\n1942         # But in a*b*a**2*b**2*a**2 the simplifications are\n1943         # a*(b*a**2)**2 and (a*b*a)**3*a in which case\n1944         # it's better to stick with the shorter subterm\n1945         if post_exp and exp % 2 == 0 and start > 0:\n1946             exp = exp/2\n1947             _pre_exp = 1\n1948             _post_exp = 1\n1949             if isinstance(args[start-1], _Pow) and args[start-1].args[0] == post_arg:\n1950                 _post_exp = post_exp + exp\n1951                 _pre_exp = args[start-1].args[1] - exp\n1952             elif args[start-1] == post_arg:\n1953                 _post_exp = post_exp + exp\n1954                 _pre_exp = 1 - exp\n1955             if _pre_exp == 0 or _post_exp == 0:\n1956                 if not pre_exp:\n1957                     start -= 1\n1958                 post_exp = _post_exp\n1959                 pre_exp = _pre_exp\n1960                 pre_arg = post_arg\n1961                 subterm = (post_arg**exp,) + subterm[:-1] + (post_arg**exp,)\n1962 \n1963         simp_coeff += end-start\n1964 \n1965         if post_exp:\n1966             simp_coeff -= 1\n1967         if pre_exp:\n1968             simp_coeff -= 1\n1969 \n1970         simps[subterm] = end\n1971 \n1972         if simp_coeff > max_simp_coeff:\n1973             max_simp_coeff = simp_coeff\n1974             simp = (start, _Mul(*subterm), p, end, l)\n1975             pre = pre_arg**pre_exp\n1976             post = post_arg**post_exp\n1977 \n1978     if simp:\n1979         subterm = _Pow(nc_simplify(simp[1], deep=deep), simp[2])\n1980         pre = nc_simplify(_Mul(*args[:simp[0]])*pre, deep=deep)\n1981         post = post*nc_simplify(_Mul(*args[simp[3]:]), deep=deep)\n1982         simp = pre*subterm*post\n1983         if pre != 1 or post != 1:\n1984             # new simplifications may be possible but no need\n1985             # to recurse over arguments\n1986             simp = nc_simplify(simp, deep=False)\n1987     else:\n1988         simp = _Mul(*args)\n1989 \n1990     if invert:\n1991         simp = _Pow(simp, -1)\n1992 \n1993     # see if factor_nc(expr) is simplified better\n1994     if not isinstance(expr, MatrixExpr):\n1995         f_expr = factor_nc(expr)\n1996         if f_expr != expr:\n1997             alt_simp = nc_simplify(f_expr, deep=deep)\n1998             simp = compare(simp, alt_simp)\n1999     else:\n2000         simp = simp.doit(inv_expand=False)\n2001     return simp\n2002 \n2003 \n2004 def dotprodsimp(expr, withsimp=False):\n2005     \"\"\"Simplification for a sum of products targeted at the kind of blowup that\n2006     occurs during summation of products. Intended to reduce expression blowup\n2007     during matrix multiplication or other similar operations. Only works with\n2008     algebraic expressions and does not recurse into non.\n2009 \n2010     Parameters\n2011     ==========\n2012 \n2013     withsimp : bool, optional\n2014         Specifies whether a flag should be returned along with the expression\n2015         to indicate roughly whether simplification was successful. It is used\n2016         in ``MatrixArithmetic._eval_pow_by_recursion`` to avoid attempting to\n2017         simplify an expression repetitively which does not simplify.\n2018     \"\"\"\n2019 \n2020     def count_ops_alg(expr):\n2021         \"\"\"Optimized count algebraic operations with no recursion into\n2022         non-algebraic args that ``core.function.count_ops`` does. Also returns\n2023         whether rational functions may be present according to negative\n2024         exponents of powers or non-number fractions.\n2025 \n2026         Returns\n2027         =======\n2028 \n2029         ops, ratfunc : int, bool\n2030             ``ops`` is the number of algebraic operations starting at the top\n2031             level expression (not recursing into non-alg children). ``ratfunc``\n2032             specifies whether the expression MAY contain rational functions\n2033             which ``cancel`` MIGHT optimize.\n2034         \"\"\"\n2035 \n2036         ops     = 0\n2037         args    = [expr]\n2038         ratfunc = False\n2039 \n2040         while args:\n2041             a = args.pop()\n2042 \n2043             if not isinstance(a, Basic):\n2044                 continue\n2045 \n2046             if a.is_Rational:\n2047                 if a is not S.One: # -1/3 = NEG + DIV\n2048                     ops += bool (a.p < 0) + bool (a.q != 1)\n2049 \n2050             elif a.is_Mul:\n2051                 if _coeff_isneg(a):\n2052                     ops += 1\n2053                     if a.args[0] is S.NegativeOne:\n2054                         a = a.as_two_terms()[1]\n2055                     else:\n2056                         a = -a\n2057 \n2058                 n, d = fraction(a)\n2059 \n2060                 if n.is_Integer:\n2061                     ops += 1 + bool (n < 0)\n2062                     args.append(d) # won't be -Mul but could be Add\n2063 \n2064                 elif d is not S.One:\n2065                     if not d.is_Integer:\n2066                         args.append(d)\n2067                         ratfunc=True\n2068 \n2069                     ops += 1\n2070                     args.append(n) # could be -Mul\n2071 \n2072                 else:\n2073                     ops += len(a.args) - 1\n2074                     args.extend(a.args)\n2075 \n2076             elif a.is_Add:\n2077                 laargs = len(a.args)\n2078                 negs   = 0\n2079 \n2080                 for ai in a.args:\n2081                     if _coeff_isneg(ai):\n2082                         negs += 1\n2083                         ai    = -ai\n2084                     args.append(ai)\n2085 \n2086                 ops += laargs - (negs != laargs) # -x - y = NEG + SUB\n2087 \n2088             elif a.is_Pow:\n2089                 ops += 1\n2090                 args.append(a.base)\n2091 \n2092                 if not ratfunc:\n2093                     ratfunc = a.exp.is_negative is not False\n2094 \n2095         return ops, ratfunc\n2096 \n2097     def nonalg_subs_dummies(expr, dummies):\n2098         \"\"\"Substitute dummy variables for non-algebraic expressions to avoid\n2099         evaluation of non-algebraic terms that ``polys.polytools.cancel`` does.\n2100         \"\"\"\n2101 \n2102         if not expr.args:\n2103             return expr\n2104 \n2105         if expr.is_Add or expr.is_Mul or expr.is_Pow:\n2106             args = None\n2107 \n2108             for i, a in enumerate(expr.args):\n2109                 c = nonalg_subs_dummies(a, dummies)\n2110 \n2111                 if c is a:\n2112                     continue\n2113 \n2114                 if args is None:\n2115                     args = list(expr.args)\n2116 \n2117                 args[i] = c\n2118 \n2119             if args is None:\n2120                 return expr\n2121 \n2122             return expr.func(*args)\n2123 \n2124         return dummies.setdefault(expr, Dummy())\n2125 \n2126     simplified = False # doesn't really mean simplified, rather \"can simplify again\"\n2127 \n2128     if isinstance(expr, Basic) and (expr.is_Add or expr.is_Mul or expr.is_Pow):\n2129         expr2 = expr.expand(deep=True, modulus=None, power_base=False,\n2130             power_exp=False, mul=True, log=False, multinomial=True, basic=False)\n2131 \n2132         if expr2 != expr:\n2133             expr       = expr2\n2134             simplified = True\n2135 \n2136         exprops, ratfunc = count_ops_alg(expr)\n2137 \n2138         if exprops >= 6: # empirically tested cutoff for expensive simplification\n2139             if ratfunc:\n2140                 dummies = {}\n2141                 expr2   = nonalg_subs_dummies(expr, dummies)\n2142 \n2143                 if expr2 is expr or count_ops_alg(expr2)[0] >= 6: # check again after substitution\n2144                     expr3 = cancel(expr2)\n2145 \n2146                     if expr3 != expr2:\n2147                         expr       = expr3.subs([(d, e) for e, d in dummies.items()])\n2148                         simplified = True\n2149 \n2150         # very special case: x/(x-1) - 1/(x-1) -> 1\n2151         elif (exprops == 5 and expr.is_Add and expr.args [0].is_Mul and\n2152                 expr.args [1].is_Mul and expr.args [0].args [-1].is_Pow and\n2153                 expr.args [1].args [-1].is_Pow and\n2154                 expr.args [0].args [-1].exp is S.NegativeOne and\n2155                 expr.args [1].args [-1].exp is S.NegativeOne):\n2156 \n2157             expr2    = together (expr)\n2158             expr2ops = count_ops_alg(expr2)[0]\n2159 \n2160             if expr2ops < exprops:\n2161                 expr       = expr2\n2162                 simplified = True\n2163 \n2164         else:\n2165             simplified = True\n2166 \n2167     return (expr, simplified) if withsimp else expr\n",
        "intended_behavior": "The `simplify` method(s) should exhibit consistent behavior when dealing with expressions passed from `sympify` with `evaluate=False`. This means ensuring that expressions involving `ceiling` are simplified appropriately without assuming that the expression has been pre-evaluated unless specified. The resolution would require a thorough review of how `simplify` interacts with expressions marked as unevaluated by `sympify` to identify any logic that might differ in handling such cases between SymPy versions 1.5.1 and 1.6.2. The goal would be to maintain the integrity of unevaluated expressions throughout the simplification process, ensuring consistent outcomes regardless of version changes."
    }
]