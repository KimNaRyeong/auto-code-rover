2025-10-18 20:42:49.261 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-18 20:42:59.943 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=339, output_tokens=12, cost=0.003750
2025-10-18 20:43:08.139 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=519, output_tokens=296, cost=0.014070
2025-10-18 20:43:09.557 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 20:43:15.153 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=647, output_tokens=252, cost=0.014030
2025-10-18 20:43:15.159 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 20:43:18.777 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=606, output_tokens=44, cost=0.007380
2025-10-18 20:43:18.779 | DEBUG    | Extracted a valid json.
2025-10-18 20:43:18.779 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_method(\"sympify\")",
        "search_method(\"simplify\")",
        "search_method(\"ceiling\")"
    ],
    "bug_locations": []
}
2025-10-18 20:43:18.864 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-18 20:43:18.864 | DEBUG    | <Agent search> Analyzing search results.
2025-10-18 20:43:41.631 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=5160, output_tokens=978, cost=0.080940
2025-10-18 20:43:41.649 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 20:43:51.781 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=6354, output_tokens=435, cost=0.076590
2025-10-18 20:43:51.791 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 20:43:59.768 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=789, output_tokens=379, cost=0.019260
2025-10-18 20:43:59.769 | DEBUG    | Extracted a valid json.
2025-10-18 20:43:59.770 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations":[
        {
            "file": "sympy/core/sympify.py", 
            "class": "", 
            "method": "sympify", 
            "intended_behavior": "The `sympify` method needs to ensure consistent handling of the `evaluate` parameter, especially in cases involving functions like `ceiling`. The intended behavior here would be to ensure that when `evaluate=False`, expressions like `4*ceiling(x/4 - 3/4)` are kept unevaluated in a consistent manner across versions. This could involve inspecting how the AST transformation is applied when `evaluate=False` and ensuring that the logic does not inadvertently simplify or alter the structure of expressions involving `ceiling`. Additionally, it would be crucial to preserve existing functionalities for all other expressions and use cases, ensuring that any adjustments made do not affect the broader utility of `sympify`."
        }, 
        {
            "file": "sympy/simplify/simplify.py", 
            "class": "", 
            "method": "", 
            "intended_behavior": "The `simplify` method(s) should exhibit consistent behavior when dealing with expressions passed from `sympify` with `evaluate=False`. This means ensuring that expressions involving `ceiling` are simplified appropriately without assuming that the expression has been pre-evaluated unless specified. The resolution would require a thorough review of how `simplify` interacts with expressions marked as unevaluated by `sympify` to identify any logic that might differ in handling such cases between SymPy versions 1.5.1 and 1.6.2. The goal would be to maintain the integrity of unevaluated expressions throughout the simplification process, ensuring consistent outcomes regardless of version changes."
        }
    ]
}
2025-10-18 20:43:59.780 | DEBUG    | Bug location extracted successfully: [<file>sympy/core/sympify.py</file>
<class>None</class>
<method>sympify</method>
<code>
92 def sympify(a, locals=None, convert_xor=True, strict=False, rational=False,
93         evaluate=None):
94     """
95     Converts an arbitrary expression to a type that can be used inside SymPy.
96 
97     Explanation
98     ===========
99 
100     It will convert Python ints into instances of sympy.Integer,
101     floats into instances of sympy.Float, etc. It is also able to coerce symbolic
102     expressions which inherit from Basic. This can be useful in cooperation
103     with SAGE.
104 
105     .. warning::
106         Note that this function uses ``eval``, and thus shouldn't be used on
107         unsanitized input.
108 
109     If the argument is already a type that SymPy understands, it will do
110     nothing but return that value. This can be used at the beginning of a
111     function to ensure you are working with the correct type.
112 
113     Examples
114     ========
115 
116     >>> from sympy import sympify
117 
118     >>> sympify(2).is_integer
119     True
120     >>> sympify(2).is_real
121     True
122 
123     >>> sympify(2.0).is_real
124     True
125     >>> sympify("2.0").is_real
126     True
127     >>> sympify("2e-45").is_real
128     True
129 
130     If the expression could not be converted, a SympifyError is raised.
131 
132     >>> sympify("x***2")
133     Traceback (most recent call last):
134     ...
135     SympifyError: SympifyError: "could not parse 'x***2'"
136 
137     Locals
138     ------
139 
140     The sympification happens with access to everything that is loaded
141     by ``from sympy import *``; anything used in a string that is not
142     defined by that import will be converted to a symbol. In the following,
143     the ``bitcount`` function is treated as a symbol and the ``O`` is
144     interpreted as the Order object (used with series) and it raises
145     an error when used improperly:
146 
147     >>> s = 'bitcount(42)'
148     >>> sympify(s)
149     bitcount(42)
150     >>> sympify("O(x)")
151     O(x)
152     >>> sympify("O + 1")
153     Traceback (most recent call last):
154     ...
155     TypeError: unbound method...
156 
157     In order to have ``bitcount`` be recognized it can be imported into a
158     namespace dictionary and passed as locals:
159 
160     >>> from sympy.core.compatibility import exec_
161     >>> ns = {}
162     >>> exec_('from sympy.core.evalf import bitcount', ns)
163     >>> sympify(s, locals=ns)
164     6
165 
166     In order to have the ``O`` interpreted as a Symbol, identify it as such
167     in the namespace dictionary. This can be done in a variety of ways; all
168     three of the following are possibilities:
169 
170     >>> from sympy import Symbol
171     >>> ns["O"] = Symbol("O")  # method 1
172     >>> exec_('from sympy.abc import O', ns)  # method 2
173     >>> ns.update(dict(O=Symbol("O")))  # method 3
174     >>> sympify("O + 1", locals=ns)
175     O + 1
176 
177     If you want *all* single-letter and Greek-letter variables to be symbols
178     then you can use the clashing-symbols dictionaries that have been defined
179     there as private variables: _clash1 (single-letter variables), _clash2
180     (the multi-letter Greek names) or _clash (both single and multi-letter
181     names that are defined in abc).
182 
183     >>> from sympy.abc import _clash1
184     >>> _clash1
185     {'C': C, 'E': E, 'I': I, 'N': N, 'O': O, 'Q': Q, 'S': S}
186     >>> sympify('I & Q', _clash1)
187     I & Q
188 
189     Strict
190     ------
191 
192     If the option ``strict`` is set to ``True``, only the types for which an
193     explicit conversion has been defined are converted. In the other
194     cases, a SympifyError is raised.
195 
196     >>> print(sympify(None))
197     None
198     >>> sympify(None, strict=True)
199     Traceback (most recent call last):
200     ...
201     SympifyError: SympifyError: None
202 
203     Evaluation
204     ----------
205 
206     If the option ``evaluate`` is set to ``False``, then arithmetic and
207     operators will be converted into their SymPy equivalents and the
208     ``evaluate=False`` option will be added. Nested ``Add`` or ``Mul`` will
209     be denested first. This is done via an AST transformation that replaces
210     operators with their SymPy equivalents, so if an operand redefines any
211     of those operations, the redefined operators will not be used. If
212     argument a is not a string, the mathematical expression is evaluated
213     before being passed to sympify, so adding evaluate=False will still
214     return the evaluated result of expression.
215 
216     >>> sympify('2**2 / 3 + 5')
217     19/3
218     >>> sympify('2**2 / 3 + 5', evaluate=False)
219     2**2/3 + 5
220     >>> sympify('4/2+7', evaluate=True)
221     9
222     >>> sympify('4/2+7', evaluate=False)
223     4/2 + 7
224     >>> sympify(4/2+7, evaluate=False)
225     9.00000000000000
226 
227     Extending
228     ---------
229 
230     To extend ``sympify`` to convert custom objects (not derived from ``Basic``),
231     just define a ``_sympy_`` method to your class. You can do that even to
232     classes that you do not own by subclassing or adding the method at runtime.
233 
234     >>> from sympy import Matrix
235     >>> class MyList1(object):
236     ...     def __iter__(self):
237     ...         yield 1
238     ...         yield 2
239     ...         return
240     ...     def __getitem__(self, i): return list(self)[i]
241     ...     def _sympy_(self): return Matrix(self)
242     >>> sympify(MyList1())
243     Matrix([
244     [1],
245     [2]])
246 
247     If you do not have control over the class definition you could also use the
248     ``converter`` global dictionary. The key is the class and the value is a
249     function that takes a single argument and returns the desired SymPy
250     object, e.g. ``converter[MyList] = lambda x: Matrix(x)``.
251 
252     >>> class MyList2(object):   # XXX Do not do this if you control the class!
253     ...     def __iter__(self):  #     Use _sympy_!
254     ...         yield 1
255     ...         yield 2
256     ...         return
257     ...     def __getitem__(self, i): return list(self)[i]
258     >>> from sympy.core.sympify import converter
259     >>> converter[MyList2] = lambda x: Matrix(x)
260     >>> sympify(MyList2())
261     Matrix([
262     [1],
263     [2]])
264 
265     Notes
266     =====
267 
268     The keywords ``rational`` and ``convert_xor`` are only used
269     when the input is a string.
270 
271     convert_xor
272     -----------
273 
274     >>> sympify('x^y',convert_xor=True)
275     x**y
276     >>> sympify('x^y',convert_xor=False)
277     x ^ y
278 
279     rational
280     --------
281 
282     >>> sympify('0.1',rational=False)
283     0.1
284     >>> sympify('0.1',rational=True)
285     1/10
286 
287     Sometimes autosimplification during sympification results in expressions
288     that are very different in structure than what was entered. Until such
289     autosimplification is no longer done, the ``kernS`` function might be of
290     some use. In the example below you can see how an expression reduces to
291     -1 by autosimplification, but does not do so when ``kernS`` is used.
292 
293     >>> from sympy.core.sympify import kernS
294     >>> from sympy.abc import x
295     >>> -2*(-(-x + 1/x)/(x*(x - 1/x)**2) - 1/(x*(x - 1/x))) - 1
296     -1
297     >>> s = '-2*(-(-x + 1/x)/(x*(x - 1/x)**2) - 1/(x*(x - 1/x))) - 1'
298     >>> sympify(s)
299     -1
300     >>> kernS(s)
301     -2*(-(-x + 1/x)/(x*(x - 1/x)**2) - 1/(x*(x - 1/x))) - 1
302 
303     Parameters
304     ==========
305 
306     a :
307         - any object defined in SymPy
308         - standard numeric python types: int, long, float, Decimal
309         - strings (like "0.09", "2e-19" or 'sin(x)')
310         - booleans, including ``None`` (will leave ``None`` unchanged)
311         - dict, lists, sets or tuples containing any of the above
312 
313     convert_xor : boolean, optional
314         If true, treats XOR as exponentiation.
315         If False, treats XOR as XOR itself.
316         Used only when input is a string.
317 
318     locals : any object defined in SymPy, optional
319         In order to have strings be recognized it can be imported
320         into a namespace dictionary and passed as locals.
321 
322     strict : boolean, optional
323         If the option strict is set to True, only the types for which
324         an explicit conversion has been defined are converted. In the
325         other cases, a SympifyError is raised.
326 
327     rational : boolean, optional
328         If true, converts floats into Rational.
329         If false, it lets floats remain as it is.
330         Used only when input is a string.
331 
332     evaluate : boolean, optional
333         If False, then arithmetic and operators will be converted into
334         their SymPy equivalents. If True the expression will be evaluated
335         and the result will be returned.
336 
337     """
338     # XXX: If a is a Basic subclass rather than instance (e.g. sin rather than
339     # sin(x)) then a.__sympy__ will be the property. Only on the instance will
340     # a.__sympy__ give the *value* of the property (True). Since sympify(sin)
341     # was used for a long time we allow it to pass. However if strict=True as
342     # is the case in internal calls to _sympify then we only allow
343     # is_sympy=True.
344     #
345     # https://github.com/sympy/sympy/issues/20124
346     is_sympy = getattr(a, '__sympy__', None)
347     if is_sympy is True:
348         return a
349     elif is_sympy is not None:
350         if not strict:
351             return a
352         else:
353             raise SympifyError(a)
354 
355     if isinstance(a, CantSympify):
356         raise SympifyError(a)
357     cls = getattr(a, "__class__", None)
358     if cls is None:
359         cls = type(a)  # Probably an old-style class
360     conv = converter.get(cls, None)
361     if conv is not None:
362         return conv(a)
363 
364     for superclass in getmro(cls):
365         try:
366             return converter[superclass](a)
367         except KeyError:
368             continue
369 
370     if cls is type(None):
371         if strict:
372             raise SympifyError(a)
373         else:
374             return a
375 
376     if evaluate is None:
377         evaluate = global_parameters.evaluate
378 
379     # Support for basic numpy datatypes
380     if _is_numpy_instance(a):
381         import numpy as np
382         if np.isscalar(a):
383             return _convert_numpy_types(a, locals=locals,
384                 convert_xor=convert_xor, strict=strict, rational=rational,
385                 evaluate=evaluate)
386 
387     _sympy_ = getattr(a, "_sympy_", None)
388     if _sympy_ is not None:
389         try:
390             return a._sympy_()
391         # XXX: Catches AttributeError: 'SympyConverter' object has no
392         # attribute 'tuple'
393         # This is probably a bug somewhere but for now we catch it here.
394         except AttributeError:
395             pass
396 
397     if not strict:
398         # Put numpy array conversion _before_ float/int, see
399         # <https://github.com/sympy/sympy/issues/13924>.
400         flat = getattr(a, "flat", None)
401         if flat is not None:
402             shape = getattr(a, "shape", None)
403             if shape is not None:
404                 from ..tensor.array import Array
405                 return Array(a.flat, a.shape)  # works with e.g. NumPy arrays
406 
407     if not isinstance(a, str):
408         if _is_numpy_instance(a):
409             import numpy as np
410             assert not isinstance(a, np.number)
411             if isinstance(a, np.ndarray):
412                 # Scalar arrays (those with zero dimensions) have sympify
413                 # called on the scalar element.
414                 if a.ndim == 0:
415                     try:
416                         return sympify(a.item(),
417                                        locals=locals,
418                                        convert_xor=convert_xor,
419                                        strict=strict,
420                                        rational=rational,
421                                        evaluate=evaluate)
422                     except SympifyError:
423                         pass
424         else:
425             # float and int can coerce size-one numpy arrays to their lone
426             # element.  See issue https://github.com/numpy/numpy/issues/10404.
427             for coerce in (float, int):
428                 try:
429                     return sympify(coerce(a))
430                 except (TypeError, ValueError, AttributeError, SympifyError):
431                     continue
432 
433     if strict:
434         raise SympifyError(a)
435 
436     if iterable(a):
437         try:
438             return type(a)([sympify(x, locals=locals, convert_xor=convert_xor,
439                 rational=rational) for x in a])
440         except TypeError:
441             # Not all iterables are rebuildable with their type.
442             pass
443     if isinstance(a, dict):
444         try:
445             return type(a)([sympify(x, locals=locals, convert_xor=convert_xor,
446                 rational=rational) for x in a.items()])
447         except TypeError:
448             # Not all iterables are rebuildable with their type.
449             pass
450 
451     if not isinstance(a, str):
452         try:
453             a = str(a)
454         except Exception as exc:
455             raise SympifyError(a, exc)
456         from sympy.utilities.exceptions import SymPyDeprecationWarning
457         SymPyDeprecationWarning(
458             feature="String fallback in sympify",
459             useinstead= \
460                 'sympify(str(obj)) or ' + \
461                 'sympy.core.sympify.converter or obj._sympy_',
462             issue=18066,
463             deprecated_since_version='1.6'
464         ).warn()
465 
466     from sympy.parsing.sympy_parser import (parse_expr, TokenError,
467                                             standard_transformations)
468     from sympy.parsing.sympy_parser import convert_xor as t_convert_xor
469     from sympy.parsing.sympy_parser import rationalize as t_rationalize
470 
471     transformations = standard_transformations
472 
473     if rational:
474         transformations += (t_rationalize,)
475     if convert_xor:
476         transformations += (t_convert_xor,)
477 
478     try:
479         a = a.replace('\n', '')
480         expr = parse_expr(a, local_dict=locals, transformations=transformations, evaluate=evaluate)
481     except (TokenError, SyntaxError) as exc:
482         raise SympifyError('could not parse %r' % a, exc)
483 
484     return expr

</code><intended_behavior>The `sympify` method needs to ensure consistent handling of the `evaluate` parameter, especially in cases involving functions like `ceiling`. The intended behavior here would be to ensure that when `evaluate=False`, expressions like `4*ceiling(x/4 - 3/4)` are kept unevaluated in a consistent manner across versions. This could involve inspecting how the AST transformation is applied when `evaluate=False` and ensuring that the logic does not inadvertently simplify or alter the structure of expressions involving `ceiling`. Additionally, it would be crucial to preserve existing functionalities for all other expressions and use cases, ensuring that any adjustments made do not affect the broader utility of `sympify`.</intended_behavior>, <file>sympy/simplify/simplify.py</file>
<class>None</class>
<method>None</method>
<code>
1 from __future__ import print_function, division
2 
3 from collections import defaultdict
4 
5 from sympy.core import (Basic, S, Add, Mul, Pow, Symbol, sympify,
6                         expand_func, Function, Dummy, Expr, factor_terms,
7                         expand_power_exp, Eq)
8 from sympy.core.compatibility import iterable, ordered, as_int
9 from sympy.core.parameters import global_parameters
10 from sympy.core.function import (expand_log, count_ops, _mexpand, _coeff_isneg,
11     nfloat, expand_mul)
12 from sympy.core.numbers import Float, I, pi, Rational, Integer
13 from sympy.core.relational import Relational
14 from sympy.core.rules import Transform
15 from sympy.core.sympify import _sympify
16 from sympy.functions import gamma, exp, sqrt, log, exp_polar, re
17 from sympy.functions.combinatorial.factorials import CombinatorialFunction
18 from sympy.functions.elementary.complexes import unpolarify, Abs
19 from sympy.functions.elementary.exponential import ExpBase
20 from sympy.functions.elementary.hyperbolic import HyperbolicFunction
21 from sympy.functions.elementary.integers import ceiling
22 from sympy.functions.elementary.piecewise import Piecewise, piecewise_fold
23 from sympy.functions.elementary.trigonometric import TrigonometricFunction
24 from sympy.functions.special.bessel import besselj, besseli, besselk, jn, bessely
25 from sympy.functions.special.tensor_functions import KroneckerDelta
26 from sympy.polys import together, cancel, factor
27 from sympy.simplify.combsimp import combsimp
28 from sympy.simplify.cse_opts import sub_pre, sub_post
29 from sympy.simplify.powsimp import powsimp
30 from sympy.simplify.radsimp import radsimp, fraction, collect_abs
31 from sympy.simplify.sqrtdenest import sqrtdenest
32 from sympy.simplify.trigsimp import trigsimp, exptrigsimp
33 from sympy.utilities.iterables import has_variety, sift
34 
35 
36 import mpmath
37 
38 
39 
40 def separatevars(expr, symbols=[], dict=False, force=False):
41     """
42     Separates variables in an expression, if possible.  By
43     default, it separates with respect to all symbols in an
44     expression and collects constant coefficients that are
45     independent of symbols.
46 
47     Explanation
48     ===========
49 
50     If ``dict=True`` then the separated terms will be returned
51     in a dictionary keyed to their corresponding symbols.
52     By default, all symbols in the expression will appear as
53     keys; if symbols are provided, then all those symbols will
54     be used as keys, and any terms in the expression containing
55     other symbols or non-symbols will be returned keyed to the
56     string 'coeff'. (Passing None for symbols will return the
57     expression in a dictionary keyed to 'coeff'.)
58 
59     If ``force=True``, then bases of powers will be separated regardless
60     of assumptions on the symbols involved.
61 
62     Notes
63     =====
64 
65     The order of the factors is determined by Mul, so that the
66     separated expressions may not necessarily be grouped together.
67 
68     Although factoring is necessary to separate variables in some
69     expressions, it is not necessary in all cases, so one should not
70     count on the returned factors being factored.
71 
72     Examples
73     ========
74 
75     >>> from sympy.abc import x, y, z, alpha
76     >>> from sympy import separatevars, sin
77     >>> separatevars((x*y)**y)
78     (x*y)**y
79     >>> separatevars((x*y)**y, force=True)
80     x**y*y**y
81 
82     >>> e = 2*x**2*z*sin(y)+2*z*x**2
83     >>> separatevars(e)
84     2*x**2*z*(sin(y) + 1)
85     >>> separatevars(e, symbols=(x, y), dict=True)
86     {'coeff': 2*z, x: x**2, y: sin(y) + 1}
87     >>> separatevars(e, [x, y, alpha], dict=True)
88     {'coeff': 2*z, alpha: 1, x: x**2, y: sin(y) + 1}
89 
90     If the expression is not really separable, or is only partially
91     separable, separatevars will do the best it can to separate it
92     by using factoring.
93 
94     >>> separatevars(x + x*y - 3*x**2)
95     -x*(3*x - y - 1)
96 
97     If the expression is not separable then expr is returned unchanged
98     or (if dict=True) then None is returned.
99 
100     >>> eq = 2*x + y*sin(x)
101     >>> separatevars(eq) == eq
102     True
103     >>> separatevars(2*x + y*sin(x), symbols=(x, y), dict=True) is None
104     True
105 
106     """
107     expr = sympify(expr)
108     if dict:
109         return _separatevars_dict(_separatevars(expr, force), symbols)
110     else:
111         return _separatevars(expr, force)
112 
113 
114 def _separatevars(expr, force):
115     if isinstance(expr, Abs):
116         arg = expr.args[0]
117         if arg.is_Mul and not arg.is_number:
118             s = separatevars(arg, dict=True, force=force)
119             if s is not None:
120                 return Mul(*map(expr.func, s.values()))
121             else:
122                 return expr
123 
124     if len(expr.free_symbols) < 2:
125         return expr
126 
127     # don't destroy a Mul since much of the work may already be done
128     if expr.is_Mul:
129         args = list(expr.args)
130         changed = False
131         for i, a in enumerate(args):
132             args[i] = separatevars(a, force)
133             changed = changed or args[i] != a
134         if changed:
135             expr = expr.func(*args)
136         return expr
137 
138     # get a Pow ready for expansion
139     if expr.is_Pow:
140         expr = Pow(separatevars(expr.base, force=force), expr.exp)
141 
142     # First try other expansion methods
143     expr = expr.expand(mul=False, multinomial=False, force=force)
144 
145     _expr, reps = posify(expr) if force else (expr, {})
146     expr = factor(_expr).subs(reps)
147 
148     if not expr.is_Add:
149         return expr
150 
151     # Find any common coefficients to pull out
152     args = list(expr.args)
153     commonc = args[0].args_cnc(cset=True, warn=False)[0]
154     for i in args[1:]:
155         commonc &= i.args_cnc(cset=True, warn=False)[0]
156     commonc = Mul(*commonc)
157     commonc = commonc.as_coeff_Mul()[1]  # ignore constants
158     commonc_set = commonc.args_cnc(cset=True, warn=False)[0]
159 
160     # remove them
161     for i, a in enumerate(args):
162         c, nc = a.args_cnc(cset=True, warn=False)
163         c = c - commonc_set
164         args[i] = Mul(*c)*Mul(*nc)
165     nonsepar = Add(*args)
166 
167     if len(nonsepar.free_symbols) > 1:
168         _expr = nonsepar
169         _expr, reps = posify(_expr) if force else (_expr, {})
170         _expr = (factor(_expr)).subs(reps)
171 
172         if not _expr.is_Add:
173             nonsepar = _expr
174 
175     return commonc*nonsepar
176 
177 
178 def _separatevars_dict(expr, symbols):
179     if symbols:
180         if not all((t.is_Atom for t in symbols)):
181             raise ValueError("symbols must be Atoms.")
182         symbols = list(symbols)
183     elif symbols is None:
184         return {'coeff': expr}
185     else:
186         symbols = list(expr.free_symbols)
187         if not symbols:
188             return None
189 
190     ret = dict(((i, []) for i in symbols + ['coeff']))
191 
192     for i in Mul.make_args(expr):
193         expsym = i.free_symbols
194         intersection = set(symbols).intersection(expsym)
195         if len(intersection) > 1:
196             return None
197         if len(intersection) == 0:
198             # There are no symbols, so it is part of the coefficient
199             ret['coeff'].append(i)
200         else:
201             ret[intersection.pop()].append(i)
202 
203     # rebuild
204     for k, v in ret.items():
205         ret[k] = Mul(*v)
206 
207     return ret
208 
209 
210 def _is_sum_surds(p):
211     args = p.args if p.is_Add else [p]
212     for y in args:
213         if not ((y**2).is_Rational and y.is_extended_real):
214             return False
215     return True
216 
217 
218 def posify(eq):
219     """Return ``eq`` (with generic symbols made positive) and a
220     dictionary containing the mapping between the old and new
221     symbols.
222 
223     Explanation
224     ===========
225 
226     Any symbol that has positive=None will be replaced with a positive dummy
227     symbol having the same name. This replacement will allow more symbolic
228     processing of expressions, especially those involving powers and
229     logarithms.
230 
231     A dictionary that can be sent to subs to restore ``eq`` to its original
232     symbols is also returned.
233 
234     >>> from sympy import posify, Symbol, log, solve
235     >>> from sympy.abc import x
236     >>> posify(x + Symbol('p', positive=True) + Symbol('n', negative=True))
237     (_x + n + p, {_x: x})
238 
239     >>> eq = 1/x
240     >>> log(eq).expand()
241     log(1/x)
242     >>> log(posify(eq)[0]).expand()
243     -log(_x)
244     >>> p, rep = posify(eq)
245     >>> log(p).expand().subs(rep)
246     -log(x)
247 
248     It is possible to apply the same transformations to an iterable
249     of expressions:
250 
251     >>> eq = x**2 - 4
252     >>> solve(eq, x)
253     [-2, 2]
254     >>> eq_x, reps = posify([eq, x]); eq_x
255     [_x**2 - 4, _x]
256     >>> solve(*eq_x)
257     [2]
258     """
259     eq = sympify(eq)
260     if iterable(eq):
261         f = type(eq)
262         eq = list(eq)
263         syms = set()
264         for e in eq:
265             syms = syms.union(e.atoms(Symbol))
266         reps = {}
267         for s in syms:
268             reps.update(dict((v, k) for k, v in posify(s)[1].items()))
269         for i, e in enumerate(eq):
270             eq[i] = e.subs(reps)
271         return f(eq), {r: s for s, r in reps.items()}
272 
273     reps = {s: Dummy(s.name, positive=True, **s.assumptions0)
274                  for s in eq.free_symbols if s.is_positive is None}
275     eq = eq.subs(reps)
276     return eq, {r: s for s, r in reps.items()}
277 
278 
279 def hypersimp(f, k):
280     """Given combinatorial term f(k) simplify its consecutive term ratio
281        i.e. f(k+1)/f(k).  The input term can be composed of functions and
282        integer sequences which have equivalent representation in terms
283        of gamma special function.
284 
285        Explanation
286        ===========
287 
288        The algorithm performs three basic steps:
289 
290        1. Rewrite all functions in terms of gamma, if possible.
291 
292        2. Rewrite all occurrences of gamma in terms of products
293           of gamma and rising factorial with integer,  absolute
294           constant exponent.
295 
296        3. Perform simplification of nested fractions, powers
297           and if the resulting expression is a quotient of
298           polynomials, reduce their total degree.
299 
300        If f(k) is hypergeometric then as result we arrive with a
301        quotient of polynomials of minimal degree. Otherwise None
302        is returned.
303 
304        For more information on the implemented algorithm refer to:
305 
306        1. W. Koepf, Algorithms for m-fold Hypergeometric Summation,
307           Journal of Symbolic Computation (1995) 20, 399-417
308     """
309     f = sympify(f)
310 
311     g = f.subs(k, k + 1) / f
312 
313     g = g.rewrite(gamma)
314     if g.has(Piecewise):
315         g = piecewise_fold(g)
316         g = g.args[-1][0]
317     g = expand_func(g)
318     g = powsimp(g, deep=True, combine='exp')
319 
320     if g.is_rational_function(k):
321         return simplify(g, ratio=S.Infinity)
322     else:
323         return None
324 
325 
326 def hypersimilar(f, g, k):
327     """
328     Returns True if ``f`` and ``g`` are hyper-similar.
329 
330     Explanation
331     ===========
332 
333     Similarity in hypergeometric sense means that a quotient of
334     f(k) and g(k) is a rational function in ``k``. This procedure
335     is useful in solving recurrence relations.
336 
337     For more information see hypersimp().
338 
339     """
340     f, g = list(map(sympify, (f, g)))
341 
342     h = (f/g).rewrite(gamma)
343     h = h.expand(func=True, basic=False)
344 
345     return h.is_rational_function(k)
346 
347 
348 def signsimp(expr, evaluate=None):
349     """Make all Add sub-expressions canonical wrt sign.
350 
351     Explanation
352     ===========
353 
354     If an Add subexpression, ``a``, can have a sign extracted,
355     as determined by could_extract_minus_sign, it is replaced
356     with Mul(-1, a, evaluate=False). This allows signs to be
357     extracted from powers and products.
358 
359     Examples
360     ========
361 
362     >>> from sympy import signsimp, exp, symbols
363     >>> from sympy.abc import x, y
364     >>> i = symbols('i', odd=True)
365     >>> n = -1 + 1/x
366     >>> n/x/(-n)**2 - 1/n/x
367     (-1 + 1/x)/(x*(1 - 1/x)**2) - 1/(x*(-1 + 1/x))
368     >>> signsimp(_)
369     0
370     >>> x*n + x*-n
371     x*(-1 + 1/x) + x*(1 - 1/x)
372     >>> signsimp(_)
373     0
374 
375     Since powers automatically handle leading signs
376 
377     >>> (-2)**i
378     -2**i
379 
380     signsimp can be used to put the base of a power with an integer
381     exponent into canonical form:
382 
383     >>> n**i
384     (-1 + 1/x)**i
385 
386     By default, signsimp doesn't leave behind any hollow simplification:
387     if making an Add canonical wrt sign didn't change the expression, the
388     original Add is restored. If this is not desired then the keyword
389     ``evaluate`` can be set to False:
390 
391     >>> e = exp(y - x)
392     >>> signsimp(e) == e
393     True
394     >>> signsimp(e, evaluate=False)
395     exp(-(x - y))
396 
397     """
398     if evaluate is None:
399         evaluate = global_parameters.evaluate
400     expr = sympify(expr)
401     if not isinstance(expr, (Expr, Relational)) or expr.is_Atom:
402         return expr
403     e = sub_post(sub_pre(expr))
404     if not isinstance(e, (Expr, Relational)) or e.is_Atom:
405         return e
406     if e.is_Add:
407         return e.func(*[signsimp(a, evaluate) for a in e.args])
408     if evaluate:
409         e = e.xreplace({m: -(-m) for m in e.atoms(Mul) if -(-m) != m})
410     return e
411 
412 
413 def simplify(expr, ratio=1.7, measure=count_ops, rational=False, inverse=False, doit=True, **kwargs):
414     """Simplifies the given expression.
415 
416     Explanation
417     ===========
418 
419     Simplification is not a well defined term and the exact strategies
420     this function tries can change in the future versions of SymPy. If
421     your algorithm relies on "simplification" (whatever it is), try to
422     determine what you need exactly  -  is it powsimp()?, radsimp()?,
423     together()?, logcombine()?, or something else? And use this particular
424     function directly, because those are well defined and thus your algorithm
425     will be robust.
426 
427     Nonetheless, especially for interactive use, or when you don't know
428     anything about the structure of the expression, simplify() tries to apply
429     intelligent heuristics to make the input expression "simpler".  For
430     example:
431 
432     >>> from sympy import simplify, cos, sin
433     >>> from sympy.abc import x, y
434     >>> a = (x + x**2)/(x*sin(y)**2 + x*cos(y)**2)
435     >>> a
436     (x**2 + x)/(x*sin(y)**2 + x*cos(y)**2)
437     >>> simplify(a)
438     x + 1
439 
440     Note that we could have obtained the same result by using specific
441     simplification functions:
442 
443     >>> from sympy import trigsimp, cancel
444     >>> trigsimp(a)
445     (x**2 + x)/x
446     >>> cancel(_)
447     x + 1
448 
449     In some cases, applying :func:`simplify` may actually result in some more
450     complicated expression. The default ``ratio=1.7`` prevents more extreme
451     cases: if (result length)/(input length) > ratio, then input is returned
452     unmodified.  The ``measure`` parameter lets you specify the function used
453     to determine how complex an expression is.  The function should take a
454     single argument as an expression and return a number such that if
455     expression ``a`` is more complex than expression ``b``, then
456     ``measure(a) > measure(b)``.  The default measure function is
457     :func:`~.count_ops`, which returns the total number of operations in the
458     expression.
459 
460     For example, if ``ratio=1``, ``simplify`` output can't be longer
461     than input.
462 
463     ::
464 
465         >>> from sympy import sqrt, simplify, count_ops, oo
466         >>> root = 1/(sqrt(2)+3)
467 
468     Since ``simplify(root)`` would result in a slightly longer expression,
469     root is returned unchanged instead::
470 
471        >>> simplify(root, ratio=1) == root
472        True
473 
474     If ``ratio=oo``, simplify will be applied anyway::
475 
476         >>> count_ops(simplify(root, ratio=oo)) > count_ops(root)
477         True
478 
479     Note that the shortest expression is not necessary the simplest, so
480     setting ``ratio`` to 1 may not be a good idea.
481     Heuristically, the default value ``ratio=1.7`` seems like a reasonable
482     choice.
483 
484     You can easily define your own measure function based on what you feel
485     should represent the "size" or "complexity" of the input expression.  Note
486     that some choices, such as ``lambda expr: len(str(expr))`` may appear to be
487     good metrics, but have other problems (in this case, the measure function
488     may slow down simplify too much for very large expressions).  If you don't
489     know what a good metric would be, the default, ``count_ops``, is a good
490     one.
491 
492     For example:
493 
494     >>> from sympy import symbols, log
495     >>> a, b = symbols('a b', positive=True)
496     >>> g = log(a) + log(b) + log(a)*log(1/b)
497     >>> h = simplify(g)
498     >>> h
499     log(a*b**(1 - log(a)))
500     >>> count_ops(g)
501     8
502     >>> count_ops(h)
503     5
504 
505     So you can see that ``h`` is simpler than ``g`` using the count_ops metric.
506     However, we may not like how ``simplify`` (in this case, using
507     ``logcombine``) has created the ``b**(log(1/a) + 1)`` term.  A simple way
508     to reduce this would be to give more weight to powers as operations in
509     ``count_ops``.  We can do this by using the ``visual=True`` option:
510 
511     >>> print(count_ops(g, visual=True))
512     2*ADD + DIV + 4*LOG + MUL
513     >>> print(count_ops(h, visual=True))
514     2*LOG + MUL + POW + SUB
515 
516     >>> from sympy import Symbol, S
517     >>> def my_measure(expr):
518     ...     POW = Symbol('POW')
519     ...     # Discourage powers by giving POW a weight of 10
520     ...     count = count_ops(expr, visual=True).subs(POW, 10)
521     ...     # Every other operation gets a weight of 1 (the default)
522     ...     count = count.replace(Symbol, type(S.One))
523     ...     return count
524     >>> my_measure(g)
525     8
526     >>> my_measure(h)
527     14
528     >>> 15./8 > 1.7 # 1.7 is the default ratio
529     True
530     >>> simplify(g, measure=my_measure)
531     -log(a)*log(b) + log(a) + log(b)
532 
533     Note that because ``simplify()`` internally tries many different
534     simplification strategies and then compares them using the measure
535     function, we get a completely different result that is still different
536     from the input expression by doing this.
537 
538     If ``rational=True``, Floats will be recast as Rationals before simplification.
539     If ``rational=None``, Floats will be recast as Rationals but the result will
540     be recast as Floats. If rational=False(default) then nothing will be done
541     to the Floats.
542 
543     If ``inverse=True``, it will be assumed that a composition of inverse
544     functions, such as sin and asin, can be cancelled in any order.
545     For example, ``asin(sin(x))`` will yield ``x`` without checking whether
546     x belongs to the set where this relation is true. The default is
547     False.
548 
549     Note that ``simplify()`` automatically calls ``doit()`` on the final
550     expression. You can avoid this behavior by passing ``doit=False`` as
551     an argument.
552     """
553 
554     def shorter(*choices):
555         """
556         Return the choice that has the fewest ops. In case of a tie,
557         the expression listed first is selected.
558         """
559         if not has_variety(choices):
560             return choices[0]
561         return min(choices, key=measure)
562 
563     def done(e):
564         rv = e.doit() if doit else e
565         return shorter(rv, collect_abs(rv))
566 
567     expr = sympify(expr)
568     kwargs = dict(
569         ratio=kwargs.get('ratio', ratio),
570         measure=kwargs.get('measure', measure),
571         rational=kwargs.get('rational', rational),
572         inverse=kwargs.get('inverse', inverse),
573         doit=kwargs.get('doit', doit))
574     # no routine for Expr needs to check for is_zero
575     if isinstance(expr, Expr) and expr.is_zero:
576         return S.Zero
577 
578     _eval_simplify = getattr(expr, '_eval_simplify', None)
579     if _eval_simplify is not None:
580         return _eval_simplify(**kwargs)
581 
582     original_expr = expr = collect_abs(signsimp(expr))
583 
584     if not isinstance(expr, Basic) or not expr.args:  # XXX: temporary hack
585         return expr
586 
587     if inverse and expr.has(Function):
588         expr = inversecombine(expr)
589         if not expr.args:  # simplified to atomic
590             return expr
591 
592     # do deep simplification
593     handled = Add, Mul, Pow, ExpBase
594     expr = expr.replace(
595         # here, checking for x.args is not enough because Basic has
596         # args but Basic does not always play well with replace, e.g.
597         # when simultaneous is True found expressions will be masked
598         # off with a Dummy but not all Basic objects in an expression
599         # can be replaced with a Dummy
600         lambda x: isinstance(x, Expr) and x.args and not isinstance(
601             x, handled),
602         lambda x: x.func(*[simplify(i, **kwargs) for i in x.args]),
603         simultaneous=False)
604     if not isinstance(expr, handled):
605         return done(expr)
606 
607     if not expr.is_commutative:
608         expr = nc_simplify(expr)
609 
610     # TODO: Apply different strategies, considering expression pattern:
611     # is it a purely rational function? Is there any trigonometric function?...
612     # See also https://github.com/sympy/sympy/pull/185.
613 
614 
615     # rationalize Floats
616     floats = False
617     if rational is not False and expr.has(Float):
618         floats = True
619         expr = nsimplify(expr, rational=True)
620 
621     expr = bottom_up(expr, lambda w: getattr(w, 'normal', lambda: w)())
622     expr = Mul(*powsimp(expr).as_content_primitive())
623     _e = cancel(expr)
624     expr1 = shorter(_e, _mexpand(_e).cancel())  # issue 6829
625     expr2 = shorter(together(expr, deep=True), together(expr1, deep=True))
626 
627     if ratio is S.Infinity:
628         expr = expr2
629     else:
630         expr = shorter(expr2, expr1, expr)
631     if not isinstance(expr, Basic):  # XXX: temporary hack
632         return expr
633 
634     expr = factor_terms(expr, sign=False)
635 
636     from sympy.simplify.hyperexpand import hyperexpand
637     from sympy.functions.special.bessel import BesselBase
638     from sympy import Sum, Product, Integral
639     from sympy.functions.elementary.complexes import sign
640 
641     # must come before `Piecewise` since this introduces more `Piecewise` terms
642     if expr.has(sign):
643         expr = expr.rewrite(Abs)
644 
645     # Deal with Piecewise separately to avoid recursive growth of expressions
646     if expr.has(Piecewise):
647         # Fold into a single Piecewise
648         expr = piecewise_fold(expr)
649         # Apply doit, if doit=True
650         expr = done(expr)
651         # Still a Piecewise?
652         if expr.has(Piecewise):
653             # Fold into a single Piecewise, in case doit lead to some
654             # expressions being Piecewise
655             expr = piecewise_fold(expr)
656             # kroneckersimp also affects Piecewise
657             if expr.has(KroneckerDelta):
658                 expr = kroneckersimp(expr)
659             # Still a Piecewise?
660             if expr.has(Piecewise):
661                 from sympy.functions.elementary.piecewise import piecewise_simplify
662                 # Do not apply doit on the segments as it has already
663                 # been done above, but simplify
664                 expr = piecewise_simplify(expr, deep=True, doit=False)
665                 # Still a Piecewise?
666                 if expr.has(Piecewise):
667                     # Try factor common terms
668                     expr = shorter(expr, factor_terms(expr))
669                     # As all expressions have been simplified above with the
670                     # complete simplify, nothing more needs to be done here
671                     return expr
672 
673     # hyperexpand automatically only works on hypergeometric terms
674     # Do this after the Piecewise part to avoid recursive expansion
675     expr = hyperexpand(expr)
676 
677     if expr.has(KroneckerDelta):
678         expr = kroneckersimp(expr)
679 
680     if expr.has(BesselBase):
681         expr = besselsimp(expr)
682 
683     if expr.has(TrigonometricFunction, HyperbolicFunction):
684         expr = trigsimp(expr, deep=True)
685 
686     if expr.has(log):
687         expr = shorter(expand_log(expr, deep=True), logcombine(expr))
688 
689     if expr.has(CombinatorialFunction, gamma):
690         # expression with gamma functions or non-integer arguments is
691         # automatically passed to gammasimp
692         expr = combsimp(expr)
693 
694     if expr.has(Sum):
695         expr = sum_simplify(expr, **kwargs)
696 
697     if expr.has(Integral):
698         expr = expr.xreplace(dict([
699             (i, factor_terms(i)) for i in expr.atoms(Integral)]))
700 
701     if expr.has(Product):
702         expr = product_simplify(expr)
703 
704     from sympy.physics.units import Quantity
705     from sympy.physics.units.util import quantity_simplify
706 
707     if expr.has(Quantity):
708         expr = quantity_simplify(expr)
709 
710     short = shorter(powsimp(expr, combine='exp', deep=True), powsimp(expr), expr)
711     short = shorter(short, cancel(short))
712     short = shorter(short, factor_terms(short), expand_power_exp(expand_mul(short)))
713     if short.has(TrigonometricFunction, HyperbolicFunction, ExpBase):
714         short = exptrigsimp(short)
715 
716     # get rid of hollow 2-arg Mul factorization
717     hollow_mul = Transform(
718         lambda x: Mul(*x.args),
719         lambda x:
720         x.is_Mul and
721         len(x.args) == 2 and
722         x.args[0].is_Number and
723         x.args[1].is_Add and
724         x.is_commutative)
725     expr = short.xreplace(hollow_mul)
726 
727     numer, denom = expr.as_numer_denom()
728     if denom.is_Add:
729         n, d = fraction(radsimp(1/denom, symbolic=False, max_terms=1))
730         if n is not S.One:
731             expr = (numer*n).expand()/d
732 
733     if expr.could_extract_minus_sign():
734         n, d = fraction(expr)
735         if d != 0:
736             expr = signsimp(-n/(-d))
737 
738     if measure(expr) > ratio*measure(original_expr):
739         expr = original_expr
740 
741     # restore floats
742     if floats and rational is None:
743         expr = nfloat(expr, exponent=False)
744 
745     return done(expr)
746 
747 
748 def sum_simplify(s, **kwargs):
749     """Main function for Sum simplification"""
750     from sympy.concrete.summations import Sum
751     from sympy.core.function import expand
752 
753     if not isinstance(s, Add):
754         s = s.xreplace(dict([(a, sum_simplify(a, **kwargs))
755             for a in s.atoms(Add) if a.has(Sum)]))
756     s = expand(s)
757     if not isinstance(s, Add):
758         return s
759 
760     terms = s.args
761     s_t = [] # Sum Terms
762     o_t = [] # Other Terms
763 
764     for term in terms:
765         sum_terms, other = sift(Mul.make_args(term),
766             lambda i: isinstance(i, Sum), binary=True)
767         if not sum_terms:
768             o_t.append(term)
769             continue
770         other = [Mul(*other)]
771         s_t.append(Mul(*(other + [s._eval_simplify(**kwargs) for s in sum_terms])))
772 
773     result = Add(sum_combine(s_t), *o_t)
774 
775     return result
776 
777 
778 def sum_combine(s_t):
779     """Helper function for Sum simplification
780 
781        Attempts to simplify a list of sums, by combining limits / sum function's
782        returns the simplified sum
783     """
784     from sympy.concrete.summations import Sum
785 
786     used = [False] * len(s_t)
787 
788     for method in range(2):
789         for i, s_term1 in enumerate(s_t):
790             if not used[i]:
791                 for j, s_term2 in enumerate(s_t):
792                     if not used[j] and i != j:
793                         temp = sum_add(s_term1, s_term2, method)
794                         if isinstance(temp, Sum) or isinstance(temp, Mul):
795                             s_t[i] = temp
796                             s_term1 = s_t[i]
797                             used[j] = True
798 
799     result = S.Zero
800     for i, s_term in enumerate(s_t):
801         if not used[i]:
802             result = Add(result, s_term)
803 
804     return result
805 
806 
807 def factor_sum(self, limits=None, radical=False, clear=False, fraction=False, sign=True):
808     """Return Sum with constant factors extracted.
809 
810     If ``limits`` is specified then ``self`` is the summand; the other
811     keywords are passed to ``factor_terms``.
812 
813     Examples
814     ========
815 
816     >>> from sympy import Sum
817     >>> from sympy.abc import x, y
818     >>> from sympy.simplify.simplify import factor_sum
819     >>> s = Sum(x*y, (x, 1, 3))
820     >>> factor_sum(s)
821     y*Sum(x, (x, 1, 3))
822     >>> factor_sum(s.function, s.limits)
823     y*Sum(x, (x, 1, 3))
824     """
825     # XXX deprecate in favor of direct call to factor_terms
826     from sympy.concrete.summations import Sum
827     kwargs = dict(radical=radical, clear=clear,
828         fraction=fraction, sign=sign)
829     expr = Sum(self, *limits) if limits else self
830     return factor_terms(expr, **kwargs)
831 
832 
833 def sum_add(self, other, method=0):
834     """Helper function for Sum simplification"""
835     from sympy.concrete.summations import Sum
836     from sympy import Mul
837 
838     #we know this is something in terms of a constant * a sum
839     #so we temporarily put the constants inside for simplification
840     #then simplify the result
841     def __refactor(val):
842         args = Mul.make_args(val)
843         sumv = next(x for x in args if isinstance(x, Sum))
844         constant = Mul(*[x for x in args if x != sumv])
845         return Sum(constant * sumv.function, *sumv.limits)
846 
847     if isinstance(self, Mul):
848         rself = __refactor(self)
849     else:
850         rself = self
851 
852     if isinstance(other, Mul):
853         rother = __refactor(other)
854     else:
855         rother = other
856 
857     if type(rself) == type(rother):
858         if method == 0:
859             if rself.limits == rother.limits:
860                 return factor_sum(Sum(rself.function + rother.function, *rself.limits))
861         elif method == 1:
862             if simplify(rself.function - rother.function) == 0:
863                 if len(rself.limits) == len(rother.limits) == 1:
864                     i = rself.limits[0][0]
865                     x1 = rself.limits[0][1]
866                     y1 = rself.limits[0][2]
867                     j = rother.limits[0][0]
868                     x2 = rother.limits[0][1]
869                     y2 = rother.limits[0][2]
870 
871                     if i == j:
872                         if x2 == y1 + 1:
873                             return factor_sum(Sum(rself.function, (i, x1, y2)))
874                         elif x1 == y2 + 1:
875                             return factor_sum(Sum(rself.function, (i, x2, y1)))
876 
877     return Add(self, other)
878 
879 
880 def product_simplify(s):
881     """Main function for Product simplification"""
882     from sympy.concrete.products import Product
883 
884     terms = Mul.make_args(s)
885     p_t = [] # Product Terms
886     o_t = [] # Other Terms
887 
888     for term in terms:
889         if isinstance(term, Product):
890             p_t.append(term)
891         else:
892             o_t.append(term)
893 
894     used = [False] * len(p_t)
895 
896     for method in range(2):
897         for i, p_term1 in enumerate(p_t):
898             if not used[i]:
899                 for j, p_term2 in enumerate(p_t):
900                     if not used[j] and i != j:
901                         if isinstance(product_mul(p_term1, p_term2, method), Product):
902                             p_t[i] = product_mul(p_term1, p_term2, method)
903                             used[j] = True
904 
905     result = Mul(*o_t)
906 
907     for i, p_term in enumerate(p_t):
908         if not used[i]:
909             result = Mul(result, p_term)
910 
911     return result
912 
913 
914 def product_mul(self, other, method=0):
915     """Helper function for Product simplification"""
916     from sympy.concrete.products import Product
917 
918     if type(self) == type(other):
919         if method == 0:
920             if self.limits == other.limits:
921                 return Product(self.function * other.function, *self.limits)
922         elif method == 1:
923             if simplify(self.function - other.function) == 0:
924                 if len(self.limits) == len(other.limits) == 1:
925                     i = self.limits[0][0]
926                     x1 = self.limits[0][1]
927                     y1 = self.limits[0][2]
928                     j = other.limits[0][0]
929                     x2 = other.limits[0][1]
930                     y2 = other.limits[0][2]
931 
932                     if i == j:
933                         if x2 == y1 + 1:
934                             return Product(self.function, (i, x1, y2))
935                         elif x1 == y2 + 1:
936                             return Product(self.function, (i, x2, y1))
937 
938     return Mul(self, other)
939 
940 
941 def _nthroot_solve(p, n, prec):
942     """
943      helper function for ``nthroot``
944      It denests ``p**Rational(1, n)`` using its minimal polynomial
945     """
946     from sympy.polys.numberfields import _minimal_polynomial_sq
947     from sympy.solvers import solve
948     while n % 2 == 0:
949         p = sqrtdenest(sqrt(p))
950         n = n // 2
951     if n == 1:
952         return p
953     pn = p**Rational(1, n)
954     x = Symbol('x')
955     f = _minimal_polynomial_sq(p, n, x)
956     if f is None:
957         return None
958     sols = solve(f, x)
959     for sol in sols:
960         if abs(sol - pn).n() < 1./10**prec:
961             sol = sqrtdenest(sol)
962             if _mexpand(sol**n) == p:
963                 return sol
964 
965 
966 def logcombine(expr, force=False):
967     """
968     Takes logarithms and combines them using the following rules:
969 
970     - log(x) + log(y) == log(x*y) if both are positive
971     - a*log(x) == log(x**a) if x is positive and a is real
972 
973     If ``force`` is ``True`` then the assumptions above will be assumed to hold if
974     there is no assumption already in place on a quantity. For example, if
975     ``a`` is imaginary or the argument negative, force will not perform a
976     combination but if ``a`` is a symbol with no assumptions the change will
977     take place.
978 
979     Examples
980     ========
981 
982     >>> from sympy import Symbol, symbols, log, logcombine, I
983     >>> from sympy.abc import a, x, y, z
984     >>> logcombine(a*log(x) + log(y) - log(z))
985     a*log(x) + log(y) - log(z)
986     >>> logcombine(a*log(x) + log(y) - log(z), force=True)
987     log(x**a*y/z)
988     >>> x,y,z = symbols('x,y,z', positive=True)
989     >>> a = Symbol('a', real=True)
990     >>> logcombine(a*log(x) + log(y) - log(z))
991     log(x**a*y/z)
992 
993     The transformation is limited to factors and/or terms that
994     contain logs, so the result depends on the initial state of
995     expansion:
996 
997     >>> eq = (2 + 3*I)*log(x)
998     >>> logcombine(eq, force=True) == eq
999     True
1000     >>> logcombine(eq.expand(), force=True)
1001     log(x**2) + I*log(x**3)
1002 
1003     See Also
1004     ========
1005 
1006     posify: replace all symbols with symbols having positive assumptions
1007     sympy.core.function.expand_log: expand the logarithms of products
1008         and powers; the opposite of logcombine
1009 
1010     """
1011 
1012     def f(rv):
1013         if not (rv.is_Add or rv.is_Mul):
1014             return rv
1015 
1016         def gooda(a):
1017             # bool to tell whether the leading ``a`` in ``a*log(x)``
1018             # could appear as log(x**a)
1019             return (a is not S.NegativeOne and  # -1 *could* go, but we disallow
1020                 (a.is_extended_real or force and a.is_extended_real is not False))
1021 
1022         def goodlog(l):
1023             # bool to tell whether log ``l``'s argument can combine with others
1024             a = l.args[0]
1025             return a.is_positive or force and a.is_nonpositive is not False
1026 
1027         other = []
1028         logs = []
1029         log1 = defaultdict(list)
1030         for a in Add.make_args(rv):
1031             if isinstance(a, log) and goodlog(a):
1032                 log1[()].append(([], a))
1033             elif not a.is_Mul:
1034                 other.append(a)
1035             else:
1036                 ot = []
1037                 co = []
1038                 lo = []
1039                 for ai in a.args:
1040                     if ai.is_Rational and ai < 0:
1041                         ot.append(S.NegativeOne)
1042                         co.append(-ai)
1043                     elif isinstance(ai, log) and goodlog(ai):
1044                         lo.append(ai)
1045                     elif gooda(ai):
1046                         co.append(ai)
1047                     else:
1048                         ot.append(ai)
1049                 if len(lo) > 1:
1050                     logs.append((ot, co, lo))
1051                 elif lo:
1052                     log1[tuple(ot)].append((co, lo[0]))
1053                 else:
1054                     other.append(a)
1055 
1056         # if there is only one log in other, put it with the
1057         # good logs
1058         if len(other) == 1 and isinstance(other[0], log):
1059             log1[()].append(([], other.pop()))
1060         # if there is only one log at each coefficient and none have
1061         # an exponent to place inside the log then there is nothing to do
1062         if not logs and all(len(log1[k]) == 1 and log1[k][0] == [] for k in log1):
1063             return rv
1064 
1065         # collapse multi-logs as far as possible in a canonical way
1066         # TODO: see if x*log(a)+x*log(a)*log(b) -> x*log(a)*(1+log(b))?
1067         # -- in this case, it's unambiguous, but if it were were a log(c) in
1068         # each term then it's arbitrary whether they are grouped by log(a) or
1069         # by log(c). So for now, just leave this alone; it's probably better to
1070         # let the user decide
1071         for o, e, l in logs:
1072             l = list(ordered(l))
1073             e = log(l.pop(0).args[0]**Mul(*e))
1074             while l:
1075                 li = l.pop(0)
1076                 e = log(li.args[0]**e)
1077             c, l = Mul(*o), e
1078             if isinstance(l, log):  # it should be, but check to be sure
1079                 log1[(c,)].append(([], l))
1080             else:
1081                 other.append(c*l)
1082 
1083         # logs that have the same coefficient can multiply
1084         for k in list(log1.keys()):
1085             log1[Mul(*k)] = log(logcombine(Mul(*[
1086                 l.args[0]**Mul(*c) for c, l in log1.pop(k)]),
1087                 force=force), evaluate=False)
1088 
1089         # logs that have oppositely signed coefficients can divide
1090         for k in ordered(list(log1.keys())):
1091             if not k in log1:  # already popped as -k
1092                 continue
1093             if -k in log1:
1094                 # figure out which has the minus sign; the one with
1095                 # more op counts should be the one
1096                 num, den = k, -k
1097                 if num.count_ops() > den.count_ops():
1098                     num, den = den, num
1099                 other.append(
1100                     num*log(log1.pop(num).args[0]/log1.pop(den).args[0],
1101                             evaluate=False))
1102             else:
1103                 other.append(k*log1.pop(k))
1104 
1105         return Add(*other)
1106 
1107     return bottom_up(expr, f)
1108 
1109 
1110 def inversecombine(expr):
1111     """Simplify the composition of a function and its inverse.
1112 
1113     Explanation
1114     ===========
1115 
1116     No attention is paid to whether the inverse is a left inverse or a
1117     right inverse; thus, the result will in general not be equivalent
1118     to the original expression.
1119 
1120     Examples
1121     ========
1122 
1123     >>> from sympy.simplify.simplify import inversecombine
1124     >>> from sympy import asin, sin, log, exp
1125     >>> from sympy.abc import x
1126     >>> inversecombine(asin(sin(x)))
1127     x
1128     >>> inversecombine(2*log(exp(3*x)))
1129     6*x
1130     """
1131 
1132     def f(rv):
1133         if rv.is_Function and hasattr(rv, "inverse"):
1134             if (len(rv.args) == 1 and len(rv.args[0].args) == 1 and
1135                 isinstance(rv.args[0], rv.inverse(argindex=1))):
1136                     rv = rv.args[0].args[0]
1137         return rv
1138 
1139     return bottom_up(expr, f)
1140 
1141 
1142 def walk(e, *target):
1143     """Iterate through the args that are the given types (target) and
1144     return a list of the args that were traversed; arguments
1145     that are not of the specified types are not traversed.
1146 
1147     Examples
1148     ========
1149 
1150     >>> from sympy.simplify.simplify import walk
1151     >>> from sympy import Min, Max
1152     >>> from sympy.abc import x, y, z
1153     >>> list(walk(Min(x, Max(y, Min(1, z))), Min))
1154     [Min(x, Max(y, Min(1, z)))]
1155     >>> list(walk(Min(x, Max(y, Min(1, z))), Min, Max))
1156     [Min(x, Max(y, Min(1, z))), Max(y, Min(1, z)), Min(1, z)]
1157 
1158     See Also
1159     ========
1160 
1161     bottom_up
1162     """
1163     if isinstance(e, target):
1164         yield e
1165         for i in e.args:
1166             for w in walk(i, *target):
1167                 yield w
1168 
1169 
1170 def bottom_up(rv, F, atoms=False, nonbasic=False):
1171     """Apply ``F`` to all expressions in an expression tree from the
1172     bottom up. If ``atoms`` is True, apply ``F`` even if there are no args;
1173     if ``nonbasic`` is True, try to apply ``F`` to non-Basic objects.
1174     """
1175     args = getattr(rv, 'args', None)
1176     if args is not None:
1177         if args:
1178             args = tuple([bottom_up(a, F, atoms, nonbasic) for a in args])
1179             if args != rv.args:
1180                 rv = rv.func(*args)
1181             rv = F(rv)
1182         elif atoms:
1183             rv = F(rv)
1184     else:
1185         if nonbasic:
1186             try:
1187                 rv = F(rv)
1188             except TypeError:
1189                 pass
1190 
1191     return rv
1192 
1193 
1194 def kroneckersimp(expr):
1195     """
1196     Simplify expressions with KroneckerDelta.
1197 
1198     The only simplification currently attempted is to identify multiplicative cancellation:
1199 
1200     Examples
1201     ========
1202 
1203     >>> from sympy import KroneckerDelta, kroneckersimp
1204     >>> from sympy.abc import i
1205     >>> kroneckersimp(1 + KroneckerDelta(0, i) * KroneckerDelta(1, i))
1206     1
1207     """
1208     def args_cancel(args1, args2):
1209         for i1 in range(2):
1210             for i2 in range(2):
1211                 a1 = args1[i1]
1212                 a2 = args2[i2]
1213                 a3 = args1[(i1 + 1) % 2]
1214                 a4 = args2[(i2 + 1) % 2]
1215                 if Eq(a1, a2) is S.true and Eq(a3, a4) is S.false:
1216                     return True
1217         return False
1218 
1219     def cancel_kronecker_mul(m):
1220         from sympy.utilities.iterables import subsets
1221 
1222         args = m.args
1223         deltas = [a for a in args if isinstance(a, KroneckerDelta)]
1224         for delta1, delta2 in subsets(deltas, 2):
1225             args1 = delta1.args
1226             args2 = delta2.args
1227             if args_cancel(args1, args2):
1228                 return 0*m
1229         return m
1230 
1231     if not expr.has(KroneckerDelta):
1232         return expr
1233 
1234     if expr.has(Piecewise):
1235         expr = expr.rewrite(KroneckerDelta)
1236 
1237     newexpr = expr
1238     expr = None
1239 
1240     while newexpr != expr:
1241         expr = newexpr
1242         newexpr = expr.replace(lambda e: isinstance(e, Mul), cancel_kronecker_mul)
1243 
1244     return expr
1245 
1246 
1247 def besselsimp(expr):
1248     """
1249     Simplify bessel-type functions.
1250 
1251     Explanation
1252     ===========
1253 
1254     This routine tries to simplify bessel-type functions. Currently it only
1255     works on the Bessel J and I functions, however. It works by looking at all
1256     such functions in turn, and eliminating factors of "I" and "-1" (actually
1257     their polar equivalents) in front of the argument. Then, functions of
1258     half-integer order are rewritten using strigonometric functions and
1259     functions of integer order (> 1) are rewritten using functions
1260     of low order.  Finally, if the expression was changed, compute
1261     factorization of the result with factor().
1262 
1263     >>> from sympy import besselj, besseli, besselsimp, polar_lift, I, S
1264     >>> from sympy.abc import z, nu
1265     >>> besselsimp(besselj(nu, z*polar_lift(-1)))
1266     exp(I*pi*nu)*besselj(nu, z)
1267     >>> besselsimp(besseli(nu, z*polar_lift(-I)))
1268     exp(-I*pi*nu/2)*besselj(nu, z)
1269     >>> besselsimp(besseli(S(-1)/2, z))
1270     sqrt(2)*cosh(z)/(sqrt(pi)*sqrt(z))
1271     >>> besselsimp(z*besseli(0, z) + z*(besseli(2, z))/2 + besseli(1, z))
1272     3*z*besseli(0, z)/2
1273     """
1274     # TODO
1275     # - better algorithm?
1276     # - simplify (cos(pi*b)*besselj(b,z) - besselj(-b,z))/sin(pi*b) ...
1277     # - use contiguity relations?
1278 
1279     def replacer(fro, to, factors):
1280         factors = set(factors)
1281 
1282         def repl(nu, z):
1283             if factors.intersection(Mul.make_args(z)):
1284                 return to(nu, z)
1285             return fro(nu, z)
1286         return repl
1287 
1288     def torewrite(fro, to):
1289         def tofunc(nu, z):
1290             return fro(nu, z).rewrite(to)
1291         return tofunc
1292 
1293     def tominus(fro):
1294         def tofunc(nu, z):
1295             return exp(I*pi*nu)*fro(nu, exp_polar(-I*pi)*z)
1296         return tofunc
1297 
1298     orig_expr = expr
1299 
1300     ifactors = [I, exp_polar(I*pi/2), exp_polar(-I*pi/2)]
1301     expr = expr.replace(
1302         besselj, replacer(besselj,
1303         torewrite(besselj, besseli), ifactors))
1304     expr = expr.replace(
1305         besseli, replacer(besseli,
1306         torewrite(besseli, besselj), ifactors))
1307 
1308     minusfactors = [-1, exp_polar(I*pi)]
1309     expr = expr.replace(
1310         besselj, replacer(besselj, tominus(besselj), minusfactors))
1311     expr = expr.replace(
1312         besseli, replacer(besseli, tominus(besseli), minusfactors))
1313 
1314     z0 = Dummy('z')
1315 
1316     def expander(fro):
1317         def repl(nu, z):
1318             if (nu % 1) == S.Half:
1319                 return simplify(trigsimp(unpolarify(
1320                         fro(nu, z0).rewrite(besselj).rewrite(jn).expand(
1321                             func=True)).subs(z0, z)))
1322             elif nu.is_Integer and nu > 1:
1323                 return fro(nu, z).expand(func=True)
1324             return fro(nu, z)
1325         return repl
1326 
1327     expr = expr.replace(besselj, expander(besselj))
1328     expr = expr.replace(bessely, expander(bessely))
1329     expr = expr.replace(besseli, expander(besseli))
1330     expr = expr.replace(besselk, expander(besselk))
1331 
1332     def _bessel_simp_recursion(expr):
1333 
1334         def _use_recursion(bessel, expr):
1335             while True:
1336                 bessels = expr.find(lambda x: isinstance(x, bessel))
1337                 try:
1338                     for ba in sorted(bessels, key=lambda x: re(x.args[0])):
1339                         a, x = ba.args
1340                         bap1 = bessel(a+1, x)
1341                         bap2 = bessel(a+2, x)
1342                         if expr.has(bap1) and expr.has(bap2):
1343                             expr = expr.subs(ba, 2*(a+1)/x*bap1 - bap2)
1344                             break
1345                     else:
1346                         return expr
1347                 except (ValueError, TypeError):
1348                     return expr
1349         if expr.has(besselj):
1350             expr = _use_recursion(besselj, expr)
1351         if expr.has(bessely):
1352             expr = _use_recursion(bessely, expr)
1353         return expr
1354 
1355     expr = _bessel_simp_recursion(expr)
1356     if expr != orig_expr:
1357         expr = expr.factor()
1358 
1359     return expr
1360 
1361 
1362 def nthroot(expr, n, max_len=4, prec=15):
1363     """
1364     Compute a real nth-root of a sum of surds.
1365 
1366     Parameters
1367     ==========
1368 
1369     expr : sum of surds
1370     n : integer
1371     max_len : maximum number of surds passed as constants to ``nsimplify``
1372 
1373     Algorithm
1374     =========
1375 
1376     First ``nsimplify`` is used to get a candidate root; if it is not a
1377     root the minimal polynomial is computed; the answer is one of its
1378     roots.
1379 
1380     Examples
1381     ========
1382 
1383     >>> from sympy.simplify.simplify import nthroot
1384     >>> from sympy import sqrt
1385     >>> nthroot(90 + 34*sqrt(7), 3)
1386     sqrt(7) + 3
1387 
1388     """
1389     expr = sympify(expr)
1390     n = sympify(n)
1391     p = expr**Rational(1, n)
1392     if not n.is_integer:
1393         return p
1394     if not _is_sum_surds(expr):
1395         return p
1396     surds = []
1397     coeff_muls = [x.as_coeff_Mul() for x in expr.args]
1398     for x, y in coeff_muls:
1399         if not x.is_rational:
1400             return p
1401         if y is S.One:
1402             continue
1403         if not (y.is_Pow and y.exp == S.Half and y.base.is_integer):
1404             return p
1405         surds.append(y)
1406     surds.sort()
1407     surds = surds[:max_len]
1408     if expr < 0 and n % 2 == 1:
1409         p = (-expr)**Rational(1, n)
1410         a = nsimplify(p, constants=surds)
1411         res = a if _mexpand(a**n) == _mexpand(-expr) else p
1412         return -res
1413     a = nsimplify(p, constants=surds)
1414     if _mexpand(a) is not _mexpand(p) and _mexpand(a**n) == _mexpand(expr):
1415         return _mexpand(a)
1416     expr = _nthroot_solve(expr, n, prec)
1417     if expr is None:
1418         return p
1419     return expr
1420 
1421 
1422 def nsimplify(expr, constants=(), tolerance=None, full=False, rational=None,
1423     rational_conversion='base10'):
1424     """
1425     Find a simple representation for a number or, if there are free symbols or
1426     if ``rational=True``, then replace Floats with their Rational equivalents. If
1427     no change is made and rational is not False then Floats will at least be
1428     converted to Rationals.
1429 
1430     Explanation
1431     ===========
1432 
1433     For numerical expressions, a simple formula that numerically matches the
1434     given numerical expression is sought (and the input should be possible
1435     to evalf to a precision of at least 30 digits).
1436 
1437     Optionally, a list of (rationally independent) constants to
1438     include in the formula may be given.
1439 
1440     A lower tolerance may be set to find less exact matches. If no tolerance
1441     is given then the least precise value will set the tolerance (e.g. Floats
1442     default to 15 digits of precision, so would be tolerance=10**-15).
1443 
1444     With ``full=True``, a more extensive search is performed
1445     (this is useful to find simpler numbers when the tolerance
1446     is set low).
1447 
1448     When converting to rational, if rational_conversion='base10' (the default), then
1449     convert floats to rationals using their base-10 (string) representation.
1450     When rational_conversion='exact' it uses the exact, base-2 representation.
1451 
1452     Examples
1453     ========
1454 
1455     >>> from sympy import nsimplify, sqrt, GoldenRatio, exp, I, pi
1456     >>> nsimplify(4/(1+sqrt(5)), [GoldenRatio])
1457     -2 + 2*GoldenRatio
1458     >>> nsimplify((1/(exp(3*pi*I/5)+1)))
1459     1/2 - I*sqrt(sqrt(5)/10 + 1/4)
1460     >>> nsimplify(I**I, [pi])
1461     exp(-pi/2)
1462     >>> nsimplify(pi, tolerance=0.01)
1463     22/7
1464 
1465     >>> nsimplify(0.333333333333333, rational=True, rational_conversion='exact')
1466     6004799503160655/18014398509481984
1467     >>> nsimplify(0.333333333333333, rational=True)
1468     1/3
1469 
1470     See Also
1471     ========
1472 
1473     sympy.core.function.nfloat
1474 
1475     """
1476     try:
1477         return sympify(as_int(expr))
1478     except (TypeError, ValueError):
1479         pass
1480     expr = sympify(expr).xreplace({
1481         Float('inf'): S.Infinity,
1482         Float('-inf'): S.NegativeInfinity,
1483         })
1484     if expr is S.Infinity or expr is S.NegativeInfinity:
1485         return expr
1486     if rational or expr.free_symbols:
1487         return _real_to_rational(expr, tolerance, rational_conversion)
1488 
1489     # SymPy's default tolerance for Rationals is 15; other numbers may have
1490     # lower tolerances set, so use them to pick the largest tolerance if None
1491     # was given
1492     if tolerance is None:
1493         tolerance = 10**-min([15] +
1494              [mpmath.libmp.libmpf.prec_to_dps(n._prec)
1495              for n in expr.atoms(Float)])
1496     # XXX should prec be set independent of tolerance or should it be computed
1497     # from tolerance?
1498     prec = 30
1499     bprec = int(prec*3.33)
1500 
1501     constants_dict = {}
1502     for constant in constants:
1503         constant = sympify(constant)
1504         v = constant.evalf(prec)
1505         if not v.is_Float:
1506             raise ValueError("constants must be real-valued")
1507         constants_dict[str(constant)] = v._to_mpmath(bprec)
1508 
1509     exprval = expr.evalf(prec, chop=True)
1510     re, im = exprval.as_real_imag()
1511 
1512     # safety check to make sure that this evaluated to a number
1513     if not (re.is_Number and im.is_Number):
1514         return expr
1515 
1516     def nsimplify_real(x):
1517         orig = mpmath.mp.dps
1518         xv = x._to_mpmath(bprec)
1519         try:
1520             # We'll be happy with low precision if a simple fraction
1521             if not (tolerance or full):
1522                 mpmath.mp.dps = 15
1523                 rat = mpmath.pslq([xv, 1])
1524                 if rat is not None:
1525                     return Rational(-int(rat[1]), int(rat[0]))
1526             mpmath.mp.dps = prec
1527             newexpr = mpmath.identify(xv, constants=constants_dict,
1528                 tol=tolerance, full=full)
1529             if not newexpr:
1530                 raise ValueError
1531             if full:
1532                 newexpr = newexpr[0]
1533             expr = sympify(newexpr)
1534             if x and not expr:  # don't let x become 0
1535                 raise ValueError
1536             if expr.is_finite is False and not xv in [mpmath.inf, mpmath.ninf]:
1537                 raise ValueError
1538             return expr
1539         finally:
1540             # even though there are returns above, this is executed
1541             # before leaving
1542             mpmath.mp.dps = orig
1543     try:
1544         if re:
1545             re = nsimplify_real(re)
1546         if im:
1547             im = nsimplify_real(im)
1548     except ValueError:
1549         if rational is None:
1550             return _real_to_rational(expr, rational_conversion=rational_conversion)
1551         return expr
1552 
1553     rv = re + im*S.ImaginaryUnit
1554     # if there was a change or rational is explicitly not wanted
1555     # return the value, else return the Rational representation
1556     if rv != expr or rational is False:
1557         return rv
1558     return _real_to_rational(expr, rational_conversion=rational_conversion)
1559 
1560 
1561 def _real_to_rational(expr, tolerance=None, rational_conversion='base10'):
1562     """
1563     Replace all reals in expr with rationals.
1564 
1565     Examples
1566     ========
1567 
1568     >>> from sympy.simplify.simplify import _real_to_rational
1569     >>> from sympy.abc import x
1570 
1571     >>> _real_to_rational(.76 + .1*x**.5)
1572     sqrt(x)/10 + 19/25
1573 
1574     If rational_conversion='base10', this uses the base-10 string. If
1575     rational_conversion='exact', the exact, base-2 representation is used.
1576 
1577     >>> _real_to_rational(0.333333333333333, rational_conversion='exact')
1578     6004799503160655/18014398509481984
1579     >>> _real_to_rational(0.333333333333333)
1580     1/3
1581 
1582     """
1583     expr = _sympify(expr)
1584     inf = Float('inf')
1585     p = expr
1586     reps = {}
1587     reduce_num = None
1588     if tolerance is not None and tolerance < 1:
1589         reduce_num = ceiling(1/tolerance)
1590     for fl in p.atoms(Float):
1591         key = fl
1592         if reduce_num is not None:
1593             r = Rational(fl).limit_denominator(reduce_num)
1594         elif (tolerance is not None and tolerance >= 1 and
1595                 fl.is_Integer is False):
1596             r = Rational(tolerance*round(fl/tolerance)
1597                 ).limit_denominator(int(tolerance))
1598         else:
1599             if rational_conversion == 'exact':
1600                 r = Rational(fl)
1601                 reps[key] = r
1602                 continue
1603             elif rational_conversion != 'base10':
1604                 raise ValueError("rational_conversion must be 'base10' or 'exact'")
1605 
1606             r = nsimplify(fl, rational=False)
1607             # e.g. log(3).n() -> log(3) instead of a Rational
1608             if fl and not r:
1609                 r = Rational(fl)
1610             elif not r.is_Rational:
1611                 if fl == inf or fl == -inf:
1612                     r = S.ComplexInfinity
1613                 elif fl < 0:
1614                     fl = -fl
1615                     d = Pow(10, int((mpmath.log(fl)/mpmath.log(10))))
1616                     r = -Rational(str(fl/d))*d
1617                 elif fl > 0:
1618                     d = Pow(10, int((mpmath.log(fl)/mpmath.log(10))))
1619                     r = Rational(str(fl/d))*d
1620                 else:
1621                     r = Integer(0)
1622         reps[key] = r
1623     return p.subs(reps, simultaneous=True)
1624 
1625 
1626 def clear_coefficients(expr, rhs=S.Zero):
1627     """Return `p, r` where `p` is the expression obtained when Rational
1628     additive and multiplicative coefficients of `expr` have been stripped
1629     away in a naive fashion (i.e. without simplification). The operations
1630     needed to remove the coefficients will be applied to `rhs` and returned
1631     as `r`.
1632 
1633     Examples
1634     ========
1635 
1636     >>> from sympy.simplify.simplify import clear_coefficients
1637     >>> from sympy.abc import x, y
1638     >>> from sympy import Dummy
1639     >>> expr = 4*y*(6*x + 3)
1640     >>> clear_coefficients(expr - 2)
1641     (y*(2*x + 1), 1/6)
1642 
1643     When solving 2 or more expressions like `expr = a`,
1644     `expr = b`, etc..., it is advantageous to provide a Dummy symbol
1645     for `rhs` and  simply replace it with `a`, `b`, etc... in `r`.
1646 
1647     >>> rhs = Dummy('rhs')
1648     >>> clear_coefficients(expr, rhs)
1649     (y*(2*x + 1), _rhs/12)
1650     >>> _[1].subs(rhs, 2)
1651     1/6
1652     """
1653     was = None
1654     free = expr.free_symbols
1655     if expr.is_Rational:
1656         return (S.Zero, rhs - expr)
1657     while expr and was != expr:
1658         was = expr
1659         m, expr = (
1660             expr.as_content_primitive()
1661             if free else
1662             factor_terms(expr).as_coeff_Mul(rational=True))
1663         rhs /= m
1664         c, expr = expr.as_coeff_Add(rational=True)
1665         rhs -= c
1666     expr = signsimp(expr, evaluate = False)
1667     if _coeff_isneg(expr):
1668         expr = -expr
1669         rhs = -rhs
1670     return expr, rhs
1671 
1672 def nc_simplify(expr, deep=True):
1673     '''
1674     Simplify a non-commutative expression composed of multiplication
1675     and raising to a power by grouping repeated subterms into one power.
1676     Priority is given to simplifications that give the fewest number
1677     of arguments in the end (for example, in a*b*a*b*c*a*b*c simplifying
1678     to (a*b)**2*c*a*b*c gives 5 arguments while a*b*(a*b*c)**2 has 3).
1679     If ``expr`` is a sum of such terms, the sum of the simplified terms
1680     is returned.
1681 
1682     Keyword argument ``deep`` controls whether or not subexpressions
1683     nested deeper inside the main expression are simplified. See examples
1684     below. Setting `deep` to `False` can save time on nested expressions
1685     that don't need simplifying on all levels.
1686 
1687     Examples
1688     ========
1689 
1690     >>> from sympy import symbols
1691     >>> from sympy.simplify.simplify import nc_simplify
1692     >>> a, b, c = symbols("a b c", commutative=False)
1693     >>> nc_simplify(a*b*a*b*c*a*b*c)
1694     a*b*(a*b*c)**2
1695     >>> expr = a**2*b*a**4*b*a**4
1696     >>> nc_simplify(expr)
1697     a**2*(b*a**4)**2
1698     >>> nc_simplify(a*b*a*b*c**2*(a*b)**2*c**2)
1699     ((a*b)**2*c**2)**2
1700     >>> nc_simplify(a*b*a*b + 2*a*c*a**2*c*a**2*c*a)
1701     (a*b)**2 + 2*(a*c*a)**3
1702     >>> nc_simplify(b**-1*a**-1*(a*b)**2)
1703     a*b
1704     >>> nc_simplify(a**-1*b**-1*c*a)
1705     (b*a)**(-1)*c*a
1706     >>> expr = (a*b*a*b)**2*a*c*a*c
1707     >>> nc_simplify(expr)
1708     (a*b)**4*(a*c)**2
1709     >>> nc_simplify(expr, deep=False)
1710     (a*b*a*b)**2*(a*c)**2
1711 
1712     '''
1713     from sympy.matrices.expressions import (MatrixExpr, MatAdd, MatMul,
1714                                                 MatPow, MatrixSymbol)
1715     from sympy.core.exprtools import factor_nc
1716 
1717     if isinstance(expr, MatrixExpr):
1718         expr = expr.doit(inv_expand=False)
1719         _Add, _Mul, _Pow, _Symbol = MatAdd, MatMul, MatPow, MatrixSymbol
1720     else:
1721         _Add, _Mul, _Pow, _Symbol = Add, Mul, Pow, Symbol
1722 
1723     # =========== Auxiliary functions ========================
1724     def _overlaps(args):
1725         # Calculate a list of lists m such that m[i][j] contains the lengths
1726         # of all possible overlaps between args[:i+1] and args[i+1+j:].
1727         # An overlap is a suffix of the prefix that matches a prefix
1728         # of the suffix.
1729         # For example, let expr=c*a*b*a*b*a*b*a*b. Then m[3][0] contains
1730         # the lengths of overlaps of c*a*b*a*b with a*b*a*b. The overlaps
1731         # are a*b*a*b, a*b and the empty word so that m[3][0]=[4,2,0].
1732         # All overlaps rather than only the longest one are recorded
1733         # because this information helps calculate other overlap lengths.
1734         m = [[([1, 0] if a == args[0] else [0]) for a in args[1:]]]
1735         for i in range(1, len(args)):
1736             overlaps = []
1737             j = 0
1738             for j in range(len(args) - i - 1):
1739                 overlap = []
1740                 for v in m[i-1][j+1]:
1741                     if j + i + 1 + v < len(args) and args[i] == args[j+i+1+v]:
1742                         overlap.append(v + 1)
1743                 overlap += [0]
1744                 overlaps.append(overlap)
1745             m.append(overlaps)
1746         return m
1747 
1748     def _reduce_inverses(_args):
1749         # replace consecutive negative powers by an inverse
1750         # of a product of positive powers, e.g. a**-1*b**-1*c
1751         # will simplify to (a*b)**-1*c;
1752         # return that new args list and the number of negative
1753         # powers in it (inv_tot)
1754         inv_tot = 0 # total number of inverses
1755         inverses = []
1756         args = []
1757         for arg in _args:
1758             if isinstance(arg, _Pow) and arg.args[1] < 0:
1759                 inverses = [arg**-1] + inverses
1760                 inv_tot += 1
1761             else:
1762                 if len(inverses) == 1:
1763                     args.append(inverses[0]**-1)
1764                 elif len(inverses) > 1:
1765                     args.append(_Pow(_Mul(*inverses), -1))
1766                     inv_tot -= len(inverses) - 1
1767                 inverses = []
1768                 args.append(arg)
1769         if inverses:
1770             args.append(_Pow(_Mul(*inverses), -1))
1771             inv_tot -= len(inverses) - 1
1772         return inv_tot, tuple(args)
1773 
1774     def get_score(s):
1775         # compute the number of arguments of s
1776         # (including in nested expressions) overall
1777         # but ignore exponents
1778         if isinstance(s, _Pow):
1779             return get_score(s.args[0])
1780         elif isinstance(s, (_Add, _Mul)):
1781             return sum([get_score(a) for a in s.args])
1782         return 1
1783 
1784     def compare(s, alt_s):
1785         # compare two possible simplifications and return a
1786         # "better" one
1787         if s != alt_s and get_score(alt_s) < get_score(s):
1788             return alt_s
1789         return s
1790     # ========================================================
1791 
1792     if not isinstance(expr, (_Add, _Mul, _Pow)) or expr.is_commutative:
1793         return expr
1794     args = expr.args[:]
1795     if isinstance(expr, _Pow):
1796         if deep:
1797             return _Pow(nc_simplify(args[0]), args[1]).doit()
1798         else:
1799             return expr
1800     elif isinstance(expr, _Add):
1801         return _Add(*[nc_simplify(a, deep=deep) for a in args]).doit()
1802     else:
1803         # get the non-commutative part
1804         c_args, args = expr.args_cnc()
1805         com_coeff = Mul(*c_args)
1806         if com_coeff != 1:
1807             return com_coeff*nc_simplify(expr/com_coeff, deep=deep)
1808 
1809     inv_tot, args = _reduce_inverses(args)
1810     # if most arguments are negative, work with the inverse
1811     # of the expression, e.g. a**-1*b*a**-1*c**-1 will become
1812     # (c*a*b**-1*a)**-1 at the end so can work with c*a*b**-1*a
1813     invert = False
1814     if inv_tot > len(args)/2:
1815         invert = True
1816         args = [a**-1 for a in args[::-1]]
1817 
1818     if deep:
1819         args = tuple(nc_simplify(a) for a in args)
1820 
1821     m = _overlaps(args)
1822 
1823     # simps will be {subterm: end} where `end` is the ending
1824     # index of a sequence of repetitions of subterm;
1825     # this is for not wasting time with subterms that are part
1826     # of longer, already considered sequences
1827     simps = {}
1828 
1829     post = 1
1830     pre = 1
1831 
1832     # the simplification coefficient is the number of
1833     # arguments by which contracting a given sequence
1834     # would reduce the word; e.g. in a*b*a*b*c*a*b*c,
1835     # contracting a*b*a*b to (a*b)**2 removes 3 arguments
1836     # while a*b*c*a*b*c to (a*b*c)**2 removes 6. It's
1837     # better to contract the latter so simplification
1838     # with a maximum simplification coefficient will be chosen
1839     max_simp_coeff = 0
1840     simp = None # information about future simplification
1841 
1842     for i in range(1, len(args)):
1843         simp_coeff = 0
1844         l = 0 # length of a subterm
1845         p = 0 # the power of a subterm
1846         if i < len(args) - 1:
1847             rep = m[i][0]
1848         start = i # starting index of the repeated sequence
1849         end = i+1 # ending index of the repeated sequence
1850         if i == len(args)-1 or rep == [0]:
1851             # no subterm is repeated at this stage, at least as
1852             # far as the arguments are concerned - there may be
1853             # a repetition if powers are taken into account
1854             if (isinstance(args[i], _Pow) and
1855                             not isinstance(args[i].args[0], _Symbol)):
1856                 subterm = args[i].args[0].args
1857                 l = len(subterm)
1858                 if args[i-l:i] == subterm:
1859                     # e.g. a*b in a*b*(a*b)**2 is not repeated
1860                     # in args (= [a, b, (a*b)**2]) but it
1861                     # can be matched here
1862                     p += 1
1863                     start -= l
1864                 if args[i+1:i+1+l] == subterm:
1865                     # e.g. a*b in (a*b)**2*a*b
1866                     p += 1
1867                     end += l
1868             if p:
1869                 p += args[i].args[1]
1870             else:
1871                 continue
1872         else:
1873             l = rep[0] # length of the longest repeated subterm at this point
1874             start -= l - 1
1875             subterm = args[start:end]
1876             p = 2
1877             end += l
1878 
1879         if subterm in simps and simps[subterm] >= start:
1880             # the subterm is part of a sequence that
1881             # has already been considered
1882             continue
1883 
1884         # count how many times it's repeated
1885         while end < len(args):
1886             if l in m[end-1][0]:
1887                 p += 1
1888                 end += l
1889             elif isinstance(args[end], _Pow) and args[end].args[0].args == subterm:
1890                 # for cases like a*b*a*b*(a*b)**2*a*b
1891                 p += args[end].args[1]
1892                 end += 1
1893             else:
1894                 break
1895 
1896         # see if another match can be made, e.g.
1897         # for b*a**2 in b*a**2*b*a**3 or a*b in
1898         # a**2*b*a*b
1899 
1900         pre_exp = 0
1901         pre_arg = 1
1902         if start - l >= 0 and args[start-l+1:start] == subterm[1:]:
1903             if isinstance(subterm[0], _Pow):
1904                 pre_arg = subterm[0].args[0]
1905                 exp = subterm[0].args[1]
1906             else:
1907                 pre_arg = subterm[0]
1908                 exp = 1
1909             if isinstance(args[start-l], _Pow) and args[start-l].args[0] == pre_arg:
1910                 pre_exp = args[start-l].args[1] - exp
1911                 start -= l
1912                 p += 1
1913             elif args[start-l] == pre_arg:
1914                 pre_exp = 1 - exp
1915                 start -= l
1916                 p += 1
1917 
1918         post_exp = 0
1919         post_arg = 1
1920         if end + l - 1 < len(args) and args[end:end+l-1] == subterm[:-1]:
1921             if isinstance(subterm[-1], _Pow):
1922                 post_arg = subterm[-1].args[0]
1923                 exp = subterm[-1].args[1]
1924             else:
1925                 post_arg = subterm[-1]
1926                 exp = 1
1927             if isinstance(args[end+l-1], _Pow) and args[end+l-1].args[0] == post_arg:
1928                 post_exp = args[end+l-1].args[1] - exp
1929                 end += l
1930                 p += 1
1931             elif args[end+l-1] == post_arg:
1932                 post_exp = 1 - exp
1933                 end += l
1934                 p += 1
1935 
1936         # Consider a*b*a**2*b*a**2*b*a:
1937         # b*a**2 is explicitly repeated, but note
1938         # that in this case a*b*a is also repeated
1939         # so there are two possible simplifications:
1940         # a*(b*a**2)**3*a**-1 or (a*b*a)**3
1941         # The latter is obviously simpler.
1942         # But in a*b*a**2*b**2*a**2 the simplifications are
1943         # a*(b*a**2)**2 and (a*b*a)**3*a in which case
1944         # it's better to stick with the shorter subterm
1945         if post_exp and exp % 2 == 0 and start > 0:
1946             exp = exp/2
1947             _pre_exp = 1
1948             _post_exp = 1
1949             if isinstance(args[start-1], _Pow) and args[start-1].args[0] == post_arg:
1950                 _post_exp = post_exp + exp
1951                 _pre_exp = args[start-1].args[1] - exp
1952             elif args[start-1] == post_arg:
1953                 _post_exp = post_exp + exp
1954                 _pre_exp = 1 - exp
1955             if _pre_exp == 0 or _post_exp == 0:
1956                 if not pre_exp:
1957                     start -= 1
1958                 post_exp = _post_exp
1959                 pre_exp = _pre_exp
1960                 pre_arg = post_arg
1961                 subterm = (post_arg**exp,) + subterm[:-1] + (post_arg**exp,)
1962 
1963         simp_coeff += end-start
1964 
1965         if post_exp:
1966             simp_coeff -= 1
1967         if pre_exp:
1968             simp_coeff -= 1
1969 
1970         simps[subterm] = end
1971 
1972         if simp_coeff > max_simp_coeff:
1973             max_simp_coeff = simp_coeff
1974             simp = (start, _Mul(*subterm), p, end, l)
1975             pre = pre_arg**pre_exp
1976             post = post_arg**post_exp
1977 
1978     if simp:
1979         subterm = _Pow(nc_simplify(simp[1], deep=deep), simp[2])
1980         pre = nc_simplify(_Mul(*args[:simp[0]])*pre, deep=deep)
1981         post = post*nc_simplify(_Mul(*args[simp[3]:]), deep=deep)
1982         simp = pre*subterm*post
1983         if pre != 1 or post != 1:
1984             # new simplifications may be possible but no need
1985             # to recurse over arguments
1986             simp = nc_simplify(simp, deep=False)
1987     else:
1988         simp = _Mul(*args)
1989 
1990     if invert:
1991         simp = _Pow(simp, -1)
1992 
1993     # see if factor_nc(expr) is simplified better
1994     if not isinstance(expr, MatrixExpr):
1995         f_expr = factor_nc(expr)
1996         if f_expr != expr:
1997             alt_simp = nc_simplify(f_expr, deep=deep)
1998             simp = compare(simp, alt_simp)
1999     else:
2000         simp = simp.doit(inv_expand=False)
2001     return simp
2002 
2003 
2004 def dotprodsimp(expr, withsimp=False):
2005     """Simplification for a sum of products targeted at the kind of blowup that
2006     occurs during summation of products. Intended to reduce expression blowup
2007     during matrix multiplication or other similar operations. Only works with
2008     algebraic expressions and does not recurse into non.
2009 
2010     Parameters
2011     ==========
2012 
2013     withsimp : bool, optional
2014         Specifies whether a flag should be returned along with the expression
2015         to indicate roughly whether simplification was successful. It is used
2016         in ``MatrixArithmetic._eval_pow_by_recursion`` to avoid attempting to
2017         simplify an expression repetitively which does not simplify.
2018     """
2019 
2020     def count_ops_alg(expr):
2021         """Optimized count algebraic operations with no recursion into
2022         non-algebraic args that ``core.function.count_ops`` does. Also returns
2023         whether rational functions may be present according to negative
2024         exponents of powers or non-number fractions.
2025 
2026         Returns
2027         =======
2028 
2029         ops, ratfunc : int, bool
2030             ``ops`` is the number of algebraic operations starting at the top
2031             level expression (not recursing into non-alg children). ``ratfunc``
2032             specifies whether the expression MAY contain rational functions
2033             which ``cancel`` MIGHT optimize.
2034         """
2035 
2036         ops     = 0
2037         args    = [expr]
2038         ratfunc = False
2039 
2040         while args:
2041             a = args.pop()
2042 
2043             if not isinstance(a, Basic):
2044                 continue
2045 
2046             if a.is_Rational:
2047                 if a is not S.One: # -1/3 = NEG + DIV
2048                     ops += bool (a.p < 0) + bool (a.q != 1)
2049 
2050             elif a.is_Mul:
2051                 if _coeff_isneg(a):
2052                     ops += 1
2053                     if a.args[0] is S.NegativeOne:
2054                         a = a.as_two_terms()[1]
2055                     else:
2056                         a = -a
2057 
2058                 n, d = fraction(a)
2059 
2060                 if n.is_Integer:
2061                     ops += 1 + bool (n < 0)
2062                     args.append(d) # won't be -Mul but could be Add
2063 
2064                 elif d is not S.One:
2065                     if not d.is_Integer:
2066                         args.append(d)
2067                         ratfunc=True
2068 
2069                     ops += 1
2070                     args.append(n) # could be -Mul
2071 
2072                 else:
2073                     ops += len(a.args) - 1
2074                     args.extend(a.args)
2075 
2076             elif a.is_Add:
2077                 laargs = len(a.args)
2078                 negs   = 0
2079 
2080                 for ai in a.args:
2081                     if _coeff_isneg(ai):
2082                         negs += 1
2083                         ai    = -ai
2084                     args.append(ai)
2085 
2086                 ops += laargs - (negs != laargs) # -x - y = NEG + SUB
2087 
2088             elif a.is_Pow:
2089                 ops += 1
2090                 args.append(a.base)
2091 
2092                 if not ratfunc:
2093                     ratfunc = a.exp.is_negative is not False
2094 
2095         return ops, ratfunc
2096 
2097     def nonalg_subs_dummies(expr, dummies):
2098         """Substitute dummy variables for non-algebraic expressions to avoid
2099         evaluation of non-algebraic terms that ``polys.polytools.cancel`` does.
2100         """
2101 
2102         if not expr.args:
2103             return expr
2104 
2105         if expr.is_Add or expr.is_Mul or expr.is_Pow:
2106             args = None
2107 
2108             for i, a in enumerate(expr.args):
2109                 c = nonalg_subs_dummies(a, dummies)
2110 
2111                 if c is a:
2112                     continue
2113 
2114                 if args is None:
2115                     args = list(expr.args)
2116 
2117                 args[i] = c
2118 
2119             if args is None:
2120                 return expr
2121 
2122             return expr.func(*args)
2123 
2124         return dummies.setdefault(expr, Dummy())
2125 
2126     simplified = False # doesn't really mean simplified, rather "can simplify again"
2127 
2128     if isinstance(expr, Basic) and (expr.is_Add or expr.is_Mul or expr.is_Pow):
2129         expr2 = expr.expand(deep=True, modulus=None, power_base=False,
2130             power_exp=False, mul=True, log=False, multinomial=True, basic=False)
2131 
2132         if expr2 != expr:
2133             expr       = expr2
2134             simplified = True
2135 
2136         exprops, ratfunc = count_ops_alg(expr)
2137 
2138         if exprops >= 6: # empirically tested cutoff for expensive simplification
2139             if ratfunc:
2140                 dummies = {}
2141                 expr2   = nonalg_subs_dummies(expr, dummies)
2142 
2143                 if expr2 is expr or count_ops_alg(expr2)[0] >= 6: # check again after substitution
2144                     expr3 = cancel(expr2)
2145 
2146                     if expr3 != expr2:
2147                         expr       = expr3.subs([(d, e) for e, d in dummies.items()])
2148                         simplified = True
2149 
2150         # very special case: x/(x-1) - 1/(x-1) -> 1
2151         elif (exprops == 5 and expr.is_Add and expr.args [0].is_Mul and
2152                 expr.args [1].is_Mul and expr.args [0].args [-1].is_Pow and
2153                 expr.args [1].args [-1].is_Pow and
2154                 expr.args [0].args [-1].exp is S.NegativeOne and
2155                 expr.args [1].args [-1].exp is S.NegativeOne):
2156 
2157             expr2    = together (expr)
2158             expr2ops = count_ops_alg(expr2)[0]
2159 
2160             if expr2ops < exprops:
2161                 expr       = expr2
2162                 simplified = True
2163 
2164         else:
2165             simplified = True
2166 
2167     return (expr, simplified) if withsimp else expr

</code><intended_behavior>The `simplify` method(s) should exhibit consistent behavior when dealing with expressions passed from `sympify` with `evaluate=False`. This means ensuring that expressions involving `ceiling` are simplified appropriately without assuming that the expression has been pre-evaluated unless specified. The resolution would require a thorough review of how `simplify` interacts with expressions marked as unevaluated by `sympify` to identify any logic that might differ in handling such cases between SymPy versions 1.5.1 and 1.6.2. The goal would be to maintain the integrity of unevaluated expressions throughout the simplification process, ensuring consistent outcomes regardless of version changes.</intended_behavior>]
2025-10-18 20:43:59.780 | INFO     | Search completed. Bug locations: [<file>sympy/core/sympify.py</file>
<class>None</class>
<method>sympify</method>
<code>
92 def sympify(a, locals=None, convert_xor=True, strict=False, rational=False,
93         evaluate=None):
94     """
95     Converts an arbitrary expression to a type that can be used inside SymPy.
96 
97     Explanation
98     ===========
99 
100     It will convert Python ints into instances of sympy.Integer,
101     floats into instances of sympy.Float, etc. It is also able to coerce symbolic
102     expressions which inherit from Basic. This can be useful in cooperation
103     with SAGE.
104 
105     .. warning::
106         Note that this function uses ``eval``, and thus shouldn't be used on
107         unsanitized input.
108 
109     If the argument is already a type that SymPy understands, it will do
110     nothing but return that value. This can be used at the beginning of a
111     function to ensure you are working with the correct type.
112 
113     Examples
114     ========
115 
116     >>> from sympy import sympify
117 
118     >>> sympify(2).is_integer
119     True
120     >>> sympify(2).is_real
121     True
122 
123     >>> sympify(2.0).is_real
124     True
125     >>> sympify("2.0").is_real
126     True
127     >>> sympify("2e-45").is_real
128     True
129 
130     If the expression could not be converted, a SympifyError is raised.
131 
132     >>> sympify("x***2")
133     Traceback (most recent call last):
134     ...
135     SympifyError: SympifyError: "could not parse 'x***2'"
136 
137     Locals
138     ------
139 
140     The sympification happens with access to everything that is loaded
141     by ``from sympy import *``; anything used in a string that is not
142     defined by that import will be converted to a symbol. In the following,
143     the ``bitcount`` function is treated as a symbol and the ``O`` is
144     interpreted as the Order object (used with series) and it raises
145     an error when used improperly:
146 
147     >>> s = 'bitcount(42)'
148     >>> sympify(s)
149     bitcount(42)
150     >>> sympify("O(x)")
151     O(x)
152     >>> sympify("O + 1")
153     Traceback (most recent call last):
154     ...
155     TypeError: unbound method...
156 
157     In order to have ``bitcount`` be recognized it can be imported into a
158     namespace dictionary and passed as locals:
159 
160     >>> from sympy.core.compatibility import exec_
161     >>> ns = {}
162     >>> exec_('from sympy.core.evalf import bitcount', ns)
163     >>> sympify(s, locals=ns)
164     6
165 
166     In order to have the ``O`` interpreted as a Symbol, identify it as such
167     in the namespace dictionary. This can be done in a variety of ways; all
168     three of the following are possibilities:
169 
170     >>> from sympy import Symbol
171     >>> ns["O"] = Symbol("O")  # method 1
172     >>> exec_('from sympy.abc import O', ns)  # method 2
173     >>> ns.update(dict(O=Symbol("O")))  # method 3
174     >>> sympify("O + 1", locals=ns)
175     O + 1
176 
177     If you want *all* single-letter and Greek-letter variables to be symbols
178     then you can use the clashing-symbols dictionaries that have been defined
179     there as private variables: _clash1 (single-letter variables), _clash2
180     (the multi-letter Greek names) or _clash (both single and multi-letter
181     names that are defined in abc).
182 
183     >>> from sympy.abc import _clash1
184     >>> _clash1
185     {'C': C, 'E': E, 'I': I, 'N': N, 'O': O, 'Q': Q, 'S': S}
186     >>> sympify('I & Q', _clash1)
187     I & Q
188 
189     Strict
190     ------
191 
192     If the option ``strict`` is set to ``True``, only the types for which an
193     explicit conversion has been defined are converted. In the other
194     cases, a SympifyError is raised.
195 
196     >>> print(sympify(None))
197     None
198     >>> sympify(None, strict=True)
199     Traceback (most recent call last):
200     ...
201     SympifyError: SympifyError: None
202 
203     Evaluation
204     ----------
205 
206     If the option ``evaluate`` is set to ``False``, then arithmetic and
207     operators will be converted into their SymPy equivalents and the
208     ``evaluate=False`` option will be added. Nested ``Add`` or ``Mul`` will
209     be denested first. This is done via an AST transformation that replaces
210     operators with their SymPy equivalents, so if an operand redefines any
211     of those operations, the redefined operators will not be used. If
212     argument a is not a string, the mathematical expression is evaluated
213     before being passed to sympify, so adding evaluate=False will still
214     return the evaluated result of expression.
215 
216     >>> sympify('2**2 / 3 + 5')
217     19/3
218     >>> sympify('2**2 / 3 + 5', evaluate=False)
219     2**2/3 + 5
220     >>> sympify('4/2+7', evaluate=True)
221     9
222     >>> sympify('4/2+7', evaluate=False)
223     4/2 + 7
224     >>> sympify(4/2+7, evaluate=False)
225     9.00000000000000
226 
227     Extending
228     ---------
229 
230     To extend ``sympify`` to convert custom objects (not derived from ``Basic``),
231     just define a ``_sympy_`` method to your class. You can do that even to
232     classes that you do not own by subclassing or adding the method at runtime.
233 
234     >>> from sympy import Matrix
235     >>> class MyList1(object):
236     ...     def __iter__(self):
237     ...         yield 1
238     ...         yield 2
239     ...         return
240     ...     def __getitem__(self, i): return list(self)[i]
241     ...     def _sympy_(self): return Matrix(self)
242     >>> sympify(MyList1())
243     Matrix([
244     [1],
245     [2]])
246 
247     If you do not have control over the class definition you could also use the
248     ``converter`` global dictionary. The key is the class and the value is a
249     function that takes a single argument and returns the desired SymPy
250     object, e.g. ``converter[MyList] = lambda x: Matrix(x)``.
251 
252     >>> class MyList2(object):   # XXX Do not do this if you control the class!
253     ...     def __iter__(self):  #     Use _sympy_!
254     ...         yield 1
255     ...         yield 2
256     ...         return
257     ...     def __getitem__(self, i): return list(self)[i]
258     >>> from sympy.core.sympify import converter
259     >>> converter[MyList2] = lambda x: Matrix(x)
260     >>> sympify(MyList2())
261     Matrix([
262     [1],
263     [2]])
264 
265     Notes
266     =====
267 
268     The keywords ``rational`` and ``convert_xor`` are only used
269     when the input is a string.
270 
271     convert_xor
272     -----------
273 
274     >>> sympify('x^y',convert_xor=True)
275     x**y
276     >>> sympify('x^y',convert_xor=False)
277     x ^ y
278 
279     rational
280     --------
281 
282     >>> sympify('0.1',rational=False)
283     0.1
284     >>> sympify('0.1',rational=True)
285     1/10
286 
287     Sometimes autosimplification during sympification results in expressions
288     that are very different in structure than what was entered. Until such
289     autosimplification is no longer done, the ``kernS`` function might be of
290     some use. In the example below you can see how an expression reduces to
291     -1 by autosimplification, but does not do so when ``kernS`` is used.
292 
293     >>> from sympy.core.sympify import kernS
294     >>> from sympy.abc import x
295     >>> -2*(-(-x + 1/x)/(x*(x - 1/x)**2) - 1/(x*(x - 1/x))) - 1
296     -1
297     >>> s = '-2*(-(-x + 1/x)/(x*(x - 1/x)**2) - 1/(x*(x - 1/x))) - 1'
298     >>> sympify(s)
299     -1
300     >>> kernS(s)
301     -2*(-(-x + 1/x)/(x*(x - 1/x)**2) - 1/(x*(x - 1/x))) - 1
302 
303     Parameters
304     ==========
305 
306     a :
307         - any object defined in SymPy
308         - standard numeric python types: int, long, float, Decimal
309         - strings (like "0.09", "2e-19" or 'sin(x)')
310         - booleans, including ``None`` (will leave ``None`` unchanged)
311         - dict, lists, sets or tuples containing any of the above
312 
313     convert_xor : boolean, optional
314         If true, treats XOR as exponentiation.
315         If False, treats XOR as XOR itself.
316         Used only when input is a string.
317 
318     locals : any object defined in SymPy, optional
319         In order to have strings be recognized it can be imported
320         into a namespace dictionary and passed as locals.
321 
322     strict : boolean, optional
323         If the option strict is set to True, only the types for which
324         an explicit conversion has been defined are converted. In the
325         other cases, a SympifyError is raised.
326 
327     rational : boolean, optional
328         If true, converts floats into Rational.
329         If false, it lets floats remain as it is.
330         Used only when input is a string.
331 
332     evaluate : boolean, optional
333         If False, then arithmetic and operators will be converted into
334         their SymPy equivalents. If True the expression will be evaluated
335         and the result will be returned.
336 
337     """
338     # XXX: If a is a Basic subclass rather than instance (e.g. sin rather than
339     # sin(x)) then a.__sympy__ will be the property. Only on the instance will
340     # a.__sympy__ give the *value* of the property (True). Since sympify(sin)
341     # was used for a long time we allow it to pass. However if strict=True as
342     # is the case in internal calls to _sympify then we only allow
343     # is_sympy=True.
344     #
345     # https://github.com/sympy/sympy/issues/20124
346     is_sympy = getattr(a, '__sympy__', None)
347     if is_sympy is True:
348         return a
349     elif is_sympy is not None:
350         if not strict:
351             return a
352         else:
353             raise SympifyError(a)
354 
355     if isinstance(a, CantSympify):
356         raise SympifyError(a)
357     cls = getattr(a, "__class__", None)
358     if cls is None:
359         cls = type(a)  # Probably an old-style class
360     conv = converter.get(cls, None)
361     if conv is not None:
362         return conv(a)
363 
364     for superclass in getmro(cls):
365         try:
366             return converter[superclass](a)
367         except KeyError:
368             continue
369 
370     if cls is type(None):
371         if strict:
372             raise SympifyError(a)
373         else:
374             return a
375 
376     if evaluate is None:
377         evaluate = global_parameters.evaluate
378 
379     # Support for basic numpy datatypes
380     if _is_numpy_instance(a):
381         import numpy as np
382         if np.isscalar(a):
383             return _convert_numpy_types(a, locals=locals,
384                 convert_xor=convert_xor, strict=strict, rational=rational,
385                 evaluate=evaluate)
386 
387     _sympy_ = getattr(a, "_sympy_", None)
388     if _sympy_ is not None:
389         try:
390             return a._sympy_()
391         # XXX: Catches AttributeError: 'SympyConverter' object has no
392         # attribute 'tuple'
393         # This is probably a bug somewhere but for now we catch it here.
394         except AttributeError:
395             pass
396 
397     if not strict:
398         # Put numpy array conversion _before_ float/int, see
399         # <https://github.com/sympy/sympy/issues/13924>.
400         flat = getattr(a, "flat", None)
401         if flat is not None:
402             shape = getattr(a, "shape", None)
403             if shape is not None:
404                 from ..tensor.array import Array
405                 return Array(a.flat, a.shape)  # works with e.g. NumPy arrays
406 
407     if not isinstance(a, str):
408         if _is_numpy_instance(a):
409             import numpy as np
410             assert not isinstance(a, np.number)
411             if isinstance(a, np.ndarray):
412                 # Scalar arrays (those with zero dimensions) have sympify
413                 # called on the scalar element.
414                 if a.ndim == 0:
415                     try:
416                         return sympify(a.item(),
417                                        locals=locals,
418                                        convert_xor=convert_xor,
419                                        strict=strict,
420                                        rational=rational,
421                                        evaluate=evaluate)
422                     except SympifyError:
423                         pass
424         else:
425             # float and int can coerce size-one numpy arrays to their lone
426             # element.  See issue https://github.com/numpy/numpy/issues/10404.
427             for coerce in (float, int):
428                 try:
429                     return sympify(coerce(a))
430                 except (TypeError, ValueError, AttributeError, SympifyError):
431                     continue
432 
433     if strict:
434         raise SympifyError(a)
435 
436     if iterable(a):
437         try:
438             return type(a)([sympify(x, locals=locals, convert_xor=convert_xor,
439                 rational=rational) for x in a])
440         except TypeError:
441             # Not all iterables are rebuildable with their type.
442             pass
443     if isinstance(a, dict):
444         try:
445             return type(a)([sympify(x, locals=locals, convert_xor=convert_xor,
446                 rational=rational) for x in a.items()])
447         except TypeError:
448             # Not all iterables are rebuildable with their type.
449             pass
450 
451     if not isinstance(a, str):
452         try:
453             a = str(a)
454         except Exception as exc:
455             raise SympifyError(a, exc)
456         from sympy.utilities.exceptions import SymPyDeprecationWarning
457         SymPyDeprecationWarning(
458             feature="String fallback in sympify",
459             useinstead= \
460                 'sympify(str(obj)) or ' + \
461                 'sympy.core.sympify.converter or obj._sympy_',
462             issue=18066,
463             deprecated_since_version='1.6'
464         ).warn()
465 
466     from sympy.parsing.sympy_parser import (parse_expr, TokenError,
467                                             standard_transformations)
468     from sympy.parsing.sympy_parser import convert_xor as t_convert_xor
469     from sympy.parsing.sympy_parser import rationalize as t_rationalize
470 
471     transformations = standard_transformations
472 
473     if rational:
474         transformations += (t_rationalize,)
475     if convert_xor:
476         transformations += (t_convert_xor,)
477 
478     try:
479         a = a.replace('\n', '')
480         expr = parse_expr(a, local_dict=locals, transformations=transformations, evaluate=evaluate)
481     except (TokenError, SyntaxError) as exc:
482         raise SympifyError('could not parse %r' % a, exc)
483 
484     return expr

</code><intended_behavior>The `sympify` method needs to ensure consistent handling of the `evaluate` parameter, especially in cases involving functions like `ceiling`. The intended behavior here would be to ensure that when `evaluate=False`, expressions like `4*ceiling(x/4 - 3/4)` are kept unevaluated in a consistent manner across versions. This could involve inspecting how the AST transformation is applied when `evaluate=False` and ensuring that the logic does not inadvertently simplify or alter the structure of expressions involving `ceiling`. Additionally, it would be crucial to preserve existing functionalities for all other expressions and use cases, ensuring that any adjustments made do not affect the broader utility of `sympify`.</intended_behavior>, <file>sympy/simplify/simplify.py</file>
<class>None</class>
<method>None</method>
<code>
1 from __future__ import print_function, division
2 
3 from collections import defaultdict
4 
5 from sympy.core import (Basic, S, Add, Mul, Pow, Symbol, sympify,
6                         expand_func, Function, Dummy, Expr, factor_terms,
7                         expand_power_exp, Eq)
8 from sympy.core.compatibility import iterable, ordered, as_int
9 from sympy.core.parameters import global_parameters
10 from sympy.core.function import (expand_log, count_ops, _mexpand, _coeff_isneg,
11     nfloat, expand_mul)
12 from sympy.core.numbers import Float, I, pi, Rational, Integer
13 from sympy.core.relational import Relational
14 from sympy.core.rules import Transform
15 from sympy.core.sympify import _sympify
16 from sympy.functions import gamma, exp, sqrt, log, exp_polar, re
17 from sympy.functions.combinatorial.factorials import CombinatorialFunction
18 from sympy.functions.elementary.complexes import unpolarify, Abs
19 from sympy.functions.elementary.exponential import ExpBase
20 from sympy.functions.elementary.hyperbolic import HyperbolicFunction
21 from sympy.functions.elementary.integers import ceiling
22 from sympy.functions.elementary.piecewise import Piecewise, piecewise_fold
23 from sympy.functions.elementary.trigonometric import TrigonometricFunction
24 from sympy.functions.special.bessel import besselj, besseli, besselk, jn, bessely
25 from sympy.functions.special.tensor_functions import KroneckerDelta
26 from sympy.polys import together, cancel, factor
27 from sympy.simplify.combsimp import combsimp
28 from sympy.simplify.cse_opts import sub_pre, sub_post
29 from sympy.simplify.powsimp import powsimp
30 from sympy.simplify.radsimp import radsimp, fraction, collect_abs
31 from sympy.simplify.sqrtdenest import sqrtdenest
32 from sympy.simplify.trigsimp import trigsimp, exptrigsimp
33 from sympy.utilities.iterables import has_variety, sift
34 
35 
36 import mpmath
37 
38 
39 
40 def separatevars(expr, symbols=[], dict=False, force=False):
41     """
42     Separates variables in an expression, if possible.  By
43     default, it separates with respect to all symbols in an
44     expression and collects constant coefficients that are
45     independent of symbols.
46 
47     Explanation
48     ===========
49 
50     If ``dict=True`` then the separated terms will be returned
51     in a dictionary keyed to their corresponding symbols.
52     By default, all symbols in the expression will appear as
53     keys; if symbols are provided, then all those symbols will
54     be used as keys, and any terms in the expression containing
55     other symbols or non-symbols will be returned keyed to the
56     string 'coeff'. (Passing None for symbols will return the
57     expression in a dictionary keyed to 'coeff'.)
58 
59     If ``force=True``, then bases of powers will be separated regardless
60     of assumptions on the symbols involved.
61 
62     Notes
63     =====
64 
65     The order of the factors is determined by Mul, so that the
66     separated expressions may not necessarily be grouped together.
67 
68     Although factoring is necessary to separate variables in some
69     expressions, it is not necessary in all cases, so one should not
70     count on the returned factors being factored.
71 
72     Examples
73     ========
74 
75     >>> from sympy.abc import x, y, z, alpha
76     >>> from sympy import separatevars, sin
77     >>> separatevars((x*y)**y)
78     (x*y)**y
79     >>> separatevars((x*y)**y, force=True)
80     x**y*y**y
81 
82     >>> e = 2*x**2*z*sin(y)+2*z*x**2
83     >>> separatevars(e)
84     2*x**2*z*(sin(y) + 1)
85     >>> separatevars(e, symbols=(x, y), dict=True)
86     {'coeff': 2*z, x: x**2, y: sin(y) + 1}
87     >>> separatevars(e, [x, y, alpha], dict=True)
88     {'coeff': 2*z, alpha: 1, x: x**2, y: sin(y) + 1}
89 
90     If the expression is not really separable, or is only partially
91     separable, separatevars will do the best it can to separate it
92     by using factoring.
93 
94     >>> separatevars(x + x*y - 3*x**2)
95     -x*(3*x - y - 1)
96 
97     If the expression is not separable then expr is returned unchanged
98     or (if dict=True) then None is returned.
99 
100     >>> eq = 2*x + y*sin(x)
101     >>> separatevars(eq) == eq
102     True
103     >>> separatevars(2*x + y*sin(x), symbols=(x, y), dict=True) is None
104     True
105 
106     """
107     expr = sympify(expr)
108     if dict:
109         return _separatevars_dict(_separatevars(expr, force), symbols)
110     else:
111         return _separatevars(expr, force)
112 
113 
114 def _separatevars(expr, force):
115     if isinstance(expr, Abs):
116         arg = expr.args[0]
117         if arg.is_Mul and not arg.is_number:
118             s = separatevars(arg, dict=True, force=force)
119             if s is not None:
120                 return Mul(*map(expr.func, s.values()))
121             else:
122                 return expr
123 
124     if len(expr.free_symbols) < 2:
125         return expr
126 
127     # don't destroy a Mul since much of the work may already be done
128     if expr.is_Mul:
129         args = list(expr.args)
130         changed = False
131         for i, a in enumerate(args):
132             args[i] = separatevars(a, force)
133             changed = changed or args[i] != a
134         if changed:
135             expr = expr.func(*args)
136         return expr
137 
138     # get a Pow ready for expansion
139     if expr.is_Pow:
140         expr = Pow(separatevars(expr.base, force=force), expr.exp)
141 
142     # First try other expansion methods
143     expr = expr.expand(mul=False, multinomial=False, force=force)
144 
145     _expr, reps = posify(expr) if force else (expr, {})
146     expr = factor(_expr).subs(reps)
147 
148     if not expr.is_Add:
149         return expr
150 
151     # Find any common coefficients to pull out
152     args = list(expr.args)
153     commonc = args[0].args_cnc(cset=True, warn=False)[0]
154     for i in args[1:]:
155         commonc &= i.args_cnc(cset=True, warn=False)[0]
156     commonc = Mul(*commonc)
157     commonc = commonc.as_coeff_Mul()[1]  # ignore constants
158     commonc_set = commonc.args_cnc(cset=True, warn=False)[0]
159 
160     # remove them
161     for i, a in enumerate(args):
162         c, nc = a.args_cnc(cset=True, warn=False)
163         c = c - commonc_set
164         args[i] = Mul(*c)*Mul(*nc)
165     nonsepar = Add(*args)
166 
167     if len(nonsepar.free_symbols) > 1:
168         _expr = nonsepar
169         _expr, reps = posify(_expr) if force else (_expr, {})
170         _expr = (factor(_expr)).subs(reps)
171 
172         if not _expr.is_Add:
173             nonsepar = _expr
174 
175     return commonc*nonsepar
176 
177 
178 def _separatevars_dict(expr, symbols):
179     if symbols:
180         if not all((t.is_Atom for t in symbols)):
181             raise ValueError("symbols must be Atoms.")
182         symbols = list(symbols)
183     elif symbols is None:
184         return {'coeff': expr}
185     else:
186         symbols = list(expr.free_symbols)
187         if not symbols:
188             return None
189 
190     ret = dict(((i, []) for i in symbols + ['coeff']))
191 
192     for i in Mul.make_args(expr):
193         expsym = i.free_symbols
194         intersection = set(symbols).intersection(expsym)
195         if len(intersection) > 1:
196             return None
197         if len(intersection) == 0:
198             # There are no symbols, so it is part of the coefficient
199             ret['coeff'].append(i)
200         else:
201             ret[intersection.pop()].append(i)
202 
203     # rebuild
204     for k, v in ret.items():
205         ret[k] = Mul(*v)
206 
207     return ret
208 
209 
210 def _is_sum_surds(p):
211     args = p.args if p.is_Add else [p]
212     for y in args:
213         if not ((y**2).is_Rational and y.is_extended_real):
214             return False
215     return True
216 
217 
218 def posify(eq):
219     """Return ``eq`` (with generic symbols made positive) and a
220     dictionary containing the mapping between the old and new
221     symbols.
222 
223     Explanation
224     ===========
225 
226     Any symbol that has positive=None will be replaced with a positive dummy
227     symbol having the same name. This replacement will allow more symbolic
228     processing of expressions, especially those involving powers and
229     logarithms.
230 
231     A dictionary that can be sent to subs to restore ``eq`` to its original
232     symbols is also returned.
233 
234     >>> from sympy import posify, Symbol, log, solve
235     >>> from sympy.abc import x
236     >>> posify(x + Symbol('p', positive=True) + Symbol('n', negative=True))
237     (_x + n + p, {_x: x})
238 
239     >>> eq = 1/x
240     >>> log(eq).expand()
241     log(1/x)
242     >>> log(posify(eq)[0]).expand()
243     -log(_x)
244     >>> p, rep = posify(eq)
245     >>> log(p).expand().subs(rep)
246     -log(x)
247 
248     It is possible to apply the same transformations to an iterable
249     of expressions:
250 
251     >>> eq = x**2 - 4
252     >>> solve(eq, x)
253     [-2, 2]
254     >>> eq_x, reps = posify([eq, x]); eq_x
255     [_x**2 - 4, _x]
256     >>> solve(*eq_x)
257     [2]
258     """
259     eq = sympify(eq)
260     if iterable(eq):
261         f = type(eq)
262         eq = list(eq)
263         syms = set()
264         for e in eq:
265             syms = syms.union(e.atoms(Symbol))
266         reps = {}
267         for s in syms:
268             reps.update(dict((v, k) for k, v in posify(s)[1].items()))
269         for i, e in enumerate(eq):
270             eq[i] = e.subs(reps)
271         return f(eq), {r: s for s, r in reps.items()}
272 
273     reps = {s: Dummy(s.name, positive=True, **s.assumptions0)
274                  for s in eq.free_symbols if s.is_positive is None}
275     eq = eq.subs(reps)
276     return eq, {r: s for s, r in reps.items()}
277 
278 
279 def hypersimp(f, k):
280     """Given combinatorial term f(k) simplify its consecutive term ratio
281        i.e. f(k+1)/f(k).  The input term can be composed of functions and
282        integer sequences which have equivalent representation in terms
283        of gamma special function.
284 
285        Explanation
286        ===========
287 
288        The algorithm performs three basic steps:
289 
290        1. Rewrite all functions in terms of gamma, if possible.
291 
292        2. Rewrite all occurrences of gamma in terms of products
293           of gamma and rising factorial with integer,  absolute
294           constant exponent.
295 
296        3. Perform simplification of nested fractions, powers
297           and if the resulting expression is a quotient of
298           polynomials, reduce their total degree.
299 
300        If f(k) is hypergeometric then as result we arrive with a
301        quotient of polynomials of minimal degree. Otherwise None
302        is returned.
303 
304        For more information on the implemented algorithm refer to:
305 
306        1. W. Koepf, Algorithms for m-fold Hypergeometric Summation,
307           Journal of Symbolic Computation (1995) 20, 399-417
308     """
309     f = sympify(f)
310 
311     g = f.subs(k, k + 1) / f
312 
313     g = g.rewrite(gamma)
314     if g.has(Piecewise):
315         g = piecewise_fold(g)
316         g = g.args[-1][0]
317     g = expand_func(g)
318     g = powsimp(g, deep=True, combine='exp')
319 
320     if g.is_rational_function(k):
321         return simplify(g, ratio=S.Infinity)
322     else:
323         return None
324 
325 
326 def hypersimilar(f, g, k):
327     """
328     Returns True if ``f`` and ``g`` are hyper-similar.
329 
330     Explanation
331     ===========
332 
333     Similarity in hypergeometric sense means that a quotient of
334     f(k) and g(k) is a rational function in ``k``. This procedure
335     is useful in solving recurrence relations.
336 
337     For more information see hypersimp().
338 
339     """
340     f, g = list(map(sympify, (f, g)))
341 
342     h = (f/g).rewrite(gamma)
343     h = h.expand(func=True, basic=False)
344 
345     return h.is_rational_function(k)
346 
347 
348 def signsimp(expr, evaluate=None):
349     """Make all Add sub-expressions canonical wrt sign.
350 
351     Explanation
352     ===========
353 
354     If an Add subexpression, ``a``, can have a sign extracted,
355     as determined by could_extract_minus_sign, it is replaced
356     with Mul(-1, a, evaluate=False). This allows signs to be
357     extracted from powers and products.
358 
359     Examples
360     ========
361 
362     >>> from sympy import signsimp, exp, symbols
363     >>> from sympy.abc import x, y
364     >>> i = symbols('i', odd=True)
365     >>> n = -1 + 1/x
366     >>> n/x/(-n)**2 - 1/n/x
367     (-1 + 1/x)/(x*(1 - 1/x)**2) - 1/(x*(-1 + 1/x))
368     >>> signsimp(_)
369     0
370     >>> x*n + x*-n
371     x*(-1 + 1/x) + x*(1 - 1/x)
372     >>> signsimp(_)
373     0
374 
375     Since powers automatically handle leading signs
376 
377     >>> (-2)**i
378     -2**i
379 
380     signsimp can be used to put the base of a power with an integer
381     exponent into canonical form:
382 
383     >>> n**i
384     (-1 + 1/x)**i
385 
386     By default, signsimp doesn't leave behind any hollow simplification:
387     if making an Add canonical wrt sign didn't change the expression, the
388     original Add is restored. If this is not desired then the keyword
389     ``evaluate`` can be set to False:
390 
391     >>> e = exp(y - x)
392     >>> signsimp(e) == e
393     True
394     >>> signsimp(e, evaluate=False)
395     exp(-(x - y))
396 
397     """
398     if evaluate is None:
399         evaluate = global_parameters.evaluate
400     expr = sympify(expr)
401     if not isinstance(expr, (Expr, Relational)) or expr.is_Atom:
402         return expr
403     e = sub_post(sub_pre(expr))
404     if not isinstance(e, (Expr, Relational)) or e.is_Atom:
405         return e
406     if e.is_Add:
407         return e.func(*[signsimp(a, evaluate) for a in e.args])
408     if evaluate:
409         e = e.xreplace({m: -(-m) for m in e.atoms(Mul) if -(-m) != m})
410     return e
411 
412 
413 def simplify(expr, ratio=1.7, measure=count_ops, rational=False, inverse=False, doit=True, **kwargs):
414     """Simplifies the given expression.
415 
416     Explanation
417     ===========
418 
419     Simplification is not a well defined term and the exact strategies
420     this function tries can change in the future versions of SymPy. If
421     your algorithm relies on "simplification" (whatever it is), try to
422     determine what you need exactly  -  is it powsimp()?, radsimp()?,
423     together()?, logcombine()?, or something else? And use this particular
424     function directly, because those are well defined and thus your algorithm
425     will be robust.
426 
427     Nonetheless, especially for interactive use, or when you don't know
428     anything about the structure of the expression, simplify() tries to apply
429     intelligent heuristics to make the input expression "simpler".  For
430     example:
431 
432     >>> from sympy import simplify, cos, sin
433     >>> from sympy.abc import x, y
434     >>> a = (x + x**2)/(x*sin(y)**2 + x*cos(y)**2)
435     >>> a
436     (x**2 + x)/(x*sin(y)**2 + x*cos(y)**2)
437     >>> simplify(a)
438     x + 1
439 
440     Note that we could have obtained the same result by using specific
441     simplification functions:
442 
443     >>> from sympy import trigsimp, cancel
444     >>> trigsimp(a)
445     (x**2 + x)/x
446     >>> cancel(_)
447     x + 1
448 
449     In some cases, applying :func:`simplify` may actually result in some more
450     complicated expression. The default ``ratio=1.7`` prevents more extreme
451     cases: if (result length)/(input length) > ratio, then input is returned
452     unmodified.  The ``measure`` parameter lets you specify the function used
453     to determine how complex an expression is.  The function should take a
454     single argument as an expression and return a number such that if
455     expression ``a`` is more complex than expression ``b``, then
456     ``measure(a) > measure(b)``.  The default measure function is
457     :func:`~.count_ops`, which returns the total number of operations in the
458     expression.
459 
460     For example, if ``ratio=1``, ``simplify`` output can't be longer
461     than input.
462 
463     ::
464 
465         >>> from sympy import sqrt, simplify, count_ops, oo
466         >>> root = 1/(sqrt(2)+3)
467 
468     Since ``simplify(root)`` would result in a slightly longer expression,
469     root is returned unchanged instead::
470 
471        >>> simplify(root, ratio=1) == root
472        True
473 
474     If ``ratio=oo``, simplify will be applied anyway::
475 
476         >>> count_ops(simplify(root, ratio=oo)) > count_ops(root)
477         True
478 
479     Note that the shortest expression is not necessary the simplest, so
480     setting ``ratio`` to 1 may not be a good idea.
481     Heuristically, the default value ``ratio=1.7`` seems like a reasonable
482     choice.
483 
484     You can easily define your own measure function based on what you feel
485     should represent the "size" or "complexity" of the input expression.  Note
486     that some choices, such as ``lambda expr: len(str(expr))`` may appear to be
487     good metrics, but have other problems (in this case, the measure function
488     may slow down simplify too much for very large expressions).  If you don't
489     know what a good metric would be, the default, ``count_ops``, is a good
490     one.
491 
492     For example:
493 
494     >>> from sympy import symbols, log
495     >>> a, b = symbols('a b', positive=True)
496     >>> g = log(a) + log(b) + log(a)*log(1/b)
497     >>> h = simplify(g)
498     >>> h
499     log(a*b**(1 - log(a)))
500     >>> count_ops(g)
501     8
502     >>> count_ops(h)
503     5
504 
505     So you can see that ``h`` is simpler than ``g`` using the count_ops metric.
506     However, we may not like how ``simplify`` (in this case, using
507     ``logcombine``) has created the ``b**(log(1/a) + 1)`` term.  A simple way
508     to reduce this would be to give more weight to powers as operations in
509     ``count_ops``.  We can do this by using the ``visual=True`` option:
510 
511     >>> print(count_ops(g, visual=True))
512     2*ADD + DIV + 4*LOG + MUL
513     >>> print(count_ops(h, visual=True))
514     2*LOG + MUL + POW + SUB
515 
516     >>> from sympy import Symbol, S
517     >>> def my_measure(expr):
518     ...     POW = Symbol('POW')
519     ...     # Discourage powers by giving POW a weight of 10
520     ...     count = count_ops(expr, visual=True).subs(POW, 10)
521     ...     # Every other operation gets a weight of 1 (the default)
522     ...     count = count.replace(Symbol, type(S.One))
523     ...     return count
524     >>> my_measure(g)
525     8
526     >>> my_measure(h)
527     14
528     >>> 15./8 > 1.7 # 1.7 is the default ratio
529     True
530     >>> simplify(g, measure=my_measure)
531     -log(a)*log(b) + log(a) + log(b)
532 
533     Note that because ``simplify()`` internally tries many different
534     simplification strategies and then compares them using the measure
535     function, we get a completely different result that is still different
536     from the input expression by doing this.
537 
538     If ``rational=True``, Floats will be recast as Rationals before simplification.
539     If ``rational=None``, Floats will be recast as Rationals but the result will
540     be recast as Floats. If rational=False(default) then nothing will be done
541     to the Floats.
542 
543     If ``inverse=True``, it will be assumed that a composition of inverse
544     functions, such as sin and asin, can be cancelled in any order.
545     For example, ``asin(sin(x))`` will yield ``x`` without checking whether
546     x belongs to the set where this relation is true. The default is
547     False.
548 
549     Note that ``simplify()`` automatically calls ``doit()`` on the final
550     expression. You can avoid this behavior by passing ``doit=False`` as
551     an argument.
552     """
553 
554     def shorter(*choices):
555         """
556         Return the choice that has the fewest ops. In case of a tie,
557         the expression listed first is selected.
558         """
559         if not has_variety(choices):
560             return choices[0]
561         return min(choices, key=measure)
562 
563     def done(e):
564         rv = e.doit() if doit else e
565         return shorter(rv, collect_abs(rv))
566 
567     expr = sympify(expr)
568     kwargs = dict(
569         ratio=kwargs.get('ratio', ratio),
570         measure=kwargs.get('measure', measure),
571         rational=kwargs.get('rational', rational),
572         inverse=kwargs.get('inverse', inverse),
573         doit=kwargs.get('doit', doit))
574     # no routine for Expr needs to check for is_zero
575     if isinstance(expr, Expr) and expr.is_zero:
576         return S.Zero
577 
578     _eval_simplify = getattr(expr, '_eval_simplify', None)
579     if _eval_simplify is not None:
580         return _eval_simplify(**kwargs)
581 
582     original_expr = expr = collect_abs(signsimp(expr))
583 
584     if not isinstance(expr, Basic) or not expr.args:  # XXX: temporary hack
585         return expr
586 
587     if inverse and expr.has(Function):
588         expr = inversecombine(expr)
589         if not expr.args:  # simplified to atomic
590             return expr
591 
592     # do deep simplification
593     handled = Add, Mul, Pow, ExpBase
594     expr = expr.replace(
595         # here, checking for x.args is not enough because Basic has
596         # args but Basic does not always play well with replace, e.g.
597         # when simultaneous is True found expressions will be masked
598         # off with a Dummy but not all Basic objects in an expression
599         # can be replaced with a Dummy
600         lambda x: isinstance(x, Expr) and x.args and not isinstance(
601             x, handled),
602         lambda x: x.func(*[simplify(i, **kwargs) for i in x.args]),
603         simultaneous=False)
604     if not isinstance(expr, handled):
605         return done(expr)
606 
607     if not expr.is_commutative:
608         expr = nc_simplify(expr)
609 
610     # TODO: Apply different strategies, considering expression pattern:
611     # is it a purely rational function? Is there any trigonometric function?...
612     # See also https://github.com/sympy/sympy/pull/185.
613 
614 
615     # rationalize Floats
616     floats = False
617     if rational is not False and expr.has(Float):
618         floats = True
619         expr = nsimplify(expr, rational=True)
620 
621     expr = bottom_up(expr, lambda w: getattr(w, 'normal', lambda: w)())
622     expr = Mul(*powsimp(expr).as_content_primitive())
623     _e = cancel(expr)
624     expr1 = shorter(_e, _mexpand(_e).cancel())  # issue 6829
625     expr2 = shorter(together(expr, deep=True), together(expr1, deep=True))
626 
627     if ratio is S.Infinity:
628         expr = expr2
629     else:
630         expr = shorter(expr2, expr1, expr)
631     if not isinstance(expr, Basic):  # XXX: temporary hack
632         return expr
633 
634     expr = factor_terms(expr, sign=False)
635 
636     from sympy.simplify.hyperexpand import hyperexpand
637     from sympy.functions.special.bessel import BesselBase
638     from sympy import Sum, Product, Integral
639     from sympy.functions.elementary.complexes import sign
640 
641     # must come before `Piecewise` since this introduces more `Piecewise` terms
642     if expr.has(sign):
643         expr = expr.rewrite(Abs)
644 
645     # Deal with Piecewise separately to avoid recursive growth of expressions
646     if expr.has(Piecewise):
647         # Fold into a single Piecewise
648         expr = piecewise_fold(expr)
649         # Apply doit, if doit=True
650         expr = done(expr)
651         # Still a Piecewise?
652         if expr.has(Piecewise):
653             # Fold into a single Piecewise, in case doit lead to some
654             # expressions being Piecewise
655             expr = piecewise_fold(expr)
656             # kroneckersimp also affects Piecewise
657             if expr.has(KroneckerDelta):
658                 expr = kroneckersimp(expr)
659             # Still a Piecewise?
660             if expr.has(Piecewise):
661                 from sympy.functions.elementary.piecewise import piecewise_simplify
662                 # Do not apply doit on the segments as it has already
663                 # been done above, but simplify
664                 expr = piecewise_simplify(expr, deep=True, doit=False)
665                 # Still a Piecewise?
666                 if expr.has(Piecewise):
667                     # Try factor common terms
668                     expr = shorter(expr, factor_terms(expr))
669                     # As all expressions have been simplified above with the
670                     # complete simplify, nothing more needs to be done here
671                     return expr
672 
673     # hyperexpand automatically only works on hypergeometric terms
674     # Do this after the Piecewise part to avoid recursive expansion
675     expr = hyperexpand(expr)
676 
677     if expr.has(KroneckerDelta):
678         expr = kroneckersimp(expr)
679 
680     if expr.has(BesselBase):
681         expr = besselsimp(expr)
682 
683     if expr.has(TrigonometricFunction, HyperbolicFunction):
684         expr = trigsimp(expr, deep=True)
685 
686     if expr.has(log):
687         expr = shorter(expand_log(expr, deep=True), logcombine(expr))
688 
689     if expr.has(CombinatorialFunction, gamma):
690         # expression with gamma functions or non-integer arguments is
691         # automatically passed to gammasimp
692         expr = combsimp(expr)
693 
694     if expr.has(Sum):
695         expr = sum_simplify(expr, **kwargs)
696 
697     if expr.has(Integral):
698         expr = expr.xreplace(dict([
699             (i, factor_terms(i)) for i in expr.atoms(Integral)]))
700 
701     if expr.has(Product):
702         expr = product_simplify(expr)
703 
704     from sympy.physics.units import Quantity
705     from sympy.physics.units.util import quantity_simplify
706 
707     if expr.has(Quantity):
708         expr = quantity_simplify(expr)
709 
710     short = shorter(powsimp(expr, combine='exp', deep=True), powsimp(expr), expr)
711     short = shorter(short, cancel(short))
712     short = shorter(short, factor_terms(short), expand_power_exp(expand_mul(short)))
713     if short.has(TrigonometricFunction, HyperbolicFunction, ExpBase):
714         short = exptrigsimp(short)
715 
716     # get rid of hollow 2-arg Mul factorization
717     hollow_mul = Transform(
718         lambda x: Mul(*x.args),
719         lambda x:
720         x.is_Mul and
721         len(x.args) == 2 and
722         x.args[0].is_Number and
723         x.args[1].is_Add and
724         x.is_commutative)
725     expr = short.xreplace(hollow_mul)
726 
727     numer, denom = expr.as_numer_denom()
728     if denom.is_Add:
729         n, d = fraction(radsimp(1/denom, symbolic=False, max_terms=1))
730         if n is not S.One:
731             expr = (numer*n).expand()/d
732 
733     if expr.could_extract_minus_sign():
734         n, d = fraction(expr)
735         if d != 0:
736             expr = signsimp(-n/(-d))
737 
738     if measure(expr) > ratio*measure(original_expr):
739         expr = original_expr
740 
741     # restore floats
742     if floats and rational is None:
743         expr = nfloat(expr, exponent=False)
744 
745     return done(expr)
746 
747 
748 def sum_simplify(s, **kwargs):
749     """Main function for Sum simplification"""
750     from sympy.concrete.summations import Sum
751     from sympy.core.function import expand
752 
753     if not isinstance(s, Add):
754         s = s.xreplace(dict([(a, sum_simplify(a, **kwargs))
755             for a in s.atoms(Add) if a.has(Sum)]))
756     s = expand(s)
757     if not isinstance(s, Add):
758         return s
759 
760     terms = s.args
761     s_t = [] # Sum Terms
762     o_t = [] # Other Terms
763 
764     for term in terms:
765         sum_terms, other = sift(Mul.make_args(term),
766             lambda i: isinstance(i, Sum), binary=True)
767         if not sum_terms:
768             o_t.append(term)
769             continue
770         other = [Mul(*other)]
771         s_t.append(Mul(*(other + [s._eval_simplify(**kwargs) for s in sum_terms])))
772 
773     result = Add(sum_combine(s_t), *o_t)
774 
775     return result
776 
777 
778 def sum_combine(s_t):
779     """Helper function for Sum simplification
780 
781        Attempts to simplify a list of sums, by combining limits / sum function's
782        returns the simplified sum
783     """
784     from sympy.concrete.summations import Sum
785 
786     used = [False] * len(s_t)
787 
788     for method in range(2):
789         for i, s_term1 in enumerate(s_t):
790             if not used[i]:
791                 for j, s_term2 in enumerate(s_t):
792                     if not used[j] and i != j:
793                         temp = sum_add(s_term1, s_term2, method)
794                         if isinstance(temp, Sum) or isinstance(temp, Mul):
795                             s_t[i] = temp
796                             s_term1 = s_t[i]
797                             used[j] = True
798 
799     result = S.Zero
800     for i, s_term in enumerate(s_t):
801         if not used[i]:
802             result = Add(result, s_term)
803 
804     return result
805 
806 
807 def factor_sum(self, limits=None, radical=False, clear=False, fraction=False, sign=True):
808     """Return Sum with constant factors extracted.
809 
810     If ``limits`` is specified then ``self`` is the summand; the other
811     keywords are passed to ``factor_terms``.
812 
813     Examples
814     ========
815 
816     >>> from sympy import Sum
817     >>> from sympy.abc import x, y
818     >>> from sympy.simplify.simplify import factor_sum
819     >>> s = Sum(x*y, (x, 1, 3))
820     >>> factor_sum(s)
821     y*Sum(x, (x, 1, 3))
822     >>> factor_sum(s.function, s.limits)
823     y*Sum(x, (x, 1, 3))
824     """
825     # XXX deprecate in favor of direct call to factor_terms
826     from sympy.concrete.summations import Sum
827     kwargs = dict(radical=radical, clear=clear,
828         fraction=fraction, sign=sign)
829     expr = Sum(self, *limits) if limits else self
830     return factor_terms(expr, **kwargs)
831 
832 
833 def sum_add(self, other, method=0):
834     """Helper function for Sum simplification"""
835     from sympy.concrete.summations import Sum
836     from sympy import Mul
837 
838     #we know this is something in terms of a constant * a sum
839     #so we temporarily put the constants inside for simplification
840     #then simplify the result
841     def __refactor(val):
842         args = Mul.make_args(val)
843         sumv = next(x for x in args if isinstance(x, Sum))
844         constant = Mul(*[x for x in args if x != sumv])
845         return Sum(constant * sumv.function, *sumv.limits)
846 
847     if isinstance(self, Mul):
848         rself = __refactor(self)
849     else:
850         rself = self
851 
852     if isinstance(other, Mul):
853         rother = __refactor(other)
854     else:
855         rother = other
856 
857     if type(rself) == type(rother):
858         if method == 0:
859             if rself.limits == rother.limits:
860                 return factor_sum(Sum(rself.function + rother.function, *rself.limits))
861         elif method == 1:
862             if simplify(rself.function - rother.function) == 0:
863                 if len(rself.limits) == len(rother.limits) == 1:
864                     i = rself.limits[0][0]
865                     x1 = rself.limits[0][1]
866                     y1 = rself.limits[0][2]
867                     j = rother.limits[0][0]
868                     x2 = rother.limits[0][1]
869                     y2 = rother.limits[0][2]
870 
871                     if i == j:
872                         if x2 == y1 + 1:
873                             return factor_sum(Sum(rself.function, (i, x1, y2)))
874                         elif x1 == y2 + 1:
875                             return factor_sum(Sum(rself.function, (i, x2, y1)))
876 
877     return Add(self, other)
878 
879 
880 def product_simplify(s):
881     """Main function for Product simplification"""
882     from sympy.concrete.products import Product
883 
884     terms = Mul.make_args(s)
885     p_t = [] # Product Terms
886     o_t = [] # Other Terms
887 
888     for term in terms:
889         if isinstance(term, Product):
890             p_t.append(term)
891         else:
892             o_t.append(term)
893 
894     used = [False] * len(p_t)
895 
896     for method in range(2):
897         for i, p_term1 in enumerate(p_t):
898             if not used[i]:
899                 for j, p_term2 in enumerate(p_t):
900                     if not used[j] and i != j:
901                         if isinstance(product_mul(p_term1, p_term2, method), Product):
902                             p_t[i] = product_mul(p_term1, p_term2, method)
903                             used[j] = True
904 
905     result = Mul(*o_t)
906 
907     for i, p_term in enumerate(p_t):
908         if not used[i]:
909             result = Mul(result, p_term)
910 
911     return result
912 
913 
914 def product_mul(self, other, method=0):
915     """Helper function for Product simplification"""
916     from sympy.concrete.products import Product
917 
918     if type(self) == type(other):
919         if method == 0:
920             if self.limits == other.limits:
921                 return Product(self.function * other.function, *self.limits)
922         elif method == 1:
923             if simplify(self.function - other.function) == 0:
924                 if len(self.limits) == len(other.limits) == 1:
925                     i = self.limits[0][0]
926                     x1 = self.limits[0][1]
927                     y1 = self.limits[0][2]
928                     j = other.limits[0][0]
929                     x2 = other.limits[0][1]
930                     y2 = other.limits[0][2]
931 
932                     if i == j:
933                         if x2 == y1 + 1:
934                             return Product(self.function, (i, x1, y2))
935                         elif x1 == y2 + 1:
936                             return Product(self.function, (i, x2, y1))
937 
938     return Mul(self, other)
939 
940 
941 def _nthroot_solve(p, n, prec):
942     """
943      helper function for ``nthroot``
944      It denests ``p**Rational(1, n)`` using its minimal polynomial
945     """
946     from sympy.polys.numberfields import _minimal_polynomial_sq
947     from sympy.solvers import solve
948     while n % 2 == 0:
949         p = sqrtdenest(sqrt(p))
950         n = n // 2
951     if n == 1:
952         return p
953     pn = p**Rational(1, n)
954     x = Symbol('x')
955     f = _minimal_polynomial_sq(p, n, x)
956     if f is None:
957         return None
958     sols = solve(f, x)
959     for sol in sols:
960         if abs(sol - pn).n() < 1./10**prec:
961             sol = sqrtdenest(sol)
962             if _mexpand(sol**n) == p:
963                 return sol
964 
965 
966 def logcombine(expr, force=False):
967     """
968     Takes logarithms and combines them using the following rules:
969 
970     - log(x) + log(y) == log(x*y) if both are positive
971     - a*log(x) == log(x**a) if x is positive and a is real
972 
973     If ``force`` is ``True`` then the assumptions above will be assumed to hold if
974     there is no assumption already in place on a quantity. For example, if
975     ``a`` is imaginary or the argument negative, force will not perform a
976     combination but if ``a`` is a symbol with no assumptions the change will
977     take place.
978 
979     Examples
980     ========
981 
982     >>> from sympy import Symbol, symbols, log, logcombine, I
983     >>> from sympy.abc import a, x, y, z
984     >>> logcombine(a*log(x) + log(y) - log(z))
985     a*log(x) + log(y) - log(z)
986     >>> logcombine(a*log(x) + log(y) - log(z), force=True)
987     log(x**a*y/z)
988     >>> x,y,z = symbols('x,y,z', positive=True)
989     >>> a = Symbol('a', real=True)
990     >>> logcombine(a*log(x) + log(y) - log(z))
991     log(x**a*y/z)
992 
993     The transformation is limited to factors and/or terms that
994     contain logs, so the result depends on the initial state of
995     expansion:
996 
997     >>> eq = (2 + 3*I)*log(x)
998     >>> logcombine(eq, force=True) == eq
999     True
1000     >>> logcombine(eq.expand(), force=True)
1001     log(x**2) + I*log(x**3)
1002 
1003     See Also
1004     ========
1005 
1006     posify: replace all symbols with symbols having positive assumptions
1007     sympy.core.function.expand_log: expand the logarithms of products
1008         and powers; the opposite of logcombine
1009 
1010     """
1011 
1012     def f(rv):
1013         if not (rv.is_Add or rv.is_Mul):
1014             return rv
1015 
1016         def gooda(a):
1017             # bool to tell whether the leading ``a`` in ``a*log(x)``
1018             # could appear as log(x**a)
1019             return (a is not S.NegativeOne and  # -1 *could* go, but we disallow
1020                 (a.is_extended_real or force and a.is_extended_real is not False))
1021 
1022         def goodlog(l):
1023             # bool to tell whether log ``l``'s argument can combine with others
1024             a = l.args[0]
1025             return a.is_positive or force and a.is_nonpositive is not False
1026 
1027         other = []
1028         logs = []
1029         log1 = defaultdict(list)
1030         for a in Add.make_args(rv):
1031             if isinstance(a, log) and goodlog(a):
1032                 log1[()].append(([], a))
1033             elif not a.is_Mul:
1034                 other.append(a)
1035             else:
1036                 ot = []
1037                 co = []
1038                 lo = []
1039                 for ai in a.args:
1040                     if ai.is_Rational and ai < 0:
1041                         ot.append(S.NegativeOne)
1042                         co.append(-ai)
1043                     elif isinstance(ai, log) and goodlog(ai):
1044                         lo.append(ai)
1045                     elif gooda(ai):
1046                         co.append(ai)
1047                     else:
1048                         ot.append(ai)
1049                 if len(lo) > 1:
1050                     logs.append((ot, co, lo))
1051                 elif lo:
1052                     log1[tuple(ot)].append((co, lo[0]))
1053                 else:
1054                     other.append(a)
1055 
1056         # if there is only one log in other, put it with the
1057         # good logs
1058         if len(other) == 1 and isinstance(other[0], log):
1059             log1[()].append(([], other.pop()))
1060         # if there is only one log at each coefficient and none have
1061         # an exponent to place inside the log then there is nothing to do
1062         if not logs and all(len(log1[k]) == 1 and log1[k][0] == [] for k in log1):
1063             return rv
1064 
1065         # collapse multi-logs as far as possible in a canonical way
1066         # TODO: see if x*log(a)+x*log(a)*log(b) -> x*log(a)*(1+log(b))?
1067         # -- in this case, it's unambiguous, but if it were were a log(c) in
1068         # each term then it's arbitrary whether they are grouped by log(a) or
1069         # by log(c). So for now, just leave this alone; it's probably better to
1070         # let the user decide
1071         for o, e, l in logs:
1072             l = list(ordered(l))
1073             e = log(l.pop(0).args[0]**Mul(*e))
1074             while l:
1075                 li = l.pop(0)
1076                 e = log(li.args[0]**e)
1077             c, l = Mul(*o), e
1078             if isinstance(l, log):  # it should be, but check to be sure
1079                 log1[(c,)].append(([], l))
1080             else:
1081                 other.append(c*l)
1082 
1083         # logs that have the same coefficient can multiply
1084         for k in list(log1.keys()):
1085             log1[Mul(*k)] = log(logcombine(Mul(*[
1086                 l.args[0]**Mul(*c) for c, l in log1.pop(k)]),
1087                 force=force), evaluate=False)
1088 
1089         # logs that have oppositely signed coefficients can divide
1090         for k in ordered(list(log1.keys())):
1091             if not k in log1:  # already popped as -k
1092                 continue
1093             if -k in log1:
1094                 # figure out which has the minus sign; the one with
1095                 # more op counts should be the one
1096                 num, den = k, -k
1097                 if num.count_ops() > den.count_ops():
1098                     num, den = den, num
1099                 other.append(
1100                     num*log(log1.pop(num).args[0]/log1.pop(den).args[0],
1101                             evaluate=False))
1102             else:
1103                 other.append(k*log1.pop(k))
1104 
1105         return Add(*other)
1106 
1107     return bottom_up(expr, f)
1108 
1109 
1110 def inversecombine(expr):
1111     """Simplify the composition of a function and its inverse.
1112 
1113     Explanation
1114     ===========
1115 
1116     No attention is paid to whether the inverse is a left inverse or a
1117     right inverse; thus, the result will in general not be equivalent
1118     to the original expression.
1119 
1120     Examples
1121     ========
1122 
1123     >>> from sympy.simplify.simplify import inversecombine
1124     >>> from sympy import asin, sin, log, exp
1125     >>> from sympy.abc import x
1126     >>> inversecombine(asin(sin(x)))
1127     x
1128     >>> inversecombine(2*log(exp(3*x)))
1129     6*x
1130     """
1131 
1132     def f(rv):
1133         if rv.is_Function and hasattr(rv, "inverse"):
1134             if (len(rv.args) == 1 and len(rv.args[0].args) == 1 and
1135                 isinstance(rv.args[0], rv.inverse(argindex=1))):
1136                     rv = rv.args[0].args[0]
1137         return rv
1138 
1139     return bottom_up(expr, f)
1140 
1141 
1142 def walk(e, *target):
1143     """Iterate through the args that are the given types (target) and
1144     return a list of the args that were traversed; arguments
1145     that are not of the specified types are not traversed.
1146 
1147     Examples
1148     ========
1149 
1150     >>> from sympy.simplify.simplify import walk
1151     >>> from sympy import Min, Max
1152     >>> from sympy.abc import x, y, z
1153     >>> list(walk(Min(x, Max(y, Min(1, z))), Min))
1154     [Min(x, Max(y, Min(1, z)))]
1155     >>> list(walk(Min(x, Max(y, Min(1, z))), Min, Max))
1156     [Min(x, Max(y, Min(1, z))), Max(y, Min(1, z)), Min(1, z)]
1157 
1158     See Also
1159     ========
1160 
1161     bottom_up
1162     """
1163     if isinstance(e, target):
1164         yield e
1165         for i in e.args:
1166             for w in walk(i, *target):
1167                 yield w
1168 
1169 
1170 def bottom_up(rv, F, atoms=False, nonbasic=False):
1171     """Apply ``F`` to all expressions in an expression tree from the
1172     bottom up. If ``atoms`` is True, apply ``F`` even if there are no args;
1173     if ``nonbasic`` is True, try to apply ``F`` to non-Basic objects.
1174     """
1175     args = getattr(rv, 'args', None)
1176     if args is not None:
1177         if args:
1178             args = tuple([bottom_up(a, F, atoms, nonbasic) for a in args])
1179             if args != rv.args:
1180                 rv = rv.func(*args)
1181             rv = F(rv)
1182         elif atoms:
1183             rv = F(rv)
1184     else:
1185         if nonbasic:
1186             try:
1187                 rv = F(rv)
1188             except TypeError:
1189                 pass
1190 
1191     return rv
1192 
1193 
1194 def kroneckersimp(expr):
1195     """
1196     Simplify expressions with KroneckerDelta.
1197 
1198     The only simplification currently attempted is to identify multiplicative cancellation:
1199 
1200     Examples
1201     ========
1202 
1203     >>> from sympy import KroneckerDelta, kroneckersimp
1204     >>> from sympy.abc import i
1205     >>> kroneckersimp(1 + KroneckerDelta(0, i) * KroneckerDelta(1, i))
1206     1
1207     """
1208     def args_cancel(args1, args2):
1209         for i1 in range(2):
1210             for i2 in range(2):
1211                 a1 = args1[i1]
1212                 a2 = args2[i2]
1213                 a3 = args1[(i1 + 1) % 2]
1214                 a4 = args2[(i2 + 1) % 2]
1215                 if Eq(a1, a2) is S.true and Eq(a3, a4) is S.false:
1216                     return True
1217         return False
1218 
1219     def cancel_kronecker_mul(m):
1220         from sympy.utilities.iterables import subsets
1221 
1222         args = m.args
1223         deltas = [a for a in args if isinstance(a, KroneckerDelta)]
1224         for delta1, delta2 in subsets(deltas, 2):
1225             args1 = delta1.args
1226             args2 = delta2.args
1227             if args_cancel(args1, args2):
1228                 return 0*m
1229         return m
1230 
1231     if not expr.has(KroneckerDelta):
1232         return expr
1233 
1234     if expr.has(Piecewise):
1235         expr = expr.rewrite(KroneckerDelta)
1236 
1237     newexpr = expr
1238     expr = None
1239 
1240     while newexpr != expr:
1241         expr = newexpr
1242         newexpr = expr.replace(lambda e: isinstance(e, Mul), cancel_kronecker_mul)
1243 
1244     return expr
1245 
1246 
1247 def besselsimp(expr):
1248     """
1249     Simplify bessel-type functions.
1250 
1251     Explanation
1252     ===========
1253 
1254     This routine tries to simplify bessel-type functions. Currently it only
1255     works on the Bessel J and I functions, however. It works by looking at all
1256     such functions in turn, and eliminating factors of "I" and "-1" (actually
1257     their polar equivalents) in front of the argument. Then, functions of
1258     half-integer order are rewritten using strigonometric functions and
1259     functions of integer order (> 1) are rewritten using functions
1260     of low order.  Finally, if the expression was changed, compute
1261     factorization of the result with factor().
1262 
1263     >>> from sympy import besselj, besseli, besselsimp, polar_lift, I, S
1264     >>> from sympy.abc import z, nu
1265     >>> besselsimp(besselj(nu, z*polar_lift(-1)))
1266     exp(I*pi*nu)*besselj(nu, z)
1267     >>> besselsimp(besseli(nu, z*polar_lift(-I)))
1268     exp(-I*pi*nu/2)*besselj(nu, z)
1269     >>> besselsimp(besseli(S(-1)/2, z))
1270     sqrt(2)*cosh(z)/(sqrt(pi)*sqrt(z))
1271     >>> besselsimp(z*besseli(0, z) + z*(besseli(2, z))/2 + besseli(1, z))
1272     3*z*besseli(0, z)/2
1273     """
1274     # TODO
1275     # - better algorithm?
1276     # - simplify (cos(pi*b)*besselj(b,z) - besselj(-b,z))/sin(pi*b) ...
1277     # - use contiguity relations?
1278 
1279     def replacer(fro, to, factors):
1280         factors = set(factors)
1281 
1282         def repl(nu, z):
1283             if factors.intersection(Mul.make_args(z)):
1284                 return to(nu, z)
1285             return fro(nu, z)
1286         return repl
1287 
1288     def torewrite(fro, to):
1289         def tofunc(nu, z):
1290             return fro(nu, z).rewrite(to)
1291         return tofunc
1292 
1293     def tominus(fro):
1294         def tofunc(nu, z):
1295             return exp(I*pi*nu)*fro(nu, exp_polar(-I*pi)*z)
1296         return tofunc
1297 
1298     orig_expr = expr
1299 
1300     ifactors = [I, exp_polar(I*pi/2), exp_polar(-I*pi/2)]
1301     expr = expr.replace(
1302         besselj, replacer(besselj,
1303         torewrite(besselj, besseli), ifactors))
1304     expr = expr.replace(
1305         besseli, replacer(besseli,
1306         torewrite(besseli, besselj), ifactors))
1307 
1308     minusfactors = [-1, exp_polar(I*pi)]
1309     expr = expr.replace(
1310         besselj, replacer(besselj, tominus(besselj), minusfactors))
1311     expr = expr.replace(
1312         besseli, replacer(besseli, tominus(besseli), minusfactors))
1313 
1314     z0 = Dummy('z')
1315 
1316     def expander(fro):
1317         def repl(nu, z):
1318             if (nu % 1) == S.Half:
1319                 return simplify(trigsimp(unpolarify(
1320                         fro(nu, z0).rewrite(besselj).rewrite(jn).expand(
1321                             func=True)).subs(z0, z)))
1322             elif nu.is_Integer and nu > 1:
1323                 return fro(nu, z).expand(func=True)
1324             return fro(nu, z)
1325         return repl
1326 
1327     expr = expr.replace(besselj, expander(besselj))
1328     expr = expr.replace(bessely, expander(bessely))
1329     expr = expr.replace(besseli, expander(besseli))
1330     expr = expr.replace(besselk, expander(besselk))
1331 
1332     def _bessel_simp_recursion(expr):
1333 
1334         def _use_recursion(bessel, expr):
1335             while True:
1336                 bessels = expr.find(lambda x: isinstance(x, bessel))
1337                 try:
1338                     for ba in sorted(bessels, key=lambda x: re(x.args[0])):
1339                         a, x = ba.args
1340                         bap1 = bessel(a+1, x)
1341                         bap2 = bessel(a+2, x)
1342                         if expr.has(bap1) and expr.has(bap2):
1343                             expr = expr.subs(ba, 2*(a+1)/x*bap1 - bap2)
1344                             break
1345                     else:
1346                         return expr
1347                 except (ValueError, TypeError):
1348                     return expr
1349         if expr.has(besselj):
1350             expr = _use_recursion(besselj, expr)
1351         if expr.has(bessely):
1352             expr = _use_recursion(bessely, expr)
1353         return expr
1354 
1355     expr = _bessel_simp_recursion(expr)
1356     if expr != orig_expr:
1357         expr = expr.factor()
1358 
1359     return expr
1360 
1361 
1362 def nthroot(expr, n, max_len=4, prec=15):
1363     """
1364     Compute a real nth-root of a sum of surds.
1365 
1366     Parameters
1367     ==========
1368 
1369     expr : sum of surds
1370     n : integer
1371     max_len : maximum number of surds passed as constants to ``nsimplify``
1372 
1373     Algorithm
1374     =========
1375 
1376     First ``nsimplify`` is used to get a candidate root; if it is not a
1377     root the minimal polynomial is computed; the answer is one of its
1378     roots.
1379 
1380     Examples
1381     ========
1382 
1383     >>> from sympy.simplify.simplify import nthroot
1384     >>> from sympy import sqrt
1385     >>> nthroot(90 + 34*sqrt(7), 3)
1386     sqrt(7) + 3
1387 
1388     """
1389     expr = sympify(expr)
1390     n = sympify(n)
1391     p = expr**Rational(1, n)
1392     if not n.is_integer:
1393         return p
1394     if not _is_sum_surds(expr):
1395         return p
1396     surds = []
1397     coeff_muls = [x.as_coeff_Mul() for x in expr.args]
1398     for x, y in coeff_muls:
1399         if not x.is_rational:
1400             return p
1401         if y is S.One:
1402             continue
1403         if not (y.is_Pow and y.exp == S.Half and y.base.is_integer):
1404             return p
1405         surds.append(y)
1406     surds.sort()
1407     surds = surds[:max_len]
1408     if expr < 0 and n % 2 == 1:
1409         p = (-expr)**Rational(1, n)
1410         a = nsimplify(p, constants=surds)
1411         res = a if _mexpand(a**n) == _mexpand(-expr) else p
1412         return -res
1413     a = nsimplify(p, constants=surds)
1414     if _mexpand(a) is not _mexpand(p) and _mexpand(a**n) == _mexpand(expr):
1415         return _mexpand(a)
1416     expr = _nthroot_solve(expr, n, prec)
1417     if expr is None:
1418         return p
1419     return expr
1420 
1421 
1422 def nsimplify(expr, constants=(), tolerance=None, full=False, rational=None,
1423     rational_conversion='base10'):
1424     """
1425     Find a simple representation for a number or, if there are free symbols or
1426     if ``rational=True``, then replace Floats with their Rational equivalents. If
1427     no change is made and rational is not False then Floats will at least be
1428     converted to Rationals.
1429 
1430     Explanation
1431     ===========
1432 
1433     For numerical expressions, a simple formula that numerically matches the
1434     given numerical expression is sought (and the input should be possible
1435     to evalf to a precision of at least 30 digits).
1436 
1437     Optionally, a list of (rationally independent) constants to
1438     include in the formula may be given.
1439 
1440     A lower tolerance may be set to find less exact matches. If no tolerance
1441     is given then the least precise value will set the tolerance (e.g. Floats
1442     default to 15 digits of precision, so would be tolerance=10**-15).
1443 
1444     With ``full=True``, a more extensive search is performed
1445     (this is useful to find simpler numbers when the tolerance
1446     is set low).
1447 
1448     When converting to rational, if rational_conversion='base10' (the default), then
1449     convert floats to rationals using their base-10 (string) representation.
1450     When rational_conversion='exact' it uses the exact, base-2 representation.
1451 
1452     Examples
1453     ========
1454 
1455     >>> from sympy import nsimplify, sqrt, GoldenRatio, exp, I, pi
1456     >>> nsimplify(4/(1+sqrt(5)), [GoldenRatio])
1457     -2 + 2*GoldenRatio
1458     >>> nsimplify((1/(exp(3*pi*I/5)+1)))
1459     1/2 - I*sqrt(sqrt(5)/10 + 1/4)
1460     >>> nsimplify(I**I, [pi])
1461     exp(-pi/2)
1462     >>> nsimplify(pi, tolerance=0.01)
1463     22/7
1464 
1465     >>> nsimplify(0.333333333333333, rational=True, rational_conversion='exact')
1466     6004799503160655/18014398509481984
1467     >>> nsimplify(0.333333333333333, rational=True)
1468     1/3
1469 
1470     See Also
1471     ========
1472 
1473     sympy.core.function.nfloat
1474 
1475     """
1476     try:
1477         return sympify(as_int(expr))
1478     except (TypeError, ValueError):
1479         pass
1480     expr = sympify(expr).xreplace({
1481         Float('inf'): S.Infinity,
1482         Float('-inf'): S.NegativeInfinity,
1483         })
1484     if expr is S.Infinity or expr is S.NegativeInfinity:
1485         return expr
1486     if rational or expr.free_symbols:
1487         return _real_to_rational(expr, tolerance, rational_conversion)
1488 
1489     # SymPy's default tolerance for Rationals is 15; other numbers may have
1490     # lower tolerances set, so use them to pick the largest tolerance if None
1491     # was given
1492     if tolerance is None:
1493         tolerance = 10**-min([15] +
1494              [mpmath.libmp.libmpf.prec_to_dps(n._prec)
1495              for n in expr.atoms(Float)])
1496     # XXX should prec be set independent of tolerance or should it be computed
1497     # from tolerance?
1498     prec = 30
1499     bprec = int(prec*3.33)
1500 
1501     constants_dict = {}
1502     for constant in constants:
1503         constant = sympify(constant)
1504         v = constant.evalf(prec)
1505         if not v.is_Float:
1506             raise ValueError("constants must be real-valued")
1507         constants_dict[str(constant)] = v._to_mpmath(bprec)
1508 
1509     exprval = expr.evalf(prec, chop=True)
1510     re, im = exprval.as_real_imag()
1511 
1512     # safety check to make sure that this evaluated to a number
1513     if not (re.is_Number and im.is_Number):
1514         return expr
1515 
1516     def nsimplify_real(x):
1517         orig = mpmath.mp.dps
1518         xv = x._to_mpmath(bprec)
1519         try:
1520             # We'll be happy with low precision if a simple fraction
1521             if not (tolerance or full):
1522                 mpmath.mp.dps = 15
1523                 rat = mpmath.pslq([xv, 1])
1524                 if rat is not None:
1525                     return Rational(-int(rat[1]), int(rat[0]))
1526             mpmath.mp.dps = prec
1527             newexpr = mpmath.identify(xv, constants=constants_dict,
1528                 tol=tolerance, full=full)
1529             if not newexpr:
1530                 raise ValueError
1531             if full:
1532                 newexpr = newexpr[0]
1533             expr = sympify(newexpr)
1534             if x and not expr:  # don't let x become 0
1535                 raise ValueError
1536             if expr.is_finite is False and not xv in [mpmath.inf, mpmath.ninf]:
1537                 raise ValueError
1538             return expr
1539         finally:
1540             # even though there are returns above, this is executed
1541             # before leaving
1542             mpmath.mp.dps = orig
1543     try:
1544         if re:
1545             re = nsimplify_real(re)
1546         if im:
1547             im = nsimplify_real(im)
1548     except ValueError:
1549         if rational is None:
1550             return _real_to_rational(expr, rational_conversion=rational_conversion)
1551         return expr
1552 
1553     rv = re + im*S.ImaginaryUnit
1554     # if there was a change or rational is explicitly not wanted
1555     # return the value, else return the Rational representation
1556     if rv != expr or rational is False:
1557         return rv
1558     return _real_to_rational(expr, rational_conversion=rational_conversion)
1559 
1560 
1561 def _real_to_rational(expr, tolerance=None, rational_conversion='base10'):
1562     """
1563     Replace all reals in expr with rationals.
1564 
1565     Examples
1566     ========
1567 
1568     >>> from sympy.simplify.simplify import _real_to_rational
1569     >>> from sympy.abc import x
1570 
1571     >>> _real_to_rational(.76 + .1*x**.5)
1572     sqrt(x)/10 + 19/25
1573 
1574     If rational_conversion='base10', this uses the base-10 string. If
1575     rational_conversion='exact', the exact, base-2 representation is used.
1576 
1577     >>> _real_to_rational(0.333333333333333, rational_conversion='exact')
1578     6004799503160655/18014398509481984
1579     >>> _real_to_rational(0.333333333333333)
1580     1/3
1581 
1582     """
1583     expr = _sympify(expr)
1584     inf = Float('inf')
1585     p = expr
1586     reps = {}
1587     reduce_num = None
1588     if tolerance is not None and tolerance < 1:
1589         reduce_num = ceiling(1/tolerance)
1590     for fl in p.atoms(Float):
1591         key = fl
1592         if reduce_num is not None:
1593             r = Rational(fl).limit_denominator(reduce_num)
1594         elif (tolerance is not None and tolerance >= 1 and
1595                 fl.is_Integer is False):
1596             r = Rational(tolerance*round(fl/tolerance)
1597                 ).limit_denominator(int(tolerance))
1598         else:
1599             if rational_conversion == 'exact':
1600                 r = Rational(fl)
1601                 reps[key] = r
1602                 continue
1603             elif rational_conversion != 'base10':
1604                 raise ValueError("rational_conversion must be 'base10' or 'exact'")
1605 
1606             r = nsimplify(fl, rational=False)
1607             # e.g. log(3).n() -> log(3) instead of a Rational
1608             if fl and not r:
1609                 r = Rational(fl)
1610             elif not r.is_Rational:
1611                 if fl == inf or fl == -inf:
1612                     r = S.ComplexInfinity
1613                 elif fl < 0:
1614                     fl = -fl
1615                     d = Pow(10, int((mpmath.log(fl)/mpmath.log(10))))
1616                     r = -Rational(str(fl/d))*d
1617                 elif fl > 0:
1618                     d = Pow(10, int((mpmath.log(fl)/mpmath.log(10))))
1619                     r = Rational(str(fl/d))*d
1620                 else:
1621                     r = Integer(0)
1622         reps[key] = r
1623     return p.subs(reps, simultaneous=True)
1624 
1625 
1626 def clear_coefficients(expr, rhs=S.Zero):
1627     """Return `p, r` where `p` is the expression obtained when Rational
1628     additive and multiplicative coefficients of `expr` have been stripped
1629     away in a naive fashion (i.e. without simplification). The operations
1630     needed to remove the coefficients will be applied to `rhs` and returned
1631     as `r`.
1632 
1633     Examples
1634     ========
1635 
1636     >>> from sympy.simplify.simplify import clear_coefficients
1637     >>> from sympy.abc import x, y
1638     >>> from sympy import Dummy
1639     >>> expr = 4*y*(6*x + 3)
1640     >>> clear_coefficients(expr - 2)
1641     (y*(2*x + 1), 1/6)
1642 
1643     When solving 2 or more expressions like `expr = a`,
1644     `expr = b`, etc..., it is advantageous to provide a Dummy symbol
1645     for `rhs` and  simply replace it with `a`, `b`, etc... in `r`.
1646 
1647     >>> rhs = Dummy('rhs')
1648     >>> clear_coefficients(expr, rhs)
1649     (y*(2*x + 1), _rhs/12)
1650     >>> _[1].subs(rhs, 2)
1651     1/6
1652     """
1653     was = None
1654     free = expr.free_symbols
1655     if expr.is_Rational:
1656         return (S.Zero, rhs - expr)
1657     while expr and was != expr:
1658         was = expr
1659         m, expr = (
1660             expr.as_content_primitive()
1661             if free else
1662             factor_terms(expr).as_coeff_Mul(rational=True))
1663         rhs /= m
1664         c, expr = expr.as_coeff_Add(rational=True)
1665         rhs -= c
1666     expr = signsimp(expr, evaluate = False)
1667     if _coeff_isneg(expr):
1668         expr = -expr
1669         rhs = -rhs
1670     return expr, rhs
1671 
1672 def nc_simplify(expr, deep=True):
1673     '''
1674     Simplify a non-commutative expression composed of multiplication
1675     and raising to a power by grouping repeated subterms into one power.
1676     Priority is given to simplifications that give the fewest number
1677     of arguments in the end (for example, in a*b*a*b*c*a*b*c simplifying
1678     to (a*b)**2*c*a*b*c gives 5 arguments while a*b*(a*b*c)**2 has 3).
1679     If ``expr`` is a sum of such terms, the sum of the simplified terms
1680     is returned.
1681 
1682     Keyword argument ``deep`` controls whether or not subexpressions
1683     nested deeper inside the main expression are simplified. See examples
1684     below. Setting `deep` to `False` can save time on nested expressions
1685     that don't need simplifying on all levels.
1686 
1687     Examples
1688     ========
1689 
1690     >>> from sympy import symbols
1691     >>> from sympy.simplify.simplify import nc_simplify
1692     >>> a, b, c = symbols("a b c", commutative=False)
1693     >>> nc_simplify(a*b*a*b*c*a*b*c)
1694     a*b*(a*b*c)**2
1695     >>> expr = a**2*b*a**4*b*a**4
1696     >>> nc_simplify(expr)
1697     a**2*(b*a**4)**2
1698     >>> nc_simplify(a*b*a*b*c**2*(a*b)**2*c**2)
1699     ((a*b)**2*c**2)**2
1700     >>> nc_simplify(a*b*a*b + 2*a*c*a**2*c*a**2*c*a)
1701     (a*b)**2 + 2*(a*c*a)**3
1702     >>> nc_simplify(b**-1*a**-1*(a*b)**2)
1703     a*b
1704     >>> nc_simplify(a**-1*b**-1*c*a)
1705     (b*a)**(-1)*c*a
1706     >>> expr = (a*b*a*b)**2*a*c*a*c
1707     >>> nc_simplify(expr)
1708     (a*b)**4*(a*c)**2
1709     >>> nc_simplify(expr, deep=False)
1710     (a*b*a*b)**2*(a*c)**2
1711 
1712     '''
1713     from sympy.matrices.expressions import (MatrixExpr, MatAdd, MatMul,
1714                                                 MatPow, MatrixSymbol)
1715     from sympy.core.exprtools import factor_nc
1716 
1717     if isinstance(expr, MatrixExpr):
1718         expr = expr.doit(inv_expand=False)
1719         _Add, _Mul, _Pow, _Symbol = MatAdd, MatMul, MatPow, MatrixSymbol
1720     else:
1721         _Add, _Mul, _Pow, _Symbol = Add, Mul, Pow, Symbol
1722 
1723     # =========== Auxiliary functions ========================
1724     def _overlaps(args):
1725         # Calculate a list of lists m such that m[i][j] contains the lengths
1726         # of all possible overlaps between args[:i+1] and args[i+1+j:].
1727         # An overlap is a suffix of the prefix that matches a prefix
1728         # of the suffix.
1729         # For example, let expr=c*a*b*a*b*a*b*a*b. Then m[3][0] contains
1730         # the lengths of overlaps of c*a*b*a*b with a*b*a*b. The overlaps
1731         # are a*b*a*b, a*b and the empty word so that m[3][0]=[4,2,0].
1732         # All overlaps rather than only the longest one are recorded
1733         # because this information helps calculate other overlap lengths.
1734         m = [[([1, 0] if a == args[0] else [0]) for a in args[1:]]]
1735         for i in range(1, len(args)):
1736             overlaps = []
1737             j = 0
1738             for j in range(len(args) - i - 1):
1739                 overlap = []
1740                 for v in m[i-1][j+1]:
1741                     if j + i + 1 + v < len(args) and args[i] == args[j+i+1+v]:
1742                         overlap.append(v + 1)
1743                 overlap += [0]
1744                 overlaps.append(overlap)
1745             m.append(overlaps)
1746         return m
1747 
1748     def _reduce_inverses(_args):
1749         # replace consecutive negative powers by an inverse
1750         # of a product of positive powers, e.g. a**-1*b**-1*c
1751         # will simplify to (a*b)**-1*c;
1752         # return that new args list and the number of negative
1753         # powers in it (inv_tot)
1754         inv_tot = 0 # total number of inverses
1755         inverses = []
1756         args = []
1757         for arg in _args:
1758             if isinstance(arg, _Pow) and arg.args[1] < 0:
1759                 inverses = [arg**-1] + inverses
1760                 inv_tot += 1
1761             else:
1762                 if len(inverses) == 1:
1763                     args.append(inverses[0]**-1)
1764                 elif len(inverses) > 1:
1765                     args.append(_Pow(_Mul(*inverses), -1))
1766                     inv_tot -= len(inverses) - 1
1767                 inverses = []
1768                 args.append(arg)
1769         if inverses:
1770             args.append(_Pow(_Mul(*inverses), -1))
1771             inv_tot -= len(inverses) - 1
1772         return inv_tot, tuple(args)
1773 
1774     def get_score(s):
1775         # compute the number of arguments of s
1776         # (including in nested expressions) overall
1777         # but ignore exponents
1778         if isinstance(s, _Pow):
1779             return get_score(s.args[0])
1780         elif isinstance(s, (_Add, _Mul)):
1781             return sum([get_score(a) for a in s.args])
1782         return 1
1783 
1784     def compare(s, alt_s):
1785         # compare two possible simplifications and return a
1786         # "better" one
1787         if s != alt_s and get_score(alt_s) < get_score(s):
1788             return alt_s
1789         return s
1790     # ========================================================
1791 
1792     if not isinstance(expr, (_Add, _Mul, _Pow)) or expr.is_commutative:
1793         return expr
1794     args = expr.args[:]
1795     if isinstance(expr, _Pow):
1796         if deep:
1797             return _Pow(nc_simplify(args[0]), args[1]).doit()
1798         else:
1799             return expr
1800     elif isinstance(expr, _Add):
1801         return _Add(*[nc_simplify(a, deep=deep) for a in args]).doit()
1802     else:
1803         # get the non-commutative part
1804         c_args, args = expr.args_cnc()
1805         com_coeff = Mul(*c_args)
1806         if com_coeff != 1:
1807             return com_coeff*nc_simplify(expr/com_coeff, deep=deep)
1808 
1809     inv_tot, args = _reduce_inverses(args)
1810     # if most arguments are negative, work with the inverse
1811     # of the expression, e.g. a**-1*b*a**-1*c**-1 will become
1812     # (c*a*b**-1*a)**-1 at the end so can work with c*a*b**-1*a
1813     invert = False
1814     if inv_tot > len(args)/2:
1815         invert = True
1816         args = [a**-1 for a in args[::-1]]
1817 
1818     if deep:
1819         args = tuple(nc_simplify(a) for a in args)
1820 
1821     m = _overlaps(args)
1822 
1823     # simps will be {subterm: end} where `end` is the ending
1824     # index of a sequence of repetitions of subterm;
1825     # this is for not wasting time with subterms that are part
1826     # of longer, already considered sequences
1827     simps = {}
1828 
1829     post = 1
1830     pre = 1
1831 
1832     # the simplification coefficient is the number of
1833     # arguments by which contracting a given sequence
1834     # would reduce the word; e.g. in a*b*a*b*c*a*b*c,
1835     # contracting a*b*a*b to (a*b)**2 removes 3 arguments
1836     # while a*b*c*a*b*c to (a*b*c)**2 removes 6. It's
1837     # better to contract the latter so simplification
1838     # with a maximum simplification coefficient will be chosen
1839     max_simp_coeff = 0
1840     simp = None # information about future simplification
1841 
1842     for i in range(1, len(args)):
1843         simp_coeff = 0
1844         l = 0 # length of a subterm
1845         p = 0 # the power of a subterm
1846         if i < len(args) - 1:
1847             rep = m[i][0]
1848         start = i # starting index of the repeated sequence
1849         end = i+1 # ending index of the repeated sequence
1850         if i == len(args)-1 or rep == [0]:
1851             # no subterm is repeated at this stage, at least as
1852             # far as the arguments are concerned - there may be
1853             # a repetition if powers are taken into account
1854             if (isinstance(args[i], _Pow) and
1855                             not isinstance(args[i].args[0], _Symbol)):
1856                 subterm = args[i].args[0].args
1857                 l = len(subterm)
1858                 if args[i-l:i] == subterm:
1859                     # e.g. a*b in a*b*(a*b)**2 is not repeated
1860                     # in args (= [a, b, (a*b)**2]) but it
1861                     # can be matched here
1862                     p += 1
1863                     start -= l
1864                 if args[i+1:i+1+l] == subterm:
1865                     # e.g. a*b in (a*b)**2*a*b
1866                     p += 1
1867                     end += l
1868             if p:
1869                 p += args[i].args[1]
1870             else:
1871                 continue
1872         else:
1873             l = rep[0] # length of the longest repeated subterm at this point
1874             start -= l - 1
1875             subterm = args[start:end]
1876             p = 2
1877             end += l
1878 
1879         if subterm in simps and simps[subterm] >= start:
1880             # the subterm is part of a sequence that
1881             # has already been considered
1882             continue
1883 
1884         # count how many times it's repeated
1885         while end < len(args):
1886             if l in m[end-1][0]:
1887                 p += 1
1888                 end += l
1889             elif isinstance(args[end], _Pow) and args[end].args[0].args == subterm:
1890                 # for cases like a*b*a*b*(a*b)**2*a*b
1891                 p += args[end].args[1]
1892                 end += 1
1893             else:
1894                 break
1895 
1896         # see if another match can be made, e.g.
1897         # for b*a**2 in b*a**2*b*a**3 or a*b in
1898         # a**2*b*a*b
1899 
1900         pre_exp = 0
1901         pre_arg = 1
1902         if start - l >= 0 and args[start-l+1:start] == subterm[1:]:
1903             if isinstance(subterm[0], _Pow):
1904                 pre_arg = subterm[0].args[0]
1905                 exp = subterm[0].args[1]
1906             else:
1907                 pre_arg = subterm[0]
1908                 exp = 1
1909             if isinstance(args[start-l], _Pow) and args[start-l].args[0] == pre_arg:
1910                 pre_exp = args[start-l].args[1] - exp
1911                 start -= l
1912                 p += 1
1913             elif args[start-l] == pre_arg:
1914                 pre_exp = 1 - exp
1915                 start -= l
1916                 p += 1
1917 
1918         post_exp = 0
1919         post_arg = 1
1920         if end + l - 1 < len(args) and args[end:end+l-1] == subterm[:-1]:
1921             if isinstance(subterm[-1], _Pow):
1922                 post_arg = subterm[-1].args[0]
1923                 exp = subterm[-1].args[1]
1924             else:
1925                 post_arg = subterm[-1]
1926                 exp = 1
1927             if isinstance(args[end+l-1], _Pow) and args[end+l-1].args[0] == post_arg:
1928                 post_exp = args[end+l-1].args[1] - exp
1929                 end += l
1930                 p += 1
1931             elif args[end+l-1] == post_arg:
1932                 post_exp = 1 - exp
1933                 end += l
1934                 p += 1
1935 
1936         # Consider a*b*a**2*b*a**2*b*a:
1937         # b*a**2 is explicitly repeated, but note
1938         # that in this case a*b*a is also repeated
1939         # so there are two possible simplifications:
1940         # a*(b*a**2)**3*a**-1 or (a*b*a)**3
1941         # The latter is obviously simpler.
1942         # But in a*b*a**2*b**2*a**2 the simplifications are
1943         # a*(b*a**2)**2 and (a*b*a)**3*a in which case
1944         # it's better to stick with the shorter subterm
1945         if post_exp and exp % 2 == 0 and start > 0:
1946             exp = exp/2
1947             _pre_exp = 1
1948             _post_exp = 1
1949             if isinstance(args[start-1], _Pow) and args[start-1].args[0] == post_arg:
1950                 _post_exp = post_exp + exp
1951                 _pre_exp = args[start-1].args[1] - exp
1952             elif args[start-1] == post_arg:
1953                 _post_exp = post_exp + exp
1954                 _pre_exp = 1 - exp
1955             if _pre_exp == 0 or _post_exp == 0:
1956                 if not pre_exp:
1957                     start -= 1
1958                 post_exp = _post_exp
1959                 pre_exp = _pre_exp
1960                 pre_arg = post_arg
1961                 subterm = (post_arg**exp,) + subterm[:-1] + (post_arg**exp,)
1962 
1963         simp_coeff += end-start
1964 
1965         if post_exp:
1966             simp_coeff -= 1
1967         if pre_exp:
1968             simp_coeff -= 1
1969 
1970         simps[subterm] = end
1971 
1972         if simp_coeff > max_simp_coeff:
1973             max_simp_coeff = simp_coeff
1974             simp = (start, _Mul(*subterm), p, end, l)
1975             pre = pre_arg**pre_exp
1976             post = post_arg**post_exp
1977 
1978     if simp:
1979         subterm = _Pow(nc_simplify(simp[1], deep=deep), simp[2])
1980         pre = nc_simplify(_Mul(*args[:simp[0]])*pre, deep=deep)
1981         post = post*nc_simplify(_Mul(*args[simp[3]:]), deep=deep)
1982         simp = pre*subterm*post
1983         if pre != 1 or post != 1:
1984             # new simplifications may be possible but no need
1985             # to recurse over arguments
1986             simp = nc_simplify(simp, deep=False)
1987     else:
1988         simp = _Mul(*args)
1989 
1990     if invert:
1991         simp = _Pow(simp, -1)
1992 
1993     # see if factor_nc(expr) is simplified better
1994     if not isinstance(expr, MatrixExpr):
1995         f_expr = factor_nc(expr)
1996         if f_expr != expr:
1997             alt_simp = nc_simplify(f_expr, deep=deep)
1998             simp = compare(simp, alt_simp)
1999     else:
2000         simp = simp.doit(inv_expand=False)
2001     return simp
2002 
2003 
2004 def dotprodsimp(expr, withsimp=False):
2005     """Simplification for a sum of products targeted at the kind of blowup that
2006     occurs during summation of products. Intended to reduce expression blowup
2007     during matrix multiplication or other similar operations. Only works with
2008     algebraic expressions and does not recurse into non.
2009 
2010     Parameters
2011     ==========
2012 
2013     withsimp : bool, optional
2014         Specifies whether a flag should be returned along with the expression
2015         to indicate roughly whether simplification was successful. It is used
2016         in ``MatrixArithmetic._eval_pow_by_recursion`` to avoid attempting to
2017         simplify an expression repetitively which does not simplify.
2018     """
2019 
2020     def count_ops_alg(expr):
2021         """Optimized count algebraic operations with no recursion into
2022         non-algebraic args that ``core.function.count_ops`` does. Also returns
2023         whether rational functions may be present according to negative
2024         exponents of powers or non-number fractions.
2025 
2026         Returns
2027         =======
2028 
2029         ops, ratfunc : int, bool
2030             ``ops`` is the number of algebraic operations starting at the top
2031             level expression (not recursing into non-alg children). ``ratfunc``
2032             specifies whether the expression MAY contain rational functions
2033             which ``cancel`` MIGHT optimize.
2034         """
2035 
2036         ops     = 0
2037         args    = [expr]
2038         ratfunc = False
2039 
2040         while args:
2041             a = args.pop()
2042 
2043             if not isinstance(a, Basic):
2044                 continue
2045 
2046             if a.is_Rational:
2047                 if a is not S.One: # -1/3 = NEG + DIV
2048                     ops += bool (a.p < 0) + bool (a.q != 1)
2049 
2050             elif a.is_Mul:
2051                 if _coeff_isneg(a):
2052                     ops += 1
2053                     if a.args[0] is S.NegativeOne:
2054                         a = a.as_two_terms()[1]
2055                     else:
2056                         a = -a
2057 
2058                 n, d = fraction(a)
2059 
2060                 if n.is_Integer:
2061                     ops += 1 + bool (n < 0)
2062                     args.append(d) # won't be -Mul but could be Add
2063 
2064                 elif d is not S.One:
2065                     if not d.is_Integer:
2066                         args.append(d)
2067                         ratfunc=True
2068 
2069                     ops += 1
2070                     args.append(n) # could be -Mul
2071 
2072                 else:
2073                     ops += len(a.args) - 1
2074                     args.extend(a.args)
2075 
2076             elif a.is_Add:
2077                 laargs = len(a.args)
2078                 negs   = 0
2079 
2080                 for ai in a.args:
2081                     if _coeff_isneg(ai):
2082                         negs += 1
2083                         ai    = -ai
2084                     args.append(ai)
2085 
2086                 ops += laargs - (negs != laargs) # -x - y = NEG + SUB
2087 
2088             elif a.is_Pow:
2089                 ops += 1
2090                 args.append(a.base)
2091 
2092                 if not ratfunc:
2093                     ratfunc = a.exp.is_negative is not False
2094 
2095         return ops, ratfunc
2096 
2097     def nonalg_subs_dummies(expr, dummies):
2098         """Substitute dummy variables for non-algebraic expressions to avoid
2099         evaluation of non-algebraic terms that ``polys.polytools.cancel`` does.
2100         """
2101 
2102         if not expr.args:
2103             return expr
2104 
2105         if expr.is_Add or expr.is_Mul or expr.is_Pow:
2106             args = None
2107 
2108             for i, a in enumerate(expr.args):
2109                 c = nonalg_subs_dummies(a, dummies)
2110 
2111                 if c is a:
2112                     continue
2113 
2114                 if args is None:
2115                     args = list(expr.args)
2116 
2117                 args[i] = c
2118 
2119             if args is None:
2120                 return expr
2121 
2122             return expr.func(*args)
2123 
2124         return dummies.setdefault(expr, Dummy())
2125 
2126     simplified = False # doesn't really mean simplified, rather "can simplify again"
2127 
2128     if isinstance(expr, Basic) and (expr.is_Add or expr.is_Mul or expr.is_Pow):
2129         expr2 = expr.expand(deep=True, modulus=None, power_base=False,
2130             power_exp=False, mul=True, log=False, multinomial=True, basic=False)
2131 
2132         if expr2 != expr:
2133             expr       = expr2
2134             simplified = True
2135 
2136         exprops, ratfunc = count_ops_alg(expr)
2137 
2138         if exprops >= 6: # empirically tested cutoff for expensive simplification
2139             if ratfunc:
2140                 dummies = {}
2141                 expr2   = nonalg_subs_dummies(expr, dummies)
2142 
2143                 if expr2 is expr or count_ops_alg(expr2)[0] >= 6: # check again after substitution
2144                     expr3 = cancel(expr2)
2145 
2146                     if expr3 != expr2:
2147                         expr       = expr3.subs([(d, e) for e, d in dummies.items()])
2148                         simplified = True
2149 
2150         # very special case: x/(x-1) - 1/(x-1) -> 1
2151         elif (exprops == 5 and expr.is_Add and expr.args [0].is_Mul and
2152                 expr.args [1].is_Mul and expr.args [0].args [-1].is_Pow and
2153                 expr.args [1].args [-1].is_Pow and
2154                 expr.args [0].args [-1].exp is S.NegativeOne and
2155                 expr.args [1].args [-1].exp is S.NegativeOne):
2156 
2157             expr2    = together (expr)
2158             expr2ops = count_ops_alg(expr2)[0]
2159 
2160             if expr2ops < exprops:
2161                 expr       = expr2
2162                 simplified = True
2163 
2164         else:
2165             simplified = True
2166 
2167     return (expr, simplified) if withsimp else expr

</code><intended_behavior>The `simplify` method(s) should exhibit consistent behavior when dealing with expressions passed from `sympify` with `evaluate=False`. This means ensuring that expressions involving `ceiling` are simplified appropriately without assuming that the expression has been pre-evaluated unless specified. The resolution would require a thorough review of how `simplify` interacts with expressions marked as unevaluated by `sympify` to identify any logic that might differ in handling such cases between SymPy versions 1.5.1 and 1.6.2. The goal would be to maintain the integrity of unevaluated expressions throughout the simplification process, ensuring consistent outcomes regardless of version changes.</intended_behavior>]
2025-10-18 20:43:59.781 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-18 20:43:59.781 | INFO     | Search-only: skipping patch selection
2025-10-18 20:43:59.862 | INFO     | Task sympy__sympy-20322 completed successfully.
2025-10-18 20:43:59.863 | INFO     | No patch generated. You can try running ACR again.
