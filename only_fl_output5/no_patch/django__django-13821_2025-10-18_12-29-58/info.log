2025-10-18 12:29:58.292 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-18 12:30:01.693 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=232, output_tokens=12, cost=0.002680
2025-10-18 12:30:01.694 | INFO     | Test agent decides that the issue statement does not contain reproduction steps; skipping reproducer tracing
2025-10-18 12:30:01.697 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 12:30:08.106 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=537, output_tokens=210, cost=0.011670
2025-10-18 12:30:08.109 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 12:30:11.646 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=564, output_tokens=46, cost=0.007020
2025-10-18 12:30:11.648 | DEBUG    | Extracted a valid json.
2025-10-18 12:30:11.648 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_method(\"get_sqlite_version\")",
        "search_code(\"SQLITE_VERSION\")",
        "search_code(\"minimum version\")"
    ],
    "bug_locations": []
}
2025-10-18 12:30:11.706 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-18 12:30:11.706 | DEBUG    | <Agent search> Analyzing search results.
2025-10-18 12:30:20.748 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=923, output_tokens=409, cost=0.021500
2025-10-18 12:30:20.756 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 12:30:22.341 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1548, output_tokens=36, cost=0.016560
2025-10-18 12:30:22.345 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 12:30:26.445 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=390, output_tokens=54, cost=0.005520
2025-10-18 12:30:26.447 | DEBUG    | Extracted a valid json.
2025-10-18 12:30:26.447 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_method(\"database_connection\")",
        "search_method(\"check_database_compatibility\")",
        "search_code(\"sqlite3\")",
        "search_code(\"database backend\")"
    ],
    "bug_locations": []
}
2025-10-18 12:30:26.563 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-18 12:30:26.564 | DEBUG    | <Agent search> Analyzing search results.
2025-10-18 12:30:39.122 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2600, output_tokens=546, cost=0.042380
2025-10-18 12:30:39.127 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 12:30:46.801 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=3362, output_tokens=317, cost=0.043130
2025-10-18 12:30:46.806 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 12:30:51.994 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=671, output_tokens=159, cost=0.011480
2025-10-18 12:30:51.995 | DEBUG    | Extracted a valid json.
2025-10-18 12:30:51.995 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations":[
        {
            "file": "django/db/backends/sqlite3/base.py",
            "class": "",
            "method": "",
            "intended_behavior": "This file should ensure on initialization or connection to the SQLite database, the version of SQLite is checked to be 3.9.0 or higher, and raise an appropriate error message if not."
        },
        {
            "file": "django/db/backends/sqlite3/schema.py",
            "class": "",
            "method": "",
            "intended_behavior": "This file should be updated to use features like indexes on expressions in SQLite 3.9.0 directly, removing checks or conditional logic for supporting older versions."
        }
    ]
}
2025-10-18 12:30:52.000 | DEBUG    | Bug location extracted successfully: [<file>django/db/backends/sqlite3/base.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2 SQLite backend for the sqlite3 module in the standard library.
3 """
4 import datetime
5 import decimal
6 import functools
7 import hashlib
8 import math
9 import operator
10 import random
11 import re
12 import statistics
13 import warnings
14 from itertools import chain
15 from sqlite3 import dbapi2 as Database
16 
17 import pytz
18 
19 from django.core.exceptions import ImproperlyConfigured
20 from django.db import IntegrityError
21 from django.db.backends import utils as backend_utils
22 from django.db.backends.base.base import BaseDatabaseWrapper
23 from django.utils import timezone
24 from django.utils.asyncio import async_unsafe
25 from django.utils.dateparse import parse_datetime, parse_time
26 from django.utils.duration import duration_microseconds
27 from django.utils.regex_helper import _lazy_re_compile
28 from django.utils.version import PY38
29 
30 from .client import DatabaseClient
31 from .creation import DatabaseCreation
32 from .features import DatabaseFeatures
33 from .introspection import DatabaseIntrospection
34 from .operations import DatabaseOperations
35 from .schema import DatabaseSchemaEditor
36 
37 
38 def decoder(conv_func):
39     """
40     Convert bytestrings from Python's sqlite3 interface to a regular string.
41     """
42     return lambda s: conv_func(s.decode())
43 
44 
45 def none_guard(func):
46     """
47     Decorator that returns None if any of the arguments to the decorated
48     function are None. Many SQL functions return NULL if any of their arguments
49     are NULL. This decorator simplifies the implementation of this for the
50     custom functions registered below.
51     """
52     @functools.wraps(func)
53     def wrapper(*args, **kwargs):
54         return None if None in args else func(*args, **kwargs)
55     return wrapper
56 
57 
58 def list_aggregate(function):
59     """
60     Return an aggregate class that accumulates values in a list and applies
61     the provided function to the data.
62     """
63     return type('ListAggregate', (list,), {'finalize': function, 'step': list.append})
64 
65 
66 def check_sqlite_version():
67     if Database.sqlite_version_info < (3, 8, 3):
68         raise ImproperlyConfigured('SQLite 3.8.3 or later is required (found %s).' % Database.sqlite_version)
69 
70 
71 check_sqlite_version()
72 
73 Database.register_converter("bool", b'1'.__eq__)
74 Database.register_converter("time", decoder(parse_time))
75 Database.register_converter("datetime", decoder(parse_datetime))
76 Database.register_converter("timestamp", decoder(parse_datetime))
77 
78 Database.register_adapter(decimal.Decimal, str)
79 
80 
81 class DatabaseWrapper(BaseDatabaseWrapper):
82     vendor = 'sqlite'
83     display_name = 'SQLite'
84     # SQLite doesn't actually support most of these types, but it "does the right
85     # thing" given more verbose field definitions, so leave them as is so that
86     # schema inspection is more useful.
87     data_types = {
88         'AutoField': 'integer',
89         'BigAutoField': 'integer',
90         'BinaryField': 'BLOB',
91         'BooleanField': 'bool',
92         'CharField': 'varchar(%(max_length)s)',
93         'DateField': 'date',
94         'DateTimeField': 'datetime',
95         'DecimalField': 'decimal',
96         'DurationField': 'bigint',
97         'FileField': 'varchar(%(max_length)s)',
98         'FilePathField': 'varchar(%(max_length)s)',
99         'FloatField': 'real',
100         'IntegerField': 'integer',
101         'BigIntegerField': 'bigint',
102         'IPAddressField': 'char(15)',
103         'GenericIPAddressField': 'char(39)',
104         'JSONField': 'text',
105         'NullBooleanField': 'bool',
106         'OneToOneField': 'integer',
107         'PositiveBigIntegerField': 'bigint unsigned',
108         'PositiveIntegerField': 'integer unsigned',
109         'PositiveSmallIntegerField': 'smallint unsigned',
110         'SlugField': 'varchar(%(max_length)s)',
111         'SmallAutoField': 'integer',
112         'SmallIntegerField': 'smallint',
113         'TextField': 'text',
114         'TimeField': 'time',
115         'UUIDField': 'char(32)',
116     }
117     data_type_check_constraints = {
118         'PositiveBigIntegerField': '"%(column)s" >= 0',
119         'JSONField': '(JSON_VALID("%(column)s") OR "%(column)s" IS NULL)',
120         'PositiveIntegerField': '"%(column)s" >= 0',
121         'PositiveSmallIntegerField': '"%(column)s" >= 0',
122     }
123     data_types_suffix = {
124         'AutoField': 'AUTOINCREMENT',
125         'BigAutoField': 'AUTOINCREMENT',
126         'SmallAutoField': 'AUTOINCREMENT',
127     }
128     # SQLite requires LIKE statements to include an ESCAPE clause if the value
129     # being escaped has a percent or underscore in it.
130     # See https://www.sqlite.org/lang_expr.html for an explanation.
131     operators = {
132         'exact': '= %s',
133         'iexact': "LIKE %s ESCAPE '\\'",
134         'contains': "LIKE %s ESCAPE '\\'",
135         'icontains': "LIKE %s ESCAPE '\\'",
136         'regex': 'REGEXP %s',
137         'iregex': "REGEXP '(?i)' || %s",
138         'gt': '> %s',
139         'gte': '>= %s',
140         'lt': '< %s',
141         'lte': '<= %s',
142         'startswith': "LIKE %s ESCAPE '\\'",
143         'endswith': "LIKE %s ESCAPE '\\'",
144         'istartswith': "LIKE %s ESCAPE '\\'",
145         'iendswith': "LIKE %s ESCAPE '\\'",
146     }
147 
148     # The patterns below are used to generate SQL pattern lookup clauses when
149     # the right-hand side of the lookup isn't a raw string (it might be an expression
150     # or the result of a bilateral transformation).
151     # In those cases, special characters for LIKE operators (e.g. \, *, _) should be
152     # escaped on database side.
153     #
154     # Note: we use str.format() here for readability as '%' is used as a wildcard for
155     # the LIKE operator.
156     pattern_esc = r"REPLACE(REPLACE(REPLACE({}, '\', '\\'), '%%', '\%%'), '_', '\_')"
157     pattern_ops = {
158         'contains': r"LIKE '%%' || {} || '%%' ESCAPE '\'",
159         'icontains': r"LIKE '%%' || UPPER({}) || '%%' ESCAPE '\'",
160         'startswith': r"LIKE {} || '%%' ESCAPE '\'",
161         'istartswith': r"LIKE UPPER({}) || '%%' ESCAPE '\'",
162         'endswith': r"LIKE '%%' || {} ESCAPE '\'",
163         'iendswith': r"LIKE '%%' || UPPER({}) ESCAPE '\'",
164     }
165 
166     Database = Database
167     SchemaEditorClass = DatabaseSchemaEditor
168     # Classes instantiated in __init__().
169     client_class = DatabaseClient
170     creation_class = DatabaseCreation
171     features_class = DatabaseFeatures
172     introspection_class = DatabaseIntrospection
173     ops_class = DatabaseOperations
174 
175     def get_connection_params(self):
176         settings_dict = self.settings_dict
177         if not settings_dict['NAME']:
178             raise ImproperlyConfigured(
179                 "settings.DATABASES is improperly configured. "
180                 "Please supply the NAME value.")
181         kwargs = {
182             # TODO: Remove str() when dropping support for PY36.
183             # https://bugs.python.org/issue33496
184             'database': str(settings_dict['NAME']),
185             'detect_types': Database.PARSE_DECLTYPES | Database.PARSE_COLNAMES,
186             **settings_dict['OPTIONS'],
187         }
188         # Always allow the underlying SQLite connection to be shareable
189         # between multiple threads. The safe-guarding will be handled at a
190         # higher level by the `BaseDatabaseWrapper.allow_thread_sharing`
191         # property. This is necessary as the shareability is disabled by
192         # default in pysqlite and it cannot be changed once a connection is
193         # opened.
194         if 'check_same_thread' in kwargs and kwargs['check_same_thread']:
195             warnings.warn(
196                 'The `check_same_thread` option was provided and set to '
197                 'True. It will be overridden with False. Use the '
198                 '`DatabaseWrapper.allow_thread_sharing` property instead '
199                 'for controlling thread shareability.',
200                 RuntimeWarning
201             )
202         kwargs.update({'check_same_thread': False, 'uri': True})
203         return kwargs
204 
205     @async_unsafe
206     def get_new_connection(self, conn_params):
207         conn = Database.connect(**conn_params)
208         if PY38:
209             create_deterministic_function = functools.partial(
210                 conn.create_function,
211                 deterministic=True,
212             )
213         else:
214             create_deterministic_function = conn.create_function
215         create_deterministic_function('django_date_extract', 2, _sqlite_datetime_extract)
216         create_deterministic_function('django_date_trunc', 4, _sqlite_date_trunc)
217         create_deterministic_function('django_datetime_cast_date', 3, _sqlite_datetime_cast_date)
218         create_deterministic_function('django_datetime_cast_time', 3, _sqlite_datetime_cast_time)
219         create_deterministic_function('django_datetime_extract', 4, _sqlite_datetime_extract)
220         create_deterministic_function('django_datetime_trunc', 4, _sqlite_datetime_trunc)
221         create_deterministic_function('django_time_extract', 2, _sqlite_time_extract)
222         create_deterministic_function('django_time_trunc', 4, _sqlite_time_trunc)
223         create_deterministic_function('django_time_diff', 2, _sqlite_time_diff)
224         create_deterministic_function('django_timestamp_diff', 2, _sqlite_timestamp_diff)
225         create_deterministic_function('django_format_dtdelta', 3, _sqlite_format_dtdelta)
226         create_deterministic_function('regexp', 2, _sqlite_regexp)
227         create_deterministic_function('ACOS', 1, none_guard(math.acos))
228         create_deterministic_function('ASIN', 1, none_guard(math.asin))
229         create_deterministic_function('ATAN', 1, none_guard(math.atan))
230         create_deterministic_function('ATAN2', 2, none_guard(math.atan2))
231         create_deterministic_function('BITXOR', 2, none_guard(operator.xor))
232         create_deterministic_function('CEILING', 1, none_guard(math.ceil))
233         create_deterministic_function('COS', 1, none_guard(math.cos))
234         create_deterministic_function('COT', 1, none_guard(lambda x: 1 / math.tan(x)))
235         create_deterministic_function('DEGREES', 1, none_guard(math.degrees))
236         create_deterministic_function('EXP', 1, none_guard(math.exp))
237         create_deterministic_function('FLOOR', 1, none_guard(math.floor))
238         create_deterministic_function('LN', 1, none_guard(math.log))
239         create_deterministic_function('LOG', 2, none_guard(lambda x, y: math.log(y, x)))
240         create_deterministic_function('LPAD', 3, _sqlite_lpad)
241         create_deterministic_function('MD5', 1, none_guard(lambda x: hashlib.md5(x.encode()).hexdigest()))
242         create_deterministic_function('MOD', 2, none_guard(math.fmod))
243         create_deterministic_function('PI', 0, lambda: math.pi)
244         create_deterministic_function('POWER', 2, none_guard(operator.pow))
245         create_deterministic_function('RADIANS', 1, none_guard(math.radians))
246         create_deterministic_function('REPEAT', 2, none_guard(operator.mul))
247         create_deterministic_function('REVERSE', 1, none_guard(lambda x: x[::-1]))
248         create_deterministic_function('RPAD', 3, _sqlite_rpad)
249         create_deterministic_function('SHA1', 1, none_guard(lambda x: hashlib.sha1(x.encode()).hexdigest()))
250         create_deterministic_function('SHA224', 1, none_guard(lambda x: hashlib.sha224(x.encode()).hexdigest()))
251         create_deterministic_function('SHA256', 1, none_guard(lambda x: hashlib.sha256(x.encode()).hexdigest()))
252         create_deterministic_function('SHA384', 1, none_guard(lambda x: hashlib.sha384(x.encode()).hexdigest()))
253         create_deterministic_function('SHA512', 1, none_guard(lambda x: hashlib.sha512(x.encode()).hexdigest()))
254         create_deterministic_function('SIGN', 1, none_guard(lambda x: (x > 0) - (x < 0)))
255         create_deterministic_function('SIN', 1, none_guard(math.sin))
256         create_deterministic_function('SQRT', 1, none_guard(math.sqrt))
257         create_deterministic_function('TAN', 1, none_guard(math.tan))
258         # Don't use the built-in RANDOM() function because it returns a value
259         # in the range [2^63, 2^63 - 1] instead of [0, 1).
260         conn.create_function('RAND', 0, random.random)
261         conn.create_aggregate('STDDEV_POP', 1, list_aggregate(statistics.pstdev))
262         conn.create_aggregate('STDDEV_SAMP', 1, list_aggregate(statistics.stdev))
263         conn.create_aggregate('VAR_POP', 1, list_aggregate(statistics.pvariance))
264         conn.create_aggregate('VAR_SAMP', 1, list_aggregate(statistics.variance))
265         conn.execute('PRAGMA foreign_keys = ON')
266         return conn
267 
268     def init_connection_state(self):
269         pass
270 
271     def create_cursor(self, name=None):
272         return self.connection.cursor(factory=SQLiteCursorWrapper)
273 
274     @async_unsafe
275     def close(self):
276         self.validate_thread_sharing()
277         # If database is in memory, closing the connection destroys the
278         # database. To prevent accidental data loss, ignore close requests on
279         # an in-memory db.
280         if not self.is_in_memory_db():
281             BaseDatabaseWrapper.close(self)
282 
283     def _savepoint_allowed(self):
284         # When 'isolation_level' is not None, sqlite3 commits before each
285         # savepoint; it's a bug. When it is None, savepoints don't make sense
286         # because autocommit is enabled. The only exception is inside 'atomic'
287         # blocks. To work around that bug, on SQLite, 'atomic' starts a
288         # transaction explicitly rather than simply disable autocommit.
289         return self.in_atomic_block
290 
291     def _set_autocommit(self, autocommit):
292         if autocommit:
293             level = None
294         else:
295             # sqlite3's internal default is ''. It's different from None.
296             # See Modules/_sqlite/connection.c.
297             level = ''
298         # 'isolation_level' is a misleading API.
299         # SQLite always runs at the SERIALIZABLE isolation level.
300         with self.wrap_database_errors:
301             self.connection.isolation_level = level
302 
303     def disable_constraint_checking(self):
304         with self.cursor() as cursor:
305             cursor.execute('PRAGMA foreign_keys = OFF')
306             # Foreign key constraints cannot be turned off while in a multi-
307             # statement transaction. Fetch the current state of the pragma
308             # to determine if constraints are effectively disabled.
309             enabled = cursor.execute('PRAGMA foreign_keys').fetchone()[0]
310         return not bool(enabled)
311 
312     def enable_constraint_checking(self):
313         with self.cursor() as cursor:
314             cursor.execute('PRAGMA foreign_keys = ON')
315 
316     def check_constraints(self, table_names=None):
317         """
318         Check each table name in `table_names` for rows with invalid foreign
319         key references. This method is intended to be used in conjunction with
320         `disable_constraint_checking()` and `enable_constraint_checking()`, to
321         determine if rows with invalid references were entered while constraint
322         checks were off.
323         """
324         if self.features.supports_pragma_foreign_key_check:
325             with self.cursor() as cursor:
326                 if table_names is None:
327                     violations = cursor.execute('PRAGMA foreign_key_check').fetchall()
328                 else:
329                     violations = chain.from_iterable(
330                         cursor.execute(
331                             'PRAGMA foreign_key_check(%s)'
332                             % self.ops.quote_name(table_name)
333                         ).fetchall()
334                         for table_name in table_names
335                     )
336                 # See https://www.sqlite.org/pragma.html#pragma_foreign_key_check
337                 for table_name, rowid, referenced_table_name, foreign_key_index in violations:
338                     foreign_key = cursor.execute(
339                         'PRAGMA foreign_key_list(%s)' % self.ops.quote_name(table_name)
340                     ).fetchall()[foreign_key_index]
341                     column_name, referenced_column_name = foreign_key[3:5]
342                     primary_key_column_name = self.introspection.get_primary_key_column(cursor, table_name)
343                     primary_key_value, bad_value = cursor.execute(
344                         'SELECT %s, %s FROM %s WHERE rowid = %%s' % (
345                             self.ops.quote_name(primary_key_column_name),
346                             self.ops.quote_name(column_name),
347                             self.ops.quote_name(table_name),
348                         ),
349                         (rowid,),
350                     ).fetchone()
351                     raise IntegrityError(
352                         "The row in table '%s' with primary key '%s' has an "
353                         "invalid foreign key: %s.%s contains a value '%s' that "
354                         "does not have a corresponding value in %s.%s." % (
355                             table_name, primary_key_value, table_name, column_name,
356                             bad_value, referenced_table_name, referenced_column_name
357                         )
358                     )
359         else:
360             with self.cursor() as cursor:
361                 if table_names is None:
362                     table_names = self.introspection.table_names(cursor)
363                 for table_name in table_names:
364                     primary_key_column_name = self.introspection.get_primary_key_column(cursor, table_name)
365                     if not primary_key_column_name:
366                         continue
367                     key_columns = self.introspection.get_key_columns(cursor, table_name)
368                     for column_name, referenced_table_name, referenced_column_name in key_columns:
369                         cursor.execute(
370                             """
371                             SELECT REFERRING.`%s`, REFERRING.`%s` FROM `%s` as REFERRING
372                             LEFT JOIN `%s` as REFERRED
373                             ON (REFERRING.`%s` = REFERRED.`%s`)
374                             WHERE REFERRING.`%s` IS NOT NULL AND REFERRED.`%s` IS NULL
375                             """
376                             % (
377                                 primary_key_column_name, column_name, table_name,
378                                 referenced_table_name, column_name, referenced_column_name,
379                                 column_name, referenced_column_name,
380                             )
381                         )
382                         for bad_row in cursor.fetchall():
383                             raise IntegrityError(
384                                 "The row in table '%s' with primary key '%s' has an "
385                                 "invalid foreign key: %s.%s contains a value '%s' that "
386                                 "does not have a corresponding value in %s.%s." % (
387                                     table_name, bad_row[0], table_name, column_name,
388                                     bad_row[1], referenced_table_name, referenced_column_name,
389                                 )
390                             )
391 
392     def is_usable(self):
393         return True
394 
395     def _start_transaction_under_autocommit(self):
396         """
397         Start a transaction explicitly in autocommit mode.
398 
399         Staying in autocommit mode works around a bug of sqlite3 that breaks
400         savepoints when autocommit is disabled.
401         """
402         self.cursor().execute("BEGIN")
403 
404     def is_in_memory_db(self):
405         return self.creation.is_in_memory_db(self.settings_dict['NAME'])
406 
407 
408 FORMAT_QMARK_REGEX = _lazy_re_compile(r'(?<!%)%s')
409 
410 
411 class SQLiteCursorWrapper(Database.Cursor):
412     """
413     Django uses "format" style placeholders, but pysqlite2 uses "qmark" style.
414     This fixes it -- but note that if you want to use a literal "%s" in a query,
415     you'll need to use "%%s".
416     """
417     def execute(self, query, params=None):
418         if params is None:
419             return Database.Cursor.execute(self, query)
420         query = self.convert_query(query)
421         return Database.Cursor.execute(self, query, params)
422 
423     def executemany(self, query, param_list):
424         query = self.convert_query(query)
425         return Database.Cursor.executemany(self, query, param_list)
426 
427     def convert_query(self, query):
428         return FORMAT_QMARK_REGEX.sub('?', query).replace('%%', '%')
429 
430 
431 def _sqlite_datetime_parse(dt, tzname=None, conn_tzname=None):
432     if dt is None:
433         return None
434     try:
435         dt = backend_utils.typecast_timestamp(dt)
436     except (TypeError, ValueError):
437         return None
438     if conn_tzname:
439         dt = dt.replace(tzinfo=pytz.timezone(conn_tzname))
440     if tzname is not None and tzname != conn_tzname:
441         sign_index = tzname.find('+') + tzname.find('-') + 1
442         if sign_index > -1:
443             sign = tzname[sign_index]
444             tzname, offset = tzname.split(sign)
445             if offset:
446                 hours, minutes = offset.split(':')
447                 offset_delta = datetime.timedelta(hours=int(hours), minutes=int(minutes))
448                 dt += offset_delta if sign == '+' else -offset_delta
449         dt = timezone.localtime(dt, pytz.timezone(tzname))
450     return dt
451 
452 
453 def _sqlite_date_trunc(lookup_type, dt, tzname, conn_tzname):
454     dt = _sqlite_datetime_parse(dt, tzname, conn_tzname)
455     if dt is None:
456         return None
457     if lookup_type == 'year':
458         return "%i-01-01" % dt.year
459     elif lookup_type == 'quarter':
460         month_in_quarter = dt.month - (dt.month - 1) % 3
461         return '%i-%02i-01' % (dt.year, month_in_quarter)
462     elif lookup_type == 'month':
463         return "%i-%02i-01" % (dt.year, dt.month)
464     elif lookup_type == 'week':
465         dt = dt - datetime.timedelta(days=dt.weekday())
466         return "%i-%02i-%02i" % (dt.year, dt.month, dt.day)
467     elif lookup_type == 'day':
468         return "%i-%02i-%02i" % (dt.year, dt.month, dt.day)
469 
470 
471 def _sqlite_time_trunc(lookup_type, dt, tzname, conn_tzname):
472     if dt is None:
473         return None
474     dt_parsed = _sqlite_datetime_parse(dt, tzname, conn_tzname)
475     if dt_parsed is None:
476         try:
477             dt = backend_utils.typecast_time(dt)
478         except (ValueError, TypeError):
479             return None
480     else:
481         dt = dt_parsed
482     if lookup_type == 'hour':
483         return "%02i:00:00" % dt.hour
484     elif lookup_type == 'minute':
485         return "%02i:%02i:00" % (dt.hour, dt.minute)
486     elif lookup_type == 'second':
487         return "%02i:%02i:%02i" % (dt.hour, dt.minute, dt.second)
488 
489 
490 def _sqlite_datetime_cast_date(dt, tzname, conn_tzname):
491     dt = _sqlite_datetime_parse(dt, tzname, conn_tzname)
492     if dt is None:
493         return None
494     return dt.date().isoformat()
495 
496 
497 def _sqlite_datetime_cast_time(dt, tzname, conn_tzname):
498     dt = _sqlite_datetime_parse(dt, tzname, conn_tzname)
499     if dt is None:
500         return None
501     return dt.time().isoformat()
502 
503 
504 def _sqlite_datetime_extract(lookup_type, dt, tzname=None, conn_tzname=None):
505     dt = _sqlite_datetime_parse(dt, tzname, conn_tzname)
506     if dt is None:
507         return None
508     if lookup_type == 'week_day':
509         return (dt.isoweekday() % 7) + 1
510     elif lookup_type == 'iso_week_day':
511         return dt.isoweekday()
512     elif lookup_type == 'week':
513         return dt.isocalendar()[1]
514     elif lookup_type == 'quarter':
515         return math.ceil(dt.month / 3)
516     elif lookup_type == 'iso_year':
517         return dt.isocalendar()[0]
518     else:
519         return getattr(dt, lookup_type)
520 
521 
522 def _sqlite_datetime_trunc(lookup_type, dt, tzname, conn_tzname):
523     dt = _sqlite_datetime_parse(dt, tzname, conn_tzname)
524     if dt is None:
525         return None
526     if lookup_type == 'year':
527         return "%i-01-01 00:00:00" % dt.year
528     elif lookup_type == 'quarter':
529         month_in_quarter = dt.month - (dt.month - 1) % 3
530         return '%i-%02i-01 00:00:00' % (dt.year, month_in_quarter)
531     elif lookup_type == 'month':
532         return "%i-%02i-01 00:00:00" % (dt.year, dt.month)
533     elif lookup_type == 'week':
534         dt = dt - datetime.timedelta(days=dt.weekday())
535         return "%i-%02i-%02i 00:00:00" % (dt.year, dt.month, dt.day)
536     elif lookup_type == 'day':
537         return "%i-%02i-%02i 00:00:00" % (dt.year, dt.month, dt.day)
538     elif lookup_type == 'hour':
539         return "%i-%02i-%02i %02i:00:00" % (dt.year, dt.month, dt.day, dt.hour)
540     elif lookup_type == 'minute':
541         return "%i-%02i-%02i %02i:%02i:00" % (dt.year, dt.month, dt.day, dt.hour, dt.minute)
542     elif lookup_type == 'second':
543         return "%i-%02i-%02i %02i:%02i:%02i" % (dt.year, dt.month, dt.day, dt.hour, dt.minute, dt.second)
544 
545 
546 def _sqlite_time_extract(lookup_type, dt):
547     if dt is None:
548         return None
549     try:
550         dt = backend_utils.typecast_time(dt)
551     except (ValueError, TypeError):
552         return None
553     return getattr(dt, lookup_type)
554 
555 
556 @none_guard
557 def _sqlite_format_dtdelta(conn, lhs, rhs):
558     """
559     LHS and RHS can be either:
560     - An integer number of microseconds
561     - A string representing a datetime
562     """
563     try:
564         real_lhs = datetime.timedelta(0, 0, lhs) if isinstance(lhs, int) else backend_utils.typecast_timestamp(lhs)
565         real_rhs = datetime.timedelta(0, 0, rhs) if isinstance(rhs, int) else backend_utils.typecast_timestamp(rhs)
566         if conn.strip() == '+':
567             out = real_lhs + real_rhs
568         else:
569             out = real_lhs - real_rhs
570     except (ValueError, TypeError):
571         return None
572     # typecast_timestamp returns a date or a datetime without timezone.
573     # It will be formatted as "%Y-%m-%d" or "%Y-%m-%d %H:%M:%S[.%f]"
574     return str(out)
575 
576 
577 @none_guard
578 def _sqlite_time_diff(lhs, rhs):
579     left = backend_utils.typecast_time(lhs)
580     right = backend_utils.typecast_time(rhs)
581     return (
582         (left.hour * 60 * 60 * 1000000) +
583         (left.minute * 60 * 1000000) +
584         (left.second * 1000000) +
585         (left.microsecond) -
586         (right.hour * 60 * 60 * 1000000) -
587         (right.minute * 60 * 1000000) -
588         (right.second * 1000000) -
589         (right.microsecond)
590     )
591 
592 
593 @none_guard
594 def _sqlite_timestamp_diff(lhs, rhs):
595     left = backend_utils.typecast_timestamp(lhs)
596     right = backend_utils.typecast_timestamp(rhs)
597     return duration_microseconds(left - right)
598 
599 
600 @none_guard
601 def _sqlite_regexp(re_pattern, re_string):
602     return bool(re.search(re_pattern, str(re_string)))
603 
604 
605 @none_guard
606 def _sqlite_lpad(text, length, fill_text):
607     if len(text) >= length:
608         return text[:length]
609     return (fill_text * length)[:length - len(text)] + text
610 
611 
612 @none_guard
613 def _sqlite_rpad(text, length, fill_text):
614     return (text + fill_text * length)[:length]

</code><intended_behavior>This file should ensure on initialization or connection to the SQLite database, the version of SQLite is checked to be 3.9.0 or higher, and raise an appropriate error message if not.</intended_behavior>, <file>django/db/backends/sqlite3/schema.py</file>
<class>None</class>
<method>None</method>
<code>
1 import copy
2 from decimal import Decimal
3 
4 from django.apps.registry import Apps
5 from django.db import NotSupportedError
6 from django.db.backends.base.schema import BaseDatabaseSchemaEditor
7 from django.db.backends.ddl_references import Statement
8 from django.db.backends.utils import strip_quotes
9 from django.db.models import UniqueConstraint
10 from django.db.transaction import atomic
11 
12 
13 class DatabaseSchemaEditor(BaseDatabaseSchemaEditor):
14 
15     sql_delete_table = "DROP TABLE %(table)s"
16     sql_create_fk = None
17     sql_create_inline_fk = "REFERENCES %(to_table)s (%(to_column)s) DEFERRABLE INITIALLY DEFERRED"
18     sql_create_unique = "CREATE UNIQUE INDEX %(name)s ON %(table)s (%(columns)s)"
19     sql_delete_unique = "DROP INDEX %(name)s"
20 
21     def __enter__(self):
22         # Some SQLite schema alterations need foreign key constraints to be
23         # disabled. Enforce it here for the duration of the schema edition.
24         if not self.connection.disable_constraint_checking():
25             raise NotSupportedError(
26                 'SQLite schema editor cannot be used while foreign key '
27                 'constraint checks are enabled. Make sure to disable them '
28                 'before entering a transaction.atomic() context because '
29                 'SQLite does not support disabling them in the middle of '
30                 'a multi-statement transaction.'
31             )
32         return super().__enter__()
33 
34     def __exit__(self, exc_type, exc_value, traceback):
35         self.connection.check_constraints()
36         super().__exit__(exc_type, exc_value, traceback)
37         self.connection.enable_constraint_checking()
38 
39     def quote_value(self, value):
40         # The backend "mostly works" without this function and there are use
41         # cases for compiling Python without the sqlite3 libraries (e.g.
42         # security hardening).
43         try:
44             import sqlite3
45             value = sqlite3.adapt(value)
46         except ImportError:
47             pass
48         except sqlite3.ProgrammingError:
49             pass
50         # Manual emulation of SQLite parameter quoting
51         if isinstance(value, bool):
52             return str(int(value))
53         elif isinstance(value, (Decimal, float, int)):
54             return str(value)
55         elif isinstance(value, str):
56             return "'%s'" % value.replace("\'", "\'\'")
57         elif value is None:
58             return "NULL"
59         elif isinstance(value, (bytes, bytearray, memoryview)):
60             # Bytes are only allowed for BLOB fields, encoded as string
61             # literals containing hexadecimal data and preceded by a single "X"
62             # character.
63             return "X'%s'" % value.hex()
64         else:
65             raise ValueError("Cannot quote parameter value %r of type %s" % (value, type(value)))
66 
67     def _is_referenced_by_fk_constraint(self, table_name, column_name=None, ignore_self=False):
68         """
69         Return whether or not the provided table name is referenced by another
70         one. If `column_name` is specified, only references pointing to that
71         column are considered. If `ignore_self` is True, self-referential
72         constraints are ignored.
73         """
74         with self.connection.cursor() as cursor:
75             for other_table in self.connection.introspection.get_table_list(cursor):
76                 if ignore_self and other_table.name == table_name:
77                     continue
78                 constraints = self.connection.introspection._get_foreign_key_constraints(cursor, other_table.name)
79                 for constraint in constraints.values():
80                     constraint_table, constraint_column = constraint['foreign_key']
81                     if (constraint_table == table_name and
82                             (column_name is None or constraint_column == column_name)):
83                         return True
84         return False
85 
86     def alter_db_table(self, model, old_db_table, new_db_table, disable_constraints=True):
87         if (not self.connection.features.supports_atomic_references_rename and
88                 disable_constraints and self._is_referenced_by_fk_constraint(old_db_table)):
89             if self.connection.in_atomic_block:
90                 raise NotSupportedError((
91                     'Renaming the %r table while in a transaction is not '
92                     'supported on SQLite < 3.26 because it would break referential '
93                     'integrity. Try adding `atomic = False` to the Migration class.'
94                 ) % old_db_table)
95             self.connection.enable_constraint_checking()
96             super().alter_db_table(model, old_db_table, new_db_table)
97             self.connection.disable_constraint_checking()
98         else:
99             super().alter_db_table(model, old_db_table, new_db_table)
100 
101     def alter_field(self, model, old_field, new_field, strict=False):
102         if not self._field_should_be_altered(old_field, new_field):
103             return
104         old_field_name = old_field.name
105         table_name = model._meta.db_table
106         _, old_column_name = old_field.get_attname_column()
107         if (new_field.name != old_field_name and
108                 not self.connection.features.supports_atomic_references_rename and
109                 self._is_referenced_by_fk_constraint(table_name, old_column_name, ignore_self=True)):
110             if self.connection.in_atomic_block:
111                 raise NotSupportedError((
112                     'Renaming the %r.%r column while in a transaction is not '
113                     'supported on SQLite < 3.26 because it would break referential '
114                     'integrity. Try adding `atomic = False` to the Migration class.'
115                 ) % (model._meta.db_table, old_field_name))
116             with atomic(self.connection.alias):
117                 super().alter_field(model, old_field, new_field, strict=strict)
118                 # Follow SQLite's documented procedure for performing changes
119                 # that don't affect the on-disk content.
120                 # https://sqlite.org/lang_altertable.html#otheralter
121                 with self.connection.cursor() as cursor:
122                     schema_version = cursor.execute('PRAGMA schema_version').fetchone()[0]
123                     cursor.execute('PRAGMA writable_schema = 1')
124                     references_template = ' REFERENCES "%s" ("%%s") ' % table_name
125                     new_column_name = new_field.get_attname_column()[1]
126                     search = references_template % old_column_name
127                     replacement = references_template % new_column_name
128                     cursor.execute('UPDATE sqlite_master SET sql = replace(sql, %s, %s)', (search, replacement))
129                     cursor.execute('PRAGMA schema_version = %d' % (schema_version + 1))
130                     cursor.execute('PRAGMA writable_schema = 0')
131                     # The integrity check will raise an exception and rollback
132                     # the transaction if the sqlite_master updates corrupt the
133                     # database.
134                     cursor.execute('PRAGMA integrity_check')
135             # Perform a VACUUM to refresh the database representation from
136             # the sqlite_master table.
137             with self.connection.cursor() as cursor:
138                 cursor.execute('VACUUM')
139         else:
140             super().alter_field(model, old_field, new_field, strict=strict)
141 
142     def _remake_table(self, model, create_field=None, delete_field=None, alter_field=None):
143         """
144         Shortcut to transform a model from old_model into new_model
145 
146         This follows the correct procedure to perform non-rename or column
147         addition operations based on SQLite's documentation
148 
149         https://www.sqlite.org/lang_altertable.html#caution
150 
151         The essential steps are:
152           1. Create a table with the updated definition called "new__app_model"
153           2. Copy the data from the existing "app_model" table to the new table
154           3. Drop the "app_model" table
155           4. Rename the "new__app_model" table to "app_model"
156           5. Restore any index of the previous "app_model" table.
157         """
158         # Self-referential fields must be recreated rather than copied from
159         # the old model to ensure their remote_field.field_name doesn't refer
160         # to an altered field.
161         def is_self_referential(f):
162             return f.is_relation and f.remote_field.model is model
163         # Work out the new fields dict / mapping
164         body = {
165             f.name: f.clone() if is_self_referential(f) else f
166             for f in model._meta.local_concrete_fields
167         }
168         # Since mapping might mix column names and default values,
169         # its values must be already quoted.
170         mapping = {f.column: self.quote_name(f.column) for f in model._meta.local_concrete_fields}
171         # This maps field names (not columns) for things like unique_together
172         rename_mapping = {}
173         # If any of the new or altered fields is introducing a new PK,
174         # remove the old one
175         restore_pk_field = None
176         if getattr(create_field, 'primary_key', False) or (
177                 alter_field and getattr(alter_field[1], 'primary_key', False)):
178             for name, field in list(body.items()):
179                 if field.primary_key:
180                     field.primary_key = False
181                     restore_pk_field = field
182                     if field.auto_created:
183                         del body[name]
184                         del mapping[field.column]
185         # Add in any created fields
186         if create_field:
187             body[create_field.name] = create_field
188             # Choose a default and insert it into the copy map
189             if not create_field.many_to_many and create_field.concrete:
190                 mapping[create_field.column] = self.quote_value(
191                     self.effective_default(create_field)
192                 )
193         # Add in any altered fields
194         if alter_field:
195             old_field, new_field = alter_field
196             body.pop(old_field.name, None)
197             mapping.pop(old_field.column, None)
198             body[new_field.name] = new_field
199             if old_field.null and not new_field.null:
200                 case_sql = "coalesce(%(col)s, %(default)s)" % {
201                     'col': self.quote_name(old_field.column),
202                     'default': self.quote_value(self.effective_default(new_field))
203                 }
204                 mapping[new_field.column] = case_sql
205             else:
206                 mapping[new_field.column] = self.quote_name(old_field.column)
207             rename_mapping[old_field.name] = new_field.name
208         # Remove any deleted fields
209         if delete_field:
210             del body[delete_field.name]
211             del mapping[delete_field.column]
212             # Remove any implicit M2M tables
213             if delete_field.many_to_many and delete_field.remote_field.through._meta.auto_created:
214                 return self.delete_model(delete_field.remote_field.through)
215         # Work inside a new app registry
216         apps = Apps()
217 
218         # Work out the new value of unique_together, taking renames into
219         # account
220         unique_together = [
221             [rename_mapping.get(n, n) for n in unique]
222             for unique in model._meta.unique_together
223         ]
224 
225         # Work out the new value for index_together, taking renames into
226         # account
227         index_together = [
228             [rename_mapping.get(n, n) for n in index]
229             for index in model._meta.index_together
230         ]
231 
232         indexes = model._meta.indexes
233         if delete_field:
234             indexes = [
235                 index for index in indexes
236                 if delete_field.name not in index.fields
237             ]
238 
239         constraints = list(model._meta.constraints)
240 
241         # Provide isolated instances of the fields to the new model body so
242         # that the existing model's internals aren't interfered with when
243         # the dummy model is constructed.
244         body_copy = copy.deepcopy(body)
245 
246         # Construct a new model with the new fields to allow self referential
247         # primary key to resolve to. This model won't ever be materialized as a
248         # table and solely exists for foreign key reference resolution purposes.
249         # This wouldn't be required if the schema editor was operating on model
250         # states instead of rendered models.
251         meta_contents = {
252             'app_label': model._meta.app_label,
253             'db_table': model._meta.db_table,
254             'unique_together': unique_together,
255             'index_together': index_together,
256             'indexes': indexes,
257             'constraints': constraints,
258             'apps': apps,
259         }
260         meta = type("Meta", (), meta_contents)
261         body_copy['Meta'] = meta
262         body_copy['__module__'] = model.__module__
263         type(model._meta.object_name, model.__bases__, body_copy)
264 
265         # Construct a model with a renamed table name.
266         body_copy = copy.deepcopy(body)
267         meta_contents = {
268             'app_label': model._meta.app_label,
269             'db_table': 'new__%s' % strip_quotes(model._meta.db_table),
270             'unique_together': unique_together,
271             'index_together': index_together,
272             'indexes': indexes,
273             'constraints': constraints,
274             'apps': apps,
275         }
276         meta = type("Meta", (), meta_contents)
277         body_copy['Meta'] = meta
278         body_copy['__module__'] = model.__module__
279         new_model = type('New%s' % model._meta.object_name, model.__bases__, body_copy)
280 
281         # Create a new table with the updated schema.
282         self.create_model(new_model)
283 
284         # Copy data from the old table into the new table
285         self.execute("INSERT INTO %s (%s) SELECT %s FROM %s" % (
286             self.quote_name(new_model._meta.db_table),
287             ', '.join(self.quote_name(x) for x in mapping),
288             ', '.join(mapping.values()),
289             self.quote_name(model._meta.db_table),
290         ))
291 
292         # Delete the old table to make way for the new
293         self.delete_model(model, handle_autom2m=False)
294 
295         # Rename the new table to take way for the old
296         self.alter_db_table(
297             new_model, new_model._meta.db_table, model._meta.db_table,
298             disable_constraints=False,
299         )
300 
301         # Run deferred SQL on correct table
302         for sql in self.deferred_sql:
303             self.execute(sql)
304         self.deferred_sql = []
305         # Fix any PK-removed field
306         if restore_pk_field:
307             restore_pk_field.primary_key = True
308 
309     def delete_model(self, model, handle_autom2m=True):
310         if handle_autom2m:
311             super().delete_model(model)
312         else:
313             # Delete the table (and only that)
314             self.execute(self.sql_delete_table % {
315                 "table": self.quote_name(model._meta.db_table),
316             })
317             # Remove all deferred statements referencing the deleted table.
318             for sql in list(self.deferred_sql):
319                 if isinstance(sql, Statement) and sql.references_table(model._meta.db_table):
320                     self.deferred_sql.remove(sql)
321 
322     def add_field(self, model, field):
323         """
324         Create a field on a model. Usually involves adding a column, but may
325         involve adding a table instead (for M2M fields).
326         """
327         # Special-case implicit M2M tables
328         if field.many_to_many and field.remote_field.through._meta.auto_created:
329             return self.create_model(field.remote_field.through)
330         self._remake_table(model, create_field=field)
331 
332     def remove_field(self, model, field):
333         """
334         Remove a field from a model. Usually involves deleting a column,
335         but for M2Ms may involve deleting a table.
336         """
337         # M2M fields are a special case
338         if field.many_to_many:
339             # For implicit M2M tables, delete the auto-created table
340             if field.remote_field.through._meta.auto_created:
341                 self.delete_model(field.remote_field.through)
342             # For explicit "through" M2M fields, do nothing
343         # For everything else, remake.
344         else:
345             # It might not actually have a column behind it
346             if field.db_parameters(connection=self.connection)['type'] is None:
347                 return
348             self._remake_table(model, delete_field=field)
349 
350     def _alter_field(self, model, old_field, new_field, old_type, new_type,
351                      old_db_params, new_db_params, strict=False):
352         """Perform a "physical" (non-ManyToMany) field update."""
353         # Use "ALTER TABLE ... RENAME COLUMN" if only the column name
354         # changed and there aren't any constraints.
355         if (self.connection.features.can_alter_table_rename_column and
356             old_field.column != new_field.column and
357             self.column_sql(model, old_field) == self.column_sql(model, new_field) and
358             not (old_field.remote_field and old_field.db_constraint or
359                  new_field.remote_field and new_field.db_constraint)):
360             return self.execute(self._rename_field_sql(model._meta.db_table, old_field, new_field, new_type))
361         # Alter by remaking table
362         self._remake_table(model, alter_field=(old_field, new_field))
363         # Rebuild tables with FKs pointing to this field.
364         if new_field.unique and old_type != new_type:
365             related_models = set()
366             opts = new_field.model._meta
367             for remote_field in opts.related_objects:
368                 # Ignore self-relationship since the table was already rebuilt.
369                 if remote_field.related_model == model:
370                     continue
371                 if not remote_field.many_to_many:
372                     if remote_field.field_name == new_field.name:
373                         related_models.add(remote_field.related_model)
374                 elif new_field.primary_key and remote_field.through._meta.auto_created:
375                     related_models.add(remote_field.through)
376             if new_field.primary_key:
377                 for many_to_many in opts.many_to_many:
378                     # Ignore self-relationship since the table was already rebuilt.
379                     if many_to_many.related_model == model:
380                         continue
381                     if many_to_many.remote_field.through._meta.auto_created:
382                         related_models.add(many_to_many.remote_field.through)
383             for related_model in related_models:
384                 self._remake_table(related_model)
385 
386     def _alter_many_to_many(self, model, old_field, new_field, strict):
387         """Alter M2Ms to repoint their to= endpoints."""
388         if old_field.remote_field.through._meta.db_table == new_field.remote_field.through._meta.db_table:
389             # The field name didn't change, but some options did; we have to propagate this altering.
390             self._remake_table(
391                 old_field.remote_field.through,
392                 alter_field=(
393                     # We need the field that points to the target model, so we can tell alter_field to change it -
394                     # this is m2m_reverse_field_name() (as opposed to m2m_field_name, which points to our model)
395                     old_field.remote_field.through._meta.get_field(old_field.m2m_reverse_field_name()),
396                     new_field.remote_field.through._meta.get_field(new_field.m2m_reverse_field_name()),
397                 ),
398             )
399             return
400 
401         # Make a new through table
402         self.create_model(new_field.remote_field.through)
403         # Copy the data across
404         self.execute("INSERT INTO %s (%s) SELECT %s FROM %s" % (
405             self.quote_name(new_field.remote_field.through._meta.db_table),
406             ', '.join([
407                 "id",
408                 new_field.m2m_column_name(),
409                 new_field.m2m_reverse_name(),
410             ]),
411             ', '.join([
412                 "id",
413                 old_field.m2m_column_name(),
414                 old_field.m2m_reverse_name(),
415             ]),
416             self.quote_name(old_field.remote_field.through._meta.db_table),
417         ))
418         # Delete the old through table
419         self.delete_model(old_field.remote_field.through)
420 
421     def add_constraint(self, model, constraint):
422         if isinstance(constraint, UniqueConstraint) and constraint.condition:
423             super().add_constraint(model, constraint)
424         else:
425             self._remake_table(model)
426 
427     def remove_constraint(self, model, constraint):
428         if isinstance(constraint, UniqueConstraint) and constraint.condition:
429             super().remove_constraint(model, constraint)
430         else:
431             self._remake_table(model)
432 
433     def _collate_sql(self, collation):
434         return ' COLLATE ' + collation

</code><intended_behavior>This file should be updated to use features like indexes on expressions in SQLite 3.9.0 directly, removing checks or conditional logic for supporting older versions.</intended_behavior>]
2025-10-18 12:30:52.001 | INFO     | Search completed. Bug locations: [<file>django/db/backends/sqlite3/base.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2 SQLite backend for the sqlite3 module in the standard library.
3 """
4 import datetime
5 import decimal
6 import functools
7 import hashlib
8 import math
9 import operator
10 import random
11 import re
12 import statistics
13 import warnings
14 from itertools import chain
15 from sqlite3 import dbapi2 as Database
16 
17 import pytz
18 
19 from django.core.exceptions import ImproperlyConfigured
20 from django.db import IntegrityError
21 from django.db.backends import utils as backend_utils
22 from django.db.backends.base.base import BaseDatabaseWrapper
23 from django.utils import timezone
24 from django.utils.asyncio import async_unsafe
25 from django.utils.dateparse import parse_datetime, parse_time
26 from django.utils.duration import duration_microseconds
27 from django.utils.regex_helper import _lazy_re_compile
28 from django.utils.version import PY38
29 
30 from .client import DatabaseClient
31 from .creation import DatabaseCreation
32 from .features import DatabaseFeatures
33 from .introspection import DatabaseIntrospection
34 from .operations import DatabaseOperations
35 from .schema import DatabaseSchemaEditor
36 
37 
38 def decoder(conv_func):
39     """
40     Convert bytestrings from Python's sqlite3 interface to a regular string.
41     """
42     return lambda s: conv_func(s.decode())
43 
44 
45 def none_guard(func):
46     """
47     Decorator that returns None if any of the arguments to the decorated
48     function are None. Many SQL functions return NULL if any of their arguments
49     are NULL. This decorator simplifies the implementation of this for the
50     custom functions registered below.
51     """
52     @functools.wraps(func)
53     def wrapper(*args, **kwargs):
54         return None if None in args else func(*args, **kwargs)
55     return wrapper
56 
57 
58 def list_aggregate(function):
59     """
60     Return an aggregate class that accumulates values in a list and applies
61     the provided function to the data.
62     """
63     return type('ListAggregate', (list,), {'finalize': function, 'step': list.append})
64 
65 
66 def check_sqlite_version():
67     if Database.sqlite_version_info < (3, 8, 3):
68         raise ImproperlyConfigured('SQLite 3.8.3 or later is required (found %s).' % Database.sqlite_version)
69 
70 
71 check_sqlite_version()
72 
73 Database.register_converter("bool", b'1'.__eq__)
74 Database.register_converter("time", decoder(parse_time))
75 Database.register_converter("datetime", decoder(parse_datetime))
76 Database.register_converter("timestamp", decoder(parse_datetime))
77 
78 Database.register_adapter(decimal.Decimal, str)
79 
80 
81 class DatabaseWrapper(BaseDatabaseWrapper):
82     vendor = 'sqlite'
83     display_name = 'SQLite'
84     # SQLite doesn't actually support most of these types, but it "does the right
85     # thing" given more verbose field definitions, so leave them as is so that
86     # schema inspection is more useful.
87     data_types = {
88         'AutoField': 'integer',
89         'BigAutoField': 'integer',
90         'BinaryField': 'BLOB',
91         'BooleanField': 'bool',
92         'CharField': 'varchar(%(max_length)s)',
93         'DateField': 'date',
94         'DateTimeField': 'datetime',
95         'DecimalField': 'decimal',
96         'DurationField': 'bigint',
97         'FileField': 'varchar(%(max_length)s)',
98         'FilePathField': 'varchar(%(max_length)s)',
99         'FloatField': 'real',
100         'IntegerField': 'integer',
101         'BigIntegerField': 'bigint',
102         'IPAddressField': 'char(15)',
103         'GenericIPAddressField': 'char(39)',
104         'JSONField': 'text',
105         'NullBooleanField': 'bool',
106         'OneToOneField': 'integer',
107         'PositiveBigIntegerField': 'bigint unsigned',
108         'PositiveIntegerField': 'integer unsigned',
109         'PositiveSmallIntegerField': 'smallint unsigned',
110         'SlugField': 'varchar(%(max_length)s)',
111         'SmallAutoField': 'integer',
112         'SmallIntegerField': 'smallint',
113         'TextField': 'text',
114         'TimeField': 'time',
115         'UUIDField': 'char(32)',
116     }
117     data_type_check_constraints = {
118         'PositiveBigIntegerField': '"%(column)s" >= 0',
119         'JSONField': '(JSON_VALID("%(column)s") OR "%(column)s" IS NULL)',
120         'PositiveIntegerField': '"%(column)s" >= 0',
121         'PositiveSmallIntegerField': '"%(column)s" >= 0',
122     }
123     data_types_suffix = {
124         'AutoField': 'AUTOINCREMENT',
125         'BigAutoField': 'AUTOINCREMENT',
126         'SmallAutoField': 'AUTOINCREMENT',
127     }
128     # SQLite requires LIKE statements to include an ESCAPE clause if the value
129     # being escaped has a percent or underscore in it.
130     # See https://www.sqlite.org/lang_expr.html for an explanation.
131     operators = {
132         'exact': '= %s',
133         'iexact': "LIKE %s ESCAPE '\\'",
134         'contains': "LIKE %s ESCAPE '\\'",
135         'icontains': "LIKE %s ESCAPE '\\'",
136         'regex': 'REGEXP %s',
137         'iregex': "REGEXP '(?i)' || %s",
138         'gt': '> %s',
139         'gte': '>= %s',
140         'lt': '< %s',
141         'lte': '<= %s',
142         'startswith': "LIKE %s ESCAPE '\\'",
143         'endswith': "LIKE %s ESCAPE '\\'",
144         'istartswith': "LIKE %s ESCAPE '\\'",
145         'iendswith': "LIKE %s ESCAPE '\\'",
146     }
147 
148     # The patterns below are used to generate SQL pattern lookup clauses when
149     # the right-hand side of the lookup isn't a raw string (it might be an expression
150     # or the result of a bilateral transformation).
151     # In those cases, special characters for LIKE operators (e.g. \, *, _) should be
152     # escaped on database side.
153     #
154     # Note: we use str.format() here for readability as '%' is used as a wildcard for
155     # the LIKE operator.
156     pattern_esc = r"REPLACE(REPLACE(REPLACE({}, '\', '\\'), '%%', '\%%'), '_', '\_')"
157     pattern_ops = {
158         'contains': r"LIKE '%%' || {} || '%%' ESCAPE '\'",
159         'icontains': r"LIKE '%%' || UPPER({}) || '%%' ESCAPE '\'",
160         'startswith': r"LIKE {} || '%%' ESCAPE '\'",
161         'istartswith': r"LIKE UPPER({}) || '%%' ESCAPE '\'",
162         'endswith': r"LIKE '%%' || {} ESCAPE '\'",
163         'iendswith': r"LIKE '%%' || UPPER({}) ESCAPE '\'",
164     }
165 
166     Database = Database
167     SchemaEditorClass = DatabaseSchemaEditor
168     # Classes instantiated in __init__().
169     client_class = DatabaseClient
170     creation_class = DatabaseCreation
171     features_class = DatabaseFeatures
172     introspection_class = DatabaseIntrospection
173     ops_class = DatabaseOperations
174 
175     def get_connection_params(self):
176         settings_dict = self.settings_dict
177         if not settings_dict['NAME']:
178             raise ImproperlyConfigured(
179                 "settings.DATABASES is improperly configured. "
180                 "Please supply the NAME value.")
181         kwargs = {
182             # TODO: Remove str() when dropping support for PY36.
183             # https://bugs.python.org/issue33496
184             'database': str(settings_dict['NAME']),
185             'detect_types': Database.PARSE_DECLTYPES | Database.PARSE_COLNAMES,
186             **settings_dict['OPTIONS'],
187         }
188         # Always allow the underlying SQLite connection to be shareable
189         # between multiple threads. The safe-guarding will be handled at a
190         # higher level by the `BaseDatabaseWrapper.allow_thread_sharing`
191         # property. This is necessary as the shareability is disabled by
192         # default in pysqlite and it cannot be changed once a connection is
193         # opened.
194         if 'check_same_thread' in kwargs and kwargs['check_same_thread']:
195             warnings.warn(
196                 'The `check_same_thread` option was provided and set to '
197                 'True. It will be overridden with False. Use the '
198                 '`DatabaseWrapper.allow_thread_sharing` property instead '
199                 'for controlling thread shareability.',
200                 RuntimeWarning
201             )
202         kwargs.update({'check_same_thread': False, 'uri': True})
203         return kwargs
204 
205     @async_unsafe
206     def get_new_connection(self, conn_params):
207         conn = Database.connect(**conn_params)
208         if PY38:
209             create_deterministic_function = functools.partial(
210                 conn.create_function,
211                 deterministic=True,
212             )
213         else:
214             create_deterministic_function = conn.create_function
215         create_deterministic_function('django_date_extract', 2, _sqlite_datetime_extract)
216         create_deterministic_function('django_date_trunc', 4, _sqlite_date_trunc)
217         create_deterministic_function('django_datetime_cast_date', 3, _sqlite_datetime_cast_date)
218         create_deterministic_function('django_datetime_cast_time', 3, _sqlite_datetime_cast_time)
219         create_deterministic_function('django_datetime_extract', 4, _sqlite_datetime_extract)
220         create_deterministic_function('django_datetime_trunc', 4, _sqlite_datetime_trunc)
221         create_deterministic_function('django_time_extract', 2, _sqlite_time_extract)
222         create_deterministic_function('django_time_trunc', 4, _sqlite_time_trunc)
223         create_deterministic_function('django_time_diff', 2, _sqlite_time_diff)
224         create_deterministic_function('django_timestamp_diff', 2, _sqlite_timestamp_diff)
225         create_deterministic_function('django_format_dtdelta', 3, _sqlite_format_dtdelta)
226         create_deterministic_function('regexp', 2, _sqlite_regexp)
227         create_deterministic_function('ACOS', 1, none_guard(math.acos))
228         create_deterministic_function('ASIN', 1, none_guard(math.asin))
229         create_deterministic_function('ATAN', 1, none_guard(math.atan))
230         create_deterministic_function('ATAN2', 2, none_guard(math.atan2))
231         create_deterministic_function('BITXOR', 2, none_guard(operator.xor))
232         create_deterministic_function('CEILING', 1, none_guard(math.ceil))
233         create_deterministic_function('COS', 1, none_guard(math.cos))
234         create_deterministic_function('COT', 1, none_guard(lambda x: 1 / math.tan(x)))
235         create_deterministic_function('DEGREES', 1, none_guard(math.degrees))
236         create_deterministic_function('EXP', 1, none_guard(math.exp))
237         create_deterministic_function('FLOOR', 1, none_guard(math.floor))
238         create_deterministic_function('LN', 1, none_guard(math.log))
239         create_deterministic_function('LOG', 2, none_guard(lambda x, y: math.log(y, x)))
240         create_deterministic_function('LPAD', 3, _sqlite_lpad)
241         create_deterministic_function('MD5', 1, none_guard(lambda x: hashlib.md5(x.encode()).hexdigest()))
242         create_deterministic_function('MOD', 2, none_guard(math.fmod))
243         create_deterministic_function('PI', 0, lambda: math.pi)
244         create_deterministic_function('POWER', 2, none_guard(operator.pow))
245         create_deterministic_function('RADIANS', 1, none_guard(math.radians))
246         create_deterministic_function('REPEAT', 2, none_guard(operator.mul))
247         create_deterministic_function('REVERSE', 1, none_guard(lambda x: x[::-1]))
248         create_deterministic_function('RPAD', 3, _sqlite_rpad)
249         create_deterministic_function('SHA1', 1, none_guard(lambda x: hashlib.sha1(x.encode()).hexdigest()))
250         create_deterministic_function('SHA224', 1, none_guard(lambda x: hashlib.sha224(x.encode()).hexdigest()))
251         create_deterministic_function('SHA256', 1, none_guard(lambda x: hashlib.sha256(x.encode()).hexdigest()))
252         create_deterministic_function('SHA384', 1, none_guard(lambda x: hashlib.sha384(x.encode()).hexdigest()))
253         create_deterministic_function('SHA512', 1, none_guard(lambda x: hashlib.sha512(x.encode()).hexdigest()))
254         create_deterministic_function('SIGN', 1, none_guard(lambda x: (x > 0) - (x < 0)))
255         create_deterministic_function('SIN', 1, none_guard(math.sin))
256         create_deterministic_function('SQRT', 1, none_guard(math.sqrt))
257         create_deterministic_function('TAN', 1, none_guard(math.tan))
258         # Don't use the built-in RANDOM() function because it returns a value
259         # in the range [2^63, 2^63 - 1] instead of [0, 1).
260         conn.create_function('RAND', 0, random.random)
261         conn.create_aggregate('STDDEV_POP', 1, list_aggregate(statistics.pstdev))
262         conn.create_aggregate('STDDEV_SAMP', 1, list_aggregate(statistics.stdev))
263         conn.create_aggregate('VAR_POP', 1, list_aggregate(statistics.pvariance))
264         conn.create_aggregate('VAR_SAMP', 1, list_aggregate(statistics.variance))
265         conn.execute('PRAGMA foreign_keys = ON')
266         return conn
267 
268     def init_connection_state(self):
269         pass
270 
271     def create_cursor(self, name=None):
272         return self.connection.cursor(factory=SQLiteCursorWrapper)
273 
274     @async_unsafe
275     def close(self):
276         self.validate_thread_sharing()
277         # If database is in memory, closing the connection destroys the
278         # database. To prevent accidental data loss, ignore close requests on
279         # an in-memory db.
280         if not self.is_in_memory_db():
281             BaseDatabaseWrapper.close(self)
282 
283     def _savepoint_allowed(self):
284         # When 'isolation_level' is not None, sqlite3 commits before each
285         # savepoint; it's a bug. When it is None, savepoints don't make sense
286         # because autocommit is enabled. The only exception is inside 'atomic'
287         # blocks. To work around that bug, on SQLite, 'atomic' starts a
288         # transaction explicitly rather than simply disable autocommit.
289         return self.in_atomic_block
290 
291     def _set_autocommit(self, autocommit):
292         if autocommit:
293             level = None
294         else:
295             # sqlite3's internal default is ''. It's different from None.
296             # See Modules/_sqlite/connection.c.
297             level = ''
298         # 'isolation_level' is a misleading API.
299         # SQLite always runs at the SERIALIZABLE isolation level.
300         with self.wrap_database_errors:
301             self.connection.isolation_level = level
302 
303     def disable_constraint_checking(self):
304         with self.cursor() as cursor:
305             cursor.execute('PRAGMA foreign_keys = OFF')
306             # Foreign key constraints cannot be turned off while in a multi-
307             # statement transaction. Fetch the current state of the pragma
308             # to determine if constraints are effectively disabled.
309             enabled = cursor.execute('PRAGMA foreign_keys').fetchone()[0]
310         return not bool(enabled)
311 
312     def enable_constraint_checking(self):
313         with self.cursor() as cursor:
314             cursor.execute('PRAGMA foreign_keys = ON')
315 
316     def check_constraints(self, table_names=None):
317         """
318         Check each table name in `table_names` for rows with invalid foreign
319         key references. This method is intended to be used in conjunction with
320         `disable_constraint_checking()` and `enable_constraint_checking()`, to
321         determine if rows with invalid references were entered while constraint
322         checks were off.
323         """
324         if self.features.supports_pragma_foreign_key_check:
325             with self.cursor() as cursor:
326                 if table_names is None:
327                     violations = cursor.execute('PRAGMA foreign_key_check').fetchall()
328                 else:
329                     violations = chain.from_iterable(
330                         cursor.execute(
331                             'PRAGMA foreign_key_check(%s)'
332                             % self.ops.quote_name(table_name)
333                         ).fetchall()
334                         for table_name in table_names
335                     )
336                 # See https://www.sqlite.org/pragma.html#pragma_foreign_key_check
337                 for table_name, rowid, referenced_table_name, foreign_key_index in violations:
338                     foreign_key = cursor.execute(
339                         'PRAGMA foreign_key_list(%s)' % self.ops.quote_name(table_name)
340                     ).fetchall()[foreign_key_index]
341                     column_name, referenced_column_name = foreign_key[3:5]
342                     primary_key_column_name = self.introspection.get_primary_key_column(cursor, table_name)
343                     primary_key_value, bad_value = cursor.execute(
344                         'SELECT %s, %s FROM %s WHERE rowid = %%s' % (
345                             self.ops.quote_name(primary_key_column_name),
346                             self.ops.quote_name(column_name),
347                             self.ops.quote_name(table_name),
348                         ),
349                         (rowid,),
350                     ).fetchone()
351                     raise IntegrityError(
352                         "The row in table '%s' with primary key '%s' has an "
353                         "invalid foreign key: %s.%s contains a value '%s' that "
354                         "does not have a corresponding value in %s.%s." % (
355                             table_name, primary_key_value, table_name, column_name,
356                             bad_value, referenced_table_name, referenced_column_name
357                         )
358                     )
359         else:
360             with self.cursor() as cursor:
361                 if table_names is None:
362                     table_names = self.introspection.table_names(cursor)
363                 for table_name in table_names:
364                     primary_key_column_name = self.introspection.get_primary_key_column(cursor, table_name)
365                     if not primary_key_column_name:
366                         continue
367                     key_columns = self.introspection.get_key_columns(cursor, table_name)
368                     for column_name, referenced_table_name, referenced_column_name in key_columns:
369                         cursor.execute(
370                             """
371                             SELECT REFERRING.`%s`, REFERRING.`%s` FROM `%s` as REFERRING
372                             LEFT JOIN `%s` as REFERRED
373                             ON (REFERRING.`%s` = REFERRED.`%s`)
374                             WHERE REFERRING.`%s` IS NOT NULL AND REFERRED.`%s` IS NULL
375                             """
376                             % (
377                                 primary_key_column_name, column_name, table_name,
378                                 referenced_table_name, column_name, referenced_column_name,
379                                 column_name, referenced_column_name,
380                             )
381                         )
382                         for bad_row in cursor.fetchall():
383                             raise IntegrityError(
384                                 "The row in table '%s' with primary key '%s' has an "
385                                 "invalid foreign key: %s.%s contains a value '%s' that "
386                                 "does not have a corresponding value in %s.%s." % (
387                                     table_name, bad_row[0], table_name, column_name,
388                                     bad_row[1], referenced_table_name, referenced_column_name,
389                                 )
390                             )
391 
392     def is_usable(self):
393         return True
394 
395     def _start_transaction_under_autocommit(self):
396         """
397         Start a transaction explicitly in autocommit mode.
398 
399         Staying in autocommit mode works around a bug of sqlite3 that breaks
400         savepoints when autocommit is disabled.
401         """
402         self.cursor().execute("BEGIN")
403 
404     def is_in_memory_db(self):
405         return self.creation.is_in_memory_db(self.settings_dict['NAME'])
406 
407 
408 FORMAT_QMARK_REGEX = _lazy_re_compile(r'(?<!%)%s')
409 
410 
411 class SQLiteCursorWrapper(Database.Cursor):
412     """
413     Django uses "format" style placeholders, but pysqlite2 uses "qmark" style.
414     This fixes it -- but note that if you want to use a literal "%s" in a query,
415     you'll need to use "%%s".
416     """
417     def execute(self, query, params=None):
418         if params is None:
419             return Database.Cursor.execute(self, query)
420         query = self.convert_query(query)
421         return Database.Cursor.execute(self, query, params)
422 
423     def executemany(self, query, param_list):
424         query = self.convert_query(query)
425         return Database.Cursor.executemany(self, query, param_list)
426 
427     def convert_query(self, query):
428         return FORMAT_QMARK_REGEX.sub('?', query).replace('%%', '%')
429 
430 
431 def _sqlite_datetime_parse(dt, tzname=None, conn_tzname=None):
432     if dt is None:
433         return None
434     try:
435         dt = backend_utils.typecast_timestamp(dt)
436     except (TypeError, ValueError):
437         return None
438     if conn_tzname:
439         dt = dt.replace(tzinfo=pytz.timezone(conn_tzname))
440     if tzname is not None and tzname != conn_tzname:
441         sign_index = tzname.find('+') + tzname.find('-') + 1
442         if sign_index > -1:
443             sign = tzname[sign_index]
444             tzname, offset = tzname.split(sign)
445             if offset:
446                 hours, minutes = offset.split(':')
447                 offset_delta = datetime.timedelta(hours=int(hours), minutes=int(minutes))
448                 dt += offset_delta if sign == '+' else -offset_delta
449         dt = timezone.localtime(dt, pytz.timezone(tzname))
450     return dt
451 
452 
453 def _sqlite_date_trunc(lookup_type, dt, tzname, conn_tzname):
454     dt = _sqlite_datetime_parse(dt, tzname, conn_tzname)
455     if dt is None:
456         return None
457     if lookup_type == 'year':
458         return "%i-01-01" % dt.year
459     elif lookup_type == 'quarter':
460         month_in_quarter = dt.month - (dt.month - 1) % 3
461         return '%i-%02i-01' % (dt.year, month_in_quarter)
462     elif lookup_type == 'month':
463         return "%i-%02i-01" % (dt.year, dt.month)
464     elif lookup_type == 'week':
465         dt = dt - datetime.timedelta(days=dt.weekday())
466         return "%i-%02i-%02i" % (dt.year, dt.month, dt.day)
467     elif lookup_type == 'day':
468         return "%i-%02i-%02i" % (dt.year, dt.month, dt.day)
469 
470 
471 def _sqlite_time_trunc(lookup_type, dt, tzname, conn_tzname):
472     if dt is None:
473         return None
474     dt_parsed = _sqlite_datetime_parse(dt, tzname, conn_tzname)
475     if dt_parsed is None:
476         try:
477             dt = backend_utils.typecast_time(dt)
478         except (ValueError, TypeError):
479             return None
480     else:
481         dt = dt_parsed
482     if lookup_type == 'hour':
483         return "%02i:00:00" % dt.hour
484     elif lookup_type == 'minute':
485         return "%02i:%02i:00" % (dt.hour, dt.minute)
486     elif lookup_type == 'second':
487         return "%02i:%02i:%02i" % (dt.hour, dt.minute, dt.second)
488 
489 
490 def _sqlite_datetime_cast_date(dt, tzname, conn_tzname):
491     dt = _sqlite_datetime_parse(dt, tzname, conn_tzname)
492     if dt is None:
493         return None
494     return dt.date().isoformat()
495 
496 
497 def _sqlite_datetime_cast_time(dt, tzname, conn_tzname):
498     dt = _sqlite_datetime_parse(dt, tzname, conn_tzname)
499     if dt is None:
500         return None
501     return dt.time().isoformat()
502 
503 
504 def _sqlite_datetime_extract(lookup_type, dt, tzname=None, conn_tzname=None):
505     dt = _sqlite_datetime_parse(dt, tzname, conn_tzname)
506     if dt is None:
507         return None
508     if lookup_type == 'week_day':
509         return (dt.isoweekday() % 7) + 1
510     elif lookup_type == 'iso_week_day':
511         return dt.isoweekday()
512     elif lookup_type == 'week':
513         return dt.isocalendar()[1]
514     elif lookup_type == 'quarter':
515         return math.ceil(dt.month / 3)
516     elif lookup_type == 'iso_year':
517         return dt.isocalendar()[0]
518     else:
519         return getattr(dt, lookup_type)
520 
521 
522 def _sqlite_datetime_trunc(lookup_type, dt, tzname, conn_tzname):
523     dt = _sqlite_datetime_parse(dt, tzname, conn_tzname)
524     if dt is None:
525         return None
526     if lookup_type == 'year':
527         return "%i-01-01 00:00:00" % dt.year
528     elif lookup_type == 'quarter':
529         month_in_quarter = dt.month - (dt.month - 1) % 3
530         return '%i-%02i-01 00:00:00' % (dt.year, month_in_quarter)
531     elif lookup_type == 'month':
532         return "%i-%02i-01 00:00:00" % (dt.year, dt.month)
533     elif lookup_type == 'week':
534         dt = dt - datetime.timedelta(days=dt.weekday())
535         return "%i-%02i-%02i 00:00:00" % (dt.year, dt.month, dt.day)
536     elif lookup_type == 'day':
537         return "%i-%02i-%02i 00:00:00" % (dt.year, dt.month, dt.day)
538     elif lookup_type == 'hour':
539         return "%i-%02i-%02i %02i:00:00" % (dt.year, dt.month, dt.day, dt.hour)
540     elif lookup_type == 'minute':
541         return "%i-%02i-%02i %02i:%02i:00" % (dt.year, dt.month, dt.day, dt.hour, dt.minute)
542     elif lookup_type == 'second':
543         return "%i-%02i-%02i %02i:%02i:%02i" % (dt.year, dt.month, dt.day, dt.hour, dt.minute, dt.second)
544 
545 
546 def _sqlite_time_extract(lookup_type, dt):
547     if dt is None:
548         return None
549     try:
550         dt = backend_utils.typecast_time(dt)
551     except (ValueError, TypeError):
552         return None
553     return getattr(dt, lookup_type)
554 
555 
556 @none_guard
557 def _sqlite_format_dtdelta(conn, lhs, rhs):
558     """
559     LHS and RHS can be either:
560     - An integer number of microseconds
561     - A string representing a datetime
562     """
563     try:
564         real_lhs = datetime.timedelta(0, 0, lhs) if isinstance(lhs, int) else backend_utils.typecast_timestamp(lhs)
565         real_rhs = datetime.timedelta(0, 0, rhs) if isinstance(rhs, int) else backend_utils.typecast_timestamp(rhs)
566         if conn.strip() == '+':
567             out = real_lhs + real_rhs
568         else:
569             out = real_lhs - real_rhs
570     except (ValueError, TypeError):
571         return None
572     # typecast_timestamp returns a date or a datetime without timezone.
573     # It will be formatted as "%Y-%m-%d" or "%Y-%m-%d %H:%M:%S[.%f]"
574     return str(out)
575 
576 
577 @none_guard
578 def _sqlite_time_diff(lhs, rhs):
579     left = backend_utils.typecast_time(lhs)
580     right = backend_utils.typecast_time(rhs)
581     return (
582         (left.hour * 60 * 60 * 1000000) +
583         (left.minute * 60 * 1000000) +
584         (left.second * 1000000) +
585         (left.microsecond) -
586         (right.hour * 60 * 60 * 1000000) -
587         (right.minute * 60 * 1000000) -
588         (right.second * 1000000) -
589         (right.microsecond)
590     )
591 
592 
593 @none_guard
594 def _sqlite_timestamp_diff(lhs, rhs):
595     left = backend_utils.typecast_timestamp(lhs)
596     right = backend_utils.typecast_timestamp(rhs)
597     return duration_microseconds(left - right)
598 
599 
600 @none_guard
601 def _sqlite_regexp(re_pattern, re_string):
602     return bool(re.search(re_pattern, str(re_string)))
603 
604 
605 @none_guard
606 def _sqlite_lpad(text, length, fill_text):
607     if len(text) >= length:
608         return text[:length]
609     return (fill_text * length)[:length - len(text)] + text
610 
611 
612 @none_guard
613 def _sqlite_rpad(text, length, fill_text):
614     return (text + fill_text * length)[:length]

</code><intended_behavior>This file should ensure on initialization or connection to the SQLite database, the version of SQLite is checked to be 3.9.0 or higher, and raise an appropriate error message if not.</intended_behavior>, <file>django/db/backends/sqlite3/schema.py</file>
<class>None</class>
<method>None</method>
<code>
1 import copy
2 from decimal import Decimal
3 
4 from django.apps.registry import Apps
5 from django.db import NotSupportedError
6 from django.db.backends.base.schema import BaseDatabaseSchemaEditor
7 from django.db.backends.ddl_references import Statement
8 from django.db.backends.utils import strip_quotes
9 from django.db.models import UniqueConstraint
10 from django.db.transaction import atomic
11 
12 
13 class DatabaseSchemaEditor(BaseDatabaseSchemaEditor):
14 
15     sql_delete_table = "DROP TABLE %(table)s"
16     sql_create_fk = None
17     sql_create_inline_fk = "REFERENCES %(to_table)s (%(to_column)s) DEFERRABLE INITIALLY DEFERRED"
18     sql_create_unique = "CREATE UNIQUE INDEX %(name)s ON %(table)s (%(columns)s)"
19     sql_delete_unique = "DROP INDEX %(name)s"
20 
21     def __enter__(self):
22         # Some SQLite schema alterations need foreign key constraints to be
23         # disabled. Enforce it here for the duration of the schema edition.
24         if not self.connection.disable_constraint_checking():
25             raise NotSupportedError(
26                 'SQLite schema editor cannot be used while foreign key '
27                 'constraint checks are enabled. Make sure to disable them '
28                 'before entering a transaction.atomic() context because '
29                 'SQLite does not support disabling them in the middle of '
30                 'a multi-statement transaction.'
31             )
32         return super().__enter__()
33 
34     def __exit__(self, exc_type, exc_value, traceback):
35         self.connection.check_constraints()
36         super().__exit__(exc_type, exc_value, traceback)
37         self.connection.enable_constraint_checking()
38 
39     def quote_value(self, value):
40         # The backend "mostly works" without this function and there are use
41         # cases for compiling Python without the sqlite3 libraries (e.g.
42         # security hardening).
43         try:
44             import sqlite3
45             value = sqlite3.adapt(value)
46         except ImportError:
47             pass
48         except sqlite3.ProgrammingError:
49             pass
50         # Manual emulation of SQLite parameter quoting
51         if isinstance(value, bool):
52             return str(int(value))
53         elif isinstance(value, (Decimal, float, int)):
54             return str(value)
55         elif isinstance(value, str):
56             return "'%s'" % value.replace("\'", "\'\'")
57         elif value is None:
58             return "NULL"
59         elif isinstance(value, (bytes, bytearray, memoryview)):
60             # Bytes are only allowed for BLOB fields, encoded as string
61             # literals containing hexadecimal data and preceded by a single "X"
62             # character.
63             return "X'%s'" % value.hex()
64         else:
65             raise ValueError("Cannot quote parameter value %r of type %s" % (value, type(value)))
66 
67     def _is_referenced_by_fk_constraint(self, table_name, column_name=None, ignore_self=False):
68         """
69         Return whether or not the provided table name is referenced by another
70         one. If `column_name` is specified, only references pointing to that
71         column are considered. If `ignore_self` is True, self-referential
72         constraints are ignored.
73         """
74         with self.connection.cursor() as cursor:
75             for other_table in self.connection.introspection.get_table_list(cursor):
76                 if ignore_self and other_table.name == table_name:
77                     continue
78                 constraints = self.connection.introspection._get_foreign_key_constraints(cursor, other_table.name)
79                 for constraint in constraints.values():
80                     constraint_table, constraint_column = constraint['foreign_key']
81                     if (constraint_table == table_name and
82                             (column_name is None or constraint_column == column_name)):
83                         return True
84         return False
85 
86     def alter_db_table(self, model, old_db_table, new_db_table, disable_constraints=True):
87         if (not self.connection.features.supports_atomic_references_rename and
88                 disable_constraints and self._is_referenced_by_fk_constraint(old_db_table)):
89             if self.connection.in_atomic_block:
90                 raise NotSupportedError((
91                     'Renaming the %r table while in a transaction is not '
92                     'supported on SQLite < 3.26 because it would break referential '
93                     'integrity. Try adding `atomic = False` to the Migration class.'
94                 ) % old_db_table)
95             self.connection.enable_constraint_checking()
96             super().alter_db_table(model, old_db_table, new_db_table)
97             self.connection.disable_constraint_checking()
98         else:
99             super().alter_db_table(model, old_db_table, new_db_table)
100 
101     def alter_field(self, model, old_field, new_field, strict=False):
102         if not self._field_should_be_altered(old_field, new_field):
103             return
104         old_field_name = old_field.name
105         table_name = model._meta.db_table
106         _, old_column_name = old_field.get_attname_column()
107         if (new_field.name != old_field_name and
108                 not self.connection.features.supports_atomic_references_rename and
109                 self._is_referenced_by_fk_constraint(table_name, old_column_name, ignore_self=True)):
110             if self.connection.in_atomic_block:
111                 raise NotSupportedError((
112                     'Renaming the %r.%r column while in a transaction is not '
113                     'supported on SQLite < 3.26 because it would break referential '
114                     'integrity. Try adding `atomic = False` to the Migration class.'
115                 ) % (model._meta.db_table, old_field_name))
116             with atomic(self.connection.alias):
117                 super().alter_field(model, old_field, new_field, strict=strict)
118                 # Follow SQLite's documented procedure for performing changes
119                 # that don't affect the on-disk content.
120                 # https://sqlite.org/lang_altertable.html#otheralter
121                 with self.connection.cursor() as cursor:
122                     schema_version = cursor.execute('PRAGMA schema_version').fetchone()[0]
123                     cursor.execute('PRAGMA writable_schema = 1')
124                     references_template = ' REFERENCES "%s" ("%%s") ' % table_name
125                     new_column_name = new_field.get_attname_column()[1]
126                     search = references_template % old_column_name
127                     replacement = references_template % new_column_name
128                     cursor.execute('UPDATE sqlite_master SET sql = replace(sql, %s, %s)', (search, replacement))
129                     cursor.execute('PRAGMA schema_version = %d' % (schema_version + 1))
130                     cursor.execute('PRAGMA writable_schema = 0')
131                     # The integrity check will raise an exception and rollback
132                     # the transaction if the sqlite_master updates corrupt the
133                     # database.
134                     cursor.execute('PRAGMA integrity_check')
135             # Perform a VACUUM to refresh the database representation from
136             # the sqlite_master table.
137             with self.connection.cursor() as cursor:
138                 cursor.execute('VACUUM')
139         else:
140             super().alter_field(model, old_field, new_field, strict=strict)
141 
142     def _remake_table(self, model, create_field=None, delete_field=None, alter_field=None):
143         """
144         Shortcut to transform a model from old_model into new_model
145 
146         This follows the correct procedure to perform non-rename or column
147         addition operations based on SQLite's documentation
148 
149         https://www.sqlite.org/lang_altertable.html#caution
150 
151         The essential steps are:
152           1. Create a table with the updated definition called "new__app_model"
153           2. Copy the data from the existing "app_model" table to the new table
154           3. Drop the "app_model" table
155           4. Rename the "new__app_model" table to "app_model"
156           5. Restore any index of the previous "app_model" table.
157         """
158         # Self-referential fields must be recreated rather than copied from
159         # the old model to ensure their remote_field.field_name doesn't refer
160         # to an altered field.
161         def is_self_referential(f):
162             return f.is_relation and f.remote_field.model is model
163         # Work out the new fields dict / mapping
164         body = {
165             f.name: f.clone() if is_self_referential(f) else f
166             for f in model._meta.local_concrete_fields
167         }
168         # Since mapping might mix column names and default values,
169         # its values must be already quoted.
170         mapping = {f.column: self.quote_name(f.column) for f in model._meta.local_concrete_fields}
171         # This maps field names (not columns) for things like unique_together
172         rename_mapping = {}
173         # If any of the new or altered fields is introducing a new PK,
174         # remove the old one
175         restore_pk_field = None
176         if getattr(create_field, 'primary_key', False) or (
177                 alter_field and getattr(alter_field[1], 'primary_key', False)):
178             for name, field in list(body.items()):
179                 if field.primary_key:
180                     field.primary_key = False
181                     restore_pk_field = field
182                     if field.auto_created:
183                         del body[name]
184                         del mapping[field.column]
185         # Add in any created fields
186         if create_field:
187             body[create_field.name] = create_field
188             # Choose a default and insert it into the copy map
189             if not create_field.many_to_many and create_field.concrete:
190                 mapping[create_field.column] = self.quote_value(
191                     self.effective_default(create_field)
192                 )
193         # Add in any altered fields
194         if alter_field:
195             old_field, new_field = alter_field
196             body.pop(old_field.name, None)
197             mapping.pop(old_field.column, None)
198             body[new_field.name] = new_field
199             if old_field.null and not new_field.null:
200                 case_sql = "coalesce(%(col)s, %(default)s)" % {
201                     'col': self.quote_name(old_field.column),
202                     'default': self.quote_value(self.effective_default(new_field))
203                 }
204                 mapping[new_field.column] = case_sql
205             else:
206                 mapping[new_field.column] = self.quote_name(old_field.column)
207             rename_mapping[old_field.name] = new_field.name
208         # Remove any deleted fields
209         if delete_field:
210             del body[delete_field.name]
211             del mapping[delete_field.column]
212             # Remove any implicit M2M tables
213             if delete_field.many_to_many and delete_field.remote_field.through._meta.auto_created:
214                 return self.delete_model(delete_field.remote_field.through)
215         # Work inside a new app registry
216         apps = Apps()
217 
218         # Work out the new value of unique_together, taking renames into
219         # account
220         unique_together = [
221             [rename_mapping.get(n, n) for n in unique]
222             for unique in model._meta.unique_together
223         ]
224 
225         # Work out the new value for index_together, taking renames into
226         # account
227         index_together = [
228             [rename_mapping.get(n, n) for n in index]
229             for index in model._meta.index_together
230         ]
231 
232         indexes = model._meta.indexes
233         if delete_field:
234             indexes = [
235                 index for index in indexes
236                 if delete_field.name not in index.fields
237             ]
238 
239         constraints = list(model._meta.constraints)
240 
241         # Provide isolated instances of the fields to the new model body so
242         # that the existing model's internals aren't interfered with when
243         # the dummy model is constructed.
244         body_copy = copy.deepcopy(body)
245 
246         # Construct a new model with the new fields to allow self referential
247         # primary key to resolve to. This model won't ever be materialized as a
248         # table and solely exists for foreign key reference resolution purposes.
249         # This wouldn't be required if the schema editor was operating on model
250         # states instead of rendered models.
251         meta_contents = {
252             'app_label': model._meta.app_label,
253             'db_table': model._meta.db_table,
254             'unique_together': unique_together,
255             'index_together': index_together,
256             'indexes': indexes,
257             'constraints': constraints,
258             'apps': apps,
259         }
260         meta = type("Meta", (), meta_contents)
261         body_copy['Meta'] = meta
262         body_copy['__module__'] = model.__module__
263         type(model._meta.object_name, model.__bases__, body_copy)
264 
265         # Construct a model with a renamed table name.
266         body_copy = copy.deepcopy(body)
267         meta_contents = {
268             'app_label': model._meta.app_label,
269             'db_table': 'new__%s' % strip_quotes(model._meta.db_table),
270             'unique_together': unique_together,
271             'index_together': index_together,
272             'indexes': indexes,
273             'constraints': constraints,
274             'apps': apps,
275         }
276         meta = type("Meta", (), meta_contents)
277         body_copy['Meta'] = meta
278         body_copy['__module__'] = model.__module__
279         new_model = type('New%s' % model._meta.object_name, model.__bases__, body_copy)
280 
281         # Create a new table with the updated schema.
282         self.create_model(new_model)
283 
284         # Copy data from the old table into the new table
285         self.execute("INSERT INTO %s (%s) SELECT %s FROM %s" % (
286             self.quote_name(new_model._meta.db_table),
287             ', '.join(self.quote_name(x) for x in mapping),
288             ', '.join(mapping.values()),
289             self.quote_name(model._meta.db_table),
290         ))
291 
292         # Delete the old table to make way for the new
293         self.delete_model(model, handle_autom2m=False)
294 
295         # Rename the new table to take way for the old
296         self.alter_db_table(
297             new_model, new_model._meta.db_table, model._meta.db_table,
298             disable_constraints=False,
299         )
300 
301         # Run deferred SQL on correct table
302         for sql in self.deferred_sql:
303             self.execute(sql)
304         self.deferred_sql = []
305         # Fix any PK-removed field
306         if restore_pk_field:
307             restore_pk_field.primary_key = True
308 
309     def delete_model(self, model, handle_autom2m=True):
310         if handle_autom2m:
311             super().delete_model(model)
312         else:
313             # Delete the table (and only that)
314             self.execute(self.sql_delete_table % {
315                 "table": self.quote_name(model._meta.db_table),
316             })
317             # Remove all deferred statements referencing the deleted table.
318             for sql in list(self.deferred_sql):
319                 if isinstance(sql, Statement) and sql.references_table(model._meta.db_table):
320                     self.deferred_sql.remove(sql)
321 
322     def add_field(self, model, field):
323         """
324         Create a field on a model. Usually involves adding a column, but may
325         involve adding a table instead (for M2M fields).
326         """
327         # Special-case implicit M2M tables
328         if field.many_to_many and field.remote_field.through._meta.auto_created:
329             return self.create_model(field.remote_field.through)
330         self._remake_table(model, create_field=field)
331 
332     def remove_field(self, model, field):
333         """
334         Remove a field from a model. Usually involves deleting a column,
335         but for M2Ms may involve deleting a table.
336         """
337         # M2M fields are a special case
338         if field.many_to_many:
339             # For implicit M2M tables, delete the auto-created table
340             if field.remote_field.through._meta.auto_created:
341                 self.delete_model(field.remote_field.through)
342             # For explicit "through" M2M fields, do nothing
343         # For everything else, remake.
344         else:
345             # It might not actually have a column behind it
346             if field.db_parameters(connection=self.connection)['type'] is None:
347                 return
348             self._remake_table(model, delete_field=field)
349 
350     def _alter_field(self, model, old_field, new_field, old_type, new_type,
351                      old_db_params, new_db_params, strict=False):
352         """Perform a "physical" (non-ManyToMany) field update."""
353         # Use "ALTER TABLE ... RENAME COLUMN" if only the column name
354         # changed and there aren't any constraints.
355         if (self.connection.features.can_alter_table_rename_column and
356             old_field.column != new_field.column and
357             self.column_sql(model, old_field) == self.column_sql(model, new_field) and
358             not (old_field.remote_field and old_field.db_constraint or
359                  new_field.remote_field and new_field.db_constraint)):
360             return self.execute(self._rename_field_sql(model._meta.db_table, old_field, new_field, new_type))
361         # Alter by remaking table
362         self._remake_table(model, alter_field=(old_field, new_field))
363         # Rebuild tables with FKs pointing to this field.
364         if new_field.unique and old_type != new_type:
365             related_models = set()
366             opts = new_field.model._meta
367             for remote_field in opts.related_objects:
368                 # Ignore self-relationship since the table was already rebuilt.
369                 if remote_field.related_model == model:
370                     continue
371                 if not remote_field.many_to_many:
372                     if remote_field.field_name == new_field.name:
373                         related_models.add(remote_field.related_model)
374                 elif new_field.primary_key and remote_field.through._meta.auto_created:
375                     related_models.add(remote_field.through)
376             if new_field.primary_key:
377                 for many_to_many in opts.many_to_many:
378                     # Ignore self-relationship since the table was already rebuilt.
379                     if many_to_many.related_model == model:
380                         continue
381                     if many_to_many.remote_field.through._meta.auto_created:
382                         related_models.add(many_to_many.remote_field.through)
383             for related_model in related_models:
384                 self._remake_table(related_model)
385 
386     def _alter_many_to_many(self, model, old_field, new_field, strict):
387         """Alter M2Ms to repoint their to= endpoints."""
388         if old_field.remote_field.through._meta.db_table == new_field.remote_field.through._meta.db_table:
389             # The field name didn't change, but some options did; we have to propagate this altering.
390             self._remake_table(
391                 old_field.remote_field.through,
392                 alter_field=(
393                     # We need the field that points to the target model, so we can tell alter_field to change it -
394                     # this is m2m_reverse_field_name() (as opposed to m2m_field_name, which points to our model)
395                     old_field.remote_field.through._meta.get_field(old_field.m2m_reverse_field_name()),
396                     new_field.remote_field.through._meta.get_field(new_field.m2m_reverse_field_name()),
397                 ),
398             )
399             return
400 
401         # Make a new through table
402         self.create_model(new_field.remote_field.through)
403         # Copy the data across
404         self.execute("INSERT INTO %s (%s) SELECT %s FROM %s" % (
405             self.quote_name(new_field.remote_field.through._meta.db_table),
406             ', '.join([
407                 "id",
408                 new_field.m2m_column_name(),
409                 new_field.m2m_reverse_name(),
410             ]),
411             ', '.join([
412                 "id",
413                 old_field.m2m_column_name(),
414                 old_field.m2m_reverse_name(),
415             ]),
416             self.quote_name(old_field.remote_field.through._meta.db_table),
417         ))
418         # Delete the old through table
419         self.delete_model(old_field.remote_field.through)
420 
421     def add_constraint(self, model, constraint):
422         if isinstance(constraint, UniqueConstraint) and constraint.condition:
423             super().add_constraint(model, constraint)
424         else:
425             self._remake_table(model)
426 
427     def remove_constraint(self, model, constraint):
428         if isinstance(constraint, UniqueConstraint) and constraint.condition:
429             super().remove_constraint(model, constraint)
430         else:
431             self._remake_table(model)
432 
433     def _collate_sql(self, collation):
434         return ' COLLATE ' + collation

</code><intended_behavior>This file should be updated to use features like indexes on expressions in SQLite 3.9.0 directly, removing checks or conditional logic for supporting older versions.</intended_behavior>]
2025-10-18 12:30:52.001 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-18 12:30:52.001 | INFO     | Search-only: skipping patch selection
2025-10-18 12:30:52.138 | INFO     | Task django__django-13821 completed successfully.
2025-10-18 12:30:52.140 | INFO     | No patch generated. You can try running ACR again.
