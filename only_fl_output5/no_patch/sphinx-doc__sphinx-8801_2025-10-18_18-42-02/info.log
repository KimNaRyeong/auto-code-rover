2025-10-18 18:42:02.654 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-18 18:42:06.538 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=317, output_tokens=12, cost=0.003530
2025-10-18 18:42:22.355 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=497, output_tokens=611, cost=0.023300
2025-10-18 18:42:23.568 | INFO     | registered non reproducing test 0
2025-10-18 18:42:40.719 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1492, output_tokens=823, cost=0.039610
2025-10-18 18:42:41.905 | INFO     | registered non reproducing test 1
2025-10-18 18:42:58.497 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2208, output_tokens=730, cost=0.043980
2025-10-18 18:42:59.905 | INFO     | registered non reproducing test 2
2025-10-18 18:42:59.905 | WARNING  | Failed to write a reproducer test; skipping reproducer tracing
2025-10-18 18:42:59.908 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 18:43:09.305 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=618, output_tokens=379, cost=0.017550
2025-10-18 18:43:09.312 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 18:43:11.751 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=733, output_tokens=30, cost=0.008230
2025-10-18 18:43:11.753 | DEBUG    | Extracted a valid json.
2025-10-18 18:43:11.753 | DEBUG    | Agent proxy return the following json: {
    "API_calls": ["search_class(\"Documenter\")", "search_method(\"autoclass\")"],
    "bug_locations": []
}
2025-10-18 18:43:11.788 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-18 18:43:11.789 | DEBUG    | <Agent search> Analyzing search results.
2025-10-18 18:43:28.278 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1736, output_tokens=691, cost=0.038090
2025-10-18 18:43:28.291 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 18:43:38.860 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2643, output_tokens=498, cost=0.041370
2025-10-18 18:43:38.870 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 18:43:47.299 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=852, output_tokens=309, cost=0.017790
2025-10-18 18:43:47.300 | DEBUG    | Extracted a valid json.
2025-10-18 18:43:47.300 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_method_in_file(\"filter_members\", \"sphinx/ext/autodoc/__init__.py\")",
        "search_method_in_file(\"get_object_members\", \"sphinx/ext/autodoc/__init__.py\")"
    ],
    "bug_locations": [
        {
            "file": "sphinx/ext/autodoc/__init__.py",
            "class": "Documenter",
            "method": "filter_members",
            "intended_behavior": "This method should be updated or extended to accurately recognize and include annotation-only members in superclasses as documented. This involves adjusting the criteria used to filter members for documentation, ensuring that an annotation, specifically in the context of inheritance, is sufficient for a member to be considered documented. The method should preserve its existing functionality for all other scenarios, ensuring that only the handling of annotation-only inherited members is affected."
        },
        {
            "file": "sphinx/ext/autodoc/__init__.py",
            "class": "Documenter",
            "method": "get_object_members",
            "intended_behavior": "This method might need adjustments to correctly and explicitly fetch inherited members from superclasses, ensuring that it provides accurate information on which members are available and their documentation status. The update should ensure that inherited members with only annotations (and optional comments) are correctly identified and passed along for potential documentation, without altering the method's ability to correctly handle members defined directly within the class."
        }
    ]
}
2025-10-18 18:43:47.390 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-18 18:43:47.390 | DEBUG    | <Agent search> Analyzing search results.
2025-10-18 18:44:05.073 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=7922, output_tokens=719, cost=0.100790
2025-10-18 18:44:05.086 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 18:44:18.323 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=8857, output_tokens=485, cost=0.103120
2025-10-18 18:44:18.333 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 18:44:29.733 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=839, output_tokens=353, cost=0.018980
2025-10-18 18:44:29.734 | DEBUG    | Extracted a valid json.
2025-10-18 18:44:29.734 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "sphinx/ext/autodoc/__init__.py",
            "class": "Documenter",
            "method": "filter_members",
            "intended_behavior": "This method should be updated to ensure that annotation-only members in superclasses are not treated as undocumented, provided they are meant to be included (e.g., through `:inherited-members:` option). Specifically, the logic that determines member documentation status should take into account the existence of annotations as a valid form of documentation, particularly for inherited members. This may entail: Adjusting the `is_filtered_inherited_member` logic to consider members with only annotations (and optionally, associated comments) as documented. Ensuring that such members are not filtered out if the `undoc-members` option is not set, reflecting a broader definition of what is considered \"documented\"."
        },
        {
            "file": "sphinx/ext/autodoc/__init__.py",
            "class": "Documenter",
            "method": "get_object_members",
            "intended_behavior": "Modifications here should ensure that the method correctly identifies and flags inherited annotation-only members for documentation. This includes: Improving how members are identified and marked as \"inherited\". This might require updating the conditionals that check if a member should be included based on `want_all` and `options.inherited_members` settings. Ensuring that annotation-only members are recognized as part of the object's members when `inherited_members` is active, possibly by augmenting how members are collected and processed (e.g., considering annotation presence as a criterion for inclusion)."
        }
    ]
}
2025-10-18 18:44:29.745 | DEBUG    | Bug location extracted successfully: [<file>sphinx/ext/autodoc/__init__.py</file>
<class>Documenter</class>
<method>filter_members</method>
<code>
664     def filter_members(self, members: ObjectMembers, want_all: bool
665                        ) -> List[Tuple[str, Any, bool]]:
666         """Filter the given member list.
667 
668         Members are skipped if
669 
670         - they are private (except if given explicitly or the private-members
671           option is set)
672         - they are special methods (except if given explicitly or the
673           special-members option is set)
674         - they are undocumented (except if the undoc-members option is set)
675 
676         The user can override the skipping decision by connecting to the
677         ``autodoc-skip-member`` event.
678         """
679         def is_filtered_inherited_member(name: str, obj: Any) -> bool:
680             if inspect.isclass(self.object):
681                 for cls in self.object.__mro__:
682                     if cls.__name__ == self.options.inherited_members and cls != self.object:
683                         # given member is a member of specified *super class*
684                         return True
685                     elif name in cls.__dict__:
686                         return False
687                     elif name in self.get_attr(cls, '__annotations__', {}):
688                         return False
689                     elif isinstance(obj, ObjectMember) and obj.class_ is cls:
690                         return False
691 
692             return False
693 
694         ret = []
695 
696         # search for members in source code too
697         namespace = '.'.join(self.objpath)  # will be empty for modules
698 
699         if self.analyzer:
700             attr_docs = self.analyzer.find_attr_docs()
701         else:
702             attr_docs = {}
703 
704         # process members and determine which to skip
705         for obj in members:
706             membername, member = obj
707             # if isattr is True, the member is documented as an attribute
708             if member is INSTANCEATTR:
709                 isattr = True
710             else:
711                 isattr = False
712 
713             doc = getdoc(member, self.get_attr, self.config.autodoc_inherit_docstrings,
714                          self.parent, self.object_name)
715             if not isinstance(doc, str):
716                 # Ignore non-string __doc__
717                 doc = None
718 
719             # if the member __doc__ is the same as self's __doc__, it's just
720             # inherited and therefore not the member's doc
721             cls = self.get_attr(member, '__class__', None)
722             if cls:
723                 cls_doc = self.get_attr(cls, '__doc__', None)
724                 if cls_doc == doc:
725                     doc = None
726 
727             if isinstance(obj, ObjectMember) and obj.docstring:
728                 # hack for ClassDocumenter to inject docstring via ObjectMember
729                 doc = obj.docstring
730 
731             has_doc = bool(doc)
732 
733             metadata = extract_metadata(doc)
734             if 'private' in metadata:
735                 # consider a member private if docstring has "private" metadata
736                 isprivate = True
737             elif 'public' in metadata:
738                 # consider a member public if docstring has "public" metadata
739                 isprivate = False
740             else:
741                 isprivate = membername.startswith('_')
742 
743             keep = False
744             if ismock(member):
745                 # mocked module or object
746                 pass
747             elif self.options.exclude_members and membername in self.options.exclude_members:
748                 # remove members given by exclude-members
749                 keep = False
750             elif want_all and special_member_re.match(membername):
751                 # special __methods__
752                 if self.options.special_members and membername in self.options.special_members:
753                     if membername == '__doc__':
754                         keep = False
755                     elif is_filtered_inherited_member(membername, obj):
756                         keep = False
757                     else:
758                         keep = has_doc or self.options.undoc_members
759                 else:
760                     keep = False
761             elif (namespace, membername) in attr_docs:
762                 if want_all and isprivate:
763                     if self.options.private_members is None:
764                         keep = False
765                     else:
766                         keep = membername in self.options.private_members
767                 else:
768                     # keep documented attributes
769                     keep = True
770                 isattr = True
771             elif want_all and isprivate:
772                 if has_doc or self.options.undoc_members:
773                     if self.options.private_members is None:
774                         keep = False
775                     elif is_filtered_inherited_member(membername, obj):
776                         keep = False
777                     else:
778                         keep = membername in self.options.private_members
779                 else:
780                     keep = False
781             else:
782                 if (self.options.members is ALL and
783                         is_filtered_inherited_member(membername, obj)):
784                     keep = False
785                 else:
786                     # ignore undocumented members if :undoc-members: is not given
787                     keep = has_doc or self.options.undoc_members
788 
789             if isinstance(obj, ObjectMember) and obj.skipped:
790                 # forcedly skipped member (ex. a module attribute not defined in __all__)
791                 keep = False
792 
793             # give the user a chance to decide whether this member
794             # should be skipped
795             if self.env.app:
796                 # let extensions preprocess docstrings
797                 try:
798                     skip_user = self.env.app.emit_firstresult(
799                         'autodoc-skip-member', self.objtype, membername, member,
800                         not keep, self.options)
801                     if skip_user is not None:
802                         keep = not skip_user
803                 except Exception as exc:
804                     logger.warning(__('autodoc: failed to determine %r to be documented, '
805                                       'the following exception was raised:\n%s'),
806                                    member, exc, type='autodoc')
807                     keep = False
808 
809             if keep:
810                 ret.append((membername, member, isattr))
811 
812         return ret

</code><intended_behavior>This method should be updated to ensure that annotation-only members in superclasses are not treated as undocumented, provided they are meant to be included (e.g., through `:inherited-members:` option). Specifically, the logic that determines member documentation status should take into account the existence of annotations as a valid form of documentation, particularly for inherited members. This may entail: Adjusting the `is_filtered_inherited_member` logic to consider members with only annotations (and optionally, associated comments) as documented. Ensuring that such members are not filtered out if the `undoc-members` option is not set, reflecting a broader definition of what is considered "documented".</intended_behavior>, <file>sphinx/ext/autodoc/__init__.py</file>
<class>Documenter</class>
<method>None</method>
<code>
289 class Documenter:
290     """
291     A Documenter knows how to autodocument a single object type.  When
292     registered with the AutoDirective, it will be used to document objects
293     of that type when needed by autodoc.
294 
295     Its *objtype* attribute selects what auto directive it is assigned to
296     (the directive name is 'auto' + objtype), and what directive it generates
297     by default, though that can be overridden by an attribute called
298     *directivetype*.
299 
300     A Documenter has an *option_spec* that works like a docutils directive's;
301     in fact, it will be used to parse an auto directive's options that matches
302     the documenter.
303     """
304     #: name by which the directive is called (auto...) and the default
305     #: generated directive name
306     objtype = 'object'
307     #: indentation by which to indent the directive content
308     content_indent = '   '
309     #: priority if multiple documenters return True from can_document_member
310     priority = 0
311     #: order if autodoc_member_order is set to 'groupwise'
312     member_order = 0
313     #: true if the generated content may contain titles
314     titles_allowed = False
315 
316     option_spec = {'noindex': bool_option}  # type: Dict[str, Callable]
317 
318     def get_attr(self, obj: Any, name: str, *defargs: Any) -> Any:
319         """getattr() override for types such as Zope interfaces."""
320         return autodoc_attrgetter(self.env.app, obj, name, *defargs)
321 
322     @classmethod
323     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
324                             ) -> bool:
325         """Called to see if a member can be documented by this documenter."""
326         raise NotImplementedError('must be implemented in subclasses')
327 
328     def __init__(self, directive: "DocumenterBridge", name: str, indent: str = '') -> None:
329         self.directive = directive
330         self.config = directive.env.config
331         self.env = directive.env    # type: BuildEnvironment
332         self.options = directive.genopt
333         self.name = name
334         self.indent = indent
335         # the module and object path within the module, and the fully
336         # qualified name (all set after resolve_name succeeds)
337         self.modname = None         # type: str
338         self.module = None          # type: ModuleType
339         self.objpath = None         # type: List[str]
340         self.fullname = None        # type: str
341         # extra signature items (arguments and return annotation,
342         # also set after resolve_name succeeds)
343         self.args = None            # type: str
344         self.retann = None          # type: str
345         # the object to document (set after import_object succeeds)
346         self.object = None          # type: Any
347         self.object_name = None     # type: str
348         # the parent/owner of the object to document
349         self.parent = None          # type: Any
350         # the module analyzer to get at attribute docs, or None
351         self.analyzer = None        # type: ModuleAnalyzer
352 
353     @property
354     def documenters(self) -> Dict[str, "Type[Documenter]"]:
355         """Returns registered Documenter classes"""
356         return self.env.app.registry.documenters
357 
358     def add_line(self, line: str, source: str, *lineno: int) -> None:
359         """Append one line of generated reST to the output."""
360         if line.strip():  # not a blank line
361             self.directive.result.append(self.indent + line, source, *lineno)
362         else:
363             self.directive.result.append('', source, *lineno)
364 
365     def resolve_name(self, modname: str, parents: Any, path: str, base: Any
366                      ) -> Tuple[str, List[str]]:
367         """Resolve the module and name of the object to document given by the
368         arguments and the current module/class.
369 
370         Must return a pair of the module name and a chain of attributes; for
371         example, it would return ``('zipfile', ['ZipFile', 'open'])`` for the
372         ``zipfile.ZipFile.open`` method.
373         """
374         raise NotImplementedError('must be implemented in subclasses')
375 
376     def parse_name(self) -> bool:
377         """Determine what module to import and what attribute to document.
378 
379         Returns True and sets *self.modname*, *self.objpath*, *self.fullname*,
380         *self.args* and *self.retann* if parsing and resolving was successful.
381         """
382         # first, parse the definition -- auto directives for classes and
383         # functions can contain a signature which is then used instead of
384         # an autogenerated one
385         try:
386             explicit_modname, path, base, args, retann = \
387                 py_ext_sig_re.match(self.name).groups()
388         except AttributeError:
389             logger.warning(__('invalid signature for auto%s (%r)') % (self.objtype, self.name),
390                            type='autodoc')
391             return False
392 
393         # support explicit module and class name separation via ::
394         if explicit_modname is not None:
395             modname = explicit_modname[:-2]
396             parents = path.rstrip('.').split('.') if path else []
397         else:
398             modname = None
399             parents = []
400 
401         with mock(self.config.autodoc_mock_imports):
402             self.modname, self.objpath = self.resolve_name(modname, parents, path, base)
403 
404         if not self.modname:
405             return False
406 
407         self.args = args
408         self.retann = retann
409         self.fullname = (self.modname or '') + \
410                         ('.' + '.'.join(self.objpath) if self.objpath else '')
411         return True
412 
413     def import_object(self, raiseerror: bool = False) -> bool:
414         """Import the object given by *self.modname* and *self.objpath* and set
415         it as *self.object*.
416 
417         Returns True if successful, False if an error occurred.
418         """
419         with mock(self.config.autodoc_mock_imports):
420             try:
421                 ret = import_object(self.modname, self.objpath, self.objtype,
422                                     attrgetter=self.get_attr,
423                                     warningiserror=self.config.autodoc_warningiserror)
424                 self.module, self.parent, self.object_name, self.object = ret
425                 if ismock(self.object):
426                     self.object = undecorate(self.object)
427                 return True
428             except ImportError as exc:
429                 if raiseerror:
430                     raise
431                 else:
432                     logger.warning(exc.args[0], type='autodoc', subtype='import_object')
433                     self.env.note_reread()
434                     return False
435 
436     def get_real_modname(self) -> str:
437         """Get the real module name of an object to document.
438 
439         It can differ from the name of the module through which the object was
440         imported.
441         """
442         return self.get_attr(self.object, '__module__', None) or self.modname
443 
444     def check_module(self) -> bool:
445         """Check if *self.object* is really defined in the module given by
446         *self.modname*.
447         """
448         if self.options.imported_members:
449             return True
450 
451         subject = inspect.unpartial(self.object)
452         modname = self.get_attr(subject, '__module__', None)
453         if modname and modname != self.modname:
454             return False
455         return True
456 
457     def format_args(self, **kwargs: Any) -> str:
458         """Format the argument signature of *self.object*.
459 
460         Should return None if the object does not have a signature.
461         """
462         return None
463 
464     def format_name(self) -> str:
465         """Format the name of *self.object*.
466 
467         This normally should be something that can be parsed by the generated
468         directive, but doesn't need to be (Sphinx will display it unparsed
469         then).
470         """
471         # normally the name doesn't contain the module (except for module
472         # directives of course)
473         return '.'.join(self.objpath) or self.modname
474 
475     def _call_format_args(self, **kwargs: Any) -> str:
476         if kwargs:
477             try:
478                 return self.format_args(**kwargs)
479             except TypeError:
480                 # avoid chaining exceptions, by putting nothing here
481                 pass
482 
483         # retry without arguments for old documenters
484         return self.format_args()
485 
486     def format_signature(self, **kwargs: Any) -> str:
487         """Format the signature (arguments and return annotation) of the object.
488 
489         Let the user process it via the ``autodoc-process-signature`` event.
490         """
491         if self.args is not None:
492             # signature given explicitly
493             args = "(%s)" % self.args
494             retann = self.retann
495         else:
496             # try to introspect the signature
497             try:
498                 retann = None
499                 args = self._call_format_args(**kwargs)
500                 if args:
501                     matched = re.match(r'^(\(.*\))\s+->\s+(.*)$', args)
502                     if matched:
503                         args = matched.group(1)
504                         retann = matched.group(2)
505             except Exception as exc:
506                 logger.warning(__('error while formatting arguments for %s: %s'),
507                                self.fullname, exc, type='autodoc')
508                 args = None
509 
510         result = self.env.events.emit_firstresult('autodoc-process-signature',
511                                                   self.objtype, self.fullname,
512                                                   self.object, self.options, args, retann)
513         if result:
514             args, retann = result
515 
516         if args is not None:
517             return args + ((' -> %s' % retann) if retann else '')
518         else:
519             return ''
520 
521     def add_directive_header(self, sig: str) -> None:
522         """Add the directive header and options to the generated content."""
523         domain = getattr(self, 'domain', 'py')
524         directive = getattr(self, 'directivetype', self.objtype)
525         name = self.format_name()
526         sourcename = self.get_sourcename()
527 
528         # one signature per line, indented by column
529         prefix = '.. %s:%s:: ' % (domain, directive)
530         for i, sig_line in enumerate(sig.split("\n")):
531             self.add_line('%s%s%s' % (prefix, name, sig_line),
532                           sourcename)
533             if i == 0:
534                 prefix = " " * len(prefix)
535 
536         if self.options.noindex:
537             self.add_line('   :noindex:', sourcename)
538         if self.objpath:
539             # Be explicit about the module, this is necessary since .. class::
540             # etc. don't support a prepended module name
541             self.add_line('   :module: %s' % self.modname, sourcename)
542 
543     def get_doc(self, encoding: str = None, ignore: int = None) -> Optional[List[List[str]]]:
544         """Decode and return lines of the docstring(s) for the object.
545 
546         When it returns None value, autodoc-process-docstring will not be called for this
547         object.
548         """
549         if encoding is not None:
550             warnings.warn("The 'encoding' argument to autodoc.%s.get_doc() is deprecated."
551                           % self.__class__.__name__,
552                           RemovedInSphinx40Warning, stacklevel=2)
553         if ignore is not None:
554             warnings.warn("The 'ignore' argument to autodoc.%s.get_doc() is deprecated."
555                           % self.__class__.__name__,
556                           RemovedInSphinx50Warning, stacklevel=2)
557         docstring = getdoc(self.object, self.get_attr, self.config.autodoc_inherit_docstrings,
558                            self.parent, self.object_name)
559         if docstring:
560             tab_width = self.directive.state.document.settings.tab_width
561             return [prepare_docstring(docstring, ignore, tab_width)]
562         return []
563 
564     def process_doc(self, docstrings: List[List[str]]) -> Iterator[str]:
565         """Let the user process the docstrings before adding them."""
566         for docstringlines in docstrings:
567             if self.env.app:
568                 # let extensions preprocess docstrings
569                 self.env.app.emit('autodoc-process-docstring',
570                                   self.objtype, self.fullname, self.object,
571                                   self.options, docstringlines)
572 
573                 if docstringlines and docstringlines[-1] != '':
574                     # append a blank line to the end of the docstring
575                     docstringlines.append('')
576 
577             yield from docstringlines
578 
579     def get_sourcename(self) -> str:
580         if (getattr(self.object, '__module__', None) and
581                 getattr(self.object, '__qualname__', None)):
582             # Get the correct location of docstring from self.object
583             # to support inherited methods
584             fullname = '%s.%s' % (self.object.__module__, self.object.__qualname__)
585         else:
586             fullname = self.fullname
587 
588         if self.analyzer:
589             return '%s:docstring of %s' % (self.analyzer.srcname, fullname)
590         else:
591             return 'docstring of %s' % fullname
592 
593     def add_content(self, more_content: Optional[StringList], no_docstring: bool = False
594                     ) -> None:
595         """Add content from docstrings, attribute documentation and user."""
596         if no_docstring:
597             warnings.warn("The 'no_docstring' argument to %s.add_content() is deprecated."
598                           % self.__class__.__name__,
599                           RemovedInSphinx50Warning, stacklevel=2)
600 
601         # set sourcename and add content from attribute documentation
602         sourcename = self.get_sourcename()
603         if self.analyzer:
604             attr_docs = self.analyzer.find_attr_docs()
605             if self.objpath:
606                 key = ('.'.join(self.objpath[:-1]), self.objpath[-1])
607                 if key in attr_docs:
608                     no_docstring = True
609                     # make a copy of docstring for attributes to avoid cache
610                     # the change of autodoc-process-docstring event.
611                     docstrings = [list(attr_docs[key])]
612 
613                     for i, line in enumerate(self.process_doc(docstrings)):
614                         self.add_line(line, sourcename, i)
615 
616         # add content from docstrings
617         if not no_docstring:
618             docstrings = self.get_doc()
619             if docstrings is None:
620                 # Do not call autodoc-process-docstring on get_doc() returns None.
621                 pass
622             else:
623                 if not docstrings:
624                     # append at least a dummy docstring, so that the event
625                     # autodoc-process-docstring is fired and can add some
626                     # content if desired
627                     docstrings.append([])
628                 for i, line in enumerate(self.process_doc(docstrings)):
629                     self.add_line(line, sourcename, i)
630 
631         # add additional content (e.g. from document), if present
632         if more_content:
633             for line, src in zip(more_content.data, more_content.items):
634                 self.add_line(line, src[0], src[1])
635 
636     def get_object_members(self, want_all: bool) -> Tuple[bool, ObjectMembers]:
637         """Return `(members_check_module, members)` where `members` is a
638         list of `(membername, member)` pairs of the members of *self.object*.
639 
640         If *want_all* is True, return all members.  Else, only return those
641         members given by *self.options.members* (which may also be none).
642         """
643         warnings.warn('The implementation of Documenter.get_object_members() will be '
644                       'removed from Sphinx-6.0.', RemovedInSphinx60Warning)
645         members = get_object_members(self.object, self.objpath, self.get_attr, self.analyzer)
646         if not want_all:
647             if not self.options.members:
648                 return False, []  # type: ignore
649             # specific members given
650             selected = []
651             for name in self.options.members:  # type: str
652                 if name in members:
653                     selected.append((name, members[name].value))
654                 else:
655                     logger.warning(__('missing attribute %s in object %s') %
656                                    (name, self.fullname), type='autodoc')
657             return False, selected
658         elif self.options.inherited_members:
659             return False, [(m.name, m.value) for m in members.values()]
660         else:
661             return False, [(m.name, m.value) for m in members.values()
662                            if m.directly_defined]
663 
664     def filter_members(self, members: ObjectMembers, want_all: bool
665                        ) -> List[Tuple[str, Any, bool]]:
666         """Filter the given member list.
667 
668         Members are skipped if
669 
670         - they are private (except if given explicitly or the private-members
671           option is set)
672         - they are special methods (except if given explicitly or the
673           special-members option is set)
674         - they are undocumented (except if the undoc-members option is set)
675 
676         The user can override the skipping decision by connecting to the
677         ``autodoc-skip-member`` event.
678         """
679         def is_filtered_inherited_member(name: str, obj: Any) -> bool:
680             if inspect.isclass(self.object):
681                 for cls in self.object.__mro__:
682                     if cls.__name__ == self.options.inherited_members and cls != self.object:
683                         # given member is a member of specified *super class*
684                         return True
685                     elif name in cls.__dict__:
686                         return False
687                     elif name in self.get_attr(cls, '__annotations__', {}):
688                         return False
689                     elif isinstance(obj, ObjectMember) and obj.class_ is cls:
690                         return False
691 
692             return False
693 
694         ret = []
695 
696         # search for members in source code too
697         namespace = '.'.join(self.objpath)  # will be empty for modules
698 
699         if self.analyzer:
700             attr_docs = self.analyzer.find_attr_docs()
701         else:
702             attr_docs = {}
703 
704         # process members and determine which to skip
705         for obj in members:
706             membername, member = obj
707             # if isattr is True, the member is documented as an attribute
708             if member is INSTANCEATTR:
709                 isattr = True
710             else:
711                 isattr = False
712 
713             doc = getdoc(member, self.get_attr, self.config.autodoc_inherit_docstrings,
714                          self.parent, self.object_name)
715             if not isinstance(doc, str):
716                 # Ignore non-string __doc__
717                 doc = None
718 
719             # if the member __doc__ is the same as self's __doc__, it's just
720             # inherited and therefore not the member's doc
721             cls = self.get_attr(member, '__class__', None)
722             if cls:
723                 cls_doc = self.get_attr(cls, '__doc__', None)
724                 if cls_doc == doc:
725                     doc = None
726 
727             if isinstance(obj, ObjectMember) and obj.docstring:
728                 # hack for ClassDocumenter to inject docstring via ObjectMember
729                 doc = obj.docstring
730 
731             has_doc = bool(doc)
732 
733             metadata = extract_metadata(doc)
734             if 'private' in metadata:
735                 # consider a member private if docstring has "private" metadata
736                 isprivate = True
737             elif 'public' in metadata:
738                 # consider a member public if docstring has "public" metadata
739                 isprivate = False
740             else:
741                 isprivate = membername.startswith('_')
742 
743             keep = False
744             if ismock(member):
745                 # mocked module or object
746                 pass
747             elif self.options.exclude_members and membername in self.options.exclude_members:
748                 # remove members given by exclude-members
749                 keep = False
750             elif want_all and special_member_re.match(membername):
751                 # special __methods__
752                 if self.options.special_members and membername in self.options.special_members:
753                     if membername == '__doc__':
754                         keep = False
755                     elif is_filtered_inherited_member(membername, obj):
756                         keep = False
757                     else:
758                         keep = has_doc or self.options.undoc_members
759                 else:
760                     keep = False
761             elif (namespace, membername) in attr_docs:
762                 if want_all and isprivate:
763                     if self.options.private_members is None:
764                         keep = False
765                     else:
766                         keep = membername in self.options.private_members
767                 else:
768                     # keep documented attributes
769                     keep = True
770                 isattr = True
771             elif want_all and isprivate:
772                 if has_doc or self.options.undoc_members:
773                     if self.options.private_members is None:
774                         keep = False
775                     elif is_filtered_inherited_member(membername, obj):
776                         keep = False
777                     else:
778                         keep = membername in self.options.private_members
779                 else:
780                     keep = False
781             else:
782                 if (self.options.members is ALL and
783                         is_filtered_inherited_member(membername, obj)):
784                     keep = False
785                 else:
786                     # ignore undocumented members if :undoc-members: is not given
787                     keep = has_doc or self.options.undoc_members
788 
789             if isinstance(obj, ObjectMember) and obj.skipped:
790                 # forcedly skipped member (ex. a module attribute not defined in __all__)
791                 keep = False
792 
793             # give the user a chance to decide whether this member
794             # should be skipped
795             if self.env.app:
796                 # let extensions preprocess docstrings
797                 try:
798                     skip_user = self.env.app.emit_firstresult(
799                         'autodoc-skip-member', self.objtype, membername, member,
800                         not keep, self.options)
801                     if skip_user is not None:
802                         keep = not skip_user
803                 except Exception as exc:
804                     logger.warning(__('autodoc: failed to determine %r to be documented, '
805                                       'the following exception was raised:\n%s'),
806                                    member, exc, type='autodoc')
807                     keep = False
808 
809             if keep:
810                 ret.append((membername, member, isattr))
811 
812         return ret
813 
814     def document_members(self, all_members: bool = False) -> None:
815         """Generate reST for member documentation.
816 
817         If *all_members* is True, do all members, else those given by
818         *self.options.members*.
819         """
820         # set current namespace for finding members
821         self.env.temp_data['autodoc:module'] = self.modname
822         if self.objpath:
823             self.env.temp_data['autodoc:class'] = self.objpath[0]
824 
825         want_all = all_members or self.options.inherited_members or \
826             self.options.members is ALL
827         # find out which members are documentable
828         members_check_module, members = self.get_object_members(want_all)
829 
830         # document non-skipped members
831         memberdocumenters = []  # type: List[Tuple[Documenter, bool]]
832         for (mname, member, isattr) in self.filter_members(members, want_all):
833             classes = [cls for cls in self.documenters.values()
834                        if cls.can_document_member(member, mname, isattr, self)]
835             if not classes:
836                 # don't know how to document this member
837                 continue
838             # prefer the documenter with the highest priority
839             classes.sort(key=lambda cls: cls.priority)
840             # give explicitly separated module name, so that members
841             # of inner classes can be documented
842             full_mname = self.modname + '::' + \
843                 '.'.join(self.objpath + [mname])
844             documenter = classes[-1](self.directive, full_mname, self.indent)
845             memberdocumenters.append((documenter, isattr))
846 
847         member_order = self.options.member_order or self.config.autodoc_member_order
848         memberdocumenters = self.sort_members(memberdocumenters, member_order)
849 
850         for documenter, isattr in memberdocumenters:
851             documenter.generate(
852                 all_members=True, real_modname=self.real_modname,
853                 check_module=members_check_module and not isattr)
854 
855         # reset current objects
856         self.env.temp_data['autodoc:module'] = None
857         self.env.temp_data['autodoc:class'] = None
858 
859     def sort_members(self, documenters: List[Tuple["Documenter", bool]],
860                      order: str) -> List[Tuple["Documenter", bool]]:
861         """Sort the given member list."""
862         if order == 'groupwise':
863             # sort by group; alphabetically within groups
864             documenters.sort(key=lambda e: (e[0].member_order, e[0].name))
865         elif order == 'bysource':
866             if self.analyzer:
867                 # sort by source order, by virtue of the module analyzer
868                 tagorder = self.analyzer.tagorder
869 
870                 def keyfunc(entry: Tuple[Documenter, bool]) -> int:
871                     fullname = entry[0].name.split('::')[1]
872                     return tagorder.get(fullname, len(tagorder))
873                 documenters.sort(key=keyfunc)
874             else:
875                 # Assume that member discovery order matches source order.
876                 # This is a reasonable assumption in Python 3.6 and up, where
877                 # module.__dict__ is insertion-ordered.
878                 pass
879         else:  # alphabetical
880             documenters.sort(key=lambda e: e[0].name)
881 
882         return documenters
883 
884     def generate(self, more_content: Optional[StringList] = None, real_modname: str = None,
885                  check_module: bool = False, all_members: bool = False) -> None:
886         """Generate reST for the object given by *self.name*, and possibly for
887         its members.
888 
889         If *more_content* is given, include that content. If *real_modname* is
890         given, use that module name to find attribute docs. If *check_module* is
891         True, only generate if the object is defined in the module name it is
892         imported from. If *all_members* is True, document all members.
893         """
894         if not self.parse_name():
895             # need a module to import
896             logger.warning(
897                 __('don\'t know which module to import for autodocumenting '
898                    '%r (try placing a "module" or "currentmodule" directive '
899                    'in the document, or giving an explicit module name)') %
900                 self.name, type='autodoc')
901             return
902 
903         # now, import the module and get object to document
904         if not self.import_object():
905             return
906 
907         # If there is no real module defined, figure out which to use.
908         # The real module is used in the module analyzer to look up the module
909         # where the attribute documentation would actually be found in.
910         # This is used for situations where you have a module that collects the
911         # functions and classes of internal submodules.
912         guess_modname = self.get_real_modname()
913         self.real_modname = real_modname or guess_modname
914 
915         # try to also get a source code analyzer for attribute docs
916         try:
917             self.analyzer = ModuleAnalyzer.for_module(self.real_modname)
918             # parse right now, to get PycodeErrors on parsing (results will
919             # be cached anyway)
920             self.analyzer.find_attr_docs()
921         except PycodeError as exc:
922             logger.debug('[autodoc] module analyzer failed: %s', exc)
923             # no source file -- e.g. for builtin and C modules
924             self.analyzer = None
925             # at least add the module.__file__ as a dependency
926             if hasattr(self.module, '__file__') and self.module.__file__:
927                 self.directive.filename_set.add(self.module.__file__)
928         else:
929             self.directive.filename_set.add(self.analyzer.srcname)
930 
931         if self.real_modname != guess_modname:
932             # Add module to dependency list if target object is defined in other module.
933             try:
934                 analyzer = ModuleAnalyzer.for_module(guess_modname)
935                 self.directive.filename_set.add(analyzer.srcname)
936             except PycodeError:
937                 pass
938 
939         # check __module__ of object (for members not given explicitly)
940         if check_module:
941             if not self.check_module():
942                 return
943 
944         sourcename = self.get_sourcename()
945 
946         # make sure that the result starts with an empty line.  This is
947         # necessary for some situations where another directive preprocesses
948         # reST and no starting newline is present
949         self.add_line('', sourcename)
950 
951         # format the object's signature, if any
952         try:
953             sig = self.format_signature()
954         except Exception as exc:
955             logger.warning(__('error while formatting signature for %s: %s'),
956                            self.fullname, exc, type='autodoc')
957             return
958 
959         # generate the directive header and options, if applicable
960         self.add_directive_header(sig)
961         self.add_line('', sourcename)
962 
963         # e.g. the module directive doesn't have content
964         self.indent += self.content_indent
965 
966         # add all content (from docstrings, attribute docs etc.)
967         self.add_content(more_content)
968 
969         # document members, if possible
970         self.document_members(all_members)

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>, <file>sphinx/ext/autodoc/__init__.py</file>
<class>Documenter</class>
<method>get_object_members</method>
<code>
636     def get_object_members(self, want_all: bool) -> Tuple[bool, ObjectMembers]:
637         """Return `(members_check_module, members)` where `members` is a
638         list of `(membername, member)` pairs of the members of *self.object*.
639 
640         If *want_all* is True, return all members.  Else, only return those
641         members given by *self.options.members* (which may also be none).
642         """
643         warnings.warn('The implementation of Documenter.get_object_members() will be '
644                       'removed from Sphinx-6.0.', RemovedInSphinx60Warning)
645         members = get_object_members(self.object, self.objpath, self.get_attr, self.analyzer)
646         if not want_all:
647             if not self.options.members:
648                 return False, []  # type: ignore
649             # specific members given
650             selected = []
651             for name in self.options.members:  # type: str
652                 if name in members:
653                     selected.append((name, members[name].value))
654                 else:
655                     logger.warning(__('missing attribute %s in object %s') %
656                                    (name, self.fullname), type='autodoc')
657             return False, selected
658         elif self.options.inherited_members:
659             return False, [(m.name, m.value) for m in members.values()]
660         else:
661             return False, [(m.name, m.value) for m in members.values()
662                            if m.directly_defined]

</code><intended_behavior>Modifications here should ensure that the method correctly identifies and flags inherited annotation-only members for documentation. This includes: Improving how members are identified and marked as "inherited". This might require updating the conditionals that check if a member should be included based on `want_all` and `options.inherited_members` settings. Ensuring that annotation-only members are recognized as part of the object's members when `inherited_members` is active, possibly by augmenting how members are collected and processed (e.g., considering annotation presence as a criterion for inclusion).</intended_behavior>, <file>sphinx/ext/autodoc/__init__.py</file>
<class>Documenter</class>
<method>None</method>
<code>
289 class Documenter:
290     """
291     A Documenter knows how to autodocument a single object type.  When
292     registered with the AutoDirective, it will be used to document objects
293     of that type when needed by autodoc.
294 
295     Its *objtype* attribute selects what auto directive it is assigned to
296     (the directive name is 'auto' + objtype), and what directive it generates
297     by default, though that can be overridden by an attribute called
298     *directivetype*.
299 
300     A Documenter has an *option_spec* that works like a docutils directive's;
301     in fact, it will be used to parse an auto directive's options that matches
302     the documenter.
303     """
304     #: name by which the directive is called (auto...) and the default
305     #: generated directive name
306     objtype = 'object'
307     #: indentation by which to indent the directive content
308     content_indent = '   '
309     #: priority if multiple documenters return True from can_document_member
310     priority = 0
311     #: order if autodoc_member_order is set to 'groupwise'
312     member_order = 0
313     #: true if the generated content may contain titles
314     titles_allowed = False
315 
316     option_spec = {'noindex': bool_option}  # type: Dict[str, Callable]
317 
318     def get_attr(self, obj: Any, name: str, *defargs: Any) -> Any:
319         """getattr() override for types such as Zope interfaces."""
320         return autodoc_attrgetter(self.env.app, obj, name, *defargs)
321 
322     @classmethod
323     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
324                             ) -> bool:
325         """Called to see if a member can be documented by this documenter."""
326         raise NotImplementedError('must be implemented in subclasses')
327 
328     def __init__(self, directive: "DocumenterBridge", name: str, indent: str = '') -> None:
329         self.directive = directive
330         self.config = directive.env.config
331         self.env = directive.env    # type: BuildEnvironment
332         self.options = directive.genopt
333         self.name = name
334         self.indent = indent
335         # the module and object path within the module, and the fully
336         # qualified name (all set after resolve_name succeeds)
337         self.modname = None         # type: str
338         self.module = None          # type: ModuleType
339         self.objpath = None         # type: List[str]
340         self.fullname = None        # type: str
341         # extra signature items (arguments and return annotation,
342         # also set after resolve_name succeeds)
343         self.args = None            # type: str
344         self.retann = None          # type: str
345         # the object to document (set after import_object succeeds)
346         self.object = None          # type: Any
347         self.object_name = None     # type: str
348         # the parent/owner of the object to document
349         self.parent = None          # type: Any
350         # the module analyzer to get at attribute docs, or None
351         self.analyzer = None        # type: ModuleAnalyzer
352 
353     @property
354     def documenters(self) -> Dict[str, "Type[Documenter]"]:
355         """Returns registered Documenter classes"""
356         return self.env.app.registry.documenters
357 
358     def add_line(self, line: str, source: str, *lineno: int) -> None:
359         """Append one line of generated reST to the output."""
360         if line.strip():  # not a blank line
361             self.directive.result.append(self.indent + line, source, *lineno)
362         else:
363             self.directive.result.append('', source, *lineno)
364 
365     def resolve_name(self, modname: str, parents: Any, path: str, base: Any
366                      ) -> Tuple[str, List[str]]:
367         """Resolve the module and name of the object to document given by the
368         arguments and the current module/class.
369 
370         Must return a pair of the module name and a chain of attributes; for
371         example, it would return ``('zipfile', ['ZipFile', 'open'])`` for the
372         ``zipfile.ZipFile.open`` method.
373         """
374         raise NotImplementedError('must be implemented in subclasses')
375 
376     def parse_name(self) -> bool:
377         """Determine what module to import and what attribute to document.
378 
379         Returns True and sets *self.modname*, *self.objpath*, *self.fullname*,
380         *self.args* and *self.retann* if parsing and resolving was successful.
381         """
382         # first, parse the definition -- auto directives for classes and
383         # functions can contain a signature which is then used instead of
384         # an autogenerated one
385         try:
386             explicit_modname, path, base, args, retann = \
387                 py_ext_sig_re.match(self.name).groups()
388         except AttributeError:
389             logger.warning(__('invalid signature for auto%s (%r)') % (self.objtype, self.name),
390                            type='autodoc')
391             return False
392 
393         # support explicit module and class name separation via ::
394         if explicit_modname is not None:
395             modname = explicit_modname[:-2]
396             parents = path.rstrip('.').split('.') if path else []
397         else:
398             modname = None
399             parents = []
400 
401         with mock(self.config.autodoc_mock_imports):
402             self.modname, self.objpath = self.resolve_name(modname, parents, path, base)
403 
404         if not self.modname:
405             return False
406 
407         self.args = args
408         self.retann = retann
409         self.fullname = (self.modname or '') + \
410                         ('.' + '.'.join(self.objpath) if self.objpath else '')
411         return True
412 
413     def import_object(self, raiseerror: bool = False) -> bool:
414         """Import the object given by *self.modname* and *self.objpath* and set
415         it as *self.object*.
416 
417         Returns True if successful, False if an error occurred.
418         """
419         with mock(self.config.autodoc_mock_imports):
420             try:
421                 ret = import_object(self.modname, self.objpath, self.objtype,
422                                     attrgetter=self.get_attr,
423                                     warningiserror=self.config.autodoc_warningiserror)
424                 self.module, self.parent, self.object_name, self.object = ret
425                 if ismock(self.object):
426                     self.object = undecorate(self.object)
427                 return True
428             except ImportError as exc:
429                 if raiseerror:
430                     raise
431                 else:
432                     logger.warning(exc.args[0], type='autodoc', subtype='import_object')
433                     self.env.note_reread()
434                     return False
435 
436     def get_real_modname(self) -> str:
437         """Get the real module name of an object to document.
438 
439         It can differ from the name of the module through which the object was
440         imported.
441         """
442         return self.get_attr(self.object, '__module__', None) or self.modname
443 
444     def check_module(self) -> bool:
445         """Check if *self.object* is really defined in the module given by
446         *self.modname*.
447         """
448         if self.options.imported_members:
449             return True
450 
451         subject = inspect.unpartial(self.object)
452         modname = self.get_attr(subject, '__module__', None)
453         if modname and modname != self.modname:
454             return False
455         return True
456 
457     def format_args(self, **kwargs: Any) -> str:
458         """Format the argument signature of *self.object*.
459 
460         Should return None if the object does not have a signature.
461         """
462         return None
463 
464     def format_name(self) -> str:
465         """Format the name of *self.object*.
466 
467         This normally should be something that can be parsed by the generated
468         directive, but doesn't need to be (Sphinx will display it unparsed
469         then).
470         """
471         # normally the name doesn't contain the module (except for module
472         # directives of course)
473         return '.'.join(self.objpath) or self.modname
474 
475     def _call_format_args(self, **kwargs: Any) -> str:
476         if kwargs:
477             try:
478                 return self.format_args(**kwargs)
479             except TypeError:
480                 # avoid chaining exceptions, by putting nothing here
481                 pass
482 
483         # retry without arguments for old documenters
484         return self.format_args()
485 
486     def format_signature(self, **kwargs: Any) -> str:
487         """Format the signature (arguments and return annotation) of the object.
488 
489         Let the user process it via the ``autodoc-process-signature`` event.
490         """
491         if self.args is not None:
492             # signature given explicitly
493             args = "(%s)" % self.args
494             retann = self.retann
495         else:
496             # try to introspect the signature
497             try:
498                 retann = None
499                 args = self._call_format_args(**kwargs)
500                 if args:
501                     matched = re.match(r'^(\(.*\))\s+->\s+(.*)$', args)
502                     if matched:
503                         args = matched.group(1)
504                         retann = matched.group(2)
505             except Exception as exc:
506                 logger.warning(__('error while formatting arguments for %s: %s'),
507                                self.fullname, exc, type='autodoc')
508                 args = None
509 
510         result = self.env.events.emit_firstresult('autodoc-process-signature',
511                                                   self.objtype, self.fullname,
512                                                   self.object, self.options, args, retann)
513         if result:
514             args, retann = result
515 
516         if args is not None:
517             return args + ((' -> %s' % retann) if retann else '')
518         else:
519             return ''
520 
521     def add_directive_header(self, sig: str) -> None:
522         """Add the directive header and options to the generated content."""
523         domain = getattr(self, 'domain', 'py')
524         directive = getattr(self, 'directivetype', self.objtype)
525         name = self.format_name()
526         sourcename = self.get_sourcename()
527 
528         # one signature per line, indented by column
529         prefix = '.. %s:%s:: ' % (domain, directive)
530         for i, sig_line in enumerate(sig.split("\n")):
531             self.add_line('%s%s%s' % (prefix, name, sig_line),
532                           sourcename)
533             if i == 0:
534                 prefix = " " * len(prefix)
535 
536         if self.options.noindex:
537             self.add_line('   :noindex:', sourcename)
538         if self.objpath:
539             # Be explicit about the module, this is necessary since .. class::
540             # etc. don't support a prepended module name
541             self.add_line('   :module: %s' % self.modname, sourcename)
542 
543     def get_doc(self, encoding: str = None, ignore: int = None) -> Optional[List[List[str]]]:
544         """Decode and return lines of the docstring(s) for the object.
545 
546         When it returns None value, autodoc-process-docstring will not be called for this
547         object.
548         """
549         if encoding is not None:
550             warnings.warn("The 'encoding' argument to autodoc.%s.get_doc() is deprecated."
551                           % self.__class__.__name__,
552                           RemovedInSphinx40Warning, stacklevel=2)
553         if ignore is not None:
554             warnings.warn("The 'ignore' argument to autodoc.%s.get_doc() is deprecated."
555                           % self.__class__.__name__,
556                           RemovedInSphinx50Warning, stacklevel=2)
557         docstring = getdoc(self.object, self.get_attr, self.config.autodoc_inherit_docstrings,
558                            self.parent, self.object_name)
559         if docstring:
560             tab_width = self.directive.state.document.settings.tab_width
561             return [prepare_docstring(docstring, ignore, tab_width)]
562         return []
563 
564     def process_doc(self, docstrings: List[List[str]]) -> Iterator[str]:
565         """Let the user process the docstrings before adding them."""
566         for docstringlines in docstrings:
567             if self.env.app:
568                 # let extensions preprocess docstrings
569                 self.env.app.emit('autodoc-process-docstring',
570                                   self.objtype, self.fullname, self.object,
571                                   self.options, docstringlines)
572 
573                 if docstringlines and docstringlines[-1] != '':
574                     # append a blank line to the end of the docstring
575                     docstringlines.append('')
576 
577             yield from docstringlines
578 
579     def get_sourcename(self) -> str:
580         if (getattr(self.object, '__module__', None) and
581                 getattr(self.object, '__qualname__', None)):
582             # Get the correct location of docstring from self.object
583             # to support inherited methods
584             fullname = '%s.%s' % (self.object.__module__, self.object.__qualname__)
585         else:
586             fullname = self.fullname
587 
588         if self.analyzer:
589             return '%s:docstring of %s' % (self.analyzer.srcname, fullname)
590         else:
591             return 'docstring of %s' % fullname
592 
593     def add_content(self, more_content: Optional[StringList], no_docstring: bool = False
594                     ) -> None:
595         """Add content from docstrings, attribute documentation and user."""
596         if no_docstring:
597             warnings.warn("The 'no_docstring' argument to %s.add_content() is deprecated."
598                           % self.__class__.__name__,
599                           RemovedInSphinx50Warning, stacklevel=2)
600 
601         # set sourcename and add content from attribute documentation
602         sourcename = self.get_sourcename()
603         if self.analyzer:
604             attr_docs = self.analyzer.find_attr_docs()
605             if self.objpath:
606                 key = ('.'.join(self.objpath[:-1]), self.objpath[-1])
607                 if key in attr_docs:
608                     no_docstring = True
609                     # make a copy of docstring for attributes to avoid cache
610                     # the change of autodoc-process-docstring event.
611                     docstrings = [list(attr_docs[key])]
612 
613                     for i, line in enumerate(self.process_doc(docstrings)):
614                         self.add_line(line, sourcename, i)
615 
616         # add content from docstrings
617         if not no_docstring:
618             docstrings = self.get_doc()
619             if docstrings is None:
620                 # Do not call autodoc-process-docstring on get_doc() returns None.
621                 pass
622             else:
623                 if not docstrings:
624                     # append at least a dummy docstring, so that the event
625                     # autodoc-process-docstring is fired and can add some
626                     # content if desired
627                     docstrings.append([])
628                 for i, line in enumerate(self.process_doc(docstrings)):
629                     self.add_line(line, sourcename, i)
630 
631         # add additional content (e.g. from document), if present
632         if more_content:
633             for line, src in zip(more_content.data, more_content.items):
634                 self.add_line(line, src[0], src[1])
635 
636     def get_object_members(self, want_all: bool) -> Tuple[bool, ObjectMembers]:
637         """Return `(members_check_module, members)` where `members` is a
638         list of `(membername, member)` pairs of the members of *self.object*.
639 
640         If *want_all* is True, return all members.  Else, only return those
641         members given by *self.options.members* (which may also be none).
642         """
643         warnings.warn('The implementation of Documenter.get_object_members() will be '
644                       'removed from Sphinx-6.0.', RemovedInSphinx60Warning)
645         members = get_object_members(self.object, self.objpath, self.get_attr, self.analyzer)
646         if not want_all:
647             if not self.options.members:
648                 return False, []  # type: ignore
649             # specific members given
650             selected = []
651             for name in self.options.members:  # type: str
652                 if name in members:
653                     selected.append((name, members[name].value))
654                 else:
655                     logger.warning(__('missing attribute %s in object %s') %
656                                    (name, self.fullname), type='autodoc')
657             return False, selected
658         elif self.options.inherited_members:
659             return False, [(m.name, m.value) for m in members.values()]
660         else:
661             return False, [(m.name, m.value) for m in members.values()
662                            if m.directly_defined]
663 
664     def filter_members(self, members: ObjectMembers, want_all: bool
665                        ) -> List[Tuple[str, Any, bool]]:
666         """Filter the given member list.
667 
668         Members are skipped if
669 
670         - they are private (except if given explicitly or the private-members
671           option is set)
672         - they are special methods (except if given explicitly or the
673           special-members option is set)
674         - they are undocumented (except if the undoc-members option is set)
675 
676         The user can override the skipping decision by connecting to the
677         ``autodoc-skip-member`` event.
678         """
679         def is_filtered_inherited_member(name: str, obj: Any) -> bool:
680             if inspect.isclass(self.object):
681                 for cls in self.object.__mro__:
682                     if cls.__name__ == self.options.inherited_members and cls != self.object:
683                         # given member is a member of specified *super class*
684                         return True
685                     elif name in cls.__dict__:
686                         return False
687                     elif name in self.get_attr(cls, '__annotations__', {}):
688                         return False
689                     elif isinstance(obj, ObjectMember) and obj.class_ is cls:
690                         return False
691 
692             return False
693 
694         ret = []
695 
696         # search for members in source code too
697         namespace = '.'.join(self.objpath)  # will be empty for modules
698 
699         if self.analyzer:
700             attr_docs = self.analyzer.find_attr_docs()
701         else:
702             attr_docs = {}
703 
704         # process members and determine which to skip
705         for obj in members:
706             membername, member = obj
707             # if isattr is True, the member is documented as an attribute
708             if member is INSTANCEATTR:
709                 isattr = True
710             else:
711                 isattr = False
712 
713             doc = getdoc(member, self.get_attr, self.config.autodoc_inherit_docstrings,
714                          self.parent, self.object_name)
715             if not isinstance(doc, str):
716                 # Ignore non-string __doc__
717                 doc = None
718 
719             # if the member __doc__ is the same as self's __doc__, it's just
720             # inherited and therefore not the member's doc
721             cls = self.get_attr(member, '__class__', None)
722             if cls:
723                 cls_doc = self.get_attr(cls, '__doc__', None)
724                 if cls_doc == doc:
725                     doc = None
726 
727             if isinstance(obj, ObjectMember) and obj.docstring:
728                 # hack for ClassDocumenter to inject docstring via ObjectMember
729                 doc = obj.docstring
730 
731             has_doc = bool(doc)
732 
733             metadata = extract_metadata(doc)
734             if 'private' in metadata:
735                 # consider a member private if docstring has "private" metadata
736                 isprivate = True
737             elif 'public' in metadata:
738                 # consider a member public if docstring has "public" metadata
739                 isprivate = False
740             else:
741                 isprivate = membername.startswith('_')
742 
743             keep = False
744             if ismock(member):
745                 # mocked module or object
746                 pass
747             elif self.options.exclude_members and membername in self.options.exclude_members:
748                 # remove members given by exclude-members
749                 keep = False
750             elif want_all and special_member_re.match(membername):
751                 # special __methods__
752                 if self.options.special_members and membername in self.options.special_members:
753                     if membername == '__doc__':
754                         keep = False
755                     elif is_filtered_inherited_member(membername, obj):
756                         keep = False
757                     else:
758                         keep = has_doc or self.options.undoc_members
759                 else:
760                     keep = False
761             elif (namespace, membername) in attr_docs:
762                 if want_all and isprivate:
763                     if self.options.private_members is None:
764                         keep = False
765                     else:
766                         keep = membername in self.options.private_members
767                 else:
768                     # keep documented attributes
769                     keep = True
770                 isattr = True
771             elif want_all and isprivate:
772                 if has_doc or self.options.undoc_members:
773                     if self.options.private_members is None:
774                         keep = False
775                     elif is_filtered_inherited_member(membername, obj):
776                         keep = False
777                     else:
778                         keep = membername in self.options.private_members
779                 else:
780                     keep = False
781             else:
782                 if (self.options.members is ALL and
783                         is_filtered_inherited_member(membername, obj)):
784                     keep = False
785                 else:
786                     # ignore undocumented members if :undoc-members: is not given
787                     keep = has_doc or self.options.undoc_members
788 
789             if isinstance(obj, ObjectMember) and obj.skipped:
790                 # forcedly skipped member (ex. a module attribute not defined in __all__)
791                 keep = False
792 
793             # give the user a chance to decide whether this member
794             # should be skipped
795             if self.env.app:
796                 # let extensions preprocess docstrings
797                 try:
798                     skip_user = self.env.app.emit_firstresult(
799                         'autodoc-skip-member', self.objtype, membername, member,
800                         not keep, self.options)
801                     if skip_user is not None:
802                         keep = not skip_user
803                 except Exception as exc:
804                     logger.warning(__('autodoc: failed to determine %r to be documented, '
805                                       'the following exception was raised:\n%s'),
806                                    member, exc, type='autodoc')
807                     keep = False
808 
809             if keep:
810                 ret.append((membername, member, isattr))
811 
812         return ret
813 
814     def document_members(self, all_members: bool = False) -> None:
815         """Generate reST for member documentation.
816 
817         If *all_members* is True, do all members, else those given by
818         *self.options.members*.
819         """
820         # set current namespace for finding members
821         self.env.temp_data['autodoc:module'] = self.modname
822         if self.objpath:
823             self.env.temp_data['autodoc:class'] = self.objpath[0]
824 
825         want_all = all_members or self.options.inherited_members or \
826             self.options.members is ALL
827         # find out which members are documentable
828         members_check_module, members = self.get_object_members(want_all)
829 
830         # document non-skipped members
831         memberdocumenters = []  # type: List[Tuple[Documenter, bool]]
832         for (mname, member, isattr) in self.filter_members(members, want_all):
833             classes = [cls for cls in self.documenters.values()
834                        if cls.can_document_member(member, mname, isattr, self)]
835             if not classes:
836                 # don't know how to document this member
837                 continue
838             # prefer the documenter with the highest priority
839             classes.sort(key=lambda cls: cls.priority)
840             # give explicitly separated module name, so that members
841             # of inner classes can be documented
842             full_mname = self.modname + '::' + \
843                 '.'.join(self.objpath + [mname])
844             documenter = classes[-1](self.directive, full_mname, self.indent)
845             memberdocumenters.append((documenter, isattr))
846 
847         member_order = self.options.member_order or self.config.autodoc_member_order
848         memberdocumenters = self.sort_members(memberdocumenters, member_order)
849 
850         for documenter, isattr in memberdocumenters:
851             documenter.generate(
852                 all_members=True, real_modname=self.real_modname,
853                 check_module=members_check_module and not isattr)
854 
855         # reset current objects
856         self.env.temp_data['autodoc:module'] = None
857         self.env.temp_data['autodoc:class'] = None
858 
859     def sort_members(self, documenters: List[Tuple["Documenter", bool]],
860                      order: str) -> List[Tuple["Documenter", bool]]:
861         """Sort the given member list."""
862         if order == 'groupwise':
863             # sort by group; alphabetically within groups
864             documenters.sort(key=lambda e: (e[0].member_order, e[0].name))
865         elif order == 'bysource':
866             if self.analyzer:
867                 # sort by source order, by virtue of the module analyzer
868                 tagorder = self.analyzer.tagorder
869 
870                 def keyfunc(entry: Tuple[Documenter, bool]) -> int:
871                     fullname = entry[0].name.split('::')[1]
872                     return tagorder.get(fullname, len(tagorder))
873                 documenters.sort(key=keyfunc)
874             else:
875                 # Assume that member discovery order matches source order.
876                 # This is a reasonable assumption in Python 3.6 and up, where
877                 # module.__dict__ is insertion-ordered.
878                 pass
879         else:  # alphabetical
880             documenters.sort(key=lambda e: e[0].name)
881 
882         return documenters
883 
884     def generate(self, more_content: Optional[StringList] = None, real_modname: str = None,
885                  check_module: bool = False, all_members: bool = False) -> None:
886         """Generate reST for the object given by *self.name*, and possibly for
887         its members.
888 
889         If *more_content* is given, include that content. If *real_modname* is
890         given, use that module name to find attribute docs. If *check_module* is
891         True, only generate if the object is defined in the module name it is
892         imported from. If *all_members* is True, document all members.
893         """
894         if not self.parse_name():
895             # need a module to import
896             logger.warning(
897                 __('don\'t know which module to import for autodocumenting '
898                    '%r (try placing a "module" or "currentmodule" directive '
899                    'in the document, or giving an explicit module name)') %
900                 self.name, type='autodoc')
901             return
902 
903         # now, import the module and get object to document
904         if not self.import_object():
905             return
906 
907         # If there is no real module defined, figure out which to use.
908         # The real module is used in the module analyzer to look up the module
909         # where the attribute documentation would actually be found in.
910         # This is used for situations where you have a module that collects the
911         # functions and classes of internal submodules.
912         guess_modname = self.get_real_modname()
913         self.real_modname = real_modname or guess_modname
914 
915         # try to also get a source code analyzer for attribute docs
916         try:
917             self.analyzer = ModuleAnalyzer.for_module(self.real_modname)
918             # parse right now, to get PycodeErrors on parsing (results will
919             # be cached anyway)
920             self.analyzer.find_attr_docs()
921         except PycodeError as exc:
922             logger.debug('[autodoc] module analyzer failed: %s', exc)
923             # no source file -- e.g. for builtin and C modules
924             self.analyzer = None
925             # at least add the module.__file__ as a dependency
926             if hasattr(self.module, '__file__') and self.module.__file__:
927                 self.directive.filename_set.add(self.module.__file__)
928         else:
929             self.directive.filename_set.add(self.analyzer.srcname)
930 
931         if self.real_modname != guess_modname:
932             # Add module to dependency list if target object is defined in other module.
933             try:
934                 analyzer = ModuleAnalyzer.for_module(guess_modname)
935                 self.directive.filename_set.add(analyzer.srcname)
936             except PycodeError:
937                 pass
938 
939         # check __module__ of object (for members not given explicitly)
940         if check_module:
941             if not self.check_module():
942                 return
943 
944         sourcename = self.get_sourcename()
945 
946         # make sure that the result starts with an empty line.  This is
947         # necessary for some situations where another directive preprocesses
948         # reST and no starting newline is present
949         self.add_line('', sourcename)
950 
951         # format the object's signature, if any
952         try:
953             sig = self.format_signature()
954         except Exception as exc:
955             logger.warning(__('error while formatting signature for %s: %s'),
956                            self.fullname, exc, type='autodoc')
957             return
958 
959         # generate the directive header and options, if applicable
960         self.add_directive_header(sig)
961         self.add_line('', sourcename)
962 
963         # e.g. the module directive doesn't have content
964         self.indent += self.content_indent
965 
966         # add all content (from docstrings, attribute docs etc.)
967         self.add_content(more_content)
968 
969         # document members, if possible
970         self.document_members(all_members)

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>]
2025-10-18 18:44:29.745 | INFO     | Search completed. Bug locations: [<file>sphinx/ext/autodoc/__init__.py</file>
<class>Documenter</class>
<method>filter_members</method>
<code>
664     def filter_members(self, members: ObjectMembers, want_all: bool
665                        ) -> List[Tuple[str, Any, bool]]:
666         """Filter the given member list.
667 
668         Members are skipped if
669 
670         - they are private (except if given explicitly or the private-members
671           option is set)
672         - they are special methods (except if given explicitly or the
673           special-members option is set)
674         - they are undocumented (except if the undoc-members option is set)
675 
676         The user can override the skipping decision by connecting to the
677         ``autodoc-skip-member`` event.
678         """
679         def is_filtered_inherited_member(name: str, obj: Any) -> bool:
680             if inspect.isclass(self.object):
681                 for cls in self.object.__mro__:
682                     if cls.__name__ == self.options.inherited_members and cls != self.object:
683                         # given member is a member of specified *super class*
684                         return True
685                     elif name in cls.__dict__:
686                         return False
687                     elif name in self.get_attr(cls, '__annotations__', {}):
688                         return False
689                     elif isinstance(obj, ObjectMember) and obj.class_ is cls:
690                         return False
691 
692             return False
693 
694         ret = []
695 
696         # search for members in source code too
697         namespace = '.'.join(self.objpath)  # will be empty for modules
698 
699         if self.analyzer:
700             attr_docs = self.analyzer.find_attr_docs()
701         else:
702             attr_docs = {}
703 
704         # process members and determine which to skip
705         for obj in members:
706             membername, member = obj
707             # if isattr is True, the member is documented as an attribute
708             if member is INSTANCEATTR:
709                 isattr = True
710             else:
711                 isattr = False
712 
713             doc = getdoc(member, self.get_attr, self.config.autodoc_inherit_docstrings,
714                          self.parent, self.object_name)
715             if not isinstance(doc, str):
716                 # Ignore non-string __doc__
717                 doc = None
718 
719             # if the member __doc__ is the same as self's __doc__, it's just
720             # inherited and therefore not the member's doc
721             cls = self.get_attr(member, '__class__', None)
722             if cls:
723                 cls_doc = self.get_attr(cls, '__doc__', None)
724                 if cls_doc == doc:
725                     doc = None
726 
727             if isinstance(obj, ObjectMember) and obj.docstring:
728                 # hack for ClassDocumenter to inject docstring via ObjectMember
729                 doc = obj.docstring
730 
731             has_doc = bool(doc)
732 
733             metadata = extract_metadata(doc)
734             if 'private' in metadata:
735                 # consider a member private if docstring has "private" metadata
736                 isprivate = True
737             elif 'public' in metadata:
738                 # consider a member public if docstring has "public" metadata
739                 isprivate = False
740             else:
741                 isprivate = membername.startswith('_')
742 
743             keep = False
744             if ismock(member):
745                 # mocked module or object
746                 pass
747             elif self.options.exclude_members and membername in self.options.exclude_members:
748                 # remove members given by exclude-members
749                 keep = False
750             elif want_all and special_member_re.match(membername):
751                 # special __methods__
752                 if self.options.special_members and membername in self.options.special_members:
753                     if membername == '__doc__':
754                         keep = False
755                     elif is_filtered_inherited_member(membername, obj):
756                         keep = False
757                     else:
758                         keep = has_doc or self.options.undoc_members
759                 else:
760                     keep = False
761             elif (namespace, membername) in attr_docs:
762                 if want_all and isprivate:
763                     if self.options.private_members is None:
764                         keep = False
765                     else:
766                         keep = membername in self.options.private_members
767                 else:
768                     # keep documented attributes
769                     keep = True
770                 isattr = True
771             elif want_all and isprivate:
772                 if has_doc or self.options.undoc_members:
773                     if self.options.private_members is None:
774                         keep = False
775                     elif is_filtered_inherited_member(membername, obj):
776                         keep = False
777                     else:
778                         keep = membername in self.options.private_members
779                 else:
780                     keep = False
781             else:
782                 if (self.options.members is ALL and
783                         is_filtered_inherited_member(membername, obj)):
784                     keep = False
785                 else:
786                     # ignore undocumented members if :undoc-members: is not given
787                     keep = has_doc or self.options.undoc_members
788 
789             if isinstance(obj, ObjectMember) and obj.skipped:
790                 # forcedly skipped member (ex. a module attribute not defined in __all__)
791                 keep = False
792 
793             # give the user a chance to decide whether this member
794             # should be skipped
795             if self.env.app:
796                 # let extensions preprocess docstrings
797                 try:
798                     skip_user = self.env.app.emit_firstresult(
799                         'autodoc-skip-member', self.objtype, membername, member,
800                         not keep, self.options)
801                     if skip_user is not None:
802                         keep = not skip_user
803                 except Exception as exc:
804                     logger.warning(__('autodoc: failed to determine %r to be documented, '
805                                       'the following exception was raised:\n%s'),
806                                    member, exc, type='autodoc')
807                     keep = False
808 
809             if keep:
810                 ret.append((membername, member, isattr))
811 
812         return ret

</code><intended_behavior>This method should be updated to ensure that annotation-only members in superclasses are not treated as undocumented, provided they are meant to be included (e.g., through `:inherited-members:` option). Specifically, the logic that determines member documentation status should take into account the existence of annotations as a valid form of documentation, particularly for inherited members. This may entail: Adjusting the `is_filtered_inherited_member` logic to consider members with only annotations (and optionally, associated comments) as documented. Ensuring that such members are not filtered out if the `undoc-members` option is not set, reflecting a broader definition of what is considered "documented".</intended_behavior>, <file>sphinx/ext/autodoc/__init__.py</file>
<class>Documenter</class>
<method>None</method>
<code>
289 class Documenter:
290     """
291     A Documenter knows how to autodocument a single object type.  When
292     registered with the AutoDirective, it will be used to document objects
293     of that type when needed by autodoc.
294 
295     Its *objtype* attribute selects what auto directive it is assigned to
296     (the directive name is 'auto' + objtype), and what directive it generates
297     by default, though that can be overridden by an attribute called
298     *directivetype*.
299 
300     A Documenter has an *option_spec* that works like a docutils directive's;
301     in fact, it will be used to parse an auto directive's options that matches
302     the documenter.
303     """
304     #: name by which the directive is called (auto...) and the default
305     #: generated directive name
306     objtype = 'object'
307     #: indentation by which to indent the directive content
308     content_indent = '   '
309     #: priority if multiple documenters return True from can_document_member
310     priority = 0
311     #: order if autodoc_member_order is set to 'groupwise'
312     member_order = 0
313     #: true if the generated content may contain titles
314     titles_allowed = False
315 
316     option_spec = {'noindex': bool_option}  # type: Dict[str, Callable]
317 
318     def get_attr(self, obj: Any, name: str, *defargs: Any) -> Any:
319         """getattr() override for types such as Zope interfaces."""
320         return autodoc_attrgetter(self.env.app, obj, name, *defargs)
321 
322     @classmethod
323     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
324                             ) -> bool:
325         """Called to see if a member can be documented by this documenter."""
326         raise NotImplementedError('must be implemented in subclasses')
327 
328     def __init__(self, directive: "DocumenterBridge", name: str, indent: str = '') -> None:
329         self.directive = directive
330         self.config = directive.env.config
331         self.env = directive.env    # type: BuildEnvironment
332         self.options = directive.genopt
333         self.name = name
334         self.indent = indent
335         # the module and object path within the module, and the fully
336         # qualified name (all set after resolve_name succeeds)
337         self.modname = None         # type: str
338         self.module = None          # type: ModuleType
339         self.objpath = None         # type: List[str]
340         self.fullname = None        # type: str
341         # extra signature items (arguments and return annotation,
342         # also set after resolve_name succeeds)
343         self.args = None            # type: str
344         self.retann = None          # type: str
345         # the object to document (set after import_object succeeds)
346         self.object = None          # type: Any
347         self.object_name = None     # type: str
348         # the parent/owner of the object to document
349         self.parent = None          # type: Any
350         # the module analyzer to get at attribute docs, or None
351         self.analyzer = None        # type: ModuleAnalyzer
352 
353     @property
354     def documenters(self) -> Dict[str, "Type[Documenter]"]:
355         """Returns registered Documenter classes"""
356         return self.env.app.registry.documenters
357 
358     def add_line(self, line: str, source: str, *lineno: int) -> None:
359         """Append one line of generated reST to the output."""
360         if line.strip():  # not a blank line
361             self.directive.result.append(self.indent + line, source, *lineno)
362         else:
363             self.directive.result.append('', source, *lineno)
364 
365     def resolve_name(self, modname: str, parents: Any, path: str, base: Any
366                      ) -> Tuple[str, List[str]]:
367         """Resolve the module and name of the object to document given by the
368         arguments and the current module/class.
369 
370         Must return a pair of the module name and a chain of attributes; for
371         example, it would return ``('zipfile', ['ZipFile', 'open'])`` for the
372         ``zipfile.ZipFile.open`` method.
373         """
374         raise NotImplementedError('must be implemented in subclasses')
375 
376     def parse_name(self) -> bool:
377         """Determine what module to import and what attribute to document.
378 
379         Returns True and sets *self.modname*, *self.objpath*, *self.fullname*,
380         *self.args* and *self.retann* if parsing and resolving was successful.
381         """
382         # first, parse the definition -- auto directives for classes and
383         # functions can contain a signature which is then used instead of
384         # an autogenerated one
385         try:
386             explicit_modname, path, base, args, retann = \
387                 py_ext_sig_re.match(self.name).groups()
388         except AttributeError:
389             logger.warning(__('invalid signature for auto%s (%r)') % (self.objtype, self.name),
390                            type='autodoc')
391             return False
392 
393         # support explicit module and class name separation via ::
394         if explicit_modname is not None:
395             modname = explicit_modname[:-2]
396             parents = path.rstrip('.').split('.') if path else []
397         else:
398             modname = None
399             parents = []
400 
401         with mock(self.config.autodoc_mock_imports):
402             self.modname, self.objpath = self.resolve_name(modname, parents, path, base)
403 
404         if not self.modname:
405             return False
406 
407         self.args = args
408         self.retann = retann
409         self.fullname = (self.modname or '') + \
410                         ('.' + '.'.join(self.objpath) if self.objpath else '')
411         return True
412 
413     def import_object(self, raiseerror: bool = False) -> bool:
414         """Import the object given by *self.modname* and *self.objpath* and set
415         it as *self.object*.
416 
417         Returns True if successful, False if an error occurred.
418         """
419         with mock(self.config.autodoc_mock_imports):
420             try:
421                 ret = import_object(self.modname, self.objpath, self.objtype,
422                                     attrgetter=self.get_attr,
423                                     warningiserror=self.config.autodoc_warningiserror)
424                 self.module, self.parent, self.object_name, self.object = ret
425                 if ismock(self.object):
426                     self.object = undecorate(self.object)
427                 return True
428             except ImportError as exc:
429                 if raiseerror:
430                     raise
431                 else:
432                     logger.warning(exc.args[0], type='autodoc', subtype='import_object')
433                     self.env.note_reread()
434                     return False
435 
436     def get_real_modname(self) -> str:
437         """Get the real module name of an object to document.
438 
439         It can differ from the name of the module through which the object was
440         imported.
441         """
442         return self.get_attr(self.object, '__module__', None) or self.modname
443 
444     def check_module(self) -> bool:
445         """Check if *self.object* is really defined in the module given by
446         *self.modname*.
447         """
448         if self.options.imported_members:
449             return True
450 
451         subject = inspect.unpartial(self.object)
452         modname = self.get_attr(subject, '__module__', None)
453         if modname and modname != self.modname:
454             return False
455         return True
456 
457     def format_args(self, **kwargs: Any) -> str:
458         """Format the argument signature of *self.object*.
459 
460         Should return None if the object does not have a signature.
461         """
462         return None
463 
464     def format_name(self) -> str:
465         """Format the name of *self.object*.
466 
467         This normally should be something that can be parsed by the generated
468         directive, but doesn't need to be (Sphinx will display it unparsed
469         then).
470         """
471         # normally the name doesn't contain the module (except for module
472         # directives of course)
473         return '.'.join(self.objpath) or self.modname
474 
475     def _call_format_args(self, **kwargs: Any) -> str:
476         if kwargs:
477             try:
478                 return self.format_args(**kwargs)
479             except TypeError:
480                 # avoid chaining exceptions, by putting nothing here
481                 pass
482 
483         # retry without arguments for old documenters
484         return self.format_args()
485 
486     def format_signature(self, **kwargs: Any) -> str:
487         """Format the signature (arguments and return annotation) of the object.
488 
489         Let the user process it via the ``autodoc-process-signature`` event.
490         """
491         if self.args is not None:
492             # signature given explicitly
493             args = "(%s)" % self.args
494             retann = self.retann
495         else:
496             # try to introspect the signature
497             try:
498                 retann = None
499                 args = self._call_format_args(**kwargs)
500                 if args:
501                     matched = re.match(r'^(\(.*\))\s+->\s+(.*)$', args)
502                     if matched:
503                         args = matched.group(1)
504                         retann = matched.group(2)
505             except Exception as exc:
506                 logger.warning(__('error while formatting arguments for %s: %s'),
507                                self.fullname, exc, type='autodoc')
508                 args = None
509 
510         result = self.env.events.emit_firstresult('autodoc-process-signature',
511                                                   self.objtype, self.fullname,
512                                                   self.object, self.options, args, retann)
513         if result:
514             args, retann = result
515 
516         if args is not None:
517             return args + ((' -> %s' % retann) if retann else '')
518         else:
519             return ''
520 
521     def add_directive_header(self, sig: str) -> None:
522         """Add the directive header and options to the generated content."""
523         domain = getattr(self, 'domain', 'py')
524         directive = getattr(self, 'directivetype', self.objtype)
525         name = self.format_name()
526         sourcename = self.get_sourcename()
527 
528         # one signature per line, indented by column
529         prefix = '.. %s:%s:: ' % (domain, directive)
530         for i, sig_line in enumerate(sig.split("\n")):
531             self.add_line('%s%s%s' % (prefix, name, sig_line),
532                           sourcename)
533             if i == 0:
534                 prefix = " " * len(prefix)
535 
536         if self.options.noindex:
537             self.add_line('   :noindex:', sourcename)
538         if self.objpath:
539             # Be explicit about the module, this is necessary since .. class::
540             # etc. don't support a prepended module name
541             self.add_line('   :module: %s' % self.modname, sourcename)
542 
543     def get_doc(self, encoding: str = None, ignore: int = None) -> Optional[List[List[str]]]:
544         """Decode and return lines of the docstring(s) for the object.
545 
546         When it returns None value, autodoc-process-docstring will not be called for this
547         object.
548         """
549         if encoding is not None:
550             warnings.warn("The 'encoding' argument to autodoc.%s.get_doc() is deprecated."
551                           % self.__class__.__name__,
552                           RemovedInSphinx40Warning, stacklevel=2)
553         if ignore is not None:
554             warnings.warn("The 'ignore' argument to autodoc.%s.get_doc() is deprecated."
555                           % self.__class__.__name__,
556                           RemovedInSphinx50Warning, stacklevel=2)
557         docstring = getdoc(self.object, self.get_attr, self.config.autodoc_inherit_docstrings,
558                            self.parent, self.object_name)
559         if docstring:
560             tab_width = self.directive.state.document.settings.tab_width
561             return [prepare_docstring(docstring, ignore, tab_width)]
562         return []
563 
564     def process_doc(self, docstrings: List[List[str]]) -> Iterator[str]:
565         """Let the user process the docstrings before adding them."""
566         for docstringlines in docstrings:
567             if self.env.app:
568                 # let extensions preprocess docstrings
569                 self.env.app.emit('autodoc-process-docstring',
570                                   self.objtype, self.fullname, self.object,
571                                   self.options, docstringlines)
572 
573                 if docstringlines and docstringlines[-1] != '':
574                     # append a blank line to the end of the docstring
575                     docstringlines.append('')
576 
577             yield from docstringlines
578 
579     def get_sourcename(self) -> str:
580         if (getattr(self.object, '__module__', None) and
581                 getattr(self.object, '__qualname__', None)):
582             # Get the correct location of docstring from self.object
583             # to support inherited methods
584             fullname = '%s.%s' % (self.object.__module__, self.object.__qualname__)
585         else:
586             fullname = self.fullname
587 
588         if self.analyzer:
589             return '%s:docstring of %s' % (self.analyzer.srcname, fullname)
590         else:
591             return 'docstring of %s' % fullname
592 
593     def add_content(self, more_content: Optional[StringList], no_docstring: bool = False
594                     ) -> None:
595         """Add content from docstrings, attribute documentation and user."""
596         if no_docstring:
597             warnings.warn("The 'no_docstring' argument to %s.add_content() is deprecated."
598                           % self.__class__.__name__,
599                           RemovedInSphinx50Warning, stacklevel=2)
600 
601         # set sourcename and add content from attribute documentation
602         sourcename = self.get_sourcename()
603         if self.analyzer:
604             attr_docs = self.analyzer.find_attr_docs()
605             if self.objpath:
606                 key = ('.'.join(self.objpath[:-1]), self.objpath[-1])
607                 if key in attr_docs:
608                     no_docstring = True
609                     # make a copy of docstring for attributes to avoid cache
610                     # the change of autodoc-process-docstring event.
611                     docstrings = [list(attr_docs[key])]
612 
613                     for i, line in enumerate(self.process_doc(docstrings)):
614                         self.add_line(line, sourcename, i)
615 
616         # add content from docstrings
617         if not no_docstring:
618             docstrings = self.get_doc()
619             if docstrings is None:
620                 # Do not call autodoc-process-docstring on get_doc() returns None.
621                 pass
622             else:
623                 if not docstrings:
624                     # append at least a dummy docstring, so that the event
625                     # autodoc-process-docstring is fired and can add some
626                     # content if desired
627                     docstrings.append([])
628                 for i, line in enumerate(self.process_doc(docstrings)):
629                     self.add_line(line, sourcename, i)
630 
631         # add additional content (e.g. from document), if present
632         if more_content:
633             for line, src in zip(more_content.data, more_content.items):
634                 self.add_line(line, src[0], src[1])
635 
636     def get_object_members(self, want_all: bool) -> Tuple[bool, ObjectMembers]:
637         """Return `(members_check_module, members)` where `members` is a
638         list of `(membername, member)` pairs of the members of *self.object*.
639 
640         If *want_all* is True, return all members.  Else, only return those
641         members given by *self.options.members* (which may also be none).
642         """
643         warnings.warn('The implementation of Documenter.get_object_members() will be '
644                       'removed from Sphinx-6.0.', RemovedInSphinx60Warning)
645         members = get_object_members(self.object, self.objpath, self.get_attr, self.analyzer)
646         if not want_all:
647             if not self.options.members:
648                 return False, []  # type: ignore
649             # specific members given
650             selected = []
651             for name in self.options.members:  # type: str
652                 if name in members:
653                     selected.append((name, members[name].value))
654                 else:
655                     logger.warning(__('missing attribute %s in object %s') %
656                                    (name, self.fullname), type='autodoc')
657             return False, selected
658         elif self.options.inherited_members:
659             return False, [(m.name, m.value) for m in members.values()]
660         else:
661             return False, [(m.name, m.value) for m in members.values()
662                            if m.directly_defined]
663 
664     def filter_members(self, members: ObjectMembers, want_all: bool
665                        ) -> List[Tuple[str, Any, bool]]:
666         """Filter the given member list.
667 
668         Members are skipped if
669 
670         - they are private (except if given explicitly or the private-members
671           option is set)
672         - they are special methods (except if given explicitly or the
673           special-members option is set)
674         - they are undocumented (except if the undoc-members option is set)
675 
676         The user can override the skipping decision by connecting to the
677         ``autodoc-skip-member`` event.
678         """
679         def is_filtered_inherited_member(name: str, obj: Any) -> bool:
680             if inspect.isclass(self.object):
681                 for cls in self.object.__mro__:
682                     if cls.__name__ == self.options.inherited_members and cls != self.object:
683                         # given member is a member of specified *super class*
684                         return True
685                     elif name in cls.__dict__:
686                         return False
687                     elif name in self.get_attr(cls, '__annotations__', {}):
688                         return False
689                     elif isinstance(obj, ObjectMember) and obj.class_ is cls:
690                         return False
691 
692             return False
693 
694         ret = []
695 
696         # search for members in source code too
697         namespace = '.'.join(self.objpath)  # will be empty for modules
698 
699         if self.analyzer:
700             attr_docs = self.analyzer.find_attr_docs()
701         else:
702             attr_docs = {}
703 
704         # process members and determine which to skip
705         for obj in members:
706             membername, member = obj
707             # if isattr is True, the member is documented as an attribute
708             if member is INSTANCEATTR:
709                 isattr = True
710             else:
711                 isattr = False
712 
713             doc = getdoc(member, self.get_attr, self.config.autodoc_inherit_docstrings,
714                          self.parent, self.object_name)
715             if not isinstance(doc, str):
716                 # Ignore non-string __doc__
717                 doc = None
718 
719             # if the member __doc__ is the same as self's __doc__, it's just
720             # inherited and therefore not the member's doc
721             cls = self.get_attr(member, '__class__', None)
722             if cls:
723                 cls_doc = self.get_attr(cls, '__doc__', None)
724                 if cls_doc == doc:
725                     doc = None
726 
727             if isinstance(obj, ObjectMember) and obj.docstring:
728                 # hack for ClassDocumenter to inject docstring via ObjectMember
729                 doc = obj.docstring
730 
731             has_doc = bool(doc)
732 
733             metadata = extract_metadata(doc)
734             if 'private' in metadata:
735                 # consider a member private if docstring has "private" metadata
736                 isprivate = True
737             elif 'public' in metadata:
738                 # consider a member public if docstring has "public" metadata
739                 isprivate = False
740             else:
741                 isprivate = membername.startswith('_')
742 
743             keep = False
744             if ismock(member):
745                 # mocked module or object
746                 pass
747             elif self.options.exclude_members and membername in self.options.exclude_members:
748                 # remove members given by exclude-members
749                 keep = False
750             elif want_all and special_member_re.match(membername):
751                 # special __methods__
752                 if self.options.special_members and membername in self.options.special_members:
753                     if membername == '__doc__':
754                         keep = False
755                     elif is_filtered_inherited_member(membername, obj):
756                         keep = False
757                     else:
758                         keep = has_doc or self.options.undoc_members
759                 else:
760                     keep = False
761             elif (namespace, membername) in attr_docs:
762                 if want_all and isprivate:
763                     if self.options.private_members is None:
764                         keep = False
765                     else:
766                         keep = membername in self.options.private_members
767                 else:
768                     # keep documented attributes
769                     keep = True
770                 isattr = True
771             elif want_all and isprivate:
772                 if has_doc or self.options.undoc_members:
773                     if self.options.private_members is None:
774                         keep = False
775                     elif is_filtered_inherited_member(membername, obj):
776                         keep = False
777                     else:
778                         keep = membername in self.options.private_members
779                 else:
780                     keep = False
781             else:
782                 if (self.options.members is ALL and
783                         is_filtered_inherited_member(membername, obj)):
784                     keep = False
785                 else:
786                     # ignore undocumented members if :undoc-members: is not given
787                     keep = has_doc or self.options.undoc_members
788 
789             if isinstance(obj, ObjectMember) and obj.skipped:
790                 # forcedly skipped member (ex. a module attribute not defined in __all__)
791                 keep = False
792 
793             # give the user a chance to decide whether this member
794             # should be skipped
795             if self.env.app:
796                 # let extensions preprocess docstrings
797                 try:
798                     skip_user = self.env.app.emit_firstresult(
799                         'autodoc-skip-member', self.objtype, membername, member,
800                         not keep, self.options)
801                     if skip_user is not None:
802                         keep = not skip_user
803                 except Exception as exc:
804                     logger.warning(__('autodoc: failed to determine %r to be documented, '
805                                       'the following exception was raised:\n%s'),
806                                    member, exc, type='autodoc')
807                     keep = False
808 
809             if keep:
810                 ret.append((membername, member, isattr))
811 
812         return ret
813 
814     def document_members(self, all_members: bool = False) -> None:
815         """Generate reST for member documentation.
816 
817         If *all_members* is True, do all members, else those given by
818         *self.options.members*.
819         """
820         # set current namespace for finding members
821         self.env.temp_data['autodoc:module'] = self.modname
822         if self.objpath:
823             self.env.temp_data['autodoc:class'] = self.objpath[0]
824 
825         want_all = all_members or self.options.inherited_members or \
826             self.options.members is ALL
827         # find out which members are documentable
828         members_check_module, members = self.get_object_members(want_all)
829 
830         # document non-skipped members
831         memberdocumenters = []  # type: List[Tuple[Documenter, bool]]
832         for (mname, member, isattr) in self.filter_members(members, want_all):
833             classes = [cls for cls in self.documenters.values()
834                        if cls.can_document_member(member, mname, isattr, self)]
835             if not classes:
836                 # don't know how to document this member
837                 continue
838             # prefer the documenter with the highest priority
839             classes.sort(key=lambda cls: cls.priority)
840             # give explicitly separated module name, so that members
841             # of inner classes can be documented
842             full_mname = self.modname + '::' + \
843                 '.'.join(self.objpath + [mname])
844             documenter = classes[-1](self.directive, full_mname, self.indent)
845             memberdocumenters.append((documenter, isattr))
846 
847         member_order = self.options.member_order or self.config.autodoc_member_order
848         memberdocumenters = self.sort_members(memberdocumenters, member_order)
849 
850         for documenter, isattr in memberdocumenters:
851             documenter.generate(
852                 all_members=True, real_modname=self.real_modname,
853                 check_module=members_check_module and not isattr)
854 
855         # reset current objects
856         self.env.temp_data['autodoc:module'] = None
857         self.env.temp_data['autodoc:class'] = None
858 
859     def sort_members(self, documenters: List[Tuple["Documenter", bool]],
860                      order: str) -> List[Tuple["Documenter", bool]]:
861         """Sort the given member list."""
862         if order == 'groupwise':
863             # sort by group; alphabetically within groups
864             documenters.sort(key=lambda e: (e[0].member_order, e[0].name))
865         elif order == 'bysource':
866             if self.analyzer:
867                 # sort by source order, by virtue of the module analyzer
868                 tagorder = self.analyzer.tagorder
869 
870                 def keyfunc(entry: Tuple[Documenter, bool]) -> int:
871                     fullname = entry[0].name.split('::')[1]
872                     return tagorder.get(fullname, len(tagorder))
873                 documenters.sort(key=keyfunc)
874             else:
875                 # Assume that member discovery order matches source order.
876                 # This is a reasonable assumption in Python 3.6 and up, where
877                 # module.__dict__ is insertion-ordered.
878                 pass
879         else:  # alphabetical
880             documenters.sort(key=lambda e: e[0].name)
881 
882         return documenters
883 
884     def generate(self, more_content: Optional[StringList] = None, real_modname: str = None,
885                  check_module: bool = False, all_members: bool = False) -> None:
886         """Generate reST for the object given by *self.name*, and possibly for
887         its members.
888 
889         If *more_content* is given, include that content. If *real_modname* is
890         given, use that module name to find attribute docs. If *check_module* is
891         True, only generate if the object is defined in the module name it is
892         imported from. If *all_members* is True, document all members.
893         """
894         if not self.parse_name():
895             # need a module to import
896             logger.warning(
897                 __('don\'t know which module to import for autodocumenting '
898                    '%r (try placing a "module" or "currentmodule" directive '
899                    'in the document, or giving an explicit module name)') %
900                 self.name, type='autodoc')
901             return
902 
903         # now, import the module and get object to document
904         if not self.import_object():
905             return
906 
907         # If there is no real module defined, figure out which to use.
908         # The real module is used in the module analyzer to look up the module
909         # where the attribute documentation would actually be found in.
910         # This is used for situations where you have a module that collects the
911         # functions and classes of internal submodules.
912         guess_modname = self.get_real_modname()
913         self.real_modname = real_modname or guess_modname
914 
915         # try to also get a source code analyzer for attribute docs
916         try:
917             self.analyzer = ModuleAnalyzer.for_module(self.real_modname)
918             # parse right now, to get PycodeErrors on parsing (results will
919             # be cached anyway)
920             self.analyzer.find_attr_docs()
921         except PycodeError as exc:
922             logger.debug('[autodoc] module analyzer failed: %s', exc)
923             # no source file -- e.g. for builtin and C modules
924             self.analyzer = None
925             # at least add the module.__file__ as a dependency
926             if hasattr(self.module, '__file__') and self.module.__file__:
927                 self.directive.filename_set.add(self.module.__file__)
928         else:
929             self.directive.filename_set.add(self.analyzer.srcname)
930 
931         if self.real_modname != guess_modname:
932             # Add module to dependency list if target object is defined in other module.
933             try:
934                 analyzer = ModuleAnalyzer.for_module(guess_modname)
935                 self.directive.filename_set.add(analyzer.srcname)
936             except PycodeError:
937                 pass
938 
939         # check __module__ of object (for members not given explicitly)
940         if check_module:
941             if not self.check_module():
942                 return
943 
944         sourcename = self.get_sourcename()
945 
946         # make sure that the result starts with an empty line.  This is
947         # necessary for some situations where another directive preprocesses
948         # reST and no starting newline is present
949         self.add_line('', sourcename)
950 
951         # format the object's signature, if any
952         try:
953             sig = self.format_signature()
954         except Exception as exc:
955             logger.warning(__('error while formatting signature for %s: %s'),
956                            self.fullname, exc, type='autodoc')
957             return
958 
959         # generate the directive header and options, if applicable
960         self.add_directive_header(sig)
961         self.add_line('', sourcename)
962 
963         # e.g. the module directive doesn't have content
964         self.indent += self.content_indent
965 
966         # add all content (from docstrings, attribute docs etc.)
967         self.add_content(more_content)
968 
969         # document members, if possible
970         self.document_members(all_members)

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>, <file>sphinx/ext/autodoc/__init__.py</file>
<class>Documenter</class>
<method>get_object_members</method>
<code>
636     def get_object_members(self, want_all: bool) -> Tuple[bool, ObjectMembers]:
637         """Return `(members_check_module, members)` where `members` is a
638         list of `(membername, member)` pairs of the members of *self.object*.
639 
640         If *want_all* is True, return all members.  Else, only return those
641         members given by *self.options.members* (which may also be none).
642         """
643         warnings.warn('The implementation of Documenter.get_object_members() will be '
644                       'removed from Sphinx-6.0.', RemovedInSphinx60Warning)
645         members = get_object_members(self.object, self.objpath, self.get_attr, self.analyzer)
646         if not want_all:
647             if not self.options.members:
648                 return False, []  # type: ignore
649             # specific members given
650             selected = []
651             for name in self.options.members:  # type: str
652                 if name in members:
653                     selected.append((name, members[name].value))
654                 else:
655                     logger.warning(__('missing attribute %s in object %s') %
656                                    (name, self.fullname), type='autodoc')
657             return False, selected
658         elif self.options.inherited_members:
659             return False, [(m.name, m.value) for m in members.values()]
660         else:
661             return False, [(m.name, m.value) for m in members.values()
662                            if m.directly_defined]

</code><intended_behavior>Modifications here should ensure that the method correctly identifies and flags inherited annotation-only members for documentation. This includes: Improving how members are identified and marked as "inherited". This might require updating the conditionals that check if a member should be included based on `want_all` and `options.inherited_members` settings. Ensuring that annotation-only members are recognized as part of the object's members when `inherited_members` is active, possibly by augmenting how members are collected and processed (e.g., considering annotation presence as a criterion for inclusion).</intended_behavior>, <file>sphinx/ext/autodoc/__init__.py</file>
<class>Documenter</class>
<method>None</method>
<code>
289 class Documenter:
290     """
291     A Documenter knows how to autodocument a single object type.  When
292     registered with the AutoDirective, it will be used to document objects
293     of that type when needed by autodoc.
294 
295     Its *objtype* attribute selects what auto directive it is assigned to
296     (the directive name is 'auto' + objtype), and what directive it generates
297     by default, though that can be overridden by an attribute called
298     *directivetype*.
299 
300     A Documenter has an *option_spec* that works like a docutils directive's;
301     in fact, it will be used to parse an auto directive's options that matches
302     the documenter.
303     """
304     #: name by which the directive is called (auto...) and the default
305     #: generated directive name
306     objtype = 'object'
307     #: indentation by which to indent the directive content
308     content_indent = '   '
309     #: priority if multiple documenters return True from can_document_member
310     priority = 0
311     #: order if autodoc_member_order is set to 'groupwise'
312     member_order = 0
313     #: true if the generated content may contain titles
314     titles_allowed = False
315 
316     option_spec = {'noindex': bool_option}  # type: Dict[str, Callable]
317 
318     def get_attr(self, obj: Any, name: str, *defargs: Any) -> Any:
319         """getattr() override for types such as Zope interfaces."""
320         return autodoc_attrgetter(self.env.app, obj, name, *defargs)
321 
322     @classmethod
323     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
324                             ) -> bool:
325         """Called to see if a member can be documented by this documenter."""
326         raise NotImplementedError('must be implemented in subclasses')
327 
328     def __init__(self, directive: "DocumenterBridge", name: str, indent: str = '') -> None:
329         self.directive = directive
330         self.config = directive.env.config
331         self.env = directive.env    # type: BuildEnvironment
332         self.options = directive.genopt
333         self.name = name
334         self.indent = indent
335         # the module and object path within the module, and the fully
336         # qualified name (all set after resolve_name succeeds)
337         self.modname = None         # type: str
338         self.module = None          # type: ModuleType
339         self.objpath = None         # type: List[str]
340         self.fullname = None        # type: str
341         # extra signature items (arguments and return annotation,
342         # also set after resolve_name succeeds)
343         self.args = None            # type: str
344         self.retann = None          # type: str
345         # the object to document (set after import_object succeeds)
346         self.object = None          # type: Any
347         self.object_name = None     # type: str
348         # the parent/owner of the object to document
349         self.parent = None          # type: Any
350         # the module analyzer to get at attribute docs, or None
351         self.analyzer = None        # type: ModuleAnalyzer
352 
353     @property
354     def documenters(self) -> Dict[str, "Type[Documenter]"]:
355         """Returns registered Documenter classes"""
356         return self.env.app.registry.documenters
357 
358     def add_line(self, line: str, source: str, *lineno: int) -> None:
359         """Append one line of generated reST to the output."""
360         if line.strip():  # not a blank line
361             self.directive.result.append(self.indent + line, source, *lineno)
362         else:
363             self.directive.result.append('', source, *lineno)
364 
365     def resolve_name(self, modname: str, parents: Any, path: str, base: Any
366                      ) -> Tuple[str, List[str]]:
367         """Resolve the module and name of the object to document given by the
368         arguments and the current module/class.
369 
370         Must return a pair of the module name and a chain of attributes; for
371         example, it would return ``('zipfile', ['ZipFile', 'open'])`` for the
372         ``zipfile.ZipFile.open`` method.
373         """
374         raise NotImplementedError('must be implemented in subclasses')
375 
376     def parse_name(self) -> bool:
377         """Determine what module to import and what attribute to document.
378 
379         Returns True and sets *self.modname*, *self.objpath*, *self.fullname*,
380         *self.args* and *self.retann* if parsing and resolving was successful.
381         """
382         # first, parse the definition -- auto directives for classes and
383         # functions can contain a signature which is then used instead of
384         # an autogenerated one
385         try:
386             explicit_modname, path, base, args, retann = \
387                 py_ext_sig_re.match(self.name).groups()
388         except AttributeError:
389             logger.warning(__('invalid signature for auto%s (%r)') % (self.objtype, self.name),
390                            type='autodoc')
391             return False
392 
393         # support explicit module and class name separation via ::
394         if explicit_modname is not None:
395             modname = explicit_modname[:-2]
396             parents = path.rstrip('.').split('.') if path else []
397         else:
398             modname = None
399             parents = []
400 
401         with mock(self.config.autodoc_mock_imports):
402             self.modname, self.objpath = self.resolve_name(modname, parents, path, base)
403 
404         if not self.modname:
405             return False
406 
407         self.args = args
408         self.retann = retann
409         self.fullname = (self.modname or '') + \
410                         ('.' + '.'.join(self.objpath) if self.objpath else '')
411         return True
412 
413     def import_object(self, raiseerror: bool = False) -> bool:
414         """Import the object given by *self.modname* and *self.objpath* and set
415         it as *self.object*.
416 
417         Returns True if successful, False if an error occurred.
418         """
419         with mock(self.config.autodoc_mock_imports):
420             try:
421                 ret = import_object(self.modname, self.objpath, self.objtype,
422                                     attrgetter=self.get_attr,
423                                     warningiserror=self.config.autodoc_warningiserror)
424                 self.module, self.parent, self.object_name, self.object = ret
425                 if ismock(self.object):
426                     self.object = undecorate(self.object)
427                 return True
428             except ImportError as exc:
429                 if raiseerror:
430                     raise
431                 else:
432                     logger.warning(exc.args[0], type='autodoc', subtype='import_object')
433                     self.env.note_reread()
434                     return False
435 
436     def get_real_modname(self) -> str:
437         """Get the real module name of an object to document.
438 
439         It can differ from the name of the module through which the object was
440         imported.
441         """
442         return self.get_attr(self.object, '__module__', None) or self.modname
443 
444     def check_module(self) -> bool:
445         """Check if *self.object* is really defined in the module given by
446         *self.modname*.
447         """
448         if self.options.imported_members:
449             return True
450 
451         subject = inspect.unpartial(self.object)
452         modname = self.get_attr(subject, '__module__', None)
453         if modname and modname != self.modname:
454             return False
455         return True
456 
457     def format_args(self, **kwargs: Any) -> str:
458         """Format the argument signature of *self.object*.
459 
460         Should return None if the object does not have a signature.
461         """
462         return None
463 
464     def format_name(self) -> str:
465         """Format the name of *self.object*.
466 
467         This normally should be something that can be parsed by the generated
468         directive, but doesn't need to be (Sphinx will display it unparsed
469         then).
470         """
471         # normally the name doesn't contain the module (except for module
472         # directives of course)
473         return '.'.join(self.objpath) or self.modname
474 
475     def _call_format_args(self, **kwargs: Any) -> str:
476         if kwargs:
477             try:
478                 return self.format_args(**kwargs)
479             except TypeError:
480                 # avoid chaining exceptions, by putting nothing here
481                 pass
482 
483         # retry without arguments for old documenters
484         return self.format_args()
485 
486     def format_signature(self, **kwargs: Any) -> str:
487         """Format the signature (arguments and return annotation) of the object.
488 
489         Let the user process it via the ``autodoc-process-signature`` event.
490         """
491         if self.args is not None:
492             # signature given explicitly
493             args = "(%s)" % self.args
494             retann = self.retann
495         else:
496             # try to introspect the signature
497             try:
498                 retann = None
499                 args = self._call_format_args(**kwargs)
500                 if args:
501                     matched = re.match(r'^(\(.*\))\s+->\s+(.*)$', args)
502                     if matched:
503                         args = matched.group(1)
504                         retann = matched.group(2)
505             except Exception as exc:
506                 logger.warning(__('error while formatting arguments for %s: %s'),
507                                self.fullname, exc, type='autodoc')
508                 args = None
509 
510         result = self.env.events.emit_firstresult('autodoc-process-signature',
511                                                   self.objtype, self.fullname,
512                                                   self.object, self.options, args, retann)
513         if result:
514             args, retann = result
515 
516         if args is not None:
517             return args + ((' -> %s' % retann) if retann else '')
518         else:
519             return ''
520 
521     def add_directive_header(self, sig: str) -> None:
522         """Add the directive header and options to the generated content."""
523         domain = getattr(self, 'domain', 'py')
524         directive = getattr(self, 'directivetype', self.objtype)
525         name = self.format_name()
526         sourcename = self.get_sourcename()
527 
528         # one signature per line, indented by column
529         prefix = '.. %s:%s:: ' % (domain, directive)
530         for i, sig_line in enumerate(sig.split("\n")):
531             self.add_line('%s%s%s' % (prefix, name, sig_line),
532                           sourcename)
533             if i == 0:
534                 prefix = " " * len(prefix)
535 
536         if self.options.noindex:
537             self.add_line('   :noindex:', sourcename)
538         if self.objpath:
539             # Be explicit about the module, this is necessary since .. class::
540             # etc. don't support a prepended module name
541             self.add_line('   :module: %s' % self.modname, sourcename)
542 
543     def get_doc(self, encoding: str = None, ignore: int = None) -> Optional[List[List[str]]]:
544         """Decode and return lines of the docstring(s) for the object.
545 
546         When it returns None value, autodoc-process-docstring will not be called for this
547         object.
548         """
549         if encoding is not None:
550             warnings.warn("The 'encoding' argument to autodoc.%s.get_doc() is deprecated."
551                           % self.__class__.__name__,
552                           RemovedInSphinx40Warning, stacklevel=2)
553         if ignore is not None:
554             warnings.warn("The 'ignore' argument to autodoc.%s.get_doc() is deprecated."
555                           % self.__class__.__name__,
556                           RemovedInSphinx50Warning, stacklevel=2)
557         docstring = getdoc(self.object, self.get_attr, self.config.autodoc_inherit_docstrings,
558                            self.parent, self.object_name)
559         if docstring:
560             tab_width = self.directive.state.document.settings.tab_width
561             return [prepare_docstring(docstring, ignore, tab_width)]
562         return []
563 
564     def process_doc(self, docstrings: List[List[str]]) -> Iterator[str]:
565         """Let the user process the docstrings before adding them."""
566         for docstringlines in docstrings:
567             if self.env.app:
568                 # let extensions preprocess docstrings
569                 self.env.app.emit('autodoc-process-docstring',
570                                   self.objtype, self.fullname, self.object,
571                                   self.options, docstringlines)
572 
573                 if docstringlines and docstringlines[-1] != '':
574                     # append a blank line to the end of the docstring
575                     docstringlines.append('')
576 
577             yield from docstringlines
578 
579     def get_sourcename(self) -> str:
580         if (getattr(self.object, '__module__', None) and
581                 getattr(self.object, '__qualname__', None)):
582             # Get the correct location of docstring from self.object
583             # to support inherited methods
584             fullname = '%s.%s' % (self.object.__module__, self.object.__qualname__)
585         else:
586             fullname = self.fullname
587 
588         if self.analyzer:
589             return '%s:docstring of %s' % (self.analyzer.srcname, fullname)
590         else:
591             return 'docstring of %s' % fullname
592 
593     def add_content(self, more_content: Optional[StringList], no_docstring: bool = False
594                     ) -> None:
595         """Add content from docstrings, attribute documentation and user."""
596         if no_docstring:
597             warnings.warn("The 'no_docstring' argument to %s.add_content() is deprecated."
598                           % self.__class__.__name__,
599                           RemovedInSphinx50Warning, stacklevel=2)
600 
601         # set sourcename and add content from attribute documentation
602         sourcename = self.get_sourcename()
603         if self.analyzer:
604             attr_docs = self.analyzer.find_attr_docs()
605             if self.objpath:
606                 key = ('.'.join(self.objpath[:-1]), self.objpath[-1])
607                 if key in attr_docs:
608                     no_docstring = True
609                     # make a copy of docstring for attributes to avoid cache
610                     # the change of autodoc-process-docstring event.
611                     docstrings = [list(attr_docs[key])]
612 
613                     for i, line in enumerate(self.process_doc(docstrings)):
614                         self.add_line(line, sourcename, i)
615 
616         # add content from docstrings
617         if not no_docstring:
618             docstrings = self.get_doc()
619             if docstrings is None:
620                 # Do not call autodoc-process-docstring on get_doc() returns None.
621                 pass
622             else:
623                 if not docstrings:
624                     # append at least a dummy docstring, so that the event
625                     # autodoc-process-docstring is fired and can add some
626                     # content if desired
627                     docstrings.append([])
628                 for i, line in enumerate(self.process_doc(docstrings)):
629                     self.add_line(line, sourcename, i)
630 
631         # add additional content (e.g. from document), if present
632         if more_content:
633             for line, src in zip(more_content.data, more_content.items):
634                 self.add_line(line, src[0], src[1])
635 
636     def get_object_members(self, want_all: bool) -> Tuple[bool, ObjectMembers]:
637         """Return `(members_check_module, members)` where `members` is a
638         list of `(membername, member)` pairs of the members of *self.object*.
639 
640         If *want_all* is True, return all members.  Else, only return those
641         members given by *self.options.members* (which may also be none).
642         """
643         warnings.warn('The implementation of Documenter.get_object_members() will be '
644                       'removed from Sphinx-6.0.', RemovedInSphinx60Warning)
645         members = get_object_members(self.object, self.objpath, self.get_attr, self.analyzer)
646         if not want_all:
647             if not self.options.members:
648                 return False, []  # type: ignore
649             # specific members given
650             selected = []
651             for name in self.options.members:  # type: str
652                 if name in members:
653                     selected.append((name, members[name].value))
654                 else:
655                     logger.warning(__('missing attribute %s in object %s') %
656                                    (name, self.fullname), type='autodoc')
657             return False, selected
658         elif self.options.inherited_members:
659             return False, [(m.name, m.value) for m in members.values()]
660         else:
661             return False, [(m.name, m.value) for m in members.values()
662                            if m.directly_defined]
663 
664     def filter_members(self, members: ObjectMembers, want_all: bool
665                        ) -> List[Tuple[str, Any, bool]]:
666         """Filter the given member list.
667 
668         Members are skipped if
669 
670         - they are private (except if given explicitly or the private-members
671           option is set)
672         - they are special methods (except if given explicitly or the
673           special-members option is set)
674         - they are undocumented (except if the undoc-members option is set)
675 
676         The user can override the skipping decision by connecting to the
677         ``autodoc-skip-member`` event.
678         """
679         def is_filtered_inherited_member(name: str, obj: Any) -> bool:
680             if inspect.isclass(self.object):
681                 for cls in self.object.__mro__:
682                     if cls.__name__ == self.options.inherited_members and cls != self.object:
683                         # given member is a member of specified *super class*
684                         return True
685                     elif name in cls.__dict__:
686                         return False
687                     elif name in self.get_attr(cls, '__annotations__', {}):
688                         return False
689                     elif isinstance(obj, ObjectMember) and obj.class_ is cls:
690                         return False
691 
692             return False
693 
694         ret = []
695 
696         # search for members in source code too
697         namespace = '.'.join(self.objpath)  # will be empty for modules
698 
699         if self.analyzer:
700             attr_docs = self.analyzer.find_attr_docs()
701         else:
702             attr_docs = {}
703 
704         # process members and determine which to skip
705         for obj in members:
706             membername, member = obj
707             # if isattr is True, the member is documented as an attribute
708             if member is INSTANCEATTR:
709                 isattr = True
710             else:
711                 isattr = False
712 
713             doc = getdoc(member, self.get_attr, self.config.autodoc_inherit_docstrings,
714                          self.parent, self.object_name)
715             if not isinstance(doc, str):
716                 # Ignore non-string __doc__
717                 doc = None
718 
719             # if the member __doc__ is the same as self's __doc__, it's just
720             # inherited and therefore not the member's doc
721             cls = self.get_attr(member, '__class__', None)
722             if cls:
723                 cls_doc = self.get_attr(cls, '__doc__', None)
724                 if cls_doc == doc:
725                     doc = None
726 
727             if isinstance(obj, ObjectMember) and obj.docstring:
728                 # hack for ClassDocumenter to inject docstring via ObjectMember
729                 doc = obj.docstring
730 
731             has_doc = bool(doc)
732 
733             metadata = extract_metadata(doc)
734             if 'private' in metadata:
735                 # consider a member private if docstring has "private" metadata
736                 isprivate = True
737             elif 'public' in metadata:
738                 # consider a member public if docstring has "public" metadata
739                 isprivate = False
740             else:
741                 isprivate = membername.startswith('_')
742 
743             keep = False
744             if ismock(member):
745                 # mocked module or object
746                 pass
747             elif self.options.exclude_members and membername in self.options.exclude_members:
748                 # remove members given by exclude-members
749                 keep = False
750             elif want_all and special_member_re.match(membername):
751                 # special __methods__
752                 if self.options.special_members and membername in self.options.special_members:
753                     if membername == '__doc__':
754                         keep = False
755                     elif is_filtered_inherited_member(membername, obj):
756                         keep = False
757                     else:
758                         keep = has_doc or self.options.undoc_members
759                 else:
760                     keep = False
761             elif (namespace, membername) in attr_docs:
762                 if want_all and isprivate:
763                     if self.options.private_members is None:
764                         keep = False
765                     else:
766                         keep = membername in self.options.private_members
767                 else:
768                     # keep documented attributes
769                     keep = True
770                 isattr = True
771             elif want_all and isprivate:
772                 if has_doc or self.options.undoc_members:
773                     if self.options.private_members is None:
774                         keep = False
775                     elif is_filtered_inherited_member(membername, obj):
776                         keep = False
777                     else:
778                         keep = membername in self.options.private_members
779                 else:
780                     keep = False
781             else:
782                 if (self.options.members is ALL and
783                         is_filtered_inherited_member(membername, obj)):
784                     keep = False
785                 else:
786                     # ignore undocumented members if :undoc-members: is not given
787                     keep = has_doc or self.options.undoc_members
788 
789             if isinstance(obj, ObjectMember) and obj.skipped:
790                 # forcedly skipped member (ex. a module attribute not defined in __all__)
791                 keep = False
792 
793             # give the user a chance to decide whether this member
794             # should be skipped
795             if self.env.app:
796                 # let extensions preprocess docstrings
797                 try:
798                     skip_user = self.env.app.emit_firstresult(
799                         'autodoc-skip-member', self.objtype, membername, member,
800                         not keep, self.options)
801                     if skip_user is not None:
802                         keep = not skip_user
803                 except Exception as exc:
804                     logger.warning(__('autodoc: failed to determine %r to be documented, '
805                                       'the following exception was raised:\n%s'),
806                                    member, exc, type='autodoc')
807                     keep = False
808 
809             if keep:
810                 ret.append((membername, member, isattr))
811 
812         return ret
813 
814     def document_members(self, all_members: bool = False) -> None:
815         """Generate reST for member documentation.
816 
817         If *all_members* is True, do all members, else those given by
818         *self.options.members*.
819         """
820         # set current namespace for finding members
821         self.env.temp_data['autodoc:module'] = self.modname
822         if self.objpath:
823             self.env.temp_data['autodoc:class'] = self.objpath[0]
824 
825         want_all = all_members or self.options.inherited_members or \
826             self.options.members is ALL
827         # find out which members are documentable
828         members_check_module, members = self.get_object_members(want_all)
829 
830         # document non-skipped members
831         memberdocumenters = []  # type: List[Tuple[Documenter, bool]]
832         for (mname, member, isattr) in self.filter_members(members, want_all):
833             classes = [cls for cls in self.documenters.values()
834                        if cls.can_document_member(member, mname, isattr, self)]
835             if not classes:
836                 # don't know how to document this member
837                 continue
838             # prefer the documenter with the highest priority
839             classes.sort(key=lambda cls: cls.priority)
840             # give explicitly separated module name, so that members
841             # of inner classes can be documented
842             full_mname = self.modname + '::' + \
843                 '.'.join(self.objpath + [mname])
844             documenter = classes[-1](self.directive, full_mname, self.indent)
845             memberdocumenters.append((documenter, isattr))
846 
847         member_order = self.options.member_order or self.config.autodoc_member_order
848         memberdocumenters = self.sort_members(memberdocumenters, member_order)
849 
850         for documenter, isattr in memberdocumenters:
851             documenter.generate(
852                 all_members=True, real_modname=self.real_modname,
853                 check_module=members_check_module and not isattr)
854 
855         # reset current objects
856         self.env.temp_data['autodoc:module'] = None
857         self.env.temp_data['autodoc:class'] = None
858 
859     def sort_members(self, documenters: List[Tuple["Documenter", bool]],
860                      order: str) -> List[Tuple["Documenter", bool]]:
861         """Sort the given member list."""
862         if order == 'groupwise':
863             # sort by group; alphabetically within groups
864             documenters.sort(key=lambda e: (e[0].member_order, e[0].name))
865         elif order == 'bysource':
866             if self.analyzer:
867                 # sort by source order, by virtue of the module analyzer
868                 tagorder = self.analyzer.tagorder
869 
870                 def keyfunc(entry: Tuple[Documenter, bool]) -> int:
871                     fullname = entry[0].name.split('::')[1]
872                     return tagorder.get(fullname, len(tagorder))
873                 documenters.sort(key=keyfunc)
874             else:
875                 # Assume that member discovery order matches source order.
876                 # This is a reasonable assumption in Python 3.6 and up, where
877                 # module.__dict__ is insertion-ordered.
878                 pass
879         else:  # alphabetical
880             documenters.sort(key=lambda e: e[0].name)
881 
882         return documenters
883 
884     def generate(self, more_content: Optional[StringList] = None, real_modname: str = None,
885                  check_module: bool = False, all_members: bool = False) -> None:
886         """Generate reST for the object given by *self.name*, and possibly for
887         its members.
888 
889         If *more_content* is given, include that content. If *real_modname* is
890         given, use that module name to find attribute docs. If *check_module* is
891         True, only generate if the object is defined in the module name it is
892         imported from. If *all_members* is True, document all members.
893         """
894         if not self.parse_name():
895             # need a module to import
896             logger.warning(
897                 __('don\'t know which module to import for autodocumenting '
898                    '%r (try placing a "module" or "currentmodule" directive '
899                    'in the document, or giving an explicit module name)') %
900                 self.name, type='autodoc')
901             return
902 
903         # now, import the module and get object to document
904         if not self.import_object():
905             return
906 
907         # If there is no real module defined, figure out which to use.
908         # The real module is used in the module analyzer to look up the module
909         # where the attribute documentation would actually be found in.
910         # This is used for situations where you have a module that collects the
911         # functions and classes of internal submodules.
912         guess_modname = self.get_real_modname()
913         self.real_modname = real_modname or guess_modname
914 
915         # try to also get a source code analyzer for attribute docs
916         try:
917             self.analyzer = ModuleAnalyzer.for_module(self.real_modname)
918             # parse right now, to get PycodeErrors on parsing (results will
919             # be cached anyway)
920             self.analyzer.find_attr_docs()
921         except PycodeError as exc:
922             logger.debug('[autodoc] module analyzer failed: %s', exc)
923             # no source file -- e.g. for builtin and C modules
924             self.analyzer = None
925             # at least add the module.__file__ as a dependency
926             if hasattr(self.module, '__file__') and self.module.__file__:
927                 self.directive.filename_set.add(self.module.__file__)
928         else:
929             self.directive.filename_set.add(self.analyzer.srcname)
930 
931         if self.real_modname != guess_modname:
932             # Add module to dependency list if target object is defined in other module.
933             try:
934                 analyzer = ModuleAnalyzer.for_module(guess_modname)
935                 self.directive.filename_set.add(analyzer.srcname)
936             except PycodeError:
937                 pass
938 
939         # check __module__ of object (for members not given explicitly)
940         if check_module:
941             if not self.check_module():
942                 return
943 
944         sourcename = self.get_sourcename()
945 
946         # make sure that the result starts with an empty line.  This is
947         # necessary for some situations where another directive preprocesses
948         # reST and no starting newline is present
949         self.add_line('', sourcename)
950 
951         # format the object's signature, if any
952         try:
953             sig = self.format_signature()
954         except Exception as exc:
955             logger.warning(__('error while formatting signature for %s: %s'),
956                            self.fullname, exc, type='autodoc')
957             return
958 
959         # generate the directive header and options, if applicable
960         self.add_directive_header(sig)
961         self.add_line('', sourcename)
962 
963         # e.g. the module directive doesn't have content
964         self.indent += self.content_indent
965 
966         # add all content (from docstrings, attribute docs etc.)
967         self.add_content(more_content)
968 
969         # document members, if possible
970         self.document_members(all_members)

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>]
2025-10-18 18:44:29.745 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-18 18:44:29.745 | INFO     | Search-only: skipping patch selection
2025-10-18 18:44:29.834 | INFO     | Task sphinx-doc__sphinx-8801 completed successfully.
2025-10-18 18:44:29.834 | INFO     | No patch generated. You can try running ACR again.
