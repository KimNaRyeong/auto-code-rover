2025-10-18 16:21:12.631 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-18 16:21:16.250 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=364, output_tokens=12, cost=0.004000
2025-10-18 16:21:16.251 | INFO     | Test agent decides that the issue statement does not contain reproduction steps; skipping reproducer tracing
2025-10-18 16:21:16.255 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 16:21:18.574 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=671, output_tokens=80, cost=0.009110
2025-10-18 16:21:18.578 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 16:21:21.960 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=434, output_tokens=35, cost=0.005390
2025-10-18 16:21:21.961 | DEBUG    | Extracted a valid json.
2025-10-18 16:21:21.961 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_code(\"DEFAULT_LOG_FORMAT\")",
        "search_code(\"logging.basicConfig\")"
    ],
    "bug_locations": []
}
2025-10-18 16:21:21.986 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-18 16:21:21.987 | DEBUG    | <Agent search> Analyzing search results.
2025-10-18 16:21:33.899 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1437, output_tokens=604, cost=0.032490
2025-10-18 16:21:33.912 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 16:21:38.280 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2257, output_tokens=188, cost=0.028210
2025-10-18 16:21:38.285 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 16:21:46.472 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=542, output_tokens=190, cost=0.011120
2025-10-18 16:21:46.473 | DEBUG    | Extracted a valid json.
2025-10-18 16:21:46.473 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations":[{"file": "src/_pytest/logging.py", "class": "", "method": "", "intended_behavior": "Modify the `DEFAULT_LOG_FORMAT` to include the module name (`name`) and potentially explore reducing the length of the path while preserving essential parts of it. The new format suggested in the issue, \"%(levelname)-8s %(name)s:%(filename)s:%(lineno)d %(message)s\", should replace the old format. This change will allow log messages to carry more contextual information (i.e., the module name along with the filename and line number), without significantly altering the existing functionality. The revised logging format will enhance debugging capabilities by making the logs more informative, showing not just where (filename and line number) but also in what context (module name) the log was generated, thereby adhering to the request for improved readability and usefulness in log messages."}]
}
2025-10-18 16:21:46.478 | DEBUG    | Bug location extracted successfully: [<file>src/_pytest/logging.py</file>
<class>None</class>
<method>None</method>
<code>
1 """ Access and control log capturing. """
2 from __future__ import absolute_import
3 from __future__ import division
4 from __future__ import print_function
5 
6 import logging
7 import re
8 from contextlib import contextmanager
9 
10 import py
11 import six
12 
13 import pytest
14 from _pytest.compat import dummy_context_manager
15 from _pytest.config import create_terminal_writer
16 from _pytest.pathlib import Path
17 
18 DEFAULT_LOG_FORMAT = "%(filename)-25s %(lineno)4d %(levelname)-8s %(message)s"
19 DEFAULT_LOG_DATE_FORMAT = "%H:%M:%S"
20 
21 
22 class ColoredLevelFormatter(logging.Formatter):
23     """
24     Colorize the %(levelname)..s part of the log format passed to __init__.
25     """
26 
27     LOGLEVEL_COLOROPTS = {
28         logging.CRITICAL: {"red"},
29         logging.ERROR: {"red", "bold"},
30         logging.WARNING: {"yellow"},
31         logging.WARN: {"yellow"},
32         logging.INFO: {"green"},
33         logging.DEBUG: {"purple"},
34         logging.NOTSET: set(),
35     }
36     LEVELNAME_FMT_REGEX = re.compile(r"%\(levelname\)([+-]?\d*s)")
37 
38     def __init__(self, terminalwriter, *args, **kwargs):
39         super(ColoredLevelFormatter, self).__init__(*args, **kwargs)
40         if six.PY2:
41             self._original_fmt = self._fmt
42         else:
43             self._original_fmt = self._style._fmt
44         self._level_to_fmt_mapping = {}
45 
46         levelname_fmt_match = self.LEVELNAME_FMT_REGEX.search(self._fmt)
47         if not levelname_fmt_match:
48             return
49         levelname_fmt = levelname_fmt_match.group()
50 
51         for level, color_opts in self.LOGLEVEL_COLOROPTS.items():
52             formatted_levelname = levelname_fmt % {
53                 "levelname": logging.getLevelName(level)
54             }
55 
56             # add ANSI escape sequences around the formatted levelname
57             color_kwargs = {name: True for name in color_opts}
58             colorized_formatted_levelname = terminalwriter.markup(
59                 formatted_levelname, **color_kwargs
60             )
61             self._level_to_fmt_mapping[level] = self.LEVELNAME_FMT_REGEX.sub(
62                 colorized_formatted_levelname, self._fmt
63             )
64 
65     def format(self, record):
66         fmt = self._level_to_fmt_mapping.get(record.levelno, self._original_fmt)
67         if six.PY2:
68             self._fmt = fmt
69         else:
70             self._style._fmt = fmt
71         return super(ColoredLevelFormatter, self).format(record)
72 
73 
74 def get_option_ini(config, *names):
75     for name in names:
76         ret = config.getoption(name)  # 'default' arg won't work as expected
77         if ret is None:
78             ret = config.getini(name)
79         if ret:
80             return ret
81 
82 
83 def pytest_addoption(parser):
84     """Add options to control log capturing."""
85     group = parser.getgroup("logging")
86 
87     def add_option_ini(option, dest, default=None, type=None, **kwargs):
88         parser.addini(
89             dest, default=default, type=type, help="default value for " + option
90         )
91         group.addoption(option, dest=dest, **kwargs)
92 
93     add_option_ini(
94         "--no-print-logs",
95         dest="log_print",
96         action="store_const",
97         const=False,
98         default=True,
99         type="bool",
100         help="disable printing caught logs on failed tests.",
101     )
102     add_option_ini(
103         "--log-level",
104         dest="log_level",
105         default=None,
106         help="logging level used by the logging module",
107     )
108     add_option_ini(
109         "--log-format",
110         dest="log_format",
111         default=DEFAULT_LOG_FORMAT,
112         help="log format as used by the logging module.",
113     )
114     add_option_ini(
115         "--log-date-format",
116         dest="log_date_format",
117         default=DEFAULT_LOG_DATE_FORMAT,
118         help="log date format as used by the logging module.",
119     )
120     parser.addini(
121         "log_cli",
122         default=False,
123         type="bool",
124         help='enable log display during test run (also known as "live logging").',
125     )
126     add_option_ini(
127         "--log-cli-level", dest="log_cli_level", default=None, help="cli logging level."
128     )
129     add_option_ini(
130         "--log-cli-format",
131         dest="log_cli_format",
132         default=None,
133         help="log format as used by the logging module.",
134     )
135     add_option_ini(
136         "--log-cli-date-format",
137         dest="log_cli_date_format",
138         default=None,
139         help="log date format as used by the logging module.",
140     )
141     add_option_ini(
142         "--log-file",
143         dest="log_file",
144         default=None,
145         help="path to a file when logging will be written to.",
146     )
147     add_option_ini(
148         "--log-file-level",
149         dest="log_file_level",
150         default=None,
151         help="log file logging level.",
152     )
153     add_option_ini(
154         "--log-file-format",
155         dest="log_file_format",
156         default=DEFAULT_LOG_FORMAT,
157         help="log format as used by the logging module.",
158     )
159     add_option_ini(
160         "--log-file-date-format",
161         dest="log_file_date_format",
162         default=DEFAULT_LOG_DATE_FORMAT,
163         help="log date format as used by the logging module.",
164     )
165 
166 
167 @contextmanager
168 def catching_logs(handler, formatter=None, level=None):
169     """Context manager that prepares the whole logging machinery properly."""
170     root_logger = logging.getLogger()
171 
172     if formatter is not None:
173         handler.setFormatter(formatter)
174     if level is not None:
175         handler.setLevel(level)
176 
177     # Adding the same handler twice would confuse logging system.
178     # Just don't do that.
179     add_new_handler = handler not in root_logger.handlers
180 
181     if add_new_handler:
182         root_logger.addHandler(handler)
183     if level is not None:
184         orig_level = root_logger.level
185         root_logger.setLevel(min(orig_level, level))
186     try:
187         yield handler
188     finally:
189         if level is not None:
190             root_logger.setLevel(orig_level)
191         if add_new_handler:
192             root_logger.removeHandler(handler)
193 
194 
195 class LogCaptureHandler(logging.StreamHandler):
196     """A logging handler that stores log records and the log text."""
197 
198     def __init__(self):
199         """Creates a new log handler."""
200         logging.StreamHandler.__init__(self, py.io.TextIO())
201         self.records = []
202 
203     def emit(self, record):
204         """Keep the log records in a list in addition to the log text."""
205         self.records.append(record)
206         logging.StreamHandler.emit(self, record)
207 
208     def reset(self):
209         self.records = []
210         self.stream = py.io.TextIO()
211 
212 
213 class LogCaptureFixture(object):
214     """Provides access and control of log capturing."""
215 
216     def __init__(self, item):
217         """Creates a new funcarg."""
218         self._item = item
219         # dict of log name -> log level
220         self._initial_log_levels = {}  # Dict[str, int]
221 
222     def _finalize(self):
223         """Finalizes the fixture.
224 
225         This restores the log levels changed by :meth:`set_level`.
226         """
227         # restore log levels
228         for logger_name, level in self._initial_log_levels.items():
229             logger = logging.getLogger(logger_name)
230             logger.setLevel(level)
231 
232     @property
233     def handler(self):
234         """
235         :rtype: LogCaptureHandler
236         """
237         return self._item.catch_log_handler
238 
239     def get_records(self, when):
240         """
241         Get the logging records for one of the possible test phases.
242 
243         :param str when:
244             Which test phase to obtain the records from. Valid values are: "setup", "call" and "teardown".
245 
246         :rtype: List[logging.LogRecord]
247         :return: the list of captured records at the given stage
248 
249         .. versionadded:: 3.4
250         """
251         handler = self._item.catch_log_handlers.get(when)
252         if handler:
253             return handler.records
254         else:
255             return []
256 
257     @property
258     def text(self):
259         """Returns the log text."""
260         return self.handler.stream.getvalue()
261 
262     @property
263     def records(self):
264         """Returns the list of log records."""
265         return self.handler.records
266 
267     @property
268     def record_tuples(self):
269         """Returns a list of a stripped down version of log records intended
270         for use in assertion comparison.
271 
272         The format of the tuple is:
273 
274             (logger_name, log_level, message)
275         """
276         return [(r.name, r.levelno, r.getMessage()) for r in self.records]
277 
278     @property
279     def messages(self):
280         """Returns a list of format-interpolated log messages.
281 
282         Unlike 'records', which contains the format string and parameters for interpolation, log messages in this list
283         are all interpolated.
284         Unlike 'text', which contains the output from the handler, log messages in this list are unadorned with
285         levels, timestamps, etc, making exact comparisons more reliable.
286 
287         Note that traceback or stack info (from :func:`logging.exception` or the `exc_info` or `stack_info` arguments
288         to the logging functions) is not included, as this is added by the formatter in the handler.
289 
290         .. versionadded:: 3.7
291         """
292         return [r.getMessage() for r in self.records]
293 
294     def clear(self):
295         """Reset the list of log records and the captured log text."""
296         self.handler.reset()
297 
298     def set_level(self, level, logger=None):
299         """Sets the level for capturing of logs. The level will be restored to its previous value at the end of
300         the test.
301 
302         :param int level: the logger to level.
303         :param str logger: the logger to update the level. If not given, the root logger level is updated.
304 
305         .. versionchanged:: 3.4
306             The levels of the loggers changed by this function will be restored to their initial values at the
307             end of the test.
308         """
309         logger_name = logger
310         logger = logging.getLogger(logger_name)
311         # save the original log-level to restore it during teardown
312         self._initial_log_levels.setdefault(logger_name, logger.level)
313         logger.setLevel(level)
314 
315     @contextmanager
316     def at_level(self, level, logger=None):
317         """Context manager that sets the level for capturing of logs. After the end of the 'with' statement the
318         level is restored to its original value.
319 
320         :param int level: the logger to level.
321         :param str logger: the logger to update the level. If not given, the root logger level is updated.
322         """
323         logger = logging.getLogger(logger)
324         orig_level = logger.level
325         logger.setLevel(level)
326         try:
327             yield
328         finally:
329             logger.setLevel(orig_level)
330 
331 
332 @pytest.fixture
333 def caplog(request):
334     """Access and control log capturing.
335 
336     Captured logs are available through the following properties/methods::
337 
338     * caplog.text            -> string containing formatted log output
339     * caplog.records         -> list of logging.LogRecord instances
340     * caplog.record_tuples   -> list of (logger_name, level, message) tuples
341     * caplog.clear()         -> clear captured records and formatted log output string
342     """
343     result = LogCaptureFixture(request.node)
344     yield result
345     result._finalize()
346 
347 
348 def get_actual_log_level(config, *setting_names):
349     """Return the actual logging level."""
350 
351     for setting_name in setting_names:
352         log_level = config.getoption(setting_name)
353         if log_level is None:
354             log_level = config.getini(setting_name)
355         if log_level:
356             break
357     else:
358         return
359 
360     if isinstance(log_level, six.string_types):
361         log_level = log_level.upper()
362     try:
363         return int(getattr(logging, log_level, log_level))
364     except ValueError:
365         # Python logging does not recognise this as a logging level
366         raise pytest.UsageError(
367             "'{}' is not recognized as a logging level name for "
368             "'{}'. Please consider passing the "
369             "logging level num instead.".format(log_level, setting_name)
370         )
371 
372 
373 # run after terminalreporter/capturemanager are configured
374 @pytest.hookimpl(trylast=True)
375 def pytest_configure(config):
376     config.pluginmanager.register(LoggingPlugin(config), "logging-plugin")
377 
378 
379 class LoggingPlugin(object):
380     """Attaches to the logging module and captures log messages for each test.
381     """
382 
383     def __init__(self, config):
384         """Creates a new plugin to capture log messages.
385 
386         The formatter can be safely shared across all handlers so
387         create a single one for the entire test session here.
388         """
389         self._config = config
390 
391         # enable verbose output automatically if live logging is enabled
392         if self._log_cli_enabled() and config.getoption("verbose") < 1:
393             config.option.verbose = 1
394 
395         self.print_logs = get_option_ini(config, "log_print")
396         self.formatter = logging.Formatter(
397             get_option_ini(config, "log_format"),
398             get_option_ini(config, "log_date_format"),
399         )
400         self.log_level = get_actual_log_level(config, "log_level")
401 
402         self.log_file_level = get_actual_log_level(config, "log_file_level")
403         self.log_file_format = get_option_ini(config, "log_file_format", "log_format")
404         self.log_file_date_format = get_option_ini(
405             config, "log_file_date_format", "log_date_format"
406         )
407         self.log_file_formatter = logging.Formatter(
408             self.log_file_format, datefmt=self.log_file_date_format
409         )
410 
411         log_file = get_option_ini(config, "log_file")
412         if log_file:
413             self.log_file_handler = logging.FileHandler(
414                 log_file, mode="w", encoding="UTF-8"
415             )
416             self.log_file_handler.setFormatter(self.log_file_formatter)
417         else:
418             self.log_file_handler = None
419 
420         self.log_cli_handler = None
421 
422         self.live_logs_context = lambda: dummy_context_manager()
423         # Note that the lambda for the live_logs_context is needed because
424         # live_logs_context can otherwise not be entered multiple times due
425         # to limitations of contextlib.contextmanager.
426 
427         if self._log_cli_enabled():
428             self._setup_cli_logging()
429 
430     def _setup_cli_logging(self):
431         config = self._config
432         terminal_reporter = config.pluginmanager.get_plugin("terminalreporter")
433         if terminal_reporter is None:
434             # terminal reporter is disabled e.g. by pytest-xdist.
435             return
436 
437         capture_manager = config.pluginmanager.get_plugin("capturemanager")
438         # if capturemanager plugin is disabled, live logging still works.
439         log_cli_handler = _LiveLoggingStreamHandler(terminal_reporter, capture_manager)
440         log_cli_format = get_option_ini(config, "log_cli_format", "log_format")
441         log_cli_date_format = get_option_ini(
442             config, "log_cli_date_format", "log_date_format"
443         )
444         if (
445             config.option.color != "no"
446             and ColoredLevelFormatter.LEVELNAME_FMT_REGEX.search(log_cli_format)
447         ):
448             log_cli_formatter = ColoredLevelFormatter(
449                 create_terminal_writer(config),
450                 log_cli_format,
451                 datefmt=log_cli_date_format,
452             )
453         else:
454             log_cli_formatter = logging.Formatter(
455                 log_cli_format, datefmt=log_cli_date_format
456             )
457         log_cli_level = get_actual_log_level(config, "log_cli_level", "log_level")
458         self.log_cli_handler = log_cli_handler
459         self.live_logs_context = lambda: catching_logs(
460             log_cli_handler, formatter=log_cli_formatter, level=log_cli_level
461         )
462 
463     def set_log_path(self, fname):
464         """Public method, which can set filename parameter for
465         Logging.FileHandler(). Also creates parent directory if
466         it does not exist.
467 
468         .. warning::
469             Please considered as an experimental API.
470         """
471         fname = Path(fname)
472 
473         if not fname.is_absolute():
474             fname = Path(self._config.rootdir, fname)
475 
476         if not fname.parent.exists():
477             fname.parent.mkdir(exist_ok=True, parents=True)
478 
479         self.log_file_handler = logging.FileHandler(
480             str(fname), mode="w", encoding="UTF-8"
481         )
482         self.log_file_handler.setFormatter(self.log_file_formatter)
483 
484     def _log_cli_enabled(self):
485         """Return True if log_cli should be considered enabled, either explicitly
486         or because --log-cli-level was given in the command-line.
487         """
488         return self._config.getoption(
489             "--log-cli-level"
490         ) is not None or self._config.getini("log_cli")
491 
492     @pytest.hookimpl(hookwrapper=True, tryfirst=True)
493     def pytest_collection(self):
494         with self.live_logs_context():
495             if self.log_cli_handler:
496                 self.log_cli_handler.set_when("collection")
497 
498             if self.log_file_handler is not None:
499                 with catching_logs(self.log_file_handler, level=self.log_file_level):
500                     yield
501             else:
502                 yield
503 
504     @contextmanager
505     def _runtest_for(self, item, when):
506         with self._runtest_for_main(item, when):
507             if self.log_file_handler is not None:
508                 with catching_logs(self.log_file_handler, level=self.log_file_level):
509                     yield
510             else:
511                 yield
512 
513     @contextmanager
514     def _runtest_for_main(self, item, when):
515         """Implements the internals of pytest_runtest_xxx() hook."""
516         with catching_logs(
517             LogCaptureHandler(), formatter=self.formatter, level=self.log_level
518         ) as log_handler:
519             if self.log_cli_handler:
520                 self.log_cli_handler.set_when(when)
521 
522             if item is None:
523                 yield  # run the test
524                 return
525 
526             if not hasattr(item, "catch_log_handlers"):
527                 item.catch_log_handlers = {}
528             item.catch_log_handlers[when] = log_handler
529             item.catch_log_handler = log_handler
530             try:
531                 yield  # run test
532             finally:
533                 if when == "teardown":
534                     del item.catch_log_handler
535                     del item.catch_log_handlers
536 
537             if self.print_logs:
538                 # Add a captured log section to the report.
539                 log = log_handler.stream.getvalue().strip()
540                 item.add_report_section(when, "log", log)
541 
542     @pytest.hookimpl(hookwrapper=True)
543     def pytest_runtest_setup(self, item):
544         with self._runtest_for(item, "setup"):
545             yield
546 
547     @pytest.hookimpl(hookwrapper=True)
548     def pytest_runtest_call(self, item):
549         with self._runtest_for(item, "call"):
550             yield
551 
552     @pytest.hookimpl(hookwrapper=True)
553     def pytest_runtest_teardown(self, item):
554         with self._runtest_for(item, "teardown"):
555             yield
556 
557     @pytest.hookimpl(hookwrapper=True)
558     def pytest_runtest_logstart(self):
559         if self.log_cli_handler:
560             self.log_cli_handler.reset()
561         with self._runtest_for(None, "start"):
562             yield
563 
564     @pytest.hookimpl(hookwrapper=True)
565     def pytest_runtest_logfinish(self):
566         with self._runtest_for(None, "finish"):
567             yield
568 
569     @pytest.hookimpl(hookwrapper=True)
570     def pytest_runtest_logreport(self):
571         with self._runtest_for(None, "logreport"):
572             yield
573 
574     @pytest.hookimpl(hookwrapper=True, tryfirst=True)
575     def pytest_sessionfinish(self):
576         with self.live_logs_context():
577             if self.log_cli_handler:
578                 self.log_cli_handler.set_when("sessionfinish")
579             if self.log_file_handler is not None:
580                 try:
581                     with catching_logs(
582                         self.log_file_handler, level=self.log_file_level
583                     ):
584                         yield
585                 finally:
586                     # Close the FileHandler explicitly.
587                     # (logging.shutdown might have lost the weakref?!)
588                     self.log_file_handler.close()
589             else:
590                 yield
591 
592     @pytest.hookimpl(hookwrapper=True, tryfirst=True)
593     def pytest_sessionstart(self):
594         with self.live_logs_context():
595             if self.log_cli_handler:
596                 self.log_cli_handler.set_when("sessionstart")
597             if self.log_file_handler is not None:
598                 with catching_logs(self.log_file_handler, level=self.log_file_level):
599                     yield
600             else:
601                 yield
602 
603     @pytest.hookimpl(hookwrapper=True)
604     def pytest_runtestloop(self, session):
605         """Runs all collected test items."""
606         with self.live_logs_context():
607             if self.log_file_handler is not None:
608                 with catching_logs(self.log_file_handler, level=self.log_file_level):
609                     yield  # run all the tests
610             else:
611                 yield  # run all the tests
612 
613 
614 class _LiveLoggingStreamHandler(logging.StreamHandler):
615     """
616     Custom StreamHandler used by the live logging feature: it will write a newline before the first log message
617     in each test.
618 
619     During live logging we must also explicitly disable stdout/stderr capturing otherwise it will get captured
620     and won't appear in the terminal.
621     """
622 
623     def __init__(self, terminal_reporter, capture_manager):
624         """
625         :param _pytest.terminal.TerminalReporter terminal_reporter:
626         :param _pytest.capture.CaptureManager capture_manager:
627         """
628         logging.StreamHandler.__init__(self, stream=terminal_reporter)
629         self.capture_manager = capture_manager
630         self.reset()
631         self.set_when(None)
632         self._test_outcome_written = False
633 
634     def reset(self):
635         """Reset the handler; should be called before the start of each test"""
636         self._first_record_emitted = False
637 
638     def set_when(self, when):
639         """Prepares for the given test phase (setup/call/teardown)"""
640         self._when = when
641         self._section_name_shown = False
642         if when == "start":
643             self._test_outcome_written = False
644 
645     def emit(self, record):
646         ctx_manager = (
647             self.capture_manager.global_and_fixture_disabled()
648             if self.capture_manager
649             else dummy_context_manager()
650         )
651         with ctx_manager:
652             if not self._first_record_emitted:
653                 self.stream.write("\n")
654                 self._first_record_emitted = True
655             elif self._when in ("teardown", "finish"):
656                 if not self._test_outcome_written:
657                     self._test_outcome_written = True
658                     self.stream.write("\n")
659             if not self._section_name_shown and self._when:
660                 self.stream.section("live log " + self._when, sep="-", bold=True)
661                 self._section_name_shown = True
662             logging.StreamHandler.emit(self, record)

</code><intended_behavior>Modify the `DEFAULT_LOG_FORMAT` to include the module name (`name`) and potentially explore reducing the length of the path while preserving essential parts of it. The new format suggested in the issue, "%(levelname)-8s %(name)s:%(filename)s:%(lineno)d %(message)s", should replace the old format. This change will allow log messages to carry more contextual information (i.e., the module name along with the filename and line number), without significantly altering the existing functionality. The revised logging format will enhance debugging capabilities by making the logs more informative, showing not just where (filename and line number) but also in what context (module name) the log was generated, thereby adhering to the request for improved readability and usefulness in log messages.</intended_behavior>]
2025-10-18 16:21:46.478 | INFO     | Search completed. Bug locations: [<file>src/_pytest/logging.py</file>
<class>None</class>
<method>None</method>
<code>
1 """ Access and control log capturing. """
2 from __future__ import absolute_import
3 from __future__ import division
4 from __future__ import print_function
5 
6 import logging
7 import re
8 from contextlib import contextmanager
9 
10 import py
11 import six
12 
13 import pytest
14 from _pytest.compat import dummy_context_manager
15 from _pytest.config import create_terminal_writer
16 from _pytest.pathlib import Path
17 
18 DEFAULT_LOG_FORMAT = "%(filename)-25s %(lineno)4d %(levelname)-8s %(message)s"
19 DEFAULT_LOG_DATE_FORMAT = "%H:%M:%S"
20 
21 
22 class ColoredLevelFormatter(logging.Formatter):
23     """
24     Colorize the %(levelname)..s part of the log format passed to __init__.
25     """
26 
27     LOGLEVEL_COLOROPTS = {
28         logging.CRITICAL: {"red"},
29         logging.ERROR: {"red", "bold"},
30         logging.WARNING: {"yellow"},
31         logging.WARN: {"yellow"},
32         logging.INFO: {"green"},
33         logging.DEBUG: {"purple"},
34         logging.NOTSET: set(),
35     }
36     LEVELNAME_FMT_REGEX = re.compile(r"%\(levelname\)([+-]?\d*s)")
37 
38     def __init__(self, terminalwriter, *args, **kwargs):
39         super(ColoredLevelFormatter, self).__init__(*args, **kwargs)
40         if six.PY2:
41             self._original_fmt = self._fmt
42         else:
43             self._original_fmt = self._style._fmt
44         self._level_to_fmt_mapping = {}
45 
46         levelname_fmt_match = self.LEVELNAME_FMT_REGEX.search(self._fmt)
47         if not levelname_fmt_match:
48             return
49         levelname_fmt = levelname_fmt_match.group()
50 
51         for level, color_opts in self.LOGLEVEL_COLOROPTS.items():
52             formatted_levelname = levelname_fmt % {
53                 "levelname": logging.getLevelName(level)
54             }
55 
56             # add ANSI escape sequences around the formatted levelname
57             color_kwargs = {name: True for name in color_opts}
58             colorized_formatted_levelname = terminalwriter.markup(
59                 formatted_levelname, **color_kwargs
60             )
61             self._level_to_fmt_mapping[level] = self.LEVELNAME_FMT_REGEX.sub(
62                 colorized_formatted_levelname, self._fmt
63             )
64 
65     def format(self, record):
66         fmt = self._level_to_fmt_mapping.get(record.levelno, self._original_fmt)
67         if six.PY2:
68             self._fmt = fmt
69         else:
70             self._style._fmt = fmt
71         return super(ColoredLevelFormatter, self).format(record)
72 
73 
74 def get_option_ini(config, *names):
75     for name in names:
76         ret = config.getoption(name)  # 'default' arg won't work as expected
77         if ret is None:
78             ret = config.getini(name)
79         if ret:
80             return ret
81 
82 
83 def pytest_addoption(parser):
84     """Add options to control log capturing."""
85     group = parser.getgroup("logging")
86 
87     def add_option_ini(option, dest, default=None, type=None, **kwargs):
88         parser.addini(
89             dest, default=default, type=type, help="default value for " + option
90         )
91         group.addoption(option, dest=dest, **kwargs)
92 
93     add_option_ini(
94         "--no-print-logs",
95         dest="log_print",
96         action="store_const",
97         const=False,
98         default=True,
99         type="bool",
100         help="disable printing caught logs on failed tests.",
101     )
102     add_option_ini(
103         "--log-level",
104         dest="log_level",
105         default=None,
106         help="logging level used by the logging module",
107     )
108     add_option_ini(
109         "--log-format",
110         dest="log_format",
111         default=DEFAULT_LOG_FORMAT,
112         help="log format as used by the logging module.",
113     )
114     add_option_ini(
115         "--log-date-format",
116         dest="log_date_format",
117         default=DEFAULT_LOG_DATE_FORMAT,
118         help="log date format as used by the logging module.",
119     )
120     parser.addini(
121         "log_cli",
122         default=False,
123         type="bool",
124         help='enable log display during test run (also known as "live logging").',
125     )
126     add_option_ini(
127         "--log-cli-level", dest="log_cli_level", default=None, help="cli logging level."
128     )
129     add_option_ini(
130         "--log-cli-format",
131         dest="log_cli_format",
132         default=None,
133         help="log format as used by the logging module.",
134     )
135     add_option_ini(
136         "--log-cli-date-format",
137         dest="log_cli_date_format",
138         default=None,
139         help="log date format as used by the logging module.",
140     )
141     add_option_ini(
142         "--log-file",
143         dest="log_file",
144         default=None,
145         help="path to a file when logging will be written to.",
146     )
147     add_option_ini(
148         "--log-file-level",
149         dest="log_file_level",
150         default=None,
151         help="log file logging level.",
152     )
153     add_option_ini(
154         "--log-file-format",
155         dest="log_file_format",
156         default=DEFAULT_LOG_FORMAT,
157         help="log format as used by the logging module.",
158     )
159     add_option_ini(
160         "--log-file-date-format",
161         dest="log_file_date_format",
162         default=DEFAULT_LOG_DATE_FORMAT,
163         help="log date format as used by the logging module.",
164     )
165 
166 
167 @contextmanager
168 def catching_logs(handler, formatter=None, level=None):
169     """Context manager that prepares the whole logging machinery properly."""
170     root_logger = logging.getLogger()
171 
172     if formatter is not None:
173         handler.setFormatter(formatter)
174     if level is not None:
175         handler.setLevel(level)
176 
177     # Adding the same handler twice would confuse logging system.
178     # Just don't do that.
179     add_new_handler = handler not in root_logger.handlers
180 
181     if add_new_handler:
182         root_logger.addHandler(handler)
183     if level is not None:
184         orig_level = root_logger.level
185         root_logger.setLevel(min(orig_level, level))
186     try:
187         yield handler
188     finally:
189         if level is not None:
190             root_logger.setLevel(orig_level)
191         if add_new_handler:
192             root_logger.removeHandler(handler)
193 
194 
195 class LogCaptureHandler(logging.StreamHandler):
196     """A logging handler that stores log records and the log text."""
197 
198     def __init__(self):
199         """Creates a new log handler."""
200         logging.StreamHandler.__init__(self, py.io.TextIO())
201         self.records = []
202 
203     def emit(self, record):
204         """Keep the log records in a list in addition to the log text."""
205         self.records.append(record)
206         logging.StreamHandler.emit(self, record)
207 
208     def reset(self):
209         self.records = []
210         self.stream = py.io.TextIO()
211 
212 
213 class LogCaptureFixture(object):
214     """Provides access and control of log capturing."""
215 
216     def __init__(self, item):
217         """Creates a new funcarg."""
218         self._item = item
219         # dict of log name -> log level
220         self._initial_log_levels = {}  # Dict[str, int]
221 
222     def _finalize(self):
223         """Finalizes the fixture.
224 
225         This restores the log levels changed by :meth:`set_level`.
226         """
227         # restore log levels
228         for logger_name, level in self._initial_log_levels.items():
229             logger = logging.getLogger(logger_name)
230             logger.setLevel(level)
231 
232     @property
233     def handler(self):
234         """
235         :rtype: LogCaptureHandler
236         """
237         return self._item.catch_log_handler
238 
239     def get_records(self, when):
240         """
241         Get the logging records for one of the possible test phases.
242 
243         :param str when:
244             Which test phase to obtain the records from. Valid values are: "setup", "call" and "teardown".
245 
246         :rtype: List[logging.LogRecord]
247         :return: the list of captured records at the given stage
248 
249         .. versionadded:: 3.4
250         """
251         handler = self._item.catch_log_handlers.get(when)
252         if handler:
253             return handler.records
254         else:
255             return []
256 
257     @property
258     def text(self):
259         """Returns the log text."""
260         return self.handler.stream.getvalue()
261 
262     @property
263     def records(self):
264         """Returns the list of log records."""
265         return self.handler.records
266 
267     @property
268     def record_tuples(self):
269         """Returns a list of a stripped down version of log records intended
270         for use in assertion comparison.
271 
272         The format of the tuple is:
273 
274             (logger_name, log_level, message)
275         """
276         return [(r.name, r.levelno, r.getMessage()) for r in self.records]
277 
278     @property
279     def messages(self):
280         """Returns a list of format-interpolated log messages.
281 
282         Unlike 'records', which contains the format string and parameters for interpolation, log messages in this list
283         are all interpolated.
284         Unlike 'text', which contains the output from the handler, log messages in this list are unadorned with
285         levels, timestamps, etc, making exact comparisons more reliable.
286 
287         Note that traceback or stack info (from :func:`logging.exception` or the `exc_info` or `stack_info` arguments
288         to the logging functions) is not included, as this is added by the formatter in the handler.
289 
290         .. versionadded:: 3.7
291         """
292         return [r.getMessage() for r in self.records]
293 
294     def clear(self):
295         """Reset the list of log records and the captured log text."""
296         self.handler.reset()
297 
298     def set_level(self, level, logger=None):
299         """Sets the level for capturing of logs. The level will be restored to its previous value at the end of
300         the test.
301 
302         :param int level: the logger to level.
303         :param str logger: the logger to update the level. If not given, the root logger level is updated.
304 
305         .. versionchanged:: 3.4
306             The levels of the loggers changed by this function will be restored to their initial values at the
307             end of the test.
308         """
309         logger_name = logger
310         logger = logging.getLogger(logger_name)
311         # save the original log-level to restore it during teardown
312         self._initial_log_levels.setdefault(logger_name, logger.level)
313         logger.setLevel(level)
314 
315     @contextmanager
316     def at_level(self, level, logger=None):
317         """Context manager that sets the level for capturing of logs. After the end of the 'with' statement the
318         level is restored to its original value.
319 
320         :param int level: the logger to level.
321         :param str logger: the logger to update the level. If not given, the root logger level is updated.
322         """
323         logger = logging.getLogger(logger)
324         orig_level = logger.level
325         logger.setLevel(level)
326         try:
327             yield
328         finally:
329             logger.setLevel(orig_level)
330 
331 
332 @pytest.fixture
333 def caplog(request):
334     """Access and control log capturing.
335 
336     Captured logs are available through the following properties/methods::
337 
338     * caplog.text            -> string containing formatted log output
339     * caplog.records         -> list of logging.LogRecord instances
340     * caplog.record_tuples   -> list of (logger_name, level, message) tuples
341     * caplog.clear()         -> clear captured records and formatted log output string
342     """
343     result = LogCaptureFixture(request.node)
344     yield result
345     result._finalize()
346 
347 
348 def get_actual_log_level(config, *setting_names):
349     """Return the actual logging level."""
350 
351     for setting_name in setting_names:
352         log_level = config.getoption(setting_name)
353         if log_level is None:
354             log_level = config.getini(setting_name)
355         if log_level:
356             break
357     else:
358         return
359 
360     if isinstance(log_level, six.string_types):
361         log_level = log_level.upper()
362     try:
363         return int(getattr(logging, log_level, log_level))
364     except ValueError:
365         # Python logging does not recognise this as a logging level
366         raise pytest.UsageError(
367             "'{}' is not recognized as a logging level name for "
368             "'{}'. Please consider passing the "
369             "logging level num instead.".format(log_level, setting_name)
370         )
371 
372 
373 # run after terminalreporter/capturemanager are configured
374 @pytest.hookimpl(trylast=True)
375 def pytest_configure(config):
376     config.pluginmanager.register(LoggingPlugin(config), "logging-plugin")
377 
378 
379 class LoggingPlugin(object):
380     """Attaches to the logging module and captures log messages for each test.
381     """
382 
383     def __init__(self, config):
384         """Creates a new plugin to capture log messages.
385 
386         The formatter can be safely shared across all handlers so
387         create a single one for the entire test session here.
388         """
389         self._config = config
390 
391         # enable verbose output automatically if live logging is enabled
392         if self._log_cli_enabled() and config.getoption("verbose") < 1:
393             config.option.verbose = 1
394 
395         self.print_logs = get_option_ini(config, "log_print")
396         self.formatter = logging.Formatter(
397             get_option_ini(config, "log_format"),
398             get_option_ini(config, "log_date_format"),
399         )
400         self.log_level = get_actual_log_level(config, "log_level")
401 
402         self.log_file_level = get_actual_log_level(config, "log_file_level")
403         self.log_file_format = get_option_ini(config, "log_file_format", "log_format")
404         self.log_file_date_format = get_option_ini(
405             config, "log_file_date_format", "log_date_format"
406         )
407         self.log_file_formatter = logging.Formatter(
408             self.log_file_format, datefmt=self.log_file_date_format
409         )
410 
411         log_file = get_option_ini(config, "log_file")
412         if log_file:
413             self.log_file_handler = logging.FileHandler(
414                 log_file, mode="w", encoding="UTF-8"
415             )
416             self.log_file_handler.setFormatter(self.log_file_formatter)
417         else:
418             self.log_file_handler = None
419 
420         self.log_cli_handler = None
421 
422         self.live_logs_context = lambda: dummy_context_manager()
423         # Note that the lambda for the live_logs_context is needed because
424         # live_logs_context can otherwise not be entered multiple times due
425         # to limitations of contextlib.contextmanager.
426 
427         if self._log_cli_enabled():
428             self._setup_cli_logging()
429 
430     def _setup_cli_logging(self):
431         config = self._config
432         terminal_reporter = config.pluginmanager.get_plugin("terminalreporter")
433         if terminal_reporter is None:
434             # terminal reporter is disabled e.g. by pytest-xdist.
435             return
436 
437         capture_manager = config.pluginmanager.get_plugin("capturemanager")
438         # if capturemanager plugin is disabled, live logging still works.
439         log_cli_handler = _LiveLoggingStreamHandler(terminal_reporter, capture_manager)
440         log_cli_format = get_option_ini(config, "log_cli_format", "log_format")
441         log_cli_date_format = get_option_ini(
442             config, "log_cli_date_format", "log_date_format"
443         )
444         if (
445             config.option.color != "no"
446             and ColoredLevelFormatter.LEVELNAME_FMT_REGEX.search(log_cli_format)
447         ):
448             log_cli_formatter = ColoredLevelFormatter(
449                 create_terminal_writer(config),
450                 log_cli_format,
451                 datefmt=log_cli_date_format,
452             )
453         else:
454             log_cli_formatter = logging.Formatter(
455                 log_cli_format, datefmt=log_cli_date_format
456             )
457         log_cli_level = get_actual_log_level(config, "log_cli_level", "log_level")
458         self.log_cli_handler = log_cli_handler
459         self.live_logs_context = lambda: catching_logs(
460             log_cli_handler, formatter=log_cli_formatter, level=log_cli_level
461         )
462 
463     def set_log_path(self, fname):
464         """Public method, which can set filename parameter for
465         Logging.FileHandler(). Also creates parent directory if
466         it does not exist.
467 
468         .. warning::
469             Please considered as an experimental API.
470         """
471         fname = Path(fname)
472 
473         if not fname.is_absolute():
474             fname = Path(self._config.rootdir, fname)
475 
476         if not fname.parent.exists():
477             fname.parent.mkdir(exist_ok=True, parents=True)
478 
479         self.log_file_handler = logging.FileHandler(
480             str(fname), mode="w", encoding="UTF-8"
481         )
482         self.log_file_handler.setFormatter(self.log_file_formatter)
483 
484     def _log_cli_enabled(self):
485         """Return True if log_cli should be considered enabled, either explicitly
486         or because --log-cli-level was given in the command-line.
487         """
488         return self._config.getoption(
489             "--log-cli-level"
490         ) is not None or self._config.getini("log_cli")
491 
492     @pytest.hookimpl(hookwrapper=True, tryfirst=True)
493     def pytest_collection(self):
494         with self.live_logs_context():
495             if self.log_cli_handler:
496                 self.log_cli_handler.set_when("collection")
497 
498             if self.log_file_handler is not None:
499                 with catching_logs(self.log_file_handler, level=self.log_file_level):
500                     yield
501             else:
502                 yield
503 
504     @contextmanager
505     def _runtest_for(self, item, when):
506         with self._runtest_for_main(item, when):
507             if self.log_file_handler is not None:
508                 with catching_logs(self.log_file_handler, level=self.log_file_level):
509                     yield
510             else:
511                 yield
512 
513     @contextmanager
514     def _runtest_for_main(self, item, when):
515         """Implements the internals of pytest_runtest_xxx() hook."""
516         with catching_logs(
517             LogCaptureHandler(), formatter=self.formatter, level=self.log_level
518         ) as log_handler:
519             if self.log_cli_handler:
520                 self.log_cli_handler.set_when(when)
521 
522             if item is None:
523                 yield  # run the test
524                 return
525 
526             if not hasattr(item, "catch_log_handlers"):
527                 item.catch_log_handlers = {}
528             item.catch_log_handlers[when] = log_handler
529             item.catch_log_handler = log_handler
530             try:
531                 yield  # run test
532             finally:
533                 if when == "teardown":
534                     del item.catch_log_handler
535                     del item.catch_log_handlers
536 
537             if self.print_logs:
538                 # Add a captured log section to the report.
539                 log = log_handler.stream.getvalue().strip()
540                 item.add_report_section(when, "log", log)
541 
542     @pytest.hookimpl(hookwrapper=True)
543     def pytest_runtest_setup(self, item):
544         with self._runtest_for(item, "setup"):
545             yield
546 
547     @pytest.hookimpl(hookwrapper=True)
548     def pytest_runtest_call(self, item):
549         with self._runtest_for(item, "call"):
550             yield
551 
552     @pytest.hookimpl(hookwrapper=True)
553     def pytest_runtest_teardown(self, item):
554         with self._runtest_for(item, "teardown"):
555             yield
556 
557     @pytest.hookimpl(hookwrapper=True)
558     def pytest_runtest_logstart(self):
559         if self.log_cli_handler:
560             self.log_cli_handler.reset()
561         with self._runtest_for(None, "start"):
562             yield
563 
564     @pytest.hookimpl(hookwrapper=True)
565     def pytest_runtest_logfinish(self):
566         with self._runtest_for(None, "finish"):
567             yield
568 
569     @pytest.hookimpl(hookwrapper=True)
570     def pytest_runtest_logreport(self):
571         with self._runtest_for(None, "logreport"):
572             yield
573 
574     @pytest.hookimpl(hookwrapper=True, tryfirst=True)
575     def pytest_sessionfinish(self):
576         with self.live_logs_context():
577             if self.log_cli_handler:
578                 self.log_cli_handler.set_when("sessionfinish")
579             if self.log_file_handler is not None:
580                 try:
581                     with catching_logs(
582                         self.log_file_handler, level=self.log_file_level
583                     ):
584                         yield
585                 finally:
586                     # Close the FileHandler explicitly.
587                     # (logging.shutdown might have lost the weakref?!)
588                     self.log_file_handler.close()
589             else:
590                 yield
591 
592     @pytest.hookimpl(hookwrapper=True, tryfirst=True)
593     def pytest_sessionstart(self):
594         with self.live_logs_context():
595             if self.log_cli_handler:
596                 self.log_cli_handler.set_when("sessionstart")
597             if self.log_file_handler is not None:
598                 with catching_logs(self.log_file_handler, level=self.log_file_level):
599                     yield
600             else:
601                 yield
602 
603     @pytest.hookimpl(hookwrapper=True)
604     def pytest_runtestloop(self, session):
605         """Runs all collected test items."""
606         with self.live_logs_context():
607             if self.log_file_handler is not None:
608                 with catching_logs(self.log_file_handler, level=self.log_file_level):
609                     yield  # run all the tests
610             else:
611                 yield  # run all the tests
612 
613 
614 class _LiveLoggingStreamHandler(logging.StreamHandler):
615     """
616     Custom StreamHandler used by the live logging feature: it will write a newline before the first log message
617     in each test.
618 
619     During live logging we must also explicitly disable stdout/stderr capturing otherwise it will get captured
620     and won't appear in the terminal.
621     """
622 
623     def __init__(self, terminal_reporter, capture_manager):
624         """
625         :param _pytest.terminal.TerminalReporter terminal_reporter:
626         :param _pytest.capture.CaptureManager capture_manager:
627         """
628         logging.StreamHandler.__init__(self, stream=terminal_reporter)
629         self.capture_manager = capture_manager
630         self.reset()
631         self.set_when(None)
632         self._test_outcome_written = False
633 
634     def reset(self):
635         """Reset the handler; should be called before the start of each test"""
636         self._first_record_emitted = False
637 
638     def set_when(self, when):
639         """Prepares for the given test phase (setup/call/teardown)"""
640         self._when = when
641         self._section_name_shown = False
642         if when == "start":
643             self._test_outcome_written = False
644 
645     def emit(self, record):
646         ctx_manager = (
647             self.capture_manager.global_and_fixture_disabled()
648             if self.capture_manager
649             else dummy_context_manager()
650         )
651         with ctx_manager:
652             if not self._first_record_emitted:
653                 self.stream.write("\n")
654                 self._first_record_emitted = True
655             elif self._when in ("teardown", "finish"):
656                 if not self._test_outcome_written:
657                     self._test_outcome_written = True
658                     self.stream.write("\n")
659             if not self._section_name_shown and self._when:
660                 self.stream.section("live log " + self._when, sep="-", bold=True)
661                 self._section_name_shown = True
662             logging.StreamHandler.emit(self, record)

</code><intended_behavior>Modify the `DEFAULT_LOG_FORMAT` to include the module name (`name`) and potentially explore reducing the length of the path while preserving essential parts of it. The new format suggested in the issue, "%(levelname)-8s %(name)s:%(filename)s:%(lineno)d %(message)s", should replace the old format. This change will allow log messages to carry more contextual information (i.e., the module name along with the filename and line number), without significantly altering the existing functionality. The revised logging format will enhance debugging capabilities by making the logs more informative, showing not just where (filename and line number) but also in what context (module name) the log was generated, thereby adhering to the request for improved readability and usefulness in log messages.</intended_behavior>]
2025-10-18 16:21:46.479 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-18 16:21:46.479 | INFO     | Search-only: skipping patch selection
2025-10-18 16:21:46.547 | INFO     | Task pytest-dev__pytest-5227 completed successfully.
2025-10-18 16:21:46.548 | INFO     | No patch generated. You can try running ACR again.
