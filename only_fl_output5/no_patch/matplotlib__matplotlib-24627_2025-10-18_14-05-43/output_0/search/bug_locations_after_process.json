[
    {
        "rel_file_path": "lib/matplotlib/axes/_base.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/matplotlib__matplotlib/setup_matplotlib__matplotlib__3.6/lib/matplotlib/axes/_base.py",
        "start": 1404,
        "end": 1411,
        "class_name": null,
        "method_name": "cla",
        "code": "1404     def cla(self):\n1405         \"\"\"Clear the Axes.\"\"\"\n1406         # Act as an alias, or as the superclass implementation depending on the\n1407         # subclass implementation.\n1408         if self._subclass_uses_cla:\n1409             self.__clear()\n1410         else:\n1411             self.clear()\n",
        "intended_behavior": "This method currently clears the axes of any artists (like lines, text, etc.), but it must also ensure that for each artist being cleared, their `.axes` (and if applicable, `.figure`) attributes are set to `None`. This change will align the internal state of the artist objects with their actual state of not being attached to any axes or figure, thereby preserving integrity and preventing misleading states. The method should iterate over all artists in the axes, unset their reference to the axes (and figure), and then proceed with the existing functionality of clearing the axes."
    },
    {
        "rel_file_path": "lib/matplotlib/axes/_base.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/matplotlib__matplotlib/setup_matplotlib__matplotlib__3.6/lib/matplotlib/axes/_base.py",
        "start": 1404,
        "end": 1411,
        "class_name": "_AxesBase",
        "method_name": "cla",
        "code": "1404     def cla(self):\n1405         \"\"\"Clear the Axes.\"\"\"\n1406         # Act as an alias, or as the superclass implementation depending on the\n1407         # subclass implementation.\n1408         if self._subclass_uses_cla:\n1409             self.__clear()\n1410         else:\n1411             self.clear()\n",
        "intended_behavior": "This method currently clears the axes of any artists (like lines, text, etc.), but it must also ensure that for each artist being cleared, their `.axes` (and if applicable, `.figure`) attributes are set to `None`. This change will align the internal state of the artist objects with their actual state of not being attached to any axes or figure, thereby preserving integrity and preventing misleading states. The method should iterate over all artists in the axes, unset their reference to the axes (and figure), and then proceed with the existing functionality of clearing the axes."
    },
    {
        "rel_file_path": "lib/matplotlib/artist.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/matplotlib__matplotlib/setup_matplotlib__matplotlib__3.6/lib/matplotlib/artist.py",
        "start": 193,
        "end": 229,
        "class_name": "Artist",
        "method_name": "remove",
        "code": "193     def remove(self):\n194         \"\"\"\n195         Remove the artist from the figure if possible.\n196 \n197         The effect will not be visible until the figure is redrawn, e.g.,\n198         with `.FigureCanvasBase.draw_idle`.  Call `~.axes.Axes.relim` to\n199         update the axes limits if desired.\n200 \n201         Note: `~.axes.Axes.relim` will not see collections even if the\n202         collection was added to the axes with *autolim* = True.\n203 \n204         Note: there is no support for removing the artist's legend entry.\n205         \"\"\"\n206 \n207         # There is no method to set the callback.  Instead, the parent should\n208         # set the _remove_method attribute directly.  This would be a\n209         # protected attribute if Python supported that sort of thing.  The\n210         # callback has one parameter, which is the child to be removed.\n211         if self._remove_method is not None:\n212             self._remove_method(self)\n213             # clear stale callback\n214             self.stale_callback = None\n215             _ax_flag = False\n216             if hasattr(self, 'axes') and self.axes:\n217                 # remove from the mouse hit list\n218                 self.axes._mouseover_set.discard(self)\n219                 self.axes.stale = True\n220                 self.axes = None  # decouple the artist from the Axes\n221                 _ax_flag = True\n222 \n223             if self.figure:\n224                 self.figure = None\n225                 if not _ax_flag:\n226                     self.figure = True\n227 \n228         else:\n229             raise NotImplementedError('cannot remove artist')\n",
        "intended_behavior": "The current functionality essentially needs no modification since it adequately unsets the `.axes` attribute of an artist when it is removed. It is mentioned for context and comparison, indicating that similar behavior needs to be ensured in the `cla()` method of the `Axes` class. However, verifying if there's a need to explicitly unset `.figure` alongside `.axes` could be considered to ensure full decoupling of the artist from its previous context. If not already doing so, extending the `remove()` method to unset the `.figure` attribute (if such direct association exists) would ensure consistency in behavior and state management across the library."
    },
    {
        "rel_file_path": "lib/matplotlib/artist.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/matplotlib__matplotlib/setup_matplotlib__matplotlib__3.6/lib/matplotlib/artist.py",
        "start": 96,
        "end": 1368,
        "class_name": "Artist",
        "method_name": null,
        "code": "96 class Artist:\n97     \"\"\"\n98     Abstract base class for objects that render into a FigureCanvas.\n99 \n100     Typically, all visible elements in a figure are subclasses of Artist.\n101     \"\"\"\n102 \n103     zorder = 0\n104 \n105     def __init_subclass__(cls):\n106         # Inject custom set() methods into the subclass with signature and\n107         # docstring based on the subclasses' properties.\n108 \n109         if not hasattr(cls.set, '_autogenerated_signature'):\n110             # Don't overwrite cls.set if the subclass or one of its parents\n111             # has defined a set method set itself.\n112             # If there was no explicit definition, cls.set is inherited from\n113             # the hierarchy of auto-generated set methods, which hold the\n114             # flag _autogenerated_signature.\n115             return\n116 \n117         cls.set = lambda self, **kwargs: Artist.set(self, **kwargs)\n118         cls.set.__name__ = \"set\"\n119         cls.set.__qualname__ = f\"{cls.__qualname__}.set\"\n120         cls._update_set_signature_and_docstring()\n121 \n122     _PROPERTIES_EXCLUDED_FROM_SET = [\n123         'navigate_mode',  # not a user-facing function\n124         'figure',         # changing the figure is such a profound operation\n125                           # that we don't want this in set()\n126         '3d_properties',  # cannot be used as a keyword due to leading digit\n127     ]\n128 \n129     @classmethod\n130     def _update_set_signature_and_docstring(cls):\n131         \"\"\"\n132         Update the signature of the set function to list all properties\n133         as keyword arguments.\n134 \n135         Property aliases are not listed in the signature for brevity, but\n136         are still accepted as keyword arguments.\n137         \"\"\"\n138         cls.set.__signature__ = Signature(\n139             [Parameter(\"self\", Parameter.POSITIONAL_OR_KEYWORD),\n140              *[Parameter(prop, Parameter.KEYWORD_ONLY, default=_UNSET)\n141                for prop in ArtistInspector(cls).get_setters()\n142                if prop not in Artist._PROPERTIES_EXCLUDED_FROM_SET]])\n143         cls.set._autogenerated_signature = True\n144 \n145         cls.set.__doc__ = (\n146             \"Set multiple properties at once.\\n\\n\"\n147             \"Supported properties are\\n\\n\"\n148             + kwdoc(cls))\n149 \n150     def __init__(self):\n151         self._stale = True\n152         self.stale_callback = None\n153         self._axes = None\n154         self.figure = None\n155 \n156         self._transform = None\n157         self._transformSet = False\n158         self._visible = True\n159         self._animated = False\n160         self._alpha = None\n161         self.clipbox = None\n162         self._clippath = None\n163         self._clipon = True\n164         self._label = ''\n165         self._picker = None\n166         self._rasterized = False\n167         self._agg_filter = None\n168         # Normally, artist classes need to be queried for mouseover info if and\n169         # only if they override get_cursor_data.\n170         self._mouseover = type(self).get_cursor_data != Artist.get_cursor_data\n171         self._callbacks = cbook.CallbackRegistry(signals=[\"pchanged\"])\n172         try:\n173             self.axes = None\n174         except AttributeError:\n175             # Handle self.axes as a read-only property, as in Figure.\n176             pass\n177         self._remove_method = None\n178         self._url = None\n179         self._gid = None\n180         self._snap = None\n181         self._sketch = mpl.rcParams['path.sketch']\n182         self._path_effects = mpl.rcParams['path.effects']\n183         self._sticky_edges = _XYPair([], [])\n184         self._in_layout = True\n185 \n186     def __getstate__(self):\n187         d = self.__dict__.copy()\n188         # remove the unpicklable remove method, this will get re-added on load\n189         # (by the Axes) if the artist lives on an Axes.\n190         d['stale_callback'] = None\n191         return d\n192 \n193     def remove(self):\n194         \"\"\"\n195         Remove the artist from the figure if possible.\n196 \n197         The effect will not be visible until the figure is redrawn, e.g.,\n198         with `.FigureCanvasBase.draw_idle`.  Call `~.axes.Axes.relim` to\n199         update the axes limits if desired.\n200 \n201         Note: `~.axes.Axes.relim` will not see collections even if the\n202         collection was added to the axes with *autolim* = True.\n203 \n204         Note: there is no support for removing the artist's legend entry.\n205         \"\"\"\n206 \n207         # There is no method to set the callback.  Instead, the parent should\n208         # set the _remove_method attribute directly.  This would be a\n209         # protected attribute if Python supported that sort of thing.  The\n210         # callback has one parameter, which is the child to be removed.\n211         if self._remove_method is not None:\n212             self._remove_method(self)\n213             # clear stale callback\n214             self.stale_callback = None\n215             _ax_flag = False\n216             if hasattr(self, 'axes') and self.axes:\n217                 # remove from the mouse hit list\n218                 self.axes._mouseover_set.discard(self)\n219                 self.axes.stale = True\n220                 self.axes = None  # decouple the artist from the Axes\n221                 _ax_flag = True\n222 \n223             if self.figure:\n224                 self.figure = None\n225                 if not _ax_flag:\n226                     self.figure = True\n227 \n228         else:\n229             raise NotImplementedError('cannot remove artist')\n230         # TODO: the fix for the collections relim problem is to move the\n231         # limits calculation into the artist itself, including the property of\n232         # whether or not the artist should affect the limits.  Then there will\n233         # be no distinction between axes.add_line, axes.add_patch, etc.\n234         # TODO: add legend support\n235 \n236     def have_units(self):\n237         \"\"\"Return whether units are set on any axis.\"\"\"\n238         ax = self.axes\n239         return ax and any(axis.have_units() for axis in ax._axis_map.values())\n240 \n241     def convert_xunits(self, x):\n242         \"\"\"\n243         Convert *x* using the unit type of the xaxis.\n244 \n245         If the artist is not contained in an Axes or if the xaxis does not\n246         have units, *x* itself is returned.\n247         \"\"\"\n248         ax = getattr(self, 'axes', None)\n249         if ax is None or ax.xaxis is None:\n250             return x\n251         return ax.xaxis.convert_units(x)\n252 \n253     def convert_yunits(self, y):\n254         \"\"\"\n255         Convert *y* using the unit type of the yaxis.\n256 \n257         If the artist is not contained in an Axes or if the yaxis does not\n258         have units, *y* itself is returned.\n259         \"\"\"\n260         ax = getattr(self, 'axes', None)\n261         if ax is None or ax.yaxis is None:\n262             return y\n263         return ax.yaxis.convert_units(y)\n264 \n265     @property\n266     def axes(self):\n267         \"\"\"The `~.axes.Axes` instance the artist resides in, or *None*.\"\"\"\n268         return self._axes\n269 \n270     @axes.setter\n271     def axes(self, new_axes):\n272         if (new_axes is not None and self._axes is not None\n273                 and new_axes != self._axes):\n274             raise ValueError(\"Can not reset the axes.  You are probably \"\n275                              \"trying to re-use an artist in more than one \"\n276                              \"Axes which is not supported\")\n277         self._axes = new_axes\n278         if new_axes is not None and new_axes is not self:\n279             self.stale_callback = _stale_axes_callback\n280 \n281     @property\n282     def stale(self):\n283         \"\"\"\n284         Whether the artist is 'stale' and needs to be re-drawn for the output\n285         to match the internal state of the artist.\n286         \"\"\"\n287         return self._stale\n288 \n289     @stale.setter\n290     def stale(self, val):\n291         self._stale = val\n292 \n293         # if the artist is animated it does not take normal part in the\n294         # draw stack and is not expected to be drawn as part of the normal\n295         # draw loop (when not saving) so do not propagate this change\n296         if self.get_animated():\n297             return\n298 \n299         if val and self.stale_callback is not None:\n300             self.stale_callback(self, val)\n301 \n302     def get_window_extent(self, renderer=None):\n303         \"\"\"\n304         Get the artist's bounding box in display space.\n305 \n306         The bounding box' width and height are nonnegative.\n307 \n308         Subclasses should override for inclusion in the bounding box\n309         \"tight\" calculation. Default is to return an empty bounding\n310         box at 0, 0.\n311 \n312         Be careful when using this function, the results will not update\n313         if the artist window extent of the artist changes.  The extent\n314         can change due to any changes in the transform stack, such as\n315         changing the axes limits, the figure size, or the canvas used\n316         (as is done when saving a figure).  This can lead to unexpected\n317         behavior where interactive figures will look fine on the screen,\n318         but will save incorrectly.\n319         \"\"\"\n320         return Bbox([[0, 0], [0, 0]])\n321 \n322     def get_tightbbox(self, renderer=None):\n323         \"\"\"\n324         Like `.Artist.get_window_extent`, but includes any clipping.\n325 \n326         Parameters\n327         ----------\n328         renderer : `.RendererBase` subclass\n329             renderer that will be used to draw the figures (i.e.\n330             ``fig.canvas.get_renderer()``)\n331 \n332         Returns\n333         -------\n334         `.Bbox`\n335             The enclosing bounding box (in figure pixel coordinates).\n336         \"\"\"\n337         bbox = self.get_window_extent(renderer)\n338         if self.get_clip_on():\n339             clip_box = self.get_clip_box()\n340             if clip_box is not None:\n341                 bbox = Bbox.intersection(bbox, clip_box)\n342             clip_path = self.get_clip_path()\n343             if clip_path is not None:\n344                 clip_path = clip_path.get_fully_transformed_path()\n345                 bbox = Bbox.intersection(bbox, clip_path.get_extents())\n346         return bbox\n347 \n348     def add_callback(self, func):\n349         \"\"\"\n350         Add a callback function that will be called whenever one of the\n351         `.Artist`'s properties changes.\n352 \n353         Parameters\n354         ----------\n355         func : callable\n356             The callback function. It must have the signature::\n357 \n358                 def func(artist: Artist) -> Any\n359 \n360             where *artist* is the calling `.Artist`. Return values may exist\n361             but are ignored.\n362 \n363         Returns\n364         -------\n365         int\n366             The observer id associated with the callback. This id can be\n367             used for removing the callback with `.remove_callback` later.\n368 \n369         See Also\n370         --------\n371         remove_callback\n372         \"\"\"\n373         # Wrapping func in a lambda ensures it can be connected multiple times\n374         # and never gets weakref-gc'ed.\n375         return self._callbacks.connect(\"pchanged\", lambda: func(self))\n376 \n377     def remove_callback(self, oid):\n378         \"\"\"\n379         Remove a callback based on its observer id.\n380 \n381         See Also\n382         --------\n383         add_callback\n384         \"\"\"\n385         self._callbacks.disconnect(oid)\n386 \n387     def pchanged(self):\n388         \"\"\"\n389         Call all of the registered callbacks.\n390 \n391         This function is triggered internally when a property is changed.\n392 \n393         See Also\n394         --------\n395         add_callback\n396         remove_callback\n397         \"\"\"\n398         self._callbacks.process(\"pchanged\")\n399 \n400     def is_transform_set(self):\n401         \"\"\"\n402         Return whether the Artist has an explicitly set transform.\n403 \n404         This is *True* after `.set_transform` has been called.\n405         \"\"\"\n406         return self._transformSet\n407 \n408     def set_transform(self, t):\n409         \"\"\"\n410         Set the artist transform.\n411 \n412         Parameters\n413         ----------\n414         t : `.Transform`\n415         \"\"\"\n416         self._transform = t\n417         self._transformSet = True\n418         self.pchanged()\n419         self.stale = True\n420 \n421     def get_transform(self):\n422         \"\"\"Return the `.Transform` instance used by this artist.\"\"\"\n423         if self._transform is None:\n424             self._transform = IdentityTransform()\n425         elif (not isinstance(self._transform, Transform)\n426               and hasattr(self._transform, '_as_mpl_transform')):\n427             self._transform = self._transform._as_mpl_transform(self.axes)\n428         return self._transform\n429 \n430     def get_children(self):\n431         r\"\"\"Return a list of the child `.Artist`\\s of this `.Artist`.\"\"\"\n432         return []\n433 \n434     def _default_contains(self, mouseevent, figure=None):\n435         \"\"\"\n436         Base impl. for checking whether a mouseevent happened in an artist.\n437 \n438         1. If the artist figure is known and the event did not occur in that\n439            figure (by checking its ``canvas`` attribute), reject it.\n440         2. Otherwise, return `None, {}`, indicating that the subclass'\n441            implementation should be used.\n442 \n443         Subclasses should start their definition of `contains` as follows:\n444 \n445             inside, info = self._default_contains(mouseevent)\n446             if inside is not None:\n447                 return inside, info\n448             # subclass-specific implementation follows\n449 \n450         The *figure* kwarg is provided for the implementation of\n451         `.Figure.contains`.\n452         \"\"\"\n453         if figure is not None and mouseevent.canvas is not figure.canvas:\n454             return False, {}\n455         return None, {}\n456 \n457     def contains(self, mouseevent):\n458         \"\"\"\n459         Test whether the artist contains the mouse event.\n460 \n461         Parameters\n462         ----------\n463         mouseevent : `matplotlib.backend_bases.MouseEvent`\n464 \n465         Returns\n466         -------\n467         contains : bool\n468             Whether any values are within the radius.\n469         details : dict\n470             An artist-specific dictionary of details of the event context,\n471             such as which points are contained in the pick radius. See the\n472             individual Artist subclasses for details.\n473         \"\"\"\n474         inside, info = self._default_contains(mouseevent)\n475         if inside is not None:\n476             return inside, info\n477         _log.warning(\"%r needs 'contains' method\", self.__class__.__name__)\n478         return False, {}\n479 \n480     def pickable(self):\n481         \"\"\"\n482         Return whether the artist is pickable.\n483 \n484         See Also\n485         --------\n486         set_picker, get_picker, pick\n487         \"\"\"\n488         return self.figure is not None and self._picker is not None\n489 \n490     def pick(self, mouseevent):\n491         \"\"\"\n492         Process a pick event.\n493 \n494         Each child artist will fire a pick event if *mouseevent* is over\n495         the artist and the artist has picker set.\n496 \n497         See Also\n498         --------\n499         set_picker, get_picker, pickable\n500         \"\"\"\n501         from .backend_bases import PickEvent  # Circular import.\n502         # Pick self\n503         if self.pickable():\n504             picker = self.get_picker()\n505             if callable(picker):\n506                 inside, prop = picker(self, mouseevent)\n507             else:\n508                 inside, prop = self.contains(mouseevent)\n509             if inside:\n510                 PickEvent(\"pick_event\", self.figure.canvas,\n511                           mouseevent, self, **prop)._process()\n512 \n513         # Pick children\n514         for a in self.get_children():\n515             # make sure the event happened in the same Axes\n516             ax = getattr(a, 'axes', None)\n517             if (mouseevent.inaxes is None or ax is None\n518                     or mouseevent.inaxes == ax):\n519                 # we need to check if mouseevent.inaxes is None\n520                 # because some objects associated with an Axes (e.g., a\n521                 # tick label) can be outside the bounding box of the\n522                 # Axes and inaxes will be None\n523                 # also check that ax is None so that it traverse objects\n524                 # which do not have an axes property but children might\n525                 a.pick(mouseevent)\n526 \n527     def set_picker(self, picker):\n528         \"\"\"\n529         Define the picking behavior of the artist.\n530 \n531         Parameters\n532         ----------\n533         picker : None or bool or float or callable\n534             This can be one of the following:\n535 \n536             - *None*: Picking is disabled for this artist (default).\n537 \n538             - A boolean: If *True* then picking will be enabled and the\n539               artist will fire a pick event if the mouse event is over\n540               the artist.\n541 \n542             - A float: If picker is a number it is interpreted as an\n543               epsilon tolerance in points and the artist will fire\n544               off an event if its data is within epsilon of the mouse\n545               event.  For some artists like lines and patch collections,\n546               the artist may provide additional data to the pick event\n547               that is generated, e.g., the indices of the data within\n548               epsilon of the pick event\n549 \n550             - A function: If picker is callable, it is a user supplied\n551               function which determines whether the artist is hit by the\n552               mouse event::\n553 \n554                 hit, props = picker(artist, mouseevent)\n555 \n556               to determine the hit test.  if the mouse event is over the\n557               artist, return *hit=True* and props is a dictionary of\n558               properties you want added to the PickEvent attributes.\n559         \"\"\"\n560         self._picker = picker\n561 \n562     def get_picker(self):\n563         \"\"\"\n564         Return the picking behavior of the artist.\n565 \n566         The possible values are described in `.set_picker`.\n567 \n568         See Also\n569         --------\n570         set_picker, pickable, pick\n571         \"\"\"\n572         return self._picker\n573 \n574     def get_url(self):\n575         \"\"\"Return the url.\"\"\"\n576         return self._url\n577 \n578     def set_url(self, url):\n579         \"\"\"\n580         Set the url for the artist.\n581 \n582         Parameters\n583         ----------\n584         url : str\n585         \"\"\"\n586         self._url = url\n587 \n588     def get_gid(self):\n589         \"\"\"Return the group id.\"\"\"\n590         return self._gid\n591 \n592     def set_gid(self, gid):\n593         \"\"\"\n594         Set the (group) id for the artist.\n595 \n596         Parameters\n597         ----------\n598         gid : str\n599         \"\"\"\n600         self._gid = gid\n601 \n602     def get_snap(self):\n603         \"\"\"\n604         Return the snap setting.\n605 \n606         See `.set_snap` for details.\n607         \"\"\"\n608         if mpl.rcParams['path.snap']:\n609             return self._snap\n610         else:\n611             return False\n612 \n613     def set_snap(self, snap):\n614         \"\"\"\n615         Set the snapping behavior.\n616 \n617         Snapping aligns positions with the pixel grid, which results in\n618         clearer images. For example, if a black line of 1px width was\n619         defined at a position in between two pixels, the resulting image\n620         would contain the interpolated value of that line in the pixel grid,\n621         which would be a grey value on both adjacent pixel positions. In\n622         contrast, snapping will move the line to the nearest integer pixel\n623         value, so that the resulting image will really contain a 1px wide\n624         black line.\n625 \n626         Snapping is currently only supported by the Agg and MacOSX backends.\n627 \n628         Parameters\n629         ----------\n630         snap : bool or None\n631             Possible values:\n632 \n633             - *True*: Snap vertices to the nearest pixel center.\n634             - *False*: Do not modify vertex positions.\n635             - *None*: (auto) If the path contains only rectilinear line\n636               segments, round to the nearest pixel center.\n637         \"\"\"\n638         self._snap = snap\n639         self.stale = True\n640 \n641     def get_sketch_params(self):\n642         \"\"\"\n643         Return the sketch parameters for the artist.\n644 \n645         Returns\n646         -------\n647         tuple or None\n648 \n649             A 3-tuple with the following elements:\n650 \n651             - *scale*: The amplitude of the wiggle perpendicular to the\n652               source line.\n653             - *length*: The length of the wiggle along the line.\n654             - *randomness*: The scale factor by which the length is\n655               shrunken or expanded.\n656 \n657             Returns *None* if no sketch parameters were set.\n658         \"\"\"\n659         return self._sketch\n660 \n661     def set_sketch_params(self, scale=None, length=None, randomness=None):\n662         \"\"\"\n663         Set the sketch parameters.\n664 \n665         Parameters\n666         ----------\n667         scale : float, optional\n668             The amplitude of the wiggle perpendicular to the source\n669             line, in pixels.  If scale is `None`, or not provided, no\n670             sketch filter will be provided.\n671         length : float, optional\n672              The length of the wiggle along the line, in pixels\n673              (default 128.0)\n674         randomness : float, optional\n675             The scale factor by which the length is shrunken or\n676             expanded (default 16.0)\n677 \n678             The PGF backend uses this argument as an RNG seed and not as\n679             described above. Using the same seed yields the same random shape.\n680 \n681             .. ACCEPTS: (scale: float, length: float, randomness: float)\n682         \"\"\"\n683         if scale is None:\n684             self._sketch = None\n685         else:\n686             self._sketch = (scale, length or 128.0, randomness or 16.0)\n687         self.stale = True\n688 \n689     def set_path_effects(self, path_effects):\n690         \"\"\"\n691         Set the path effects.\n692 \n693         Parameters\n694         ----------\n695         path_effects : `.AbstractPathEffect`\n696         \"\"\"\n697         self._path_effects = path_effects\n698         self.stale = True\n699 \n700     def get_path_effects(self):\n701         return self._path_effects\n702 \n703     def get_figure(self):\n704         \"\"\"Return the `.Figure` instance the artist belongs to.\"\"\"\n705         return self.figure\n706 \n707     def set_figure(self, fig):\n708         \"\"\"\n709         Set the `.Figure` instance the artist belongs to.\n710 \n711         Parameters\n712         ----------\n713         fig : `.Figure`\n714         \"\"\"\n715         # if this is a no-op just return\n716         if self.figure is fig:\n717             return\n718         # if we currently have a figure (the case of both `self.figure`\n719         # and *fig* being none is taken care of above) we then user is\n720         # trying to change the figure an artist is associated with which\n721         # is not allowed for the same reason as adding the same instance\n722         # to more than one Axes\n723         if self.figure is not None:\n724             raise RuntimeError(\"Can not put single artist in \"\n725                                \"more than one figure\")\n726         self.figure = fig\n727         if self.figure and self.figure is not self:\n728             self.pchanged()\n729         self.stale = True\n730 \n731     def set_clip_box(self, clipbox):\n732         \"\"\"\n733         Set the artist's clip `.Bbox`.\n734 \n735         Parameters\n736         ----------\n737         clipbox : `.Bbox`\n738         \"\"\"\n739         self.clipbox = clipbox\n740         self.pchanged()\n741         self.stale = True\n742 \n743     def set_clip_path(self, path, transform=None):\n744         \"\"\"\n745         Set the artist's clip path.\n746 \n747         Parameters\n748         ----------\n749         path : `.Patch` or `.Path` or `.TransformedPath` or None\n750             The clip path. If given a `.Path`, *transform* must be provided as\n751             well. If *None*, a previously set clip path is removed.\n752         transform : `~matplotlib.transforms.Transform`, optional\n753             Only used if *path* is a `.Path`, in which case the given `.Path`\n754             is converted to a `.TransformedPath` using *transform*.\n755 \n756         Notes\n757         -----\n758         For efficiency, if *path* is a `.Rectangle` this method will set the\n759         clipping box to the corresponding rectangle and set the clipping path\n760         to ``None``.\n761 \n762         For technical reasons (support of `~.Artist.set`), a tuple\n763         (*path*, *transform*) is also accepted as a single positional\n764         parameter.\n765 \n766         .. ACCEPTS: Patch or (Path, Transform) or None\n767         \"\"\"\n768         from matplotlib.patches import Patch, Rectangle\n769 \n770         success = False\n771         if transform is None:\n772             if isinstance(path, Rectangle):\n773                 self.clipbox = TransformedBbox(Bbox.unit(),\n774                                                path.get_transform())\n775                 self._clippath = None\n776                 success = True\n777             elif isinstance(path, Patch):\n778                 self._clippath = TransformedPatchPath(path)\n779                 success = True\n780             elif isinstance(path, tuple):\n781                 path, transform = path\n782 \n783         if path is None:\n784             self._clippath = None\n785             success = True\n786         elif isinstance(path, Path):\n787             self._clippath = TransformedPath(path, transform)\n788             success = True\n789         elif isinstance(path, TransformedPatchPath):\n790             self._clippath = path\n791             success = True\n792         elif isinstance(path, TransformedPath):\n793             self._clippath = path\n794             success = True\n795 \n796         if not success:\n797             raise TypeError(\n798                 \"Invalid arguments to set_clip_path, of type {} and {}\"\n799                 .format(type(path).__name__, type(transform).__name__))\n800         # This may result in the callbacks being hit twice, but guarantees they\n801         # will be hit at least once.\n802         self.pchanged()\n803         self.stale = True\n804 \n805     def get_alpha(self):\n806         \"\"\"\n807         Return the alpha value used for blending - not supported on all\n808         backends.\n809         \"\"\"\n810         return self._alpha\n811 \n812     def get_visible(self):\n813         \"\"\"Return the visibility.\"\"\"\n814         return self._visible\n815 \n816     def get_animated(self):\n817         \"\"\"Return whether the artist is animated.\"\"\"\n818         return self._animated\n819 \n820     def get_in_layout(self):\n821         \"\"\"\n822         Return boolean flag, ``True`` if artist is included in layout\n823         calculations.\n824 \n825         E.g. :doc:`/tutorials/intermediate/constrainedlayout_guide`,\n826         `.Figure.tight_layout()`, and\n827         ``fig.savefig(fname, bbox_inches='tight')``.\n828         \"\"\"\n829         return self._in_layout\n830 \n831     def _fully_clipped_to_axes(self):\n832         \"\"\"\n833         Return a boolean flag, ``True`` if the artist is clipped to the Axes\n834         and can thus be skipped in layout calculations. Requires `get_clip_on`\n835         is True, one of `clip_box` or `clip_path` is set, ``clip_box.extents``\n836         is equivalent to ``ax.bbox.extents`` (if set), and ``clip_path._patch``\n837         is equivalent to ``ax.patch`` (if set).\n838         \"\"\"\n839         # Note that ``clip_path.get_fully_transformed_path().get_extents()``\n840         # cannot be directly compared to ``axes.bbox.extents`` because the\n841         # extents may be undefined (i.e. equivalent to ``Bbox.null()``)\n842         # before the associated artist is drawn, and this method is meant\n843         # to determine whether ``axes.get_tightbbox()`` may bypass drawing\n844         clip_box = self.get_clip_box()\n845         clip_path = self.get_clip_path()\n846         return (self.axes is not None\n847                 and self.get_clip_on()\n848                 and (clip_box is not None or clip_path is not None)\n849                 and (clip_box is None\n850                      or np.all(clip_box.extents == self.axes.bbox.extents))\n851                 and (clip_path is None\n852                      or isinstance(clip_path, TransformedPatchPath)\n853                      and clip_path._patch is self.axes.patch))\n854 \n855     def get_clip_on(self):\n856         \"\"\"Return whether the artist uses clipping.\"\"\"\n857         return self._clipon\n858 \n859     def get_clip_box(self):\n860         \"\"\"Return the clipbox.\"\"\"\n861         return self.clipbox\n862 \n863     def get_clip_path(self):\n864         \"\"\"Return the clip path.\"\"\"\n865         return self._clippath\n866 \n867     def get_transformed_clip_path_and_affine(self):\n868         \"\"\"\n869         Return the clip path with the non-affine part of its\n870         transformation applied, and the remaining affine part of its\n871         transformation.\n872         \"\"\"\n873         if self._clippath is not None:\n874             return self._clippath.get_transformed_path_and_affine()\n875         return None, None\n876 \n877     def set_clip_on(self, b):\n878         \"\"\"\n879         Set whether the artist uses clipping.\n880 \n881         When False, artists will be visible outside the Axes which\n882         can lead to unexpected results.\n883 \n884         Parameters\n885         ----------\n886         b : bool\n887         \"\"\"\n888         self._clipon = b\n889         # This may result in the callbacks being hit twice, but ensures they\n890         # are hit at least once\n891         self.pchanged()\n892         self.stale = True\n893 \n894     def _set_gc_clip(self, gc):\n895         \"\"\"Set the clip properly for the gc.\"\"\"\n896         if self._clipon:\n897             if self.clipbox is not None:\n898                 gc.set_clip_rectangle(self.clipbox)\n899             gc.set_clip_path(self._clippath)\n900         else:\n901             gc.set_clip_rectangle(None)\n902             gc.set_clip_path(None)\n903 \n904     def get_rasterized(self):\n905         \"\"\"Return whether the artist is to be rasterized.\"\"\"\n906         return self._rasterized\n907 \n908     def set_rasterized(self, rasterized):\n909         \"\"\"\n910         Force rasterized (bitmap) drawing for vector graphics output.\n911 \n912         Rasterized drawing is not supported by all artists. If you try to\n913         enable this on an artist that does not support it, the command has no\n914         effect and a warning will be issued.\n915 \n916         This setting is ignored for pixel-based output.\n917 \n918         See also :doc:`/gallery/misc/rasterization_demo`.\n919 \n920         Parameters\n921         ----------\n922         rasterized : bool\n923         \"\"\"\n924         if rasterized and not hasattr(self.draw, \"_supports_rasterization\"):\n925             _api.warn_external(f\"Rasterization of '{self}' will be ignored\")\n926 \n927         self._rasterized = rasterized\n928 \n929     def get_agg_filter(self):\n930         \"\"\"Return filter function to be used for agg filter.\"\"\"\n931         return self._agg_filter\n932 \n933     def set_agg_filter(self, filter_func):\n934         \"\"\"\n935         Set the agg filter.\n936 \n937         Parameters\n938         ----------\n939         filter_func : callable\n940             A filter function, which takes a (m, n, depth) float array\n941             and a dpi value, and returns a (m, n, depth) array and two\n942             offsets from the bottom left corner of the image\n943 \n944             .. ACCEPTS: a filter function, which takes a (m, n, 3) float array\n945                 and a dpi value, and returns a (m, n, 3) array and two offsets\n946                 from the bottom left corner of the image\n947         \"\"\"\n948         self._agg_filter = filter_func\n949         self.stale = True\n950 \n951     def draw(self, renderer):\n952         \"\"\"\n953         Draw the Artist (and its children) using the given renderer.\n954 \n955         This has no effect if the artist is not visible (`.Artist.get_visible`\n956         returns False).\n957 \n958         Parameters\n959         ----------\n960         renderer : `.RendererBase` subclass.\n961 \n962         Notes\n963         -----\n964         This method is overridden in the Artist subclasses.\n965         \"\"\"\n966         if not self.get_visible():\n967             return\n968         self.stale = False\n969 \n970     def set_alpha(self, alpha):\n971         \"\"\"\n972         Set the alpha value used for blending - not supported on all backends.\n973 \n974         Parameters\n975         ----------\n976         alpha : scalar or None\n977             *alpha* must be within the 0-1 range, inclusive.\n978         \"\"\"\n979         if alpha is not None and not isinstance(alpha, Number):\n980             raise TypeError(\n981                 f'alpha must be numeric or None, not {type(alpha)}')\n982         if alpha is not None and not (0 <= alpha <= 1):\n983             raise ValueError(f'alpha ({alpha}) is outside 0-1 range')\n984         self._alpha = alpha\n985         self.pchanged()\n986         self.stale = True\n987 \n988     def _set_alpha_for_array(self, alpha):\n989         \"\"\"\n990         Set the alpha value used for blending - not supported on all backends.\n991 \n992         Parameters\n993         ----------\n994         alpha : array-like or scalar or None\n995             All values must be within the 0-1 range, inclusive.\n996             Masked values and nans are not supported.\n997         \"\"\"\n998         if isinstance(alpha, str):\n999             raise TypeError(\"alpha must be numeric or None, not a string\")\n1000         if not np.iterable(alpha):\n1001             Artist.set_alpha(self, alpha)\n1002             return\n1003         alpha = np.asarray(alpha)\n1004         if not (0 <= alpha.min() and alpha.max() <= 1):\n1005             raise ValueError('alpha must be between 0 and 1, inclusive, '\n1006                              f'but min is {alpha.min()}, max is {alpha.max()}')\n1007         self._alpha = alpha\n1008         self.pchanged()\n1009         self.stale = True\n1010 \n1011     def set_visible(self, b):\n1012         \"\"\"\n1013         Set the artist's visibility.\n1014 \n1015         Parameters\n1016         ----------\n1017         b : bool\n1018         \"\"\"\n1019         self._visible = b\n1020         self.pchanged()\n1021         self.stale = True\n1022 \n1023     def set_animated(self, b):\n1024         \"\"\"\n1025         Set whether the artist is intended to be used in an animation.\n1026 \n1027         If True, the artist is excluded from regular drawing of the figure.\n1028         You have to call `.Figure.draw_artist` / `.Axes.draw_artist`\n1029         explicitly on the artist. This approach is used to speed up animations\n1030         using blitting.\n1031 \n1032         See also `matplotlib.animation` and\n1033         :doc:`/tutorials/advanced/blitting`.\n1034 \n1035         Parameters\n1036         ----------\n1037         b : bool\n1038         \"\"\"\n1039         if self._animated != b:\n1040             self._animated = b\n1041             self.pchanged()\n1042 \n1043     def set_in_layout(self, in_layout):\n1044         \"\"\"\n1045         Set if artist is to be included in layout calculations,\n1046         E.g. :doc:`/tutorials/intermediate/constrainedlayout_guide`,\n1047         `.Figure.tight_layout()`, and\n1048         ``fig.savefig(fname, bbox_inches='tight')``.\n1049 \n1050         Parameters\n1051         ----------\n1052         in_layout : bool\n1053         \"\"\"\n1054         self._in_layout = in_layout\n1055 \n1056     def get_label(self):\n1057         \"\"\"Return the label used for this artist in the legend.\"\"\"\n1058         return self._label\n1059 \n1060     def set_label(self, s):\n1061         \"\"\"\n1062         Set a label that will be displayed in the legend.\n1063 \n1064         Parameters\n1065         ----------\n1066         s : object\n1067             *s* will be converted to a string by calling `str`.\n1068         \"\"\"\n1069         if s is not None:\n1070             self._label = str(s)\n1071         else:\n1072             self._label = None\n1073         self.pchanged()\n1074         self.stale = True\n1075 \n1076     def get_zorder(self):\n1077         \"\"\"Return the artist's zorder.\"\"\"\n1078         return self.zorder\n1079 \n1080     def set_zorder(self, level):\n1081         \"\"\"\n1082         Set the zorder for the artist.  Artists with lower zorder\n1083         values are drawn first.\n1084 \n1085         Parameters\n1086         ----------\n1087         level : float\n1088         \"\"\"\n1089         if level is None:\n1090             level = self.__class__.zorder\n1091         self.zorder = level\n1092         self.pchanged()\n1093         self.stale = True\n1094 \n1095     @property\n1096     def sticky_edges(self):\n1097         \"\"\"\n1098         ``x`` and ``y`` sticky edge lists for autoscaling.\n1099 \n1100         When performing autoscaling, if a data limit coincides with a value in\n1101         the corresponding sticky_edges list, then no margin will be added--the\n1102         view limit \"sticks\" to the edge. A typical use case is histograms,\n1103         where one usually expects no margin on the bottom edge (0) of the\n1104         histogram.\n1105 \n1106         Moreover, margin expansion \"bumps\" against sticky edges and cannot\n1107         cross them.  For example, if the upper data limit is 1.0, the upper\n1108         view limit computed by simple margin application is 1.2, but there is a\n1109         sticky edge at 1.1, then the actual upper view limit will be 1.1.\n1110 \n1111         This attribute cannot be assigned to; however, the ``x`` and ``y``\n1112         lists can be modified in place as needed.\n1113 \n1114         Examples\n1115         --------\n1116         >>> artist.sticky_edges.x[:] = (xmin, xmax)\n1117         >>> artist.sticky_edges.y[:] = (ymin, ymax)\n1118 \n1119         \"\"\"\n1120         return self._sticky_edges\n1121 \n1122     def update_from(self, other):\n1123         \"\"\"Copy properties from *other* to *self*.\"\"\"\n1124         self._transform = other._transform\n1125         self._transformSet = other._transformSet\n1126         self._visible = other._visible\n1127         self._alpha = other._alpha\n1128         self.clipbox = other.clipbox\n1129         self._clipon = other._clipon\n1130         self._clippath = other._clippath\n1131         self._label = other._label\n1132         self._sketch = other._sketch\n1133         self._path_effects = other._path_effects\n1134         self.sticky_edges.x[:] = other.sticky_edges.x.copy()\n1135         self.sticky_edges.y[:] = other.sticky_edges.y.copy()\n1136         self.pchanged()\n1137         self.stale = True\n1138 \n1139     def properties(self):\n1140         \"\"\"Return a dictionary of all the properties of the artist.\"\"\"\n1141         return ArtistInspector(self).properties()\n1142 \n1143     def _update_props(self, props, errfmt):\n1144         \"\"\"\n1145         Helper for `.Artist.set` and `.Artist.update`.\n1146 \n1147         *errfmt* is used to generate error messages for invalid property\n1148         names; it gets formatted with ``type(self)`` and the property name.\n1149         \"\"\"\n1150         ret = []\n1151         with cbook._setattr_cm(self, eventson=False):\n1152             for k, v in props.items():\n1153                 # Allow attributes we want to be able to update through\n1154                 # art.update, art.set, setp.\n1155                 if k == \"axes\":\n1156                     ret.append(setattr(self, k, v))\n1157                 else:\n1158                     func = getattr(self, f\"set_{k}\", None)\n1159                     if not callable(func):\n1160                         raise AttributeError(\n1161                             errfmt.format(cls=type(self), prop_name=k))\n1162                     ret.append(func(v))\n1163         if ret:\n1164             self.pchanged()\n1165             self.stale = True\n1166         return ret\n1167 \n1168     def update(self, props):\n1169         \"\"\"\n1170         Update this artist's properties from the dict *props*.\n1171 \n1172         Parameters\n1173         ----------\n1174         props : dict\n1175         \"\"\"\n1176         return self._update_props(\n1177             props, \"{cls.__name__!r} object has no property {prop_name!r}\")\n1178 \n1179     def _internal_update(self, kwargs):\n1180         \"\"\"\n1181         Update artist properties without prenormalizing them, but generating\n1182         errors as if calling `set`.\n1183 \n1184         The lack of prenormalization is to maintain backcompatibility.\n1185         \"\"\"\n1186         return self._update_props(\n1187             kwargs, \"{cls.__name__}.set() got an unexpected keyword argument \"\n1188             \"{prop_name!r}\")\n1189 \n1190     def set(self, **kwargs):\n1191         # docstring and signature are auto-generated via\n1192         # Artist._update_set_signature_and_docstring() at the end of the\n1193         # module.\n1194         return self._internal_update(cbook.normalize_kwargs(kwargs, self))\n1195 \n1196     @contextlib.contextmanager\n1197     def _cm_set(self, **kwargs):\n1198         \"\"\"\n1199         `.Artist.set` context-manager that restores original values at exit.\n1200         \"\"\"\n1201         orig_vals = {k: getattr(self, f\"get_{k}\")() for k in kwargs}\n1202         try:\n1203             self.set(**kwargs)\n1204             yield\n1205         finally:\n1206             self.set(**orig_vals)\n1207 \n1208     def findobj(self, match=None, include_self=True):\n1209         \"\"\"\n1210         Find artist objects.\n1211 \n1212         Recursively find all `.Artist` instances contained in the artist.\n1213 \n1214         Parameters\n1215         ----------\n1216         match\n1217             A filter criterion for the matches. This can be\n1218 \n1219             - *None*: Return all objects contained in artist.\n1220             - A function with signature ``def match(artist: Artist) -> bool``.\n1221               The result will only contain artists for which the function\n1222               returns *True*.\n1223             - A class instance: e.g., `.Line2D`. The result will only contain\n1224               artists of this class or its subclasses (``isinstance`` check).\n1225 \n1226         include_self : bool\n1227             Include *self* in the list to be checked for a match.\n1228 \n1229         Returns\n1230         -------\n1231         list of `.Artist`\n1232 \n1233         \"\"\"\n1234         if match is None:  # always return True\n1235             def matchfunc(x):\n1236                 return True\n1237         elif isinstance(match, type) and issubclass(match, Artist):\n1238             def matchfunc(x):\n1239                 return isinstance(x, match)\n1240         elif callable(match):\n1241             matchfunc = match\n1242         else:\n1243             raise ValueError('match must be None, a matplotlib.artist.Artist '\n1244                              'subclass, or a callable')\n1245 \n1246         artists = sum([c.findobj(matchfunc) for c in self.get_children()], [])\n1247         if include_self and matchfunc(self):\n1248             artists.append(self)\n1249         return artists\n1250 \n1251     def get_cursor_data(self, event):\n1252         \"\"\"\n1253         Return the cursor data for a given event.\n1254 \n1255         .. note::\n1256             This method is intended to be overridden by artist subclasses.\n1257             As an end-user of Matplotlib you will most likely not call this\n1258             method yourself.\n1259 \n1260         Cursor data can be used by Artists to provide additional context\n1261         information for a given event. The default implementation just returns\n1262         *None*.\n1263 \n1264         Subclasses can override the method and return arbitrary data. However,\n1265         when doing so, they must ensure that `.format_cursor_data` can convert\n1266         the data to a string representation.\n1267 \n1268         The only current use case is displaying the z-value of an `.AxesImage`\n1269         in the status bar of a plot window, while moving the mouse.\n1270 \n1271         Parameters\n1272         ----------\n1273         event : `matplotlib.backend_bases.MouseEvent`\n1274 \n1275         See Also\n1276         --------\n1277         format_cursor_data\n1278 \n1279         \"\"\"\n1280         return None\n1281 \n1282     def format_cursor_data(self, data):\n1283         \"\"\"\n1284         Return a string representation of *data*.\n1285 \n1286         .. note::\n1287             This method is intended to be overridden by artist subclasses.\n1288             As an end-user of Matplotlib you will most likely not call this\n1289             method yourself.\n1290 \n1291         The default implementation converts ints and floats and arrays of ints\n1292         and floats into a comma-separated string enclosed in square brackets,\n1293         unless the artist has an associated colorbar, in which case scalar\n1294         values are formatted using the colorbar's formatter.\n1295 \n1296         See Also\n1297         --------\n1298         get_cursor_data\n1299         \"\"\"\n1300         if np.ndim(data) == 0 and isinstance(self, ScalarMappable):\n1301             # This block logically belongs to ScalarMappable, but can't be\n1302             # implemented in it because most ScalarMappable subclasses inherit\n1303             # from Artist first and from ScalarMappable second, so\n1304             # Artist.format_cursor_data would always have precedence over\n1305             # ScalarMappable.format_cursor_data.\n1306             n = self.cmap.N\n1307             if np.ma.getmask(data):\n1308                 return \"[]\"\n1309             normed = self.norm(data)\n1310             if np.isfinite(normed):\n1311                 if isinstance(self.norm, BoundaryNorm):\n1312                     # not an invertible normalization mapping\n1313                     cur_idx = np.argmin(np.abs(self.norm.boundaries - data))\n1314                     neigh_idx = max(0, cur_idx - 1)\n1315                     # use max diff to prevent delta == 0\n1316                     delta = np.diff(\n1317                         self.norm.boundaries[neigh_idx:cur_idx + 2]\n1318                     ).max()\n1319 \n1320                 else:\n1321                     # Midpoints of neighboring color intervals.\n1322                     neighbors = self.norm.inverse(\n1323                         (int(normed * n) + np.array([0, 1])) / n)\n1324                     delta = abs(neighbors - data).max()\n1325                 g_sig_digits = cbook._g_sig_digits(data, delta)\n1326             else:\n1327                 g_sig_digits = 3  # Consistent with default below.\n1328             return \"[{:-#.{}g}]\".format(data, g_sig_digits)\n1329         else:\n1330             try:\n1331                 data[0]\n1332             except (TypeError, IndexError):\n1333                 data = [data]\n1334             data_str = ', '.join('{:0.3g}'.format(item) for item in data\n1335                                  if isinstance(item, Number))\n1336             return \"[\" + data_str + \"]\"\n1337 \n1338     def get_mouseover(self):\n1339         \"\"\"\n1340         Return whether this artist is queried for custom context information\n1341         when the mouse cursor moves over it.\n1342         \"\"\"\n1343         return self._mouseover\n1344 \n1345     def set_mouseover(self, mouseover):\n1346         \"\"\"\n1347         Set whether this artist is queried for custom context information when\n1348         the mouse cursor moves over it.\n1349 \n1350         Parameters\n1351         ----------\n1352         mouseover : bool\n1353 \n1354         See Also\n1355         --------\n1356         get_cursor_data\n1357         .ToolCursorPosition\n1358         .NavigationToolbar2\n1359         \"\"\"\n1360         self._mouseover = bool(mouseover)\n1361         ax = self.axes\n1362         if ax:\n1363             if self._mouseover:\n1364                 ax._mouseover_set.add(self)\n1365             else:\n1366                 ax._mouseover_set.discard(self)\n1367 \n1368     mouseover = property(get_mouseover, set_mouseover)  # backcompat.\n",
        "intended_behavior": "This class provides additional context to the issue."
    }
]