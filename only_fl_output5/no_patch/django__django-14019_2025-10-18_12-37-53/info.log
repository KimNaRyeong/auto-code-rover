2025-10-18 12:37:53.484 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-18 12:37:56.640 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=140, output_tokens=12, cost=0.001760
2025-10-18 12:37:56.641 | INFO     | Test agent decides that the issue statement does not contain reproduction steps; skipping reproducer tracing
2025-10-18 12:37:56.645 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 12:38:01.869 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=445, output_tokens=186, cost=0.010030
2025-10-18 12:38:01.872 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 12:38:06.891 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=540, output_tokens=116, cost=0.008880
2025-10-18 12:38:06.893 | DEBUG    | Extracted a valid json.
2025-10-18 12:38:06.898 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_class(\"Index\")",
        "search_class(\"UniqueConstraint\")",
        "search_class(\"ExclusionConstraint\")",
        "search_class(\"CheckConstraint\")",
        "search_method_in_class(\"__repr__\", \"Index\")",
        "search_method_in_class(\"__repr__\", \"UniqueConstraint\")",
        "search_method_in_class(\"__repr__\", \"ExclusionConstraint\")",
        "search_method_in_class(\"__repr__\", \"CheckConstraint\")"
    ],
    "bug_locations": []
}
2025-10-18 12:38:06.949 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-18 12:38:06.950 | DEBUG    | <Agent search> Analyzing search results.
2025-10-18 12:38:23.298 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2230, output_tokens=715, cost=0.043750
2025-10-18 12:38:23.314 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 12:38:32.563 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=3161, output_tokens=407, cost=0.043820
2025-10-18 12:38:32.574 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 12:38:41.200 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=761, output_tokens=350, cost=0.018110
2025-10-18 12:38:41.201 | DEBUG    | Extracted a valid json.
2025-10-18 12:38:41.201 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations":[
        {
            "file": "django/db/models/indexes.py",
            "class": "Index",
            "method": "__repr__",
            "intended_behavior": "Ensure consistent labeling and formatting of attribute values within the string representation. Align the style closely with the other constraints by using consistent conditional checks for attribute presence and standardized format across representations."
        },
        {
            "file": "django/db/models/constraints.py",
            "class": "UniqueConstraint",
            "method": "__repr__",
            "intended_behavior": "Standardize the use of representation markers (`%r` for all attribute values) and ensure conditional inclusions of attributes follow a common format. Ensure this method's structure aligns with others in aesthetics and information delivery."
        },
        {
            "file": "django/contrib/postgres/constraints.py",
            "class": "ExclusionConstraint",
            "method": "__repr__",
            "intended_behavior": "Adapt the `__repr__` method to follow the established patterns from `Index` and `UniqueConstraint` for a unified approach in attribute presentation. This includes standardizing how conditional attributes are displayed and ensuring the format remains clear and concise."
        },
        {
            "file": "django/db/models/constraints.py",
            "class": "CheckConstraint",
            "method": "__repr__",
            "intended_behavior": "While maintaining the simplicity fitting CheckConstraint's needs, ensure that the presentation of its attributes aligns with the other classes in terms of formatting and conditionality. This could mean adopting the same style of conditionally including attributes and using consistent representation formats."
        }
    ]
}
2025-10-18 12:38:41.211 | DEBUG    | Bug location extracted successfully: [<file>django/db/models/indexes.py</file>
<class>Index</class>
<method>__repr__</method>
<code>
171     def __repr__(self):
172         return '<%s:%s%s%s%s%s>' % (
173             self.__class__.__name__,
174             '' if not self.fields else " fields='%s'" % ', '.join(self.fields),
175             '' if not self.expressions else " expressions='%s'" % ', '.join([
176                 str(expression) for expression in self.expressions
177             ]),
178             '' if self.condition is None else ' condition=%s' % self.condition,
179             '' if not self.include else " include='%s'" % ', '.join(self.include),
180             '' if not self.opclasses else " opclasses='%s'" % ', '.join(self.opclasses),
181         )

</code><intended_behavior>Ensure consistent labeling and formatting of attribute values within the string representation. Align the style closely with the other constraints by using consistent conditional checks for attribute presence and standardized format across representations.</intended_behavior>, <file>django/db/models/indexes.py</file>
<class>Index</class>
<method>None</method>
<code>
11 class Index:
12     suffix = 'idx'
13     # The max length of the name of the index (restricted to 30 for
14     # cross-database compatibility with Oracle)
15     max_name_length = 30
16 
17     def __init__(
18         self,
19         *expressions,
20         fields=(),
21         name=None,
22         db_tablespace=None,
23         opclasses=(),
24         condition=None,
25         include=None,
26     ):
27         if opclasses and not name:
28             raise ValueError('An index must be named to use opclasses.')
29         if not isinstance(condition, (type(None), Q)):
30             raise ValueError('Index.condition must be a Q instance.')
31         if condition and not name:
32             raise ValueError('An index must be named to use condition.')
33         if not isinstance(fields, (list, tuple)):
34             raise ValueError('Index.fields must be a list or tuple.')
35         if not isinstance(opclasses, (list, tuple)):
36             raise ValueError('Index.opclasses must be a list or tuple.')
37         if not expressions and not fields:
38             raise ValueError(
39                 'At least one field or expression is required to define an '
40                 'index.'
41             )
42         if expressions and fields:
43             raise ValueError(
44                 'Index.fields and expressions are mutually exclusive.',
45             )
46         if expressions and not name:
47             raise ValueError('An index must be named to use expressions.')
48         if expressions and opclasses:
49             raise ValueError(
50                 'Index.opclasses cannot be used with expressions. Use '
51                 'django.contrib.postgres.indexes.OpClass() instead.'
52             )
53         if opclasses and len(fields) != len(opclasses):
54             raise ValueError('Index.fields and Index.opclasses must have the same number of elements.')
55         if fields and not all(isinstance(field, str) for field in fields):
56             raise ValueError('Index.fields must contain only strings with field names.')
57         if include and not name:
58             raise ValueError('A covering index must be named.')
59         if not isinstance(include, (type(None), list, tuple)):
60             raise ValueError('Index.include must be a list or tuple.')
61         self.fields = list(fields)
62         # A list of 2-tuple with the field name and ordering ('' or 'DESC').
63         self.fields_orders = [
64             (field_name[1:], 'DESC') if field_name.startswith('-') else (field_name, '')
65             for field_name in self.fields
66         ]
67         self.name = name or ''
68         self.db_tablespace = db_tablespace
69         self.opclasses = opclasses
70         self.condition = condition
71         self.include = tuple(include) if include else ()
72         self.expressions = tuple(
73             F(expression) if isinstance(expression, str) else expression
74             for expression in expressions
75         )
76 
77     @property
78     def contains_expressions(self):
79         return bool(self.expressions)
80 
81     def _get_condition_sql(self, model, schema_editor):
82         if self.condition is None:
83             return None
84         query = Query(model=model, alias_cols=False)
85         where = query.build_where(self.condition)
86         compiler = query.get_compiler(connection=schema_editor.connection)
87         sql, params = where.as_sql(compiler, schema_editor.connection)
88         return sql % tuple(schema_editor.quote_value(p) for p in params)
89 
90     def create_sql(self, model, schema_editor, using='', **kwargs):
91         include = [model._meta.get_field(field_name).column for field_name in self.include]
92         condition = self._get_condition_sql(model, schema_editor)
93         if self.expressions:
94             index_expressions = []
95             for expression in self.expressions:
96                 index_expression = IndexExpression(expression)
97                 index_expression.set_wrapper_classes(schema_editor.connection)
98                 index_expressions.append(index_expression)
99             expressions = ExpressionList(*index_expressions).resolve_expression(
100                 Query(model, alias_cols=False),
101             )
102             fields = None
103             col_suffixes = None
104         else:
105             fields = [
106                 model._meta.get_field(field_name)
107                 for field_name, _ in self.fields_orders
108             ]
109             col_suffixes = [order[1] for order in self.fields_orders]
110             expressions = None
111         return schema_editor._create_index_sql(
112             model, fields=fields, name=self.name, using=using,
113             db_tablespace=self.db_tablespace, col_suffixes=col_suffixes,
114             opclasses=self.opclasses, condition=condition, include=include,
115             expressions=expressions, **kwargs,
116         )
117 
118     def remove_sql(self, model, schema_editor, **kwargs):
119         return schema_editor._delete_index_sql(model, self.name, **kwargs)
120 
121     def deconstruct(self):
122         path = '%s.%s' % (self.__class__.__module__, self.__class__.__name__)
123         path = path.replace('django.db.models.indexes', 'django.db.models')
124         kwargs = {'name': self.name}
125         if self.fields:
126             kwargs['fields'] = self.fields
127         if self.db_tablespace is not None:
128             kwargs['db_tablespace'] = self.db_tablespace
129         if self.opclasses:
130             kwargs['opclasses'] = self.opclasses
131         if self.condition:
132             kwargs['condition'] = self.condition
133         if self.include:
134             kwargs['include'] = self.include
135         return (path, self.expressions, kwargs)
136 
137     def clone(self):
138         """Create a copy of this Index."""
139         _, args, kwargs = self.deconstruct()
140         return self.__class__(*args, **kwargs)
141 
142     def set_name_with_model(self, model):
143         """
144         Generate a unique name for the index.
145 
146         The name is divided into 3 parts - table name (12 chars), field name
147         (8 chars) and unique hash + suffix (10 chars). Each part is made to
148         fit its size by truncating the excess length.
149         """
150         _, table_name = split_identifier(model._meta.db_table)
151         column_names = [model._meta.get_field(field_name).column for field_name, order in self.fields_orders]
152         column_names_with_order = [
153             (('-%s' if order else '%s') % column_name)
154             for column_name, (field_name, order) in zip(column_names, self.fields_orders)
155         ]
156         # The length of the parts of the name is based on the default max
157         # length of 30 characters.
158         hash_data = [table_name] + column_names_with_order + [self.suffix]
159         self.name = '%s_%s_%s' % (
160             table_name[:11],
161             column_names[0][:7],
162             '%s_%s' % (names_digest(*hash_data, length=6), self.suffix),
163         )
164         assert len(self.name) <= self.max_name_length, (
165             'Index too long for multiple database support. Is self.suffix '
166             'longer than 3 characters?'
167         )
168         if self.name[0] == '_' or self.name[0].isdigit():
169             self.name = 'D%s' % self.name[1:]
170 
171     def __repr__(self):
172         return '<%s:%s%s%s%s%s>' % (
173             self.__class__.__name__,
174             '' if not self.fields else " fields='%s'" % ', '.join(self.fields),
175             '' if not self.expressions else " expressions='%s'" % ', '.join([
176                 str(expression) for expression in self.expressions
177             ]),
178             '' if self.condition is None else ' condition=%s' % self.condition,
179             '' if not self.include else " include='%s'" % ', '.join(self.include),
180             '' if not self.opclasses else " opclasses='%s'" % ', '.join(self.opclasses),
181         )
182 
183     def __eq__(self, other):
184         if self.__class__ == other.__class__:
185             return self.deconstruct() == other.deconstruct()
186         return NotImplemented

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>, <file>django/db/models/constraints.py</file>
<class>UniqueConstraint</class>
<method>__repr__</method>
<code>
163     def __repr__(self):
164         return '<%s: fields=%r name=%r%s%s%s%s>' % (
165             self.__class__.__name__, self.fields, self.name,
166             '' if self.condition is None else ' condition=%s' % self.condition,
167             '' if self.deferrable is None else ' deferrable=%s' % self.deferrable,
168             '' if not self.include else ' include=%s' % repr(self.include),
169             '' if not self.opclasses else ' opclasses=%s' % repr(self.opclasses),
170         )

</code><intended_behavior>Standardize the use of representation markers (`%r` for all attribute values) and ensure conditional inclusions of attributes follow a common format. Ensure this method's structure aligns with others in aesthetics and information delivery.</intended_behavior>, <file>django/db/models/constraints.py</file>
<class>UniqueConstraint</class>
<method>None</method>
<code>
79 class UniqueConstraint(BaseConstraint):
80     def __init__(
81         self,
82         *,
83         fields,
84         name,
85         condition=None,
86         deferrable=None,
87         include=None,
88         opclasses=(),
89     ):
90         if not fields:
91             raise ValueError('At least one field is required to define a unique constraint.')
92         if not isinstance(condition, (type(None), Q)):
93             raise ValueError('UniqueConstraint.condition must be a Q instance.')
94         if condition and deferrable:
95             raise ValueError(
96                 'UniqueConstraint with conditions cannot be deferred.'
97             )
98         if include and deferrable:
99             raise ValueError(
100                 'UniqueConstraint with include fields cannot be deferred.'
101             )
102         if opclasses and deferrable:
103             raise ValueError(
104                 'UniqueConstraint with opclasses cannot be deferred.'
105             )
106         if not isinstance(deferrable, (type(None), Deferrable)):
107             raise ValueError(
108                 'UniqueConstraint.deferrable must be a Deferrable instance.'
109             )
110         if not isinstance(include, (type(None), list, tuple)):
111             raise ValueError('UniqueConstraint.include must be a list or tuple.')
112         if not isinstance(opclasses, (list, tuple)):
113             raise ValueError('UniqueConstraint.opclasses must be a list or tuple.')
114         if opclasses and len(fields) != len(opclasses):
115             raise ValueError(
116                 'UniqueConstraint.fields and UniqueConstraint.opclasses must '
117                 'have the same number of elements.'
118             )
119         self.fields = tuple(fields)
120         self.condition = condition
121         self.deferrable = deferrable
122         self.include = tuple(include) if include else ()
123         self.opclasses = opclasses
124         super().__init__(name)
125 
126     def _get_condition_sql(self, model, schema_editor):
127         if self.condition is None:
128             return None
129         query = Query(model=model, alias_cols=False)
130         where = query.build_where(self.condition)
131         compiler = query.get_compiler(connection=schema_editor.connection)
132         sql, params = where.as_sql(compiler, schema_editor.connection)
133         return sql % tuple(schema_editor.quote_value(p) for p in params)
134 
135     def constraint_sql(self, model, schema_editor):
136         fields = [model._meta.get_field(field_name).column for field_name in self.fields]
137         include = [model._meta.get_field(field_name).column for field_name in self.include]
138         condition = self._get_condition_sql(model, schema_editor)
139         return schema_editor._unique_sql(
140             model, fields, self.name, condition=condition,
141             deferrable=self.deferrable, include=include,
142             opclasses=self.opclasses,
143         )
144 
145     def create_sql(self, model, schema_editor):
146         fields = [model._meta.get_field(field_name).column for field_name in self.fields]
147         include = [model._meta.get_field(field_name).column for field_name in self.include]
148         condition = self._get_condition_sql(model, schema_editor)
149         return schema_editor._create_unique_sql(
150             model, fields, self.name, condition=condition,
151             deferrable=self.deferrable, include=include,
152             opclasses=self.opclasses,
153         )
154 
155     def remove_sql(self, model, schema_editor):
156         condition = self._get_condition_sql(model, schema_editor)
157         include = [model._meta.get_field(field_name).column for field_name in self.include]
158         return schema_editor._delete_unique_sql(
159             model, self.name, condition=condition, deferrable=self.deferrable,
160             include=include, opclasses=self.opclasses,
161         )
162 
163     def __repr__(self):
164         return '<%s: fields=%r name=%r%s%s%s%s>' % (
165             self.__class__.__name__, self.fields, self.name,
166             '' if self.condition is None else ' condition=%s' % self.condition,
167             '' if self.deferrable is None else ' deferrable=%s' % self.deferrable,
168             '' if not self.include else ' include=%s' % repr(self.include),
169             '' if not self.opclasses else ' opclasses=%s' % repr(self.opclasses),
170         )
171 
172     def __eq__(self, other):
173         if isinstance(other, UniqueConstraint):
174             return (
175                 self.name == other.name and
176                 self.fields == other.fields and
177                 self.condition == other.condition and
178                 self.deferrable == other.deferrable and
179                 self.include == other.include and
180                 self.opclasses == other.opclasses
181             )
182         return super().__eq__(other)
183 
184     def deconstruct(self):
185         path, args, kwargs = super().deconstruct()
186         kwargs['fields'] = self.fields
187         if self.condition:
188             kwargs['condition'] = self.condition
189         if self.deferrable:
190             kwargs['deferrable'] = self.deferrable
191         if self.include:
192             kwargs['include'] = self.include
193         if self.opclasses:
194             kwargs['opclasses'] = self.opclasses
195         return path, args, kwargs

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>, <file>django/contrib/postgres/constraints.py</file>
<class>ExclusionConstraint</class>
<method>__repr__</method>
<code>
157     def __repr__(self):
158         return '<%s: index_type=%s, expressions=%s%s%s%s%s>' % (
159             self.__class__.__qualname__,
160             self.index_type,
161             self.expressions,
162             '' if self.condition is None else ', condition=%s' % self.condition,
163             '' if self.deferrable is None else ', deferrable=%s' % self.deferrable,
164             '' if not self.include else ', include=%s' % repr(self.include),
165             '' if not self.opclasses else ', opclasses=%s' % repr(self.opclasses),
166         )

</code><intended_behavior>Adapt the `__repr__` method to follow the established patterns from `Index` and `UniqueConstraint` for a unified approach in attribute presentation. This includes standardizing how conditional attributes are displayed and ensuring the format remains clear and concise.</intended_behavior>, <file>django/contrib/postgres/constraints.py</file>
<class>ExclusionConstraint</class>
<method>None</method>
<code>
10 class ExclusionConstraint(BaseConstraint):
11     template = 'CONSTRAINT %(name)s EXCLUDE USING %(index_type)s (%(expressions)s)%(include)s%(where)s%(deferrable)s'
12 
13     def __init__(
14         self, *, name, expressions, index_type=None, condition=None,
15         deferrable=None, include=None, opclasses=(),
16     ):
17         if index_type and index_type.lower() not in {'gist', 'spgist'}:
18             raise ValueError(
19                 'Exclusion constraints only support GiST or SP-GiST indexes.'
20             )
21         if not expressions:
22             raise ValueError(
23                 'At least one expression is required to define an exclusion '
24                 'constraint.'
25             )
26         if not all(
27             isinstance(expr, (list, tuple)) and len(expr) == 2
28             for expr in expressions
29         ):
30             raise ValueError('The expressions must be a list of 2-tuples.')
31         if not isinstance(condition, (type(None), Q)):
32             raise ValueError(
33                 'ExclusionConstraint.condition must be a Q instance.'
34             )
35         if condition and deferrable:
36             raise ValueError(
37                 'ExclusionConstraint with conditions cannot be deferred.'
38             )
39         if not isinstance(deferrable, (type(None), Deferrable)):
40             raise ValueError(
41                 'ExclusionConstraint.deferrable must be a Deferrable instance.'
42             )
43         if not isinstance(include, (type(None), list, tuple)):
44             raise ValueError(
45                 'ExclusionConstraint.include must be a list or tuple.'
46             )
47         if include and index_type and index_type.lower() != 'gist':
48             raise ValueError(
49                 'Covering exclusion constraints only support GiST indexes.'
50             )
51         if not isinstance(opclasses, (list, tuple)):
52             raise ValueError(
53                 'ExclusionConstraint.opclasses must be a list or tuple.'
54             )
55         if opclasses and len(expressions) != len(opclasses):
56             raise ValueError(
57                 'ExclusionConstraint.expressions and '
58                 'ExclusionConstraint.opclasses must have the same number of '
59                 'elements.'
60             )
61         self.expressions = expressions
62         self.index_type = index_type or 'GIST'
63         self.condition = condition
64         self.deferrable = deferrable
65         self.include = tuple(include) if include else ()
66         self.opclasses = opclasses
67         super().__init__(name=name)
68 
69     def _get_expression_sql(self, compiler, schema_editor, query):
70         expressions = []
71         for idx, (expression, operator) in enumerate(self.expressions):
72             if isinstance(expression, str):
73                 expression = F(expression)
74             expression = expression.resolve_expression(query=query)
75             sql, params = compiler.compile(expression)
76             try:
77                 opclass = self.opclasses[idx]
78                 if opclass:
79                     sql = '%s %s' % (sql, opclass)
80             except IndexError:
81                 pass
82             sql = sql % tuple(schema_editor.quote_value(p) for p in params)
83             expressions.append('%s WITH %s' % (sql, operator))
84         return expressions
85 
86     def _get_condition_sql(self, compiler, schema_editor, query):
87         if self.condition is None:
88             return None
89         where = query.build_where(self.condition)
90         sql, params = where.as_sql(compiler, schema_editor.connection)
91         return sql % tuple(schema_editor.quote_value(p) for p in params)
92 
93     def constraint_sql(self, model, schema_editor):
94         query = Query(model, alias_cols=False)
95         compiler = query.get_compiler(connection=schema_editor.connection)
96         expressions = self._get_expression_sql(compiler, schema_editor, query)
97         condition = self._get_condition_sql(compiler, schema_editor, query)
98         include = [model._meta.get_field(field_name).column for field_name in self.include]
99         return self.template % {
100             'name': schema_editor.quote_name(self.name),
101             'index_type': self.index_type,
102             'expressions': ', '.join(expressions),
103             'include': schema_editor._index_include_sql(model, include),
104             'where': ' WHERE (%s)' % condition if condition else '',
105             'deferrable': schema_editor._deferrable_constraint_sql(self.deferrable),
106         }
107 
108     def create_sql(self, model, schema_editor):
109         self.check_supported(schema_editor)
110         return Statement(
111             'ALTER TABLE %(table)s ADD %(constraint)s',
112             table=Table(model._meta.db_table, schema_editor.quote_name),
113             constraint=self.constraint_sql(model, schema_editor),
114         )
115 
116     def remove_sql(self, model, schema_editor):
117         return schema_editor._delete_constraint_sql(
118             schema_editor.sql_delete_check,
119             model,
120             schema_editor.quote_name(self.name),
121         )
122 
123     def check_supported(self, schema_editor):
124         if self.include and not schema_editor.connection.features.supports_covering_gist_indexes:
125             raise NotSupportedError(
126                 'Covering exclusion constraints requires PostgreSQL 12+.'
127             )
128 
129     def deconstruct(self):
130         path, args, kwargs = super().deconstruct()
131         kwargs['expressions'] = self.expressions
132         if self.condition is not None:
133             kwargs['condition'] = self.condition
134         if self.index_type.lower() != 'gist':
135             kwargs['index_type'] = self.index_type
136         if self.deferrable:
137             kwargs['deferrable'] = self.deferrable
138         if self.include:
139             kwargs['include'] = self.include
140         if self.opclasses:
141             kwargs['opclasses'] = self.opclasses
142         return path, args, kwargs
143 
144     def __eq__(self, other):
145         if isinstance(other, self.__class__):
146             return (
147                 self.name == other.name and
148                 self.index_type == other.index_type and
149                 self.expressions == other.expressions and
150                 self.condition == other.condition and
151                 self.deferrable == other.deferrable and
152                 self.include == other.include and
153                 self.opclasses == other.opclasses
154             )
155         return super().__eq__(other)
156 
157     def __repr__(self):
158         return '<%s: index_type=%s, expressions=%s%s%s%s%s>' % (
159             self.__class__.__qualname__,
160             self.index_type,
161             self.expressions,
162             '' if self.condition is None else ', condition=%s' % self.condition,
163             '' if self.deferrable is None else ', deferrable=%s' % self.deferrable,
164             '' if not self.include else ', include=%s' % repr(self.include),
165             '' if not self.opclasses else ', opclasses=%s' % repr(self.opclasses),
166         )

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>, <file>django/db/models/constraints.py</file>
<class>CheckConstraint</class>
<method>__repr__</method>
<code>
60     def __repr__(self):
61         return "<%s: check='%s' name=%r>" % (self.__class__.__name__, self.check, self.name)

</code><intended_behavior>While maintaining the simplicity fitting CheckConstraint's needs, ensure that the presentation of its attributes aligns with the other classes in terms of formatting and conditionality. This could mean adopting the same style of conditionally including attributes and using consistent representation formats.</intended_behavior>, <file>django/db/models/constraints.py</file>
<class>CheckConstraint</class>
<method>None</method>
<code>
32 class CheckConstraint(BaseConstraint):
33     def __init__(self, *, check, name):
34         self.check = check
35         if not getattr(check, 'conditional', False):
36             raise TypeError(
37                 'CheckConstraint.check must be a Q instance or boolean '
38                 'expression.'
39             )
40         super().__init__(name)
41 
42     def _get_check_sql(self, model, schema_editor):
43         query = Query(model=model, alias_cols=False)
44         where = query.build_where(self.check)
45         compiler = query.get_compiler(connection=schema_editor.connection)
46         sql, params = where.as_sql(compiler, schema_editor.connection)
47         return sql % tuple(schema_editor.quote_value(p) for p in params)
48 
49     def constraint_sql(self, model, schema_editor):
50         check = self._get_check_sql(model, schema_editor)
51         return schema_editor._check_sql(self.name, check)
52 
53     def create_sql(self, model, schema_editor):
54         check = self._get_check_sql(model, schema_editor)
55         return schema_editor._create_check_sql(model, self.name, check)
56 
57     def remove_sql(self, model, schema_editor):
58         return schema_editor._delete_check_sql(model, self.name)
59 
60     def __repr__(self):
61         return "<%s: check='%s' name=%r>" % (self.__class__.__name__, self.check, self.name)
62 
63     def __eq__(self, other):
64         if isinstance(other, CheckConstraint):
65             return self.name == other.name and self.check == other.check
66         return super().__eq__(other)
67 
68     def deconstruct(self):
69         path, args, kwargs = super().deconstruct()
70         kwargs['check'] = self.check
71         return path, args, kwargs

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>]
2025-10-18 12:38:41.211 | INFO     | Search completed. Bug locations: [<file>django/db/models/indexes.py</file>
<class>Index</class>
<method>__repr__</method>
<code>
171     def __repr__(self):
172         return '<%s:%s%s%s%s%s>' % (
173             self.__class__.__name__,
174             '' if not self.fields else " fields='%s'" % ', '.join(self.fields),
175             '' if not self.expressions else " expressions='%s'" % ', '.join([
176                 str(expression) for expression in self.expressions
177             ]),
178             '' if self.condition is None else ' condition=%s' % self.condition,
179             '' if not self.include else " include='%s'" % ', '.join(self.include),
180             '' if not self.opclasses else " opclasses='%s'" % ', '.join(self.opclasses),
181         )

</code><intended_behavior>Ensure consistent labeling and formatting of attribute values within the string representation. Align the style closely with the other constraints by using consistent conditional checks for attribute presence and standardized format across representations.</intended_behavior>, <file>django/db/models/indexes.py</file>
<class>Index</class>
<method>None</method>
<code>
11 class Index:
12     suffix = 'idx'
13     # The max length of the name of the index (restricted to 30 for
14     # cross-database compatibility with Oracle)
15     max_name_length = 30
16 
17     def __init__(
18         self,
19         *expressions,
20         fields=(),
21         name=None,
22         db_tablespace=None,
23         opclasses=(),
24         condition=None,
25         include=None,
26     ):
27         if opclasses and not name:
28             raise ValueError('An index must be named to use opclasses.')
29         if not isinstance(condition, (type(None), Q)):
30             raise ValueError('Index.condition must be a Q instance.')
31         if condition and not name:
32             raise ValueError('An index must be named to use condition.')
33         if not isinstance(fields, (list, tuple)):
34             raise ValueError('Index.fields must be a list or tuple.')
35         if not isinstance(opclasses, (list, tuple)):
36             raise ValueError('Index.opclasses must be a list or tuple.')
37         if not expressions and not fields:
38             raise ValueError(
39                 'At least one field or expression is required to define an '
40                 'index.'
41             )
42         if expressions and fields:
43             raise ValueError(
44                 'Index.fields and expressions are mutually exclusive.',
45             )
46         if expressions and not name:
47             raise ValueError('An index must be named to use expressions.')
48         if expressions and opclasses:
49             raise ValueError(
50                 'Index.opclasses cannot be used with expressions. Use '
51                 'django.contrib.postgres.indexes.OpClass() instead.'
52             )
53         if opclasses and len(fields) != len(opclasses):
54             raise ValueError('Index.fields and Index.opclasses must have the same number of elements.')
55         if fields and not all(isinstance(field, str) for field in fields):
56             raise ValueError('Index.fields must contain only strings with field names.')
57         if include and not name:
58             raise ValueError('A covering index must be named.')
59         if not isinstance(include, (type(None), list, tuple)):
60             raise ValueError('Index.include must be a list or tuple.')
61         self.fields = list(fields)
62         # A list of 2-tuple with the field name and ordering ('' or 'DESC').
63         self.fields_orders = [
64             (field_name[1:], 'DESC') if field_name.startswith('-') else (field_name, '')
65             for field_name in self.fields
66         ]
67         self.name = name or ''
68         self.db_tablespace = db_tablespace
69         self.opclasses = opclasses
70         self.condition = condition
71         self.include = tuple(include) if include else ()
72         self.expressions = tuple(
73             F(expression) if isinstance(expression, str) else expression
74             for expression in expressions
75         )
76 
77     @property
78     def contains_expressions(self):
79         return bool(self.expressions)
80 
81     def _get_condition_sql(self, model, schema_editor):
82         if self.condition is None:
83             return None
84         query = Query(model=model, alias_cols=False)
85         where = query.build_where(self.condition)
86         compiler = query.get_compiler(connection=schema_editor.connection)
87         sql, params = where.as_sql(compiler, schema_editor.connection)
88         return sql % tuple(schema_editor.quote_value(p) for p in params)
89 
90     def create_sql(self, model, schema_editor, using='', **kwargs):
91         include = [model._meta.get_field(field_name).column for field_name in self.include]
92         condition = self._get_condition_sql(model, schema_editor)
93         if self.expressions:
94             index_expressions = []
95             for expression in self.expressions:
96                 index_expression = IndexExpression(expression)
97                 index_expression.set_wrapper_classes(schema_editor.connection)
98                 index_expressions.append(index_expression)
99             expressions = ExpressionList(*index_expressions).resolve_expression(
100                 Query(model, alias_cols=False),
101             )
102             fields = None
103             col_suffixes = None
104         else:
105             fields = [
106                 model._meta.get_field(field_name)
107                 for field_name, _ in self.fields_orders
108             ]
109             col_suffixes = [order[1] for order in self.fields_orders]
110             expressions = None
111         return schema_editor._create_index_sql(
112             model, fields=fields, name=self.name, using=using,
113             db_tablespace=self.db_tablespace, col_suffixes=col_suffixes,
114             opclasses=self.opclasses, condition=condition, include=include,
115             expressions=expressions, **kwargs,
116         )
117 
118     def remove_sql(self, model, schema_editor, **kwargs):
119         return schema_editor._delete_index_sql(model, self.name, **kwargs)
120 
121     def deconstruct(self):
122         path = '%s.%s' % (self.__class__.__module__, self.__class__.__name__)
123         path = path.replace('django.db.models.indexes', 'django.db.models')
124         kwargs = {'name': self.name}
125         if self.fields:
126             kwargs['fields'] = self.fields
127         if self.db_tablespace is not None:
128             kwargs['db_tablespace'] = self.db_tablespace
129         if self.opclasses:
130             kwargs['opclasses'] = self.opclasses
131         if self.condition:
132             kwargs['condition'] = self.condition
133         if self.include:
134             kwargs['include'] = self.include
135         return (path, self.expressions, kwargs)
136 
137     def clone(self):
138         """Create a copy of this Index."""
139         _, args, kwargs = self.deconstruct()
140         return self.__class__(*args, **kwargs)
141 
142     def set_name_with_model(self, model):
143         """
144         Generate a unique name for the index.
145 
146         The name is divided into 3 parts - table name (12 chars), field name
147         (8 chars) and unique hash + suffix (10 chars). Each part is made to
148         fit its size by truncating the excess length.
149         """
150         _, table_name = split_identifier(model._meta.db_table)
151         column_names = [model._meta.get_field(field_name).column for field_name, order in self.fields_orders]
152         column_names_with_order = [
153             (('-%s' if order else '%s') % column_name)
154             for column_name, (field_name, order) in zip(column_names, self.fields_orders)
155         ]
156         # The length of the parts of the name is based on the default max
157         # length of 30 characters.
158         hash_data = [table_name] + column_names_with_order + [self.suffix]
159         self.name = '%s_%s_%s' % (
160             table_name[:11],
161             column_names[0][:7],
162             '%s_%s' % (names_digest(*hash_data, length=6), self.suffix),
163         )
164         assert len(self.name) <= self.max_name_length, (
165             'Index too long for multiple database support. Is self.suffix '
166             'longer than 3 characters?'
167         )
168         if self.name[0] == '_' or self.name[0].isdigit():
169             self.name = 'D%s' % self.name[1:]
170 
171     def __repr__(self):
172         return '<%s:%s%s%s%s%s>' % (
173             self.__class__.__name__,
174             '' if not self.fields else " fields='%s'" % ', '.join(self.fields),
175             '' if not self.expressions else " expressions='%s'" % ', '.join([
176                 str(expression) for expression in self.expressions
177             ]),
178             '' if self.condition is None else ' condition=%s' % self.condition,
179             '' if not self.include else " include='%s'" % ', '.join(self.include),
180             '' if not self.opclasses else " opclasses='%s'" % ', '.join(self.opclasses),
181         )
182 
183     def __eq__(self, other):
184         if self.__class__ == other.__class__:
185             return self.deconstruct() == other.deconstruct()
186         return NotImplemented

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>, <file>django/db/models/constraints.py</file>
<class>UniqueConstraint</class>
<method>__repr__</method>
<code>
163     def __repr__(self):
164         return '<%s: fields=%r name=%r%s%s%s%s>' % (
165             self.__class__.__name__, self.fields, self.name,
166             '' if self.condition is None else ' condition=%s' % self.condition,
167             '' if self.deferrable is None else ' deferrable=%s' % self.deferrable,
168             '' if not self.include else ' include=%s' % repr(self.include),
169             '' if not self.opclasses else ' opclasses=%s' % repr(self.opclasses),
170         )

</code><intended_behavior>Standardize the use of representation markers (`%r` for all attribute values) and ensure conditional inclusions of attributes follow a common format. Ensure this method's structure aligns with others in aesthetics and information delivery.</intended_behavior>, <file>django/db/models/constraints.py</file>
<class>UniqueConstraint</class>
<method>None</method>
<code>
79 class UniqueConstraint(BaseConstraint):
80     def __init__(
81         self,
82         *,
83         fields,
84         name,
85         condition=None,
86         deferrable=None,
87         include=None,
88         opclasses=(),
89     ):
90         if not fields:
91             raise ValueError('At least one field is required to define a unique constraint.')
92         if not isinstance(condition, (type(None), Q)):
93             raise ValueError('UniqueConstraint.condition must be a Q instance.')
94         if condition and deferrable:
95             raise ValueError(
96                 'UniqueConstraint with conditions cannot be deferred.'
97             )
98         if include and deferrable:
99             raise ValueError(
100                 'UniqueConstraint with include fields cannot be deferred.'
101             )
102         if opclasses and deferrable:
103             raise ValueError(
104                 'UniqueConstraint with opclasses cannot be deferred.'
105             )
106         if not isinstance(deferrable, (type(None), Deferrable)):
107             raise ValueError(
108                 'UniqueConstraint.deferrable must be a Deferrable instance.'
109             )
110         if not isinstance(include, (type(None), list, tuple)):
111             raise ValueError('UniqueConstraint.include must be a list or tuple.')
112         if not isinstance(opclasses, (list, tuple)):
113             raise ValueError('UniqueConstraint.opclasses must be a list or tuple.')
114         if opclasses and len(fields) != len(opclasses):
115             raise ValueError(
116                 'UniqueConstraint.fields and UniqueConstraint.opclasses must '
117                 'have the same number of elements.'
118             )
119         self.fields = tuple(fields)
120         self.condition = condition
121         self.deferrable = deferrable
122         self.include = tuple(include) if include else ()
123         self.opclasses = opclasses
124         super().__init__(name)
125 
126     def _get_condition_sql(self, model, schema_editor):
127         if self.condition is None:
128             return None
129         query = Query(model=model, alias_cols=False)
130         where = query.build_where(self.condition)
131         compiler = query.get_compiler(connection=schema_editor.connection)
132         sql, params = where.as_sql(compiler, schema_editor.connection)
133         return sql % tuple(schema_editor.quote_value(p) for p in params)
134 
135     def constraint_sql(self, model, schema_editor):
136         fields = [model._meta.get_field(field_name).column for field_name in self.fields]
137         include = [model._meta.get_field(field_name).column for field_name in self.include]
138         condition = self._get_condition_sql(model, schema_editor)
139         return schema_editor._unique_sql(
140             model, fields, self.name, condition=condition,
141             deferrable=self.deferrable, include=include,
142             opclasses=self.opclasses,
143         )
144 
145     def create_sql(self, model, schema_editor):
146         fields = [model._meta.get_field(field_name).column for field_name in self.fields]
147         include = [model._meta.get_field(field_name).column for field_name in self.include]
148         condition = self._get_condition_sql(model, schema_editor)
149         return schema_editor._create_unique_sql(
150             model, fields, self.name, condition=condition,
151             deferrable=self.deferrable, include=include,
152             opclasses=self.opclasses,
153         )
154 
155     def remove_sql(self, model, schema_editor):
156         condition = self._get_condition_sql(model, schema_editor)
157         include = [model._meta.get_field(field_name).column for field_name in self.include]
158         return schema_editor._delete_unique_sql(
159             model, self.name, condition=condition, deferrable=self.deferrable,
160             include=include, opclasses=self.opclasses,
161         )
162 
163     def __repr__(self):
164         return '<%s: fields=%r name=%r%s%s%s%s>' % (
165             self.__class__.__name__, self.fields, self.name,
166             '' if self.condition is None else ' condition=%s' % self.condition,
167             '' if self.deferrable is None else ' deferrable=%s' % self.deferrable,
168             '' if not self.include else ' include=%s' % repr(self.include),
169             '' if not self.opclasses else ' opclasses=%s' % repr(self.opclasses),
170         )
171 
172     def __eq__(self, other):
173         if isinstance(other, UniqueConstraint):
174             return (
175                 self.name == other.name and
176                 self.fields == other.fields and
177                 self.condition == other.condition and
178                 self.deferrable == other.deferrable and
179                 self.include == other.include and
180                 self.opclasses == other.opclasses
181             )
182         return super().__eq__(other)
183 
184     def deconstruct(self):
185         path, args, kwargs = super().deconstruct()
186         kwargs['fields'] = self.fields
187         if self.condition:
188             kwargs['condition'] = self.condition
189         if self.deferrable:
190             kwargs['deferrable'] = self.deferrable
191         if self.include:
192             kwargs['include'] = self.include
193         if self.opclasses:
194             kwargs['opclasses'] = self.opclasses
195         return path, args, kwargs

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>, <file>django/contrib/postgres/constraints.py</file>
<class>ExclusionConstraint</class>
<method>__repr__</method>
<code>
157     def __repr__(self):
158         return '<%s: index_type=%s, expressions=%s%s%s%s%s>' % (
159             self.__class__.__qualname__,
160             self.index_type,
161             self.expressions,
162             '' if self.condition is None else ', condition=%s' % self.condition,
163             '' if self.deferrable is None else ', deferrable=%s' % self.deferrable,
164             '' if not self.include else ', include=%s' % repr(self.include),
165             '' if not self.opclasses else ', opclasses=%s' % repr(self.opclasses),
166         )

</code><intended_behavior>Adapt the `__repr__` method to follow the established patterns from `Index` and `UniqueConstraint` for a unified approach in attribute presentation. This includes standardizing how conditional attributes are displayed and ensuring the format remains clear and concise.</intended_behavior>, <file>django/contrib/postgres/constraints.py</file>
<class>ExclusionConstraint</class>
<method>None</method>
<code>
10 class ExclusionConstraint(BaseConstraint):
11     template = 'CONSTRAINT %(name)s EXCLUDE USING %(index_type)s (%(expressions)s)%(include)s%(where)s%(deferrable)s'
12 
13     def __init__(
14         self, *, name, expressions, index_type=None, condition=None,
15         deferrable=None, include=None, opclasses=(),
16     ):
17         if index_type and index_type.lower() not in {'gist', 'spgist'}:
18             raise ValueError(
19                 'Exclusion constraints only support GiST or SP-GiST indexes.'
20             )
21         if not expressions:
22             raise ValueError(
23                 'At least one expression is required to define an exclusion '
24                 'constraint.'
25             )
26         if not all(
27             isinstance(expr, (list, tuple)) and len(expr) == 2
28             for expr in expressions
29         ):
30             raise ValueError('The expressions must be a list of 2-tuples.')
31         if not isinstance(condition, (type(None), Q)):
32             raise ValueError(
33                 'ExclusionConstraint.condition must be a Q instance.'
34             )
35         if condition and deferrable:
36             raise ValueError(
37                 'ExclusionConstraint with conditions cannot be deferred.'
38             )
39         if not isinstance(deferrable, (type(None), Deferrable)):
40             raise ValueError(
41                 'ExclusionConstraint.deferrable must be a Deferrable instance.'
42             )
43         if not isinstance(include, (type(None), list, tuple)):
44             raise ValueError(
45                 'ExclusionConstraint.include must be a list or tuple.'
46             )
47         if include and index_type and index_type.lower() != 'gist':
48             raise ValueError(
49                 'Covering exclusion constraints only support GiST indexes.'
50             )
51         if not isinstance(opclasses, (list, tuple)):
52             raise ValueError(
53                 'ExclusionConstraint.opclasses must be a list or tuple.'
54             )
55         if opclasses and len(expressions) != len(opclasses):
56             raise ValueError(
57                 'ExclusionConstraint.expressions and '
58                 'ExclusionConstraint.opclasses must have the same number of '
59                 'elements.'
60             )
61         self.expressions = expressions
62         self.index_type = index_type or 'GIST'
63         self.condition = condition
64         self.deferrable = deferrable
65         self.include = tuple(include) if include else ()
66         self.opclasses = opclasses
67         super().__init__(name=name)
68 
69     def _get_expression_sql(self, compiler, schema_editor, query):
70         expressions = []
71         for idx, (expression, operator) in enumerate(self.expressions):
72             if isinstance(expression, str):
73                 expression = F(expression)
74             expression = expression.resolve_expression(query=query)
75             sql, params = compiler.compile(expression)
76             try:
77                 opclass = self.opclasses[idx]
78                 if opclass:
79                     sql = '%s %s' % (sql, opclass)
80             except IndexError:
81                 pass
82             sql = sql % tuple(schema_editor.quote_value(p) for p in params)
83             expressions.append('%s WITH %s' % (sql, operator))
84         return expressions
85 
86     def _get_condition_sql(self, compiler, schema_editor, query):
87         if self.condition is None:
88             return None
89         where = query.build_where(self.condition)
90         sql, params = where.as_sql(compiler, schema_editor.connection)
91         return sql % tuple(schema_editor.quote_value(p) for p in params)
92 
93     def constraint_sql(self, model, schema_editor):
94         query = Query(model, alias_cols=False)
95         compiler = query.get_compiler(connection=schema_editor.connection)
96         expressions = self._get_expression_sql(compiler, schema_editor, query)
97         condition = self._get_condition_sql(compiler, schema_editor, query)
98         include = [model._meta.get_field(field_name).column for field_name in self.include]
99         return self.template % {
100             'name': schema_editor.quote_name(self.name),
101             'index_type': self.index_type,
102             'expressions': ', '.join(expressions),
103             'include': schema_editor._index_include_sql(model, include),
104             'where': ' WHERE (%s)' % condition if condition else '',
105             'deferrable': schema_editor._deferrable_constraint_sql(self.deferrable),
106         }
107 
108     def create_sql(self, model, schema_editor):
109         self.check_supported(schema_editor)
110         return Statement(
111             'ALTER TABLE %(table)s ADD %(constraint)s',
112             table=Table(model._meta.db_table, schema_editor.quote_name),
113             constraint=self.constraint_sql(model, schema_editor),
114         )
115 
116     def remove_sql(self, model, schema_editor):
117         return schema_editor._delete_constraint_sql(
118             schema_editor.sql_delete_check,
119             model,
120             schema_editor.quote_name(self.name),
121         )
122 
123     def check_supported(self, schema_editor):
124         if self.include and not schema_editor.connection.features.supports_covering_gist_indexes:
125             raise NotSupportedError(
126                 'Covering exclusion constraints requires PostgreSQL 12+.'
127             )
128 
129     def deconstruct(self):
130         path, args, kwargs = super().deconstruct()
131         kwargs['expressions'] = self.expressions
132         if self.condition is not None:
133             kwargs['condition'] = self.condition
134         if self.index_type.lower() != 'gist':
135             kwargs['index_type'] = self.index_type
136         if self.deferrable:
137             kwargs['deferrable'] = self.deferrable
138         if self.include:
139             kwargs['include'] = self.include
140         if self.opclasses:
141             kwargs['opclasses'] = self.opclasses
142         return path, args, kwargs
143 
144     def __eq__(self, other):
145         if isinstance(other, self.__class__):
146             return (
147                 self.name == other.name and
148                 self.index_type == other.index_type and
149                 self.expressions == other.expressions and
150                 self.condition == other.condition and
151                 self.deferrable == other.deferrable and
152                 self.include == other.include and
153                 self.opclasses == other.opclasses
154             )
155         return super().__eq__(other)
156 
157     def __repr__(self):
158         return '<%s: index_type=%s, expressions=%s%s%s%s%s>' % (
159             self.__class__.__qualname__,
160             self.index_type,
161             self.expressions,
162             '' if self.condition is None else ', condition=%s' % self.condition,
163             '' if self.deferrable is None else ', deferrable=%s' % self.deferrable,
164             '' if not self.include else ', include=%s' % repr(self.include),
165             '' if not self.opclasses else ', opclasses=%s' % repr(self.opclasses),
166         )

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>, <file>django/db/models/constraints.py</file>
<class>CheckConstraint</class>
<method>__repr__</method>
<code>
60     def __repr__(self):
61         return "<%s: check='%s' name=%r>" % (self.__class__.__name__, self.check, self.name)

</code><intended_behavior>While maintaining the simplicity fitting CheckConstraint's needs, ensure that the presentation of its attributes aligns with the other classes in terms of formatting and conditionality. This could mean adopting the same style of conditionally including attributes and using consistent representation formats.</intended_behavior>, <file>django/db/models/constraints.py</file>
<class>CheckConstraint</class>
<method>None</method>
<code>
32 class CheckConstraint(BaseConstraint):
33     def __init__(self, *, check, name):
34         self.check = check
35         if not getattr(check, 'conditional', False):
36             raise TypeError(
37                 'CheckConstraint.check must be a Q instance or boolean '
38                 'expression.'
39             )
40         super().__init__(name)
41 
42     def _get_check_sql(self, model, schema_editor):
43         query = Query(model=model, alias_cols=False)
44         where = query.build_where(self.check)
45         compiler = query.get_compiler(connection=schema_editor.connection)
46         sql, params = where.as_sql(compiler, schema_editor.connection)
47         return sql % tuple(schema_editor.quote_value(p) for p in params)
48 
49     def constraint_sql(self, model, schema_editor):
50         check = self._get_check_sql(model, schema_editor)
51         return schema_editor._check_sql(self.name, check)
52 
53     def create_sql(self, model, schema_editor):
54         check = self._get_check_sql(model, schema_editor)
55         return schema_editor._create_check_sql(model, self.name, check)
56 
57     def remove_sql(self, model, schema_editor):
58         return schema_editor._delete_check_sql(model, self.name)
59 
60     def __repr__(self):
61         return "<%s: check='%s' name=%r>" % (self.__class__.__name__, self.check, self.name)
62 
63     def __eq__(self, other):
64         if isinstance(other, CheckConstraint):
65             return self.name == other.name and self.check == other.check
66         return super().__eq__(other)
67 
68     def deconstruct(self):
69         path, args, kwargs = super().deconstruct()
70         kwargs['check'] = self.check
71         return path, args, kwargs

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>]
2025-10-18 12:38:41.212 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-18 12:38:41.212 | INFO     | Search-only: skipping patch selection
2025-10-18 12:38:41.352 | INFO     | Task django__django-14019 completed successfully.
2025-10-18 12:38:41.353 | INFO     | No patch generated. You can try running ACR again.
