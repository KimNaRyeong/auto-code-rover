[
    {
        "rel_file_path": "src/_pytest/python_api.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/pytest-dev__pytest/setup_pytest-dev__pytest__8.0/src/_pytest/python_api.py",
        "start": 297,
        "end": 304,
        "class_name": "ApproxMapping",
        "method_name": "__eq__",
        "code": "297     def __eq__(self, actual) -> bool:\n298         try:\n299             if set(actual.keys()) != set(self.expected.keys()):\n300                 return False\n301         except AttributeError:\n302             return False\n303 \n304         return super().__eq__(actual)\n",
        "intended_behavior": "The `__eq__` method should be enhanced to explicitly check for `None` values in the dictionary being compared. When a `None` value is encountered, it should perform a strict equality comparison instead of proceeding with numeric approximation logic that leads to a `TypeError`. This adjustment ensures that `None` values within dictionaries are handled correctly, preserving the described functionality of the `approx` function for non-numeric types."
    },
    {
        "rel_file_path": "src/_pytest/python_api.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/pytest-dev__pytest/setup_pytest-dev__pytest__8.0/src/_pytest/python_api.py",
        "start": 244,
        "end": 315,
        "class_name": "ApproxMapping",
        "method_name": null,
        "code": "244 class ApproxMapping(ApproxBase):\n245     \"\"\"Perform approximate comparisons where the expected value is a mapping\n246     with numeric values (the keys can be anything).\"\"\"\n247 \n248     def __repr__(self) -> str:\n249         return \"approx({!r})\".format(\n250             {k: self._approx_scalar(v) for k, v in self.expected.items()}\n251         )\n252 \n253     def _repr_compare(self, other_side: Mapping[object, float]) -> List[str]:\n254         import math\n255 \n256         approx_side_as_map = {\n257             k: self._approx_scalar(v) for k, v in self.expected.items()\n258         }\n259 \n260         number_of_elements = len(approx_side_as_map)\n261         max_abs_diff = -math.inf\n262         max_rel_diff = -math.inf\n263         different_ids = []\n264         for (approx_key, approx_value), other_value in zip(\n265             approx_side_as_map.items(), other_side.values()\n266         ):\n267             if approx_value != other_value:\n268                 max_abs_diff = max(\n269                     max_abs_diff, abs(approx_value.expected - other_value)\n270                 )\n271                 if approx_value.expected == 0.0:\n272                     max_rel_diff = math.inf\n273                 else:\n274                     max_rel_diff = max(\n275                         max_rel_diff,\n276                         abs(\n277                             (approx_value.expected - other_value)\n278                             / approx_value.expected\n279                         ),\n280                     )\n281                 different_ids.append(approx_key)\n282 \n283         message_data = [\n284             (str(key), str(other_side[key]), str(approx_side_as_map[key]))\n285             for key in different_ids\n286         ]\n287 \n288         return _compare_approx(\n289             self.expected,\n290             message_data,\n291             number_of_elements,\n292             different_ids,\n293             max_abs_diff,\n294             max_rel_diff,\n295         )\n296 \n297     def __eq__(self, actual) -> bool:\n298         try:\n299             if set(actual.keys()) != set(self.expected.keys()):\n300                 return False\n301         except AttributeError:\n302             return False\n303 \n304         return super().__eq__(actual)\n305 \n306     def _yield_comparisons(self, actual):\n307         for k in self.expected.keys():\n308             yield actual[k], self.expected[k]\n309 \n310     def _check_type(self) -> None:\n311         __tracebackhide__ = True\n312         for key, value in self.expected.items():\n313             if isinstance(value, type(self.expected)):\n314                 msg = \"pytest.approx() does not support nested dictionaries: key={!r} value={!r}\\n  full mapping={}\"\n315                 raise TypeError(msg.format(key, value, pprint.pformat(self.expected)))\n",
        "intended_behavior": "This class provides additional context to the issue."
    }
]