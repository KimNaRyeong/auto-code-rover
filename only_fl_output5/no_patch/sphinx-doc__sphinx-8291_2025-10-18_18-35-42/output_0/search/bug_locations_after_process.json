[
    {
        "rel_file_path": "sphinx/ext/napoleon/docstring.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sphinx-doc__sphinx/setup_sphinx-doc__sphinx__3.4/sphinx/ext/napoleon/docstring.py",
        "start": 1,
        "end": 1267,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\"\n2     sphinx.ext.napoleon.docstring\n3     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n4 \n5 \n6     Classes for docstring parsing and formatting.\n7 \n8 \n9     :copyright: Copyright 2007-2020 by the Sphinx team, see AUTHORS.\n10     :license: BSD, see LICENSE for details.\n11 \"\"\"\n12 \n13 import collections\n14 import inspect\n15 import re\n16 from functools import partial\n17 from typing import Any, Callable, Dict, List, Tuple, Union\n18 \n19 from sphinx.application import Sphinx\n20 from sphinx.config import Config as SphinxConfig\n21 from sphinx.ext.napoleon.iterators import modify_iter\n22 from sphinx.locale import _, __\n23 from sphinx.util import logging\n24 \n25 if False:\n26     # For type annotation\n27     from typing import Type  # for python3.5.1\n28 \n29 \n30 logger = logging.getLogger(__name__)\n31 \n32 _directive_regex = re.compile(r'\\.\\. \\S+::')\n33 _google_section_regex = re.compile(r'^(\\s|\\w)+:\\s*$')\n34 _google_typed_arg_regex = re.compile(r'(.+?)\\(\\s*(.*[^\\s]+)\\s*\\)')\n35 _numpy_section_regex = re.compile(r'^[=\\-`:\\'\"~^_*+#<>]{2,}\\s*$')\n36 _single_colon_regex = re.compile(r'(?<!:):(?!:)')\n37 _xref_or_code_regex = re.compile(\n38     r'((?::(?:[a-zA-Z0-9]+[\\-_+:.])*[a-zA-Z0-9]+:`.+?`)|'\n39     r'(?:``.+?``))')\n40 _xref_regex = re.compile(\n41     r'(?:(?::(?:[a-zA-Z0-9]+[\\-_+:.])*[a-zA-Z0-9]+:)?`.+?`)'\n42 )\n43 _bullet_list_regex = re.compile(r'^(\\*|\\+|\\-)(\\s+\\S|\\s*$)')\n44 _enumerated_list_regex = re.compile(\n45     r'^(?P<paren>\\()?'\n46     r'(\\d+|#|[ivxlcdm]+|[IVXLCDM]+|[a-zA-Z])'\n47     r'(?(paren)\\)|\\.)(\\s+\\S|\\s*$)')\n48 _token_regex = re.compile(\n49     r\"(,\\sor\\s|\\sor\\s|\\sof\\s|:\\s|\\sto\\s|,\\sand\\s|\\sand\\s|,\\s\"\n50     r\"|[{]|[}]\"\n51     r'|\"(?:\\\\\"|[^\"])*\"'\n52     r\"|'(?:\\\\'|[^'])*')\"\n53 )\n54 _default_regex = re.compile(\n55     r\"^default[^_0-9A-Za-z].*$\",\n56 )\n57 _SINGLETONS = (\"None\", \"True\", \"False\", \"Ellipsis\")\n58 \n59 \n60 class GoogleDocstring:\n61     \"\"\"Convert Google style docstrings to reStructuredText.\n62 \n63     Parameters\n64     ----------\n65     docstring : :obj:`str` or :obj:`list` of :obj:`str`\n66         The docstring to parse, given either as a string or split into\n67         individual lines.\n68     config: :obj:`sphinx.ext.napoleon.Config` or :obj:`sphinx.config.Config`\n69         The configuration settings to use. If not given, defaults to the\n70         config object on `app`; or if `app` is not given defaults to the\n71         a new :class:`sphinx.ext.napoleon.Config` object.\n72 \n73 \n74     Other Parameters\n75     ----------------\n76     app : :class:`sphinx.application.Sphinx`, optional\n77         Application object representing the Sphinx process.\n78     what : :obj:`str`, optional\n79         A string specifying the type of the object to which the docstring\n80         belongs. Valid values: \"module\", \"class\", \"exception\", \"function\",\n81         \"method\", \"attribute\".\n82     name : :obj:`str`, optional\n83         The fully qualified name of the object.\n84     obj : module, class, exception, function, method, or attribute\n85         The object to which the docstring belongs.\n86     options : :class:`sphinx.ext.autodoc.Options`, optional\n87         The options given to the directive: an object with attributes\n88         inherited_members, undoc_members, show_inheritance and noindex that\n89         are True if the flag option of same name was given to the auto\n90         directive.\n91 \n92 \n93     Example\n94     -------\n95     >>> from sphinx.ext.napoleon import Config\n96     >>> config = Config(napoleon_use_param=True, napoleon_use_rtype=True)\n97     >>> docstring = '''One line summary.\n98     ...\n99     ... Extended description.\n100     ...\n101     ... Args:\n102     ...   arg1(int): Description of `arg1`\n103     ...   arg2(str): Description of `arg2`\n104     ... Returns:\n105     ...   str: Description of return value.\n106     ... '''\n107     >>> print(GoogleDocstring(docstring, config))\n108     One line summary.\n109     <BLANKLINE>\n110     Extended description.\n111     <BLANKLINE>\n112     :param arg1: Description of `arg1`\n113     :type arg1: int\n114     :param arg2: Description of `arg2`\n115     :type arg2: str\n116     <BLANKLINE>\n117     :returns: Description of return value.\n118     :rtype: str\n119     <BLANKLINE>\n120 \n121     \"\"\"\n122 \n123     _name_rgx = re.compile(r\"^\\s*((?::(?P<role>\\S+):)?`(?P<name>~?[a-zA-Z0-9_.-]+)`|\"\n124                            r\" (?P<name2>~?[a-zA-Z0-9_.-]+))\\s*\", re.X)\n125 \n126     def __init__(self, docstring: Union[str, List[str]], config: SphinxConfig = None,\n127                  app: Sphinx = None, what: str = '', name: str = '',\n128                  obj: Any = None, options: Any = None) -> None:\n129         self._config = config\n130         self._app = app\n131 \n132         if not self._config:\n133             from sphinx.ext.napoleon import Config\n134             self._config = self._app.config if self._app else Config()  # type: ignore\n135 \n136         if not what:\n137             if inspect.isclass(obj):\n138                 what = 'class'\n139             elif inspect.ismodule(obj):\n140                 what = 'module'\n141             elif callable(obj):\n142                 what = 'function'\n143             else:\n144                 what = 'object'\n145 \n146         self._what = what\n147         self._name = name\n148         self._obj = obj\n149         self._opt = options\n150         if isinstance(docstring, str):\n151             lines = docstring.splitlines()\n152         else:\n153             lines = docstring\n154         self._line_iter = modify_iter(lines, modifier=lambda s: s.rstrip())\n155         self._parsed_lines = []  # type: List[str]\n156         self._is_in_section = False\n157         self._section_indent = 0\n158         if not hasattr(self, '_directive_sections'):\n159             self._directive_sections = []  # type: List[str]\n160         if not hasattr(self, '_sections'):\n161             self._sections = {\n162                 'args': self._parse_parameters_section,\n163                 'arguments': self._parse_parameters_section,\n164                 'attention': partial(self._parse_admonition, 'attention'),\n165                 'attributes': self._parse_attributes_section,\n166                 'caution': partial(self._parse_admonition, 'caution'),\n167                 'danger': partial(self._parse_admonition, 'danger'),\n168                 'error': partial(self._parse_admonition, 'error'),\n169                 'example': self._parse_examples_section,\n170                 'examples': self._parse_examples_section,\n171                 'hint': partial(self._parse_admonition, 'hint'),\n172                 'important': partial(self._parse_admonition, 'important'),\n173                 'keyword args': self._parse_keyword_arguments_section,\n174                 'keyword arguments': self._parse_keyword_arguments_section,\n175                 'methods': self._parse_methods_section,\n176                 'note': partial(self._parse_admonition, 'note'),\n177                 'notes': self._parse_notes_section,\n178                 'other parameters': self._parse_other_parameters_section,\n179                 'parameters': self._parse_parameters_section,\n180                 'return': self._parse_returns_section,\n181                 'returns': self._parse_returns_section,\n182                 'raise': self._parse_raises_section,\n183                 'raises': self._parse_raises_section,\n184                 'references': self._parse_references_section,\n185                 'see also': self._parse_see_also_section,\n186                 'tip': partial(self._parse_admonition, 'tip'),\n187                 'todo': partial(self._parse_admonition, 'todo'),\n188                 'warning': partial(self._parse_admonition, 'warning'),\n189                 'warnings': partial(self._parse_admonition, 'warning'),\n190                 'warn': self._parse_warns_section,\n191                 'warns': self._parse_warns_section,\n192                 'yield': self._parse_yields_section,\n193                 'yields': self._parse_yields_section,\n194             }  # type: Dict[str, Callable]\n195 \n196         self._load_custom_sections()\n197 \n198         self._parse()\n199 \n200     def __str__(self) -> str:\n201         \"\"\"Return the parsed docstring in reStructuredText format.\n202 \n203         Returns\n204         -------\n205         unicode\n206             Unicode version of the docstring.\n207 \n208         \"\"\"\n209         return '\\n'.join(self.lines())\n210 \n211     def lines(self) -> List[str]:\n212         \"\"\"Return the parsed lines of the docstring in reStructuredText format.\n213 \n214         Returns\n215         -------\n216         list(str)\n217             The lines of the docstring in a list.\n218 \n219         \"\"\"\n220         return self._parsed_lines\n221 \n222     def _consume_indented_block(self, indent: int = 1) -> List[str]:\n223         lines = []\n224         line = self._line_iter.peek()\n225         while(not self._is_section_break() and\n226               (not line or self._is_indented(line, indent))):\n227             lines.append(next(self._line_iter))\n228             line = self._line_iter.peek()\n229         return lines\n230 \n231     def _consume_contiguous(self) -> List[str]:\n232         lines = []\n233         while (self._line_iter.has_next() and\n234                self._line_iter.peek() and\n235                not self._is_section_header()):\n236             lines.append(next(self._line_iter))\n237         return lines\n238 \n239     def _consume_empty(self) -> List[str]:\n240         lines = []\n241         line = self._line_iter.peek()\n242         while self._line_iter.has_next() and not line:\n243             lines.append(next(self._line_iter))\n244             line = self._line_iter.peek()\n245         return lines\n246 \n247     def _consume_field(self, parse_type: bool = True, prefer_type: bool = False\n248                        ) -> Tuple[str, str, List[str]]:\n249         line = next(self._line_iter)\n250 \n251         before, colon, after = self._partition_field_on_colon(line)\n252         _name, _type, _desc = before, '', after\n253 \n254         if parse_type:\n255             match = _google_typed_arg_regex.match(before)\n256             if match:\n257                 _name = match.group(1).strip()\n258                 _type = match.group(2)\n259 \n260         _name = self._escape_args_and_kwargs(_name)\n261 \n262         if prefer_type and not _type:\n263             _type, _name = _name, _type\n264         indent = self._get_indent(line) + 1\n265         _descs = [_desc] + self._dedent(self._consume_indented_block(indent))\n266         _descs = self.__class__(_descs, self._config).lines()\n267         return _name, _type, _descs\n268 \n269     def _consume_fields(self, parse_type: bool = True, prefer_type: bool = False,\n270                         multiple: bool = False) -> List[Tuple[str, str, List[str]]]:\n271         self._consume_empty()\n272         fields = []\n273         while not self._is_section_break():\n274             _name, _type, _desc = self._consume_field(parse_type, prefer_type)\n275             if multiple and _name:\n276                 for name in _name.split(\",\"):\n277                     fields.append((name.strip(), _type, _desc))\n278             elif _name or _type or _desc:\n279                 fields.append((_name, _type, _desc,))\n280         return fields\n281 \n282     def _consume_inline_attribute(self) -> Tuple[str, List[str]]:\n283         line = next(self._line_iter)\n284         _type, colon, _desc = self._partition_field_on_colon(line)\n285         if not colon or not _desc:\n286             _type, _desc = _desc, _type\n287             _desc += colon\n288         _descs = [_desc] + self._dedent(self._consume_to_end())\n289         _descs = self.__class__(_descs, self._config).lines()\n290         return _type, _descs\n291 \n292     def _consume_returns_section(self) -> List[Tuple[str, str, List[str]]]:\n293         lines = self._dedent(self._consume_to_next_section())\n294         if lines:\n295             before, colon, after = self._partition_field_on_colon(lines[0])\n296             _name, _type, _desc = '', '', lines\n297 \n298             if colon:\n299                 if after:\n300                     _desc = [after] + lines[1:]\n301                 else:\n302                     _desc = lines[1:]\n303 \n304                 _type = before\n305 \n306             _desc = self.__class__(_desc, self._config).lines()\n307             return [(_name, _type, _desc,)]\n308         else:\n309             return []\n310 \n311     def _consume_usage_section(self) -> List[str]:\n312         lines = self._dedent(self._consume_to_next_section())\n313         return lines\n314 \n315     def _consume_section_header(self) -> str:\n316         section = next(self._line_iter)\n317         stripped_section = section.strip(':')\n318         if stripped_section.lower() in self._sections:\n319             section = stripped_section\n320         return section\n321 \n322     def _consume_to_end(self) -> List[str]:\n323         lines = []\n324         while self._line_iter.has_next():\n325             lines.append(next(self._line_iter))\n326         return lines\n327 \n328     def _consume_to_next_section(self) -> List[str]:\n329         self._consume_empty()\n330         lines = []\n331         while not self._is_section_break():\n332             lines.append(next(self._line_iter))\n333         return lines + self._consume_empty()\n334 \n335     def _dedent(self, lines: List[str], full: bool = False) -> List[str]:\n336         if full:\n337             return [line.lstrip() for line in lines]\n338         else:\n339             min_indent = self._get_min_indent(lines)\n340             return [line[min_indent:] for line in lines]\n341 \n342     def _escape_args_and_kwargs(self, name: str) -> str:\n343         if name.endswith('_') and getattr(self._config, 'strip_signature_backslash', False):\n344             name = name[:-1] + r'\\_'\n345 \n346         if name[:2] == '**':\n347             return r'\\*\\*' + name[2:]\n348         elif name[:1] == '*':\n349             return r'\\*' + name[1:]\n350         else:\n351             return name\n352 \n353     def _fix_field_desc(self, desc: List[str]) -> List[str]:\n354         if self._is_list(desc):\n355             desc = [''] + desc\n356         elif desc[0].endswith('::'):\n357             desc_block = desc[1:]\n358             indent = self._get_indent(desc[0])\n359             block_indent = self._get_initial_indent(desc_block)\n360             if block_indent > indent:\n361                 desc = [''] + desc\n362             else:\n363                 desc = ['', desc[0]] + self._indent(desc_block, 4)\n364         return desc\n365 \n366     def _format_admonition(self, admonition: str, lines: List[str]) -> List[str]:\n367         lines = self._strip_empty(lines)\n368         if len(lines) == 1:\n369             return ['.. %s:: %s' % (admonition, lines[0].strip()), '']\n370         elif lines:\n371             lines = self._indent(self._dedent(lines), 3)\n372             return ['.. %s::' % admonition, ''] + lines + ['']\n373         else:\n374             return ['.. %s::' % admonition, '']\n375 \n376     def _format_block(self, prefix: str, lines: List[str], padding: str = None) -> List[str]:\n377         if lines:\n378             if padding is None:\n379                 padding = ' ' * len(prefix)\n380             result_lines = []\n381             for i, line in enumerate(lines):\n382                 if i == 0:\n383                     result_lines.append((prefix + line).rstrip())\n384                 elif line:\n385                     result_lines.append(padding + line)\n386                 else:\n387                     result_lines.append('')\n388             return result_lines\n389         else:\n390             return [prefix]\n391 \n392     def _format_docutils_params(self, fields: List[Tuple[str, str, List[str]]],\n393                                 field_role: str = 'param', type_role: str = 'type'\n394                                 ) -> List[str]:\n395         lines = []\n396         for _name, _type, _desc in fields:\n397             _desc = self._strip_empty(_desc)\n398             if any(_desc):\n399                 _desc = self._fix_field_desc(_desc)\n400                 field = ':%s %s: ' % (field_role, _name)\n401                 lines.extend(self._format_block(field, _desc))\n402             else:\n403                 lines.append(':%s %s:' % (field_role, _name))\n404 \n405             if _type:\n406                 lines.append(':%s %s: %s' % (type_role, _name, _type))\n407         return lines + ['']\n408 \n409     def _format_field(self, _name: str, _type: str, _desc: List[str]) -> List[str]:\n410         _desc = self._strip_empty(_desc)\n411         has_desc = any(_desc)\n412         separator = ' -- ' if has_desc else ''\n413         if _name:\n414             if _type:\n415                 if '`' in _type:\n416                     field = '**%s** (%s)%s' % (_name, _type, separator)\n417                 else:\n418                     field = '**%s** (*%s*)%s' % (_name, _type, separator)\n419             else:\n420                 field = '**%s**%s' % (_name, separator)\n421         elif _type:\n422             if '`' in _type:\n423                 field = '%s%s' % (_type, separator)\n424             else:\n425                 field = '*%s*%s' % (_type, separator)\n426         else:\n427             field = ''\n428 \n429         if has_desc:\n430             _desc = self._fix_field_desc(_desc)\n431             if _desc[0]:\n432                 return [field + _desc[0]] + _desc[1:]\n433             else:\n434                 return [field] + _desc\n435         else:\n436             return [field]\n437 \n438     def _format_fields(self, field_type: str, fields: List[Tuple[str, str, List[str]]]\n439                        ) -> List[str]:\n440         field_type = ':%s:' % field_type.strip()\n441         padding = ' ' * len(field_type)\n442         multi = len(fields) > 1\n443         lines = []  # type: List[str]\n444         for _name, _type, _desc in fields:\n445             field = self._format_field(_name, _type, _desc)\n446             if multi:\n447                 if lines:\n448                     lines.extend(self._format_block(padding + ' * ', field))\n449                 else:\n450                     lines.extend(self._format_block(field_type + ' * ', field))\n451             else:\n452                 lines.extend(self._format_block(field_type + ' ', field))\n453         if lines and lines[-1]:\n454             lines.append('')\n455         return lines\n456 \n457     def _get_current_indent(self, peek_ahead: int = 0) -> int:\n458         line = self._line_iter.peek(peek_ahead + 1)[peek_ahead]\n459         while line != self._line_iter.sentinel:\n460             if line:\n461                 return self._get_indent(line)\n462             peek_ahead += 1\n463             line = self._line_iter.peek(peek_ahead + 1)[peek_ahead]\n464         return 0\n465 \n466     def _get_indent(self, line: str) -> int:\n467         for i, s in enumerate(line):\n468             if not s.isspace():\n469                 return i\n470         return len(line)\n471 \n472     def _get_initial_indent(self, lines: List[str]) -> int:\n473         for line in lines:\n474             if line:\n475                 return self._get_indent(line)\n476         return 0\n477 \n478     def _get_min_indent(self, lines: List[str]) -> int:\n479         min_indent = None\n480         for line in lines:\n481             if line:\n482                 indent = self._get_indent(line)\n483                 if min_indent is None:\n484                     min_indent = indent\n485                 elif indent < min_indent:\n486                     min_indent = indent\n487         return min_indent or 0\n488 \n489     def _indent(self, lines: List[str], n: int = 4) -> List[str]:\n490         return [(' ' * n) + line for line in lines]\n491 \n492     def _is_indented(self, line: str, indent: int = 1) -> bool:\n493         for i, s in enumerate(line):\n494             if i >= indent:\n495                 return True\n496             elif not s.isspace():\n497                 return False\n498         return False\n499 \n500     def _is_list(self, lines: List[str]) -> bool:\n501         if not lines:\n502             return False\n503         if _bullet_list_regex.match(lines[0]):\n504             return True\n505         if _enumerated_list_regex.match(lines[0]):\n506             return True\n507         if len(lines) < 2 or lines[0].endswith('::'):\n508             return False\n509         indent = self._get_indent(lines[0])\n510         next_indent = indent\n511         for line in lines[1:]:\n512             if line:\n513                 next_indent = self._get_indent(line)\n514                 break\n515         return next_indent > indent\n516 \n517     def _is_section_header(self) -> bool:\n518         section = self._line_iter.peek().lower()\n519         match = _google_section_regex.match(section)\n520         if match and section.strip(':') in self._sections:\n521             header_indent = self._get_indent(section)\n522             section_indent = self._get_current_indent(peek_ahead=1)\n523             return section_indent > header_indent\n524         elif self._directive_sections:\n525             if _directive_regex.match(section):\n526                 for directive_section in self._directive_sections:\n527                     if section.startswith(directive_section):\n528                         return True\n529         return False\n530 \n531     def _is_section_break(self) -> bool:\n532         line = self._line_iter.peek()\n533         return (not self._line_iter.has_next() or\n534                 self._is_section_header() or\n535                 (self._is_in_section and\n536                     line and\n537                     not self._is_indented(line, self._section_indent)))\n538 \n539     def _load_custom_sections(self) -> None:\n540         if self._config.napoleon_custom_sections is not None:\n541             for entry in self._config.napoleon_custom_sections:\n542                 if isinstance(entry, str):\n543                     # if entry is just a label, add to sections list,\n544                     # using generic section logic.\n545                     self._sections[entry.lower()] = self._parse_custom_generic_section\n546                 else:\n547                     # otherwise, assume entry is container;\n548                     # [0] is new section, [1] is the section to alias.\n549                     # in the case of key mismatch, just handle as generic section.\n550                     self._sections[entry[0].lower()] = \\\n551                         self._sections.get(entry[1].lower(),\n552                                            self._parse_custom_generic_section)\n553 \n554     def _parse(self) -> None:\n555         self._parsed_lines = self._consume_empty()\n556 \n557         if self._name and self._what in ('attribute', 'data', 'property'):\n558             # Implicit stop using StopIteration no longer allowed in\n559             # Python 3.7; see PEP 479\n560             res = []  # type: List[str]\n561             try:\n562                 res = self._parse_attribute_docstring()\n563             except StopIteration:\n564                 pass\n565             self._parsed_lines.extend(res)\n566             return\n567 \n568         while self._line_iter.has_next():\n569             if self._is_section_header():\n570                 try:\n571                     section = self._consume_section_header()\n572                     self._is_in_section = True\n573                     self._section_indent = self._get_current_indent()\n574                     if _directive_regex.match(section):\n575                         lines = [section] + self._consume_to_next_section()\n576                     else:\n577                         lines = self._sections[section.lower()](section)\n578                 finally:\n579                     self._is_in_section = False\n580                     self._section_indent = 0\n581             else:\n582                 if not self._parsed_lines:\n583                     lines = self._consume_contiguous() + self._consume_empty()\n584                 else:\n585                     lines = self._consume_to_next_section()\n586             self._parsed_lines.extend(lines)\n587 \n588     def _parse_admonition(self, admonition: str, section: str) -> List[str]:\n589         # type (str, str) -> List[str]\n590         lines = self._consume_to_next_section()\n591         return self._format_admonition(admonition, lines)\n592 \n593     def _parse_attribute_docstring(self) -> List[str]:\n594         _type, _desc = self._consume_inline_attribute()\n595         lines = self._format_field('', '', _desc)\n596         if _type:\n597             lines.extend(['', ':type: %s' % _type])\n598         return lines\n599 \n600     def _parse_attributes_section(self, section: str) -> List[str]:\n601         lines = []\n602         for _name, _type, _desc in self._consume_fields():\n603             if self._config.napoleon_use_ivar:\n604                 _name = self._qualify_name(_name, self._obj)\n605                 field = ':ivar %s: ' % _name\n606                 lines.extend(self._format_block(field, _desc))\n607                 if _type:\n608                     lines.append(':vartype %s: %s' % (_name, _type))\n609             else:\n610                 lines.append('.. attribute:: ' + _name)\n611                 if self._opt and 'noindex' in self._opt:\n612                     lines.append('   :noindex:')\n613                 lines.append('')\n614 \n615                 fields = self._format_field('', '', _desc)\n616                 lines.extend(self._indent(fields, 3))\n617                 if _type:\n618                     lines.append('')\n619                     lines.extend(self._indent([':type: %s' % _type], 3))\n620                 lines.append('')\n621         if self._config.napoleon_use_ivar:\n622             lines.append('')\n623         return lines\n624 \n625     def _parse_examples_section(self, section: str) -> List[str]:\n626         labels = {\n627             'example': _('Example'),\n628             'examples': _('Examples'),\n629         }\n630         use_admonition = self._config.napoleon_use_admonition_for_examples\n631         label = labels.get(section.lower(), section)\n632         return self._parse_generic_section(label, use_admonition)\n633 \n634     def _parse_custom_generic_section(self, section: str) -> List[str]:\n635         # for now, no admonition for simple custom sections\n636         return self._parse_generic_section(section, False)\n637 \n638     def _parse_usage_section(self, section: str) -> List[str]:\n639         header = ['.. rubric:: Usage:', '']\n640         block = ['.. code-block:: python', '']\n641         lines = self._consume_usage_section()\n642         lines = self._indent(lines, 3)\n643         return header + block + lines + ['']\n644 \n645     def _parse_generic_section(self, section: str, use_admonition: bool) -> List[str]:\n646         lines = self._strip_empty(self._consume_to_next_section())\n647         lines = self._dedent(lines)\n648         if use_admonition:\n649             header = '.. admonition:: %s' % section\n650             lines = self._indent(lines, 3)\n651         else:\n652             header = '.. rubric:: %s' % section\n653         if lines:\n654             return [header, ''] + lines + ['']\n655         else:\n656             return [header, '']\n657 \n658     def _parse_keyword_arguments_section(self, section: str) -> List[str]:\n659         fields = self._consume_fields()\n660         if self._config.napoleon_use_keyword:\n661             return self._format_docutils_params(\n662                 fields,\n663                 field_role=\"keyword\",\n664                 type_role=\"kwtype\")\n665         else:\n666             return self._format_fields(_('Keyword Arguments'), fields)\n667 \n668     def _parse_methods_section(self, section: str) -> List[str]:\n669         lines = []  # type: List[str]\n670         for _name, _type, _desc in self._consume_fields(parse_type=False):\n671             lines.append('.. method:: %s' % _name)\n672             if self._opt and 'noindex' in self._opt:\n673                 lines.append('   :noindex:')\n674             if _desc:\n675                 lines.extend([''] + self._indent(_desc, 3))\n676             lines.append('')\n677         return lines\n678 \n679     def _parse_notes_section(self, section: str) -> List[str]:\n680         use_admonition = self._config.napoleon_use_admonition_for_notes\n681         return self._parse_generic_section(_('Notes'), use_admonition)\n682 \n683     def _parse_other_parameters_section(self, section: str) -> List[str]:\n684         return self._format_fields(_('Other Parameters'), self._consume_fields())\n685 \n686     def _parse_parameters_section(self, section: str) -> List[str]:\n687         if self._config.napoleon_use_param:\n688             # Allow to declare multiple parameters at once (ex: x, y: int)\n689             fields = self._consume_fields(multiple=True)\n690             return self._format_docutils_params(fields)\n691         else:\n692             fields = self._consume_fields()\n693             return self._format_fields(_('Parameters'), fields)\n694 \n695     def _parse_raises_section(self, section: str) -> List[str]:\n696         fields = self._consume_fields(parse_type=False, prefer_type=True)\n697         lines = []  # type: List[str]\n698         for _name, _type, _desc in fields:\n699             m = self._name_rgx.match(_type)\n700             if m and m.group('name'):\n701                 _type = m.group('name')\n702             elif _xref_regex.match(_type):\n703                 pos = _type.find('`')\n704                 _type = _type[pos + 1:-1]\n705             _type = ' ' + _type if _type else ''\n706             _desc = self._strip_empty(_desc)\n707             _descs = ' ' + '\\n    '.join(_desc) if any(_desc) else ''\n708             lines.append(':raises%s:%s' % (_type, _descs))\n709         if lines:\n710             lines.append('')\n711         return lines\n712 \n713     def _parse_references_section(self, section: str) -> List[str]:\n714         use_admonition = self._config.napoleon_use_admonition_for_references\n715         return self._parse_generic_section(_('References'), use_admonition)\n716 \n717     def _parse_returns_section(self, section: str) -> List[str]:\n718         fields = self._consume_returns_section()\n719         multi = len(fields) > 1\n720         if multi:\n721             use_rtype = False\n722         else:\n723             use_rtype = self._config.napoleon_use_rtype\n724 \n725         lines = []  # type: List[str]\n726         for _name, _type, _desc in fields:\n727             if use_rtype:\n728                 field = self._format_field(_name, '', _desc)\n729             else:\n730                 field = self._format_field(_name, _type, _desc)\n731 \n732             if multi:\n733                 if lines:\n734                     lines.extend(self._format_block('          * ', field))\n735                 else:\n736                     lines.extend(self._format_block(':returns: * ', field))\n737             else:\n738                 lines.extend(self._format_block(':returns: ', field))\n739                 if _type and use_rtype:\n740                     lines.extend([':rtype: %s' % _type, ''])\n741         if lines and lines[-1]:\n742             lines.append('')\n743         return lines\n744 \n745     def _parse_see_also_section(self, section: str) -> List[str]:\n746         return self._parse_admonition('seealso', section)\n747 \n748     def _parse_warns_section(self, section: str) -> List[str]:\n749         return self._format_fields(_('Warns'), self._consume_fields())\n750 \n751     def _parse_yields_section(self, section: str) -> List[str]:\n752         fields = self._consume_returns_section()\n753         return self._format_fields(_('Yields'), fields)\n754 \n755     def _partition_field_on_colon(self, line: str) -> Tuple[str, str, str]:\n756         before_colon = []\n757         after_colon = []\n758         colon = ''\n759         found_colon = False\n760         for i, source in enumerate(_xref_or_code_regex.split(line)):\n761             if found_colon:\n762                 after_colon.append(source)\n763             else:\n764                 m = _single_colon_regex.search(source)\n765                 if (i % 2) == 0 and m:\n766                     found_colon = True\n767                     colon = source[m.start(): m.end()]\n768                     before_colon.append(source[:m.start()])\n769                     after_colon.append(source[m.end():])\n770                 else:\n771                     before_colon.append(source)\n772 \n773         return (\"\".join(before_colon).strip(),\n774                 colon,\n775                 \"\".join(after_colon).strip())\n776 \n777     def _qualify_name(self, attr_name: str, klass: \"Type\") -> str:\n778         if klass and '.' not in attr_name:\n779             if attr_name.startswith('~'):\n780                 attr_name = attr_name[1:]\n781             try:\n782                 q = klass.__qualname__\n783             except AttributeError:\n784                 q = klass.__name__\n785             return '~%s.%s' % (q, attr_name)\n786         return attr_name\n787 \n788     def _strip_empty(self, lines: List[str]) -> List[str]:\n789         if lines:\n790             start = -1\n791             for i, line in enumerate(lines):\n792                 if line:\n793                     start = i\n794                     break\n795             if start == -1:\n796                 lines = []\n797             end = -1\n798             for i in reversed(range(len(lines))):\n799                 line = lines[i]\n800                 if line:\n801                     end = i\n802                     break\n803             if start > 0 or end + 1 < len(lines):\n804                 lines = lines[start:end + 1]\n805         return lines\n806 \n807 \n808 def _recombine_set_tokens(tokens: List[str]) -> List[str]:\n809     token_queue = collections.deque(tokens)\n810     keywords = (\"optional\", \"default\")\n811 \n812     def takewhile_set(tokens):\n813         open_braces = 0\n814         previous_token = None\n815         while True:\n816             try:\n817                 token = tokens.popleft()\n818             except IndexError:\n819                 break\n820 \n821             if token == \", \":\n822                 previous_token = token\n823                 continue\n824 \n825             if not token.strip():\n826                 continue\n827 \n828             if token in keywords:\n829                 tokens.appendleft(token)\n830                 if previous_token is not None:\n831                     tokens.appendleft(previous_token)\n832                 break\n833 \n834             if previous_token is not None:\n835                 yield previous_token\n836                 previous_token = None\n837 \n838             if token == \"{\":\n839                 open_braces += 1\n840             elif token == \"}\":\n841                 open_braces -= 1\n842 \n843             yield token\n844 \n845             if open_braces == 0:\n846                 break\n847 \n848     def combine_set(tokens):\n849         while True:\n850             try:\n851                 token = tokens.popleft()\n852             except IndexError:\n853                 break\n854 \n855             if token == \"{\":\n856                 tokens.appendleft(\"{\")\n857                 yield \"\".join(takewhile_set(tokens))\n858             else:\n859                 yield token\n860 \n861     return list(combine_set(token_queue))\n862 \n863 \n864 def _tokenize_type_spec(spec: str) -> List[str]:\n865     def postprocess(item):\n866         if _default_regex.match(item):\n867             default = item[:7]\n868             # can't be separated by anything other than a single space\n869             # for now\n870             other = item[8:]\n871 \n872             return [default, \" \", other]\n873         else:\n874             return [item]\n875 \n876     tokens = list(\n877         item\n878         for raw_token in _token_regex.split(spec)\n879         for item in postprocess(raw_token)\n880         if item\n881     )\n882     return tokens\n883 \n884 \n885 def _token_type(token: str, location: str = None) -> str:\n886     def is_numeric(token):\n887         try:\n888             # use complex to make sure every numeric value is detected as literal\n889             complex(token)\n890         except ValueError:\n891             return False\n892         else:\n893             return True\n894 \n895     if token.startswith(\" \") or token.endswith(\" \"):\n896         type_ = \"delimiter\"\n897     elif (\n898             is_numeric(token) or\n899             (token.startswith(\"{\") and token.endswith(\"}\")) or\n900             (token.startswith('\"') and token.endswith('\"')) or\n901             (token.startswith(\"'\") and token.endswith(\"'\"))\n902     ):\n903         type_ = \"literal\"\n904     elif token.startswith(\"{\"):\n905         logger.warning(\n906             __(\"invalid value set (missing closing brace): %s\"),\n907             token,\n908             location=location,\n909         )\n910         type_ = \"literal\"\n911     elif token.endswith(\"}\"):\n912         logger.warning(\n913             __(\"invalid value set (missing opening brace): %s\"),\n914             token,\n915             location=location,\n916         )\n917         type_ = \"literal\"\n918     elif token.startswith(\"'\") or token.startswith('\"'):\n919         logger.warning(\n920             __(\"malformed string literal (missing closing quote): %s\"),\n921             token,\n922             location=location,\n923         )\n924         type_ = \"literal\"\n925     elif token.endswith(\"'\") or token.endswith('\"'):\n926         logger.warning(\n927             __(\"malformed string literal (missing opening quote): %s\"),\n928             token,\n929             location=location,\n930         )\n931         type_ = \"literal\"\n932     elif token in (\"optional\", \"default\"):\n933         # default is not a official keyword (yet) but supported by the\n934         # reference implementation (numpydoc) and widely used\n935         type_ = \"control\"\n936     elif _xref_regex.match(token):\n937         type_ = \"reference\"\n938     else:\n939         type_ = \"obj\"\n940 \n941     return type_\n942 \n943 \n944 def _convert_numpy_type_spec(_type: str, location: str = None, translations: dict = {}) -> str:\n945     def convert_obj(obj, translations, default_translation):\n946         translation = translations.get(obj, obj)\n947 \n948         # use :class: (the default) only if obj is not a standard singleton\n949         if translation in _SINGLETONS and default_translation == \":class:`%s`\":\n950             default_translation = \":obj:`%s`\"\n951         elif translation == \"...\" and default_translation == \":class:`%s`\":\n952             # allow referencing the builtin ...\n953             default_translation = \":obj:`%s <Ellipsis>`\"\n954 \n955         if _xref_regex.match(translation) is None:\n956             translation = default_translation % translation\n957 \n958         return translation\n959 \n960     tokens = _tokenize_type_spec(_type)\n961     combined_tokens = _recombine_set_tokens(tokens)\n962     types = [\n963         (token, _token_type(token, location))\n964         for token in combined_tokens\n965     ]\n966 \n967     converters = {\n968         \"literal\": lambda x: \"``%s``\" % x,\n969         \"obj\": lambda x: convert_obj(x, translations, \":class:`%s`\"),\n970         \"control\": lambda x: \"*%s*\" % x,\n971         \"delimiter\": lambda x: x,\n972         \"reference\": lambda x: x,\n973     }\n974 \n975     converted = \"\".join(converters.get(type_)(token) for token, type_ in types)\n976 \n977     return converted\n978 \n979 \n980 class NumpyDocstring(GoogleDocstring):\n981     \"\"\"Convert NumPy style docstrings to reStructuredText.\n982 \n983     Parameters\n984     ----------\n985     docstring : :obj:`str` or :obj:`list` of :obj:`str`\n986         The docstring to parse, given either as a string or split into\n987         individual lines.\n988     config: :obj:`sphinx.ext.napoleon.Config` or :obj:`sphinx.config.Config`\n989         The configuration settings to use. If not given, defaults to the\n990         config object on `app`; or if `app` is not given defaults to the\n991         a new :class:`sphinx.ext.napoleon.Config` object.\n992 \n993 \n994     Other Parameters\n995     ----------------\n996     app : :class:`sphinx.application.Sphinx`, optional\n997         Application object representing the Sphinx process.\n998     what : :obj:`str`, optional\n999         A string specifying the type of the object to which the docstring\n1000         belongs. Valid values: \"module\", \"class\", \"exception\", \"function\",\n1001         \"method\", \"attribute\".\n1002     name : :obj:`str`, optional\n1003         The fully qualified name of the object.\n1004     obj : module, class, exception, function, method, or attribute\n1005         The object to which the docstring belongs.\n1006     options : :class:`sphinx.ext.autodoc.Options`, optional\n1007         The options given to the directive: an object with attributes\n1008         inherited_members, undoc_members, show_inheritance and noindex that\n1009         are True if the flag option of same name was given to the auto\n1010         directive.\n1011 \n1012 \n1013     Example\n1014     -------\n1015     >>> from sphinx.ext.napoleon import Config\n1016     >>> config = Config(napoleon_use_param=True, napoleon_use_rtype=True)\n1017     >>> docstring = '''One line summary.\n1018     ...\n1019     ... Extended description.\n1020     ...\n1021     ... Parameters\n1022     ... ----------\n1023     ... arg1 : int\n1024     ...     Description of `arg1`\n1025     ... arg2 : str\n1026     ...     Description of `arg2`\n1027     ... Returns\n1028     ... -------\n1029     ... str\n1030     ...     Description of return value.\n1031     ... '''\n1032     >>> print(NumpyDocstring(docstring, config))\n1033     One line summary.\n1034     <BLANKLINE>\n1035     Extended description.\n1036     <BLANKLINE>\n1037     :param arg1: Description of `arg1`\n1038     :type arg1: int\n1039     :param arg2: Description of `arg2`\n1040     :type arg2: str\n1041     <BLANKLINE>\n1042     :returns: Description of return value.\n1043     :rtype: str\n1044     <BLANKLINE>\n1045 \n1046     Methods\n1047     -------\n1048     __str__()\n1049         Return the parsed docstring in reStructuredText format.\n1050 \n1051         Returns\n1052         -------\n1053         str\n1054             UTF-8 encoded version of the docstring.\n1055 \n1056     __unicode__()\n1057         Return the parsed docstring in reStructuredText format.\n1058 \n1059         Returns\n1060         -------\n1061         unicode\n1062             Unicode version of the docstring.\n1063 \n1064     lines()\n1065         Return the parsed lines of the docstring in reStructuredText format.\n1066 \n1067         Returns\n1068         -------\n1069         list(str)\n1070             The lines of the docstring in a list.\n1071 \n1072     \"\"\"\n1073     def __init__(self, docstring: Union[str, List[str]], config: SphinxConfig = None,\n1074                  app: Sphinx = None, what: str = '', name: str = '',\n1075                  obj: Any = None, options: Any = None) -> None:\n1076         self._directive_sections = ['.. index::']\n1077         super().__init__(docstring, config, app, what, name, obj, options)\n1078 \n1079     def _get_location(self) -> str:\n1080         try:\n1081             filepath = inspect.getfile(self._obj) if self._obj is not None else None\n1082         except TypeError:\n1083             filepath = None\n1084         name = self._name\n1085 \n1086         if filepath is None and name is None:\n1087             return None\n1088         elif filepath is None:\n1089             filepath = \"\"\n1090 \n1091         return \":\".join([filepath, \"docstring of %s\" % name])\n1092 \n1093     def _escape_args_and_kwargs(self, name: str) -> str:\n1094         func = super()._escape_args_and_kwargs\n1095 \n1096         if \", \" in name:\n1097             return \", \".join(func(param) for param in name.split(\", \"))\n1098         else:\n1099             return func(name)\n1100 \n1101     def _consume_field(self, parse_type: bool = True, prefer_type: bool = False\n1102                        ) -> Tuple[str, str, List[str]]:\n1103         line = next(self._line_iter)\n1104         if parse_type:\n1105             _name, _, _type = self._partition_field_on_colon(line)\n1106         else:\n1107             _name, _type = line, ''\n1108         _name, _type = _name.strip(), _type.strip()\n1109         _name = self._escape_args_and_kwargs(_name)\n1110 \n1111         if prefer_type and not _type:\n1112             _type, _name = _name, _type\n1113 \n1114         if self._config.napoleon_preprocess_types:\n1115             _type = _convert_numpy_type_spec(\n1116                 _type,\n1117                 location=self._get_location(),\n1118                 translations=self._config.napoleon_type_aliases or {},\n1119             )\n1120 \n1121         indent = self._get_indent(line) + 1\n1122         _desc = self._dedent(self._consume_indented_block(indent))\n1123         _desc = self.__class__(_desc, self._config).lines()\n1124         return _name, _type, _desc\n1125 \n1126     def _consume_returns_section(self) -> List[Tuple[str, str, List[str]]]:\n1127         return self._consume_fields(prefer_type=True)\n1128 \n1129     def _consume_section_header(self) -> str:\n1130         section = next(self._line_iter)\n1131         if not _directive_regex.match(section):\n1132             # Consume the header underline\n1133             next(self._line_iter)\n1134         return section\n1135 \n1136     def _is_section_break(self) -> bool:\n1137         line1, line2 = self._line_iter.peek(2)\n1138         return (not self._line_iter.has_next() or\n1139                 self._is_section_header() or\n1140                 ['', ''] == [line1, line2] or\n1141                 (self._is_in_section and\n1142                     line1 and\n1143                     not self._is_indented(line1, self._section_indent)))\n1144 \n1145     def _is_section_header(self) -> bool:\n1146         section, underline = self._line_iter.peek(2)\n1147         section = section.lower()\n1148         if section in self._sections and isinstance(underline, str):\n1149             return bool(_numpy_section_regex.match(underline))\n1150         elif self._directive_sections:\n1151             if _directive_regex.match(section):\n1152                 for directive_section in self._directive_sections:\n1153                     if section.startswith(directive_section):\n1154                         return True\n1155         return False\n1156 \n1157     def _parse_see_also_section(self, section: str) -> List[str]:\n1158         lines = self._consume_to_next_section()\n1159         try:\n1160             return self._parse_numpydoc_see_also_section(lines)\n1161         except ValueError:\n1162             return self._format_admonition('seealso', lines)\n1163 \n1164     def _parse_numpydoc_see_also_section(self, content: List[str]) -> List[str]:\n1165         \"\"\"\n1166         Derived from the NumpyDoc implementation of _parse_see_also.\n1167 \n1168         See Also\n1169         --------\n1170         func_name : Descriptive text\n1171             continued text\n1172         another_func_name : Descriptive text\n1173         func_name1, func_name2, :meth:`func_name`, func_name3\n1174 \n1175         \"\"\"\n1176         items = []\n1177 \n1178         def parse_item_name(text: str) -> Tuple[str, str]:\n1179             \"\"\"Match ':role:`name`' or 'name'\"\"\"\n1180             m = self._name_rgx.match(text)\n1181             if m:\n1182                 g = m.groups()\n1183                 if g[1] is None:\n1184                     return g[3], None\n1185                 else:\n1186                     return g[2], g[1]\n1187             raise ValueError(\"%s is not a item name\" % text)\n1188 \n1189         def push_item(name: str, rest: List[str]) -> None:\n1190             if not name:\n1191                 return\n1192             name, role = parse_item_name(name)\n1193             items.append((name, list(rest), role))\n1194             del rest[:]\n1195 \n1196         def translate(func, description, role):\n1197             translations = self._config.napoleon_type_aliases\n1198             if role is not None or not translations:\n1199                 return func, description, role\n1200 \n1201             translated = translations.get(func, func)\n1202             match = self._name_rgx.match(translated)\n1203             if not match:\n1204                 return translated, description, role\n1205 \n1206             groups = match.groupdict()\n1207             role = groups[\"role\"]\n1208             new_func = groups[\"name\"] or groups[\"name2\"]\n1209 \n1210             return new_func, description, role\n1211 \n1212         current_func = None\n1213         rest = []  # type: List[str]\n1214 \n1215         for line in content:\n1216             if not line.strip():\n1217                 continue\n1218 \n1219             m = self._name_rgx.match(line)\n1220             if m and line[m.end():].strip().startswith(':'):\n1221                 push_item(current_func, rest)\n1222                 current_func, line = line[:m.end()], line[m.end():]\n1223                 rest = [line.split(':', 1)[1].strip()]\n1224                 if not rest[0]:\n1225                     rest = []\n1226             elif not line.startswith(' '):\n1227                 push_item(current_func, rest)\n1228                 current_func = None\n1229                 if ',' in line:\n1230                     for func in line.split(','):\n1231                         if func.strip():\n1232                             push_item(func, [])\n1233                 elif line.strip():\n1234                     current_func = line\n1235             elif current_func is not None:\n1236                 rest.append(line.strip())\n1237         push_item(current_func, rest)\n1238 \n1239         if not items:\n1240             return []\n1241 \n1242         # apply type aliases\n1243         items = [\n1244             translate(func, description, role)\n1245             for func, description, role in items\n1246         ]\n1247 \n1248         lines = []  # type: List[str]\n1249         last_had_desc = True\n1250         for name, desc, role in items:\n1251             if role:\n1252                 link = ':%s:`%s`' % (role, name)\n1253             else:\n1254                 link = ':obj:`%s`' % name\n1255             if desc or last_had_desc:\n1256                 lines += ['']\n1257                 lines += [link]\n1258             else:\n1259                 lines[-1] += \", %s\" % link\n1260             if desc:\n1261                 lines += self._indent([' '.join(desc)])\n1262                 last_had_desc = True\n1263             else:\n1264                 last_had_desc = False\n1265         lines += ['']\n1266 \n1267         return self._format_admonition('seealso', lines)\n",
        "intended_behavior": "Modify or enhance the docstring parsing functionality to better integrate type hints from the source code into the attribute documentation generated from Google-style docstrings. This could involve checking for existing type hints and preventing the generation of duplicate attribute entries, one from the docstring and one from the type hint, thereby merging them into a single entry."
    },
    {
        "rel_file_path": "sphinx/ext/autodoc/typehints.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sphinx-doc__sphinx/setup_sphinx-doc__sphinx__3.4/sphinx/ext/autodoc/typehints.py",
        "start": 1,
        "end": 137,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\"\n2     sphinx.ext.autodoc.typehints\n3     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n4 \n5     Generating content for autodoc using typehints\n6 \n7     :copyright: Copyright 2007-2020 by the Sphinx team, see AUTHORS.\n8     :license: BSD, see LICENSE for details.\n9 \"\"\"\n10 \n11 import re\n12 from collections import OrderedDict\n13 from typing import Any, Dict, Iterable, cast\n14 \n15 from docutils import nodes\n16 from docutils.nodes import Element\n17 \n18 from sphinx import addnodes\n19 from sphinx.application import Sphinx\n20 from sphinx.util import inspect, typing\n21 \n22 \n23 def record_typehints(app: Sphinx, objtype: str, name: str, obj: Any,\n24                      options: Dict, args: str, retann: str) -> None:\n25     \"\"\"Record type hints to env object.\"\"\"\n26     try:\n27         if callable(obj):\n28             annotations = app.env.temp_data.setdefault('annotations', {})\n29             annotation = annotations.setdefault(name, OrderedDict())\n30             sig = inspect.signature(obj, type_aliases=app.config.autodoc_type_aliases)\n31             for param in sig.parameters.values():\n32                 if param.annotation is not param.empty:\n33                     annotation[param.name] = typing.stringify(param.annotation)\n34             if sig.return_annotation is not sig.empty:\n35                 annotation['return'] = typing.stringify(sig.return_annotation)\n36     except (TypeError, ValueError):\n37         pass\n38 \n39 \n40 def merge_typehints(app: Sphinx, domain: str, objtype: str, contentnode: Element) -> None:\n41     if domain != 'py':\n42         return\n43     if app.config.autodoc_typehints != 'description':\n44         return\n45     if objtype == 'class' and app.config.autoclass_content not in ('init', 'both'):\n46         return\n47 \n48     try:\n49         signature = cast(addnodes.desc_signature, contentnode.parent[0])\n50         if signature['module']:\n51             fullname = '.'.join([signature['module'], signature['fullname']])\n52         else:\n53             fullname = signature['fullname']\n54     except KeyError:\n55         # signature node does not have valid context info for the target object\n56         return\n57 \n58     annotations = app.env.temp_data.get('annotations', {})\n59     if annotations.get(fullname, {}):\n60         field_lists = [n for n in contentnode if isinstance(n, nodes.field_list)]\n61         if field_lists == []:\n62             field_list = insert_field_list(contentnode)\n63             field_lists.append(field_list)\n64 \n65         for field_list in field_lists:\n66             modify_field_list(field_list, annotations[fullname])\n67 \n68 \n69 def insert_field_list(node: Element) -> nodes.field_list:\n70     field_list = nodes.field_list()\n71     desc = [n for n in node if isinstance(n, addnodes.desc)]\n72     if desc:\n73         # insert just before sub object descriptions (ex. methods, nested classes, etc.)\n74         index = node.index(desc[0])\n75         node.insert(index - 1, [field_list])\n76     else:\n77         node += field_list\n78 \n79     return field_list\n80 \n81 \n82 def modify_field_list(node: nodes.field_list, annotations: Dict[str, str]) -> None:\n83     arguments = {}  # type: Dict[str, Dict[str, bool]]\n84     fields = cast(Iterable[nodes.field], node)\n85     for field in fields:\n86         field_name = field[0].astext()\n87         parts = re.split(' +', field_name)\n88         if parts[0] == 'param':\n89             if len(parts) == 2:\n90                 # :param xxx:\n91                 arg = arguments.setdefault(parts[1], {})\n92                 arg['param'] = True\n93             elif len(parts) > 2:\n94                 # :param xxx yyy:\n95                 name = ' '.join(parts[2:])\n96                 arg = arguments.setdefault(name, {})\n97                 arg['param'] = True\n98                 arg['type'] = True\n99         elif parts[0] == 'type':\n100             name = ' '.join(parts[1:])\n101             arg = arguments.setdefault(name, {})\n102             arg['type'] = True\n103         elif parts[0] == 'rtype':\n104             arguments['return'] = {'type': True}\n105 \n106     for name, annotation in annotations.items():\n107         if name == 'return':\n108             continue\n109 \n110         arg = arguments.get(name, {})\n111         if not arg.get('type'):\n112             field = nodes.field()\n113             field += nodes.field_name('', 'type ' + name)\n114             field += nodes.field_body('', nodes.paragraph('', annotation))\n115             node += field\n116         if not arg.get('param'):\n117             field = nodes.field()\n118             field += nodes.field_name('', 'param ' + name)\n119             field += nodes.field_body('', nodes.paragraph('', ''))\n120             node += field\n121 \n122     if 'return' in annotations and 'return' not in arguments:\n123         field = nodes.field()\n124         field += nodes.field_name('', 'rtype')\n125         field += nodes.field_body('', nodes.paragraph('', annotation))\n126         node += field\n127 \n128 \n129 def setup(app: Sphinx) -> Dict[str, Any]:\n130     app.connect('autodoc-process-signature', record_typehints)\n131     app.connect('object-description-transform', merge_typehints)\n132 \n133     return {\n134         'version': 'builtin',\n135         'parallel_read_safe': True,\n136         'parallel_write_safe': True,\n137     }\n",
        "intended_behavior": "Enhance the handling of type hints for attributes specifically, with logic to intelligently merge type information with attribute descriptions obtained from docstrings. This process should respect user configurations in `conf.py`, possibly adding new options that allow users to specify their preferred handling method (e.g., prefer docstring types, prefer type hints, merge both with docstring taking precedence, etc.)."
    },
    {
        "rel_file_path": "doc/conf.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sphinx-doc__sphinx/setup_sphinx-doc__sphinx__3.4/doc/conf.py",
        "start": 1,
        "end": 162,
        "class_name": null,
        "method_name": null,
        "code": "1 # Sphinx documentation build configuration file\n2 \n3 import re\n4 \n5 import sphinx\n6 \n7 extensions = ['sphinx.ext.autodoc', 'sphinx.ext.doctest', 'sphinx.ext.todo',\n8               'sphinx.ext.autosummary', 'sphinx.ext.extlinks',\n9               'sphinx.ext.intersphinx',\n10               'sphinx.ext.viewcode', 'sphinx.ext.inheritance_diagram']\n11 \n12 master_doc = 'contents'\n13 templates_path = ['_templates']\n14 exclude_patterns = ['_build']\n15 \n16 project = 'Sphinx'\n17 copyright = '2007-2020, Georg Brandl and the Sphinx team'\n18 version = sphinx.__display_version__\n19 release = version\n20 show_authors = True\n21 \n22 html_theme = 'sphinx13'\n23 html_theme_path = ['_themes']\n24 modindex_common_prefix = ['sphinx.']\n25 html_static_path = ['_static']\n26 html_sidebars = {'index': ['indexsidebar.html', 'searchbox.html']}\n27 html_additional_pages = {'index': 'index.html'}\n28 html_use_opensearch = 'https://www.sphinx-doc.org/en/master'\n29 html_baseurl = 'https://www.sphinx-doc.org/en/master/'\n30 html_favicon = '_static/favicon.svg'\n31 \n32 htmlhelp_basename = 'Sphinxdoc'\n33 \n34 epub_theme = 'epub'\n35 epub_basename = 'sphinx'\n36 epub_author = 'Georg Brandl'\n37 epub_publisher = 'http://sphinx-doc.org/'\n38 epub_uid = 'web-site'\n39 epub_scheme = 'url'\n40 epub_identifier = epub_publisher\n41 epub_pre_files = [('index.xhtml', 'Welcome')]\n42 epub_post_files = [('usage/installation.xhtml', 'Installing Sphinx'),\n43                    ('develop.xhtml', 'Sphinx development')]\n44 epub_exclude_files = ['_static/opensearch.xml', '_static/doctools.js',\n45                       '_static/jquery.js', '_static/searchtools.js',\n46                       '_static/underscore.js', '_static/basic.css',\n47                       '_static/language_data.js',\n48                       'search.html', '_static/websupport.js']\n49 epub_fix_images = False\n50 epub_max_image_width = 0\n51 epub_show_urls = 'inline'\n52 epub_use_index = False\n53 epub_guide = (('toc', 'contents.xhtml', 'Table of Contents'),)\n54 epub_description = 'Sphinx documentation generator system manual'\n55 \n56 latex_documents = [('contents', 'sphinx.tex', 'Sphinx Documentation',\n57                     'Georg Brandl', 'manual', 1)]\n58 latex_logo = '_static/sphinx.png'\n59 latex_elements = {\n60     'fontenc': r'\\usepackage[LGR,X2,T1]{fontenc}',\n61     'fontpkg': r'''\n62 \\usepackage[sc]{mathpazo}\n63 \\usepackage[scaled]{helvet}\n64 \\usepackage{courier}\n65 \\substitutefont{LGR}{\\rmdefault}{cmr}\n66 \\substitutefont{LGR}{\\sfdefault}{cmss}\n67 \\substitutefont{LGR}{\\ttdefault}{cmtt}\n68 \\substitutefont{X2}{\\rmdefault}{cmr}\n69 \\substitutefont{X2}{\\sfdefault}{cmss}\n70 \\substitutefont{X2}{\\ttdefault}{cmtt}\n71 ''',\n72     'passoptionstopackages': '\\\\PassOptionsToPackage{svgnames}{xcolor}',\n73     'preamble': '\\\\DeclareUnicodeCharacter{229E}{\\\\ensuremath{\\\\boxplus}}',\n74     'fvset': '\\\\fvset{fontsize=auto}',\n75     # fix missing index entry due to RTD doing only once pdflatex after makeindex\n76     'printindex': r'''\n77 \\IfFileExists{\\jobname.ind}\n78              {\\footnotesize\\raggedright\\printindex}\n79              {\\begin{sphinxtheindex}\\end{sphinxtheindex}}\n80 ''',\n81 }\n82 latex_show_urls = 'footnote'\n83 latex_use_xindy = True\n84 \n85 autodoc_member_order = 'groupwise'\n86 todo_include_todos = True\n87 extlinks = {'duref': ('http://docutils.sourceforge.net/docs/ref/rst/'\n88                       'restructuredtext.html#%s', ''),\n89             'durole': ('http://docutils.sourceforge.net/docs/ref/rst/'\n90                        'roles.html#%s', ''),\n91             'dudir': ('http://docutils.sourceforge.net/docs/ref/rst/'\n92                       'directives.html#%s', '')}\n93 \n94 man_pages = [\n95     ('contents', 'sphinx-all', 'Sphinx documentation generator system manual',\n96      'Georg Brandl', 1),\n97     ('man/sphinx-build', 'sphinx-build', 'Sphinx documentation generator tool',\n98      '', 1),\n99     ('man/sphinx-quickstart', 'sphinx-quickstart', 'Sphinx documentation '\n100      'template generator', '', 1),\n101     ('man/sphinx-apidoc', 'sphinx-apidoc', 'Sphinx API doc generator tool',\n102      '', 1),\n103     ('man/sphinx-autogen', 'sphinx-autogen', 'Generate autodoc stub pages',\n104      '', 1),\n105 ]\n106 \n107 texinfo_documents = [\n108     ('contents', 'sphinx', 'Sphinx Documentation', 'Georg Brandl',\n109      'Sphinx', 'The Sphinx documentation builder.', 'Documentation tools',\n110      1),\n111 ]\n112 \n113 intersphinx_mapping = {'python': ('https://docs.python.org/3/', None)}\n114 \n115 # Sphinx document translation with sphinx gettext feature uses these settings:\n116 locale_dirs = ['locale/']\n117 gettext_compact = False\n118 \n119 \n120 # -- Extension interface -------------------------------------------------------\n121 \n122 from sphinx import addnodes  # noqa\n123 \n124 event_sig_re = re.compile(r'([a-zA-Z-]+)\\s*\\((.*)\\)')\n125 \n126 \n127 def parse_event(env, sig, signode):\n128     m = event_sig_re.match(sig)\n129     if not m:\n130         signode += addnodes.desc_name(sig, sig)\n131         return sig\n132     name, args = m.groups()\n133     signode += addnodes.desc_name(name, name)\n134     plist = addnodes.desc_parameterlist()\n135     for arg in args.split(','):\n136         arg = arg.strip()\n137         plist += addnodes.desc_parameter(arg, arg)\n138     signode += plist\n139     return name\n140 \n141 \n142 def setup(app):\n143     from sphinx.ext.autodoc import cut_lines\n144     from sphinx.util.docfields import GroupedField\n145     app.connect('autodoc-process-docstring', cut_lines(4, what=['module']))\n146     app.add_object_type('confval', 'confval',\n147                         objname='configuration value',\n148                         indextemplate='pair: %s; configuration value')\n149     app.add_object_type('setuptools-confval', 'setuptools-confval',\n150                         objname='setuptools configuration value',\n151                         indextemplate='pair: %s; setuptools configuration value')\n152     fdesc = GroupedField('parameter', label='Parameters',\n153                          names=['param'], can_collapse=True)\n154     app.add_object_type('event', 'event', 'pair: %s; event', parse_event,\n155                         doc_field_types=[fdesc])\n156 \n157     # workaround for RTD\n158     from sphinx.util import logging\n159     logger = logging.getLogger(__name__)\n160     app.info = lambda *args, **kwargs: logger.info(*args, **kwargs)\n161     app.warn = lambda *args, **kwargs: logger.warning(*args, **kwargs)\n162     app.debug = lambda *args, **kwargs: logger.debug(*args, **kwargs)\n",
        "intended_behavior": "Introduce new configuration options that provide users with explicit control over how attribute documentation is generated in the presence of both docstrings and type hints. This can include settings to avoid duplication and control the merging behavior."
    }
]