2025-10-18 12:26:35.477 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-18 12:26:40.199 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=188, output_tokens=12, cost=0.002240
2025-10-18 12:26:40.206 | INFO     | Test agent decides that the issue statement does not contain reproduction steps; skipping reproducer tracing
2025-10-18 12:26:40.210 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 12:26:44.135 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=497, output_tokens=145, cost=0.009320
2025-10-18 12:26:44.139 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 12:26:49.165 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=499, output_tokens=53, cost=0.006580
2025-10-18 12:26:49.167 | DEBUG    | Extracted a valid json.
2025-10-18 12:26:49.167 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_class(\"MemcachedCache\")",
        "search_method_in_class(\"__init__\", \"MemcachedCache\")",
        "search_code(\"MemcachedCache\")"
    ],
    "bug_locations": []
}
2025-10-18 12:26:49.227 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-18 12:26:49.228 | DEBUG    | <Agent search> Analyzing search results.
2025-10-18 12:27:02.041 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1090, output_tokens=527, cost=0.026710
2025-10-18 12:27:02.052 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 12:27:11.720 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1833, output_tokens=385, cost=0.029880
2025-10-18 12:27:11.729 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 12:27:16.998 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=739, output_tokens=158, cost=0.012130
2025-10-18 12:27:16.999 | DEBUG    | Extracted a valid json.
2025-10-18 12:27:17.005 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "django/core/cache/backends/memcached.py",
            "class": "MemcachedCache",
            "method": "__init__",
            "intended_behavior": "The `__init__` method should include a deprecation warning for the `MemcachedCache` class, advising users to switch to `pymemcache`."
        },
        {
            "file": "django/core/cache/backends/memcached.py",
            "class": "",
            "method": "",
            "intended_behavior": "Update documentation and comments related to `MemcachedCache` to reflect its deprecation and guide users towards migrating to `pymemcache`."
        }
    ]
}
2025-10-18 12:27:17.009 | DEBUG    | Found override of __init__ in BaseMemcachedCache
2025-10-18 12:27:17.010 | ERROR    | SearchBackend.search_method_in_class() missing 1 required positional argument: 'class_name'
Traceback (most recent call last):

  File "/home/kimnal0/auto-code-rover/app/main.py", line 656, in <module>
    main()
    └ <function main at 0x761e6b526c00>

  File "/home/kimnal0/auto-code-rover/app/main.py", line 120, in main
    run_task_groups(groups, num_processes, organize_output=True)
    │               │       └ 1
    │               └ {'setup_astropy__astropy__4.3': [<app.raw_tasks.RawSweTask object at 0x761d78dc37d0>, <app.raw_tasks.RawSweTask object at 0x7...
    └ <function run_task_groups at 0x761d7b11a3e0>

  File "/home/kimnal0/auto-code-rover/app/main.py", line 396, in run_task_groups
    run_tasks_serial(all_tasks)
    │                └ [<app.raw_tasks.RawSweTask object at 0x761d78dc37d0>, <app.raw_tasks.RawSweTask object at 0x761d78dc3800>, <app.raw_tasks.Raw...
    └ <function run_tasks_serial at 0x761d7b11a480>

  File "/home/kimnal0/auto-code-rover/app/main.py", line 414, in run_tasks_serial
    run_task_in_subprocess(task)
    │                      └ <app.raw_tasks.RawSweTask object at 0x761d78d39eb0>
    └ <function run_task_in_subprocess at 0x761d7b11a660>

  File "/home/kimnal0/auto-code-rover/app/main.py", line 462, in run_task_in_subprocess
    executor.submit(run_raw_task, task)
    │        │      │             └ <app.raw_tasks.RawSweTask object at 0x761d78d39eb0>
    │        │      └ <function run_raw_task at 0x761d7b11a700>
    │        └ <function ProcessPoolExecutor.submit at 0x761e6ae72020>
    └ <concurrent.futures.process.ProcessPoolExecutor object at 0x761d7b1d56d0>

  File "/home/kimnal0/miniconda3/envs/auto-code-rover/lib/python3.12/concurrent/futures/process.py", line 831, in submit
    self._start_executor_manager_thread()
    │    └ <function ProcessPoolExecutor._start_executor_manager_thread at 0x761e6ae71da0>
    └ <concurrent.futures.process.ProcessPoolExecutor object at 0x761d7b1d56d0>
  File "/home/kimnal0/miniconda3/envs/auto-code-rover/lib/python3.12/concurrent/futures/process.py", line 770, in _start_executor_manager_thread
    self._launch_processes()
    │    └ <function ProcessPoolExecutor._launch_processes at 0x761e6ae71ee0>
    └ <concurrent.futures.process.ProcessPoolExecutor object at 0x761d7b1d56d0>
  File "/home/kimnal0/miniconda3/envs/auto-code-rover/lib/python3.12/concurrent/futures/process.py", line 797, in _launch_processes
    self._spawn_process()
    │    └ <function ProcessPoolExecutor._spawn_process at 0x761e6ae71f80>
    └ <concurrent.futures.process.ProcessPoolExecutor object at 0x761d7b1d56d0>
  File "/home/kimnal0/miniconda3/envs/auto-code-rover/lib/python3.12/concurrent/futures/process.py", line 807, in _spawn_process
    p.start()
    │ └ <function BaseProcess.start at 0x761e6b02cea0>
    └ <ForkProcess name='ForkProcess-141' parent=497161 started>
  File "/home/kimnal0/miniconda3/envs/auto-code-rover/lib/python3.12/multiprocessing/process.py", line 121, in start
    self._popen = self._Popen(self)
    │    │        │    │      └ <ForkProcess name='ForkProcess-141' parent=497161 started>
    │    │        │    └ <staticmethod(<function ForkProcess._Popen at 0x761e6b09e0c0>)>
    │    │        └ <ForkProcess name='ForkProcess-141' parent=497161 started>
    │    └ None
    └ <ForkProcess name='ForkProcess-141' parent=497161 started>
  File "/home/kimnal0/miniconda3/envs/auto-code-rover/lib/python3.12/multiprocessing/context.py", line 282, in _Popen
    return Popen(process_obj)
           │     └ <ForkProcess name='ForkProcess-141' parent=497161 started>
           └ <class 'multiprocessing.popen_fork.Popen'>
  File "/home/kimnal0/miniconda3/envs/auto-code-rover/lib/python3.12/multiprocessing/popen_fork.py", line 19, in __init__
    self._launch(process_obj)
    │    │       └ <ForkProcess name='ForkProcess-141' parent=497161 started>
    │    └ <function Popen._launch at 0x761d7911b7e0>
    └ <multiprocessing.popen_fork.Popen object at 0x761d7a57e0c0>
  File "/home/kimnal0/miniconda3/envs/auto-code-rover/lib/python3.12/multiprocessing/popen_fork.py", line 71, in _launch
    code = process_obj._bootstrap(parent_sentinel=child_r)
           │           │                          └ 13
           │           └ <function BaseProcess._bootstrap at 0x761e6b02d8a0>
           └ <ForkProcess name='ForkProcess-141' parent=497161 started>
  File "/home/kimnal0/miniconda3/envs/auto-code-rover/lib/python3.12/multiprocessing/process.py", line 314, in _bootstrap
    self.run()
    │    └ <function BaseProcess.run at 0x761e6b02ce00>
    └ <ForkProcess name='ForkProcess-141' parent=497161 started>
  File "/home/kimnal0/miniconda3/envs/auto-code-rover/lib/python3.12/multiprocessing/process.py", line 108, in run
    self._target(*self._args, **self._kwargs)
    │    │        │    │        │    └ {}
    │    │        │    │        └ <ForkProcess name='ForkProcess-141' parent=497161 started>
    │    │        │    └ (<concurrent.futures.process._SafeQueue object at 0x761d795c47d0>, <multiprocessing.queues.SimpleQueue object at 0x761d795c4c...
    │    │        └ <ForkProcess name='ForkProcess-141' parent=497161 started>
    │    └ <function _process_worker at 0x761e6ae711c0>
    └ <ForkProcess name='ForkProcess-141' parent=497161 started>
  File "/home/kimnal0/miniconda3/envs/auto-code-rover/lib/python3.12/concurrent/futures/process.py", line 263, in _process_worker
    r = call_item.fn(*call_item.args, **call_item.kwargs)
        │         │   │         │       │         └ {}
        │         │   │         │       └ <concurrent.futures.process._CallItem object at 0x761d7b4c74d0>
        │         │   │         └ (<app.raw_tasks.RawSweTask object at 0x761d7b4c71d0>,)
        │         │   └ <concurrent.futures.process._CallItem object at 0x761d7b4c74d0>
        │         └ <function run_raw_task at 0x761d7b11a700>
        └ <concurrent.futures.process._CallItem object at 0x761d7b4c74d0>

  File "/home/kimnal0/auto-code-rover/app/main.py", line 494, in run_raw_task
    run_ok = do_inference(task.to_task(), task_output_dir)
             │            │    │          └ '/home/kimnal0/auto-code-rover/only_fl_output5/django__django-13744_2025-10-18_12-26-35'
             │            │    └ <function RawSweTask.to_task at 0x761d7b1196c0>
             │            └ <app.raw_tasks.RawSweTask object at 0x761d7b4c71d0>
             └ <function do_inference at 0x761d7b11a8e0>

  File "/home/kimnal0/auto-code-rover/app/main.py", line 590, in do_inference
    run_ok = inference.run_one_task(
             │         └ <function run_one_task at 0x761d7b228400>
             └ <module 'app.inference' from '/home/kimnal0/auto-code-rover/app/inference.py'>

  File "/home/kimnal0/auto-code-rover/app/inference.py", line 128, in run_one_task
    if _run_one_task(str(out_dir), api_manager, task.get_issue_statement()):
       │                 │         │            │    └ <function SweTask.get_issue_statement at 0x761d7b9b84a0>
       │                 │         │            └ SweTask(task_id='django__django-13744', problem_statement="Deprecate MemcachedCache.\nDescription\n\t\npython-memcached is no...
       │                 │         └ <app.manage.ProjectApiManager object at 0x761d7b21d610>
       │                 └ Path('/home/kimnal0/auto-code-rover/only_fl_output5/django__django-13744_2025-10-18_12-26-35/output_0')
       └ <function _run_one_task at 0x761d7b2298a0>

  File "/home/kimnal0/auto-code-rover/app/inference.py", line 303, in _run_one_task
    bug_locs, search_msg_thread = api_manager.search_manager.search_iterative(
                                  │           │              └ <function SearchManager.search_iterative at 0x761d7b431bc0>
                                  │           └ <app.search.search_manage.SearchManager object at 0x761d795c7ec0>
                                  └ <app.manage.ProjectApiManager object at 0x761d7b21d610>

  File "/home/kimnal0/auto-code-rover/app/search/search_manage.py", line 125, in search_iterative
    new_bug_locations.extend(self.backend.get_bug_loc_snippets_new(loc))
    │                 │      │    │       │                        └ {'file': 'django/core/cache/backends/memcached.py', 'class': 'MemcachedCache', 'method': '__init__', 'intended_behavior': 'Th...
    │                 │      │    │       └ <function SearchBackend.get_bug_loc_snippets_new at 0x761d7b4318a0>
    │                 │      │    └ <app.search.search_backend.SearchBackend object at 0x761d7b6a3170>
    │                 │      └ <app.search.search_manage.SearchManager object at 0x761d795c7ec0>
    │                 └ <method 'extend' of 'list' objects>
    └ []

  File "/home/kimnal0/auto-code-rover/app/search/search_backend.py", line 825, in get_bug_loc_snippets_new
    self._get_inherited_methods(res.class_name, res.func_name)
    │    │                      │   │           │   └ '__init__'
    │    │                      │   │           └ SearchResult(file_path='/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.2/django/core/...
    │    │                      │   └ 'MemcachedCache'
    │    │                      └ SearchResult(file_path='/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.2/django/core/...
    │    └ <function SearchBackend._get_inherited_methods at 0x761d7b431800>
    └ <app.search.search_backend.SearchBackend object at 0x761d7b6a3170>

  File "/home/kimnal0/auto-code-rover/app/search/search_backend.py", line 748, in _get_inherited_methods
    output, search_res, call_ok = self.search_method_in_class(super_call)
                                  │    │                      └ {'class_name': 'BaseMemcachedCache', 'method_name': '__init__'}
                                  │    └ <function SearchBackend.search_method_in_class at 0x761d7b430f40>
                                  └ <app.search.search_backend.SearchBackend object at 0x761d7b6a3170>

> File "/home/kimnal0/auto-code-rover/app/utils.py", line 343, in wrapper
    return func(*args, **kwargs)
           │     │       └ {}
           │     └ (<app.search.search_backend.SearchBackend object at 0x761d7b6a3170>, {'class_name': 'BaseMemcachedCache', 'method_name': '__i...
           └ <function SearchBackend.search_method_in_class at 0x761d7b430ea0>

TypeError: SearchBackend.search_method_in_class() missing 1 required positional argument: 'class_name'
2025-10-18 12:27:17.017 | DEBUG    | Bug location extracted successfully: [<file>django/core/cache/backends/memcached.py</file>
<class>MemcachedCache</class>
<method>__init__</method>
<code>
166     def __init__(self, server, params):
167         # python-memcached ≥ 1.45 returns None for a nonexistent key in
168         # incr/decr(), python-memcached < 1.45 raises ValueError.
169         import memcache
170         super().__init__(server, params, library=memcache, value_not_found_exception=ValueError)
171         self._options = {'pickleProtocol': pickle.HIGHEST_PROTOCOL, **self._options}

</code><intended_behavior>The `__init__` method should include a deprecation warning for the `MemcachedCache` class, advising users to switch to `pymemcache`.</intended_behavior>, <file>django/core/cache/backends/memcached.py</file>
<class>MemcachedCache</class>
<method>None</method>
<code>
164 class MemcachedCache(BaseMemcachedCache):
165     "An implementation of a cache binding using python-memcached"
166     def __init__(self, server, params):
167         # python-memcached ≥ 1.45 returns None for a nonexistent key in
168         # incr/decr(), python-memcached < 1.45 raises ValueError.
169         import memcache
170         super().__init__(server, params, library=memcache, value_not_found_exception=ValueError)
171         self._options = {'pickleProtocol': pickle.HIGHEST_PROTOCOL, **self._options}
172 
173     def get(self, key, default=None, version=None):
174         key = self.make_key(key, version=version)
175         self.validate_key(key)
176         val = self._cache.get(key)
177         # python-memcached doesn't support default values in get().
178         # https://github.com/linsomniac/python-memcached/issues/159
179         # Remove this method if that issue is fixed.
180         if val is None:
181             return default
182         return val
183 
184     def delete(self, key, version=None):
185         # python-memcached's delete() returns True when key doesn't exist.
186         # https://github.com/linsomniac/python-memcached/issues/170
187         # Call _deletetouch() without the NOT_FOUND in expected results.
188         key = self.make_key(key, version=version)
189         self.validate_key(key)
190         return bool(self._cache._deletetouch([b'DELETED'], 'delete', key))

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>, <file>django/core/cache/backends/memcached.py</file>
<class>None</class>
<method>None</method>
<code>
1 "Memcached cache backend"
2 
3 import pickle
4 import re
5 import time
6 
7 from django.core.cache.backends.base import (
8     DEFAULT_TIMEOUT, BaseCache, InvalidCacheKey, memcache_key_warnings,
9 )
10 from django.utils.functional import cached_property
11 
12 
13 class BaseMemcachedCache(BaseCache):
14     def __init__(self, server, params, library, value_not_found_exception):
15         super().__init__(params)
16         if isinstance(server, str):
17             self._servers = re.split('[;,]', server)
18         else:
19             self._servers = server
20 
21         # Exception type raised by the underlying client library for a
22         # nonexistent key.
23         self.LibraryValueNotFoundException = value_not_found_exception
24 
25         self._lib = library
26         self._class = library.Client
27         self._options = params.get('OPTIONS') or {}
28 
29     @property
30     def client_servers(self):
31         return self._servers
32 
33     @cached_property
34     def _cache(self):
35         """
36         Implement transparent thread-safe access to a memcached client.
37         """
38         return self._class(self.client_servers, **self._options)
39 
40     def get_backend_timeout(self, timeout=DEFAULT_TIMEOUT):
41         """
42         Memcached deals with long (> 30 days) timeouts in a special
43         way. Call this function to obtain a safe value for your timeout.
44         """
45         if timeout == DEFAULT_TIMEOUT:
46             timeout = self.default_timeout
47 
48         if timeout is None:
49             # Using 0 in memcache sets a non-expiring timeout.
50             return 0
51         elif int(timeout) == 0:
52             # Other cache backends treat 0 as set-and-expire. To achieve this
53             # in memcache backends, a negative timeout must be passed.
54             timeout = -1
55 
56         if timeout > 2592000:  # 60*60*24*30, 30 days
57             # See https://github.com/memcached/memcached/wiki/Programming#expiration
58             # "Expiration times can be set from 0, meaning "never expire", to
59             # 30 days. Any time higher than 30 days is interpreted as a Unix
60             # timestamp date. If you want to expire an object on January 1st of
61             # next year, this is how you do that."
62             #
63             # This means that we have to switch to absolute timestamps.
64             timeout += int(time.time())
65         return int(timeout)
66 
67     def add(self, key, value, timeout=DEFAULT_TIMEOUT, version=None):
68         key = self.make_key(key, version=version)
69         self.validate_key(key)
70         return self._cache.add(key, value, self.get_backend_timeout(timeout))
71 
72     def get(self, key, default=None, version=None):
73         key = self.make_key(key, version=version)
74         self.validate_key(key)
75         return self._cache.get(key, default)
76 
77     def set(self, key, value, timeout=DEFAULT_TIMEOUT, version=None):
78         key = self.make_key(key, version=version)
79         self.validate_key(key)
80         if not self._cache.set(key, value, self.get_backend_timeout(timeout)):
81             # make sure the key doesn't keep its old value in case of failure to set (memcached's 1MB limit)
82             self._cache.delete(key)
83 
84     def touch(self, key, timeout=DEFAULT_TIMEOUT, version=None):
85         key = self.make_key(key, version=version)
86         self.validate_key(key)
87         return bool(self._cache.touch(key, self.get_backend_timeout(timeout)))
88 
89     def delete(self, key, version=None):
90         key = self.make_key(key, version=version)
91         self.validate_key(key)
92         return bool(self._cache.delete(key))
93 
94     def get_many(self, keys, version=None):
95         key_map = {self.make_key(key, version=version): key for key in keys}
96         for key in key_map:
97             self.validate_key(key)
98         ret = self._cache.get_multi(key_map.keys())
99         return {key_map[k]: v for k, v in ret.items()}
100 
101     def close(self, **kwargs):
102         # Many clients don't clean up connections properly.
103         self._cache.disconnect_all()
104 
105     def incr(self, key, delta=1, version=None):
106         key = self.make_key(key, version=version)
107         self.validate_key(key)
108         # memcached doesn't support a negative delta
109         if delta < 0:
110             return self._cache.decr(key, -delta)
111         try:
112             val = self._cache.incr(key, delta)
113 
114         # Normalize an exception raised by the underlying client library to
115         # ValueError in the event of a nonexistent key when calling incr().
116         except self.LibraryValueNotFoundException:
117             val = None
118         if val is None:
119             raise ValueError("Key '%s' not found" % key)
120         return val
121 
122     def decr(self, key, delta=1, version=None):
123         key = self.make_key(key, version=version)
124         self.validate_key(key)
125         # memcached doesn't support a negative delta
126         if delta < 0:
127             return self._cache.incr(key, -delta)
128         try:
129             val = self._cache.decr(key, delta)
130 
131         # Normalize an exception raised by the underlying client library to
132         # ValueError in the event of a nonexistent key when calling decr().
133         except self.LibraryValueNotFoundException:
134             val = None
135         if val is None:
136             raise ValueError("Key '%s' not found" % key)
137         return val
138 
139     def set_many(self, data, timeout=DEFAULT_TIMEOUT, version=None):
140         safe_data = {}
141         original_keys = {}
142         for key, value in data.items():
143             safe_key = self.make_key(key, version=version)
144             self.validate_key(safe_key)
145             safe_data[safe_key] = value
146             original_keys[safe_key] = key
147         failed_keys = self._cache.set_multi(safe_data, self.get_backend_timeout(timeout))
148         return [original_keys[k] for k in failed_keys]
149 
150     def delete_many(self, keys, version=None):
151         keys = [self.make_key(key, version=version) for key in keys]
152         for key in keys:
153             self.validate_key(key)
154         self._cache.delete_multi(keys)
155 
156     def clear(self):
157         self._cache.flush_all()
158 
159     def validate_key(self, key):
160         for warning in memcache_key_warnings(key):
161             raise InvalidCacheKey(warning)
162 
163 
164 class MemcachedCache(BaseMemcachedCache):
165     "An implementation of a cache binding using python-memcached"
166     def __init__(self, server, params):
167         # python-memcached ≥ 1.45 returns None for a nonexistent key in
168         # incr/decr(), python-memcached < 1.45 raises ValueError.
169         import memcache
170         super().__init__(server, params, library=memcache, value_not_found_exception=ValueError)
171         self._options = {'pickleProtocol': pickle.HIGHEST_PROTOCOL, **self._options}
172 
173     def get(self, key, default=None, version=None):
174         key = self.make_key(key, version=version)
175         self.validate_key(key)
176         val = self._cache.get(key)
177         # python-memcached doesn't support default values in get().
178         # https://github.com/linsomniac/python-memcached/issues/159
179         # Remove this method if that issue is fixed.
180         if val is None:
181             return default
182         return val
183 
184     def delete(self, key, version=None):
185         # python-memcached's delete() returns True when key doesn't exist.
186         # https://github.com/linsomniac/python-memcached/issues/170
187         # Call _deletetouch() without the NOT_FOUND in expected results.
188         key = self.make_key(key, version=version)
189         self.validate_key(key)
190         return bool(self._cache._deletetouch([b'DELETED'], 'delete', key))
191 
192 
193 class PyLibMCCache(BaseMemcachedCache):
194     "An implementation of a cache binding using pylibmc"
195     def __init__(self, server, params):
196         import pylibmc
197         super().__init__(server, params, library=pylibmc, value_not_found_exception=pylibmc.NotFound)
198 
199     @property
200     def client_servers(self):
201         output = []
202         for server in self._servers:
203             output.append(server[5:] if server.startswith('unix:') else server)
204         return output
205 
206     def touch(self, key, timeout=DEFAULT_TIMEOUT, version=None):
207         key = self.make_key(key, version=version)
208         self.validate_key(key)
209         if timeout == 0:
210             return self._cache.delete(key)
211         return self._cache.touch(key, self.get_backend_timeout(timeout))
212 
213     def close(self, **kwargs):
214         # libmemcached manages its own connections. Don't call disconnect_all()
215         # as it resets the failover state and creates unnecessary reconnects.
216         pass
217 
218 
219 class PyMemcacheCache(BaseMemcachedCache):
220     """An implementation of a cache binding using pymemcache."""
221     def __init__(self, server, params):
222         import pymemcache.serde
223         super().__init__(server, params, library=pymemcache, value_not_found_exception=KeyError)
224         self._class = self._lib.HashClient
225         self._options = {
226             'allow_unicode_keys': True,
227             'default_noreply': False,
228             'serde': pymemcache.serde.pickle_serde,
229             **self._options,
230         }

</code><intended_behavior>Update documentation and comments related to `MemcachedCache` to reflect its deprecation and guide users towards migrating to `pymemcache`.</intended_behavior>]
2025-10-18 12:27:17.017 | INFO     | Search completed. Bug locations: [<file>django/core/cache/backends/memcached.py</file>
<class>MemcachedCache</class>
<method>__init__</method>
<code>
166     def __init__(self, server, params):
167         # python-memcached ≥ 1.45 returns None for a nonexistent key in
168         # incr/decr(), python-memcached < 1.45 raises ValueError.
169         import memcache
170         super().__init__(server, params, library=memcache, value_not_found_exception=ValueError)
171         self._options = {'pickleProtocol': pickle.HIGHEST_PROTOCOL, **self._options}

</code><intended_behavior>The `__init__` method should include a deprecation warning for the `MemcachedCache` class, advising users to switch to `pymemcache`.</intended_behavior>, <file>django/core/cache/backends/memcached.py</file>
<class>MemcachedCache</class>
<method>None</method>
<code>
164 class MemcachedCache(BaseMemcachedCache):
165     "An implementation of a cache binding using python-memcached"
166     def __init__(self, server, params):
167         # python-memcached ≥ 1.45 returns None for a nonexistent key in
168         # incr/decr(), python-memcached < 1.45 raises ValueError.
169         import memcache
170         super().__init__(server, params, library=memcache, value_not_found_exception=ValueError)
171         self._options = {'pickleProtocol': pickle.HIGHEST_PROTOCOL, **self._options}
172 
173     def get(self, key, default=None, version=None):
174         key = self.make_key(key, version=version)
175         self.validate_key(key)
176         val = self._cache.get(key)
177         # python-memcached doesn't support default values in get().
178         # https://github.com/linsomniac/python-memcached/issues/159
179         # Remove this method if that issue is fixed.
180         if val is None:
181             return default
182         return val
183 
184     def delete(self, key, version=None):
185         # python-memcached's delete() returns True when key doesn't exist.
186         # https://github.com/linsomniac/python-memcached/issues/170
187         # Call _deletetouch() without the NOT_FOUND in expected results.
188         key = self.make_key(key, version=version)
189         self.validate_key(key)
190         return bool(self._cache._deletetouch([b'DELETED'], 'delete', key))

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>, <file>django/core/cache/backends/memcached.py</file>
<class>None</class>
<method>None</method>
<code>
1 "Memcached cache backend"
2 
3 import pickle
4 import re
5 import time
6 
7 from django.core.cache.backends.base import (
8     DEFAULT_TIMEOUT, BaseCache, InvalidCacheKey, memcache_key_warnings,
9 )
10 from django.utils.functional import cached_property
11 
12 
13 class BaseMemcachedCache(BaseCache):
14     def __init__(self, server, params, library, value_not_found_exception):
15         super().__init__(params)
16         if isinstance(server, str):
17             self._servers = re.split('[;,]', server)
18         else:
19             self._servers = server
20 
21         # Exception type raised by the underlying client library for a
22         # nonexistent key.
23         self.LibraryValueNotFoundException = value_not_found_exception
24 
25         self._lib = library
26         self._class = library.Client
27         self._options = params.get('OPTIONS') or {}
28 
29     @property
30     def client_servers(self):
31         return self._servers
32 
33     @cached_property
34     def _cache(self):
35         """
36         Implement transparent thread-safe access to a memcached client.
37         """
38         return self._class(self.client_servers, **self._options)
39 
40     def get_backend_timeout(self, timeout=DEFAULT_TIMEOUT):
41         """
42         Memcached deals with long (> 30 days) timeouts in a special
43         way. Call this function to obtain a safe value for your timeout.
44         """
45         if timeout == DEFAULT_TIMEOUT:
46             timeout = self.default_timeout
47 
48         if timeout is None:
49             # Using 0 in memcache sets a non-expiring timeout.
50             return 0
51         elif int(timeout) == 0:
52             # Other cache backends treat 0 as set-and-expire. To achieve this
53             # in memcache backends, a negative timeout must be passed.
54             timeout = -1
55 
56         if timeout > 2592000:  # 60*60*24*30, 30 days
57             # See https://github.com/memcached/memcached/wiki/Programming#expiration
58             # "Expiration times can be set from 0, meaning "never expire", to
59             # 30 days. Any time higher than 30 days is interpreted as a Unix
60             # timestamp date. If you want to expire an object on January 1st of
61             # next year, this is how you do that."
62             #
63             # This means that we have to switch to absolute timestamps.
64             timeout += int(time.time())
65         return int(timeout)
66 
67     def add(self, key, value, timeout=DEFAULT_TIMEOUT, version=None):
68         key = self.make_key(key, version=version)
69         self.validate_key(key)
70         return self._cache.add(key, value, self.get_backend_timeout(timeout))
71 
72     def get(self, key, default=None, version=None):
73         key = self.make_key(key, version=version)
74         self.validate_key(key)
75         return self._cache.get(key, default)
76 
77     def set(self, key, value, timeout=DEFAULT_TIMEOUT, version=None):
78         key = self.make_key(key, version=version)
79         self.validate_key(key)
80         if not self._cache.set(key, value, self.get_backend_timeout(timeout)):
81             # make sure the key doesn't keep its old value in case of failure to set (memcached's 1MB limit)
82             self._cache.delete(key)
83 
84     def touch(self, key, timeout=DEFAULT_TIMEOUT, version=None):
85         key = self.make_key(key, version=version)
86         self.validate_key(key)
87         return bool(self._cache.touch(key, self.get_backend_timeout(timeout)))
88 
89     def delete(self, key, version=None):
90         key = self.make_key(key, version=version)
91         self.validate_key(key)
92         return bool(self._cache.delete(key))
93 
94     def get_many(self, keys, version=None):
95         key_map = {self.make_key(key, version=version): key for key in keys}
96         for key in key_map:
97             self.validate_key(key)
98         ret = self._cache.get_multi(key_map.keys())
99         return {key_map[k]: v for k, v in ret.items()}
100 
101     def close(self, **kwargs):
102         # Many clients don't clean up connections properly.
103         self._cache.disconnect_all()
104 
105     def incr(self, key, delta=1, version=None):
106         key = self.make_key(key, version=version)
107         self.validate_key(key)
108         # memcached doesn't support a negative delta
109         if delta < 0:
110             return self._cache.decr(key, -delta)
111         try:
112             val = self._cache.incr(key, delta)
113 
114         # Normalize an exception raised by the underlying client library to
115         # ValueError in the event of a nonexistent key when calling incr().
116         except self.LibraryValueNotFoundException:
117             val = None
118         if val is None:
119             raise ValueError("Key '%s' not found" % key)
120         return val
121 
122     def decr(self, key, delta=1, version=None):
123         key = self.make_key(key, version=version)
124         self.validate_key(key)
125         # memcached doesn't support a negative delta
126         if delta < 0:
127             return self._cache.incr(key, -delta)
128         try:
129             val = self._cache.decr(key, delta)
130 
131         # Normalize an exception raised by the underlying client library to
132         # ValueError in the event of a nonexistent key when calling decr().
133         except self.LibraryValueNotFoundException:
134             val = None
135         if val is None:
136             raise ValueError("Key '%s' not found" % key)
137         return val
138 
139     def set_many(self, data, timeout=DEFAULT_TIMEOUT, version=None):
140         safe_data = {}
141         original_keys = {}
142         for key, value in data.items():
143             safe_key = self.make_key(key, version=version)
144             self.validate_key(safe_key)
145             safe_data[safe_key] = value
146             original_keys[safe_key] = key
147         failed_keys = self._cache.set_multi(safe_data, self.get_backend_timeout(timeout))
148         return [original_keys[k] for k in failed_keys]
149 
150     def delete_many(self, keys, version=None):
151         keys = [self.make_key(key, version=version) for key in keys]
152         for key in keys:
153             self.validate_key(key)
154         self._cache.delete_multi(keys)
155 
156     def clear(self):
157         self._cache.flush_all()
158 
159     def validate_key(self, key):
160         for warning in memcache_key_warnings(key):
161             raise InvalidCacheKey(warning)
162 
163 
164 class MemcachedCache(BaseMemcachedCache):
165     "An implementation of a cache binding using python-memcached"
166     def __init__(self, server, params):
167         # python-memcached ≥ 1.45 returns None for a nonexistent key in
168         # incr/decr(), python-memcached < 1.45 raises ValueError.
169         import memcache
170         super().__init__(server, params, library=memcache, value_not_found_exception=ValueError)
171         self._options = {'pickleProtocol': pickle.HIGHEST_PROTOCOL, **self._options}
172 
173     def get(self, key, default=None, version=None):
174         key = self.make_key(key, version=version)
175         self.validate_key(key)
176         val = self._cache.get(key)
177         # python-memcached doesn't support default values in get().
178         # https://github.com/linsomniac/python-memcached/issues/159
179         # Remove this method if that issue is fixed.
180         if val is None:
181             return default
182         return val
183 
184     def delete(self, key, version=None):
185         # python-memcached's delete() returns True when key doesn't exist.
186         # https://github.com/linsomniac/python-memcached/issues/170
187         # Call _deletetouch() without the NOT_FOUND in expected results.
188         key = self.make_key(key, version=version)
189         self.validate_key(key)
190         return bool(self._cache._deletetouch([b'DELETED'], 'delete', key))
191 
192 
193 class PyLibMCCache(BaseMemcachedCache):
194     "An implementation of a cache binding using pylibmc"
195     def __init__(self, server, params):
196         import pylibmc
197         super().__init__(server, params, library=pylibmc, value_not_found_exception=pylibmc.NotFound)
198 
199     @property
200     def client_servers(self):
201         output = []
202         for server in self._servers:
203             output.append(server[5:] if server.startswith('unix:') else server)
204         return output
205 
206     def touch(self, key, timeout=DEFAULT_TIMEOUT, version=None):
207         key = self.make_key(key, version=version)
208         self.validate_key(key)
209         if timeout == 0:
210             return self._cache.delete(key)
211         return self._cache.touch(key, self.get_backend_timeout(timeout))
212 
213     def close(self, **kwargs):
214         # libmemcached manages its own connections. Don't call disconnect_all()
215         # as it resets the failover state and creates unnecessary reconnects.
216         pass
217 
218 
219 class PyMemcacheCache(BaseMemcachedCache):
220     """An implementation of a cache binding using pymemcache."""
221     def __init__(self, server, params):
222         import pymemcache.serde
223         super().__init__(server, params, library=pymemcache, value_not_found_exception=KeyError)
224         self._class = self._lib.HashClient
225         self._options = {
226             'allow_unicode_keys': True,
227             'default_noreply': False,
228             'serde': pymemcache.serde.pickle_serde,
229             **self._options,
230         }

</code><intended_behavior>Update documentation and comments related to `MemcachedCache` to reflect its deprecation and guide users towards migrating to `pymemcache`.</intended_behavior>]
2025-10-18 12:27:17.017 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-18 12:27:17.017 | INFO     | Search-only: skipping patch selection
2025-10-18 12:27:17.157 | INFO     | Task django__django-13744 completed successfully.
2025-10-18 12:27:17.157 | INFO     | No patch generated. You can try running ACR again.
