[
    {
        "rel_file_path": "django/core/cache/backends/memcached.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.2/django/core/cache/backends/memcached.py",
        "start": 166,
        "end": 171,
        "class_name": "MemcachedCache",
        "method_name": "__init__",
        "code": "166     def __init__(self, server, params):\n167         # python-memcached \u2265 1.45 returns None for a nonexistent key in\n168         # incr/decr(), python-memcached < 1.45 raises ValueError.\n169         import memcache\n170         super().__init__(server, params, library=memcache, value_not_found_exception=ValueError)\n171         self._options = {'pickleProtocol': pickle.HIGHEST_PROTOCOL, **self._options}\n",
        "intended_behavior": "The `__init__` method should include a deprecation warning for the `MemcachedCache` class, advising users to switch to `pymemcache`."
    },
    {
        "rel_file_path": "django/core/cache/backends/memcached.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.2/django/core/cache/backends/memcached.py",
        "start": 164,
        "end": 190,
        "class_name": "MemcachedCache",
        "method_name": null,
        "code": "164 class MemcachedCache(BaseMemcachedCache):\n165     \"An implementation of a cache binding using python-memcached\"\n166     def __init__(self, server, params):\n167         # python-memcached \u2265 1.45 returns None for a nonexistent key in\n168         # incr/decr(), python-memcached < 1.45 raises ValueError.\n169         import memcache\n170         super().__init__(server, params, library=memcache, value_not_found_exception=ValueError)\n171         self._options = {'pickleProtocol': pickle.HIGHEST_PROTOCOL, **self._options}\n172 \n173     def get(self, key, default=None, version=None):\n174         key = self.make_key(key, version=version)\n175         self.validate_key(key)\n176         val = self._cache.get(key)\n177         # python-memcached doesn't support default values in get().\n178         # https://github.com/linsomniac/python-memcached/issues/159\n179         # Remove this method if that issue is fixed.\n180         if val is None:\n181             return default\n182         return val\n183 \n184     def delete(self, key, version=None):\n185         # python-memcached's delete() returns True when key doesn't exist.\n186         # https://github.com/linsomniac/python-memcached/issues/170\n187         # Call _deletetouch() without the NOT_FOUND in expected results.\n188         key = self.make_key(key, version=version)\n189         self.validate_key(key)\n190         return bool(self._cache._deletetouch([b'DELETED'], 'delete', key))\n",
        "intended_behavior": "This class provides additional context to the issue."
    },
    {
        "rel_file_path": "django/core/cache/backends/memcached.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.2/django/core/cache/backends/memcached.py",
        "start": 1,
        "end": 230,
        "class_name": null,
        "method_name": null,
        "code": "1 \"Memcached cache backend\"\n2 \n3 import pickle\n4 import re\n5 import time\n6 \n7 from django.core.cache.backends.base import (\n8     DEFAULT_TIMEOUT, BaseCache, InvalidCacheKey, memcache_key_warnings,\n9 )\n10 from django.utils.functional import cached_property\n11 \n12 \n13 class BaseMemcachedCache(BaseCache):\n14     def __init__(self, server, params, library, value_not_found_exception):\n15         super().__init__(params)\n16         if isinstance(server, str):\n17             self._servers = re.split('[;,]', server)\n18         else:\n19             self._servers = server\n20 \n21         # Exception type raised by the underlying client library for a\n22         # nonexistent key.\n23         self.LibraryValueNotFoundException = value_not_found_exception\n24 \n25         self._lib = library\n26         self._class = library.Client\n27         self._options = params.get('OPTIONS') or {}\n28 \n29     @property\n30     def client_servers(self):\n31         return self._servers\n32 \n33     @cached_property\n34     def _cache(self):\n35         \"\"\"\n36         Implement transparent thread-safe access to a memcached client.\n37         \"\"\"\n38         return self._class(self.client_servers, **self._options)\n39 \n40     def get_backend_timeout(self, timeout=DEFAULT_TIMEOUT):\n41         \"\"\"\n42         Memcached deals with long (> 30 days) timeouts in a special\n43         way. Call this function to obtain a safe value for your timeout.\n44         \"\"\"\n45         if timeout == DEFAULT_TIMEOUT:\n46             timeout = self.default_timeout\n47 \n48         if timeout is None:\n49             # Using 0 in memcache sets a non-expiring timeout.\n50             return 0\n51         elif int(timeout) == 0:\n52             # Other cache backends treat 0 as set-and-expire. To achieve this\n53             # in memcache backends, a negative timeout must be passed.\n54             timeout = -1\n55 \n56         if timeout > 2592000:  # 60*60*24*30, 30 days\n57             # See https://github.com/memcached/memcached/wiki/Programming#expiration\n58             # \"Expiration times can be set from 0, meaning \"never expire\", to\n59             # 30 days. Any time higher than 30 days is interpreted as a Unix\n60             # timestamp date. If you want to expire an object on January 1st of\n61             # next year, this is how you do that.\"\n62             #\n63             # This means that we have to switch to absolute timestamps.\n64             timeout += int(time.time())\n65         return int(timeout)\n66 \n67     def add(self, key, value, timeout=DEFAULT_TIMEOUT, version=None):\n68         key = self.make_key(key, version=version)\n69         self.validate_key(key)\n70         return self._cache.add(key, value, self.get_backend_timeout(timeout))\n71 \n72     def get(self, key, default=None, version=None):\n73         key = self.make_key(key, version=version)\n74         self.validate_key(key)\n75         return self._cache.get(key, default)\n76 \n77     def set(self, key, value, timeout=DEFAULT_TIMEOUT, version=None):\n78         key = self.make_key(key, version=version)\n79         self.validate_key(key)\n80         if not self._cache.set(key, value, self.get_backend_timeout(timeout)):\n81             # make sure the key doesn't keep its old value in case of failure to set (memcached's 1MB limit)\n82             self._cache.delete(key)\n83 \n84     def touch(self, key, timeout=DEFAULT_TIMEOUT, version=None):\n85         key = self.make_key(key, version=version)\n86         self.validate_key(key)\n87         return bool(self._cache.touch(key, self.get_backend_timeout(timeout)))\n88 \n89     def delete(self, key, version=None):\n90         key = self.make_key(key, version=version)\n91         self.validate_key(key)\n92         return bool(self._cache.delete(key))\n93 \n94     def get_many(self, keys, version=None):\n95         key_map = {self.make_key(key, version=version): key for key in keys}\n96         for key in key_map:\n97             self.validate_key(key)\n98         ret = self._cache.get_multi(key_map.keys())\n99         return {key_map[k]: v for k, v in ret.items()}\n100 \n101     def close(self, **kwargs):\n102         # Many clients don't clean up connections properly.\n103         self._cache.disconnect_all()\n104 \n105     def incr(self, key, delta=1, version=None):\n106         key = self.make_key(key, version=version)\n107         self.validate_key(key)\n108         # memcached doesn't support a negative delta\n109         if delta < 0:\n110             return self._cache.decr(key, -delta)\n111         try:\n112             val = self._cache.incr(key, delta)\n113 \n114         # Normalize an exception raised by the underlying client library to\n115         # ValueError in the event of a nonexistent key when calling incr().\n116         except self.LibraryValueNotFoundException:\n117             val = None\n118         if val is None:\n119             raise ValueError(\"Key '%s' not found\" % key)\n120         return val\n121 \n122     def decr(self, key, delta=1, version=None):\n123         key = self.make_key(key, version=version)\n124         self.validate_key(key)\n125         # memcached doesn't support a negative delta\n126         if delta < 0:\n127             return self._cache.incr(key, -delta)\n128         try:\n129             val = self._cache.decr(key, delta)\n130 \n131         # Normalize an exception raised by the underlying client library to\n132         # ValueError in the event of a nonexistent key when calling decr().\n133         except self.LibraryValueNotFoundException:\n134             val = None\n135         if val is None:\n136             raise ValueError(\"Key '%s' not found\" % key)\n137         return val\n138 \n139     def set_many(self, data, timeout=DEFAULT_TIMEOUT, version=None):\n140         safe_data = {}\n141         original_keys = {}\n142         for key, value in data.items():\n143             safe_key = self.make_key(key, version=version)\n144             self.validate_key(safe_key)\n145             safe_data[safe_key] = value\n146             original_keys[safe_key] = key\n147         failed_keys = self._cache.set_multi(safe_data, self.get_backend_timeout(timeout))\n148         return [original_keys[k] for k in failed_keys]\n149 \n150     def delete_many(self, keys, version=None):\n151         keys = [self.make_key(key, version=version) for key in keys]\n152         for key in keys:\n153             self.validate_key(key)\n154         self._cache.delete_multi(keys)\n155 \n156     def clear(self):\n157         self._cache.flush_all()\n158 \n159     def validate_key(self, key):\n160         for warning in memcache_key_warnings(key):\n161             raise InvalidCacheKey(warning)\n162 \n163 \n164 class MemcachedCache(BaseMemcachedCache):\n165     \"An implementation of a cache binding using python-memcached\"\n166     def __init__(self, server, params):\n167         # python-memcached \u2265 1.45 returns None for a nonexistent key in\n168         # incr/decr(), python-memcached < 1.45 raises ValueError.\n169         import memcache\n170         super().__init__(server, params, library=memcache, value_not_found_exception=ValueError)\n171         self._options = {'pickleProtocol': pickle.HIGHEST_PROTOCOL, **self._options}\n172 \n173     def get(self, key, default=None, version=None):\n174         key = self.make_key(key, version=version)\n175         self.validate_key(key)\n176         val = self._cache.get(key)\n177         # python-memcached doesn't support default values in get().\n178         # https://github.com/linsomniac/python-memcached/issues/159\n179         # Remove this method if that issue is fixed.\n180         if val is None:\n181             return default\n182         return val\n183 \n184     def delete(self, key, version=None):\n185         # python-memcached's delete() returns True when key doesn't exist.\n186         # https://github.com/linsomniac/python-memcached/issues/170\n187         # Call _deletetouch() without the NOT_FOUND in expected results.\n188         key = self.make_key(key, version=version)\n189         self.validate_key(key)\n190         return bool(self._cache._deletetouch([b'DELETED'], 'delete', key))\n191 \n192 \n193 class PyLibMCCache(BaseMemcachedCache):\n194     \"An implementation of a cache binding using pylibmc\"\n195     def __init__(self, server, params):\n196         import pylibmc\n197         super().__init__(server, params, library=pylibmc, value_not_found_exception=pylibmc.NotFound)\n198 \n199     @property\n200     def client_servers(self):\n201         output = []\n202         for server in self._servers:\n203             output.append(server[5:] if server.startswith('unix:') else server)\n204         return output\n205 \n206     def touch(self, key, timeout=DEFAULT_TIMEOUT, version=None):\n207         key = self.make_key(key, version=version)\n208         self.validate_key(key)\n209         if timeout == 0:\n210             return self._cache.delete(key)\n211         return self._cache.touch(key, self.get_backend_timeout(timeout))\n212 \n213     def close(self, **kwargs):\n214         # libmemcached manages its own connections. Don't call disconnect_all()\n215         # as it resets the failover state and creates unnecessary reconnects.\n216         pass\n217 \n218 \n219 class PyMemcacheCache(BaseMemcachedCache):\n220     \"\"\"An implementation of a cache binding using pymemcache.\"\"\"\n221     def __init__(self, server, params):\n222         import pymemcache.serde\n223         super().__init__(server, params, library=pymemcache, value_not_found_exception=KeyError)\n224         self._class = self._lib.HashClient\n225         self._options = {\n226             'allow_unicode_keys': True,\n227             'default_noreply': False,\n228             'serde': pymemcache.serde.pickle_serde,\n229             **self._options,\n230         }\n",
        "intended_behavior": "Update documentation and comments related to `MemcachedCache` to reflect its deprecation and guide users towards migrating to `pymemcache`."
    }
]