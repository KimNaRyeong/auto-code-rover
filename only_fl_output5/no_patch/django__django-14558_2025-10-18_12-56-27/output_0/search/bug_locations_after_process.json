[
    {
        "rel_file_path": "django/forms/fields.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__4.0/django/forms/fields.py",
        "start": 1251,
        "end": 1257,
        "class_name": "JSONField",
        "method_name": "bound_data",
        "code": "1251     def bound_data(self, data, initial):\n1252         if self.disabled:\n1253             return initial\n1254         try:\n1255             return json.loads(data, cls=self.decoder)\n1256         except json.JSONDecodeError:\n1257             return InvalidJSONInput(data)\n",
        "intended_behavior": "The `bound_data` method should be updated to gracefully handle `None` as an input argument without raising a `TypeError`. When `data` is `None`, the method should return `None` instead of attempting to load it as JSON data, thus preserving the functionality of allowing forms to be rendered even when no data is provided for `JSONField`. This modification ensures that when a form is bound with a `JSONField` that has not received any input, the application does not crash due to a failed attempt to parse `None` as JSON. This will maintain the existing functionality for cases where `data` is not `None` and can be normally parsed as valid JSON."
    },
    {
        "rel_file_path": "django/forms/fields.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__4.0/django/forms/fields.py",
        "start": 1220,
        "end": 1272,
        "class_name": "JSONField",
        "method_name": null,
        "code": "1220 class JSONField(CharField):\n1221     default_error_messages = {\n1222         'invalid': _('Enter a valid JSON.'),\n1223     }\n1224     widget = Textarea\n1225 \n1226     def __init__(self, encoder=None, decoder=None, **kwargs):\n1227         self.encoder = encoder\n1228         self.decoder = decoder\n1229         super().__init__(**kwargs)\n1230 \n1231     def to_python(self, value):\n1232         if self.disabled:\n1233             return value\n1234         if value in self.empty_values:\n1235             return None\n1236         elif isinstance(value, (list, dict, int, float, JSONString)):\n1237             return value\n1238         try:\n1239             converted = json.loads(value, cls=self.decoder)\n1240         except json.JSONDecodeError:\n1241             raise ValidationError(\n1242                 self.error_messages['invalid'],\n1243                 code='invalid',\n1244                 params={'value': value},\n1245             )\n1246         if isinstance(converted, str):\n1247             return JSONString(converted)\n1248         else:\n1249             return converted\n1250 \n1251     def bound_data(self, data, initial):\n1252         if self.disabled:\n1253             return initial\n1254         try:\n1255             return json.loads(data, cls=self.decoder)\n1256         except json.JSONDecodeError:\n1257             return InvalidJSONInput(data)\n1258 \n1259     def prepare_value(self, value):\n1260         if isinstance(value, InvalidJSONInput):\n1261             return value\n1262         return json.dumps(value, ensure_ascii=False, cls=self.encoder)\n1263 \n1264     def has_changed(self, initial, data):\n1265         if super().has_changed(initial, data):\n1266             return True\n1267         # For purposes of seeing whether something has changed, True isn't the\n1268         # same as 1 and the order of keys doesn't matter.\n1269         return (\n1270             json.dumps(initial, sort_keys=True, cls=self.encoder) !=\n1271             json.dumps(self.to_python(data), sort_keys=True, cls=self.encoder)\n1272         )\n",
        "intended_behavior": "This class provides additional context to the issue."
    }
]