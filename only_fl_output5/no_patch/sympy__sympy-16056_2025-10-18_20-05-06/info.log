2025-10-18 20:05:06.760 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-18 20:05:17.195 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=369, output_tokens=12, cost=0.004050
2025-10-18 20:05:17.196 | INFO     | Test agent decides that the issue statement does not contain reproduction steps; skipping reproducer tracing
2025-10-18 20:05:17.199 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 20:05:24.772 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=677, output_tokens=348, cost=0.017210
2025-10-18 20:05:24.779 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 20:05:26.240 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=702, output_tokens=29, cost=0.007890
2025-10-18 20:05:26.241 | INFO     | Refactored invocation argument parsing gives different result on 'search_code("\\\\mathrm")': old result is ['\\\\mathrm'], new result  is ['\\mathrm']
2025-10-18 20:05:26.242 | INFO     | Refactored invocation argument parsing gives different result on 'search_code("\\\\text")': old result is ['\\\\text'], new result  is ['\\text']
2025-10-18 20:05:26.243 | DEBUG    | Extracted a valid json.
2025-10-18 20:05:26.243 | DEBUG    | Agent proxy return the following json: {
    "API_calls": ["search_code(\"\\\\mathrm\")", "search_code(\"\\\\text\")"],
    "bug_locations": []
}
2025-10-18 20:05:26.245 | INFO     | Refactored invocation argument parsing gives different result on 'search_code("\\\\mathrm")': old result is ['\\\\mathrm'], new result  is ['\\mathrm']
2025-10-18 20:05:26.308 | INFO     | Refactored invocation argument parsing gives different result on 'search_code("\\\\text")': old result is ['\\\\text'], new result  is ['\\text']
2025-10-18 20:05:26.350 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-18 20:05:26.350 | DEBUG    | <Agent search> Analyzing search results.
2025-10-18 20:05:42.283 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1672, output_tokens=761, cost=0.039550
2025-10-18 20:05:42.291 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 20:05:51.166 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2649, output_tokens=382, cost=0.037950
2025-10-18 20:05:51.172 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 20:06:00.354 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=736, output_tokens=362, cost=0.018220
2025-10-18 20:06:00.355 | DEBUG    | Extracted a valid json.
2025-10-18 20:06:00.355 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "sympy/functions/special/error_functions.py",
            "class": "",
            "method": "",
            "intended_behavior": "The use of \\mathrm within the error functions (i.e., _erfs and _eis classes) is consistent but not configurable. To resolve the issue, either maintain the use of \\mathrm as the standard due to its simplicity and lack of additional package dependencies or introduce a helper function/utility method within this file (or at a more global scope accessible by this file) that abstracts away the choice between \\text and \\mathrm. This method should allow for configuration at the library level, determining which command to use based on user preference or a global setting. The existing functionality of rendering mathematical expressions accurately should be preserved, with added flexibility for font adaptiveness where required."
        },
        {
            "file": "sympy/integrals/meijerint_doc.py",
            "class": "",
            "method": "",
            "intended_behavior": "Here, the \\text command is used to adapt the font of textual content within mathematical expressions in dynamic documentation. The intended behavior should ensure that any conditional statements or symbols added to the documentation continue to match the style of the surrounding maths content. Implementing a similar helper function/utility method that chooses between \\text and \\mathrm based on a configurable setting would standardize the approach and potentially enhance adaptability. This utility method should be used wherever such textual content is integrated with mathematical expressions to ensure consistency and configurability throughout the project. The method should default to \\text to preserve the adaptiveness with the math font but allow for \\mathrm if specified by the user or the project settings."
        }
    ]
}
2025-10-18 20:06:00.363 | DEBUG    | Bug location extracted successfully: [<file>sympy/functions/special/error_functions.py</file>
<class>None</class>
<method>None</method>
<code>
1 """ This module contains various functions that are special cases
2     of incomplete gamma functions. It should probably be renamed. """
3 
4 from __future__ import print_function, division
5 
6 from sympy.core import Add, S, sympify, cacheit, pi, I
7 from sympy.core.compatibility import range
8 from sympy.core.function import Function, ArgumentIndexError
9 from sympy.core.symbol import Symbol
10 from sympy.functions.combinatorial.factorials import factorial
11 from sympy.functions.elementary.integers import floor
12 from sympy.functions.elementary.miscellaneous import sqrt, root
13 from sympy.functions.elementary.exponential import exp, log
14 from sympy.functions.elementary.complexes import polar_lift
15 from sympy.functions.elementary.hyperbolic import cosh, sinh
16 from sympy.functions.elementary.trigonometric import cos, sin, sinc
17 from sympy.functions.special.hyper import hyper, meijerg
18 
19 # TODO series expansions
20 # TODO see the "Note:" in Ei
21 
22 ###############################################################################
23 ################################ ERROR FUNCTION ###############################
24 ###############################################################################
25 
26 
27 class erf(Function):
28     r"""
29     The Gauss error function. This function is defined as:
30 
31     .. math ::
32         \mathrm{erf}(x) = \frac{2}{\sqrt{\pi}} \int_0^x e^{-t^2} \mathrm{d}t.
33 
34     Examples
35     ========
36 
37     >>> from sympy import I, oo, erf
38     >>> from sympy.abc import z
39 
40     Several special values are known:
41 
42     >>> erf(0)
43     0
44     >>> erf(oo)
45     1
46     >>> erf(-oo)
47     -1
48     >>> erf(I*oo)
49     oo*I
50     >>> erf(-I*oo)
51     -oo*I
52 
53     In general one can pull out factors of -1 and I from the argument:
54 
55     >>> erf(-z)
56     -erf(z)
57 
58     The error function obeys the mirror symmetry:
59 
60     >>> from sympy import conjugate
61     >>> conjugate(erf(z))
62     erf(conjugate(z))
63 
64     Differentiation with respect to z is supported:
65 
66     >>> from sympy import diff
67     >>> diff(erf(z), z)
68     2*exp(-z**2)/sqrt(pi)
69 
70     We can numerically evaluate the error function to arbitrary precision
71     on the whole complex plane:
72 
73     >>> erf(4).evalf(30)
74     0.999999984582742099719981147840
75 
76     >>> erf(-4*I).evalf(30)
77     -1296959.73071763923152794095062*I
78 
79     See Also
80     ========
81 
82     erfc: Complementary error function.
83     erfi: Imaginary error function.
84     erf2: Two-argument error function.
85     erfinv: Inverse error function.
86     erfcinv: Inverse Complementary error function.
87     erf2inv: Inverse two-argument error function.
88 
89     References
90     ==========
91 
92     .. [1] https://en.wikipedia.org/wiki/Error_function
93     .. [2] http://dlmf.nist.gov/7
94     .. [3] http://mathworld.wolfram.com/Erf.html
95     .. [4] http://functions.wolfram.com/GammaBetaErf/Erf
96     """
97 
98     unbranched = True
99 
100     def fdiff(self, argindex=1):
101         if argindex == 1:
102             return 2*exp(-self.args[0]**2)/sqrt(S.Pi)
103         else:
104             raise ArgumentIndexError(self, argindex)
105 
106 
107     def inverse(self, argindex=1):
108         """
109         Returns the inverse of this function.
110         """
111         return erfinv
112 
113     @classmethod
114     def eval(cls, arg):
115         if arg.is_Number:
116             if arg is S.NaN:
117                 return S.NaN
118             elif arg is S.Infinity:
119                 return S.One
120             elif arg is S.NegativeInfinity:
121                 return S.NegativeOne
122             elif arg is S.Zero:
123                 return S.Zero
124 
125         if isinstance(arg, erfinv):
126              return arg.args[0]
127 
128         if isinstance(arg, erfcinv):
129             return S.One - arg.args[0]
130 
131         if isinstance(arg, erf2inv) and arg.args[0] is S.Zero:
132             return arg.args[1]
133 
134         # Try to pull out factors of I
135         t = arg.extract_multiplicatively(S.ImaginaryUnit)
136         if t is S.Infinity or t is S.NegativeInfinity:
137             return arg
138 
139         # Try to pull out factors of -1
140         if arg.could_extract_minus_sign():
141             return -cls(-arg)
142 
143     @staticmethod
144     @cacheit
145     def taylor_term(n, x, *previous_terms):
146         if n < 0 or n % 2 == 0:
147             return S.Zero
148         else:
149             x = sympify(x)
150             k = floor((n - 1)/S(2))
151             if len(previous_terms) > 2:
152                 return -previous_terms[-2] * x**2 * (n - 2)/(n*k)
153             else:
154                 return 2*(-1)**k * x**n/(n*factorial(k)*sqrt(S.Pi))
155 
156     def _eval_conjugate(self):
157         return self.func(self.args[0].conjugate())
158 
159     def _eval_is_real(self):
160         return self.args[0].is_real
161 
162     def _eval_rewrite_as_uppergamma(self, z, **kwargs):
163         from sympy import uppergamma
164         return sqrt(z**2)/z*(S.One - uppergamma(S.Half, z**2)/sqrt(S.Pi))
165 
166     def _eval_rewrite_as_fresnels(self, z, **kwargs):
167         arg = (S.One - S.ImaginaryUnit)*z/sqrt(pi)
168         return (S.One + S.ImaginaryUnit)*(fresnelc(arg) - I*fresnels(arg))
169 
170     def _eval_rewrite_as_fresnelc(self, z, **kwargs):
171         arg = (S.One - S.ImaginaryUnit)*z/sqrt(pi)
172         return (S.One + S.ImaginaryUnit)*(fresnelc(arg) - I*fresnels(arg))
173 
174     def _eval_rewrite_as_meijerg(self, z, **kwargs):
175         return z/sqrt(pi)*meijerg([S.Half], [], [0], [-S.Half], z**2)
176 
177     def _eval_rewrite_as_hyper(self, z, **kwargs):
178         return 2*z/sqrt(pi)*hyper([S.Half], [3*S.Half], -z**2)
179 
180     def _eval_rewrite_as_expint(self, z, **kwargs):
181         return sqrt(z**2)/z - z*expint(S.Half, z**2)/sqrt(S.Pi)
182 
183     def _eval_rewrite_as_tractable(self, z, **kwargs):
184         return S.One - _erfs(z)*exp(-z**2)
185 
186     def _eval_rewrite_as_erfc(self, z, **kwargs):
187         return S.One - erfc(z)
188 
189     def _eval_rewrite_as_erfi(self, z, **kwargs):
190         return -I*erfi(I*z)
191 
192     def _eval_as_leading_term(self, x):
193         from sympy import Order
194         arg = self.args[0].as_leading_term(x)
195 
196         if x in arg.free_symbols and Order(1, x).contains(arg):
197             return 2*x/sqrt(pi)
198         else:
199             return self.func(arg)
200 
201     def as_real_imag(self, deep=True, **hints):
202         if self.args[0].is_real:
203             if deep:
204                 hints['complex'] = False
205                 return (self.expand(deep, **hints), S.Zero)
206             else:
207                 return (self, S.Zero)
208         if deep:
209             x, y = self.args[0].expand(deep, **hints).as_real_imag()
210         else:
211             x, y = self.args[0].as_real_imag()
212 
213         sq = -y**2/x**2
214         re = S.Half*(self.func(x + x*sqrt(sq)) + self.func(x - x*sqrt(sq)))
215         im = x/(2*y) * sqrt(sq) * (self.func(x - x*sqrt(sq)) -
216                     self.func(x + x*sqrt(sq)))
217         return (re, im)
218 
219 
220 class erfc(Function):
221     r"""
222     Complementary Error Function. The function is defined as:
223 
224     .. math ::
225         \mathrm{erfc}(x) = \frac{2}{\sqrt{\pi}} \int_x^\infty e^{-t^2} \mathrm{d}t
226 
227     Examples
228     ========
229 
230     >>> from sympy import I, oo, erfc
231     >>> from sympy.abc import z
232 
233     Several special values are known:
234 
235     >>> erfc(0)
236     1
237     >>> erfc(oo)
238     0
239     >>> erfc(-oo)
240     2
241     >>> erfc(I*oo)
242     -oo*I
243     >>> erfc(-I*oo)
244     oo*I
245 
246     The error function obeys the mirror symmetry:
247 
248     >>> from sympy import conjugate
249     >>> conjugate(erfc(z))
250     erfc(conjugate(z))
251 
252     Differentiation with respect to z is supported:
253 
254     >>> from sympy import diff
255     >>> diff(erfc(z), z)
256     -2*exp(-z**2)/sqrt(pi)
257 
258     It also follows
259 
260     >>> erfc(-z)
261     2 - erfc(z)
262 
263     We can numerically evaluate the complementary error function to arbitrary precision
264     on the whole complex plane:
265 
266     >>> erfc(4).evalf(30)
267     0.0000000154172579002800188521596734869
268 
269     >>> erfc(4*I).evalf(30)
270     1.0 - 1296959.73071763923152794095062*I
271 
272     See Also
273     ========
274 
275     erf: Gaussian error function.
276     erfi: Imaginary error function.
277     erf2: Two-argument error function.
278     erfinv: Inverse error function.
279     erfcinv: Inverse Complementary error function.
280     erf2inv: Inverse two-argument error function.
281 
282     References
283     ==========
284 
285     .. [1] https://en.wikipedia.org/wiki/Error_function
286     .. [2] http://dlmf.nist.gov/7
287     .. [3] http://mathworld.wolfram.com/Erfc.html
288     .. [4] http://functions.wolfram.com/GammaBetaErf/Erfc
289     """
290 
291     unbranched = True
292 
293     def fdiff(self, argindex=1):
294         if argindex == 1:
295             return -2*exp(-self.args[0]**2)/sqrt(S.Pi)
296         else:
297             raise ArgumentIndexError(self, argindex)
298 
299     def inverse(self, argindex=1):
300         """
301         Returns the inverse of this function.
302         """
303         return erfcinv
304 
305     @classmethod
306     def eval(cls, arg):
307         if arg.is_Number:
308             if arg is S.NaN:
309                 return S.NaN
310             elif arg is S.Infinity:
311                 return S.Zero
312             elif arg is S.Zero:
313                 return S.One
314 
315         if isinstance(arg, erfinv):
316             return S.One - arg.args[0]
317 
318         if isinstance(arg, erfcinv):
319             return arg.args[0]
320 
321         # Try to pull out factors of I
322         t = arg.extract_multiplicatively(S.ImaginaryUnit)
323         if t is S.Infinity or t is S.NegativeInfinity:
324             return -arg
325 
326         # Try to pull out factors of -1
327         if arg.could_extract_minus_sign():
328             return S(2) - cls(-arg)
329 
330     @staticmethod
331     @cacheit
332     def taylor_term(n, x, *previous_terms):
333         if n == 0:
334             return S.One
335         elif n < 0 or n % 2 == 0:
336             return S.Zero
337         else:
338             x = sympify(x)
339             k = floor((n - 1)/S(2))
340             if len(previous_terms) > 2:
341                 return -previous_terms[-2] * x**2 * (n - 2)/(n*k)
342             else:
343                 return -2*(-1)**k * x**n/(n*factorial(k)*sqrt(S.Pi))
344 
345     def _eval_conjugate(self):
346         return self.func(self.args[0].conjugate())
347 
348     def _eval_is_real(self):
349         return self.args[0].is_real
350 
351     def _eval_rewrite_as_tractable(self, z, **kwargs):
352         return self.rewrite(erf).rewrite("tractable", deep=True)
353 
354     def _eval_rewrite_as_erf(self, z, **kwargs):
355         return S.One - erf(z)
356 
357     def _eval_rewrite_as_erfi(self, z, **kwargs):
358         return S.One + I*erfi(I*z)
359 
360     def _eval_rewrite_as_fresnels(self, z, **kwargs):
361         arg = (S.One - S.ImaginaryUnit)*z/sqrt(pi)
362         return S.One - (S.One + S.ImaginaryUnit)*(fresnelc(arg) - I*fresnels(arg))
363 
364     def _eval_rewrite_as_fresnelc(self, z, **kwargs):
365         arg = (S.One-S.ImaginaryUnit)*z/sqrt(pi)
366         return S.One - (S.One + S.ImaginaryUnit)*(fresnelc(arg) - I*fresnels(arg))
367 
368     def _eval_rewrite_as_meijerg(self, z, **kwargs):
369         return S.One - z/sqrt(pi)*meijerg([S.Half], [], [0], [-S.Half], z**2)
370 
371     def _eval_rewrite_as_hyper(self, z, **kwargs):
372         return S.One - 2*z/sqrt(pi)*hyper([S.Half], [3*S.Half], -z**2)
373 
374     def _eval_rewrite_as_uppergamma(self, z, **kwargs):
375         from sympy import uppergamma
376         return S.One - sqrt(z**2)/z*(S.One - uppergamma(S.Half, z**2)/sqrt(S.Pi))
377 
378     def _eval_rewrite_as_expint(self, z, **kwargs):
379         return S.One - sqrt(z**2)/z + z*expint(S.Half, z**2)/sqrt(S.Pi)
380 
381     def _eval_expand_func(self, **hints):
382         return self.rewrite(erf)
383 
384     def _eval_as_leading_term(self, x):
385         from sympy import Order
386         arg = self.args[0].as_leading_term(x)
387 
388         if x in arg.free_symbols and Order(1, x).contains(arg):
389             return S.One
390         else:
391             return self.func(arg)
392 
393     def as_real_imag(self, deep=True, **hints):
394         if self.args[0].is_real:
395             if deep:
396                 hints['complex'] = False
397                 return (self.expand(deep, **hints), S.Zero)
398             else:
399                 return (self, S.Zero)
400         if deep:
401             x, y = self.args[0].expand(deep, **hints).as_real_imag()
402         else:
403             x, y = self.args[0].as_real_imag()
404 
405         sq = -y**2/x**2
406         re = S.Half*(self.func(x + x*sqrt(sq)) + self.func(x - x*sqrt(sq)))
407         im = x/(2*y) * sqrt(sq) * (self.func(x - x*sqrt(sq)) -
408                     self.func(x + x*sqrt(sq)))
409         return (re, im)
410 
411 class erfi(Function):
412     r"""
413     Imaginary error function. The function erfi is defined as:
414 
415     .. math ::
416         \mathrm{erfi}(x) = \frac{2}{\sqrt{\pi}} \int_0^x e^{t^2} \mathrm{d}t
417 
418     Examples
419     ========
420 
421     >>> from sympy import I, oo, erfi
422     >>> from sympy.abc import z
423 
424     Several special values are known:
425 
426     >>> erfi(0)
427     0
428     >>> erfi(oo)
429     oo
430     >>> erfi(-oo)
431     -oo
432     >>> erfi(I*oo)
433     I
434     >>> erfi(-I*oo)
435     -I
436 
437     In general one can pull out factors of -1 and I from the argument:
438 
439     >>> erfi(-z)
440     -erfi(z)
441 
442     >>> from sympy import conjugate
443     >>> conjugate(erfi(z))
444     erfi(conjugate(z))
445 
446     Differentiation with respect to z is supported:
447 
448     >>> from sympy import diff
449     >>> diff(erfi(z), z)
450     2*exp(z**2)/sqrt(pi)
451 
452     We can numerically evaluate the imaginary error function to arbitrary precision
453     on the whole complex plane:
454 
455     >>> erfi(2).evalf(30)
456     18.5648024145755525987042919132
457 
458     >>> erfi(-2*I).evalf(30)
459     -0.995322265018952734162069256367*I
460 
461     See Also
462     ========
463 
464     erf: Gaussian error function.
465     erfc: Complementary error function.
466     erf2: Two-argument error function.
467     erfinv: Inverse error function.
468     erfcinv: Inverse Complementary error function.
469     erf2inv: Inverse two-argument error function.
470 
471     References
472     ==========
473 
474     .. [1] https://en.wikipedia.org/wiki/Error_function
475     .. [2] http://mathworld.wolfram.com/Erfi.html
476     .. [3] http://functions.wolfram.com/GammaBetaErf/Erfi
477     """
478 
479     unbranched = True
480 
481     def fdiff(self, argindex=1):
482         if argindex == 1:
483             return 2*exp(self.args[0]**2)/sqrt(S.Pi)
484         else:
485             raise ArgumentIndexError(self, argindex)
486 
487     @classmethod
488     def eval(cls, z):
489         if z.is_Number:
490             if z is S.NaN:
491                 return S.NaN
492             elif z is S.Zero:
493                 return S.Zero
494             elif z is S.Infinity:
495                 return S.Infinity
496 
497         # Try to pull out factors of -1
498         if z.could_extract_minus_sign():
499             return -cls(-z)
500 
501         # Try to pull out factors of I
502         nz = z.extract_multiplicatively(I)
503         if nz is not None:
504             if nz is S.Infinity:
505                 return I
506             if isinstance(nz, erfinv):
507                 return I*nz.args[0]
508             if isinstance(nz, erfcinv):
509                 return I*(S.One - nz.args[0])
510             if isinstance(nz, erf2inv) and nz.args[0] is S.Zero:
511                 return I*nz.args[1]
512 
513     @staticmethod
514     @cacheit
515     def taylor_term(n, x, *previous_terms):
516         if n < 0 or n % 2 == 0:
517             return S.Zero
518         else:
519             x = sympify(x)
520             k = floor((n - 1)/S(2))
521             if len(previous_terms) > 2:
522                 return previous_terms[-2] * x**2 * (n - 2)/(n*k)
523             else:
524                 return 2 * x**n/(n*factorial(k)*sqrt(S.Pi))
525 
526     def _eval_conjugate(self):
527         return self.func(self.args[0].conjugate())
528 
529     def _eval_is_real(self):
530         return self.args[0].is_real
531 
532     def _eval_rewrite_as_tractable(self, z, **kwargs):
533         return self.rewrite(erf).rewrite("tractable", deep=True)
534 
535     def _eval_rewrite_as_erf(self, z, **kwargs):
536         return -I*erf(I*z)
537 
538     def _eval_rewrite_as_erfc(self, z, **kwargs):
539         return I*erfc(I*z) - I
540 
541     def _eval_rewrite_as_fresnels(self, z, **kwargs):
542         arg = (S.One + S.ImaginaryUnit)*z/sqrt(pi)
543         return (S.One - S.ImaginaryUnit)*(fresnelc(arg) - I*fresnels(arg))
544 
545     def _eval_rewrite_as_fresnelc(self, z, **kwargs):
546         arg = (S.One + S.ImaginaryUnit)*z/sqrt(pi)
547         return (S.One - S.ImaginaryUnit)*(fresnelc(arg) - I*fresnels(arg))
548 
549     def _eval_rewrite_as_meijerg(self, z, **kwargs):
550         return z/sqrt(pi)*meijerg([S.Half], [], [0], [-S.Half], -z**2)
551 
552     def _eval_rewrite_as_hyper(self, z, **kwargs):
553         return 2*z/sqrt(pi)*hyper([S.Half], [3*S.Half], z**2)
554 
555     def _eval_rewrite_as_uppergamma(self, z, **kwargs):
556         from sympy import uppergamma
557         return sqrt(-z**2)/z*(uppergamma(S.Half, -z**2)/sqrt(S.Pi) - S.One)
558 
559     def _eval_rewrite_as_expint(self, z, **kwargs):
560         return sqrt(-z**2)/z - z*expint(S.Half, -z**2)/sqrt(S.Pi)
561 
562     def _eval_expand_func(self, **hints):
563         return self.rewrite(erf)
564 
565     def as_real_imag(self, deep=True, **hints):
566         if self.args[0].is_real:
567             if deep:
568                 hints['complex'] = False
569                 return (self.expand(deep, **hints), S.Zero)
570             else:
571                 return (self, S.Zero)
572         if deep:
573             x, y = self.args[0].expand(deep, **hints).as_real_imag()
574         else:
575             x, y = self.args[0].as_real_imag()
576 
577         sq = -y**2/x**2
578         re = S.Half*(self.func(x + x*sqrt(sq)) + self.func(x - x*sqrt(sq)))
579         im = x/(2*y) * sqrt(sq) * (self.func(x - x*sqrt(sq)) -
580                     self.func(x + x*sqrt(sq)))
581         return (re, im)
582 
583 class erf2(Function):
584     r"""
585     Two-argument error function. This function is defined as:
586 
587     .. math ::
588         \mathrm{erf2}(x, y) = \frac{2}{\sqrt{\pi}} \int_x^y e^{-t^2} \mathrm{d}t
589 
590     Examples
591     ========
592 
593     >>> from sympy import I, oo, erf2
594     >>> from sympy.abc import x, y
595 
596     Several special values are known:
597 
598     >>> erf2(0, 0)
599     0
600     >>> erf2(x, x)
601     0
602     >>> erf2(x, oo)
603     1 - erf(x)
604     >>> erf2(x, -oo)
605     -erf(x) - 1
606     >>> erf2(oo, y)
607     erf(y) - 1
608     >>> erf2(-oo, y)
609     erf(y) + 1
610 
611     In general one can pull out factors of -1:
612 
613     >>> erf2(-x, -y)
614     -erf2(x, y)
615 
616     The error function obeys the mirror symmetry:
617 
618     >>> from sympy import conjugate
619     >>> conjugate(erf2(x, y))
620     erf2(conjugate(x), conjugate(y))
621 
622     Differentiation with respect to x, y is supported:
623 
624     >>> from sympy import diff
625     >>> diff(erf2(x, y), x)
626     -2*exp(-x**2)/sqrt(pi)
627     >>> diff(erf2(x, y), y)
628     2*exp(-y**2)/sqrt(pi)
629 
630     See Also
631     ========
632 
633     erf: Gaussian error function.
634     erfc: Complementary error function.
635     erfi: Imaginary error function.
636     erfinv: Inverse error function.
637     erfcinv: Inverse Complementary error function.
638     erf2inv: Inverse two-argument error function.
639 
640     References
641     ==========
642 
643     .. [1] http://functions.wolfram.com/GammaBetaErf/Erf2/
644     """
645 
646 
647     def fdiff(self, argindex):
648         x, y = self.args
649         if argindex == 1:
650             return -2*exp(-x**2)/sqrt(S.Pi)
651         elif argindex == 2:
652             return 2*exp(-y**2)/sqrt(S.Pi)
653         else:
654             raise ArgumentIndexError(self, argindex)
655 
656     @classmethod
657     def eval(cls, x, y):
658         I = S.Infinity
659         N = S.NegativeInfinity
660         O = S.Zero
661         if x is S.NaN or y is S.NaN:
662             return S.NaN
663         elif x == y:
664             return S.Zero
665         elif (x is I or x is N or x is O) or (y is I or y is N or y is O):
666             return erf(y) - erf(x)
667 
668         if isinstance(y, erf2inv) and y.args[0] == x:
669             return y.args[1]
670 
671         #Try to pull out -1 factor
672         sign_x = x.could_extract_minus_sign()
673         sign_y = y.could_extract_minus_sign()
674         if (sign_x and sign_y):
675             return -cls(-x, -y)
676         elif (sign_x or sign_y):
677             return erf(y)-erf(x)
678 
679     def _eval_conjugate(self):
680         return self.func(self.args[0].conjugate(), self.args[1].conjugate())
681 
682     def _eval_is_real(self):
683         return self.args[0].is_real and self.args[1].is_real
684 
685     def _eval_rewrite_as_erf(self, x, y, **kwargs):
686         return erf(y) - erf(x)
687 
688     def _eval_rewrite_as_erfc(self, x, y, **kwargs):
689         return erfc(x) - erfc(y)
690 
691     def _eval_rewrite_as_erfi(self, x, y, **kwargs):
692         return I*(erfi(I*x)-erfi(I*y))
693 
694     def _eval_rewrite_as_fresnels(self, x, y, **kwargs):
695         return erf(y).rewrite(fresnels) - erf(x).rewrite(fresnels)
696 
697     def _eval_rewrite_as_fresnelc(self, x, y, **kwargs):
698         return erf(y).rewrite(fresnelc) - erf(x).rewrite(fresnelc)
699 
700     def _eval_rewrite_as_meijerg(self, x, y, **kwargs):
701         return erf(y).rewrite(meijerg) - erf(x).rewrite(meijerg)
702 
703     def _eval_rewrite_as_hyper(self, x, y, **kwargs):
704         return erf(y).rewrite(hyper) - erf(x).rewrite(hyper)
705 
706     def _eval_rewrite_as_uppergamma(self, x, y, **kwargs):
707         from sympy import uppergamma
708         return (sqrt(y**2)/y*(S.One - uppergamma(S.Half, y**2)/sqrt(S.Pi)) -
709             sqrt(x**2)/x*(S.One - uppergamma(S.Half, x**2)/sqrt(S.Pi)))
710 
711     def _eval_rewrite_as_expint(self, x, y, **kwargs):
712         return erf(y).rewrite(expint) - erf(x).rewrite(expint)
713 
714     def _eval_expand_func(self, **hints):
715         return self.rewrite(erf)
716 
717 
718 class erfinv(Function):
719     r"""
720     Inverse Error Function. The erfinv function is defined as:
721 
722     .. math ::
723         \mathrm{erf}(x) = y \quad \Rightarrow \quad \mathrm{erfinv}(y) = x
724 
725     Examples
726     ========
727 
728     >>> from sympy import I, oo, erfinv
729     >>> from sympy.abc import x
730 
731     Several special values are known:
732 
733     >>> erfinv(0)
734     0
735     >>> erfinv(1)
736     oo
737 
738     Differentiation with respect to x is supported:
739 
740     >>> from sympy import diff
741     >>> diff(erfinv(x), x)
742     sqrt(pi)*exp(erfinv(x)**2)/2
743 
744     We can numerically evaluate the inverse error function to arbitrary precision
745     on [-1, 1]:
746 
747     >>> erfinv(0.2).evalf(30)
748     0.179143454621291692285822705344
749 
750     See Also
751     ========
752 
753     erf: Gaussian error function.
754     erfc: Complementary error function.
755     erfi: Imaginary error function.
756     erf2: Two-argument error function.
757     erfcinv: Inverse Complementary error function.
758     erf2inv: Inverse two-argument error function.
759 
760     References
761     ==========
762 
763     .. [1] https://en.wikipedia.org/wiki/Error_function#Inverse_functions
764     .. [2] http://functions.wolfram.com/GammaBetaErf/InverseErf/
765     """
766 
767 
768     def fdiff(self, argindex =1):
769         if argindex == 1:
770             return sqrt(S.Pi)*exp(self.func(self.args[0])**2)*S.Half
771         else :
772             raise ArgumentIndexError(self, argindex)
773 
774     def inverse(self, argindex=1):
775         """
776         Returns the inverse of this function.
777         """
778         return erf
779 
780     @classmethod
781     def eval(cls, z):
782         if z is S.NaN:
783             return S.NaN
784         elif z is S.NegativeOne:
785             return S.NegativeInfinity
786         elif z is S.Zero:
787             return S.Zero
788         elif z is S.One:
789             return S.Infinity
790 
791         if isinstance(z, erf) and z.args[0].is_real:
792             return z.args[0]
793 
794         # Try to pull out factors of -1
795         nz = z.extract_multiplicatively(-1)
796         if nz is not None and (isinstance(nz, erf) and (nz.args[0]).is_real):
797             return -nz.args[0]
798 
799     def _eval_rewrite_as_erfcinv(self, z, **kwargs):
800        return erfcinv(1-z)
801 
802 
803 class erfcinv (Function):
804     r"""
805     Inverse Complementary Error Function. The erfcinv function is defined as:
806 
807     .. math ::
808         \mathrm{erfc}(x) = y \quad \Rightarrow \quad \mathrm{erfcinv}(y) = x
809 
810     Examples
811     ========
812 
813     >>> from sympy import I, oo, erfcinv
814     >>> from sympy.abc import x
815 
816     Several special values are known:
817 
818     >>> erfcinv(1)
819     0
820     >>> erfcinv(0)
821     oo
822 
823     Differentiation with respect to x is supported:
824 
825     >>> from sympy import diff
826     >>> diff(erfcinv(x), x)
827     -sqrt(pi)*exp(erfcinv(x)**2)/2
828 
829     See Also
830     ========
831 
832     erf: Gaussian error function.
833     erfc: Complementary error function.
834     erfi: Imaginary error function.
835     erf2: Two-argument error function.
836     erfinv: Inverse error function.
837     erf2inv: Inverse two-argument error function.
838 
839     References
840     ==========
841 
842     .. [1] https://en.wikipedia.org/wiki/Error_function#Inverse_functions
843     .. [2] http://functions.wolfram.com/GammaBetaErf/InverseErfc/
844     """
845 
846 
847     def fdiff(self, argindex =1):
848         if argindex == 1:
849             return -sqrt(S.Pi)*exp(self.func(self.args[0])**2)*S.Half
850         else:
851             raise ArgumentIndexError(self, argindex)
852 
853     def inverse(self, argindex=1):
854         """
855         Returns the inverse of this function.
856         """
857         return erfc
858 
859     @classmethod
860     def eval(cls, z):
861         if z is S.NaN:
862             return S.NaN
863         elif z is S.Zero:
864             return S.Infinity
865         elif z is S.One:
866             return S.Zero
867         elif z == 2:
868             return S.NegativeInfinity
869 
870     def _eval_rewrite_as_erfinv(self, z, **kwargs):
871         return erfinv(1-z)
872 
873 
874 class erf2inv(Function):
875     r"""
876     Two-argument Inverse error function. The erf2inv function is defined as:
877 
878     .. math ::
879         \mathrm{erf2}(x, w) = y \quad \Rightarrow \quad \mathrm{erf2inv}(x, y) = w
880 
881     Examples
882     ========
883 
884     >>> from sympy import I, oo, erf2inv, erfinv, erfcinv
885     >>> from sympy.abc import x, y
886 
887     Several special values are known:
888 
889     >>> erf2inv(0, 0)
890     0
891     >>> erf2inv(1, 0)
892     1
893     >>> erf2inv(0, 1)
894     oo
895     >>> erf2inv(0, y)
896     erfinv(y)
897     >>> erf2inv(oo, y)
898     erfcinv(-y)
899 
900     Differentiation with respect to x and y is supported:
901 
902     >>> from sympy import diff
903     >>> diff(erf2inv(x, y), x)
904     exp(-x**2 + erf2inv(x, y)**2)
905     >>> diff(erf2inv(x, y), y)
906     sqrt(pi)*exp(erf2inv(x, y)**2)/2
907 
908     See Also
909     ========
910 
911     erf: Gaussian error function.
912     erfc: Complementary error function.
913     erfi: Imaginary error function.
914     erf2: Two-argument error function.
915     erfinv: Inverse error function.
916     erfcinv: Inverse complementary error function.
917 
918     References
919     ==========
920 
921     .. [1] http://functions.wolfram.com/GammaBetaErf/InverseErf2/
922     """
923 
924 
925     def fdiff(self, argindex):
926         x, y = self.args
927         if argindex == 1:
928             return exp(self.func(x,y)**2-x**2)
929         elif argindex == 2:
930             return sqrt(S.Pi)*S.Half*exp(self.func(x,y)**2)
931         else:
932             raise ArgumentIndexError(self, argindex)
933 
934     @classmethod
935     def eval(cls, x, y):
936         if x is S.NaN or y is S.NaN:
937             return S.NaN
938         elif x is S.Zero and y is S.Zero:
939             return S.Zero
940         elif x is S.Zero and y is S.One:
941             return S.Infinity
942         elif x is S.One and y is S.Zero:
943             return S.One
944         elif x is S.Zero:
945             return erfinv(y)
946         elif x is S.Infinity:
947             return erfcinv(-y)
948         elif y is S.Zero:
949             return x
950         elif y is S.Infinity:
951             return erfinv(x)
952 
953 
954 ###############################################################################
955 #################### EXPONENTIAL INTEGRALS ####################################
956 ###############################################################################
957 
958 class Ei(Function):
959     r"""
960     The classical exponential integral.
961 
962     For use in SymPy, this function is defined as
963 
964     .. math:: \operatorname{Ei}(x) = \sum_{n=1}^\infty \frac{x^n}{n\, n!}
965                                      + \log(x) + \gamma,
966 
967     where `\gamma` is the Euler-Mascheroni constant.
968 
969     If `x` is a polar number, this defines an analytic function on the
970     Riemann surface of the logarithm. Otherwise this defines an analytic
971     function in the cut plane `\mathbb{C} \setminus (-\infty, 0]`.
972 
973     **Background**
974 
975     The name *exponential integral* comes from the following statement:
976 
977     .. math:: \operatorname{Ei}(x) = \int_{-\infty}^x \frac{e^t}{t} \mathrm{d}t
978 
979     If the integral is interpreted as a Cauchy principal value, this statement
980     holds for `x > 0` and `\operatorname{Ei}(x)` as defined above.
981 
982     Examples
983     ========
984 
985     >>> from sympy import Ei, polar_lift, exp_polar, I, pi
986     >>> from sympy.abc import x
987 
988     >>> Ei(-1)
989     Ei(-1)
990 
991     This yields a real value:
992 
993     >>> Ei(-1).n(chop=True)
994     -0.219383934395520
995 
996     On the other hand the analytic continuation is not real:
997 
998     >>> Ei(polar_lift(-1)).n(chop=True)
999     -0.21938393439552 + 3.14159265358979*I
1000 
1001     The exponential integral has a logarithmic branch point at the origin:
1002 
1003     >>> Ei(x*exp_polar(2*I*pi))
1004     Ei(x) + 2*I*pi
1005 
1006     Differentiation is supported:
1007 
1008     >>> Ei(x).diff(x)
1009     exp(x)/x
1010 
1011     The exponential integral is related to many other special functions.
1012     For example:
1013 
1014     >>> from sympy import uppergamma, expint, Shi
1015     >>> Ei(x).rewrite(expint)
1016     -expint(1, x*exp_polar(I*pi)) - I*pi
1017     >>> Ei(x).rewrite(Shi)
1018     Chi(x) + Shi(x)
1019 
1020     See Also
1021     ========
1022 
1023     expint: Generalised exponential integral.
1024     E1: Special case of the generalised exponential integral.
1025     li: Logarithmic integral.
1026     Li: Offset logarithmic integral.
1027     Si: Sine integral.
1028     Ci: Cosine integral.
1029     Shi: Hyperbolic sine integral.
1030     Chi: Hyperbolic cosine integral.
1031     sympy.functions.special.gamma_functions.uppergamma: Upper incomplete gamma function.
1032 
1033     References
1034     ==========
1035 
1036     .. [1] http://dlmf.nist.gov/6.6
1037     .. [2] https://en.wikipedia.org/wiki/Exponential_integral
1038     .. [3] Abramowitz & Stegun, section 5: http://people.math.sfu.ca/~cbm/aands/page_228.htm
1039 
1040     """
1041 
1042 
1043     @classmethod
1044     def eval(cls, z):
1045         if z is S.Zero:
1046             return S.NegativeInfinity
1047         elif z is S.Infinity:
1048             return S.Infinity
1049         elif z is S.NegativeInfinity:
1050             return S.Zero
1051 
1052         nz, n = z.extract_branch_factor()
1053         if n:
1054             return Ei(nz) + 2*I*pi*n
1055 
1056     def fdiff(self, argindex=1):
1057         from sympy import unpolarify
1058         arg = unpolarify(self.args[0])
1059         if argindex == 1:
1060             return exp(arg)/arg
1061         else:
1062             raise ArgumentIndexError(self, argindex)
1063 
1064     def _eval_evalf(self, prec):
1065         if (self.args[0]/polar_lift(-1)).is_positive:
1066             return Function._eval_evalf(self, prec) + (I*pi)._eval_evalf(prec)
1067         return Function._eval_evalf(self, prec)
1068 
1069     def _eval_rewrite_as_uppergamma(self, z, **kwargs):
1070         from sympy import uppergamma
1071         # XXX this does not currently work usefully because uppergamma
1072         #     immediately turns into expint
1073         return -uppergamma(0, polar_lift(-1)*z) - I*pi
1074 
1075     def _eval_rewrite_as_expint(self, z, **kwargs):
1076         return -expint(1, polar_lift(-1)*z) - I*pi
1077 
1078     def _eval_rewrite_as_li(self, z, **kwargs):
1079         if isinstance(z, log):
1080             return li(z.args[0])
1081         # TODO:
1082         # Actually it only holds that:
1083         #  Ei(z) = li(exp(z))
1084         # for -pi < imag(z) <= pi
1085         return li(exp(z))
1086 
1087     def _eval_rewrite_as_Si(self, z, **kwargs):
1088         return Shi(z) + Chi(z)
1089     _eval_rewrite_as_Ci = _eval_rewrite_as_Si
1090     _eval_rewrite_as_Chi = _eval_rewrite_as_Si
1091     _eval_rewrite_as_Shi = _eval_rewrite_as_Si
1092 
1093     def _eval_rewrite_as_tractable(self, z, **kwargs):
1094         return exp(z) * _eis(z)
1095 
1096     def _eval_nseries(self, x, n, logx):
1097         x0 = self.args[0].limit(x, 0)
1098         if x0 is S.Zero:
1099             f = self._eval_rewrite_as_Si(*self.args)
1100             return f._eval_nseries(x, n, logx)
1101         return super(Ei, self)._eval_nseries(x, n, logx)
1102 
1103 
1104 class expint(Function):
1105     r"""
1106     Generalized exponential integral.
1107 
1108     This function is defined as
1109 
1110     .. math:: \operatorname{E}_\nu(z) = z^{\nu - 1} \Gamma(1 - \nu, z),
1111 
1112     where `\Gamma(1 - \nu, z)` is the upper incomplete gamma function
1113     (``uppergamma``).
1114 
1115     Hence for :math:`z` with positive real part we have
1116 
1117     .. math:: \operatorname{E}_\nu(z)
1118               =   \int_1^\infty \frac{e^{-zt}}{z^\nu} \mathrm{d}t,
1119 
1120     which explains the name.
1121 
1122     The representation as an incomplete gamma function provides an analytic
1123     continuation for :math:`\operatorname{E}_\nu(z)`. If :math:`\nu` is a
1124     non-positive integer the exponential integral is thus an unbranched
1125     function of :math:`z`, otherwise there is a branch point at the origin.
1126     Refer to the incomplete gamma function documentation for details of the
1127     branching behavior.
1128 
1129     Examples
1130     ========
1131 
1132     >>> from sympy import expint, S
1133     >>> from sympy.abc import nu, z
1134 
1135     Differentiation is supported. Differentiation with respect to z explains
1136     further the name: for integral orders, the exponential integral is an
1137     iterated integral of the exponential function.
1138 
1139     >>> expint(nu, z).diff(z)
1140     -expint(nu - 1, z)
1141 
1142     Differentiation with respect to nu has no classical expression:
1143 
1144     >>> expint(nu, z).diff(nu)
1145     -z**(nu - 1)*meijerg(((), (1, 1)), ((0, 0, 1 - nu), ()), z)
1146 
1147     At non-postive integer orders, the exponential integral reduces to the
1148     exponential function:
1149 
1150     >>> expint(0, z)
1151     exp(-z)/z
1152     >>> expint(-1, z)
1153     exp(-z)/z + exp(-z)/z**2
1154 
1155     At half-integers it reduces to error functions:
1156 
1157     >>> expint(S(1)/2, z)
1158     sqrt(pi)*erfc(sqrt(z))/sqrt(z)
1159 
1160     At positive integer orders it can be rewritten in terms of exponentials
1161     and expint(1, z). Use expand_func() to do this:
1162 
1163     >>> from sympy import expand_func
1164     >>> expand_func(expint(5, z))
1165     z**4*expint(1, z)/24 + (-z**3 + z**2 - 2*z + 6)*exp(-z)/24
1166 
1167     The generalised exponential integral is essentially equivalent to the
1168     incomplete gamma function:
1169 
1170     >>> from sympy import uppergamma
1171     >>> expint(nu, z).rewrite(uppergamma)
1172     z**(nu - 1)*uppergamma(1 - nu, z)
1173 
1174     As such it is branched at the origin:
1175 
1176     >>> from sympy import exp_polar, pi, I
1177     >>> expint(4, z*exp_polar(2*pi*I))
1178     I*pi*z**3/3 + expint(4, z)
1179     >>> expint(nu, z*exp_polar(2*pi*I))
1180     z**(nu - 1)*(exp(2*I*pi*nu) - 1)*gamma(1 - nu) + expint(nu, z)
1181 
1182     See Also
1183     ========
1184 
1185     Ei: Another related function called exponential integral.
1186     E1: The classical case, returns expint(1, z).
1187     li: Logarithmic integral.
1188     Li: Offset logarithmic integral.
1189     Si: Sine integral.
1190     Ci: Cosine integral.
1191     Shi: Hyperbolic sine integral.
1192     Chi: Hyperbolic cosine integral.
1193     sympy.functions.special.gamma_functions.uppergamma
1194 
1195     References
1196     ==========
1197 
1198     .. [1] http://dlmf.nist.gov/8.19
1199     .. [2] http://functions.wolfram.com/GammaBetaErf/ExpIntegralE/
1200     .. [3] https://en.wikipedia.org/wiki/Exponential_integral
1201 
1202     """
1203 
1204 
1205     @classmethod
1206     def eval(cls, nu, z):
1207         from sympy import (unpolarify, expand_mul, uppergamma, exp, gamma,
1208                            factorial)
1209         nu2 = unpolarify(nu)
1210         if nu != nu2:
1211             return expint(nu2, z)
1212         if nu.is_Integer and nu <= 0 or (not nu.is_Integer and (2*nu).is_Integer):
1213             return unpolarify(expand_mul(z**(nu - 1)*uppergamma(1 - nu, z)))
1214 
1215         # Extract branching information. This can be deduced from what is
1216         # explained in lowergamma.eval().
1217         z, n = z.extract_branch_factor()
1218         if n == 0:
1219             return
1220         if nu.is_integer:
1221             if not nu > 0:
1222                 return
1223             return expint(nu, z) \
1224                 - 2*pi*I*n*(-1)**(nu - 1)/factorial(nu - 1)*unpolarify(z)**(nu - 1)
1225         else:
1226             return (exp(2*I*pi*nu*n) - 1)*z**(nu - 1)*gamma(1 - nu) + expint(nu, z)
1227 
1228     def fdiff(self, argindex):
1229         from sympy import meijerg
1230         nu, z = self.args
1231         if argindex == 1:
1232             return -z**(nu - 1)*meijerg([], [1, 1], [0, 0, 1 - nu], [], z)
1233         elif argindex == 2:
1234             return -expint(nu - 1, z)
1235         else:
1236             raise ArgumentIndexError(self, argindex)
1237 
1238     def _eval_rewrite_as_uppergamma(self, nu, z, **kwargs):
1239         from sympy import uppergamma
1240         return z**(nu - 1)*uppergamma(1 - nu, z)
1241 
1242     def _eval_rewrite_as_Ei(self, nu, z, **kwargs):
1243         from sympy import exp_polar, unpolarify, exp, factorial
1244         if nu == 1:
1245             return -Ei(z*exp_polar(-I*pi)) - I*pi
1246         elif nu.is_Integer and nu > 1:
1247             # DLMF, 8.19.7
1248             x = -unpolarify(z)
1249             return x**(nu - 1)/factorial(nu - 1)*E1(z).rewrite(Ei) + \
1250                 exp(x)/factorial(nu - 1) * \
1251                 Add(*[factorial(nu - k - 2)*x**k for k in range(nu - 1)])
1252         else:
1253             return self
1254 
1255     def _eval_expand_func(self, **hints):
1256         return self.rewrite(Ei).rewrite(expint, **hints)
1257 
1258     def _eval_rewrite_as_Si(self, nu, z, **kwargs):
1259         if nu != 1:
1260             return self
1261         return Shi(z) - Chi(z)
1262     _eval_rewrite_as_Ci = _eval_rewrite_as_Si
1263     _eval_rewrite_as_Chi = _eval_rewrite_as_Si
1264     _eval_rewrite_as_Shi = _eval_rewrite_as_Si
1265 
1266     def _eval_nseries(self, x, n, logx):
1267         if not self.args[0].has(x):
1268             nu = self.args[0]
1269             if nu == 1:
1270                 f = self._eval_rewrite_as_Si(*self.args)
1271                 return f._eval_nseries(x, n, logx)
1272             elif nu.is_Integer and nu > 1:
1273                 f = self._eval_rewrite_as_Ei(*self.args)
1274                 return f._eval_nseries(x, n, logx)
1275         return super(expint, self)._eval_nseries(x, n, logx)
1276 
1277     def _sage_(self):
1278         import sage.all as sage
1279         return sage.exp_integral_e(self.args[0]._sage_(), self.args[1]._sage_())
1280 
1281 
1282 def E1(z):
1283     """
1284     Classical case of the generalized exponential integral.
1285 
1286     This is equivalent to ``expint(1, z)``.
1287 
1288     See Also
1289     ========
1290 
1291     Ei: Exponential integral.
1292     expint: Generalised exponential integral.
1293     li: Logarithmic integral.
1294     Li: Offset logarithmic integral.
1295     Si: Sine integral.
1296     Ci: Cosine integral.
1297     Shi: Hyperbolic sine integral.
1298     Chi: Hyperbolic cosine integral.
1299     """
1300     return expint(1, z)
1301 
1302 
1303 class li(Function):
1304     r"""
1305     The classical logarithmic integral.
1306 
1307     For the use in SymPy, this function is defined as
1308 
1309     .. math:: \operatorname{li}(x) = \int_0^x \frac{1}{\log(t)} \mathrm{d}t \,.
1310 
1311     Examples
1312     ========
1313 
1314     >>> from sympy import I, oo, li
1315     >>> from sympy.abc import z
1316 
1317     Several special values are known:
1318 
1319     >>> li(0)
1320     0
1321     >>> li(1)
1322     -oo
1323     >>> li(oo)
1324     oo
1325 
1326     Differentiation with respect to z is supported:
1327 
1328     >>> from sympy import diff
1329     >>> diff(li(z), z)
1330     1/log(z)
1331 
1332     Defining the `li` function via an integral:
1333 
1334 
1335     The logarithmic integral can also be defined in terms of Ei:
1336 
1337     >>> from sympy import Ei
1338     >>> li(z).rewrite(Ei)
1339     Ei(log(z))
1340     >>> diff(li(z).rewrite(Ei), z)
1341     1/log(z)
1342 
1343     We can numerically evaluate the logarithmic integral to arbitrary precision
1344     on the whole complex plane (except the singular points):
1345 
1346     >>> li(2).evalf(30)
1347     1.04516378011749278484458888919
1348 
1349     >>> li(2*I).evalf(30)
1350     1.0652795784357498247001125598 + 3.08346052231061726610939702133*I
1351 
1352     We can even compute Soldner's constant by the help of mpmath:
1353 
1354     >>> from mpmath import findroot
1355     >>> findroot(li, 2)
1356     1.45136923488338
1357 
1358     Further transformations include rewriting `li` in terms of
1359     the trigonometric integrals `Si`, `Ci`, `Shi` and `Chi`:
1360 
1361     >>> from sympy import Si, Ci, Shi, Chi
1362     >>> li(z).rewrite(Si)
1363     -log(I*log(z)) - log(1/log(z))/2 + log(log(z))/2 + Ci(I*log(z)) + Shi(log(z))
1364     >>> li(z).rewrite(Ci)
1365     -log(I*log(z)) - log(1/log(z))/2 + log(log(z))/2 + Ci(I*log(z)) + Shi(log(z))
1366     >>> li(z).rewrite(Shi)
1367     -log(1/log(z))/2 + log(log(z))/2 + Chi(log(z)) - Shi(log(z))
1368     >>> li(z).rewrite(Chi)
1369     -log(1/log(z))/2 + log(log(z))/2 + Chi(log(z)) - Shi(log(z))
1370 
1371     See Also
1372     ========
1373 
1374     Li: Offset logarithmic integral.
1375     Ei: Exponential integral.
1376     expint: Generalised exponential integral.
1377     E1: Special case of the generalised exponential integral.
1378     Si: Sine integral.
1379     Ci: Cosine integral.
1380     Shi: Hyperbolic sine integral.
1381     Chi: Hyperbolic cosine integral.
1382 
1383     References
1384     ==========
1385 
1386     .. [1] https://en.wikipedia.org/wiki/Logarithmic_integral
1387     .. [2] http://mathworld.wolfram.com/LogarithmicIntegral.html
1388     .. [3] http://dlmf.nist.gov/6
1389     .. [4] http://mathworld.wolfram.com/SoldnersConstant.html
1390     """
1391 
1392 
1393     @classmethod
1394     def eval(cls, z):
1395         if z is S.Zero:
1396             return S.Zero
1397         elif z is S.One:
1398             return S.NegativeInfinity
1399         elif z is S.Infinity:
1400             return S.Infinity
1401 
1402     def fdiff(self, argindex=1):
1403         arg = self.args[0]
1404         if argindex == 1:
1405             return S.One / log(arg)
1406         else:
1407             raise ArgumentIndexError(self, argindex)
1408 
1409     def _eval_conjugate(self):
1410         z = self.args[0]
1411         # Exclude values on the branch cut (-oo, 0)
1412         if not (z.is_real and z.is_negative):
1413             return self.func(z.conjugate())
1414 
1415     def _eval_rewrite_as_Li(self, z, **kwargs):
1416         return Li(z) + li(2)
1417 
1418     def _eval_rewrite_as_Ei(self, z, **kwargs):
1419         return Ei(log(z))
1420 
1421     def _eval_rewrite_as_uppergamma(self, z, **kwargs):
1422         from sympy import uppergamma
1423         return (-uppergamma(0, -log(z)) +
1424                 S.Half*(log(log(z)) - log(S.One/log(z))) - log(-log(z)))
1425 
1426     def _eval_rewrite_as_Si(self, z, **kwargs):
1427         return (Ci(I*log(z)) - I*Si(I*log(z)) -
1428                 S.Half*(log(S.One/log(z)) - log(log(z))) - log(I*log(z)))
1429 
1430     _eval_rewrite_as_Ci = _eval_rewrite_as_Si
1431 
1432     def _eval_rewrite_as_Shi(self, z, **kwargs):
1433         return (Chi(log(z)) - Shi(log(z)) - S.Half*(log(S.One/log(z)) - log(log(z))))
1434 
1435     _eval_rewrite_as_Chi = _eval_rewrite_as_Shi
1436 
1437     def _eval_rewrite_as_hyper(self, z, **kwargs):
1438         return (log(z)*hyper((1, 1), (2, 2), log(z)) +
1439                 S.Half*(log(log(z)) - log(S.One/log(z))) + S.EulerGamma)
1440 
1441     def _eval_rewrite_as_meijerg(self, z, **kwargs):
1442         return (-log(-log(z)) - S.Half*(log(S.One/log(z)) - log(log(z)))
1443                 - meijerg(((), (1,)), ((0, 0), ()), -log(z)))
1444 
1445     def _eval_rewrite_as_tractable(self, z, **kwargs):
1446         return z * _eis(log(z))
1447 
1448 
1449 class Li(Function):
1450     r"""
1451     The offset logarithmic integral.
1452 
1453     For the use in SymPy, this function is defined as
1454 
1455     .. math:: \operatorname{Li}(x) = \operatorname{li}(x) - \operatorname{li}(2)
1456 
1457     Examples
1458     ========
1459 
1460     >>> from sympy import I, oo, Li
1461     >>> from sympy.abc import z
1462 
1463     The following special value is known:
1464 
1465     >>> Li(2)
1466     0
1467 
1468     Differentiation with respect to z is supported:
1469 
1470     >>> from sympy import diff
1471     >>> diff(Li(z), z)
1472     1/log(z)
1473 
1474     The shifted logarithmic integral can be written in terms of `li(z)`:
1475 
1476     >>> from sympy import li
1477     >>> Li(z).rewrite(li)
1478     li(z) - li(2)
1479 
1480     We can numerically evaluate the logarithmic integral to arbitrary precision
1481     on the whole complex plane (except the singular points):
1482 
1483     >>> Li(2).evalf(30)
1484     0
1485 
1486     >>> Li(4).evalf(30)
1487     1.92242131492155809316615998938
1488 
1489     See Also
1490     ========
1491 
1492     li: Logarithmic integral.
1493     Ei: Exponential integral.
1494     expint: Generalised exponential integral.
1495     E1: Special case of the generalised exponential integral.
1496     Si: Sine integral.
1497     Ci: Cosine integral.
1498     Shi: Hyperbolic sine integral.
1499     Chi: Hyperbolic cosine integral.
1500 
1501     References
1502     ==========
1503 
1504     .. [1] https://en.wikipedia.org/wiki/Logarithmic_integral
1505     .. [2] http://mathworld.wolfram.com/LogarithmicIntegral.html
1506     .. [3] http://dlmf.nist.gov/6
1507     """
1508 
1509 
1510     @classmethod
1511     def eval(cls, z):
1512         if z is S.Infinity:
1513             return S.Infinity
1514         elif z is 2*S.One:
1515             return S.Zero
1516 
1517     def fdiff(self, argindex=1):
1518         arg = self.args[0]
1519         if argindex == 1:
1520             return S.One / log(arg)
1521         else:
1522             raise ArgumentIndexError(self, argindex)
1523 
1524     def _eval_evalf(self, prec):
1525         return self.rewrite(li).evalf(prec)
1526 
1527     def _eval_rewrite_as_li(self, z, **kwargs):
1528         return li(z) - li(2)
1529 
1530     def _eval_rewrite_as_tractable(self, z, **kwargs):
1531         return self.rewrite(li).rewrite("tractable", deep=True)
1532 
1533 ###############################################################################
1534 #################### TRIGONOMETRIC INTEGRALS ##################################
1535 ###############################################################################
1536 
1537 class TrigonometricIntegral(Function):
1538     """ Base class for trigonometric integrals. """
1539 
1540 
1541     @classmethod
1542     def eval(cls, z):
1543         if z == 0:
1544             return cls._atzero
1545         elif z is S.Infinity:
1546             return cls._atinf()
1547         elif z is S.NegativeInfinity:
1548             return cls._atneginf()
1549 
1550         nz = z.extract_multiplicatively(polar_lift(I))
1551         if nz is None and cls._trigfunc(0) == 0:
1552             nz = z.extract_multiplicatively(I)
1553         if nz is not None:
1554             return cls._Ifactor(nz, 1)
1555         nz = z.extract_multiplicatively(polar_lift(-I))
1556         if nz is not None:
1557             return cls._Ifactor(nz, -1)
1558 
1559         nz = z.extract_multiplicatively(polar_lift(-1))
1560         if nz is None and cls._trigfunc(0) == 0:
1561             nz = z.extract_multiplicatively(-1)
1562         if nz is not None:
1563             return cls._minusfactor(nz)
1564 
1565         nz, n = z.extract_branch_factor()
1566         if n == 0 and nz == z:
1567             return
1568         return 2*pi*I*n*cls._trigfunc(0) + cls(nz)
1569 
1570     def fdiff(self, argindex=1):
1571         from sympy import unpolarify
1572         arg = unpolarify(self.args[0])
1573         if argindex == 1:
1574             return self._trigfunc(arg)/arg
1575 
1576     def _eval_rewrite_as_Ei(self, z, **kwargs):
1577         return self._eval_rewrite_as_expint(z).rewrite(Ei)
1578 
1579     def _eval_rewrite_as_uppergamma(self, z, **kwargs):
1580         from sympy import uppergamma
1581         return self._eval_rewrite_as_expint(z).rewrite(uppergamma)
1582 
1583     def _eval_nseries(self, x, n, logx):
1584         # NOTE this is fairly inefficient
1585         from sympy import log, EulerGamma, Pow
1586         n += 1
1587         if self.args[0].subs(x, 0) != 0:
1588             return super(TrigonometricIntegral, self)._eval_nseries(x, n, logx)
1589         baseseries = self._trigfunc(x)._eval_nseries(x, n, logx)
1590         if self._trigfunc(0) != 0:
1591             baseseries -= 1
1592         baseseries = baseseries.replace(Pow, lambda t, n: t**n/n, simultaneous=False)
1593         if self._trigfunc(0) != 0:
1594             baseseries += EulerGamma + log(x)
1595         return baseseries.subs(x, self.args[0])._eval_nseries(x, n, logx)
1596 
1597 
1598 class Si(TrigonometricIntegral):
1599     r"""
1600     Sine integral.
1601 
1602     This function is defined by
1603 
1604     .. math:: \operatorname{Si}(z) = \int_0^z \frac{\sin{t}}{t} \mathrm{d}t.
1605 
1606     It is an entire function.
1607 
1608     Examples
1609     ========
1610 
1611     >>> from sympy import Si
1612     >>> from sympy.abc import z
1613 
1614     The sine integral is an antiderivative of sin(z)/z:
1615 
1616     >>> Si(z).diff(z)
1617     sin(z)/z
1618 
1619     It is unbranched:
1620 
1621     >>> from sympy import exp_polar, I, pi
1622     >>> Si(z*exp_polar(2*I*pi))
1623     Si(z)
1624 
1625     Sine integral behaves much like ordinary sine under multiplication by ``I``:
1626 
1627     >>> Si(I*z)
1628     I*Shi(z)
1629     >>> Si(-z)
1630     -Si(z)
1631 
1632     It can also be expressed in terms of exponential integrals, but beware
1633     that the latter is branched:
1634 
1635     >>> from sympy import expint
1636     >>> Si(z).rewrite(expint)
1637     -I*(-expint(1, z*exp_polar(-I*pi/2))/2 +
1638          expint(1, z*exp_polar(I*pi/2))/2) + pi/2
1639 
1640     It can be rewritten in the form of sinc function (By definition)
1641 
1642     >>> from sympy import sinc
1643     >>> Si(z).rewrite(sinc)
1644     Integral(sinc(t), (t, 0, z))
1645 
1646     See Also
1647     ========
1648 
1649     Ci: Cosine integral.
1650     Shi: Hyperbolic sine integral.
1651     Chi: Hyperbolic cosine integral.
1652     Ei: Exponential integral.
1653     expint: Generalised exponential integral.
1654     sinc: unnormalized sinc function
1655     E1: Special case of the generalised exponential integral.
1656     li: Logarithmic integral.
1657     Li: Offset logarithmic integral.
1658 
1659     References
1660     ==========
1661 
1662     .. [1] https://en.wikipedia.org/wiki/Trigonometric_integral
1663 
1664     """
1665 
1666     _trigfunc = sin
1667     _atzero = S(0)
1668 
1669     @classmethod
1670     def _atinf(cls):
1671         return pi*S.Half
1672 
1673     @classmethod
1674     def _atneginf(cls):
1675         return -pi*S.Half
1676 
1677     @classmethod
1678     def _minusfactor(cls, z):
1679         return -Si(z)
1680 
1681     @classmethod
1682     def _Ifactor(cls, z, sign):
1683         return I*Shi(z)*sign
1684 
1685     def _eval_rewrite_as_expint(self, z, **kwargs):
1686         # XXX should we polarify z?
1687         return pi/2 + (E1(polar_lift(I)*z) - E1(polar_lift(-I)*z))/2/I
1688 
1689     def _eval_rewrite_as_sinc(self, z, **kwargs):
1690         from sympy import Integral
1691         t = Symbol('t', Dummy=True)
1692         return Integral(sinc(t), (t, 0, z))
1693 
1694     def _sage_(self):
1695         import sage.all as sage
1696         return sage.sin_integral(self.args[0]._sage_())
1697 
1698 class Ci(TrigonometricIntegral):
1699     r"""
1700     Cosine integral.
1701 
1702     This function is defined for positive `x` by
1703 
1704     .. math:: \operatorname{Ci}(x) = \gamma + \log{x}
1705                          + \int_0^x \frac{\cos{t} - 1}{t} \mathrm{d}t
1706            = -\int_x^\infty \frac{\cos{t}}{t} \mathrm{d}t,
1707 
1708     where `\gamma` is the Euler-Mascheroni constant.
1709 
1710     We have
1711 
1712     .. math:: \operatorname{Ci}(z) =
1713         -\frac{\operatorname{E}_1\left(e^{i\pi/2} z\right)
1714                + \operatorname{E}_1\left(e^{-i \pi/2} z\right)}{2}
1715 
1716     which holds for all polar `z` and thus provides an analytic
1717     continuation to the Riemann surface of the logarithm.
1718 
1719     The formula also holds as stated
1720     for `z \in \mathbb{C}` with `\Re(z) > 0`.
1721     By lifting to the principal branch we obtain an analytic function on the
1722     cut complex plane.
1723 
1724     Examples
1725     ========
1726 
1727     >>> from sympy import Ci
1728     >>> from sympy.abc import z
1729 
1730     The cosine integral is a primitive of `\cos(z)/z`:
1731 
1732     >>> Ci(z).diff(z)
1733     cos(z)/z
1734 
1735     It has a logarithmic branch point at the origin:
1736 
1737     >>> from sympy import exp_polar, I, pi
1738     >>> Ci(z*exp_polar(2*I*pi))
1739     Ci(z) + 2*I*pi
1740 
1741     The cosine integral behaves somewhat like ordinary `\cos` under multiplication by `i`:
1742 
1743     >>> from sympy import polar_lift
1744     >>> Ci(polar_lift(I)*z)
1745     Chi(z) + I*pi/2
1746     >>> Ci(polar_lift(-1)*z)
1747     Ci(z) + I*pi
1748 
1749     It can also be expressed in terms of exponential integrals:
1750 
1751     >>> from sympy import expint
1752     >>> Ci(z).rewrite(expint)
1753     -expint(1, z*exp_polar(-I*pi/2))/2 - expint(1, z*exp_polar(I*pi/2))/2
1754 
1755     See Also
1756     ========
1757 
1758     Si: Sine integral.
1759     Shi: Hyperbolic sine integral.
1760     Chi: Hyperbolic cosine integral.
1761     Ei: Exponential integral.
1762     expint: Generalised exponential integral.
1763     E1: Special case of the generalised exponential integral.
1764     li: Logarithmic integral.
1765     Li: Offset logarithmic integral.
1766 
1767     References
1768     ==========
1769 
1770     .. [1] https://en.wikipedia.org/wiki/Trigonometric_integral
1771 
1772     """
1773 
1774     _trigfunc = cos
1775     _atzero = S.ComplexInfinity
1776 
1777     @classmethod
1778     def _atinf(cls):
1779         return S.Zero
1780 
1781     @classmethod
1782     def _atneginf(cls):
1783         return I*pi
1784 
1785     @classmethod
1786     def _minusfactor(cls, z):
1787         return Ci(z) + I*pi
1788 
1789     @classmethod
1790     def _Ifactor(cls, z, sign):
1791         return Chi(z) + I*pi/2*sign
1792 
1793     def _eval_rewrite_as_expint(self, z, **kwargs):
1794         return -(E1(polar_lift(I)*z) + E1(polar_lift(-I)*z))/2
1795 
1796     def _sage_(self):
1797         import sage.all as sage
1798         return sage.cos_integral(self.args[0]._sage_())
1799 
1800 
1801 class Shi(TrigonometricIntegral):
1802     r"""
1803     Sinh integral.
1804 
1805     This function is defined by
1806 
1807     .. math:: \operatorname{Shi}(z) = \int_0^z \frac{\sinh{t}}{t} \mathrm{d}t.
1808 
1809     It is an entire function.
1810 
1811     Examples
1812     ========
1813 
1814     >>> from sympy import Shi
1815     >>> from sympy.abc import z
1816 
1817     The Sinh integral is a primitive of `\sinh(z)/z`:
1818 
1819     >>> Shi(z).diff(z)
1820     sinh(z)/z
1821 
1822     It is unbranched:
1823 
1824     >>> from sympy import exp_polar, I, pi
1825     >>> Shi(z*exp_polar(2*I*pi))
1826     Shi(z)
1827 
1828     The `\sinh` integral behaves much like ordinary `\sinh` under multiplication by `i`:
1829 
1830     >>> Shi(I*z)
1831     I*Si(z)
1832     >>> Shi(-z)
1833     -Shi(z)
1834 
1835     It can also be expressed in terms of exponential integrals, but beware
1836     that the latter is branched:
1837 
1838     >>> from sympy import expint
1839     >>> Shi(z).rewrite(expint)
1840     expint(1, z)/2 - expint(1, z*exp_polar(I*pi))/2 - I*pi/2
1841 
1842     See Also
1843     ========
1844 
1845     Si: Sine integral.
1846     Ci: Cosine integral.
1847     Chi: Hyperbolic cosine integral.
1848     Ei: Exponential integral.
1849     expint: Generalised exponential integral.
1850     E1: Special case of the generalised exponential integral.
1851     li: Logarithmic integral.
1852     Li: Offset logarithmic integral.
1853 
1854     References
1855     ==========
1856 
1857     .. [1] https://en.wikipedia.org/wiki/Trigonometric_integral
1858 
1859     """
1860 
1861     _trigfunc = sinh
1862     _atzero = S(0)
1863 
1864     @classmethod
1865     def _atinf(cls):
1866         return S.Infinity
1867 
1868     @classmethod
1869     def _atneginf(cls):
1870         return S.NegativeInfinity
1871 
1872     @classmethod
1873     def _minusfactor(cls, z):
1874         return -Shi(z)
1875 
1876     @classmethod
1877     def _Ifactor(cls, z, sign):
1878         return I*Si(z)*sign
1879 
1880     def _eval_rewrite_as_expint(self, z, **kwargs):
1881         from sympy import exp_polar
1882         # XXX should we polarify z?
1883         return (E1(z) - E1(exp_polar(I*pi)*z))/2 - I*pi/2
1884 
1885     def _sage_(self):
1886         import sage.all as sage
1887         return sage.sinh_integral(self.args[0]._sage_())
1888 
1889 
1890 class Chi(TrigonometricIntegral):
1891     r"""
1892     Cosh integral.
1893 
1894     This function is defined for positive :math:`x` by
1895 
1896     .. math:: \operatorname{Chi}(x) = \gamma + \log{x}
1897                          + \int_0^x \frac{\cosh{t} - 1}{t} \mathrm{d}t,
1898 
1899     where :math:`\gamma` is the Euler-Mascheroni constant.
1900 
1901     We have
1902 
1903     .. math:: \operatorname{Chi}(z) = \operatorname{Ci}\left(e^{i \pi/2}z\right)
1904                          - i\frac{\pi}{2},
1905 
1906     which holds for all polar :math:`z` and thus provides an analytic
1907     continuation to the Riemann surface of the logarithm.
1908     By lifting to the principal branch we obtain an analytic function on the
1909     cut complex plane.
1910 
1911     Examples
1912     ========
1913 
1914     >>> from sympy import Chi
1915     >>> from sympy.abc import z
1916 
1917     The `\cosh` integral is a primitive of `\cosh(z)/z`:
1918 
1919     >>> Chi(z).diff(z)
1920     cosh(z)/z
1921 
1922     It has a logarithmic branch point at the origin:
1923 
1924     >>> from sympy import exp_polar, I, pi
1925     >>> Chi(z*exp_polar(2*I*pi))
1926     Chi(z) + 2*I*pi
1927 
1928     The `\cosh` integral behaves somewhat like ordinary `\cosh` under multiplication by `i`:
1929 
1930     >>> from sympy import polar_lift
1931     >>> Chi(polar_lift(I)*z)
1932     Ci(z) + I*pi/2
1933     >>> Chi(polar_lift(-1)*z)
1934     Chi(z) + I*pi
1935 
1936     It can also be expressed in terms of exponential integrals:
1937 
1938     >>> from sympy import expint
1939     >>> Chi(z).rewrite(expint)
1940     -expint(1, z)/2 - expint(1, z*exp_polar(I*pi))/2 - I*pi/2
1941 
1942     See Also
1943     ========
1944 
1945     Si: Sine integral.
1946     Ci: Cosine integral.
1947     Shi: Hyperbolic sine integral.
1948     Ei: Exponential integral.
1949     expint: Generalised exponential integral.
1950     E1: Special case of the generalised exponential integral.
1951     li: Logarithmic integral.
1952     Li: Offset logarithmic integral.
1953 
1954     References
1955     ==========
1956 
1957     .. [1] https://en.wikipedia.org/wiki/Trigonometric_integral
1958 
1959     """
1960 
1961     _trigfunc = cosh
1962     _atzero = S.ComplexInfinity
1963 
1964     @classmethod
1965     def _atinf(cls):
1966         return S.Infinity
1967 
1968     @classmethod
1969     def _atneginf(cls):
1970         return S.Infinity
1971 
1972     @classmethod
1973     def _minusfactor(cls, z):
1974         return Chi(z) + I*pi
1975 
1976     @classmethod
1977     def _Ifactor(cls, z, sign):
1978         return Ci(z) + I*pi/2*sign
1979 
1980     def _eval_rewrite_as_expint(self, z, **kwargs):
1981         from sympy import exp_polar
1982         return -I*pi/2 - (E1(z) + E1(exp_polar(I*pi)*z))/2
1983 
1984     def _sage_(self):
1985         import sage.all as sage
1986         return sage.cosh_integral(self.args[0]._sage_())
1987 
1988 
1989 ###############################################################################
1990 #################### FRESNEL INTEGRALS ########################################
1991 ###############################################################################
1992 
1993 class FresnelIntegral(Function):
1994     """ Base class for the Fresnel integrals."""
1995 
1996     unbranched = True
1997 
1998     @classmethod
1999     def eval(cls, z):
2000         # Value at zero
2001         if z is S.Zero:
2002             return S(0)
2003 
2004         # Try to pull out factors of -1 and I
2005         prefact = S.One
2006         newarg = z
2007         changed = False
2008 
2009         nz = newarg.extract_multiplicatively(-1)
2010         if nz is not None:
2011             prefact = -prefact
2012             newarg = nz
2013             changed = True
2014 
2015         nz = newarg.extract_multiplicatively(I)
2016         if nz is not None:
2017             prefact = cls._sign*I*prefact
2018             newarg = nz
2019             changed = True
2020 
2021         if changed:
2022             return prefact*cls(newarg)
2023 
2024         # Values at positive infinities signs
2025         # if any were extracted automatically
2026         if z is S.Infinity:
2027             return S.Half
2028         elif z is I*S.Infinity:
2029             return cls._sign*I*S.Half
2030 
2031     def fdiff(self, argindex=1):
2032         if argindex == 1:
2033             return self._trigfunc(S.Half*pi*self.args[0]**2)
2034         else:
2035             raise ArgumentIndexError(self, argindex)
2036 
2037     def _eval_is_real(self):
2038         return self.args[0].is_real
2039 
2040     def _eval_conjugate(self):
2041         return self.func(self.args[0].conjugate())
2042 
2043     def _as_real_imag(self, deep=True, **hints):
2044         if self.args[0].is_real:
2045             if deep:
2046                 hints['complex'] = False
2047                 return (self.expand(deep, **hints), S.Zero)
2048             else:
2049                 return (self, S.Zero)
2050         if deep:
2051             re, im = self.args[0].expand(deep, **hints).as_real_imag()
2052         else:
2053             re, im = self.args[0].as_real_imag()
2054         return (re, im)
2055 
2056     def as_real_imag(self, deep=True, **hints):
2057         # Fresnel S
2058         # http://functions.wolfram.com/06.32.19.0003.01
2059         # http://functions.wolfram.com/06.32.19.0006.01
2060         # Fresnel C
2061         # http://functions.wolfram.com/06.33.19.0003.01
2062         # http://functions.wolfram.com/06.33.19.0006.01
2063         x, y = self._as_real_imag(deep=deep, **hints)
2064         sq = -y**2/x**2
2065         re = S.Half*(self.func(x + x*sqrt(sq)) + self.func(x - x*sqrt(sq)))
2066         im = x/(2*y) * sqrt(sq) * (self.func(x - x*sqrt(sq)) -
2067                 self.func(x + x*sqrt(sq)))
2068         return (re, im)
2069 
2070 
2071 class fresnels(FresnelIntegral):
2072     r"""
2073     Fresnel integral S.
2074 
2075     This function is defined by
2076 
2077     .. math:: \operatorname{S}(z) = \int_0^z \sin{\frac{\pi}{2} t^2} \mathrm{d}t.
2078 
2079     It is an entire function.
2080 
2081     Examples
2082     ========
2083 
2084     >>> from sympy import I, oo, fresnels
2085     >>> from sympy.abc import z
2086 
2087     Several special values are known:
2088 
2089     >>> fresnels(0)
2090     0
2091     >>> fresnels(oo)
2092     1/2
2093     >>> fresnels(-oo)
2094     -1/2
2095     >>> fresnels(I*oo)
2096     -I/2
2097     >>> fresnels(-I*oo)
2098     I/2
2099 
2100     In general one can pull out factors of -1 and `i` from the argument:
2101 
2102     >>> fresnels(-z)
2103     -fresnels(z)
2104     >>> fresnels(I*z)
2105     -I*fresnels(z)
2106 
2107     The Fresnel S integral obeys the mirror symmetry
2108     `\overline{S(z)} = S(\bar{z})`:
2109 
2110     >>> from sympy import conjugate
2111     >>> conjugate(fresnels(z))
2112     fresnels(conjugate(z))
2113 
2114     Differentiation with respect to `z` is supported:
2115 
2116     >>> from sympy import diff
2117     >>> diff(fresnels(z), z)
2118     sin(pi*z**2/2)
2119 
2120     Defining the Fresnel functions via an integral
2121 
2122     >>> from sympy import integrate, pi, sin, gamma, expand_func
2123     >>> integrate(sin(pi*z**2/2), z)
2124     3*fresnels(z)*gamma(3/4)/(4*gamma(7/4))
2125     >>> expand_func(integrate(sin(pi*z**2/2), z))
2126     fresnels(z)
2127 
2128     We can numerically evaluate the Fresnel integral to arbitrary precision
2129     on the whole complex plane:
2130 
2131     >>> fresnels(2).evalf(30)
2132     0.343415678363698242195300815958
2133 
2134     >>> fresnels(-2*I).evalf(30)
2135     0.343415678363698242195300815958*I
2136 
2137     See Also
2138     ========
2139 
2140     fresnelc: Fresnel cosine integral.
2141 
2142     References
2143     ==========
2144 
2145     .. [1] https://en.wikipedia.org/wiki/Fresnel_integral
2146     .. [2] http://dlmf.nist.gov/7
2147     .. [3] http://mathworld.wolfram.com/FresnelIntegrals.html
2148     .. [4] http://functions.wolfram.com/GammaBetaErf/FresnelS
2149     .. [5] The converging factors for the fresnel integrals
2150             by John W. Wrench Jr. and Vicki Alley
2151 
2152     """
2153     _trigfunc = sin
2154     _sign = -S.One
2155 
2156     @staticmethod
2157     @cacheit
2158     def taylor_term(n, x, *previous_terms):
2159         if n < 0:
2160             return S.Zero
2161         else:
2162             x = sympify(x)
2163             if len(previous_terms) > 1:
2164                 p = previous_terms[-1]
2165                 return (-pi**2*x**4*(4*n - 1)/(8*n*(2*n + 1)*(4*n + 3))) * p
2166             else:
2167                 return x**3 * (-x**4)**n * (S(2)**(-2*n - 1)*pi**(2*n + 1)) / ((4*n + 3)*factorial(2*n + 1))
2168 
2169     def _eval_rewrite_as_erf(self, z, **kwargs):
2170         return (S.One + I)/4 * (erf((S.One + I)/2*sqrt(pi)*z) - I*erf((S.One - I)/2*sqrt(pi)*z))
2171 
2172     def _eval_rewrite_as_hyper(self, z, **kwargs):
2173         return pi*z**3/6 * hyper([S(3)/4], [S(3)/2, S(7)/4], -pi**2*z**4/16)
2174 
2175     def _eval_rewrite_as_meijerg(self, z, **kwargs):
2176         return (pi*z**(S(9)/4) / (sqrt(2)*(z**2)**(S(3)/4)*(-z)**(S(3)/4))
2177                 * meijerg([], [1], [S(3)/4], [S(1)/4, 0], -pi**2*z**4/16))
2178 
2179     def _eval_aseries(self, n, args0, x, logx):
2180         from sympy import Order
2181         point = args0[0]
2182 
2183         # Expansion at oo and -oo
2184         if point in [S.Infinity, -S.Infinity]:
2185             z = self.args[0]
2186 
2187             # expansion of S(x) = S1(x*sqrt(pi/2)), see reference[5] page 1-8
2188             # as only real infinities are dealt with, sin and cos are O(1)
2189             p = [(-1)**k * factorial(4*k + 1) /
2190                  (2**(2*k + 2) * z**(4*k + 3) * 2**(2*k)*factorial(2*k))
2191                  for k in range(0, n) if 4*k + 3 < n]
2192             q = [1/(2*z)] + [(-1)**k * factorial(4*k - 1) /
2193                  (2**(2*k + 1) * z**(4*k + 1) * 2**(2*k - 1)*factorial(2*k - 1))
2194                  for k in range(1, n) if 4*k + 1 < n]
2195 
2196             p = [-sqrt(2/pi)*t for t in p]
2197             q = [-sqrt(2/pi)*t for t in q]
2198             s = 1 if point is S.Infinity else -1
2199             # The expansion at oo is 1/2 + some odd powers of z
2200             # To get the expansion at -oo, replace z by -z and flip the sign
2201             # The result -1/2 + the same odd powers of z as before.
2202             return s*S.Half + (sin(z**2)*Add(*p) + cos(z**2)*Add(*q)
2203                 ).subs(x, sqrt(2/pi)*x) + Order(1/z**n, x)
2204 
2205         # All other points are not handled
2206         return super(fresnels, self)._eval_aseries(n, args0, x, logx)
2207 
2208 
2209 class fresnelc(FresnelIntegral):
2210     r"""
2211     Fresnel integral C.
2212 
2213     This function is defined by
2214 
2215     .. math:: \operatorname{C}(z) = \int_0^z \cos{\frac{\pi}{2} t^2} \mathrm{d}t.
2216 
2217     It is an entire function.
2218 
2219     Examples
2220     ========
2221 
2222     >>> from sympy import I, oo, fresnelc
2223     >>> from sympy.abc import z
2224 
2225     Several special values are known:
2226 
2227     >>> fresnelc(0)
2228     0
2229     >>> fresnelc(oo)
2230     1/2
2231     >>> fresnelc(-oo)
2232     -1/2
2233     >>> fresnelc(I*oo)
2234     I/2
2235     >>> fresnelc(-I*oo)
2236     -I/2
2237 
2238     In general one can pull out factors of -1 and `i` from the argument:
2239 
2240     >>> fresnelc(-z)
2241     -fresnelc(z)
2242     >>> fresnelc(I*z)
2243     I*fresnelc(z)
2244 
2245     The Fresnel C integral obeys the mirror symmetry
2246     `\overline{C(z)} = C(\bar{z})`:
2247 
2248     >>> from sympy import conjugate
2249     >>> conjugate(fresnelc(z))
2250     fresnelc(conjugate(z))
2251 
2252     Differentiation with respect to `z` is supported:
2253 
2254     >>> from sympy import diff
2255     >>> diff(fresnelc(z), z)
2256     cos(pi*z**2/2)
2257 
2258     Defining the Fresnel functions via an integral
2259 
2260     >>> from sympy import integrate, pi, cos, gamma, expand_func
2261     >>> integrate(cos(pi*z**2/2), z)
2262     fresnelc(z)*gamma(1/4)/(4*gamma(5/4))
2263     >>> expand_func(integrate(cos(pi*z**2/2), z))
2264     fresnelc(z)
2265 
2266     We can numerically evaluate the Fresnel integral to arbitrary precision
2267     on the whole complex plane:
2268 
2269     >>> fresnelc(2).evalf(30)
2270     0.488253406075340754500223503357
2271 
2272     >>> fresnelc(-2*I).evalf(30)
2273     -0.488253406075340754500223503357*I
2274 
2275     See Also
2276     ========
2277 
2278     fresnels: Fresnel sine integral.
2279 
2280     References
2281     ==========
2282 
2283     .. [1] https://en.wikipedia.org/wiki/Fresnel_integral
2284     .. [2] http://dlmf.nist.gov/7
2285     .. [3] http://mathworld.wolfram.com/FresnelIntegrals.html
2286     .. [4] http://functions.wolfram.com/GammaBetaErf/FresnelC
2287     .. [5] The converging factors for the fresnel integrals
2288             by John W. Wrench Jr. and Vicki Alley
2289     """
2290     _trigfunc = cos
2291     _sign = S.One
2292 
2293     @staticmethod
2294     @cacheit
2295     def taylor_term(n, x, *previous_terms):
2296         if n < 0:
2297             return S.Zero
2298         else:
2299             x = sympify(x)
2300             if len(previous_terms) > 1:
2301                 p = previous_terms[-1]
2302                 return (-pi**2*x**4*(4*n - 3)/(8*n*(2*n - 1)*(4*n + 1))) * p
2303             else:
2304                 return x * (-x**4)**n * (S(2)**(-2*n)*pi**(2*n)) / ((4*n + 1)*factorial(2*n))
2305 
2306     def _eval_rewrite_as_erf(self, z, **kwargs):
2307         return (S.One - I)/4 * (erf((S.One + I)/2*sqrt(pi)*z) + I*erf((S.One - I)/2*sqrt(pi)*z))
2308 
2309     def _eval_rewrite_as_hyper(self, z, **kwargs):
2310         return z * hyper([S.One/4], [S.One/2, S(5)/4], -pi**2*z**4/16)
2311 
2312     def _eval_rewrite_as_meijerg(self, z, **kwargs):
2313         return (pi*z**(S(3)/4) / (sqrt(2)*root(z**2, 4)*root(-z, 4))
2314                 * meijerg([], [1], [S(1)/4], [S(3)/4, 0], -pi**2*z**4/16))
2315 
2316     def _eval_aseries(self, n, args0, x, logx):
2317         from sympy import Order
2318         point = args0[0]
2319 
2320         # Expansion at oo
2321         if point in [S.Infinity, -S.Infinity]:
2322             z = self.args[0]
2323 
2324             # expansion of C(x) = C1(x*sqrt(pi/2)), see reference[5] page 1-8
2325             # as only real infinities are dealt with, sin and cos are O(1)
2326             p = [(-1)**k * factorial(4*k + 1) /
2327                  (2**(2*k + 2) * z**(4*k + 3) * 2**(2*k)*factorial(2*k))
2328                  for k in range(0, n) if 4*k + 3 < n]
2329             q = [1/(2*z)] + [(-1)**k * factorial(4*k - 1) /
2330                  (2**(2*k + 1) * z**(4*k + 1) * 2**(2*k - 1)*factorial(2*k - 1))
2331                  for k in range(1, n) if 4*k + 1 < n]
2332 
2333             p = [-sqrt(2/pi)*t for t in p]
2334             q = [ sqrt(2/pi)*t for t in q]
2335             s = 1 if point is S.Infinity else -1
2336             # The expansion at oo is 1/2 + some odd powers of z
2337             # To get the expansion at -oo, replace z by -z and flip the sign
2338             # The result -1/2 + the same odd powers of z as before.
2339             return s*S.Half + (cos(z**2)*Add(*p) + sin(z**2)*Add(*q)
2340                 ).subs(x, sqrt(2/pi)*x) + Order(1/z**n, x)
2341 
2342         # All other points are not handled
2343         return super(fresnelc, self)._eval_aseries(n, args0, x, logx)
2344 
2345 
2346 ###############################################################################
2347 #################### HELPER FUNCTIONS #########################################
2348 ###############################################################################
2349 
2350 
2351 class _erfs(Function):
2352     """
2353     Helper function to make the `\\mathrm{erf}(z)` function
2354     tractable for the Gruntz algorithm.
2355     """
2356 
2357 
2358     def _eval_aseries(self, n, args0, x, logx):
2359         from sympy import Order
2360         point = args0[0]
2361 
2362         # Expansion at oo
2363         if point is S.Infinity:
2364             z = self.args[0]
2365             l = [ 1/sqrt(S.Pi) * factorial(2*k)*(-S(
2366                 4))**(-k)/factorial(k) * (1/z)**(2*k + 1) for k in range(0, n) ]
2367             o = Order(1/z**(2*n + 1), x)
2368             # It is very inefficient to first add the order and then do the nseries
2369             return (Add(*l))._eval_nseries(x, n, logx) + o
2370 
2371         # Expansion at I*oo
2372         t = point.extract_multiplicatively(S.ImaginaryUnit)
2373         if t is S.Infinity:
2374             z = self.args[0]
2375             # TODO: is the series really correct?
2376             l = [ 1/sqrt(S.Pi) * factorial(2*k)*(-S(
2377                 4))**(-k)/factorial(k) * (1/z)**(2*k + 1) for k in range(0, n) ]
2378             o = Order(1/z**(2*n + 1), x)
2379             # It is very inefficient to first add the order and then do the nseries
2380             return (Add(*l))._eval_nseries(x, n, logx) + o
2381 
2382         # All other points are not handled
2383         return super(_erfs, self)._eval_aseries(n, args0, x, logx)
2384 
2385     def fdiff(self, argindex=1):
2386         if argindex == 1:
2387             z = self.args[0]
2388             return -2/sqrt(S.Pi) + 2*z*_erfs(z)
2389         else:
2390             raise ArgumentIndexError(self, argindex)
2391 
2392     def _eval_rewrite_as_intractable(self, z, **kwargs):
2393         return (S.One - erf(z))*exp(z**2)
2394 
2395 
2396 class _eis(Function):
2397     """
2398     Helper function to make the `\\mathrm{Ei}(z)` and `\\mathrm{li}(z)` functions
2399     tractable for the Gruntz algorithm.
2400     """
2401 
2402 
2403     def _eval_aseries(self, n, args0, x, logx):
2404         from sympy import Order
2405         if args0[0] != S.Infinity:
2406             return super(_erfs, self)._eval_aseries(n, args0, x, logx)
2407 
2408         z = self.args[0]
2409         l = [ factorial(k) * (1/z)**(k + 1) for k in range(0, n) ]
2410         o = Order(1/z**(n + 1), x)
2411         # It is very inefficient to first add the order and then do the nseries
2412         return (Add(*l))._eval_nseries(x, n, logx) + o
2413 
2414 
2415     def fdiff(self, argindex=1):
2416         if argindex == 1:
2417             z = self.args[0]
2418             return S.One / z - _eis(z)
2419         else:
2420             raise ArgumentIndexError(self, argindex)
2421 
2422     def _eval_rewrite_as_intractable(self, z, **kwargs):
2423         return exp(-z)*Ei(z)
2424 
2425     def _eval_nseries(self, x, n, logx):
2426         x0 = self.args[0].limit(x, 0)
2427         if x0 is S.Zero:
2428             f = self._eval_rewrite_as_intractable(*self.args)
2429             return f._eval_nseries(x, n, logx)
2430         return super(_eis, self)._eval_nseries(x, n, logx)

</code><intended_behavior>The use of \mathrm within the error functions (i.e., _erfs and _eis classes) is consistent but not configurable. To resolve the issue, either maintain the use of \mathrm as the standard due to its simplicity and lack of additional package dependencies or introduce a helper function/utility method within this file (or at a more global scope accessible by this file) that abstracts away the choice between \text and \mathrm. This method should allow for configuration at the library level, determining which command to use based on user preference or a global setting. The existing functionality of rendering mathematical expressions accurately should be preserved, with added flexibility for font adaptiveness where required.</intended_behavior>, <file>sympy/integrals/meijerint_doc.py</file>
<class>None</class>
<method>None</method>
<code>
1 """ This module cooks up a docstring when imported. Its only purpose is to
2     be displayed in the sphinx documentation. """
3 
4 from __future__ import print_function, division
5 
6 from sympy.integrals.meijerint import _create_lookup_table
7 from sympy import latex, Eq, Add, Symbol
8 
9 t = {}
10 _create_lookup_table(t)
11 
12 doc = ""
13 
14 for about, category in sorted(t.items()):
15     if about == ():
16         doc += 'Elementary functions:\n\n'
17     else:
18         doc += 'Functions involving ' + ', '.join('`%s`' % latex(
19             list(category[0][0].atoms(func))[0]) for func in about) + ':\n\n'
20     for formula, gs, cond, hint in category:
21         if not isinstance(gs, list):
22             g = Symbol('\\text{generated}')
23         else:
24             g = Add(*[fac*f for (fac, f) in gs])
25         obj = Eq(formula, g)
26         if cond is True:
27             cond = ""
28         else:
29             cond = ',\\text{ if } %s' % latex(cond)
30         doc += ".. math::\n  %s%s\n\n" % (latex(obj), cond)
31 
32 __doc__ = doc

</code><intended_behavior>Here, the \text command is used to adapt the font of textual content within mathematical expressions in dynamic documentation. The intended behavior should ensure that any conditional statements or symbols added to the documentation continue to match the style of the surrounding maths content. Implementing a similar helper function/utility method that chooses between \text and \mathrm based on a configurable setting would standardize the approach and potentially enhance adaptability. This utility method should be used wherever such textual content is integrated with mathematical expressions to ensure consistency and configurability throughout the project. The method should default to \text to preserve the adaptiveness with the math font but allow for \mathrm if specified by the user or the project settings.</intended_behavior>]
2025-10-18 20:06:00.364 | INFO     | Search completed. Bug locations: [<file>sympy/functions/special/error_functions.py</file>
<class>None</class>
<method>None</method>
<code>
1 """ This module contains various functions that are special cases
2     of incomplete gamma functions. It should probably be renamed. """
3 
4 from __future__ import print_function, division
5 
6 from sympy.core import Add, S, sympify, cacheit, pi, I
7 from sympy.core.compatibility import range
8 from sympy.core.function import Function, ArgumentIndexError
9 from sympy.core.symbol import Symbol
10 from sympy.functions.combinatorial.factorials import factorial
11 from sympy.functions.elementary.integers import floor
12 from sympy.functions.elementary.miscellaneous import sqrt, root
13 from sympy.functions.elementary.exponential import exp, log
14 from sympy.functions.elementary.complexes import polar_lift
15 from sympy.functions.elementary.hyperbolic import cosh, sinh
16 from sympy.functions.elementary.trigonometric import cos, sin, sinc
17 from sympy.functions.special.hyper import hyper, meijerg
18 
19 # TODO series expansions
20 # TODO see the "Note:" in Ei
21 
22 ###############################################################################
23 ################################ ERROR FUNCTION ###############################
24 ###############################################################################
25 
26 
27 class erf(Function):
28     r"""
29     The Gauss error function. This function is defined as:
30 
31     .. math ::
32         \mathrm{erf}(x) = \frac{2}{\sqrt{\pi}} \int_0^x e^{-t^2} \mathrm{d}t.
33 
34     Examples
35     ========
36 
37     >>> from sympy import I, oo, erf
38     >>> from sympy.abc import z
39 
40     Several special values are known:
41 
42     >>> erf(0)
43     0
44     >>> erf(oo)
45     1
46     >>> erf(-oo)
47     -1
48     >>> erf(I*oo)
49     oo*I
50     >>> erf(-I*oo)
51     -oo*I
52 
53     In general one can pull out factors of -1 and I from the argument:
54 
55     >>> erf(-z)
56     -erf(z)
57 
58     The error function obeys the mirror symmetry:
59 
60     >>> from sympy import conjugate
61     >>> conjugate(erf(z))
62     erf(conjugate(z))
63 
64     Differentiation with respect to z is supported:
65 
66     >>> from sympy import diff
67     >>> diff(erf(z), z)
68     2*exp(-z**2)/sqrt(pi)
69 
70     We can numerically evaluate the error function to arbitrary precision
71     on the whole complex plane:
72 
73     >>> erf(4).evalf(30)
74     0.999999984582742099719981147840
75 
76     >>> erf(-4*I).evalf(30)
77     -1296959.73071763923152794095062*I
78 
79     See Also
80     ========
81 
82     erfc: Complementary error function.
83     erfi: Imaginary error function.
84     erf2: Two-argument error function.
85     erfinv: Inverse error function.
86     erfcinv: Inverse Complementary error function.
87     erf2inv: Inverse two-argument error function.
88 
89     References
90     ==========
91 
92     .. [1] https://en.wikipedia.org/wiki/Error_function
93     .. [2] http://dlmf.nist.gov/7
94     .. [3] http://mathworld.wolfram.com/Erf.html
95     .. [4] http://functions.wolfram.com/GammaBetaErf/Erf
96     """
97 
98     unbranched = True
99 
100     def fdiff(self, argindex=1):
101         if argindex == 1:
102             return 2*exp(-self.args[0]**2)/sqrt(S.Pi)
103         else:
104             raise ArgumentIndexError(self, argindex)
105 
106 
107     def inverse(self, argindex=1):
108         """
109         Returns the inverse of this function.
110         """
111         return erfinv
112 
113     @classmethod
114     def eval(cls, arg):
115         if arg.is_Number:
116             if arg is S.NaN:
117                 return S.NaN
118             elif arg is S.Infinity:
119                 return S.One
120             elif arg is S.NegativeInfinity:
121                 return S.NegativeOne
122             elif arg is S.Zero:
123                 return S.Zero
124 
125         if isinstance(arg, erfinv):
126              return arg.args[0]
127 
128         if isinstance(arg, erfcinv):
129             return S.One - arg.args[0]
130 
131         if isinstance(arg, erf2inv) and arg.args[0] is S.Zero:
132             return arg.args[1]
133 
134         # Try to pull out factors of I
135         t = arg.extract_multiplicatively(S.ImaginaryUnit)
136         if t is S.Infinity or t is S.NegativeInfinity:
137             return arg
138 
139         # Try to pull out factors of -1
140         if arg.could_extract_minus_sign():
141             return -cls(-arg)
142 
143     @staticmethod
144     @cacheit
145     def taylor_term(n, x, *previous_terms):
146         if n < 0 or n % 2 == 0:
147             return S.Zero
148         else:
149             x = sympify(x)
150             k = floor((n - 1)/S(2))
151             if len(previous_terms) > 2:
152                 return -previous_terms[-2] * x**2 * (n - 2)/(n*k)
153             else:
154                 return 2*(-1)**k * x**n/(n*factorial(k)*sqrt(S.Pi))
155 
156     def _eval_conjugate(self):
157         return self.func(self.args[0].conjugate())
158 
159     def _eval_is_real(self):
160         return self.args[0].is_real
161 
162     def _eval_rewrite_as_uppergamma(self, z, **kwargs):
163         from sympy import uppergamma
164         return sqrt(z**2)/z*(S.One - uppergamma(S.Half, z**2)/sqrt(S.Pi))
165 
166     def _eval_rewrite_as_fresnels(self, z, **kwargs):
167         arg = (S.One - S.ImaginaryUnit)*z/sqrt(pi)
168         return (S.One + S.ImaginaryUnit)*(fresnelc(arg) - I*fresnels(arg))
169 
170     def _eval_rewrite_as_fresnelc(self, z, **kwargs):
171         arg = (S.One - S.ImaginaryUnit)*z/sqrt(pi)
172         return (S.One + S.ImaginaryUnit)*(fresnelc(arg) - I*fresnels(arg))
173 
174     def _eval_rewrite_as_meijerg(self, z, **kwargs):
175         return z/sqrt(pi)*meijerg([S.Half], [], [0], [-S.Half], z**2)
176 
177     def _eval_rewrite_as_hyper(self, z, **kwargs):
178         return 2*z/sqrt(pi)*hyper([S.Half], [3*S.Half], -z**2)
179 
180     def _eval_rewrite_as_expint(self, z, **kwargs):
181         return sqrt(z**2)/z - z*expint(S.Half, z**2)/sqrt(S.Pi)
182 
183     def _eval_rewrite_as_tractable(self, z, **kwargs):
184         return S.One - _erfs(z)*exp(-z**2)
185 
186     def _eval_rewrite_as_erfc(self, z, **kwargs):
187         return S.One - erfc(z)
188 
189     def _eval_rewrite_as_erfi(self, z, **kwargs):
190         return -I*erfi(I*z)
191 
192     def _eval_as_leading_term(self, x):
193         from sympy import Order
194         arg = self.args[0].as_leading_term(x)
195 
196         if x in arg.free_symbols and Order(1, x).contains(arg):
197             return 2*x/sqrt(pi)
198         else:
199             return self.func(arg)
200 
201     def as_real_imag(self, deep=True, **hints):
202         if self.args[0].is_real:
203             if deep:
204                 hints['complex'] = False
205                 return (self.expand(deep, **hints), S.Zero)
206             else:
207                 return (self, S.Zero)
208         if deep:
209             x, y = self.args[0].expand(deep, **hints).as_real_imag()
210         else:
211             x, y = self.args[0].as_real_imag()
212 
213         sq = -y**2/x**2
214         re = S.Half*(self.func(x + x*sqrt(sq)) + self.func(x - x*sqrt(sq)))
215         im = x/(2*y) * sqrt(sq) * (self.func(x - x*sqrt(sq)) -
216                     self.func(x + x*sqrt(sq)))
217         return (re, im)
218 
219 
220 class erfc(Function):
221     r"""
222     Complementary Error Function. The function is defined as:
223 
224     .. math ::
225         \mathrm{erfc}(x) = \frac{2}{\sqrt{\pi}} \int_x^\infty e^{-t^2} \mathrm{d}t
226 
227     Examples
228     ========
229 
230     >>> from sympy import I, oo, erfc
231     >>> from sympy.abc import z
232 
233     Several special values are known:
234 
235     >>> erfc(0)
236     1
237     >>> erfc(oo)
238     0
239     >>> erfc(-oo)
240     2
241     >>> erfc(I*oo)
242     -oo*I
243     >>> erfc(-I*oo)
244     oo*I
245 
246     The error function obeys the mirror symmetry:
247 
248     >>> from sympy import conjugate
249     >>> conjugate(erfc(z))
250     erfc(conjugate(z))
251 
252     Differentiation with respect to z is supported:
253 
254     >>> from sympy import diff
255     >>> diff(erfc(z), z)
256     -2*exp(-z**2)/sqrt(pi)
257 
258     It also follows
259 
260     >>> erfc(-z)
261     2 - erfc(z)
262 
263     We can numerically evaluate the complementary error function to arbitrary precision
264     on the whole complex plane:
265 
266     >>> erfc(4).evalf(30)
267     0.0000000154172579002800188521596734869
268 
269     >>> erfc(4*I).evalf(30)
270     1.0 - 1296959.73071763923152794095062*I
271 
272     See Also
273     ========
274 
275     erf: Gaussian error function.
276     erfi: Imaginary error function.
277     erf2: Two-argument error function.
278     erfinv: Inverse error function.
279     erfcinv: Inverse Complementary error function.
280     erf2inv: Inverse two-argument error function.
281 
282     References
283     ==========
284 
285     .. [1] https://en.wikipedia.org/wiki/Error_function
286     .. [2] http://dlmf.nist.gov/7
287     .. [3] http://mathworld.wolfram.com/Erfc.html
288     .. [4] http://functions.wolfram.com/GammaBetaErf/Erfc
289     """
290 
291     unbranched = True
292 
293     def fdiff(self, argindex=1):
294         if argindex == 1:
295             return -2*exp(-self.args[0]**2)/sqrt(S.Pi)
296         else:
297             raise ArgumentIndexError(self, argindex)
298 
299     def inverse(self, argindex=1):
300         """
301         Returns the inverse of this function.
302         """
303         return erfcinv
304 
305     @classmethod
306     def eval(cls, arg):
307         if arg.is_Number:
308             if arg is S.NaN:
309                 return S.NaN
310             elif arg is S.Infinity:
311                 return S.Zero
312             elif arg is S.Zero:
313                 return S.One
314 
315         if isinstance(arg, erfinv):
316             return S.One - arg.args[0]
317 
318         if isinstance(arg, erfcinv):
319             return arg.args[0]
320 
321         # Try to pull out factors of I
322         t = arg.extract_multiplicatively(S.ImaginaryUnit)
323         if t is S.Infinity or t is S.NegativeInfinity:
324             return -arg
325 
326         # Try to pull out factors of -1
327         if arg.could_extract_minus_sign():
328             return S(2) - cls(-arg)
329 
330     @staticmethod
331     @cacheit
332     def taylor_term(n, x, *previous_terms):
333         if n == 0:
334             return S.One
335         elif n < 0 or n % 2 == 0:
336             return S.Zero
337         else:
338             x = sympify(x)
339             k = floor((n - 1)/S(2))
340             if len(previous_terms) > 2:
341                 return -previous_terms[-2] * x**2 * (n - 2)/(n*k)
342             else:
343                 return -2*(-1)**k * x**n/(n*factorial(k)*sqrt(S.Pi))
344 
345     def _eval_conjugate(self):
346         return self.func(self.args[0].conjugate())
347 
348     def _eval_is_real(self):
349         return self.args[0].is_real
350 
351     def _eval_rewrite_as_tractable(self, z, **kwargs):
352         return self.rewrite(erf).rewrite("tractable", deep=True)
353 
354     def _eval_rewrite_as_erf(self, z, **kwargs):
355         return S.One - erf(z)
356 
357     def _eval_rewrite_as_erfi(self, z, **kwargs):
358         return S.One + I*erfi(I*z)
359 
360     def _eval_rewrite_as_fresnels(self, z, **kwargs):
361         arg = (S.One - S.ImaginaryUnit)*z/sqrt(pi)
362         return S.One - (S.One + S.ImaginaryUnit)*(fresnelc(arg) - I*fresnels(arg))
363 
364     def _eval_rewrite_as_fresnelc(self, z, **kwargs):
365         arg = (S.One-S.ImaginaryUnit)*z/sqrt(pi)
366         return S.One - (S.One + S.ImaginaryUnit)*(fresnelc(arg) - I*fresnels(arg))
367 
368     def _eval_rewrite_as_meijerg(self, z, **kwargs):
369         return S.One - z/sqrt(pi)*meijerg([S.Half], [], [0], [-S.Half], z**2)
370 
371     def _eval_rewrite_as_hyper(self, z, **kwargs):
372         return S.One - 2*z/sqrt(pi)*hyper([S.Half], [3*S.Half], -z**2)
373 
374     def _eval_rewrite_as_uppergamma(self, z, **kwargs):
375         from sympy import uppergamma
376         return S.One - sqrt(z**2)/z*(S.One - uppergamma(S.Half, z**2)/sqrt(S.Pi))
377 
378     def _eval_rewrite_as_expint(self, z, **kwargs):
379         return S.One - sqrt(z**2)/z + z*expint(S.Half, z**2)/sqrt(S.Pi)
380 
381     def _eval_expand_func(self, **hints):
382         return self.rewrite(erf)
383 
384     def _eval_as_leading_term(self, x):
385         from sympy import Order
386         arg = self.args[0].as_leading_term(x)
387 
388         if x in arg.free_symbols and Order(1, x).contains(arg):
389             return S.One
390         else:
391             return self.func(arg)
392 
393     def as_real_imag(self, deep=True, **hints):
394         if self.args[0].is_real:
395             if deep:
396                 hints['complex'] = False
397                 return (self.expand(deep, **hints), S.Zero)
398             else:
399                 return (self, S.Zero)
400         if deep:
401             x, y = self.args[0].expand(deep, **hints).as_real_imag()
402         else:
403             x, y = self.args[0].as_real_imag()
404 
405         sq = -y**2/x**2
406         re = S.Half*(self.func(x + x*sqrt(sq)) + self.func(x - x*sqrt(sq)))
407         im = x/(2*y) * sqrt(sq) * (self.func(x - x*sqrt(sq)) -
408                     self.func(x + x*sqrt(sq)))
409         return (re, im)
410 
411 class erfi(Function):
412     r"""
413     Imaginary error function. The function erfi is defined as:
414 
415     .. math ::
416         \mathrm{erfi}(x) = \frac{2}{\sqrt{\pi}} \int_0^x e^{t^2} \mathrm{d}t
417 
418     Examples
419     ========
420 
421     >>> from sympy import I, oo, erfi
422     >>> from sympy.abc import z
423 
424     Several special values are known:
425 
426     >>> erfi(0)
427     0
428     >>> erfi(oo)
429     oo
430     >>> erfi(-oo)
431     -oo
432     >>> erfi(I*oo)
433     I
434     >>> erfi(-I*oo)
435     -I
436 
437     In general one can pull out factors of -1 and I from the argument:
438 
439     >>> erfi(-z)
440     -erfi(z)
441 
442     >>> from sympy import conjugate
443     >>> conjugate(erfi(z))
444     erfi(conjugate(z))
445 
446     Differentiation with respect to z is supported:
447 
448     >>> from sympy import diff
449     >>> diff(erfi(z), z)
450     2*exp(z**2)/sqrt(pi)
451 
452     We can numerically evaluate the imaginary error function to arbitrary precision
453     on the whole complex plane:
454 
455     >>> erfi(2).evalf(30)
456     18.5648024145755525987042919132
457 
458     >>> erfi(-2*I).evalf(30)
459     -0.995322265018952734162069256367*I
460 
461     See Also
462     ========
463 
464     erf: Gaussian error function.
465     erfc: Complementary error function.
466     erf2: Two-argument error function.
467     erfinv: Inverse error function.
468     erfcinv: Inverse Complementary error function.
469     erf2inv: Inverse two-argument error function.
470 
471     References
472     ==========
473 
474     .. [1] https://en.wikipedia.org/wiki/Error_function
475     .. [2] http://mathworld.wolfram.com/Erfi.html
476     .. [3] http://functions.wolfram.com/GammaBetaErf/Erfi
477     """
478 
479     unbranched = True
480 
481     def fdiff(self, argindex=1):
482         if argindex == 1:
483             return 2*exp(self.args[0]**2)/sqrt(S.Pi)
484         else:
485             raise ArgumentIndexError(self, argindex)
486 
487     @classmethod
488     def eval(cls, z):
489         if z.is_Number:
490             if z is S.NaN:
491                 return S.NaN
492             elif z is S.Zero:
493                 return S.Zero
494             elif z is S.Infinity:
495                 return S.Infinity
496 
497         # Try to pull out factors of -1
498         if z.could_extract_minus_sign():
499             return -cls(-z)
500 
501         # Try to pull out factors of I
502         nz = z.extract_multiplicatively(I)
503         if nz is not None:
504             if nz is S.Infinity:
505                 return I
506             if isinstance(nz, erfinv):
507                 return I*nz.args[0]
508             if isinstance(nz, erfcinv):
509                 return I*(S.One - nz.args[0])
510             if isinstance(nz, erf2inv) and nz.args[0] is S.Zero:
511                 return I*nz.args[1]
512 
513     @staticmethod
514     @cacheit
515     def taylor_term(n, x, *previous_terms):
516         if n < 0 or n % 2 == 0:
517             return S.Zero
518         else:
519             x = sympify(x)
520             k = floor((n - 1)/S(2))
521             if len(previous_terms) > 2:
522                 return previous_terms[-2] * x**2 * (n - 2)/(n*k)
523             else:
524                 return 2 * x**n/(n*factorial(k)*sqrt(S.Pi))
525 
526     def _eval_conjugate(self):
527         return self.func(self.args[0].conjugate())
528 
529     def _eval_is_real(self):
530         return self.args[0].is_real
531 
532     def _eval_rewrite_as_tractable(self, z, **kwargs):
533         return self.rewrite(erf).rewrite("tractable", deep=True)
534 
535     def _eval_rewrite_as_erf(self, z, **kwargs):
536         return -I*erf(I*z)
537 
538     def _eval_rewrite_as_erfc(self, z, **kwargs):
539         return I*erfc(I*z) - I
540 
541     def _eval_rewrite_as_fresnels(self, z, **kwargs):
542         arg = (S.One + S.ImaginaryUnit)*z/sqrt(pi)
543         return (S.One - S.ImaginaryUnit)*(fresnelc(arg) - I*fresnels(arg))
544 
545     def _eval_rewrite_as_fresnelc(self, z, **kwargs):
546         arg = (S.One + S.ImaginaryUnit)*z/sqrt(pi)
547         return (S.One - S.ImaginaryUnit)*(fresnelc(arg) - I*fresnels(arg))
548 
549     def _eval_rewrite_as_meijerg(self, z, **kwargs):
550         return z/sqrt(pi)*meijerg([S.Half], [], [0], [-S.Half], -z**2)
551 
552     def _eval_rewrite_as_hyper(self, z, **kwargs):
553         return 2*z/sqrt(pi)*hyper([S.Half], [3*S.Half], z**2)
554 
555     def _eval_rewrite_as_uppergamma(self, z, **kwargs):
556         from sympy import uppergamma
557         return sqrt(-z**2)/z*(uppergamma(S.Half, -z**2)/sqrt(S.Pi) - S.One)
558 
559     def _eval_rewrite_as_expint(self, z, **kwargs):
560         return sqrt(-z**2)/z - z*expint(S.Half, -z**2)/sqrt(S.Pi)
561 
562     def _eval_expand_func(self, **hints):
563         return self.rewrite(erf)
564 
565     def as_real_imag(self, deep=True, **hints):
566         if self.args[0].is_real:
567             if deep:
568                 hints['complex'] = False
569                 return (self.expand(deep, **hints), S.Zero)
570             else:
571                 return (self, S.Zero)
572         if deep:
573             x, y = self.args[0].expand(deep, **hints).as_real_imag()
574         else:
575             x, y = self.args[0].as_real_imag()
576 
577         sq = -y**2/x**2
578         re = S.Half*(self.func(x + x*sqrt(sq)) + self.func(x - x*sqrt(sq)))
579         im = x/(2*y) * sqrt(sq) * (self.func(x - x*sqrt(sq)) -
580                     self.func(x + x*sqrt(sq)))
581         return (re, im)
582 
583 class erf2(Function):
584     r"""
585     Two-argument error function. This function is defined as:
586 
587     .. math ::
588         \mathrm{erf2}(x, y) = \frac{2}{\sqrt{\pi}} \int_x^y e^{-t^2} \mathrm{d}t
589 
590     Examples
591     ========
592 
593     >>> from sympy import I, oo, erf2
594     >>> from sympy.abc import x, y
595 
596     Several special values are known:
597 
598     >>> erf2(0, 0)
599     0
600     >>> erf2(x, x)
601     0
602     >>> erf2(x, oo)
603     1 - erf(x)
604     >>> erf2(x, -oo)
605     -erf(x) - 1
606     >>> erf2(oo, y)
607     erf(y) - 1
608     >>> erf2(-oo, y)
609     erf(y) + 1
610 
611     In general one can pull out factors of -1:
612 
613     >>> erf2(-x, -y)
614     -erf2(x, y)
615 
616     The error function obeys the mirror symmetry:
617 
618     >>> from sympy import conjugate
619     >>> conjugate(erf2(x, y))
620     erf2(conjugate(x), conjugate(y))
621 
622     Differentiation with respect to x, y is supported:
623 
624     >>> from sympy import diff
625     >>> diff(erf2(x, y), x)
626     -2*exp(-x**2)/sqrt(pi)
627     >>> diff(erf2(x, y), y)
628     2*exp(-y**2)/sqrt(pi)
629 
630     See Also
631     ========
632 
633     erf: Gaussian error function.
634     erfc: Complementary error function.
635     erfi: Imaginary error function.
636     erfinv: Inverse error function.
637     erfcinv: Inverse Complementary error function.
638     erf2inv: Inverse two-argument error function.
639 
640     References
641     ==========
642 
643     .. [1] http://functions.wolfram.com/GammaBetaErf/Erf2/
644     """
645 
646 
647     def fdiff(self, argindex):
648         x, y = self.args
649         if argindex == 1:
650             return -2*exp(-x**2)/sqrt(S.Pi)
651         elif argindex == 2:
652             return 2*exp(-y**2)/sqrt(S.Pi)
653         else:
654             raise ArgumentIndexError(self, argindex)
655 
656     @classmethod
657     def eval(cls, x, y):
658         I = S.Infinity
659         N = S.NegativeInfinity
660         O = S.Zero
661         if x is S.NaN or y is S.NaN:
662             return S.NaN
663         elif x == y:
664             return S.Zero
665         elif (x is I or x is N or x is O) or (y is I or y is N or y is O):
666             return erf(y) - erf(x)
667 
668         if isinstance(y, erf2inv) and y.args[0] == x:
669             return y.args[1]
670 
671         #Try to pull out -1 factor
672         sign_x = x.could_extract_minus_sign()
673         sign_y = y.could_extract_minus_sign()
674         if (sign_x and sign_y):
675             return -cls(-x, -y)
676         elif (sign_x or sign_y):
677             return erf(y)-erf(x)
678 
679     def _eval_conjugate(self):
680         return self.func(self.args[0].conjugate(), self.args[1].conjugate())
681 
682     def _eval_is_real(self):
683         return self.args[0].is_real and self.args[1].is_real
684 
685     def _eval_rewrite_as_erf(self, x, y, **kwargs):
686         return erf(y) - erf(x)
687 
688     def _eval_rewrite_as_erfc(self, x, y, **kwargs):
689         return erfc(x) - erfc(y)
690 
691     def _eval_rewrite_as_erfi(self, x, y, **kwargs):
692         return I*(erfi(I*x)-erfi(I*y))
693 
694     def _eval_rewrite_as_fresnels(self, x, y, **kwargs):
695         return erf(y).rewrite(fresnels) - erf(x).rewrite(fresnels)
696 
697     def _eval_rewrite_as_fresnelc(self, x, y, **kwargs):
698         return erf(y).rewrite(fresnelc) - erf(x).rewrite(fresnelc)
699 
700     def _eval_rewrite_as_meijerg(self, x, y, **kwargs):
701         return erf(y).rewrite(meijerg) - erf(x).rewrite(meijerg)
702 
703     def _eval_rewrite_as_hyper(self, x, y, **kwargs):
704         return erf(y).rewrite(hyper) - erf(x).rewrite(hyper)
705 
706     def _eval_rewrite_as_uppergamma(self, x, y, **kwargs):
707         from sympy import uppergamma
708         return (sqrt(y**2)/y*(S.One - uppergamma(S.Half, y**2)/sqrt(S.Pi)) -
709             sqrt(x**2)/x*(S.One - uppergamma(S.Half, x**2)/sqrt(S.Pi)))
710 
711     def _eval_rewrite_as_expint(self, x, y, **kwargs):
712         return erf(y).rewrite(expint) - erf(x).rewrite(expint)
713 
714     def _eval_expand_func(self, **hints):
715         return self.rewrite(erf)
716 
717 
718 class erfinv(Function):
719     r"""
720     Inverse Error Function. The erfinv function is defined as:
721 
722     .. math ::
723         \mathrm{erf}(x) = y \quad \Rightarrow \quad \mathrm{erfinv}(y) = x
724 
725     Examples
726     ========
727 
728     >>> from sympy import I, oo, erfinv
729     >>> from sympy.abc import x
730 
731     Several special values are known:
732 
733     >>> erfinv(0)
734     0
735     >>> erfinv(1)
736     oo
737 
738     Differentiation with respect to x is supported:
739 
740     >>> from sympy import diff
741     >>> diff(erfinv(x), x)
742     sqrt(pi)*exp(erfinv(x)**2)/2
743 
744     We can numerically evaluate the inverse error function to arbitrary precision
745     on [-1, 1]:
746 
747     >>> erfinv(0.2).evalf(30)
748     0.179143454621291692285822705344
749 
750     See Also
751     ========
752 
753     erf: Gaussian error function.
754     erfc: Complementary error function.
755     erfi: Imaginary error function.
756     erf2: Two-argument error function.
757     erfcinv: Inverse Complementary error function.
758     erf2inv: Inverse two-argument error function.
759 
760     References
761     ==========
762 
763     .. [1] https://en.wikipedia.org/wiki/Error_function#Inverse_functions
764     .. [2] http://functions.wolfram.com/GammaBetaErf/InverseErf/
765     """
766 
767 
768     def fdiff(self, argindex =1):
769         if argindex == 1:
770             return sqrt(S.Pi)*exp(self.func(self.args[0])**2)*S.Half
771         else :
772             raise ArgumentIndexError(self, argindex)
773 
774     def inverse(self, argindex=1):
775         """
776         Returns the inverse of this function.
777         """
778         return erf
779 
780     @classmethod
781     def eval(cls, z):
782         if z is S.NaN:
783             return S.NaN
784         elif z is S.NegativeOne:
785             return S.NegativeInfinity
786         elif z is S.Zero:
787             return S.Zero
788         elif z is S.One:
789             return S.Infinity
790 
791         if isinstance(z, erf) and z.args[0].is_real:
792             return z.args[0]
793 
794         # Try to pull out factors of -1
795         nz = z.extract_multiplicatively(-1)
796         if nz is not None and (isinstance(nz, erf) and (nz.args[0]).is_real):
797             return -nz.args[0]
798 
799     def _eval_rewrite_as_erfcinv(self, z, **kwargs):
800        return erfcinv(1-z)
801 
802 
803 class erfcinv (Function):
804     r"""
805     Inverse Complementary Error Function. The erfcinv function is defined as:
806 
807     .. math ::
808         \mathrm{erfc}(x) = y \quad \Rightarrow \quad \mathrm{erfcinv}(y) = x
809 
810     Examples
811     ========
812 
813     >>> from sympy import I, oo, erfcinv
814     >>> from sympy.abc import x
815 
816     Several special values are known:
817 
818     >>> erfcinv(1)
819     0
820     >>> erfcinv(0)
821     oo
822 
823     Differentiation with respect to x is supported:
824 
825     >>> from sympy import diff
826     >>> diff(erfcinv(x), x)
827     -sqrt(pi)*exp(erfcinv(x)**2)/2
828 
829     See Also
830     ========
831 
832     erf: Gaussian error function.
833     erfc: Complementary error function.
834     erfi: Imaginary error function.
835     erf2: Two-argument error function.
836     erfinv: Inverse error function.
837     erf2inv: Inverse two-argument error function.
838 
839     References
840     ==========
841 
842     .. [1] https://en.wikipedia.org/wiki/Error_function#Inverse_functions
843     .. [2] http://functions.wolfram.com/GammaBetaErf/InverseErfc/
844     """
845 
846 
847     def fdiff(self, argindex =1):
848         if argindex == 1:
849             return -sqrt(S.Pi)*exp(self.func(self.args[0])**2)*S.Half
850         else:
851             raise ArgumentIndexError(self, argindex)
852 
853     def inverse(self, argindex=1):
854         """
855         Returns the inverse of this function.
856         """
857         return erfc
858 
859     @classmethod
860     def eval(cls, z):
861         if z is S.NaN:
862             return S.NaN
863         elif z is S.Zero:
864             return S.Infinity
865         elif z is S.One:
866             return S.Zero
867         elif z == 2:
868             return S.NegativeInfinity
869 
870     def _eval_rewrite_as_erfinv(self, z, **kwargs):
871         return erfinv(1-z)
872 
873 
874 class erf2inv(Function):
875     r"""
876     Two-argument Inverse error function. The erf2inv function is defined as:
877 
878     .. math ::
879         \mathrm{erf2}(x, w) = y \quad \Rightarrow \quad \mathrm{erf2inv}(x, y) = w
880 
881     Examples
882     ========
883 
884     >>> from sympy import I, oo, erf2inv, erfinv, erfcinv
885     >>> from sympy.abc import x, y
886 
887     Several special values are known:
888 
889     >>> erf2inv(0, 0)
890     0
891     >>> erf2inv(1, 0)
892     1
893     >>> erf2inv(0, 1)
894     oo
895     >>> erf2inv(0, y)
896     erfinv(y)
897     >>> erf2inv(oo, y)
898     erfcinv(-y)
899 
900     Differentiation with respect to x and y is supported:
901 
902     >>> from sympy import diff
903     >>> diff(erf2inv(x, y), x)
904     exp(-x**2 + erf2inv(x, y)**2)
905     >>> diff(erf2inv(x, y), y)
906     sqrt(pi)*exp(erf2inv(x, y)**2)/2
907 
908     See Also
909     ========
910 
911     erf: Gaussian error function.
912     erfc: Complementary error function.
913     erfi: Imaginary error function.
914     erf2: Two-argument error function.
915     erfinv: Inverse error function.
916     erfcinv: Inverse complementary error function.
917 
918     References
919     ==========
920 
921     .. [1] http://functions.wolfram.com/GammaBetaErf/InverseErf2/
922     """
923 
924 
925     def fdiff(self, argindex):
926         x, y = self.args
927         if argindex == 1:
928             return exp(self.func(x,y)**2-x**2)
929         elif argindex == 2:
930             return sqrt(S.Pi)*S.Half*exp(self.func(x,y)**2)
931         else:
932             raise ArgumentIndexError(self, argindex)
933 
934     @classmethod
935     def eval(cls, x, y):
936         if x is S.NaN or y is S.NaN:
937             return S.NaN
938         elif x is S.Zero and y is S.Zero:
939             return S.Zero
940         elif x is S.Zero and y is S.One:
941             return S.Infinity
942         elif x is S.One and y is S.Zero:
943             return S.One
944         elif x is S.Zero:
945             return erfinv(y)
946         elif x is S.Infinity:
947             return erfcinv(-y)
948         elif y is S.Zero:
949             return x
950         elif y is S.Infinity:
951             return erfinv(x)
952 
953 
954 ###############################################################################
955 #################### EXPONENTIAL INTEGRALS ####################################
956 ###############################################################################
957 
958 class Ei(Function):
959     r"""
960     The classical exponential integral.
961 
962     For use in SymPy, this function is defined as
963 
964     .. math:: \operatorname{Ei}(x) = \sum_{n=1}^\infty \frac{x^n}{n\, n!}
965                                      + \log(x) + \gamma,
966 
967     where `\gamma` is the Euler-Mascheroni constant.
968 
969     If `x` is a polar number, this defines an analytic function on the
970     Riemann surface of the logarithm. Otherwise this defines an analytic
971     function in the cut plane `\mathbb{C} \setminus (-\infty, 0]`.
972 
973     **Background**
974 
975     The name *exponential integral* comes from the following statement:
976 
977     .. math:: \operatorname{Ei}(x) = \int_{-\infty}^x \frac{e^t}{t} \mathrm{d}t
978 
979     If the integral is interpreted as a Cauchy principal value, this statement
980     holds for `x > 0` and `\operatorname{Ei}(x)` as defined above.
981 
982     Examples
983     ========
984 
985     >>> from sympy import Ei, polar_lift, exp_polar, I, pi
986     >>> from sympy.abc import x
987 
988     >>> Ei(-1)
989     Ei(-1)
990 
991     This yields a real value:
992 
993     >>> Ei(-1).n(chop=True)
994     -0.219383934395520
995 
996     On the other hand the analytic continuation is not real:
997 
998     >>> Ei(polar_lift(-1)).n(chop=True)
999     -0.21938393439552 + 3.14159265358979*I
1000 
1001     The exponential integral has a logarithmic branch point at the origin:
1002 
1003     >>> Ei(x*exp_polar(2*I*pi))
1004     Ei(x) + 2*I*pi
1005 
1006     Differentiation is supported:
1007 
1008     >>> Ei(x).diff(x)
1009     exp(x)/x
1010 
1011     The exponential integral is related to many other special functions.
1012     For example:
1013 
1014     >>> from sympy import uppergamma, expint, Shi
1015     >>> Ei(x).rewrite(expint)
1016     -expint(1, x*exp_polar(I*pi)) - I*pi
1017     >>> Ei(x).rewrite(Shi)
1018     Chi(x) + Shi(x)
1019 
1020     See Also
1021     ========
1022 
1023     expint: Generalised exponential integral.
1024     E1: Special case of the generalised exponential integral.
1025     li: Logarithmic integral.
1026     Li: Offset logarithmic integral.
1027     Si: Sine integral.
1028     Ci: Cosine integral.
1029     Shi: Hyperbolic sine integral.
1030     Chi: Hyperbolic cosine integral.
1031     sympy.functions.special.gamma_functions.uppergamma: Upper incomplete gamma function.
1032 
1033     References
1034     ==========
1035 
1036     .. [1] http://dlmf.nist.gov/6.6
1037     .. [2] https://en.wikipedia.org/wiki/Exponential_integral
1038     .. [3] Abramowitz & Stegun, section 5: http://people.math.sfu.ca/~cbm/aands/page_228.htm
1039 
1040     """
1041 
1042 
1043     @classmethod
1044     def eval(cls, z):
1045         if z is S.Zero:
1046             return S.NegativeInfinity
1047         elif z is S.Infinity:
1048             return S.Infinity
1049         elif z is S.NegativeInfinity:
1050             return S.Zero
1051 
1052         nz, n = z.extract_branch_factor()
1053         if n:
1054             return Ei(nz) + 2*I*pi*n
1055 
1056     def fdiff(self, argindex=1):
1057         from sympy import unpolarify
1058         arg = unpolarify(self.args[0])
1059         if argindex == 1:
1060             return exp(arg)/arg
1061         else:
1062             raise ArgumentIndexError(self, argindex)
1063 
1064     def _eval_evalf(self, prec):
1065         if (self.args[0]/polar_lift(-1)).is_positive:
1066             return Function._eval_evalf(self, prec) + (I*pi)._eval_evalf(prec)
1067         return Function._eval_evalf(self, prec)
1068 
1069     def _eval_rewrite_as_uppergamma(self, z, **kwargs):
1070         from sympy import uppergamma
1071         # XXX this does not currently work usefully because uppergamma
1072         #     immediately turns into expint
1073         return -uppergamma(0, polar_lift(-1)*z) - I*pi
1074 
1075     def _eval_rewrite_as_expint(self, z, **kwargs):
1076         return -expint(1, polar_lift(-1)*z) - I*pi
1077 
1078     def _eval_rewrite_as_li(self, z, **kwargs):
1079         if isinstance(z, log):
1080             return li(z.args[0])
1081         # TODO:
1082         # Actually it only holds that:
1083         #  Ei(z) = li(exp(z))
1084         # for -pi < imag(z) <= pi
1085         return li(exp(z))
1086 
1087     def _eval_rewrite_as_Si(self, z, **kwargs):
1088         return Shi(z) + Chi(z)
1089     _eval_rewrite_as_Ci = _eval_rewrite_as_Si
1090     _eval_rewrite_as_Chi = _eval_rewrite_as_Si
1091     _eval_rewrite_as_Shi = _eval_rewrite_as_Si
1092 
1093     def _eval_rewrite_as_tractable(self, z, **kwargs):
1094         return exp(z) * _eis(z)
1095 
1096     def _eval_nseries(self, x, n, logx):
1097         x0 = self.args[0].limit(x, 0)
1098         if x0 is S.Zero:
1099             f = self._eval_rewrite_as_Si(*self.args)
1100             return f._eval_nseries(x, n, logx)
1101         return super(Ei, self)._eval_nseries(x, n, logx)
1102 
1103 
1104 class expint(Function):
1105     r"""
1106     Generalized exponential integral.
1107 
1108     This function is defined as
1109 
1110     .. math:: \operatorname{E}_\nu(z) = z^{\nu - 1} \Gamma(1 - \nu, z),
1111 
1112     where `\Gamma(1 - \nu, z)` is the upper incomplete gamma function
1113     (``uppergamma``).
1114 
1115     Hence for :math:`z` with positive real part we have
1116 
1117     .. math:: \operatorname{E}_\nu(z)
1118               =   \int_1^\infty \frac{e^{-zt}}{z^\nu} \mathrm{d}t,
1119 
1120     which explains the name.
1121 
1122     The representation as an incomplete gamma function provides an analytic
1123     continuation for :math:`\operatorname{E}_\nu(z)`. If :math:`\nu` is a
1124     non-positive integer the exponential integral is thus an unbranched
1125     function of :math:`z`, otherwise there is a branch point at the origin.
1126     Refer to the incomplete gamma function documentation for details of the
1127     branching behavior.
1128 
1129     Examples
1130     ========
1131 
1132     >>> from sympy import expint, S
1133     >>> from sympy.abc import nu, z
1134 
1135     Differentiation is supported. Differentiation with respect to z explains
1136     further the name: for integral orders, the exponential integral is an
1137     iterated integral of the exponential function.
1138 
1139     >>> expint(nu, z).diff(z)
1140     -expint(nu - 1, z)
1141 
1142     Differentiation with respect to nu has no classical expression:
1143 
1144     >>> expint(nu, z).diff(nu)
1145     -z**(nu - 1)*meijerg(((), (1, 1)), ((0, 0, 1 - nu), ()), z)
1146 
1147     At non-postive integer orders, the exponential integral reduces to the
1148     exponential function:
1149 
1150     >>> expint(0, z)
1151     exp(-z)/z
1152     >>> expint(-1, z)
1153     exp(-z)/z + exp(-z)/z**2
1154 
1155     At half-integers it reduces to error functions:
1156 
1157     >>> expint(S(1)/2, z)
1158     sqrt(pi)*erfc(sqrt(z))/sqrt(z)
1159 
1160     At positive integer orders it can be rewritten in terms of exponentials
1161     and expint(1, z). Use expand_func() to do this:
1162 
1163     >>> from sympy import expand_func
1164     >>> expand_func(expint(5, z))
1165     z**4*expint(1, z)/24 + (-z**3 + z**2 - 2*z + 6)*exp(-z)/24
1166 
1167     The generalised exponential integral is essentially equivalent to the
1168     incomplete gamma function:
1169 
1170     >>> from sympy import uppergamma
1171     >>> expint(nu, z).rewrite(uppergamma)
1172     z**(nu - 1)*uppergamma(1 - nu, z)
1173 
1174     As such it is branched at the origin:
1175 
1176     >>> from sympy import exp_polar, pi, I
1177     >>> expint(4, z*exp_polar(2*pi*I))
1178     I*pi*z**3/3 + expint(4, z)
1179     >>> expint(nu, z*exp_polar(2*pi*I))
1180     z**(nu - 1)*(exp(2*I*pi*nu) - 1)*gamma(1 - nu) + expint(nu, z)
1181 
1182     See Also
1183     ========
1184 
1185     Ei: Another related function called exponential integral.
1186     E1: The classical case, returns expint(1, z).
1187     li: Logarithmic integral.
1188     Li: Offset logarithmic integral.
1189     Si: Sine integral.
1190     Ci: Cosine integral.
1191     Shi: Hyperbolic sine integral.
1192     Chi: Hyperbolic cosine integral.
1193     sympy.functions.special.gamma_functions.uppergamma
1194 
1195     References
1196     ==========
1197 
1198     .. [1] http://dlmf.nist.gov/8.19
1199     .. [2] http://functions.wolfram.com/GammaBetaErf/ExpIntegralE/
1200     .. [3] https://en.wikipedia.org/wiki/Exponential_integral
1201 
1202     """
1203 
1204 
1205     @classmethod
1206     def eval(cls, nu, z):
1207         from sympy import (unpolarify, expand_mul, uppergamma, exp, gamma,
1208                            factorial)
1209         nu2 = unpolarify(nu)
1210         if nu != nu2:
1211             return expint(nu2, z)
1212         if nu.is_Integer and nu <= 0 or (not nu.is_Integer and (2*nu).is_Integer):
1213             return unpolarify(expand_mul(z**(nu - 1)*uppergamma(1 - nu, z)))
1214 
1215         # Extract branching information. This can be deduced from what is
1216         # explained in lowergamma.eval().
1217         z, n = z.extract_branch_factor()
1218         if n == 0:
1219             return
1220         if nu.is_integer:
1221             if not nu > 0:
1222                 return
1223             return expint(nu, z) \
1224                 - 2*pi*I*n*(-1)**(nu - 1)/factorial(nu - 1)*unpolarify(z)**(nu - 1)
1225         else:
1226             return (exp(2*I*pi*nu*n) - 1)*z**(nu - 1)*gamma(1 - nu) + expint(nu, z)
1227 
1228     def fdiff(self, argindex):
1229         from sympy import meijerg
1230         nu, z = self.args
1231         if argindex == 1:
1232             return -z**(nu - 1)*meijerg([], [1, 1], [0, 0, 1 - nu], [], z)
1233         elif argindex == 2:
1234             return -expint(nu - 1, z)
1235         else:
1236             raise ArgumentIndexError(self, argindex)
1237 
1238     def _eval_rewrite_as_uppergamma(self, nu, z, **kwargs):
1239         from sympy import uppergamma
1240         return z**(nu - 1)*uppergamma(1 - nu, z)
1241 
1242     def _eval_rewrite_as_Ei(self, nu, z, **kwargs):
1243         from sympy import exp_polar, unpolarify, exp, factorial
1244         if nu == 1:
1245             return -Ei(z*exp_polar(-I*pi)) - I*pi
1246         elif nu.is_Integer and nu > 1:
1247             # DLMF, 8.19.7
1248             x = -unpolarify(z)
1249             return x**(nu - 1)/factorial(nu - 1)*E1(z).rewrite(Ei) + \
1250                 exp(x)/factorial(nu - 1) * \
1251                 Add(*[factorial(nu - k - 2)*x**k for k in range(nu - 1)])
1252         else:
1253             return self
1254 
1255     def _eval_expand_func(self, **hints):
1256         return self.rewrite(Ei).rewrite(expint, **hints)
1257 
1258     def _eval_rewrite_as_Si(self, nu, z, **kwargs):
1259         if nu != 1:
1260             return self
1261         return Shi(z) - Chi(z)
1262     _eval_rewrite_as_Ci = _eval_rewrite_as_Si
1263     _eval_rewrite_as_Chi = _eval_rewrite_as_Si
1264     _eval_rewrite_as_Shi = _eval_rewrite_as_Si
1265 
1266     def _eval_nseries(self, x, n, logx):
1267         if not self.args[0].has(x):
1268             nu = self.args[0]
1269             if nu == 1:
1270                 f = self._eval_rewrite_as_Si(*self.args)
1271                 return f._eval_nseries(x, n, logx)
1272             elif nu.is_Integer and nu > 1:
1273                 f = self._eval_rewrite_as_Ei(*self.args)
1274                 return f._eval_nseries(x, n, logx)
1275         return super(expint, self)._eval_nseries(x, n, logx)
1276 
1277     def _sage_(self):
1278         import sage.all as sage
1279         return sage.exp_integral_e(self.args[0]._sage_(), self.args[1]._sage_())
1280 
1281 
1282 def E1(z):
1283     """
1284     Classical case of the generalized exponential integral.
1285 
1286     This is equivalent to ``expint(1, z)``.
1287 
1288     See Also
1289     ========
1290 
1291     Ei: Exponential integral.
1292     expint: Generalised exponential integral.
1293     li: Logarithmic integral.
1294     Li: Offset logarithmic integral.
1295     Si: Sine integral.
1296     Ci: Cosine integral.
1297     Shi: Hyperbolic sine integral.
1298     Chi: Hyperbolic cosine integral.
1299     """
1300     return expint(1, z)
1301 
1302 
1303 class li(Function):
1304     r"""
1305     The classical logarithmic integral.
1306 
1307     For the use in SymPy, this function is defined as
1308 
1309     .. math:: \operatorname{li}(x) = \int_0^x \frac{1}{\log(t)} \mathrm{d}t \,.
1310 
1311     Examples
1312     ========
1313 
1314     >>> from sympy import I, oo, li
1315     >>> from sympy.abc import z
1316 
1317     Several special values are known:
1318 
1319     >>> li(0)
1320     0
1321     >>> li(1)
1322     -oo
1323     >>> li(oo)
1324     oo
1325 
1326     Differentiation with respect to z is supported:
1327 
1328     >>> from sympy import diff
1329     >>> diff(li(z), z)
1330     1/log(z)
1331 
1332     Defining the `li` function via an integral:
1333 
1334 
1335     The logarithmic integral can also be defined in terms of Ei:
1336 
1337     >>> from sympy import Ei
1338     >>> li(z).rewrite(Ei)
1339     Ei(log(z))
1340     >>> diff(li(z).rewrite(Ei), z)
1341     1/log(z)
1342 
1343     We can numerically evaluate the logarithmic integral to arbitrary precision
1344     on the whole complex plane (except the singular points):
1345 
1346     >>> li(2).evalf(30)
1347     1.04516378011749278484458888919
1348 
1349     >>> li(2*I).evalf(30)
1350     1.0652795784357498247001125598 + 3.08346052231061726610939702133*I
1351 
1352     We can even compute Soldner's constant by the help of mpmath:
1353 
1354     >>> from mpmath import findroot
1355     >>> findroot(li, 2)
1356     1.45136923488338
1357 
1358     Further transformations include rewriting `li` in terms of
1359     the trigonometric integrals `Si`, `Ci`, `Shi` and `Chi`:
1360 
1361     >>> from sympy import Si, Ci, Shi, Chi
1362     >>> li(z).rewrite(Si)
1363     -log(I*log(z)) - log(1/log(z))/2 + log(log(z))/2 + Ci(I*log(z)) + Shi(log(z))
1364     >>> li(z).rewrite(Ci)
1365     -log(I*log(z)) - log(1/log(z))/2 + log(log(z))/2 + Ci(I*log(z)) + Shi(log(z))
1366     >>> li(z).rewrite(Shi)
1367     -log(1/log(z))/2 + log(log(z))/2 + Chi(log(z)) - Shi(log(z))
1368     >>> li(z).rewrite(Chi)
1369     -log(1/log(z))/2 + log(log(z))/2 + Chi(log(z)) - Shi(log(z))
1370 
1371     See Also
1372     ========
1373 
1374     Li: Offset logarithmic integral.
1375     Ei: Exponential integral.
1376     expint: Generalised exponential integral.
1377     E1: Special case of the generalised exponential integral.
1378     Si: Sine integral.
1379     Ci: Cosine integral.
1380     Shi: Hyperbolic sine integral.
1381     Chi: Hyperbolic cosine integral.
1382 
1383     References
1384     ==========
1385 
1386     .. [1] https://en.wikipedia.org/wiki/Logarithmic_integral
1387     .. [2] http://mathworld.wolfram.com/LogarithmicIntegral.html
1388     .. [3] http://dlmf.nist.gov/6
1389     .. [4] http://mathworld.wolfram.com/SoldnersConstant.html
1390     """
1391 
1392 
1393     @classmethod
1394     def eval(cls, z):
1395         if z is S.Zero:
1396             return S.Zero
1397         elif z is S.One:
1398             return S.NegativeInfinity
1399         elif z is S.Infinity:
1400             return S.Infinity
1401 
1402     def fdiff(self, argindex=1):
1403         arg = self.args[0]
1404         if argindex == 1:
1405             return S.One / log(arg)
1406         else:
1407             raise ArgumentIndexError(self, argindex)
1408 
1409     def _eval_conjugate(self):
1410         z = self.args[0]
1411         # Exclude values on the branch cut (-oo, 0)
1412         if not (z.is_real and z.is_negative):
1413             return self.func(z.conjugate())
1414 
1415     def _eval_rewrite_as_Li(self, z, **kwargs):
1416         return Li(z) + li(2)
1417 
1418     def _eval_rewrite_as_Ei(self, z, **kwargs):
1419         return Ei(log(z))
1420 
1421     def _eval_rewrite_as_uppergamma(self, z, **kwargs):
1422         from sympy import uppergamma
1423         return (-uppergamma(0, -log(z)) +
1424                 S.Half*(log(log(z)) - log(S.One/log(z))) - log(-log(z)))
1425 
1426     def _eval_rewrite_as_Si(self, z, **kwargs):
1427         return (Ci(I*log(z)) - I*Si(I*log(z)) -
1428                 S.Half*(log(S.One/log(z)) - log(log(z))) - log(I*log(z)))
1429 
1430     _eval_rewrite_as_Ci = _eval_rewrite_as_Si
1431 
1432     def _eval_rewrite_as_Shi(self, z, **kwargs):
1433         return (Chi(log(z)) - Shi(log(z)) - S.Half*(log(S.One/log(z)) - log(log(z))))
1434 
1435     _eval_rewrite_as_Chi = _eval_rewrite_as_Shi
1436 
1437     def _eval_rewrite_as_hyper(self, z, **kwargs):
1438         return (log(z)*hyper((1, 1), (2, 2), log(z)) +
1439                 S.Half*(log(log(z)) - log(S.One/log(z))) + S.EulerGamma)
1440 
1441     def _eval_rewrite_as_meijerg(self, z, **kwargs):
1442         return (-log(-log(z)) - S.Half*(log(S.One/log(z)) - log(log(z)))
1443                 - meijerg(((), (1,)), ((0, 0), ()), -log(z)))
1444 
1445     def _eval_rewrite_as_tractable(self, z, **kwargs):
1446         return z * _eis(log(z))
1447 
1448 
1449 class Li(Function):
1450     r"""
1451     The offset logarithmic integral.
1452 
1453     For the use in SymPy, this function is defined as
1454 
1455     .. math:: \operatorname{Li}(x) = \operatorname{li}(x) - \operatorname{li}(2)
1456 
1457     Examples
1458     ========
1459 
1460     >>> from sympy import I, oo, Li
1461     >>> from sympy.abc import z
1462 
1463     The following special value is known:
1464 
1465     >>> Li(2)
1466     0
1467 
1468     Differentiation with respect to z is supported:
1469 
1470     >>> from sympy import diff
1471     >>> diff(Li(z), z)
1472     1/log(z)
1473 
1474     The shifted logarithmic integral can be written in terms of `li(z)`:
1475 
1476     >>> from sympy import li
1477     >>> Li(z).rewrite(li)
1478     li(z) - li(2)
1479 
1480     We can numerically evaluate the logarithmic integral to arbitrary precision
1481     on the whole complex plane (except the singular points):
1482 
1483     >>> Li(2).evalf(30)
1484     0
1485 
1486     >>> Li(4).evalf(30)
1487     1.92242131492155809316615998938
1488 
1489     See Also
1490     ========
1491 
1492     li: Logarithmic integral.
1493     Ei: Exponential integral.
1494     expint: Generalised exponential integral.
1495     E1: Special case of the generalised exponential integral.
1496     Si: Sine integral.
1497     Ci: Cosine integral.
1498     Shi: Hyperbolic sine integral.
1499     Chi: Hyperbolic cosine integral.
1500 
1501     References
1502     ==========
1503 
1504     .. [1] https://en.wikipedia.org/wiki/Logarithmic_integral
1505     .. [2] http://mathworld.wolfram.com/LogarithmicIntegral.html
1506     .. [3] http://dlmf.nist.gov/6
1507     """
1508 
1509 
1510     @classmethod
1511     def eval(cls, z):
1512         if z is S.Infinity:
1513             return S.Infinity
1514         elif z is 2*S.One:
1515             return S.Zero
1516 
1517     def fdiff(self, argindex=1):
1518         arg = self.args[0]
1519         if argindex == 1:
1520             return S.One / log(arg)
1521         else:
1522             raise ArgumentIndexError(self, argindex)
1523 
1524     def _eval_evalf(self, prec):
1525         return self.rewrite(li).evalf(prec)
1526 
1527     def _eval_rewrite_as_li(self, z, **kwargs):
1528         return li(z) - li(2)
1529 
1530     def _eval_rewrite_as_tractable(self, z, **kwargs):
1531         return self.rewrite(li).rewrite("tractable", deep=True)
1532 
1533 ###############################################################################
1534 #################### TRIGONOMETRIC INTEGRALS ##################################
1535 ###############################################################################
1536 
1537 class TrigonometricIntegral(Function):
1538     """ Base class for trigonometric integrals. """
1539 
1540 
1541     @classmethod
1542     def eval(cls, z):
1543         if z == 0:
1544             return cls._atzero
1545         elif z is S.Infinity:
1546             return cls._atinf()
1547         elif z is S.NegativeInfinity:
1548             return cls._atneginf()
1549 
1550         nz = z.extract_multiplicatively(polar_lift(I))
1551         if nz is None and cls._trigfunc(0) == 0:
1552             nz = z.extract_multiplicatively(I)
1553         if nz is not None:
1554             return cls._Ifactor(nz, 1)
1555         nz = z.extract_multiplicatively(polar_lift(-I))
1556         if nz is not None:
1557             return cls._Ifactor(nz, -1)
1558 
1559         nz = z.extract_multiplicatively(polar_lift(-1))
1560         if nz is None and cls._trigfunc(0) == 0:
1561             nz = z.extract_multiplicatively(-1)
1562         if nz is not None:
1563             return cls._minusfactor(nz)
1564 
1565         nz, n = z.extract_branch_factor()
1566         if n == 0 and nz == z:
1567             return
1568         return 2*pi*I*n*cls._trigfunc(0) + cls(nz)
1569 
1570     def fdiff(self, argindex=1):
1571         from sympy import unpolarify
1572         arg = unpolarify(self.args[0])
1573         if argindex == 1:
1574             return self._trigfunc(arg)/arg
1575 
1576     def _eval_rewrite_as_Ei(self, z, **kwargs):
1577         return self._eval_rewrite_as_expint(z).rewrite(Ei)
1578 
1579     def _eval_rewrite_as_uppergamma(self, z, **kwargs):
1580         from sympy import uppergamma
1581         return self._eval_rewrite_as_expint(z).rewrite(uppergamma)
1582 
1583     def _eval_nseries(self, x, n, logx):
1584         # NOTE this is fairly inefficient
1585         from sympy import log, EulerGamma, Pow
1586         n += 1
1587         if self.args[0].subs(x, 0) != 0:
1588             return super(TrigonometricIntegral, self)._eval_nseries(x, n, logx)
1589         baseseries = self._trigfunc(x)._eval_nseries(x, n, logx)
1590         if self._trigfunc(0) != 0:
1591             baseseries -= 1
1592         baseseries = baseseries.replace(Pow, lambda t, n: t**n/n, simultaneous=False)
1593         if self._trigfunc(0) != 0:
1594             baseseries += EulerGamma + log(x)
1595         return baseseries.subs(x, self.args[0])._eval_nseries(x, n, logx)
1596 
1597 
1598 class Si(TrigonometricIntegral):
1599     r"""
1600     Sine integral.
1601 
1602     This function is defined by
1603 
1604     .. math:: \operatorname{Si}(z) = \int_0^z \frac{\sin{t}}{t} \mathrm{d}t.
1605 
1606     It is an entire function.
1607 
1608     Examples
1609     ========
1610 
1611     >>> from sympy import Si
1612     >>> from sympy.abc import z
1613 
1614     The sine integral is an antiderivative of sin(z)/z:
1615 
1616     >>> Si(z).diff(z)
1617     sin(z)/z
1618 
1619     It is unbranched:
1620 
1621     >>> from sympy import exp_polar, I, pi
1622     >>> Si(z*exp_polar(2*I*pi))
1623     Si(z)
1624 
1625     Sine integral behaves much like ordinary sine under multiplication by ``I``:
1626 
1627     >>> Si(I*z)
1628     I*Shi(z)
1629     >>> Si(-z)
1630     -Si(z)
1631 
1632     It can also be expressed in terms of exponential integrals, but beware
1633     that the latter is branched:
1634 
1635     >>> from sympy import expint
1636     >>> Si(z).rewrite(expint)
1637     -I*(-expint(1, z*exp_polar(-I*pi/2))/2 +
1638          expint(1, z*exp_polar(I*pi/2))/2) + pi/2
1639 
1640     It can be rewritten in the form of sinc function (By definition)
1641 
1642     >>> from sympy import sinc
1643     >>> Si(z).rewrite(sinc)
1644     Integral(sinc(t), (t, 0, z))
1645 
1646     See Also
1647     ========
1648 
1649     Ci: Cosine integral.
1650     Shi: Hyperbolic sine integral.
1651     Chi: Hyperbolic cosine integral.
1652     Ei: Exponential integral.
1653     expint: Generalised exponential integral.
1654     sinc: unnormalized sinc function
1655     E1: Special case of the generalised exponential integral.
1656     li: Logarithmic integral.
1657     Li: Offset logarithmic integral.
1658 
1659     References
1660     ==========
1661 
1662     .. [1] https://en.wikipedia.org/wiki/Trigonometric_integral
1663 
1664     """
1665 
1666     _trigfunc = sin
1667     _atzero = S(0)
1668 
1669     @classmethod
1670     def _atinf(cls):
1671         return pi*S.Half
1672 
1673     @classmethod
1674     def _atneginf(cls):
1675         return -pi*S.Half
1676 
1677     @classmethod
1678     def _minusfactor(cls, z):
1679         return -Si(z)
1680 
1681     @classmethod
1682     def _Ifactor(cls, z, sign):
1683         return I*Shi(z)*sign
1684 
1685     def _eval_rewrite_as_expint(self, z, **kwargs):
1686         # XXX should we polarify z?
1687         return pi/2 + (E1(polar_lift(I)*z) - E1(polar_lift(-I)*z))/2/I
1688 
1689     def _eval_rewrite_as_sinc(self, z, **kwargs):
1690         from sympy import Integral
1691         t = Symbol('t', Dummy=True)
1692         return Integral(sinc(t), (t, 0, z))
1693 
1694     def _sage_(self):
1695         import sage.all as sage
1696         return sage.sin_integral(self.args[0]._sage_())
1697 
1698 class Ci(TrigonometricIntegral):
1699     r"""
1700     Cosine integral.
1701 
1702     This function is defined for positive `x` by
1703 
1704     .. math:: \operatorname{Ci}(x) = \gamma + \log{x}
1705                          + \int_0^x \frac{\cos{t} - 1}{t} \mathrm{d}t
1706            = -\int_x^\infty \frac{\cos{t}}{t} \mathrm{d}t,
1707 
1708     where `\gamma` is the Euler-Mascheroni constant.
1709 
1710     We have
1711 
1712     .. math:: \operatorname{Ci}(z) =
1713         -\frac{\operatorname{E}_1\left(e^{i\pi/2} z\right)
1714                + \operatorname{E}_1\left(e^{-i \pi/2} z\right)}{2}
1715 
1716     which holds for all polar `z` and thus provides an analytic
1717     continuation to the Riemann surface of the logarithm.
1718 
1719     The formula also holds as stated
1720     for `z \in \mathbb{C}` with `\Re(z) > 0`.
1721     By lifting to the principal branch we obtain an analytic function on the
1722     cut complex plane.
1723 
1724     Examples
1725     ========
1726 
1727     >>> from sympy import Ci
1728     >>> from sympy.abc import z
1729 
1730     The cosine integral is a primitive of `\cos(z)/z`:
1731 
1732     >>> Ci(z).diff(z)
1733     cos(z)/z
1734 
1735     It has a logarithmic branch point at the origin:
1736 
1737     >>> from sympy import exp_polar, I, pi
1738     >>> Ci(z*exp_polar(2*I*pi))
1739     Ci(z) + 2*I*pi
1740 
1741     The cosine integral behaves somewhat like ordinary `\cos` under multiplication by `i`:
1742 
1743     >>> from sympy import polar_lift
1744     >>> Ci(polar_lift(I)*z)
1745     Chi(z) + I*pi/2
1746     >>> Ci(polar_lift(-1)*z)
1747     Ci(z) + I*pi
1748 
1749     It can also be expressed in terms of exponential integrals:
1750 
1751     >>> from sympy import expint
1752     >>> Ci(z).rewrite(expint)
1753     -expint(1, z*exp_polar(-I*pi/2))/2 - expint(1, z*exp_polar(I*pi/2))/2
1754 
1755     See Also
1756     ========
1757 
1758     Si: Sine integral.
1759     Shi: Hyperbolic sine integral.
1760     Chi: Hyperbolic cosine integral.
1761     Ei: Exponential integral.
1762     expint: Generalised exponential integral.
1763     E1: Special case of the generalised exponential integral.
1764     li: Logarithmic integral.
1765     Li: Offset logarithmic integral.
1766 
1767     References
1768     ==========
1769 
1770     .. [1] https://en.wikipedia.org/wiki/Trigonometric_integral
1771 
1772     """
1773 
1774     _trigfunc = cos
1775     _atzero = S.ComplexInfinity
1776 
1777     @classmethod
1778     def _atinf(cls):
1779         return S.Zero
1780 
1781     @classmethod
1782     def _atneginf(cls):
1783         return I*pi
1784 
1785     @classmethod
1786     def _minusfactor(cls, z):
1787         return Ci(z) + I*pi
1788 
1789     @classmethod
1790     def _Ifactor(cls, z, sign):
1791         return Chi(z) + I*pi/2*sign
1792 
1793     def _eval_rewrite_as_expint(self, z, **kwargs):
1794         return -(E1(polar_lift(I)*z) + E1(polar_lift(-I)*z))/2
1795 
1796     def _sage_(self):
1797         import sage.all as sage
1798         return sage.cos_integral(self.args[0]._sage_())
1799 
1800 
1801 class Shi(TrigonometricIntegral):
1802     r"""
1803     Sinh integral.
1804 
1805     This function is defined by
1806 
1807     .. math:: \operatorname{Shi}(z) = \int_0^z \frac{\sinh{t}}{t} \mathrm{d}t.
1808 
1809     It is an entire function.
1810 
1811     Examples
1812     ========
1813 
1814     >>> from sympy import Shi
1815     >>> from sympy.abc import z
1816 
1817     The Sinh integral is a primitive of `\sinh(z)/z`:
1818 
1819     >>> Shi(z).diff(z)
1820     sinh(z)/z
1821 
1822     It is unbranched:
1823 
1824     >>> from sympy import exp_polar, I, pi
1825     >>> Shi(z*exp_polar(2*I*pi))
1826     Shi(z)
1827 
1828     The `\sinh` integral behaves much like ordinary `\sinh` under multiplication by `i`:
1829 
1830     >>> Shi(I*z)
1831     I*Si(z)
1832     >>> Shi(-z)
1833     -Shi(z)
1834 
1835     It can also be expressed in terms of exponential integrals, but beware
1836     that the latter is branched:
1837 
1838     >>> from sympy import expint
1839     >>> Shi(z).rewrite(expint)
1840     expint(1, z)/2 - expint(1, z*exp_polar(I*pi))/2 - I*pi/2
1841 
1842     See Also
1843     ========
1844 
1845     Si: Sine integral.
1846     Ci: Cosine integral.
1847     Chi: Hyperbolic cosine integral.
1848     Ei: Exponential integral.
1849     expint: Generalised exponential integral.
1850     E1: Special case of the generalised exponential integral.
1851     li: Logarithmic integral.
1852     Li: Offset logarithmic integral.
1853 
1854     References
1855     ==========
1856 
1857     .. [1] https://en.wikipedia.org/wiki/Trigonometric_integral
1858 
1859     """
1860 
1861     _trigfunc = sinh
1862     _atzero = S(0)
1863 
1864     @classmethod
1865     def _atinf(cls):
1866         return S.Infinity
1867 
1868     @classmethod
1869     def _atneginf(cls):
1870         return S.NegativeInfinity
1871 
1872     @classmethod
1873     def _minusfactor(cls, z):
1874         return -Shi(z)
1875 
1876     @classmethod
1877     def _Ifactor(cls, z, sign):
1878         return I*Si(z)*sign
1879 
1880     def _eval_rewrite_as_expint(self, z, **kwargs):
1881         from sympy import exp_polar
1882         # XXX should we polarify z?
1883         return (E1(z) - E1(exp_polar(I*pi)*z))/2 - I*pi/2
1884 
1885     def _sage_(self):
1886         import sage.all as sage
1887         return sage.sinh_integral(self.args[0]._sage_())
1888 
1889 
1890 class Chi(TrigonometricIntegral):
1891     r"""
1892     Cosh integral.
1893 
1894     This function is defined for positive :math:`x` by
1895 
1896     .. math:: \operatorname{Chi}(x) = \gamma + \log{x}
1897                          + \int_0^x \frac{\cosh{t} - 1}{t} \mathrm{d}t,
1898 
1899     where :math:`\gamma` is the Euler-Mascheroni constant.
1900 
1901     We have
1902 
1903     .. math:: \operatorname{Chi}(z) = \operatorname{Ci}\left(e^{i \pi/2}z\right)
1904                          - i\frac{\pi}{2},
1905 
1906     which holds for all polar :math:`z` and thus provides an analytic
1907     continuation to the Riemann surface of the logarithm.
1908     By lifting to the principal branch we obtain an analytic function on the
1909     cut complex plane.
1910 
1911     Examples
1912     ========
1913 
1914     >>> from sympy import Chi
1915     >>> from sympy.abc import z
1916 
1917     The `\cosh` integral is a primitive of `\cosh(z)/z`:
1918 
1919     >>> Chi(z).diff(z)
1920     cosh(z)/z
1921 
1922     It has a logarithmic branch point at the origin:
1923 
1924     >>> from sympy import exp_polar, I, pi
1925     >>> Chi(z*exp_polar(2*I*pi))
1926     Chi(z) + 2*I*pi
1927 
1928     The `\cosh` integral behaves somewhat like ordinary `\cosh` under multiplication by `i`:
1929 
1930     >>> from sympy import polar_lift
1931     >>> Chi(polar_lift(I)*z)
1932     Ci(z) + I*pi/2
1933     >>> Chi(polar_lift(-1)*z)
1934     Chi(z) + I*pi
1935 
1936     It can also be expressed in terms of exponential integrals:
1937 
1938     >>> from sympy import expint
1939     >>> Chi(z).rewrite(expint)
1940     -expint(1, z)/2 - expint(1, z*exp_polar(I*pi))/2 - I*pi/2
1941 
1942     See Also
1943     ========
1944 
1945     Si: Sine integral.
1946     Ci: Cosine integral.
1947     Shi: Hyperbolic sine integral.
1948     Ei: Exponential integral.
1949     expint: Generalised exponential integral.
1950     E1: Special case of the generalised exponential integral.
1951     li: Logarithmic integral.
1952     Li: Offset logarithmic integral.
1953 
1954     References
1955     ==========
1956 
1957     .. [1] https://en.wikipedia.org/wiki/Trigonometric_integral
1958 
1959     """
1960 
1961     _trigfunc = cosh
1962     _atzero = S.ComplexInfinity
1963 
1964     @classmethod
1965     def _atinf(cls):
1966         return S.Infinity
1967 
1968     @classmethod
1969     def _atneginf(cls):
1970         return S.Infinity
1971 
1972     @classmethod
1973     def _minusfactor(cls, z):
1974         return Chi(z) + I*pi
1975 
1976     @classmethod
1977     def _Ifactor(cls, z, sign):
1978         return Ci(z) + I*pi/2*sign
1979 
1980     def _eval_rewrite_as_expint(self, z, **kwargs):
1981         from sympy import exp_polar
1982         return -I*pi/2 - (E1(z) + E1(exp_polar(I*pi)*z))/2
1983 
1984     def _sage_(self):
1985         import sage.all as sage
1986         return sage.cosh_integral(self.args[0]._sage_())
1987 
1988 
1989 ###############################################################################
1990 #################### FRESNEL INTEGRALS ########################################
1991 ###############################################################################
1992 
1993 class FresnelIntegral(Function):
1994     """ Base class for the Fresnel integrals."""
1995 
1996     unbranched = True
1997 
1998     @classmethod
1999     def eval(cls, z):
2000         # Value at zero
2001         if z is S.Zero:
2002             return S(0)
2003 
2004         # Try to pull out factors of -1 and I
2005         prefact = S.One
2006         newarg = z
2007         changed = False
2008 
2009         nz = newarg.extract_multiplicatively(-1)
2010         if nz is not None:
2011             prefact = -prefact
2012             newarg = nz
2013             changed = True
2014 
2015         nz = newarg.extract_multiplicatively(I)
2016         if nz is not None:
2017             prefact = cls._sign*I*prefact
2018             newarg = nz
2019             changed = True
2020 
2021         if changed:
2022             return prefact*cls(newarg)
2023 
2024         # Values at positive infinities signs
2025         # if any were extracted automatically
2026         if z is S.Infinity:
2027             return S.Half
2028         elif z is I*S.Infinity:
2029             return cls._sign*I*S.Half
2030 
2031     def fdiff(self, argindex=1):
2032         if argindex == 1:
2033             return self._trigfunc(S.Half*pi*self.args[0]**2)
2034         else:
2035             raise ArgumentIndexError(self, argindex)
2036 
2037     def _eval_is_real(self):
2038         return self.args[0].is_real
2039 
2040     def _eval_conjugate(self):
2041         return self.func(self.args[0].conjugate())
2042 
2043     def _as_real_imag(self, deep=True, **hints):
2044         if self.args[0].is_real:
2045             if deep:
2046                 hints['complex'] = False
2047                 return (self.expand(deep, **hints), S.Zero)
2048             else:
2049                 return (self, S.Zero)
2050         if deep:
2051             re, im = self.args[0].expand(deep, **hints).as_real_imag()
2052         else:
2053             re, im = self.args[0].as_real_imag()
2054         return (re, im)
2055 
2056     def as_real_imag(self, deep=True, **hints):
2057         # Fresnel S
2058         # http://functions.wolfram.com/06.32.19.0003.01
2059         # http://functions.wolfram.com/06.32.19.0006.01
2060         # Fresnel C
2061         # http://functions.wolfram.com/06.33.19.0003.01
2062         # http://functions.wolfram.com/06.33.19.0006.01
2063         x, y = self._as_real_imag(deep=deep, **hints)
2064         sq = -y**2/x**2
2065         re = S.Half*(self.func(x + x*sqrt(sq)) + self.func(x - x*sqrt(sq)))
2066         im = x/(2*y) * sqrt(sq) * (self.func(x - x*sqrt(sq)) -
2067                 self.func(x + x*sqrt(sq)))
2068         return (re, im)
2069 
2070 
2071 class fresnels(FresnelIntegral):
2072     r"""
2073     Fresnel integral S.
2074 
2075     This function is defined by
2076 
2077     .. math:: \operatorname{S}(z) = \int_0^z \sin{\frac{\pi}{2} t^2} \mathrm{d}t.
2078 
2079     It is an entire function.
2080 
2081     Examples
2082     ========
2083 
2084     >>> from sympy import I, oo, fresnels
2085     >>> from sympy.abc import z
2086 
2087     Several special values are known:
2088 
2089     >>> fresnels(0)
2090     0
2091     >>> fresnels(oo)
2092     1/2
2093     >>> fresnels(-oo)
2094     -1/2
2095     >>> fresnels(I*oo)
2096     -I/2
2097     >>> fresnels(-I*oo)
2098     I/2
2099 
2100     In general one can pull out factors of -1 and `i` from the argument:
2101 
2102     >>> fresnels(-z)
2103     -fresnels(z)
2104     >>> fresnels(I*z)
2105     -I*fresnels(z)
2106 
2107     The Fresnel S integral obeys the mirror symmetry
2108     `\overline{S(z)} = S(\bar{z})`:
2109 
2110     >>> from sympy import conjugate
2111     >>> conjugate(fresnels(z))
2112     fresnels(conjugate(z))
2113 
2114     Differentiation with respect to `z` is supported:
2115 
2116     >>> from sympy import diff
2117     >>> diff(fresnels(z), z)
2118     sin(pi*z**2/2)
2119 
2120     Defining the Fresnel functions via an integral
2121 
2122     >>> from sympy import integrate, pi, sin, gamma, expand_func
2123     >>> integrate(sin(pi*z**2/2), z)
2124     3*fresnels(z)*gamma(3/4)/(4*gamma(7/4))
2125     >>> expand_func(integrate(sin(pi*z**2/2), z))
2126     fresnels(z)
2127 
2128     We can numerically evaluate the Fresnel integral to arbitrary precision
2129     on the whole complex plane:
2130 
2131     >>> fresnels(2).evalf(30)
2132     0.343415678363698242195300815958
2133 
2134     >>> fresnels(-2*I).evalf(30)
2135     0.343415678363698242195300815958*I
2136 
2137     See Also
2138     ========
2139 
2140     fresnelc: Fresnel cosine integral.
2141 
2142     References
2143     ==========
2144 
2145     .. [1] https://en.wikipedia.org/wiki/Fresnel_integral
2146     .. [2] http://dlmf.nist.gov/7
2147     .. [3] http://mathworld.wolfram.com/FresnelIntegrals.html
2148     .. [4] http://functions.wolfram.com/GammaBetaErf/FresnelS
2149     .. [5] The converging factors for the fresnel integrals
2150             by John W. Wrench Jr. and Vicki Alley
2151 
2152     """
2153     _trigfunc = sin
2154     _sign = -S.One
2155 
2156     @staticmethod
2157     @cacheit
2158     def taylor_term(n, x, *previous_terms):
2159         if n < 0:
2160             return S.Zero
2161         else:
2162             x = sympify(x)
2163             if len(previous_terms) > 1:
2164                 p = previous_terms[-1]
2165                 return (-pi**2*x**4*(4*n - 1)/(8*n*(2*n + 1)*(4*n + 3))) * p
2166             else:
2167                 return x**3 * (-x**4)**n * (S(2)**(-2*n - 1)*pi**(2*n + 1)) / ((4*n + 3)*factorial(2*n + 1))
2168 
2169     def _eval_rewrite_as_erf(self, z, **kwargs):
2170         return (S.One + I)/4 * (erf((S.One + I)/2*sqrt(pi)*z) - I*erf((S.One - I)/2*sqrt(pi)*z))
2171 
2172     def _eval_rewrite_as_hyper(self, z, **kwargs):
2173         return pi*z**3/6 * hyper([S(3)/4], [S(3)/2, S(7)/4], -pi**2*z**4/16)
2174 
2175     def _eval_rewrite_as_meijerg(self, z, **kwargs):
2176         return (pi*z**(S(9)/4) / (sqrt(2)*(z**2)**(S(3)/4)*(-z)**(S(3)/4))
2177                 * meijerg([], [1], [S(3)/4], [S(1)/4, 0], -pi**2*z**4/16))
2178 
2179     def _eval_aseries(self, n, args0, x, logx):
2180         from sympy import Order
2181         point = args0[0]
2182 
2183         # Expansion at oo and -oo
2184         if point in [S.Infinity, -S.Infinity]:
2185             z = self.args[0]
2186 
2187             # expansion of S(x) = S1(x*sqrt(pi/2)), see reference[5] page 1-8
2188             # as only real infinities are dealt with, sin and cos are O(1)
2189             p = [(-1)**k * factorial(4*k + 1) /
2190                  (2**(2*k + 2) * z**(4*k + 3) * 2**(2*k)*factorial(2*k))
2191                  for k in range(0, n) if 4*k + 3 < n]
2192             q = [1/(2*z)] + [(-1)**k * factorial(4*k - 1) /
2193                  (2**(2*k + 1) * z**(4*k + 1) * 2**(2*k - 1)*factorial(2*k - 1))
2194                  for k in range(1, n) if 4*k + 1 < n]
2195 
2196             p = [-sqrt(2/pi)*t for t in p]
2197             q = [-sqrt(2/pi)*t for t in q]
2198             s = 1 if point is S.Infinity else -1
2199             # The expansion at oo is 1/2 + some odd powers of z
2200             # To get the expansion at -oo, replace z by -z and flip the sign
2201             # The result -1/2 + the same odd powers of z as before.
2202             return s*S.Half + (sin(z**2)*Add(*p) + cos(z**2)*Add(*q)
2203                 ).subs(x, sqrt(2/pi)*x) + Order(1/z**n, x)
2204 
2205         # All other points are not handled
2206         return super(fresnels, self)._eval_aseries(n, args0, x, logx)
2207 
2208 
2209 class fresnelc(FresnelIntegral):
2210     r"""
2211     Fresnel integral C.
2212 
2213     This function is defined by
2214 
2215     .. math:: \operatorname{C}(z) = \int_0^z \cos{\frac{\pi}{2} t^2} \mathrm{d}t.
2216 
2217     It is an entire function.
2218 
2219     Examples
2220     ========
2221 
2222     >>> from sympy import I, oo, fresnelc
2223     >>> from sympy.abc import z
2224 
2225     Several special values are known:
2226 
2227     >>> fresnelc(0)
2228     0
2229     >>> fresnelc(oo)
2230     1/2
2231     >>> fresnelc(-oo)
2232     -1/2
2233     >>> fresnelc(I*oo)
2234     I/2
2235     >>> fresnelc(-I*oo)
2236     -I/2
2237 
2238     In general one can pull out factors of -1 and `i` from the argument:
2239 
2240     >>> fresnelc(-z)
2241     -fresnelc(z)
2242     >>> fresnelc(I*z)
2243     I*fresnelc(z)
2244 
2245     The Fresnel C integral obeys the mirror symmetry
2246     `\overline{C(z)} = C(\bar{z})`:
2247 
2248     >>> from sympy import conjugate
2249     >>> conjugate(fresnelc(z))
2250     fresnelc(conjugate(z))
2251 
2252     Differentiation with respect to `z` is supported:
2253 
2254     >>> from sympy import diff
2255     >>> diff(fresnelc(z), z)
2256     cos(pi*z**2/2)
2257 
2258     Defining the Fresnel functions via an integral
2259 
2260     >>> from sympy import integrate, pi, cos, gamma, expand_func
2261     >>> integrate(cos(pi*z**2/2), z)
2262     fresnelc(z)*gamma(1/4)/(4*gamma(5/4))
2263     >>> expand_func(integrate(cos(pi*z**2/2), z))
2264     fresnelc(z)
2265 
2266     We can numerically evaluate the Fresnel integral to arbitrary precision
2267     on the whole complex plane:
2268 
2269     >>> fresnelc(2).evalf(30)
2270     0.488253406075340754500223503357
2271 
2272     >>> fresnelc(-2*I).evalf(30)
2273     -0.488253406075340754500223503357*I
2274 
2275     See Also
2276     ========
2277 
2278     fresnels: Fresnel sine integral.
2279 
2280     References
2281     ==========
2282 
2283     .. [1] https://en.wikipedia.org/wiki/Fresnel_integral
2284     .. [2] http://dlmf.nist.gov/7
2285     .. [3] http://mathworld.wolfram.com/FresnelIntegrals.html
2286     .. [4] http://functions.wolfram.com/GammaBetaErf/FresnelC
2287     .. [5] The converging factors for the fresnel integrals
2288             by John W. Wrench Jr. and Vicki Alley
2289     """
2290     _trigfunc = cos
2291     _sign = S.One
2292 
2293     @staticmethod
2294     @cacheit
2295     def taylor_term(n, x, *previous_terms):
2296         if n < 0:
2297             return S.Zero
2298         else:
2299             x = sympify(x)
2300             if len(previous_terms) > 1:
2301                 p = previous_terms[-1]
2302                 return (-pi**2*x**4*(4*n - 3)/(8*n*(2*n - 1)*(4*n + 1))) * p
2303             else:
2304                 return x * (-x**4)**n * (S(2)**(-2*n)*pi**(2*n)) / ((4*n + 1)*factorial(2*n))
2305 
2306     def _eval_rewrite_as_erf(self, z, **kwargs):
2307         return (S.One - I)/4 * (erf((S.One + I)/2*sqrt(pi)*z) + I*erf((S.One - I)/2*sqrt(pi)*z))
2308 
2309     def _eval_rewrite_as_hyper(self, z, **kwargs):
2310         return z * hyper([S.One/4], [S.One/2, S(5)/4], -pi**2*z**4/16)
2311 
2312     def _eval_rewrite_as_meijerg(self, z, **kwargs):
2313         return (pi*z**(S(3)/4) / (sqrt(2)*root(z**2, 4)*root(-z, 4))
2314                 * meijerg([], [1], [S(1)/4], [S(3)/4, 0], -pi**2*z**4/16))
2315 
2316     def _eval_aseries(self, n, args0, x, logx):
2317         from sympy import Order
2318         point = args0[0]
2319 
2320         # Expansion at oo
2321         if point in [S.Infinity, -S.Infinity]:
2322             z = self.args[0]
2323 
2324             # expansion of C(x) = C1(x*sqrt(pi/2)), see reference[5] page 1-8
2325             # as only real infinities are dealt with, sin and cos are O(1)
2326             p = [(-1)**k * factorial(4*k + 1) /
2327                  (2**(2*k + 2) * z**(4*k + 3) * 2**(2*k)*factorial(2*k))
2328                  for k in range(0, n) if 4*k + 3 < n]
2329             q = [1/(2*z)] + [(-1)**k * factorial(4*k - 1) /
2330                  (2**(2*k + 1) * z**(4*k + 1) * 2**(2*k - 1)*factorial(2*k - 1))
2331                  for k in range(1, n) if 4*k + 1 < n]
2332 
2333             p = [-sqrt(2/pi)*t for t in p]
2334             q = [ sqrt(2/pi)*t for t in q]
2335             s = 1 if point is S.Infinity else -1
2336             # The expansion at oo is 1/2 + some odd powers of z
2337             # To get the expansion at -oo, replace z by -z and flip the sign
2338             # The result -1/2 + the same odd powers of z as before.
2339             return s*S.Half + (cos(z**2)*Add(*p) + sin(z**2)*Add(*q)
2340                 ).subs(x, sqrt(2/pi)*x) + Order(1/z**n, x)
2341 
2342         # All other points are not handled
2343         return super(fresnelc, self)._eval_aseries(n, args0, x, logx)
2344 
2345 
2346 ###############################################################################
2347 #################### HELPER FUNCTIONS #########################################
2348 ###############################################################################
2349 
2350 
2351 class _erfs(Function):
2352     """
2353     Helper function to make the `\\mathrm{erf}(z)` function
2354     tractable for the Gruntz algorithm.
2355     """
2356 
2357 
2358     def _eval_aseries(self, n, args0, x, logx):
2359         from sympy import Order
2360         point = args0[0]
2361 
2362         # Expansion at oo
2363         if point is S.Infinity:
2364             z = self.args[0]
2365             l = [ 1/sqrt(S.Pi) * factorial(2*k)*(-S(
2366                 4))**(-k)/factorial(k) * (1/z)**(2*k + 1) for k in range(0, n) ]
2367             o = Order(1/z**(2*n + 1), x)
2368             # It is very inefficient to first add the order and then do the nseries
2369             return (Add(*l))._eval_nseries(x, n, logx) + o
2370 
2371         # Expansion at I*oo
2372         t = point.extract_multiplicatively(S.ImaginaryUnit)
2373         if t is S.Infinity:
2374             z = self.args[0]
2375             # TODO: is the series really correct?
2376             l = [ 1/sqrt(S.Pi) * factorial(2*k)*(-S(
2377                 4))**(-k)/factorial(k) * (1/z)**(2*k + 1) for k in range(0, n) ]
2378             o = Order(1/z**(2*n + 1), x)
2379             # It is very inefficient to first add the order and then do the nseries
2380             return (Add(*l))._eval_nseries(x, n, logx) + o
2381 
2382         # All other points are not handled
2383         return super(_erfs, self)._eval_aseries(n, args0, x, logx)
2384 
2385     def fdiff(self, argindex=1):
2386         if argindex == 1:
2387             z = self.args[0]
2388             return -2/sqrt(S.Pi) + 2*z*_erfs(z)
2389         else:
2390             raise ArgumentIndexError(self, argindex)
2391 
2392     def _eval_rewrite_as_intractable(self, z, **kwargs):
2393         return (S.One - erf(z))*exp(z**2)
2394 
2395 
2396 class _eis(Function):
2397     """
2398     Helper function to make the `\\mathrm{Ei}(z)` and `\\mathrm{li}(z)` functions
2399     tractable for the Gruntz algorithm.
2400     """
2401 
2402 
2403     def _eval_aseries(self, n, args0, x, logx):
2404         from sympy import Order
2405         if args0[0] != S.Infinity:
2406             return super(_erfs, self)._eval_aseries(n, args0, x, logx)
2407 
2408         z = self.args[0]
2409         l = [ factorial(k) * (1/z)**(k + 1) for k in range(0, n) ]
2410         o = Order(1/z**(n + 1), x)
2411         # It is very inefficient to first add the order and then do the nseries
2412         return (Add(*l))._eval_nseries(x, n, logx) + o
2413 
2414 
2415     def fdiff(self, argindex=1):
2416         if argindex == 1:
2417             z = self.args[0]
2418             return S.One / z - _eis(z)
2419         else:
2420             raise ArgumentIndexError(self, argindex)
2421 
2422     def _eval_rewrite_as_intractable(self, z, **kwargs):
2423         return exp(-z)*Ei(z)
2424 
2425     def _eval_nseries(self, x, n, logx):
2426         x0 = self.args[0].limit(x, 0)
2427         if x0 is S.Zero:
2428             f = self._eval_rewrite_as_intractable(*self.args)
2429             return f._eval_nseries(x, n, logx)
2430         return super(_eis, self)._eval_nseries(x, n, logx)

</code><intended_behavior>The use of \mathrm within the error functions (i.e., _erfs and _eis classes) is consistent but not configurable. To resolve the issue, either maintain the use of \mathrm as the standard due to its simplicity and lack of additional package dependencies or introduce a helper function/utility method within this file (or at a more global scope accessible by this file) that abstracts away the choice between \text and \mathrm. This method should allow for configuration at the library level, determining which command to use based on user preference or a global setting. The existing functionality of rendering mathematical expressions accurately should be preserved, with added flexibility for font adaptiveness where required.</intended_behavior>, <file>sympy/integrals/meijerint_doc.py</file>
<class>None</class>
<method>None</method>
<code>
1 """ This module cooks up a docstring when imported. Its only purpose is to
2     be displayed in the sphinx documentation. """
3 
4 from __future__ import print_function, division
5 
6 from sympy.integrals.meijerint import _create_lookup_table
7 from sympy import latex, Eq, Add, Symbol
8 
9 t = {}
10 _create_lookup_table(t)
11 
12 doc = ""
13 
14 for about, category in sorted(t.items()):
15     if about == ():
16         doc += 'Elementary functions:\n\n'
17     else:
18         doc += 'Functions involving ' + ', '.join('`%s`' % latex(
19             list(category[0][0].atoms(func))[0]) for func in about) + ':\n\n'
20     for formula, gs, cond, hint in category:
21         if not isinstance(gs, list):
22             g = Symbol('\\text{generated}')
23         else:
24             g = Add(*[fac*f for (fac, f) in gs])
25         obj = Eq(formula, g)
26         if cond is True:
27             cond = ""
28         else:
29             cond = ',\\text{ if } %s' % latex(cond)
30         doc += ".. math::\n  %s%s\n\n" % (latex(obj), cond)
31 
32 __doc__ = doc

</code><intended_behavior>Here, the \text command is used to adapt the font of textual content within mathematical expressions in dynamic documentation. The intended behavior should ensure that any conditional statements or symbols added to the documentation continue to match the style of the surrounding maths content. Implementing a similar helper function/utility method that chooses between \text and \mathrm based on a configurable setting would standardize the approach and potentially enhance adaptability. This utility method should be used wherever such textual content is integrated with mathematical expressions to ensure consistency and configurability throughout the project. The method should default to \text to preserve the adaptiveness with the math font but allow for \mathrm if specified by the user or the project settings.</intended_behavior>]
2025-10-18 20:06:00.364 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-18 20:06:00.364 | INFO     | Search-only: skipping patch selection
2025-10-18 20:06:00.491 | INFO     | Task sympy__sympy-16056 completed successfully.
2025-10-18 20:06:00.492 | INFO     | No patch generated. You can try running ACR again.
