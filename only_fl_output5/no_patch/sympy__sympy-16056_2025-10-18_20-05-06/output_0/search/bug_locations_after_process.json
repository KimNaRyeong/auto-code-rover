[
    {
        "rel_file_path": "sympy/functions/special/error_functions.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sympy__sympy/setup_sympy__sympy__1.4/sympy/functions/special/error_functions.py",
        "start": 1,
        "end": 2430,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\" This module contains various functions that are special cases\n2     of incomplete gamma functions. It should probably be renamed. \"\"\"\n3 \n4 from __future__ import print_function, division\n5 \n6 from sympy.core import Add, S, sympify, cacheit, pi, I\n7 from sympy.core.compatibility import range\n8 from sympy.core.function import Function, ArgumentIndexError\n9 from sympy.core.symbol import Symbol\n10 from sympy.functions.combinatorial.factorials import factorial\n11 from sympy.functions.elementary.integers import floor\n12 from sympy.functions.elementary.miscellaneous import sqrt, root\n13 from sympy.functions.elementary.exponential import exp, log\n14 from sympy.functions.elementary.complexes import polar_lift\n15 from sympy.functions.elementary.hyperbolic import cosh, sinh\n16 from sympy.functions.elementary.trigonometric import cos, sin, sinc\n17 from sympy.functions.special.hyper import hyper, meijerg\n18 \n19 # TODO series expansions\n20 # TODO see the \"Note:\" in Ei\n21 \n22 ###############################################################################\n23 ################################ ERROR FUNCTION ###############################\n24 ###############################################################################\n25 \n26 \n27 class erf(Function):\n28     r\"\"\"\n29     The Gauss error function. This function is defined as:\n30 \n31     .. math ::\n32         \\mathrm{erf}(x) = \\frac{2}{\\sqrt{\\pi}} \\int_0^x e^{-t^2} \\mathrm{d}t.\n33 \n34     Examples\n35     ========\n36 \n37     >>> from sympy import I, oo, erf\n38     >>> from sympy.abc import z\n39 \n40     Several special values are known:\n41 \n42     >>> erf(0)\n43     0\n44     >>> erf(oo)\n45     1\n46     >>> erf(-oo)\n47     -1\n48     >>> erf(I*oo)\n49     oo*I\n50     >>> erf(-I*oo)\n51     -oo*I\n52 \n53     In general one can pull out factors of -1 and I from the argument:\n54 \n55     >>> erf(-z)\n56     -erf(z)\n57 \n58     The error function obeys the mirror symmetry:\n59 \n60     >>> from sympy import conjugate\n61     >>> conjugate(erf(z))\n62     erf(conjugate(z))\n63 \n64     Differentiation with respect to z is supported:\n65 \n66     >>> from sympy import diff\n67     >>> diff(erf(z), z)\n68     2*exp(-z**2)/sqrt(pi)\n69 \n70     We can numerically evaluate the error function to arbitrary precision\n71     on the whole complex plane:\n72 \n73     >>> erf(4).evalf(30)\n74     0.999999984582742099719981147840\n75 \n76     >>> erf(-4*I).evalf(30)\n77     -1296959.73071763923152794095062*I\n78 \n79     See Also\n80     ========\n81 \n82     erfc: Complementary error function.\n83     erfi: Imaginary error function.\n84     erf2: Two-argument error function.\n85     erfinv: Inverse error function.\n86     erfcinv: Inverse Complementary error function.\n87     erf2inv: Inverse two-argument error function.\n88 \n89     References\n90     ==========\n91 \n92     .. [1] https://en.wikipedia.org/wiki/Error_function\n93     .. [2] http://dlmf.nist.gov/7\n94     .. [3] http://mathworld.wolfram.com/Erf.html\n95     .. [4] http://functions.wolfram.com/GammaBetaErf/Erf\n96     \"\"\"\n97 \n98     unbranched = True\n99 \n100     def fdiff(self, argindex=1):\n101         if argindex == 1:\n102             return 2*exp(-self.args[0]**2)/sqrt(S.Pi)\n103         else:\n104             raise ArgumentIndexError(self, argindex)\n105 \n106 \n107     def inverse(self, argindex=1):\n108         \"\"\"\n109         Returns the inverse of this function.\n110         \"\"\"\n111         return erfinv\n112 \n113     @classmethod\n114     def eval(cls, arg):\n115         if arg.is_Number:\n116             if arg is S.NaN:\n117                 return S.NaN\n118             elif arg is S.Infinity:\n119                 return S.One\n120             elif arg is S.NegativeInfinity:\n121                 return S.NegativeOne\n122             elif arg is S.Zero:\n123                 return S.Zero\n124 \n125         if isinstance(arg, erfinv):\n126              return arg.args[0]\n127 \n128         if isinstance(arg, erfcinv):\n129             return S.One - arg.args[0]\n130 \n131         if isinstance(arg, erf2inv) and arg.args[0] is S.Zero:\n132             return arg.args[1]\n133 \n134         # Try to pull out factors of I\n135         t = arg.extract_multiplicatively(S.ImaginaryUnit)\n136         if t is S.Infinity or t is S.NegativeInfinity:\n137             return arg\n138 \n139         # Try to pull out factors of -1\n140         if arg.could_extract_minus_sign():\n141             return -cls(-arg)\n142 \n143     @staticmethod\n144     @cacheit\n145     def taylor_term(n, x, *previous_terms):\n146         if n < 0 or n % 2 == 0:\n147             return S.Zero\n148         else:\n149             x = sympify(x)\n150             k = floor((n - 1)/S(2))\n151             if len(previous_terms) > 2:\n152                 return -previous_terms[-2] * x**2 * (n - 2)/(n*k)\n153             else:\n154                 return 2*(-1)**k * x**n/(n*factorial(k)*sqrt(S.Pi))\n155 \n156     def _eval_conjugate(self):\n157         return self.func(self.args[0].conjugate())\n158 \n159     def _eval_is_real(self):\n160         return self.args[0].is_real\n161 \n162     def _eval_rewrite_as_uppergamma(self, z, **kwargs):\n163         from sympy import uppergamma\n164         return sqrt(z**2)/z*(S.One - uppergamma(S.Half, z**2)/sqrt(S.Pi))\n165 \n166     def _eval_rewrite_as_fresnels(self, z, **kwargs):\n167         arg = (S.One - S.ImaginaryUnit)*z/sqrt(pi)\n168         return (S.One + S.ImaginaryUnit)*(fresnelc(arg) - I*fresnels(arg))\n169 \n170     def _eval_rewrite_as_fresnelc(self, z, **kwargs):\n171         arg = (S.One - S.ImaginaryUnit)*z/sqrt(pi)\n172         return (S.One + S.ImaginaryUnit)*(fresnelc(arg) - I*fresnels(arg))\n173 \n174     def _eval_rewrite_as_meijerg(self, z, **kwargs):\n175         return z/sqrt(pi)*meijerg([S.Half], [], [0], [-S.Half], z**2)\n176 \n177     def _eval_rewrite_as_hyper(self, z, **kwargs):\n178         return 2*z/sqrt(pi)*hyper([S.Half], [3*S.Half], -z**2)\n179 \n180     def _eval_rewrite_as_expint(self, z, **kwargs):\n181         return sqrt(z**2)/z - z*expint(S.Half, z**2)/sqrt(S.Pi)\n182 \n183     def _eval_rewrite_as_tractable(self, z, **kwargs):\n184         return S.One - _erfs(z)*exp(-z**2)\n185 \n186     def _eval_rewrite_as_erfc(self, z, **kwargs):\n187         return S.One - erfc(z)\n188 \n189     def _eval_rewrite_as_erfi(self, z, **kwargs):\n190         return -I*erfi(I*z)\n191 \n192     def _eval_as_leading_term(self, x):\n193         from sympy import Order\n194         arg = self.args[0].as_leading_term(x)\n195 \n196         if x in arg.free_symbols and Order(1, x).contains(arg):\n197             return 2*x/sqrt(pi)\n198         else:\n199             return self.func(arg)\n200 \n201     def as_real_imag(self, deep=True, **hints):\n202         if self.args[0].is_real:\n203             if deep:\n204                 hints['complex'] = False\n205                 return (self.expand(deep, **hints), S.Zero)\n206             else:\n207                 return (self, S.Zero)\n208         if deep:\n209             x, y = self.args[0].expand(deep, **hints).as_real_imag()\n210         else:\n211             x, y = self.args[0].as_real_imag()\n212 \n213         sq = -y**2/x**2\n214         re = S.Half*(self.func(x + x*sqrt(sq)) + self.func(x - x*sqrt(sq)))\n215         im = x/(2*y) * sqrt(sq) * (self.func(x - x*sqrt(sq)) -\n216                     self.func(x + x*sqrt(sq)))\n217         return (re, im)\n218 \n219 \n220 class erfc(Function):\n221     r\"\"\"\n222     Complementary Error Function. The function is defined as:\n223 \n224     .. math ::\n225         \\mathrm{erfc}(x) = \\frac{2}{\\sqrt{\\pi}} \\int_x^\\infty e^{-t^2} \\mathrm{d}t\n226 \n227     Examples\n228     ========\n229 \n230     >>> from sympy import I, oo, erfc\n231     >>> from sympy.abc import z\n232 \n233     Several special values are known:\n234 \n235     >>> erfc(0)\n236     1\n237     >>> erfc(oo)\n238     0\n239     >>> erfc(-oo)\n240     2\n241     >>> erfc(I*oo)\n242     -oo*I\n243     >>> erfc(-I*oo)\n244     oo*I\n245 \n246     The error function obeys the mirror symmetry:\n247 \n248     >>> from sympy import conjugate\n249     >>> conjugate(erfc(z))\n250     erfc(conjugate(z))\n251 \n252     Differentiation with respect to z is supported:\n253 \n254     >>> from sympy import diff\n255     >>> diff(erfc(z), z)\n256     -2*exp(-z**2)/sqrt(pi)\n257 \n258     It also follows\n259 \n260     >>> erfc(-z)\n261     2 - erfc(z)\n262 \n263     We can numerically evaluate the complementary error function to arbitrary precision\n264     on the whole complex plane:\n265 \n266     >>> erfc(4).evalf(30)\n267     0.0000000154172579002800188521596734869\n268 \n269     >>> erfc(4*I).evalf(30)\n270     1.0 - 1296959.73071763923152794095062*I\n271 \n272     See Also\n273     ========\n274 \n275     erf: Gaussian error function.\n276     erfi: Imaginary error function.\n277     erf2: Two-argument error function.\n278     erfinv: Inverse error function.\n279     erfcinv: Inverse Complementary error function.\n280     erf2inv: Inverse two-argument error function.\n281 \n282     References\n283     ==========\n284 \n285     .. [1] https://en.wikipedia.org/wiki/Error_function\n286     .. [2] http://dlmf.nist.gov/7\n287     .. [3] http://mathworld.wolfram.com/Erfc.html\n288     .. [4] http://functions.wolfram.com/GammaBetaErf/Erfc\n289     \"\"\"\n290 \n291     unbranched = True\n292 \n293     def fdiff(self, argindex=1):\n294         if argindex == 1:\n295             return -2*exp(-self.args[0]**2)/sqrt(S.Pi)\n296         else:\n297             raise ArgumentIndexError(self, argindex)\n298 \n299     def inverse(self, argindex=1):\n300         \"\"\"\n301         Returns the inverse of this function.\n302         \"\"\"\n303         return erfcinv\n304 \n305     @classmethod\n306     def eval(cls, arg):\n307         if arg.is_Number:\n308             if arg is S.NaN:\n309                 return S.NaN\n310             elif arg is S.Infinity:\n311                 return S.Zero\n312             elif arg is S.Zero:\n313                 return S.One\n314 \n315         if isinstance(arg, erfinv):\n316             return S.One - arg.args[0]\n317 \n318         if isinstance(arg, erfcinv):\n319             return arg.args[0]\n320 \n321         # Try to pull out factors of I\n322         t = arg.extract_multiplicatively(S.ImaginaryUnit)\n323         if t is S.Infinity or t is S.NegativeInfinity:\n324             return -arg\n325 \n326         # Try to pull out factors of -1\n327         if arg.could_extract_minus_sign():\n328             return S(2) - cls(-arg)\n329 \n330     @staticmethod\n331     @cacheit\n332     def taylor_term(n, x, *previous_terms):\n333         if n == 0:\n334             return S.One\n335         elif n < 0 or n % 2 == 0:\n336             return S.Zero\n337         else:\n338             x = sympify(x)\n339             k = floor((n - 1)/S(2))\n340             if len(previous_terms) > 2:\n341                 return -previous_terms[-2] * x**2 * (n - 2)/(n*k)\n342             else:\n343                 return -2*(-1)**k * x**n/(n*factorial(k)*sqrt(S.Pi))\n344 \n345     def _eval_conjugate(self):\n346         return self.func(self.args[0].conjugate())\n347 \n348     def _eval_is_real(self):\n349         return self.args[0].is_real\n350 \n351     def _eval_rewrite_as_tractable(self, z, **kwargs):\n352         return self.rewrite(erf).rewrite(\"tractable\", deep=True)\n353 \n354     def _eval_rewrite_as_erf(self, z, **kwargs):\n355         return S.One - erf(z)\n356 \n357     def _eval_rewrite_as_erfi(self, z, **kwargs):\n358         return S.One + I*erfi(I*z)\n359 \n360     def _eval_rewrite_as_fresnels(self, z, **kwargs):\n361         arg = (S.One - S.ImaginaryUnit)*z/sqrt(pi)\n362         return S.One - (S.One + S.ImaginaryUnit)*(fresnelc(arg) - I*fresnels(arg))\n363 \n364     def _eval_rewrite_as_fresnelc(self, z, **kwargs):\n365         arg = (S.One-S.ImaginaryUnit)*z/sqrt(pi)\n366         return S.One - (S.One + S.ImaginaryUnit)*(fresnelc(arg) - I*fresnels(arg))\n367 \n368     def _eval_rewrite_as_meijerg(self, z, **kwargs):\n369         return S.One - z/sqrt(pi)*meijerg([S.Half], [], [0], [-S.Half], z**2)\n370 \n371     def _eval_rewrite_as_hyper(self, z, **kwargs):\n372         return S.One - 2*z/sqrt(pi)*hyper([S.Half], [3*S.Half], -z**2)\n373 \n374     def _eval_rewrite_as_uppergamma(self, z, **kwargs):\n375         from sympy import uppergamma\n376         return S.One - sqrt(z**2)/z*(S.One - uppergamma(S.Half, z**2)/sqrt(S.Pi))\n377 \n378     def _eval_rewrite_as_expint(self, z, **kwargs):\n379         return S.One - sqrt(z**2)/z + z*expint(S.Half, z**2)/sqrt(S.Pi)\n380 \n381     def _eval_expand_func(self, **hints):\n382         return self.rewrite(erf)\n383 \n384     def _eval_as_leading_term(self, x):\n385         from sympy import Order\n386         arg = self.args[0].as_leading_term(x)\n387 \n388         if x in arg.free_symbols and Order(1, x).contains(arg):\n389             return S.One\n390         else:\n391             return self.func(arg)\n392 \n393     def as_real_imag(self, deep=True, **hints):\n394         if self.args[0].is_real:\n395             if deep:\n396                 hints['complex'] = False\n397                 return (self.expand(deep, **hints), S.Zero)\n398             else:\n399                 return (self, S.Zero)\n400         if deep:\n401             x, y = self.args[0].expand(deep, **hints).as_real_imag()\n402         else:\n403             x, y = self.args[0].as_real_imag()\n404 \n405         sq = -y**2/x**2\n406         re = S.Half*(self.func(x + x*sqrt(sq)) + self.func(x - x*sqrt(sq)))\n407         im = x/(2*y) * sqrt(sq) * (self.func(x - x*sqrt(sq)) -\n408                     self.func(x + x*sqrt(sq)))\n409         return (re, im)\n410 \n411 class erfi(Function):\n412     r\"\"\"\n413     Imaginary error function. The function erfi is defined as:\n414 \n415     .. math ::\n416         \\mathrm{erfi}(x) = \\frac{2}{\\sqrt{\\pi}} \\int_0^x e^{t^2} \\mathrm{d}t\n417 \n418     Examples\n419     ========\n420 \n421     >>> from sympy import I, oo, erfi\n422     >>> from sympy.abc import z\n423 \n424     Several special values are known:\n425 \n426     >>> erfi(0)\n427     0\n428     >>> erfi(oo)\n429     oo\n430     >>> erfi(-oo)\n431     -oo\n432     >>> erfi(I*oo)\n433     I\n434     >>> erfi(-I*oo)\n435     -I\n436 \n437     In general one can pull out factors of -1 and I from the argument:\n438 \n439     >>> erfi(-z)\n440     -erfi(z)\n441 \n442     >>> from sympy import conjugate\n443     >>> conjugate(erfi(z))\n444     erfi(conjugate(z))\n445 \n446     Differentiation with respect to z is supported:\n447 \n448     >>> from sympy import diff\n449     >>> diff(erfi(z), z)\n450     2*exp(z**2)/sqrt(pi)\n451 \n452     We can numerically evaluate the imaginary error function to arbitrary precision\n453     on the whole complex plane:\n454 \n455     >>> erfi(2).evalf(30)\n456     18.5648024145755525987042919132\n457 \n458     >>> erfi(-2*I).evalf(30)\n459     -0.995322265018952734162069256367*I\n460 \n461     See Also\n462     ========\n463 \n464     erf: Gaussian error function.\n465     erfc: Complementary error function.\n466     erf2: Two-argument error function.\n467     erfinv: Inverse error function.\n468     erfcinv: Inverse Complementary error function.\n469     erf2inv: Inverse two-argument error function.\n470 \n471     References\n472     ==========\n473 \n474     .. [1] https://en.wikipedia.org/wiki/Error_function\n475     .. [2] http://mathworld.wolfram.com/Erfi.html\n476     .. [3] http://functions.wolfram.com/GammaBetaErf/Erfi\n477     \"\"\"\n478 \n479     unbranched = True\n480 \n481     def fdiff(self, argindex=1):\n482         if argindex == 1:\n483             return 2*exp(self.args[0]**2)/sqrt(S.Pi)\n484         else:\n485             raise ArgumentIndexError(self, argindex)\n486 \n487     @classmethod\n488     def eval(cls, z):\n489         if z.is_Number:\n490             if z is S.NaN:\n491                 return S.NaN\n492             elif z is S.Zero:\n493                 return S.Zero\n494             elif z is S.Infinity:\n495                 return S.Infinity\n496 \n497         # Try to pull out factors of -1\n498         if z.could_extract_minus_sign():\n499             return -cls(-z)\n500 \n501         # Try to pull out factors of I\n502         nz = z.extract_multiplicatively(I)\n503         if nz is not None:\n504             if nz is S.Infinity:\n505                 return I\n506             if isinstance(nz, erfinv):\n507                 return I*nz.args[0]\n508             if isinstance(nz, erfcinv):\n509                 return I*(S.One - nz.args[0])\n510             if isinstance(nz, erf2inv) and nz.args[0] is S.Zero:\n511                 return I*nz.args[1]\n512 \n513     @staticmethod\n514     @cacheit\n515     def taylor_term(n, x, *previous_terms):\n516         if n < 0 or n % 2 == 0:\n517             return S.Zero\n518         else:\n519             x = sympify(x)\n520             k = floor((n - 1)/S(2))\n521             if len(previous_terms) > 2:\n522                 return previous_terms[-2] * x**2 * (n - 2)/(n*k)\n523             else:\n524                 return 2 * x**n/(n*factorial(k)*sqrt(S.Pi))\n525 \n526     def _eval_conjugate(self):\n527         return self.func(self.args[0].conjugate())\n528 \n529     def _eval_is_real(self):\n530         return self.args[0].is_real\n531 \n532     def _eval_rewrite_as_tractable(self, z, **kwargs):\n533         return self.rewrite(erf).rewrite(\"tractable\", deep=True)\n534 \n535     def _eval_rewrite_as_erf(self, z, **kwargs):\n536         return -I*erf(I*z)\n537 \n538     def _eval_rewrite_as_erfc(self, z, **kwargs):\n539         return I*erfc(I*z) - I\n540 \n541     def _eval_rewrite_as_fresnels(self, z, **kwargs):\n542         arg = (S.One + S.ImaginaryUnit)*z/sqrt(pi)\n543         return (S.One - S.ImaginaryUnit)*(fresnelc(arg) - I*fresnels(arg))\n544 \n545     def _eval_rewrite_as_fresnelc(self, z, **kwargs):\n546         arg = (S.One + S.ImaginaryUnit)*z/sqrt(pi)\n547         return (S.One - S.ImaginaryUnit)*(fresnelc(arg) - I*fresnels(arg))\n548 \n549     def _eval_rewrite_as_meijerg(self, z, **kwargs):\n550         return z/sqrt(pi)*meijerg([S.Half], [], [0], [-S.Half], -z**2)\n551 \n552     def _eval_rewrite_as_hyper(self, z, **kwargs):\n553         return 2*z/sqrt(pi)*hyper([S.Half], [3*S.Half], z**2)\n554 \n555     def _eval_rewrite_as_uppergamma(self, z, **kwargs):\n556         from sympy import uppergamma\n557         return sqrt(-z**2)/z*(uppergamma(S.Half, -z**2)/sqrt(S.Pi) - S.One)\n558 \n559     def _eval_rewrite_as_expint(self, z, **kwargs):\n560         return sqrt(-z**2)/z - z*expint(S.Half, -z**2)/sqrt(S.Pi)\n561 \n562     def _eval_expand_func(self, **hints):\n563         return self.rewrite(erf)\n564 \n565     def as_real_imag(self, deep=True, **hints):\n566         if self.args[0].is_real:\n567             if deep:\n568                 hints['complex'] = False\n569                 return (self.expand(deep, **hints), S.Zero)\n570             else:\n571                 return (self, S.Zero)\n572         if deep:\n573             x, y = self.args[0].expand(deep, **hints).as_real_imag()\n574         else:\n575             x, y = self.args[0].as_real_imag()\n576 \n577         sq = -y**2/x**2\n578         re = S.Half*(self.func(x + x*sqrt(sq)) + self.func(x - x*sqrt(sq)))\n579         im = x/(2*y) * sqrt(sq) * (self.func(x - x*sqrt(sq)) -\n580                     self.func(x + x*sqrt(sq)))\n581         return (re, im)\n582 \n583 class erf2(Function):\n584     r\"\"\"\n585     Two-argument error function. This function is defined as:\n586 \n587     .. math ::\n588         \\mathrm{erf2}(x, y) = \\frac{2}{\\sqrt{\\pi}} \\int_x^y e^{-t^2} \\mathrm{d}t\n589 \n590     Examples\n591     ========\n592 \n593     >>> from sympy import I, oo, erf2\n594     >>> from sympy.abc import x, y\n595 \n596     Several special values are known:\n597 \n598     >>> erf2(0, 0)\n599     0\n600     >>> erf2(x, x)\n601     0\n602     >>> erf2(x, oo)\n603     1 - erf(x)\n604     >>> erf2(x, -oo)\n605     -erf(x) - 1\n606     >>> erf2(oo, y)\n607     erf(y) - 1\n608     >>> erf2(-oo, y)\n609     erf(y) + 1\n610 \n611     In general one can pull out factors of -1:\n612 \n613     >>> erf2(-x, -y)\n614     -erf2(x, y)\n615 \n616     The error function obeys the mirror symmetry:\n617 \n618     >>> from sympy import conjugate\n619     >>> conjugate(erf2(x, y))\n620     erf2(conjugate(x), conjugate(y))\n621 \n622     Differentiation with respect to x, y is supported:\n623 \n624     >>> from sympy import diff\n625     >>> diff(erf2(x, y), x)\n626     -2*exp(-x**2)/sqrt(pi)\n627     >>> diff(erf2(x, y), y)\n628     2*exp(-y**2)/sqrt(pi)\n629 \n630     See Also\n631     ========\n632 \n633     erf: Gaussian error function.\n634     erfc: Complementary error function.\n635     erfi: Imaginary error function.\n636     erfinv: Inverse error function.\n637     erfcinv: Inverse Complementary error function.\n638     erf2inv: Inverse two-argument error function.\n639 \n640     References\n641     ==========\n642 \n643     .. [1] http://functions.wolfram.com/GammaBetaErf/Erf2/\n644     \"\"\"\n645 \n646 \n647     def fdiff(self, argindex):\n648         x, y = self.args\n649         if argindex == 1:\n650             return -2*exp(-x**2)/sqrt(S.Pi)\n651         elif argindex == 2:\n652             return 2*exp(-y**2)/sqrt(S.Pi)\n653         else:\n654             raise ArgumentIndexError(self, argindex)\n655 \n656     @classmethod\n657     def eval(cls, x, y):\n658         I = S.Infinity\n659         N = S.NegativeInfinity\n660         O = S.Zero\n661         if x is S.NaN or y is S.NaN:\n662             return S.NaN\n663         elif x == y:\n664             return S.Zero\n665         elif (x is I or x is N or x is O) or (y is I or y is N or y is O):\n666             return erf(y) - erf(x)\n667 \n668         if isinstance(y, erf2inv) and y.args[0] == x:\n669             return y.args[1]\n670 \n671         #Try to pull out -1 factor\n672         sign_x = x.could_extract_minus_sign()\n673         sign_y = y.could_extract_minus_sign()\n674         if (sign_x and sign_y):\n675             return -cls(-x, -y)\n676         elif (sign_x or sign_y):\n677             return erf(y)-erf(x)\n678 \n679     def _eval_conjugate(self):\n680         return self.func(self.args[0].conjugate(), self.args[1].conjugate())\n681 \n682     def _eval_is_real(self):\n683         return self.args[0].is_real and self.args[1].is_real\n684 \n685     def _eval_rewrite_as_erf(self, x, y, **kwargs):\n686         return erf(y) - erf(x)\n687 \n688     def _eval_rewrite_as_erfc(self, x, y, **kwargs):\n689         return erfc(x) - erfc(y)\n690 \n691     def _eval_rewrite_as_erfi(self, x, y, **kwargs):\n692         return I*(erfi(I*x)-erfi(I*y))\n693 \n694     def _eval_rewrite_as_fresnels(self, x, y, **kwargs):\n695         return erf(y).rewrite(fresnels) - erf(x).rewrite(fresnels)\n696 \n697     def _eval_rewrite_as_fresnelc(self, x, y, **kwargs):\n698         return erf(y).rewrite(fresnelc) - erf(x).rewrite(fresnelc)\n699 \n700     def _eval_rewrite_as_meijerg(self, x, y, **kwargs):\n701         return erf(y).rewrite(meijerg) - erf(x).rewrite(meijerg)\n702 \n703     def _eval_rewrite_as_hyper(self, x, y, **kwargs):\n704         return erf(y).rewrite(hyper) - erf(x).rewrite(hyper)\n705 \n706     def _eval_rewrite_as_uppergamma(self, x, y, **kwargs):\n707         from sympy import uppergamma\n708         return (sqrt(y**2)/y*(S.One - uppergamma(S.Half, y**2)/sqrt(S.Pi)) -\n709             sqrt(x**2)/x*(S.One - uppergamma(S.Half, x**2)/sqrt(S.Pi)))\n710 \n711     def _eval_rewrite_as_expint(self, x, y, **kwargs):\n712         return erf(y).rewrite(expint) - erf(x).rewrite(expint)\n713 \n714     def _eval_expand_func(self, **hints):\n715         return self.rewrite(erf)\n716 \n717 \n718 class erfinv(Function):\n719     r\"\"\"\n720     Inverse Error Function. The erfinv function is defined as:\n721 \n722     .. math ::\n723         \\mathrm{erf}(x) = y \\quad \\Rightarrow \\quad \\mathrm{erfinv}(y) = x\n724 \n725     Examples\n726     ========\n727 \n728     >>> from sympy import I, oo, erfinv\n729     >>> from sympy.abc import x\n730 \n731     Several special values are known:\n732 \n733     >>> erfinv(0)\n734     0\n735     >>> erfinv(1)\n736     oo\n737 \n738     Differentiation with respect to x is supported:\n739 \n740     >>> from sympy import diff\n741     >>> diff(erfinv(x), x)\n742     sqrt(pi)*exp(erfinv(x)**2)/2\n743 \n744     We can numerically evaluate the inverse error function to arbitrary precision\n745     on [-1, 1]:\n746 \n747     >>> erfinv(0.2).evalf(30)\n748     0.179143454621291692285822705344\n749 \n750     See Also\n751     ========\n752 \n753     erf: Gaussian error function.\n754     erfc: Complementary error function.\n755     erfi: Imaginary error function.\n756     erf2: Two-argument error function.\n757     erfcinv: Inverse Complementary error function.\n758     erf2inv: Inverse two-argument error function.\n759 \n760     References\n761     ==========\n762 \n763     .. [1] https://en.wikipedia.org/wiki/Error_function#Inverse_functions\n764     .. [2] http://functions.wolfram.com/GammaBetaErf/InverseErf/\n765     \"\"\"\n766 \n767 \n768     def fdiff(self, argindex =1):\n769         if argindex == 1:\n770             return sqrt(S.Pi)*exp(self.func(self.args[0])**2)*S.Half\n771         else :\n772             raise ArgumentIndexError(self, argindex)\n773 \n774     def inverse(self, argindex=1):\n775         \"\"\"\n776         Returns the inverse of this function.\n777         \"\"\"\n778         return erf\n779 \n780     @classmethod\n781     def eval(cls, z):\n782         if z is S.NaN:\n783             return S.NaN\n784         elif z is S.NegativeOne:\n785             return S.NegativeInfinity\n786         elif z is S.Zero:\n787             return S.Zero\n788         elif z is S.One:\n789             return S.Infinity\n790 \n791         if isinstance(z, erf) and z.args[0].is_real:\n792             return z.args[0]\n793 \n794         # Try to pull out factors of -1\n795         nz = z.extract_multiplicatively(-1)\n796         if nz is not None and (isinstance(nz, erf) and (nz.args[0]).is_real):\n797             return -nz.args[0]\n798 \n799     def _eval_rewrite_as_erfcinv(self, z, **kwargs):\n800        return erfcinv(1-z)\n801 \n802 \n803 class erfcinv (Function):\n804     r\"\"\"\n805     Inverse Complementary Error Function. The erfcinv function is defined as:\n806 \n807     .. math ::\n808         \\mathrm{erfc}(x) = y \\quad \\Rightarrow \\quad \\mathrm{erfcinv}(y) = x\n809 \n810     Examples\n811     ========\n812 \n813     >>> from sympy import I, oo, erfcinv\n814     >>> from sympy.abc import x\n815 \n816     Several special values are known:\n817 \n818     >>> erfcinv(1)\n819     0\n820     >>> erfcinv(0)\n821     oo\n822 \n823     Differentiation with respect to x is supported:\n824 \n825     >>> from sympy import diff\n826     >>> diff(erfcinv(x), x)\n827     -sqrt(pi)*exp(erfcinv(x)**2)/2\n828 \n829     See Also\n830     ========\n831 \n832     erf: Gaussian error function.\n833     erfc: Complementary error function.\n834     erfi: Imaginary error function.\n835     erf2: Two-argument error function.\n836     erfinv: Inverse error function.\n837     erf2inv: Inverse two-argument error function.\n838 \n839     References\n840     ==========\n841 \n842     .. [1] https://en.wikipedia.org/wiki/Error_function#Inverse_functions\n843     .. [2] http://functions.wolfram.com/GammaBetaErf/InverseErfc/\n844     \"\"\"\n845 \n846 \n847     def fdiff(self, argindex =1):\n848         if argindex == 1:\n849             return -sqrt(S.Pi)*exp(self.func(self.args[0])**2)*S.Half\n850         else:\n851             raise ArgumentIndexError(self, argindex)\n852 \n853     def inverse(self, argindex=1):\n854         \"\"\"\n855         Returns the inverse of this function.\n856         \"\"\"\n857         return erfc\n858 \n859     @classmethod\n860     def eval(cls, z):\n861         if z is S.NaN:\n862             return S.NaN\n863         elif z is S.Zero:\n864             return S.Infinity\n865         elif z is S.One:\n866             return S.Zero\n867         elif z == 2:\n868             return S.NegativeInfinity\n869 \n870     def _eval_rewrite_as_erfinv(self, z, **kwargs):\n871         return erfinv(1-z)\n872 \n873 \n874 class erf2inv(Function):\n875     r\"\"\"\n876     Two-argument Inverse error function. The erf2inv function is defined as:\n877 \n878     .. math ::\n879         \\mathrm{erf2}(x, w) = y \\quad \\Rightarrow \\quad \\mathrm{erf2inv}(x, y) = w\n880 \n881     Examples\n882     ========\n883 \n884     >>> from sympy import I, oo, erf2inv, erfinv, erfcinv\n885     >>> from sympy.abc import x, y\n886 \n887     Several special values are known:\n888 \n889     >>> erf2inv(0, 0)\n890     0\n891     >>> erf2inv(1, 0)\n892     1\n893     >>> erf2inv(0, 1)\n894     oo\n895     >>> erf2inv(0, y)\n896     erfinv(y)\n897     >>> erf2inv(oo, y)\n898     erfcinv(-y)\n899 \n900     Differentiation with respect to x and y is supported:\n901 \n902     >>> from sympy import diff\n903     >>> diff(erf2inv(x, y), x)\n904     exp(-x**2 + erf2inv(x, y)**2)\n905     >>> diff(erf2inv(x, y), y)\n906     sqrt(pi)*exp(erf2inv(x, y)**2)/2\n907 \n908     See Also\n909     ========\n910 \n911     erf: Gaussian error function.\n912     erfc: Complementary error function.\n913     erfi: Imaginary error function.\n914     erf2: Two-argument error function.\n915     erfinv: Inverse error function.\n916     erfcinv: Inverse complementary error function.\n917 \n918     References\n919     ==========\n920 \n921     .. [1] http://functions.wolfram.com/GammaBetaErf/InverseErf2/\n922     \"\"\"\n923 \n924 \n925     def fdiff(self, argindex):\n926         x, y = self.args\n927         if argindex == 1:\n928             return exp(self.func(x,y)**2-x**2)\n929         elif argindex == 2:\n930             return sqrt(S.Pi)*S.Half*exp(self.func(x,y)**2)\n931         else:\n932             raise ArgumentIndexError(self, argindex)\n933 \n934     @classmethod\n935     def eval(cls, x, y):\n936         if x is S.NaN or y is S.NaN:\n937             return S.NaN\n938         elif x is S.Zero and y is S.Zero:\n939             return S.Zero\n940         elif x is S.Zero and y is S.One:\n941             return S.Infinity\n942         elif x is S.One and y is S.Zero:\n943             return S.One\n944         elif x is S.Zero:\n945             return erfinv(y)\n946         elif x is S.Infinity:\n947             return erfcinv(-y)\n948         elif y is S.Zero:\n949             return x\n950         elif y is S.Infinity:\n951             return erfinv(x)\n952 \n953 \n954 ###############################################################################\n955 #################### EXPONENTIAL INTEGRALS ####################################\n956 ###############################################################################\n957 \n958 class Ei(Function):\n959     r\"\"\"\n960     The classical exponential integral.\n961 \n962     For use in SymPy, this function is defined as\n963 \n964     .. math:: \\operatorname{Ei}(x) = \\sum_{n=1}^\\infty \\frac{x^n}{n\\, n!}\n965                                      + \\log(x) + \\gamma,\n966 \n967     where `\\gamma` is the Euler-Mascheroni constant.\n968 \n969     If `x` is a polar number, this defines an analytic function on the\n970     Riemann surface of the logarithm. Otherwise this defines an analytic\n971     function in the cut plane `\\mathbb{C} \\setminus (-\\infty, 0]`.\n972 \n973     **Background**\n974 \n975     The name *exponential integral* comes from the following statement:\n976 \n977     .. math:: \\operatorname{Ei}(x) = \\int_{-\\infty}^x \\frac{e^t}{t} \\mathrm{d}t\n978 \n979     If the integral is interpreted as a Cauchy principal value, this statement\n980     holds for `x > 0` and `\\operatorname{Ei}(x)` as defined above.\n981 \n982     Examples\n983     ========\n984 \n985     >>> from sympy import Ei, polar_lift, exp_polar, I, pi\n986     >>> from sympy.abc import x\n987 \n988     >>> Ei(-1)\n989     Ei(-1)\n990 \n991     This yields a real value:\n992 \n993     >>> Ei(-1).n(chop=True)\n994     -0.219383934395520\n995 \n996     On the other hand the analytic continuation is not real:\n997 \n998     >>> Ei(polar_lift(-1)).n(chop=True)\n999     -0.21938393439552 + 3.14159265358979*I\n1000 \n1001     The exponential integral has a logarithmic branch point at the origin:\n1002 \n1003     >>> Ei(x*exp_polar(2*I*pi))\n1004     Ei(x) + 2*I*pi\n1005 \n1006     Differentiation is supported:\n1007 \n1008     >>> Ei(x).diff(x)\n1009     exp(x)/x\n1010 \n1011     The exponential integral is related to many other special functions.\n1012     For example:\n1013 \n1014     >>> from sympy import uppergamma, expint, Shi\n1015     >>> Ei(x).rewrite(expint)\n1016     -expint(1, x*exp_polar(I*pi)) - I*pi\n1017     >>> Ei(x).rewrite(Shi)\n1018     Chi(x) + Shi(x)\n1019 \n1020     See Also\n1021     ========\n1022 \n1023     expint: Generalised exponential integral.\n1024     E1: Special case of the generalised exponential integral.\n1025     li: Logarithmic integral.\n1026     Li: Offset logarithmic integral.\n1027     Si: Sine integral.\n1028     Ci: Cosine integral.\n1029     Shi: Hyperbolic sine integral.\n1030     Chi: Hyperbolic cosine integral.\n1031     sympy.functions.special.gamma_functions.uppergamma: Upper incomplete gamma function.\n1032 \n1033     References\n1034     ==========\n1035 \n1036     .. [1] http://dlmf.nist.gov/6.6\n1037     .. [2] https://en.wikipedia.org/wiki/Exponential_integral\n1038     .. [3] Abramowitz & Stegun, section 5: http://people.math.sfu.ca/~cbm/aands/page_228.htm\n1039 \n1040     \"\"\"\n1041 \n1042 \n1043     @classmethod\n1044     def eval(cls, z):\n1045         if z is S.Zero:\n1046             return S.NegativeInfinity\n1047         elif z is S.Infinity:\n1048             return S.Infinity\n1049         elif z is S.NegativeInfinity:\n1050             return S.Zero\n1051 \n1052         nz, n = z.extract_branch_factor()\n1053         if n:\n1054             return Ei(nz) + 2*I*pi*n\n1055 \n1056     def fdiff(self, argindex=1):\n1057         from sympy import unpolarify\n1058         arg = unpolarify(self.args[0])\n1059         if argindex == 1:\n1060             return exp(arg)/arg\n1061         else:\n1062             raise ArgumentIndexError(self, argindex)\n1063 \n1064     def _eval_evalf(self, prec):\n1065         if (self.args[0]/polar_lift(-1)).is_positive:\n1066             return Function._eval_evalf(self, prec) + (I*pi)._eval_evalf(prec)\n1067         return Function._eval_evalf(self, prec)\n1068 \n1069     def _eval_rewrite_as_uppergamma(self, z, **kwargs):\n1070         from sympy import uppergamma\n1071         # XXX this does not currently work usefully because uppergamma\n1072         #     immediately turns into expint\n1073         return -uppergamma(0, polar_lift(-1)*z) - I*pi\n1074 \n1075     def _eval_rewrite_as_expint(self, z, **kwargs):\n1076         return -expint(1, polar_lift(-1)*z) - I*pi\n1077 \n1078     def _eval_rewrite_as_li(self, z, **kwargs):\n1079         if isinstance(z, log):\n1080             return li(z.args[0])\n1081         # TODO:\n1082         # Actually it only holds that:\n1083         #  Ei(z) = li(exp(z))\n1084         # for -pi < imag(z) <= pi\n1085         return li(exp(z))\n1086 \n1087     def _eval_rewrite_as_Si(self, z, **kwargs):\n1088         return Shi(z) + Chi(z)\n1089     _eval_rewrite_as_Ci = _eval_rewrite_as_Si\n1090     _eval_rewrite_as_Chi = _eval_rewrite_as_Si\n1091     _eval_rewrite_as_Shi = _eval_rewrite_as_Si\n1092 \n1093     def _eval_rewrite_as_tractable(self, z, **kwargs):\n1094         return exp(z) * _eis(z)\n1095 \n1096     def _eval_nseries(self, x, n, logx):\n1097         x0 = self.args[0].limit(x, 0)\n1098         if x0 is S.Zero:\n1099             f = self._eval_rewrite_as_Si(*self.args)\n1100             return f._eval_nseries(x, n, logx)\n1101         return super(Ei, self)._eval_nseries(x, n, logx)\n1102 \n1103 \n1104 class expint(Function):\n1105     r\"\"\"\n1106     Generalized exponential integral.\n1107 \n1108     This function is defined as\n1109 \n1110     .. math:: \\operatorname{E}_\\nu(z) = z^{\\nu - 1} \\Gamma(1 - \\nu, z),\n1111 \n1112     where `\\Gamma(1 - \\nu, z)` is the upper incomplete gamma function\n1113     (``uppergamma``).\n1114 \n1115     Hence for :math:`z` with positive real part we have\n1116 \n1117     .. math:: \\operatorname{E}_\\nu(z)\n1118               =   \\int_1^\\infty \\frac{e^{-zt}}{z^\\nu} \\mathrm{d}t,\n1119 \n1120     which explains the name.\n1121 \n1122     The representation as an incomplete gamma function provides an analytic\n1123     continuation for :math:`\\operatorname{E}_\\nu(z)`. If :math:`\\nu` is a\n1124     non-positive integer the exponential integral is thus an unbranched\n1125     function of :math:`z`, otherwise there is a branch point at the origin.\n1126     Refer to the incomplete gamma function documentation for details of the\n1127     branching behavior.\n1128 \n1129     Examples\n1130     ========\n1131 \n1132     >>> from sympy import expint, S\n1133     >>> from sympy.abc import nu, z\n1134 \n1135     Differentiation is supported. Differentiation with respect to z explains\n1136     further the name: for integral orders, the exponential integral is an\n1137     iterated integral of the exponential function.\n1138 \n1139     >>> expint(nu, z).diff(z)\n1140     -expint(nu - 1, z)\n1141 \n1142     Differentiation with respect to nu has no classical expression:\n1143 \n1144     >>> expint(nu, z).diff(nu)\n1145     -z**(nu - 1)*meijerg(((), (1, 1)), ((0, 0, 1 - nu), ()), z)\n1146 \n1147     At non-postive integer orders, the exponential integral reduces to the\n1148     exponential function:\n1149 \n1150     >>> expint(0, z)\n1151     exp(-z)/z\n1152     >>> expint(-1, z)\n1153     exp(-z)/z + exp(-z)/z**2\n1154 \n1155     At half-integers it reduces to error functions:\n1156 \n1157     >>> expint(S(1)/2, z)\n1158     sqrt(pi)*erfc(sqrt(z))/sqrt(z)\n1159 \n1160     At positive integer orders it can be rewritten in terms of exponentials\n1161     and expint(1, z). Use expand_func() to do this:\n1162 \n1163     >>> from sympy import expand_func\n1164     >>> expand_func(expint(5, z))\n1165     z**4*expint(1, z)/24 + (-z**3 + z**2 - 2*z + 6)*exp(-z)/24\n1166 \n1167     The generalised exponential integral is essentially equivalent to the\n1168     incomplete gamma function:\n1169 \n1170     >>> from sympy import uppergamma\n1171     >>> expint(nu, z).rewrite(uppergamma)\n1172     z**(nu - 1)*uppergamma(1 - nu, z)\n1173 \n1174     As such it is branched at the origin:\n1175 \n1176     >>> from sympy import exp_polar, pi, I\n1177     >>> expint(4, z*exp_polar(2*pi*I))\n1178     I*pi*z**3/3 + expint(4, z)\n1179     >>> expint(nu, z*exp_polar(2*pi*I))\n1180     z**(nu - 1)*(exp(2*I*pi*nu) - 1)*gamma(1 - nu) + expint(nu, z)\n1181 \n1182     See Also\n1183     ========\n1184 \n1185     Ei: Another related function called exponential integral.\n1186     E1: The classical case, returns expint(1, z).\n1187     li: Logarithmic integral.\n1188     Li: Offset logarithmic integral.\n1189     Si: Sine integral.\n1190     Ci: Cosine integral.\n1191     Shi: Hyperbolic sine integral.\n1192     Chi: Hyperbolic cosine integral.\n1193     sympy.functions.special.gamma_functions.uppergamma\n1194 \n1195     References\n1196     ==========\n1197 \n1198     .. [1] http://dlmf.nist.gov/8.19\n1199     .. [2] http://functions.wolfram.com/GammaBetaErf/ExpIntegralE/\n1200     .. [3] https://en.wikipedia.org/wiki/Exponential_integral\n1201 \n1202     \"\"\"\n1203 \n1204 \n1205     @classmethod\n1206     def eval(cls, nu, z):\n1207         from sympy import (unpolarify, expand_mul, uppergamma, exp, gamma,\n1208                            factorial)\n1209         nu2 = unpolarify(nu)\n1210         if nu != nu2:\n1211             return expint(nu2, z)\n1212         if nu.is_Integer and nu <= 0 or (not nu.is_Integer and (2*nu).is_Integer):\n1213             return unpolarify(expand_mul(z**(nu - 1)*uppergamma(1 - nu, z)))\n1214 \n1215         # Extract branching information. This can be deduced from what is\n1216         # explained in lowergamma.eval().\n1217         z, n = z.extract_branch_factor()\n1218         if n == 0:\n1219             return\n1220         if nu.is_integer:\n1221             if not nu > 0:\n1222                 return\n1223             return expint(nu, z) \\\n1224                 - 2*pi*I*n*(-1)**(nu - 1)/factorial(nu - 1)*unpolarify(z)**(nu - 1)\n1225         else:\n1226             return (exp(2*I*pi*nu*n) - 1)*z**(nu - 1)*gamma(1 - nu) + expint(nu, z)\n1227 \n1228     def fdiff(self, argindex):\n1229         from sympy import meijerg\n1230         nu, z = self.args\n1231         if argindex == 1:\n1232             return -z**(nu - 1)*meijerg([], [1, 1], [0, 0, 1 - nu], [], z)\n1233         elif argindex == 2:\n1234             return -expint(nu - 1, z)\n1235         else:\n1236             raise ArgumentIndexError(self, argindex)\n1237 \n1238     def _eval_rewrite_as_uppergamma(self, nu, z, **kwargs):\n1239         from sympy import uppergamma\n1240         return z**(nu - 1)*uppergamma(1 - nu, z)\n1241 \n1242     def _eval_rewrite_as_Ei(self, nu, z, **kwargs):\n1243         from sympy import exp_polar, unpolarify, exp, factorial\n1244         if nu == 1:\n1245             return -Ei(z*exp_polar(-I*pi)) - I*pi\n1246         elif nu.is_Integer and nu > 1:\n1247             # DLMF, 8.19.7\n1248             x = -unpolarify(z)\n1249             return x**(nu - 1)/factorial(nu - 1)*E1(z).rewrite(Ei) + \\\n1250                 exp(x)/factorial(nu - 1) * \\\n1251                 Add(*[factorial(nu - k - 2)*x**k for k in range(nu - 1)])\n1252         else:\n1253             return self\n1254 \n1255     def _eval_expand_func(self, **hints):\n1256         return self.rewrite(Ei).rewrite(expint, **hints)\n1257 \n1258     def _eval_rewrite_as_Si(self, nu, z, **kwargs):\n1259         if nu != 1:\n1260             return self\n1261         return Shi(z) - Chi(z)\n1262     _eval_rewrite_as_Ci = _eval_rewrite_as_Si\n1263     _eval_rewrite_as_Chi = _eval_rewrite_as_Si\n1264     _eval_rewrite_as_Shi = _eval_rewrite_as_Si\n1265 \n1266     def _eval_nseries(self, x, n, logx):\n1267         if not self.args[0].has(x):\n1268             nu = self.args[0]\n1269             if nu == 1:\n1270                 f = self._eval_rewrite_as_Si(*self.args)\n1271                 return f._eval_nseries(x, n, logx)\n1272             elif nu.is_Integer and nu > 1:\n1273                 f = self._eval_rewrite_as_Ei(*self.args)\n1274                 return f._eval_nseries(x, n, logx)\n1275         return super(expint, self)._eval_nseries(x, n, logx)\n1276 \n1277     def _sage_(self):\n1278         import sage.all as sage\n1279         return sage.exp_integral_e(self.args[0]._sage_(), self.args[1]._sage_())\n1280 \n1281 \n1282 def E1(z):\n1283     \"\"\"\n1284     Classical case of the generalized exponential integral.\n1285 \n1286     This is equivalent to ``expint(1, z)``.\n1287 \n1288     See Also\n1289     ========\n1290 \n1291     Ei: Exponential integral.\n1292     expint: Generalised exponential integral.\n1293     li: Logarithmic integral.\n1294     Li: Offset logarithmic integral.\n1295     Si: Sine integral.\n1296     Ci: Cosine integral.\n1297     Shi: Hyperbolic sine integral.\n1298     Chi: Hyperbolic cosine integral.\n1299     \"\"\"\n1300     return expint(1, z)\n1301 \n1302 \n1303 class li(Function):\n1304     r\"\"\"\n1305     The classical logarithmic integral.\n1306 \n1307     For the use in SymPy, this function is defined as\n1308 \n1309     .. math:: \\operatorname{li}(x) = \\int_0^x \\frac{1}{\\log(t)} \\mathrm{d}t \\,.\n1310 \n1311     Examples\n1312     ========\n1313 \n1314     >>> from sympy import I, oo, li\n1315     >>> from sympy.abc import z\n1316 \n1317     Several special values are known:\n1318 \n1319     >>> li(0)\n1320     0\n1321     >>> li(1)\n1322     -oo\n1323     >>> li(oo)\n1324     oo\n1325 \n1326     Differentiation with respect to z is supported:\n1327 \n1328     >>> from sympy import diff\n1329     >>> diff(li(z), z)\n1330     1/log(z)\n1331 \n1332     Defining the `li` function via an integral:\n1333 \n1334 \n1335     The logarithmic integral can also be defined in terms of Ei:\n1336 \n1337     >>> from sympy import Ei\n1338     >>> li(z).rewrite(Ei)\n1339     Ei(log(z))\n1340     >>> diff(li(z).rewrite(Ei), z)\n1341     1/log(z)\n1342 \n1343     We can numerically evaluate the logarithmic integral to arbitrary precision\n1344     on the whole complex plane (except the singular points):\n1345 \n1346     >>> li(2).evalf(30)\n1347     1.04516378011749278484458888919\n1348 \n1349     >>> li(2*I).evalf(30)\n1350     1.0652795784357498247001125598 + 3.08346052231061726610939702133*I\n1351 \n1352     We can even compute Soldner's constant by the help of mpmath:\n1353 \n1354     >>> from mpmath import findroot\n1355     >>> findroot(li, 2)\n1356     1.45136923488338\n1357 \n1358     Further transformations include rewriting `li` in terms of\n1359     the trigonometric integrals `Si`, `Ci`, `Shi` and `Chi`:\n1360 \n1361     >>> from sympy import Si, Ci, Shi, Chi\n1362     >>> li(z).rewrite(Si)\n1363     -log(I*log(z)) - log(1/log(z))/2 + log(log(z))/2 + Ci(I*log(z)) + Shi(log(z))\n1364     >>> li(z).rewrite(Ci)\n1365     -log(I*log(z)) - log(1/log(z))/2 + log(log(z))/2 + Ci(I*log(z)) + Shi(log(z))\n1366     >>> li(z).rewrite(Shi)\n1367     -log(1/log(z))/2 + log(log(z))/2 + Chi(log(z)) - Shi(log(z))\n1368     >>> li(z).rewrite(Chi)\n1369     -log(1/log(z))/2 + log(log(z))/2 + Chi(log(z)) - Shi(log(z))\n1370 \n1371     See Also\n1372     ========\n1373 \n1374     Li: Offset logarithmic integral.\n1375     Ei: Exponential integral.\n1376     expint: Generalised exponential integral.\n1377     E1: Special case of the generalised exponential integral.\n1378     Si: Sine integral.\n1379     Ci: Cosine integral.\n1380     Shi: Hyperbolic sine integral.\n1381     Chi: Hyperbolic cosine integral.\n1382 \n1383     References\n1384     ==========\n1385 \n1386     .. [1] https://en.wikipedia.org/wiki/Logarithmic_integral\n1387     .. [2] http://mathworld.wolfram.com/LogarithmicIntegral.html\n1388     .. [3] http://dlmf.nist.gov/6\n1389     .. [4] http://mathworld.wolfram.com/SoldnersConstant.html\n1390     \"\"\"\n1391 \n1392 \n1393     @classmethod\n1394     def eval(cls, z):\n1395         if z is S.Zero:\n1396             return S.Zero\n1397         elif z is S.One:\n1398             return S.NegativeInfinity\n1399         elif z is S.Infinity:\n1400             return S.Infinity\n1401 \n1402     def fdiff(self, argindex=1):\n1403         arg = self.args[0]\n1404         if argindex == 1:\n1405             return S.One / log(arg)\n1406         else:\n1407             raise ArgumentIndexError(self, argindex)\n1408 \n1409     def _eval_conjugate(self):\n1410         z = self.args[0]\n1411         # Exclude values on the branch cut (-oo, 0)\n1412         if not (z.is_real and z.is_negative):\n1413             return self.func(z.conjugate())\n1414 \n1415     def _eval_rewrite_as_Li(self, z, **kwargs):\n1416         return Li(z) + li(2)\n1417 \n1418     def _eval_rewrite_as_Ei(self, z, **kwargs):\n1419         return Ei(log(z))\n1420 \n1421     def _eval_rewrite_as_uppergamma(self, z, **kwargs):\n1422         from sympy import uppergamma\n1423         return (-uppergamma(0, -log(z)) +\n1424                 S.Half*(log(log(z)) - log(S.One/log(z))) - log(-log(z)))\n1425 \n1426     def _eval_rewrite_as_Si(self, z, **kwargs):\n1427         return (Ci(I*log(z)) - I*Si(I*log(z)) -\n1428                 S.Half*(log(S.One/log(z)) - log(log(z))) - log(I*log(z)))\n1429 \n1430     _eval_rewrite_as_Ci = _eval_rewrite_as_Si\n1431 \n1432     def _eval_rewrite_as_Shi(self, z, **kwargs):\n1433         return (Chi(log(z)) - Shi(log(z)) - S.Half*(log(S.One/log(z)) - log(log(z))))\n1434 \n1435     _eval_rewrite_as_Chi = _eval_rewrite_as_Shi\n1436 \n1437     def _eval_rewrite_as_hyper(self, z, **kwargs):\n1438         return (log(z)*hyper((1, 1), (2, 2), log(z)) +\n1439                 S.Half*(log(log(z)) - log(S.One/log(z))) + S.EulerGamma)\n1440 \n1441     def _eval_rewrite_as_meijerg(self, z, **kwargs):\n1442         return (-log(-log(z)) - S.Half*(log(S.One/log(z)) - log(log(z)))\n1443                 - meijerg(((), (1,)), ((0, 0), ()), -log(z)))\n1444 \n1445     def _eval_rewrite_as_tractable(self, z, **kwargs):\n1446         return z * _eis(log(z))\n1447 \n1448 \n1449 class Li(Function):\n1450     r\"\"\"\n1451     The offset logarithmic integral.\n1452 \n1453     For the use in SymPy, this function is defined as\n1454 \n1455     .. math:: \\operatorname{Li}(x) = \\operatorname{li}(x) - \\operatorname{li}(2)\n1456 \n1457     Examples\n1458     ========\n1459 \n1460     >>> from sympy import I, oo, Li\n1461     >>> from sympy.abc import z\n1462 \n1463     The following special value is known:\n1464 \n1465     >>> Li(2)\n1466     0\n1467 \n1468     Differentiation with respect to z is supported:\n1469 \n1470     >>> from sympy import diff\n1471     >>> diff(Li(z), z)\n1472     1/log(z)\n1473 \n1474     The shifted logarithmic integral can be written in terms of `li(z)`:\n1475 \n1476     >>> from sympy import li\n1477     >>> Li(z).rewrite(li)\n1478     li(z) - li(2)\n1479 \n1480     We can numerically evaluate the logarithmic integral to arbitrary precision\n1481     on the whole complex plane (except the singular points):\n1482 \n1483     >>> Li(2).evalf(30)\n1484     0\n1485 \n1486     >>> Li(4).evalf(30)\n1487     1.92242131492155809316615998938\n1488 \n1489     See Also\n1490     ========\n1491 \n1492     li: Logarithmic integral.\n1493     Ei: Exponential integral.\n1494     expint: Generalised exponential integral.\n1495     E1: Special case of the generalised exponential integral.\n1496     Si: Sine integral.\n1497     Ci: Cosine integral.\n1498     Shi: Hyperbolic sine integral.\n1499     Chi: Hyperbolic cosine integral.\n1500 \n1501     References\n1502     ==========\n1503 \n1504     .. [1] https://en.wikipedia.org/wiki/Logarithmic_integral\n1505     .. [2] http://mathworld.wolfram.com/LogarithmicIntegral.html\n1506     .. [3] http://dlmf.nist.gov/6\n1507     \"\"\"\n1508 \n1509 \n1510     @classmethod\n1511     def eval(cls, z):\n1512         if z is S.Infinity:\n1513             return S.Infinity\n1514         elif z is 2*S.One:\n1515             return S.Zero\n1516 \n1517     def fdiff(self, argindex=1):\n1518         arg = self.args[0]\n1519         if argindex == 1:\n1520             return S.One / log(arg)\n1521         else:\n1522             raise ArgumentIndexError(self, argindex)\n1523 \n1524     def _eval_evalf(self, prec):\n1525         return self.rewrite(li).evalf(prec)\n1526 \n1527     def _eval_rewrite_as_li(self, z, **kwargs):\n1528         return li(z) - li(2)\n1529 \n1530     def _eval_rewrite_as_tractable(self, z, **kwargs):\n1531         return self.rewrite(li).rewrite(\"tractable\", deep=True)\n1532 \n1533 ###############################################################################\n1534 #################### TRIGONOMETRIC INTEGRALS ##################################\n1535 ###############################################################################\n1536 \n1537 class TrigonometricIntegral(Function):\n1538     \"\"\" Base class for trigonometric integrals. \"\"\"\n1539 \n1540 \n1541     @classmethod\n1542     def eval(cls, z):\n1543         if z == 0:\n1544             return cls._atzero\n1545         elif z is S.Infinity:\n1546             return cls._atinf()\n1547         elif z is S.NegativeInfinity:\n1548             return cls._atneginf()\n1549 \n1550         nz = z.extract_multiplicatively(polar_lift(I))\n1551         if nz is None and cls._trigfunc(0) == 0:\n1552             nz = z.extract_multiplicatively(I)\n1553         if nz is not None:\n1554             return cls._Ifactor(nz, 1)\n1555         nz = z.extract_multiplicatively(polar_lift(-I))\n1556         if nz is not None:\n1557             return cls._Ifactor(nz, -1)\n1558 \n1559         nz = z.extract_multiplicatively(polar_lift(-1))\n1560         if nz is None and cls._trigfunc(0) == 0:\n1561             nz = z.extract_multiplicatively(-1)\n1562         if nz is not None:\n1563             return cls._minusfactor(nz)\n1564 \n1565         nz, n = z.extract_branch_factor()\n1566         if n == 0 and nz == z:\n1567             return\n1568         return 2*pi*I*n*cls._trigfunc(0) + cls(nz)\n1569 \n1570     def fdiff(self, argindex=1):\n1571         from sympy import unpolarify\n1572         arg = unpolarify(self.args[0])\n1573         if argindex == 1:\n1574             return self._trigfunc(arg)/arg\n1575 \n1576     def _eval_rewrite_as_Ei(self, z, **kwargs):\n1577         return self._eval_rewrite_as_expint(z).rewrite(Ei)\n1578 \n1579     def _eval_rewrite_as_uppergamma(self, z, **kwargs):\n1580         from sympy import uppergamma\n1581         return self._eval_rewrite_as_expint(z).rewrite(uppergamma)\n1582 \n1583     def _eval_nseries(self, x, n, logx):\n1584         # NOTE this is fairly inefficient\n1585         from sympy import log, EulerGamma, Pow\n1586         n += 1\n1587         if self.args[0].subs(x, 0) != 0:\n1588             return super(TrigonometricIntegral, self)._eval_nseries(x, n, logx)\n1589         baseseries = self._trigfunc(x)._eval_nseries(x, n, logx)\n1590         if self._trigfunc(0) != 0:\n1591             baseseries -= 1\n1592         baseseries = baseseries.replace(Pow, lambda t, n: t**n/n, simultaneous=False)\n1593         if self._trigfunc(0) != 0:\n1594             baseseries += EulerGamma + log(x)\n1595         return baseseries.subs(x, self.args[0])._eval_nseries(x, n, logx)\n1596 \n1597 \n1598 class Si(TrigonometricIntegral):\n1599     r\"\"\"\n1600     Sine integral.\n1601 \n1602     This function is defined by\n1603 \n1604     .. math:: \\operatorname{Si}(z) = \\int_0^z \\frac{\\sin{t}}{t} \\mathrm{d}t.\n1605 \n1606     It is an entire function.\n1607 \n1608     Examples\n1609     ========\n1610 \n1611     >>> from sympy import Si\n1612     >>> from sympy.abc import z\n1613 \n1614     The sine integral is an antiderivative of sin(z)/z:\n1615 \n1616     >>> Si(z).diff(z)\n1617     sin(z)/z\n1618 \n1619     It is unbranched:\n1620 \n1621     >>> from sympy import exp_polar, I, pi\n1622     >>> Si(z*exp_polar(2*I*pi))\n1623     Si(z)\n1624 \n1625     Sine integral behaves much like ordinary sine under multiplication by ``I``:\n1626 \n1627     >>> Si(I*z)\n1628     I*Shi(z)\n1629     >>> Si(-z)\n1630     -Si(z)\n1631 \n1632     It can also be expressed in terms of exponential integrals, but beware\n1633     that the latter is branched:\n1634 \n1635     >>> from sympy import expint\n1636     >>> Si(z).rewrite(expint)\n1637     -I*(-expint(1, z*exp_polar(-I*pi/2))/2 +\n1638          expint(1, z*exp_polar(I*pi/2))/2) + pi/2\n1639 \n1640     It can be rewritten in the form of sinc function (By definition)\n1641 \n1642     >>> from sympy import sinc\n1643     >>> Si(z).rewrite(sinc)\n1644     Integral(sinc(t), (t, 0, z))\n1645 \n1646     See Also\n1647     ========\n1648 \n1649     Ci: Cosine integral.\n1650     Shi: Hyperbolic sine integral.\n1651     Chi: Hyperbolic cosine integral.\n1652     Ei: Exponential integral.\n1653     expint: Generalised exponential integral.\n1654     sinc: unnormalized sinc function\n1655     E1: Special case of the generalised exponential integral.\n1656     li: Logarithmic integral.\n1657     Li: Offset logarithmic integral.\n1658 \n1659     References\n1660     ==========\n1661 \n1662     .. [1] https://en.wikipedia.org/wiki/Trigonometric_integral\n1663 \n1664     \"\"\"\n1665 \n1666     _trigfunc = sin\n1667     _atzero = S(0)\n1668 \n1669     @classmethod\n1670     def _atinf(cls):\n1671         return pi*S.Half\n1672 \n1673     @classmethod\n1674     def _atneginf(cls):\n1675         return -pi*S.Half\n1676 \n1677     @classmethod\n1678     def _minusfactor(cls, z):\n1679         return -Si(z)\n1680 \n1681     @classmethod\n1682     def _Ifactor(cls, z, sign):\n1683         return I*Shi(z)*sign\n1684 \n1685     def _eval_rewrite_as_expint(self, z, **kwargs):\n1686         # XXX should we polarify z?\n1687         return pi/2 + (E1(polar_lift(I)*z) - E1(polar_lift(-I)*z))/2/I\n1688 \n1689     def _eval_rewrite_as_sinc(self, z, **kwargs):\n1690         from sympy import Integral\n1691         t = Symbol('t', Dummy=True)\n1692         return Integral(sinc(t), (t, 0, z))\n1693 \n1694     def _sage_(self):\n1695         import sage.all as sage\n1696         return sage.sin_integral(self.args[0]._sage_())\n1697 \n1698 class Ci(TrigonometricIntegral):\n1699     r\"\"\"\n1700     Cosine integral.\n1701 \n1702     This function is defined for positive `x` by\n1703 \n1704     .. math:: \\operatorname{Ci}(x) = \\gamma + \\log{x}\n1705                          + \\int_0^x \\frac{\\cos{t} - 1}{t} \\mathrm{d}t\n1706            = -\\int_x^\\infty \\frac{\\cos{t}}{t} \\mathrm{d}t,\n1707 \n1708     where `\\gamma` is the Euler-Mascheroni constant.\n1709 \n1710     We have\n1711 \n1712     .. math:: \\operatorname{Ci}(z) =\n1713         -\\frac{\\operatorname{E}_1\\left(e^{i\\pi/2} z\\right)\n1714                + \\operatorname{E}_1\\left(e^{-i \\pi/2} z\\right)}{2}\n1715 \n1716     which holds for all polar `z` and thus provides an analytic\n1717     continuation to the Riemann surface of the logarithm.\n1718 \n1719     The formula also holds as stated\n1720     for `z \\in \\mathbb{C}` with `\\Re(z) > 0`.\n1721     By lifting to the principal branch we obtain an analytic function on the\n1722     cut complex plane.\n1723 \n1724     Examples\n1725     ========\n1726 \n1727     >>> from sympy import Ci\n1728     >>> from sympy.abc import z\n1729 \n1730     The cosine integral is a primitive of `\\cos(z)/z`:\n1731 \n1732     >>> Ci(z).diff(z)\n1733     cos(z)/z\n1734 \n1735     It has a logarithmic branch point at the origin:\n1736 \n1737     >>> from sympy import exp_polar, I, pi\n1738     >>> Ci(z*exp_polar(2*I*pi))\n1739     Ci(z) + 2*I*pi\n1740 \n1741     The cosine integral behaves somewhat like ordinary `\\cos` under multiplication by `i`:\n1742 \n1743     >>> from sympy import polar_lift\n1744     >>> Ci(polar_lift(I)*z)\n1745     Chi(z) + I*pi/2\n1746     >>> Ci(polar_lift(-1)*z)\n1747     Ci(z) + I*pi\n1748 \n1749     It can also be expressed in terms of exponential integrals:\n1750 \n1751     >>> from sympy import expint\n1752     >>> Ci(z).rewrite(expint)\n1753     -expint(1, z*exp_polar(-I*pi/2))/2 - expint(1, z*exp_polar(I*pi/2))/2\n1754 \n1755     See Also\n1756     ========\n1757 \n1758     Si: Sine integral.\n1759     Shi: Hyperbolic sine integral.\n1760     Chi: Hyperbolic cosine integral.\n1761     Ei: Exponential integral.\n1762     expint: Generalised exponential integral.\n1763     E1: Special case of the generalised exponential integral.\n1764     li: Logarithmic integral.\n1765     Li: Offset logarithmic integral.\n1766 \n1767     References\n1768     ==========\n1769 \n1770     .. [1] https://en.wikipedia.org/wiki/Trigonometric_integral\n1771 \n1772     \"\"\"\n1773 \n1774     _trigfunc = cos\n1775     _atzero = S.ComplexInfinity\n1776 \n1777     @classmethod\n1778     def _atinf(cls):\n1779         return S.Zero\n1780 \n1781     @classmethod\n1782     def _atneginf(cls):\n1783         return I*pi\n1784 \n1785     @classmethod\n1786     def _minusfactor(cls, z):\n1787         return Ci(z) + I*pi\n1788 \n1789     @classmethod\n1790     def _Ifactor(cls, z, sign):\n1791         return Chi(z) + I*pi/2*sign\n1792 \n1793     def _eval_rewrite_as_expint(self, z, **kwargs):\n1794         return -(E1(polar_lift(I)*z) + E1(polar_lift(-I)*z))/2\n1795 \n1796     def _sage_(self):\n1797         import sage.all as sage\n1798         return sage.cos_integral(self.args[0]._sage_())\n1799 \n1800 \n1801 class Shi(TrigonometricIntegral):\n1802     r\"\"\"\n1803     Sinh integral.\n1804 \n1805     This function is defined by\n1806 \n1807     .. math:: \\operatorname{Shi}(z) = \\int_0^z \\frac{\\sinh{t}}{t} \\mathrm{d}t.\n1808 \n1809     It is an entire function.\n1810 \n1811     Examples\n1812     ========\n1813 \n1814     >>> from sympy import Shi\n1815     >>> from sympy.abc import z\n1816 \n1817     The Sinh integral is a primitive of `\\sinh(z)/z`:\n1818 \n1819     >>> Shi(z).diff(z)\n1820     sinh(z)/z\n1821 \n1822     It is unbranched:\n1823 \n1824     >>> from sympy import exp_polar, I, pi\n1825     >>> Shi(z*exp_polar(2*I*pi))\n1826     Shi(z)\n1827 \n1828     The `\\sinh` integral behaves much like ordinary `\\sinh` under multiplication by `i`:\n1829 \n1830     >>> Shi(I*z)\n1831     I*Si(z)\n1832     >>> Shi(-z)\n1833     -Shi(z)\n1834 \n1835     It can also be expressed in terms of exponential integrals, but beware\n1836     that the latter is branched:\n1837 \n1838     >>> from sympy import expint\n1839     >>> Shi(z).rewrite(expint)\n1840     expint(1, z)/2 - expint(1, z*exp_polar(I*pi))/2 - I*pi/2\n1841 \n1842     See Also\n1843     ========\n1844 \n1845     Si: Sine integral.\n1846     Ci: Cosine integral.\n1847     Chi: Hyperbolic cosine integral.\n1848     Ei: Exponential integral.\n1849     expint: Generalised exponential integral.\n1850     E1: Special case of the generalised exponential integral.\n1851     li: Logarithmic integral.\n1852     Li: Offset logarithmic integral.\n1853 \n1854     References\n1855     ==========\n1856 \n1857     .. [1] https://en.wikipedia.org/wiki/Trigonometric_integral\n1858 \n1859     \"\"\"\n1860 \n1861     _trigfunc = sinh\n1862     _atzero = S(0)\n1863 \n1864     @classmethod\n1865     def _atinf(cls):\n1866         return S.Infinity\n1867 \n1868     @classmethod\n1869     def _atneginf(cls):\n1870         return S.NegativeInfinity\n1871 \n1872     @classmethod\n1873     def _minusfactor(cls, z):\n1874         return -Shi(z)\n1875 \n1876     @classmethod\n1877     def _Ifactor(cls, z, sign):\n1878         return I*Si(z)*sign\n1879 \n1880     def _eval_rewrite_as_expint(self, z, **kwargs):\n1881         from sympy import exp_polar\n1882         # XXX should we polarify z?\n1883         return (E1(z) - E1(exp_polar(I*pi)*z))/2 - I*pi/2\n1884 \n1885     def _sage_(self):\n1886         import sage.all as sage\n1887         return sage.sinh_integral(self.args[0]._sage_())\n1888 \n1889 \n1890 class Chi(TrigonometricIntegral):\n1891     r\"\"\"\n1892     Cosh integral.\n1893 \n1894     This function is defined for positive :math:`x` by\n1895 \n1896     .. math:: \\operatorname{Chi}(x) = \\gamma + \\log{x}\n1897                          + \\int_0^x \\frac{\\cosh{t} - 1}{t} \\mathrm{d}t,\n1898 \n1899     where :math:`\\gamma` is the Euler-Mascheroni constant.\n1900 \n1901     We have\n1902 \n1903     .. math:: \\operatorname{Chi}(z) = \\operatorname{Ci}\\left(e^{i \\pi/2}z\\right)\n1904                          - i\\frac{\\pi}{2},\n1905 \n1906     which holds for all polar :math:`z` and thus provides an analytic\n1907     continuation to the Riemann surface of the logarithm.\n1908     By lifting to the principal branch we obtain an analytic function on the\n1909     cut complex plane.\n1910 \n1911     Examples\n1912     ========\n1913 \n1914     >>> from sympy import Chi\n1915     >>> from sympy.abc import z\n1916 \n1917     The `\\cosh` integral is a primitive of `\\cosh(z)/z`:\n1918 \n1919     >>> Chi(z).diff(z)\n1920     cosh(z)/z\n1921 \n1922     It has a logarithmic branch point at the origin:\n1923 \n1924     >>> from sympy import exp_polar, I, pi\n1925     >>> Chi(z*exp_polar(2*I*pi))\n1926     Chi(z) + 2*I*pi\n1927 \n1928     The `\\cosh` integral behaves somewhat like ordinary `\\cosh` under multiplication by `i`:\n1929 \n1930     >>> from sympy import polar_lift\n1931     >>> Chi(polar_lift(I)*z)\n1932     Ci(z) + I*pi/2\n1933     >>> Chi(polar_lift(-1)*z)\n1934     Chi(z) + I*pi\n1935 \n1936     It can also be expressed in terms of exponential integrals:\n1937 \n1938     >>> from sympy import expint\n1939     >>> Chi(z).rewrite(expint)\n1940     -expint(1, z)/2 - expint(1, z*exp_polar(I*pi))/2 - I*pi/2\n1941 \n1942     See Also\n1943     ========\n1944 \n1945     Si: Sine integral.\n1946     Ci: Cosine integral.\n1947     Shi: Hyperbolic sine integral.\n1948     Ei: Exponential integral.\n1949     expint: Generalised exponential integral.\n1950     E1: Special case of the generalised exponential integral.\n1951     li: Logarithmic integral.\n1952     Li: Offset logarithmic integral.\n1953 \n1954     References\n1955     ==========\n1956 \n1957     .. [1] https://en.wikipedia.org/wiki/Trigonometric_integral\n1958 \n1959     \"\"\"\n1960 \n1961     _trigfunc = cosh\n1962     _atzero = S.ComplexInfinity\n1963 \n1964     @classmethod\n1965     def _atinf(cls):\n1966         return S.Infinity\n1967 \n1968     @classmethod\n1969     def _atneginf(cls):\n1970         return S.Infinity\n1971 \n1972     @classmethod\n1973     def _minusfactor(cls, z):\n1974         return Chi(z) + I*pi\n1975 \n1976     @classmethod\n1977     def _Ifactor(cls, z, sign):\n1978         return Ci(z) + I*pi/2*sign\n1979 \n1980     def _eval_rewrite_as_expint(self, z, **kwargs):\n1981         from sympy import exp_polar\n1982         return -I*pi/2 - (E1(z) + E1(exp_polar(I*pi)*z))/2\n1983 \n1984     def _sage_(self):\n1985         import sage.all as sage\n1986         return sage.cosh_integral(self.args[0]._sage_())\n1987 \n1988 \n1989 ###############################################################################\n1990 #################### FRESNEL INTEGRALS ########################################\n1991 ###############################################################################\n1992 \n1993 class FresnelIntegral(Function):\n1994     \"\"\" Base class for the Fresnel integrals.\"\"\"\n1995 \n1996     unbranched = True\n1997 \n1998     @classmethod\n1999     def eval(cls, z):\n2000         # Value at zero\n2001         if z is S.Zero:\n2002             return S(0)\n2003 \n2004         # Try to pull out factors of -1 and I\n2005         prefact = S.One\n2006         newarg = z\n2007         changed = False\n2008 \n2009         nz = newarg.extract_multiplicatively(-1)\n2010         if nz is not None:\n2011             prefact = -prefact\n2012             newarg = nz\n2013             changed = True\n2014 \n2015         nz = newarg.extract_multiplicatively(I)\n2016         if nz is not None:\n2017             prefact = cls._sign*I*prefact\n2018             newarg = nz\n2019             changed = True\n2020 \n2021         if changed:\n2022             return prefact*cls(newarg)\n2023 \n2024         # Values at positive infinities signs\n2025         # if any were extracted automatically\n2026         if z is S.Infinity:\n2027             return S.Half\n2028         elif z is I*S.Infinity:\n2029             return cls._sign*I*S.Half\n2030 \n2031     def fdiff(self, argindex=1):\n2032         if argindex == 1:\n2033             return self._trigfunc(S.Half*pi*self.args[0]**2)\n2034         else:\n2035             raise ArgumentIndexError(self, argindex)\n2036 \n2037     def _eval_is_real(self):\n2038         return self.args[0].is_real\n2039 \n2040     def _eval_conjugate(self):\n2041         return self.func(self.args[0].conjugate())\n2042 \n2043     def _as_real_imag(self, deep=True, **hints):\n2044         if self.args[0].is_real:\n2045             if deep:\n2046                 hints['complex'] = False\n2047                 return (self.expand(deep, **hints), S.Zero)\n2048             else:\n2049                 return (self, S.Zero)\n2050         if deep:\n2051             re, im = self.args[0].expand(deep, **hints).as_real_imag()\n2052         else:\n2053             re, im = self.args[0].as_real_imag()\n2054         return (re, im)\n2055 \n2056     def as_real_imag(self, deep=True, **hints):\n2057         # Fresnel S\n2058         # http://functions.wolfram.com/06.32.19.0003.01\n2059         # http://functions.wolfram.com/06.32.19.0006.01\n2060         # Fresnel C\n2061         # http://functions.wolfram.com/06.33.19.0003.01\n2062         # http://functions.wolfram.com/06.33.19.0006.01\n2063         x, y = self._as_real_imag(deep=deep, **hints)\n2064         sq = -y**2/x**2\n2065         re = S.Half*(self.func(x + x*sqrt(sq)) + self.func(x - x*sqrt(sq)))\n2066         im = x/(2*y) * sqrt(sq) * (self.func(x - x*sqrt(sq)) -\n2067                 self.func(x + x*sqrt(sq)))\n2068         return (re, im)\n2069 \n2070 \n2071 class fresnels(FresnelIntegral):\n2072     r\"\"\"\n2073     Fresnel integral S.\n2074 \n2075     This function is defined by\n2076 \n2077     .. math:: \\operatorname{S}(z) = \\int_0^z \\sin{\\frac{\\pi}{2} t^2} \\mathrm{d}t.\n2078 \n2079     It is an entire function.\n2080 \n2081     Examples\n2082     ========\n2083 \n2084     >>> from sympy import I, oo, fresnels\n2085     >>> from sympy.abc import z\n2086 \n2087     Several special values are known:\n2088 \n2089     >>> fresnels(0)\n2090     0\n2091     >>> fresnels(oo)\n2092     1/2\n2093     >>> fresnels(-oo)\n2094     -1/2\n2095     >>> fresnels(I*oo)\n2096     -I/2\n2097     >>> fresnels(-I*oo)\n2098     I/2\n2099 \n2100     In general one can pull out factors of -1 and `i` from the argument:\n2101 \n2102     >>> fresnels(-z)\n2103     -fresnels(z)\n2104     >>> fresnels(I*z)\n2105     -I*fresnels(z)\n2106 \n2107     The Fresnel S integral obeys the mirror symmetry\n2108     `\\overline{S(z)} = S(\\bar{z})`:\n2109 \n2110     >>> from sympy import conjugate\n2111     >>> conjugate(fresnels(z))\n2112     fresnels(conjugate(z))\n2113 \n2114     Differentiation with respect to `z` is supported:\n2115 \n2116     >>> from sympy import diff\n2117     >>> diff(fresnels(z), z)\n2118     sin(pi*z**2/2)\n2119 \n2120     Defining the Fresnel functions via an integral\n2121 \n2122     >>> from sympy import integrate, pi, sin, gamma, expand_func\n2123     >>> integrate(sin(pi*z**2/2), z)\n2124     3*fresnels(z)*gamma(3/4)/(4*gamma(7/4))\n2125     >>> expand_func(integrate(sin(pi*z**2/2), z))\n2126     fresnels(z)\n2127 \n2128     We can numerically evaluate the Fresnel integral to arbitrary precision\n2129     on the whole complex plane:\n2130 \n2131     >>> fresnels(2).evalf(30)\n2132     0.343415678363698242195300815958\n2133 \n2134     >>> fresnels(-2*I).evalf(30)\n2135     0.343415678363698242195300815958*I\n2136 \n2137     See Also\n2138     ========\n2139 \n2140     fresnelc: Fresnel cosine integral.\n2141 \n2142     References\n2143     ==========\n2144 \n2145     .. [1] https://en.wikipedia.org/wiki/Fresnel_integral\n2146     .. [2] http://dlmf.nist.gov/7\n2147     .. [3] http://mathworld.wolfram.com/FresnelIntegrals.html\n2148     .. [4] http://functions.wolfram.com/GammaBetaErf/FresnelS\n2149     .. [5] The converging factors for the fresnel integrals\n2150             by John W. Wrench Jr. and Vicki Alley\n2151 \n2152     \"\"\"\n2153     _trigfunc = sin\n2154     _sign = -S.One\n2155 \n2156     @staticmethod\n2157     @cacheit\n2158     def taylor_term(n, x, *previous_terms):\n2159         if n < 0:\n2160             return S.Zero\n2161         else:\n2162             x = sympify(x)\n2163             if len(previous_terms) > 1:\n2164                 p = previous_terms[-1]\n2165                 return (-pi**2*x**4*(4*n - 1)/(8*n*(2*n + 1)*(4*n + 3))) * p\n2166             else:\n2167                 return x**3 * (-x**4)**n * (S(2)**(-2*n - 1)*pi**(2*n + 1)) / ((4*n + 3)*factorial(2*n + 1))\n2168 \n2169     def _eval_rewrite_as_erf(self, z, **kwargs):\n2170         return (S.One + I)/4 * (erf((S.One + I)/2*sqrt(pi)*z) - I*erf((S.One - I)/2*sqrt(pi)*z))\n2171 \n2172     def _eval_rewrite_as_hyper(self, z, **kwargs):\n2173         return pi*z**3/6 * hyper([S(3)/4], [S(3)/2, S(7)/4], -pi**2*z**4/16)\n2174 \n2175     def _eval_rewrite_as_meijerg(self, z, **kwargs):\n2176         return (pi*z**(S(9)/4) / (sqrt(2)*(z**2)**(S(3)/4)*(-z)**(S(3)/4))\n2177                 * meijerg([], [1], [S(3)/4], [S(1)/4, 0], -pi**2*z**4/16))\n2178 \n2179     def _eval_aseries(self, n, args0, x, logx):\n2180         from sympy import Order\n2181         point = args0[0]\n2182 \n2183         # Expansion at oo and -oo\n2184         if point in [S.Infinity, -S.Infinity]:\n2185             z = self.args[0]\n2186 \n2187             # expansion of S(x) = S1(x*sqrt(pi/2)), see reference[5] page 1-8\n2188             # as only real infinities are dealt with, sin and cos are O(1)\n2189             p = [(-1)**k * factorial(4*k + 1) /\n2190                  (2**(2*k + 2) * z**(4*k + 3) * 2**(2*k)*factorial(2*k))\n2191                  for k in range(0, n) if 4*k + 3 < n]\n2192             q = [1/(2*z)] + [(-1)**k * factorial(4*k - 1) /\n2193                  (2**(2*k + 1) * z**(4*k + 1) * 2**(2*k - 1)*factorial(2*k - 1))\n2194                  for k in range(1, n) if 4*k + 1 < n]\n2195 \n2196             p = [-sqrt(2/pi)*t for t in p]\n2197             q = [-sqrt(2/pi)*t for t in q]\n2198             s = 1 if point is S.Infinity else -1\n2199             # The expansion at oo is 1/2 + some odd powers of z\n2200             # To get the expansion at -oo, replace z by -z and flip the sign\n2201             # The result -1/2 + the same odd powers of z as before.\n2202             return s*S.Half + (sin(z**2)*Add(*p) + cos(z**2)*Add(*q)\n2203                 ).subs(x, sqrt(2/pi)*x) + Order(1/z**n, x)\n2204 \n2205         # All other points are not handled\n2206         return super(fresnels, self)._eval_aseries(n, args0, x, logx)\n2207 \n2208 \n2209 class fresnelc(FresnelIntegral):\n2210     r\"\"\"\n2211     Fresnel integral C.\n2212 \n2213     This function is defined by\n2214 \n2215     .. math:: \\operatorname{C}(z) = \\int_0^z \\cos{\\frac{\\pi}{2} t^2} \\mathrm{d}t.\n2216 \n2217     It is an entire function.\n2218 \n2219     Examples\n2220     ========\n2221 \n2222     >>> from sympy import I, oo, fresnelc\n2223     >>> from sympy.abc import z\n2224 \n2225     Several special values are known:\n2226 \n2227     >>> fresnelc(0)\n2228     0\n2229     >>> fresnelc(oo)\n2230     1/2\n2231     >>> fresnelc(-oo)\n2232     -1/2\n2233     >>> fresnelc(I*oo)\n2234     I/2\n2235     >>> fresnelc(-I*oo)\n2236     -I/2\n2237 \n2238     In general one can pull out factors of -1 and `i` from the argument:\n2239 \n2240     >>> fresnelc(-z)\n2241     -fresnelc(z)\n2242     >>> fresnelc(I*z)\n2243     I*fresnelc(z)\n2244 \n2245     The Fresnel C integral obeys the mirror symmetry\n2246     `\\overline{C(z)} = C(\\bar{z})`:\n2247 \n2248     >>> from sympy import conjugate\n2249     >>> conjugate(fresnelc(z))\n2250     fresnelc(conjugate(z))\n2251 \n2252     Differentiation with respect to `z` is supported:\n2253 \n2254     >>> from sympy import diff\n2255     >>> diff(fresnelc(z), z)\n2256     cos(pi*z**2/2)\n2257 \n2258     Defining the Fresnel functions via an integral\n2259 \n2260     >>> from sympy import integrate, pi, cos, gamma, expand_func\n2261     >>> integrate(cos(pi*z**2/2), z)\n2262     fresnelc(z)*gamma(1/4)/(4*gamma(5/4))\n2263     >>> expand_func(integrate(cos(pi*z**2/2), z))\n2264     fresnelc(z)\n2265 \n2266     We can numerically evaluate the Fresnel integral to arbitrary precision\n2267     on the whole complex plane:\n2268 \n2269     >>> fresnelc(2).evalf(30)\n2270     0.488253406075340754500223503357\n2271 \n2272     >>> fresnelc(-2*I).evalf(30)\n2273     -0.488253406075340754500223503357*I\n2274 \n2275     See Also\n2276     ========\n2277 \n2278     fresnels: Fresnel sine integral.\n2279 \n2280     References\n2281     ==========\n2282 \n2283     .. [1] https://en.wikipedia.org/wiki/Fresnel_integral\n2284     .. [2] http://dlmf.nist.gov/7\n2285     .. [3] http://mathworld.wolfram.com/FresnelIntegrals.html\n2286     .. [4] http://functions.wolfram.com/GammaBetaErf/FresnelC\n2287     .. [5] The converging factors for the fresnel integrals\n2288             by John W. Wrench Jr. and Vicki Alley\n2289     \"\"\"\n2290     _trigfunc = cos\n2291     _sign = S.One\n2292 \n2293     @staticmethod\n2294     @cacheit\n2295     def taylor_term(n, x, *previous_terms):\n2296         if n < 0:\n2297             return S.Zero\n2298         else:\n2299             x = sympify(x)\n2300             if len(previous_terms) > 1:\n2301                 p = previous_terms[-1]\n2302                 return (-pi**2*x**4*(4*n - 3)/(8*n*(2*n - 1)*(4*n + 1))) * p\n2303             else:\n2304                 return x * (-x**4)**n * (S(2)**(-2*n)*pi**(2*n)) / ((4*n + 1)*factorial(2*n))\n2305 \n2306     def _eval_rewrite_as_erf(self, z, **kwargs):\n2307         return (S.One - I)/4 * (erf((S.One + I)/2*sqrt(pi)*z) + I*erf((S.One - I)/2*sqrt(pi)*z))\n2308 \n2309     def _eval_rewrite_as_hyper(self, z, **kwargs):\n2310         return z * hyper([S.One/4], [S.One/2, S(5)/4], -pi**2*z**4/16)\n2311 \n2312     def _eval_rewrite_as_meijerg(self, z, **kwargs):\n2313         return (pi*z**(S(3)/4) / (sqrt(2)*root(z**2, 4)*root(-z, 4))\n2314                 * meijerg([], [1], [S(1)/4], [S(3)/4, 0], -pi**2*z**4/16))\n2315 \n2316     def _eval_aseries(self, n, args0, x, logx):\n2317         from sympy import Order\n2318         point = args0[0]\n2319 \n2320         # Expansion at oo\n2321         if point in [S.Infinity, -S.Infinity]:\n2322             z = self.args[0]\n2323 \n2324             # expansion of C(x) = C1(x*sqrt(pi/2)), see reference[5] page 1-8\n2325             # as only real infinities are dealt with, sin and cos are O(1)\n2326             p = [(-1)**k * factorial(4*k + 1) /\n2327                  (2**(2*k + 2) * z**(4*k + 3) * 2**(2*k)*factorial(2*k))\n2328                  for k in range(0, n) if 4*k + 3 < n]\n2329             q = [1/(2*z)] + [(-1)**k * factorial(4*k - 1) /\n2330                  (2**(2*k + 1) * z**(4*k + 1) * 2**(2*k - 1)*factorial(2*k - 1))\n2331                  for k in range(1, n) if 4*k + 1 < n]\n2332 \n2333             p = [-sqrt(2/pi)*t for t in p]\n2334             q = [ sqrt(2/pi)*t for t in q]\n2335             s = 1 if point is S.Infinity else -1\n2336             # The expansion at oo is 1/2 + some odd powers of z\n2337             # To get the expansion at -oo, replace z by -z and flip the sign\n2338             # The result -1/2 + the same odd powers of z as before.\n2339             return s*S.Half + (cos(z**2)*Add(*p) + sin(z**2)*Add(*q)\n2340                 ).subs(x, sqrt(2/pi)*x) + Order(1/z**n, x)\n2341 \n2342         # All other points are not handled\n2343         return super(fresnelc, self)._eval_aseries(n, args0, x, logx)\n2344 \n2345 \n2346 ###############################################################################\n2347 #################### HELPER FUNCTIONS #########################################\n2348 ###############################################################################\n2349 \n2350 \n2351 class _erfs(Function):\n2352     \"\"\"\n2353     Helper function to make the `\\\\mathrm{erf}(z)` function\n2354     tractable for the Gruntz algorithm.\n2355     \"\"\"\n2356 \n2357 \n2358     def _eval_aseries(self, n, args0, x, logx):\n2359         from sympy import Order\n2360         point = args0[0]\n2361 \n2362         # Expansion at oo\n2363         if point is S.Infinity:\n2364             z = self.args[0]\n2365             l = [ 1/sqrt(S.Pi) * factorial(2*k)*(-S(\n2366                 4))**(-k)/factorial(k) * (1/z)**(2*k + 1) for k in range(0, n) ]\n2367             o = Order(1/z**(2*n + 1), x)\n2368             # It is very inefficient to first add the order and then do the nseries\n2369             return (Add(*l))._eval_nseries(x, n, logx) + o\n2370 \n2371         # Expansion at I*oo\n2372         t = point.extract_multiplicatively(S.ImaginaryUnit)\n2373         if t is S.Infinity:\n2374             z = self.args[0]\n2375             # TODO: is the series really correct?\n2376             l = [ 1/sqrt(S.Pi) * factorial(2*k)*(-S(\n2377                 4))**(-k)/factorial(k) * (1/z)**(2*k + 1) for k in range(0, n) ]\n2378             o = Order(1/z**(2*n + 1), x)\n2379             # It is very inefficient to first add the order and then do the nseries\n2380             return (Add(*l))._eval_nseries(x, n, logx) + o\n2381 \n2382         # All other points are not handled\n2383         return super(_erfs, self)._eval_aseries(n, args0, x, logx)\n2384 \n2385     def fdiff(self, argindex=1):\n2386         if argindex == 1:\n2387             z = self.args[0]\n2388             return -2/sqrt(S.Pi) + 2*z*_erfs(z)\n2389         else:\n2390             raise ArgumentIndexError(self, argindex)\n2391 \n2392     def _eval_rewrite_as_intractable(self, z, **kwargs):\n2393         return (S.One - erf(z))*exp(z**2)\n2394 \n2395 \n2396 class _eis(Function):\n2397     \"\"\"\n2398     Helper function to make the `\\\\mathrm{Ei}(z)` and `\\\\mathrm{li}(z)` functions\n2399     tractable for the Gruntz algorithm.\n2400     \"\"\"\n2401 \n2402 \n2403     def _eval_aseries(self, n, args0, x, logx):\n2404         from sympy import Order\n2405         if args0[0] != S.Infinity:\n2406             return super(_erfs, self)._eval_aseries(n, args0, x, logx)\n2407 \n2408         z = self.args[0]\n2409         l = [ factorial(k) * (1/z)**(k + 1) for k in range(0, n) ]\n2410         o = Order(1/z**(n + 1), x)\n2411         # It is very inefficient to first add the order and then do the nseries\n2412         return (Add(*l))._eval_nseries(x, n, logx) + o\n2413 \n2414 \n2415     def fdiff(self, argindex=1):\n2416         if argindex == 1:\n2417             z = self.args[0]\n2418             return S.One / z - _eis(z)\n2419         else:\n2420             raise ArgumentIndexError(self, argindex)\n2421 \n2422     def _eval_rewrite_as_intractable(self, z, **kwargs):\n2423         return exp(-z)*Ei(z)\n2424 \n2425     def _eval_nseries(self, x, n, logx):\n2426         x0 = self.args[0].limit(x, 0)\n2427         if x0 is S.Zero:\n2428             f = self._eval_rewrite_as_intractable(*self.args)\n2429             return f._eval_nseries(x, n, logx)\n2430         return super(_eis, self)._eval_nseries(x, n, logx)\n",
        "intended_behavior": "The use of \\mathrm within the error functions (i.e., _erfs and _eis classes) is consistent but not configurable. To resolve the issue, either maintain the use of \\mathrm as the standard due to its simplicity and lack of additional package dependencies or introduce a helper function/utility method within this file (or at a more global scope accessible by this file) that abstracts away the choice between \\text and \\mathrm. This method should allow for configuration at the library level, determining which command to use based on user preference or a global setting. The existing functionality of rendering mathematical expressions accurately should be preserved, with added flexibility for font adaptiveness where required."
    },
    {
        "rel_file_path": "sympy/integrals/meijerint_doc.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sympy__sympy/setup_sympy__sympy__1.4/sympy/integrals/meijerint_doc.py",
        "start": 1,
        "end": 32,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\" This module cooks up a docstring when imported. Its only purpose is to\n2     be displayed in the sphinx documentation. \"\"\"\n3 \n4 from __future__ import print_function, division\n5 \n6 from sympy.integrals.meijerint import _create_lookup_table\n7 from sympy import latex, Eq, Add, Symbol\n8 \n9 t = {}\n10 _create_lookup_table(t)\n11 \n12 doc = \"\"\n13 \n14 for about, category in sorted(t.items()):\n15     if about == ():\n16         doc += 'Elementary functions:\\n\\n'\n17     else:\n18         doc += 'Functions involving ' + ', '.join('`%s`' % latex(\n19             list(category[0][0].atoms(func))[0]) for func in about) + ':\\n\\n'\n20     for formula, gs, cond, hint in category:\n21         if not isinstance(gs, list):\n22             g = Symbol('\\\\text{generated}')\n23         else:\n24             g = Add(*[fac*f for (fac, f) in gs])\n25         obj = Eq(formula, g)\n26         if cond is True:\n27             cond = \"\"\n28         else:\n29             cond = ',\\\\text{ if } %s' % latex(cond)\n30         doc += \".. math::\\n  %s%s\\n\\n\" % (latex(obj), cond)\n31 \n32 __doc__ = doc\n",
        "intended_behavior": "Here, the \\text command is used to adapt the font of textual content within mathematical expressions in dynamic documentation. The intended behavior should ensure that any conditional statements or symbols added to the documentation continue to match the style of the surrounding maths content. Implementing a similar helper function/utility method that chooses between \\text and \\mathrm based on a configurable setting would standardize the approach and potentially enhance adaptability. This utility method should be used wherever such textual content is integrated with mathematical expressions to ensure consistency and configurability throughout the project. The method should default to \\text to preserve the adaptiveness with the math font but allow for \\mathrm if specified by the user or the project settings."
    }
]