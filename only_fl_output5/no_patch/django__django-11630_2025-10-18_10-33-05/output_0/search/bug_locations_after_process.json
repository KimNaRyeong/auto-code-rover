[
    {
        "rel_file_path": "django/core/checks/model_checks.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.0/django/core/checks/model_checks.py",
        "start": 1,
        "end": 198,
        "class_name": null,
        "method_name": null,
        "code": "1 import inspect\n2 import types\n3 from collections import defaultdict\n4 from itertools import chain\n5 \n6 from django.apps import apps\n7 from django.core.checks import Error, Tags, register\n8 \n9 \n10 @register(Tags.models)\n11 def check_all_models(app_configs=None, **kwargs):\n12     db_table_models = defaultdict(list)\n13     indexes = defaultdict(list)\n14     constraints = defaultdict(list)\n15     errors = []\n16     if app_configs is None:\n17         models = apps.get_models()\n18     else:\n19         models = chain.from_iterable(app_config.get_models() for app_config in app_configs)\n20     for model in models:\n21         if model._meta.managed and not model._meta.proxy:\n22             db_table_models[model._meta.db_table].append(model._meta.label)\n23         if not inspect.ismethod(model.check):\n24             errors.append(\n25                 Error(\n26                     \"The '%s.check()' class method is currently overridden by %r.\"\n27                     % (model.__name__, model.check),\n28                     obj=model,\n29                     id='models.E020'\n30                 )\n31             )\n32         else:\n33             errors.extend(model.check(**kwargs))\n34         for model_index in model._meta.indexes:\n35             indexes[model_index.name].append(model._meta.label)\n36         for model_constraint in model._meta.constraints:\n37             constraints[model_constraint.name].append(model._meta.label)\n38     for db_table, model_labels in db_table_models.items():\n39         if len(model_labels) != 1:\n40             errors.append(\n41                 Error(\n42                     \"db_table '%s' is used by multiple models: %s.\"\n43                     % (db_table, ', '.join(db_table_models[db_table])),\n44                     obj=db_table,\n45                     id='models.E028',\n46                 )\n47             )\n48     for index_name, model_labels in indexes.items():\n49         if len(model_labels) > 1:\n50             model_labels = set(model_labels)\n51             errors.append(\n52                 Error(\n53                     \"index name '%s' is not unique %s %s.\" % (\n54                         index_name,\n55                         'for model' if len(model_labels) == 1 else 'amongst models:',\n56                         ', '.join(sorted(model_labels)),\n57                     ),\n58                     id='models.E029' if len(model_labels) == 1 else 'models.E030',\n59                 ),\n60             )\n61     for constraint_name, model_labels in constraints.items():\n62         if len(model_labels) > 1:\n63             model_labels = set(model_labels)\n64             errors.append(\n65                 Error(\n66                     \"constraint name '%s' is not unique %s %s.\" % (\n67                         constraint_name,\n68                         'for model' if len(model_labels) == 1 else 'amongst models:',\n69                         ', '.join(sorted(model_labels)),\n70                     ),\n71                     id='models.E031' if len(model_labels) == 1 else 'models.E032',\n72                 ),\n73             )\n74     return errors\n75 \n76 \n77 def _check_lazy_references(apps, ignore=None):\n78     \"\"\"\n79     Ensure all lazy (i.e. string) model references have been resolved.\n80 \n81     Lazy references are used in various places throughout Django, primarily in\n82     related fields and model signals. Identify those common cases and provide\n83     more helpful error messages for them.\n84 \n85     The ignore parameter is used by StateApps to exclude swappable models from\n86     this check.\n87     \"\"\"\n88     pending_models = set(apps._pending_operations) - (ignore or set())\n89 \n90     # Short circuit if there aren't any errors.\n91     if not pending_models:\n92         return []\n93 \n94     from django.db.models import signals\n95     model_signals = {\n96         signal: name for name, signal in vars(signals).items()\n97         if isinstance(signal, signals.ModelSignal)\n98     }\n99 \n100     def extract_operation(obj):\n101         \"\"\"\n102         Take a callable found in Apps._pending_operations and identify the\n103         original callable passed to Apps.lazy_model_operation(). If that\n104         callable was a partial, return the inner, non-partial function and\n105         any arguments and keyword arguments that were supplied with it.\n106 \n107         obj is a callback defined locally in Apps.lazy_model_operation() and\n108         annotated there with a `func` attribute so as to imitate a partial.\n109         \"\"\"\n110         operation, args, keywords = obj, [], {}\n111         while hasattr(operation, 'func'):\n112             args.extend(getattr(operation, 'args', []))\n113             keywords.update(getattr(operation, 'keywords', {}))\n114             operation = operation.func\n115         return operation, args, keywords\n116 \n117     def app_model_error(model_key):\n118         try:\n119             apps.get_app_config(model_key[0])\n120             model_error = \"app '%s' doesn't provide model '%s'\" % model_key\n121         except LookupError:\n122             model_error = \"app '%s' isn't installed\" % model_key[0]\n123         return model_error\n124 \n125     # Here are several functions which return CheckMessage instances for the\n126     # most common usages of lazy operations throughout Django. These functions\n127     # take the model that was being waited on as an (app_label, modelname)\n128     # pair, the original lazy function, and its positional and keyword args as\n129     # determined by extract_operation().\n130 \n131     def field_error(model_key, func, args, keywords):\n132         error_msg = (\n133             \"The field %(field)s was declared with a lazy reference \"\n134             \"to '%(model)s', but %(model_error)s.\"\n135         )\n136         params = {\n137             'model': '.'.join(model_key),\n138             'field': keywords['field'],\n139             'model_error': app_model_error(model_key),\n140         }\n141         return Error(error_msg % params, obj=keywords['field'], id='fields.E307')\n142 \n143     def signal_connect_error(model_key, func, args, keywords):\n144         error_msg = (\n145             \"%(receiver)s was connected to the '%(signal)s' signal with a \"\n146             \"lazy reference to the sender '%(model)s', but %(model_error)s.\"\n147         )\n148         receiver = args[0]\n149         # The receiver is either a function or an instance of class\n150         # defining a `__call__` method.\n151         if isinstance(receiver, types.FunctionType):\n152             description = \"The function '%s'\" % receiver.__name__\n153         elif isinstance(receiver, types.MethodType):\n154             description = \"Bound method '%s.%s'\" % (receiver.__self__.__class__.__name__, receiver.__name__)\n155         else:\n156             description = \"An instance of class '%s'\" % receiver.__class__.__name__\n157         signal_name = model_signals.get(func.__self__, 'unknown')\n158         params = {\n159             'model': '.'.join(model_key),\n160             'receiver': description,\n161             'signal': signal_name,\n162             'model_error': app_model_error(model_key),\n163         }\n164         return Error(error_msg % params, obj=receiver.__module__, id='signals.E001')\n165 \n166     def default_error(model_key, func, args, keywords):\n167         error_msg = \"%(op)s contains a lazy reference to %(model)s, but %(model_error)s.\"\n168         params = {\n169             'op': func,\n170             'model': '.'.join(model_key),\n171             'model_error': app_model_error(model_key),\n172         }\n173         return Error(error_msg % params, obj=func, id='models.E022')\n174 \n175     # Maps common uses of lazy operations to corresponding error functions\n176     # defined above. If a key maps to None, no error will be produced.\n177     # default_error() will be used for usages that don't appear in this dict.\n178     known_lazy = {\n179         ('django.db.models.fields.related', 'resolve_related_class'): field_error,\n180         ('django.db.models.fields.related', 'set_managed'): None,\n181         ('django.dispatch.dispatcher', 'connect'): signal_connect_error,\n182     }\n183 \n184     def build_error(model_key, func, args, keywords):\n185         key = (func.__module__, func.__name__)\n186         error_fn = known_lazy.get(key, default_error)\n187         return error_fn(model_key, func, args, keywords) if error_fn else None\n188 \n189     return sorted(filter(None, (\n190         build_error(model_key, *extract_operation(func))\n191         for model_key in pending_models\n192         for func in apps._pending_operations[model_key]\n193     )), key=lambda error: error.msg)\n194 \n195 \n196 @register(Tags.models)\n197 def check_lazy_references(app_configs=None, **kwargs):\n198     return _check_lazy_references(apps)\n",
        "intended_behavior": "Adaptation or modification (if possible and advisable) could involve adding conditions or hooks that allow exempting certain app-model combinations from this check based on their database routing configurations, thus preserving the project's multi-database functionality without interfering with Django's integrity checks."
    }
]