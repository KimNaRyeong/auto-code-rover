2025-10-18 14:37:44.077 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-18 14:37:47.231 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=888, output_tokens=12, cost=0.009240
2025-10-18 14:37:58.021 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1068, output_tokens=483, cost=0.025170
2025-10-18 14:37:59.356 | INFO     | registered non reproducing test 0
2025-10-18 14:38:13.997 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2165, output_tokens=709, cost=0.042920
2025-10-18 14:38:15.300 | INFO     | registered non reproducing test 1
2025-10-18 14:38:29.578 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2236, output_tokens=661, cost=0.042190
2025-10-18 14:38:30.886 | INFO     | registered non reproducing test 2
2025-10-18 14:38:30.886 | WARNING  | Failed to write a reproducer test; skipping reproducer tracing
2025-10-18 14:38:30.889 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 14:38:37.387 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1084, output_tokens=285, cost=0.019390
2025-10-18 14:38:37.394 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 14:38:40.177 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=639, output_tokens=51, cost=0.007920
2025-10-18 14:38:40.178 | DEBUG    | Extracted a valid json.
2025-10-18 14:38:40.178 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_method(\"matplotlib\")",
        "search_method(\"show\")",
        "search_code(\"ion()\")",
        "search_code(\"ioff()\")"
    ],
    "bug_locations": []
}
2025-10-18 14:38:40.396 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-18 14:38:40.397 | DEBUG    | <Agent search> Analyzing search results.
2025-10-18 14:39:03.246 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=3149, output_tokens=862, cost=0.057350
2025-10-18 14:39:03.254 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 14:39:08.438 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=4227, output_tokens=213, cost=0.048660
2025-10-18 14:39:08.442 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 14:39:13.878 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=567, output_tokens=160, cost=0.010470
2025-10-18 14:39:13.879 | DEBUG    | Extracted a valid json.
2025-10-18 14:39:13.885 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "lib/matplotlib/backends/backend_qt.py",
            "class": "",
            "method": "show",
            "intended_behavior": "This code should modify or supplement the existing `show` method to check for a transition between `qt5` and `inline` and implement a mechanism to preserve any open GUI windows."
        },
        {
            "file": "lib/matplotlib/pyplot.py",
            "class": "",
            "method": "ion and ioff",
            "intended_behavior": "These functions should ensure switching interactive mode on or off does not inadvertently close GUI windows that were intended to remain open across backend transitions, by adding context awareness."
        }
    ]
}
2025-10-18 14:39:13.903 | DEBUG    | Bug location extracted successfully: [<file>lib/matplotlib/backends/backend_qt.py</file>
<class>None</class>
<method>show</method>
<code>
596     def show(self):
597         self.window.show()
598         if mpl.rcParams['figure.raise_window']:
599             self.window.activateWindow()
600             self.window.raise_()

</code><intended_behavior>This code should modify or supplement the existing `show` method to check for a transition between `qt5` and `inline` and implement a mechanism to preserve any open GUI windows.</intended_behavior>, <file>lib/matplotlib/backends/backend_qt.py</file>
<class>FigureManagerQT</class>
<method>show</method>
<code>
596     def show(self):
597         self.window.show()
598         if mpl.rcParams['figure.raise_window']:
599             self.window.activateWindow()
600             self.window.raise_()

</code><intended_behavior>This code should modify or supplement the existing `show` method to check for a transition between `qt5` and `inline` and implement a mechanism to preserve any open GUI windows.</intended_behavior>, <file>lib/matplotlib/pyplot.py</file>
<class>None</class>
<method>None</method>
<code>
1 # Note: The first part of this file can be modified in place, but the latter
2 # part is autogenerated by the boilerplate.py script.
3 
4 """
5 `matplotlib.pyplot` is a state-based interface to matplotlib. It provides
6 an implicit,  MATLAB-like, way of plotting.  It also opens figures on your
7 screen, and acts as the figure GUI manager.
8 
9 pyplot is mainly intended for interactive plots and simple cases of
10 programmatic plot generation::
11 
12     import numpy as np
13     import matplotlib.pyplot as plt
14 
15     x = np.arange(0, 5, 0.1)
16     y = np.sin(x)
17     plt.plot(x, y)
18 
19 The explicit object-oriented API is recommended for complex plots, though
20 pyplot is still usually used to create the figure and often the axes in the
21 figure. See `.pyplot.figure`, `.pyplot.subplots`, and
22 `.pyplot.subplot_mosaic` to create figures, and
23 :doc:`Axes API </api/axes_api>` for the plotting methods on an Axes::
24 
25     import numpy as np
26     import matplotlib.pyplot as plt
27 
28     x = np.arange(0, 5, 0.1)
29     y = np.sin(x)
30     fig, ax = plt.subplots()
31     ax.plot(x, y)
32 
33 
34 See :ref:`api_interfaces` for an explanation of the tradeoffs between the
35 implicit and explicit interfaces.
36 """
37 
38 # fmt: off
39 
40 from __future__ import annotations
41 
42 from contextlib import AbstractContextManager, ExitStack
43 from enum import Enum
44 import functools
45 import importlib
46 import inspect
47 import logging
48 import re
49 import sys
50 import threading
51 import time
52 from typing import cast, overload
53 
54 from cycler import cycler
55 import matplotlib
56 import matplotlib.colorbar
57 import matplotlib.image
58 from matplotlib import _api
59 from matplotlib import (  # Re-exported for typing.
60     cm as cm, get_backend as get_backend, rcParams as rcParams, style as style)
61 from matplotlib import _pylab_helpers, interactive
62 from matplotlib import cbook
63 from matplotlib import _docstring
64 from matplotlib.backend_bases import (
65     FigureCanvasBase, FigureManagerBase, MouseButton)
66 from matplotlib.figure import Figure, FigureBase, figaspect
67 from matplotlib.gridspec import GridSpec, SubplotSpec
68 from matplotlib import rcsetup, rcParamsDefault, rcParamsOrig
69 from matplotlib.artist import Artist
70 from matplotlib.axes import Axes, Subplot  # type: ignore
71 from matplotlib.projections import PolarAxes  # type: ignore
72 from matplotlib import mlab  # for detrend_none, window_hanning
73 from matplotlib.scale import get_scale_names
74 
75 from matplotlib.cm import _colormaps
76 from matplotlib.cm import register_cmap  # type: ignore
77 from matplotlib.colors import _color_sequences
78 
79 import numpy as np
80 
81 from typing import TYPE_CHECKING, cast
82 
83 if TYPE_CHECKING:
84     from collections.abc import Callable, Hashable, Iterable, Sequence
85     import datetime
86     import pathlib
87     import os
88     from typing import Any, BinaryIO, Literal, TypeVar
89     from typing_extensions import ParamSpec
90 
91     import PIL
92     from numpy.typing import ArrayLike
93 
94     from matplotlib.axis import Tick
95     from matplotlib.axes._base import _AxesBase
96     from matplotlib.backend_bases import RendererBase, Event
97     from matplotlib.cm import ScalarMappable
98     from matplotlib.contour import ContourSet, QuadContourSet
99     from matplotlib.collections import (
100         Collection,
101         LineCollection,
102         BrokenBarHCollection,
103         PolyCollection,
104         PathCollection,
105         EventCollection,
106         QuadMesh,
107     )
108     from matplotlib.colorbar import Colorbar
109     from matplotlib.colors import Colormap
110     from matplotlib.container import (
111         BarContainer,
112         ErrorbarContainer,
113         StemContainer,
114     )
115     from matplotlib.figure import SubFigure
116     from matplotlib.legend import Legend
117     from matplotlib.mlab import GaussianKDE
118     from matplotlib.image import AxesImage, FigureImage
119     from matplotlib.patches import FancyArrow, StepPatch, Wedge
120     from matplotlib.quiver import Barbs, Quiver, QuiverKey
121     from matplotlib.scale import ScaleBase
122     from matplotlib.transforms import Transform, Bbox
123     from matplotlib.typing import ColorType, LineStyleType, MarkerType, HashableList
124     from matplotlib.widgets import SubplotTool
125 
126     _P = ParamSpec('_P')
127     _R = TypeVar('_R')
128 
129 
130 # We may not need the following imports here:
131 from matplotlib.colors import Normalize
132 from matplotlib.lines import Line2D
133 from matplotlib.text import Text, Annotation
134 from matplotlib.patches import Polygon, Rectangle, Circle, Arrow
135 from matplotlib.widgets import Button, Slider, Widget
136 
137 from .ticker import (
138     TickHelper, Formatter, FixedFormatter, NullFormatter, FuncFormatter,
139     FormatStrFormatter, ScalarFormatter, LogFormatter, LogFormatterExponent,
140     LogFormatterMathtext, Locator, IndexLocator, FixedLocator, NullLocator,
141     LinearLocator, LogLocator, AutoLocator, MultipleLocator, MaxNLocator)
142 
143 _log = logging.getLogger(__name__)
144 
145 
146 # Explicit rename instead of import-as for typing's sake.
147 colormaps = _colormaps
148 color_sequences = _color_sequences
149 
150 
151 @overload
152 def _copy_docstring_and_deprecators(
153     method: Any,
154     func: Literal[None] = None
155 ) -> Callable[[Callable[_P, _R]], Callable[_P, _R]]: ...
156 
157 
158 @overload
159 def _copy_docstring_and_deprecators(
160     method: Any, func: Callable[_P, _R]) -> Callable[_P, _R]: ...
161 
162 
163 def _copy_docstring_and_deprecators(
164     method: Any,
165     func: Callable[_P, _R] | None = None
166 ) -> Callable[[Callable[_P, _R]], Callable[_P, _R]] | Callable[_P, _R]:
167     if func is None:
168         return cast('Callable[[Callable[_P, _R]], Callable[_P, _R]]',
169                     functools.partial(_copy_docstring_and_deprecators, method))
170     decorators: list[Callable[[Callable[_P, _R]], Callable[_P, _R]]] = [
171         _docstring.copy(method)
172     ]
173     # Check whether the definition of *method* includes @_api.rename_parameter
174     # or @_api.make_keyword_only decorators; if so, propagate them to the
175     # pyplot wrapper as well.
176     while hasattr(method, "__wrapped__"):
177         potential_decorator = _api.deprecation.DECORATORS.get(method)
178         if potential_decorator:
179             decorators.append(potential_decorator)
180         method = method.__wrapped__
181     for decorator in decorators[::-1]:
182         func = decorator(func)
183     return func
184 
185 
186 ## Global ##
187 
188 
189 # The state controlled by {,un}install_repl_displayhook().
190 _ReplDisplayHook = Enum("_ReplDisplayHook", ["NONE", "PLAIN", "IPYTHON"])
191 _REPL_DISPLAYHOOK = _ReplDisplayHook.NONE
192 
193 
194 def _draw_all_if_interactive() -> None:
195     if matplotlib.is_interactive():
196         draw_all()
197 
198 
199 def install_repl_displayhook() -> None:
200     """
201     Connect to the display hook of the current shell.
202 
203     The display hook gets called when the read-evaluate-print-loop (REPL) of
204     the shell has finished the execution of a command. We use this callback
205     to be able to automatically update a figure in interactive mode.
206 
207     This works both with IPython and with vanilla python shells.
208     """
209     global _REPL_DISPLAYHOOK
210 
211     if _REPL_DISPLAYHOOK is _ReplDisplayHook.IPYTHON:
212         return
213 
214     # See if we have IPython hooks around, if so use them.
215     # Use ``sys.modules.get(name)`` rather than ``name in sys.modules`` as
216     # entries can also have been explicitly set to None.
217     mod_ipython = sys.modules.get("IPython")
218     if not mod_ipython:
219         _REPL_DISPLAYHOOK = _ReplDisplayHook.PLAIN
220         return
221     ip = mod_ipython.get_ipython()
222     if not ip:
223         _REPL_DISPLAYHOOK = _ReplDisplayHook.PLAIN
224         return
225 
226     ip.events.register("post_execute", _draw_all_if_interactive)
227     _REPL_DISPLAYHOOK = _ReplDisplayHook.IPYTHON
228 
229     from IPython.core.pylabtools import backend2gui  # type: ignore
230     # trigger IPython's eventloop integration, if available
231     ipython_gui_name = backend2gui.get(get_backend())
232     if ipython_gui_name:
233         ip.enable_gui(ipython_gui_name)
234 
235 
236 def uninstall_repl_displayhook() -> None:
237     """Disconnect from the display hook of the current shell."""
238     global _REPL_DISPLAYHOOK
239     if _REPL_DISPLAYHOOK is _ReplDisplayHook.IPYTHON:
240         from IPython import get_ipython  # type: ignore
241         ip = get_ipython()
242         ip.events.unregister("post_execute", _draw_all_if_interactive)
243     _REPL_DISPLAYHOOK = _ReplDisplayHook.NONE
244 
245 
246 draw_all = _pylab_helpers.Gcf.draw_all
247 
248 
249 # Ensure this appears in the pyplot docs.
250 @_copy_docstring_and_deprecators(matplotlib.set_loglevel)
251 def set_loglevel(*args, **kwargs) -> None:
252     return matplotlib.set_loglevel(*args, **kwargs)
253 
254 
255 @_copy_docstring_and_deprecators(Artist.findobj)
256 def findobj(
257     o: Artist | None = None,
258     match: Callable[[Artist], bool] | type[Artist] | None = None,
259     include_self: bool = True
260 ) -> list[Artist]:
261     if o is None:
262         o = gcf()
263     return o.findobj(match, include_self=include_self)
264 
265 
266 _backend_mod: type[matplotlib.backend_bases._Backend] | None = None
267 
268 
269 def _get_backend_mod() -> type[matplotlib.backend_bases._Backend]:
270     """
271     Ensure that a backend is selected and return it.
272 
273     This is currently private, but may be made public in the future.
274     """
275     if _backend_mod is None:
276         # Use rcParams._get("backend") to avoid going through the fallback
277         # logic (which will (re)import pyplot and then call switch_backend if
278         # we need to resolve the auto sentinel)
279         switch_backend(rcParams._get("backend"))  # type: ignore[attr-defined]
280     return cast(type[matplotlib.backend_bases._Backend], _backend_mod)
281 
282 
283 def switch_backend(newbackend: str) -> None:
284     """
285     Set the pyplot backend.
286 
287     Switching to an interactive backend is possible only if no event loop for
288     another interactive backend has started.  Switching to and from
289     non-interactive backends is always possible.
290 
291     If the new backend is different than the current backend then all open
292     Figures will be closed via ``plt.close('all')``.
293 
294     Parameters
295     ----------
296     newbackend : str
297         The case-insensitive name of the backend to use.
298 
299     """
300     global _backend_mod
301     # make sure the init is pulled up so we can assign to it later
302     import matplotlib.backends
303 
304     if newbackend is rcsetup._auto_backend_sentinel:
305         current_framework = cbook._get_running_interactive_framework()
306         mapping = {'qt': 'qtagg',
307                    'gtk3': 'gtk3agg',
308                    'gtk4': 'gtk4agg',
309                    'wx': 'wxagg',
310                    'tk': 'tkagg',
311                    'macosx': 'macosx',
312                    'headless': 'agg'}
313 
314         if current_framework in mapping:
315             candidates = [mapping[current_framework]]
316         else:
317             candidates = []
318         candidates += [
319             "macosx", "qtagg", "gtk4agg", "gtk3agg", "tkagg", "wxagg"]
320 
321         # Don't try to fallback on the cairo-based backends as they each have
322         # an additional dependency (pycairo) over the agg-based backend, and
323         # are of worse quality.
324         for candidate in candidates:
325             try:
326                 switch_backend(candidate)
327             except ImportError:
328                 continue
329             else:
330                 rcParamsOrig['backend'] = candidate
331                 return
332         else:
333             # Switching to Agg should always succeed; if it doesn't, let the
334             # exception propagate out.
335             switch_backend("agg")
336             rcParamsOrig["backend"] = "agg"
337             return
338     # have to escape the switch on access logic
339     old_backend = dict.__getitem__(rcParams, 'backend')
340 
341     module = importlib.import_module(cbook._backend_module_name(newbackend))
342 
343     required_framework = module.FigureCanvas.required_interactive_framework
344     if required_framework is not None:
345         current_framework = cbook._get_running_interactive_framework()
346         if (current_framework and required_framework
347                 and current_framework != required_framework):
348             raise ImportError(
349                 "Cannot load backend {!r} which requires the {!r} interactive "
350                 "framework, as {!r} is currently running".format(
351                     newbackend, required_framework, current_framework))
352 
353     # Load the new_figure_manager() and show() functions from the backend.
354 
355     # Classically, backends can directly export these functions.  This should
356     # keep working for backcompat.
357     new_figure_manager = getattr(module, "new_figure_manager", None)
358     show = getattr(module, "show", None)
359 
360     # In that classical approach, backends are implemented as modules, but
361     # "inherit" default method implementations from backend_bases._Backend.
362     # This is achieved by creating a "class" that inherits from
363     # backend_bases._Backend and whose body is filled with the module globals.
364     class backend_mod(matplotlib.backend_bases._Backend):
365         locals().update(vars(module))
366 
367     # However, the newer approach for defining new_figure_manager and
368     # show is to derive them from canvas methods.  In that case, also
369     # update backend_mod accordingly; also, per-backend customization of
370     # draw_if_interactive is disabled.
371     if new_figure_manager is None:
372         # Only try to get the canvas class if have opted into the new scheme.
373         canvas_class = backend_mod.FigureCanvas
374 
375         def new_figure_manager_given_figure(num, figure):
376             return canvas_class.new_manager(figure, num)
377 
378         def new_figure_manager(num, *args, FigureClass=Figure, **kwargs):
379             fig = FigureClass(*args, **kwargs)
380             return new_figure_manager_given_figure(num, fig)
381 
382         def draw_if_interactive() -> None:
383             if matplotlib.is_interactive():
384                 manager = _pylab_helpers.Gcf.get_active()
385                 if manager:
386                     manager.canvas.draw_idle()
387 
388         backend_mod.new_figure_manager_given_figure = (  # type: ignore[method-assign]
389             new_figure_manager_given_figure)
390         backend_mod.new_figure_manager = (  # type: ignore[method-assign]
391             new_figure_manager)
392         backend_mod.draw_if_interactive = (  # type: ignore[method-assign]
393             draw_if_interactive)
394 
395     # If the manager explicitly overrides pyplot_show, use it even if a global
396     # show is already present, as the latter may be here for backcompat.
397     manager_class = getattr(getattr(backend_mod, "FigureCanvas", None),
398                             "manager_class", None)
399     # We can't compare directly manager_class.pyplot_show and FMB.pyplot_show because
400     # pyplot_show is a classmethod so the above constructs are bound classmethods, and
401     # thus always different (being bound to different classes).  We also have to use
402     # getattr_static instead of vars as manager_class could have no __dict__.
403     manager_pyplot_show = inspect.getattr_static(manager_class, "pyplot_show", None)
404     base_pyplot_show = inspect.getattr_static(FigureManagerBase, "pyplot_show", None)
405     if (show is None
406             or (manager_pyplot_show is not None
407                 and manager_pyplot_show != base_pyplot_show)):
408         _pyplot_show = cast('Any', manager_class).pyplot_show
409         backend_mod.show = _pyplot_show  # type: ignore[method-assign]
410 
411     _log.debug("Loaded backend %s version %s.",
412                newbackend, backend_mod.backend_version)
413 
414     rcParams['backend'] = rcParamsDefault['backend'] = newbackend
415     _backend_mod = backend_mod
416     for func_name in ["new_figure_manager", "draw_if_interactive", "show"]:
417         globals()[func_name].__signature__ = inspect.signature(
418             getattr(backend_mod, func_name))
419 
420     # Need to keep a global reference to the backend for compatibility reasons.
421     # See https://github.com/matplotlib/matplotlib/issues/6092
422     matplotlib.backends.backend = newbackend  # type: ignore[attr-defined]
423     if not cbook._str_equal(old_backend, newbackend):
424         close("all")
425 
426     # make sure the repl display hook is installed in case we become
427     # interactive
428     install_repl_displayhook()
429 
430 
431 def _warn_if_gui_out_of_main_thread() -> None:
432     warn = False
433     canvas_class = cast(type[FigureCanvasBase], _get_backend_mod().FigureCanvas)
434     if canvas_class.required_interactive_framework:
435         if hasattr(threading, 'get_native_id'):
436             # This compares native thread ids because even if Python-level
437             # Thread objects match, the underlying OS thread (which is what
438             # really matters) may be different on Python implementations with
439             # green threads.
440             if threading.get_native_id() != threading.main_thread().native_id:
441                 warn = True
442         else:
443             # Fall back to Python-level Thread if native IDs are unavailable,
444             # mainly for PyPy.
445             if threading.current_thread() is not threading.main_thread():
446                 warn = True
447     if warn:
448         _api.warn_external(
449             "Starting a Matplotlib GUI outside of the main thread will likely "
450             "fail.")
451 
452 
453 # This function's signature is rewritten upon backend-load by switch_backend.
454 def new_figure_manager(*args, **kwargs):
455     """Create a new figure manager instance."""
456     _warn_if_gui_out_of_main_thread()
457     return _get_backend_mod().new_figure_manager(*args, **kwargs)
458 
459 
460 # This function's signature is rewritten upon backend-load by switch_backend.
461 def draw_if_interactive(*args, **kwargs):
462     """
463     Redraw the current figure if in interactive mode.
464 
465     .. warning::
466 
467         End users will typically not have to call this function because the
468         the interactive mode takes care of this.
469     """
470     return _get_backend_mod().draw_if_interactive(*args, **kwargs)
471 
472 
473 # This function's signature is rewritten upon backend-load by switch_backend.
474 def show(*args, **kwargs):
475     """
476     Display all open figures.
477 
478     Parameters
479     ----------
480     block : bool, optional
481         Whether to wait for all figures to be closed before returning.
482 
483         If `True` block and run the GUI main loop until all figure windows
484         are closed.
485 
486         If `False` ensure that all figure windows are displayed and return
487         immediately.  In this case, you are responsible for ensuring
488         that the event loop is running to have responsive figures.
489 
490         Defaults to True in non-interactive mode and to False in interactive
491         mode (see `.pyplot.isinteractive`).
492 
493     See Also
494     --------
495     ion : Enable interactive mode, which shows / updates the figure after
496           every plotting command, so that calling ``show()`` is not necessary.
497     ioff : Disable interactive mode.
498     savefig : Save the figure to an image file instead of showing it on screen.
499 
500     Notes
501     -----
502     **Saving figures to file and showing a window at the same time**
503 
504     If you want an image file as well as a user interface window, use
505     `.pyplot.savefig` before `.pyplot.show`. At the end of (a blocking)
506     ``show()`` the figure is closed and thus unregistered from pyplot. Calling
507     `.pyplot.savefig` afterwards would save a new and thus empty figure. This
508     limitation of command order does not apply if the show is non-blocking or
509     if you keep a reference to the figure and use `.Figure.savefig`.
510 
511     **Auto-show in jupyter notebooks**
512 
513     The jupyter backends (activated via ``%matplotlib inline``,
514     ``%matplotlib notebook``, or ``%matplotlib widget``), call ``show()`` at
515     the end of every cell by default. Thus, you usually don't have to call it
516     explicitly there.
517     """
518     _warn_if_gui_out_of_main_thread()
519     return _get_backend_mod().show(*args, **kwargs)
520 
521 
522 def isinteractive() -> bool:
523     """
524     Return whether plots are updated after every plotting command.
525 
526     The interactive mode is mainly useful if you build plots from the command
527     line and want to see the effect of each command while you are building the
528     figure.
529 
530     In interactive mode:
531 
532     - newly created figures will be shown immediately;
533     - figures will automatically redraw on change;
534     - `.pyplot.show` will not block by default.
535 
536     In non-interactive mode:
537 
538     - newly created figures and changes to figures will not be reflected until
539       explicitly asked to be;
540     - `.pyplot.show` will block by default.
541 
542     See Also
543     --------
544     ion : Enable interactive mode.
545     ioff : Disable interactive mode.
546     show : Show all figures (and maybe block).
547     pause : Show all figures, and block for a time.
548     """
549     return matplotlib.is_interactive()
550 
551 
552 def ioff() -> ExitStack:
553     """
554     Disable interactive mode.
555 
556     See `.pyplot.isinteractive` for more details.
557 
558     See Also
559     --------
560     ion : Enable interactive mode.
561     isinteractive : Whether interactive mode is enabled.
562     show : Show all figures (and maybe block).
563     pause : Show all figures, and block for a time.
564 
565     Notes
566     -----
567     For a temporary change, this can be used as a context manager::
568 
569         # if interactive mode is on
570         # then figures will be shown on creation
571         plt.ion()
572         # This figure will be shown immediately
573         fig = plt.figure()
574 
575         with plt.ioff():
576             # interactive mode will be off
577             # figures will not automatically be shown
578             fig2 = plt.figure()
579             # ...
580 
581     To enable optional usage as a context manager, this function returns a
582     `~contextlib.ExitStack` object, which is not intended to be stored or
583     accessed by the user.
584     """
585     stack = ExitStack()
586     stack.callback(ion if isinteractive() else ioff)
587     matplotlib.interactive(False)
588     uninstall_repl_displayhook()
589     return stack
590 
591 
592 def ion() -> ExitStack:
593     """
594     Enable interactive mode.
595 
596     See `.pyplot.isinteractive` for more details.
597 
598     See Also
599     --------
600     ioff : Disable interactive mode.
601     isinteractive : Whether interactive mode is enabled.
602     show : Show all figures (and maybe block).
603     pause : Show all figures, and block for a time.
604 
605     Notes
606     -----
607     For a temporary change, this can be used as a context manager::
608 
609         # if interactive mode is off
610         # then figures will not be shown on creation
611         plt.ioff()
612         # This figure will not be shown immediately
613         fig = plt.figure()
614 
615         with plt.ion():
616             # interactive mode will be on
617             # figures will automatically be shown
618             fig2 = plt.figure()
619             # ...
620 
621     To enable optional usage as a context manager, this function returns a
622     `~contextlib.ExitStack` object, which is not intended to be stored or
623     accessed by the user.
624     """
625     stack = ExitStack()
626     stack.callback(ion if isinteractive() else ioff)
627     matplotlib.interactive(True)
628     install_repl_displayhook()
629     return stack
630 
631 
632 def pause(interval: float) -> None:
633     """
634     Run the GUI event loop for *interval* seconds.
635 
636     If there is an active figure, it will be updated and displayed before the
637     pause, and the GUI event loop (if any) will run during the pause.
638 
639     This can be used for crude animation.  For more complex animation use
640     :mod:`matplotlib.animation`.
641 
642     If there is no active figure, sleep for *interval* seconds instead.
643 
644     See Also
645     --------
646     matplotlib.animation : Proper animations
647     show : Show all figures and optional block until all figures are closed.
648     """
649     manager = _pylab_helpers.Gcf.get_active()
650     if manager is not None:
651         canvas = manager.canvas
652         if canvas.figure.stale:
653             canvas.draw_idle()
654         show(block=False)
655         canvas.start_event_loop(interval)
656     else:
657         time.sleep(interval)
658 
659 
660 @_copy_docstring_and_deprecators(matplotlib.rc)
661 def rc(group: str, **kwargs) -> None:
662     matplotlib.rc(group, **kwargs)
663 
664 
665 @_copy_docstring_and_deprecators(matplotlib.rc_context)
666 def rc_context(
667     rc: dict[str, Any] | None = None,
668     fname: str | pathlib.Path | os.PathLike | None = None,
669 ) -> AbstractContextManager[None]:
670     return matplotlib.rc_context(rc, fname)
671 
672 
673 @_copy_docstring_and_deprecators(matplotlib.rcdefaults)
674 def rcdefaults() -> None:
675     matplotlib.rcdefaults()
676     if matplotlib.is_interactive():
677         draw_all()
678 
679 
680 # getp/get/setp are explicitly reexported so that they show up in pyplot docs.
681 
682 
683 @_copy_docstring_and_deprecators(matplotlib.artist.getp)
684 def getp(obj, *args, **kwargs):
685     return matplotlib.artist.getp(obj, *args, **kwargs)
686 
687 
688 @_copy_docstring_and_deprecators(matplotlib.artist.get)
689 def get(obj, *args, **kwargs):
690     return matplotlib.artist.get(obj, *args, **kwargs)
691 
692 
693 @_copy_docstring_and_deprecators(matplotlib.artist.setp)
694 def setp(obj, *args, **kwargs):
695     return matplotlib.artist.setp(obj, *args, **kwargs)
696 
697 
698 def xkcd(
699     scale: float = 1, length: float = 100, randomness: float = 2
700 ) -> ExitStack:
701     """
702     Turn on `xkcd <https://xkcd.com/>`_ sketch-style drawing mode.  This will
703     only have effect on things drawn after this function is called.
704 
705     For best results, the "Humor Sans" font should be installed: it is
706     not included with Matplotlib.
707 
708     Parameters
709     ----------
710     scale : float, optional
711         The amplitude of the wiggle perpendicular to the source line.
712     length : float, optional
713         The length of the wiggle along the line.
714     randomness : float, optional
715         The scale factor by which the length is shrunken or expanded.
716 
717     Notes
718     -----
719     This function works by a number of rcParams, so it will probably
720     override others you have set before.
721 
722     If you want the effects of this function to be temporary, it can
723     be used as a context manager, for example::
724 
725         with plt.xkcd():
726             # This figure will be in XKCD-style
727             fig1 = plt.figure()
728             # ...
729 
730         # This figure will be in regular style
731         fig2 = plt.figure()
732     """
733     # This cannot be implemented in terms of contextmanager() or rc_context()
734     # because this needs to work as a non-contextmanager too.
735 
736     if rcParams['text.usetex']:
737         raise RuntimeError(
738             "xkcd mode is not compatible with text.usetex = True")
739 
740     stack = ExitStack()
741     stack.callback(dict.update, rcParams, rcParams.copy())  # type: ignore
742 
743     from matplotlib import patheffects
744     rcParams.update({
745         'font.family': ['xkcd', 'xkcd Script', 'Humor Sans', 'Comic Neue',
746                         'Comic Sans MS'],
747         'font.size': 14.0,
748         'path.sketch': (scale, length, randomness),
749         'path.effects': [
750             patheffects.withStroke(linewidth=4, foreground="w")],
751         'axes.linewidth': 1.5,
752         'lines.linewidth': 2.0,
753         'figure.facecolor': 'white',
754         'grid.linewidth': 0.0,
755         'axes.grid': False,
756         'axes.unicode_minus': False,
757         'axes.edgecolor': 'black',
758         'xtick.major.size': 8,
759         'xtick.major.width': 3,
760         'ytick.major.size': 8,
761         'ytick.major.width': 3,
762     })
763 
764     return stack
765 
766 
767 ## Figures ##
768 
769 def figure(
770     # autoincrement if None, else integer from 1-N
771     num: int | str | Figure | SubFigure | None = None,
772     # defaults to rc figure.figsize
773     figsize: tuple[float, float] | None = None,
774     # defaults to rc figure.dpi
775     dpi: float | None = None,
776     *,
777     # defaults to rc figure.facecolor
778     facecolor: ColorType | None = None,
779     # defaults to rc figure.edgecolor
780     edgecolor: ColorType | None = None,
781     frameon: bool = True,
782     FigureClass: type[Figure] = Figure,
783     clear: bool = False,
784     **kwargs
785 ) -> Figure:
786     """
787     Create a new figure, or activate an existing figure.
788 
789     Parameters
790     ----------
791     num : int or str or `.Figure` or `.SubFigure`, optional
792         A unique identifier for the figure.
793 
794         If a figure with that identifier already exists, this figure is made
795         active and returned. An integer refers to the ``Figure.number``
796         attribute, a string refers to the figure label.
797 
798         If there is no figure with the identifier or *num* is not given, a new
799         figure is created, made active and returned.  If *num* is an int, it
800         will be used for the ``Figure.number`` attribute, otherwise, an
801         auto-generated integer value is used (starting at 1 and incremented
802         for each new figure). If *num* is a string, the figure label and the
803         window title is set to this value.  If num is a ``SubFigure``, its
804         parent ``Figure`` is activated.
805 
806     figsize : (float, float), default: :rc:`figure.figsize`
807         Width, height in inches.
808 
809     dpi : float, default: :rc:`figure.dpi`
810         The resolution of the figure in dots-per-inch.
811 
812     facecolor : color, default: :rc:`figure.facecolor`
813         The background color.
814 
815     edgecolor : color, default: :rc:`figure.edgecolor`
816         The border color.
817 
818     frameon : bool, default: True
819         If False, suppress drawing the figure frame.
820 
821     FigureClass : subclass of `~matplotlib.figure.Figure`
822         If set, an instance of this subclass will be created, rather than a
823         plain `.Figure`.
824 
825     clear : bool, default: False
826         If True and the figure already exists, then it is cleared.
827 
828     layout : {'constrained', 'compressed', 'tight', 'none', `.LayoutEngine`, None}, \
829 default: None
830         The layout mechanism for positioning of plot elements to avoid
831         overlapping Axes decorations (labels, ticks, etc). Note that layout
832         managers can measurably slow down figure display.
833 
834         - 'constrained': The constrained layout solver adjusts axes sizes
835           to avoid overlapping axes decorations.  Can handle complex plot
836           layouts and colorbars, and is thus recommended.
837 
838           See :ref:`constrainedlayout_guide`
839           for examples.
840 
841         - 'compressed': uses the same algorithm as 'constrained', but
842           removes extra space between fixed-aspect-ratio Axes.  Best for
843           simple grids of axes.
844 
845         - 'tight': Use the tight layout mechanism. This is a relatively
846           simple algorithm that adjusts the subplot parameters so that
847           decorations do not overlap. See `.Figure.set_tight_layout` for
848           further details.
849 
850         - 'none': Do not use a layout engine.
851 
852         - A `.LayoutEngine` instance. Builtin layout classes are
853           `.ConstrainedLayoutEngine` and `.TightLayoutEngine`, more easily
854           accessible by 'constrained' and 'tight'.  Passing an instance
855           allows third parties to provide their own layout engine.
856 
857         If not given, fall back to using the parameters *tight_layout* and
858         *constrained_layout*, including their config defaults
859         :rc:`figure.autolayout` and :rc:`figure.constrained_layout.use`.
860 
861     **kwargs
862         Additional keyword arguments are passed to the `.Figure` constructor.
863 
864     Returns
865     -------
866     `~matplotlib.figure.Figure`
867 
868     Notes
869     -----
870     A newly created figure is passed to the `~.FigureCanvasBase.new_manager`
871     method or the `new_figure_manager` function provided by the current
872     backend, which install a canvas and a manager on the figure.
873 
874     Once this is done, :rc:`figure.hooks` are called, one at a time, on the
875     figure; these hooks allow arbitrary customization of the figure (e.g.,
876     attaching callbacks) or of associated elements (e.g., modifying the
877     toolbar).  See :doc:`/gallery/user_interfaces/mplcvd` for an example of
878     toolbar customization.
879 
880     If you are creating many figures, make sure you explicitly call
881     `.pyplot.close` on the figures you are not using, because this will
882     enable pyplot to properly clean up the memory.
883 
884     `~matplotlib.rcParams` defines the default values, which can be modified
885     in the matplotlibrc file.
886     """
887     if isinstance(num, FigureBase):
888         # type narrowed to `Figure | SubFigure` by combination of input and isinstance
889         if num.canvas.manager is None:
890             raise ValueError("The passed figure is not managed by pyplot")
891         _pylab_helpers.Gcf.set_active(num.canvas.manager)
892         return num.figure
893 
894     allnums = get_fignums()
895     next_num = max(allnums) + 1 if allnums else 1
896     fig_label = ''
897     if num is None:
898         num = next_num
899     elif isinstance(num, str):
900         fig_label = num
901         all_labels = get_figlabels()
902         if fig_label not in all_labels:
903             if fig_label == 'all':
904                 _api.warn_external("close('all') closes all existing figures.")
905             num = next_num
906         else:
907             inum = all_labels.index(fig_label)
908             num = allnums[inum]
909     else:
910         num = int(num)  # crude validation of num argument
911 
912     # Type of "num" has narrowed to int, but mypy can't quite see it
913     manager = _pylab_helpers.Gcf.get_fig_manager(num)  # type: ignore[arg-type]
914     if manager is None:
915         max_open_warning = rcParams['figure.max_open_warning']
916         if len(allnums) == max_open_warning >= 1:
917             _api.warn_external(
918                 f"More than {max_open_warning} figures have been opened. "
919                 f"Figures created through the pyplot interface "
920                 f"(`matplotlib.pyplot.figure`) are retained until explicitly "
921                 f"closed and may consume too much memory. (To control this "
922                 f"warning, see the rcParam `figure.max_open_warning`). "
923                 f"Consider using `matplotlib.pyplot.close()`.",
924                 RuntimeWarning)
925 
926         manager = new_figure_manager(
927             num, figsize=figsize, dpi=dpi,
928             facecolor=facecolor, edgecolor=edgecolor, frameon=frameon,
929             FigureClass=FigureClass, **kwargs)
930         fig = manager.canvas.figure
931         if fig_label:
932             fig.set_label(fig_label)
933 
934         for hookspecs in rcParams["figure.hooks"]:
935             module_name, dotted_name = hookspecs.split(":")
936             obj = importlib.import_module(module_name)
937             for part in dotted_name.split("."):
938                 obj = getattr(obj, part)
939             obj(fig)
940 
941         _pylab_helpers.Gcf._set_new_active_manager(manager)
942 
943         # make sure backends (inline) that we don't ship that expect this
944         # to be called in plotting commands to make the figure call show
945         # still work.  There is probably a better way to do this in the
946         # FigureManager base class.
947         draw_if_interactive()
948 
949         if _REPL_DISPLAYHOOK is _ReplDisplayHook.PLAIN:
950             fig.stale_callback = _auto_draw_if_interactive
951 
952     if clear:
953         manager.canvas.figure.clear()
954 
955     return manager.canvas.figure
956 
957 
958 def _auto_draw_if_interactive(fig, val):
959     """
960     An internal helper function for making sure that auto-redrawing
961     works as intended in the plain python repl.
962 
963     Parameters
964     ----------
965     fig : Figure
966         A figure object which is assumed to be associated with a canvas
967     """
968     if (val and matplotlib.is_interactive()
969             and not fig.canvas.is_saving()
970             and not fig.canvas._is_idle_drawing):
971         # Some artists can mark themselves as stale in the middle of drawing
972         # (e.g. axes position & tick labels being computed at draw time), but
973         # this shouldn't trigger a redraw because the current redraw will
974         # already take them into account.
975         with fig.canvas._idle_draw_cntx():
976             fig.canvas.draw_idle()
977 
978 
979 def gcf() -> Figure:
980     """
981     Get the current figure.
982 
983     If there is currently no figure on the pyplot figure stack, a new one is
984     created using `~.pyplot.figure()`.  (To test whether there is currently a
985     figure on the pyplot figure stack, check whether `~.pyplot.get_fignums()`
986     is empty.)
987     """
988     manager = _pylab_helpers.Gcf.get_active()
989     if manager is not None:
990         return manager.canvas.figure
991     else:
992         return figure()
993 
994 
995 def fignum_exists(num: int) -> bool:
996     """Return whether the figure with the given id exists."""
997     return _pylab_helpers.Gcf.has_fignum(num) or num in get_figlabels()
998 
999 
1000 def get_fignums() -> list[int]:
1001     """Return a list of existing figure numbers."""
1002     return sorted(_pylab_helpers.Gcf.figs)
1003 
1004 
1005 def get_figlabels() -> list[Any]:
1006     """Return a list of existing figure labels."""
1007     managers = _pylab_helpers.Gcf.get_all_fig_managers()
1008     managers.sort(key=lambda m: m.num)
1009     return [m.canvas.figure.get_label() for m in managers]
1010 
1011 
1012 def get_current_fig_manager() -> FigureManagerBase | None:
1013     """
1014     Return the figure manager of the current figure.
1015 
1016     The figure manager is a container for the actual backend-depended window
1017     that displays the figure on screen.
1018 
1019     If no current figure exists, a new one is created, and its figure
1020     manager is returned.
1021 
1022     Returns
1023     -------
1024     `.FigureManagerBase` or backend-dependent subclass thereof
1025     """
1026     return gcf().canvas.manager
1027 
1028 
1029 @_copy_docstring_and_deprecators(FigureCanvasBase.mpl_connect)
1030 def connect(s: str, func: Callable[[Event], Any]) -> int:
1031     return gcf().canvas.mpl_connect(s, func)
1032 
1033 
1034 @_copy_docstring_and_deprecators(FigureCanvasBase.mpl_disconnect)
1035 def disconnect(cid: int) -> None:
1036     gcf().canvas.mpl_disconnect(cid)
1037 
1038 
1039 def close(fig: None | int | str | Figure | Literal["all"] = None) -> None:
1040     """
1041     Close a figure window.
1042 
1043     Parameters
1044     ----------
1045     fig : None or int or str or `.Figure`
1046         The figure to close. There are a number of ways to specify this:
1047 
1048         - *None*: the current figure
1049         - `.Figure`: the given `.Figure` instance
1050         - ``int``: a figure number
1051         - ``str``: a figure name
1052         - 'all': all figures
1053 
1054     """
1055     if fig is None:
1056         manager = _pylab_helpers.Gcf.get_active()
1057         if manager is None:
1058             return
1059         else:
1060             _pylab_helpers.Gcf.destroy(manager)
1061     elif fig == 'all':
1062         _pylab_helpers.Gcf.destroy_all()
1063     elif isinstance(fig, int):
1064         _pylab_helpers.Gcf.destroy(fig)
1065     elif hasattr(fig, 'int'):
1066         # if we are dealing with a type UUID, we
1067         # can use its integer representation
1068         _pylab_helpers.Gcf.destroy(fig.int)
1069     elif isinstance(fig, str):
1070         all_labels = get_figlabels()
1071         if fig in all_labels:
1072             num = get_fignums()[all_labels.index(fig)]
1073             _pylab_helpers.Gcf.destroy(num)
1074     elif isinstance(fig, Figure):
1075         _pylab_helpers.Gcf.destroy_fig(fig)
1076     else:
1077         raise TypeError("close() argument must be a Figure, an int, a string, "
1078                         "or None, not %s" % type(fig))
1079 
1080 
1081 def clf() -> None:
1082     """Clear the current figure."""
1083     gcf().clear()
1084 
1085 
1086 def draw() -> None:
1087     """
1088     Redraw the current figure.
1089 
1090     This is used to update a figure that has been altered, but not
1091     automatically re-drawn.  If interactive mode is on (via `.ion()`), this
1092     should be only rarely needed, but there may be ways to modify the state of
1093     a figure without marking it as "stale".  Please report these cases as bugs.
1094 
1095     This is equivalent to calling ``fig.canvas.draw_idle()``, where ``fig`` is
1096     the current figure.
1097 
1098     See Also
1099     --------
1100     .FigureCanvasBase.draw_idle
1101     .FigureCanvasBase.draw
1102     """
1103     gcf().canvas.draw_idle()
1104 
1105 
1106 @_copy_docstring_and_deprecators(Figure.savefig)
1107 def savefig(*args, **kwargs) -> None:
1108     fig = gcf()
1109     # savefig default implementation has no return, so mypy is unhappy
1110     # presumably this is here because subclasses can return?
1111     res = fig.savefig(*args, **kwargs)  # type: ignore[func-returns-value]
1112     fig.canvas.draw_idle()  # Need this if 'transparent=True', to reset colors.
1113     return res
1114 
1115 
1116 ## Putting things in figures ##
1117 
1118 
1119 def figlegend(*args, **kwargs) -> Legend:
1120     return gcf().legend(*args, **kwargs)
1121 if Figure.legend.__doc__:
1122     figlegend.__doc__ = Figure.legend.__doc__ \
1123         .replace(" legend(", " figlegend(") \
1124         .replace("fig.legend(", "plt.figlegend(") \
1125         .replace("ax.plot(", "plt.plot(")
1126 
1127 
1128 ## Axes ##
1129 
1130 @_docstring.dedent_interpd
1131 def axes(
1132     arg: None | tuple[float, float, float, float] = None,
1133     **kwargs
1134 ) -> matplotlib.axes.Axes:
1135     """
1136     Add an Axes to the current figure and make it the current Axes.
1137 
1138     Call signatures::
1139 
1140         plt.axes()
1141         plt.axes(rect, projection=None, polar=False, **kwargs)
1142         plt.axes(ax)
1143 
1144     Parameters
1145     ----------
1146     arg : None or 4-tuple
1147         The exact behavior of this function depends on the type:
1148 
1149         - *None*: A new full window Axes is added using
1150           ``subplot(**kwargs)``.
1151         - 4-tuple of floats *rect* = ``[left, bottom, width, height]``.
1152           A new Axes is added with dimensions *rect* in normalized
1153           (0, 1) units using `~.Figure.add_axes` on the current figure.
1154 
1155     projection : {None, 'aitoff', 'hammer', 'lambert', 'mollweide', \
1156 'polar', 'rectilinear', str}, optional
1157         The projection type of the `~.axes.Axes`. *str* is the name of
1158         a custom projection, see `~matplotlib.projections`. The default
1159         None results in a 'rectilinear' projection.
1160 
1161     polar : bool, default: False
1162         If True, equivalent to projection='polar'.
1163 
1164     sharex, sharey : `~matplotlib.axes.Axes`, optional
1165         Share the x or y `~matplotlib.axis` with sharex and/or sharey.
1166         The axis will have the same limits, ticks, and scale as the axis
1167         of the shared Axes.
1168 
1169     label : str
1170         A label for the returned Axes.
1171 
1172     Returns
1173     -------
1174     `~.axes.Axes`, or a subclass of `~.axes.Axes`
1175         The returned axes class depends on the projection used. It is
1176         `~.axes.Axes` if rectilinear projection is used and
1177         `.projections.polar.PolarAxes` if polar projection is used.
1178 
1179     Other Parameters
1180     ----------------
1181     **kwargs
1182         This method also takes the keyword arguments for
1183         the returned Axes class. The keyword arguments for the
1184         rectilinear Axes class `~.axes.Axes` can be found in
1185         the following table but there might also be other keyword
1186         arguments if another projection is used, see the actual Axes
1187         class.
1188 
1189         %(Axes:kwdoc)s
1190 
1191     See Also
1192     --------
1193     .Figure.add_axes
1194     .pyplot.subplot
1195     .Figure.add_subplot
1196     .Figure.subplots
1197     .pyplot.subplots
1198 
1199     Examples
1200     --------
1201     ::
1202 
1203         # Creating a new full window Axes
1204         plt.axes()
1205 
1206         # Creating a new Axes with specified dimensions and a grey background
1207         plt.axes((left, bottom, width, height), facecolor='grey')
1208     """
1209     fig = gcf()
1210     pos = kwargs.pop('position', None)
1211     if arg is None:
1212         if pos is None:
1213             return fig.add_subplot(**kwargs)
1214         else:
1215             return fig.add_axes(pos, **kwargs)
1216     else:
1217         return fig.add_axes(arg, **kwargs)
1218 
1219 
1220 def delaxes(ax: matplotlib.axes.Axes | None = None) -> None:
1221     """
1222     Remove an `~.axes.Axes` (defaulting to the current axes) from its figure.
1223     """
1224     if ax is None:
1225         ax = gca()
1226     ax.remove()
1227 
1228 
1229 def sca(ax: Axes) -> None:
1230     """
1231     Set the current Axes to *ax* and the current Figure to the parent of *ax*.
1232     """
1233     # Mypy sees ax.figure as potentially None,
1234     # but if you are calling this, it won't be None
1235     # Additionally the slight difference between `Figure` and `FigureBase` mypy catches
1236     figure(ax.figure)  # type: ignore[arg-type]
1237     ax.figure.sca(ax)  # type: ignore[union-attr]
1238 
1239 
1240 def cla() -> None:
1241     """Clear the current axes."""
1242     # Not generated via boilerplate.py to allow a different docstring.
1243     return gca().cla()
1244 
1245 
1246 ## More ways of creating axes ##
1247 
1248 @_docstring.dedent_interpd
1249 def subplot(*args, **kwargs) -> Axes:
1250     """
1251     Add an Axes to the current figure or retrieve an existing Axes.
1252 
1253     This is a wrapper of `.Figure.add_subplot` which provides additional
1254     behavior when working with the implicit API (see the notes section).
1255 
1256     Call signatures::
1257 
1258        subplot(nrows, ncols, index, **kwargs)
1259        subplot(pos, **kwargs)
1260        subplot(**kwargs)
1261        subplot(ax)
1262 
1263     Parameters
1264     ----------
1265     *args : int, (int, int, *index*), or `.SubplotSpec`, default: (1, 1, 1)
1266         The position of the subplot described by one of
1267 
1268         - Three integers (*nrows*, *ncols*, *index*). The subplot will take the
1269           *index* position on a grid with *nrows* rows and *ncols* columns.
1270           *index* starts at 1 in the upper left corner and increases to the
1271           right. *index* can also be a two-tuple specifying the (*first*,
1272           *last*) indices (1-based, and including *last*) of the subplot, e.g.,
1273           ``fig.add_subplot(3, 1, (1, 2))`` makes a subplot that spans the
1274           upper 2/3 of the figure.
1275         - A 3-digit integer. The digits are interpreted as if given separately
1276           as three single-digit integers, i.e. ``fig.add_subplot(235)`` is the
1277           same as ``fig.add_subplot(2, 3, 5)``. Note that this can only be used
1278           if there are no more than 9 subplots.
1279         - A `.SubplotSpec`.
1280 
1281     projection : {None, 'aitoff', 'hammer', 'lambert', 'mollweide', \
1282 'polar', 'rectilinear', str}, optional
1283         The projection type of the subplot (`~.axes.Axes`). *str* is the name
1284         of a custom projection, see `~matplotlib.projections`. The default
1285         None results in a 'rectilinear' projection.
1286 
1287     polar : bool, default: False
1288         If True, equivalent to projection='polar'.
1289 
1290     sharex, sharey : `~matplotlib.axes.Axes`, optional
1291         Share the x or y `~matplotlib.axis` with sharex and/or sharey. The
1292         axis will have the same limits, ticks, and scale as the axis of the
1293         shared axes.
1294 
1295     label : str
1296         A label for the returned axes.
1297 
1298     Returns
1299     -------
1300     `~.axes.Axes`
1301 
1302         The Axes of the subplot. The returned Axes can actually be an instance
1303         of a subclass, such as `.projections.polar.PolarAxes` for polar
1304         projections.
1305 
1306     Other Parameters
1307     ----------------
1308     **kwargs
1309         This method also takes the keyword arguments for the returned axes
1310         base class; except for the *figure* argument. The keyword arguments
1311         for the rectilinear base class `~.axes.Axes` can be found in
1312         the following table but there might also be other keyword
1313         arguments if another projection is used.
1314 
1315         %(Axes:kwdoc)s
1316 
1317     Notes
1318     -----
1319     Creating a new Axes will delete any preexisting Axes that
1320     overlaps with it beyond sharing a boundary::
1321 
1322         import matplotlib.pyplot as plt
1323         # plot a line, implicitly creating a subplot(111)
1324         plt.plot([1, 2, 3])
1325         # now create a subplot which represents the top plot of a grid
1326         # with 2 rows and 1 column. Since this subplot will overlap the
1327         # first, the plot (and its axes) previously created, will be removed
1328         plt.subplot(211)
1329 
1330     If you do not want this behavior, use the `.Figure.add_subplot` method
1331     or the `.pyplot.axes` function instead.
1332 
1333     If no *kwargs* are passed and there exists an Axes in the location
1334     specified by *args* then that Axes will be returned rather than a new
1335     Axes being created.
1336 
1337     If *kwargs* are passed and there exists an Axes in the location
1338     specified by *args*, the projection type is the same, and the
1339     *kwargs* match with the existing Axes, then the existing Axes is
1340     returned.  Otherwise a new Axes is created with the specified
1341     parameters.  We save a reference to the *kwargs* which we use
1342     for this comparison.  If any of the values in *kwargs* are
1343     mutable we will not detect the case where they are mutated.
1344     In these cases we suggest using `.Figure.add_subplot` and the
1345     explicit Axes API rather than the implicit pyplot API.
1346 
1347     See Also
1348     --------
1349     .Figure.add_subplot
1350     .pyplot.subplots
1351     .pyplot.axes
1352     .Figure.subplots
1353 
1354     Examples
1355     --------
1356     ::
1357 
1358         plt.subplot(221)
1359 
1360         # equivalent but more general
1361         ax1 = plt.subplot(2, 2, 1)
1362 
1363         # add a subplot with no frame
1364         ax2 = plt.subplot(222, frameon=False)
1365 
1366         # add a polar subplot
1367         plt.subplot(223, projection='polar')
1368 
1369         # add a red subplot that shares the x-axis with ax1
1370         plt.subplot(224, sharex=ax1, facecolor='red')
1371 
1372         # delete ax2 from the figure
1373         plt.delaxes(ax2)
1374 
1375         # add ax2 to the figure again
1376         plt.subplot(ax2)
1377 
1378         # make the first axes "current" again
1379         plt.subplot(221)
1380 
1381     """
1382     # Here we will only normalize `polar=True` vs `projection='polar'` and let
1383     # downstream code deal with the rest.
1384     unset = object()
1385     projection = kwargs.get('projection', unset)
1386     polar = kwargs.pop('polar', unset)
1387     if polar is not unset and polar:
1388         # if we got mixed messages from the user, raise
1389         if projection is not unset and projection != 'polar':
1390             raise ValueError(
1391                 f"polar={polar}, yet projection={projection!r}. "
1392                 "Only one of these arguments should be supplied."
1393             )
1394         kwargs['projection'] = projection = 'polar'
1395 
1396     # if subplot called without arguments, create subplot(1, 1, 1)
1397     if len(args) == 0:
1398         args = (1, 1, 1)
1399 
1400     # This check was added because it is very easy to type subplot(1, 2, False)
1401     # when subplots(1, 2, False) was intended (sharex=False, that is). In most
1402     # cases, no error will ever occur, but mysterious behavior can result
1403     # because what was intended to be the sharex argument is instead treated as
1404     # a subplot index for subplot()
1405     if len(args) >= 3 and isinstance(args[2], bool):
1406         _api.warn_external("The subplot index argument to subplot() appears "
1407                            "to be a boolean. Did you intend to use "
1408                            "subplots()?")
1409     # Check for nrows and ncols, which are not valid subplot args:
1410     if 'nrows' in kwargs or 'ncols' in kwargs:
1411         raise TypeError("subplot() got an unexpected keyword argument 'ncols' "
1412                         "and/or 'nrows'.  Did you intend to call subplots()?")
1413 
1414     fig = gcf()
1415 
1416     # First, search for an existing subplot with a matching spec.
1417     key = SubplotSpec._from_subplot_args(fig, args)
1418 
1419     for ax in fig.axes:
1420         # If we found an Axes at the position, we can re-use it if the user passed no
1421         # kwargs or if the axes class and kwargs are identical.
1422         if (ax.get_subplotspec() == key
1423             and (kwargs == {}
1424                  or (ax._projection_init
1425                      == fig._process_projection_requirements(**kwargs)))):
1426             break
1427     else:
1428         # we have exhausted the known Axes and none match, make a new one!
1429         ax = fig.add_subplot(*args, **kwargs)
1430 
1431     fig.sca(ax)
1432 
1433     return ax
1434 
1435 
1436 def subplots(
1437     nrows: int = 1, ncols: int = 1, *,
1438     sharex: bool | Literal["none", "all", "row", "col"] = False,
1439     sharey: bool | Literal["none", "all", "row", "col"] = False,
1440     squeeze: bool = True,
1441     width_ratios: Sequence[float] | None = None,
1442     height_ratios: Sequence[float] | None = None,
1443     subplot_kw: dict[str, Any] | None = None,
1444     gridspec_kw: dict[str, Any] | None = None,
1445     **fig_kw
1446 ) -> tuple[Figure, Any]:
1447     """
1448     Create a figure and a set of subplots.
1449 
1450     This utility wrapper makes it convenient to create common layouts of
1451     subplots, including the enclosing figure object, in a single call.
1452 
1453     Parameters
1454     ----------
1455     nrows, ncols : int, default: 1
1456         Number of rows/columns of the subplot grid.
1457 
1458     sharex, sharey : bool or {'none', 'all', 'row', 'col'}, default: False
1459         Controls sharing of properties among x (*sharex*) or y (*sharey*)
1460         axes:
1461 
1462         - True or 'all': x- or y-axis will be shared among all subplots.
1463         - False or 'none': each subplot x- or y-axis will be independent.
1464         - 'row': each subplot row will share an x- or y-axis.
1465         - 'col': each subplot column will share an x- or y-axis.
1466 
1467         When subplots have a shared x-axis along a column, only the x tick
1468         labels of the bottom subplot are created. Similarly, when subplots
1469         have a shared y-axis along a row, only the y tick labels of the first
1470         column subplot are created. To later turn other subplots' ticklabels
1471         on, use `~matplotlib.axes.Axes.tick_params`.
1472 
1473         When subplots have a shared axis that has units, calling
1474         `~matplotlib.axis.Axis.set_units` will update each axis with the
1475         new units.
1476 
1477     squeeze : bool, default: True
1478         - If True, extra dimensions are squeezed out from the returned
1479           array of `~matplotlib.axes.Axes`:
1480 
1481           - if only one subplot is constructed (nrows=ncols=1), the
1482             resulting single Axes object is returned as a scalar.
1483           - for Nx1 or 1xM subplots, the returned object is a 1D numpy
1484             object array of Axes objects.
1485           - for NxM, subplots with N>1 and M>1 are returned as a 2D array.
1486 
1487         - If False, no squeezing at all is done: the returned Axes object is
1488           always a 2D array containing Axes instances, even if it ends up
1489           being 1x1.
1490 
1491     width_ratios : array-like of length *ncols*, optional
1492         Defines the relative widths of the columns. Each column gets a
1493         relative width of ``width_ratios[i] / sum(width_ratios)``.
1494         If not given, all columns will have the same width.  Equivalent
1495         to ``gridspec_kw={'width_ratios': [...]}``.
1496 
1497     height_ratios : array-like of length *nrows*, optional
1498         Defines the relative heights of the rows. Each row gets a
1499         relative height of ``height_ratios[i] / sum(height_ratios)``.
1500         If not given, all rows will have the same height. Convenience
1501         for ``gridspec_kw={'height_ratios': [...]}``.
1502 
1503     subplot_kw : dict, optional
1504         Dict with keywords passed to the
1505         `~matplotlib.figure.Figure.add_subplot` call used to create each
1506         subplot.
1507 
1508     gridspec_kw : dict, optional
1509         Dict with keywords passed to the `~matplotlib.gridspec.GridSpec`
1510         constructor used to create the grid the subplots are placed on.
1511 
1512     **fig_kw
1513         All additional keyword arguments are passed to the
1514         `.pyplot.figure` call.
1515 
1516     Returns
1517     -------
1518     fig : `.Figure`
1519 
1520     ax : `~matplotlib.axes.Axes` or array of Axes
1521         *ax* can be either a single `~.axes.Axes` object, or an array of Axes
1522         objects if more than one subplot was created.  The dimensions of the
1523         resulting array can be controlled with the squeeze keyword, see above.
1524 
1525         Typical idioms for handling the return value are::
1526 
1527             # using the variable ax for single a Axes
1528             fig, ax = plt.subplots()
1529 
1530             # using the variable axs for multiple Axes
1531             fig, axs = plt.subplots(2, 2)
1532 
1533             # using tuple unpacking for multiple Axes
1534             fig, (ax1, ax2) = plt.subplots(1, 2)
1535             fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2)
1536 
1537         The names ``ax`` and pluralized ``axs`` are preferred over ``axes``
1538         because for the latter it's not clear if it refers to a single
1539         `~.axes.Axes` instance or a collection of these.
1540 
1541     See Also
1542     --------
1543     .pyplot.figure
1544     .pyplot.subplot
1545     .pyplot.axes
1546     .Figure.subplots
1547     .Figure.add_subplot
1548 
1549     Examples
1550     --------
1551     ::
1552 
1553         # First create some toy data:
1554         x = np.linspace(0, 2*np.pi, 400)
1555         y = np.sin(x**2)
1556 
1557         # Create just a figure and only one subplot
1558         fig, ax = plt.subplots()
1559         ax.plot(x, y)
1560         ax.set_title('Simple plot')
1561 
1562         # Create two subplots and unpack the output array immediately
1563         f, (ax1, ax2) = plt.subplots(1, 2, sharey=True)
1564         ax1.plot(x, y)
1565         ax1.set_title('Sharing Y axis')
1566         ax2.scatter(x, y)
1567 
1568         # Create four polar axes and access them through the returned array
1569         fig, axs = plt.subplots(2, 2, subplot_kw=dict(projection="polar"))
1570         axs[0, 0].plot(x, y)
1571         axs[1, 1].scatter(x, y)
1572 
1573         # Share a X axis with each column of subplots
1574         plt.subplots(2, 2, sharex='col')
1575 
1576         # Share a Y axis with each row of subplots
1577         plt.subplots(2, 2, sharey='row')
1578 
1579         # Share both X and Y axes with all subplots
1580         plt.subplots(2, 2, sharex='all', sharey='all')
1581 
1582         # Note that this is the same as
1583         plt.subplots(2, 2, sharex=True, sharey=True)
1584 
1585         # Create figure number 10 with a single subplot
1586         # and clears it if it already exists.
1587         fig, ax = plt.subplots(num=10, clear=True)
1588 
1589     """
1590     fig = figure(**fig_kw)
1591     axs = fig.subplots(nrows=nrows, ncols=ncols, sharex=sharex, sharey=sharey,
1592                        squeeze=squeeze, subplot_kw=subplot_kw,
1593                        gridspec_kw=gridspec_kw, height_ratios=height_ratios,
1594                        width_ratios=width_ratios)
1595     return fig, axs
1596 
1597 
1598 def subplot_mosaic(
1599     mosaic: str | HashableList,
1600     *,
1601     sharex: bool = False,
1602     sharey: bool = False,
1603     width_ratios: ArrayLike | None = None,
1604     height_ratios: ArrayLike | None = None,
1605     empty_sentinel: Any = '.',
1606     subplot_kw: dict[str, Any] | None = None,
1607     gridspec_kw: dict[str, Any] | None = None,
1608     per_subplot_kw: dict[Hashable, dict[str, Any]] | None = None,
1609     **fig_kw
1610 ) -> tuple[Figure, dict[Hashable, matplotlib.axes.Axes]]:
1611     """
1612     Build a layout of Axes based on ASCII art or nested lists.
1613 
1614     This is a helper function to build complex GridSpec layouts visually.
1615 
1616     See :ref:`mosaic`
1617     for an example and full API documentation
1618 
1619     Parameters
1620     ----------
1621     mosaic : list of list of {hashable or nested} or str
1622 
1623         A visual layout of how you want your Axes to be arranged
1624         labeled as strings.  For example ::
1625 
1626            x = [['A panel', 'A panel', 'edge'],
1627                 ['C panel', '.',       'edge']]
1628 
1629         produces 4 axes:
1630 
1631         - 'A panel' which is 1 row high and spans the first two columns
1632         - 'edge' which is 2 rows high and is on the right edge
1633         - 'C panel' which in 1 row and 1 column wide in the bottom left
1634         - a blank space 1 row and 1 column wide in the bottom center
1635 
1636         Any of the entries in the layout can be a list of lists
1637         of the same form to create nested layouts.
1638 
1639         If input is a str, then it must be of the form ::
1640 
1641           '''
1642           AAE
1643           C.E
1644           '''
1645 
1646         where each character is a column and each line is a row.
1647         This only allows only single character Axes labels and does
1648         not allow nesting but is very terse.
1649 
1650     sharex, sharey : bool, default: False
1651         If True, the x-axis (*sharex*) or y-axis (*sharey*) will be shared
1652         among all subplots.  In that case, tick label visibility and axis units
1653         behave as for `subplots`.  If False, each subplot's x- or y-axis will
1654         be independent.
1655 
1656     width_ratios : array-like of length *ncols*, optional
1657         Defines the relative widths of the columns. Each column gets a
1658         relative width of ``width_ratios[i] / sum(width_ratios)``.
1659         If not given, all columns will have the same width.  Convenience
1660         for ``gridspec_kw={'width_ratios': [...]}``.
1661 
1662     height_ratios : array-like of length *nrows*, optional
1663         Defines the relative heights of the rows. Each row gets a
1664         relative height of ``height_ratios[i] / sum(height_ratios)``.
1665         If not given, all rows will have the same height. Convenience
1666         for ``gridspec_kw={'height_ratios': [...]}``.
1667 
1668     empty_sentinel : object, optional
1669         Entry in the layout to mean "leave this space empty".  Defaults
1670         to ``'.'``. Note, if *layout* is a string, it is processed via
1671         `inspect.cleandoc` to remove leading white space, which may
1672         interfere with using white-space as the empty sentinel.
1673 
1674     subplot_kw : dict, optional
1675         Dictionary with keywords passed to the `.Figure.add_subplot` call
1676         used to create each subplot.  These values may be overridden by
1677         values in *per_subplot_kw*.
1678 
1679     per_subplot_kw : dict, optional
1680         A dictionary mapping the Axes identifiers or tuples of identifiers
1681         to a dictionary of keyword arguments to be passed to the
1682         `.Figure.add_subplot` call used to create each subplot.  The values
1683         in these dictionaries have precedence over the values in
1684         *subplot_kw*.
1685 
1686         If *mosaic* is a string, and thus all keys are single characters,
1687         it is possible to use a single string instead of a tuple as keys;
1688         i.e. ``"AB"`` is equivalent to ``("A", "B")``.
1689 
1690         .. versionadded:: 3.7
1691 
1692     gridspec_kw : dict, optional
1693         Dictionary with keywords passed to the `.GridSpec` constructor used
1694         to create the grid the subplots are placed on.
1695 
1696     **fig_kw
1697         All additional keyword arguments are passed to the
1698         `.pyplot.figure` call.
1699 
1700     Returns
1701     -------
1702     fig : `.Figure`
1703        The new figure
1704 
1705     dict[label, Axes]
1706        A dictionary mapping the labels to the Axes objects.  The order of
1707        the axes is left-to-right and top-to-bottom of their position in the
1708        total layout.
1709 
1710     """
1711     fig = figure(**fig_kw)
1712     ax_dict = fig.subplot_mosaic(
1713         mosaic, sharex=sharex, sharey=sharey,
1714         height_ratios=height_ratios, width_ratios=width_ratios,
1715         subplot_kw=subplot_kw, gridspec_kw=gridspec_kw,
1716         empty_sentinel=empty_sentinel,
1717         per_subplot_kw=per_subplot_kw,
1718     )
1719     return fig, ax_dict
1720 
1721 
1722 def subplot2grid(
1723     shape: tuple[int, int], loc: tuple[int, int],
1724     rowspan: int = 1, colspan: int = 1,
1725     fig: Figure | None = None,
1726     **kwargs
1727 ) -> matplotlib.axes.Axes:
1728     """
1729     Create a subplot at a specific location inside a regular grid.
1730 
1731     Parameters
1732     ----------
1733     shape : (int, int)
1734         Number of rows and of columns of the grid in which to place axis.
1735     loc : (int, int)
1736         Row number and column number of the axis location within the grid.
1737     rowspan : int, default: 1
1738         Number of rows for the axis to span downwards.
1739     colspan : int, default: 1
1740         Number of columns for the axis to span to the right.
1741     fig : `.Figure`, optional
1742         Figure to place the subplot in. Defaults to the current figure.
1743     **kwargs
1744         Additional keyword arguments are handed to `~.Figure.add_subplot`.
1745 
1746     Returns
1747     -------
1748     `~.axes.Axes`
1749 
1750         The Axes of the subplot. The returned Axes can actually be an instance
1751         of a subclass, such as `.projections.polar.PolarAxes` for polar
1752         projections.
1753 
1754     Notes
1755     -----
1756     The following call ::
1757 
1758         ax = subplot2grid((nrows, ncols), (row, col), rowspan, colspan)
1759 
1760     is identical to ::
1761 
1762         fig = gcf()
1763         gs = fig.add_gridspec(nrows, ncols)
1764         ax = fig.add_subplot(gs[row:row+rowspan, col:col+colspan])
1765     """
1766     if fig is None:
1767         fig = gcf()
1768     rows, cols = shape
1769     gs = GridSpec._check_gridspec_exists(fig, rows, cols)
1770     subplotspec = gs.new_subplotspec(loc, rowspan=rowspan, colspan=colspan)
1771     return fig.add_subplot(subplotspec, **kwargs)
1772 
1773 
1774 def twinx(ax: matplotlib.axes.Axes | None = None) -> _AxesBase:
1775     """
1776     Make and return a second axes that shares the *x*-axis.  The new axes will
1777     overlay *ax* (or the current axes if *ax* is *None*), and its ticks will be
1778     on the right.
1779 
1780     Examples
1781     --------
1782     :doc:`/gallery/subplots_axes_and_figures/two_scales`
1783     """
1784     if ax is None:
1785         ax = gca()
1786     ax1 = ax.twinx()
1787     return ax1
1788 
1789 
1790 def twiny(ax: matplotlib.axes.Axes | None = None) -> _AxesBase:
1791     """
1792     Make and return a second axes that shares the *y*-axis.  The new axes will
1793     overlay *ax* (or the current axes if *ax* is *None*), and its ticks will be
1794     on the top.
1795 
1796     Examples
1797     --------
1798     :doc:`/gallery/subplots_axes_and_figures/two_scales`
1799     """
1800     if ax is None:
1801         ax = gca()
1802     ax1 = ax.twiny()
1803     return ax1
1804 
1805 
1806 def subplot_tool(targetfig: Figure | None = None) -> SubplotTool | None:
1807     """
1808     Launch a subplot tool window for a figure.
1809 
1810     Returns
1811     -------
1812     `matplotlib.widgets.SubplotTool`
1813     """
1814     if targetfig is None:
1815         targetfig = gcf()
1816     tb = targetfig.canvas.manager.toolbar  # type: ignore[union-attr]
1817     if hasattr(tb, "configure_subplots"):  # toolbar2
1818         from matplotlib.backend_bases import NavigationToolbar2
1819         return cast(NavigationToolbar2, tb).configure_subplots()
1820     elif hasattr(tb, "trigger_tool"):  # toolmanager
1821         from matplotlib.backend_bases import ToolContainerBase
1822         cast(ToolContainerBase, tb).trigger_tool("subplots")
1823         return None
1824     else:
1825         raise ValueError("subplot_tool can only be launched for figures with "
1826                          "an associated toolbar")
1827 
1828 
1829 def box(on: bool | None = None) -> None:
1830     """
1831     Turn the axes box on or off on the current axes.
1832 
1833     Parameters
1834     ----------
1835     on : bool or None
1836         The new `~matplotlib.axes.Axes` box state. If ``None``, toggle
1837         the state.
1838 
1839     See Also
1840     --------
1841     :meth:`matplotlib.axes.Axes.set_frame_on`
1842     :meth:`matplotlib.axes.Axes.get_frame_on`
1843     """
1844     ax = gca()
1845     if on is None:
1846         on = not ax.get_frame_on()
1847     ax.set_frame_on(on)
1848 
1849 ## Axis ##
1850 
1851 
1852 def xlim(*args, **kwargs) -> tuple[float, float]:
1853     """
1854     Get or set the x limits of the current axes.
1855 
1856     Call signatures::
1857 
1858         left, right = xlim()  # return the current xlim
1859         xlim((left, right))   # set the xlim to left, right
1860         xlim(left, right)     # set the xlim to left, right
1861 
1862     If you do not specify args, you can pass *left* or *right* as kwargs,
1863     i.e.::
1864 
1865         xlim(right=3)  # adjust the right leaving left unchanged
1866         xlim(left=1)  # adjust the left leaving right unchanged
1867 
1868     Setting limits turns autoscaling off for the x-axis.
1869 
1870     Returns
1871     -------
1872     left, right
1873         A tuple of the new x-axis limits.
1874 
1875     Notes
1876     -----
1877     Calling this function with no arguments (e.g. ``xlim()``) is the pyplot
1878     equivalent of calling `~.Axes.get_xlim` on the current axes.
1879     Calling this function with arguments is the pyplot equivalent of calling
1880     `~.Axes.set_xlim` on the current axes. All arguments are passed though.
1881     """
1882     ax = gca()
1883     if not args and not kwargs:
1884         return ax.get_xlim()
1885     ret = ax.set_xlim(*args, **kwargs)
1886     return ret
1887 
1888 
1889 def ylim(*args, **kwargs) -> tuple[float, float]:
1890     """
1891     Get or set the y-limits of the current axes.
1892 
1893     Call signatures::
1894 
1895         bottom, top = ylim()  # return the current ylim
1896         ylim((bottom, top))   # set the ylim to bottom, top
1897         ylim(bottom, top)     # set the ylim to bottom, top
1898 
1899     If you do not specify args, you can alternatively pass *bottom* or
1900     *top* as kwargs, i.e.::
1901 
1902         ylim(top=3)  # adjust the top leaving bottom unchanged
1903         ylim(bottom=1)  # adjust the bottom leaving top unchanged
1904 
1905     Setting limits turns autoscaling off for the y-axis.
1906 
1907     Returns
1908     -------
1909     bottom, top
1910         A tuple of the new y-axis limits.
1911 
1912     Notes
1913     -----
1914     Calling this function with no arguments (e.g. ``ylim()``) is the pyplot
1915     equivalent of calling `~.Axes.get_ylim` on the current axes.
1916     Calling this function with arguments is the pyplot equivalent of calling
1917     `~.Axes.set_ylim` on the current axes. All arguments are passed though.
1918     """
1919     ax = gca()
1920     if not args and not kwargs:
1921         return ax.get_ylim()
1922     ret = ax.set_ylim(*args, **kwargs)
1923     return ret
1924 
1925 
1926 def xticks(
1927     ticks: ArrayLike | None = None,
1928     labels: Sequence[str] | None = None,
1929     *,
1930     minor: bool = False,
1931     **kwargs
1932 ) -> tuple[list[Tick] | np.ndarray, list[Text]]:
1933     """
1934     Get or set the current tick locations and labels of the x-axis.
1935 
1936     Pass no arguments to return the current values without modifying them.
1937 
1938     Parameters
1939     ----------
1940     ticks : array-like, optional
1941         The list of xtick locations.  Passing an empty list removes all xticks.
1942     labels : array-like, optional
1943         The labels to place at the given *ticks* locations.  This argument can
1944         only be passed if *ticks* is passed as well.
1945     minor : bool, default: False
1946         If ``False``, get/set the major ticks/labels; if ``True``, the minor
1947         ticks/labels.
1948     **kwargs
1949         `.Text` properties can be used to control the appearance of the labels.
1950 
1951     Returns
1952     -------
1953     locs
1954         The list of xtick locations.
1955     labels
1956         The list of xlabel `.Text` objects.
1957 
1958     Notes
1959     -----
1960     Calling this function with no arguments (e.g. ``xticks()``) is the pyplot
1961     equivalent of calling `~.Axes.get_xticks` and `~.Axes.get_xticklabels` on
1962     the current axes.
1963     Calling this function with arguments is the pyplot equivalent of calling
1964     `~.Axes.set_xticks` and `~.Axes.set_xticklabels` on the current axes.
1965 
1966     Examples
1967     --------
1968     >>> locs, labels = xticks()  # Get the current locations and labels.
1969     >>> xticks(np.arange(0, 1, step=0.2))  # Set label locations.
1970     >>> xticks(np.arange(3), ['Tom', 'Dick', 'Sue'])  # Set text labels.
1971     >>> xticks([0, 1, 2], ['January', 'February', 'March'],
1972     ...        rotation=20)  # Set text labels and properties.
1973     >>> xticks([])  # Disable xticks.
1974     """
1975     ax = gca()
1976 
1977     locs: list[Tick] | np.ndarray
1978     if ticks is None:
1979         locs = ax.get_xticks(minor=minor)
1980         if labels is not None:
1981             raise TypeError("xticks(): Parameter 'labels' can't be set "
1982                             "without setting 'ticks'")
1983     else:
1984         locs = ax.set_xticks(ticks, minor=minor)
1985 
1986     labels_out: list[Text] = []
1987     if labels is None:
1988         labels_out = ax.get_xticklabels(minor=minor)
1989         for l in labels_out:
1990             l._internal_update(kwargs)
1991     else:
1992         labels_out = ax.set_xticklabels(labels, minor=minor, **kwargs)
1993 
1994     return locs, labels_out
1995 
1996 
1997 def yticks(
1998     ticks: ArrayLike | None = None,
1999     labels: Sequence[str] | None = None,
2000     *,
2001     minor: bool = False,
2002     **kwargs
2003 ) -> tuple[list[Tick] | np.ndarray, list[Text]]:
2004     """
2005     Get or set the current tick locations and labels of the y-axis.
2006 
2007     Pass no arguments to return the current values without modifying them.
2008 
2009     Parameters
2010     ----------
2011     ticks : array-like, optional
2012         The list of ytick locations.  Passing an empty list removes all yticks.
2013     labels : array-like, optional
2014         The labels to place at the given *ticks* locations.  This argument can
2015         only be passed if *ticks* is passed as well.
2016     minor : bool, default: False
2017         If ``False``, get/set the major ticks/labels; if ``True``, the minor
2018         ticks/labels.
2019     **kwargs
2020         `.Text` properties can be used to control the appearance of the labels.
2021 
2022     Returns
2023     -------
2024     locs
2025         The list of ytick locations.
2026     labels
2027         The list of ylabel `.Text` objects.
2028 
2029     Notes
2030     -----
2031     Calling this function with no arguments (e.g. ``yticks()``) is the pyplot
2032     equivalent of calling `~.Axes.get_yticks` and `~.Axes.get_yticklabels` on
2033     the current axes.
2034     Calling this function with arguments is the pyplot equivalent of calling
2035     `~.Axes.set_yticks` and `~.Axes.set_yticklabels` on the current axes.
2036 
2037     Examples
2038     --------
2039     >>> locs, labels = yticks()  # Get the current locations and labels.
2040     >>> yticks(np.arange(0, 1, step=0.2))  # Set label locations.
2041     >>> yticks(np.arange(3), ['Tom', 'Dick', 'Sue'])  # Set text labels.
2042     >>> yticks([0, 1, 2], ['January', 'February', 'March'],
2043     ...        rotation=45)  # Set text labels and properties.
2044     >>> yticks([])  # Disable yticks.
2045     """
2046     ax = gca()
2047 
2048     locs: list[Tick] | np.ndarray
2049     if ticks is None:
2050         locs = ax.get_yticks(minor=minor)
2051         if labels is not None:
2052             raise TypeError("yticks(): Parameter 'labels' can't be set "
2053                             "without setting 'ticks'")
2054     else:
2055         locs = ax.set_yticks(ticks, minor=minor)
2056 
2057     labels_out: list[Text] = []
2058     if labels is None:
2059         labels_out = ax.get_yticklabels(minor=minor)
2060         for l in labels_out:
2061             l._internal_update(kwargs)
2062     else:
2063         labels_out = ax.set_yticklabels(labels, minor=minor, **kwargs)
2064 
2065     return locs, labels_out
2066 
2067 
2068 def rgrids(
2069     radii: ArrayLike | None = None,
2070     labels: Sequence[str | Text] | None = None,
2071     angle: float | None = None,
2072     fmt: str | None = None,
2073     **kwargs
2074 ) -> tuple[list[Line2D], list[Text]]:
2075     """
2076     Get or set the radial gridlines on the current polar plot.
2077 
2078     Call signatures::
2079 
2080      lines, labels = rgrids()
2081      lines, labels = rgrids(radii, labels=None, angle=22.5, fmt=None, **kwargs)
2082 
2083     When called with no arguments, `.rgrids` simply returns the tuple
2084     (*lines*, *labels*). When called with arguments, the labels will
2085     appear at the specified radial distances and angle.
2086 
2087     Parameters
2088     ----------
2089     radii : tuple with floats
2090         The radii for the radial gridlines
2091 
2092     labels : tuple with strings or None
2093         The labels to use at each radial gridline. The
2094         `matplotlib.ticker.ScalarFormatter` will be used if None.
2095 
2096     angle : float
2097         The angular position of the radius labels in degrees.
2098 
2099     fmt : str or None
2100         Format string used in `matplotlib.ticker.FormatStrFormatter`.
2101         For example '%f'.
2102 
2103     Returns
2104     -------
2105     lines : list of `.lines.Line2D`
2106         The radial gridlines.
2107 
2108     labels : list of `.text.Text`
2109         The tick labels.
2110 
2111     Other Parameters
2112     ----------------
2113     **kwargs
2114         *kwargs* are optional `.Text` properties for the labels.
2115 
2116     See Also
2117     --------
2118     .pyplot.thetagrids
2119     .projections.polar.PolarAxes.set_rgrids
2120     .Axis.get_gridlines
2121     .Axis.get_ticklabels
2122 
2123     Examples
2124     --------
2125     ::
2126 
2127       # set the locations of the radial gridlines
2128       lines, labels = rgrids( (0.25, 0.5, 1.0) )
2129 
2130       # set the locations and labels of the radial gridlines
2131       lines, labels = rgrids( (0.25, 0.5, 1.0), ('Tom', 'Dick', 'Harry' ))
2132     """
2133     ax = gca()
2134     if not isinstance(ax, PolarAxes):
2135         raise RuntimeError('rgrids only defined for polar axes')
2136     if all(p is None for p in [radii, labels, angle, fmt]) and not kwargs:
2137         lines_out: list[Line2D] = ax.yaxis.get_gridlines()
2138         labels_out: list[Text] = ax.yaxis.get_ticklabels()
2139     elif radii is None:
2140         raise TypeError("'radii' cannot be None when other parameters are passed")
2141     else:
2142         lines_out, labels_out = ax.set_rgrids(
2143             radii, labels=labels, angle=angle, fmt=fmt, **kwargs)
2144     return lines_out, labels_out
2145 
2146 
2147 def thetagrids(
2148     angles: ArrayLike | None = None,
2149     labels: Sequence[str | Text] | None = None,
2150     fmt: str | None = None,
2151     **kwargs
2152 ) -> tuple[list[Line2D], list[Text]]:
2153     """
2154     Get or set the theta gridlines on the current polar plot.
2155 
2156     Call signatures::
2157 
2158      lines, labels = thetagrids()
2159      lines, labels = thetagrids(angles, labels=None, fmt=None, **kwargs)
2160 
2161     When called with no arguments, `.thetagrids` simply returns the tuple
2162     (*lines*, *labels*). When called with arguments, the labels will
2163     appear at the specified angles.
2164 
2165     Parameters
2166     ----------
2167     angles : tuple with floats, degrees
2168         The angles of the theta gridlines.
2169 
2170     labels : tuple with strings or None
2171         The labels to use at each radial gridline. The
2172         `.projections.polar.ThetaFormatter` will be used if None.
2173 
2174     fmt : str or None
2175         Format string used in `matplotlib.ticker.FormatStrFormatter`.
2176         For example '%f'. Note that the angle in radians will be used.
2177 
2178     Returns
2179     -------
2180     lines : list of `.lines.Line2D`
2181         The theta gridlines.
2182 
2183     labels : list of `.text.Text`
2184         The tick labels.
2185 
2186     Other Parameters
2187     ----------------
2188     **kwargs
2189         *kwargs* are optional `.Text` properties for the labels.
2190 
2191     See Also
2192     --------
2193     .pyplot.rgrids
2194     .projections.polar.PolarAxes.set_thetagrids
2195     .Axis.get_gridlines
2196     .Axis.get_ticklabels
2197 
2198     Examples
2199     --------
2200     ::
2201 
2202       # set the locations of the angular gridlines
2203       lines, labels = thetagrids(range(45, 360, 90))
2204 
2205       # set the locations and labels of the angular gridlines
2206       lines, labels = thetagrids(range(45, 360, 90), ('NE', 'NW', 'SW', 'SE'))
2207     """
2208     ax = gca()
2209     if not isinstance(ax, PolarAxes):
2210         raise RuntimeError('thetagrids only defined for polar axes')
2211     if all(param is None for param in [angles, labels, fmt]) and not kwargs:
2212         lines_out: list[Line2D] = ax.xaxis.get_ticklines()
2213         labels_out: list[Text] = ax.xaxis.get_ticklabels()
2214     elif angles is None:
2215         raise TypeError("'angles' cannot be None when other parameters are passed")
2216     else:
2217         lines_out, labels_out = ax.set_thetagrids(angles,
2218                                                   labels=labels, fmt=fmt,
2219                                                   **kwargs)
2220     return lines_out, labels_out
2221 
2222 
2223 @_api.deprecated("3.7", pending=True)
2224 def get_plot_commands() -> list[str]:
2225     """
2226     Get a sorted list of all of the plotting commands.
2227     """
2228     NON_PLOT_COMMANDS = {
2229         'connect', 'disconnect', 'get_current_fig_manager', 'ginput',
2230         'new_figure_manager', 'waitforbuttonpress'}
2231     return [name for name in _get_pyplot_commands()
2232             if name not in NON_PLOT_COMMANDS]
2233 
2234 
2235 def _get_pyplot_commands() -> list[str]:
2236     # This works by searching for all functions in this module and removing
2237     # a few hard-coded exclusions, as well as all of the colormap-setting
2238     # functions, and anything marked as private with a preceding underscore.
2239     exclude = {'colormaps', 'colors', 'get_plot_commands', *colormaps}
2240     this_module = inspect.getmodule(get_plot_commands)
2241     return sorted(
2242         name for name, obj in globals().items()
2243         if not name.startswith('_') and name not in exclude
2244            and inspect.isfunction(obj)
2245            and inspect.getmodule(obj) is this_module)
2246 
2247 
2248 ## Plotting part 1: manually generated functions and wrappers ##
2249 
2250 
2251 @_copy_docstring_and_deprecators(Figure.colorbar)
2252 def colorbar(
2253     mappable: ScalarMappable | None = None,
2254     cax: matplotlib.axes.Axes | None = None,
2255     ax: matplotlib.axes.Axes | Iterable[matplotlib.axes.Axes] | None = None,
2256     **kwargs
2257 ) -> Colorbar:
2258     if mappable is None:
2259         mappable = gci()
2260         if mappable is None:
2261             raise RuntimeError('No mappable was found to use for colorbar '
2262                                'creation. First define a mappable such as '
2263                                'an image (with imshow) or a contour set ('
2264                                'with contourf).')
2265     ret = gcf().colorbar(mappable, cax=cax, ax=ax, **kwargs)
2266     return ret
2267 
2268 
2269 def clim(vmin: float | None = None, vmax: float | None = None) -> None:
2270     """
2271     Set the color limits of the current image.
2272 
2273     If either *vmin* or *vmax* is None, the image min/max respectively
2274     will be used for color scaling.
2275 
2276     If you want to set the clim of multiple images, use
2277     `~.ScalarMappable.set_clim` on every image, for example::
2278 
2279       for im in gca().get_images():
2280           im.set_clim(0, 0.5)
2281 
2282     """
2283     im = gci()
2284     if im is None:
2285         raise RuntimeError('You must first define an image, e.g., with imshow')
2286 
2287     im.set_clim(vmin, vmax)
2288 
2289 
2290 # eventually this implementation should move here, use indirection for now to
2291 # avoid having two copies of the code floating around.
2292 def get_cmap(
2293     name: Colormap | str | None = None,
2294     lut: int | None = None
2295 ) -> Colormap:
2296     return cm._get_cmap(name=name, lut=lut)  # type: ignore
2297 get_cmap.__doc__ = cm._get_cmap.__doc__  # type: ignore
2298 
2299 
2300 def set_cmap(cmap: Colormap | str) -> None:
2301     """
2302     Set the default colormap, and applies it to the current image if any.
2303 
2304     Parameters
2305     ----------
2306     cmap : `~matplotlib.colors.Colormap` or str
2307         A colormap instance or the name of a registered colormap.
2308 
2309     See Also
2310     --------
2311     colormaps
2312     matplotlib.cm.register_cmap
2313     matplotlib.cm.get_cmap
2314     """
2315     cmap = get_cmap(cmap)
2316 
2317     rc('image', cmap=cmap.name)
2318     im = gci()
2319 
2320     if im is not None:
2321         im.set_cmap(cmap)
2322 
2323 
2324 @_copy_docstring_and_deprecators(matplotlib.image.imread)
2325 def imread(
2326         fname: str | pathlib.Path | BinaryIO, format: str | None = None
2327 ) -> np.ndarray:
2328     return matplotlib.image.imread(fname, format)
2329 
2330 
2331 @_copy_docstring_and_deprecators(matplotlib.image.imsave)
2332 def imsave(
2333     fname: str | os.PathLike | BinaryIO, arr: ArrayLike, **kwargs
2334 ) -> None:
2335     matplotlib.image.imsave(fname, arr, **kwargs)
2336 
2337 
2338 def matshow(A: ArrayLike, fignum: None | int = None, **kwargs) -> AxesImage:
2339     """
2340     Display an array as a matrix in a new figure window.
2341 
2342     The origin is set at the upper left hand corner and rows (first
2343     dimension of the array) are displayed horizontally.  The aspect
2344     ratio of the figure window is that of the array, unless this would
2345     make an excessively short or narrow figure.
2346 
2347     Tick labels for the xaxis are placed on top.
2348 
2349     Parameters
2350     ----------
2351     A : 2D array-like
2352         The matrix to be displayed.
2353 
2354     fignum : None or int
2355         If *None*, create a new figure window with automatic numbering.
2356 
2357         If a nonzero integer, draw into the figure with the given number
2358         (create it if it does not exist).
2359 
2360         If 0, use the current axes (or create one if it does not exist).
2361 
2362         .. note::
2363 
2364            Because of how `.Axes.matshow` tries to set the figure aspect
2365            ratio to be the one of the array, strange things may happen if you
2366            reuse an existing figure.
2367 
2368     Returns
2369     -------
2370     `~matplotlib.image.AxesImage`
2371 
2372     Other Parameters
2373     ----------------
2374     **kwargs : `~matplotlib.axes.Axes.imshow` arguments
2375 
2376     """
2377     A = np.asanyarray(A)
2378     if fignum == 0:
2379         ax = gca()
2380     else:
2381         # Extract actual aspect ratio of array and make appropriately sized
2382         # figure.
2383         fig = figure(fignum, figsize=figaspect(A))
2384         ax = fig.add_axes((0.15, 0.09, 0.775, 0.775))
2385     im = ax.matshow(A, **kwargs)
2386     sci(im)
2387     return im
2388 
2389 
2390 def polar(*args, **kwargs) -> list[Line2D]:
2391     """
2392     Make a polar plot.
2393 
2394     call signature::
2395 
2396       polar(theta, r, **kwargs)
2397 
2398     Multiple *theta*, *r* arguments are supported, with format strings, as in
2399     `plot`.
2400     """
2401     # If an axis already exists, check if it has a polar projection
2402     if gcf().get_axes():
2403         ax = gca()
2404         if not isinstance(ax, PolarAxes):
2405             _api.warn_external('Trying to create polar plot on an Axes '
2406                                'that does not have a polar projection.')
2407     else:
2408         ax = axes(projection="polar")
2409     return ax.plot(*args, **kwargs)
2410 
2411 
2412 # If rcParams['backend_fallback'] is true, and an interactive backend is
2413 # requested, ignore rcParams['backend'] and force selection of a backend that
2414 # is compatible with the current running interactive framework.
2415 if (rcParams["backend_fallback"]
2416         and rcParams._get_backend_or_none() in (  # type: ignore
2417             set(rcsetup.interactive_bk) - {'WebAgg', 'nbAgg'})
2418         and cbook._get_running_interactive_framework()):  # type: ignore
2419     rcParams._set("backend", rcsetup._auto_backend_sentinel)  # type: ignore
2420 
2421 # fmt: on
2422 
2423 ################# REMAINING CONTENT GENERATED BY boilerplate.py ##############
2424 
2425 
2426 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2427 @_copy_docstring_and_deprecators(Figure.figimage)
2428 def figimage(
2429     X: ArrayLike,
2430     xo: int = 0,
2431     yo: int = 0,
2432     alpha: float | None = None,
2433     norm: str | Normalize | None = None,
2434     cmap: str | Colormap | None = None,
2435     vmin: float | None = None,
2436     vmax: float | None = None,
2437     origin: Literal["upper", "lower"] | None = None,
2438     resize: bool = False,
2439     **kwargs,
2440 ) -> FigureImage:
2441     return gcf().figimage(
2442         X,
2443         xo=xo,
2444         yo=yo,
2445         alpha=alpha,
2446         norm=norm,
2447         cmap=cmap,
2448         vmin=vmin,
2449         vmax=vmax,
2450         origin=origin,
2451         resize=resize,
2452         **kwargs,
2453     )
2454 
2455 
2456 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2457 @_copy_docstring_and_deprecators(Figure.text)
2458 def figtext(
2459     x: float, y: float, s: str, fontdict: dict[str, Any] | None = None, **kwargs
2460 ) -> Text:
2461     return gcf().text(x, y, s, fontdict=fontdict, **kwargs)
2462 
2463 
2464 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2465 @_copy_docstring_and_deprecators(Figure.gca)
2466 def gca() -> Axes:
2467     return gcf().gca()
2468 
2469 
2470 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2471 @_copy_docstring_and_deprecators(Figure._gci)
2472 def gci() -> ScalarMappable | None:
2473     return gcf()._gci()
2474 
2475 
2476 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2477 @_copy_docstring_and_deprecators(Figure.ginput)
2478 def ginput(
2479     n: int = 1,
2480     timeout: float = 30,
2481     show_clicks: bool = True,
2482     mouse_add: MouseButton = MouseButton.LEFT,
2483     mouse_pop: MouseButton = MouseButton.RIGHT,
2484     mouse_stop: MouseButton = MouseButton.MIDDLE,
2485 ) -> list[tuple[int, int]]:
2486     return gcf().ginput(
2487         n=n,
2488         timeout=timeout,
2489         show_clicks=show_clicks,
2490         mouse_add=mouse_add,
2491         mouse_pop=mouse_pop,
2492         mouse_stop=mouse_stop,
2493     )
2494 
2495 
2496 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2497 @_copy_docstring_and_deprecators(Figure.subplots_adjust)
2498 def subplots_adjust(
2499     left: float | None = None,
2500     bottom: float | None = None,
2501     right: float | None = None,
2502     top: float | None = None,
2503     wspace: float | None = None,
2504     hspace: float | None = None,
2505 ) -> None:
2506     gcf().subplots_adjust(
2507         left=left, bottom=bottom, right=right, top=top, wspace=wspace, hspace=hspace
2508     )
2509 
2510 
2511 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2512 @_copy_docstring_and_deprecators(Figure.suptitle)
2513 def suptitle(t: str, **kwargs) -> Text:
2514     return gcf().suptitle(t, **kwargs)
2515 
2516 
2517 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2518 @_copy_docstring_and_deprecators(Figure.tight_layout)
2519 def tight_layout(
2520     *,
2521     pad: float = 1.08,
2522     h_pad: float | None = None,
2523     w_pad: float | None = None,
2524     rect: tuple[float, float, float, float] | None = None,
2525 ) -> None:
2526     gcf().tight_layout(pad=pad, h_pad=h_pad, w_pad=w_pad, rect=rect)
2527 
2528 
2529 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2530 @_copy_docstring_and_deprecators(Figure.waitforbuttonpress)
2531 def waitforbuttonpress(timeout: float = -1) -> None | bool:
2532     return gcf().waitforbuttonpress(timeout=timeout)
2533 
2534 
2535 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2536 @_copy_docstring_and_deprecators(Axes.acorr)
2537 def acorr(
2538     x: ArrayLike, *, data=None, **kwargs
2539 ) -> tuple[np.ndarray, np.ndarray, LineCollection | Line2D, Line2D | None]:
2540     return gca().acorr(x, **({"data": data} if data is not None else {}), **kwargs)
2541 
2542 
2543 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2544 @_copy_docstring_and_deprecators(Axes.angle_spectrum)
2545 def angle_spectrum(
2546     x: ArrayLike,
2547     Fs: float | None = None,
2548     Fc: int | None = None,
2549     window: Callable[[ArrayLike], ArrayLike] | ArrayLike | None = None,
2550     pad_to: int | None = None,
2551     sides: Literal["default", "onesided", "twosided"] | None = None,
2552     *,
2553     data=None,
2554     **kwargs,
2555 ) -> tuple[np.ndarray, np.ndarray, Line2D]:
2556     return gca().angle_spectrum(
2557         x,
2558         Fs=Fs,
2559         Fc=Fc,
2560         window=window,
2561         pad_to=pad_to,
2562         sides=sides,
2563         **({"data": data} if data is not None else {}),
2564         **kwargs,
2565     )
2566 
2567 
2568 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2569 @_copy_docstring_and_deprecators(Axes.annotate)
2570 def annotate(
2571     text: str,
2572     xy: tuple[float, float],
2573     xytext: tuple[float, float] | None = None,
2574     xycoords: str
2575     | Artist
2576     | Transform
2577     | Callable[[RendererBase], Bbox | Transform]
2578     | tuple[float, float] = "data",
2579     textcoords: str
2580     | Artist
2581     | Transform
2582     | Callable[[RendererBase], Bbox | Transform]
2583     | tuple[float, float]
2584     | None = None,
2585     arrowprops: dict[str, Any] | None = None,
2586     annotation_clip: bool | None = None,
2587     **kwargs,
2588 ) -> Annotation:
2589     return gca().annotate(
2590         text,
2591         xy,
2592         xytext=xytext,
2593         xycoords=xycoords,
2594         textcoords=textcoords,
2595         arrowprops=arrowprops,
2596         annotation_clip=annotation_clip,
2597         **kwargs,
2598     )
2599 
2600 
2601 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2602 @_copy_docstring_and_deprecators(Axes.arrow)
2603 def arrow(x: float, y: float, dx: float, dy: float, **kwargs) -> FancyArrow:
2604     return gca().arrow(x, y, dx, dy, **kwargs)
2605 
2606 
2607 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2608 @_copy_docstring_and_deprecators(Axes.autoscale)
2609 def autoscale(
2610     enable: bool = True,
2611     axis: Literal["both", "x", "y"] = "both",
2612     tight: bool | None = None,
2613 ) -> None:
2614     gca().autoscale(enable=enable, axis=axis, tight=tight)
2615 
2616 
2617 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2618 @_copy_docstring_and_deprecators(Axes.axhline)
2619 def axhline(y: float = 0, xmin: float = 0, xmax: float = 1, **kwargs) -> Line2D:
2620     return gca().axhline(y=y, xmin=xmin, xmax=xmax, **kwargs)
2621 
2622 
2623 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2624 @_copy_docstring_and_deprecators(Axes.axhspan)
2625 def axhspan(
2626     ymin: float, ymax: float, xmin: float = 0, xmax: float = 1, **kwargs
2627 ) -> Polygon:
2628     return gca().axhspan(ymin, ymax, xmin=xmin, xmax=xmax, **kwargs)
2629 
2630 
2631 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2632 @_copy_docstring_and_deprecators(Axes.axis)
2633 def axis(
2634     arg: tuple[float, float, float, float] | bool | str | None = None,
2635     /,
2636     *,
2637     emit: bool = True,
2638     **kwargs,
2639 ) -> tuple[float, float, float, float]:
2640     return gca().axis(arg, emit=emit, **kwargs)
2641 
2642 
2643 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2644 @_copy_docstring_and_deprecators(Axes.axline)
2645 def axline(
2646     xy1: tuple[float, float],
2647     xy2: tuple[float, float] | None = None,
2648     *,
2649     slope: float | None = None,
2650     **kwargs,
2651 ) -> Line2D:
2652     return gca().axline(xy1, xy2=xy2, slope=slope, **kwargs)
2653 
2654 
2655 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2656 @_copy_docstring_and_deprecators(Axes.axvline)
2657 def axvline(x: float = 0, ymin: float = 0, ymax: float = 1, **kwargs) -> Line2D:
2658     return gca().axvline(x=x, ymin=ymin, ymax=ymax, **kwargs)
2659 
2660 
2661 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2662 @_copy_docstring_and_deprecators(Axes.axvspan)
2663 def axvspan(
2664     xmin: float, xmax: float, ymin: float = 0, ymax: float = 1, **kwargs
2665 ) -> Polygon:
2666     return gca().axvspan(xmin, xmax, ymin=ymin, ymax=ymax, **kwargs)
2667 
2668 
2669 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2670 @_copy_docstring_and_deprecators(Axes.bar)
2671 def bar(
2672     x: float | ArrayLike,
2673     height: float | ArrayLike,
2674     width: float | ArrayLike = 0.8,
2675     bottom: float | ArrayLike | None = None,
2676     *,
2677     align: Literal["center", "edge"] = "center",
2678     data=None,
2679     **kwargs,
2680 ) -> BarContainer:
2681     return gca().bar(
2682         x,
2683         height,
2684         width=width,
2685         bottom=bottom,
2686         align=align,
2687         **({"data": data} if data is not None else {}),
2688         **kwargs,
2689     )
2690 
2691 
2692 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2693 @_copy_docstring_and_deprecators(Axes.barbs)
2694 def barbs(*args, data=None, **kwargs) -> Barbs:
2695     return gca().barbs(*args, **({"data": data} if data is not None else {}), **kwargs)
2696 
2697 
2698 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2699 @_copy_docstring_and_deprecators(Axes.barh)
2700 def barh(
2701     y: float | ArrayLike,
2702     width: float | ArrayLike,
2703     height: float | ArrayLike = 0.8,
2704     left: float | ArrayLike | None = None,
2705     *,
2706     align: Literal["center", "edge"] = "center",
2707     data=None,
2708     **kwargs,
2709 ) -> BarContainer:
2710     return gca().barh(
2711         y,
2712         width,
2713         height=height,
2714         left=left,
2715         align=align,
2716         **({"data": data} if data is not None else {}),
2717         **kwargs,
2718     )
2719 
2720 
2721 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2722 @_copy_docstring_and_deprecators(Axes.bar_label)
2723 def bar_label(
2724     container: BarContainer,
2725     labels: ArrayLike | None = None,
2726     *,
2727     fmt: str | Callable[[float], str] = "%g",
2728     label_type: Literal["center", "edge"] = "edge",
2729     padding: float = 0,
2730     **kwargs,
2731 ) -> list[Annotation]:
2732     return gca().bar_label(
2733         container,
2734         labels=labels,
2735         fmt=fmt,
2736         label_type=label_type,
2737         padding=padding,
2738         **kwargs,
2739     )
2740 
2741 
2742 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2743 @_copy_docstring_and_deprecators(Axes.boxplot)
2744 def boxplot(
2745     x: ArrayLike | Sequence[ArrayLike],
2746     notch: bool | None = None,
2747     sym: str | None = None,
2748     vert: bool | None = None,
2749     whis: float | tuple[float, float] | None = None,
2750     positions: ArrayLike | None = None,
2751     widths: float | ArrayLike | None = None,
2752     patch_artist: bool | None = None,
2753     bootstrap: int | None = None,
2754     usermedians: ArrayLike | None = None,
2755     conf_intervals: ArrayLike | None = None,
2756     meanline: bool | None = None,
2757     showmeans: bool | None = None,
2758     showcaps: bool | None = None,
2759     showbox: bool | None = None,
2760     showfliers: bool | None = None,
2761     boxprops: dict[str, Any] | None = None,
2762     labels: Sequence[str] | None = None,
2763     flierprops: dict[str, Any] | None = None,
2764     medianprops: dict[str, Any] | None = None,
2765     meanprops: dict[str, Any] | None = None,
2766     capprops: dict[str, Any] | None = None,
2767     whiskerprops: dict[str, Any] | None = None,
2768     manage_ticks: bool = True,
2769     autorange: bool = False,
2770     zorder: float | None = None,
2771     capwidths: float | ArrayLike | None = None,
2772     *,
2773     data=None,
2774 ) -> dict[str, Any]:
2775     return gca().boxplot(
2776         x,
2777         notch=notch,
2778         sym=sym,
2779         vert=vert,
2780         whis=whis,
2781         positions=positions,
2782         widths=widths,
2783         patch_artist=patch_artist,
2784         bootstrap=bootstrap,
2785         usermedians=usermedians,
2786         conf_intervals=conf_intervals,
2787         meanline=meanline,
2788         showmeans=showmeans,
2789         showcaps=showcaps,
2790         showbox=showbox,
2791         showfliers=showfliers,
2792         boxprops=boxprops,
2793         labels=labels,
2794         flierprops=flierprops,
2795         medianprops=medianprops,
2796         meanprops=meanprops,
2797         capprops=capprops,
2798         whiskerprops=whiskerprops,
2799         manage_ticks=manage_ticks,
2800         autorange=autorange,
2801         zorder=zorder,
2802         capwidths=capwidths,
2803         **({"data": data} if data is not None else {}),
2804     )
2805 
2806 
2807 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2808 @_copy_docstring_and_deprecators(Axes.broken_barh)
2809 def broken_barh(
2810     xranges: Sequence[tuple[float, float]],
2811     yrange: tuple[float, float],
2812     *,
2813     data=None,
2814     **kwargs,
2815 ) -> BrokenBarHCollection:
2816     return gca().broken_barh(
2817         xranges, yrange, **({"data": data} if data is not None else {}), **kwargs
2818     )
2819 
2820 
2821 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2822 @_copy_docstring_and_deprecators(Axes.clabel)
2823 def clabel(CS: ContourSet, levels: ArrayLike | None = None, **kwargs) -> list[Text]:
2824     return gca().clabel(CS, levels=levels, **kwargs)
2825 
2826 
2827 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2828 @_copy_docstring_and_deprecators(Axes.cohere)
2829 def cohere(
2830     x: ArrayLike,
2831     y: ArrayLike,
2832     NFFT: int = 256,
2833     Fs: float = 2,
2834     Fc: int = 0,
2835     detrend: Literal["none", "mean", "linear"]
2836     | Callable[[ArrayLike], ArrayLike] = mlab.detrend_none,
2837     window: Callable[[ArrayLike], ArrayLike] | ArrayLike = mlab.window_hanning,
2838     noverlap: int = 0,
2839     pad_to: int | None = None,
2840     sides: Literal["default", "onesided", "twosided"] = "default",
2841     scale_by_freq: bool | None = None,
2842     *,
2843     data=None,
2844     **kwargs,
2845 ) -> tuple[np.ndarray, np.ndarray]:
2846     return gca().cohere(
2847         x,
2848         y,
2849         NFFT=NFFT,
2850         Fs=Fs,
2851         Fc=Fc,
2852         detrend=detrend,
2853         window=window,
2854         noverlap=noverlap,
2855         pad_to=pad_to,
2856         sides=sides,
2857         scale_by_freq=scale_by_freq,
2858         **({"data": data} if data is not None else {}),
2859         **kwargs,
2860     )
2861 
2862 
2863 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2864 @_copy_docstring_and_deprecators(Axes.contour)
2865 def contour(*args, data=None, **kwargs) -> QuadContourSet:
2866     __ret = gca().contour(
2867         *args, **({"data": data} if data is not None else {}), **kwargs
2868     )
2869     if __ret._A is not None:  # type: ignore[attr-defined]
2870         sci(__ret)
2871     return __ret
2872 
2873 
2874 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2875 @_copy_docstring_and_deprecators(Axes.contourf)
2876 def contourf(*args, data=None, **kwargs) -> QuadContourSet:
2877     __ret = gca().contourf(
2878         *args, **({"data": data} if data is not None else {}), **kwargs
2879     )
2880     if __ret._A is not None:  # type: ignore[attr-defined]
2881         sci(__ret)
2882     return __ret
2883 
2884 
2885 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2886 @_copy_docstring_and_deprecators(Axes.csd)
2887 def csd(
2888     x: ArrayLike,
2889     y: ArrayLike,
2890     NFFT: int | None = None,
2891     Fs: float | None = None,
2892     Fc: int | None = None,
2893     detrend: Literal["none", "mean", "linear"]
2894     | Callable[[ArrayLike], ArrayLike]
2895     | None = None,
2896     window: Callable[[ArrayLike], ArrayLike] | ArrayLike | None = None,
2897     noverlap: int | None = None,
2898     pad_to: int | None = None,
2899     sides: Literal["default", "onesided", "twosided"] | None = None,
2900     scale_by_freq: bool | None = None,
2901     return_line: bool | None = None,
2902     *,
2903     data=None,
2904     **kwargs,
2905 ) -> tuple[np.ndarray, np.ndarray] | tuple[np.ndarray, np.ndarray, Line2D]:
2906     return gca().csd(
2907         x,
2908         y,
2909         NFFT=NFFT,
2910         Fs=Fs,
2911         Fc=Fc,
2912         detrend=detrend,
2913         window=window,
2914         noverlap=noverlap,
2915         pad_to=pad_to,
2916         sides=sides,
2917         scale_by_freq=scale_by_freq,
2918         return_line=return_line,
2919         **({"data": data} if data is not None else {}),
2920         **kwargs,
2921     )
2922 
2923 
2924 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2925 @_copy_docstring_and_deprecators(Axes.ecdf)
2926 def ecdf(
2927     x: ArrayLike,
2928     weights: ArrayLike | None = None,
2929     *,
2930     complementary: bool = False,
2931     orientation: Literal["vertical", "horizonatal"] = "vertical",
2932     compress: bool = False,
2933     data=None,
2934     **kwargs,
2935 ) -> Line2D:
2936     return gca().ecdf(
2937         x,
2938         weights=weights,
2939         complementary=complementary,
2940         orientation=orientation,
2941         compress=compress,
2942         **({"data": data} if data is not None else {}),
2943         **kwargs,
2944     )
2945 
2946 
2947 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2948 @_copy_docstring_and_deprecators(Axes.errorbar)
2949 def errorbar(
2950     x: float | ArrayLike,
2951     y: float | ArrayLike,
2952     yerr: float | ArrayLike | None = None,
2953     xerr: float | ArrayLike | None = None,
2954     fmt: str = "",
2955     ecolor: ColorType | None = None,
2956     elinewidth: float | None = None,
2957     capsize: float | None = None,
2958     barsabove: bool = False,
2959     lolims: bool = False,
2960     uplims: bool = False,
2961     xlolims: bool = False,
2962     xuplims: bool = False,
2963     errorevery: int | tuple[int, int] = 1,
2964     capthick: float | None = None,
2965     *,
2966     data=None,
2967     **kwargs,
2968 ) -> ErrorbarContainer:
2969     return gca().errorbar(
2970         x,
2971         y,
2972         yerr=yerr,
2973         xerr=xerr,
2974         fmt=fmt,
2975         ecolor=ecolor,
2976         elinewidth=elinewidth,
2977         capsize=capsize,
2978         barsabove=barsabove,
2979         lolims=lolims,
2980         uplims=uplims,
2981         xlolims=xlolims,
2982         xuplims=xuplims,
2983         errorevery=errorevery,
2984         capthick=capthick,
2985         **({"data": data} if data is not None else {}),
2986         **kwargs,
2987     )
2988 
2989 
2990 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2991 @_copy_docstring_and_deprecators(Axes.eventplot)
2992 def eventplot(
2993     positions: ArrayLike | Sequence[ArrayLike],
2994     orientation: Literal["horizontal", "vertical"] = "horizontal",
2995     lineoffsets: float | Sequence[float] = 1,
2996     linelengths: float | Sequence[float] = 1,
2997     linewidths: float | Sequence[float] | None = None,
2998     colors: ColorType | Sequence[ColorType] | None = None,
2999     alpha: float | Sequence[float] | None = None,
3000     linestyles: LineStyleType | Sequence[LineStyleType] = "solid",
3001     *,
3002     data=None,
3003     **kwargs,
3004 ) -> EventCollection:
3005     return gca().eventplot(
3006         positions,
3007         orientation=orientation,
3008         lineoffsets=lineoffsets,
3009         linelengths=linelengths,
3010         linewidths=linewidths,
3011         colors=colors,
3012         alpha=alpha,
3013         linestyles=linestyles,
3014         **({"data": data} if data is not None else {}),
3015         **kwargs,
3016     )
3017 
3018 
3019 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3020 @_copy_docstring_and_deprecators(Axes.fill)
3021 def fill(*args, data=None, **kwargs) -> list[Polygon]:
3022     return gca().fill(*args, **({"data": data} if data is not None else {}), **kwargs)
3023 
3024 
3025 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3026 @_copy_docstring_and_deprecators(Axes.fill_between)
3027 def fill_between(
3028     x: ArrayLike,
3029     y1: ArrayLike | float,
3030     y2: ArrayLike | float = 0,
3031     where: Sequence[bool] | None = None,
3032     interpolate: bool = False,
3033     step: Literal["pre", "post", "mid"] | None = None,
3034     *,
3035     data=None,
3036     **kwargs,
3037 ) -> PolyCollection:
3038     return gca().fill_between(
3039         x,
3040         y1,
3041         y2=y2,
3042         where=where,
3043         interpolate=interpolate,
3044         step=step,
3045         **({"data": data} if data is not None else {}),
3046         **kwargs,
3047     )
3048 
3049 
3050 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3051 @_copy_docstring_and_deprecators(Axes.fill_betweenx)
3052 def fill_betweenx(
3053     y: ArrayLike,
3054     x1: ArrayLike | float,
3055     x2: ArrayLike | float = 0,
3056     where: Sequence[bool] | None = None,
3057     step: Literal["pre", "post", "mid"] | None = None,
3058     interpolate: bool = False,
3059     *,
3060     data=None,
3061     **kwargs,
3062 ) -> PolyCollection:
3063     return gca().fill_betweenx(
3064         y,
3065         x1,
3066         x2=x2,
3067         where=where,
3068         step=step,
3069         interpolate=interpolate,
3070         **({"data": data} if data is not None else {}),
3071         **kwargs,
3072     )
3073 
3074 
3075 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3076 @_copy_docstring_and_deprecators(Axes.grid)
3077 def grid(
3078     visible: bool | None = None,
3079     which: Literal["major", "minor", "both"] = "major",
3080     axis: Literal["both", "x", "y"] = "both",
3081     **kwargs,
3082 ) -> None:
3083     gca().grid(visible=visible, which=which, axis=axis, **kwargs)
3084 
3085 
3086 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3087 @_copy_docstring_and_deprecators(Axes.hexbin)
3088 def hexbin(
3089     x: ArrayLike,
3090     y: ArrayLike,
3091     C: ArrayLike | None = None,
3092     gridsize: int | tuple[int, int] = 100,
3093     bins: Literal["log"] | int | Sequence[float] | None = None,
3094     xscale: Literal["linear", "log"] = "linear",
3095     yscale: Literal["linear", "log"] = "linear",
3096     extent: tuple[float, float, float, float] | None = None,
3097     cmap: str | Colormap | None = None,
3098     norm: str | Normalize | None = None,
3099     vmin: float | None = None,
3100     vmax: float | None = None,
3101     alpha: float | None = None,
3102     linewidths: float | None = None,
3103     edgecolors: Literal["face", "none"] | ColorType = "face",
3104     reduce_C_function: Callable[[np.ndarray | list[float]], float] = np.mean,
3105     mincnt: int | None = None,
3106     marginals: bool = False,
3107     *,
3108     data=None,
3109     **kwargs,
3110 ) -> PolyCollection:
3111     __ret = gca().hexbin(
3112         x,
3113         y,
3114         C=C,
3115         gridsize=gridsize,
3116         bins=bins,
3117         xscale=xscale,
3118         yscale=yscale,
3119         extent=extent,
3120         cmap=cmap,
3121         norm=norm,
3122         vmin=vmin,
3123         vmax=vmax,
3124         alpha=alpha,
3125         linewidths=linewidths,
3126         edgecolors=edgecolors,
3127         reduce_C_function=reduce_C_function,
3128         mincnt=mincnt,
3129         marginals=marginals,
3130         **({"data": data} if data is not None else {}),
3131         **kwargs,
3132     )
3133     sci(__ret)
3134     return __ret
3135 
3136 
3137 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3138 @_copy_docstring_and_deprecators(Axes.hist)
3139 def hist(
3140     x: ArrayLike | Sequence[ArrayLike],
3141     bins: int | Sequence[float] | str | None = None,
3142     range: tuple[float, float] | None = None,
3143     density: bool = False,
3144     weights: ArrayLike | None = None,
3145     cumulative: bool | float = False,
3146     bottom: ArrayLike | float | None = None,
3147     histtype: Literal["bar", "barstacked", "step", "stepfilled"] = "bar",
3148     align: Literal["left", "mid", "right"] = "mid",
3149     orientation: Literal["vertical", "horizontal"] = "vertical",
3150     rwidth: float | None = None,
3151     log: bool = False,
3152     color: ColorType | Sequence[ColorType] | None = None,
3153     label: str | Sequence[str] | None = None,
3154     stacked: bool = False,
3155     *,
3156     data=None,
3157     **kwargs,
3158 ) -> tuple[
3159     np.ndarray | list[np.ndarray],
3160     np.ndarray,
3161     BarContainer | Polygon | list[BarContainer | Polygon],
3162 ]:
3163     return gca().hist(
3164         x,
3165         bins=bins,
3166         range=range,
3167         density=density,
3168         weights=weights,
3169         cumulative=cumulative,
3170         bottom=bottom,
3171         histtype=histtype,
3172         align=align,
3173         orientation=orientation,
3174         rwidth=rwidth,
3175         log=log,
3176         color=color,
3177         label=label,
3178         stacked=stacked,
3179         **({"data": data} if data is not None else {}),
3180         **kwargs,
3181     )
3182 
3183 
3184 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3185 @_copy_docstring_and_deprecators(Axes.stairs)
3186 def stairs(
3187     values: ArrayLike,
3188     edges: ArrayLike | None = None,
3189     *,
3190     orientation: Literal["vertical", "horizontal"] = "vertical",
3191     baseline: float | ArrayLike | None = 0,
3192     fill: bool = False,
3193     data=None,
3194     **kwargs,
3195 ) -> StepPatch:
3196     return gca().stairs(
3197         values,
3198         edges=edges,
3199         orientation=orientation,
3200         baseline=baseline,
3201         fill=fill,
3202         **({"data": data} if data is not None else {}),
3203         **kwargs,
3204     )
3205 
3206 
3207 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3208 @_copy_docstring_and_deprecators(Axes.hist2d)
3209 def hist2d(
3210     x: ArrayLike,
3211     y: ArrayLike,
3212     bins: None | int | tuple[int, int] | ArrayLike | tuple[ArrayLike, ArrayLike] = 10,
3213     range: ArrayLike | None = None,
3214     density: bool = False,
3215     weights: ArrayLike | None = None,
3216     cmin: float | None = None,
3217     cmax: float | None = None,
3218     *,
3219     data=None,
3220     **kwargs,
3221 ) -> tuple[np.ndarray, np.ndarray, np.ndarray, QuadMesh]:
3222     __ret = gca().hist2d(
3223         x,
3224         y,
3225         bins=bins,
3226         range=range,
3227         density=density,
3228         weights=weights,
3229         cmin=cmin,
3230         cmax=cmax,
3231         **({"data": data} if data is not None else {}),
3232         **kwargs,
3233     )
3234     sci(__ret[-1])
3235     return __ret
3236 
3237 
3238 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3239 @_copy_docstring_and_deprecators(Axes.hlines)
3240 def hlines(
3241     y: float | ArrayLike,
3242     xmin: float | ArrayLike,
3243     xmax: float | ArrayLike,
3244     colors: ColorType | Sequence[ColorType] | None = None,
3245     linestyles: LineStyleType = "solid",
3246     label: str = "",
3247     *,
3248     data=None,
3249     **kwargs,
3250 ) -> LineCollection:
3251     return gca().hlines(
3252         y,
3253         xmin,
3254         xmax,
3255         colors=colors,
3256         linestyles=linestyles,
3257         label=label,
3258         **({"data": data} if data is not None else {}),
3259         **kwargs,
3260     )
3261 
3262 
3263 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3264 @_copy_docstring_and_deprecators(Axes.imshow)
3265 def imshow(
3266     X: ArrayLike | PIL.Image.Image,
3267     cmap: str | Colormap | None = None,
3268     norm: str | Normalize | None = None,
3269     *,
3270     aspect: Literal["equal", "auto"] | float | None = None,
3271     interpolation: str | None = None,
3272     alpha: float | ArrayLike | None = None,
3273     vmin: float | None = None,
3274     vmax: float | None = None,
3275     origin: Literal["upper", "lower"] | None = None,
3276     extent: tuple[float, float, float, float] | None = None,
3277     interpolation_stage: Literal["data", "rgba"] | None = None,
3278     filternorm: bool = True,
3279     filterrad: float = 4.0,
3280     resample: bool | None = None,
3281     url: str | None = None,
3282     data=None,
3283     **kwargs,
3284 ) -> AxesImage:
3285     __ret = gca().imshow(
3286         X,
3287         cmap=cmap,
3288         norm=norm,
3289         aspect=aspect,
3290         interpolation=interpolation,
3291         alpha=alpha,
3292         vmin=vmin,
3293         vmax=vmax,
3294         origin=origin,
3295         extent=extent,
3296         interpolation_stage=interpolation_stage,
3297         filternorm=filternorm,
3298         filterrad=filterrad,
3299         resample=resample,
3300         url=url,
3301         **({"data": data} if data is not None else {}),
3302         **kwargs,
3303     )
3304     sci(__ret)
3305     return __ret
3306 
3307 
3308 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3309 @_copy_docstring_and_deprecators(Axes.legend)
3310 def legend(*args, **kwargs) -> Legend:
3311     return gca().legend(*args, **kwargs)
3312 
3313 
3314 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3315 @_copy_docstring_and_deprecators(Axes.locator_params)
3316 def locator_params(
3317     axis: Literal["both", "x", "y"] = "both", tight: bool | None = None, **kwargs
3318 ) -> None:
3319     gca().locator_params(axis=axis, tight=tight, **kwargs)
3320 
3321 
3322 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3323 @_copy_docstring_and_deprecators(Axes.loglog)
3324 def loglog(*args, **kwargs) -> list[Line2D]:
3325     return gca().loglog(*args, **kwargs)
3326 
3327 
3328 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3329 @_copy_docstring_and_deprecators(Axes.magnitude_spectrum)
3330 def magnitude_spectrum(
3331     x: ArrayLike,
3332     Fs: float | None = None,
3333     Fc: int | None = None,
3334     window: Callable[[ArrayLike], ArrayLike] | ArrayLike | None = None,
3335     pad_to: int | None = None,
3336     sides: Literal["default", "onesided", "twosided"] | None = None,
3337     scale: Literal["default", "linear", "dB"] | None = None,
3338     *,
3339     data=None,
3340     **kwargs,
3341 ) -> tuple[np.ndarray, np.ndarray, Line2D]:
3342     return gca().magnitude_spectrum(
3343         x,
3344         Fs=Fs,
3345         Fc=Fc,
3346         window=window,
3347         pad_to=pad_to,
3348         sides=sides,
3349         scale=scale,
3350         **({"data": data} if data is not None else {}),
3351         **kwargs,
3352     )
3353 
3354 
3355 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3356 @_copy_docstring_and_deprecators(Axes.margins)
3357 def margins(
3358     *margins: float,
3359     x: float | None = None,
3360     y: float | None = None,
3361     tight: bool | None = True,
3362 ) -> tuple[float, float] | None:
3363     return gca().margins(*margins, x=x, y=y, tight=tight)
3364 
3365 
3366 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3367 @_copy_docstring_and_deprecators(Axes.minorticks_off)
3368 def minorticks_off() -> None:
3369     gca().minorticks_off()
3370 
3371 
3372 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3373 @_copy_docstring_and_deprecators(Axes.minorticks_on)
3374 def minorticks_on() -> None:
3375     gca().minorticks_on()
3376 
3377 
3378 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3379 @_copy_docstring_and_deprecators(Axes.pcolor)
3380 def pcolor(
3381     *args: ArrayLike,
3382     shading: Literal["flat", "nearest", "auto"] | None = None,
3383     alpha: float | None = None,
3384     norm: str | Normalize | None = None,
3385     cmap: str | Colormap | None = None,
3386     vmin: float | None = None,
3387     vmax: float | None = None,
3388     data=None,
3389     **kwargs,
3390 ) -> Collection:
3391     __ret = gca().pcolor(
3392         *args,
3393         shading=shading,
3394         alpha=alpha,
3395         norm=norm,
3396         cmap=cmap,
3397         vmin=vmin,
3398         vmax=vmax,
3399         **({"data": data} if data is not None else {}),
3400         **kwargs,
3401     )
3402     sci(__ret)
3403     return __ret
3404 
3405 
3406 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3407 @_copy_docstring_and_deprecators(Axes.pcolormesh)
3408 def pcolormesh(
3409     *args: ArrayLike,
3410     alpha: float | None = None,
3411     norm: str | Normalize | None = None,
3412     cmap: str | Colormap | None = None,
3413     vmin: float | None = None,
3414     vmax: float | None = None,
3415     shading: Literal["flat", "nearest", "gouraud", "auto"] | None = None,
3416     antialiased: bool = False,
3417     data=None,
3418     **kwargs,
3419 ) -> QuadMesh:
3420     __ret = gca().pcolormesh(
3421         *args,
3422         alpha=alpha,
3423         norm=norm,
3424         cmap=cmap,
3425         vmin=vmin,
3426         vmax=vmax,
3427         shading=shading,
3428         antialiased=antialiased,
3429         **({"data": data} if data is not None else {}),
3430         **kwargs,
3431     )
3432     sci(__ret)
3433     return __ret
3434 
3435 
3436 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3437 @_copy_docstring_and_deprecators(Axes.phase_spectrum)
3438 def phase_spectrum(
3439     x: ArrayLike,
3440     Fs: float | None = None,
3441     Fc: int | None = None,
3442     window: Callable[[ArrayLike], ArrayLike] | ArrayLike | None = None,
3443     pad_to: int | None = None,
3444     sides: Literal["default", "onesided", "twosided"] | None = None,
3445     *,
3446     data=None,
3447     **kwargs,
3448 ) -> tuple[np.ndarray, np.ndarray, Line2D]:
3449     return gca().phase_spectrum(
3450         x,
3451         Fs=Fs,
3452         Fc=Fc,
3453         window=window,
3454         pad_to=pad_to,
3455         sides=sides,
3456         **({"data": data} if data is not None else {}),
3457         **kwargs,
3458     )
3459 
3460 
3461 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3462 @_copy_docstring_and_deprecators(Axes.pie)
3463 def pie(
3464     x: ArrayLike,
3465     explode: ArrayLike | None = None,
3466     labels: Sequence[str] | None = None,
3467     colors: ColorType | Sequence[ColorType] | None = None,
3468     autopct: str | Callable[[float], str] | None = None,
3469     pctdistance: float = 0.6,
3470     shadow: bool = False,
3471     labeldistance: float | None = 1.1,
3472     startangle: float = 0,
3473     radius: float = 1,
3474     counterclock: bool = True,
3475     wedgeprops: dict[str, Any] | None = None,
3476     textprops: dict[str, Any] | None = None,
3477     center: tuple[float, float] = (0, 0),
3478     frame: bool = False,
3479     rotatelabels: bool = False,
3480     *,
3481     normalize: bool = True,
3482     hatch: str | Sequence[str] | None = None,
3483     data=None,
3484 ) -> tuple[list[Wedge], list[Text]] | tuple[list[Wedge], list[Text], list[Text]]:
3485     return gca().pie(
3486         x,
3487         explode=explode,
3488         labels=labels,
3489         colors=colors,
3490         autopct=autopct,
3491         pctdistance=pctdistance,
3492         shadow=shadow,
3493         labeldistance=labeldistance,
3494         startangle=startangle,
3495         radius=radius,
3496         counterclock=counterclock,
3497         wedgeprops=wedgeprops,
3498         textprops=textprops,
3499         center=center,
3500         frame=frame,
3501         rotatelabels=rotatelabels,
3502         normalize=normalize,
3503         hatch=hatch,
3504         **({"data": data} if data is not None else {}),
3505     )
3506 
3507 
3508 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3509 @_copy_docstring_and_deprecators(Axes.plot)
3510 def plot(
3511     *args: float | ArrayLike | str,
3512     scalex: bool = True,
3513     scaley: bool = True,
3514     data=None,
3515     **kwargs,
3516 ) -> list[Line2D]:
3517     return gca().plot(
3518         *args,
3519         scalex=scalex,
3520         scaley=scaley,
3521         **({"data": data} if data is not None else {}),
3522         **kwargs,
3523     )
3524 
3525 
3526 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3527 @_copy_docstring_and_deprecators(Axes.plot_date)
3528 def plot_date(
3529     x: ArrayLike,
3530     y: ArrayLike,
3531     fmt: str = "o",
3532     tz: str | datetime.tzinfo | None = None,
3533     xdate: bool = True,
3534     ydate: bool = False,
3535     *,
3536     data=None,
3537     **kwargs,
3538 ) -> list[Line2D]:
3539     return gca().plot_date(
3540         x,
3541         y,
3542         fmt=fmt,
3543         tz=tz,
3544         xdate=xdate,
3545         ydate=ydate,
3546         **({"data": data} if data is not None else {}),
3547         **kwargs,
3548     )
3549 
3550 
3551 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3552 @_copy_docstring_and_deprecators(Axes.psd)
3553 def psd(
3554     x: ArrayLike,
3555     NFFT: int | None = None,
3556     Fs: float | None = None,
3557     Fc: int | None = None,
3558     detrend: Literal["none", "mean", "linear"]
3559     | Callable[[ArrayLike], ArrayLike]
3560     | None = None,
3561     window: Callable[[ArrayLike], ArrayLike] | ArrayLike | None = None,
3562     noverlap: int | None = None,
3563     pad_to: int | None = None,
3564     sides: Literal["default", "onesided", "twosided"] | None = None,
3565     scale_by_freq: bool | None = None,
3566     return_line: bool | None = None,
3567     *,
3568     data=None,
3569     **kwargs,
3570 ) -> tuple[np.ndarray, np.ndarray] | tuple[np.ndarray, np.ndarray, Line2D]:
3571     return gca().psd(
3572         x,
3573         NFFT=NFFT,
3574         Fs=Fs,
3575         Fc=Fc,
3576         detrend=detrend,
3577         window=window,
3578         noverlap=noverlap,
3579         pad_to=pad_to,
3580         sides=sides,
3581         scale_by_freq=scale_by_freq,
3582         return_line=return_line,
3583         **({"data": data} if data is not None else {}),
3584         **kwargs,
3585     )
3586 
3587 
3588 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3589 @_copy_docstring_and_deprecators(Axes.quiver)
3590 def quiver(*args, data=None, **kwargs) -> Quiver:
3591     __ret = gca().quiver(
3592         *args, **({"data": data} if data is not None else {}), **kwargs
3593     )
3594     sci(__ret)
3595     return __ret
3596 
3597 
3598 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3599 @_copy_docstring_and_deprecators(Axes.quiverkey)
3600 def quiverkey(
3601     Q: Quiver, X: float, Y: float, U: float, label: str, **kwargs
3602 ) -> QuiverKey:
3603     return gca().quiverkey(Q, X, Y, U, label, **kwargs)
3604 
3605 
3606 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3607 @_copy_docstring_and_deprecators(Axes.scatter)
3608 def scatter(
3609     x: float | ArrayLike,
3610     y: float | ArrayLike,
3611     s: float | ArrayLike | None = None,
3612     c: Sequence[ColorType] | ColorType | None = None,
3613     marker: MarkerType | None = None,
3614     cmap: str | Colormap | None = None,
3615     norm: str | Normalize | None = None,
3616     vmin: float | None = None,
3617     vmax: float | None = None,
3618     alpha: float | None = None,
3619     linewidths: float | Sequence[float] | None = None,
3620     *,
3621     edgecolors: Literal["face", "none"] | ColorType | Sequence[ColorType] | None = None,
3622     plotnonfinite: bool = False,
3623     data=None,
3624     **kwargs,
3625 ) -> PathCollection:
3626     __ret = gca().scatter(
3627         x,
3628         y,
3629         s=s,
3630         c=c,
3631         marker=marker,
3632         cmap=cmap,
3633         norm=norm,
3634         vmin=vmin,
3635         vmax=vmax,
3636         alpha=alpha,
3637         linewidths=linewidths,
3638         edgecolors=edgecolors,
3639         plotnonfinite=plotnonfinite,
3640         **({"data": data} if data is not None else {}),
3641         **kwargs,
3642     )
3643     sci(__ret)
3644     return __ret
3645 
3646 
3647 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3648 @_copy_docstring_and_deprecators(Axes.semilogx)
3649 def semilogx(*args, **kwargs) -> list[Line2D]:
3650     return gca().semilogx(*args, **kwargs)
3651 
3652 
3653 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3654 @_copy_docstring_and_deprecators(Axes.semilogy)
3655 def semilogy(*args, **kwargs) -> list[Line2D]:
3656     return gca().semilogy(*args, **kwargs)
3657 
3658 
3659 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3660 @_copy_docstring_and_deprecators(Axes.specgram)
3661 def specgram(
3662     x: ArrayLike,
3663     NFFT: int | None = None,
3664     Fs: float | None = None,
3665     Fc: int | None = None,
3666     detrend: Literal["none", "mean", "linear"]
3667     | Callable[[ArrayLike], ArrayLike]
3668     | None = None,
3669     window: Callable[[ArrayLike], ArrayLike] | ArrayLike | None = None,
3670     noverlap: int | None = None,
3671     cmap: str | Colormap | None = None,
3672     xextent: tuple[float, float] | None = None,
3673     pad_to: int | None = None,
3674     sides: Literal["default", "onesided", "twosided"] | None = None,
3675     scale_by_freq: bool | None = None,
3676     mode: Literal["default", "psd", "magnitude", "angle", "phase"] | None = None,
3677     scale: Literal["default", "linear", "dB"] | None = None,
3678     vmin: float | None = None,
3679     vmax: float | None = None,
3680     *,
3681     data=None,
3682     **kwargs,
3683 ) -> tuple[np.ndarray, np.ndarray, np.ndarray, AxesImage]:
3684     __ret = gca().specgram(
3685         x,
3686         NFFT=NFFT,
3687         Fs=Fs,
3688         Fc=Fc,
3689         detrend=detrend,
3690         window=window,
3691         noverlap=noverlap,
3692         cmap=cmap,
3693         xextent=xextent,
3694         pad_to=pad_to,
3695         sides=sides,
3696         scale_by_freq=scale_by_freq,
3697         mode=mode,
3698         scale=scale,
3699         vmin=vmin,
3700         vmax=vmax,
3701         **({"data": data} if data is not None else {}),
3702         **kwargs,
3703     )
3704     sci(__ret[-1])
3705     return __ret
3706 
3707 
3708 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3709 @_copy_docstring_and_deprecators(Axes.spy)
3710 def spy(
3711     Z: ArrayLike,
3712     precision: float | Literal["present"] = 0,
3713     marker: str | None = None,
3714     markersize: float | None = None,
3715     aspect: Literal["equal", "auto"] | float | None = "equal",
3716     origin: Literal["upper", "lower"] = "upper",
3717     **kwargs,
3718 ) -> AxesImage:
3719     __ret = gca().spy(
3720         Z,
3721         precision=precision,
3722         marker=marker,
3723         markersize=markersize,
3724         aspect=aspect,
3725         origin=origin,
3726         **kwargs,
3727     )
3728     if isinstance(__ret, cm.ScalarMappable):
3729         sci(__ret)  # noqa
3730     return __ret
3731 
3732 
3733 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3734 @_copy_docstring_and_deprecators(Axes.stackplot)
3735 def stackplot(x, *args, labels=(), colors=None, baseline="zero", data=None, **kwargs):
3736     return gca().stackplot(
3737         x,
3738         *args,
3739         labels=labels,
3740         colors=colors,
3741         baseline=baseline,
3742         **({"data": data} if data is not None else {}),
3743         **kwargs,
3744     )
3745 
3746 
3747 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3748 @_copy_docstring_and_deprecators(Axes.stem)
3749 def stem(
3750     *args: ArrayLike | str,
3751     linefmt: str | None = None,
3752     markerfmt: str | None = None,
3753     basefmt: str | None = None,
3754     bottom: float = 0,
3755     label: str | None = None,
3756     orientation: Literal["vertical", "horizontal"] = "vertical",
3757     data=None,
3758 ) -> StemContainer:
3759     return gca().stem(
3760         *args,
3761         linefmt=linefmt,
3762         markerfmt=markerfmt,
3763         basefmt=basefmt,
3764         bottom=bottom,
3765         label=label,
3766         orientation=orientation,
3767         **({"data": data} if data is not None else {}),
3768     )
3769 
3770 
3771 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3772 @_copy_docstring_and_deprecators(Axes.step)
3773 def step(
3774     x: ArrayLike,
3775     y: ArrayLike,
3776     *args,
3777     where: Literal["pre", "post", "mid"] = "pre",
3778     data=None,
3779     **kwargs,
3780 ) -> list[Line2D]:
3781     return gca().step(
3782         x,
3783         y,
3784         *args,
3785         where=where,
3786         **({"data": data} if data is not None else {}),
3787         **kwargs,
3788     )
3789 
3790 
3791 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3792 @_copy_docstring_and_deprecators(Axes.streamplot)
3793 def streamplot(
3794     x,
3795     y,
3796     u,
3797     v,
3798     density=1,
3799     linewidth=None,
3800     color=None,
3801     cmap=None,
3802     norm=None,
3803     arrowsize=1,
3804     arrowstyle="-|>",
3805     minlength=0.1,
3806     transform=None,
3807     zorder=None,
3808     start_points=None,
3809     maxlength=4.0,
3810     integration_direction="both",
3811     broken_streamlines=True,
3812     *,
3813     data=None,
3814 ):
3815     __ret = gca().streamplot(
3816         x,
3817         y,
3818         u,
3819         v,
3820         density=density,
3821         linewidth=linewidth,
3822         color=color,
3823         cmap=cmap,
3824         norm=norm,
3825         arrowsize=arrowsize,
3826         arrowstyle=arrowstyle,
3827         minlength=minlength,
3828         transform=transform,
3829         zorder=zorder,
3830         start_points=start_points,
3831         maxlength=maxlength,
3832         integration_direction=integration_direction,
3833         broken_streamlines=broken_streamlines,
3834         **({"data": data} if data is not None else {}),
3835     )
3836     sci(__ret.lines)
3837     return __ret
3838 
3839 
3840 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3841 @_copy_docstring_and_deprecators(Axes.table)
3842 def table(
3843     cellText=None,
3844     cellColours=None,
3845     cellLoc="right",
3846     colWidths=None,
3847     rowLabels=None,
3848     rowColours=None,
3849     rowLoc="left",
3850     colLabels=None,
3851     colColours=None,
3852     colLoc="center",
3853     loc="bottom",
3854     bbox=None,
3855     edges="closed",
3856     **kwargs,
3857 ):
3858     return gca().table(
3859         cellText=cellText,
3860         cellColours=cellColours,
3861         cellLoc=cellLoc,
3862         colWidths=colWidths,
3863         rowLabels=rowLabels,
3864         rowColours=rowColours,
3865         rowLoc=rowLoc,
3866         colLabels=colLabels,
3867         colColours=colColours,
3868         colLoc=colLoc,
3869         loc=loc,
3870         bbox=bbox,
3871         edges=edges,
3872         **kwargs,
3873     )
3874 
3875 
3876 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3877 @_copy_docstring_and_deprecators(Axes.text)
3878 def text(
3879     x: float, y: float, s: str, fontdict: dict[str, Any] | None = None, **kwargs
3880 ) -> Text:
3881     return gca().text(x, y, s, fontdict=fontdict, **kwargs)
3882 
3883 
3884 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3885 @_copy_docstring_and_deprecators(Axes.tick_params)
3886 def tick_params(axis: Literal["both", "x", "y"] = "both", **kwargs) -> None:
3887     gca().tick_params(axis=axis, **kwargs)
3888 
3889 
3890 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3891 @_copy_docstring_and_deprecators(Axes.ticklabel_format)
3892 def ticklabel_format(
3893     *,
3894     axis: Literal["both", "x", "y"] = "both",
3895     style: Literal["", "sci", "scientific", "plain"] = "",
3896     scilimits: tuple[int, int] | None = None,
3897     useOffset: bool | float | None = None,
3898     useLocale: bool | None = None,
3899     useMathText: bool | None = None,
3900 ) -> None:
3901     gca().ticklabel_format(
3902         axis=axis,
3903         style=style,
3904         scilimits=scilimits,
3905         useOffset=useOffset,
3906         useLocale=useLocale,
3907         useMathText=useMathText,
3908     )
3909 
3910 
3911 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3912 @_copy_docstring_and_deprecators(Axes.tricontour)
3913 def tricontour(*args, **kwargs):
3914     __ret = gca().tricontour(*args, **kwargs)
3915     if __ret._A is not None:  # type: ignore[attr-defined]
3916         sci(__ret)
3917     return __ret
3918 
3919 
3920 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3921 @_copy_docstring_and_deprecators(Axes.tricontourf)
3922 def tricontourf(*args, **kwargs):
3923     __ret = gca().tricontourf(*args, **kwargs)
3924     if __ret._A is not None:  # type: ignore[attr-defined]
3925         sci(__ret)
3926     return __ret
3927 
3928 
3929 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3930 @_copy_docstring_and_deprecators(Axes.tripcolor)
3931 def tripcolor(
3932     *args,
3933     alpha=1.0,
3934     norm=None,
3935     cmap=None,
3936     vmin=None,
3937     vmax=None,
3938     shading="flat",
3939     facecolors=None,
3940     **kwargs,
3941 ):
3942     __ret = gca().tripcolor(
3943         *args,
3944         alpha=alpha,
3945         norm=norm,
3946         cmap=cmap,
3947         vmin=vmin,
3948         vmax=vmax,
3949         shading=shading,
3950         facecolors=facecolors,
3951         **kwargs,
3952     )
3953     sci(__ret)
3954     return __ret
3955 
3956 
3957 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3958 @_copy_docstring_and_deprecators(Axes.triplot)
3959 def triplot(*args, **kwargs):
3960     return gca().triplot(*args, **kwargs)
3961 
3962 
3963 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3964 @_copy_docstring_and_deprecators(Axes.violinplot)
3965 def violinplot(
3966     dataset: ArrayLike | Sequence[ArrayLike],
3967     positions: ArrayLike | None = None,
3968     vert: bool = True,
3969     widths: float | ArrayLike = 0.5,
3970     showmeans: bool = False,
3971     showextrema: bool = True,
3972     showmedians: bool = False,
3973     quantiles: Sequence[float | Sequence[float]] | None = None,
3974     points: int = 100,
3975     bw_method: Literal["scott", "silverman"]
3976     | float
3977     | Callable[[GaussianKDE], float]
3978     | None = None,
3979     *,
3980     data=None,
3981 ) -> dict[str, Collection]:
3982     return gca().violinplot(
3983         dataset,
3984         positions=positions,
3985         vert=vert,
3986         widths=widths,
3987         showmeans=showmeans,
3988         showextrema=showextrema,
3989         showmedians=showmedians,
3990         quantiles=quantiles,
3991         points=points,
3992         bw_method=bw_method,
3993         **({"data": data} if data is not None else {}),
3994     )
3995 
3996 
3997 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3998 @_copy_docstring_and_deprecators(Axes.vlines)
3999 def vlines(
4000     x: float | ArrayLike,
4001     ymin: float | ArrayLike,
4002     ymax: float | ArrayLike,
4003     colors: ColorType | Sequence[ColorType] | None = None,
4004     linestyles: LineStyleType = "solid",
4005     label: str = "",
4006     *,
4007     data=None,
4008     **kwargs,
4009 ) -> LineCollection:
4010     return gca().vlines(
4011         x,
4012         ymin,
4013         ymax,
4014         colors=colors,
4015         linestyles=linestyles,
4016         label=label,
4017         **({"data": data} if data is not None else {}),
4018         **kwargs,
4019     )
4020 
4021 
4022 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
4023 @_copy_docstring_and_deprecators(Axes.xcorr)
4024 def xcorr(
4025     x: ArrayLike,
4026     y: ArrayLike,
4027     normed: bool = True,
4028     detrend: Callable[[ArrayLike], ArrayLike] = mlab.detrend_none,
4029     usevlines: bool = True,
4030     maxlags: int = 10,
4031     *,
4032     data=None,
4033     **kwargs,
4034 ) -> tuple[np.ndarray, np.ndarray, LineCollection | Line2D, Line2D | None]:
4035     return gca().xcorr(
4036         x,
4037         y,
4038         normed=normed,
4039         detrend=detrend,
4040         usevlines=usevlines,
4041         maxlags=maxlags,
4042         **({"data": data} if data is not None else {}),
4043         **kwargs,
4044     )
4045 
4046 
4047 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
4048 @_copy_docstring_and_deprecators(Axes._sci)
4049 def sci(im: ScalarMappable) -> None:
4050     gca()._sci(im)
4051 
4052 
4053 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
4054 @_copy_docstring_and_deprecators(Axes.set_title)
4055 def title(
4056     label: str,
4057     fontdict: dict[str, Any] | None = None,
4058     loc: Literal["left", "center", "right"] | None = None,
4059     pad: float | None = None,
4060     *,
4061     y: float | None = None,
4062     **kwargs,
4063 ) -> Text:
4064     return gca().set_title(label, fontdict=fontdict, loc=loc, pad=pad, y=y, **kwargs)
4065 
4066 
4067 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
4068 @_copy_docstring_and_deprecators(Axes.set_xlabel)
4069 def xlabel(
4070     xlabel: str,
4071     fontdict: dict[str, Any] | None = None,
4072     labelpad: float | None = None,
4073     *,
4074     loc: Literal["left", "center", "right"] | None = None,
4075     **kwargs,
4076 ) -> Text:
4077     return gca().set_xlabel(
4078         xlabel, fontdict=fontdict, labelpad=labelpad, loc=loc, **kwargs
4079     )
4080 
4081 
4082 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
4083 @_copy_docstring_and_deprecators(Axes.set_ylabel)
4084 def ylabel(
4085     ylabel: str,
4086     fontdict: dict[str, Any] | None = None,
4087     labelpad: float | None = None,
4088     *,
4089     loc: Literal["bottom", "center", "top"] | None = None,
4090     **kwargs,
4091 ) -> Text:
4092     return gca().set_ylabel(
4093         ylabel, fontdict=fontdict, labelpad=labelpad, loc=loc, **kwargs
4094     )
4095 
4096 
4097 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
4098 @_copy_docstring_and_deprecators(Axes.set_xscale)
4099 def xscale(value: str | ScaleBase, **kwargs) -> None:
4100     gca().set_xscale(value, **kwargs)
4101 
4102 
4103 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
4104 @_copy_docstring_and_deprecators(Axes.set_yscale)
4105 def yscale(value: str | ScaleBase, **kwargs) -> None:
4106     gca().set_yscale(value, **kwargs)
4107 
4108 
4109 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
4110 def autumn() -> None:
4111     """
4112     Set the colormap to 'autumn'.
4113 
4114     This changes the default colormap as well as the colormap of the current
4115     image if there is one. See ``help(colormaps)`` for more information.
4116     """
4117     set_cmap("autumn")
4118 
4119 
4120 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
4121 def bone() -> None:
4122     """
4123     Set the colormap to 'bone'.
4124 
4125     This changes the default colormap as well as the colormap of the current
4126     image if there is one. See ``help(colormaps)`` for more information.
4127     """
4128     set_cmap("bone")
4129 
4130 
4131 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
4132 def cool() -> None:
4133     """
4134     Set the colormap to 'cool'.
4135 
4136     This changes the default colormap as well as the colormap of the current
4137     image if there is one. See ``help(colormaps)`` for more information.
4138     """
4139     set_cmap("cool")
4140 
4141 
4142 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
4143 def copper() -> None:
4144     """
4145     Set the colormap to 'copper'.
4146 
4147     This changes the default colormap as well as the colormap of the current
4148     image if there is one. See ``help(colormaps)`` for more information.
4149     """
4150     set_cmap("copper")
4151 
4152 
4153 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
4154 def flag() -> None:
4155     """
4156     Set the colormap to 'flag'.
4157 
4158     This changes the default colormap as well as the colormap of the current
4159     image if there is one. See ``help(colormaps)`` for more information.
4160     """
4161     set_cmap("flag")
4162 
4163 
4164 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
4165 def gray() -> None:
4166     """
4167     Set the colormap to 'gray'.
4168 
4169     This changes the default colormap as well as the colormap of the current
4170     image if there is one. See ``help(colormaps)`` for more information.
4171     """
4172     set_cmap("gray")
4173 
4174 
4175 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
4176 def hot() -> None:
4177     """
4178     Set the colormap to 'hot'.
4179 
4180     This changes the default colormap as well as the colormap of the current
4181     image if there is one. See ``help(colormaps)`` for more information.
4182     """
4183     set_cmap("hot")
4184 
4185 
4186 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
4187 def hsv() -> None:
4188     """
4189     Set the colormap to 'hsv'.
4190 
4191     This changes the default colormap as well as the colormap of the current
4192     image if there is one. See ``help(colormaps)`` for more information.
4193     """
4194     set_cmap("hsv")
4195 
4196 
4197 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
4198 def jet() -> None:
4199     """
4200     Set the colormap to 'jet'.
4201 
4202     This changes the default colormap as well as the colormap of the current
4203     image if there is one. See ``help(colormaps)`` for more information.
4204     """
4205     set_cmap("jet")
4206 
4207 
4208 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
4209 def pink() -> None:
4210     """
4211     Set the colormap to 'pink'.
4212 
4213     This changes the default colormap as well as the colormap of the current
4214     image if there is one. See ``help(colormaps)`` for more information.
4215     """
4216     set_cmap("pink")
4217 
4218 
4219 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
4220 def prism() -> None:
4221     """
4222     Set the colormap to 'prism'.
4223 
4224     This changes the default colormap as well as the colormap of the current
4225     image if there is one. See ``help(colormaps)`` for more information.
4226     """
4227     set_cmap("prism")
4228 
4229 
4230 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
4231 def spring() -> None:
4232     """
4233     Set the colormap to 'spring'.
4234 
4235     This changes the default colormap as well as the colormap of the current
4236     image if there is one. See ``help(colormaps)`` for more information.
4237     """
4238     set_cmap("spring")
4239 
4240 
4241 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
4242 def summer() -> None:
4243     """
4244     Set the colormap to 'summer'.
4245 
4246     This changes the default colormap as well as the colormap of the current
4247     image if there is one. See ``help(colormaps)`` for more information.
4248     """
4249     set_cmap("summer")
4250 
4251 
4252 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
4253 def winter() -> None:
4254     """
4255     Set the colormap to 'winter'.
4256 
4257     This changes the default colormap as well as the colormap of the current
4258     image if there is one. See ``help(colormaps)`` for more information.
4259     """
4260     set_cmap("winter")
4261 
4262 
4263 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
4264 def magma() -> None:
4265     """
4266     Set the colormap to 'magma'.
4267 
4268     This changes the default colormap as well as the colormap of the current
4269     image if there is one. See ``help(colormaps)`` for more information.
4270     """
4271     set_cmap("magma")
4272 
4273 
4274 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
4275 def inferno() -> None:
4276     """
4277     Set the colormap to 'inferno'.
4278 
4279     This changes the default colormap as well as the colormap of the current
4280     image if there is one. See ``help(colormaps)`` for more information.
4281     """
4282     set_cmap("inferno")
4283 
4284 
4285 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
4286 def plasma() -> None:
4287     """
4288     Set the colormap to 'plasma'.
4289 
4290     This changes the default colormap as well as the colormap of the current
4291     image if there is one. See ``help(colormaps)`` for more information.
4292     """
4293     set_cmap("plasma")
4294 
4295 
4296 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
4297 def viridis() -> None:
4298     """
4299     Set the colormap to 'viridis'.
4300 
4301     This changes the default colormap as well as the colormap of the current
4302     image if there is one. See ``help(colormaps)`` for more information.
4303     """
4304     set_cmap("viridis")
4305 
4306 
4307 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
4308 def nipy_spectral() -> None:
4309     """
4310     Set the colormap to 'nipy_spectral'.
4311 
4312     This changes the default colormap as well as the colormap of the current
4313     image if there is one. See ``help(colormaps)`` for more information.
4314     """
4315     set_cmap("nipy_spectral")

</code><intended_behavior>These functions should ensure switching interactive mode on or off does not inadvertently close GUI windows that were intended to remain open across backend transitions, by adding context awareness.</intended_behavior>]
2025-10-18 14:39:13.904 | INFO     | Search completed. Bug locations: [<file>lib/matplotlib/backends/backend_qt.py</file>
<class>None</class>
<method>show</method>
<code>
596     def show(self):
597         self.window.show()
598         if mpl.rcParams['figure.raise_window']:
599             self.window.activateWindow()
600             self.window.raise_()

</code><intended_behavior>This code should modify or supplement the existing `show` method to check for a transition between `qt5` and `inline` and implement a mechanism to preserve any open GUI windows.</intended_behavior>, <file>lib/matplotlib/backends/backend_qt.py</file>
<class>FigureManagerQT</class>
<method>show</method>
<code>
596     def show(self):
597         self.window.show()
598         if mpl.rcParams['figure.raise_window']:
599             self.window.activateWindow()
600             self.window.raise_()

</code><intended_behavior>This code should modify or supplement the existing `show` method to check for a transition between `qt5` and `inline` and implement a mechanism to preserve any open GUI windows.</intended_behavior>, <file>lib/matplotlib/pyplot.py</file>
<class>None</class>
<method>None</method>
<code>
1 # Note: The first part of this file can be modified in place, but the latter
2 # part is autogenerated by the boilerplate.py script.
3 
4 """
5 `matplotlib.pyplot` is a state-based interface to matplotlib. It provides
6 an implicit,  MATLAB-like, way of plotting.  It also opens figures on your
7 screen, and acts as the figure GUI manager.
8 
9 pyplot is mainly intended for interactive plots and simple cases of
10 programmatic plot generation::
11 
12     import numpy as np
13     import matplotlib.pyplot as plt
14 
15     x = np.arange(0, 5, 0.1)
16     y = np.sin(x)
17     plt.plot(x, y)
18 
19 The explicit object-oriented API is recommended for complex plots, though
20 pyplot is still usually used to create the figure and often the axes in the
21 figure. See `.pyplot.figure`, `.pyplot.subplots`, and
22 `.pyplot.subplot_mosaic` to create figures, and
23 :doc:`Axes API </api/axes_api>` for the plotting methods on an Axes::
24 
25     import numpy as np
26     import matplotlib.pyplot as plt
27 
28     x = np.arange(0, 5, 0.1)
29     y = np.sin(x)
30     fig, ax = plt.subplots()
31     ax.plot(x, y)
32 
33 
34 See :ref:`api_interfaces` for an explanation of the tradeoffs between the
35 implicit and explicit interfaces.
36 """
37 
38 # fmt: off
39 
40 from __future__ import annotations
41 
42 from contextlib import AbstractContextManager, ExitStack
43 from enum import Enum
44 import functools
45 import importlib
46 import inspect
47 import logging
48 import re
49 import sys
50 import threading
51 import time
52 from typing import cast, overload
53 
54 from cycler import cycler
55 import matplotlib
56 import matplotlib.colorbar
57 import matplotlib.image
58 from matplotlib import _api
59 from matplotlib import (  # Re-exported for typing.
60     cm as cm, get_backend as get_backend, rcParams as rcParams, style as style)
61 from matplotlib import _pylab_helpers, interactive
62 from matplotlib import cbook
63 from matplotlib import _docstring
64 from matplotlib.backend_bases import (
65     FigureCanvasBase, FigureManagerBase, MouseButton)
66 from matplotlib.figure import Figure, FigureBase, figaspect
67 from matplotlib.gridspec import GridSpec, SubplotSpec
68 from matplotlib import rcsetup, rcParamsDefault, rcParamsOrig
69 from matplotlib.artist import Artist
70 from matplotlib.axes import Axes, Subplot  # type: ignore
71 from matplotlib.projections import PolarAxes  # type: ignore
72 from matplotlib import mlab  # for detrend_none, window_hanning
73 from matplotlib.scale import get_scale_names
74 
75 from matplotlib.cm import _colormaps
76 from matplotlib.cm import register_cmap  # type: ignore
77 from matplotlib.colors import _color_sequences
78 
79 import numpy as np
80 
81 from typing import TYPE_CHECKING, cast
82 
83 if TYPE_CHECKING:
84     from collections.abc import Callable, Hashable, Iterable, Sequence
85     import datetime
86     import pathlib
87     import os
88     from typing import Any, BinaryIO, Literal, TypeVar
89     from typing_extensions import ParamSpec
90 
91     import PIL
92     from numpy.typing import ArrayLike
93 
94     from matplotlib.axis import Tick
95     from matplotlib.axes._base import _AxesBase
96     from matplotlib.backend_bases import RendererBase, Event
97     from matplotlib.cm import ScalarMappable
98     from matplotlib.contour import ContourSet, QuadContourSet
99     from matplotlib.collections import (
100         Collection,
101         LineCollection,
102         BrokenBarHCollection,
103         PolyCollection,
104         PathCollection,
105         EventCollection,
106         QuadMesh,
107     )
108     from matplotlib.colorbar import Colorbar
109     from matplotlib.colors import Colormap
110     from matplotlib.container import (
111         BarContainer,
112         ErrorbarContainer,
113         StemContainer,
114     )
115     from matplotlib.figure import SubFigure
116     from matplotlib.legend import Legend
117     from matplotlib.mlab import GaussianKDE
118     from matplotlib.image import AxesImage, FigureImage
119     from matplotlib.patches import FancyArrow, StepPatch, Wedge
120     from matplotlib.quiver import Barbs, Quiver, QuiverKey
121     from matplotlib.scale import ScaleBase
122     from matplotlib.transforms import Transform, Bbox
123     from matplotlib.typing import ColorType, LineStyleType, MarkerType, HashableList
124     from matplotlib.widgets import SubplotTool
125 
126     _P = ParamSpec('_P')
127     _R = TypeVar('_R')
128 
129 
130 # We may not need the following imports here:
131 from matplotlib.colors import Normalize
132 from matplotlib.lines import Line2D
133 from matplotlib.text import Text, Annotation
134 from matplotlib.patches import Polygon, Rectangle, Circle, Arrow
135 from matplotlib.widgets import Button, Slider, Widget
136 
137 from .ticker import (
138     TickHelper, Formatter, FixedFormatter, NullFormatter, FuncFormatter,
139     FormatStrFormatter, ScalarFormatter, LogFormatter, LogFormatterExponent,
140     LogFormatterMathtext, Locator, IndexLocator, FixedLocator, NullLocator,
141     LinearLocator, LogLocator, AutoLocator, MultipleLocator, MaxNLocator)
142 
143 _log = logging.getLogger(__name__)
144 
145 
146 # Explicit rename instead of import-as for typing's sake.
147 colormaps = _colormaps
148 color_sequences = _color_sequences
149 
150 
151 @overload
152 def _copy_docstring_and_deprecators(
153     method: Any,
154     func: Literal[None] = None
155 ) -> Callable[[Callable[_P, _R]], Callable[_P, _R]]: ...
156 
157 
158 @overload
159 def _copy_docstring_and_deprecators(
160     method: Any, func: Callable[_P, _R]) -> Callable[_P, _R]: ...
161 
162 
163 def _copy_docstring_and_deprecators(
164     method: Any,
165     func: Callable[_P, _R] | None = None
166 ) -> Callable[[Callable[_P, _R]], Callable[_P, _R]] | Callable[_P, _R]:
167     if func is None:
168         return cast('Callable[[Callable[_P, _R]], Callable[_P, _R]]',
169                     functools.partial(_copy_docstring_and_deprecators, method))
170     decorators: list[Callable[[Callable[_P, _R]], Callable[_P, _R]]] = [
171         _docstring.copy(method)
172     ]
173     # Check whether the definition of *method* includes @_api.rename_parameter
174     # or @_api.make_keyword_only decorators; if so, propagate them to the
175     # pyplot wrapper as well.
176     while hasattr(method, "__wrapped__"):
177         potential_decorator = _api.deprecation.DECORATORS.get(method)
178         if potential_decorator:
179             decorators.append(potential_decorator)
180         method = method.__wrapped__
181     for decorator in decorators[::-1]:
182         func = decorator(func)
183     return func
184 
185 
186 ## Global ##
187 
188 
189 # The state controlled by {,un}install_repl_displayhook().
190 _ReplDisplayHook = Enum("_ReplDisplayHook", ["NONE", "PLAIN", "IPYTHON"])
191 _REPL_DISPLAYHOOK = _ReplDisplayHook.NONE
192 
193 
194 def _draw_all_if_interactive() -> None:
195     if matplotlib.is_interactive():
196         draw_all()
197 
198 
199 def install_repl_displayhook() -> None:
200     """
201     Connect to the display hook of the current shell.
202 
203     The display hook gets called when the read-evaluate-print-loop (REPL) of
204     the shell has finished the execution of a command. We use this callback
205     to be able to automatically update a figure in interactive mode.
206 
207     This works both with IPython and with vanilla python shells.
208     """
209     global _REPL_DISPLAYHOOK
210 
211     if _REPL_DISPLAYHOOK is _ReplDisplayHook.IPYTHON:
212         return
213 
214     # See if we have IPython hooks around, if so use them.
215     # Use ``sys.modules.get(name)`` rather than ``name in sys.modules`` as
216     # entries can also have been explicitly set to None.
217     mod_ipython = sys.modules.get("IPython")
218     if not mod_ipython:
219         _REPL_DISPLAYHOOK = _ReplDisplayHook.PLAIN
220         return
221     ip = mod_ipython.get_ipython()
222     if not ip:
223         _REPL_DISPLAYHOOK = _ReplDisplayHook.PLAIN
224         return
225 
226     ip.events.register("post_execute", _draw_all_if_interactive)
227     _REPL_DISPLAYHOOK = _ReplDisplayHook.IPYTHON
228 
229     from IPython.core.pylabtools import backend2gui  # type: ignore
230     # trigger IPython's eventloop integration, if available
231     ipython_gui_name = backend2gui.get(get_backend())
232     if ipython_gui_name:
233         ip.enable_gui(ipython_gui_name)
234 
235 
236 def uninstall_repl_displayhook() -> None:
237     """Disconnect from the display hook of the current shell."""
238     global _REPL_DISPLAYHOOK
239     if _REPL_DISPLAYHOOK is _ReplDisplayHook.IPYTHON:
240         from IPython import get_ipython  # type: ignore
241         ip = get_ipython()
242         ip.events.unregister("post_execute", _draw_all_if_interactive)
243     _REPL_DISPLAYHOOK = _ReplDisplayHook.NONE
244 
245 
246 draw_all = _pylab_helpers.Gcf.draw_all
247 
248 
249 # Ensure this appears in the pyplot docs.
250 @_copy_docstring_and_deprecators(matplotlib.set_loglevel)
251 def set_loglevel(*args, **kwargs) -> None:
252     return matplotlib.set_loglevel(*args, **kwargs)
253 
254 
255 @_copy_docstring_and_deprecators(Artist.findobj)
256 def findobj(
257     o: Artist | None = None,
258     match: Callable[[Artist], bool] | type[Artist] | None = None,
259     include_self: bool = True
260 ) -> list[Artist]:
261     if o is None:
262         o = gcf()
263     return o.findobj(match, include_self=include_self)
264 
265 
266 _backend_mod: type[matplotlib.backend_bases._Backend] | None = None
267 
268 
269 def _get_backend_mod() -> type[matplotlib.backend_bases._Backend]:
270     """
271     Ensure that a backend is selected and return it.
272 
273     This is currently private, but may be made public in the future.
274     """
275     if _backend_mod is None:
276         # Use rcParams._get("backend") to avoid going through the fallback
277         # logic (which will (re)import pyplot and then call switch_backend if
278         # we need to resolve the auto sentinel)
279         switch_backend(rcParams._get("backend"))  # type: ignore[attr-defined]
280     return cast(type[matplotlib.backend_bases._Backend], _backend_mod)
281 
282 
283 def switch_backend(newbackend: str) -> None:
284     """
285     Set the pyplot backend.
286 
287     Switching to an interactive backend is possible only if no event loop for
288     another interactive backend has started.  Switching to and from
289     non-interactive backends is always possible.
290 
291     If the new backend is different than the current backend then all open
292     Figures will be closed via ``plt.close('all')``.
293 
294     Parameters
295     ----------
296     newbackend : str
297         The case-insensitive name of the backend to use.
298 
299     """
300     global _backend_mod
301     # make sure the init is pulled up so we can assign to it later
302     import matplotlib.backends
303 
304     if newbackend is rcsetup._auto_backend_sentinel:
305         current_framework = cbook._get_running_interactive_framework()
306         mapping = {'qt': 'qtagg',
307                    'gtk3': 'gtk3agg',
308                    'gtk4': 'gtk4agg',
309                    'wx': 'wxagg',
310                    'tk': 'tkagg',
311                    'macosx': 'macosx',
312                    'headless': 'agg'}
313 
314         if current_framework in mapping:
315             candidates = [mapping[current_framework]]
316         else:
317             candidates = []
318         candidates += [
319             "macosx", "qtagg", "gtk4agg", "gtk3agg", "tkagg", "wxagg"]
320 
321         # Don't try to fallback on the cairo-based backends as they each have
322         # an additional dependency (pycairo) over the agg-based backend, and
323         # are of worse quality.
324         for candidate in candidates:
325             try:
326                 switch_backend(candidate)
327             except ImportError:
328                 continue
329             else:
330                 rcParamsOrig['backend'] = candidate
331                 return
332         else:
333             # Switching to Agg should always succeed; if it doesn't, let the
334             # exception propagate out.
335             switch_backend("agg")
336             rcParamsOrig["backend"] = "agg"
337             return
338     # have to escape the switch on access logic
339     old_backend = dict.__getitem__(rcParams, 'backend')
340 
341     module = importlib.import_module(cbook._backend_module_name(newbackend))
342 
343     required_framework = module.FigureCanvas.required_interactive_framework
344     if required_framework is not None:
345         current_framework = cbook._get_running_interactive_framework()
346         if (current_framework and required_framework
347                 and current_framework != required_framework):
348             raise ImportError(
349                 "Cannot load backend {!r} which requires the {!r} interactive "
350                 "framework, as {!r} is currently running".format(
351                     newbackend, required_framework, current_framework))
352 
353     # Load the new_figure_manager() and show() functions from the backend.
354 
355     # Classically, backends can directly export these functions.  This should
356     # keep working for backcompat.
357     new_figure_manager = getattr(module, "new_figure_manager", None)
358     show = getattr(module, "show", None)
359 
360     # In that classical approach, backends are implemented as modules, but
361     # "inherit" default method implementations from backend_bases._Backend.
362     # This is achieved by creating a "class" that inherits from
363     # backend_bases._Backend and whose body is filled with the module globals.
364     class backend_mod(matplotlib.backend_bases._Backend):
365         locals().update(vars(module))
366 
367     # However, the newer approach for defining new_figure_manager and
368     # show is to derive them from canvas methods.  In that case, also
369     # update backend_mod accordingly; also, per-backend customization of
370     # draw_if_interactive is disabled.
371     if new_figure_manager is None:
372         # Only try to get the canvas class if have opted into the new scheme.
373         canvas_class = backend_mod.FigureCanvas
374 
375         def new_figure_manager_given_figure(num, figure):
376             return canvas_class.new_manager(figure, num)
377 
378         def new_figure_manager(num, *args, FigureClass=Figure, **kwargs):
379             fig = FigureClass(*args, **kwargs)
380             return new_figure_manager_given_figure(num, fig)
381 
382         def draw_if_interactive() -> None:
383             if matplotlib.is_interactive():
384                 manager = _pylab_helpers.Gcf.get_active()
385                 if manager:
386                     manager.canvas.draw_idle()
387 
388         backend_mod.new_figure_manager_given_figure = (  # type: ignore[method-assign]
389             new_figure_manager_given_figure)
390         backend_mod.new_figure_manager = (  # type: ignore[method-assign]
391             new_figure_manager)
392         backend_mod.draw_if_interactive = (  # type: ignore[method-assign]
393             draw_if_interactive)
394 
395     # If the manager explicitly overrides pyplot_show, use it even if a global
396     # show is already present, as the latter may be here for backcompat.
397     manager_class = getattr(getattr(backend_mod, "FigureCanvas", None),
398                             "manager_class", None)
399     # We can't compare directly manager_class.pyplot_show and FMB.pyplot_show because
400     # pyplot_show is a classmethod so the above constructs are bound classmethods, and
401     # thus always different (being bound to different classes).  We also have to use
402     # getattr_static instead of vars as manager_class could have no __dict__.
403     manager_pyplot_show = inspect.getattr_static(manager_class, "pyplot_show", None)
404     base_pyplot_show = inspect.getattr_static(FigureManagerBase, "pyplot_show", None)
405     if (show is None
406             or (manager_pyplot_show is not None
407                 and manager_pyplot_show != base_pyplot_show)):
408         _pyplot_show = cast('Any', manager_class).pyplot_show
409         backend_mod.show = _pyplot_show  # type: ignore[method-assign]
410 
411     _log.debug("Loaded backend %s version %s.",
412                newbackend, backend_mod.backend_version)
413 
414     rcParams['backend'] = rcParamsDefault['backend'] = newbackend
415     _backend_mod = backend_mod
416     for func_name in ["new_figure_manager", "draw_if_interactive", "show"]:
417         globals()[func_name].__signature__ = inspect.signature(
418             getattr(backend_mod, func_name))
419 
420     # Need to keep a global reference to the backend for compatibility reasons.
421     # See https://github.com/matplotlib/matplotlib/issues/6092
422     matplotlib.backends.backend = newbackend  # type: ignore[attr-defined]
423     if not cbook._str_equal(old_backend, newbackend):
424         close("all")
425 
426     # make sure the repl display hook is installed in case we become
427     # interactive
428     install_repl_displayhook()
429 
430 
431 def _warn_if_gui_out_of_main_thread() -> None:
432     warn = False
433     canvas_class = cast(type[FigureCanvasBase], _get_backend_mod().FigureCanvas)
434     if canvas_class.required_interactive_framework:
435         if hasattr(threading, 'get_native_id'):
436             # This compares native thread ids because even if Python-level
437             # Thread objects match, the underlying OS thread (which is what
438             # really matters) may be different on Python implementations with
439             # green threads.
440             if threading.get_native_id() != threading.main_thread().native_id:
441                 warn = True
442         else:
443             # Fall back to Python-level Thread if native IDs are unavailable,
444             # mainly for PyPy.
445             if threading.current_thread() is not threading.main_thread():
446                 warn = True
447     if warn:
448         _api.warn_external(
449             "Starting a Matplotlib GUI outside of the main thread will likely "
450             "fail.")
451 
452 
453 # This function's signature is rewritten upon backend-load by switch_backend.
454 def new_figure_manager(*args, **kwargs):
455     """Create a new figure manager instance."""
456     _warn_if_gui_out_of_main_thread()
457     return _get_backend_mod().new_figure_manager(*args, **kwargs)
458 
459 
460 # This function's signature is rewritten upon backend-load by switch_backend.
461 def draw_if_interactive(*args, **kwargs):
462     """
463     Redraw the current figure if in interactive mode.
464 
465     .. warning::
466 
467         End users will typically not have to call this function because the
468         the interactive mode takes care of this.
469     """
470     return _get_backend_mod().draw_if_interactive(*args, **kwargs)
471 
472 
473 # This function's signature is rewritten upon backend-load by switch_backend.
474 def show(*args, **kwargs):
475     """
476     Display all open figures.
477 
478     Parameters
479     ----------
480     block : bool, optional
481         Whether to wait for all figures to be closed before returning.
482 
483         If `True` block and run the GUI main loop until all figure windows
484         are closed.
485 
486         If `False` ensure that all figure windows are displayed and return
487         immediately.  In this case, you are responsible for ensuring
488         that the event loop is running to have responsive figures.
489 
490         Defaults to True in non-interactive mode and to False in interactive
491         mode (see `.pyplot.isinteractive`).
492 
493     See Also
494     --------
495     ion : Enable interactive mode, which shows / updates the figure after
496           every plotting command, so that calling ``show()`` is not necessary.
497     ioff : Disable interactive mode.
498     savefig : Save the figure to an image file instead of showing it on screen.
499 
500     Notes
501     -----
502     **Saving figures to file and showing a window at the same time**
503 
504     If you want an image file as well as a user interface window, use
505     `.pyplot.savefig` before `.pyplot.show`. At the end of (a blocking)
506     ``show()`` the figure is closed and thus unregistered from pyplot. Calling
507     `.pyplot.savefig` afterwards would save a new and thus empty figure. This
508     limitation of command order does not apply if the show is non-blocking or
509     if you keep a reference to the figure and use `.Figure.savefig`.
510 
511     **Auto-show in jupyter notebooks**
512 
513     The jupyter backends (activated via ``%matplotlib inline``,
514     ``%matplotlib notebook``, or ``%matplotlib widget``), call ``show()`` at
515     the end of every cell by default. Thus, you usually don't have to call it
516     explicitly there.
517     """
518     _warn_if_gui_out_of_main_thread()
519     return _get_backend_mod().show(*args, **kwargs)
520 
521 
522 def isinteractive() -> bool:
523     """
524     Return whether plots are updated after every plotting command.
525 
526     The interactive mode is mainly useful if you build plots from the command
527     line and want to see the effect of each command while you are building the
528     figure.
529 
530     In interactive mode:
531 
532     - newly created figures will be shown immediately;
533     - figures will automatically redraw on change;
534     - `.pyplot.show` will not block by default.
535 
536     In non-interactive mode:
537 
538     - newly created figures and changes to figures will not be reflected until
539       explicitly asked to be;
540     - `.pyplot.show` will block by default.
541 
542     See Also
543     --------
544     ion : Enable interactive mode.
545     ioff : Disable interactive mode.
546     show : Show all figures (and maybe block).
547     pause : Show all figures, and block for a time.
548     """
549     return matplotlib.is_interactive()
550 
551 
552 def ioff() -> ExitStack:
553     """
554     Disable interactive mode.
555 
556     See `.pyplot.isinteractive` for more details.
557 
558     See Also
559     --------
560     ion : Enable interactive mode.
561     isinteractive : Whether interactive mode is enabled.
562     show : Show all figures (and maybe block).
563     pause : Show all figures, and block for a time.
564 
565     Notes
566     -----
567     For a temporary change, this can be used as a context manager::
568 
569         # if interactive mode is on
570         # then figures will be shown on creation
571         plt.ion()
572         # This figure will be shown immediately
573         fig = plt.figure()
574 
575         with plt.ioff():
576             # interactive mode will be off
577             # figures will not automatically be shown
578             fig2 = plt.figure()
579             # ...
580 
581     To enable optional usage as a context manager, this function returns a
582     `~contextlib.ExitStack` object, which is not intended to be stored or
583     accessed by the user.
584     """
585     stack = ExitStack()
586     stack.callback(ion if isinteractive() else ioff)
587     matplotlib.interactive(False)
588     uninstall_repl_displayhook()
589     return stack
590 
591 
592 def ion() -> ExitStack:
593     """
594     Enable interactive mode.
595 
596     See `.pyplot.isinteractive` for more details.
597 
598     See Also
599     --------
600     ioff : Disable interactive mode.
601     isinteractive : Whether interactive mode is enabled.
602     show : Show all figures (and maybe block).
603     pause : Show all figures, and block for a time.
604 
605     Notes
606     -----
607     For a temporary change, this can be used as a context manager::
608 
609         # if interactive mode is off
610         # then figures will not be shown on creation
611         plt.ioff()
612         # This figure will not be shown immediately
613         fig = plt.figure()
614 
615         with plt.ion():
616             # interactive mode will be on
617             # figures will automatically be shown
618             fig2 = plt.figure()
619             # ...
620 
621     To enable optional usage as a context manager, this function returns a
622     `~contextlib.ExitStack` object, which is not intended to be stored or
623     accessed by the user.
624     """
625     stack = ExitStack()
626     stack.callback(ion if isinteractive() else ioff)
627     matplotlib.interactive(True)
628     install_repl_displayhook()
629     return stack
630 
631 
632 def pause(interval: float) -> None:
633     """
634     Run the GUI event loop for *interval* seconds.
635 
636     If there is an active figure, it will be updated and displayed before the
637     pause, and the GUI event loop (if any) will run during the pause.
638 
639     This can be used for crude animation.  For more complex animation use
640     :mod:`matplotlib.animation`.
641 
642     If there is no active figure, sleep for *interval* seconds instead.
643 
644     See Also
645     --------
646     matplotlib.animation : Proper animations
647     show : Show all figures and optional block until all figures are closed.
648     """
649     manager = _pylab_helpers.Gcf.get_active()
650     if manager is not None:
651         canvas = manager.canvas
652         if canvas.figure.stale:
653             canvas.draw_idle()
654         show(block=False)
655         canvas.start_event_loop(interval)
656     else:
657         time.sleep(interval)
658 
659 
660 @_copy_docstring_and_deprecators(matplotlib.rc)
661 def rc(group: str, **kwargs) -> None:
662     matplotlib.rc(group, **kwargs)
663 
664 
665 @_copy_docstring_and_deprecators(matplotlib.rc_context)
666 def rc_context(
667     rc: dict[str, Any] | None = None,
668     fname: str | pathlib.Path | os.PathLike | None = None,
669 ) -> AbstractContextManager[None]:
670     return matplotlib.rc_context(rc, fname)
671 
672 
673 @_copy_docstring_and_deprecators(matplotlib.rcdefaults)
674 def rcdefaults() -> None:
675     matplotlib.rcdefaults()
676     if matplotlib.is_interactive():
677         draw_all()
678 
679 
680 # getp/get/setp are explicitly reexported so that they show up in pyplot docs.
681 
682 
683 @_copy_docstring_and_deprecators(matplotlib.artist.getp)
684 def getp(obj, *args, **kwargs):
685     return matplotlib.artist.getp(obj, *args, **kwargs)
686 
687 
688 @_copy_docstring_and_deprecators(matplotlib.artist.get)
689 def get(obj, *args, **kwargs):
690     return matplotlib.artist.get(obj, *args, **kwargs)
691 
692 
693 @_copy_docstring_and_deprecators(matplotlib.artist.setp)
694 def setp(obj, *args, **kwargs):
695     return matplotlib.artist.setp(obj, *args, **kwargs)
696 
697 
698 def xkcd(
699     scale: float = 1, length: float = 100, randomness: float = 2
700 ) -> ExitStack:
701     """
702     Turn on `xkcd <https://xkcd.com/>`_ sketch-style drawing mode.  This will
703     only have effect on things drawn after this function is called.
704 
705     For best results, the "Humor Sans" font should be installed: it is
706     not included with Matplotlib.
707 
708     Parameters
709     ----------
710     scale : float, optional
711         The amplitude of the wiggle perpendicular to the source line.
712     length : float, optional
713         The length of the wiggle along the line.
714     randomness : float, optional
715         The scale factor by which the length is shrunken or expanded.
716 
717     Notes
718     -----
719     This function works by a number of rcParams, so it will probably
720     override others you have set before.
721 
722     If you want the effects of this function to be temporary, it can
723     be used as a context manager, for example::
724 
725         with plt.xkcd():
726             # This figure will be in XKCD-style
727             fig1 = plt.figure()
728             # ...
729 
730         # This figure will be in regular style
731         fig2 = plt.figure()
732     """
733     # This cannot be implemented in terms of contextmanager() or rc_context()
734     # because this needs to work as a non-contextmanager too.
735 
736     if rcParams['text.usetex']:
737         raise RuntimeError(
738             "xkcd mode is not compatible with text.usetex = True")
739 
740     stack = ExitStack()
741     stack.callback(dict.update, rcParams, rcParams.copy())  # type: ignore
742 
743     from matplotlib import patheffects
744     rcParams.update({
745         'font.family': ['xkcd', 'xkcd Script', 'Humor Sans', 'Comic Neue',
746                         'Comic Sans MS'],
747         'font.size': 14.0,
748         'path.sketch': (scale, length, randomness),
749         'path.effects': [
750             patheffects.withStroke(linewidth=4, foreground="w")],
751         'axes.linewidth': 1.5,
752         'lines.linewidth': 2.0,
753         'figure.facecolor': 'white',
754         'grid.linewidth': 0.0,
755         'axes.grid': False,
756         'axes.unicode_minus': False,
757         'axes.edgecolor': 'black',
758         'xtick.major.size': 8,
759         'xtick.major.width': 3,
760         'ytick.major.size': 8,
761         'ytick.major.width': 3,
762     })
763 
764     return stack
765 
766 
767 ## Figures ##
768 
769 def figure(
770     # autoincrement if None, else integer from 1-N
771     num: int | str | Figure | SubFigure | None = None,
772     # defaults to rc figure.figsize
773     figsize: tuple[float, float] | None = None,
774     # defaults to rc figure.dpi
775     dpi: float | None = None,
776     *,
777     # defaults to rc figure.facecolor
778     facecolor: ColorType | None = None,
779     # defaults to rc figure.edgecolor
780     edgecolor: ColorType | None = None,
781     frameon: bool = True,
782     FigureClass: type[Figure] = Figure,
783     clear: bool = False,
784     **kwargs
785 ) -> Figure:
786     """
787     Create a new figure, or activate an existing figure.
788 
789     Parameters
790     ----------
791     num : int or str or `.Figure` or `.SubFigure`, optional
792         A unique identifier for the figure.
793 
794         If a figure with that identifier already exists, this figure is made
795         active and returned. An integer refers to the ``Figure.number``
796         attribute, a string refers to the figure label.
797 
798         If there is no figure with the identifier or *num* is not given, a new
799         figure is created, made active and returned.  If *num* is an int, it
800         will be used for the ``Figure.number`` attribute, otherwise, an
801         auto-generated integer value is used (starting at 1 and incremented
802         for each new figure). If *num* is a string, the figure label and the
803         window title is set to this value.  If num is a ``SubFigure``, its
804         parent ``Figure`` is activated.
805 
806     figsize : (float, float), default: :rc:`figure.figsize`
807         Width, height in inches.
808 
809     dpi : float, default: :rc:`figure.dpi`
810         The resolution of the figure in dots-per-inch.
811 
812     facecolor : color, default: :rc:`figure.facecolor`
813         The background color.
814 
815     edgecolor : color, default: :rc:`figure.edgecolor`
816         The border color.
817 
818     frameon : bool, default: True
819         If False, suppress drawing the figure frame.
820 
821     FigureClass : subclass of `~matplotlib.figure.Figure`
822         If set, an instance of this subclass will be created, rather than a
823         plain `.Figure`.
824 
825     clear : bool, default: False
826         If True and the figure already exists, then it is cleared.
827 
828     layout : {'constrained', 'compressed', 'tight', 'none', `.LayoutEngine`, None}, \
829 default: None
830         The layout mechanism for positioning of plot elements to avoid
831         overlapping Axes decorations (labels, ticks, etc). Note that layout
832         managers can measurably slow down figure display.
833 
834         - 'constrained': The constrained layout solver adjusts axes sizes
835           to avoid overlapping axes decorations.  Can handle complex plot
836           layouts and colorbars, and is thus recommended.
837 
838           See :ref:`constrainedlayout_guide`
839           for examples.
840 
841         - 'compressed': uses the same algorithm as 'constrained', but
842           removes extra space between fixed-aspect-ratio Axes.  Best for
843           simple grids of axes.
844 
845         - 'tight': Use the tight layout mechanism. This is a relatively
846           simple algorithm that adjusts the subplot parameters so that
847           decorations do not overlap. See `.Figure.set_tight_layout` for
848           further details.
849 
850         - 'none': Do not use a layout engine.
851 
852         - A `.LayoutEngine` instance. Builtin layout classes are
853           `.ConstrainedLayoutEngine` and `.TightLayoutEngine`, more easily
854           accessible by 'constrained' and 'tight'.  Passing an instance
855           allows third parties to provide their own layout engine.
856 
857         If not given, fall back to using the parameters *tight_layout* and
858         *constrained_layout*, including their config defaults
859         :rc:`figure.autolayout` and :rc:`figure.constrained_layout.use`.
860 
861     **kwargs
862         Additional keyword arguments are passed to the `.Figure` constructor.
863 
864     Returns
865     -------
866     `~matplotlib.figure.Figure`
867 
868     Notes
869     -----
870     A newly created figure is passed to the `~.FigureCanvasBase.new_manager`
871     method or the `new_figure_manager` function provided by the current
872     backend, which install a canvas and a manager on the figure.
873 
874     Once this is done, :rc:`figure.hooks` are called, one at a time, on the
875     figure; these hooks allow arbitrary customization of the figure (e.g.,
876     attaching callbacks) or of associated elements (e.g., modifying the
877     toolbar).  See :doc:`/gallery/user_interfaces/mplcvd` for an example of
878     toolbar customization.
879 
880     If you are creating many figures, make sure you explicitly call
881     `.pyplot.close` on the figures you are not using, because this will
882     enable pyplot to properly clean up the memory.
883 
884     `~matplotlib.rcParams` defines the default values, which can be modified
885     in the matplotlibrc file.
886     """
887     if isinstance(num, FigureBase):
888         # type narrowed to `Figure | SubFigure` by combination of input and isinstance
889         if num.canvas.manager is None:
890             raise ValueError("The passed figure is not managed by pyplot")
891         _pylab_helpers.Gcf.set_active(num.canvas.manager)
892         return num.figure
893 
894     allnums = get_fignums()
895     next_num = max(allnums) + 1 if allnums else 1
896     fig_label = ''
897     if num is None:
898         num = next_num
899     elif isinstance(num, str):
900         fig_label = num
901         all_labels = get_figlabels()
902         if fig_label not in all_labels:
903             if fig_label == 'all':
904                 _api.warn_external("close('all') closes all existing figures.")
905             num = next_num
906         else:
907             inum = all_labels.index(fig_label)
908             num = allnums[inum]
909     else:
910         num = int(num)  # crude validation of num argument
911 
912     # Type of "num" has narrowed to int, but mypy can't quite see it
913     manager = _pylab_helpers.Gcf.get_fig_manager(num)  # type: ignore[arg-type]
914     if manager is None:
915         max_open_warning = rcParams['figure.max_open_warning']
916         if len(allnums) == max_open_warning >= 1:
917             _api.warn_external(
918                 f"More than {max_open_warning} figures have been opened. "
919                 f"Figures created through the pyplot interface "
920                 f"(`matplotlib.pyplot.figure`) are retained until explicitly "
921                 f"closed and may consume too much memory. (To control this "
922                 f"warning, see the rcParam `figure.max_open_warning`). "
923                 f"Consider using `matplotlib.pyplot.close()`.",
924                 RuntimeWarning)
925 
926         manager = new_figure_manager(
927             num, figsize=figsize, dpi=dpi,
928             facecolor=facecolor, edgecolor=edgecolor, frameon=frameon,
929             FigureClass=FigureClass, **kwargs)
930         fig = manager.canvas.figure
931         if fig_label:
932             fig.set_label(fig_label)
933 
934         for hookspecs in rcParams["figure.hooks"]:
935             module_name, dotted_name = hookspecs.split(":")
936             obj = importlib.import_module(module_name)
937             for part in dotted_name.split("."):
938                 obj = getattr(obj, part)
939             obj(fig)
940 
941         _pylab_helpers.Gcf._set_new_active_manager(manager)
942 
943         # make sure backends (inline) that we don't ship that expect this
944         # to be called in plotting commands to make the figure call show
945         # still work.  There is probably a better way to do this in the
946         # FigureManager base class.
947         draw_if_interactive()
948 
949         if _REPL_DISPLAYHOOK is _ReplDisplayHook.PLAIN:
950             fig.stale_callback = _auto_draw_if_interactive
951 
952     if clear:
953         manager.canvas.figure.clear()
954 
955     return manager.canvas.figure
956 
957 
958 def _auto_draw_if_interactive(fig, val):
959     """
960     An internal helper function for making sure that auto-redrawing
961     works as intended in the plain python repl.
962 
963     Parameters
964     ----------
965     fig : Figure
966         A figure object which is assumed to be associated with a canvas
967     """
968     if (val and matplotlib.is_interactive()
969             and not fig.canvas.is_saving()
970             and not fig.canvas._is_idle_drawing):
971         # Some artists can mark themselves as stale in the middle of drawing
972         # (e.g. axes position & tick labels being computed at draw time), but
973         # this shouldn't trigger a redraw because the current redraw will
974         # already take them into account.
975         with fig.canvas._idle_draw_cntx():
976             fig.canvas.draw_idle()
977 
978 
979 def gcf() -> Figure:
980     """
981     Get the current figure.
982 
983     If there is currently no figure on the pyplot figure stack, a new one is
984     created using `~.pyplot.figure()`.  (To test whether there is currently a
985     figure on the pyplot figure stack, check whether `~.pyplot.get_fignums()`
986     is empty.)
987     """
988     manager = _pylab_helpers.Gcf.get_active()
989     if manager is not None:
990         return manager.canvas.figure
991     else:
992         return figure()
993 
994 
995 def fignum_exists(num: int) -> bool:
996     """Return whether the figure with the given id exists."""
997     return _pylab_helpers.Gcf.has_fignum(num) or num in get_figlabels()
998 
999 
1000 def get_fignums() -> list[int]:
1001     """Return a list of existing figure numbers."""
1002     return sorted(_pylab_helpers.Gcf.figs)
1003 
1004 
1005 def get_figlabels() -> list[Any]:
1006     """Return a list of existing figure labels."""
1007     managers = _pylab_helpers.Gcf.get_all_fig_managers()
1008     managers.sort(key=lambda m: m.num)
1009     return [m.canvas.figure.get_label() for m in managers]
1010 
1011 
1012 def get_current_fig_manager() -> FigureManagerBase | None:
1013     """
1014     Return the figure manager of the current figure.
1015 
1016     The figure manager is a container for the actual backend-depended window
1017     that displays the figure on screen.
1018 
1019     If no current figure exists, a new one is created, and its figure
1020     manager is returned.
1021 
1022     Returns
1023     -------
1024     `.FigureManagerBase` or backend-dependent subclass thereof
1025     """
1026     return gcf().canvas.manager
1027 
1028 
1029 @_copy_docstring_and_deprecators(FigureCanvasBase.mpl_connect)
1030 def connect(s: str, func: Callable[[Event], Any]) -> int:
1031     return gcf().canvas.mpl_connect(s, func)
1032 
1033 
1034 @_copy_docstring_and_deprecators(FigureCanvasBase.mpl_disconnect)
1035 def disconnect(cid: int) -> None:
1036     gcf().canvas.mpl_disconnect(cid)
1037 
1038 
1039 def close(fig: None | int | str | Figure | Literal["all"] = None) -> None:
1040     """
1041     Close a figure window.
1042 
1043     Parameters
1044     ----------
1045     fig : None or int or str or `.Figure`
1046         The figure to close. There are a number of ways to specify this:
1047 
1048         - *None*: the current figure
1049         - `.Figure`: the given `.Figure` instance
1050         - ``int``: a figure number
1051         - ``str``: a figure name
1052         - 'all': all figures
1053 
1054     """
1055     if fig is None:
1056         manager = _pylab_helpers.Gcf.get_active()
1057         if manager is None:
1058             return
1059         else:
1060             _pylab_helpers.Gcf.destroy(manager)
1061     elif fig == 'all':
1062         _pylab_helpers.Gcf.destroy_all()
1063     elif isinstance(fig, int):
1064         _pylab_helpers.Gcf.destroy(fig)
1065     elif hasattr(fig, 'int'):
1066         # if we are dealing with a type UUID, we
1067         # can use its integer representation
1068         _pylab_helpers.Gcf.destroy(fig.int)
1069     elif isinstance(fig, str):
1070         all_labels = get_figlabels()
1071         if fig in all_labels:
1072             num = get_fignums()[all_labels.index(fig)]
1073             _pylab_helpers.Gcf.destroy(num)
1074     elif isinstance(fig, Figure):
1075         _pylab_helpers.Gcf.destroy_fig(fig)
1076     else:
1077         raise TypeError("close() argument must be a Figure, an int, a string, "
1078                         "or None, not %s" % type(fig))
1079 
1080 
1081 def clf() -> None:
1082     """Clear the current figure."""
1083     gcf().clear()
1084 
1085 
1086 def draw() -> None:
1087     """
1088     Redraw the current figure.
1089 
1090     This is used to update a figure that has been altered, but not
1091     automatically re-drawn.  If interactive mode is on (via `.ion()`), this
1092     should be only rarely needed, but there may be ways to modify the state of
1093     a figure without marking it as "stale".  Please report these cases as bugs.
1094 
1095     This is equivalent to calling ``fig.canvas.draw_idle()``, where ``fig`` is
1096     the current figure.
1097 
1098     See Also
1099     --------
1100     .FigureCanvasBase.draw_idle
1101     .FigureCanvasBase.draw
1102     """
1103     gcf().canvas.draw_idle()
1104 
1105 
1106 @_copy_docstring_and_deprecators(Figure.savefig)
1107 def savefig(*args, **kwargs) -> None:
1108     fig = gcf()
1109     # savefig default implementation has no return, so mypy is unhappy
1110     # presumably this is here because subclasses can return?
1111     res = fig.savefig(*args, **kwargs)  # type: ignore[func-returns-value]
1112     fig.canvas.draw_idle()  # Need this if 'transparent=True', to reset colors.
1113     return res
1114 
1115 
1116 ## Putting things in figures ##
1117 
1118 
1119 def figlegend(*args, **kwargs) -> Legend:
1120     return gcf().legend(*args, **kwargs)
1121 if Figure.legend.__doc__:
1122     figlegend.__doc__ = Figure.legend.__doc__ \
1123         .replace(" legend(", " figlegend(") \
1124         .replace("fig.legend(", "plt.figlegend(") \
1125         .replace("ax.plot(", "plt.plot(")
1126 
1127 
1128 ## Axes ##
1129 
1130 @_docstring.dedent_interpd
1131 def axes(
1132     arg: None | tuple[float, float, float, float] = None,
1133     **kwargs
1134 ) -> matplotlib.axes.Axes:
1135     """
1136     Add an Axes to the current figure and make it the current Axes.
1137 
1138     Call signatures::
1139 
1140         plt.axes()
1141         plt.axes(rect, projection=None, polar=False, **kwargs)
1142         plt.axes(ax)
1143 
1144     Parameters
1145     ----------
1146     arg : None or 4-tuple
1147         The exact behavior of this function depends on the type:
1148 
1149         - *None*: A new full window Axes is added using
1150           ``subplot(**kwargs)``.
1151         - 4-tuple of floats *rect* = ``[left, bottom, width, height]``.
1152           A new Axes is added with dimensions *rect* in normalized
1153           (0, 1) units using `~.Figure.add_axes` on the current figure.
1154 
1155     projection : {None, 'aitoff', 'hammer', 'lambert', 'mollweide', \
1156 'polar', 'rectilinear', str}, optional
1157         The projection type of the `~.axes.Axes`. *str* is the name of
1158         a custom projection, see `~matplotlib.projections`. The default
1159         None results in a 'rectilinear' projection.
1160 
1161     polar : bool, default: False
1162         If True, equivalent to projection='polar'.
1163 
1164     sharex, sharey : `~matplotlib.axes.Axes`, optional
1165         Share the x or y `~matplotlib.axis` with sharex and/or sharey.
1166         The axis will have the same limits, ticks, and scale as the axis
1167         of the shared Axes.
1168 
1169     label : str
1170         A label for the returned Axes.
1171 
1172     Returns
1173     -------
1174     `~.axes.Axes`, or a subclass of `~.axes.Axes`
1175         The returned axes class depends on the projection used. It is
1176         `~.axes.Axes` if rectilinear projection is used and
1177         `.projections.polar.PolarAxes` if polar projection is used.
1178 
1179     Other Parameters
1180     ----------------
1181     **kwargs
1182         This method also takes the keyword arguments for
1183         the returned Axes class. The keyword arguments for the
1184         rectilinear Axes class `~.axes.Axes` can be found in
1185         the following table but there might also be other keyword
1186         arguments if another projection is used, see the actual Axes
1187         class.
1188 
1189         %(Axes:kwdoc)s
1190 
1191     See Also
1192     --------
1193     .Figure.add_axes
1194     .pyplot.subplot
1195     .Figure.add_subplot
1196     .Figure.subplots
1197     .pyplot.subplots
1198 
1199     Examples
1200     --------
1201     ::
1202 
1203         # Creating a new full window Axes
1204         plt.axes()
1205 
1206         # Creating a new Axes with specified dimensions and a grey background
1207         plt.axes((left, bottom, width, height), facecolor='grey')
1208     """
1209     fig = gcf()
1210     pos = kwargs.pop('position', None)
1211     if arg is None:
1212         if pos is None:
1213             return fig.add_subplot(**kwargs)
1214         else:
1215             return fig.add_axes(pos, **kwargs)
1216     else:
1217         return fig.add_axes(arg, **kwargs)
1218 
1219 
1220 def delaxes(ax: matplotlib.axes.Axes | None = None) -> None:
1221     """
1222     Remove an `~.axes.Axes` (defaulting to the current axes) from its figure.
1223     """
1224     if ax is None:
1225         ax = gca()
1226     ax.remove()
1227 
1228 
1229 def sca(ax: Axes) -> None:
1230     """
1231     Set the current Axes to *ax* and the current Figure to the parent of *ax*.
1232     """
1233     # Mypy sees ax.figure as potentially None,
1234     # but if you are calling this, it won't be None
1235     # Additionally the slight difference between `Figure` and `FigureBase` mypy catches
1236     figure(ax.figure)  # type: ignore[arg-type]
1237     ax.figure.sca(ax)  # type: ignore[union-attr]
1238 
1239 
1240 def cla() -> None:
1241     """Clear the current axes."""
1242     # Not generated via boilerplate.py to allow a different docstring.
1243     return gca().cla()
1244 
1245 
1246 ## More ways of creating axes ##
1247 
1248 @_docstring.dedent_interpd
1249 def subplot(*args, **kwargs) -> Axes:
1250     """
1251     Add an Axes to the current figure or retrieve an existing Axes.
1252 
1253     This is a wrapper of `.Figure.add_subplot` which provides additional
1254     behavior when working with the implicit API (see the notes section).
1255 
1256     Call signatures::
1257 
1258        subplot(nrows, ncols, index, **kwargs)
1259        subplot(pos, **kwargs)
1260        subplot(**kwargs)
1261        subplot(ax)
1262 
1263     Parameters
1264     ----------
1265     *args : int, (int, int, *index*), or `.SubplotSpec`, default: (1, 1, 1)
1266         The position of the subplot described by one of
1267 
1268         - Three integers (*nrows*, *ncols*, *index*). The subplot will take the
1269           *index* position on a grid with *nrows* rows and *ncols* columns.
1270           *index* starts at 1 in the upper left corner and increases to the
1271           right. *index* can also be a two-tuple specifying the (*first*,
1272           *last*) indices (1-based, and including *last*) of the subplot, e.g.,
1273           ``fig.add_subplot(3, 1, (1, 2))`` makes a subplot that spans the
1274           upper 2/3 of the figure.
1275         - A 3-digit integer. The digits are interpreted as if given separately
1276           as three single-digit integers, i.e. ``fig.add_subplot(235)`` is the
1277           same as ``fig.add_subplot(2, 3, 5)``. Note that this can only be used
1278           if there are no more than 9 subplots.
1279         - A `.SubplotSpec`.
1280 
1281     projection : {None, 'aitoff', 'hammer', 'lambert', 'mollweide', \
1282 'polar', 'rectilinear', str}, optional
1283         The projection type of the subplot (`~.axes.Axes`). *str* is the name
1284         of a custom projection, see `~matplotlib.projections`. The default
1285         None results in a 'rectilinear' projection.
1286 
1287     polar : bool, default: False
1288         If True, equivalent to projection='polar'.
1289 
1290     sharex, sharey : `~matplotlib.axes.Axes`, optional
1291         Share the x or y `~matplotlib.axis` with sharex and/or sharey. The
1292         axis will have the same limits, ticks, and scale as the axis of the
1293         shared axes.
1294 
1295     label : str
1296         A label for the returned axes.
1297 
1298     Returns
1299     -------
1300     `~.axes.Axes`
1301 
1302         The Axes of the subplot. The returned Axes can actually be an instance
1303         of a subclass, such as `.projections.polar.PolarAxes` for polar
1304         projections.
1305 
1306     Other Parameters
1307     ----------------
1308     **kwargs
1309         This method also takes the keyword arguments for the returned axes
1310         base class; except for the *figure* argument. The keyword arguments
1311         for the rectilinear base class `~.axes.Axes` can be found in
1312         the following table but there might also be other keyword
1313         arguments if another projection is used.
1314 
1315         %(Axes:kwdoc)s
1316 
1317     Notes
1318     -----
1319     Creating a new Axes will delete any preexisting Axes that
1320     overlaps with it beyond sharing a boundary::
1321 
1322         import matplotlib.pyplot as plt
1323         # plot a line, implicitly creating a subplot(111)
1324         plt.plot([1, 2, 3])
1325         # now create a subplot which represents the top plot of a grid
1326         # with 2 rows and 1 column. Since this subplot will overlap the
1327         # first, the plot (and its axes) previously created, will be removed
1328         plt.subplot(211)
1329 
1330     If you do not want this behavior, use the `.Figure.add_subplot` method
1331     or the `.pyplot.axes` function instead.
1332 
1333     If no *kwargs* are passed and there exists an Axes in the location
1334     specified by *args* then that Axes will be returned rather than a new
1335     Axes being created.
1336 
1337     If *kwargs* are passed and there exists an Axes in the location
1338     specified by *args*, the projection type is the same, and the
1339     *kwargs* match with the existing Axes, then the existing Axes is
1340     returned.  Otherwise a new Axes is created with the specified
1341     parameters.  We save a reference to the *kwargs* which we use
1342     for this comparison.  If any of the values in *kwargs* are
1343     mutable we will not detect the case where they are mutated.
1344     In these cases we suggest using `.Figure.add_subplot` and the
1345     explicit Axes API rather than the implicit pyplot API.
1346 
1347     See Also
1348     --------
1349     .Figure.add_subplot
1350     .pyplot.subplots
1351     .pyplot.axes
1352     .Figure.subplots
1353 
1354     Examples
1355     --------
1356     ::
1357 
1358         plt.subplot(221)
1359 
1360         # equivalent but more general
1361         ax1 = plt.subplot(2, 2, 1)
1362 
1363         # add a subplot with no frame
1364         ax2 = plt.subplot(222, frameon=False)
1365 
1366         # add a polar subplot
1367         plt.subplot(223, projection='polar')
1368 
1369         # add a red subplot that shares the x-axis with ax1
1370         plt.subplot(224, sharex=ax1, facecolor='red')
1371 
1372         # delete ax2 from the figure
1373         plt.delaxes(ax2)
1374 
1375         # add ax2 to the figure again
1376         plt.subplot(ax2)
1377 
1378         # make the first axes "current" again
1379         plt.subplot(221)
1380 
1381     """
1382     # Here we will only normalize `polar=True` vs `projection='polar'` and let
1383     # downstream code deal with the rest.
1384     unset = object()
1385     projection = kwargs.get('projection', unset)
1386     polar = kwargs.pop('polar', unset)
1387     if polar is not unset and polar:
1388         # if we got mixed messages from the user, raise
1389         if projection is not unset and projection != 'polar':
1390             raise ValueError(
1391                 f"polar={polar}, yet projection={projection!r}. "
1392                 "Only one of these arguments should be supplied."
1393             )
1394         kwargs['projection'] = projection = 'polar'
1395 
1396     # if subplot called without arguments, create subplot(1, 1, 1)
1397     if len(args) == 0:
1398         args = (1, 1, 1)
1399 
1400     # This check was added because it is very easy to type subplot(1, 2, False)
1401     # when subplots(1, 2, False) was intended (sharex=False, that is). In most
1402     # cases, no error will ever occur, but mysterious behavior can result
1403     # because what was intended to be the sharex argument is instead treated as
1404     # a subplot index for subplot()
1405     if len(args) >= 3 and isinstance(args[2], bool):
1406         _api.warn_external("The subplot index argument to subplot() appears "
1407                            "to be a boolean. Did you intend to use "
1408                            "subplots()?")
1409     # Check for nrows and ncols, which are not valid subplot args:
1410     if 'nrows' in kwargs or 'ncols' in kwargs:
1411         raise TypeError("subplot() got an unexpected keyword argument 'ncols' "
1412                         "and/or 'nrows'.  Did you intend to call subplots()?")
1413 
1414     fig = gcf()
1415 
1416     # First, search for an existing subplot with a matching spec.
1417     key = SubplotSpec._from_subplot_args(fig, args)
1418 
1419     for ax in fig.axes:
1420         # If we found an Axes at the position, we can re-use it if the user passed no
1421         # kwargs or if the axes class and kwargs are identical.
1422         if (ax.get_subplotspec() == key
1423             and (kwargs == {}
1424                  or (ax._projection_init
1425                      == fig._process_projection_requirements(**kwargs)))):
1426             break
1427     else:
1428         # we have exhausted the known Axes and none match, make a new one!
1429         ax = fig.add_subplot(*args, **kwargs)
1430 
1431     fig.sca(ax)
1432 
1433     return ax
1434 
1435 
1436 def subplots(
1437     nrows: int = 1, ncols: int = 1, *,
1438     sharex: bool | Literal["none", "all", "row", "col"] = False,
1439     sharey: bool | Literal["none", "all", "row", "col"] = False,
1440     squeeze: bool = True,
1441     width_ratios: Sequence[float] | None = None,
1442     height_ratios: Sequence[float] | None = None,
1443     subplot_kw: dict[str, Any] | None = None,
1444     gridspec_kw: dict[str, Any] | None = None,
1445     **fig_kw
1446 ) -> tuple[Figure, Any]:
1447     """
1448     Create a figure and a set of subplots.
1449 
1450     This utility wrapper makes it convenient to create common layouts of
1451     subplots, including the enclosing figure object, in a single call.
1452 
1453     Parameters
1454     ----------
1455     nrows, ncols : int, default: 1
1456         Number of rows/columns of the subplot grid.
1457 
1458     sharex, sharey : bool or {'none', 'all', 'row', 'col'}, default: False
1459         Controls sharing of properties among x (*sharex*) or y (*sharey*)
1460         axes:
1461 
1462         - True or 'all': x- or y-axis will be shared among all subplots.
1463         - False or 'none': each subplot x- or y-axis will be independent.
1464         - 'row': each subplot row will share an x- or y-axis.
1465         - 'col': each subplot column will share an x- or y-axis.
1466 
1467         When subplots have a shared x-axis along a column, only the x tick
1468         labels of the bottom subplot are created. Similarly, when subplots
1469         have a shared y-axis along a row, only the y tick labels of the first
1470         column subplot are created. To later turn other subplots' ticklabels
1471         on, use `~matplotlib.axes.Axes.tick_params`.
1472 
1473         When subplots have a shared axis that has units, calling
1474         `~matplotlib.axis.Axis.set_units` will update each axis with the
1475         new units.
1476 
1477     squeeze : bool, default: True
1478         - If True, extra dimensions are squeezed out from the returned
1479           array of `~matplotlib.axes.Axes`:
1480 
1481           - if only one subplot is constructed (nrows=ncols=1), the
1482             resulting single Axes object is returned as a scalar.
1483           - for Nx1 or 1xM subplots, the returned object is a 1D numpy
1484             object array of Axes objects.
1485           - for NxM, subplots with N>1 and M>1 are returned as a 2D array.
1486 
1487         - If False, no squeezing at all is done: the returned Axes object is
1488           always a 2D array containing Axes instances, even if it ends up
1489           being 1x1.
1490 
1491     width_ratios : array-like of length *ncols*, optional
1492         Defines the relative widths of the columns. Each column gets a
1493         relative width of ``width_ratios[i] / sum(width_ratios)``.
1494         If not given, all columns will have the same width.  Equivalent
1495         to ``gridspec_kw={'width_ratios': [...]}``.
1496 
1497     height_ratios : array-like of length *nrows*, optional
1498         Defines the relative heights of the rows. Each row gets a
1499         relative height of ``height_ratios[i] / sum(height_ratios)``.
1500         If not given, all rows will have the same height. Convenience
1501         for ``gridspec_kw={'height_ratios': [...]}``.
1502 
1503     subplot_kw : dict, optional
1504         Dict with keywords passed to the
1505         `~matplotlib.figure.Figure.add_subplot` call used to create each
1506         subplot.
1507 
1508     gridspec_kw : dict, optional
1509         Dict with keywords passed to the `~matplotlib.gridspec.GridSpec`
1510         constructor used to create the grid the subplots are placed on.
1511 
1512     **fig_kw
1513         All additional keyword arguments are passed to the
1514         `.pyplot.figure` call.
1515 
1516     Returns
1517     -------
1518     fig : `.Figure`
1519 
1520     ax : `~matplotlib.axes.Axes` or array of Axes
1521         *ax* can be either a single `~.axes.Axes` object, or an array of Axes
1522         objects if more than one subplot was created.  The dimensions of the
1523         resulting array can be controlled with the squeeze keyword, see above.
1524 
1525         Typical idioms for handling the return value are::
1526 
1527             # using the variable ax for single a Axes
1528             fig, ax = plt.subplots()
1529 
1530             # using the variable axs for multiple Axes
1531             fig, axs = plt.subplots(2, 2)
1532 
1533             # using tuple unpacking for multiple Axes
1534             fig, (ax1, ax2) = plt.subplots(1, 2)
1535             fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2)
1536 
1537         The names ``ax`` and pluralized ``axs`` are preferred over ``axes``
1538         because for the latter it's not clear if it refers to a single
1539         `~.axes.Axes` instance or a collection of these.
1540 
1541     See Also
1542     --------
1543     .pyplot.figure
1544     .pyplot.subplot
1545     .pyplot.axes
1546     .Figure.subplots
1547     .Figure.add_subplot
1548 
1549     Examples
1550     --------
1551     ::
1552 
1553         # First create some toy data:
1554         x = np.linspace(0, 2*np.pi, 400)
1555         y = np.sin(x**2)
1556 
1557         # Create just a figure and only one subplot
1558         fig, ax = plt.subplots()
1559         ax.plot(x, y)
1560         ax.set_title('Simple plot')
1561 
1562         # Create two subplots and unpack the output array immediately
1563         f, (ax1, ax2) = plt.subplots(1, 2, sharey=True)
1564         ax1.plot(x, y)
1565         ax1.set_title('Sharing Y axis')
1566         ax2.scatter(x, y)
1567 
1568         # Create four polar axes and access them through the returned array
1569         fig, axs = plt.subplots(2, 2, subplot_kw=dict(projection="polar"))
1570         axs[0, 0].plot(x, y)
1571         axs[1, 1].scatter(x, y)
1572 
1573         # Share a X axis with each column of subplots
1574         plt.subplots(2, 2, sharex='col')
1575 
1576         # Share a Y axis with each row of subplots
1577         plt.subplots(2, 2, sharey='row')
1578 
1579         # Share both X and Y axes with all subplots
1580         plt.subplots(2, 2, sharex='all', sharey='all')
1581 
1582         # Note that this is the same as
1583         plt.subplots(2, 2, sharex=True, sharey=True)
1584 
1585         # Create figure number 10 with a single subplot
1586         # and clears it if it already exists.
1587         fig, ax = plt.subplots(num=10, clear=True)
1588 
1589     """
1590     fig = figure(**fig_kw)
1591     axs = fig.subplots(nrows=nrows, ncols=ncols, sharex=sharex, sharey=sharey,
1592                        squeeze=squeeze, subplot_kw=subplot_kw,
1593                        gridspec_kw=gridspec_kw, height_ratios=height_ratios,
1594                        width_ratios=width_ratios)
1595     return fig, axs
1596 
1597 
1598 def subplot_mosaic(
1599     mosaic: str | HashableList,
1600     *,
1601     sharex: bool = False,
1602     sharey: bool = False,
1603     width_ratios: ArrayLike | None = None,
1604     height_ratios: ArrayLike | None = None,
1605     empty_sentinel: Any = '.',
1606     subplot_kw: dict[str, Any] | None = None,
1607     gridspec_kw: dict[str, Any] | None = None,
1608     per_subplot_kw: dict[Hashable, dict[str, Any]] | None = None,
1609     **fig_kw
1610 ) -> tuple[Figure, dict[Hashable, matplotlib.axes.Axes]]:
1611     """
1612     Build a layout of Axes based on ASCII art or nested lists.
1613 
1614     This is a helper function to build complex GridSpec layouts visually.
1615 
1616     See :ref:`mosaic`
1617     for an example and full API documentation
1618 
1619     Parameters
1620     ----------
1621     mosaic : list of list of {hashable or nested} or str
1622 
1623         A visual layout of how you want your Axes to be arranged
1624         labeled as strings.  For example ::
1625 
1626            x = [['A panel', 'A panel', 'edge'],
1627                 ['C panel', '.',       'edge']]
1628 
1629         produces 4 axes:
1630 
1631         - 'A panel' which is 1 row high and spans the first two columns
1632         - 'edge' which is 2 rows high and is on the right edge
1633         - 'C panel' which in 1 row and 1 column wide in the bottom left
1634         - a blank space 1 row and 1 column wide in the bottom center
1635 
1636         Any of the entries in the layout can be a list of lists
1637         of the same form to create nested layouts.
1638 
1639         If input is a str, then it must be of the form ::
1640 
1641           '''
1642           AAE
1643           C.E
1644           '''
1645 
1646         where each character is a column and each line is a row.
1647         This only allows only single character Axes labels and does
1648         not allow nesting but is very terse.
1649 
1650     sharex, sharey : bool, default: False
1651         If True, the x-axis (*sharex*) or y-axis (*sharey*) will be shared
1652         among all subplots.  In that case, tick label visibility and axis units
1653         behave as for `subplots`.  If False, each subplot's x- or y-axis will
1654         be independent.
1655 
1656     width_ratios : array-like of length *ncols*, optional
1657         Defines the relative widths of the columns. Each column gets a
1658         relative width of ``width_ratios[i] / sum(width_ratios)``.
1659         If not given, all columns will have the same width.  Convenience
1660         for ``gridspec_kw={'width_ratios': [...]}``.
1661 
1662     height_ratios : array-like of length *nrows*, optional
1663         Defines the relative heights of the rows. Each row gets a
1664         relative height of ``height_ratios[i] / sum(height_ratios)``.
1665         If not given, all rows will have the same height. Convenience
1666         for ``gridspec_kw={'height_ratios': [...]}``.
1667 
1668     empty_sentinel : object, optional
1669         Entry in the layout to mean "leave this space empty".  Defaults
1670         to ``'.'``. Note, if *layout* is a string, it is processed via
1671         `inspect.cleandoc` to remove leading white space, which may
1672         interfere with using white-space as the empty sentinel.
1673 
1674     subplot_kw : dict, optional
1675         Dictionary with keywords passed to the `.Figure.add_subplot` call
1676         used to create each subplot.  These values may be overridden by
1677         values in *per_subplot_kw*.
1678 
1679     per_subplot_kw : dict, optional
1680         A dictionary mapping the Axes identifiers or tuples of identifiers
1681         to a dictionary of keyword arguments to be passed to the
1682         `.Figure.add_subplot` call used to create each subplot.  The values
1683         in these dictionaries have precedence over the values in
1684         *subplot_kw*.
1685 
1686         If *mosaic* is a string, and thus all keys are single characters,
1687         it is possible to use a single string instead of a tuple as keys;
1688         i.e. ``"AB"`` is equivalent to ``("A", "B")``.
1689 
1690         .. versionadded:: 3.7
1691 
1692     gridspec_kw : dict, optional
1693         Dictionary with keywords passed to the `.GridSpec` constructor used
1694         to create the grid the subplots are placed on.
1695 
1696     **fig_kw
1697         All additional keyword arguments are passed to the
1698         `.pyplot.figure` call.
1699 
1700     Returns
1701     -------
1702     fig : `.Figure`
1703        The new figure
1704 
1705     dict[label, Axes]
1706        A dictionary mapping the labels to the Axes objects.  The order of
1707        the axes is left-to-right and top-to-bottom of their position in the
1708        total layout.
1709 
1710     """
1711     fig = figure(**fig_kw)
1712     ax_dict = fig.subplot_mosaic(
1713         mosaic, sharex=sharex, sharey=sharey,
1714         height_ratios=height_ratios, width_ratios=width_ratios,
1715         subplot_kw=subplot_kw, gridspec_kw=gridspec_kw,
1716         empty_sentinel=empty_sentinel,
1717         per_subplot_kw=per_subplot_kw,
1718     )
1719     return fig, ax_dict
1720 
1721 
1722 def subplot2grid(
1723     shape: tuple[int, int], loc: tuple[int, int],
1724     rowspan: int = 1, colspan: int = 1,
1725     fig: Figure | None = None,
1726     **kwargs
1727 ) -> matplotlib.axes.Axes:
1728     """
1729     Create a subplot at a specific location inside a regular grid.
1730 
1731     Parameters
1732     ----------
1733     shape : (int, int)
1734         Number of rows and of columns of the grid in which to place axis.
1735     loc : (int, int)
1736         Row number and column number of the axis location within the grid.
1737     rowspan : int, default: 1
1738         Number of rows for the axis to span downwards.
1739     colspan : int, default: 1
1740         Number of columns for the axis to span to the right.
1741     fig : `.Figure`, optional
1742         Figure to place the subplot in. Defaults to the current figure.
1743     **kwargs
1744         Additional keyword arguments are handed to `~.Figure.add_subplot`.
1745 
1746     Returns
1747     -------
1748     `~.axes.Axes`
1749 
1750         The Axes of the subplot. The returned Axes can actually be an instance
1751         of a subclass, such as `.projections.polar.PolarAxes` for polar
1752         projections.
1753 
1754     Notes
1755     -----
1756     The following call ::
1757 
1758         ax = subplot2grid((nrows, ncols), (row, col), rowspan, colspan)
1759 
1760     is identical to ::
1761 
1762         fig = gcf()
1763         gs = fig.add_gridspec(nrows, ncols)
1764         ax = fig.add_subplot(gs[row:row+rowspan, col:col+colspan])
1765     """
1766     if fig is None:
1767         fig = gcf()
1768     rows, cols = shape
1769     gs = GridSpec._check_gridspec_exists(fig, rows, cols)
1770     subplotspec = gs.new_subplotspec(loc, rowspan=rowspan, colspan=colspan)
1771     return fig.add_subplot(subplotspec, **kwargs)
1772 
1773 
1774 def twinx(ax: matplotlib.axes.Axes | None = None) -> _AxesBase:
1775     """
1776     Make and return a second axes that shares the *x*-axis.  The new axes will
1777     overlay *ax* (or the current axes if *ax* is *None*), and its ticks will be
1778     on the right.
1779 
1780     Examples
1781     --------
1782     :doc:`/gallery/subplots_axes_and_figures/two_scales`
1783     """
1784     if ax is None:
1785         ax = gca()
1786     ax1 = ax.twinx()
1787     return ax1
1788 
1789 
1790 def twiny(ax: matplotlib.axes.Axes | None = None) -> _AxesBase:
1791     """
1792     Make and return a second axes that shares the *y*-axis.  The new axes will
1793     overlay *ax* (or the current axes if *ax* is *None*), and its ticks will be
1794     on the top.
1795 
1796     Examples
1797     --------
1798     :doc:`/gallery/subplots_axes_and_figures/two_scales`
1799     """
1800     if ax is None:
1801         ax = gca()
1802     ax1 = ax.twiny()
1803     return ax1
1804 
1805 
1806 def subplot_tool(targetfig: Figure | None = None) -> SubplotTool | None:
1807     """
1808     Launch a subplot tool window for a figure.
1809 
1810     Returns
1811     -------
1812     `matplotlib.widgets.SubplotTool`
1813     """
1814     if targetfig is None:
1815         targetfig = gcf()
1816     tb = targetfig.canvas.manager.toolbar  # type: ignore[union-attr]
1817     if hasattr(tb, "configure_subplots"):  # toolbar2
1818         from matplotlib.backend_bases import NavigationToolbar2
1819         return cast(NavigationToolbar2, tb).configure_subplots()
1820     elif hasattr(tb, "trigger_tool"):  # toolmanager
1821         from matplotlib.backend_bases import ToolContainerBase
1822         cast(ToolContainerBase, tb).trigger_tool("subplots")
1823         return None
1824     else:
1825         raise ValueError("subplot_tool can only be launched for figures with "
1826                          "an associated toolbar")
1827 
1828 
1829 def box(on: bool | None = None) -> None:
1830     """
1831     Turn the axes box on or off on the current axes.
1832 
1833     Parameters
1834     ----------
1835     on : bool or None
1836         The new `~matplotlib.axes.Axes` box state. If ``None``, toggle
1837         the state.
1838 
1839     See Also
1840     --------
1841     :meth:`matplotlib.axes.Axes.set_frame_on`
1842     :meth:`matplotlib.axes.Axes.get_frame_on`
1843     """
1844     ax = gca()
1845     if on is None:
1846         on = not ax.get_frame_on()
1847     ax.set_frame_on(on)
1848 
1849 ## Axis ##
1850 
1851 
1852 def xlim(*args, **kwargs) -> tuple[float, float]:
1853     """
1854     Get or set the x limits of the current axes.
1855 
1856     Call signatures::
1857 
1858         left, right = xlim()  # return the current xlim
1859         xlim((left, right))   # set the xlim to left, right
1860         xlim(left, right)     # set the xlim to left, right
1861 
1862     If you do not specify args, you can pass *left* or *right* as kwargs,
1863     i.e.::
1864 
1865         xlim(right=3)  # adjust the right leaving left unchanged
1866         xlim(left=1)  # adjust the left leaving right unchanged
1867 
1868     Setting limits turns autoscaling off for the x-axis.
1869 
1870     Returns
1871     -------
1872     left, right
1873         A tuple of the new x-axis limits.
1874 
1875     Notes
1876     -----
1877     Calling this function with no arguments (e.g. ``xlim()``) is the pyplot
1878     equivalent of calling `~.Axes.get_xlim` on the current axes.
1879     Calling this function with arguments is the pyplot equivalent of calling
1880     `~.Axes.set_xlim` on the current axes. All arguments are passed though.
1881     """
1882     ax = gca()
1883     if not args and not kwargs:
1884         return ax.get_xlim()
1885     ret = ax.set_xlim(*args, **kwargs)
1886     return ret
1887 
1888 
1889 def ylim(*args, **kwargs) -> tuple[float, float]:
1890     """
1891     Get or set the y-limits of the current axes.
1892 
1893     Call signatures::
1894 
1895         bottom, top = ylim()  # return the current ylim
1896         ylim((bottom, top))   # set the ylim to bottom, top
1897         ylim(bottom, top)     # set the ylim to bottom, top
1898 
1899     If you do not specify args, you can alternatively pass *bottom* or
1900     *top* as kwargs, i.e.::
1901 
1902         ylim(top=3)  # adjust the top leaving bottom unchanged
1903         ylim(bottom=1)  # adjust the bottom leaving top unchanged
1904 
1905     Setting limits turns autoscaling off for the y-axis.
1906 
1907     Returns
1908     -------
1909     bottom, top
1910         A tuple of the new y-axis limits.
1911 
1912     Notes
1913     -----
1914     Calling this function with no arguments (e.g. ``ylim()``) is the pyplot
1915     equivalent of calling `~.Axes.get_ylim` on the current axes.
1916     Calling this function with arguments is the pyplot equivalent of calling
1917     `~.Axes.set_ylim` on the current axes. All arguments are passed though.
1918     """
1919     ax = gca()
1920     if not args and not kwargs:
1921         return ax.get_ylim()
1922     ret = ax.set_ylim(*args, **kwargs)
1923     return ret
1924 
1925 
1926 def xticks(
1927     ticks: ArrayLike | None = None,
1928     labels: Sequence[str] | None = None,
1929     *,
1930     minor: bool = False,
1931     **kwargs
1932 ) -> tuple[list[Tick] | np.ndarray, list[Text]]:
1933     """
1934     Get or set the current tick locations and labels of the x-axis.
1935 
1936     Pass no arguments to return the current values without modifying them.
1937 
1938     Parameters
1939     ----------
1940     ticks : array-like, optional
1941         The list of xtick locations.  Passing an empty list removes all xticks.
1942     labels : array-like, optional
1943         The labels to place at the given *ticks* locations.  This argument can
1944         only be passed if *ticks* is passed as well.
1945     minor : bool, default: False
1946         If ``False``, get/set the major ticks/labels; if ``True``, the minor
1947         ticks/labels.
1948     **kwargs
1949         `.Text` properties can be used to control the appearance of the labels.
1950 
1951     Returns
1952     -------
1953     locs
1954         The list of xtick locations.
1955     labels
1956         The list of xlabel `.Text` objects.
1957 
1958     Notes
1959     -----
1960     Calling this function with no arguments (e.g. ``xticks()``) is the pyplot
1961     equivalent of calling `~.Axes.get_xticks` and `~.Axes.get_xticklabels` on
1962     the current axes.
1963     Calling this function with arguments is the pyplot equivalent of calling
1964     `~.Axes.set_xticks` and `~.Axes.set_xticklabels` on the current axes.
1965 
1966     Examples
1967     --------
1968     >>> locs, labels = xticks()  # Get the current locations and labels.
1969     >>> xticks(np.arange(0, 1, step=0.2))  # Set label locations.
1970     >>> xticks(np.arange(3), ['Tom', 'Dick', 'Sue'])  # Set text labels.
1971     >>> xticks([0, 1, 2], ['January', 'February', 'March'],
1972     ...        rotation=20)  # Set text labels and properties.
1973     >>> xticks([])  # Disable xticks.
1974     """
1975     ax = gca()
1976 
1977     locs: list[Tick] | np.ndarray
1978     if ticks is None:
1979         locs = ax.get_xticks(minor=minor)
1980         if labels is not None:
1981             raise TypeError("xticks(): Parameter 'labels' can't be set "
1982                             "without setting 'ticks'")
1983     else:
1984         locs = ax.set_xticks(ticks, minor=minor)
1985 
1986     labels_out: list[Text] = []
1987     if labels is None:
1988         labels_out = ax.get_xticklabels(minor=minor)
1989         for l in labels_out:
1990             l._internal_update(kwargs)
1991     else:
1992         labels_out = ax.set_xticklabels(labels, minor=minor, **kwargs)
1993 
1994     return locs, labels_out
1995 
1996 
1997 def yticks(
1998     ticks: ArrayLike | None = None,
1999     labels: Sequence[str] | None = None,
2000     *,
2001     minor: bool = False,
2002     **kwargs
2003 ) -> tuple[list[Tick] | np.ndarray, list[Text]]:
2004     """
2005     Get or set the current tick locations and labels of the y-axis.
2006 
2007     Pass no arguments to return the current values without modifying them.
2008 
2009     Parameters
2010     ----------
2011     ticks : array-like, optional
2012         The list of ytick locations.  Passing an empty list removes all yticks.
2013     labels : array-like, optional
2014         The labels to place at the given *ticks* locations.  This argument can
2015         only be passed if *ticks* is passed as well.
2016     minor : bool, default: False
2017         If ``False``, get/set the major ticks/labels; if ``True``, the minor
2018         ticks/labels.
2019     **kwargs
2020         `.Text` properties can be used to control the appearance of the labels.
2021 
2022     Returns
2023     -------
2024     locs
2025         The list of ytick locations.
2026     labels
2027         The list of ylabel `.Text` objects.
2028 
2029     Notes
2030     -----
2031     Calling this function with no arguments (e.g. ``yticks()``) is the pyplot
2032     equivalent of calling `~.Axes.get_yticks` and `~.Axes.get_yticklabels` on
2033     the current axes.
2034     Calling this function with arguments is the pyplot equivalent of calling
2035     `~.Axes.set_yticks` and `~.Axes.set_yticklabels` on the current axes.
2036 
2037     Examples
2038     --------
2039     >>> locs, labels = yticks()  # Get the current locations and labels.
2040     >>> yticks(np.arange(0, 1, step=0.2))  # Set label locations.
2041     >>> yticks(np.arange(3), ['Tom', 'Dick', 'Sue'])  # Set text labels.
2042     >>> yticks([0, 1, 2], ['January', 'February', 'March'],
2043     ...        rotation=45)  # Set text labels and properties.
2044     >>> yticks([])  # Disable yticks.
2045     """
2046     ax = gca()
2047 
2048     locs: list[Tick] | np.ndarray
2049     if ticks is None:
2050         locs = ax.get_yticks(minor=minor)
2051         if labels is not None:
2052             raise TypeError("yticks(): Parameter 'labels' can't be set "
2053                             "without setting 'ticks'")
2054     else:
2055         locs = ax.set_yticks(ticks, minor=minor)
2056 
2057     labels_out: list[Text] = []
2058     if labels is None:
2059         labels_out = ax.get_yticklabels(minor=minor)
2060         for l in labels_out:
2061             l._internal_update(kwargs)
2062     else:
2063         labels_out = ax.set_yticklabels(labels, minor=minor, **kwargs)
2064 
2065     return locs, labels_out
2066 
2067 
2068 def rgrids(
2069     radii: ArrayLike | None = None,
2070     labels: Sequence[str | Text] | None = None,
2071     angle: float | None = None,
2072     fmt: str | None = None,
2073     **kwargs
2074 ) -> tuple[list[Line2D], list[Text]]:
2075     """
2076     Get or set the radial gridlines on the current polar plot.
2077 
2078     Call signatures::
2079 
2080      lines, labels = rgrids()
2081      lines, labels = rgrids(radii, labels=None, angle=22.5, fmt=None, **kwargs)
2082 
2083     When called with no arguments, `.rgrids` simply returns the tuple
2084     (*lines*, *labels*). When called with arguments, the labels will
2085     appear at the specified radial distances and angle.
2086 
2087     Parameters
2088     ----------
2089     radii : tuple with floats
2090         The radii for the radial gridlines
2091 
2092     labels : tuple with strings or None
2093         The labels to use at each radial gridline. The
2094         `matplotlib.ticker.ScalarFormatter` will be used if None.
2095 
2096     angle : float
2097         The angular position of the radius labels in degrees.
2098 
2099     fmt : str or None
2100         Format string used in `matplotlib.ticker.FormatStrFormatter`.
2101         For example '%f'.
2102 
2103     Returns
2104     -------
2105     lines : list of `.lines.Line2D`
2106         The radial gridlines.
2107 
2108     labels : list of `.text.Text`
2109         The tick labels.
2110 
2111     Other Parameters
2112     ----------------
2113     **kwargs
2114         *kwargs* are optional `.Text` properties for the labels.
2115 
2116     See Also
2117     --------
2118     .pyplot.thetagrids
2119     .projections.polar.PolarAxes.set_rgrids
2120     .Axis.get_gridlines
2121     .Axis.get_ticklabels
2122 
2123     Examples
2124     --------
2125     ::
2126 
2127       # set the locations of the radial gridlines
2128       lines, labels = rgrids( (0.25, 0.5, 1.0) )
2129 
2130       # set the locations and labels of the radial gridlines
2131       lines, labels = rgrids( (0.25, 0.5, 1.0), ('Tom', 'Dick', 'Harry' ))
2132     """
2133     ax = gca()
2134     if not isinstance(ax, PolarAxes):
2135         raise RuntimeError('rgrids only defined for polar axes')
2136     if all(p is None for p in [radii, labels, angle, fmt]) and not kwargs:
2137         lines_out: list[Line2D] = ax.yaxis.get_gridlines()
2138         labels_out: list[Text] = ax.yaxis.get_ticklabels()
2139     elif radii is None:
2140         raise TypeError("'radii' cannot be None when other parameters are passed")
2141     else:
2142         lines_out, labels_out = ax.set_rgrids(
2143             radii, labels=labels, angle=angle, fmt=fmt, **kwargs)
2144     return lines_out, labels_out
2145 
2146 
2147 def thetagrids(
2148     angles: ArrayLike | None = None,
2149     labels: Sequence[str | Text] | None = None,
2150     fmt: str | None = None,
2151     **kwargs
2152 ) -> tuple[list[Line2D], list[Text]]:
2153     """
2154     Get or set the theta gridlines on the current polar plot.
2155 
2156     Call signatures::
2157 
2158      lines, labels = thetagrids()
2159      lines, labels = thetagrids(angles, labels=None, fmt=None, **kwargs)
2160 
2161     When called with no arguments, `.thetagrids` simply returns the tuple
2162     (*lines*, *labels*). When called with arguments, the labels will
2163     appear at the specified angles.
2164 
2165     Parameters
2166     ----------
2167     angles : tuple with floats, degrees
2168         The angles of the theta gridlines.
2169 
2170     labels : tuple with strings or None
2171         The labels to use at each radial gridline. The
2172         `.projections.polar.ThetaFormatter` will be used if None.
2173 
2174     fmt : str or None
2175         Format string used in `matplotlib.ticker.FormatStrFormatter`.
2176         For example '%f'. Note that the angle in radians will be used.
2177 
2178     Returns
2179     -------
2180     lines : list of `.lines.Line2D`
2181         The theta gridlines.
2182 
2183     labels : list of `.text.Text`
2184         The tick labels.
2185 
2186     Other Parameters
2187     ----------------
2188     **kwargs
2189         *kwargs* are optional `.Text` properties for the labels.
2190 
2191     See Also
2192     --------
2193     .pyplot.rgrids
2194     .projections.polar.PolarAxes.set_thetagrids
2195     .Axis.get_gridlines
2196     .Axis.get_ticklabels
2197 
2198     Examples
2199     --------
2200     ::
2201 
2202       # set the locations of the angular gridlines
2203       lines, labels = thetagrids(range(45, 360, 90))
2204 
2205       # set the locations and labels of the angular gridlines
2206       lines, labels = thetagrids(range(45, 360, 90), ('NE', 'NW', 'SW', 'SE'))
2207     """
2208     ax = gca()
2209     if not isinstance(ax, PolarAxes):
2210         raise RuntimeError('thetagrids only defined for polar axes')
2211     if all(param is None for param in [angles, labels, fmt]) and not kwargs:
2212         lines_out: list[Line2D] = ax.xaxis.get_ticklines()
2213         labels_out: list[Text] = ax.xaxis.get_ticklabels()
2214     elif angles is None:
2215         raise TypeError("'angles' cannot be None when other parameters are passed")
2216     else:
2217         lines_out, labels_out = ax.set_thetagrids(angles,
2218                                                   labels=labels, fmt=fmt,
2219                                                   **kwargs)
2220     return lines_out, labels_out
2221 
2222 
2223 @_api.deprecated("3.7", pending=True)
2224 def get_plot_commands() -> list[str]:
2225     """
2226     Get a sorted list of all of the plotting commands.
2227     """
2228     NON_PLOT_COMMANDS = {
2229         'connect', 'disconnect', 'get_current_fig_manager', 'ginput',
2230         'new_figure_manager', 'waitforbuttonpress'}
2231     return [name for name in _get_pyplot_commands()
2232             if name not in NON_PLOT_COMMANDS]
2233 
2234 
2235 def _get_pyplot_commands() -> list[str]:
2236     # This works by searching for all functions in this module and removing
2237     # a few hard-coded exclusions, as well as all of the colormap-setting
2238     # functions, and anything marked as private with a preceding underscore.
2239     exclude = {'colormaps', 'colors', 'get_plot_commands', *colormaps}
2240     this_module = inspect.getmodule(get_plot_commands)
2241     return sorted(
2242         name for name, obj in globals().items()
2243         if not name.startswith('_') and name not in exclude
2244            and inspect.isfunction(obj)
2245            and inspect.getmodule(obj) is this_module)
2246 
2247 
2248 ## Plotting part 1: manually generated functions and wrappers ##
2249 
2250 
2251 @_copy_docstring_and_deprecators(Figure.colorbar)
2252 def colorbar(
2253     mappable: ScalarMappable | None = None,
2254     cax: matplotlib.axes.Axes | None = None,
2255     ax: matplotlib.axes.Axes | Iterable[matplotlib.axes.Axes] | None = None,
2256     **kwargs
2257 ) -> Colorbar:
2258     if mappable is None:
2259         mappable = gci()
2260         if mappable is None:
2261             raise RuntimeError('No mappable was found to use for colorbar '
2262                                'creation. First define a mappable such as '
2263                                'an image (with imshow) or a contour set ('
2264                                'with contourf).')
2265     ret = gcf().colorbar(mappable, cax=cax, ax=ax, **kwargs)
2266     return ret
2267 
2268 
2269 def clim(vmin: float | None = None, vmax: float | None = None) -> None:
2270     """
2271     Set the color limits of the current image.
2272 
2273     If either *vmin* or *vmax* is None, the image min/max respectively
2274     will be used for color scaling.
2275 
2276     If you want to set the clim of multiple images, use
2277     `~.ScalarMappable.set_clim` on every image, for example::
2278 
2279       for im in gca().get_images():
2280           im.set_clim(0, 0.5)
2281 
2282     """
2283     im = gci()
2284     if im is None:
2285         raise RuntimeError('You must first define an image, e.g., with imshow')
2286 
2287     im.set_clim(vmin, vmax)
2288 
2289 
2290 # eventually this implementation should move here, use indirection for now to
2291 # avoid having two copies of the code floating around.
2292 def get_cmap(
2293     name: Colormap | str | None = None,
2294     lut: int | None = None
2295 ) -> Colormap:
2296     return cm._get_cmap(name=name, lut=lut)  # type: ignore
2297 get_cmap.__doc__ = cm._get_cmap.__doc__  # type: ignore
2298 
2299 
2300 def set_cmap(cmap: Colormap | str) -> None:
2301     """
2302     Set the default colormap, and applies it to the current image if any.
2303 
2304     Parameters
2305     ----------
2306     cmap : `~matplotlib.colors.Colormap` or str
2307         A colormap instance or the name of a registered colormap.
2308 
2309     See Also
2310     --------
2311     colormaps
2312     matplotlib.cm.register_cmap
2313     matplotlib.cm.get_cmap
2314     """
2315     cmap = get_cmap(cmap)
2316 
2317     rc('image', cmap=cmap.name)
2318     im = gci()
2319 
2320     if im is not None:
2321         im.set_cmap(cmap)
2322 
2323 
2324 @_copy_docstring_and_deprecators(matplotlib.image.imread)
2325 def imread(
2326         fname: str | pathlib.Path | BinaryIO, format: str | None = None
2327 ) -> np.ndarray:
2328     return matplotlib.image.imread(fname, format)
2329 
2330 
2331 @_copy_docstring_and_deprecators(matplotlib.image.imsave)
2332 def imsave(
2333     fname: str | os.PathLike | BinaryIO, arr: ArrayLike, **kwargs
2334 ) -> None:
2335     matplotlib.image.imsave(fname, arr, **kwargs)
2336 
2337 
2338 def matshow(A: ArrayLike, fignum: None | int = None, **kwargs) -> AxesImage:
2339     """
2340     Display an array as a matrix in a new figure window.
2341 
2342     The origin is set at the upper left hand corner and rows (first
2343     dimension of the array) are displayed horizontally.  The aspect
2344     ratio of the figure window is that of the array, unless this would
2345     make an excessively short or narrow figure.
2346 
2347     Tick labels for the xaxis are placed on top.
2348 
2349     Parameters
2350     ----------
2351     A : 2D array-like
2352         The matrix to be displayed.
2353 
2354     fignum : None or int
2355         If *None*, create a new figure window with automatic numbering.
2356 
2357         If a nonzero integer, draw into the figure with the given number
2358         (create it if it does not exist).
2359 
2360         If 0, use the current axes (or create one if it does not exist).
2361 
2362         .. note::
2363 
2364            Because of how `.Axes.matshow` tries to set the figure aspect
2365            ratio to be the one of the array, strange things may happen if you
2366            reuse an existing figure.
2367 
2368     Returns
2369     -------
2370     `~matplotlib.image.AxesImage`
2371 
2372     Other Parameters
2373     ----------------
2374     **kwargs : `~matplotlib.axes.Axes.imshow` arguments
2375 
2376     """
2377     A = np.asanyarray(A)
2378     if fignum == 0:
2379         ax = gca()
2380     else:
2381         # Extract actual aspect ratio of array and make appropriately sized
2382         # figure.
2383         fig = figure(fignum, figsize=figaspect(A))
2384         ax = fig.add_axes((0.15, 0.09, 0.775, 0.775))
2385     im = ax.matshow(A, **kwargs)
2386     sci(im)
2387     return im
2388 
2389 
2390 def polar(*args, **kwargs) -> list[Line2D]:
2391     """
2392     Make a polar plot.
2393 
2394     call signature::
2395 
2396       polar(theta, r, **kwargs)
2397 
2398     Multiple *theta*, *r* arguments are supported, with format strings, as in
2399     `plot`.
2400     """
2401     # If an axis already exists, check if it has a polar projection
2402     if gcf().get_axes():
2403         ax = gca()
2404         if not isinstance(ax, PolarAxes):
2405             _api.warn_external('Trying to create polar plot on an Axes '
2406                                'that does not have a polar projection.')
2407     else:
2408         ax = axes(projection="polar")
2409     return ax.plot(*args, **kwargs)
2410 
2411 
2412 # If rcParams['backend_fallback'] is true, and an interactive backend is
2413 # requested, ignore rcParams['backend'] and force selection of a backend that
2414 # is compatible with the current running interactive framework.
2415 if (rcParams["backend_fallback"]
2416         and rcParams._get_backend_or_none() in (  # type: ignore
2417             set(rcsetup.interactive_bk) - {'WebAgg', 'nbAgg'})
2418         and cbook._get_running_interactive_framework()):  # type: ignore
2419     rcParams._set("backend", rcsetup._auto_backend_sentinel)  # type: ignore
2420 
2421 # fmt: on
2422 
2423 ################# REMAINING CONTENT GENERATED BY boilerplate.py ##############
2424 
2425 
2426 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2427 @_copy_docstring_and_deprecators(Figure.figimage)
2428 def figimage(
2429     X: ArrayLike,
2430     xo: int = 0,
2431     yo: int = 0,
2432     alpha: float | None = None,
2433     norm: str | Normalize | None = None,
2434     cmap: str | Colormap | None = None,
2435     vmin: float | None = None,
2436     vmax: float | None = None,
2437     origin: Literal["upper", "lower"] | None = None,
2438     resize: bool = False,
2439     **kwargs,
2440 ) -> FigureImage:
2441     return gcf().figimage(
2442         X,
2443         xo=xo,
2444         yo=yo,
2445         alpha=alpha,
2446         norm=norm,
2447         cmap=cmap,
2448         vmin=vmin,
2449         vmax=vmax,
2450         origin=origin,
2451         resize=resize,
2452         **kwargs,
2453     )
2454 
2455 
2456 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2457 @_copy_docstring_and_deprecators(Figure.text)
2458 def figtext(
2459     x: float, y: float, s: str, fontdict: dict[str, Any] | None = None, **kwargs
2460 ) -> Text:
2461     return gcf().text(x, y, s, fontdict=fontdict, **kwargs)
2462 
2463 
2464 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2465 @_copy_docstring_and_deprecators(Figure.gca)
2466 def gca() -> Axes:
2467     return gcf().gca()
2468 
2469 
2470 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2471 @_copy_docstring_and_deprecators(Figure._gci)
2472 def gci() -> ScalarMappable | None:
2473     return gcf()._gci()
2474 
2475 
2476 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2477 @_copy_docstring_and_deprecators(Figure.ginput)
2478 def ginput(
2479     n: int = 1,
2480     timeout: float = 30,
2481     show_clicks: bool = True,
2482     mouse_add: MouseButton = MouseButton.LEFT,
2483     mouse_pop: MouseButton = MouseButton.RIGHT,
2484     mouse_stop: MouseButton = MouseButton.MIDDLE,
2485 ) -> list[tuple[int, int]]:
2486     return gcf().ginput(
2487         n=n,
2488         timeout=timeout,
2489         show_clicks=show_clicks,
2490         mouse_add=mouse_add,
2491         mouse_pop=mouse_pop,
2492         mouse_stop=mouse_stop,
2493     )
2494 
2495 
2496 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2497 @_copy_docstring_and_deprecators(Figure.subplots_adjust)
2498 def subplots_adjust(
2499     left: float | None = None,
2500     bottom: float | None = None,
2501     right: float | None = None,
2502     top: float | None = None,
2503     wspace: float | None = None,
2504     hspace: float | None = None,
2505 ) -> None:
2506     gcf().subplots_adjust(
2507         left=left, bottom=bottom, right=right, top=top, wspace=wspace, hspace=hspace
2508     )
2509 
2510 
2511 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2512 @_copy_docstring_and_deprecators(Figure.suptitle)
2513 def suptitle(t: str, **kwargs) -> Text:
2514     return gcf().suptitle(t, **kwargs)
2515 
2516 
2517 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2518 @_copy_docstring_and_deprecators(Figure.tight_layout)
2519 def tight_layout(
2520     *,
2521     pad: float = 1.08,
2522     h_pad: float | None = None,
2523     w_pad: float | None = None,
2524     rect: tuple[float, float, float, float] | None = None,
2525 ) -> None:
2526     gcf().tight_layout(pad=pad, h_pad=h_pad, w_pad=w_pad, rect=rect)
2527 
2528 
2529 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2530 @_copy_docstring_and_deprecators(Figure.waitforbuttonpress)
2531 def waitforbuttonpress(timeout: float = -1) -> None | bool:
2532     return gcf().waitforbuttonpress(timeout=timeout)
2533 
2534 
2535 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2536 @_copy_docstring_and_deprecators(Axes.acorr)
2537 def acorr(
2538     x: ArrayLike, *, data=None, **kwargs
2539 ) -> tuple[np.ndarray, np.ndarray, LineCollection | Line2D, Line2D | None]:
2540     return gca().acorr(x, **({"data": data} if data is not None else {}), **kwargs)
2541 
2542 
2543 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2544 @_copy_docstring_and_deprecators(Axes.angle_spectrum)
2545 def angle_spectrum(
2546     x: ArrayLike,
2547     Fs: float | None = None,
2548     Fc: int | None = None,
2549     window: Callable[[ArrayLike], ArrayLike] | ArrayLike | None = None,
2550     pad_to: int | None = None,
2551     sides: Literal["default", "onesided", "twosided"] | None = None,
2552     *,
2553     data=None,
2554     **kwargs,
2555 ) -> tuple[np.ndarray, np.ndarray, Line2D]:
2556     return gca().angle_spectrum(
2557         x,
2558         Fs=Fs,
2559         Fc=Fc,
2560         window=window,
2561         pad_to=pad_to,
2562         sides=sides,
2563         **({"data": data} if data is not None else {}),
2564         **kwargs,
2565     )
2566 
2567 
2568 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2569 @_copy_docstring_and_deprecators(Axes.annotate)
2570 def annotate(
2571     text: str,
2572     xy: tuple[float, float],
2573     xytext: tuple[float, float] | None = None,
2574     xycoords: str
2575     | Artist
2576     | Transform
2577     | Callable[[RendererBase], Bbox | Transform]
2578     | tuple[float, float] = "data",
2579     textcoords: str
2580     | Artist
2581     | Transform
2582     | Callable[[RendererBase], Bbox | Transform]
2583     | tuple[float, float]
2584     | None = None,
2585     arrowprops: dict[str, Any] | None = None,
2586     annotation_clip: bool | None = None,
2587     **kwargs,
2588 ) -> Annotation:
2589     return gca().annotate(
2590         text,
2591         xy,
2592         xytext=xytext,
2593         xycoords=xycoords,
2594         textcoords=textcoords,
2595         arrowprops=arrowprops,
2596         annotation_clip=annotation_clip,
2597         **kwargs,
2598     )
2599 
2600 
2601 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2602 @_copy_docstring_and_deprecators(Axes.arrow)
2603 def arrow(x: float, y: float, dx: float, dy: float, **kwargs) -> FancyArrow:
2604     return gca().arrow(x, y, dx, dy, **kwargs)
2605 
2606 
2607 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2608 @_copy_docstring_and_deprecators(Axes.autoscale)
2609 def autoscale(
2610     enable: bool = True,
2611     axis: Literal["both", "x", "y"] = "both",
2612     tight: bool | None = None,
2613 ) -> None:
2614     gca().autoscale(enable=enable, axis=axis, tight=tight)
2615 
2616 
2617 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2618 @_copy_docstring_and_deprecators(Axes.axhline)
2619 def axhline(y: float = 0, xmin: float = 0, xmax: float = 1, **kwargs) -> Line2D:
2620     return gca().axhline(y=y, xmin=xmin, xmax=xmax, **kwargs)
2621 
2622 
2623 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2624 @_copy_docstring_and_deprecators(Axes.axhspan)
2625 def axhspan(
2626     ymin: float, ymax: float, xmin: float = 0, xmax: float = 1, **kwargs
2627 ) -> Polygon:
2628     return gca().axhspan(ymin, ymax, xmin=xmin, xmax=xmax, **kwargs)
2629 
2630 
2631 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2632 @_copy_docstring_and_deprecators(Axes.axis)
2633 def axis(
2634     arg: tuple[float, float, float, float] | bool | str | None = None,
2635     /,
2636     *,
2637     emit: bool = True,
2638     **kwargs,
2639 ) -> tuple[float, float, float, float]:
2640     return gca().axis(arg, emit=emit, **kwargs)
2641 
2642 
2643 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2644 @_copy_docstring_and_deprecators(Axes.axline)
2645 def axline(
2646     xy1: tuple[float, float],
2647     xy2: tuple[float, float] | None = None,
2648     *,
2649     slope: float | None = None,
2650     **kwargs,
2651 ) -> Line2D:
2652     return gca().axline(xy1, xy2=xy2, slope=slope, **kwargs)
2653 
2654 
2655 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2656 @_copy_docstring_and_deprecators(Axes.axvline)
2657 def axvline(x: float = 0, ymin: float = 0, ymax: float = 1, **kwargs) -> Line2D:
2658     return gca().axvline(x=x, ymin=ymin, ymax=ymax, **kwargs)
2659 
2660 
2661 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2662 @_copy_docstring_and_deprecators(Axes.axvspan)
2663 def axvspan(
2664     xmin: float, xmax: float, ymin: float = 0, ymax: float = 1, **kwargs
2665 ) -> Polygon:
2666     return gca().axvspan(xmin, xmax, ymin=ymin, ymax=ymax, **kwargs)
2667 
2668 
2669 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2670 @_copy_docstring_and_deprecators(Axes.bar)
2671 def bar(
2672     x: float | ArrayLike,
2673     height: float | ArrayLike,
2674     width: float | ArrayLike = 0.8,
2675     bottom: float | ArrayLike | None = None,
2676     *,
2677     align: Literal["center", "edge"] = "center",
2678     data=None,
2679     **kwargs,
2680 ) -> BarContainer:
2681     return gca().bar(
2682         x,
2683         height,
2684         width=width,
2685         bottom=bottom,
2686         align=align,
2687         **({"data": data} if data is not None else {}),
2688         **kwargs,
2689     )
2690 
2691 
2692 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2693 @_copy_docstring_and_deprecators(Axes.barbs)
2694 def barbs(*args, data=None, **kwargs) -> Barbs:
2695     return gca().barbs(*args, **({"data": data} if data is not None else {}), **kwargs)
2696 
2697 
2698 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2699 @_copy_docstring_and_deprecators(Axes.barh)
2700 def barh(
2701     y: float | ArrayLike,
2702     width: float | ArrayLike,
2703     height: float | ArrayLike = 0.8,
2704     left: float | ArrayLike | None = None,
2705     *,
2706     align: Literal["center", "edge"] = "center",
2707     data=None,
2708     **kwargs,
2709 ) -> BarContainer:
2710     return gca().barh(
2711         y,
2712         width,
2713         height=height,
2714         left=left,
2715         align=align,
2716         **({"data": data} if data is not None else {}),
2717         **kwargs,
2718     )
2719 
2720 
2721 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2722 @_copy_docstring_and_deprecators(Axes.bar_label)
2723 def bar_label(
2724     container: BarContainer,
2725     labels: ArrayLike | None = None,
2726     *,
2727     fmt: str | Callable[[float], str] = "%g",
2728     label_type: Literal["center", "edge"] = "edge",
2729     padding: float = 0,
2730     **kwargs,
2731 ) -> list[Annotation]:
2732     return gca().bar_label(
2733         container,
2734         labels=labels,
2735         fmt=fmt,
2736         label_type=label_type,
2737         padding=padding,
2738         **kwargs,
2739     )
2740 
2741 
2742 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2743 @_copy_docstring_and_deprecators(Axes.boxplot)
2744 def boxplot(
2745     x: ArrayLike | Sequence[ArrayLike],
2746     notch: bool | None = None,
2747     sym: str | None = None,
2748     vert: bool | None = None,
2749     whis: float | tuple[float, float] | None = None,
2750     positions: ArrayLike | None = None,
2751     widths: float | ArrayLike | None = None,
2752     patch_artist: bool | None = None,
2753     bootstrap: int | None = None,
2754     usermedians: ArrayLike | None = None,
2755     conf_intervals: ArrayLike | None = None,
2756     meanline: bool | None = None,
2757     showmeans: bool | None = None,
2758     showcaps: bool | None = None,
2759     showbox: bool | None = None,
2760     showfliers: bool | None = None,
2761     boxprops: dict[str, Any] | None = None,
2762     labels: Sequence[str] | None = None,
2763     flierprops: dict[str, Any] | None = None,
2764     medianprops: dict[str, Any] | None = None,
2765     meanprops: dict[str, Any] | None = None,
2766     capprops: dict[str, Any] | None = None,
2767     whiskerprops: dict[str, Any] | None = None,
2768     manage_ticks: bool = True,
2769     autorange: bool = False,
2770     zorder: float | None = None,
2771     capwidths: float | ArrayLike | None = None,
2772     *,
2773     data=None,
2774 ) -> dict[str, Any]:
2775     return gca().boxplot(
2776         x,
2777         notch=notch,
2778         sym=sym,
2779         vert=vert,
2780         whis=whis,
2781         positions=positions,
2782         widths=widths,
2783         patch_artist=patch_artist,
2784         bootstrap=bootstrap,
2785         usermedians=usermedians,
2786         conf_intervals=conf_intervals,
2787         meanline=meanline,
2788         showmeans=showmeans,
2789         showcaps=showcaps,
2790         showbox=showbox,
2791         showfliers=showfliers,
2792         boxprops=boxprops,
2793         labels=labels,
2794         flierprops=flierprops,
2795         medianprops=medianprops,
2796         meanprops=meanprops,
2797         capprops=capprops,
2798         whiskerprops=whiskerprops,
2799         manage_ticks=manage_ticks,
2800         autorange=autorange,
2801         zorder=zorder,
2802         capwidths=capwidths,
2803         **({"data": data} if data is not None else {}),
2804     )
2805 
2806 
2807 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2808 @_copy_docstring_and_deprecators(Axes.broken_barh)
2809 def broken_barh(
2810     xranges: Sequence[tuple[float, float]],
2811     yrange: tuple[float, float],
2812     *,
2813     data=None,
2814     **kwargs,
2815 ) -> BrokenBarHCollection:
2816     return gca().broken_barh(
2817         xranges, yrange, **({"data": data} if data is not None else {}), **kwargs
2818     )
2819 
2820 
2821 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2822 @_copy_docstring_and_deprecators(Axes.clabel)
2823 def clabel(CS: ContourSet, levels: ArrayLike | None = None, **kwargs) -> list[Text]:
2824     return gca().clabel(CS, levels=levels, **kwargs)
2825 
2826 
2827 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2828 @_copy_docstring_and_deprecators(Axes.cohere)
2829 def cohere(
2830     x: ArrayLike,
2831     y: ArrayLike,
2832     NFFT: int = 256,
2833     Fs: float = 2,
2834     Fc: int = 0,
2835     detrend: Literal["none", "mean", "linear"]
2836     | Callable[[ArrayLike], ArrayLike] = mlab.detrend_none,
2837     window: Callable[[ArrayLike], ArrayLike] | ArrayLike = mlab.window_hanning,
2838     noverlap: int = 0,
2839     pad_to: int | None = None,
2840     sides: Literal["default", "onesided", "twosided"] = "default",
2841     scale_by_freq: bool | None = None,
2842     *,
2843     data=None,
2844     **kwargs,
2845 ) -> tuple[np.ndarray, np.ndarray]:
2846     return gca().cohere(
2847         x,
2848         y,
2849         NFFT=NFFT,
2850         Fs=Fs,
2851         Fc=Fc,
2852         detrend=detrend,
2853         window=window,
2854         noverlap=noverlap,
2855         pad_to=pad_to,
2856         sides=sides,
2857         scale_by_freq=scale_by_freq,
2858         **({"data": data} if data is not None else {}),
2859         **kwargs,
2860     )
2861 
2862 
2863 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2864 @_copy_docstring_and_deprecators(Axes.contour)
2865 def contour(*args, data=None, **kwargs) -> QuadContourSet:
2866     __ret = gca().contour(
2867         *args, **({"data": data} if data is not None else {}), **kwargs
2868     )
2869     if __ret._A is not None:  # type: ignore[attr-defined]
2870         sci(__ret)
2871     return __ret
2872 
2873 
2874 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2875 @_copy_docstring_and_deprecators(Axes.contourf)
2876 def contourf(*args, data=None, **kwargs) -> QuadContourSet:
2877     __ret = gca().contourf(
2878         *args, **({"data": data} if data is not None else {}), **kwargs
2879     )
2880     if __ret._A is not None:  # type: ignore[attr-defined]
2881         sci(__ret)
2882     return __ret
2883 
2884 
2885 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2886 @_copy_docstring_and_deprecators(Axes.csd)
2887 def csd(
2888     x: ArrayLike,
2889     y: ArrayLike,
2890     NFFT: int | None = None,
2891     Fs: float | None = None,
2892     Fc: int | None = None,
2893     detrend: Literal["none", "mean", "linear"]
2894     | Callable[[ArrayLike], ArrayLike]
2895     | None = None,
2896     window: Callable[[ArrayLike], ArrayLike] | ArrayLike | None = None,
2897     noverlap: int | None = None,
2898     pad_to: int | None = None,
2899     sides: Literal["default", "onesided", "twosided"] | None = None,
2900     scale_by_freq: bool | None = None,
2901     return_line: bool | None = None,
2902     *,
2903     data=None,
2904     **kwargs,
2905 ) -> tuple[np.ndarray, np.ndarray] | tuple[np.ndarray, np.ndarray, Line2D]:
2906     return gca().csd(
2907         x,
2908         y,
2909         NFFT=NFFT,
2910         Fs=Fs,
2911         Fc=Fc,
2912         detrend=detrend,
2913         window=window,
2914         noverlap=noverlap,
2915         pad_to=pad_to,
2916         sides=sides,
2917         scale_by_freq=scale_by_freq,
2918         return_line=return_line,
2919         **({"data": data} if data is not None else {}),
2920         **kwargs,
2921     )
2922 
2923 
2924 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2925 @_copy_docstring_and_deprecators(Axes.ecdf)
2926 def ecdf(
2927     x: ArrayLike,
2928     weights: ArrayLike | None = None,
2929     *,
2930     complementary: bool = False,
2931     orientation: Literal["vertical", "horizonatal"] = "vertical",
2932     compress: bool = False,
2933     data=None,
2934     **kwargs,
2935 ) -> Line2D:
2936     return gca().ecdf(
2937         x,
2938         weights=weights,
2939         complementary=complementary,
2940         orientation=orientation,
2941         compress=compress,
2942         **({"data": data} if data is not None else {}),
2943         **kwargs,
2944     )
2945 
2946 
2947 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2948 @_copy_docstring_and_deprecators(Axes.errorbar)
2949 def errorbar(
2950     x: float | ArrayLike,
2951     y: float | ArrayLike,
2952     yerr: float | ArrayLike | None = None,
2953     xerr: float | ArrayLike | None = None,
2954     fmt: str = "",
2955     ecolor: ColorType | None = None,
2956     elinewidth: float | None = None,
2957     capsize: float | None = None,
2958     barsabove: bool = False,
2959     lolims: bool = False,
2960     uplims: bool = False,
2961     xlolims: bool = False,
2962     xuplims: bool = False,
2963     errorevery: int | tuple[int, int] = 1,
2964     capthick: float | None = None,
2965     *,
2966     data=None,
2967     **kwargs,
2968 ) -> ErrorbarContainer:
2969     return gca().errorbar(
2970         x,
2971         y,
2972         yerr=yerr,
2973         xerr=xerr,
2974         fmt=fmt,
2975         ecolor=ecolor,
2976         elinewidth=elinewidth,
2977         capsize=capsize,
2978         barsabove=barsabove,
2979         lolims=lolims,
2980         uplims=uplims,
2981         xlolims=xlolims,
2982         xuplims=xuplims,
2983         errorevery=errorevery,
2984         capthick=capthick,
2985         **({"data": data} if data is not None else {}),
2986         **kwargs,
2987     )
2988 
2989 
2990 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
2991 @_copy_docstring_and_deprecators(Axes.eventplot)
2992 def eventplot(
2993     positions: ArrayLike | Sequence[ArrayLike],
2994     orientation: Literal["horizontal", "vertical"] = "horizontal",
2995     lineoffsets: float | Sequence[float] = 1,
2996     linelengths: float | Sequence[float] = 1,
2997     linewidths: float | Sequence[float] | None = None,
2998     colors: ColorType | Sequence[ColorType] | None = None,
2999     alpha: float | Sequence[float] | None = None,
3000     linestyles: LineStyleType | Sequence[LineStyleType] = "solid",
3001     *,
3002     data=None,
3003     **kwargs,
3004 ) -> EventCollection:
3005     return gca().eventplot(
3006         positions,
3007         orientation=orientation,
3008         lineoffsets=lineoffsets,
3009         linelengths=linelengths,
3010         linewidths=linewidths,
3011         colors=colors,
3012         alpha=alpha,
3013         linestyles=linestyles,
3014         **({"data": data} if data is not None else {}),
3015         **kwargs,
3016     )
3017 
3018 
3019 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3020 @_copy_docstring_and_deprecators(Axes.fill)
3021 def fill(*args, data=None, **kwargs) -> list[Polygon]:
3022     return gca().fill(*args, **({"data": data} if data is not None else {}), **kwargs)
3023 
3024 
3025 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3026 @_copy_docstring_and_deprecators(Axes.fill_between)
3027 def fill_between(
3028     x: ArrayLike,
3029     y1: ArrayLike | float,
3030     y2: ArrayLike | float = 0,
3031     where: Sequence[bool] | None = None,
3032     interpolate: bool = False,
3033     step: Literal["pre", "post", "mid"] | None = None,
3034     *,
3035     data=None,
3036     **kwargs,
3037 ) -> PolyCollection:
3038     return gca().fill_between(
3039         x,
3040         y1,
3041         y2=y2,
3042         where=where,
3043         interpolate=interpolate,
3044         step=step,
3045         **({"data": data} if data is not None else {}),
3046         **kwargs,
3047     )
3048 
3049 
3050 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3051 @_copy_docstring_and_deprecators(Axes.fill_betweenx)
3052 def fill_betweenx(
3053     y: ArrayLike,
3054     x1: ArrayLike | float,
3055     x2: ArrayLike | float = 0,
3056     where: Sequence[bool] | None = None,
3057     step: Literal["pre", "post", "mid"] | None = None,
3058     interpolate: bool = False,
3059     *,
3060     data=None,
3061     **kwargs,
3062 ) -> PolyCollection:
3063     return gca().fill_betweenx(
3064         y,
3065         x1,
3066         x2=x2,
3067         where=where,
3068         step=step,
3069         interpolate=interpolate,
3070         **({"data": data} if data is not None else {}),
3071         **kwargs,
3072     )
3073 
3074 
3075 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3076 @_copy_docstring_and_deprecators(Axes.grid)
3077 def grid(
3078     visible: bool | None = None,
3079     which: Literal["major", "minor", "both"] = "major",
3080     axis: Literal["both", "x", "y"] = "both",
3081     **kwargs,
3082 ) -> None:
3083     gca().grid(visible=visible, which=which, axis=axis, **kwargs)
3084 
3085 
3086 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3087 @_copy_docstring_and_deprecators(Axes.hexbin)
3088 def hexbin(
3089     x: ArrayLike,
3090     y: ArrayLike,
3091     C: ArrayLike | None = None,
3092     gridsize: int | tuple[int, int] = 100,
3093     bins: Literal["log"] | int | Sequence[float] | None = None,
3094     xscale: Literal["linear", "log"] = "linear",
3095     yscale: Literal["linear", "log"] = "linear",
3096     extent: tuple[float, float, float, float] | None = None,
3097     cmap: str | Colormap | None = None,
3098     norm: str | Normalize | None = None,
3099     vmin: float | None = None,
3100     vmax: float | None = None,
3101     alpha: float | None = None,
3102     linewidths: float | None = None,
3103     edgecolors: Literal["face", "none"] | ColorType = "face",
3104     reduce_C_function: Callable[[np.ndarray | list[float]], float] = np.mean,
3105     mincnt: int | None = None,
3106     marginals: bool = False,
3107     *,
3108     data=None,
3109     **kwargs,
3110 ) -> PolyCollection:
3111     __ret = gca().hexbin(
3112         x,
3113         y,
3114         C=C,
3115         gridsize=gridsize,
3116         bins=bins,
3117         xscale=xscale,
3118         yscale=yscale,
3119         extent=extent,
3120         cmap=cmap,
3121         norm=norm,
3122         vmin=vmin,
3123         vmax=vmax,
3124         alpha=alpha,
3125         linewidths=linewidths,
3126         edgecolors=edgecolors,
3127         reduce_C_function=reduce_C_function,
3128         mincnt=mincnt,
3129         marginals=marginals,
3130         **({"data": data} if data is not None else {}),
3131         **kwargs,
3132     )
3133     sci(__ret)
3134     return __ret
3135 
3136 
3137 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3138 @_copy_docstring_and_deprecators(Axes.hist)
3139 def hist(
3140     x: ArrayLike | Sequence[ArrayLike],
3141     bins: int | Sequence[float] | str | None = None,
3142     range: tuple[float, float] | None = None,
3143     density: bool = False,
3144     weights: ArrayLike | None = None,
3145     cumulative: bool | float = False,
3146     bottom: ArrayLike | float | None = None,
3147     histtype: Literal["bar", "barstacked", "step", "stepfilled"] = "bar",
3148     align: Literal["left", "mid", "right"] = "mid",
3149     orientation: Literal["vertical", "horizontal"] = "vertical",
3150     rwidth: float | None = None,
3151     log: bool = False,
3152     color: ColorType | Sequence[ColorType] | None = None,
3153     label: str | Sequence[str] | None = None,
3154     stacked: bool = False,
3155     *,
3156     data=None,
3157     **kwargs,
3158 ) -> tuple[
3159     np.ndarray | list[np.ndarray],
3160     np.ndarray,
3161     BarContainer | Polygon | list[BarContainer | Polygon],
3162 ]:
3163     return gca().hist(
3164         x,
3165         bins=bins,
3166         range=range,
3167         density=density,
3168         weights=weights,
3169         cumulative=cumulative,
3170         bottom=bottom,
3171         histtype=histtype,
3172         align=align,
3173         orientation=orientation,
3174         rwidth=rwidth,
3175         log=log,
3176         color=color,
3177         label=label,
3178         stacked=stacked,
3179         **({"data": data} if data is not None else {}),
3180         **kwargs,
3181     )
3182 
3183 
3184 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3185 @_copy_docstring_and_deprecators(Axes.stairs)
3186 def stairs(
3187     values: ArrayLike,
3188     edges: ArrayLike | None = None,
3189     *,
3190     orientation: Literal["vertical", "horizontal"] = "vertical",
3191     baseline: float | ArrayLike | None = 0,
3192     fill: bool = False,
3193     data=None,
3194     **kwargs,
3195 ) -> StepPatch:
3196     return gca().stairs(
3197         values,
3198         edges=edges,
3199         orientation=orientation,
3200         baseline=baseline,
3201         fill=fill,
3202         **({"data": data} if data is not None else {}),
3203         **kwargs,
3204     )
3205 
3206 
3207 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3208 @_copy_docstring_and_deprecators(Axes.hist2d)
3209 def hist2d(
3210     x: ArrayLike,
3211     y: ArrayLike,
3212     bins: None | int | tuple[int, int] | ArrayLike | tuple[ArrayLike, ArrayLike] = 10,
3213     range: ArrayLike | None = None,
3214     density: bool = False,
3215     weights: ArrayLike | None = None,
3216     cmin: float | None = None,
3217     cmax: float | None = None,
3218     *,
3219     data=None,
3220     **kwargs,
3221 ) -> tuple[np.ndarray, np.ndarray, np.ndarray, QuadMesh]:
3222     __ret = gca().hist2d(
3223         x,
3224         y,
3225         bins=bins,
3226         range=range,
3227         density=density,
3228         weights=weights,
3229         cmin=cmin,
3230         cmax=cmax,
3231         **({"data": data} if data is not None else {}),
3232         **kwargs,
3233     )
3234     sci(__ret[-1])
3235     return __ret
3236 
3237 
3238 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3239 @_copy_docstring_and_deprecators(Axes.hlines)
3240 def hlines(
3241     y: float | ArrayLike,
3242     xmin: float | ArrayLike,
3243     xmax: float | ArrayLike,
3244     colors: ColorType | Sequence[ColorType] | None = None,
3245     linestyles: LineStyleType = "solid",
3246     label: str = "",
3247     *,
3248     data=None,
3249     **kwargs,
3250 ) -> LineCollection:
3251     return gca().hlines(
3252         y,
3253         xmin,
3254         xmax,
3255         colors=colors,
3256         linestyles=linestyles,
3257         label=label,
3258         **({"data": data} if data is not None else {}),
3259         **kwargs,
3260     )
3261 
3262 
3263 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3264 @_copy_docstring_and_deprecators(Axes.imshow)
3265 def imshow(
3266     X: ArrayLike | PIL.Image.Image,
3267     cmap: str | Colormap | None = None,
3268     norm: str | Normalize | None = None,
3269     *,
3270     aspect: Literal["equal", "auto"] | float | None = None,
3271     interpolation: str | None = None,
3272     alpha: float | ArrayLike | None = None,
3273     vmin: float | None = None,
3274     vmax: float | None = None,
3275     origin: Literal["upper", "lower"] | None = None,
3276     extent: tuple[float, float, float, float] | None = None,
3277     interpolation_stage: Literal["data", "rgba"] | None = None,
3278     filternorm: bool = True,
3279     filterrad: float = 4.0,
3280     resample: bool | None = None,
3281     url: str | None = None,
3282     data=None,
3283     **kwargs,
3284 ) -> AxesImage:
3285     __ret = gca().imshow(
3286         X,
3287         cmap=cmap,
3288         norm=norm,
3289         aspect=aspect,
3290         interpolation=interpolation,
3291         alpha=alpha,
3292         vmin=vmin,
3293         vmax=vmax,
3294         origin=origin,
3295         extent=extent,
3296         interpolation_stage=interpolation_stage,
3297         filternorm=filternorm,
3298         filterrad=filterrad,
3299         resample=resample,
3300         url=url,
3301         **({"data": data} if data is not None else {}),
3302         **kwargs,
3303     )
3304     sci(__ret)
3305     return __ret
3306 
3307 
3308 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3309 @_copy_docstring_and_deprecators(Axes.legend)
3310 def legend(*args, **kwargs) -> Legend:
3311     return gca().legend(*args, **kwargs)
3312 
3313 
3314 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3315 @_copy_docstring_and_deprecators(Axes.locator_params)
3316 def locator_params(
3317     axis: Literal["both", "x", "y"] = "both", tight: bool | None = None, **kwargs
3318 ) -> None:
3319     gca().locator_params(axis=axis, tight=tight, **kwargs)
3320 
3321 
3322 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3323 @_copy_docstring_and_deprecators(Axes.loglog)
3324 def loglog(*args, **kwargs) -> list[Line2D]:
3325     return gca().loglog(*args, **kwargs)
3326 
3327 
3328 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3329 @_copy_docstring_and_deprecators(Axes.magnitude_spectrum)
3330 def magnitude_spectrum(
3331     x: ArrayLike,
3332     Fs: float | None = None,
3333     Fc: int | None = None,
3334     window: Callable[[ArrayLike], ArrayLike] | ArrayLike | None = None,
3335     pad_to: int | None = None,
3336     sides: Literal["default", "onesided", "twosided"] | None = None,
3337     scale: Literal["default", "linear", "dB"] | None = None,
3338     *,
3339     data=None,
3340     **kwargs,
3341 ) -> tuple[np.ndarray, np.ndarray, Line2D]:
3342     return gca().magnitude_spectrum(
3343         x,
3344         Fs=Fs,
3345         Fc=Fc,
3346         window=window,
3347         pad_to=pad_to,
3348         sides=sides,
3349         scale=scale,
3350         **({"data": data} if data is not None else {}),
3351         **kwargs,
3352     )
3353 
3354 
3355 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3356 @_copy_docstring_and_deprecators(Axes.margins)
3357 def margins(
3358     *margins: float,
3359     x: float | None = None,
3360     y: float | None = None,
3361     tight: bool | None = True,
3362 ) -> tuple[float, float] | None:
3363     return gca().margins(*margins, x=x, y=y, tight=tight)
3364 
3365 
3366 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3367 @_copy_docstring_and_deprecators(Axes.minorticks_off)
3368 def minorticks_off() -> None:
3369     gca().minorticks_off()
3370 
3371 
3372 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3373 @_copy_docstring_and_deprecators(Axes.minorticks_on)
3374 def minorticks_on() -> None:
3375     gca().minorticks_on()
3376 
3377 
3378 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3379 @_copy_docstring_and_deprecators(Axes.pcolor)
3380 def pcolor(
3381     *args: ArrayLike,
3382     shading: Literal["flat", "nearest", "auto"] | None = None,
3383     alpha: float | None = None,
3384     norm: str | Normalize | None = None,
3385     cmap: str | Colormap | None = None,
3386     vmin: float | None = None,
3387     vmax: float | None = None,
3388     data=None,
3389     **kwargs,
3390 ) -> Collection:
3391     __ret = gca().pcolor(
3392         *args,
3393         shading=shading,
3394         alpha=alpha,
3395         norm=norm,
3396         cmap=cmap,
3397         vmin=vmin,
3398         vmax=vmax,
3399         **({"data": data} if data is not None else {}),
3400         **kwargs,
3401     )
3402     sci(__ret)
3403     return __ret
3404 
3405 
3406 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3407 @_copy_docstring_and_deprecators(Axes.pcolormesh)
3408 def pcolormesh(
3409     *args: ArrayLike,
3410     alpha: float | None = None,
3411     norm: str | Normalize | None = None,
3412     cmap: str | Colormap | None = None,
3413     vmin: float | None = None,
3414     vmax: float | None = None,
3415     shading: Literal["flat", "nearest", "gouraud", "auto"] | None = None,
3416     antialiased: bool = False,
3417     data=None,
3418     **kwargs,
3419 ) -> QuadMesh:
3420     __ret = gca().pcolormesh(
3421         *args,
3422         alpha=alpha,
3423         norm=norm,
3424         cmap=cmap,
3425         vmin=vmin,
3426         vmax=vmax,
3427         shading=shading,
3428         antialiased=antialiased,
3429         **({"data": data} if data is not None else {}),
3430         **kwargs,
3431     )
3432     sci(__ret)
3433     return __ret
3434 
3435 
3436 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3437 @_copy_docstring_and_deprecators(Axes.phase_spectrum)
3438 def phase_spectrum(
3439     x: ArrayLike,
3440     Fs: float | None = None,
3441     Fc: int | None = None,
3442     window: Callable[[ArrayLike], ArrayLike] | ArrayLike | None = None,
3443     pad_to: int | None = None,
3444     sides: Literal["default", "onesided", "twosided"] | None = None,
3445     *,
3446     data=None,
3447     **kwargs,
3448 ) -> tuple[np.ndarray, np.ndarray, Line2D]:
3449     return gca().phase_spectrum(
3450         x,
3451         Fs=Fs,
3452         Fc=Fc,
3453         window=window,
3454         pad_to=pad_to,
3455         sides=sides,
3456         **({"data": data} if data is not None else {}),
3457         **kwargs,
3458     )
3459 
3460 
3461 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3462 @_copy_docstring_and_deprecators(Axes.pie)
3463 def pie(
3464     x: ArrayLike,
3465     explode: ArrayLike | None = None,
3466     labels: Sequence[str] | None = None,
3467     colors: ColorType | Sequence[ColorType] | None = None,
3468     autopct: str | Callable[[float], str] | None = None,
3469     pctdistance: float = 0.6,
3470     shadow: bool = False,
3471     labeldistance: float | None = 1.1,
3472     startangle: float = 0,
3473     radius: float = 1,
3474     counterclock: bool = True,
3475     wedgeprops: dict[str, Any] | None = None,
3476     textprops: dict[str, Any] | None = None,
3477     center: tuple[float, float] = (0, 0),
3478     frame: bool = False,
3479     rotatelabels: bool = False,
3480     *,
3481     normalize: bool = True,
3482     hatch: str | Sequence[str] | None = None,
3483     data=None,
3484 ) -> tuple[list[Wedge], list[Text]] | tuple[list[Wedge], list[Text], list[Text]]:
3485     return gca().pie(
3486         x,
3487         explode=explode,
3488         labels=labels,
3489         colors=colors,
3490         autopct=autopct,
3491         pctdistance=pctdistance,
3492         shadow=shadow,
3493         labeldistance=labeldistance,
3494         startangle=startangle,
3495         radius=radius,
3496         counterclock=counterclock,
3497         wedgeprops=wedgeprops,
3498         textprops=textprops,
3499         center=center,
3500         frame=frame,
3501         rotatelabels=rotatelabels,
3502         normalize=normalize,
3503         hatch=hatch,
3504         **({"data": data} if data is not None else {}),
3505     )
3506 
3507 
3508 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3509 @_copy_docstring_and_deprecators(Axes.plot)
3510 def plot(
3511     *args: float | ArrayLike | str,
3512     scalex: bool = True,
3513     scaley: bool = True,
3514     data=None,
3515     **kwargs,
3516 ) -> list[Line2D]:
3517     return gca().plot(
3518         *args,
3519         scalex=scalex,
3520         scaley=scaley,
3521         **({"data": data} if data is not None else {}),
3522         **kwargs,
3523     )
3524 
3525 
3526 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3527 @_copy_docstring_and_deprecators(Axes.plot_date)
3528 def plot_date(
3529     x: ArrayLike,
3530     y: ArrayLike,
3531     fmt: str = "o",
3532     tz: str | datetime.tzinfo | None = None,
3533     xdate: bool = True,
3534     ydate: bool = False,
3535     *,
3536     data=None,
3537     **kwargs,
3538 ) -> list[Line2D]:
3539     return gca().plot_date(
3540         x,
3541         y,
3542         fmt=fmt,
3543         tz=tz,
3544         xdate=xdate,
3545         ydate=ydate,
3546         **({"data": data} if data is not None else {}),
3547         **kwargs,
3548     )
3549 
3550 
3551 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3552 @_copy_docstring_and_deprecators(Axes.psd)
3553 def psd(
3554     x: ArrayLike,
3555     NFFT: int | None = None,
3556     Fs: float | None = None,
3557     Fc: int | None = None,
3558     detrend: Literal["none", "mean", "linear"]
3559     | Callable[[ArrayLike], ArrayLike]
3560     | None = None,
3561     window: Callable[[ArrayLike], ArrayLike] | ArrayLike | None = None,
3562     noverlap: int | None = None,
3563     pad_to: int | None = None,
3564     sides: Literal["default", "onesided", "twosided"] | None = None,
3565     scale_by_freq: bool | None = None,
3566     return_line: bool | None = None,
3567     *,
3568     data=None,
3569     **kwargs,
3570 ) -> tuple[np.ndarray, np.ndarray] | tuple[np.ndarray, np.ndarray, Line2D]:
3571     return gca().psd(
3572         x,
3573         NFFT=NFFT,
3574         Fs=Fs,
3575         Fc=Fc,
3576         detrend=detrend,
3577         window=window,
3578         noverlap=noverlap,
3579         pad_to=pad_to,
3580         sides=sides,
3581         scale_by_freq=scale_by_freq,
3582         return_line=return_line,
3583         **({"data": data} if data is not None else {}),
3584         **kwargs,
3585     )
3586 
3587 
3588 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3589 @_copy_docstring_and_deprecators(Axes.quiver)
3590 def quiver(*args, data=None, **kwargs) -> Quiver:
3591     __ret = gca().quiver(
3592         *args, **({"data": data} if data is not None else {}), **kwargs
3593     )
3594     sci(__ret)
3595     return __ret
3596 
3597 
3598 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3599 @_copy_docstring_and_deprecators(Axes.quiverkey)
3600 def quiverkey(
3601     Q: Quiver, X: float, Y: float, U: float, label: str, **kwargs
3602 ) -> QuiverKey:
3603     return gca().quiverkey(Q, X, Y, U, label, **kwargs)
3604 
3605 
3606 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3607 @_copy_docstring_and_deprecators(Axes.scatter)
3608 def scatter(
3609     x: float | ArrayLike,
3610     y: float | ArrayLike,
3611     s: float | ArrayLike | None = None,
3612     c: Sequence[ColorType] | ColorType | None = None,
3613     marker: MarkerType | None = None,
3614     cmap: str | Colormap | None = None,
3615     norm: str | Normalize | None = None,
3616     vmin: float | None = None,
3617     vmax: float | None = None,
3618     alpha: float | None = None,
3619     linewidths: float | Sequence[float] | None = None,
3620     *,
3621     edgecolors: Literal["face", "none"] | ColorType | Sequence[ColorType] | None = None,
3622     plotnonfinite: bool = False,
3623     data=None,
3624     **kwargs,
3625 ) -> PathCollection:
3626     __ret = gca().scatter(
3627         x,
3628         y,
3629         s=s,
3630         c=c,
3631         marker=marker,
3632         cmap=cmap,
3633         norm=norm,
3634         vmin=vmin,
3635         vmax=vmax,
3636         alpha=alpha,
3637         linewidths=linewidths,
3638         edgecolors=edgecolors,
3639         plotnonfinite=plotnonfinite,
3640         **({"data": data} if data is not None else {}),
3641         **kwargs,
3642     )
3643     sci(__ret)
3644     return __ret
3645 
3646 
3647 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3648 @_copy_docstring_and_deprecators(Axes.semilogx)
3649 def semilogx(*args, **kwargs) -> list[Line2D]:
3650     return gca().semilogx(*args, **kwargs)
3651 
3652 
3653 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3654 @_copy_docstring_and_deprecators(Axes.semilogy)
3655 def semilogy(*args, **kwargs) -> list[Line2D]:
3656     return gca().semilogy(*args, **kwargs)
3657 
3658 
3659 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3660 @_copy_docstring_and_deprecators(Axes.specgram)
3661 def specgram(
3662     x: ArrayLike,
3663     NFFT: int | None = None,
3664     Fs: float | None = None,
3665     Fc: int | None = None,
3666     detrend: Literal["none", "mean", "linear"]
3667     | Callable[[ArrayLike], ArrayLike]
3668     | None = None,
3669     window: Callable[[ArrayLike], ArrayLike] | ArrayLike | None = None,
3670     noverlap: int | None = None,
3671     cmap: str | Colormap | None = None,
3672     xextent: tuple[float, float] | None = None,
3673     pad_to: int | None = None,
3674     sides: Literal["default", "onesided", "twosided"] | None = None,
3675     scale_by_freq: bool | None = None,
3676     mode: Literal["default", "psd", "magnitude", "angle", "phase"] | None = None,
3677     scale: Literal["default", "linear", "dB"] | None = None,
3678     vmin: float | None = None,
3679     vmax: float | None = None,
3680     *,
3681     data=None,
3682     **kwargs,
3683 ) -> tuple[np.ndarray, np.ndarray, np.ndarray, AxesImage]:
3684     __ret = gca().specgram(
3685         x,
3686         NFFT=NFFT,
3687         Fs=Fs,
3688         Fc=Fc,
3689         detrend=detrend,
3690         window=window,
3691         noverlap=noverlap,
3692         cmap=cmap,
3693         xextent=xextent,
3694         pad_to=pad_to,
3695         sides=sides,
3696         scale_by_freq=scale_by_freq,
3697         mode=mode,
3698         scale=scale,
3699         vmin=vmin,
3700         vmax=vmax,
3701         **({"data": data} if data is not None else {}),
3702         **kwargs,
3703     )
3704     sci(__ret[-1])
3705     return __ret
3706 
3707 
3708 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3709 @_copy_docstring_and_deprecators(Axes.spy)
3710 def spy(
3711     Z: ArrayLike,
3712     precision: float | Literal["present"] = 0,
3713     marker: str | None = None,
3714     markersize: float | None = None,
3715     aspect: Literal["equal", "auto"] | float | None = "equal",
3716     origin: Literal["upper", "lower"] = "upper",
3717     **kwargs,
3718 ) -> AxesImage:
3719     __ret = gca().spy(
3720         Z,
3721         precision=precision,
3722         marker=marker,
3723         markersize=markersize,
3724         aspect=aspect,
3725         origin=origin,
3726         **kwargs,
3727     )
3728     if isinstance(__ret, cm.ScalarMappable):
3729         sci(__ret)  # noqa
3730     return __ret
3731 
3732 
3733 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3734 @_copy_docstring_and_deprecators(Axes.stackplot)
3735 def stackplot(x, *args, labels=(), colors=None, baseline="zero", data=None, **kwargs):
3736     return gca().stackplot(
3737         x,
3738         *args,
3739         labels=labels,
3740         colors=colors,
3741         baseline=baseline,
3742         **({"data": data} if data is not None else {}),
3743         **kwargs,
3744     )
3745 
3746 
3747 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3748 @_copy_docstring_and_deprecators(Axes.stem)
3749 def stem(
3750     *args: ArrayLike | str,
3751     linefmt: str | None = None,
3752     markerfmt: str | None = None,
3753     basefmt: str | None = None,
3754     bottom: float = 0,
3755     label: str | None = None,
3756     orientation: Literal["vertical", "horizontal"] = "vertical",
3757     data=None,
3758 ) -> StemContainer:
3759     return gca().stem(
3760         *args,
3761         linefmt=linefmt,
3762         markerfmt=markerfmt,
3763         basefmt=basefmt,
3764         bottom=bottom,
3765         label=label,
3766         orientation=orientation,
3767         **({"data": data} if data is not None else {}),
3768     )
3769 
3770 
3771 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3772 @_copy_docstring_and_deprecators(Axes.step)
3773 def step(
3774     x: ArrayLike,
3775     y: ArrayLike,
3776     *args,
3777     where: Literal["pre", "post", "mid"] = "pre",
3778     data=None,
3779     **kwargs,
3780 ) -> list[Line2D]:
3781     return gca().step(
3782         x,
3783         y,
3784         *args,
3785         where=where,
3786         **({"data": data} if data is not None else {}),
3787         **kwargs,
3788     )
3789 
3790 
3791 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3792 @_copy_docstring_and_deprecators(Axes.streamplot)
3793 def streamplot(
3794     x,
3795     y,
3796     u,
3797     v,
3798     density=1,
3799     linewidth=None,
3800     color=None,
3801     cmap=None,
3802     norm=None,
3803     arrowsize=1,
3804     arrowstyle="-|>",
3805     minlength=0.1,
3806     transform=None,
3807     zorder=None,
3808     start_points=None,
3809     maxlength=4.0,
3810     integration_direction="both",
3811     broken_streamlines=True,
3812     *,
3813     data=None,
3814 ):
3815     __ret = gca().streamplot(
3816         x,
3817         y,
3818         u,
3819         v,
3820         density=density,
3821         linewidth=linewidth,
3822         color=color,
3823         cmap=cmap,
3824         norm=norm,
3825         arrowsize=arrowsize,
3826         arrowstyle=arrowstyle,
3827         minlength=minlength,
3828         transform=transform,
3829         zorder=zorder,
3830         start_points=start_points,
3831         maxlength=maxlength,
3832         integration_direction=integration_direction,
3833         broken_streamlines=broken_streamlines,
3834         **({"data": data} if data is not None else {}),
3835     )
3836     sci(__ret.lines)
3837     return __ret
3838 
3839 
3840 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3841 @_copy_docstring_and_deprecators(Axes.table)
3842 def table(
3843     cellText=None,
3844     cellColours=None,
3845     cellLoc="right",
3846     colWidths=None,
3847     rowLabels=None,
3848     rowColours=None,
3849     rowLoc="left",
3850     colLabels=None,
3851     colColours=None,
3852     colLoc="center",
3853     loc="bottom",
3854     bbox=None,
3855     edges="closed",
3856     **kwargs,
3857 ):
3858     return gca().table(
3859         cellText=cellText,
3860         cellColours=cellColours,
3861         cellLoc=cellLoc,
3862         colWidths=colWidths,
3863         rowLabels=rowLabels,
3864         rowColours=rowColours,
3865         rowLoc=rowLoc,
3866         colLabels=colLabels,
3867         colColours=colColours,
3868         colLoc=colLoc,
3869         loc=loc,
3870         bbox=bbox,
3871         edges=edges,
3872         **kwargs,
3873     )
3874 
3875 
3876 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3877 @_copy_docstring_and_deprecators(Axes.text)
3878 def text(
3879     x: float, y: float, s: str, fontdict: dict[str, Any] | None = None, **kwargs
3880 ) -> Text:
3881     return gca().text(x, y, s, fontdict=fontdict, **kwargs)
3882 
3883 
3884 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3885 @_copy_docstring_and_deprecators(Axes.tick_params)
3886 def tick_params(axis: Literal["both", "x", "y"] = "both", **kwargs) -> None:
3887     gca().tick_params(axis=axis, **kwargs)
3888 
3889 
3890 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3891 @_copy_docstring_and_deprecators(Axes.ticklabel_format)
3892 def ticklabel_format(
3893     *,
3894     axis: Literal["both", "x", "y"] = "both",
3895     style: Literal["", "sci", "scientific", "plain"] = "",
3896     scilimits: tuple[int, int] | None = None,
3897     useOffset: bool | float | None = None,
3898     useLocale: bool | None = None,
3899     useMathText: bool | None = None,
3900 ) -> None:
3901     gca().ticklabel_format(
3902         axis=axis,
3903         style=style,
3904         scilimits=scilimits,
3905         useOffset=useOffset,
3906         useLocale=useLocale,
3907         useMathText=useMathText,
3908     )
3909 
3910 
3911 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3912 @_copy_docstring_and_deprecators(Axes.tricontour)
3913 def tricontour(*args, **kwargs):
3914     __ret = gca().tricontour(*args, **kwargs)
3915     if __ret._A is not None:  # type: ignore[attr-defined]
3916         sci(__ret)
3917     return __ret
3918 
3919 
3920 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3921 @_copy_docstring_and_deprecators(Axes.tricontourf)
3922 def tricontourf(*args, **kwargs):
3923     __ret = gca().tricontourf(*args, **kwargs)
3924     if __ret._A is not None:  # type: ignore[attr-defined]
3925         sci(__ret)
3926     return __ret
3927 
3928 
3929 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3930 @_copy_docstring_and_deprecators(Axes.tripcolor)
3931 def tripcolor(
3932     *args,
3933     alpha=1.0,
3934     norm=None,
3935     cmap=None,
3936     vmin=None,
3937     vmax=None,
3938     shading="flat",
3939     facecolors=None,
3940     **kwargs,
3941 ):
3942     __ret = gca().tripcolor(
3943         *args,
3944         alpha=alpha,
3945         norm=norm,
3946         cmap=cmap,
3947         vmin=vmin,
3948         vmax=vmax,
3949         shading=shading,
3950         facecolors=facecolors,
3951         **kwargs,
3952     )
3953     sci(__ret)
3954     return __ret
3955 
3956 
3957 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3958 @_copy_docstring_and_deprecators(Axes.triplot)
3959 def triplot(*args, **kwargs):
3960     return gca().triplot(*args, **kwargs)
3961 
3962 
3963 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3964 @_copy_docstring_and_deprecators(Axes.violinplot)
3965 def violinplot(
3966     dataset: ArrayLike | Sequence[ArrayLike],
3967     positions: ArrayLike | None = None,
3968     vert: bool = True,
3969     widths: float | ArrayLike = 0.5,
3970     showmeans: bool = False,
3971     showextrema: bool = True,
3972     showmedians: bool = False,
3973     quantiles: Sequence[float | Sequence[float]] | None = None,
3974     points: int = 100,
3975     bw_method: Literal["scott", "silverman"]
3976     | float
3977     | Callable[[GaussianKDE], float]
3978     | None = None,
3979     *,
3980     data=None,
3981 ) -> dict[str, Collection]:
3982     return gca().violinplot(
3983         dataset,
3984         positions=positions,
3985         vert=vert,
3986         widths=widths,
3987         showmeans=showmeans,
3988         showextrema=showextrema,
3989         showmedians=showmedians,
3990         quantiles=quantiles,
3991         points=points,
3992         bw_method=bw_method,
3993         **({"data": data} if data is not None else {}),
3994     )
3995 
3996 
3997 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
3998 @_copy_docstring_and_deprecators(Axes.vlines)
3999 def vlines(
4000     x: float | ArrayLike,
4001     ymin: float | ArrayLike,
4002     ymax: float | ArrayLike,
4003     colors: ColorType | Sequence[ColorType] | None = None,
4004     linestyles: LineStyleType = "solid",
4005     label: str = "",
4006     *,
4007     data=None,
4008     **kwargs,
4009 ) -> LineCollection:
4010     return gca().vlines(
4011         x,
4012         ymin,
4013         ymax,
4014         colors=colors,
4015         linestyles=linestyles,
4016         label=label,
4017         **({"data": data} if data is not None else {}),
4018         **kwargs,
4019     )
4020 
4021 
4022 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
4023 @_copy_docstring_and_deprecators(Axes.xcorr)
4024 def xcorr(
4025     x: ArrayLike,
4026     y: ArrayLike,
4027     normed: bool = True,
4028     detrend: Callable[[ArrayLike], ArrayLike] = mlab.detrend_none,
4029     usevlines: bool = True,
4030     maxlags: int = 10,
4031     *,
4032     data=None,
4033     **kwargs,
4034 ) -> tuple[np.ndarray, np.ndarray, LineCollection | Line2D, Line2D | None]:
4035     return gca().xcorr(
4036         x,
4037         y,
4038         normed=normed,
4039         detrend=detrend,
4040         usevlines=usevlines,
4041         maxlags=maxlags,
4042         **({"data": data} if data is not None else {}),
4043         **kwargs,
4044     )
4045 
4046 
4047 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
4048 @_copy_docstring_and_deprecators(Axes._sci)
4049 def sci(im: ScalarMappable) -> None:
4050     gca()._sci(im)
4051 
4052 
4053 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
4054 @_copy_docstring_and_deprecators(Axes.set_title)
4055 def title(
4056     label: str,
4057     fontdict: dict[str, Any] | None = None,
4058     loc: Literal["left", "center", "right"] | None = None,
4059     pad: float | None = None,
4060     *,
4061     y: float | None = None,
4062     **kwargs,
4063 ) -> Text:
4064     return gca().set_title(label, fontdict=fontdict, loc=loc, pad=pad, y=y, **kwargs)
4065 
4066 
4067 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
4068 @_copy_docstring_and_deprecators(Axes.set_xlabel)
4069 def xlabel(
4070     xlabel: str,
4071     fontdict: dict[str, Any] | None = None,
4072     labelpad: float | None = None,
4073     *,
4074     loc: Literal["left", "center", "right"] | None = None,
4075     **kwargs,
4076 ) -> Text:
4077     return gca().set_xlabel(
4078         xlabel, fontdict=fontdict, labelpad=labelpad, loc=loc, **kwargs
4079     )
4080 
4081 
4082 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
4083 @_copy_docstring_and_deprecators(Axes.set_ylabel)
4084 def ylabel(
4085     ylabel: str,
4086     fontdict: dict[str, Any] | None = None,
4087     labelpad: float | None = None,
4088     *,
4089     loc: Literal["bottom", "center", "top"] | None = None,
4090     **kwargs,
4091 ) -> Text:
4092     return gca().set_ylabel(
4093         ylabel, fontdict=fontdict, labelpad=labelpad, loc=loc, **kwargs
4094     )
4095 
4096 
4097 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
4098 @_copy_docstring_and_deprecators(Axes.set_xscale)
4099 def xscale(value: str | ScaleBase, **kwargs) -> None:
4100     gca().set_xscale(value, **kwargs)
4101 
4102 
4103 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
4104 @_copy_docstring_and_deprecators(Axes.set_yscale)
4105 def yscale(value: str | ScaleBase, **kwargs) -> None:
4106     gca().set_yscale(value, **kwargs)
4107 
4108 
4109 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
4110 def autumn() -> None:
4111     """
4112     Set the colormap to 'autumn'.
4113 
4114     This changes the default colormap as well as the colormap of the current
4115     image if there is one. See ``help(colormaps)`` for more information.
4116     """
4117     set_cmap("autumn")
4118 
4119 
4120 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
4121 def bone() -> None:
4122     """
4123     Set the colormap to 'bone'.
4124 
4125     This changes the default colormap as well as the colormap of the current
4126     image if there is one. See ``help(colormaps)`` for more information.
4127     """
4128     set_cmap("bone")
4129 
4130 
4131 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
4132 def cool() -> None:
4133     """
4134     Set the colormap to 'cool'.
4135 
4136     This changes the default colormap as well as the colormap of the current
4137     image if there is one. See ``help(colormaps)`` for more information.
4138     """
4139     set_cmap("cool")
4140 
4141 
4142 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
4143 def copper() -> None:
4144     """
4145     Set the colormap to 'copper'.
4146 
4147     This changes the default colormap as well as the colormap of the current
4148     image if there is one. See ``help(colormaps)`` for more information.
4149     """
4150     set_cmap("copper")
4151 
4152 
4153 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
4154 def flag() -> None:
4155     """
4156     Set the colormap to 'flag'.
4157 
4158     This changes the default colormap as well as the colormap of the current
4159     image if there is one. See ``help(colormaps)`` for more information.
4160     """
4161     set_cmap("flag")
4162 
4163 
4164 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
4165 def gray() -> None:
4166     """
4167     Set the colormap to 'gray'.
4168 
4169     This changes the default colormap as well as the colormap of the current
4170     image if there is one. See ``help(colormaps)`` for more information.
4171     """
4172     set_cmap("gray")
4173 
4174 
4175 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
4176 def hot() -> None:
4177     """
4178     Set the colormap to 'hot'.
4179 
4180     This changes the default colormap as well as the colormap of the current
4181     image if there is one. See ``help(colormaps)`` for more information.
4182     """
4183     set_cmap("hot")
4184 
4185 
4186 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
4187 def hsv() -> None:
4188     """
4189     Set the colormap to 'hsv'.
4190 
4191     This changes the default colormap as well as the colormap of the current
4192     image if there is one. See ``help(colormaps)`` for more information.
4193     """
4194     set_cmap("hsv")
4195 
4196 
4197 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
4198 def jet() -> None:
4199     """
4200     Set the colormap to 'jet'.
4201 
4202     This changes the default colormap as well as the colormap of the current
4203     image if there is one. See ``help(colormaps)`` for more information.
4204     """
4205     set_cmap("jet")
4206 
4207 
4208 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
4209 def pink() -> None:
4210     """
4211     Set the colormap to 'pink'.
4212 
4213     This changes the default colormap as well as the colormap of the current
4214     image if there is one. See ``help(colormaps)`` for more information.
4215     """
4216     set_cmap("pink")
4217 
4218 
4219 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
4220 def prism() -> None:
4221     """
4222     Set the colormap to 'prism'.
4223 
4224     This changes the default colormap as well as the colormap of the current
4225     image if there is one. See ``help(colormaps)`` for more information.
4226     """
4227     set_cmap("prism")
4228 
4229 
4230 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
4231 def spring() -> None:
4232     """
4233     Set the colormap to 'spring'.
4234 
4235     This changes the default colormap as well as the colormap of the current
4236     image if there is one. See ``help(colormaps)`` for more information.
4237     """
4238     set_cmap("spring")
4239 
4240 
4241 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
4242 def summer() -> None:
4243     """
4244     Set the colormap to 'summer'.
4245 
4246     This changes the default colormap as well as the colormap of the current
4247     image if there is one. See ``help(colormaps)`` for more information.
4248     """
4249     set_cmap("summer")
4250 
4251 
4252 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
4253 def winter() -> None:
4254     """
4255     Set the colormap to 'winter'.
4256 
4257     This changes the default colormap as well as the colormap of the current
4258     image if there is one. See ``help(colormaps)`` for more information.
4259     """
4260     set_cmap("winter")
4261 
4262 
4263 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
4264 def magma() -> None:
4265     """
4266     Set the colormap to 'magma'.
4267 
4268     This changes the default colormap as well as the colormap of the current
4269     image if there is one. See ``help(colormaps)`` for more information.
4270     """
4271     set_cmap("magma")
4272 
4273 
4274 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
4275 def inferno() -> None:
4276     """
4277     Set the colormap to 'inferno'.
4278 
4279     This changes the default colormap as well as the colormap of the current
4280     image if there is one. See ``help(colormaps)`` for more information.
4281     """
4282     set_cmap("inferno")
4283 
4284 
4285 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
4286 def plasma() -> None:
4287     """
4288     Set the colormap to 'plasma'.
4289 
4290     This changes the default colormap as well as the colormap of the current
4291     image if there is one. See ``help(colormaps)`` for more information.
4292     """
4293     set_cmap("plasma")
4294 
4295 
4296 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
4297 def viridis() -> None:
4298     """
4299     Set the colormap to 'viridis'.
4300 
4301     This changes the default colormap as well as the colormap of the current
4302     image if there is one. See ``help(colormaps)`` for more information.
4303     """
4304     set_cmap("viridis")
4305 
4306 
4307 # Autogenerated by boilerplate.py.  Do not edit as changes will be lost.
4308 def nipy_spectral() -> None:
4309     """
4310     Set the colormap to 'nipy_spectral'.
4311 
4312     This changes the default colormap as well as the colormap of the current
4313     image if there is one. See ``help(colormaps)`` for more information.
4314     """
4315     set_cmap("nipy_spectral")

</code><intended_behavior>These functions should ensure switching interactive mode on or off does not inadvertently close GUI windows that were intended to remain open across backend transitions, by adding context awareness.</intended_behavior>]
2025-10-18 14:39:13.904 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-18 14:39:13.904 | INFO     | Search-only: skipping patch selection
2025-10-18 14:39:13.989 | INFO     | Task matplotlib__matplotlib-26472 completed successfully.
2025-10-18 14:39:13.990 | INFO     | No patch generated. You can try running ACR again.
