[
    {
        "rel_file_path": "django/contrib/admin/options.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__5.0/django/contrib/admin/options.py",
        "start": 614,
        "end": 2282,
        "class_name": "ModelAdmin",
        "method_name": null,
        "code": "614 class ModelAdmin(BaseModelAdmin):\n615     \"\"\"Encapsulate all admin options and functionality for a given model.\"\"\"\n616 \n617     list_display = (\"__str__\",)\n618     list_display_links = ()\n619     list_filter = ()\n620     list_select_related = False\n621     list_per_page = 100\n622     list_max_show_all = 200\n623     list_editable = ()\n624     search_fields = ()\n625     search_help_text = None\n626     date_hierarchy = None\n627     save_as = False\n628     save_as_continue = True\n629     save_on_top = False\n630     paginator = Paginator\n631     preserve_filters = True\n632     inlines = ()\n633 \n634     # Custom templates (designed to be over-ridden in subclasses)\n635     add_form_template = None\n636     change_form_template = None\n637     change_list_template = None\n638     delete_confirmation_template = None\n639     delete_selected_confirmation_template = None\n640     object_history_template = None\n641     popup_response_template = None\n642 \n643     # Actions\n644     actions = ()\n645     action_form = helpers.ActionForm\n646     actions_on_top = True\n647     actions_on_bottom = False\n648     actions_selection_counter = True\n649     checks_class = ModelAdminChecks\n650 \n651     def __init__(self, model, admin_site):\n652         self.model = model\n653         self.opts = model._meta\n654         self.admin_site = admin_site\n655         super().__init__()\n656 \n657     def __str__(self):\n658         return \"%s.%s\" % (self.opts.app_label, self.__class__.__name__)\n659 \n660     def __repr__(self):\n661         return (\n662             f\"<{self.__class__.__qualname__}: model={self.model.__qualname__} \"\n663             f\"site={self.admin_site!r}>\"\n664         )\n665 \n666     def get_inline_instances(self, request, obj=None):\n667         inline_instances = []\n668         for inline_class in self.get_inlines(request, obj):\n669             inline = inline_class(self.model, self.admin_site)\n670             if request:\n671                 if not (\n672                     inline.has_view_or_change_permission(request, obj)\n673                     or inline.has_add_permission(request, obj)\n674                     or inline.has_delete_permission(request, obj)\n675                 ):\n676                     continue\n677                 if not inline.has_add_permission(request, obj):\n678                     inline.max_num = 0\n679             inline_instances.append(inline)\n680 \n681         return inline_instances\n682 \n683     def get_urls(self):\n684         from django.urls import path\n685 \n686         def wrap(view):\n687             def wrapper(*args, **kwargs):\n688                 return self.admin_site.admin_view(view)(*args, **kwargs)\n689 \n690             wrapper.model_admin = self\n691             return update_wrapper(wrapper, view)\n692 \n693         info = self.opts.app_label, self.opts.model_name\n694 \n695         return [\n696             path(\"\", wrap(self.changelist_view), name=\"%s_%s_changelist\" % info),\n697             path(\"add/\", wrap(self.add_view), name=\"%s_%s_add\" % info),\n698             path(\n699                 \"<path:object_id>/history/\",\n700                 wrap(self.history_view),\n701                 name=\"%s_%s_history\" % info,\n702             ),\n703             path(\n704                 \"<path:object_id>/delete/\",\n705                 wrap(self.delete_view),\n706                 name=\"%s_%s_delete\" % info,\n707             ),\n708             path(\n709                 \"<path:object_id>/change/\",\n710                 wrap(self.change_view),\n711                 name=\"%s_%s_change\" % info,\n712             ),\n713             # For backwards compatibility (was the change url before 1.9)\n714             path(\n715                 \"<path:object_id>/\",\n716                 wrap(\n717                     RedirectView.as_view(\n718                         pattern_name=\"%s:%s_%s_change\"\n719                         % ((self.admin_site.name,) + info)\n720                     )\n721                 ),\n722             ),\n723         ]\n724 \n725     @property\n726     def urls(self):\n727         return self.get_urls()\n728 \n729     @property\n730     def media(self):\n731         extra = \"\" if settings.DEBUG else \".min\"\n732         js = [\n733             \"vendor/jquery/jquery%s.js\" % extra,\n734             \"jquery.init.js\",\n735             \"core.js\",\n736             \"admin/RelatedObjectLookups.js\",\n737             \"actions.js\",\n738             \"urlify.js\",\n739             \"prepopulate.js\",\n740             \"vendor/xregexp/xregexp%s.js\" % extra,\n741         ]\n742         return forms.Media(js=[\"admin/js/%s\" % url for url in js])\n743 \n744     def get_model_perms(self, request):\n745         \"\"\"\n746         Return a dict of all perms for this model. This dict has the keys\n747         ``add``, ``change``, ``delete``, and ``view`` mapping to the True/False\n748         for each of those actions.\n749         \"\"\"\n750         return {\n751             \"add\": self.has_add_permission(request),\n752             \"change\": self.has_change_permission(request),\n753             \"delete\": self.has_delete_permission(request),\n754             \"view\": self.has_view_permission(request),\n755         }\n756 \n757     def _get_form_for_get_fields(self, request, obj):\n758         return self.get_form(request, obj, fields=None)\n759 \n760     def get_form(self, request, obj=None, change=False, **kwargs):\n761         \"\"\"\n762         Return a Form class for use in the admin add view. This is used by\n763         add_view and change_view.\n764         \"\"\"\n765         if \"fields\" in kwargs:\n766             fields = kwargs.pop(\"fields\")\n767         else:\n768             fields = flatten_fieldsets(self.get_fieldsets(request, obj))\n769         excluded = self.get_exclude(request, obj)\n770         exclude = [] if excluded is None else list(excluded)\n771         readonly_fields = self.get_readonly_fields(request, obj)\n772         exclude.extend(readonly_fields)\n773         # Exclude all fields if it's a change form and the user doesn't have\n774         # the change permission.\n775         if (\n776             change\n777             and hasattr(request, \"user\")\n778             and not self.has_change_permission(request, obj)\n779         ):\n780             exclude.extend(fields)\n781         if excluded is None and hasattr(self.form, \"_meta\") and self.form._meta.exclude:\n782             # Take the custom ModelForm's Meta.exclude into account only if the\n783             # ModelAdmin doesn't define its own.\n784             exclude.extend(self.form._meta.exclude)\n785         # if exclude is an empty list we pass None to be consistent with the\n786         # default on modelform_factory\n787         exclude = exclude or None\n788 \n789         # Remove declared form fields which are in readonly_fields.\n790         new_attrs = dict.fromkeys(\n791             f for f in readonly_fields if f in self.form.declared_fields\n792         )\n793         form = type(self.form.__name__, (self.form,), new_attrs)\n794 \n795         defaults = {\n796             \"form\": form,\n797             \"fields\": fields,\n798             \"exclude\": exclude,\n799             \"formfield_callback\": partial(self.formfield_for_dbfield, request=request),\n800             **kwargs,\n801         }\n802 \n803         if defaults[\"fields\"] is None and not modelform_defines_fields(\n804             defaults[\"form\"]\n805         ):\n806             defaults[\"fields\"] = forms.ALL_FIELDS\n807 \n808         try:\n809             return modelform_factory(self.model, **defaults)\n810         except FieldError as e:\n811             raise FieldError(\n812                 \"%s. Check fields/fieldsets/exclude attributes of class %s.\"\n813                 % (e, self.__class__.__name__)\n814             )\n815 \n816     def get_changelist(self, request, **kwargs):\n817         \"\"\"\n818         Return the ChangeList class for use on the changelist page.\n819         \"\"\"\n820         from django.contrib.admin.views.main import ChangeList\n821 \n822         return ChangeList\n823 \n824     def get_changelist_instance(self, request):\n825         \"\"\"\n826         Return a `ChangeList` instance based on `request`. May raise\n827         `IncorrectLookupParameters`.\n828         \"\"\"\n829         list_display = self.get_list_display(request)\n830         list_display_links = self.get_list_display_links(request, list_display)\n831         # Add the action checkboxes if any actions are available.\n832         if self.get_actions(request):\n833             list_display = [\"action_checkbox\", *list_display]\n834         sortable_by = self.get_sortable_by(request)\n835         ChangeList = self.get_changelist(request)\n836         return ChangeList(\n837             request,\n838             self.model,\n839             list_display,\n840             list_display_links,\n841             self.get_list_filter(request),\n842             self.date_hierarchy,\n843             self.get_search_fields(request),\n844             self.get_list_select_related(request),\n845             self.list_per_page,\n846             self.list_max_show_all,\n847             self.list_editable,\n848             self,\n849             sortable_by,\n850             self.search_help_text,\n851         )\n852 \n853     def get_object(self, request, object_id, from_field=None):\n854         \"\"\"\n855         Return an instance matching the field and value provided, the primary\n856         key is used if no field is provided. Return ``None`` if no match is\n857         found or the object_id fails validation.\n858         \"\"\"\n859         queryset = self.get_queryset(request)\n860         model = queryset.model\n861         field = (\n862             model._meta.pk if from_field is None else model._meta.get_field(from_field)\n863         )\n864         try:\n865             object_id = field.to_python(object_id)\n866             return queryset.get(**{field.name: object_id})\n867         except (model.DoesNotExist, ValidationError, ValueError):\n868             return None\n869 \n870     def get_changelist_form(self, request, **kwargs):\n871         \"\"\"\n872         Return a Form class for use in the Formset on the changelist page.\n873         \"\"\"\n874         defaults = {\n875             \"formfield_callback\": partial(self.formfield_for_dbfield, request=request),\n876             **kwargs,\n877         }\n878         if defaults.get(\"fields\") is None and not modelform_defines_fields(\n879             defaults.get(\"form\")\n880         ):\n881             defaults[\"fields\"] = forms.ALL_FIELDS\n882 \n883         return modelform_factory(self.model, **defaults)\n884 \n885     def get_changelist_formset(self, request, **kwargs):\n886         \"\"\"\n887         Return a FormSet class for use on the changelist page if list_editable\n888         is used.\n889         \"\"\"\n890         defaults = {\n891             \"formfield_callback\": partial(self.formfield_for_dbfield, request=request),\n892             **kwargs,\n893         }\n894         return modelformset_factory(\n895             self.model,\n896             self.get_changelist_form(request),\n897             extra=0,\n898             fields=self.list_editable,\n899             **defaults,\n900         )\n901 \n902     def get_formsets_with_inlines(self, request, obj=None):\n903         \"\"\"\n904         Yield formsets and the corresponding inlines.\n905         \"\"\"\n906         for inline in self.get_inline_instances(request, obj):\n907             yield inline.get_formset(request, obj), inline\n908 \n909     def get_paginator(\n910         self, request, queryset, per_page, orphans=0, allow_empty_first_page=True\n911     ):\n912         return self.paginator(queryset, per_page, orphans, allow_empty_first_page)\n913 \n914     def log_addition(self, request, obj, message):\n915         \"\"\"\n916         Log that an object has been successfully added.\n917 \n918         The default implementation creates an admin LogEntry object.\n919         \"\"\"\n920         from django.contrib.admin.models import ADDITION, LogEntry\n921 \n922         return LogEntry.objects.log_action(\n923             user_id=request.user.pk,\n924             content_type_id=get_content_type_for_model(obj).pk,\n925             object_id=obj.pk,\n926             object_repr=str(obj),\n927             action_flag=ADDITION,\n928             change_message=message,\n929         )\n930 \n931     def log_change(self, request, obj, message):\n932         \"\"\"\n933         Log that an object has been successfully changed.\n934 \n935         The default implementation creates an admin LogEntry object.\n936         \"\"\"\n937         from django.contrib.admin.models import CHANGE, LogEntry\n938 \n939         return LogEntry.objects.log_action(\n940             user_id=request.user.pk,\n941             content_type_id=get_content_type_for_model(obj).pk,\n942             object_id=obj.pk,\n943             object_repr=str(obj),\n944             action_flag=CHANGE,\n945             change_message=message,\n946         )\n947 \n948     def log_deletion(self, request, obj, object_repr):\n949         \"\"\"\n950         Log that an object will be deleted. Note that this method must be\n951         called before the deletion.\n952 \n953         The default implementation creates an admin LogEntry object.\n954         \"\"\"\n955         from django.contrib.admin.models import DELETION, LogEntry\n956 \n957         return LogEntry.objects.log_action(\n958             user_id=request.user.pk,\n959             content_type_id=get_content_type_for_model(obj).pk,\n960             object_id=obj.pk,\n961             object_repr=object_repr,\n962             action_flag=DELETION,\n963         )\n964 \n965     @display(description=mark_safe('<input type=\"checkbox\" id=\"action-toggle\">'))\n966     def action_checkbox(self, obj):\n967         \"\"\"\n968         A list_display column containing a checkbox widget.\n969         \"\"\"\n970         return helpers.checkbox.render(helpers.ACTION_CHECKBOX_NAME, str(obj.pk))\n971 \n972     @staticmethod\n973     def _get_action_description(func, name):\n974         return getattr(func, \"short_description\", capfirst(name.replace(\"_\", \" \")))\n975 \n976     def _get_base_actions(self):\n977         \"\"\"Return the list of actions, prior to any request-based filtering.\"\"\"\n978         actions = []\n979         base_actions = (self.get_action(action) for action in self.actions or [])\n980         # get_action might have returned None, so filter any of those out.\n981         base_actions = [action for action in base_actions if action]\n982         base_action_names = {name for _, name, _ in base_actions}\n983 \n984         # Gather actions from the admin site first\n985         for name, func in self.admin_site.actions:\n986             if name in base_action_names:\n987                 continue\n988             description = self._get_action_description(func, name)\n989             actions.append((func, name, description))\n990         # Add actions from this ModelAdmin.\n991         actions.extend(base_actions)\n992         return actions\n993 \n994     def _filter_actions_by_permissions(self, request, actions):\n995         \"\"\"Filter out any actions that the user doesn't have access to.\"\"\"\n996         filtered_actions = []\n997         for action in actions:\n998             callable = action[0]\n999             if not hasattr(callable, \"allowed_permissions\"):\n1000                 filtered_actions.append(action)\n1001                 continue\n1002             permission_checks = (\n1003                 getattr(self, \"has_%s_permission\" % permission)\n1004                 for permission in callable.allowed_permissions\n1005             )\n1006             if any(has_permission(request) for has_permission in permission_checks):\n1007                 filtered_actions.append(action)\n1008         return filtered_actions\n1009 \n1010     def get_actions(self, request):\n1011         \"\"\"\n1012         Return a dictionary mapping the names of all actions for this\n1013         ModelAdmin to a tuple of (callable, name, description) for each action.\n1014         \"\"\"\n1015         # If self.actions is set to None that means actions are disabled on\n1016         # this page.\n1017         if self.actions is None or IS_POPUP_VAR in request.GET:\n1018             return {}\n1019         actions = self._filter_actions_by_permissions(request, self._get_base_actions())\n1020         return {name: (func, name, desc) for func, name, desc in actions}\n1021 \n1022     def get_action_choices(self, request, default_choices=models.BLANK_CHOICE_DASH):\n1023         \"\"\"\n1024         Return a list of choices for use in a form object.  Each choice is a\n1025         tuple (name, description).\n1026         \"\"\"\n1027         choices = [] + default_choices\n1028         for func, name, description in self.get_actions(request).values():\n1029             choice = (name, description % model_format_dict(self.opts))\n1030             choices.append(choice)\n1031         return choices\n1032 \n1033     def get_action(self, action):\n1034         \"\"\"\n1035         Return a given action from a parameter, which can either be a callable,\n1036         or the name of a method on the ModelAdmin.  Return is a tuple of\n1037         (callable, name, description).\n1038         \"\"\"\n1039         # If the action is a callable, just use it.\n1040         if callable(action):\n1041             func = action\n1042             action = action.__name__\n1043 \n1044         # Next, look for a method. Grab it off self.__class__ to get an unbound\n1045         # method instead of a bound one; this ensures that the calling\n1046         # conventions are the same for functions and methods.\n1047         elif hasattr(self.__class__, action):\n1048             func = getattr(self.__class__, action)\n1049 \n1050         # Finally, look for a named method on the admin site\n1051         else:\n1052             try:\n1053                 func = self.admin_site.get_action(action)\n1054             except KeyError:\n1055                 return None\n1056 \n1057         description = self._get_action_description(func, action)\n1058         return func, action, description\n1059 \n1060     def get_list_display(self, request):\n1061         \"\"\"\n1062         Return a sequence containing the fields to be displayed on the\n1063         changelist.\n1064         \"\"\"\n1065         return self.list_display\n1066 \n1067     def get_list_display_links(self, request, list_display):\n1068         \"\"\"\n1069         Return a sequence containing the fields to be displayed as links\n1070         on the changelist. The list_display parameter is the list of fields\n1071         returned by get_list_display().\n1072         \"\"\"\n1073         if (\n1074             self.list_display_links\n1075             or self.list_display_links is None\n1076             or not list_display\n1077         ):\n1078             return self.list_display_links\n1079         else:\n1080             # Use only the first item in list_display as link\n1081             return list(list_display)[:1]\n1082 \n1083     def get_list_filter(self, request):\n1084         \"\"\"\n1085         Return a sequence containing the fields to be displayed as filters in\n1086         the right sidebar of the changelist page.\n1087         \"\"\"\n1088         return self.list_filter\n1089 \n1090     def get_list_select_related(self, request):\n1091         \"\"\"\n1092         Return a list of fields to add to the select_related() part of the\n1093         changelist items query.\n1094         \"\"\"\n1095         return self.list_select_related\n1096 \n1097     def get_search_fields(self, request):\n1098         \"\"\"\n1099         Return a sequence containing the fields to be searched whenever\n1100         somebody submits a search query.\n1101         \"\"\"\n1102         return self.search_fields\n1103 \n1104     def get_search_results(self, request, queryset, search_term):\n1105         \"\"\"\n1106         Return a tuple containing a queryset to implement the search\n1107         and a boolean indicating if the results may contain duplicates.\n1108         \"\"\"\n1109 \n1110         # Apply keyword searches.\n1111         def construct_search(field_name):\n1112             if field_name.startswith(\"^\"):\n1113                 return \"%s__istartswith\" % field_name.removeprefix(\"^\")\n1114             elif field_name.startswith(\"=\"):\n1115                 return \"%s__iexact\" % field_name.removeprefix(\"=\")\n1116             elif field_name.startswith(\"@\"):\n1117                 return \"%s__search\" % field_name.removeprefix(\"@\")\n1118             # Use field_name if it includes a lookup.\n1119             opts = queryset.model._meta\n1120             lookup_fields = field_name.split(LOOKUP_SEP)\n1121             # Go through the fields, following all relations.\n1122             prev_field = None\n1123             for path_part in lookup_fields:\n1124                 if path_part == \"pk\":\n1125                     path_part = opts.pk.name\n1126                 try:\n1127                     field = opts.get_field(path_part)\n1128                 except FieldDoesNotExist:\n1129                     # Use valid query lookups.\n1130                     if prev_field and prev_field.get_lookup(path_part):\n1131                         return field_name\n1132                 else:\n1133                     prev_field = field\n1134                     if hasattr(field, \"path_infos\"):\n1135                         # Update opts to follow the relation.\n1136                         opts = field.path_infos[-1].to_opts\n1137             # Otherwise, use the field with icontains.\n1138             return \"%s__icontains\" % field_name\n1139 \n1140         may_have_duplicates = False\n1141         search_fields = self.get_search_fields(request)\n1142         if search_fields and search_term:\n1143             orm_lookups = [\n1144                 construct_search(str(search_field)) for search_field in search_fields\n1145             ]\n1146             term_queries = []\n1147             for bit in smart_split(search_term):\n1148                 if bit.startswith(('\"', \"'\")) and bit[0] == bit[-1]:\n1149                     bit = unescape_string_literal(bit)\n1150                 or_queries = models.Q.create(\n1151                     [(orm_lookup, bit) for orm_lookup in orm_lookups],\n1152                     connector=models.Q.OR,\n1153                 )\n1154                 term_queries.append(or_queries)\n1155             queryset = queryset.filter(models.Q.create(term_queries))\n1156             may_have_duplicates |= any(\n1157                 lookup_spawns_duplicates(self.opts, search_spec)\n1158                 for search_spec in orm_lookups\n1159             )\n1160         return queryset, may_have_duplicates\n1161 \n1162     def get_preserved_filters(self, request):\n1163         \"\"\"\n1164         Return the preserved filters querystring.\n1165         \"\"\"\n1166         match = request.resolver_match\n1167         if self.preserve_filters and match:\n1168             current_url = \"%s:%s\" % (match.app_name, match.url_name)\n1169             changelist_url = \"admin:%s_%s_changelist\" % (\n1170                 self.opts.app_label,\n1171                 self.opts.model_name,\n1172             )\n1173             if current_url == changelist_url:\n1174                 preserved_filters = request.GET.urlencode()\n1175             else:\n1176                 preserved_filters = request.GET.get(\"_changelist_filters\")\n1177 \n1178             if preserved_filters:\n1179                 return urlencode({\"_changelist_filters\": preserved_filters})\n1180         return \"\"\n1181 \n1182     def construct_change_message(self, request, form, formsets, add=False):\n1183         \"\"\"\n1184         Construct a JSON structure describing changes from a changed object.\n1185         \"\"\"\n1186         return construct_change_message(form, formsets, add)\n1187 \n1188     def message_user(\n1189         self, request, message, level=messages.INFO, extra_tags=\"\", fail_silently=False\n1190     ):\n1191         \"\"\"\n1192         Send a message to the user. The default implementation\n1193         posts a message using the django.contrib.messages backend.\n1194 \n1195         Exposes almost the same API as messages.add_message(), but accepts the\n1196         positional arguments in a different order to maintain backwards\n1197         compatibility. For convenience, it accepts the `level` argument as\n1198         a string rather than the usual level number.\n1199         \"\"\"\n1200         if not isinstance(level, int):\n1201             # attempt to get the level if passed a string\n1202             try:\n1203                 level = getattr(messages.constants, level.upper())\n1204             except AttributeError:\n1205                 levels = messages.constants.DEFAULT_TAGS.values()\n1206                 levels_repr = \", \".join(\"`%s`\" % level for level in levels)\n1207                 raise ValueError(\n1208                     \"Bad message level string: `%s`. Possible values are: %s\"\n1209                     % (level, levels_repr)\n1210                 )\n1211 \n1212         messages.add_message(\n1213             request, level, message, extra_tags=extra_tags, fail_silently=fail_silently\n1214         )\n1215 \n1216     def save_form(self, request, form, change):\n1217         \"\"\"\n1218         Given a ModelForm return an unsaved instance. ``change`` is True if\n1219         the object is being changed, and False if it's being added.\n1220         \"\"\"\n1221         return form.save(commit=False)\n1222 \n1223     def save_model(self, request, obj, form, change):\n1224         \"\"\"\n1225         Given a model instance save it to the database.\n1226         \"\"\"\n1227         obj.save()\n1228 \n1229     def delete_model(self, request, obj):\n1230         \"\"\"\n1231         Given a model instance delete it from the database.\n1232         \"\"\"\n1233         obj.delete()\n1234 \n1235     def delete_queryset(self, request, queryset):\n1236         \"\"\"Given a queryset, delete it from the database.\"\"\"\n1237         queryset.delete()\n1238 \n1239     def save_formset(self, request, form, formset, change):\n1240         \"\"\"\n1241         Given an inline formset save it to the database.\n1242         \"\"\"\n1243         formset.save()\n1244 \n1245     def save_related(self, request, form, formsets, change):\n1246         \"\"\"\n1247         Given the ``HttpRequest``, the parent ``ModelForm`` instance, the\n1248         list of inline formsets and a boolean value based on whether the\n1249         parent is being added or changed, save the related objects to the\n1250         database. Note that at this point save_form() and save_model() have\n1251         already been called.\n1252         \"\"\"\n1253         form.save_m2m()\n1254         for formset in formsets:\n1255             self.save_formset(request, form, formset, change=change)\n1256 \n1257     def render_change_form(\n1258         self, request, context, add=False, change=False, form_url=\"\", obj=None\n1259     ):\n1260         app_label = self.opts.app_label\n1261         preserved_filters = self.get_preserved_filters(request)\n1262         form_url = add_preserved_filters(\n1263             {\"preserved_filters\": preserved_filters, \"opts\": self.opts}, form_url\n1264         )\n1265         view_on_site_url = self.get_view_on_site_url(obj)\n1266         has_editable_inline_admin_formsets = False\n1267         for inline in context[\"inline_admin_formsets\"]:\n1268             if (\n1269                 inline.has_add_permission\n1270                 or inline.has_change_permission\n1271                 or inline.has_delete_permission\n1272             ):\n1273                 has_editable_inline_admin_formsets = True\n1274                 break\n1275         context.update(\n1276             {\n1277                 \"add\": add,\n1278                 \"change\": change,\n1279                 \"has_view_permission\": self.has_view_permission(request, obj),\n1280                 \"has_add_permission\": self.has_add_permission(request),\n1281                 \"has_change_permission\": self.has_change_permission(request, obj),\n1282                 \"has_delete_permission\": self.has_delete_permission(request, obj),\n1283                 \"has_editable_inline_admin_formsets\": (\n1284                     has_editable_inline_admin_formsets\n1285                 ),\n1286                 \"has_file_field\": context[\"adminform\"].form.is_multipart()\n1287                 or any(\n1288                     admin_formset.formset.is_multipart()\n1289                     for admin_formset in context[\"inline_admin_formsets\"]\n1290                 ),\n1291                 \"has_absolute_url\": view_on_site_url is not None,\n1292                 \"absolute_url\": view_on_site_url,\n1293                 \"form_url\": form_url,\n1294                 \"opts\": self.opts,\n1295                 \"content_type_id\": get_content_type_for_model(self.model).pk,\n1296                 \"save_as\": self.save_as,\n1297                 \"save_on_top\": self.save_on_top,\n1298                 \"to_field_var\": TO_FIELD_VAR,\n1299                 \"is_popup_var\": IS_POPUP_VAR,\n1300                 \"app_label\": app_label,\n1301             }\n1302         )\n1303         if add and self.add_form_template is not None:\n1304             form_template = self.add_form_template\n1305         else:\n1306             form_template = self.change_form_template\n1307 \n1308         request.current_app = self.admin_site.name\n1309 \n1310         return TemplateResponse(\n1311             request,\n1312             form_template\n1313             or [\n1314                 \"admin/%s/%s/change_form.html\" % (app_label, self.opts.model_name),\n1315                 \"admin/%s/change_form.html\" % app_label,\n1316                 \"admin/change_form.html\",\n1317             ],\n1318             context,\n1319         )\n1320 \n1321     def response_add(self, request, obj, post_url_continue=None):\n1322         \"\"\"\n1323         Determine the HttpResponse for the add_view stage.\n1324         \"\"\"\n1325         opts = obj._meta\n1326         preserved_filters = self.get_preserved_filters(request)\n1327         obj_url = reverse(\n1328             \"admin:%s_%s_change\" % (opts.app_label, opts.model_name),\n1329             args=(quote(obj.pk),),\n1330             current_app=self.admin_site.name,\n1331         )\n1332         # Add a link to the object's change form if the user can edit the obj.\n1333         if self.has_change_permission(request, obj):\n1334             obj_repr = format_html('<a href=\"{}\">{}</a>', urlquote(obj_url), obj)\n1335         else:\n1336             obj_repr = str(obj)\n1337         msg_dict = {\n1338             \"name\": opts.verbose_name,\n1339             \"obj\": obj_repr,\n1340         }\n1341         # Here, we distinguish between different save types by checking for\n1342         # the presence of keys in request.POST.\n1343 \n1344         if IS_POPUP_VAR in request.POST:\n1345             to_field = request.POST.get(TO_FIELD_VAR)\n1346             if to_field:\n1347                 attr = str(to_field)\n1348             else:\n1349                 attr = obj._meta.pk.attname\n1350             value = obj.serializable_value(attr)\n1351             popup_response_data = json.dumps(\n1352                 {\n1353                     \"value\": str(value),\n1354                     \"obj\": str(obj),\n1355                 }\n1356             )\n1357             return TemplateResponse(\n1358                 request,\n1359                 self.popup_response_template\n1360                 or [\n1361                     \"admin/%s/%s/popup_response.html\"\n1362                     % (opts.app_label, opts.model_name),\n1363                     \"admin/%s/popup_response.html\" % opts.app_label,\n1364                     \"admin/popup_response.html\",\n1365                 ],\n1366                 {\n1367                     \"popup_response_data\": popup_response_data,\n1368                 },\n1369             )\n1370 \n1371         elif \"_continue\" in request.POST or (\n1372             # Redirecting after \"Save as new\".\n1373             \"_saveasnew\" in request.POST\n1374             and self.save_as_continue\n1375             and self.has_change_permission(request, obj)\n1376         ):\n1377             msg = _(\"The {name} \u201c{obj}\u201d was added successfully.\")\n1378             if self.has_change_permission(request, obj):\n1379                 msg += \" \" + _(\"You may edit it again below.\")\n1380             self.message_user(request, format_html(msg, **msg_dict), messages.SUCCESS)\n1381             if post_url_continue is None:\n1382                 post_url_continue = obj_url\n1383             post_url_continue = add_preserved_filters(\n1384                 {\"preserved_filters\": preserved_filters, \"opts\": opts},\n1385                 post_url_continue,\n1386             )\n1387             return HttpResponseRedirect(post_url_continue)\n1388 \n1389         elif \"_addanother\" in request.POST:\n1390             msg = format_html(\n1391                 _(\n1392                     \"The {name} \u201c{obj}\u201d was added successfully. You may add another \"\n1393                     \"{name} below.\"\n1394                 ),\n1395                 **msg_dict,\n1396             )\n1397             self.message_user(request, msg, messages.SUCCESS)\n1398             redirect_url = request.path\n1399             redirect_url = add_preserved_filters(\n1400                 {\"preserved_filters\": preserved_filters, \"opts\": opts}, redirect_url\n1401             )\n1402             return HttpResponseRedirect(redirect_url)\n1403 \n1404         else:\n1405             msg = format_html(\n1406                 _(\"The {name} \u201c{obj}\u201d was added successfully.\"), **msg_dict\n1407             )\n1408             self.message_user(request, msg, messages.SUCCESS)\n1409             return self.response_post_save_add(request, obj)\n1410 \n1411     def response_change(self, request, obj):\n1412         \"\"\"\n1413         Determine the HttpResponse for the change_view stage.\n1414         \"\"\"\n1415 \n1416         if IS_POPUP_VAR in request.POST:\n1417             opts = obj._meta\n1418             to_field = request.POST.get(TO_FIELD_VAR)\n1419             attr = str(to_field) if to_field else opts.pk.attname\n1420             value = request.resolver_match.kwargs[\"object_id\"]\n1421             new_value = obj.serializable_value(attr)\n1422             popup_response_data = json.dumps(\n1423                 {\n1424                     \"action\": \"change\",\n1425                     \"value\": str(value),\n1426                     \"obj\": str(obj),\n1427                     \"new_value\": str(new_value),\n1428                 }\n1429             )\n1430             return TemplateResponse(\n1431                 request,\n1432                 self.popup_response_template\n1433                 or [\n1434                     \"admin/%s/%s/popup_response.html\"\n1435                     % (opts.app_label, opts.model_name),\n1436                     \"admin/%s/popup_response.html\" % opts.app_label,\n1437                     \"admin/popup_response.html\",\n1438                 ],\n1439                 {\n1440                     \"popup_response_data\": popup_response_data,\n1441                 },\n1442             )\n1443 \n1444         opts = self.opts\n1445         preserved_filters = self.get_preserved_filters(request)\n1446 \n1447         msg_dict = {\n1448             \"name\": opts.verbose_name,\n1449             \"obj\": format_html('<a href=\"{}\">{}</a>', urlquote(request.path), obj),\n1450         }\n1451         if \"_continue\" in request.POST:\n1452             msg = format_html(\n1453                 _(\n1454                     \"The {name} \u201c{obj}\u201d was changed successfully. You may edit it \"\n1455                     \"again below.\"\n1456                 ),\n1457                 **msg_dict,\n1458             )\n1459             self.message_user(request, msg, messages.SUCCESS)\n1460             redirect_url = request.path\n1461             redirect_url = add_preserved_filters(\n1462                 {\"preserved_filters\": preserved_filters, \"opts\": opts}, redirect_url\n1463             )\n1464             return HttpResponseRedirect(redirect_url)\n1465 \n1466         elif \"_saveasnew\" in request.POST:\n1467             msg = format_html(\n1468                 _(\n1469                     \"The {name} \u201c{obj}\u201d was added successfully. You may edit it again \"\n1470                     \"below.\"\n1471                 ),\n1472                 **msg_dict,\n1473             )\n1474             self.message_user(request, msg, messages.SUCCESS)\n1475             redirect_url = reverse(\n1476                 \"admin:%s_%s_change\" % (opts.app_label, opts.model_name),\n1477                 args=(obj.pk,),\n1478                 current_app=self.admin_site.name,\n1479             )\n1480             redirect_url = add_preserved_filters(\n1481                 {\"preserved_filters\": preserved_filters, \"opts\": opts}, redirect_url\n1482             )\n1483             return HttpResponseRedirect(redirect_url)\n1484 \n1485         elif \"_addanother\" in request.POST:\n1486             msg = format_html(\n1487                 _(\n1488                     \"The {name} \u201c{obj}\u201d was changed successfully. You may add another \"\n1489                     \"{name} below.\"\n1490                 ),\n1491                 **msg_dict,\n1492             )\n1493             self.message_user(request, msg, messages.SUCCESS)\n1494             redirect_url = reverse(\n1495                 \"admin:%s_%s_add\" % (opts.app_label, opts.model_name),\n1496                 current_app=self.admin_site.name,\n1497             )\n1498             redirect_url = add_preserved_filters(\n1499                 {\"preserved_filters\": preserved_filters, \"opts\": opts}, redirect_url\n1500             )\n1501             return HttpResponseRedirect(redirect_url)\n1502 \n1503         else:\n1504             msg = format_html(\n1505                 _(\"The {name} \u201c{obj}\u201d was changed successfully.\"), **msg_dict\n1506             )\n1507             self.message_user(request, msg, messages.SUCCESS)\n1508             return self.response_post_save_change(request, obj)\n1509 \n1510     def _response_post_save(self, request, obj):\n1511         if self.has_view_or_change_permission(request):\n1512             post_url = reverse(\n1513                 \"admin:%s_%s_changelist\" % (self.opts.app_label, self.opts.model_name),\n1514                 current_app=self.admin_site.name,\n1515             )\n1516             preserved_filters = self.get_preserved_filters(request)\n1517             post_url = add_preserved_filters(\n1518                 {\"preserved_filters\": preserved_filters, \"opts\": self.opts}, post_url\n1519             )\n1520         else:\n1521             post_url = reverse(\"admin:index\", current_app=self.admin_site.name)\n1522         return HttpResponseRedirect(post_url)\n1523 \n1524     def response_post_save_add(self, request, obj):\n1525         \"\"\"\n1526         Figure out where to redirect after the 'Save' button has been pressed\n1527         when adding a new object.\n1528         \"\"\"\n1529         return self._response_post_save(request, obj)\n1530 \n1531     def response_post_save_change(self, request, obj):\n1532         \"\"\"\n1533         Figure out where to redirect after the 'Save' button has been pressed\n1534         when editing an existing object.\n1535         \"\"\"\n1536         return self._response_post_save(request, obj)\n1537 \n1538     def response_action(self, request, queryset):\n1539         \"\"\"\n1540         Handle an admin action. This is called if a request is POSTed to the\n1541         changelist; it returns an HttpResponse if the action was handled, and\n1542         None otherwise.\n1543         \"\"\"\n1544 \n1545         # There can be multiple action forms on the page (at the top\n1546         # and bottom of the change list, for example). Get the action\n1547         # whose button was pushed.\n1548         try:\n1549             action_index = int(request.POST.get(\"index\", 0))\n1550         except ValueError:\n1551             action_index = 0\n1552 \n1553         # Construct the action form.\n1554         data = request.POST.copy()\n1555         data.pop(helpers.ACTION_CHECKBOX_NAME, None)\n1556         data.pop(\"index\", None)\n1557 \n1558         # Use the action whose button was pushed\n1559         try:\n1560             data.update({\"action\": data.getlist(\"action\")[action_index]})\n1561         except IndexError:\n1562             # If we didn't get an action from the chosen form that's invalid\n1563             # POST data, so by deleting action it'll fail the validation check\n1564             # below. So no need to do anything here\n1565             pass\n1566 \n1567         action_form = self.action_form(data, auto_id=None)\n1568         action_form.fields[\"action\"].choices = self.get_action_choices(request)\n1569 \n1570         # If the form's valid we can handle the action.\n1571         if action_form.is_valid():\n1572             action = action_form.cleaned_data[\"action\"]\n1573             select_across = action_form.cleaned_data[\"select_across\"]\n1574             func = self.get_actions(request)[action][0]\n1575 \n1576             # Get the list of selected PKs. If nothing's selected, we can't\n1577             # perform an action on it, so bail. Except we want to perform\n1578             # the action explicitly on all objects.\n1579             selected = request.POST.getlist(helpers.ACTION_CHECKBOX_NAME)\n1580             if not selected and not select_across:\n1581                 # Reminder that something needs to be selected or nothing will happen\n1582                 msg = _(\n1583                     \"Items must be selected in order to perform \"\n1584                     \"actions on them. No items have been changed.\"\n1585                 )\n1586                 self.message_user(request, msg, messages.WARNING)\n1587                 return None\n1588 \n1589             if not select_across:\n1590                 # Perform the action only on the selected objects\n1591                 queryset = queryset.filter(pk__in=selected)\n1592 \n1593             response = func(self, request, queryset)\n1594 \n1595             # Actions may return an HttpResponse-like object, which will be\n1596             # used as the response from the POST. If not, we'll be a good\n1597             # little HTTP citizen and redirect back to the changelist page.\n1598             if isinstance(response, HttpResponseBase):\n1599                 return response\n1600             else:\n1601                 return HttpResponseRedirect(request.get_full_path())\n1602         else:\n1603             msg = _(\"No action selected.\")\n1604             self.message_user(request, msg, messages.WARNING)\n1605             return None\n1606 \n1607     def response_delete(self, request, obj_display, obj_id):\n1608         \"\"\"\n1609         Determine the HttpResponse for the delete_view stage.\n1610         \"\"\"\n1611         if IS_POPUP_VAR in request.POST:\n1612             popup_response_data = json.dumps(\n1613                 {\n1614                     \"action\": \"delete\",\n1615                     \"value\": str(obj_id),\n1616                 }\n1617             )\n1618             return TemplateResponse(\n1619                 request,\n1620                 self.popup_response_template\n1621                 or [\n1622                     \"admin/%s/%s/popup_response.html\"\n1623                     % (self.opts.app_label, self.opts.model_name),\n1624                     \"admin/%s/popup_response.html\" % self.opts.app_label,\n1625                     \"admin/popup_response.html\",\n1626                 ],\n1627                 {\n1628                     \"popup_response_data\": popup_response_data,\n1629                 },\n1630             )\n1631 \n1632         self.message_user(\n1633             request,\n1634             _(\"The %(name)s \u201c%(obj)s\u201d was deleted successfully.\")\n1635             % {\n1636                 \"name\": self.opts.verbose_name,\n1637                 \"obj\": obj_display,\n1638             },\n1639             messages.SUCCESS,\n1640         )\n1641 \n1642         if self.has_change_permission(request, None):\n1643             post_url = reverse(\n1644                 \"admin:%s_%s_changelist\" % (self.opts.app_label, self.opts.model_name),\n1645                 current_app=self.admin_site.name,\n1646             )\n1647             preserved_filters = self.get_preserved_filters(request)\n1648             post_url = add_preserved_filters(\n1649                 {\"preserved_filters\": preserved_filters, \"opts\": self.opts}, post_url\n1650             )\n1651         else:\n1652             post_url = reverse(\"admin:index\", current_app=self.admin_site.name)\n1653         return HttpResponseRedirect(post_url)\n1654 \n1655     def render_delete_form(self, request, context):\n1656         app_label = self.opts.app_label\n1657 \n1658         request.current_app = self.admin_site.name\n1659         context.update(\n1660             to_field_var=TO_FIELD_VAR,\n1661             is_popup_var=IS_POPUP_VAR,\n1662             media=self.media,\n1663         )\n1664 \n1665         return TemplateResponse(\n1666             request,\n1667             self.delete_confirmation_template\n1668             or [\n1669                 \"admin/{}/{}/delete_confirmation.html\".format(\n1670                     app_label, self.opts.model_name\n1671                 ),\n1672                 \"admin/{}/delete_confirmation.html\".format(app_label),\n1673                 \"admin/delete_confirmation.html\",\n1674             ],\n1675             context,\n1676         )\n1677 \n1678     def get_inline_formsets(self, request, formsets, inline_instances, obj=None):\n1679         # Edit permissions on parent model are required for editable inlines.\n1680         can_edit_parent = (\n1681             self.has_change_permission(request, obj)\n1682             if obj\n1683             else self.has_add_permission(request)\n1684         )\n1685         inline_admin_formsets = []\n1686         for inline, formset in zip(inline_instances, formsets):\n1687             fieldsets = list(inline.get_fieldsets(request, obj))\n1688             readonly = list(inline.get_readonly_fields(request, obj))\n1689             if can_edit_parent:\n1690                 has_add_permission = inline.has_add_permission(request, obj)\n1691                 has_change_permission = inline.has_change_permission(request, obj)\n1692                 has_delete_permission = inline.has_delete_permission(request, obj)\n1693             else:\n1694                 # Disable all edit-permissions, and override formset settings.\n1695                 has_add_permission = (\n1696                     has_change_permission\n1697                 ) = has_delete_permission = False\n1698                 formset.extra = formset.max_num = 0\n1699             has_view_permission = inline.has_view_permission(request, obj)\n1700             prepopulated = dict(inline.get_prepopulated_fields(request, obj))\n1701             inline_admin_formset = helpers.InlineAdminFormSet(\n1702                 inline,\n1703                 formset,\n1704                 fieldsets,\n1705                 prepopulated,\n1706                 readonly,\n1707                 model_admin=self,\n1708                 has_add_permission=has_add_permission,\n1709                 has_change_permission=has_change_permission,\n1710                 has_delete_permission=has_delete_permission,\n1711                 has_view_permission=has_view_permission,\n1712             )\n1713             inline_admin_formsets.append(inline_admin_formset)\n1714         return inline_admin_formsets\n1715 \n1716     def get_changeform_initial_data(self, request):\n1717         \"\"\"\n1718         Get the initial form data from the request's GET params.\n1719         \"\"\"\n1720         initial = dict(request.GET.items())\n1721         for k in initial:\n1722             try:\n1723                 f = self.opts.get_field(k)\n1724             except FieldDoesNotExist:\n1725                 continue\n1726             # We have to special-case M2Ms as a list of comma-separated PKs.\n1727             if isinstance(f, models.ManyToManyField):\n1728                 initial[k] = initial[k].split(\",\")\n1729         return initial\n1730 \n1731     def _get_obj_does_not_exist_redirect(self, request, opts, object_id):\n1732         \"\"\"\n1733         Create a message informing the user that the object doesn't exist\n1734         and return a redirect to the admin index page.\n1735         \"\"\"\n1736         msg = _(\"%(name)s with ID \u201c%(key)s\u201d doesn\u2019t exist. Perhaps it was deleted?\") % {\n1737             \"name\": opts.verbose_name,\n1738             \"key\": unquote(object_id),\n1739         }\n1740         self.message_user(request, msg, messages.WARNING)\n1741         url = reverse(\"admin:index\", current_app=self.admin_site.name)\n1742         return HttpResponseRedirect(url)\n1743 \n1744     @csrf_protect_m\n1745     def changeform_view(self, request, object_id=None, form_url=\"\", extra_context=None):\n1746         with transaction.atomic(using=router.db_for_write(self.model)):\n1747             return self._changeform_view(request, object_id, form_url, extra_context)\n1748 \n1749     def _changeform_view(self, request, object_id, form_url, extra_context):\n1750         to_field = request.POST.get(TO_FIELD_VAR, request.GET.get(TO_FIELD_VAR))\n1751         if to_field and not self.to_field_allowed(request, to_field):\n1752             raise DisallowedModelAdminToField(\n1753                 \"The field %s cannot be referenced.\" % to_field\n1754             )\n1755 \n1756         if request.method == \"POST\" and \"_saveasnew\" in request.POST:\n1757             object_id = None\n1758 \n1759         add = object_id is None\n1760 \n1761         if add:\n1762             if not self.has_add_permission(request):\n1763                 raise PermissionDenied\n1764             obj = None\n1765 \n1766         else:\n1767             obj = self.get_object(request, unquote(object_id), to_field)\n1768 \n1769             if request.method == \"POST\":\n1770                 if not self.has_change_permission(request, obj):\n1771                     raise PermissionDenied\n1772             else:\n1773                 if not self.has_view_or_change_permission(request, obj):\n1774                     raise PermissionDenied\n1775 \n1776             if obj is None:\n1777                 return self._get_obj_does_not_exist_redirect(\n1778                     request, self.opts, object_id\n1779                 )\n1780 \n1781         fieldsets = self.get_fieldsets(request, obj)\n1782         ModelForm = self.get_form(\n1783             request, obj, change=not add, fields=flatten_fieldsets(fieldsets)\n1784         )\n1785         if request.method == \"POST\":\n1786             form = ModelForm(request.POST, request.FILES, instance=obj)\n1787             formsets, inline_instances = self._create_formsets(\n1788                 request,\n1789                 form.instance,\n1790                 change=not add,\n1791             )\n1792             form_validated = form.is_valid()\n1793             if form_validated:\n1794                 new_object = self.save_form(request, form, change=not add)\n1795             else:\n1796                 new_object = form.instance\n1797             if all_valid(formsets) and form_validated:\n1798                 self.save_model(request, new_object, form, not add)\n1799                 self.save_related(request, form, formsets, not add)\n1800                 change_message = self.construct_change_message(\n1801                     request, form, formsets, add\n1802                 )\n1803                 if add:\n1804                     self.log_addition(request, new_object, change_message)\n1805                     return self.response_add(request, new_object)\n1806                 else:\n1807                     self.log_change(request, new_object, change_message)\n1808                     return self.response_change(request, new_object)\n1809             else:\n1810                 form_validated = False\n1811         else:\n1812             if add:\n1813                 initial = self.get_changeform_initial_data(request)\n1814                 form = ModelForm(initial=initial)\n1815                 formsets, inline_instances = self._create_formsets(\n1816                     request, form.instance, change=False\n1817                 )\n1818             else:\n1819                 form = ModelForm(instance=obj)\n1820                 formsets, inline_instances = self._create_formsets(\n1821                     request, obj, change=True\n1822                 )\n1823 \n1824         if not add and not self.has_change_permission(request, obj):\n1825             readonly_fields = flatten_fieldsets(fieldsets)\n1826         else:\n1827             readonly_fields = self.get_readonly_fields(request, obj)\n1828         admin_form = helpers.AdminForm(\n1829             form,\n1830             list(fieldsets),\n1831             # Clear prepopulated fields on a view-only form to avoid a crash.\n1832             self.get_prepopulated_fields(request, obj)\n1833             if add or self.has_change_permission(request, obj)\n1834             else {},\n1835             readonly_fields,\n1836             model_admin=self,\n1837         )\n1838         media = self.media + admin_form.media\n1839 \n1840         inline_formsets = self.get_inline_formsets(\n1841             request, formsets, inline_instances, obj\n1842         )\n1843         for inline_formset in inline_formsets:\n1844             media += inline_formset.media\n1845 \n1846         if add:\n1847             title = _(\"Add %s\")\n1848         elif self.has_change_permission(request, obj):\n1849             title = _(\"Change %s\")\n1850         else:\n1851             title = _(\"View %s\")\n1852         context = {\n1853             **self.admin_site.each_context(request),\n1854             \"title\": title % self.opts.verbose_name,\n1855             \"subtitle\": str(obj) if obj else None,\n1856             \"adminform\": admin_form,\n1857             \"object_id\": object_id,\n1858             \"original\": obj,\n1859             \"is_popup\": IS_POPUP_VAR in request.POST or IS_POPUP_VAR in request.GET,\n1860             \"to_field\": to_field,\n1861             \"media\": media,\n1862             \"inline_admin_formsets\": inline_formsets,\n1863             \"errors\": helpers.AdminErrorList(form, formsets),\n1864             \"preserved_filters\": self.get_preserved_filters(request),\n1865         }\n1866 \n1867         # Hide the \"Save\" and \"Save and continue\" buttons if \"Save as New\" was\n1868         # previously chosen to prevent the interface from getting confusing.\n1869         if (\n1870             request.method == \"POST\"\n1871             and not form_validated\n1872             and \"_saveasnew\" in request.POST\n1873         ):\n1874             context[\"show_save\"] = False\n1875             context[\"show_save_and_continue\"] = False\n1876             # Use the change template instead of the add template.\n1877             add = False\n1878 \n1879         context.update(extra_context or {})\n1880 \n1881         return self.render_change_form(\n1882             request, context, add=add, change=not add, obj=obj, form_url=form_url\n1883         )\n1884 \n1885     def add_view(self, request, form_url=\"\", extra_context=None):\n1886         return self.changeform_view(request, None, form_url, extra_context)\n1887 \n1888     def change_view(self, request, object_id, form_url=\"\", extra_context=None):\n1889         return self.changeform_view(request, object_id, form_url, extra_context)\n1890 \n1891     def _get_edited_object_pks(self, request, prefix):\n1892         \"\"\"Return POST data values of list_editable primary keys.\"\"\"\n1893         pk_pattern = re.compile(\n1894             r\"{}-\\d+-{}$\".format(re.escape(prefix), self.opts.pk.name)\n1895         )\n1896         return [value for key, value in request.POST.items() if pk_pattern.match(key)]\n1897 \n1898     def _get_list_editable_queryset(self, request, prefix):\n1899         \"\"\"\n1900         Based on POST data, return a queryset of the objects that were edited\n1901         via list_editable.\n1902         \"\"\"\n1903         object_pks = self._get_edited_object_pks(request, prefix)\n1904         queryset = self.get_queryset(request)\n1905         validate = queryset.model._meta.pk.to_python\n1906         try:\n1907             for pk in object_pks:\n1908                 validate(pk)\n1909         except ValidationError:\n1910             # Disable the optimization if the POST data was tampered with.\n1911             return queryset\n1912         return queryset.filter(pk__in=object_pks)\n1913 \n1914     @csrf_protect_m\n1915     def changelist_view(self, request, extra_context=None):\n1916         \"\"\"\n1917         The 'change list' admin view for this model.\n1918         \"\"\"\n1919         from django.contrib.admin.views.main import ERROR_FLAG\n1920 \n1921         app_label = self.opts.app_label\n1922         if not self.has_view_or_change_permission(request):\n1923             raise PermissionDenied\n1924 \n1925         try:\n1926             cl = self.get_changelist_instance(request)\n1927         except IncorrectLookupParameters:\n1928             # Wacky lookup parameters were given, so redirect to the main\n1929             # changelist page, without parameters, and pass an 'invalid=1'\n1930             # parameter via the query string. If wacky parameters were given\n1931             # and the 'invalid=1' parameter was already in the query string,\n1932             # something is screwed up with the database, so display an error\n1933             # page.\n1934             if ERROR_FLAG in request.GET:\n1935                 return SimpleTemplateResponse(\n1936                     \"admin/invalid_setup.html\",\n1937                     {\n1938                         \"title\": _(\"Database error\"),\n1939                     },\n1940                 )\n1941             return HttpResponseRedirect(request.path + \"?\" + ERROR_FLAG + \"=1\")\n1942 \n1943         # If the request was POSTed, this might be a bulk action or a bulk\n1944         # edit. Try to look up an action or confirmation first, but if this\n1945         # isn't an action the POST will fall through to the bulk edit check,\n1946         # below.\n1947         action_failed = False\n1948         selected = request.POST.getlist(helpers.ACTION_CHECKBOX_NAME)\n1949 \n1950         actions = self.get_actions(request)\n1951         # Actions with no confirmation\n1952         if (\n1953             actions\n1954             and request.method == \"POST\"\n1955             and \"index\" in request.POST\n1956             and \"_save\" not in request.POST\n1957         ):\n1958             if selected:\n1959                 response = self.response_action(\n1960                     request, queryset=cl.get_queryset(request)\n1961                 )\n1962                 if response:\n1963                     return response\n1964                 else:\n1965                     action_failed = True\n1966             else:\n1967                 msg = _(\n1968                     \"Items must be selected in order to perform \"\n1969                     \"actions on them. No items have been changed.\"\n1970                 )\n1971                 self.message_user(request, msg, messages.WARNING)\n1972                 action_failed = True\n1973 \n1974         # Actions with confirmation\n1975         if (\n1976             actions\n1977             and request.method == \"POST\"\n1978             and helpers.ACTION_CHECKBOX_NAME in request.POST\n1979             and \"index\" not in request.POST\n1980             and \"_save\" not in request.POST\n1981         ):\n1982             if selected:\n1983                 response = self.response_action(\n1984                     request, queryset=cl.get_queryset(request)\n1985                 )\n1986                 if response:\n1987                     return response\n1988                 else:\n1989                     action_failed = True\n1990 \n1991         if action_failed:\n1992             # Redirect back to the changelist page to avoid resubmitting the\n1993             # form if the user refreshes the browser or uses the \"No, take\n1994             # me back\" button on the action confirmation page.\n1995             return HttpResponseRedirect(request.get_full_path())\n1996 \n1997         # If we're allowing changelist editing, we need to construct a formset\n1998         # for the changelist given all the fields to be edited. Then we'll\n1999         # use the formset to validate/process POSTed data.\n2000         formset = cl.formset = None\n2001 \n2002         # Handle POSTed bulk-edit data.\n2003         if request.method == \"POST\" and cl.list_editable and \"_save\" in request.POST:\n2004             if not self.has_change_permission(request):\n2005                 raise PermissionDenied\n2006             FormSet = self.get_changelist_formset(request)\n2007             modified_objects = self._get_list_editable_queryset(\n2008                 request, FormSet.get_default_prefix()\n2009             )\n2010             formset = cl.formset = FormSet(\n2011                 request.POST, request.FILES, queryset=modified_objects\n2012             )\n2013             if formset.is_valid():\n2014                 changecount = 0\n2015                 with transaction.atomic(using=router.db_for_write(self.model)):\n2016                     for form in formset.forms:\n2017                         if form.has_changed():\n2018                             obj = self.save_form(request, form, change=True)\n2019                             self.save_model(request, obj, form, change=True)\n2020                             self.save_related(request, form, formsets=[], change=True)\n2021                             change_msg = self.construct_change_message(\n2022                                 request, form, None\n2023                             )\n2024                             self.log_change(request, obj, change_msg)\n2025                             changecount += 1\n2026                 if changecount:\n2027                     msg = ngettext(\n2028                         \"%(count)s %(name)s was changed successfully.\",\n2029                         \"%(count)s %(name)s were changed successfully.\",\n2030                         changecount,\n2031                     ) % {\n2032                         \"count\": changecount,\n2033                         \"name\": model_ngettext(self.opts, changecount),\n2034                     }\n2035                     self.message_user(request, msg, messages.SUCCESS)\n2036 \n2037                 return HttpResponseRedirect(request.get_full_path())\n2038 \n2039         # Handle GET -- construct a formset for display.\n2040         elif cl.list_editable and self.has_change_permission(request):\n2041             FormSet = self.get_changelist_formset(request)\n2042             formset = cl.formset = FormSet(queryset=cl.result_list)\n2043 \n2044         # Build the list of media to be used by the formset.\n2045         if formset:\n2046             media = self.media + formset.media\n2047         else:\n2048             media = self.media\n2049 \n2050         # Build the action form and populate it with available actions.\n2051         if actions:\n2052             action_form = self.action_form(auto_id=None)\n2053             action_form.fields[\"action\"].choices = self.get_action_choices(request)\n2054             media += action_form.media\n2055         else:\n2056             action_form = None\n2057 \n2058         selection_note_all = ngettext(\n2059             \"%(total_count)s selected\", \"All %(total_count)s selected\", cl.result_count\n2060         )\n2061 \n2062         context = {\n2063             **self.admin_site.each_context(request),\n2064             \"module_name\": str(self.opts.verbose_name_plural),\n2065             \"selection_note\": _(\"0 of %(cnt)s selected\") % {\"cnt\": len(cl.result_list)},\n2066             \"selection_note_all\": selection_note_all % {\"total_count\": cl.result_count},\n2067             \"title\": cl.title,\n2068             \"subtitle\": None,\n2069             \"is_popup\": cl.is_popup,\n2070             \"to_field\": cl.to_field,\n2071             \"cl\": cl,\n2072             \"media\": media,\n2073             \"has_add_permission\": self.has_add_permission(request),\n2074             \"opts\": cl.opts,\n2075             \"action_form\": action_form,\n2076             \"actions_on_top\": self.actions_on_top,\n2077             \"actions_on_bottom\": self.actions_on_bottom,\n2078             \"actions_selection_counter\": self.actions_selection_counter,\n2079             \"preserved_filters\": self.get_preserved_filters(request),\n2080             **(extra_context or {}),\n2081         }\n2082 \n2083         request.current_app = self.admin_site.name\n2084 \n2085         return TemplateResponse(\n2086             request,\n2087             self.change_list_template\n2088             or [\n2089                 \"admin/%s/%s/change_list.html\" % (app_label, self.opts.model_name),\n2090                 \"admin/%s/change_list.html\" % app_label,\n2091                 \"admin/change_list.html\",\n2092             ],\n2093             context,\n2094         )\n2095 \n2096     def get_deleted_objects(self, objs, request):\n2097         \"\"\"\n2098         Hook for customizing the delete process for the delete view and the\n2099         \"delete selected\" action.\n2100         \"\"\"\n2101         return get_deleted_objects(objs, request, self.admin_site)\n2102 \n2103     @csrf_protect_m\n2104     def delete_view(self, request, object_id, extra_context=None):\n2105         with transaction.atomic(using=router.db_for_write(self.model)):\n2106             return self._delete_view(request, object_id, extra_context)\n2107 \n2108     def _delete_view(self, request, object_id, extra_context):\n2109         \"The 'delete' admin view for this model.\"\n2110         app_label = self.opts.app_label\n2111 \n2112         to_field = request.POST.get(TO_FIELD_VAR, request.GET.get(TO_FIELD_VAR))\n2113         if to_field and not self.to_field_allowed(request, to_field):\n2114             raise DisallowedModelAdminToField(\n2115                 \"The field %s cannot be referenced.\" % to_field\n2116             )\n2117 \n2118         obj = self.get_object(request, unquote(object_id), to_field)\n2119 \n2120         if not self.has_delete_permission(request, obj):\n2121             raise PermissionDenied\n2122 \n2123         if obj is None:\n2124             return self._get_obj_does_not_exist_redirect(request, self.opts, object_id)\n2125 \n2126         # Populate deleted_objects, a data structure of all related objects that\n2127         # will also be deleted.\n2128         (\n2129             deleted_objects,\n2130             model_count,\n2131             perms_needed,\n2132             protected,\n2133         ) = self.get_deleted_objects([obj], request)\n2134 \n2135         if request.POST and not protected:  # The user has confirmed the deletion.\n2136             if perms_needed:\n2137                 raise PermissionDenied\n2138             obj_display = str(obj)\n2139             attr = str(to_field) if to_field else self.opts.pk.attname\n2140             obj_id = obj.serializable_value(attr)\n2141             self.log_deletion(request, obj, obj_display)\n2142             self.delete_model(request, obj)\n2143 \n2144             return self.response_delete(request, obj_display, obj_id)\n2145 \n2146         object_name = str(self.opts.verbose_name)\n2147 \n2148         if perms_needed or protected:\n2149             title = _(\"Cannot delete %(name)s\") % {\"name\": object_name}\n2150         else:\n2151             title = _(\"Are you sure?\")\n2152 \n2153         context = {\n2154             **self.admin_site.each_context(request),\n2155             \"title\": title,\n2156             \"subtitle\": None,\n2157             \"object_name\": object_name,\n2158             \"object\": obj,\n2159             \"deleted_objects\": deleted_objects,\n2160             \"model_count\": dict(model_count).items(),\n2161             \"perms_lacking\": perms_needed,\n2162             \"protected\": protected,\n2163             \"opts\": self.opts,\n2164             \"app_label\": app_label,\n2165             \"preserved_filters\": self.get_preserved_filters(request),\n2166             \"is_popup\": IS_POPUP_VAR in request.POST or IS_POPUP_VAR in request.GET,\n2167             \"to_field\": to_field,\n2168             **(extra_context or {}),\n2169         }\n2170 \n2171         return self.render_delete_form(request, context)\n2172 \n2173     def history_view(self, request, object_id, extra_context=None):\n2174         \"The 'history' admin view for this model.\"\n2175         from django.contrib.admin.models import LogEntry\n2176         from django.contrib.admin.views.main import PAGE_VAR\n2177 \n2178         # First check if the user can see this history.\n2179         model = self.model\n2180         obj = self.get_object(request, unquote(object_id))\n2181         if obj is None:\n2182             return self._get_obj_does_not_exist_redirect(\n2183                 request, model._meta, object_id\n2184             )\n2185 \n2186         if not self.has_view_or_change_permission(request, obj):\n2187             raise PermissionDenied\n2188 \n2189         # Then get the history for this object.\n2190         app_label = self.opts.app_label\n2191         action_list = (\n2192             LogEntry.objects.filter(\n2193                 object_id=unquote(object_id),\n2194                 content_type=get_content_type_for_model(model),\n2195             )\n2196             .select_related()\n2197             .order_by(\"action_time\")\n2198         )\n2199 \n2200         paginator = self.get_paginator(request, action_list, 100)\n2201         page_number = request.GET.get(PAGE_VAR, 1)\n2202         page_obj = paginator.get_page(page_number)\n2203         page_range = paginator.get_elided_page_range(page_obj.number)\n2204 \n2205         context = {\n2206             **self.admin_site.each_context(request),\n2207             \"title\": _(\"Change history: %s\") % obj,\n2208             \"subtitle\": None,\n2209             \"action_list\": page_obj,\n2210             \"page_range\": page_range,\n2211             \"page_var\": PAGE_VAR,\n2212             \"pagination_required\": paginator.count > 100,\n2213             \"module_name\": str(capfirst(self.opts.verbose_name_plural)),\n2214             \"object\": obj,\n2215             \"opts\": self.opts,\n2216             \"preserved_filters\": self.get_preserved_filters(request),\n2217             **(extra_context or {}),\n2218         }\n2219 \n2220         request.current_app = self.admin_site.name\n2221 \n2222         return TemplateResponse(\n2223             request,\n2224             self.object_history_template\n2225             or [\n2226                 \"admin/%s/%s/object_history.html\" % (app_label, self.opts.model_name),\n2227                 \"admin/%s/object_history.html\" % app_label,\n2228                 \"admin/object_history.html\",\n2229             ],\n2230             context,\n2231         )\n2232 \n2233     def get_formset_kwargs(self, request, obj, inline, prefix):\n2234         formset_params = {\n2235             \"instance\": obj,\n2236             \"prefix\": prefix,\n2237             \"queryset\": inline.get_queryset(request),\n2238         }\n2239         if request.method == \"POST\":\n2240             formset_params.update(\n2241                 {\n2242                     \"data\": request.POST.copy(),\n2243                     \"files\": request.FILES,\n2244                     \"save_as_new\": \"_saveasnew\" in request.POST,\n2245                 }\n2246             )\n2247         return formset_params\n2248 \n2249     def _create_formsets(self, request, obj, change):\n2250         \"Helper function to generate formsets for add/change_view.\"\n2251         formsets = []\n2252         inline_instances = []\n2253         prefixes = {}\n2254         get_formsets_args = [request]\n2255         if change:\n2256             get_formsets_args.append(obj)\n2257         for FormSet, inline in self.get_formsets_with_inlines(*get_formsets_args):\n2258             prefix = FormSet.get_default_prefix()\n2259             prefixes[prefix] = prefixes.get(prefix, 0) + 1\n2260             if prefixes[prefix] != 1 or not prefix:\n2261                 prefix = \"%s-%s\" % (prefix, prefixes[prefix])\n2262             formset_params = self.get_formset_kwargs(request, obj, inline, prefix)\n2263             formset = FormSet(**formset_params)\n2264 \n2265             def user_deleted_form(request, obj, formset, index, inline):\n2266                 \"\"\"Return whether or not the user deleted the form.\"\"\"\n2267                 return (\n2268                     inline.has_delete_permission(request, obj)\n2269                     and \"{}-{}-DELETE\".format(formset.prefix, index) in request.POST\n2270                 )\n2271 \n2272             # Bypass validation of each view-only inline form (since the form's\n2273             # data won't be in request.POST), unless the form was deleted.\n2274             if not inline.has_change_permission(request, obj if change else None):\n2275                 for index, form in enumerate(formset.initial_forms):\n2276                     if user_deleted_form(request, obj, formset, index, inline):\n2277                         continue\n2278                     form._errors = {}\n2279                     form.cleaned_data = form.initial\n2280             formsets.append(formset)\n2281             inline_instances.append(inline)\n2282         return formsets, inline_instances\n",
        "intended_behavior": "These methods should be extended to not only log actions but also include a reference or identification of which AdminSite the action is associated with. A plausible approach could involve adding an additional parameter or context to these methods that allows passing information about the AdminSite. This added information could be stored in the LogEntry in an indirect manner (e.g., stored in the change_message as a serialized dict or utilizing a custom field that can encode this context). The challenge is to do this in a backward-compatible way, ensuring that existing functionality remains intact while providing the necessary hooks or information for AdminSite-specific LogEntry filtering."
    },
    {
        "rel_file_path": "django/contrib/admin/sites.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__5.0/django/contrib/admin/sites.py",
        "start": 99,
        "end": 148,
        "class_name": "AdminSite",
        "method_name": "register",
        "code": "99     def register(self, model_or_iterable, admin_class=None, **options):\n100         \"\"\"\n101         Register the given model(s) with the given admin class.\n102 \n103         The model(s) should be Model classes, not instances.\n104 \n105         If an admin class isn't given, use ModelAdmin (the default admin\n106         options). If keyword arguments are given -- e.g., list_display --\n107         apply them as options to the admin class.\n108 \n109         If a model is already registered, raise AlreadyRegistered.\n110 \n111         If a model is abstract, raise ImproperlyConfigured.\n112         \"\"\"\n113         admin_class = admin_class or ModelAdmin\n114         if isinstance(model_or_iterable, ModelBase):\n115             model_or_iterable = [model_or_iterable]\n116         for model in model_or_iterable:\n117             if model._meta.abstract:\n118                 raise ImproperlyConfigured(\n119                     \"The model %s is abstract, so it cannot be registered with admin.\"\n120                     % model.__name__\n121                 )\n122 \n123             if model in self._registry:\n124                 registered_admin = str(self._registry[model])\n125                 msg = \"The model %s is already registered \" % model.__name__\n126                 if registered_admin.endswith(\".ModelAdmin\"):\n127                     # Most likely registered without a ModelAdmin subclass.\n128                     msg += \"in app %r.\" % registered_admin.removesuffix(\".ModelAdmin\")\n129                 else:\n130                     msg += \"with %r.\" % registered_admin\n131                 raise AlreadyRegistered(msg)\n132 \n133             # Ignore the registration if the model has been\n134             # swapped out.\n135             if not model._meta.swapped:\n136                 # If we got **options then dynamically construct a subclass of\n137                 # admin_class with those **options.\n138                 if options:\n139                     # For reasons I don't quite understand, without a __module__\n140                     # the created class appears to \"live\" in the wrong place,\n141                     # which causes issues later on.\n142                     options[\"__module__\"] = __name__\n143                     admin_class = type(\n144                         \"%sAdmin\" % model.__name__, (admin_class,), options\n145                     )\n146 \n147                 # Instantiate the admin class to save in the registry\n148                 self._registry[model] = admin_class(model, self)\n",
        "intended_behavior": "While the register method itself may not need modification for direct bug resolution, ensuring its interaction with the logging mechanism considers AdminSite context is crucial. There may be value in exploring mechanisms within this method to implicitly or explicitly tag LogEntry instances with AdminSite identification upon registration or action logging. This implies a broader strategy of integrating AdminSite context awareness into actions logged via the ModelAdmin methods above."
    },
    {
        "rel_file_path": "django/contrib/admin/sites.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__5.0/django/contrib/admin/sites.py",
        "start": 36,
        "end": 589,
        "class_name": "AdminSite",
        "method_name": null,
        "code": "36 class AdminSite:\n37     \"\"\"\n38     An AdminSite object encapsulates an instance of the Django admin application, ready\n39     to be hooked in to your URLconf. Models are registered with the AdminSite using the\n40     register() method, and the get_urls() method can then be used to access Django view\n41     functions that present a full admin interface for the collection of registered\n42     models.\n43     \"\"\"\n44 \n45     # Text to put at the end of each page's <title>.\n46     site_title = gettext_lazy(\"Django site admin\")\n47 \n48     # Text to put in each page's <h1>.\n49     site_header = gettext_lazy(\"Django administration\")\n50 \n51     # Text to put at the top of the admin index page.\n52     index_title = gettext_lazy(\"Site administration\")\n53 \n54     # URL for the \"View site\" link at the top of each admin page.\n55     site_url = \"/\"\n56 \n57     enable_nav_sidebar = True\n58 \n59     empty_value_display = \"-\"\n60 \n61     login_form = None\n62     index_template = None\n63     app_index_template = None\n64     login_template = None\n65     logout_template = None\n66     password_change_template = None\n67     password_change_done_template = None\n68 \n69     final_catch_all_view = True\n70 \n71     def __init__(self, name=\"admin\"):\n72         self._registry = {}  # model_class class -> admin_class instance\n73         self.name = name\n74         self._actions = {\"delete_selected\": actions.delete_selected}\n75         self._global_actions = self._actions.copy()\n76         all_sites.add(self)\n77 \n78     def __repr__(self):\n79         return f\"{self.__class__.__name__}(name={self.name!r})\"\n80 \n81     def check(self, app_configs):\n82         \"\"\"\n83         Run the system checks on all ModelAdmins, except if they aren't\n84         customized at all.\n85         \"\"\"\n86         if app_configs is None:\n87             app_configs = apps.get_app_configs()\n88         app_configs = set(app_configs)  # Speed up lookups below\n89 \n90         errors = []\n91         modeladmins = (\n92             o for o in self._registry.values() if o.__class__ is not ModelAdmin\n93         )\n94         for modeladmin in modeladmins:\n95             if modeladmin.model._meta.app_config in app_configs:\n96                 errors.extend(modeladmin.check())\n97         return errors\n98 \n99     def register(self, model_or_iterable, admin_class=None, **options):\n100         \"\"\"\n101         Register the given model(s) with the given admin class.\n102 \n103         The model(s) should be Model classes, not instances.\n104 \n105         If an admin class isn't given, use ModelAdmin (the default admin\n106         options). If keyword arguments are given -- e.g., list_display --\n107         apply them as options to the admin class.\n108 \n109         If a model is already registered, raise AlreadyRegistered.\n110 \n111         If a model is abstract, raise ImproperlyConfigured.\n112         \"\"\"\n113         admin_class = admin_class or ModelAdmin\n114         if isinstance(model_or_iterable, ModelBase):\n115             model_or_iterable = [model_or_iterable]\n116         for model in model_or_iterable:\n117             if model._meta.abstract:\n118                 raise ImproperlyConfigured(\n119                     \"The model %s is abstract, so it cannot be registered with admin.\"\n120                     % model.__name__\n121                 )\n122 \n123             if model in self._registry:\n124                 registered_admin = str(self._registry[model])\n125                 msg = \"The model %s is already registered \" % model.__name__\n126                 if registered_admin.endswith(\".ModelAdmin\"):\n127                     # Most likely registered without a ModelAdmin subclass.\n128                     msg += \"in app %r.\" % registered_admin.removesuffix(\".ModelAdmin\")\n129                 else:\n130                     msg += \"with %r.\" % registered_admin\n131                 raise AlreadyRegistered(msg)\n132 \n133             # Ignore the registration if the model has been\n134             # swapped out.\n135             if not model._meta.swapped:\n136                 # If we got **options then dynamically construct a subclass of\n137                 # admin_class with those **options.\n138                 if options:\n139                     # For reasons I don't quite understand, without a __module__\n140                     # the created class appears to \"live\" in the wrong place,\n141                     # which causes issues later on.\n142                     options[\"__module__\"] = __name__\n143                     admin_class = type(\n144                         \"%sAdmin\" % model.__name__, (admin_class,), options\n145                     )\n146 \n147                 # Instantiate the admin class to save in the registry\n148                 self._registry[model] = admin_class(model, self)\n149 \n150     def unregister(self, model_or_iterable):\n151         \"\"\"\n152         Unregister the given model(s).\n153 \n154         If a model isn't already registered, raise NotRegistered.\n155         \"\"\"\n156         if isinstance(model_or_iterable, ModelBase):\n157             model_or_iterable = [model_or_iterable]\n158         for model in model_or_iterable:\n159             if model not in self._registry:\n160                 raise NotRegistered(\"The model %s is not registered\" % model.__name__)\n161             del self._registry[model]\n162 \n163     def is_registered(self, model):\n164         \"\"\"\n165         Check if a model class is registered with this `AdminSite`.\n166         \"\"\"\n167         return model in self._registry\n168 \n169     def add_action(self, action, name=None):\n170         \"\"\"\n171         Register an action to be available globally.\n172         \"\"\"\n173         name = name or action.__name__\n174         self._actions[name] = action\n175         self._global_actions[name] = action\n176 \n177     def disable_action(self, name):\n178         \"\"\"\n179         Disable a globally-registered action. Raise KeyError for invalid names.\n180         \"\"\"\n181         del self._actions[name]\n182 \n183     def get_action(self, name):\n184         \"\"\"\n185         Explicitly get a registered global action whether it's enabled or\n186         not. Raise KeyError for invalid names.\n187         \"\"\"\n188         return self._global_actions[name]\n189 \n190     @property\n191     def actions(self):\n192         \"\"\"\n193         Get all the enabled actions as an iterable of (name, func).\n194         \"\"\"\n195         return self._actions.items()\n196 \n197     def has_permission(self, request):\n198         \"\"\"\n199         Return True if the given HttpRequest has permission to view\n200         *at least one* page in the admin site.\n201         \"\"\"\n202         return request.user.is_active and request.user.is_staff\n203 \n204     def admin_view(self, view, cacheable=False):\n205         \"\"\"\n206         Decorator to create an admin view attached to this ``AdminSite``. This\n207         wraps the view and provides permission checking by calling\n208         ``self.has_permission``.\n209 \n210         You'll want to use this from within ``AdminSite.get_urls()``:\n211 \n212             class MyAdminSite(AdminSite):\n213 \n214                 def get_urls(self):\n215                     from django.urls import path\n216 \n217                     urls = super().get_urls()\n218                     urls += [\n219                         path('my_view/', self.admin_view(some_view))\n220                     ]\n221                     return urls\n222 \n223         By default, admin_views are marked non-cacheable using the\n224         ``never_cache`` decorator. If the view can be safely cached, set\n225         cacheable=True.\n226         \"\"\"\n227 \n228         def inner(request, *args, **kwargs):\n229             if not self.has_permission(request):\n230                 if request.path == reverse(\"admin:logout\", current_app=self.name):\n231                     index_path = reverse(\"admin:index\", current_app=self.name)\n232                     return HttpResponseRedirect(index_path)\n233                 # Inner import to prevent django.contrib.admin (app) from\n234                 # importing django.contrib.auth.models.User (unrelated model).\n235                 from django.contrib.auth.views import redirect_to_login\n236 \n237                 return redirect_to_login(\n238                     request.get_full_path(),\n239                     reverse(\"admin:login\", current_app=self.name),\n240                 )\n241             return view(request, *args, **kwargs)\n242 \n243         if not cacheable:\n244             inner = never_cache(inner)\n245         # We add csrf_protect here so this function can be used as a utility\n246         # function for any view, without having to repeat 'csrf_protect'.\n247         if not getattr(view, \"csrf_exempt\", False):\n248             inner = csrf_protect(inner)\n249         return update_wrapper(inner, view)\n250 \n251     def get_urls(self):\n252         # Since this module gets imported in the application's root package,\n253         # it cannot import models from other applications at the module level,\n254         # and django.contrib.contenttypes.views imports ContentType.\n255         from django.contrib.contenttypes import views as contenttype_views\n256         from django.urls import include, path, re_path\n257 \n258         def wrap(view, cacheable=False):\n259             def wrapper(*args, **kwargs):\n260                 return self.admin_view(view, cacheable)(*args, **kwargs)\n261 \n262             wrapper.admin_site = self\n263             return update_wrapper(wrapper, view)\n264 \n265         # Admin-site-wide views.\n266         urlpatterns = [\n267             path(\"\", wrap(self.index), name=\"index\"),\n268             path(\"login/\", self.login, name=\"login\"),\n269             path(\"logout/\", wrap(self.logout), name=\"logout\"),\n270             path(\n271                 \"password_change/\",\n272                 wrap(self.password_change, cacheable=True),\n273                 name=\"password_change\",\n274             ),\n275             path(\n276                 \"password_change/done/\",\n277                 wrap(self.password_change_done, cacheable=True),\n278                 name=\"password_change_done\",\n279             ),\n280             path(\"autocomplete/\", wrap(self.autocomplete_view), name=\"autocomplete\"),\n281             path(\"jsi18n/\", wrap(self.i18n_javascript, cacheable=True), name=\"jsi18n\"),\n282             path(\n283                 \"r/<int:content_type_id>/<path:object_id>/\",\n284                 wrap(contenttype_views.shortcut),\n285                 name=\"view_on_site\",\n286             ),\n287         ]\n288 \n289         # Add in each model's views, and create a list of valid URLS for the\n290         # app_index\n291         valid_app_labels = []\n292         for model, model_admin in self._registry.items():\n293             urlpatterns += [\n294                 path(\n295                     \"%s/%s/\" % (model._meta.app_label, model._meta.model_name),\n296                     include(model_admin.urls),\n297                 ),\n298             ]\n299             if model._meta.app_label not in valid_app_labels:\n300                 valid_app_labels.append(model._meta.app_label)\n301 \n302         # If there were ModelAdmins registered, we should have a list of app\n303         # labels for which we need to allow access to the app_index view,\n304         if valid_app_labels:\n305             regex = r\"^(?P<app_label>\" + \"|\".join(valid_app_labels) + \")/$\"\n306             urlpatterns += [\n307                 re_path(regex, wrap(self.app_index), name=\"app_list\"),\n308             ]\n309 \n310         if self.final_catch_all_view:\n311             urlpatterns.append(re_path(r\"(?P<url>.*)$\", wrap(self.catch_all_view)))\n312 \n313         return urlpatterns\n314 \n315     @property\n316     def urls(self):\n317         return self.get_urls(), \"admin\", self.name\n318 \n319     def each_context(self, request):\n320         \"\"\"\n321         Return a dictionary of variables to put in the template context for\n322         *every* page in the admin site.\n323 \n324         For sites running on a subpath, use the SCRIPT_NAME value if site_url\n325         hasn't been customized.\n326         \"\"\"\n327         script_name = request.META[\"SCRIPT_NAME\"]\n328         site_url = (\n329             script_name if self.site_url == \"/\" and script_name else self.site_url\n330         )\n331         return {\n332             \"site_title\": self.site_title,\n333             \"site_header\": self.site_header,\n334             \"site_url\": site_url,\n335             \"has_permission\": self.has_permission(request),\n336             \"available_apps\": self.get_app_list(request),\n337             \"is_popup\": False,\n338             \"is_nav_sidebar_enabled\": self.enable_nav_sidebar,\n339         }\n340 \n341     def password_change(self, request, extra_context=None):\n342         \"\"\"\n343         Handle the \"change password\" task -- both form display and validation.\n344         \"\"\"\n345         from django.contrib.admin.forms import AdminPasswordChangeForm\n346         from django.contrib.auth.views import PasswordChangeView\n347 \n348         url = reverse(\"admin:password_change_done\", current_app=self.name)\n349         defaults = {\n350             \"form_class\": AdminPasswordChangeForm,\n351             \"success_url\": url,\n352             \"extra_context\": {**self.each_context(request), **(extra_context or {})},\n353         }\n354         if self.password_change_template is not None:\n355             defaults[\"template_name\"] = self.password_change_template\n356         request.current_app = self.name\n357         return PasswordChangeView.as_view(**defaults)(request)\n358 \n359     def password_change_done(self, request, extra_context=None):\n360         \"\"\"\n361         Display the \"success\" page after a password change.\n362         \"\"\"\n363         from django.contrib.auth.views import PasswordChangeDoneView\n364 \n365         defaults = {\n366             \"extra_context\": {**self.each_context(request), **(extra_context or {})},\n367         }\n368         if self.password_change_done_template is not None:\n369             defaults[\"template_name\"] = self.password_change_done_template\n370         request.current_app = self.name\n371         return PasswordChangeDoneView.as_view(**defaults)(request)\n372 \n373     def i18n_javascript(self, request, extra_context=None):\n374         \"\"\"\n375         Display the i18n JavaScript that the Django admin requires.\n376 \n377         `extra_context` is unused but present for consistency with the other\n378         admin views.\n379         \"\"\"\n380         return JavaScriptCatalog.as_view(packages=[\"django.contrib.admin\"])(request)\n381 \n382     def logout(self, request, extra_context=None):\n383         \"\"\"\n384         Log out the user for the given HttpRequest.\n385 \n386         This should *not* assume the user is already logged in.\n387         \"\"\"\n388         from django.contrib.auth.views import LogoutView\n389 \n390         defaults = {\n391             \"extra_context\": {\n392                 **self.each_context(request),\n393                 # Since the user isn't logged out at this point, the value of\n394                 # has_permission must be overridden.\n395                 \"has_permission\": False,\n396                 **(extra_context or {}),\n397             },\n398         }\n399         if self.logout_template is not None:\n400             defaults[\"template_name\"] = self.logout_template\n401         request.current_app = self.name\n402         return LogoutView.as_view(**defaults)(request)\n403 \n404     @method_decorator(never_cache)\n405     def login(self, request, extra_context=None):\n406         \"\"\"\n407         Display the login form for the given HttpRequest.\n408         \"\"\"\n409         if request.method == \"GET\" and self.has_permission(request):\n410             # Already logged-in, redirect to admin index\n411             index_path = reverse(\"admin:index\", current_app=self.name)\n412             return HttpResponseRedirect(index_path)\n413 \n414         # Since this module gets imported in the application's root package,\n415         # it cannot import models from other applications at the module level,\n416         # and django.contrib.admin.forms eventually imports User.\n417         from django.contrib.admin.forms import AdminAuthenticationForm\n418         from django.contrib.auth.views import LoginView\n419 \n420         context = {\n421             **self.each_context(request),\n422             \"title\": _(\"Log in\"),\n423             \"subtitle\": None,\n424             \"app_path\": request.get_full_path(),\n425             \"username\": request.user.get_username(),\n426         }\n427         if (\n428             REDIRECT_FIELD_NAME not in request.GET\n429             and REDIRECT_FIELD_NAME not in request.POST\n430         ):\n431             context[REDIRECT_FIELD_NAME] = reverse(\"admin:index\", current_app=self.name)\n432         context.update(extra_context or {})\n433 \n434         defaults = {\n435             \"extra_context\": context,\n436             \"authentication_form\": self.login_form or AdminAuthenticationForm,\n437             \"template_name\": self.login_template or \"admin/login.html\",\n438         }\n439         request.current_app = self.name\n440         return LoginView.as_view(**defaults)(request)\n441 \n442     def autocomplete_view(self, request):\n443         return AutocompleteJsonView.as_view(admin_site=self)(request)\n444 \n445     @no_append_slash\n446     def catch_all_view(self, request, url):\n447         if settings.APPEND_SLASH and not url.endswith(\"/\"):\n448             urlconf = getattr(request, \"urlconf\", None)\n449             try:\n450                 match = resolve(\"%s/\" % request.path_info, urlconf)\n451             except Resolver404:\n452                 pass\n453             else:\n454                 if getattr(match.func, \"should_append_slash\", True):\n455                     return HttpResponsePermanentRedirect(\"%s/\" % request.path)\n456         raise Http404\n457 \n458     def _build_app_dict(self, request, label=None):\n459         \"\"\"\n460         Build the app dictionary. The optional `label` parameter filters models\n461         of a specific app.\n462         \"\"\"\n463         app_dict = {}\n464 \n465         if label:\n466             models = {\n467                 m: m_a\n468                 for m, m_a in self._registry.items()\n469                 if m._meta.app_label == label\n470             }\n471         else:\n472             models = self._registry\n473 \n474         for model, model_admin in models.items():\n475             app_label = model._meta.app_label\n476 \n477             has_module_perms = model_admin.has_module_permission(request)\n478             if not has_module_perms:\n479                 continue\n480 \n481             perms = model_admin.get_model_perms(request)\n482 \n483             # Check whether user has any perm for this module.\n484             # If so, add the module to the model_list.\n485             if True not in perms.values():\n486                 continue\n487 \n488             info = (app_label, model._meta.model_name)\n489             model_dict = {\n490                 \"model\": model,\n491                 \"name\": capfirst(model._meta.verbose_name_plural),\n492                 \"object_name\": model._meta.object_name,\n493                 \"perms\": perms,\n494                 \"admin_url\": None,\n495                 \"add_url\": None,\n496             }\n497             if perms.get(\"change\") or perms.get(\"view\"):\n498                 model_dict[\"view_only\"] = not perms.get(\"change\")\n499                 try:\n500                     model_dict[\"admin_url\"] = reverse(\n501                         \"admin:%s_%s_changelist\" % info, current_app=self.name\n502                     )\n503                 except NoReverseMatch:\n504                     pass\n505             if perms.get(\"add\"):\n506                 try:\n507                     model_dict[\"add_url\"] = reverse(\n508                         \"admin:%s_%s_add\" % info, current_app=self.name\n509                     )\n510                 except NoReverseMatch:\n511                     pass\n512 \n513             if app_label in app_dict:\n514                 app_dict[app_label][\"models\"].append(model_dict)\n515             else:\n516                 app_dict[app_label] = {\n517                     \"name\": apps.get_app_config(app_label).verbose_name,\n518                     \"app_label\": app_label,\n519                     \"app_url\": reverse(\n520                         \"admin:app_list\",\n521                         kwargs={\"app_label\": app_label},\n522                         current_app=self.name,\n523                     ),\n524                     \"has_module_perms\": has_module_perms,\n525                     \"models\": [model_dict],\n526                 }\n527 \n528         return app_dict\n529 \n530     def get_app_list(self, request, app_label=None):\n531         \"\"\"\n532         Return a sorted list of all the installed apps that have been\n533         registered in this site.\n534         \"\"\"\n535         app_dict = self._build_app_dict(request, app_label)\n536 \n537         # Sort the apps alphabetically.\n538         app_list = sorted(app_dict.values(), key=lambda x: x[\"name\"].lower())\n539 \n540         # Sort the models alphabetically within each app.\n541         for app in app_list:\n542             app[\"models\"].sort(key=lambda x: x[\"name\"])\n543 \n544         return app_list\n545 \n546     def index(self, request, extra_context=None):\n547         \"\"\"\n548         Display the main admin index page, which lists all of the installed\n549         apps that have been registered in this site.\n550         \"\"\"\n551         app_list = self.get_app_list(request)\n552 \n553         context = {\n554             **self.each_context(request),\n555             \"title\": self.index_title,\n556             \"subtitle\": None,\n557             \"app_list\": app_list,\n558             **(extra_context or {}),\n559         }\n560 \n561         request.current_app = self.name\n562 \n563         return TemplateResponse(\n564             request, self.index_template or \"admin/index.html\", context\n565         )\n566 \n567     def app_index(self, request, app_label, extra_context=None):\n568         app_list = self.get_app_list(request, app_label)\n569 \n570         if not app_list:\n571             raise Http404(\"The requested admin page does not exist.\")\n572 \n573         context = {\n574             **self.each_context(request),\n575             \"title\": _(\"%(app)s administration\") % {\"app\": app_list[0][\"name\"]},\n576             \"subtitle\": None,\n577             \"app_list\": app_list,\n578             \"app_label\": app_label,\n579             **(extra_context or {}),\n580         }\n581 \n582         request.current_app = self.name\n583 \n584         return TemplateResponse(\n585             request,\n586             self.app_index_template\n587             or [\"admin/%s/app_index.html\" % app_label, \"admin/app_index.html\"],\n588             context,\n589         )\n",
        "intended_behavior": "This class provides additional context to the issue."
    },
    {
        "rel_file_path": "django/contrib/admin/views/main.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__5.0/django/contrib/admin/views/main.py",
        "start": 1,
        "end": 585,
        "class_name": null,
        "method_name": null,
        "code": "1 from datetime import datetime, timedelta\n2 \n3 from django import forms\n4 from django.conf import settings\n5 from django.contrib import messages\n6 from django.contrib.admin import FieldListFilter\n7 from django.contrib.admin.exceptions import (\n8     DisallowedModelAdminLookup,\n9     DisallowedModelAdminToField,\n10 )\n11 from django.contrib.admin.options import (\n12     IS_POPUP_VAR,\n13     TO_FIELD_VAR,\n14     IncorrectLookupParameters,\n15 )\n16 from django.contrib.admin.utils import (\n17     get_fields_from_path,\n18     lookup_spawns_duplicates,\n19     prepare_lookup_value,\n20     quote,\n21 )\n22 from django.core.exceptions import (\n23     FieldDoesNotExist,\n24     ImproperlyConfigured,\n25     SuspiciousOperation,\n26 )\n27 from django.core.paginator import InvalidPage\n28 from django.db.models import Exists, F, Field, ManyToOneRel, OrderBy, OuterRef\n29 from django.db.models.expressions import Combinable\n30 from django.urls import reverse\n31 from django.utils.http import urlencode\n32 from django.utils.timezone import make_aware\n33 from django.utils.translation import gettext\n34 \n35 # Changelist settings\n36 ALL_VAR = \"all\"\n37 ORDER_VAR = \"o\"\n38 PAGE_VAR = \"p\"\n39 SEARCH_VAR = \"q\"\n40 ERROR_FLAG = \"e\"\n41 \n42 IGNORED_PARAMS = (ALL_VAR, ORDER_VAR, SEARCH_VAR, IS_POPUP_VAR, TO_FIELD_VAR)\n43 \n44 \n45 class ChangeListSearchForm(forms.Form):\n46     def __init__(self, *args, **kwargs):\n47         super().__init__(*args, **kwargs)\n48         # Populate \"fields\" dynamically because SEARCH_VAR is a variable:\n49         self.fields = {\n50             SEARCH_VAR: forms.CharField(required=False, strip=False),\n51         }\n52 \n53 \n54 class ChangeList:\n55     search_form_class = ChangeListSearchForm\n56 \n57     def __init__(\n58         self,\n59         request,\n60         model,\n61         list_display,\n62         list_display_links,\n63         list_filter,\n64         date_hierarchy,\n65         search_fields,\n66         list_select_related,\n67         list_per_page,\n68         list_max_show_all,\n69         list_editable,\n70         model_admin,\n71         sortable_by,\n72         search_help_text,\n73     ):\n74         self.model = model\n75         self.opts = model._meta\n76         self.lookup_opts = self.opts\n77         self.root_queryset = model_admin.get_queryset(request)\n78         self.list_display = list_display\n79         self.list_display_links = list_display_links\n80         self.list_filter = list_filter\n81         self.has_filters = None\n82         self.has_active_filters = None\n83         self.clear_all_filters_qs = None\n84         self.date_hierarchy = date_hierarchy\n85         self.search_fields = search_fields\n86         self.list_select_related = list_select_related\n87         self.list_per_page = list_per_page\n88         self.list_max_show_all = list_max_show_all\n89         self.model_admin = model_admin\n90         self.preserved_filters = model_admin.get_preserved_filters(request)\n91         self.sortable_by = sortable_by\n92         self.search_help_text = search_help_text\n93 \n94         # Get search parameters from the query string.\n95         _search_form = self.search_form_class(request.GET)\n96         if not _search_form.is_valid():\n97             for error in _search_form.errors.values():\n98                 messages.error(request, \", \".join(error))\n99         self.query = _search_form.cleaned_data.get(SEARCH_VAR) or \"\"\n100         try:\n101             self.page_num = int(request.GET.get(PAGE_VAR, 1))\n102         except ValueError:\n103             self.page_num = 1\n104         self.show_all = ALL_VAR in request.GET\n105         self.is_popup = IS_POPUP_VAR in request.GET\n106         to_field = request.GET.get(TO_FIELD_VAR)\n107         if to_field and not model_admin.to_field_allowed(request, to_field):\n108             raise DisallowedModelAdminToField(\n109                 \"The field %s cannot be referenced.\" % to_field\n110             )\n111         self.to_field = to_field\n112         self.params = dict(request.GET.items())\n113         if PAGE_VAR in self.params:\n114             del self.params[PAGE_VAR]\n115         if ERROR_FLAG in self.params:\n116             del self.params[ERROR_FLAG]\n117 \n118         if self.is_popup:\n119             self.list_editable = ()\n120         else:\n121             self.list_editable = list_editable\n122         self.queryset = self.get_queryset(request)\n123         self.get_results(request)\n124         if self.is_popup:\n125             title = gettext(\"Select %s\")\n126         elif self.model_admin.has_change_permission(request):\n127             title = gettext(\"Select %s to change\")\n128         else:\n129             title = gettext(\"Select %s to view\")\n130         self.title = title % self.opts.verbose_name\n131         self.pk_attname = self.lookup_opts.pk.attname\n132 \n133     def __repr__(self):\n134         return \"<%s: model=%s model_admin=%s>\" % (\n135             self.__class__.__qualname__,\n136             self.model.__qualname__,\n137             self.model_admin.__class__.__qualname__,\n138         )\n139 \n140     def get_filters_params(self, params=None):\n141         \"\"\"\n142         Return all params except IGNORED_PARAMS.\n143         \"\"\"\n144         params = params or self.params\n145         lookup_params = params.copy()  # a dictionary of the query string\n146         # Remove all the parameters that are globally and systematically\n147         # ignored.\n148         for ignored in IGNORED_PARAMS:\n149             if ignored in lookup_params:\n150                 del lookup_params[ignored]\n151         return lookup_params\n152 \n153     def get_filters(self, request):\n154         lookup_params = self.get_filters_params()\n155         may_have_duplicates = False\n156         has_active_filters = False\n157 \n158         for key, value in lookup_params.items():\n159             if not self.model_admin.lookup_allowed(key, value):\n160                 raise DisallowedModelAdminLookup(\"Filtering by %s not allowed\" % key)\n161 \n162         filter_specs = []\n163         for list_filter in self.list_filter:\n164             lookup_params_count = len(lookup_params)\n165             if callable(list_filter):\n166                 # This is simply a custom list filter class.\n167                 spec = list_filter(request, lookup_params, self.model, self.model_admin)\n168             else:\n169                 field_path = None\n170                 if isinstance(list_filter, (tuple, list)):\n171                     # This is a custom FieldListFilter class for a given field.\n172                     field, field_list_filter_class = list_filter\n173                 else:\n174                     # This is simply a field name, so use the default\n175                     # FieldListFilter class that has been registered for the\n176                     # type of the given field.\n177                     field, field_list_filter_class = list_filter, FieldListFilter.create\n178                 if not isinstance(field, Field):\n179                     field_path = field\n180                     field = get_fields_from_path(self.model, field_path)[-1]\n181 \n182                 spec = field_list_filter_class(\n183                     field,\n184                     request,\n185                     lookup_params,\n186                     self.model,\n187                     self.model_admin,\n188                     field_path=field_path,\n189                 )\n190                 # field_list_filter_class removes any lookup_params it\n191                 # processes. If that happened, check if duplicates should be\n192                 # removed.\n193                 if lookup_params_count > len(lookup_params):\n194                     may_have_duplicates |= lookup_spawns_duplicates(\n195                         self.lookup_opts,\n196                         field_path,\n197                     )\n198             if spec and spec.has_output():\n199                 filter_specs.append(spec)\n200                 if lookup_params_count > len(lookup_params):\n201                     has_active_filters = True\n202 \n203         if self.date_hierarchy:\n204             # Create bounded lookup parameters so that the query is more\n205             # efficient.\n206             year = lookup_params.pop(\"%s__year\" % self.date_hierarchy, None)\n207             if year is not None:\n208                 month = lookup_params.pop(\"%s__month\" % self.date_hierarchy, None)\n209                 day = lookup_params.pop(\"%s__day\" % self.date_hierarchy, None)\n210                 try:\n211                     from_date = datetime(\n212                         int(year),\n213                         int(month if month is not None else 1),\n214                         int(day if day is not None else 1),\n215                     )\n216                 except ValueError as e:\n217                     raise IncorrectLookupParameters(e) from e\n218                 if day:\n219                     to_date = from_date + timedelta(days=1)\n220                 elif month:\n221                     # In this branch, from_date will always be the first of a\n222                     # month, so advancing 32 days gives the next month.\n223                     to_date = (from_date + timedelta(days=32)).replace(day=1)\n224                 else:\n225                     to_date = from_date.replace(year=from_date.year + 1)\n226                 if settings.USE_TZ:\n227                     from_date = make_aware(from_date)\n228                     to_date = make_aware(to_date)\n229                 lookup_params.update(\n230                     {\n231                         \"%s__gte\" % self.date_hierarchy: from_date,\n232                         \"%s__lt\" % self.date_hierarchy: to_date,\n233                     }\n234                 )\n235 \n236         # At this point, all the parameters used by the various ListFilters\n237         # have been removed from lookup_params, which now only contains other\n238         # parameters passed via the query string. We now loop through the\n239         # remaining parameters both to ensure that all the parameters are valid\n240         # fields and to determine if at least one of them spawns duplicates. If\n241         # the lookup parameters aren't real fields, then bail out.\n242         try:\n243             for key, value in lookup_params.items():\n244                 lookup_params[key] = prepare_lookup_value(key, value)\n245                 may_have_duplicates |= lookup_spawns_duplicates(self.lookup_opts, key)\n246             return (\n247                 filter_specs,\n248                 bool(filter_specs),\n249                 lookup_params,\n250                 may_have_duplicates,\n251                 has_active_filters,\n252             )\n253         except FieldDoesNotExist as e:\n254             raise IncorrectLookupParameters(e) from e\n255 \n256     def get_query_string(self, new_params=None, remove=None):\n257         if new_params is None:\n258             new_params = {}\n259         if remove is None:\n260             remove = []\n261         p = self.params.copy()\n262         for r in remove:\n263             for k in list(p):\n264                 if k.startswith(r):\n265                     del p[k]\n266         for k, v in new_params.items():\n267             if v is None:\n268                 if k in p:\n269                     del p[k]\n270             else:\n271                 p[k] = v\n272         return \"?%s\" % urlencode(sorted(p.items()))\n273 \n274     def get_results(self, request):\n275         paginator = self.model_admin.get_paginator(\n276             request, self.queryset, self.list_per_page\n277         )\n278         # Get the number of objects, with admin filters applied.\n279         result_count = paginator.count\n280 \n281         # Get the total number of objects, with no admin filters applied.\n282         if self.model_admin.show_full_result_count:\n283             full_result_count = self.root_queryset.count()\n284         else:\n285             full_result_count = None\n286         can_show_all = result_count <= self.list_max_show_all\n287         multi_page = result_count > self.list_per_page\n288 \n289         # Get the list of objects to display on this page.\n290         if (self.show_all and can_show_all) or not multi_page:\n291             result_list = self.queryset._clone()\n292         else:\n293             try:\n294                 result_list = paginator.page(self.page_num).object_list\n295             except InvalidPage:\n296                 raise IncorrectLookupParameters\n297 \n298         self.result_count = result_count\n299         self.show_full_result_count = self.model_admin.show_full_result_count\n300         # Admin actions are shown if there is at least one entry\n301         # or if entries are not counted because show_full_result_count is disabled\n302         self.show_admin_actions = not self.show_full_result_count or bool(\n303             full_result_count\n304         )\n305         self.full_result_count = full_result_count\n306         self.result_list = result_list\n307         self.can_show_all = can_show_all\n308         self.multi_page = multi_page\n309         self.paginator = paginator\n310 \n311     def _get_default_ordering(self):\n312         ordering = []\n313         if self.model_admin.ordering:\n314             ordering = self.model_admin.ordering\n315         elif self.lookup_opts.ordering:\n316             ordering = self.lookup_opts.ordering\n317         return ordering\n318 \n319     def get_ordering_field(self, field_name):\n320         \"\"\"\n321         Return the proper model field name corresponding to the given\n322         field_name to use for ordering. field_name may either be the name of a\n323         proper model field or the name of a method (on the admin or model) or a\n324         callable with the 'admin_order_field' attribute. Return None if no\n325         proper model field name can be matched.\n326         \"\"\"\n327         try:\n328             field = self.lookup_opts.get_field(field_name)\n329             return field.name\n330         except FieldDoesNotExist:\n331             # See whether field_name is a name of a non-field\n332             # that allows sorting.\n333             if callable(field_name):\n334                 attr = field_name\n335             elif hasattr(self.model_admin, field_name):\n336                 attr = getattr(self.model_admin, field_name)\n337             else:\n338                 attr = getattr(self.model, field_name)\n339             if isinstance(attr, property) and hasattr(attr, \"fget\"):\n340                 attr = attr.fget\n341             return getattr(attr, \"admin_order_field\", None)\n342 \n343     def get_ordering(self, request, queryset):\n344         \"\"\"\n345         Return the list of ordering fields for the change list.\n346         First check the get_ordering() method in model admin, then check\n347         the object's default ordering. Then, any manually-specified ordering\n348         from the query string overrides anything. Finally, a deterministic\n349         order is guaranteed by calling _get_deterministic_ordering() with the\n350         constructed ordering.\n351         \"\"\"\n352         params = self.params\n353         ordering = list(\n354             self.model_admin.get_ordering(request) or self._get_default_ordering()\n355         )\n356         if ORDER_VAR in params:\n357             # Clear ordering and used params\n358             ordering = []\n359             order_params = params[ORDER_VAR].split(\".\")\n360             for p in order_params:\n361                 try:\n362                     none, pfx, idx = p.rpartition(\"-\")\n363                     field_name = self.list_display[int(idx)]\n364                     order_field = self.get_ordering_field(field_name)\n365                     if not order_field:\n366                         continue  # No 'admin_order_field', skip it\n367                     if isinstance(order_field, OrderBy):\n368                         if pfx == \"-\":\n369                             order_field = order_field.copy()\n370                             order_field.reverse_ordering()\n371                         ordering.append(order_field)\n372                     elif hasattr(order_field, \"resolve_expression\"):\n373                         # order_field is an expression.\n374                         ordering.append(\n375                             order_field.desc() if pfx == \"-\" else order_field.asc()\n376                         )\n377                     # reverse order if order_field has already \"-\" as prefix\n378                     elif pfx == \"-\" and order_field.startswith(pfx):\n379                         ordering.append(order_field.removeprefix(pfx))\n380                     else:\n381                         ordering.append(pfx + order_field)\n382                 except (IndexError, ValueError):\n383                     continue  # Invalid ordering specified, skip it.\n384 \n385         # Add the given query's ordering fields, if any.\n386         ordering.extend(queryset.query.order_by)\n387 \n388         return self._get_deterministic_ordering(ordering)\n389 \n390     def _get_deterministic_ordering(self, ordering):\n391         \"\"\"\n392         Ensure a deterministic order across all database backends. Search for a\n393         single field or unique together set of fields providing a total\n394         ordering. If these are missing, augment the ordering with a descendant\n395         primary key.\n396         \"\"\"\n397         ordering = list(ordering)\n398         ordering_fields = set()\n399         total_ordering_fields = {\"pk\"} | {\n400             field.attname\n401             for field in self.lookup_opts.fields\n402             if field.unique and not field.null\n403         }\n404         for part in ordering:\n405             # Search for single field providing a total ordering.\n406             field_name = None\n407             if isinstance(part, str):\n408                 field_name = part.lstrip(\"-\")\n409             elif isinstance(part, F):\n410                 field_name = part.name\n411             elif isinstance(part, OrderBy) and isinstance(part.expression, F):\n412                 field_name = part.expression.name\n413             if field_name:\n414                 # Normalize attname references by using get_field().\n415                 try:\n416                     field = self.lookup_opts.get_field(field_name)\n417                 except FieldDoesNotExist:\n418                     # Could be \"?\" for random ordering or a related field\n419                     # lookup. Skip this part of introspection for now.\n420                     continue\n421                 # Ordering by a related field name orders by the referenced\n422                 # model's ordering. Skip this part of introspection for now.\n423                 if field.remote_field and field_name == field.name:\n424                     continue\n425                 if field.attname in total_ordering_fields:\n426                     break\n427                 ordering_fields.add(field.attname)\n428         else:\n429             # No single total ordering field, try unique_together and total\n430             # unique constraints.\n431             constraint_field_names = (\n432                 *self.lookup_opts.unique_together,\n433                 *(\n434                     constraint.fields\n435                     for constraint in self.lookup_opts.total_unique_constraints\n436                 ),\n437             )\n438             for field_names in constraint_field_names:\n439                 # Normalize attname references by using get_field().\n440                 fields = [\n441                     self.lookup_opts.get_field(field_name) for field_name in field_names\n442                 ]\n443                 # Composite unique constraints containing a nullable column\n444                 # cannot ensure total ordering.\n445                 if any(field.null for field in fields):\n446                     continue\n447                 if ordering_fields.issuperset(field.attname for field in fields):\n448                     break\n449             else:\n450                 # If no set of unique fields is present in the ordering, rely\n451                 # on the primary key to provide total ordering.\n452                 ordering.append(\"-pk\")\n453         return ordering\n454 \n455     def get_ordering_field_columns(self):\n456         \"\"\"\n457         Return a dictionary of ordering field column numbers and asc/desc.\n458         \"\"\"\n459         # We must cope with more than one column having the same underlying sort\n460         # field, so we base things on column numbers.\n461         ordering = self._get_default_ordering()\n462         ordering_fields = {}\n463         if ORDER_VAR not in self.params:\n464             # for ordering specified on ModelAdmin or model Meta, we don't know\n465             # the right column numbers absolutely, because there might be more\n466             # than one column associated with that ordering, so we guess.\n467             for field in ordering:\n468                 if isinstance(field, (Combinable, OrderBy)):\n469                     if not isinstance(field, OrderBy):\n470                         field = field.asc()\n471                     if isinstance(field.expression, F):\n472                         order_type = \"desc\" if field.descending else \"asc\"\n473                         field = field.expression.name\n474                     else:\n475                         continue\n476                 elif field.startswith(\"-\"):\n477                     field = field.removeprefix(\"-\")\n478                     order_type = \"desc\"\n479                 else:\n480                     order_type = \"asc\"\n481                 for index, attr in enumerate(self.list_display):\n482                     if self.get_ordering_field(attr) == field:\n483                         ordering_fields[index] = order_type\n484                         break\n485         else:\n486             for p in self.params[ORDER_VAR].split(\".\"):\n487                 none, pfx, idx = p.rpartition(\"-\")\n488                 try:\n489                     idx = int(idx)\n490                 except ValueError:\n491                     continue  # skip it\n492                 ordering_fields[idx] = \"desc\" if pfx == \"-\" else \"asc\"\n493         return ordering_fields\n494 \n495     def get_queryset(self, request):\n496         # First, we collect all the declared list filters.\n497         (\n498             self.filter_specs,\n499             self.has_filters,\n500             remaining_lookup_params,\n501             filters_may_have_duplicates,\n502             self.has_active_filters,\n503         ) = self.get_filters(request)\n504         # Then, we let every list filter modify the queryset to its liking.\n505         qs = self.root_queryset\n506         for filter_spec in self.filter_specs:\n507             new_qs = filter_spec.queryset(request, qs)\n508             if new_qs is not None:\n509                 qs = new_qs\n510 \n511         try:\n512             # Finally, we apply the remaining lookup parameters from the query\n513             # string (i.e. those that haven't already been processed by the\n514             # filters).\n515             qs = qs.filter(**remaining_lookup_params)\n516         except (SuspiciousOperation, ImproperlyConfigured):\n517             # Allow certain types of errors to be re-raised as-is so that the\n518             # caller can treat them in a special way.\n519             raise\n520         except Exception as e:\n521             # Every other error is caught with a naked except, because we don't\n522             # have any other way of validating lookup parameters. They might be\n523             # invalid if the keyword arguments are incorrect, or if the values\n524             # are not in the correct type, so we might get FieldError,\n525             # ValueError, ValidationError, or ?.\n526             raise IncorrectLookupParameters(e)\n527 \n528         # Apply search results\n529         qs, search_may_have_duplicates = self.model_admin.get_search_results(\n530             request,\n531             qs,\n532             self.query,\n533         )\n534 \n535         # Set query string for clearing all filters.\n536         self.clear_all_filters_qs = self.get_query_string(\n537             new_params=remaining_lookup_params,\n538             remove=self.get_filters_params(),\n539         )\n540         # Remove duplicates from results, if necessary\n541         if filters_may_have_duplicates | search_may_have_duplicates:\n542             qs = qs.filter(pk=OuterRef(\"pk\"))\n543             qs = self.root_queryset.filter(Exists(qs))\n544 \n545         # Set ordering.\n546         ordering = self.get_ordering(request, qs)\n547         qs = qs.order_by(*ordering)\n548 \n549         if not qs.query.select_related:\n550             qs = self.apply_select_related(qs)\n551 \n552         return qs\n553 \n554     def apply_select_related(self, qs):\n555         if self.list_select_related is True:\n556             return qs.select_related()\n557 \n558         if self.list_select_related is False:\n559             if self.has_related_field_in_list_display():\n560                 return qs.select_related()\n561 \n562         if self.list_select_related:\n563             return qs.select_related(*self.list_select_related)\n564         return qs\n565 \n566     def has_related_field_in_list_display(self):\n567         for field_name in self.list_display:\n568             try:\n569                 field = self.lookup_opts.get_field(field_name)\n570             except FieldDoesNotExist:\n571                 pass\n572             else:\n573                 if isinstance(field.remote_field, ManyToOneRel):\n574                     # <FK>_id field names don't require a join.\n575                     if field_name != field.get_attname():\n576                         return True\n577         return False\n578 \n579     def url_for_result(self, result):\n580         pk = getattr(result, self.pk_attname)\n581         return reverse(\n582             \"admin:%s_%s_change\" % (self.opts.app_label, self.opts.model_name),\n583             args=(quote(pk),),\n584             current_app=self.model_admin.admin_site.name,\n585         )\n",
        "intended_behavior": "Implementing or enhancing a get_queryset method (or similar) specifically for filtering LogEntry instances based on the admin site. This could involve adding new mechanisms or utilities that customize LogEntry queryset fetching to include consideration of AdminSite context, likely utilizing indirect identification or tagging mechanisms as mentioned earlier."
    }
]