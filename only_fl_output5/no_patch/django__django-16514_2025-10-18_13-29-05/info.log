2025-10-18 13:29:05.557 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-18 13:29:08.791 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=192, output_tokens=12, cost=0.002280
2025-10-18 13:29:08.792 | INFO     | Test agent decides that the issue statement does not contain reproduction steps; skipping reproducer tracing
2025-10-18 13:29:08.795 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 13:29:18.429 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=501, output_tokens=407, cost=0.017220
2025-10-18 13:29:18.433 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 13:29:21.550 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=761, output_tokens=64, cost=0.009530
2025-10-18 13:29:21.552 | DEBUG    | Extracted a valid json.
2025-10-18 13:29:21.557 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_class(\"LogEntry\")",
        "search_class(\"AdminSite\")",
        "search_method_in_class(\"log_entry\", \"AdminSite\")",
        "search_method_in_class(\"get_queryset\", \"AdminSite\")"
    ],
    "bug_locations": []
}
2025-10-18 13:29:21.589 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-18 13:29:21.590 | DEBUG    | <Agent search> Analyzing search results.
2025-10-18 13:29:38.196 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1798, output_tokens=790, cost=0.041680
2025-10-18 13:29:38.213 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 13:29:49.737 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2804, output_tokens=530, cost=0.043940
2025-10-18 13:29:49.746 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 13:29:56.380 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=884, output_tokens=251, cost=0.016370
2025-10-18 13:29:56.381 | DEBUG    | Extracted a valid json.
2025-10-18 13:29:56.381 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_method_in_file(\"log_addition\", \"django/contrib/admin/options.py\")",
        "search_method_in_file(\"log_change\", \"django/contrib/admin/options.py\")",
        "search_method_in_file(\"log_deletion\", \"django/contrib/admin/options.py\")",
        "search_method_in_class(\"register\", \"AdminSite\")",
        "search_code_in_file(\"get_queryset\", \"django/contrib/admin/views/main.py\")"
    ],
    "bug_locations": [
        {
            "file": "django/contrib/admin/models.py",
            "class": "LogEntry",
            "method": "",
            "intended_behavior": "Extend the LogEntry model to include a reference to AdminSite. Implement an alternative approach for linking AdminSite instances with LogEntry without using a direct foreign key."
        },
        {
            "file": "django/contrib/admin/sites.py",
            "class": "AdminSite",
            "method": "",
            "intended_behavior": "Implement or enhance methods for logging actions that include context about the AdminSite instance. Also, explore a filtering mechanism for LogEntry queries that are aware of the specific AdminSite instance."
        }
    ]
}
2025-10-18 13:29:56.447 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-18 13:29:56.448 | DEBUG    | <Agent search> Analyzing search results.
2025-10-18 13:30:17.821 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=5464, output_tokens=917, cost=0.082150
2025-10-18 13:30:17.836 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 13:30:32.815 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=6597, output_tokens=597, cost=0.083880
2025-10-18 13:30:32.825 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 13:30:44.327 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=951, output_tokens=390, cost=0.021210
2025-10-18 13:30:44.328 | DEBUG    | Extracted a valid json.
2025-10-18 13:30:44.328 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "django/contrib/admin/options.py",
            "class": "ModelAdmin",
            "method": "log_addition, log_change, log_deletion",
            "intended_behavior": "These methods should be extended to not only log actions but also include a reference or identification of which AdminSite the action is associated with. A plausible approach could involve adding an additional parameter or context to these methods that allows passing information about the AdminSite. This added information could be stored in the LogEntry in an indirect manner (e.g., stored in the change_message as a serialized dict or utilizing a custom field that can encode this context). The challenge is to do this in a backward-compatible way, ensuring that existing functionality remains intact while providing the necessary hooks or information for AdminSite-specific LogEntry filtering."
        },
        {
            "file": "django/contrib/admin/sites.py",
            "class": "AdminSite",
            "method": "register",
            "intended_behavior": "While the register method itself may not need modification for direct bug resolution, ensuring its interaction with the logging mechanism considers AdminSite context is crucial. There may be value in exploring mechanisms within this method to implicitly or explicitly tag LogEntry instances with AdminSite identification upon registration or action logging. This implies a broader strategy of integrating AdminSite context awareness into actions logged via the ModelAdmin methods above."
        },
        {
            "file": "django/contrib/admin/views/main.py",
            "class": "",
            "method": "",
            "intended_behavior": "Implementing or enhancing a get_queryset method (or similar) specifically for filtering LogEntry instances based on the admin site. This could involve adding new mechanisms or utilities that customize LogEntry queryset fetching to include consideration of AdminSite context, likely utilizing indirect identification or tagging mechanisms as mentioned earlier."
        }
    ]
}
2025-10-18 13:30:44.346 | DEBUG    | Bug location extracted successfully: [<file>django/contrib/admin/options.py</file>
<class>ModelAdmin</class>
<method>None</method>
<code>
614 class ModelAdmin(BaseModelAdmin):
615     """Encapsulate all admin options and functionality for a given model."""
616 
617     list_display = ("__str__",)
618     list_display_links = ()
619     list_filter = ()
620     list_select_related = False
621     list_per_page = 100
622     list_max_show_all = 200
623     list_editable = ()
624     search_fields = ()
625     search_help_text = None
626     date_hierarchy = None
627     save_as = False
628     save_as_continue = True
629     save_on_top = False
630     paginator = Paginator
631     preserve_filters = True
632     inlines = ()
633 
634     # Custom templates (designed to be over-ridden in subclasses)
635     add_form_template = None
636     change_form_template = None
637     change_list_template = None
638     delete_confirmation_template = None
639     delete_selected_confirmation_template = None
640     object_history_template = None
641     popup_response_template = None
642 
643     # Actions
644     actions = ()
645     action_form = helpers.ActionForm
646     actions_on_top = True
647     actions_on_bottom = False
648     actions_selection_counter = True
649     checks_class = ModelAdminChecks
650 
651     def __init__(self, model, admin_site):
652         self.model = model
653         self.opts = model._meta
654         self.admin_site = admin_site
655         super().__init__()
656 
657     def __str__(self):
658         return "%s.%s" % (self.opts.app_label, self.__class__.__name__)
659 
660     def __repr__(self):
661         return (
662             f"<{self.__class__.__qualname__}: model={self.model.__qualname__} "
663             f"site={self.admin_site!r}>"
664         )
665 
666     def get_inline_instances(self, request, obj=None):
667         inline_instances = []
668         for inline_class in self.get_inlines(request, obj):
669             inline = inline_class(self.model, self.admin_site)
670             if request:
671                 if not (
672                     inline.has_view_or_change_permission(request, obj)
673                     or inline.has_add_permission(request, obj)
674                     or inline.has_delete_permission(request, obj)
675                 ):
676                     continue
677                 if not inline.has_add_permission(request, obj):
678                     inline.max_num = 0
679             inline_instances.append(inline)
680 
681         return inline_instances
682 
683     def get_urls(self):
684         from django.urls import path
685 
686         def wrap(view):
687             def wrapper(*args, **kwargs):
688                 return self.admin_site.admin_view(view)(*args, **kwargs)
689 
690             wrapper.model_admin = self
691             return update_wrapper(wrapper, view)
692 
693         info = self.opts.app_label, self.opts.model_name
694 
695         return [
696             path("", wrap(self.changelist_view), name="%s_%s_changelist" % info),
697             path("add/", wrap(self.add_view), name="%s_%s_add" % info),
698             path(
699                 "<path:object_id>/history/",
700                 wrap(self.history_view),
701                 name="%s_%s_history" % info,
702             ),
703             path(
704                 "<path:object_id>/delete/",
705                 wrap(self.delete_view),
706                 name="%s_%s_delete" % info,
707             ),
708             path(
709                 "<path:object_id>/change/",
710                 wrap(self.change_view),
711                 name="%s_%s_change" % info,
712             ),
713             # For backwards compatibility (was the change url before 1.9)
714             path(
715                 "<path:object_id>/",
716                 wrap(
717                     RedirectView.as_view(
718                         pattern_name="%s:%s_%s_change"
719                         % ((self.admin_site.name,) + info)
720                     )
721                 ),
722             ),
723         ]
724 
725     @property
726     def urls(self):
727         return self.get_urls()
728 
729     @property
730     def media(self):
731         extra = "" if settings.DEBUG else ".min"
732         js = [
733             "vendor/jquery/jquery%s.js" % extra,
734             "jquery.init.js",
735             "core.js",
736             "admin/RelatedObjectLookups.js",
737             "actions.js",
738             "urlify.js",
739             "prepopulate.js",
740             "vendor/xregexp/xregexp%s.js" % extra,
741         ]
742         return forms.Media(js=["admin/js/%s" % url for url in js])
743 
744     def get_model_perms(self, request):
745         """
746         Return a dict of all perms for this model. This dict has the keys
747         ``add``, ``change``, ``delete``, and ``view`` mapping to the True/False
748         for each of those actions.
749         """
750         return {
751             "add": self.has_add_permission(request),
752             "change": self.has_change_permission(request),
753             "delete": self.has_delete_permission(request),
754             "view": self.has_view_permission(request),
755         }
756 
757     def _get_form_for_get_fields(self, request, obj):
758         return self.get_form(request, obj, fields=None)
759 
760     def get_form(self, request, obj=None, change=False, **kwargs):
761         """
762         Return a Form class for use in the admin add view. This is used by
763         add_view and change_view.
764         """
765         if "fields" in kwargs:
766             fields = kwargs.pop("fields")
767         else:
768             fields = flatten_fieldsets(self.get_fieldsets(request, obj))
769         excluded = self.get_exclude(request, obj)
770         exclude = [] if excluded is None else list(excluded)
771         readonly_fields = self.get_readonly_fields(request, obj)
772         exclude.extend(readonly_fields)
773         # Exclude all fields if it's a change form and the user doesn't have
774         # the change permission.
775         if (
776             change
777             and hasattr(request, "user")
778             and not self.has_change_permission(request, obj)
779         ):
780             exclude.extend(fields)
781         if excluded is None and hasattr(self.form, "_meta") and self.form._meta.exclude:
782             # Take the custom ModelForm's Meta.exclude into account only if the
783             # ModelAdmin doesn't define its own.
784             exclude.extend(self.form._meta.exclude)
785         # if exclude is an empty list we pass None to be consistent with the
786         # default on modelform_factory
787         exclude = exclude or None
788 
789         # Remove declared form fields which are in readonly_fields.
790         new_attrs = dict.fromkeys(
791             f for f in readonly_fields if f in self.form.declared_fields
792         )
793         form = type(self.form.__name__, (self.form,), new_attrs)
794 
795         defaults = {
796             "form": form,
797             "fields": fields,
798             "exclude": exclude,
799             "formfield_callback": partial(self.formfield_for_dbfield, request=request),
800             **kwargs,
801         }
802 
803         if defaults["fields"] is None and not modelform_defines_fields(
804             defaults["form"]
805         ):
806             defaults["fields"] = forms.ALL_FIELDS
807 
808         try:
809             return modelform_factory(self.model, **defaults)
810         except FieldError as e:
811             raise FieldError(
812                 "%s. Check fields/fieldsets/exclude attributes of class %s."
813                 % (e, self.__class__.__name__)
814             )
815 
816     def get_changelist(self, request, **kwargs):
817         """
818         Return the ChangeList class for use on the changelist page.
819         """
820         from django.contrib.admin.views.main import ChangeList
821 
822         return ChangeList
823 
824     def get_changelist_instance(self, request):
825         """
826         Return a `ChangeList` instance based on `request`. May raise
827         `IncorrectLookupParameters`.
828         """
829         list_display = self.get_list_display(request)
830         list_display_links = self.get_list_display_links(request, list_display)
831         # Add the action checkboxes if any actions are available.
832         if self.get_actions(request):
833             list_display = ["action_checkbox", *list_display]
834         sortable_by = self.get_sortable_by(request)
835         ChangeList = self.get_changelist(request)
836         return ChangeList(
837             request,
838             self.model,
839             list_display,
840             list_display_links,
841             self.get_list_filter(request),
842             self.date_hierarchy,
843             self.get_search_fields(request),
844             self.get_list_select_related(request),
845             self.list_per_page,
846             self.list_max_show_all,
847             self.list_editable,
848             self,
849             sortable_by,
850             self.search_help_text,
851         )
852 
853     def get_object(self, request, object_id, from_field=None):
854         """
855         Return an instance matching the field and value provided, the primary
856         key is used if no field is provided. Return ``None`` if no match is
857         found or the object_id fails validation.
858         """
859         queryset = self.get_queryset(request)
860         model = queryset.model
861         field = (
862             model._meta.pk if from_field is None else model._meta.get_field(from_field)
863         )
864         try:
865             object_id = field.to_python(object_id)
866             return queryset.get(**{field.name: object_id})
867         except (model.DoesNotExist, ValidationError, ValueError):
868             return None
869 
870     def get_changelist_form(self, request, **kwargs):
871         """
872         Return a Form class for use in the Formset on the changelist page.
873         """
874         defaults = {
875             "formfield_callback": partial(self.formfield_for_dbfield, request=request),
876             **kwargs,
877         }
878         if defaults.get("fields") is None and not modelform_defines_fields(
879             defaults.get("form")
880         ):
881             defaults["fields"] = forms.ALL_FIELDS
882 
883         return modelform_factory(self.model, **defaults)
884 
885     def get_changelist_formset(self, request, **kwargs):
886         """
887         Return a FormSet class for use on the changelist page if list_editable
888         is used.
889         """
890         defaults = {
891             "formfield_callback": partial(self.formfield_for_dbfield, request=request),
892             **kwargs,
893         }
894         return modelformset_factory(
895             self.model,
896             self.get_changelist_form(request),
897             extra=0,
898             fields=self.list_editable,
899             **defaults,
900         )
901 
902     def get_formsets_with_inlines(self, request, obj=None):
903         """
904         Yield formsets and the corresponding inlines.
905         """
906         for inline in self.get_inline_instances(request, obj):
907             yield inline.get_formset(request, obj), inline
908 
909     def get_paginator(
910         self, request, queryset, per_page, orphans=0, allow_empty_first_page=True
911     ):
912         return self.paginator(queryset, per_page, orphans, allow_empty_first_page)
913 
914     def log_addition(self, request, obj, message):
915         """
916         Log that an object has been successfully added.
917 
918         The default implementation creates an admin LogEntry object.
919         """
920         from django.contrib.admin.models import ADDITION, LogEntry
921 
922         return LogEntry.objects.log_action(
923             user_id=request.user.pk,
924             content_type_id=get_content_type_for_model(obj).pk,
925             object_id=obj.pk,
926             object_repr=str(obj),
927             action_flag=ADDITION,
928             change_message=message,
929         )
930 
931     def log_change(self, request, obj, message):
932         """
933         Log that an object has been successfully changed.
934 
935         The default implementation creates an admin LogEntry object.
936         """
937         from django.contrib.admin.models import CHANGE, LogEntry
938 
939         return LogEntry.objects.log_action(
940             user_id=request.user.pk,
941             content_type_id=get_content_type_for_model(obj).pk,
942             object_id=obj.pk,
943             object_repr=str(obj),
944             action_flag=CHANGE,
945             change_message=message,
946         )
947 
948     def log_deletion(self, request, obj, object_repr):
949         """
950         Log that an object will be deleted. Note that this method must be
951         called before the deletion.
952 
953         The default implementation creates an admin LogEntry object.
954         """
955         from django.contrib.admin.models import DELETION, LogEntry
956 
957         return LogEntry.objects.log_action(
958             user_id=request.user.pk,
959             content_type_id=get_content_type_for_model(obj).pk,
960             object_id=obj.pk,
961             object_repr=object_repr,
962             action_flag=DELETION,
963         )
964 
965     @display(description=mark_safe('<input type="checkbox" id="action-toggle">'))
966     def action_checkbox(self, obj):
967         """
968         A list_display column containing a checkbox widget.
969         """
970         return helpers.checkbox.render(helpers.ACTION_CHECKBOX_NAME, str(obj.pk))
971 
972     @staticmethod
973     def _get_action_description(func, name):
974         return getattr(func, "short_description", capfirst(name.replace("_", " ")))
975 
976     def _get_base_actions(self):
977         """Return the list of actions, prior to any request-based filtering."""
978         actions = []
979         base_actions = (self.get_action(action) for action in self.actions or [])
980         # get_action might have returned None, so filter any of those out.
981         base_actions = [action for action in base_actions if action]
982         base_action_names = {name for _, name, _ in base_actions}
983 
984         # Gather actions from the admin site first
985         for name, func in self.admin_site.actions:
986             if name in base_action_names:
987                 continue
988             description = self._get_action_description(func, name)
989             actions.append((func, name, description))
990         # Add actions from this ModelAdmin.
991         actions.extend(base_actions)
992         return actions
993 
994     def _filter_actions_by_permissions(self, request, actions):
995         """Filter out any actions that the user doesn't have access to."""
996         filtered_actions = []
997         for action in actions:
998             callable = action[0]
999             if not hasattr(callable, "allowed_permissions"):
1000                 filtered_actions.append(action)
1001                 continue
1002             permission_checks = (
1003                 getattr(self, "has_%s_permission" % permission)
1004                 for permission in callable.allowed_permissions
1005             )
1006             if any(has_permission(request) for has_permission in permission_checks):
1007                 filtered_actions.append(action)
1008         return filtered_actions
1009 
1010     def get_actions(self, request):
1011         """
1012         Return a dictionary mapping the names of all actions for this
1013         ModelAdmin to a tuple of (callable, name, description) for each action.
1014         """
1015         # If self.actions is set to None that means actions are disabled on
1016         # this page.
1017         if self.actions is None or IS_POPUP_VAR in request.GET:
1018             return {}
1019         actions = self._filter_actions_by_permissions(request, self._get_base_actions())
1020         return {name: (func, name, desc) for func, name, desc in actions}
1021 
1022     def get_action_choices(self, request, default_choices=models.BLANK_CHOICE_DASH):
1023         """
1024         Return a list of choices for use in a form object.  Each choice is a
1025         tuple (name, description).
1026         """
1027         choices = [] + default_choices
1028         for func, name, description in self.get_actions(request).values():
1029             choice = (name, description % model_format_dict(self.opts))
1030             choices.append(choice)
1031         return choices
1032 
1033     def get_action(self, action):
1034         """
1035         Return a given action from a parameter, which can either be a callable,
1036         or the name of a method on the ModelAdmin.  Return is a tuple of
1037         (callable, name, description).
1038         """
1039         # If the action is a callable, just use it.
1040         if callable(action):
1041             func = action
1042             action = action.__name__
1043 
1044         # Next, look for a method. Grab it off self.__class__ to get an unbound
1045         # method instead of a bound one; this ensures that the calling
1046         # conventions are the same for functions and methods.
1047         elif hasattr(self.__class__, action):
1048             func = getattr(self.__class__, action)
1049 
1050         # Finally, look for a named method on the admin site
1051         else:
1052             try:
1053                 func = self.admin_site.get_action(action)
1054             except KeyError:
1055                 return None
1056 
1057         description = self._get_action_description(func, action)
1058         return func, action, description
1059 
1060     def get_list_display(self, request):
1061         """
1062         Return a sequence containing the fields to be displayed on the
1063         changelist.
1064         """
1065         return self.list_display
1066 
1067     def get_list_display_links(self, request, list_display):
1068         """
1069         Return a sequence containing the fields to be displayed as links
1070         on the changelist. The list_display parameter is the list of fields
1071         returned by get_list_display().
1072         """
1073         if (
1074             self.list_display_links
1075             or self.list_display_links is None
1076             or not list_display
1077         ):
1078             return self.list_display_links
1079         else:
1080             # Use only the first item in list_display as link
1081             return list(list_display)[:1]
1082 
1083     def get_list_filter(self, request):
1084         """
1085         Return a sequence containing the fields to be displayed as filters in
1086         the right sidebar of the changelist page.
1087         """
1088         return self.list_filter
1089 
1090     def get_list_select_related(self, request):
1091         """
1092         Return a list of fields to add to the select_related() part of the
1093         changelist items query.
1094         """
1095         return self.list_select_related
1096 
1097     def get_search_fields(self, request):
1098         """
1099         Return a sequence containing the fields to be searched whenever
1100         somebody submits a search query.
1101         """
1102         return self.search_fields
1103 
1104     def get_search_results(self, request, queryset, search_term):
1105         """
1106         Return a tuple containing a queryset to implement the search
1107         and a boolean indicating if the results may contain duplicates.
1108         """
1109 
1110         # Apply keyword searches.
1111         def construct_search(field_name):
1112             if field_name.startswith("^"):
1113                 return "%s__istartswith" % field_name.removeprefix("^")
1114             elif field_name.startswith("="):
1115                 return "%s__iexact" % field_name.removeprefix("=")
1116             elif field_name.startswith("@"):
1117                 return "%s__search" % field_name.removeprefix("@")
1118             # Use field_name if it includes a lookup.
1119             opts = queryset.model._meta
1120             lookup_fields = field_name.split(LOOKUP_SEP)
1121             # Go through the fields, following all relations.
1122             prev_field = None
1123             for path_part in lookup_fields:
1124                 if path_part == "pk":
1125                     path_part = opts.pk.name
1126                 try:
1127                     field = opts.get_field(path_part)
1128                 except FieldDoesNotExist:
1129                     # Use valid query lookups.
1130                     if prev_field and prev_field.get_lookup(path_part):
1131                         return field_name
1132                 else:
1133                     prev_field = field
1134                     if hasattr(field, "path_infos"):
1135                         # Update opts to follow the relation.
1136                         opts = field.path_infos[-1].to_opts
1137             # Otherwise, use the field with icontains.
1138             return "%s__icontains" % field_name
1139 
1140         may_have_duplicates = False
1141         search_fields = self.get_search_fields(request)
1142         if search_fields and search_term:
1143             orm_lookups = [
1144                 construct_search(str(search_field)) for search_field in search_fields
1145             ]
1146             term_queries = []
1147             for bit in smart_split(search_term):
1148                 if bit.startswith(('"', "'")) and bit[0] == bit[-1]:
1149                     bit = unescape_string_literal(bit)
1150                 or_queries = models.Q.create(
1151                     [(orm_lookup, bit) for orm_lookup in orm_lookups],
1152                     connector=models.Q.OR,
1153                 )
1154                 term_queries.append(or_queries)
1155             queryset = queryset.filter(models.Q.create(term_queries))
1156             may_have_duplicates |= any(
1157                 lookup_spawns_duplicates(self.opts, search_spec)
1158                 for search_spec in orm_lookups
1159             )
1160         return queryset, may_have_duplicates
1161 
1162     def get_preserved_filters(self, request):
1163         """
1164         Return the preserved filters querystring.
1165         """
1166         match = request.resolver_match
1167         if self.preserve_filters and match:
1168             current_url = "%s:%s" % (match.app_name, match.url_name)
1169             changelist_url = "admin:%s_%s_changelist" % (
1170                 self.opts.app_label,
1171                 self.opts.model_name,
1172             )
1173             if current_url == changelist_url:
1174                 preserved_filters = request.GET.urlencode()
1175             else:
1176                 preserved_filters = request.GET.get("_changelist_filters")
1177 
1178             if preserved_filters:
1179                 return urlencode({"_changelist_filters": preserved_filters})
1180         return ""
1181 
1182     def construct_change_message(self, request, form, formsets, add=False):
1183         """
1184         Construct a JSON structure describing changes from a changed object.
1185         """
1186         return construct_change_message(form, formsets, add)
1187 
1188     def message_user(
1189         self, request, message, level=messages.INFO, extra_tags="", fail_silently=False
1190     ):
1191         """
1192         Send a message to the user. The default implementation
1193         posts a message using the django.contrib.messages backend.
1194 
1195         Exposes almost the same API as messages.add_message(), but accepts the
1196         positional arguments in a different order to maintain backwards
1197         compatibility. For convenience, it accepts the `level` argument as
1198         a string rather than the usual level number.
1199         """
1200         if not isinstance(level, int):
1201             # attempt to get the level if passed a string
1202             try:
1203                 level = getattr(messages.constants, level.upper())
1204             except AttributeError:
1205                 levels = messages.constants.DEFAULT_TAGS.values()
1206                 levels_repr = ", ".join("`%s`" % level for level in levels)
1207                 raise ValueError(
1208                     "Bad message level string: `%s`. Possible values are: %s"
1209                     % (level, levels_repr)
1210                 )
1211 
1212         messages.add_message(
1213             request, level, message, extra_tags=extra_tags, fail_silently=fail_silently
1214         )
1215 
1216     def save_form(self, request, form, change):
1217         """
1218         Given a ModelForm return an unsaved instance. ``change`` is True if
1219         the object is being changed, and False if it's being added.
1220         """
1221         return form.save(commit=False)
1222 
1223     def save_model(self, request, obj, form, change):
1224         """
1225         Given a model instance save it to the database.
1226         """
1227         obj.save()
1228 
1229     def delete_model(self, request, obj):
1230         """
1231         Given a model instance delete it from the database.
1232         """
1233         obj.delete()
1234 
1235     def delete_queryset(self, request, queryset):
1236         """Given a queryset, delete it from the database."""
1237         queryset.delete()
1238 
1239     def save_formset(self, request, form, formset, change):
1240         """
1241         Given an inline formset save it to the database.
1242         """
1243         formset.save()
1244 
1245     def save_related(self, request, form, formsets, change):
1246         """
1247         Given the ``HttpRequest``, the parent ``ModelForm`` instance, the
1248         list of inline formsets and a boolean value based on whether the
1249         parent is being added or changed, save the related objects to the
1250         database. Note that at this point save_form() and save_model() have
1251         already been called.
1252         """
1253         form.save_m2m()
1254         for formset in formsets:
1255             self.save_formset(request, form, formset, change=change)
1256 
1257     def render_change_form(
1258         self, request, context, add=False, change=False, form_url="", obj=None
1259     ):
1260         app_label = self.opts.app_label
1261         preserved_filters = self.get_preserved_filters(request)
1262         form_url = add_preserved_filters(
1263             {"preserved_filters": preserved_filters, "opts": self.opts}, form_url
1264         )
1265         view_on_site_url = self.get_view_on_site_url(obj)
1266         has_editable_inline_admin_formsets = False
1267         for inline in context["inline_admin_formsets"]:
1268             if (
1269                 inline.has_add_permission
1270                 or inline.has_change_permission
1271                 or inline.has_delete_permission
1272             ):
1273                 has_editable_inline_admin_formsets = True
1274                 break
1275         context.update(
1276             {
1277                 "add": add,
1278                 "change": change,
1279                 "has_view_permission": self.has_view_permission(request, obj),
1280                 "has_add_permission": self.has_add_permission(request),
1281                 "has_change_permission": self.has_change_permission(request, obj),
1282                 "has_delete_permission": self.has_delete_permission(request, obj),
1283                 "has_editable_inline_admin_formsets": (
1284                     has_editable_inline_admin_formsets
1285                 ),
1286                 "has_file_field": context["adminform"].form.is_multipart()
1287                 or any(
1288                     admin_formset.formset.is_multipart()
1289                     for admin_formset in context["inline_admin_formsets"]
1290                 ),
1291                 "has_absolute_url": view_on_site_url is not None,
1292                 "absolute_url": view_on_site_url,
1293                 "form_url": form_url,
1294                 "opts": self.opts,
1295                 "content_type_id": get_content_type_for_model(self.model).pk,
1296                 "save_as": self.save_as,
1297                 "save_on_top": self.save_on_top,
1298                 "to_field_var": TO_FIELD_VAR,
1299                 "is_popup_var": IS_POPUP_VAR,
1300                 "app_label": app_label,
1301             }
1302         )
1303         if add and self.add_form_template is not None:
1304             form_template = self.add_form_template
1305         else:
1306             form_template = self.change_form_template
1307 
1308         request.current_app = self.admin_site.name
1309 
1310         return TemplateResponse(
1311             request,
1312             form_template
1313             or [
1314                 "admin/%s/%s/change_form.html" % (app_label, self.opts.model_name),
1315                 "admin/%s/change_form.html" % app_label,
1316                 "admin/change_form.html",
1317             ],
1318             context,
1319         )
1320 
1321     def response_add(self, request, obj, post_url_continue=None):
1322         """
1323         Determine the HttpResponse for the add_view stage.
1324         """
1325         opts = obj._meta
1326         preserved_filters = self.get_preserved_filters(request)
1327         obj_url = reverse(
1328             "admin:%s_%s_change" % (opts.app_label, opts.model_name),
1329             args=(quote(obj.pk),),
1330             current_app=self.admin_site.name,
1331         )
1332         # Add a link to the object's change form if the user can edit the obj.
1333         if self.has_change_permission(request, obj):
1334             obj_repr = format_html('<a href="{}">{}</a>', urlquote(obj_url), obj)
1335         else:
1336             obj_repr = str(obj)
1337         msg_dict = {
1338             "name": opts.verbose_name,
1339             "obj": obj_repr,
1340         }
1341         # Here, we distinguish between different save types by checking for
1342         # the presence of keys in request.POST.
1343 
1344         if IS_POPUP_VAR in request.POST:
1345             to_field = request.POST.get(TO_FIELD_VAR)
1346             if to_field:
1347                 attr = str(to_field)
1348             else:
1349                 attr = obj._meta.pk.attname
1350             value = obj.serializable_value(attr)
1351             popup_response_data = json.dumps(
1352                 {
1353                     "value": str(value),
1354                     "obj": str(obj),
1355                 }
1356             )
1357             return TemplateResponse(
1358                 request,
1359                 self.popup_response_template
1360                 or [
1361                     "admin/%s/%s/popup_response.html"
1362                     % (opts.app_label, opts.model_name),
1363                     "admin/%s/popup_response.html" % opts.app_label,
1364                     "admin/popup_response.html",
1365                 ],
1366                 {
1367                     "popup_response_data": popup_response_data,
1368                 },
1369             )
1370 
1371         elif "_continue" in request.POST or (
1372             # Redirecting after "Save as new".
1373             "_saveasnew" in request.POST
1374             and self.save_as_continue
1375             and self.has_change_permission(request, obj)
1376         ):
1377             msg = _("The {name} “{obj}” was added successfully.")
1378             if self.has_change_permission(request, obj):
1379                 msg += " " + _("You may edit it again below.")
1380             self.message_user(request, format_html(msg, **msg_dict), messages.SUCCESS)
1381             if post_url_continue is None:
1382                 post_url_continue = obj_url
1383             post_url_continue = add_preserved_filters(
1384                 {"preserved_filters": preserved_filters, "opts": opts},
1385                 post_url_continue,
1386             )
1387             return HttpResponseRedirect(post_url_continue)
1388 
1389         elif "_addanother" in request.POST:
1390             msg = format_html(
1391                 _(
1392                     "The {name} “{obj}” was added successfully. You may add another "
1393                     "{name} below."
1394                 ),
1395                 **msg_dict,
1396             )
1397             self.message_user(request, msg, messages.SUCCESS)
1398             redirect_url = request.path
1399             redirect_url = add_preserved_filters(
1400                 {"preserved_filters": preserved_filters, "opts": opts}, redirect_url
1401             )
1402             return HttpResponseRedirect(redirect_url)
1403 
1404         else:
1405             msg = format_html(
1406                 _("The {name} “{obj}” was added successfully."), **msg_dict
1407             )
1408             self.message_user(request, msg, messages.SUCCESS)
1409             return self.response_post_save_add(request, obj)
1410 
1411     def response_change(self, request, obj):
1412         """
1413         Determine the HttpResponse for the change_view stage.
1414         """
1415 
1416         if IS_POPUP_VAR in request.POST:
1417             opts = obj._meta
1418             to_field = request.POST.get(TO_FIELD_VAR)
1419             attr = str(to_field) if to_field else opts.pk.attname
1420             value = request.resolver_match.kwargs["object_id"]
1421             new_value = obj.serializable_value(attr)
1422             popup_response_data = json.dumps(
1423                 {
1424                     "action": "change",
1425                     "value": str(value),
1426                     "obj": str(obj),
1427                     "new_value": str(new_value),
1428                 }
1429             )
1430             return TemplateResponse(
1431                 request,
1432                 self.popup_response_template
1433                 or [
1434                     "admin/%s/%s/popup_response.html"
1435                     % (opts.app_label, opts.model_name),
1436                     "admin/%s/popup_response.html" % opts.app_label,
1437                     "admin/popup_response.html",
1438                 ],
1439                 {
1440                     "popup_response_data": popup_response_data,
1441                 },
1442             )
1443 
1444         opts = self.opts
1445         preserved_filters = self.get_preserved_filters(request)
1446 
1447         msg_dict = {
1448             "name": opts.verbose_name,
1449             "obj": format_html('<a href="{}">{}</a>', urlquote(request.path), obj),
1450         }
1451         if "_continue" in request.POST:
1452             msg = format_html(
1453                 _(
1454                     "The {name} “{obj}” was changed successfully. You may edit it "
1455                     "again below."
1456                 ),
1457                 **msg_dict,
1458             )
1459             self.message_user(request, msg, messages.SUCCESS)
1460             redirect_url = request.path
1461             redirect_url = add_preserved_filters(
1462                 {"preserved_filters": preserved_filters, "opts": opts}, redirect_url
1463             )
1464             return HttpResponseRedirect(redirect_url)
1465 
1466         elif "_saveasnew" in request.POST:
1467             msg = format_html(
1468                 _(
1469                     "The {name} “{obj}” was added successfully. You may edit it again "
1470                     "below."
1471                 ),
1472                 **msg_dict,
1473             )
1474             self.message_user(request, msg, messages.SUCCESS)
1475             redirect_url = reverse(
1476                 "admin:%s_%s_change" % (opts.app_label, opts.model_name),
1477                 args=(obj.pk,),
1478                 current_app=self.admin_site.name,
1479             )
1480             redirect_url = add_preserved_filters(
1481                 {"preserved_filters": preserved_filters, "opts": opts}, redirect_url
1482             )
1483             return HttpResponseRedirect(redirect_url)
1484 
1485         elif "_addanother" in request.POST:
1486             msg = format_html(
1487                 _(
1488                     "The {name} “{obj}” was changed successfully. You may add another "
1489                     "{name} below."
1490                 ),
1491                 **msg_dict,
1492             )
1493             self.message_user(request, msg, messages.SUCCESS)
1494             redirect_url = reverse(
1495                 "admin:%s_%s_add" % (opts.app_label, opts.model_name),
1496                 current_app=self.admin_site.name,
1497             )
1498             redirect_url = add_preserved_filters(
1499                 {"preserved_filters": preserved_filters, "opts": opts}, redirect_url
1500             )
1501             return HttpResponseRedirect(redirect_url)
1502 
1503         else:
1504             msg = format_html(
1505                 _("The {name} “{obj}” was changed successfully."), **msg_dict
1506             )
1507             self.message_user(request, msg, messages.SUCCESS)
1508             return self.response_post_save_change(request, obj)
1509 
1510     def _response_post_save(self, request, obj):
1511         if self.has_view_or_change_permission(request):
1512             post_url = reverse(
1513                 "admin:%s_%s_changelist" % (self.opts.app_label, self.opts.model_name),
1514                 current_app=self.admin_site.name,
1515             )
1516             preserved_filters = self.get_preserved_filters(request)
1517             post_url = add_preserved_filters(
1518                 {"preserved_filters": preserved_filters, "opts": self.opts}, post_url
1519             )
1520         else:
1521             post_url = reverse("admin:index", current_app=self.admin_site.name)
1522         return HttpResponseRedirect(post_url)
1523 
1524     def response_post_save_add(self, request, obj):
1525         """
1526         Figure out where to redirect after the 'Save' button has been pressed
1527         when adding a new object.
1528         """
1529         return self._response_post_save(request, obj)
1530 
1531     def response_post_save_change(self, request, obj):
1532         """
1533         Figure out where to redirect after the 'Save' button has been pressed
1534         when editing an existing object.
1535         """
1536         return self._response_post_save(request, obj)
1537 
1538     def response_action(self, request, queryset):
1539         """
1540         Handle an admin action. This is called if a request is POSTed to the
1541         changelist; it returns an HttpResponse if the action was handled, and
1542         None otherwise.
1543         """
1544 
1545         # There can be multiple action forms on the page (at the top
1546         # and bottom of the change list, for example). Get the action
1547         # whose button was pushed.
1548         try:
1549             action_index = int(request.POST.get("index", 0))
1550         except ValueError:
1551             action_index = 0
1552 
1553         # Construct the action form.
1554         data = request.POST.copy()
1555         data.pop(helpers.ACTION_CHECKBOX_NAME, None)
1556         data.pop("index", None)
1557 
1558         # Use the action whose button was pushed
1559         try:
1560             data.update({"action": data.getlist("action")[action_index]})
1561         except IndexError:
1562             # If we didn't get an action from the chosen form that's invalid
1563             # POST data, so by deleting action it'll fail the validation check
1564             # below. So no need to do anything here
1565             pass
1566 
1567         action_form = self.action_form(data, auto_id=None)
1568         action_form.fields["action"].choices = self.get_action_choices(request)
1569 
1570         # If the form's valid we can handle the action.
1571         if action_form.is_valid():
1572             action = action_form.cleaned_data["action"]
1573             select_across = action_form.cleaned_data["select_across"]
1574             func = self.get_actions(request)[action][0]
1575 
1576             # Get the list of selected PKs. If nothing's selected, we can't
1577             # perform an action on it, so bail. Except we want to perform
1578             # the action explicitly on all objects.
1579             selected = request.POST.getlist(helpers.ACTION_CHECKBOX_NAME)
1580             if not selected and not select_across:
1581                 # Reminder that something needs to be selected or nothing will happen
1582                 msg = _(
1583                     "Items must be selected in order to perform "
1584                     "actions on them. No items have been changed."
1585                 )
1586                 self.message_user(request, msg, messages.WARNING)
1587                 return None
1588 
1589             if not select_across:
1590                 # Perform the action only on the selected objects
1591                 queryset = queryset.filter(pk__in=selected)
1592 
1593             response = func(self, request, queryset)
1594 
1595             # Actions may return an HttpResponse-like object, which will be
1596             # used as the response from the POST. If not, we'll be a good
1597             # little HTTP citizen and redirect back to the changelist page.
1598             if isinstance(response, HttpResponseBase):
1599                 return response
1600             else:
1601                 return HttpResponseRedirect(request.get_full_path())
1602         else:
1603             msg = _("No action selected.")
1604             self.message_user(request, msg, messages.WARNING)
1605             return None
1606 
1607     def response_delete(self, request, obj_display, obj_id):
1608         """
1609         Determine the HttpResponse for the delete_view stage.
1610         """
1611         if IS_POPUP_VAR in request.POST:
1612             popup_response_data = json.dumps(
1613                 {
1614                     "action": "delete",
1615                     "value": str(obj_id),
1616                 }
1617             )
1618             return TemplateResponse(
1619                 request,
1620                 self.popup_response_template
1621                 or [
1622                     "admin/%s/%s/popup_response.html"
1623                     % (self.opts.app_label, self.opts.model_name),
1624                     "admin/%s/popup_response.html" % self.opts.app_label,
1625                     "admin/popup_response.html",
1626                 ],
1627                 {
1628                     "popup_response_data": popup_response_data,
1629                 },
1630             )
1631 
1632         self.message_user(
1633             request,
1634             _("The %(name)s “%(obj)s” was deleted successfully.")
1635             % {
1636                 "name": self.opts.verbose_name,
1637                 "obj": obj_display,
1638             },
1639             messages.SUCCESS,
1640         )
1641 
1642         if self.has_change_permission(request, None):
1643             post_url = reverse(
1644                 "admin:%s_%s_changelist" % (self.opts.app_label, self.opts.model_name),
1645                 current_app=self.admin_site.name,
1646             )
1647             preserved_filters = self.get_preserved_filters(request)
1648             post_url = add_preserved_filters(
1649                 {"preserved_filters": preserved_filters, "opts": self.opts}, post_url
1650             )
1651         else:
1652             post_url = reverse("admin:index", current_app=self.admin_site.name)
1653         return HttpResponseRedirect(post_url)
1654 
1655     def render_delete_form(self, request, context):
1656         app_label = self.opts.app_label
1657 
1658         request.current_app = self.admin_site.name
1659         context.update(
1660             to_field_var=TO_FIELD_VAR,
1661             is_popup_var=IS_POPUP_VAR,
1662             media=self.media,
1663         )
1664 
1665         return TemplateResponse(
1666             request,
1667             self.delete_confirmation_template
1668             or [
1669                 "admin/{}/{}/delete_confirmation.html".format(
1670                     app_label, self.opts.model_name
1671                 ),
1672                 "admin/{}/delete_confirmation.html".format(app_label),
1673                 "admin/delete_confirmation.html",
1674             ],
1675             context,
1676         )
1677 
1678     def get_inline_formsets(self, request, formsets, inline_instances, obj=None):
1679         # Edit permissions on parent model are required for editable inlines.
1680         can_edit_parent = (
1681             self.has_change_permission(request, obj)
1682             if obj
1683             else self.has_add_permission(request)
1684         )
1685         inline_admin_formsets = []
1686         for inline, formset in zip(inline_instances, formsets):
1687             fieldsets = list(inline.get_fieldsets(request, obj))
1688             readonly = list(inline.get_readonly_fields(request, obj))
1689             if can_edit_parent:
1690                 has_add_permission = inline.has_add_permission(request, obj)
1691                 has_change_permission = inline.has_change_permission(request, obj)
1692                 has_delete_permission = inline.has_delete_permission(request, obj)
1693             else:
1694                 # Disable all edit-permissions, and override formset settings.
1695                 has_add_permission = (
1696                     has_change_permission
1697                 ) = has_delete_permission = False
1698                 formset.extra = formset.max_num = 0
1699             has_view_permission = inline.has_view_permission(request, obj)
1700             prepopulated = dict(inline.get_prepopulated_fields(request, obj))
1701             inline_admin_formset = helpers.InlineAdminFormSet(
1702                 inline,
1703                 formset,
1704                 fieldsets,
1705                 prepopulated,
1706                 readonly,
1707                 model_admin=self,
1708                 has_add_permission=has_add_permission,
1709                 has_change_permission=has_change_permission,
1710                 has_delete_permission=has_delete_permission,
1711                 has_view_permission=has_view_permission,
1712             )
1713             inline_admin_formsets.append(inline_admin_formset)
1714         return inline_admin_formsets
1715 
1716     def get_changeform_initial_data(self, request):
1717         """
1718         Get the initial form data from the request's GET params.
1719         """
1720         initial = dict(request.GET.items())
1721         for k in initial:
1722             try:
1723                 f = self.opts.get_field(k)
1724             except FieldDoesNotExist:
1725                 continue
1726             # We have to special-case M2Ms as a list of comma-separated PKs.
1727             if isinstance(f, models.ManyToManyField):
1728                 initial[k] = initial[k].split(",")
1729         return initial
1730 
1731     def _get_obj_does_not_exist_redirect(self, request, opts, object_id):
1732         """
1733         Create a message informing the user that the object doesn't exist
1734         and return a redirect to the admin index page.
1735         """
1736         msg = _("%(name)s with ID “%(key)s” doesn’t exist. Perhaps it was deleted?") % {
1737             "name": opts.verbose_name,
1738             "key": unquote(object_id),
1739         }
1740         self.message_user(request, msg, messages.WARNING)
1741         url = reverse("admin:index", current_app=self.admin_site.name)
1742         return HttpResponseRedirect(url)
1743 
1744     @csrf_protect_m
1745     def changeform_view(self, request, object_id=None, form_url="", extra_context=None):
1746         with transaction.atomic(using=router.db_for_write(self.model)):
1747             return self._changeform_view(request, object_id, form_url, extra_context)
1748 
1749     def _changeform_view(self, request, object_id, form_url, extra_context):
1750         to_field = request.POST.get(TO_FIELD_VAR, request.GET.get(TO_FIELD_VAR))
1751         if to_field and not self.to_field_allowed(request, to_field):
1752             raise DisallowedModelAdminToField(
1753                 "The field %s cannot be referenced." % to_field
1754             )
1755 
1756         if request.method == "POST" and "_saveasnew" in request.POST:
1757             object_id = None
1758 
1759         add = object_id is None
1760 
1761         if add:
1762             if not self.has_add_permission(request):
1763                 raise PermissionDenied
1764             obj = None
1765 
1766         else:
1767             obj = self.get_object(request, unquote(object_id), to_field)
1768 
1769             if request.method == "POST":
1770                 if not self.has_change_permission(request, obj):
1771                     raise PermissionDenied
1772             else:
1773                 if not self.has_view_or_change_permission(request, obj):
1774                     raise PermissionDenied
1775 
1776             if obj is None:
1777                 return self._get_obj_does_not_exist_redirect(
1778                     request, self.opts, object_id
1779                 )
1780 
1781         fieldsets = self.get_fieldsets(request, obj)
1782         ModelForm = self.get_form(
1783             request, obj, change=not add, fields=flatten_fieldsets(fieldsets)
1784         )
1785         if request.method == "POST":
1786             form = ModelForm(request.POST, request.FILES, instance=obj)
1787             formsets, inline_instances = self._create_formsets(
1788                 request,
1789                 form.instance,
1790                 change=not add,
1791             )
1792             form_validated = form.is_valid()
1793             if form_validated:
1794                 new_object = self.save_form(request, form, change=not add)
1795             else:
1796                 new_object = form.instance
1797             if all_valid(formsets) and form_validated:
1798                 self.save_model(request, new_object, form, not add)
1799                 self.save_related(request, form, formsets, not add)
1800                 change_message = self.construct_change_message(
1801                     request, form, formsets, add
1802                 )
1803                 if add:
1804                     self.log_addition(request, new_object, change_message)
1805                     return self.response_add(request, new_object)
1806                 else:
1807                     self.log_change(request, new_object, change_message)
1808                     return self.response_change(request, new_object)
1809             else:
1810                 form_validated = False
1811         else:
1812             if add:
1813                 initial = self.get_changeform_initial_data(request)
1814                 form = ModelForm(initial=initial)
1815                 formsets, inline_instances = self._create_formsets(
1816                     request, form.instance, change=False
1817                 )
1818             else:
1819                 form = ModelForm(instance=obj)
1820                 formsets, inline_instances = self._create_formsets(
1821                     request, obj, change=True
1822                 )
1823 
1824         if not add and not self.has_change_permission(request, obj):
1825             readonly_fields = flatten_fieldsets(fieldsets)
1826         else:
1827             readonly_fields = self.get_readonly_fields(request, obj)
1828         admin_form = helpers.AdminForm(
1829             form,
1830             list(fieldsets),
1831             # Clear prepopulated fields on a view-only form to avoid a crash.
1832             self.get_prepopulated_fields(request, obj)
1833             if add or self.has_change_permission(request, obj)
1834             else {},
1835             readonly_fields,
1836             model_admin=self,
1837         )
1838         media = self.media + admin_form.media
1839 
1840         inline_formsets = self.get_inline_formsets(
1841             request, formsets, inline_instances, obj
1842         )
1843         for inline_formset in inline_formsets:
1844             media += inline_formset.media
1845 
1846         if add:
1847             title = _("Add %s")
1848         elif self.has_change_permission(request, obj):
1849             title = _("Change %s")
1850         else:
1851             title = _("View %s")
1852         context = {
1853             **self.admin_site.each_context(request),
1854             "title": title % self.opts.verbose_name,
1855             "subtitle": str(obj) if obj else None,
1856             "adminform": admin_form,
1857             "object_id": object_id,
1858             "original": obj,
1859             "is_popup": IS_POPUP_VAR in request.POST or IS_POPUP_VAR in request.GET,
1860             "to_field": to_field,
1861             "media": media,
1862             "inline_admin_formsets": inline_formsets,
1863             "errors": helpers.AdminErrorList(form, formsets),
1864             "preserved_filters": self.get_preserved_filters(request),
1865         }
1866 
1867         # Hide the "Save" and "Save and continue" buttons if "Save as New" was
1868         # previously chosen to prevent the interface from getting confusing.
1869         if (
1870             request.method == "POST"
1871             and not form_validated
1872             and "_saveasnew" in request.POST
1873         ):
1874             context["show_save"] = False
1875             context["show_save_and_continue"] = False
1876             # Use the change template instead of the add template.
1877             add = False
1878 
1879         context.update(extra_context or {})
1880 
1881         return self.render_change_form(
1882             request, context, add=add, change=not add, obj=obj, form_url=form_url
1883         )
1884 
1885     def add_view(self, request, form_url="", extra_context=None):
1886         return self.changeform_view(request, None, form_url, extra_context)
1887 
1888     def change_view(self, request, object_id, form_url="", extra_context=None):
1889         return self.changeform_view(request, object_id, form_url, extra_context)
1890 
1891     def _get_edited_object_pks(self, request, prefix):
1892         """Return POST data values of list_editable primary keys."""
1893         pk_pattern = re.compile(
1894             r"{}-\d+-{}$".format(re.escape(prefix), self.opts.pk.name)
1895         )
1896         return [value for key, value in request.POST.items() if pk_pattern.match(key)]
1897 
1898     def _get_list_editable_queryset(self, request, prefix):
1899         """
1900         Based on POST data, return a queryset of the objects that were edited
1901         via list_editable.
1902         """
1903         object_pks = self._get_edited_object_pks(request, prefix)
1904         queryset = self.get_queryset(request)
1905         validate = queryset.model._meta.pk.to_python
1906         try:
1907             for pk in object_pks:
1908                 validate(pk)
1909         except ValidationError:
1910             # Disable the optimization if the POST data was tampered with.
1911             return queryset
1912         return queryset.filter(pk__in=object_pks)
1913 
1914     @csrf_protect_m
1915     def changelist_view(self, request, extra_context=None):
1916         """
1917         The 'change list' admin view for this model.
1918         """
1919         from django.contrib.admin.views.main import ERROR_FLAG
1920 
1921         app_label = self.opts.app_label
1922         if not self.has_view_or_change_permission(request):
1923             raise PermissionDenied
1924 
1925         try:
1926             cl = self.get_changelist_instance(request)
1927         except IncorrectLookupParameters:
1928             # Wacky lookup parameters were given, so redirect to the main
1929             # changelist page, without parameters, and pass an 'invalid=1'
1930             # parameter via the query string. If wacky parameters were given
1931             # and the 'invalid=1' parameter was already in the query string,
1932             # something is screwed up with the database, so display an error
1933             # page.
1934             if ERROR_FLAG in request.GET:
1935                 return SimpleTemplateResponse(
1936                     "admin/invalid_setup.html",
1937                     {
1938                         "title": _("Database error"),
1939                     },
1940                 )
1941             return HttpResponseRedirect(request.path + "?" + ERROR_FLAG + "=1")
1942 
1943         # If the request was POSTed, this might be a bulk action or a bulk
1944         # edit. Try to look up an action or confirmation first, but if this
1945         # isn't an action the POST will fall through to the bulk edit check,
1946         # below.
1947         action_failed = False
1948         selected = request.POST.getlist(helpers.ACTION_CHECKBOX_NAME)
1949 
1950         actions = self.get_actions(request)
1951         # Actions with no confirmation
1952         if (
1953             actions
1954             and request.method == "POST"
1955             and "index" in request.POST
1956             and "_save" not in request.POST
1957         ):
1958             if selected:
1959                 response = self.response_action(
1960                     request, queryset=cl.get_queryset(request)
1961                 )
1962                 if response:
1963                     return response
1964                 else:
1965                     action_failed = True
1966             else:
1967                 msg = _(
1968                     "Items must be selected in order to perform "
1969                     "actions on them. No items have been changed."
1970                 )
1971                 self.message_user(request, msg, messages.WARNING)
1972                 action_failed = True
1973 
1974         # Actions with confirmation
1975         if (
1976             actions
1977             and request.method == "POST"
1978             and helpers.ACTION_CHECKBOX_NAME in request.POST
1979             and "index" not in request.POST
1980             and "_save" not in request.POST
1981         ):
1982             if selected:
1983                 response = self.response_action(
1984                     request, queryset=cl.get_queryset(request)
1985                 )
1986                 if response:
1987                     return response
1988                 else:
1989                     action_failed = True
1990 
1991         if action_failed:
1992             # Redirect back to the changelist page to avoid resubmitting the
1993             # form if the user refreshes the browser or uses the "No, take
1994             # me back" button on the action confirmation page.
1995             return HttpResponseRedirect(request.get_full_path())
1996 
1997         # If we're allowing changelist editing, we need to construct a formset
1998         # for the changelist given all the fields to be edited. Then we'll
1999         # use the formset to validate/process POSTed data.
2000         formset = cl.formset = None
2001 
2002         # Handle POSTed bulk-edit data.
2003         if request.method == "POST" and cl.list_editable and "_save" in request.POST:
2004             if not self.has_change_permission(request):
2005                 raise PermissionDenied
2006             FormSet = self.get_changelist_formset(request)
2007             modified_objects = self._get_list_editable_queryset(
2008                 request, FormSet.get_default_prefix()
2009             )
2010             formset = cl.formset = FormSet(
2011                 request.POST, request.FILES, queryset=modified_objects
2012             )
2013             if formset.is_valid():
2014                 changecount = 0
2015                 with transaction.atomic(using=router.db_for_write(self.model)):
2016                     for form in formset.forms:
2017                         if form.has_changed():
2018                             obj = self.save_form(request, form, change=True)
2019                             self.save_model(request, obj, form, change=True)
2020                             self.save_related(request, form, formsets=[], change=True)
2021                             change_msg = self.construct_change_message(
2022                                 request, form, None
2023                             )
2024                             self.log_change(request, obj, change_msg)
2025                             changecount += 1
2026                 if changecount:
2027                     msg = ngettext(
2028                         "%(count)s %(name)s was changed successfully.",
2029                         "%(count)s %(name)s were changed successfully.",
2030                         changecount,
2031                     ) % {
2032                         "count": changecount,
2033                         "name": model_ngettext(self.opts, changecount),
2034                     }
2035                     self.message_user(request, msg, messages.SUCCESS)
2036 
2037                 return HttpResponseRedirect(request.get_full_path())
2038 
2039         # Handle GET -- construct a formset for display.
2040         elif cl.list_editable and self.has_change_permission(request):
2041             FormSet = self.get_changelist_formset(request)
2042             formset = cl.formset = FormSet(queryset=cl.result_list)
2043 
2044         # Build the list of media to be used by the formset.
2045         if formset:
2046             media = self.media + formset.media
2047         else:
2048             media = self.media
2049 
2050         # Build the action form and populate it with available actions.
2051         if actions:
2052             action_form = self.action_form(auto_id=None)
2053             action_form.fields["action"].choices = self.get_action_choices(request)
2054             media += action_form.media
2055         else:
2056             action_form = None
2057 
2058         selection_note_all = ngettext(
2059             "%(total_count)s selected", "All %(total_count)s selected", cl.result_count
2060         )
2061 
2062         context = {
2063             **self.admin_site.each_context(request),
2064             "module_name": str(self.opts.verbose_name_plural),
2065             "selection_note": _("0 of %(cnt)s selected") % {"cnt": len(cl.result_list)},
2066             "selection_note_all": selection_note_all % {"total_count": cl.result_count},
2067             "title": cl.title,
2068             "subtitle": None,
2069             "is_popup": cl.is_popup,
2070             "to_field": cl.to_field,
2071             "cl": cl,
2072             "media": media,
2073             "has_add_permission": self.has_add_permission(request),
2074             "opts": cl.opts,
2075             "action_form": action_form,
2076             "actions_on_top": self.actions_on_top,
2077             "actions_on_bottom": self.actions_on_bottom,
2078             "actions_selection_counter": self.actions_selection_counter,
2079             "preserved_filters": self.get_preserved_filters(request),
2080             **(extra_context or {}),
2081         }
2082 
2083         request.current_app = self.admin_site.name
2084 
2085         return TemplateResponse(
2086             request,
2087             self.change_list_template
2088             or [
2089                 "admin/%s/%s/change_list.html" % (app_label, self.opts.model_name),
2090                 "admin/%s/change_list.html" % app_label,
2091                 "admin/change_list.html",
2092             ],
2093             context,
2094         )
2095 
2096     def get_deleted_objects(self, objs, request):
2097         """
2098         Hook for customizing the delete process for the delete view and the
2099         "delete selected" action.
2100         """
2101         return get_deleted_objects(objs, request, self.admin_site)
2102 
2103     @csrf_protect_m
2104     def delete_view(self, request, object_id, extra_context=None):
2105         with transaction.atomic(using=router.db_for_write(self.model)):
2106             return self._delete_view(request, object_id, extra_context)
2107 
2108     def _delete_view(self, request, object_id, extra_context):
2109         "The 'delete' admin view for this model."
2110         app_label = self.opts.app_label
2111 
2112         to_field = request.POST.get(TO_FIELD_VAR, request.GET.get(TO_FIELD_VAR))
2113         if to_field and not self.to_field_allowed(request, to_field):
2114             raise DisallowedModelAdminToField(
2115                 "The field %s cannot be referenced." % to_field
2116             )
2117 
2118         obj = self.get_object(request, unquote(object_id), to_field)
2119 
2120         if not self.has_delete_permission(request, obj):
2121             raise PermissionDenied
2122 
2123         if obj is None:
2124             return self._get_obj_does_not_exist_redirect(request, self.opts, object_id)
2125 
2126         # Populate deleted_objects, a data structure of all related objects that
2127         # will also be deleted.
2128         (
2129             deleted_objects,
2130             model_count,
2131             perms_needed,
2132             protected,
2133         ) = self.get_deleted_objects([obj], request)
2134 
2135         if request.POST and not protected:  # The user has confirmed the deletion.
2136             if perms_needed:
2137                 raise PermissionDenied
2138             obj_display = str(obj)
2139             attr = str(to_field) if to_field else self.opts.pk.attname
2140             obj_id = obj.serializable_value(attr)
2141             self.log_deletion(request, obj, obj_display)
2142             self.delete_model(request, obj)
2143 
2144             return self.response_delete(request, obj_display, obj_id)
2145 
2146         object_name = str(self.opts.verbose_name)
2147 
2148         if perms_needed or protected:
2149             title = _("Cannot delete %(name)s") % {"name": object_name}
2150         else:
2151             title = _("Are you sure?")
2152 
2153         context = {
2154             **self.admin_site.each_context(request),
2155             "title": title,
2156             "subtitle": None,
2157             "object_name": object_name,
2158             "object": obj,
2159             "deleted_objects": deleted_objects,
2160             "model_count": dict(model_count).items(),
2161             "perms_lacking": perms_needed,
2162             "protected": protected,
2163             "opts": self.opts,
2164             "app_label": app_label,
2165             "preserved_filters": self.get_preserved_filters(request),
2166             "is_popup": IS_POPUP_VAR in request.POST or IS_POPUP_VAR in request.GET,
2167             "to_field": to_field,
2168             **(extra_context or {}),
2169         }
2170 
2171         return self.render_delete_form(request, context)
2172 
2173     def history_view(self, request, object_id, extra_context=None):
2174         "The 'history' admin view for this model."
2175         from django.contrib.admin.models import LogEntry
2176         from django.contrib.admin.views.main import PAGE_VAR
2177 
2178         # First check if the user can see this history.
2179         model = self.model
2180         obj = self.get_object(request, unquote(object_id))
2181         if obj is None:
2182             return self._get_obj_does_not_exist_redirect(
2183                 request, model._meta, object_id
2184             )
2185 
2186         if not self.has_view_or_change_permission(request, obj):
2187             raise PermissionDenied
2188 
2189         # Then get the history for this object.
2190         app_label = self.opts.app_label
2191         action_list = (
2192             LogEntry.objects.filter(
2193                 object_id=unquote(object_id),
2194                 content_type=get_content_type_for_model(model),
2195             )
2196             .select_related()
2197             .order_by("action_time")
2198         )
2199 
2200         paginator = self.get_paginator(request, action_list, 100)
2201         page_number = request.GET.get(PAGE_VAR, 1)
2202         page_obj = paginator.get_page(page_number)
2203         page_range = paginator.get_elided_page_range(page_obj.number)
2204 
2205         context = {
2206             **self.admin_site.each_context(request),
2207             "title": _("Change history: %s") % obj,
2208             "subtitle": None,
2209             "action_list": page_obj,
2210             "page_range": page_range,
2211             "page_var": PAGE_VAR,
2212             "pagination_required": paginator.count > 100,
2213             "module_name": str(capfirst(self.opts.verbose_name_plural)),
2214             "object": obj,
2215             "opts": self.opts,
2216             "preserved_filters": self.get_preserved_filters(request),
2217             **(extra_context or {}),
2218         }
2219 
2220         request.current_app = self.admin_site.name
2221 
2222         return TemplateResponse(
2223             request,
2224             self.object_history_template
2225             or [
2226                 "admin/%s/%s/object_history.html" % (app_label, self.opts.model_name),
2227                 "admin/%s/object_history.html" % app_label,
2228                 "admin/object_history.html",
2229             ],
2230             context,
2231         )
2232 
2233     def get_formset_kwargs(self, request, obj, inline, prefix):
2234         formset_params = {
2235             "instance": obj,
2236             "prefix": prefix,
2237             "queryset": inline.get_queryset(request),
2238         }
2239         if request.method == "POST":
2240             formset_params.update(
2241                 {
2242                     "data": request.POST.copy(),
2243                     "files": request.FILES,
2244                     "save_as_new": "_saveasnew" in request.POST,
2245                 }
2246             )
2247         return formset_params
2248 
2249     def _create_formsets(self, request, obj, change):
2250         "Helper function to generate formsets for add/change_view."
2251         formsets = []
2252         inline_instances = []
2253         prefixes = {}
2254         get_formsets_args = [request]
2255         if change:
2256             get_formsets_args.append(obj)
2257         for FormSet, inline in self.get_formsets_with_inlines(*get_formsets_args):
2258             prefix = FormSet.get_default_prefix()
2259             prefixes[prefix] = prefixes.get(prefix, 0) + 1
2260             if prefixes[prefix] != 1 or not prefix:
2261                 prefix = "%s-%s" % (prefix, prefixes[prefix])
2262             formset_params = self.get_formset_kwargs(request, obj, inline, prefix)
2263             formset = FormSet(**formset_params)
2264 
2265             def user_deleted_form(request, obj, formset, index, inline):
2266                 """Return whether or not the user deleted the form."""
2267                 return (
2268                     inline.has_delete_permission(request, obj)
2269                     and "{}-{}-DELETE".format(formset.prefix, index) in request.POST
2270                 )
2271 
2272             # Bypass validation of each view-only inline form (since the form's
2273             # data won't be in request.POST), unless the form was deleted.
2274             if not inline.has_change_permission(request, obj if change else None):
2275                 for index, form in enumerate(formset.initial_forms):
2276                     if user_deleted_form(request, obj, formset, index, inline):
2277                         continue
2278                     form._errors = {}
2279                     form.cleaned_data = form.initial
2280             formsets.append(formset)
2281             inline_instances.append(inline)
2282         return formsets, inline_instances

</code><intended_behavior>These methods should be extended to not only log actions but also include a reference or identification of which AdminSite the action is associated with. A plausible approach could involve adding an additional parameter or context to these methods that allows passing information about the AdminSite. This added information could be stored in the LogEntry in an indirect manner (e.g., stored in the change_message as a serialized dict or utilizing a custom field that can encode this context). The challenge is to do this in a backward-compatible way, ensuring that existing functionality remains intact while providing the necessary hooks or information for AdminSite-specific LogEntry filtering.</intended_behavior>, <file>django/contrib/admin/sites.py</file>
<class>AdminSite</class>
<method>register</method>
<code>
99     def register(self, model_or_iterable, admin_class=None, **options):
100         """
101         Register the given model(s) with the given admin class.
102 
103         The model(s) should be Model classes, not instances.
104 
105         If an admin class isn't given, use ModelAdmin (the default admin
106         options). If keyword arguments are given -- e.g., list_display --
107         apply them as options to the admin class.
108 
109         If a model is already registered, raise AlreadyRegistered.
110 
111         If a model is abstract, raise ImproperlyConfigured.
112         """
113         admin_class = admin_class or ModelAdmin
114         if isinstance(model_or_iterable, ModelBase):
115             model_or_iterable = [model_or_iterable]
116         for model in model_or_iterable:
117             if model._meta.abstract:
118                 raise ImproperlyConfigured(
119                     "The model %s is abstract, so it cannot be registered with admin."
120                     % model.__name__
121                 )
122 
123             if model in self._registry:
124                 registered_admin = str(self._registry[model])
125                 msg = "The model %s is already registered " % model.__name__
126                 if registered_admin.endswith(".ModelAdmin"):
127                     # Most likely registered without a ModelAdmin subclass.
128                     msg += "in app %r." % registered_admin.removesuffix(".ModelAdmin")
129                 else:
130                     msg += "with %r." % registered_admin
131                 raise AlreadyRegistered(msg)
132 
133             # Ignore the registration if the model has been
134             # swapped out.
135             if not model._meta.swapped:
136                 # If we got **options then dynamically construct a subclass of
137                 # admin_class with those **options.
138                 if options:
139                     # For reasons I don't quite understand, without a __module__
140                     # the created class appears to "live" in the wrong place,
141                     # which causes issues later on.
142                     options["__module__"] = __name__
143                     admin_class = type(
144                         "%sAdmin" % model.__name__, (admin_class,), options
145                     )
146 
147                 # Instantiate the admin class to save in the registry
148                 self._registry[model] = admin_class(model, self)

</code><intended_behavior>While the register method itself may not need modification for direct bug resolution, ensuring its interaction with the logging mechanism considers AdminSite context is crucial. There may be value in exploring mechanisms within this method to implicitly or explicitly tag LogEntry instances with AdminSite identification upon registration or action logging. This implies a broader strategy of integrating AdminSite context awareness into actions logged via the ModelAdmin methods above.</intended_behavior>, <file>django/contrib/admin/sites.py</file>
<class>AdminSite</class>
<method>None</method>
<code>
36 class AdminSite:
37     """
38     An AdminSite object encapsulates an instance of the Django admin application, ready
39     to be hooked in to your URLconf. Models are registered with the AdminSite using the
40     register() method, and the get_urls() method can then be used to access Django view
41     functions that present a full admin interface for the collection of registered
42     models.
43     """
44 
45     # Text to put at the end of each page's <title>.
46     site_title = gettext_lazy("Django site admin")
47 
48     # Text to put in each page's <h1>.
49     site_header = gettext_lazy("Django administration")
50 
51     # Text to put at the top of the admin index page.
52     index_title = gettext_lazy("Site administration")
53 
54     # URL for the "View site" link at the top of each admin page.
55     site_url = "/"
56 
57     enable_nav_sidebar = True
58 
59     empty_value_display = "-"
60 
61     login_form = None
62     index_template = None
63     app_index_template = None
64     login_template = None
65     logout_template = None
66     password_change_template = None
67     password_change_done_template = None
68 
69     final_catch_all_view = True
70 
71     def __init__(self, name="admin"):
72         self._registry = {}  # model_class class -> admin_class instance
73         self.name = name
74         self._actions = {"delete_selected": actions.delete_selected}
75         self._global_actions = self._actions.copy()
76         all_sites.add(self)
77 
78     def __repr__(self):
79         return f"{self.__class__.__name__}(name={self.name!r})"
80 
81     def check(self, app_configs):
82         """
83         Run the system checks on all ModelAdmins, except if they aren't
84         customized at all.
85         """
86         if app_configs is None:
87             app_configs = apps.get_app_configs()
88         app_configs = set(app_configs)  # Speed up lookups below
89 
90         errors = []
91         modeladmins = (
92             o for o in self._registry.values() if o.__class__ is not ModelAdmin
93         )
94         for modeladmin in modeladmins:
95             if modeladmin.model._meta.app_config in app_configs:
96                 errors.extend(modeladmin.check())
97         return errors
98 
99     def register(self, model_or_iterable, admin_class=None, **options):
100         """
101         Register the given model(s) with the given admin class.
102 
103         The model(s) should be Model classes, not instances.
104 
105         If an admin class isn't given, use ModelAdmin (the default admin
106         options). If keyword arguments are given -- e.g., list_display --
107         apply them as options to the admin class.
108 
109         If a model is already registered, raise AlreadyRegistered.
110 
111         If a model is abstract, raise ImproperlyConfigured.
112         """
113         admin_class = admin_class or ModelAdmin
114         if isinstance(model_or_iterable, ModelBase):
115             model_or_iterable = [model_or_iterable]
116         for model in model_or_iterable:
117             if model._meta.abstract:
118                 raise ImproperlyConfigured(
119                     "The model %s is abstract, so it cannot be registered with admin."
120                     % model.__name__
121                 )
122 
123             if model in self._registry:
124                 registered_admin = str(self._registry[model])
125                 msg = "The model %s is already registered " % model.__name__
126                 if registered_admin.endswith(".ModelAdmin"):
127                     # Most likely registered without a ModelAdmin subclass.
128                     msg += "in app %r." % registered_admin.removesuffix(".ModelAdmin")
129                 else:
130                     msg += "with %r." % registered_admin
131                 raise AlreadyRegistered(msg)
132 
133             # Ignore the registration if the model has been
134             # swapped out.
135             if not model._meta.swapped:
136                 # If we got **options then dynamically construct a subclass of
137                 # admin_class with those **options.
138                 if options:
139                     # For reasons I don't quite understand, without a __module__
140                     # the created class appears to "live" in the wrong place,
141                     # which causes issues later on.
142                     options["__module__"] = __name__
143                     admin_class = type(
144                         "%sAdmin" % model.__name__, (admin_class,), options
145                     )
146 
147                 # Instantiate the admin class to save in the registry
148                 self._registry[model] = admin_class(model, self)
149 
150     def unregister(self, model_or_iterable):
151         """
152         Unregister the given model(s).
153 
154         If a model isn't already registered, raise NotRegistered.
155         """
156         if isinstance(model_or_iterable, ModelBase):
157             model_or_iterable = [model_or_iterable]
158         for model in model_or_iterable:
159             if model not in self._registry:
160                 raise NotRegistered("The model %s is not registered" % model.__name__)
161             del self._registry[model]
162 
163     def is_registered(self, model):
164         """
165         Check if a model class is registered with this `AdminSite`.
166         """
167         return model in self._registry
168 
169     def add_action(self, action, name=None):
170         """
171         Register an action to be available globally.
172         """
173         name = name or action.__name__
174         self._actions[name] = action
175         self._global_actions[name] = action
176 
177     def disable_action(self, name):
178         """
179         Disable a globally-registered action. Raise KeyError for invalid names.
180         """
181         del self._actions[name]
182 
183     def get_action(self, name):
184         """
185         Explicitly get a registered global action whether it's enabled or
186         not. Raise KeyError for invalid names.
187         """
188         return self._global_actions[name]
189 
190     @property
191     def actions(self):
192         """
193         Get all the enabled actions as an iterable of (name, func).
194         """
195         return self._actions.items()
196 
197     def has_permission(self, request):
198         """
199         Return True if the given HttpRequest has permission to view
200         *at least one* page in the admin site.
201         """
202         return request.user.is_active and request.user.is_staff
203 
204     def admin_view(self, view, cacheable=False):
205         """
206         Decorator to create an admin view attached to this ``AdminSite``. This
207         wraps the view and provides permission checking by calling
208         ``self.has_permission``.
209 
210         You'll want to use this from within ``AdminSite.get_urls()``:
211 
212             class MyAdminSite(AdminSite):
213 
214                 def get_urls(self):
215                     from django.urls import path
216 
217                     urls = super().get_urls()
218                     urls += [
219                         path('my_view/', self.admin_view(some_view))
220                     ]
221                     return urls
222 
223         By default, admin_views are marked non-cacheable using the
224         ``never_cache`` decorator. If the view can be safely cached, set
225         cacheable=True.
226         """
227 
228         def inner(request, *args, **kwargs):
229             if not self.has_permission(request):
230                 if request.path == reverse("admin:logout", current_app=self.name):
231                     index_path = reverse("admin:index", current_app=self.name)
232                     return HttpResponseRedirect(index_path)
233                 # Inner import to prevent django.contrib.admin (app) from
234                 # importing django.contrib.auth.models.User (unrelated model).
235                 from django.contrib.auth.views import redirect_to_login
236 
237                 return redirect_to_login(
238                     request.get_full_path(),
239                     reverse("admin:login", current_app=self.name),
240                 )
241             return view(request, *args, **kwargs)
242 
243         if not cacheable:
244             inner = never_cache(inner)
245         # We add csrf_protect here so this function can be used as a utility
246         # function for any view, without having to repeat 'csrf_protect'.
247         if not getattr(view, "csrf_exempt", False):
248             inner = csrf_protect(inner)
249         return update_wrapper(inner, view)
250 
251     def get_urls(self):
252         # Since this module gets imported in the application's root package,
253         # it cannot import models from other applications at the module level,
254         # and django.contrib.contenttypes.views imports ContentType.
255         from django.contrib.contenttypes import views as contenttype_views
256         from django.urls import include, path, re_path
257 
258         def wrap(view, cacheable=False):
259             def wrapper(*args, **kwargs):
260                 return self.admin_view(view, cacheable)(*args, **kwargs)
261 
262             wrapper.admin_site = self
263             return update_wrapper(wrapper, view)
264 
265         # Admin-site-wide views.
266         urlpatterns = [
267             path("", wrap(self.index), name="index"),
268             path("login/", self.login, name="login"),
269             path("logout/", wrap(self.logout), name="logout"),
270             path(
271                 "password_change/",
272                 wrap(self.password_change, cacheable=True),
273                 name="password_change",
274             ),
275             path(
276                 "password_change/done/",
277                 wrap(self.password_change_done, cacheable=True),
278                 name="password_change_done",
279             ),
280             path("autocomplete/", wrap(self.autocomplete_view), name="autocomplete"),
281             path("jsi18n/", wrap(self.i18n_javascript, cacheable=True), name="jsi18n"),
282             path(
283                 "r/<int:content_type_id>/<path:object_id>/",
284                 wrap(contenttype_views.shortcut),
285                 name="view_on_site",
286             ),
287         ]
288 
289         # Add in each model's views, and create a list of valid URLS for the
290         # app_index
291         valid_app_labels = []
292         for model, model_admin in self._registry.items():
293             urlpatterns += [
294                 path(
295                     "%s/%s/" % (model._meta.app_label, model._meta.model_name),
296                     include(model_admin.urls),
297                 ),
298             ]
299             if model._meta.app_label not in valid_app_labels:
300                 valid_app_labels.append(model._meta.app_label)
301 
302         # If there were ModelAdmins registered, we should have a list of app
303         # labels for which we need to allow access to the app_index view,
304         if valid_app_labels:
305             regex = r"^(?P<app_label>" + "|".join(valid_app_labels) + ")/$"
306             urlpatterns += [
307                 re_path(regex, wrap(self.app_index), name="app_list"),
308             ]
309 
310         if self.final_catch_all_view:
311             urlpatterns.append(re_path(r"(?P<url>.*)$", wrap(self.catch_all_view)))
312 
313         return urlpatterns
314 
315     @property
316     def urls(self):
317         return self.get_urls(), "admin", self.name
318 
319     def each_context(self, request):
320         """
321         Return a dictionary of variables to put in the template context for
322         *every* page in the admin site.
323 
324         For sites running on a subpath, use the SCRIPT_NAME value if site_url
325         hasn't been customized.
326         """
327         script_name = request.META["SCRIPT_NAME"]
328         site_url = (
329             script_name if self.site_url == "/" and script_name else self.site_url
330         )
331         return {
332             "site_title": self.site_title,
333             "site_header": self.site_header,
334             "site_url": site_url,
335             "has_permission": self.has_permission(request),
336             "available_apps": self.get_app_list(request),
337             "is_popup": False,
338             "is_nav_sidebar_enabled": self.enable_nav_sidebar,
339         }
340 
341     def password_change(self, request, extra_context=None):
342         """
343         Handle the "change password" task -- both form display and validation.
344         """
345         from django.contrib.admin.forms import AdminPasswordChangeForm
346         from django.contrib.auth.views import PasswordChangeView
347 
348         url = reverse("admin:password_change_done", current_app=self.name)
349         defaults = {
350             "form_class": AdminPasswordChangeForm,
351             "success_url": url,
352             "extra_context": {**self.each_context(request), **(extra_context or {})},
353         }
354         if self.password_change_template is not None:
355             defaults["template_name"] = self.password_change_template
356         request.current_app = self.name
357         return PasswordChangeView.as_view(**defaults)(request)
358 
359     def password_change_done(self, request, extra_context=None):
360         """
361         Display the "success" page after a password change.
362         """
363         from django.contrib.auth.views import PasswordChangeDoneView
364 
365         defaults = {
366             "extra_context": {**self.each_context(request), **(extra_context or {})},
367         }
368         if self.password_change_done_template is not None:
369             defaults["template_name"] = self.password_change_done_template
370         request.current_app = self.name
371         return PasswordChangeDoneView.as_view(**defaults)(request)
372 
373     def i18n_javascript(self, request, extra_context=None):
374         """
375         Display the i18n JavaScript that the Django admin requires.
376 
377         `extra_context` is unused but present for consistency with the other
378         admin views.
379         """
380         return JavaScriptCatalog.as_view(packages=["django.contrib.admin"])(request)
381 
382     def logout(self, request, extra_context=None):
383         """
384         Log out the user for the given HttpRequest.
385 
386         This should *not* assume the user is already logged in.
387         """
388         from django.contrib.auth.views import LogoutView
389 
390         defaults = {
391             "extra_context": {
392                 **self.each_context(request),
393                 # Since the user isn't logged out at this point, the value of
394                 # has_permission must be overridden.
395                 "has_permission": False,
396                 **(extra_context or {}),
397             },
398         }
399         if self.logout_template is not None:
400             defaults["template_name"] = self.logout_template
401         request.current_app = self.name
402         return LogoutView.as_view(**defaults)(request)
403 
404     @method_decorator(never_cache)
405     def login(self, request, extra_context=None):
406         """
407         Display the login form for the given HttpRequest.
408         """
409         if request.method == "GET" and self.has_permission(request):
410             # Already logged-in, redirect to admin index
411             index_path = reverse("admin:index", current_app=self.name)
412             return HttpResponseRedirect(index_path)
413 
414         # Since this module gets imported in the application's root package,
415         # it cannot import models from other applications at the module level,
416         # and django.contrib.admin.forms eventually imports User.
417         from django.contrib.admin.forms import AdminAuthenticationForm
418         from django.contrib.auth.views import LoginView
419 
420         context = {
421             **self.each_context(request),
422             "title": _("Log in"),
423             "subtitle": None,
424             "app_path": request.get_full_path(),
425             "username": request.user.get_username(),
426         }
427         if (
428             REDIRECT_FIELD_NAME not in request.GET
429             and REDIRECT_FIELD_NAME not in request.POST
430         ):
431             context[REDIRECT_FIELD_NAME] = reverse("admin:index", current_app=self.name)
432         context.update(extra_context or {})
433 
434         defaults = {
435             "extra_context": context,
436             "authentication_form": self.login_form or AdminAuthenticationForm,
437             "template_name": self.login_template or "admin/login.html",
438         }
439         request.current_app = self.name
440         return LoginView.as_view(**defaults)(request)
441 
442     def autocomplete_view(self, request):
443         return AutocompleteJsonView.as_view(admin_site=self)(request)
444 
445     @no_append_slash
446     def catch_all_view(self, request, url):
447         if settings.APPEND_SLASH and not url.endswith("/"):
448             urlconf = getattr(request, "urlconf", None)
449             try:
450                 match = resolve("%s/" % request.path_info, urlconf)
451             except Resolver404:
452                 pass
453             else:
454                 if getattr(match.func, "should_append_slash", True):
455                     return HttpResponsePermanentRedirect("%s/" % request.path)
456         raise Http404
457 
458     def _build_app_dict(self, request, label=None):
459         """
460         Build the app dictionary. The optional `label` parameter filters models
461         of a specific app.
462         """
463         app_dict = {}
464 
465         if label:
466             models = {
467                 m: m_a
468                 for m, m_a in self._registry.items()
469                 if m._meta.app_label == label
470             }
471         else:
472             models = self._registry
473 
474         for model, model_admin in models.items():
475             app_label = model._meta.app_label
476 
477             has_module_perms = model_admin.has_module_permission(request)
478             if not has_module_perms:
479                 continue
480 
481             perms = model_admin.get_model_perms(request)
482 
483             # Check whether user has any perm for this module.
484             # If so, add the module to the model_list.
485             if True not in perms.values():
486                 continue
487 
488             info = (app_label, model._meta.model_name)
489             model_dict = {
490                 "model": model,
491                 "name": capfirst(model._meta.verbose_name_plural),
492                 "object_name": model._meta.object_name,
493                 "perms": perms,
494                 "admin_url": None,
495                 "add_url": None,
496             }
497             if perms.get("change") or perms.get("view"):
498                 model_dict["view_only"] = not perms.get("change")
499                 try:
500                     model_dict["admin_url"] = reverse(
501                         "admin:%s_%s_changelist" % info, current_app=self.name
502                     )
503                 except NoReverseMatch:
504                     pass
505             if perms.get("add"):
506                 try:
507                     model_dict["add_url"] = reverse(
508                         "admin:%s_%s_add" % info, current_app=self.name
509                     )
510                 except NoReverseMatch:
511                     pass
512 
513             if app_label in app_dict:
514                 app_dict[app_label]["models"].append(model_dict)
515             else:
516                 app_dict[app_label] = {
517                     "name": apps.get_app_config(app_label).verbose_name,
518                     "app_label": app_label,
519                     "app_url": reverse(
520                         "admin:app_list",
521                         kwargs={"app_label": app_label},
522                         current_app=self.name,
523                     ),
524                     "has_module_perms": has_module_perms,
525                     "models": [model_dict],
526                 }
527 
528         return app_dict
529 
530     def get_app_list(self, request, app_label=None):
531         """
532         Return a sorted list of all the installed apps that have been
533         registered in this site.
534         """
535         app_dict = self._build_app_dict(request, app_label)
536 
537         # Sort the apps alphabetically.
538         app_list = sorted(app_dict.values(), key=lambda x: x["name"].lower())
539 
540         # Sort the models alphabetically within each app.
541         for app in app_list:
542             app["models"].sort(key=lambda x: x["name"])
543 
544         return app_list
545 
546     def index(self, request, extra_context=None):
547         """
548         Display the main admin index page, which lists all of the installed
549         apps that have been registered in this site.
550         """
551         app_list = self.get_app_list(request)
552 
553         context = {
554             **self.each_context(request),
555             "title": self.index_title,
556             "subtitle": None,
557             "app_list": app_list,
558             **(extra_context or {}),
559         }
560 
561         request.current_app = self.name
562 
563         return TemplateResponse(
564             request, self.index_template or "admin/index.html", context
565         )
566 
567     def app_index(self, request, app_label, extra_context=None):
568         app_list = self.get_app_list(request, app_label)
569 
570         if not app_list:
571             raise Http404("The requested admin page does not exist.")
572 
573         context = {
574             **self.each_context(request),
575             "title": _("%(app)s administration") % {"app": app_list[0]["name"]},
576             "subtitle": None,
577             "app_list": app_list,
578             "app_label": app_label,
579             **(extra_context or {}),
580         }
581 
582         request.current_app = self.name
583 
584         return TemplateResponse(
585             request,
586             self.app_index_template
587             or ["admin/%s/app_index.html" % app_label, "admin/app_index.html"],
588             context,
589         )

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>, <file>django/contrib/admin/views/main.py</file>
<class>None</class>
<method>None</method>
<code>
1 from datetime import datetime, timedelta
2 
3 from django import forms
4 from django.conf import settings
5 from django.contrib import messages
6 from django.contrib.admin import FieldListFilter
7 from django.contrib.admin.exceptions import (
8     DisallowedModelAdminLookup,
9     DisallowedModelAdminToField,
10 )
11 from django.contrib.admin.options import (
12     IS_POPUP_VAR,
13     TO_FIELD_VAR,
14     IncorrectLookupParameters,
15 )
16 from django.contrib.admin.utils import (
17     get_fields_from_path,
18     lookup_spawns_duplicates,
19     prepare_lookup_value,
20     quote,
21 )
22 from django.core.exceptions import (
23     FieldDoesNotExist,
24     ImproperlyConfigured,
25     SuspiciousOperation,
26 )
27 from django.core.paginator import InvalidPage
28 from django.db.models import Exists, F, Field, ManyToOneRel, OrderBy, OuterRef
29 from django.db.models.expressions import Combinable
30 from django.urls import reverse
31 from django.utils.http import urlencode
32 from django.utils.timezone import make_aware
33 from django.utils.translation import gettext
34 
35 # Changelist settings
36 ALL_VAR = "all"
37 ORDER_VAR = "o"
38 PAGE_VAR = "p"
39 SEARCH_VAR = "q"
40 ERROR_FLAG = "e"
41 
42 IGNORED_PARAMS = (ALL_VAR, ORDER_VAR, SEARCH_VAR, IS_POPUP_VAR, TO_FIELD_VAR)
43 
44 
45 class ChangeListSearchForm(forms.Form):
46     def __init__(self, *args, **kwargs):
47         super().__init__(*args, **kwargs)
48         # Populate "fields" dynamically because SEARCH_VAR is a variable:
49         self.fields = {
50             SEARCH_VAR: forms.CharField(required=False, strip=False),
51         }
52 
53 
54 class ChangeList:
55     search_form_class = ChangeListSearchForm
56 
57     def __init__(
58         self,
59         request,
60         model,
61         list_display,
62         list_display_links,
63         list_filter,
64         date_hierarchy,
65         search_fields,
66         list_select_related,
67         list_per_page,
68         list_max_show_all,
69         list_editable,
70         model_admin,
71         sortable_by,
72         search_help_text,
73     ):
74         self.model = model
75         self.opts = model._meta
76         self.lookup_opts = self.opts
77         self.root_queryset = model_admin.get_queryset(request)
78         self.list_display = list_display
79         self.list_display_links = list_display_links
80         self.list_filter = list_filter
81         self.has_filters = None
82         self.has_active_filters = None
83         self.clear_all_filters_qs = None
84         self.date_hierarchy = date_hierarchy
85         self.search_fields = search_fields
86         self.list_select_related = list_select_related
87         self.list_per_page = list_per_page
88         self.list_max_show_all = list_max_show_all
89         self.model_admin = model_admin
90         self.preserved_filters = model_admin.get_preserved_filters(request)
91         self.sortable_by = sortable_by
92         self.search_help_text = search_help_text
93 
94         # Get search parameters from the query string.
95         _search_form = self.search_form_class(request.GET)
96         if not _search_form.is_valid():
97             for error in _search_form.errors.values():
98                 messages.error(request, ", ".join(error))
99         self.query = _search_form.cleaned_data.get(SEARCH_VAR) or ""
100         try:
101             self.page_num = int(request.GET.get(PAGE_VAR, 1))
102         except ValueError:
103             self.page_num = 1
104         self.show_all = ALL_VAR in request.GET
105         self.is_popup = IS_POPUP_VAR in request.GET
106         to_field = request.GET.get(TO_FIELD_VAR)
107         if to_field and not model_admin.to_field_allowed(request, to_field):
108             raise DisallowedModelAdminToField(
109                 "The field %s cannot be referenced." % to_field
110             )
111         self.to_field = to_field
112         self.params = dict(request.GET.items())
113         if PAGE_VAR in self.params:
114             del self.params[PAGE_VAR]
115         if ERROR_FLAG in self.params:
116             del self.params[ERROR_FLAG]
117 
118         if self.is_popup:
119             self.list_editable = ()
120         else:
121             self.list_editable = list_editable
122         self.queryset = self.get_queryset(request)
123         self.get_results(request)
124         if self.is_popup:
125             title = gettext("Select %s")
126         elif self.model_admin.has_change_permission(request):
127             title = gettext("Select %s to change")
128         else:
129             title = gettext("Select %s to view")
130         self.title = title % self.opts.verbose_name
131         self.pk_attname = self.lookup_opts.pk.attname
132 
133     def __repr__(self):
134         return "<%s: model=%s model_admin=%s>" % (
135             self.__class__.__qualname__,
136             self.model.__qualname__,
137             self.model_admin.__class__.__qualname__,
138         )
139 
140     def get_filters_params(self, params=None):
141         """
142         Return all params except IGNORED_PARAMS.
143         """
144         params = params or self.params
145         lookup_params = params.copy()  # a dictionary of the query string
146         # Remove all the parameters that are globally and systematically
147         # ignored.
148         for ignored in IGNORED_PARAMS:
149             if ignored in lookup_params:
150                 del lookup_params[ignored]
151         return lookup_params
152 
153     def get_filters(self, request):
154         lookup_params = self.get_filters_params()
155         may_have_duplicates = False
156         has_active_filters = False
157 
158         for key, value in lookup_params.items():
159             if not self.model_admin.lookup_allowed(key, value):
160                 raise DisallowedModelAdminLookup("Filtering by %s not allowed" % key)
161 
162         filter_specs = []
163         for list_filter in self.list_filter:
164             lookup_params_count = len(lookup_params)
165             if callable(list_filter):
166                 # This is simply a custom list filter class.
167                 spec = list_filter(request, lookup_params, self.model, self.model_admin)
168             else:
169                 field_path = None
170                 if isinstance(list_filter, (tuple, list)):
171                     # This is a custom FieldListFilter class for a given field.
172                     field, field_list_filter_class = list_filter
173                 else:
174                     # This is simply a field name, so use the default
175                     # FieldListFilter class that has been registered for the
176                     # type of the given field.
177                     field, field_list_filter_class = list_filter, FieldListFilter.create
178                 if not isinstance(field, Field):
179                     field_path = field
180                     field = get_fields_from_path(self.model, field_path)[-1]
181 
182                 spec = field_list_filter_class(
183                     field,
184                     request,
185                     lookup_params,
186                     self.model,
187                     self.model_admin,
188                     field_path=field_path,
189                 )
190                 # field_list_filter_class removes any lookup_params it
191                 # processes. If that happened, check if duplicates should be
192                 # removed.
193                 if lookup_params_count > len(lookup_params):
194                     may_have_duplicates |= lookup_spawns_duplicates(
195                         self.lookup_opts,
196                         field_path,
197                     )
198             if spec and spec.has_output():
199                 filter_specs.append(spec)
200                 if lookup_params_count > len(lookup_params):
201                     has_active_filters = True
202 
203         if self.date_hierarchy:
204             # Create bounded lookup parameters so that the query is more
205             # efficient.
206             year = lookup_params.pop("%s__year" % self.date_hierarchy, None)
207             if year is not None:
208                 month = lookup_params.pop("%s__month" % self.date_hierarchy, None)
209                 day = lookup_params.pop("%s__day" % self.date_hierarchy, None)
210                 try:
211                     from_date = datetime(
212                         int(year),
213                         int(month if month is not None else 1),
214                         int(day if day is not None else 1),
215                     )
216                 except ValueError as e:
217                     raise IncorrectLookupParameters(e) from e
218                 if day:
219                     to_date = from_date + timedelta(days=1)
220                 elif month:
221                     # In this branch, from_date will always be the first of a
222                     # month, so advancing 32 days gives the next month.
223                     to_date = (from_date + timedelta(days=32)).replace(day=1)
224                 else:
225                     to_date = from_date.replace(year=from_date.year + 1)
226                 if settings.USE_TZ:
227                     from_date = make_aware(from_date)
228                     to_date = make_aware(to_date)
229                 lookup_params.update(
230                     {
231                         "%s__gte" % self.date_hierarchy: from_date,
232                         "%s__lt" % self.date_hierarchy: to_date,
233                     }
234                 )
235 
236         # At this point, all the parameters used by the various ListFilters
237         # have been removed from lookup_params, which now only contains other
238         # parameters passed via the query string. We now loop through the
239         # remaining parameters both to ensure that all the parameters are valid
240         # fields and to determine if at least one of them spawns duplicates. If
241         # the lookup parameters aren't real fields, then bail out.
242         try:
243             for key, value in lookup_params.items():
244                 lookup_params[key] = prepare_lookup_value(key, value)
245                 may_have_duplicates |= lookup_spawns_duplicates(self.lookup_opts, key)
246             return (
247                 filter_specs,
248                 bool(filter_specs),
249                 lookup_params,
250                 may_have_duplicates,
251                 has_active_filters,
252             )
253         except FieldDoesNotExist as e:
254             raise IncorrectLookupParameters(e) from e
255 
256     def get_query_string(self, new_params=None, remove=None):
257         if new_params is None:
258             new_params = {}
259         if remove is None:
260             remove = []
261         p = self.params.copy()
262         for r in remove:
263             for k in list(p):
264                 if k.startswith(r):
265                     del p[k]
266         for k, v in new_params.items():
267             if v is None:
268                 if k in p:
269                     del p[k]
270             else:
271                 p[k] = v
272         return "?%s" % urlencode(sorted(p.items()))
273 
274     def get_results(self, request):
275         paginator = self.model_admin.get_paginator(
276             request, self.queryset, self.list_per_page
277         )
278         # Get the number of objects, with admin filters applied.
279         result_count = paginator.count
280 
281         # Get the total number of objects, with no admin filters applied.
282         if self.model_admin.show_full_result_count:
283             full_result_count = self.root_queryset.count()
284         else:
285             full_result_count = None
286         can_show_all = result_count <= self.list_max_show_all
287         multi_page = result_count > self.list_per_page
288 
289         # Get the list of objects to display on this page.
290         if (self.show_all and can_show_all) or not multi_page:
291             result_list = self.queryset._clone()
292         else:
293             try:
294                 result_list = paginator.page(self.page_num).object_list
295             except InvalidPage:
296                 raise IncorrectLookupParameters
297 
298         self.result_count = result_count
299         self.show_full_result_count = self.model_admin.show_full_result_count
300         # Admin actions are shown if there is at least one entry
301         # or if entries are not counted because show_full_result_count is disabled
302         self.show_admin_actions = not self.show_full_result_count or bool(
303             full_result_count
304         )
305         self.full_result_count = full_result_count
306         self.result_list = result_list
307         self.can_show_all = can_show_all
308         self.multi_page = multi_page
309         self.paginator = paginator
310 
311     def _get_default_ordering(self):
312         ordering = []
313         if self.model_admin.ordering:
314             ordering = self.model_admin.ordering
315         elif self.lookup_opts.ordering:
316             ordering = self.lookup_opts.ordering
317         return ordering
318 
319     def get_ordering_field(self, field_name):
320         """
321         Return the proper model field name corresponding to the given
322         field_name to use for ordering. field_name may either be the name of a
323         proper model field or the name of a method (on the admin or model) or a
324         callable with the 'admin_order_field' attribute. Return None if no
325         proper model field name can be matched.
326         """
327         try:
328             field = self.lookup_opts.get_field(field_name)
329             return field.name
330         except FieldDoesNotExist:
331             # See whether field_name is a name of a non-field
332             # that allows sorting.
333             if callable(field_name):
334                 attr = field_name
335             elif hasattr(self.model_admin, field_name):
336                 attr = getattr(self.model_admin, field_name)
337             else:
338                 attr = getattr(self.model, field_name)
339             if isinstance(attr, property) and hasattr(attr, "fget"):
340                 attr = attr.fget
341             return getattr(attr, "admin_order_field", None)
342 
343     def get_ordering(self, request, queryset):
344         """
345         Return the list of ordering fields for the change list.
346         First check the get_ordering() method in model admin, then check
347         the object's default ordering. Then, any manually-specified ordering
348         from the query string overrides anything. Finally, a deterministic
349         order is guaranteed by calling _get_deterministic_ordering() with the
350         constructed ordering.
351         """
352         params = self.params
353         ordering = list(
354             self.model_admin.get_ordering(request) or self._get_default_ordering()
355         )
356         if ORDER_VAR in params:
357             # Clear ordering and used params
358             ordering = []
359             order_params = params[ORDER_VAR].split(".")
360             for p in order_params:
361                 try:
362                     none, pfx, idx = p.rpartition("-")
363                     field_name = self.list_display[int(idx)]
364                     order_field = self.get_ordering_field(field_name)
365                     if not order_field:
366                         continue  # No 'admin_order_field', skip it
367                     if isinstance(order_field, OrderBy):
368                         if pfx == "-":
369                             order_field = order_field.copy()
370                             order_field.reverse_ordering()
371                         ordering.append(order_field)
372                     elif hasattr(order_field, "resolve_expression"):
373                         # order_field is an expression.
374                         ordering.append(
375                             order_field.desc() if pfx == "-" else order_field.asc()
376                         )
377                     # reverse order if order_field has already "-" as prefix
378                     elif pfx == "-" and order_field.startswith(pfx):
379                         ordering.append(order_field.removeprefix(pfx))
380                     else:
381                         ordering.append(pfx + order_field)
382                 except (IndexError, ValueError):
383                     continue  # Invalid ordering specified, skip it.
384 
385         # Add the given query's ordering fields, if any.
386         ordering.extend(queryset.query.order_by)
387 
388         return self._get_deterministic_ordering(ordering)
389 
390     def _get_deterministic_ordering(self, ordering):
391         """
392         Ensure a deterministic order across all database backends. Search for a
393         single field or unique together set of fields providing a total
394         ordering. If these are missing, augment the ordering with a descendant
395         primary key.
396         """
397         ordering = list(ordering)
398         ordering_fields = set()
399         total_ordering_fields = {"pk"} | {
400             field.attname
401             for field in self.lookup_opts.fields
402             if field.unique and not field.null
403         }
404         for part in ordering:
405             # Search for single field providing a total ordering.
406             field_name = None
407             if isinstance(part, str):
408                 field_name = part.lstrip("-")
409             elif isinstance(part, F):
410                 field_name = part.name
411             elif isinstance(part, OrderBy) and isinstance(part.expression, F):
412                 field_name = part.expression.name
413             if field_name:
414                 # Normalize attname references by using get_field().
415                 try:
416                     field = self.lookup_opts.get_field(field_name)
417                 except FieldDoesNotExist:
418                     # Could be "?" for random ordering or a related field
419                     # lookup. Skip this part of introspection for now.
420                     continue
421                 # Ordering by a related field name orders by the referenced
422                 # model's ordering. Skip this part of introspection for now.
423                 if field.remote_field and field_name == field.name:
424                     continue
425                 if field.attname in total_ordering_fields:
426                     break
427                 ordering_fields.add(field.attname)
428         else:
429             # No single total ordering field, try unique_together and total
430             # unique constraints.
431             constraint_field_names = (
432                 *self.lookup_opts.unique_together,
433                 *(
434                     constraint.fields
435                     for constraint in self.lookup_opts.total_unique_constraints
436                 ),
437             )
438             for field_names in constraint_field_names:
439                 # Normalize attname references by using get_field().
440                 fields = [
441                     self.lookup_opts.get_field(field_name) for field_name in field_names
442                 ]
443                 # Composite unique constraints containing a nullable column
444                 # cannot ensure total ordering.
445                 if any(field.null for field in fields):
446                     continue
447                 if ordering_fields.issuperset(field.attname for field in fields):
448                     break
449             else:
450                 # If no set of unique fields is present in the ordering, rely
451                 # on the primary key to provide total ordering.
452                 ordering.append("-pk")
453         return ordering
454 
455     def get_ordering_field_columns(self):
456         """
457         Return a dictionary of ordering field column numbers and asc/desc.
458         """
459         # We must cope with more than one column having the same underlying sort
460         # field, so we base things on column numbers.
461         ordering = self._get_default_ordering()
462         ordering_fields = {}
463         if ORDER_VAR not in self.params:
464             # for ordering specified on ModelAdmin or model Meta, we don't know
465             # the right column numbers absolutely, because there might be more
466             # than one column associated with that ordering, so we guess.
467             for field in ordering:
468                 if isinstance(field, (Combinable, OrderBy)):
469                     if not isinstance(field, OrderBy):
470                         field = field.asc()
471                     if isinstance(field.expression, F):
472                         order_type = "desc" if field.descending else "asc"
473                         field = field.expression.name
474                     else:
475                         continue
476                 elif field.startswith("-"):
477                     field = field.removeprefix("-")
478                     order_type = "desc"
479                 else:
480                     order_type = "asc"
481                 for index, attr in enumerate(self.list_display):
482                     if self.get_ordering_field(attr) == field:
483                         ordering_fields[index] = order_type
484                         break
485         else:
486             for p in self.params[ORDER_VAR].split("."):
487                 none, pfx, idx = p.rpartition("-")
488                 try:
489                     idx = int(idx)
490                 except ValueError:
491                     continue  # skip it
492                 ordering_fields[idx] = "desc" if pfx == "-" else "asc"
493         return ordering_fields
494 
495     def get_queryset(self, request):
496         # First, we collect all the declared list filters.
497         (
498             self.filter_specs,
499             self.has_filters,
500             remaining_lookup_params,
501             filters_may_have_duplicates,
502             self.has_active_filters,
503         ) = self.get_filters(request)
504         # Then, we let every list filter modify the queryset to its liking.
505         qs = self.root_queryset
506         for filter_spec in self.filter_specs:
507             new_qs = filter_spec.queryset(request, qs)
508             if new_qs is not None:
509                 qs = new_qs
510 
511         try:
512             # Finally, we apply the remaining lookup parameters from the query
513             # string (i.e. those that haven't already been processed by the
514             # filters).
515             qs = qs.filter(**remaining_lookup_params)
516         except (SuspiciousOperation, ImproperlyConfigured):
517             # Allow certain types of errors to be re-raised as-is so that the
518             # caller can treat them in a special way.
519             raise
520         except Exception as e:
521             # Every other error is caught with a naked except, because we don't
522             # have any other way of validating lookup parameters. They might be
523             # invalid if the keyword arguments are incorrect, or if the values
524             # are not in the correct type, so we might get FieldError,
525             # ValueError, ValidationError, or ?.
526             raise IncorrectLookupParameters(e)
527 
528         # Apply search results
529         qs, search_may_have_duplicates = self.model_admin.get_search_results(
530             request,
531             qs,
532             self.query,
533         )
534 
535         # Set query string for clearing all filters.
536         self.clear_all_filters_qs = self.get_query_string(
537             new_params=remaining_lookup_params,
538             remove=self.get_filters_params(),
539         )
540         # Remove duplicates from results, if necessary
541         if filters_may_have_duplicates | search_may_have_duplicates:
542             qs = qs.filter(pk=OuterRef("pk"))
543             qs = self.root_queryset.filter(Exists(qs))
544 
545         # Set ordering.
546         ordering = self.get_ordering(request, qs)
547         qs = qs.order_by(*ordering)
548 
549         if not qs.query.select_related:
550             qs = self.apply_select_related(qs)
551 
552         return qs
553 
554     def apply_select_related(self, qs):
555         if self.list_select_related is True:
556             return qs.select_related()
557 
558         if self.list_select_related is False:
559             if self.has_related_field_in_list_display():
560                 return qs.select_related()
561 
562         if self.list_select_related:
563             return qs.select_related(*self.list_select_related)
564         return qs
565 
566     def has_related_field_in_list_display(self):
567         for field_name in self.list_display:
568             try:
569                 field = self.lookup_opts.get_field(field_name)
570             except FieldDoesNotExist:
571                 pass
572             else:
573                 if isinstance(field.remote_field, ManyToOneRel):
574                     # <FK>_id field names don't require a join.
575                     if field_name != field.get_attname():
576                         return True
577         return False
578 
579     def url_for_result(self, result):
580         pk = getattr(result, self.pk_attname)
581         return reverse(
582             "admin:%s_%s_change" % (self.opts.app_label, self.opts.model_name),
583             args=(quote(pk),),
584             current_app=self.model_admin.admin_site.name,
585         )

</code><intended_behavior>Implementing or enhancing a get_queryset method (or similar) specifically for filtering LogEntry instances based on the admin site. This could involve adding new mechanisms or utilities that customize LogEntry queryset fetching to include consideration of AdminSite context, likely utilizing indirect identification or tagging mechanisms as mentioned earlier.</intended_behavior>]
2025-10-18 13:30:44.347 | INFO     | Search completed. Bug locations: [<file>django/contrib/admin/options.py</file>
<class>ModelAdmin</class>
<method>None</method>
<code>
614 class ModelAdmin(BaseModelAdmin):
615     """Encapsulate all admin options and functionality for a given model."""
616 
617     list_display = ("__str__",)
618     list_display_links = ()
619     list_filter = ()
620     list_select_related = False
621     list_per_page = 100
622     list_max_show_all = 200
623     list_editable = ()
624     search_fields = ()
625     search_help_text = None
626     date_hierarchy = None
627     save_as = False
628     save_as_continue = True
629     save_on_top = False
630     paginator = Paginator
631     preserve_filters = True
632     inlines = ()
633 
634     # Custom templates (designed to be over-ridden in subclasses)
635     add_form_template = None
636     change_form_template = None
637     change_list_template = None
638     delete_confirmation_template = None
639     delete_selected_confirmation_template = None
640     object_history_template = None
641     popup_response_template = None
642 
643     # Actions
644     actions = ()
645     action_form = helpers.ActionForm
646     actions_on_top = True
647     actions_on_bottom = False
648     actions_selection_counter = True
649     checks_class = ModelAdminChecks
650 
651     def __init__(self, model, admin_site):
652         self.model = model
653         self.opts = model._meta
654         self.admin_site = admin_site
655         super().__init__()
656 
657     def __str__(self):
658         return "%s.%s" % (self.opts.app_label, self.__class__.__name__)
659 
660     def __repr__(self):
661         return (
662             f"<{self.__class__.__qualname__}: model={self.model.__qualname__} "
663             f"site={self.admin_site!r}>"
664         )
665 
666     def get_inline_instances(self, request, obj=None):
667         inline_instances = []
668         for inline_class in self.get_inlines(request, obj):
669             inline = inline_class(self.model, self.admin_site)
670             if request:
671                 if not (
672                     inline.has_view_or_change_permission(request, obj)
673                     or inline.has_add_permission(request, obj)
674                     or inline.has_delete_permission(request, obj)
675                 ):
676                     continue
677                 if not inline.has_add_permission(request, obj):
678                     inline.max_num = 0
679             inline_instances.append(inline)
680 
681         return inline_instances
682 
683     def get_urls(self):
684         from django.urls import path
685 
686         def wrap(view):
687             def wrapper(*args, **kwargs):
688                 return self.admin_site.admin_view(view)(*args, **kwargs)
689 
690             wrapper.model_admin = self
691             return update_wrapper(wrapper, view)
692 
693         info = self.opts.app_label, self.opts.model_name
694 
695         return [
696             path("", wrap(self.changelist_view), name="%s_%s_changelist" % info),
697             path("add/", wrap(self.add_view), name="%s_%s_add" % info),
698             path(
699                 "<path:object_id>/history/",
700                 wrap(self.history_view),
701                 name="%s_%s_history" % info,
702             ),
703             path(
704                 "<path:object_id>/delete/",
705                 wrap(self.delete_view),
706                 name="%s_%s_delete" % info,
707             ),
708             path(
709                 "<path:object_id>/change/",
710                 wrap(self.change_view),
711                 name="%s_%s_change" % info,
712             ),
713             # For backwards compatibility (was the change url before 1.9)
714             path(
715                 "<path:object_id>/",
716                 wrap(
717                     RedirectView.as_view(
718                         pattern_name="%s:%s_%s_change"
719                         % ((self.admin_site.name,) + info)
720                     )
721                 ),
722             ),
723         ]
724 
725     @property
726     def urls(self):
727         return self.get_urls()
728 
729     @property
730     def media(self):
731         extra = "" if settings.DEBUG else ".min"
732         js = [
733             "vendor/jquery/jquery%s.js" % extra,
734             "jquery.init.js",
735             "core.js",
736             "admin/RelatedObjectLookups.js",
737             "actions.js",
738             "urlify.js",
739             "prepopulate.js",
740             "vendor/xregexp/xregexp%s.js" % extra,
741         ]
742         return forms.Media(js=["admin/js/%s" % url for url in js])
743 
744     def get_model_perms(self, request):
745         """
746         Return a dict of all perms for this model. This dict has the keys
747         ``add``, ``change``, ``delete``, and ``view`` mapping to the True/False
748         for each of those actions.
749         """
750         return {
751             "add": self.has_add_permission(request),
752             "change": self.has_change_permission(request),
753             "delete": self.has_delete_permission(request),
754             "view": self.has_view_permission(request),
755         }
756 
757     def _get_form_for_get_fields(self, request, obj):
758         return self.get_form(request, obj, fields=None)
759 
760     def get_form(self, request, obj=None, change=False, **kwargs):
761         """
762         Return a Form class for use in the admin add view. This is used by
763         add_view and change_view.
764         """
765         if "fields" in kwargs:
766             fields = kwargs.pop("fields")
767         else:
768             fields = flatten_fieldsets(self.get_fieldsets(request, obj))
769         excluded = self.get_exclude(request, obj)
770         exclude = [] if excluded is None else list(excluded)
771         readonly_fields = self.get_readonly_fields(request, obj)
772         exclude.extend(readonly_fields)
773         # Exclude all fields if it's a change form and the user doesn't have
774         # the change permission.
775         if (
776             change
777             and hasattr(request, "user")
778             and not self.has_change_permission(request, obj)
779         ):
780             exclude.extend(fields)
781         if excluded is None and hasattr(self.form, "_meta") and self.form._meta.exclude:
782             # Take the custom ModelForm's Meta.exclude into account only if the
783             # ModelAdmin doesn't define its own.
784             exclude.extend(self.form._meta.exclude)
785         # if exclude is an empty list we pass None to be consistent with the
786         # default on modelform_factory
787         exclude = exclude or None
788 
789         # Remove declared form fields which are in readonly_fields.
790         new_attrs = dict.fromkeys(
791             f for f in readonly_fields if f in self.form.declared_fields
792         )
793         form = type(self.form.__name__, (self.form,), new_attrs)
794 
795         defaults = {
796             "form": form,
797             "fields": fields,
798             "exclude": exclude,
799             "formfield_callback": partial(self.formfield_for_dbfield, request=request),
800             **kwargs,
801         }
802 
803         if defaults["fields"] is None and not modelform_defines_fields(
804             defaults["form"]
805         ):
806             defaults["fields"] = forms.ALL_FIELDS
807 
808         try:
809             return modelform_factory(self.model, **defaults)
810         except FieldError as e:
811             raise FieldError(
812                 "%s. Check fields/fieldsets/exclude attributes of class %s."
813                 % (e, self.__class__.__name__)
814             )
815 
816     def get_changelist(self, request, **kwargs):
817         """
818         Return the ChangeList class for use on the changelist page.
819         """
820         from django.contrib.admin.views.main import ChangeList
821 
822         return ChangeList
823 
824     def get_changelist_instance(self, request):
825         """
826         Return a `ChangeList` instance based on `request`. May raise
827         `IncorrectLookupParameters`.
828         """
829         list_display = self.get_list_display(request)
830         list_display_links = self.get_list_display_links(request, list_display)
831         # Add the action checkboxes if any actions are available.
832         if self.get_actions(request):
833             list_display = ["action_checkbox", *list_display]
834         sortable_by = self.get_sortable_by(request)
835         ChangeList = self.get_changelist(request)
836         return ChangeList(
837             request,
838             self.model,
839             list_display,
840             list_display_links,
841             self.get_list_filter(request),
842             self.date_hierarchy,
843             self.get_search_fields(request),
844             self.get_list_select_related(request),
845             self.list_per_page,
846             self.list_max_show_all,
847             self.list_editable,
848             self,
849             sortable_by,
850             self.search_help_text,
851         )
852 
853     def get_object(self, request, object_id, from_field=None):
854         """
855         Return an instance matching the field and value provided, the primary
856         key is used if no field is provided. Return ``None`` if no match is
857         found or the object_id fails validation.
858         """
859         queryset = self.get_queryset(request)
860         model = queryset.model
861         field = (
862             model._meta.pk if from_field is None else model._meta.get_field(from_field)
863         )
864         try:
865             object_id = field.to_python(object_id)
866             return queryset.get(**{field.name: object_id})
867         except (model.DoesNotExist, ValidationError, ValueError):
868             return None
869 
870     def get_changelist_form(self, request, **kwargs):
871         """
872         Return a Form class for use in the Formset on the changelist page.
873         """
874         defaults = {
875             "formfield_callback": partial(self.formfield_for_dbfield, request=request),
876             **kwargs,
877         }
878         if defaults.get("fields") is None and not modelform_defines_fields(
879             defaults.get("form")
880         ):
881             defaults["fields"] = forms.ALL_FIELDS
882 
883         return modelform_factory(self.model, **defaults)
884 
885     def get_changelist_formset(self, request, **kwargs):
886         """
887         Return a FormSet class for use on the changelist page if list_editable
888         is used.
889         """
890         defaults = {
891             "formfield_callback": partial(self.formfield_for_dbfield, request=request),
892             **kwargs,
893         }
894         return modelformset_factory(
895             self.model,
896             self.get_changelist_form(request),
897             extra=0,
898             fields=self.list_editable,
899             **defaults,
900         )
901 
902     def get_formsets_with_inlines(self, request, obj=None):
903         """
904         Yield formsets and the corresponding inlines.
905         """
906         for inline in self.get_inline_instances(request, obj):
907             yield inline.get_formset(request, obj), inline
908 
909     def get_paginator(
910         self, request, queryset, per_page, orphans=0, allow_empty_first_page=True
911     ):
912         return self.paginator(queryset, per_page, orphans, allow_empty_first_page)
913 
914     def log_addition(self, request, obj, message):
915         """
916         Log that an object has been successfully added.
917 
918         The default implementation creates an admin LogEntry object.
919         """
920         from django.contrib.admin.models import ADDITION, LogEntry
921 
922         return LogEntry.objects.log_action(
923             user_id=request.user.pk,
924             content_type_id=get_content_type_for_model(obj).pk,
925             object_id=obj.pk,
926             object_repr=str(obj),
927             action_flag=ADDITION,
928             change_message=message,
929         )
930 
931     def log_change(self, request, obj, message):
932         """
933         Log that an object has been successfully changed.
934 
935         The default implementation creates an admin LogEntry object.
936         """
937         from django.contrib.admin.models import CHANGE, LogEntry
938 
939         return LogEntry.objects.log_action(
940             user_id=request.user.pk,
941             content_type_id=get_content_type_for_model(obj).pk,
942             object_id=obj.pk,
943             object_repr=str(obj),
944             action_flag=CHANGE,
945             change_message=message,
946         )
947 
948     def log_deletion(self, request, obj, object_repr):
949         """
950         Log that an object will be deleted. Note that this method must be
951         called before the deletion.
952 
953         The default implementation creates an admin LogEntry object.
954         """
955         from django.contrib.admin.models import DELETION, LogEntry
956 
957         return LogEntry.objects.log_action(
958             user_id=request.user.pk,
959             content_type_id=get_content_type_for_model(obj).pk,
960             object_id=obj.pk,
961             object_repr=object_repr,
962             action_flag=DELETION,
963         )
964 
965     @display(description=mark_safe('<input type="checkbox" id="action-toggle">'))
966     def action_checkbox(self, obj):
967         """
968         A list_display column containing a checkbox widget.
969         """
970         return helpers.checkbox.render(helpers.ACTION_CHECKBOX_NAME, str(obj.pk))
971 
972     @staticmethod
973     def _get_action_description(func, name):
974         return getattr(func, "short_description", capfirst(name.replace("_", " ")))
975 
976     def _get_base_actions(self):
977         """Return the list of actions, prior to any request-based filtering."""
978         actions = []
979         base_actions = (self.get_action(action) for action in self.actions or [])
980         # get_action might have returned None, so filter any of those out.
981         base_actions = [action for action in base_actions if action]
982         base_action_names = {name for _, name, _ in base_actions}
983 
984         # Gather actions from the admin site first
985         for name, func in self.admin_site.actions:
986             if name in base_action_names:
987                 continue
988             description = self._get_action_description(func, name)
989             actions.append((func, name, description))
990         # Add actions from this ModelAdmin.
991         actions.extend(base_actions)
992         return actions
993 
994     def _filter_actions_by_permissions(self, request, actions):
995         """Filter out any actions that the user doesn't have access to."""
996         filtered_actions = []
997         for action in actions:
998             callable = action[0]
999             if not hasattr(callable, "allowed_permissions"):
1000                 filtered_actions.append(action)
1001                 continue
1002             permission_checks = (
1003                 getattr(self, "has_%s_permission" % permission)
1004                 for permission in callable.allowed_permissions
1005             )
1006             if any(has_permission(request) for has_permission in permission_checks):
1007                 filtered_actions.append(action)
1008         return filtered_actions
1009 
1010     def get_actions(self, request):
1011         """
1012         Return a dictionary mapping the names of all actions for this
1013         ModelAdmin to a tuple of (callable, name, description) for each action.
1014         """
1015         # If self.actions is set to None that means actions are disabled on
1016         # this page.
1017         if self.actions is None or IS_POPUP_VAR in request.GET:
1018             return {}
1019         actions = self._filter_actions_by_permissions(request, self._get_base_actions())
1020         return {name: (func, name, desc) for func, name, desc in actions}
1021 
1022     def get_action_choices(self, request, default_choices=models.BLANK_CHOICE_DASH):
1023         """
1024         Return a list of choices for use in a form object.  Each choice is a
1025         tuple (name, description).
1026         """
1027         choices = [] + default_choices
1028         for func, name, description in self.get_actions(request).values():
1029             choice = (name, description % model_format_dict(self.opts))
1030             choices.append(choice)
1031         return choices
1032 
1033     def get_action(self, action):
1034         """
1035         Return a given action from a parameter, which can either be a callable,
1036         or the name of a method on the ModelAdmin.  Return is a tuple of
1037         (callable, name, description).
1038         """
1039         # If the action is a callable, just use it.
1040         if callable(action):
1041             func = action
1042             action = action.__name__
1043 
1044         # Next, look for a method. Grab it off self.__class__ to get an unbound
1045         # method instead of a bound one; this ensures that the calling
1046         # conventions are the same for functions and methods.
1047         elif hasattr(self.__class__, action):
1048             func = getattr(self.__class__, action)
1049 
1050         # Finally, look for a named method on the admin site
1051         else:
1052             try:
1053                 func = self.admin_site.get_action(action)
1054             except KeyError:
1055                 return None
1056 
1057         description = self._get_action_description(func, action)
1058         return func, action, description
1059 
1060     def get_list_display(self, request):
1061         """
1062         Return a sequence containing the fields to be displayed on the
1063         changelist.
1064         """
1065         return self.list_display
1066 
1067     def get_list_display_links(self, request, list_display):
1068         """
1069         Return a sequence containing the fields to be displayed as links
1070         on the changelist. The list_display parameter is the list of fields
1071         returned by get_list_display().
1072         """
1073         if (
1074             self.list_display_links
1075             or self.list_display_links is None
1076             or not list_display
1077         ):
1078             return self.list_display_links
1079         else:
1080             # Use only the first item in list_display as link
1081             return list(list_display)[:1]
1082 
1083     def get_list_filter(self, request):
1084         """
1085         Return a sequence containing the fields to be displayed as filters in
1086         the right sidebar of the changelist page.
1087         """
1088         return self.list_filter
1089 
1090     def get_list_select_related(self, request):
1091         """
1092         Return a list of fields to add to the select_related() part of the
1093         changelist items query.
1094         """
1095         return self.list_select_related
1096 
1097     def get_search_fields(self, request):
1098         """
1099         Return a sequence containing the fields to be searched whenever
1100         somebody submits a search query.
1101         """
1102         return self.search_fields
1103 
1104     def get_search_results(self, request, queryset, search_term):
1105         """
1106         Return a tuple containing a queryset to implement the search
1107         and a boolean indicating if the results may contain duplicates.
1108         """
1109 
1110         # Apply keyword searches.
1111         def construct_search(field_name):
1112             if field_name.startswith("^"):
1113                 return "%s__istartswith" % field_name.removeprefix("^")
1114             elif field_name.startswith("="):
1115                 return "%s__iexact" % field_name.removeprefix("=")
1116             elif field_name.startswith("@"):
1117                 return "%s__search" % field_name.removeprefix("@")
1118             # Use field_name if it includes a lookup.
1119             opts = queryset.model._meta
1120             lookup_fields = field_name.split(LOOKUP_SEP)
1121             # Go through the fields, following all relations.
1122             prev_field = None
1123             for path_part in lookup_fields:
1124                 if path_part == "pk":
1125                     path_part = opts.pk.name
1126                 try:
1127                     field = opts.get_field(path_part)
1128                 except FieldDoesNotExist:
1129                     # Use valid query lookups.
1130                     if prev_field and prev_field.get_lookup(path_part):
1131                         return field_name
1132                 else:
1133                     prev_field = field
1134                     if hasattr(field, "path_infos"):
1135                         # Update opts to follow the relation.
1136                         opts = field.path_infos[-1].to_opts
1137             # Otherwise, use the field with icontains.
1138             return "%s__icontains" % field_name
1139 
1140         may_have_duplicates = False
1141         search_fields = self.get_search_fields(request)
1142         if search_fields and search_term:
1143             orm_lookups = [
1144                 construct_search(str(search_field)) for search_field in search_fields
1145             ]
1146             term_queries = []
1147             for bit in smart_split(search_term):
1148                 if bit.startswith(('"', "'")) and bit[0] == bit[-1]:
1149                     bit = unescape_string_literal(bit)
1150                 or_queries = models.Q.create(
1151                     [(orm_lookup, bit) for orm_lookup in orm_lookups],
1152                     connector=models.Q.OR,
1153                 )
1154                 term_queries.append(or_queries)
1155             queryset = queryset.filter(models.Q.create(term_queries))
1156             may_have_duplicates |= any(
1157                 lookup_spawns_duplicates(self.opts, search_spec)
1158                 for search_spec in orm_lookups
1159             )
1160         return queryset, may_have_duplicates
1161 
1162     def get_preserved_filters(self, request):
1163         """
1164         Return the preserved filters querystring.
1165         """
1166         match = request.resolver_match
1167         if self.preserve_filters and match:
1168             current_url = "%s:%s" % (match.app_name, match.url_name)
1169             changelist_url = "admin:%s_%s_changelist" % (
1170                 self.opts.app_label,
1171                 self.opts.model_name,
1172             )
1173             if current_url == changelist_url:
1174                 preserved_filters = request.GET.urlencode()
1175             else:
1176                 preserved_filters = request.GET.get("_changelist_filters")
1177 
1178             if preserved_filters:
1179                 return urlencode({"_changelist_filters": preserved_filters})
1180         return ""
1181 
1182     def construct_change_message(self, request, form, formsets, add=False):
1183         """
1184         Construct a JSON structure describing changes from a changed object.
1185         """
1186         return construct_change_message(form, formsets, add)
1187 
1188     def message_user(
1189         self, request, message, level=messages.INFO, extra_tags="", fail_silently=False
1190     ):
1191         """
1192         Send a message to the user. The default implementation
1193         posts a message using the django.contrib.messages backend.
1194 
1195         Exposes almost the same API as messages.add_message(), but accepts the
1196         positional arguments in a different order to maintain backwards
1197         compatibility. For convenience, it accepts the `level` argument as
1198         a string rather than the usual level number.
1199         """
1200         if not isinstance(level, int):
1201             # attempt to get the level if passed a string
1202             try:
1203                 level = getattr(messages.constants, level.upper())
1204             except AttributeError:
1205                 levels = messages.constants.DEFAULT_TAGS.values()
1206                 levels_repr = ", ".join("`%s`" % level for level in levels)
1207                 raise ValueError(
1208                     "Bad message level string: `%s`. Possible values are: %s"
1209                     % (level, levels_repr)
1210                 )
1211 
1212         messages.add_message(
1213             request, level, message, extra_tags=extra_tags, fail_silently=fail_silently
1214         )
1215 
1216     def save_form(self, request, form, change):
1217         """
1218         Given a ModelForm return an unsaved instance. ``change`` is True if
1219         the object is being changed, and False if it's being added.
1220         """
1221         return form.save(commit=False)
1222 
1223     def save_model(self, request, obj, form, change):
1224         """
1225         Given a model instance save it to the database.
1226         """
1227         obj.save()
1228 
1229     def delete_model(self, request, obj):
1230         """
1231         Given a model instance delete it from the database.
1232         """
1233         obj.delete()
1234 
1235     def delete_queryset(self, request, queryset):
1236         """Given a queryset, delete it from the database."""
1237         queryset.delete()
1238 
1239     def save_formset(self, request, form, formset, change):
1240         """
1241         Given an inline formset save it to the database.
1242         """
1243         formset.save()
1244 
1245     def save_related(self, request, form, formsets, change):
1246         """
1247         Given the ``HttpRequest``, the parent ``ModelForm`` instance, the
1248         list of inline formsets and a boolean value based on whether the
1249         parent is being added or changed, save the related objects to the
1250         database. Note that at this point save_form() and save_model() have
1251         already been called.
1252         """
1253         form.save_m2m()
1254         for formset in formsets:
1255             self.save_formset(request, form, formset, change=change)
1256 
1257     def render_change_form(
1258         self, request, context, add=False, change=False, form_url="", obj=None
1259     ):
1260         app_label = self.opts.app_label
1261         preserved_filters = self.get_preserved_filters(request)
1262         form_url = add_preserved_filters(
1263             {"preserved_filters": preserved_filters, "opts": self.opts}, form_url
1264         )
1265         view_on_site_url = self.get_view_on_site_url(obj)
1266         has_editable_inline_admin_formsets = False
1267         for inline in context["inline_admin_formsets"]:
1268             if (
1269                 inline.has_add_permission
1270                 or inline.has_change_permission
1271                 or inline.has_delete_permission
1272             ):
1273                 has_editable_inline_admin_formsets = True
1274                 break
1275         context.update(
1276             {
1277                 "add": add,
1278                 "change": change,
1279                 "has_view_permission": self.has_view_permission(request, obj),
1280                 "has_add_permission": self.has_add_permission(request),
1281                 "has_change_permission": self.has_change_permission(request, obj),
1282                 "has_delete_permission": self.has_delete_permission(request, obj),
1283                 "has_editable_inline_admin_formsets": (
1284                     has_editable_inline_admin_formsets
1285                 ),
1286                 "has_file_field": context["adminform"].form.is_multipart()
1287                 or any(
1288                     admin_formset.formset.is_multipart()
1289                     for admin_formset in context["inline_admin_formsets"]
1290                 ),
1291                 "has_absolute_url": view_on_site_url is not None,
1292                 "absolute_url": view_on_site_url,
1293                 "form_url": form_url,
1294                 "opts": self.opts,
1295                 "content_type_id": get_content_type_for_model(self.model).pk,
1296                 "save_as": self.save_as,
1297                 "save_on_top": self.save_on_top,
1298                 "to_field_var": TO_FIELD_VAR,
1299                 "is_popup_var": IS_POPUP_VAR,
1300                 "app_label": app_label,
1301             }
1302         )
1303         if add and self.add_form_template is not None:
1304             form_template = self.add_form_template
1305         else:
1306             form_template = self.change_form_template
1307 
1308         request.current_app = self.admin_site.name
1309 
1310         return TemplateResponse(
1311             request,
1312             form_template
1313             or [
1314                 "admin/%s/%s/change_form.html" % (app_label, self.opts.model_name),
1315                 "admin/%s/change_form.html" % app_label,
1316                 "admin/change_form.html",
1317             ],
1318             context,
1319         )
1320 
1321     def response_add(self, request, obj, post_url_continue=None):
1322         """
1323         Determine the HttpResponse for the add_view stage.
1324         """
1325         opts = obj._meta
1326         preserved_filters = self.get_preserved_filters(request)
1327         obj_url = reverse(
1328             "admin:%s_%s_change" % (opts.app_label, opts.model_name),
1329             args=(quote(obj.pk),),
1330             current_app=self.admin_site.name,
1331         )
1332         # Add a link to the object's change form if the user can edit the obj.
1333         if self.has_change_permission(request, obj):
1334             obj_repr = format_html('<a href="{}">{}</a>', urlquote(obj_url), obj)
1335         else:
1336             obj_repr = str(obj)
1337         msg_dict = {
1338             "name": opts.verbose_name,
1339             "obj": obj_repr,
1340         }
1341         # Here, we distinguish between different save types by checking for
1342         # the presence of keys in request.POST.
1343 
1344         if IS_POPUP_VAR in request.POST:
1345             to_field = request.POST.get(TO_FIELD_VAR)
1346             if to_field:
1347                 attr = str(to_field)
1348             else:
1349                 attr = obj._meta.pk.attname
1350             value = obj.serializable_value(attr)
1351             popup_response_data = json.dumps(
1352                 {
1353                     "value": str(value),
1354                     "obj": str(obj),
1355                 }
1356             )
1357             return TemplateResponse(
1358                 request,
1359                 self.popup_response_template
1360                 or [
1361                     "admin/%s/%s/popup_response.html"
1362                     % (opts.app_label, opts.model_name),
1363                     "admin/%s/popup_response.html" % opts.app_label,
1364                     "admin/popup_response.html",
1365                 ],
1366                 {
1367                     "popup_response_data": popup_response_data,
1368                 },
1369             )
1370 
1371         elif "_continue" in request.POST or (
1372             # Redirecting after "Save as new".
1373             "_saveasnew" in request.POST
1374             and self.save_as_continue
1375             and self.has_change_permission(request, obj)
1376         ):
1377             msg = _("The {name} “{obj}” was added successfully.")
1378             if self.has_change_permission(request, obj):
1379                 msg += " " + _("You may edit it again below.")
1380             self.message_user(request, format_html(msg, **msg_dict), messages.SUCCESS)
1381             if post_url_continue is None:
1382                 post_url_continue = obj_url
1383             post_url_continue = add_preserved_filters(
1384                 {"preserved_filters": preserved_filters, "opts": opts},
1385                 post_url_continue,
1386             )
1387             return HttpResponseRedirect(post_url_continue)
1388 
1389         elif "_addanother" in request.POST:
1390             msg = format_html(
1391                 _(
1392                     "The {name} “{obj}” was added successfully. You may add another "
1393                     "{name} below."
1394                 ),
1395                 **msg_dict,
1396             )
1397             self.message_user(request, msg, messages.SUCCESS)
1398             redirect_url = request.path
1399             redirect_url = add_preserved_filters(
1400                 {"preserved_filters": preserved_filters, "opts": opts}, redirect_url
1401             )
1402             return HttpResponseRedirect(redirect_url)
1403 
1404         else:
1405             msg = format_html(
1406                 _("The {name} “{obj}” was added successfully."), **msg_dict
1407             )
1408             self.message_user(request, msg, messages.SUCCESS)
1409             return self.response_post_save_add(request, obj)
1410 
1411     def response_change(self, request, obj):
1412         """
1413         Determine the HttpResponse for the change_view stage.
1414         """
1415 
1416         if IS_POPUP_VAR in request.POST:
1417             opts = obj._meta
1418             to_field = request.POST.get(TO_FIELD_VAR)
1419             attr = str(to_field) if to_field else opts.pk.attname
1420             value = request.resolver_match.kwargs["object_id"]
1421             new_value = obj.serializable_value(attr)
1422             popup_response_data = json.dumps(
1423                 {
1424                     "action": "change",
1425                     "value": str(value),
1426                     "obj": str(obj),
1427                     "new_value": str(new_value),
1428                 }
1429             )
1430             return TemplateResponse(
1431                 request,
1432                 self.popup_response_template
1433                 or [
1434                     "admin/%s/%s/popup_response.html"
1435                     % (opts.app_label, opts.model_name),
1436                     "admin/%s/popup_response.html" % opts.app_label,
1437                     "admin/popup_response.html",
1438                 ],
1439                 {
1440                     "popup_response_data": popup_response_data,
1441                 },
1442             )
1443 
1444         opts = self.opts
1445         preserved_filters = self.get_preserved_filters(request)
1446 
1447         msg_dict = {
1448             "name": opts.verbose_name,
1449             "obj": format_html('<a href="{}">{}</a>', urlquote(request.path), obj),
1450         }
1451         if "_continue" in request.POST:
1452             msg = format_html(
1453                 _(
1454                     "The {name} “{obj}” was changed successfully. You may edit it "
1455                     "again below."
1456                 ),
1457                 **msg_dict,
1458             )
1459             self.message_user(request, msg, messages.SUCCESS)
1460             redirect_url = request.path
1461             redirect_url = add_preserved_filters(
1462                 {"preserved_filters": preserved_filters, "opts": opts}, redirect_url
1463             )
1464             return HttpResponseRedirect(redirect_url)
1465 
1466         elif "_saveasnew" in request.POST:
1467             msg = format_html(
1468                 _(
1469                     "The {name} “{obj}” was added successfully. You may edit it again "
1470                     "below."
1471                 ),
1472                 **msg_dict,
1473             )
1474             self.message_user(request, msg, messages.SUCCESS)
1475             redirect_url = reverse(
1476                 "admin:%s_%s_change" % (opts.app_label, opts.model_name),
1477                 args=(obj.pk,),
1478                 current_app=self.admin_site.name,
1479             )
1480             redirect_url = add_preserved_filters(
1481                 {"preserved_filters": preserved_filters, "opts": opts}, redirect_url
1482             )
1483             return HttpResponseRedirect(redirect_url)
1484 
1485         elif "_addanother" in request.POST:
1486             msg = format_html(
1487                 _(
1488                     "The {name} “{obj}” was changed successfully. You may add another "
1489                     "{name} below."
1490                 ),
1491                 **msg_dict,
1492             )
1493             self.message_user(request, msg, messages.SUCCESS)
1494             redirect_url = reverse(
1495                 "admin:%s_%s_add" % (opts.app_label, opts.model_name),
1496                 current_app=self.admin_site.name,
1497             )
1498             redirect_url = add_preserved_filters(
1499                 {"preserved_filters": preserved_filters, "opts": opts}, redirect_url
1500             )
1501             return HttpResponseRedirect(redirect_url)
1502 
1503         else:
1504             msg = format_html(
1505                 _("The {name} “{obj}” was changed successfully."), **msg_dict
1506             )
1507             self.message_user(request, msg, messages.SUCCESS)
1508             return self.response_post_save_change(request, obj)
1509 
1510     def _response_post_save(self, request, obj):
1511         if self.has_view_or_change_permission(request):
1512             post_url = reverse(
1513                 "admin:%s_%s_changelist" % (self.opts.app_label, self.opts.model_name),
1514                 current_app=self.admin_site.name,
1515             )
1516             preserved_filters = self.get_preserved_filters(request)
1517             post_url = add_preserved_filters(
1518                 {"preserved_filters": preserved_filters, "opts": self.opts}, post_url
1519             )
1520         else:
1521             post_url = reverse("admin:index", current_app=self.admin_site.name)
1522         return HttpResponseRedirect(post_url)
1523 
1524     def response_post_save_add(self, request, obj):
1525         """
1526         Figure out where to redirect after the 'Save' button has been pressed
1527         when adding a new object.
1528         """
1529         return self._response_post_save(request, obj)
1530 
1531     def response_post_save_change(self, request, obj):
1532         """
1533         Figure out where to redirect after the 'Save' button has been pressed
1534         when editing an existing object.
1535         """
1536         return self._response_post_save(request, obj)
1537 
1538     def response_action(self, request, queryset):
1539         """
1540         Handle an admin action. This is called if a request is POSTed to the
1541         changelist; it returns an HttpResponse if the action was handled, and
1542         None otherwise.
1543         """
1544 
1545         # There can be multiple action forms on the page (at the top
1546         # and bottom of the change list, for example). Get the action
1547         # whose button was pushed.
1548         try:
1549             action_index = int(request.POST.get("index", 0))
1550         except ValueError:
1551             action_index = 0
1552 
1553         # Construct the action form.
1554         data = request.POST.copy()
1555         data.pop(helpers.ACTION_CHECKBOX_NAME, None)
1556         data.pop("index", None)
1557 
1558         # Use the action whose button was pushed
1559         try:
1560             data.update({"action": data.getlist("action")[action_index]})
1561         except IndexError:
1562             # If we didn't get an action from the chosen form that's invalid
1563             # POST data, so by deleting action it'll fail the validation check
1564             # below. So no need to do anything here
1565             pass
1566 
1567         action_form = self.action_form(data, auto_id=None)
1568         action_form.fields["action"].choices = self.get_action_choices(request)
1569 
1570         # If the form's valid we can handle the action.
1571         if action_form.is_valid():
1572             action = action_form.cleaned_data["action"]
1573             select_across = action_form.cleaned_data["select_across"]
1574             func = self.get_actions(request)[action][0]
1575 
1576             # Get the list of selected PKs. If nothing's selected, we can't
1577             # perform an action on it, so bail. Except we want to perform
1578             # the action explicitly on all objects.
1579             selected = request.POST.getlist(helpers.ACTION_CHECKBOX_NAME)
1580             if not selected and not select_across:
1581                 # Reminder that something needs to be selected or nothing will happen
1582                 msg = _(
1583                     "Items must be selected in order to perform "
1584                     "actions on them. No items have been changed."
1585                 )
1586                 self.message_user(request, msg, messages.WARNING)
1587                 return None
1588 
1589             if not select_across:
1590                 # Perform the action only on the selected objects
1591                 queryset = queryset.filter(pk__in=selected)
1592 
1593             response = func(self, request, queryset)
1594 
1595             # Actions may return an HttpResponse-like object, which will be
1596             # used as the response from the POST. If not, we'll be a good
1597             # little HTTP citizen and redirect back to the changelist page.
1598             if isinstance(response, HttpResponseBase):
1599                 return response
1600             else:
1601                 return HttpResponseRedirect(request.get_full_path())
1602         else:
1603             msg = _("No action selected.")
1604             self.message_user(request, msg, messages.WARNING)
1605             return None
1606 
1607     def response_delete(self, request, obj_display, obj_id):
1608         """
1609         Determine the HttpResponse for the delete_view stage.
1610         """
1611         if IS_POPUP_VAR in request.POST:
1612             popup_response_data = json.dumps(
1613                 {
1614                     "action": "delete",
1615                     "value": str(obj_id),
1616                 }
1617             )
1618             return TemplateResponse(
1619                 request,
1620                 self.popup_response_template
1621                 or [
1622                     "admin/%s/%s/popup_response.html"
1623                     % (self.opts.app_label, self.opts.model_name),
1624                     "admin/%s/popup_response.html" % self.opts.app_label,
1625                     "admin/popup_response.html",
1626                 ],
1627                 {
1628                     "popup_response_data": popup_response_data,
1629                 },
1630             )
1631 
1632         self.message_user(
1633             request,
1634             _("The %(name)s “%(obj)s” was deleted successfully.")
1635             % {
1636                 "name": self.opts.verbose_name,
1637                 "obj": obj_display,
1638             },
1639             messages.SUCCESS,
1640         )
1641 
1642         if self.has_change_permission(request, None):
1643             post_url = reverse(
1644                 "admin:%s_%s_changelist" % (self.opts.app_label, self.opts.model_name),
1645                 current_app=self.admin_site.name,
1646             )
1647             preserved_filters = self.get_preserved_filters(request)
1648             post_url = add_preserved_filters(
1649                 {"preserved_filters": preserved_filters, "opts": self.opts}, post_url
1650             )
1651         else:
1652             post_url = reverse("admin:index", current_app=self.admin_site.name)
1653         return HttpResponseRedirect(post_url)
1654 
1655     def render_delete_form(self, request, context):
1656         app_label = self.opts.app_label
1657 
1658         request.current_app = self.admin_site.name
1659         context.update(
1660             to_field_var=TO_FIELD_VAR,
1661             is_popup_var=IS_POPUP_VAR,
1662             media=self.media,
1663         )
1664 
1665         return TemplateResponse(
1666             request,
1667             self.delete_confirmation_template
1668             or [
1669                 "admin/{}/{}/delete_confirmation.html".format(
1670                     app_label, self.opts.model_name
1671                 ),
1672                 "admin/{}/delete_confirmation.html".format(app_label),
1673                 "admin/delete_confirmation.html",
1674             ],
1675             context,
1676         )
1677 
1678     def get_inline_formsets(self, request, formsets, inline_instances, obj=None):
1679         # Edit permissions on parent model are required for editable inlines.
1680         can_edit_parent = (
1681             self.has_change_permission(request, obj)
1682             if obj
1683             else self.has_add_permission(request)
1684         )
1685         inline_admin_formsets = []
1686         for inline, formset in zip(inline_instances, formsets):
1687             fieldsets = list(inline.get_fieldsets(request, obj))
1688             readonly = list(inline.get_readonly_fields(request, obj))
1689             if can_edit_parent:
1690                 has_add_permission = inline.has_add_permission(request, obj)
1691                 has_change_permission = inline.has_change_permission(request, obj)
1692                 has_delete_permission = inline.has_delete_permission(request, obj)
1693             else:
1694                 # Disable all edit-permissions, and override formset settings.
1695                 has_add_permission = (
1696                     has_change_permission
1697                 ) = has_delete_permission = False
1698                 formset.extra = formset.max_num = 0
1699             has_view_permission = inline.has_view_permission(request, obj)
1700             prepopulated = dict(inline.get_prepopulated_fields(request, obj))
1701             inline_admin_formset = helpers.InlineAdminFormSet(
1702                 inline,
1703                 formset,
1704                 fieldsets,
1705                 prepopulated,
1706                 readonly,
1707                 model_admin=self,
1708                 has_add_permission=has_add_permission,
1709                 has_change_permission=has_change_permission,
1710                 has_delete_permission=has_delete_permission,
1711                 has_view_permission=has_view_permission,
1712             )
1713             inline_admin_formsets.append(inline_admin_formset)
1714         return inline_admin_formsets
1715 
1716     def get_changeform_initial_data(self, request):
1717         """
1718         Get the initial form data from the request's GET params.
1719         """
1720         initial = dict(request.GET.items())
1721         for k in initial:
1722             try:
1723                 f = self.opts.get_field(k)
1724             except FieldDoesNotExist:
1725                 continue
1726             # We have to special-case M2Ms as a list of comma-separated PKs.
1727             if isinstance(f, models.ManyToManyField):
1728                 initial[k] = initial[k].split(",")
1729         return initial
1730 
1731     def _get_obj_does_not_exist_redirect(self, request, opts, object_id):
1732         """
1733         Create a message informing the user that the object doesn't exist
1734         and return a redirect to the admin index page.
1735         """
1736         msg = _("%(name)s with ID “%(key)s” doesn’t exist. Perhaps it was deleted?") % {
1737             "name": opts.verbose_name,
1738             "key": unquote(object_id),
1739         }
1740         self.message_user(request, msg, messages.WARNING)
1741         url = reverse("admin:index", current_app=self.admin_site.name)
1742         return HttpResponseRedirect(url)
1743 
1744     @csrf_protect_m
1745     def changeform_view(self, request, object_id=None, form_url="", extra_context=None):
1746         with transaction.atomic(using=router.db_for_write(self.model)):
1747             return self._changeform_view(request, object_id, form_url, extra_context)
1748 
1749     def _changeform_view(self, request, object_id, form_url, extra_context):
1750         to_field = request.POST.get(TO_FIELD_VAR, request.GET.get(TO_FIELD_VAR))
1751         if to_field and not self.to_field_allowed(request, to_field):
1752             raise DisallowedModelAdminToField(
1753                 "The field %s cannot be referenced." % to_field
1754             )
1755 
1756         if request.method == "POST" and "_saveasnew" in request.POST:
1757             object_id = None
1758 
1759         add = object_id is None
1760 
1761         if add:
1762             if not self.has_add_permission(request):
1763                 raise PermissionDenied
1764             obj = None
1765 
1766         else:
1767             obj = self.get_object(request, unquote(object_id), to_field)
1768 
1769             if request.method == "POST":
1770                 if not self.has_change_permission(request, obj):
1771                     raise PermissionDenied
1772             else:
1773                 if not self.has_view_or_change_permission(request, obj):
1774                     raise PermissionDenied
1775 
1776             if obj is None:
1777                 return self._get_obj_does_not_exist_redirect(
1778                     request, self.opts, object_id
1779                 )
1780 
1781         fieldsets = self.get_fieldsets(request, obj)
1782         ModelForm = self.get_form(
1783             request, obj, change=not add, fields=flatten_fieldsets(fieldsets)
1784         )
1785         if request.method == "POST":
1786             form = ModelForm(request.POST, request.FILES, instance=obj)
1787             formsets, inline_instances = self._create_formsets(
1788                 request,
1789                 form.instance,
1790                 change=not add,
1791             )
1792             form_validated = form.is_valid()
1793             if form_validated:
1794                 new_object = self.save_form(request, form, change=not add)
1795             else:
1796                 new_object = form.instance
1797             if all_valid(formsets) and form_validated:
1798                 self.save_model(request, new_object, form, not add)
1799                 self.save_related(request, form, formsets, not add)
1800                 change_message = self.construct_change_message(
1801                     request, form, formsets, add
1802                 )
1803                 if add:
1804                     self.log_addition(request, new_object, change_message)
1805                     return self.response_add(request, new_object)
1806                 else:
1807                     self.log_change(request, new_object, change_message)
1808                     return self.response_change(request, new_object)
1809             else:
1810                 form_validated = False
1811         else:
1812             if add:
1813                 initial = self.get_changeform_initial_data(request)
1814                 form = ModelForm(initial=initial)
1815                 formsets, inline_instances = self._create_formsets(
1816                     request, form.instance, change=False
1817                 )
1818             else:
1819                 form = ModelForm(instance=obj)
1820                 formsets, inline_instances = self._create_formsets(
1821                     request, obj, change=True
1822                 )
1823 
1824         if not add and not self.has_change_permission(request, obj):
1825             readonly_fields = flatten_fieldsets(fieldsets)
1826         else:
1827             readonly_fields = self.get_readonly_fields(request, obj)
1828         admin_form = helpers.AdminForm(
1829             form,
1830             list(fieldsets),
1831             # Clear prepopulated fields on a view-only form to avoid a crash.
1832             self.get_prepopulated_fields(request, obj)
1833             if add or self.has_change_permission(request, obj)
1834             else {},
1835             readonly_fields,
1836             model_admin=self,
1837         )
1838         media = self.media + admin_form.media
1839 
1840         inline_formsets = self.get_inline_formsets(
1841             request, formsets, inline_instances, obj
1842         )
1843         for inline_formset in inline_formsets:
1844             media += inline_formset.media
1845 
1846         if add:
1847             title = _("Add %s")
1848         elif self.has_change_permission(request, obj):
1849             title = _("Change %s")
1850         else:
1851             title = _("View %s")
1852         context = {
1853             **self.admin_site.each_context(request),
1854             "title": title % self.opts.verbose_name,
1855             "subtitle": str(obj) if obj else None,
1856             "adminform": admin_form,
1857             "object_id": object_id,
1858             "original": obj,
1859             "is_popup": IS_POPUP_VAR in request.POST or IS_POPUP_VAR in request.GET,
1860             "to_field": to_field,
1861             "media": media,
1862             "inline_admin_formsets": inline_formsets,
1863             "errors": helpers.AdminErrorList(form, formsets),
1864             "preserved_filters": self.get_preserved_filters(request),
1865         }
1866 
1867         # Hide the "Save" and "Save and continue" buttons if "Save as New" was
1868         # previously chosen to prevent the interface from getting confusing.
1869         if (
1870             request.method == "POST"
1871             and not form_validated
1872             and "_saveasnew" in request.POST
1873         ):
1874             context["show_save"] = False
1875             context["show_save_and_continue"] = False
1876             # Use the change template instead of the add template.
1877             add = False
1878 
1879         context.update(extra_context or {})
1880 
1881         return self.render_change_form(
1882             request, context, add=add, change=not add, obj=obj, form_url=form_url
1883         )
1884 
1885     def add_view(self, request, form_url="", extra_context=None):
1886         return self.changeform_view(request, None, form_url, extra_context)
1887 
1888     def change_view(self, request, object_id, form_url="", extra_context=None):
1889         return self.changeform_view(request, object_id, form_url, extra_context)
1890 
1891     def _get_edited_object_pks(self, request, prefix):
1892         """Return POST data values of list_editable primary keys."""
1893         pk_pattern = re.compile(
1894             r"{}-\d+-{}$".format(re.escape(prefix), self.opts.pk.name)
1895         )
1896         return [value for key, value in request.POST.items() if pk_pattern.match(key)]
1897 
1898     def _get_list_editable_queryset(self, request, prefix):
1899         """
1900         Based on POST data, return a queryset of the objects that were edited
1901         via list_editable.
1902         """
1903         object_pks = self._get_edited_object_pks(request, prefix)
1904         queryset = self.get_queryset(request)
1905         validate = queryset.model._meta.pk.to_python
1906         try:
1907             for pk in object_pks:
1908                 validate(pk)
1909         except ValidationError:
1910             # Disable the optimization if the POST data was tampered with.
1911             return queryset
1912         return queryset.filter(pk__in=object_pks)
1913 
1914     @csrf_protect_m
1915     def changelist_view(self, request, extra_context=None):
1916         """
1917         The 'change list' admin view for this model.
1918         """
1919         from django.contrib.admin.views.main import ERROR_FLAG
1920 
1921         app_label = self.opts.app_label
1922         if not self.has_view_or_change_permission(request):
1923             raise PermissionDenied
1924 
1925         try:
1926             cl = self.get_changelist_instance(request)
1927         except IncorrectLookupParameters:
1928             # Wacky lookup parameters were given, so redirect to the main
1929             # changelist page, without parameters, and pass an 'invalid=1'
1930             # parameter via the query string. If wacky parameters were given
1931             # and the 'invalid=1' parameter was already in the query string,
1932             # something is screwed up with the database, so display an error
1933             # page.
1934             if ERROR_FLAG in request.GET:
1935                 return SimpleTemplateResponse(
1936                     "admin/invalid_setup.html",
1937                     {
1938                         "title": _("Database error"),
1939                     },
1940                 )
1941             return HttpResponseRedirect(request.path + "?" + ERROR_FLAG + "=1")
1942 
1943         # If the request was POSTed, this might be a bulk action or a bulk
1944         # edit. Try to look up an action or confirmation first, but if this
1945         # isn't an action the POST will fall through to the bulk edit check,
1946         # below.
1947         action_failed = False
1948         selected = request.POST.getlist(helpers.ACTION_CHECKBOX_NAME)
1949 
1950         actions = self.get_actions(request)
1951         # Actions with no confirmation
1952         if (
1953             actions
1954             and request.method == "POST"
1955             and "index" in request.POST
1956             and "_save" not in request.POST
1957         ):
1958             if selected:
1959                 response = self.response_action(
1960                     request, queryset=cl.get_queryset(request)
1961                 )
1962                 if response:
1963                     return response
1964                 else:
1965                     action_failed = True
1966             else:
1967                 msg = _(
1968                     "Items must be selected in order to perform "
1969                     "actions on them. No items have been changed."
1970                 )
1971                 self.message_user(request, msg, messages.WARNING)
1972                 action_failed = True
1973 
1974         # Actions with confirmation
1975         if (
1976             actions
1977             and request.method == "POST"
1978             and helpers.ACTION_CHECKBOX_NAME in request.POST
1979             and "index" not in request.POST
1980             and "_save" not in request.POST
1981         ):
1982             if selected:
1983                 response = self.response_action(
1984                     request, queryset=cl.get_queryset(request)
1985                 )
1986                 if response:
1987                     return response
1988                 else:
1989                     action_failed = True
1990 
1991         if action_failed:
1992             # Redirect back to the changelist page to avoid resubmitting the
1993             # form if the user refreshes the browser or uses the "No, take
1994             # me back" button on the action confirmation page.
1995             return HttpResponseRedirect(request.get_full_path())
1996 
1997         # If we're allowing changelist editing, we need to construct a formset
1998         # for the changelist given all the fields to be edited. Then we'll
1999         # use the formset to validate/process POSTed data.
2000         formset = cl.formset = None
2001 
2002         # Handle POSTed bulk-edit data.
2003         if request.method == "POST" and cl.list_editable and "_save" in request.POST:
2004             if not self.has_change_permission(request):
2005                 raise PermissionDenied
2006             FormSet = self.get_changelist_formset(request)
2007             modified_objects = self._get_list_editable_queryset(
2008                 request, FormSet.get_default_prefix()
2009             )
2010             formset = cl.formset = FormSet(
2011                 request.POST, request.FILES, queryset=modified_objects
2012             )
2013             if formset.is_valid():
2014                 changecount = 0
2015                 with transaction.atomic(using=router.db_for_write(self.model)):
2016                     for form in formset.forms:
2017                         if form.has_changed():
2018                             obj = self.save_form(request, form, change=True)
2019                             self.save_model(request, obj, form, change=True)
2020                             self.save_related(request, form, formsets=[], change=True)
2021                             change_msg = self.construct_change_message(
2022                                 request, form, None
2023                             )
2024                             self.log_change(request, obj, change_msg)
2025                             changecount += 1
2026                 if changecount:
2027                     msg = ngettext(
2028                         "%(count)s %(name)s was changed successfully.",
2029                         "%(count)s %(name)s were changed successfully.",
2030                         changecount,
2031                     ) % {
2032                         "count": changecount,
2033                         "name": model_ngettext(self.opts, changecount),
2034                     }
2035                     self.message_user(request, msg, messages.SUCCESS)
2036 
2037                 return HttpResponseRedirect(request.get_full_path())
2038 
2039         # Handle GET -- construct a formset for display.
2040         elif cl.list_editable and self.has_change_permission(request):
2041             FormSet = self.get_changelist_formset(request)
2042             formset = cl.formset = FormSet(queryset=cl.result_list)
2043 
2044         # Build the list of media to be used by the formset.
2045         if formset:
2046             media = self.media + formset.media
2047         else:
2048             media = self.media
2049 
2050         # Build the action form and populate it with available actions.
2051         if actions:
2052             action_form = self.action_form(auto_id=None)
2053             action_form.fields["action"].choices = self.get_action_choices(request)
2054             media += action_form.media
2055         else:
2056             action_form = None
2057 
2058         selection_note_all = ngettext(
2059             "%(total_count)s selected", "All %(total_count)s selected", cl.result_count
2060         )
2061 
2062         context = {
2063             **self.admin_site.each_context(request),
2064             "module_name": str(self.opts.verbose_name_plural),
2065             "selection_note": _("0 of %(cnt)s selected") % {"cnt": len(cl.result_list)},
2066             "selection_note_all": selection_note_all % {"total_count": cl.result_count},
2067             "title": cl.title,
2068             "subtitle": None,
2069             "is_popup": cl.is_popup,
2070             "to_field": cl.to_field,
2071             "cl": cl,
2072             "media": media,
2073             "has_add_permission": self.has_add_permission(request),
2074             "opts": cl.opts,
2075             "action_form": action_form,
2076             "actions_on_top": self.actions_on_top,
2077             "actions_on_bottom": self.actions_on_bottom,
2078             "actions_selection_counter": self.actions_selection_counter,
2079             "preserved_filters": self.get_preserved_filters(request),
2080             **(extra_context or {}),
2081         }
2082 
2083         request.current_app = self.admin_site.name
2084 
2085         return TemplateResponse(
2086             request,
2087             self.change_list_template
2088             or [
2089                 "admin/%s/%s/change_list.html" % (app_label, self.opts.model_name),
2090                 "admin/%s/change_list.html" % app_label,
2091                 "admin/change_list.html",
2092             ],
2093             context,
2094         )
2095 
2096     def get_deleted_objects(self, objs, request):
2097         """
2098         Hook for customizing the delete process for the delete view and the
2099         "delete selected" action.
2100         """
2101         return get_deleted_objects(objs, request, self.admin_site)
2102 
2103     @csrf_protect_m
2104     def delete_view(self, request, object_id, extra_context=None):
2105         with transaction.atomic(using=router.db_for_write(self.model)):
2106             return self._delete_view(request, object_id, extra_context)
2107 
2108     def _delete_view(self, request, object_id, extra_context):
2109         "The 'delete' admin view for this model."
2110         app_label = self.opts.app_label
2111 
2112         to_field = request.POST.get(TO_FIELD_VAR, request.GET.get(TO_FIELD_VAR))
2113         if to_field and not self.to_field_allowed(request, to_field):
2114             raise DisallowedModelAdminToField(
2115                 "The field %s cannot be referenced." % to_field
2116             )
2117 
2118         obj = self.get_object(request, unquote(object_id), to_field)
2119 
2120         if not self.has_delete_permission(request, obj):
2121             raise PermissionDenied
2122 
2123         if obj is None:
2124             return self._get_obj_does_not_exist_redirect(request, self.opts, object_id)
2125 
2126         # Populate deleted_objects, a data structure of all related objects that
2127         # will also be deleted.
2128         (
2129             deleted_objects,
2130             model_count,
2131             perms_needed,
2132             protected,
2133         ) = self.get_deleted_objects([obj], request)
2134 
2135         if request.POST and not protected:  # The user has confirmed the deletion.
2136             if perms_needed:
2137                 raise PermissionDenied
2138             obj_display = str(obj)
2139             attr = str(to_field) if to_field else self.opts.pk.attname
2140             obj_id = obj.serializable_value(attr)
2141             self.log_deletion(request, obj, obj_display)
2142             self.delete_model(request, obj)
2143 
2144             return self.response_delete(request, obj_display, obj_id)
2145 
2146         object_name = str(self.opts.verbose_name)
2147 
2148         if perms_needed or protected:
2149             title = _("Cannot delete %(name)s") % {"name": object_name}
2150         else:
2151             title = _("Are you sure?")
2152 
2153         context = {
2154             **self.admin_site.each_context(request),
2155             "title": title,
2156             "subtitle": None,
2157             "object_name": object_name,
2158             "object": obj,
2159             "deleted_objects": deleted_objects,
2160             "model_count": dict(model_count).items(),
2161             "perms_lacking": perms_needed,
2162             "protected": protected,
2163             "opts": self.opts,
2164             "app_label": app_label,
2165             "preserved_filters": self.get_preserved_filters(request),
2166             "is_popup": IS_POPUP_VAR in request.POST or IS_POPUP_VAR in request.GET,
2167             "to_field": to_field,
2168             **(extra_context or {}),
2169         }
2170 
2171         return self.render_delete_form(request, context)
2172 
2173     def history_view(self, request, object_id, extra_context=None):
2174         "The 'history' admin view for this model."
2175         from django.contrib.admin.models import LogEntry
2176         from django.contrib.admin.views.main import PAGE_VAR
2177 
2178         # First check if the user can see this history.
2179         model = self.model
2180         obj = self.get_object(request, unquote(object_id))
2181         if obj is None:
2182             return self._get_obj_does_not_exist_redirect(
2183                 request, model._meta, object_id
2184             )
2185 
2186         if not self.has_view_or_change_permission(request, obj):
2187             raise PermissionDenied
2188 
2189         # Then get the history for this object.
2190         app_label = self.opts.app_label
2191         action_list = (
2192             LogEntry.objects.filter(
2193                 object_id=unquote(object_id),
2194                 content_type=get_content_type_for_model(model),
2195             )
2196             .select_related()
2197             .order_by("action_time")
2198         )
2199 
2200         paginator = self.get_paginator(request, action_list, 100)
2201         page_number = request.GET.get(PAGE_VAR, 1)
2202         page_obj = paginator.get_page(page_number)
2203         page_range = paginator.get_elided_page_range(page_obj.number)
2204 
2205         context = {
2206             **self.admin_site.each_context(request),
2207             "title": _("Change history: %s") % obj,
2208             "subtitle": None,
2209             "action_list": page_obj,
2210             "page_range": page_range,
2211             "page_var": PAGE_VAR,
2212             "pagination_required": paginator.count > 100,
2213             "module_name": str(capfirst(self.opts.verbose_name_plural)),
2214             "object": obj,
2215             "opts": self.opts,
2216             "preserved_filters": self.get_preserved_filters(request),
2217             **(extra_context or {}),
2218         }
2219 
2220         request.current_app = self.admin_site.name
2221 
2222         return TemplateResponse(
2223             request,
2224             self.object_history_template
2225             or [
2226                 "admin/%s/%s/object_history.html" % (app_label, self.opts.model_name),
2227                 "admin/%s/object_history.html" % app_label,
2228                 "admin/object_history.html",
2229             ],
2230             context,
2231         )
2232 
2233     def get_formset_kwargs(self, request, obj, inline, prefix):
2234         formset_params = {
2235             "instance": obj,
2236             "prefix": prefix,
2237             "queryset": inline.get_queryset(request),
2238         }
2239         if request.method == "POST":
2240             formset_params.update(
2241                 {
2242                     "data": request.POST.copy(),
2243                     "files": request.FILES,
2244                     "save_as_new": "_saveasnew" in request.POST,
2245                 }
2246             )
2247         return formset_params
2248 
2249     def _create_formsets(self, request, obj, change):
2250         "Helper function to generate formsets for add/change_view."
2251         formsets = []
2252         inline_instances = []
2253         prefixes = {}
2254         get_formsets_args = [request]
2255         if change:
2256             get_formsets_args.append(obj)
2257         for FormSet, inline in self.get_formsets_with_inlines(*get_formsets_args):
2258             prefix = FormSet.get_default_prefix()
2259             prefixes[prefix] = prefixes.get(prefix, 0) + 1
2260             if prefixes[prefix] != 1 or not prefix:
2261                 prefix = "%s-%s" % (prefix, prefixes[prefix])
2262             formset_params = self.get_formset_kwargs(request, obj, inline, prefix)
2263             formset = FormSet(**formset_params)
2264 
2265             def user_deleted_form(request, obj, formset, index, inline):
2266                 """Return whether or not the user deleted the form."""
2267                 return (
2268                     inline.has_delete_permission(request, obj)
2269                     and "{}-{}-DELETE".format(formset.prefix, index) in request.POST
2270                 )
2271 
2272             # Bypass validation of each view-only inline form (since the form's
2273             # data won't be in request.POST), unless the form was deleted.
2274             if not inline.has_change_permission(request, obj if change else None):
2275                 for index, form in enumerate(formset.initial_forms):
2276                     if user_deleted_form(request, obj, formset, index, inline):
2277                         continue
2278                     form._errors = {}
2279                     form.cleaned_data = form.initial
2280             formsets.append(formset)
2281             inline_instances.append(inline)
2282         return formsets, inline_instances

</code><intended_behavior>These methods should be extended to not only log actions but also include a reference or identification of which AdminSite the action is associated with. A plausible approach could involve adding an additional parameter or context to these methods that allows passing information about the AdminSite. This added information could be stored in the LogEntry in an indirect manner (e.g., stored in the change_message as a serialized dict or utilizing a custom field that can encode this context). The challenge is to do this in a backward-compatible way, ensuring that existing functionality remains intact while providing the necessary hooks or information for AdminSite-specific LogEntry filtering.</intended_behavior>, <file>django/contrib/admin/sites.py</file>
<class>AdminSite</class>
<method>register</method>
<code>
99     def register(self, model_or_iterable, admin_class=None, **options):
100         """
101         Register the given model(s) with the given admin class.
102 
103         The model(s) should be Model classes, not instances.
104 
105         If an admin class isn't given, use ModelAdmin (the default admin
106         options). If keyword arguments are given -- e.g., list_display --
107         apply them as options to the admin class.
108 
109         If a model is already registered, raise AlreadyRegistered.
110 
111         If a model is abstract, raise ImproperlyConfigured.
112         """
113         admin_class = admin_class or ModelAdmin
114         if isinstance(model_or_iterable, ModelBase):
115             model_or_iterable = [model_or_iterable]
116         for model in model_or_iterable:
117             if model._meta.abstract:
118                 raise ImproperlyConfigured(
119                     "The model %s is abstract, so it cannot be registered with admin."
120                     % model.__name__
121                 )
122 
123             if model in self._registry:
124                 registered_admin = str(self._registry[model])
125                 msg = "The model %s is already registered " % model.__name__
126                 if registered_admin.endswith(".ModelAdmin"):
127                     # Most likely registered without a ModelAdmin subclass.
128                     msg += "in app %r." % registered_admin.removesuffix(".ModelAdmin")
129                 else:
130                     msg += "with %r." % registered_admin
131                 raise AlreadyRegistered(msg)
132 
133             # Ignore the registration if the model has been
134             # swapped out.
135             if not model._meta.swapped:
136                 # If we got **options then dynamically construct a subclass of
137                 # admin_class with those **options.
138                 if options:
139                     # For reasons I don't quite understand, without a __module__
140                     # the created class appears to "live" in the wrong place,
141                     # which causes issues later on.
142                     options["__module__"] = __name__
143                     admin_class = type(
144                         "%sAdmin" % model.__name__, (admin_class,), options
145                     )
146 
147                 # Instantiate the admin class to save in the registry
148                 self._registry[model] = admin_class(model, self)

</code><intended_behavior>While the register method itself may not need modification for direct bug resolution, ensuring its interaction with the logging mechanism considers AdminSite context is crucial. There may be value in exploring mechanisms within this method to implicitly or explicitly tag LogEntry instances with AdminSite identification upon registration or action logging. This implies a broader strategy of integrating AdminSite context awareness into actions logged via the ModelAdmin methods above.</intended_behavior>, <file>django/contrib/admin/sites.py</file>
<class>AdminSite</class>
<method>None</method>
<code>
36 class AdminSite:
37     """
38     An AdminSite object encapsulates an instance of the Django admin application, ready
39     to be hooked in to your URLconf. Models are registered with the AdminSite using the
40     register() method, and the get_urls() method can then be used to access Django view
41     functions that present a full admin interface for the collection of registered
42     models.
43     """
44 
45     # Text to put at the end of each page's <title>.
46     site_title = gettext_lazy("Django site admin")
47 
48     # Text to put in each page's <h1>.
49     site_header = gettext_lazy("Django administration")
50 
51     # Text to put at the top of the admin index page.
52     index_title = gettext_lazy("Site administration")
53 
54     # URL for the "View site" link at the top of each admin page.
55     site_url = "/"
56 
57     enable_nav_sidebar = True
58 
59     empty_value_display = "-"
60 
61     login_form = None
62     index_template = None
63     app_index_template = None
64     login_template = None
65     logout_template = None
66     password_change_template = None
67     password_change_done_template = None
68 
69     final_catch_all_view = True
70 
71     def __init__(self, name="admin"):
72         self._registry = {}  # model_class class -> admin_class instance
73         self.name = name
74         self._actions = {"delete_selected": actions.delete_selected}
75         self._global_actions = self._actions.copy()
76         all_sites.add(self)
77 
78     def __repr__(self):
79         return f"{self.__class__.__name__}(name={self.name!r})"
80 
81     def check(self, app_configs):
82         """
83         Run the system checks on all ModelAdmins, except if they aren't
84         customized at all.
85         """
86         if app_configs is None:
87             app_configs = apps.get_app_configs()
88         app_configs = set(app_configs)  # Speed up lookups below
89 
90         errors = []
91         modeladmins = (
92             o for o in self._registry.values() if o.__class__ is not ModelAdmin
93         )
94         for modeladmin in modeladmins:
95             if modeladmin.model._meta.app_config in app_configs:
96                 errors.extend(modeladmin.check())
97         return errors
98 
99     def register(self, model_or_iterable, admin_class=None, **options):
100         """
101         Register the given model(s) with the given admin class.
102 
103         The model(s) should be Model classes, not instances.
104 
105         If an admin class isn't given, use ModelAdmin (the default admin
106         options). If keyword arguments are given -- e.g., list_display --
107         apply them as options to the admin class.
108 
109         If a model is already registered, raise AlreadyRegistered.
110 
111         If a model is abstract, raise ImproperlyConfigured.
112         """
113         admin_class = admin_class or ModelAdmin
114         if isinstance(model_or_iterable, ModelBase):
115             model_or_iterable = [model_or_iterable]
116         for model in model_or_iterable:
117             if model._meta.abstract:
118                 raise ImproperlyConfigured(
119                     "The model %s is abstract, so it cannot be registered with admin."
120                     % model.__name__
121                 )
122 
123             if model in self._registry:
124                 registered_admin = str(self._registry[model])
125                 msg = "The model %s is already registered " % model.__name__
126                 if registered_admin.endswith(".ModelAdmin"):
127                     # Most likely registered without a ModelAdmin subclass.
128                     msg += "in app %r." % registered_admin.removesuffix(".ModelAdmin")
129                 else:
130                     msg += "with %r." % registered_admin
131                 raise AlreadyRegistered(msg)
132 
133             # Ignore the registration if the model has been
134             # swapped out.
135             if not model._meta.swapped:
136                 # If we got **options then dynamically construct a subclass of
137                 # admin_class with those **options.
138                 if options:
139                     # For reasons I don't quite understand, without a __module__
140                     # the created class appears to "live" in the wrong place,
141                     # which causes issues later on.
142                     options["__module__"] = __name__
143                     admin_class = type(
144                         "%sAdmin" % model.__name__, (admin_class,), options
145                     )
146 
147                 # Instantiate the admin class to save in the registry
148                 self._registry[model] = admin_class(model, self)
149 
150     def unregister(self, model_or_iterable):
151         """
152         Unregister the given model(s).
153 
154         If a model isn't already registered, raise NotRegistered.
155         """
156         if isinstance(model_or_iterable, ModelBase):
157             model_or_iterable = [model_or_iterable]
158         for model in model_or_iterable:
159             if model not in self._registry:
160                 raise NotRegistered("The model %s is not registered" % model.__name__)
161             del self._registry[model]
162 
163     def is_registered(self, model):
164         """
165         Check if a model class is registered with this `AdminSite`.
166         """
167         return model in self._registry
168 
169     def add_action(self, action, name=None):
170         """
171         Register an action to be available globally.
172         """
173         name = name or action.__name__
174         self._actions[name] = action
175         self._global_actions[name] = action
176 
177     def disable_action(self, name):
178         """
179         Disable a globally-registered action. Raise KeyError for invalid names.
180         """
181         del self._actions[name]
182 
183     def get_action(self, name):
184         """
185         Explicitly get a registered global action whether it's enabled or
186         not. Raise KeyError for invalid names.
187         """
188         return self._global_actions[name]
189 
190     @property
191     def actions(self):
192         """
193         Get all the enabled actions as an iterable of (name, func).
194         """
195         return self._actions.items()
196 
197     def has_permission(self, request):
198         """
199         Return True if the given HttpRequest has permission to view
200         *at least one* page in the admin site.
201         """
202         return request.user.is_active and request.user.is_staff
203 
204     def admin_view(self, view, cacheable=False):
205         """
206         Decorator to create an admin view attached to this ``AdminSite``. This
207         wraps the view and provides permission checking by calling
208         ``self.has_permission``.
209 
210         You'll want to use this from within ``AdminSite.get_urls()``:
211 
212             class MyAdminSite(AdminSite):
213 
214                 def get_urls(self):
215                     from django.urls import path
216 
217                     urls = super().get_urls()
218                     urls += [
219                         path('my_view/', self.admin_view(some_view))
220                     ]
221                     return urls
222 
223         By default, admin_views are marked non-cacheable using the
224         ``never_cache`` decorator. If the view can be safely cached, set
225         cacheable=True.
226         """
227 
228         def inner(request, *args, **kwargs):
229             if not self.has_permission(request):
230                 if request.path == reverse("admin:logout", current_app=self.name):
231                     index_path = reverse("admin:index", current_app=self.name)
232                     return HttpResponseRedirect(index_path)
233                 # Inner import to prevent django.contrib.admin (app) from
234                 # importing django.contrib.auth.models.User (unrelated model).
235                 from django.contrib.auth.views import redirect_to_login
236 
237                 return redirect_to_login(
238                     request.get_full_path(),
239                     reverse("admin:login", current_app=self.name),
240                 )
241             return view(request, *args, **kwargs)
242 
243         if not cacheable:
244             inner = never_cache(inner)
245         # We add csrf_protect here so this function can be used as a utility
246         # function for any view, without having to repeat 'csrf_protect'.
247         if not getattr(view, "csrf_exempt", False):
248             inner = csrf_protect(inner)
249         return update_wrapper(inner, view)
250 
251     def get_urls(self):
252         # Since this module gets imported in the application's root package,
253         # it cannot import models from other applications at the module level,
254         # and django.contrib.contenttypes.views imports ContentType.
255         from django.contrib.contenttypes import views as contenttype_views
256         from django.urls import include, path, re_path
257 
258         def wrap(view, cacheable=False):
259             def wrapper(*args, **kwargs):
260                 return self.admin_view(view, cacheable)(*args, **kwargs)
261 
262             wrapper.admin_site = self
263             return update_wrapper(wrapper, view)
264 
265         # Admin-site-wide views.
266         urlpatterns = [
267             path("", wrap(self.index), name="index"),
268             path("login/", self.login, name="login"),
269             path("logout/", wrap(self.logout), name="logout"),
270             path(
271                 "password_change/",
272                 wrap(self.password_change, cacheable=True),
273                 name="password_change",
274             ),
275             path(
276                 "password_change/done/",
277                 wrap(self.password_change_done, cacheable=True),
278                 name="password_change_done",
279             ),
280             path("autocomplete/", wrap(self.autocomplete_view), name="autocomplete"),
281             path("jsi18n/", wrap(self.i18n_javascript, cacheable=True), name="jsi18n"),
282             path(
283                 "r/<int:content_type_id>/<path:object_id>/",
284                 wrap(contenttype_views.shortcut),
285                 name="view_on_site",
286             ),
287         ]
288 
289         # Add in each model's views, and create a list of valid URLS for the
290         # app_index
291         valid_app_labels = []
292         for model, model_admin in self._registry.items():
293             urlpatterns += [
294                 path(
295                     "%s/%s/" % (model._meta.app_label, model._meta.model_name),
296                     include(model_admin.urls),
297                 ),
298             ]
299             if model._meta.app_label not in valid_app_labels:
300                 valid_app_labels.append(model._meta.app_label)
301 
302         # If there were ModelAdmins registered, we should have a list of app
303         # labels for which we need to allow access to the app_index view,
304         if valid_app_labels:
305             regex = r"^(?P<app_label>" + "|".join(valid_app_labels) + ")/$"
306             urlpatterns += [
307                 re_path(regex, wrap(self.app_index), name="app_list"),
308             ]
309 
310         if self.final_catch_all_view:
311             urlpatterns.append(re_path(r"(?P<url>.*)$", wrap(self.catch_all_view)))
312 
313         return urlpatterns
314 
315     @property
316     def urls(self):
317         return self.get_urls(), "admin", self.name
318 
319     def each_context(self, request):
320         """
321         Return a dictionary of variables to put in the template context for
322         *every* page in the admin site.
323 
324         For sites running on a subpath, use the SCRIPT_NAME value if site_url
325         hasn't been customized.
326         """
327         script_name = request.META["SCRIPT_NAME"]
328         site_url = (
329             script_name if self.site_url == "/" and script_name else self.site_url
330         )
331         return {
332             "site_title": self.site_title,
333             "site_header": self.site_header,
334             "site_url": site_url,
335             "has_permission": self.has_permission(request),
336             "available_apps": self.get_app_list(request),
337             "is_popup": False,
338             "is_nav_sidebar_enabled": self.enable_nav_sidebar,
339         }
340 
341     def password_change(self, request, extra_context=None):
342         """
343         Handle the "change password" task -- both form display and validation.
344         """
345         from django.contrib.admin.forms import AdminPasswordChangeForm
346         from django.contrib.auth.views import PasswordChangeView
347 
348         url = reverse("admin:password_change_done", current_app=self.name)
349         defaults = {
350             "form_class": AdminPasswordChangeForm,
351             "success_url": url,
352             "extra_context": {**self.each_context(request), **(extra_context or {})},
353         }
354         if self.password_change_template is not None:
355             defaults["template_name"] = self.password_change_template
356         request.current_app = self.name
357         return PasswordChangeView.as_view(**defaults)(request)
358 
359     def password_change_done(self, request, extra_context=None):
360         """
361         Display the "success" page after a password change.
362         """
363         from django.contrib.auth.views import PasswordChangeDoneView
364 
365         defaults = {
366             "extra_context": {**self.each_context(request), **(extra_context or {})},
367         }
368         if self.password_change_done_template is not None:
369             defaults["template_name"] = self.password_change_done_template
370         request.current_app = self.name
371         return PasswordChangeDoneView.as_view(**defaults)(request)
372 
373     def i18n_javascript(self, request, extra_context=None):
374         """
375         Display the i18n JavaScript that the Django admin requires.
376 
377         `extra_context` is unused but present for consistency with the other
378         admin views.
379         """
380         return JavaScriptCatalog.as_view(packages=["django.contrib.admin"])(request)
381 
382     def logout(self, request, extra_context=None):
383         """
384         Log out the user for the given HttpRequest.
385 
386         This should *not* assume the user is already logged in.
387         """
388         from django.contrib.auth.views import LogoutView
389 
390         defaults = {
391             "extra_context": {
392                 **self.each_context(request),
393                 # Since the user isn't logged out at this point, the value of
394                 # has_permission must be overridden.
395                 "has_permission": False,
396                 **(extra_context or {}),
397             },
398         }
399         if self.logout_template is not None:
400             defaults["template_name"] = self.logout_template
401         request.current_app = self.name
402         return LogoutView.as_view(**defaults)(request)
403 
404     @method_decorator(never_cache)
405     def login(self, request, extra_context=None):
406         """
407         Display the login form for the given HttpRequest.
408         """
409         if request.method == "GET" and self.has_permission(request):
410             # Already logged-in, redirect to admin index
411             index_path = reverse("admin:index", current_app=self.name)
412             return HttpResponseRedirect(index_path)
413 
414         # Since this module gets imported in the application's root package,
415         # it cannot import models from other applications at the module level,
416         # and django.contrib.admin.forms eventually imports User.
417         from django.contrib.admin.forms import AdminAuthenticationForm
418         from django.contrib.auth.views import LoginView
419 
420         context = {
421             **self.each_context(request),
422             "title": _("Log in"),
423             "subtitle": None,
424             "app_path": request.get_full_path(),
425             "username": request.user.get_username(),
426         }
427         if (
428             REDIRECT_FIELD_NAME not in request.GET
429             and REDIRECT_FIELD_NAME not in request.POST
430         ):
431             context[REDIRECT_FIELD_NAME] = reverse("admin:index", current_app=self.name)
432         context.update(extra_context or {})
433 
434         defaults = {
435             "extra_context": context,
436             "authentication_form": self.login_form or AdminAuthenticationForm,
437             "template_name": self.login_template or "admin/login.html",
438         }
439         request.current_app = self.name
440         return LoginView.as_view(**defaults)(request)
441 
442     def autocomplete_view(self, request):
443         return AutocompleteJsonView.as_view(admin_site=self)(request)
444 
445     @no_append_slash
446     def catch_all_view(self, request, url):
447         if settings.APPEND_SLASH and not url.endswith("/"):
448             urlconf = getattr(request, "urlconf", None)
449             try:
450                 match = resolve("%s/" % request.path_info, urlconf)
451             except Resolver404:
452                 pass
453             else:
454                 if getattr(match.func, "should_append_slash", True):
455                     return HttpResponsePermanentRedirect("%s/" % request.path)
456         raise Http404
457 
458     def _build_app_dict(self, request, label=None):
459         """
460         Build the app dictionary. The optional `label` parameter filters models
461         of a specific app.
462         """
463         app_dict = {}
464 
465         if label:
466             models = {
467                 m: m_a
468                 for m, m_a in self._registry.items()
469                 if m._meta.app_label == label
470             }
471         else:
472             models = self._registry
473 
474         for model, model_admin in models.items():
475             app_label = model._meta.app_label
476 
477             has_module_perms = model_admin.has_module_permission(request)
478             if not has_module_perms:
479                 continue
480 
481             perms = model_admin.get_model_perms(request)
482 
483             # Check whether user has any perm for this module.
484             # If so, add the module to the model_list.
485             if True not in perms.values():
486                 continue
487 
488             info = (app_label, model._meta.model_name)
489             model_dict = {
490                 "model": model,
491                 "name": capfirst(model._meta.verbose_name_plural),
492                 "object_name": model._meta.object_name,
493                 "perms": perms,
494                 "admin_url": None,
495                 "add_url": None,
496             }
497             if perms.get("change") or perms.get("view"):
498                 model_dict["view_only"] = not perms.get("change")
499                 try:
500                     model_dict["admin_url"] = reverse(
501                         "admin:%s_%s_changelist" % info, current_app=self.name
502                     )
503                 except NoReverseMatch:
504                     pass
505             if perms.get("add"):
506                 try:
507                     model_dict["add_url"] = reverse(
508                         "admin:%s_%s_add" % info, current_app=self.name
509                     )
510                 except NoReverseMatch:
511                     pass
512 
513             if app_label in app_dict:
514                 app_dict[app_label]["models"].append(model_dict)
515             else:
516                 app_dict[app_label] = {
517                     "name": apps.get_app_config(app_label).verbose_name,
518                     "app_label": app_label,
519                     "app_url": reverse(
520                         "admin:app_list",
521                         kwargs={"app_label": app_label},
522                         current_app=self.name,
523                     ),
524                     "has_module_perms": has_module_perms,
525                     "models": [model_dict],
526                 }
527 
528         return app_dict
529 
530     def get_app_list(self, request, app_label=None):
531         """
532         Return a sorted list of all the installed apps that have been
533         registered in this site.
534         """
535         app_dict = self._build_app_dict(request, app_label)
536 
537         # Sort the apps alphabetically.
538         app_list = sorted(app_dict.values(), key=lambda x: x["name"].lower())
539 
540         # Sort the models alphabetically within each app.
541         for app in app_list:
542             app["models"].sort(key=lambda x: x["name"])
543 
544         return app_list
545 
546     def index(self, request, extra_context=None):
547         """
548         Display the main admin index page, which lists all of the installed
549         apps that have been registered in this site.
550         """
551         app_list = self.get_app_list(request)
552 
553         context = {
554             **self.each_context(request),
555             "title": self.index_title,
556             "subtitle": None,
557             "app_list": app_list,
558             **(extra_context or {}),
559         }
560 
561         request.current_app = self.name
562 
563         return TemplateResponse(
564             request, self.index_template or "admin/index.html", context
565         )
566 
567     def app_index(self, request, app_label, extra_context=None):
568         app_list = self.get_app_list(request, app_label)
569 
570         if not app_list:
571             raise Http404("The requested admin page does not exist.")
572 
573         context = {
574             **self.each_context(request),
575             "title": _("%(app)s administration") % {"app": app_list[0]["name"]},
576             "subtitle": None,
577             "app_list": app_list,
578             "app_label": app_label,
579             **(extra_context or {}),
580         }
581 
582         request.current_app = self.name
583 
584         return TemplateResponse(
585             request,
586             self.app_index_template
587             or ["admin/%s/app_index.html" % app_label, "admin/app_index.html"],
588             context,
589         )

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>, <file>django/contrib/admin/views/main.py</file>
<class>None</class>
<method>None</method>
<code>
1 from datetime import datetime, timedelta
2 
3 from django import forms
4 from django.conf import settings
5 from django.contrib import messages
6 from django.contrib.admin import FieldListFilter
7 from django.contrib.admin.exceptions import (
8     DisallowedModelAdminLookup,
9     DisallowedModelAdminToField,
10 )
11 from django.contrib.admin.options import (
12     IS_POPUP_VAR,
13     TO_FIELD_VAR,
14     IncorrectLookupParameters,
15 )
16 from django.contrib.admin.utils import (
17     get_fields_from_path,
18     lookup_spawns_duplicates,
19     prepare_lookup_value,
20     quote,
21 )
22 from django.core.exceptions import (
23     FieldDoesNotExist,
24     ImproperlyConfigured,
25     SuspiciousOperation,
26 )
27 from django.core.paginator import InvalidPage
28 from django.db.models import Exists, F, Field, ManyToOneRel, OrderBy, OuterRef
29 from django.db.models.expressions import Combinable
30 from django.urls import reverse
31 from django.utils.http import urlencode
32 from django.utils.timezone import make_aware
33 from django.utils.translation import gettext
34 
35 # Changelist settings
36 ALL_VAR = "all"
37 ORDER_VAR = "o"
38 PAGE_VAR = "p"
39 SEARCH_VAR = "q"
40 ERROR_FLAG = "e"
41 
42 IGNORED_PARAMS = (ALL_VAR, ORDER_VAR, SEARCH_VAR, IS_POPUP_VAR, TO_FIELD_VAR)
43 
44 
45 class ChangeListSearchForm(forms.Form):
46     def __init__(self, *args, **kwargs):
47         super().__init__(*args, **kwargs)
48         # Populate "fields" dynamically because SEARCH_VAR is a variable:
49         self.fields = {
50             SEARCH_VAR: forms.CharField(required=False, strip=False),
51         }
52 
53 
54 class ChangeList:
55     search_form_class = ChangeListSearchForm
56 
57     def __init__(
58         self,
59         request,
60         model,
61         list_display,
62         list_display_links,
63         list_filter,
64         date_hierarchy,
65         search_fields,
66         list_select_related,
67         list_per_page,
68         list_max_show_all,
69         list_editable,
70         model_admin,
71         sortable_by,
72         search_help_text,
73     ):
74         self.model = model
75         self.opts = model._meta
76         self.lookup_opts = self.opts
77         self.root_queryset = model_admin.get_queryset(request)
78         self.list_display = list_display
79         self.list_display_links = list_display_links
80         self.list_filter = list_filter
81         self.has_filters = None
82         self.has_active_filters = None
83         self.clear_all_filters_qs = None
84         self.date_hierarchy = date_hierarchy
85         self.search_fields = search_fields
86         self.list_select_related = list_select_related
87         self.list_per_page = list_per_page
88         self.list_max_show_all = list_max_show_all
89         self.model_admin = model_admin
90         self.preserved_filters = model_admin.get_preserved_filters(request)
91         self.sortable_by = sortable_by
92         self.search_help_text = search_help_text
93 
94         # Get search parameters from the query string.
95         _search_form = self.search_form_class(request.GET)
96         if not _search_form.is_valid():
97             for error in _search_form.errors.values():
98                 messages.error(request, ", ".join(error))
99         self.query = _search_form.cleaned_data.get(SEARCH_VAR) or ""
100         try:
101             self.page_num = int(request.GET.get(PAGE_VAR, 1))
102         except ValueError:
103             self.page_num = 1
104         self.show_all = ALL_VAR in request.GET
105         self.is_popup = IS_POPUP_VAR in request.GET
106         to_field = request.GET.get(TO_FIELD_VAR)
107         if to_field and not model_admin.to_field_allowed(request, to_field):
108             raise DisallowedModelAdminToField(
109                 "The field %s cannot be referenced." % to_field
110             )
111         self.to_field = to_field
112         self.params = dict(request.GET.items())
113         if PAGE_VAR in self.params:
114             del self.params[PAGE_VAR]
115         if ERROR_FLAG in self.params:
116             del self.params[ERROR_FLAG]
117 
118         if self.is_popup:
119             self.list_editable = ()
120         else:
121             self.list_editable = list_editable
122         self.queryset = self.get_queryset(request)
123         self.get_results(request)
124         if self.is_popup:
125             title = gettext("Select %s")
126         elif self.model_admin.has_change_permission(request):
127             title = gettext("Select %s to change")
128         else:
129             title = gettext("Select %s to view")
130         self.title = title % self.opts.verbose_name
131         self.pk_attname = self.lookup_opts.pk.attname
132 
133     def __repr__(self):
134         return "<%s: model=%s model_admin=%s>" % (
135             self.__class__.__qualname__,
136             self.model.__qualname__,
137             self.model_admin.__class__.__qualname__,
138         )
139 
140     def get_filters_params(self, params=None):
141         """
142         Return all params except IGNORED_PARAMS.
143         """
144         params = params or self.params
145         lookup_params = params.copy()  # a dictionary of the query string
146         # Remove all the parameters that are globally and systematically
147         # ignored.
148         for ignored in IGNORED_PARAMS:
149             if ignored in lookup_params:
150                 del lookup_params[ignored]
151         return lookup_params
152 
153     def get_filters(self, request):
154         lookup_params = self.get_filters_params()
155         may_have_duplicates = False
156         has_active_filters = False
157 
158         for key, value in lookup_params.items():
159             if not self.model_admin.lookup_allowed(key, value):
160                 raise DisallowedModelAdminLookup("Filtering by %s not allowed" % key)
161 
162         filter_specs = []
163         for list_filter in self.list_filter:
164             lookup_params_count = len(lookup_params)
165             if callable(list_filter):
166                 # This is simply a custom list filter class.
167                 spec = list_filter(request, lookup_params, self.model, self.model_admin)
168             else:
169                 field_path = None
170                 if isinstance(list_filter, (tuple, list)):
171                     # This is a custom FieldListFilter class for a given field.
172                     field, field_list_filter_class = list_filter
173                 else:
174                     # This is simply a field name, so use the default
175                     # FieldListFilter class that has been registered for the
176                     # type of the given field.
177                     field, field_list_filter_class = list_filter, FieldListFilter.create
178                 if not isinstance(field, Field):
179                     field_path = field
180                     field = get_fields_from_path(self.model, field_path)[-1]
181 
182                 spec = field_list_filter_class(
183                     field,
184                     request,
185                     lookup_params,
186                     self.model,
187                     self.model_admin,
188                     field_path=field_path,
189                 )
190                 # field_list_filter_class removes any lookup_params it
191                 # processes. If that happened, check if duplicates should be
192                 # removed.
193                 if lookup_params_count > len(lookup_params):
194                     may_have_duplicates |= lookup_spawns_duplicates(
195                         self.lookup_opts,
196                         field_path,
197                     )
198             if spec and spec.has_output():
199                 filter_specs.append(spec)
200                 if lookup_params_count > len(lookup_params):
201                     has_active_filters = True
202 
203         if self.date_hierarchy:
204             # Create bounded lookup parameters so that the query is more
205             # efficient.
206             year = lookup_params.pop("%s__year" % self.date_hierarchy, None)
207             if year is not None:
208                 month = lookup_params.pop("%s__month" % self.date_hierarchy, None)
209                 day = lookup_params.pop("%s__day" % self.date_hierarchy, None)
210                 try:
211                     from_date = datetime(
212                         int(year),
213                         int(month if month is not None else 1),
214                         int(day if day is not None else 1),
215                     )
216                 except ValueError as e:
217                     raise IncorrectLookupParameters(e) from e
218                 if day:
219                     to_date = from_date + timedelta(days=1)
220                 elif month:
221                     # In this branch, from_date will always be the first of a
222                     # month, so advancing 32 days gives the next month.
223                     to_date = (from_date + timedelta(days=32)).replace(day=1)
224                 else:
225                     to_date = from_date.replace(year=from_date.year + 1)
226                 if settings.USE_TZ:
227                     from_date = make_aware(from_date)
228                     to_date = make_aware(to_date)
229                 lookup_params.update(
230                     {
231                         "%s__gte" % self.date_hierarchy: from_date,
232                         "%s__lt" % self.date_hierarchy: to_date,
233                     }
234                 )
235 
236         # At this point, all the parameters used by the various ListFilters
237         # have been removed from lookup_params, which now only contains other
238         # parameters passed via the query string. We now loop through the
239         # remaining parameters both to ensure that all the parameters are valid
240         # fields and to determine if at least one of them spawns duplicates. If
241         # the lookup parameters aren't real fields, then bail out.
242         try:
243             for key, value in lookup_params.items():
244                 lookup_params[key] = prepare_lookup_value(key, value)
245                 may_have_duplicates |= lookup_spawns_duplicates(self.lookup_opts, key)
246             return (
247                 filter_specs,
248                 bool(filter_specs),
249                 lookup_params,
250                 may_have_duplicates,
251                 has_active_filters,
252             )
253         except FieldDoesNotExist as e:
254             raise IncorrectLookupParameters(e) from e
255 
256     def get_query_string(self, new_params=None, remove=None):
257         if new_params is None:
258             new_params = {}
259         if remove is None:
260             remove = []
261         p = self.params.copy()
262         for r in remove:
263             for k in list(p):
264                 if k.startswith(r):
265                     del p[k]
266         for k, v in new_params.items():
267             if v is None:
268                 if k in p:
269                     del p[k]
270             else:
271                 p[k] = v
272         return "?%s" % urlencode(sorted(p.items()))
273 
274     def get_results(self, request):
275         paginator = self.model_admin.get_paginator(
276             request, self.queryset, self.list_per_page
277         )
278         # Get the number of objects, with admin filters applied.
279         result_count = paginator.count
280 
281         # Get the total number of objects, with no admin filters applied.
282         if self.model_admin.show_full_result_count:
283             full_result_count = self.root_queryset.count()
284         else:
285             full_result_count = None
286         can_show_all = result_count <= self.list_max_show_all
287         multi_page = result_count > self.list_per_page
288 
289         # Get the list of objects to display on this page.
290         if (self.show_all and can_show_all) or not multi_page:
291             result_list = self.queryset._clone()
292         else:
293             try:
294                 result_list = paginator.page(self.page_num).object_list
295             except InvalidPage:
296                 raise IncorrectLookupParameters
297 
298         self.result_count = result_count
299         self.show_full_result_count = self.model_admin.show_full_result_count
300         # Admin actions are shown if there is at least one entry
301         # or if entries are not counted because show_full_result_count is disabled
302         self.show_admin_actions = not self.show_full_result_count or bool(
303             full_result_count
304         )
305         self.full_result_count = full_result_count
306         self.result_list = result_list
307         self.can_show_all = can_show_all
308         self.multi_page = multi_page
309         self.paginator = paginator
310 
311     def _get_default_ordering(self):
312         ordering = []
313         if self.model_admin.ordering:
314             ordering = self.model_admin.ordering
315         elif self.lookup_opts.ordering:
316             ordering = self.lookup_opts.ordering
317         return ordering
318 
319     def get_ordering_field(self, field_name):
320         """
321         Return the proper model field name corresponding to the given
322         field_name to use for ordering. field_name may either be the name of a
323         proper model field or the name of a method (on the admin or model) or a
324         callable with the 'admin_order_field' attribute. Return None if no
325         proper model field name can be matched.
326         """
327         try:
328             field = self.lookup_opts.get_field(field_name)
329             return field.name
330         except FieldDoesNotExist:
331             # See whether field_name is a name of a non-field
332             # that allows sorting.
333             if callable(field_name):
334                 attr = field_name
335             elif hasattr(self.model_admin, field_name):
336                 attr = getattr(self.model_admin, field_name)
337             else:
338                 attr = getattr(self.model, field_name)
339             if isinstance(attr, property) and hasattr(attr, "fget"):
340                 attr = attr.fget
341             return getattr(attr, "admin_order_field", None)
342 
343     def get_ordering(self, request, queryset):
344         """
345         Return the list of ordering fields for the change list.
346         First check the get_ordering() method in model admin, then check
347         the object's default ordering. Then, any manually-specified ordering
348         from the query string overrides anything. Finally, a deterministic
349         order is guaranteed by calling _get_deterministic_ordering() with the
350         constructed ordering.
351         """
352         params = self.params
353         ordering = list(
354             self.model_admin.get_ordering(request) or self._get_default_ordering()
355         )
356         if ORDER_VAR in params:
357             # Clear ordering and used params
358             ordering = []
359             order_params = params[ORDER_VAR].split(".")
360             for p in order_params:
361                 try:
362                     none, pfx, idx = p.rpartition("-")
363                     field_name = self.list_display[int(idx)]
364                     order_field = self.get_ordering_field(field_name)
365                     if not order_field:
366                         continue  # No 'admin_order_field', skip it
367                     if isinstance(order_field, OrderBy):
368                         if pfx == "-":
369                             order_field = order_field.copy()
370                             order_field.reverse_ordering()
371                         ordering.append(order_field)
372                     elif hasattr(order_field, "resolve_expression"):
373                         # order_field is an expression.
374                         ordering.append(
375                             order_field.desc() if pfx == "-" else order_field.asc()
376                         )
377                     # reverse order if order_field has already "-" as prefix
378                     elif pfx == "-" and order_field.startswith(pfx):
379                         ordering.append(order_field.removeprefix(pfx))
380                     else:
381                         ordering.append(pfx + order_field)
382                 except (IndexError, ValueError):
383                     continue  # Invalid ordering specified, skip it.
384 
385         # Add the given query's ordering fields, if any.
386         ordering.extend(queryset.query.order_by)
387 
388         return self._get_deterministic_ordering(ordering)
389 
390     def _get_deterministic_ordering(self, ordering):
391         """
392         Ensure a deterministic order across all database backends. Search for a
393         single field or unique together set of fields providing a total
394         ordering. If these are missing, augment the ordering with a descendant
395         primary key.
396         """
397         ordering = list(ordering)
398         ordering_fields = set()
399         total_ordering_fields = {"pk"} | {
400             field.attname
401             for field in self.lookup_opts.fields
402             if field.unique and not field.null
403         }
404         for part in ordering:
405             # Search for single field providing a total ordering.
406             field_name = None
407             if isinstance(part, str):
408                 field_name = part.lstrip("-")
409             elif isinstance(part, F):
410                 field_name = part.name
411             elif isinstance(part, OrderBy) and isinstance(part.expression, F):
412                 field_name = part.expression.name
413             if field_name:
414                 # Normalize attname references by using get_field().
415                 try:
416                     field = self.lookup_opts.get_field(field_name)
417                 except FieldDoesNotExist:
418                     # Could be "?" for random ordering or a related field
419                     # lookup. Skip this part of introspection for now.
420                     continue
421                 # Ordering by a related field name orders by the referenced
422                 # model's ordering. Skip this part of introspection for now.
423                 if field.remote_field and field_name == field.name:
424                     continue
425                 if field.attname in total_ordering_fields:
426                     break
427                 ordering_fields.add(field.attname)
428         else:
429             # No single total ordering field, try unique_together and total
430             # unique constraints.
431             constraint_field_names = (
432                 *self.lookup_opts.unique_together,
433                 *(
434                     constraint.fields
435                     for constraint in self.lookup_opts.total_unique_constraints
436                 ),
437             )
438             for field_names in constraint_field_names:
439                 # Normalize attname references by using get_field().
440                 fields = [
441                     self.lookup_opts.get_field(field_name) for field_name in field_names
442                 ]
443                 # Composite unique constraints containing a nullable column
444                 # cannot ensure total ordering.
445                 if any(field.null for field in fields):
446                     continue
447                 if ordering_fields.issuperset(field.attname for field in fields):
448                     break
449             else:
450                 # If no set of unique fields is present in the ordering, rely
451                 # on the primary key to provide total ordering.
452                 ordering.append("-pk")
453         return ordering
454 
455     def get_ordering_field_columns(self):
456         """
457         Return a dictionary of ordering field column numbers and asc/desc.
458         """
459         # We must cope with more than one column having the same underlying sort
460         # field, so we base things on column numbers.
461         ordering = self._get_default_ordering()
462         ordering_fields = {}
463         if ORDER_VAR not in self.params:
464             # for ordering specified on ModelAdmin or model Meta, we don't know
465             # the right column numbers absolutely, because there might be more
466             # than one column associated with that ordering, so we guess.
467             for field in ordering:
468                 if isinstance(field, (Combinable, OrderBy)):
469                     if not isinstance(field, OrderBy):
470                         field = field.asc()
471                     if isinstance(field.expression, F):
472                         order_type = "desc" if field.descending else "asc"
473                         field = field.expression.name
474                     else:
475                         continue
476                 elif field.startswith("-"):
477                     field = field.removeprefix("-")
478                     order_type = "desc"
479                 else:
480                     order_type = "asc"
481                 for index, attr in enumerate(self.list_display):
482                     if self.get_ordering_field(attr) == field:
483                         ordering_fields[index] = order_type
484                         break
485         else:
486             for p in self.params[ORDER_VAR].split("."):
487                 none, pfx, idx = p.rpartition("-")
488                 try:
489                     idx = int(idx)
490                 except ValueError:
491                     continue  # skip it
492                 ordering_fields[idx] = "desc" if pfx == "-" else "asc"
493         return ordering_fields
494 
495     def get_queryset(self, request):
496         # First, we collect all the declared list filters.
497         (
498             self.filter_specs,
499             self.has_filters,
500             remaining_lookup_params,
501             filters_may_have_duplicates,
502             self.has_active_filters,
503         ) = self.get_filters(request)
504         # Then, we let every list filter modify the queryset to its liking.
505         qs = self.root_queryset
506         for filter_spec in self.filter_specs:
507             new_qs = filter_spec.queryset(request, qs)
508             if new_qs is not None:
509                 qs = new_qs
510 
511         try:
512             # Finally, we apply the remaining lookup parameters from the query
513             # string (i.e. those that haven't already been processed by the
514             # filters).
515             qs = qs.filter(**remaining_lookup_params)
516         except (SuspiciousOperation, ImproperlyConfigured):
517             # Allow certain types of errors to be re-raised as-is so that the
518             # caller can treat them in a special way.
519             raise
520         except Exception as e:
521             # Every other error is caught with a naked except, because we don't
522             # have any other way of validating lookup parameters. They might be
523             # invalid if the keyword arguments are incorrect, or if the values
524             # are not in the correct type, so we might get FieldError,
525             # ValueError, ValidationError, or ?.
526             raise IncorrectLookupParameters(e)
527 
528         # Apply search results
529         qs, search_may_have_duplicates = self.model_admin.get_search_results(
530             request,
531             qs,
532             self.query,
533         )
534 
535         # Set query string for clearing all filters.
536         self.clear_all_filters_qs = self.get_query_string(
537             new_params=remaining_lookup_params,
538             remove=self.get_filters_params(),
539         )
540         # Remove duplicates from results, if necessary
541         if filters_may_have_duplicates | search_may_have_duplicates:
542             qs = qs.filter(pk=OuterRef("pk"))
543             qs = self.root_queryset.filter(Exists(qs))
544 
545         # Set ordering.
546         ordering = self.get_ordering(request, qs)
547         qs = qs.order_by(*ordering)
548 
549         if not qs.query.select_related:
550             qs = self.apply_select_related(qs)
551 
552         return qs
553 
554     def apply_select_related(self, qs):
555         if self.list_select_related is True:
556             return qs.select_related()
557 
558         if self.list_select_related is False:
559             if self.has_related_field_in_list_display():
560                 return qs.select_related()
561 
562         if self.list_select_related:
563             return qs.select_related(*self.list_select_related)
564         return qs
565 
566     def has_related_field_in_list_display(self):
567         for field_name in self.list_display:
568             try:
569                 field = self.lookup_opts.get_field(field_name)
570             except FieldDoesNotExist:
571                 pass
572             else:
573                 if isinstance(field.remote_field, ManyToOneRel):
574                     # <FK>_id field names don't require a join.
575                     if field_name != field.get_attname():
576                         return True
577         return False
578 
579     def url_for_result(self, result):
580         pk = getattr(result, self.pk_attname)
581         return reverse(
582             "admin:%s_%s_change" % (self.opts.app_label, self.opts.model_name),
583             args=(quote(pk),),
584             current_app=self.model_admin.admin_site.name,
585         )

</code><intended_behavior>Implementing or enhancing a get_queryset method (or similar) specifically for filtering LogEntry instances based on the admin site. This could involve adding new mechanisms or utilities that customize LogEntry queryset fetching to include consideration of AdminSite context, likely utilizing indirect identification or tagging mechanisms as mentioned earlier.</intended_behavior>]
2025-10-18 13:30:44.348 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-18 13:30:44.348 | INFO     | Search-only: skipping patch selection
2025-10-18 13:30:44.512 | INFO     | Task django__django-16514 completed successfully.
2025-10-18 13:30:44.512 | INFO     | No patch generated. You can try running ACR again.
