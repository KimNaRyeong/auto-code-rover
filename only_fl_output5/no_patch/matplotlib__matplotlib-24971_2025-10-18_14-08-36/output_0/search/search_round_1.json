[
    {
        "role": "system",
        "content": "You are a software developer maintaining a large project.\nYou are working on an issue submitted to your project.\nThe issue contains a description marked between <issue> and </issue>.\nYour task is to invoke a few search API calls to gather sufficient code context for resolving the issue.\nThe collected context will later be sent to your colleage for writing a patch.\nDo not worry about test files or writing test; you are only interested in crafting a patch.\n"
    },
    {
        "role": "user",
        "content": "<issue>[Bug]: compressed layout setting can be forgotten on second save\n### Bug summary\nI'm not sure whether this is really a bug or I'm just using an inconsistent combination of options.  Under some specific circumstances (see below) compressed layout is not applied the second time a figure is saved.\n### Code for reproduction\n```python\nimport matplotlib\nimport matplotlib.pyplot as plt\nimport numpy as np\narr = np.arange(100).reshape((10, 10))\nmatplotlib.rcParams['figure.constrained_layout.use'] = True\nfig, ax_dict = plt.subplot_mosaic('AB;AC', figsize=(6, 9), width_ratios=[3, 2],\nlayout='compressed')\nfor key in [\"B\", \"C\"]:\nax_dict[key].imshow(arr)\nfig.savefig(\"test1.png\", bbox_inches=\"tight\")\nfig.savefig(\"test2.png\", bbox_inches=\"tight\")\n```\n### Actual outcome\ntest1.png\n![test1](https://user-images.githubusercontent.com/10599679/212073531-4841d847-29a5-45a4-aaa1-1d3b81277ddc.png)\ntest2.png\n![test2](https://user-images.githubusercontent.com/10599679/212073574-f6286243-690d-4199-b6f4-4033e5d14635.png)\n### Expected outcome\nBoth images should look like the first.\n### Additional information\nIf I do not set the `rcParams`, all is well.  If I do not set `bbox_inches=\"tight\"` in my calls to `savefig`, the images are identical (but I have too much white space top and bottom).  Maybe there is a better option than `bbox_inches=\"tight\"` when using compressed layout?\nFor context, my real example is a script that makes several figures.  For most of them I want constrained layout, so I set that once in the `rcParams` for convenience.  Only one figure needs \"compressed\", and I am saving twice because I want both a png and a pdf.  Fixed it in my current example by just reverting the `rcParams` setting for the one figure.\n### Operating system\nRHEL7\n### Matplotlib Version\n3.6.2 and main\n### Matplotlib Backend\nQtAgg\n### Python version\n3.9 and 3.11\n### Jupyter version\n_No response_\n### Installation\nconda\n</issue>"
    },
    {
        "role": "user",
        "content": "Based on the files, classes, methods, and code statements from the issue related to the bug, you can use the following search APIs to get more context of the project.\n- search_class(class_name: str): Search for a class in the codebase.\n- search_class_in_file(self, class_name, file_name: str): Search for a class in a given file.\n- search_method_in_file(method_name: str, file_path: str): Search for a method in a given file..\n- search_method_in_class(method_name: str, class_name: str): Search for a method in a given class.\n- search_method(method_name: str): Search for a method in the entire codebase.\n- search_code(code_str: str): Search for a code snippet in the entire codebase.\n- search_code_in_file(code_str: str, file_path: str): Search for a code snippet in a given file file.\n- get_code_around_line(file_path: str, line_number: int, window_size: int): Get the code around a given line number in a file. window_size is the number of lines before and after the line number.\n\nYou must give correct number of arguments when invoking API calls.\n\nNote that you can use multiple search APIs in one round.\n\nNow analyze the issue and select necessary APIs to get more context of the project. Each API call must have concrete arguments as inputs."
    },
    {
        "role": "assistant",
        "content": "To address the issue described, we'll need to gather more context on several aspects of the Matplotlib codebase related to how figures are saved, especially in the context of using `bbox_inches=\"tight\"` and setting the figure layout to \"compressed\" via `subplot_mosaic`. Here are the API calls we need to make:\n\n1. Check how `subplot_mosaic` is implemented since it's directly involved in arranging the subplots and might handle the \"compressed\" layout.\n2. Look into the implementation of `savefig` to understand how it processes `bbox_inches=\"tight\"` and if it changes any layout settings.\n3. Investigate how `rcParams` are applied and if changing them directly might cause issues with repeated save operations.\n\nBased on this, here are the specific API calls:\n\n- `search_method(\"subplot_mosaic\")`: To get insight into how `subplot_mosaic` method works and how it handles the \"compressed\" layout.\n- `search_method(\"savefig\")`: To understand how the `savefig` function behaves, especially with `bbox_inches=\"tight\"` parameter and within the context of saving figures multiple times with layout constraints.\n- `search_code(\"rcParams['figure.constrained_layout.use'] = True\")`: To find out where and how `rcParams` are being modified in the codebase, possibly affecting layout behavior between saves."
    },
    {
        "role": "user",
        "content": "Result of search_method(\"subplot_mosaic\"):\n\nFound 3 methods with name subplot_mosaic in the codebase:\n\n- Search result 1:\n```\n<file>lib/matplotlib/figure.py</file>\n <func>subplot_mosaic</func>\n<code>\n1791     def subplot_mosaic(self, mosaic, *, sharex=False, sharey=False,\n1792                        width_ratios=None, height_ratios=None,\n1793                        empty_sentinel='.',\n1794                        subplot_kw=None, per_subplot_kw=None, gridspec_kw=None):\n1795         \"\"\"\n1796         Build a layout of Axes based on ASCII art or nested lists.\n1797 \n1798         This is a helper function to build complex GridSpec layouts visually.\n1799 \n1800         See :doc:`/gallery/subplots_axes_and_figures/mosaic`\n1801         for an example and full API documentation\n1802 \n1803         Parameters\n1804         ----------\n1805         mosaic : list of list of {hashable or nested} or str\n1806 \n1807             A visual layout of how you want your Axes to be arranged\n1808             labeled as strings.  For example ::\n1809 \n1810                x = [['A panel', 'A panel', 'edge'],\n1811                     ['C panel', '.',       'edge']]\n1812 \n1813             produces 4 Axes:\n1814 \n1815             - 'A panel' which is 1 row high and spans the first two columns\n1816             - 'edge' which is 2 rows high and is on the right edge\n1817             - 'C panel' which in 1 row and 1 column wide in the bottom left\n1818             - a blank space 1 row and 1 column wide in the bottom center\n1819 \n1820             Any of the entries in the layout can be a list of lists\n1821             of the same form to create nested layouts.\n1822 \n1823             If input is a str, then it can either be a multi-line string of\n1824             the form ::\n1825 \n1826               '''\n1827               AAE\n1828               C.E\n1829               '''\n1830 \n1831             where each character is a column and each line is a row. Or it\n1832             can be a single-line string where rows are separated by ``;``::\n1833 \n1834               'AB;CC'\n1835 \n1836             The string notation allows only single character Axes labels and\n1837             does not support nesting but is very terse.\n1838 \n1839             The Axes identifiers may be `str` or a non-iterable hashable\n1840             object (e.g. `tuple` s may not be used).\n1841 \n1842         sharex, sharey : bool, default: False\n1843             If True, the x-axis (*sharex*) or y-axis (*sharey*) will be shared\n1844             among all subplots.  In that case, tick label visibility and axis\n1845             units behave as for `subplots`.  If False, each subplot's x- or\n1846             y-axis will be independent.\n1847 \n1848         width_ratios : array-like of length *ncols*, optional\n1849             Defines the relative widths of the columns. Each column gets a\n1850             relative width of ``width_ratios[i] / sum(width_ratios)``.\n1851             If not given, all columns will have the same width.  Equivalent\n1852             to ``gridspec_kw={'width_ratios': [...]}``. In the case of nested\n1853             layouts, this argument applies only to the outer layout.\n1854 \n1855         height_ratios : array-like of length *nrows*, optional\n1856             Defines the relative heights of the rows. Each row gets a\n1857             relative height of ``height_ratios[i] / sum(height_ratios)``.\n1858             If not given, all rows will have the same height. Equivalent\n1859             to ``gridspec_kw={'height_ratios': [...]}``. In the case of nested\n1860             layouts, this argument applies only to the outer layout.\n1861 \n1862         subplot_kw : dict, optional\n1863             Dictionary with keywords passed to the `.Figure.add_subplot` call\n1864             used to create each subplot.  These values may be overridden by\n1865             values in *per_subplot_kw*.\n1866 \n1867         per_subplot_kw : dict, optional\n1868             A dictionary mapping the Axes identifiers or tuples of identifiers\n1869             to a dictionary of keyword arguments to be passed to the\n1870             `.Figure.add_subplot` call used to create each subplot.  The values\n1871             in these dictionaries have precedence over the values in\n1872             *subplot_kw*.\n1873 \n1874             If *mosaic* is a string, and thus all keys are single characters,\n1875             it is possible to use a single string instead of a tuple as keys;\n1876             i.e. ``\"AB\"`` is equivalent to ``(\"A\", \"B\")``.\n1877 \n1878             .. versionadded:: 3.7\n1879 \n1880         gridspec_kw : dict, optional\n1881             Dictionary with keywords passed to the `.GridSpec` constructor used\n1882             to create the grid the subplots are placed on. In the case of\n1883             nested layouts, this argument applies only to the outer layout.\n1884             For more complex layouts, users should use `.Figure.subfigures`\n1885             to create the nesting.\n1886 \n1887         empty_sentinel : object, optional\n1888             Entry in the layout to mean \"leave this space empty\".  Defaults\n1889             to ``'.'``. Note, if *layout* is a string, it is processed via\n1890             `inspect.cleandoc` to remove leading white space, which may\n1891             interfere with using white-space as the empty sentinel.\n1892 \n1893         Returns\n1894         -------\n1895         dict[label, Axes]\n1896            A dictionary mapping the labels to the Axes objects.  The order of\n1897            the axes is left-to-right and top-to-bottom of their position in the\n1898            total layout.\n1899 \n1900         \"\"\"\n1901         subplot_kw = subplot_kw or {}\n1902         gridspec_kw = dict(gridspec_kw or {})\n1903         per_subplot_kw = per_subplot_kw or {}\n1904 \n1905         if height_ratios is not None:\n1906             if 'height_ratios' in gridspec_kw:\n1907                 raise ValueError(\"'height_ratios' must not be defined both as \"\n1908                                  \"parameter and as key in 'gridspec_kw'\")\n1909             gridspec_kw['height_ratios'] = height_ratios\n1910         if width_ratios is not None:\n1911             if 'width_ratios' in gridspec_kw:\n1912                 raise ValueError(\"'width_ratios' must not be defined both as \"\n1913                                  \"parameter and as key in 'gridspec_kw'\")\n1914             gridspec_kw['width_ratios'] = width_ratios\n1915 \n1916         # special-case string input\n1917         if isinstance(mosaic, str):\n1918             mosaic = self._normalize_grid_string(mosaic)\n1919             per_subplot_kw = {\n1920                 tuple(k): v for k, v in per_subplot_kw.items()\n1921             }\n1922 \n1923         per_subplot_kw = self._norm_per_subplot_kw(per_subplot_kw)\n1924 \n1925         # Only accept strict bools to allow a possible future API expansion.\n1926         _api.check_isinstance(bool, sharex=sharex, sharey=sharey)\n1927 \n1928         def _make_array(inp):\n1929             \"\"\"\n1930             Convert input into 2D array\n1931 \n1932             We need to have this internal function rather than\n1933             ``np.asarray(..., dtype=object)`` so that a list of lists\n1934             of lists does not get converted to an array of dimension >\n1935             2\n1936 \n1937             Returns\n1938             -------\n1939             2D object array\n1940 \n1941             \"\"\"\n1942             r0, *rest = inp\n1943             if isinstance(r0, str):\n1944                 raise ValueError('List mosaic specification must be 2D')\n1945             for j, r in enumerate(rest, start=1):\n1946                 if isinstance(r, str):\n1947                     raise ValueError('List mosaic specification must be 2D')\n1948                 if len(r0) != len(r):\n1949                     raise ValueError(\n1950                         \"All of the rows must be the same length, however \"\n1951                         f\"the first row ({r0!r}) has length {len(r0)} \"\n1952                         f\"and row {j} ({r!r}) has length {len(r)}.\"\n1953                     )\n1954             out = np.zeros((len(inp), len(r0)), dtype=object)\n1955             for j, r in enumerate(inp):\n1956                 for k, v in enumerate(r):\n1957                     out[j, k] = v\n1958             return out\n1959 \n1960         def _identify_keys_and_nested(mosaic):\n1961             \"\"\"\n1962             Given a 2D object array, identify unique IDs and nested mosaics\n1963 \n1964             Parameters\n1965             ----------\n1966             mosaic : 2D numpy object array\n1967 \n1968             Returns\n1969             -------\n1970             unique_ids : tuple\n1971                 The unique non-sub mosaic entries in this mosaic\n1972             nested : dict[tuple[int, int]], 2D object array\n1973             \"\"\"\n1974             # make sure we preserve the user supplied order\n1975             unique_ids = cbook._OrderedSet()\n1976             nested = {}\n1977             for j, row in enumerate(mosaic):\n1978                 for k, v in enumerate(row):\n1979                     if v == empty_sentinel:\n1980                         continue\n1981                     elif not cbook.is_scalar_or_string(v):\n1982                         nested[(j, k)] = _make_array(v)\n1983                     else:\n1984                         unique_ids.add(v)\n1985 \n1986             return tuple(unique_ids), nested\n1987 \n1988         def _do_layout(gs, mosaic, unique_ids, nested):\n1989             \"\"\"\n1990             Recursively do the mosaic.\n1991 \n1992             Parameters\n1993             ----------\n1994             gs : GridSpec\n1995             mosaic : 2D object array\n1996                 The input converted to a 2D numpy array for this level.\n1997             unique_ids : tuple\n1998                 The identified scalar labels at this level of nesting.\n1999             nested : dict[tuple[int, int]], 2D object array\n2000                 The identified nested mosaics, if any.\n2001 \n2002             Returns\n2003             -------\n2004             dict[label, Axes]\n2005                 A flat dict of all of the Axes created.\n2006             \"\"\"\n2007             output = dict()\n2008 \n2009             # we need to merge together the Axes at this level and the axes\n2010             # in the (recursively) nested sub-mosaics so that we can add\n2011             # them to the figure in the \"natural\" order if you were to\n2012             # ravel in c-order all of the Axes that will be created\n2013             #\n2014             # This will stash the upper left index of each object (axes or\n2015             # nested mosaic) at this level\n2016             this_level = dict()\n2017 \n2018             # go through the unique keys,\n2019             for name in unique_ids:\n2020                 # sort out where each axes starts/ends\n2021                 indx = np.argwhere(mosaic == name)\n2022                 start_row, start_col = np.min(indx, axis=0)\n2023                 end_row, end_col = np.max(indx, axis=0) + 1\n2024                 # and construct the slice object\n2025                 slc = (slice(start_row, end_row), slice(start_col, end_col))\n2026                 # some light error checking\n2027                 if (mosaic[slc] != name).any():\n2028                     raise ValueError(\n2029                         f\"While trying to layout\\n{mosaic!r}\\n\"\n2030                         f\"we found that the label {name!r} specifies a \"\n2031                         \"non-rectangular or non-contiguous area.\")\n2032                 # and stash this slice for later\n2033                 this_level[(start_row, start_col)] = (name, slc, 'axes')\n2034 \n2035             # do the same thing for the nested mosaics (simpler because these\n2036             # can not be spans yet!)\n2037             for (j, k), nested_mosaic in nested.items():\n2038                 this_level[(j, k)] = (None, nested_mosaic, 'nested')\n2039 \n2040             # now go through the things in this level and add them\n2041             # in order left-to-right top-to-bottom\n2042             for key in sorted(this_level):\n2043                 name, arg, method = this_level[key]\n2044                 # we are doing some hokey function dispatch here based\n2045                 # on the 'method' string stashed above to sort out if this\n2046                 # element is an Axes or a nested mosaic.\n2047                 if method == 'axes':\n2048                     slc = arg\n2049                     # add a single axes\n2050                     if name in output:\n2051                         raise ValueError(f\"There are duplicate keys {name} \"\n2052                                          f\"in the layout\\n{mosaic!r}\")\n2053                     ax = self.add_subplot(\n2054                         gs[slc], **{\n2055                             'label': str(name),\n2056                             **subplot_kw,\n2057                             **per_subplot_kw.get(name, {})\n2058                         }\n2059                     )\n2060                     output[name] = ax\n2061                 elif method == 'nested':\n2062                     nested_mosaic = arg\n2063                     j, k = key\n2064                     # recursively add the nested mosaic\n2065                     rows, cols = nested_mosaic.shape\n2066                     nested_output = _do_layout(\n2067                         gs[j, k].subgridspec(rows, cols),\n2068                         nested_mosaic,\n2069                         *_identify_keys_and_nested(nested_mosaic)\n2070                     )\n2071                     overlap = set(output) & set(nested_output)\n2072                     if overlap:\n2073                         raise ValueError(\n2074                             f\"There are duplicate keys {overlap} \"\n2075                             f\"between the outer layout\\n{mosaic!r}\\n\"\n2076                             f\"and the nested layout\\n{nested_mosaic}\"\n2077                         )\n2078                     output.update(nested_output)\n2079                 else:\n2080                     raise RuntimeError(\"This should never happen\")\n2081             return output\n2082 \n2083         mosaic = _make_array(mosaic)\n2084         rows, cols = mosaic.shape\n2085         gs = self.add_gridspec(rows, cols, **gridspec_kw)\n2086         ret = _do_layout(gs, mosaic, *_identify_keys_and_nested(mosaic))\n2087         ax0 = next(iter(ret.values()))\n2088         for ax in ret.values():\n2089             if sharex:\n2090                 ax.sharex(ax0)\n2091                 ax._label_outer_xaxis(check_patch=True)\n2092             if sharey:\n2093                 ax.sharey(ax0)\n2094                 ax._label_outer_yaxis(check_patch=True)\n2095         if extra := set(per_subplot_kw) - set(ret):\n2096             raise ValueError(\n2097                 f\"The keys {extra} are in *per_subplot_kw* \"\n2098                 \"but not in the mosaic.\"\n2099             )\n2100         return ret\n\n</code>\n```\n- Search result 2:\n```\n<file>lib/matplotlib/pyplot.py</file>\n <func>subplot_mosaic</func>\n<code>\n1482 def subplot_mosaic(mosaic, *, sharex=False, sharey=False,\n1483                    width_ratios=None, height_ratios=None, empty_sentinel='.',\n1484                    subplot_kw=None, gridspec_kw=None,\n1485                    per_subplot_kw=None, **fig_kw):\n1486     \"\"\"\n1487     Build a layout of Axes based on ASCII art or nested lists.\n1488 \n1489     This is a helper function to build complex GridSpec layouts visually.\n1490 \n1491     See :doc:`/gallery/subplots_axes_and_figures/mosaic`\n1492     for an example and full API documentation\n1493 \n1494     Parameters\n1495     ----------\n1496     mosaic : list of list of {hashable or nested} or str\n1497 \n1498         A visual layout of how you want your Axes to be arranged\n1499         labeled as strings.  For example ::\n1500 \n1501            x = [['A panel', 'A panel', 'edge'],\n1502                 ['C panel', '.',       'edge']]\n1503 \n1504         produces 4 axes:\n1505 \n1506         - 'A panel' which is 1 row high and spans the first two columns\n1507         - 'edge' which is 2 rows high and is on the right edge\n1508         - 'C panel' which in 1 row and 1 column wide in the bottom left\n1509         - a blank space 1 row and 1 column wide in the bottom center\n1510 \n1511         Any of the entries in the layout can be a list of lists\n1512         of the same form to create nested layouts.\n1513 \n1514         If input is a str, then it must be of the form ::\n1515 \n1516           '''\n1517           AAE\n1518           C.E\n1519           '''\n1520 \n1521         where each character is a column and each line is a row.\n1522         This only allows only single character Axes labels and does\n1523         not allow nesting but is very terse.\n1524 \n1525     sharex, sharey : bool, default: False\n1526         If True, the x-axis (*sharex*) or y-axis (*sharey*) will be shared\n1527         among all subplots.  In that case, tick label visibility and axis units\n1528         behave as for `subplots`.  If False, each subplot's x- or y-axis will\n1529         be independent.\n1530 \n1531     width_ratios : array-like of length *ncols*, optional\n1532         Defines the relative widths of the columns. Each column gets a\n1533         relative width of ``width_ratios[i] / sum(width_ratios)``.\n1534         If not given, all columns will have the same width.  Convenience\n1535         for ``gridspec_kw={'width_ratios': [...]}``.\n1536 \n1537     height_ratios : array-like of length *nrows*, optional\n1538         Defines the relative heights of the rows. Each row gets a\n1539         relative height of ``height_ratios[i] / sum(height_ratios)``.\n1540         If not given, all rows will have the same height. Convenience\n1541         for ``gridspec_kw={'height_ratios': [...]}``.\n1542 \n1543     empty_sentinel : object, optional\n1544         Entry in the layout to mean \"leave this space empty\".  Defaults\n1545         to ``'.'``. Note, if *layout* is a string, it is processed via\n1546         `inspect.cleandoc` to remove leading white space, which may\n1547         interfere with using white-space as the empty sentinel.\n1548 \n1549     subplot_kw : dict, optional\n1550         Dictionary with keywords passed to the `.Figure.add_subplot` call\n1551         used to create each subplot.  These values may be overridden by\n1552         values in *per_subplot_kw*.\n1553 \n1554     per_subplot_kw : dict, optional\n1555         A dictionary mapping the Axes identifiers or tuples of identifiers\n1556         to a dictionary of keyword arguments to be passed to the\n1557         `.Figure.add_subplot` call used to create each subplot.  The values\n1558         in these dictionaries have precedence over the values in\n1559         *subplot_kw*.\n1560 \n1561         If *mosaic* is a string, and thus all keys are single characters,\n1562         it is possible to use a single string instead of a tuple as keys;\n1563         i.e. ``\"AB\"`` is equivalent to ``(\"A\", \"B\")``.\n1564 \n1565         .. versionadded:: 3.7\n1566 \n1567     gridspec_kw : dict, optional\n1568         Dictionary with keywords passed to the `.GridSpec` constructor used\n1569         to create the grid the subplots are placed on.\n1570 \n1571     **fig_kw\n1572         All additional keyword arguments are passed to the\n1573         `.pyplot.figure` call.\n1574 \n1575     Returns\n1576     -------\n1577     fig : `.Figure`\n1578        The new figure\n1579 \n1580     dict[label, Axes]\n1581        A dictionary mapping the labels to the Axes objects.  The order of\n1582        the axes is left-to-right and top-to-bottom of their position in the\n1583        total layout.\n1584 \n1585     \"\"\"\n1586     fig = figure(**fig_kw)\n1587     ax_dict = fig.subplot_mosaic(\n1588         mosaic, sharex=sharex, sharey=sharey,\n1589         height_ratios=height_ratios, width_ratios=width_ratios,\n1590         subplot_kw=subplot_kw, gridspec_kw=gridspec_kw,\n1591         empty_sentinel=empty_sentinel,\n1592         per_subplot_kw=per_subplot_kw,\n1593     )\n1594     return fig, ax_dict\n\n</code>\n```\n- Search result 3:\n```\n<file>lib/matplotlib/figure.py</file>\n<class>FigureBase</class> <func>subplot_mosaic</func>\n<code>\n1791     def subplot_mosaic(self, mosaic, *, sharex=False, sharey=False,\n1792                        width_ratios=None, height_ratios=None,\n1793                        empty_sentinel='.',\n1794                        subplot_kw=None, per_subplot_kw=None, gridspec_kw=None):\n1795         \"\"\"\n1796         Build a layout of Axes based on ASCII art or nested lists.\n1797 \n1798         This is a helper function to build complex GridSpec layouts visually.\n1799 \n1800         See :doc:`/gallery/subplots_axes_and_figures/mosaic`\n1801         for an example and full API documentation\n1802 \n1803         Parameters\n1804         ----------\n1805         mosaic : list of list of {hashable or nested} or str\n1806 \n1807             A visual layout of how you want your Axes to be arranged\n1808             labeled as strings.  For example ::\n1809 \n1810                x = [['A panel', 'A panel', 'edge'],\n1811                     ['C panel', '.',       'edge']]\n1812 \n1813             produces 4 Axes:\n1814 \n1815             - 'A panel' which is 1 row high and spans the first two columns\n1816             - 'edge' which is 2 rows high and is on the right edge\n1817             - 'C panel' which in 1 row and 1 column wide in the bottom left\n1818             - a blank space 1 row and 1 column wide in the bottom center\n1819 \n1820             Any of the entries in the layout can be a list of lists\n1821             of the same form to create nested layouts.\n1822 \n1823             If input is a str, then it can either be a multi-line string of\n1824             the form ::\n1825 \n1826               '''\n1827               AAE\n1828               C.E\n1829               '''\n1830 \n1831             where each character is a column and each line is a row. Or it\n1832             can be a single-line string where rows are separated by ``;``::\n1833 \n1834               'AB;CC'\n1835 \n1836             The string notation allows only single character Axes labels and\n1837             does not support nesting but is very terse.\n1838 \n1839             The Axes identifiers may be `str` or a non-iterable hashable\n1840             object (e.g. `tuple` s may not be used).\n1841 \n1842         sharex, sharey : bool, default: False\n1843             If True, the x-axis (*sharex*) or y-axis (*sharey*) will be shared\n1844             among all subplots.  In that case, tick label visibility and axis\n1845             units behave as for `subplots`.  If False, each subplot's x- or\n1846             y-axis will be independent.\n1847 \n1848         width_ratios : array-like of length *ncols*, optional\n1849             Defines the relative widths of the columns. Each column gets a\n1850             relative width of ``width_ratios[i] / sum(width_ratios)``.\n1851             If not given, all columns will have the same width.  Equivalent\n1852             to ``gridspec_kw={'width_ratios': [...]}``. In the case of nested\n1853             layouts, this argument applies only to the outer layout.\n1854 \n1855         height_ratios : array-like of length *nrows*, optional\n1856             Defines the relative heights of the rows. Each row gets a\n1857             relative height of ``height_ratios[i] / sum(height_ratios)``.\n1858             If not given, all rows will have the same height. Equivalent\n1859             to ``gridspec_kw={'height_ratios': [...]}``. In the case of nested\n1860             layouts, this argument applies only to the outer layout.\n1861 \n1862         subplot_kw : dict, optional\n1863             Dictionary with keywords passed to the `.Figure.add_subplot` call\n1864             used to create each subplot.  These values may be overridden by\n1865             values in *per_subplot_kw*.\n1866 \n1867         per_subplot_kw : dict, optional\n1868             A dictionary mapping the Axes identifiers or tuples of identifiers\n1869             to a dictionary of keyword arguments to be passed to the\n1870             `.Figure.add_subplot` call used to create each subplot.  The values\n1871             in these dictionaries have precedence over the values in\n1872             *subplot_kw*.\n1873 \n1874             If *mosaic* is a string, and thus all keys are single characters,\n1875             it is possible to use a single string instead of a tuple as keys;\n1876             i.e. ``\"AB\"`` is equivalent to ``(\"A\", \"B\")``.\n1877 \n1878             .. versionadded:: 3.7\n1879 \n1880         gridspec_kw : dict, optional\n1881             Dictionary with keywords passed to the `.GridSpec` constructor used\n1882             to create the grid the subplots are placed on. In the case of\n1883             nested layouts, this argument applies only to the outer layout.\n1884             For more complex layouts, users should use `.Figure.subfigures`\n1885             to create the nesting.\n1886 \n1887         empty_sentinel : object, optional\n1888             Entry in the layout to mean \"leave this space empty\".  Defaults\n1889             to ``'.'``. Note, if *layout* is a string, it is processed via\n1890             `inspect.cleandoc` to remove leading white space, which may\n1891             interfere with using white-space as the empty sentinel.\n1892 \n1893         Returns\n1894         -------\n1895         dict[label, Axes]\n1896            A dictionary mapping the labels to the Axes objects.  The order of\n1897            the axes is left-to-right and top-to-bottom of their position in the\n1898            total layout.\n1899 \n1900         \"\"\"\n1901         subplot_kw = subplot_kw or {}\n1902         gridspec_kw = dict(gridspec_kw or {})\n1903         per_subplot_kw = per_subplot_kw or {}\n1904 \n1905         if height_ratios is not None:\n1906             if 'height_ratios' in gridspec_kw:\n1907                 raise ValueError(\"'height_ratios' must not be defined both as \"\n1908                                  \"parameter and as key in 'gridspec_kw'\")\n1909             gridspec_kw['height_ratios'] = height_ratios\n1910         if width_ratios is not None:\n1911             if 'width_ratios' in gridspec_kw:\n1912                 raise ValueError(\"'width_ratios' must not be defined both as \"\n1913                                  \"parameter and as key in 'gridspec_kw'\")\n1914             gridspec_kw['width_ratios'] = width_ratios\n1915 \n1916         # special-case string input\n1917         if isinstance(mosaic, str):\n1918             mosaic = self._normalize_grid_string(mosaic)\n1919             per_subplot_kw = {\n1920                 tuple(k): v for k, v in per_subplot_kw.items()\n1921             }\n1922 \n1923         per_subplot_kw = self._norm_per_subplot_kw(per_subplot_kw)\n1924 \n1925         # Only accept strict bools to allow a possible future API expansion.\n1926         _api.check_isinstance(bool, sharex=sharex, sharey=sharey)\n1927 \n1928         def _make_array(inp):\n1929             \"\"\"\n1930             Convert input into 2D array\n1931 \n1932             We need to have this internal function rather than\n1933             ``np.asarray(..., dtype=object)`` so that a list of lists\n1934             of lists does not get converted to an array of dimension >\n1935             2\n1936 \n1937             Returns\n1938             -------\n1939             2D object array\n1940 \n1941             \"\"\"\n1942             r0, *rest = inp\n1943             if isinstance(r0, str):\n1944                 raise ValueError('List mosaic specification must be 2D')\n1945             for j, r in enumerate(rest, start=1):\n1946                 if isinstance(r, str):\n1947                     raise ValueError('List mosaic specification must be 2D')\n1948                 if len(r0) != len(r):\n1949                     raise ValueError(\n1950                         \"All of the rows must be the same length, however \"\n1951                         f\"the first row ({r0!r}) has length {len(r0)} \"\n1952                         f\"and row {j} ({r!r}) has length {len(r)}.\"\n1953                     )\n1954             out = np.zeros((len(inp), len(r0)), dtype=object)\n1955             for j, r in enumerate(inp):\n1956                 for k, v in enumerate(r):\n1957                     out[j, k] = v\n1958             return out\n1959 \n1960         def _identify_keys_and_nested(mosaic):\n1961             \"\"\"\n1962             Given a 2D object array, identify unique IDs and nested mosaics\n1963 \n1964             Parameters\n1965             ----------\n1966             mosaic : 2D numpy object array\n1967 \n1968             Returns\n1969             -------\n1970             unique_ids : tuple\n1971                 The unique non-sub mosaic entries in this mosaic\n1972             nested : dict[tuple[int, int]], 2D object array\n1973             \"\"\"\n1974             # make sure we preserve the user supplied order\n1975             unique_ids = cbook._OrderedSet()\n1976             nested = {}\n1977             for j, row in enumerate(mosaic):\n1978                 for k, v in enumerate(row):\n1979                     if v == empty_sentinel:\n1980                         continue\n1981                     elif not cbook.is_scalar_or_string(v):\n1982                         nested[(j, k)] = _make_array(v)\n1983                     else:\n1984                         unique_ids.add(v)\n1985 \n1986             return tuple(unique_ids), nested\n1987 \n1988         def _do_layout(gs, mosaic, unique_ids, nested):\n1989             \"\"\"\n1990             Recursively do the mosaic.\n1991 \n1992             Parameters\n1993             ----------\n1994             gs : GridSpec\n1995             mosaic : 2D object array\n1996                 The input converted to a 2D numpy array for this level.\n1997             unique_ids : tuple\n1998                 The identified scalar labels at this level of nesting.\n1999             nested : dict[tuple[int, int]], 2D object array\n2000                 The identified nested mosaics, if any.\n2001 \n2002             Returns\n2003             -------\n2004             dict[label, Axes]\n2005                 A flat dict of all of the Axes created.\n2006             \"\"\"\n2007             output = dict()\n2008 \n2009             # we need to merge together the Axes at this level and the axes\n2010             # in the (recursively) nested sub-mosaics so that we can add\n2011             # them to the figure in the \"natural\" order if you were to\n2012             # ravel in c-order all of the Axes that will be created\n2013             #\n2014             # This will stash the upper left index of each object (axes or\n2015             # nested mosaic) at this level\n2016             this_level = dict()\n2017 \n2018             # go through the unique keys,\n2019             for name in unique_ids:\n2020                 # sort out where each axes starts/ends\n2021                 indx = np.argwhere(mosaic == name)\n2022                 start_row, start_col = np.min(indx, axis=0)\n2023                 end_row, end_col = np.max(indx, axis=0) + 1\n2024                 # and construct the slice object\n2025                 slc = (slice(start_row, end_row), slice(start_col, end_col))\n2026                 # some light error checking\n2027                 if (mosaic[slc] != name).any():\n2028                     raise ValueError(\n2029                         f\"While trying to layout\\n{mosaic!r}\\n\"\n2030                         f\"we found that the label {name!r} specifies a \"\n2031                         \"non-rectangular or non-contiguous area.\")\n2032                 # and stash this slice for later\n2033                 this_level[(start_row, start_col)] = (name, slc, 'axes')\n2034 \n2035             # do the same thing for the nested mosaics (simpler because these\n2036             # can not be spans yet!)\n2037             for (j, k), nested_mosaic in nested.items():\n2038                 this_level[(j, k)] = (None, nested_mosaic, 'nested')\n2039 \n2040             # now go through the things in this level and add them\n2041             # in order left-to-right top-to-bottom\n2042             for key in sorted(this_level):\n2043                 name, arg, method = this_level[key]\n2044                 # we are doing some hokey function dispatch here based\n2045                 # on the 'method' string stashed above to sort out if this\n2046                 # element is an Axes or a nested mosaic.\n2047                 if method == 'axes':\n2048                     slc = arg\n2049                     # add a single axes\n2050                     if name in output:\n2051                         raise ValueError(f\"There are duplicate keys {name} \"\n2052                                          f\"in the layout\\n{mosaic!r}\")\n2053                     ax = self.add_subplot(\n2054                         gs[slc], **{\n2055                             'label': str(name),\n2056                             **subplot_kw,\n2057                             **per_subplot_kw.get(name, {})\n2058                         }\n2059                     )\n2060                     output[name] = ax\n2061                 elif method == 'nested':\n2062                     nested_mosaic = arg\n2063                     j, k = key\n2064                     # recursively add the nested mosaic\n2065                     rows, cols = nested_mosaic.shape\n2066                     nested_output = _do_layout(\n2067                         gs[j, k].subgridspec(rows, cols),\n2068                         nested_mosaic,\n2069                         *_identify_keys_and_nested(nested_mosaic)\n2070                     )\n2071                     overlap = set(output) & set(nested_output)\n2072                     if overlap:\n2073                         raise ValueError(\n2074                             f\"There are duplicate keys {overlap} \"\n2075                             f\"between the outer layout\\n{mosaic!r}\\n\"\n2076                             f\"and the nested layout\\n{nested_mosaic}\"\n2077                         )\n2078                     output.update(nested_output)\n2079                 else:\n2080                     raise RuntimeError(\"This should never happen\")\n2081             return output\n2082 \n2083         mosaic = _make_array(mosaic)\n2084         rows, cols = mosaic.shape\n2085         gs = self.add_gridspec(rows, cols, **gridspec_kw)\n2086         ret = _do_layout(gs, mosaic, *_identify_keys_and_nested(mosaic))\n2087         ax0 = next(iter(ret.values()))\n2088         for ax in ret.values():\n2089             if sharex:\n2090                 ax.sharex(ax0)\n2091                 ax._label_outer_xaxis(check_patch=True)\n2092             if sharey:\n2093                 ax.sharey(ax0)\n2094                 ax._label_outer_yaxis(check_patch=True)\n2095         if extra := set(per_subplot_kw) - set(ret):\n2096             raise ValueError(\n2097                 f\"The keys {extra} are in *per_subplot_kw* \"\n2098                 \"but not in the mosaic.\"\n2099             )\n2100         return ret\n\n</code>\n```\n\n\nResult of search_method(\"savefig\"):\n\nFound 7 methods with name savefig in the codebase:\n\nThey appeared in the following files:\n- <file>lib/matplotlib/figure.py</file> (2 matches)\n- <file>lib/matplotlib/pyplot.py</file> (1 matches)\n- <file>lib/matplotlib/backends/backend_pdf.py</file> (2 matches)\n- <file>lib/matplotlib/backends/backend_pgf.py</file> (2 matches)\n\n\nResult of search_code(\"rcParams['figure.constrained_layout.use'] = True\"):\n\nFound 2 snippets containing `rcParams['figure.constrained_layout.use'] = True` in the codebase:\n\n- Search result 1:\n```\n<file>tutorials/intermediate/constrainedlayout_guide.py</file>\n\n<code>\n25 * activate it via :ref:`rcParams<customizing-with-dynamic-rc-settings>`,\n26   like::\n27 \n28       plt.rcParams['figure.constrained_layout.use'] = True\n29 \n30 Those are described in detail throughout the following sections.\n31 \n\n</code>\n```\n- Search result 2:\n```\n<file>tutorials/intermediate/constrainedlayout_guide.py</file>\n\n<code>\n319 #   Float representing a fraction of the subplot widths being separated.\n320 #   Default is 0.02.\n321 \n322 plt.rcParams['figure.constrained_layout.use'] = True\n323 fig, axs = plt.subplots(2, 2, figsize=(3, 3))\n324 for ax in axs.flat:\n325     example_plot(ax)\n\n</code>\n```\n\n\n"
    },
    {
        "role": "user",
        "content": "Let's analyze collected context first.\nIf an API call could not find any code, you should think about what other API calls you can make to get more context.\nIf an API call returns some result, you should analyze the result and think about these questions:\n1. What does this part of the code do?\n2. What is the relationship between this part of the code and the bug?\n3. Given the issue description, what would be the intended behavior of this part of the code?\n"
    },
    {
        "role": "assistant",
        "content": "Analyzing the collected context from the API calls, let's dive into the details and consider our three main questions.\n\n### `subplot_mosaic`\n1. **What does this part of the code do?**\n   - The `subplot_mosaic` function creates a layout of axes based on ASCII art or nested lists, allowing for complex gridspec layouts to be easily visualized. It takes several parameters including `mosaic`, `sharex`, `sharey`, `width_ratios`, `height_ratios`, `subplot_kw`, and others that control the appearance and behavior of the subplots. It returns a dictionary mapping labels to axes objects.\n   \n2. **What is the relationship between this part of the code and the bug?**\n   - The issue mentions that the \"compressed\" layout is not applied the second time a figure is saved. The `subplot_mosaic` function is directly involved in setting up the layout as specified with a \"compressed\" layout option. The bug might be related to how these layouts and their settings are preserved or altered between multiple save operations.\n   \n3. **Given the issue description, what would be the intended behavior of this part of the code?**\n   - Ideally, the \"compressed\" layout setting should consistently affect the figure layout across multiple saves. It seems the expected behavior would be that once the layout is set using `subplot_mosaic`, the resultant layout should not change or lose its \"compressed\" nature on subsequent saves, regardless of any other parameters or methods called afterwards.\n\n### `savefig`\n1. **What does this part of the code do?**\n   - The `savefig` method saves the current figure to a file or a file-like object using various options, including `bbox_inches` which can adjust the bounding box of the figure being saved.\n   \n2. **What is the relationship between this part of the code and the bug?**\n   - Since the problem occurs on the second save operation with the `bbox_inches=\"tight\"` setting, this could suggest an issue within the `savefig` method's handling of figure layouts or bounding boxes on consecutive saves. It might not correctly preserve or apply layout settings upon subsequent saves.\n   \n3. **Given the issue description, what would be the intended behavior of this part of the code?**\n   - The `savefig` method should consistently apply figure layout settings, including any \"compressed\" layout adjustments, across all saves. If `bbox_inches=\"tight\"` is specified, it should adjust the bounding box accordingly without disregarding the established layout from `subplot_mosaic` or any `rcParams`.\n\n### `rcParams` usage\n1. **What does this part of the code do?**\n   - The `rcParams` configuration is used to set global properties of Matplotlib plots, in this case enabling the constrained layout feature across figures unless overridden.\n   \n2. **What is the relationship between this part of the code and the bug?**\n   - The issue describes potentially inconsistent behavior when saving figures after modifying `rcParams` to use constrained layout with `figure.constrained_layout.use`. The interaction between `rcParams` settings and figure layout mechanisms may not be functioning correctly or as expected, particularly with respect to preserved settings across figure saves.\n   \n3. **Given the issue description, what would be the intended behavior of this part of the code?**\n   - Global settings via `rcParams` should affect all figures consistently and should not lead to unpredictable behavior when combined with specific figure layout options. Setting `figure.constrained_layout.use` to `True` should ensure that all figures respect the constrained layout without needing to be explicitly set with each figure or affecting the layout between saves negatively.\n\nGiven these three areas, the intended behavior seems to be a consistent application of layout settings across multiple saves and configurability via `rcParams` without unexpected alterations. The next steps in diagnosing or fixing the bug will likely involve exploring how `savefig` and `subplot_mosaic` interact with global settings via `rcParams` and ensuring that these interactions remain stable across saves. This might include ensuring that layout calculations are accurately preserved or re-applied on each save operation."
    },
    {
        "role": "user",
        "content": "Based on your analysis, answer below questions:\n1. do we need more context: construct search API calls to get more context of the project. If you don't need more context, LEAVE THIS EMTPY.\n2. where are bug locations: buggy files, classes, and methods. Only include the necessary locations that need to be fixed. For each bug location, you should also describe the intended behavior of the code at that location, in order to resolve the issue. The intended behavior should preserve the existing functionality of the code. If you think two methods in the same class are buggy, you should provide two bug locations (E.g. Location 1: File: a.py, Class: A, Method: a. Location 2: File: a.py, Class: A, Method: b.). If you want to add a method to a class, you should only provide the file and class as bug location, and describe the new method in intended behavior. If you still need more context, LEAVE THIS EMPTY."
    },
    {
        "role": "assistant",
        "content": "1. \n\n2. **Bug Locations:**\n\n   - **Location 1:**\n     - **File:** `lib/matplotlib/figure.py`\n     - **Class:** `Figure`\n     - **Method:** `subplot_mosaic`\n     - **Intended Behavior:** The method should ensure that the \"compressed\" layout, once applied to the figure via `subplot_mosaic`, persists through multiple save operations. This might require establishing a mechanism to check if a \"compressed\" layout has been applied and ensuring that this configuration is not lost or overridden unless explicitly changed when `savefig` is called multiple times. The existing functionality of setting up complex GridSpec layouts visually should be preserved.\n\n   - **Location 2:**\n     - **File:** `lib/matplotlib/figure.py`\n     - **Class:** `Figure`\n     - **Method:** `savefig`\n     - **Intended Behavior:** This method needs to guarantee that layout settings, including those related to \"compressed\" layouts or any adjustments made by setting `rcParams`, are consistently applied or re-evaluated at each call to `savefig`, especially when `bbox_inches=\"tight\"` is specified. It should handle the bounding box adjustments without negating or forgetting the previously applied layout configurations. The method should preserve all existing functionalities related to saving figures, including handling of file formats, DPI settings, and any other parameter supported by `savefig`.\n\nThese modifications should address the reported issue by ensuring consistent application of the \"compressed\" layout across multiple saves, thereby resolving the forgetting of layout settings on the second save."
    }
]