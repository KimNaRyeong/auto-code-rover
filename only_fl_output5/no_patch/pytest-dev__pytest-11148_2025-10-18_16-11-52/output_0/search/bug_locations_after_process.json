[
    {
        "rel_file_path": "testing/test_pathlib.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/pytest-dev__pytest/setup_pytest-dev__pytest__8.0/testing/test_pathlib.py",
        "start": 1,
        "end": 606,
        "class_name": null,
        "method_name": null,
        "code": "1 import os.path\n2 import pickle\n3 import sys\n4 import unittest.mock\n5 from pathlib import Path\n6 from textwrap import dedent\n7 from types import ModuleType\n8 from typing import Any\n9 from typing import Generator\n10 \n11 import pytest\n12 from _pytest.monkeypatch import MonkeyPatch\n13 from _pytest.pathlib import bestrelpath\n14 from _pytest.pathlib import commonpath\n15 from _pytest.pathlib import ensure_deletable\n16 from _pytest.pathlib import fnmatch_ex\n17 from _pytest.pathlib import get_extended_length_path_str\n18 from _pytest.pathlib import get_lock_path\n19 from _pytest.pathlib import import_path\n20 from _pytest.pathlib import ImportPathMismatchError\n21 from _pytest.pathlib import insert_missing_modules\n22 from _pytest.pathlib import maybe_delete_a_numbered_dir\n23 from _pytest.pathlib import module_name_from_path\n24 from _pytest.pathlib import resolve_package_path\n25 from _pytest.pathlib import symlink_or_skip\n26 from _pytest.pathlib import visit\n27 from _pytest.tmpdir import TempPathFactory\n28 \n29 \n30 class TestFNMatcherPort:\n31     \"\"\"Test our port of py.common.FNMatcher (fnmatch_ex).\"\"\"\n32 \n33     if sys.platform == \"win32\":\n34         drv1 = \"c:\"\n35         drv2 = \"d:\"\n36     else:\n37         drv1 = \"/c\"\n38         drv2 = \"/d\"\n39 \n40     @pytest.mark.parametrize(\n41         \"pattern, path\",\n42         [\n43             (\"*.py\", \"foo.py\"),\n44             (\"*.py\", \"bar/foo.py\"),\n45             (\"test_*.py\", \"foo/test_foo.py\"),\n46             (\"tests/*.py\", \"tests/foo.py\"),\n47             (f\"{drv1}/*.py\", f\"{drv1}/foo.py\"),\n48             (f\"{drv1}/foo/*.py\", f\"{drv1}/foo/foo.py\"),\n49             (\"tests/**/test*.py\", \"tests/foo/test_foo.py\"),\n50             (\"tests/**/doc/test*.py\", \"tests/foo/bar/doc/test_foo.py\"),\n51             (\"tests/**/doc/**/test*.py\", \"tests/foo/doc/bar/test_foo.py\"),\n52         ],\n53     )\n54     def test_matching(self, pattern: str, path: str) -> None:\n55         assert fnmatch_ex(pattern, path)\n56 \n57     def test_matching_abspath(self) -> None:\n58         abspath = os.path.abspath(os.path.join(\"tests/foo.py\"))\n59         assert fnmatch_ex(\"tests/foo.py\", abspath)\n60 \n61     @pytest.mark.parametrize(\n62         \"pattern, path\",\n63         [\n64             (\"*.py\", \"foo.pyc\"),\n65             (\"*.py\", \"foo/foo.pyc\"),\n66             (\"tests/*.py\", \"foo/foo.py\"),\n67             (f\"{drv1}/*.py\", f\"{drv2}/foo.py\"),\n68             (f\"{drv1}/foo/*.py\", f\"{drv2}/foo/foo.py\"),\n69             (\"tests/**/test*.py\", \"tests/foo.py\"),\n70             (\"tests/**/test*.py\", \"foo/test_foo.py\"),\n71             (\"tests/**/doc/test*.py\", \"tests/foo/bar/doc/foo.py\"),\n72             (\"tests/**/doc/test*.py\", \"tests/foo/bar/test_foo.py\"),\n73         ],\n74     )\n75     def test_not_matching(self, pattern: str, path: str) -> None:\n76         assert not fnmatch_ex(pattern, path)\n77 \n78 \n79 class TestImportPath:\n80     \"\"\"\n81 \n82     Most of the tests here were copied from py lib's tests for \"py.local.path.pyimport\".\n83 \n84     Having our own pyimport-like function is inline with removing py.path dependency in the future.\n85     \"\"\"\n86 \n87     @pytest.fixture(scope=\"session\")\n88     def path1(self, tmp_path_factory: TempPathFactory) -> Generator[Path, None, None]:\n89         path = tmp_path_factory.mktemp(\"path\")\n90         self.setuptestfs(path)\n91         yield path\n92         assert path.joinpath(\"samplefile\").exists()\n93 \n94     @pytest.fixture(autouse=True)\n95     def preserve_sys(self):\n96         with unittest.mock.patch.dict(sys.modules):\n97             with unittest.mock.patch.object(sys, \"path\", list(sys.path)):\n98                 yield\n99 \n100     def setuptestfs(self, path: Path) -> None:\n101         # print \"setting up test fs for\", repr(path)\n102         samplefile = path / \"samplefile\"\n103         samplefile.write_text(\"samplefile\\n\", encoding=\"utf-8\")\n104 \n105         execfile = path / \"execfile\"\n106         execfile.write_text(\"x=42\", encoding=\"utf-8\")\n107 \n108         execfilepy = path / \"execfile.py\"\n109         execfilepy.write_text(\"x=42\", encoding=\"utf-8\")\n110 \n111         d = {1: 2, \"hello\": \"world\", \"answer\": 42}\n112         path.joinpath(\"samplepickle\").write_bytes(pickle.dumps(d, 1))\n113 \n114         sampledir = path / \"sampledir\"\n115         sampledir.mkdir()\n116         sampledir.joinpath(\"otherfile\").touch()\n117 \n118         otherdir = path / \"otherdir\"\n119         otherdir.mkdir()\n120         otherdir.joinpath(\"__init__.py\").touch()\n121 \n122         module_a = otherdir / \"a.py\"\n123         module_a.write_text(\"from .b import stuff as result\\n\", encoding=\"utf-8\")\n124         module_b = otherdir / \"b.py\"\n125         module_b.write_text('stuff=\"got it\"\\n', encoding=\"utf-8\")\n126         module_c = otherdir / \"c.py\"\n127         module_c.write_text(\n128             dedent(\n129                 \"\"\"\n130             import pluggy;\n131             import otherdir.a\n132             value = otherdir.a.result\n133         \"\"\"\n134             ),\n135             encoding=\"utf-8\",\n136         )\n137         module_d = otherdir / \"d.py\"\n138         module_d.write_text(\n139             dedent(\n140                 \"\"\"\n141             import pluggy;\n142             from otherdir import a\n143             value2 = a.result\n144         \"\"\"\n145             ),\n146             encoding=\"utf-8\",\n147         )\n148 \n149     def test_smoke_test(self, path1: Path) -> None:\n150         obj = import_path(path1 / \"execfile.py\", root=path1)\n151         assert obj.x == 42  # type: ignore[attr-defined]\n152         assert obj.__name__ == \"execfile\"\n153 \n154     def test_import_path_missing_file(self, path1: Path) -> None:\n155         with pytest.raises(ImportPathMismatchError):\n156             import_path(path1 / \"sampledir\", root=path1)\n157 \n158     def test_renamed_dir_creates_mismatch(\n159         self, tmp_path: Path, monkeypatch: MonkeyPatch\n160     ) -> None:\n161         tmp_path.joinpath(\"a\").mkdir()\n162         p = tmp_path.joinpath(\"a\", \"test_x123.py\")\n163         p.touch()\n164         import_path(p, root=tmp_path)\n165         tmp_path.joinpath(\"a\").rename(tmp_path.joinpath(\"b\"))\n166         with pytest.raises(ImportPathMismatchError):\n167             import_path(tmp_path.joinpath(\"b\", \"test_x123.py\"), root=tmp_path)\n168 \n169         # Errors can be ignored.\n170         monkeypatch.setenv(\"PY_IGNORE_IMPORTMISMATCH\", \"1\")\n171         import_path(tmp_path.joinpath(\"b\", \"test_x123.py\"), root=tmp_path)\n172 \n173         # PY_IGNORE_IMPORTMISMATCH=0 does not ignore error.\n174         monkeypatch.setenv(\"PY_IGNORE_IMPORTMISMATCH\", \"0\")\n175         with pytest.raises(ImportPathMismatchError):\n176             import_path(tmp_path.joinpath(\"b\", \"test_x123.py\"), root=tmp_path)\n177 \n178     def test_messy_name(self, tmp_path: Path) -> None:\n179         # https://bitbucket.org/hpk42/py-trunk/issue/129\n180         path = tmp_path / \"foo__init__.py\"\n181         path.touch()\n182         module = import_path(path, root=tmp_path)\n183         assert module.__name__ == \"foo__init__\"\n184 \n185     def test_dir(self, tmp_path: Path) -> None:\n186         p = tmp_path / \"hello_123\"\n187         p.mkdir()\n188         p_init = p / \"__init__.py\"\n189         p_init.touch()\n190         m = import_path(p, root=tmp_path)\n191         assert m.__name__ == \"hello_123\"\n192         m = import_path(p_init, root=tmp_path)\n193         assert m.__name__ == \"hello_123\"\n194 \n195     def test_a(self, path1: Path) -> None:\n196         otherdir = path1 / \"otherdir\"\n197         mod = import_path(otherdir / \"a.py\", root=path1)\n198         assert mod.result == \"got it\"  # type: ignore[attr-defined]\n199         assert mod.__name__ == \"otherdir.a\"\n200 \n201     def test_b(self, path1: Path) -> None:\n202         otherdir = path1 / \"otherdir\"\n203         mod = import_path(otherdir / \"b.py\", root=path1)\n204         assert mod.stuff == \"got it\"  # type: ignore[attr-defined]\n205         assert mod.__name__ == \"otherdir.b\"\n206 \n207     def test_c(self, path1: Path) -> None:\n208         otherdir = path1 / \"otherdir\"\n209         mod = import_path(otherdir / \"c.py\", root=path1)\n210         assert mod.value == \"got it\"  # type: ignore[attr-defined]\n211 \n212     def test_d(self, path1: Path) -> None:\n213         otherdir = path1 / \"otherdir\"\n214         mod = import_path(otherdir / \"d.py\", root=path1)\n215         assert mod.value2 == \"got it\"  # type: ignore[attr-defined]\n216 \n217     def test_import_after(self, tmp_path: Path) -> None:\n218         tmp_path.joinpath(\"xxxpackage\").mkdir()\n219         tmp_path.joinpath(\"xxxpackage\", \"__init__.py\").touch()\n220         mod1path = tmp_path.joinpath(\"xxxpackage\", \"module1.py\")\n221         mod1path.touch()\n222         mod1 = import_path(mod1path, root=tmp_path)\n223         assert mod1.__name__ == \"xxxpackage.module1\"\n224         from xxxpackage import module1\n225 \n226         assert module1 is mod1\n227 \n228     def test_check_filepath_consistency(\n229         self, monkeypatch: MonkeyPatch, tmp_path: Path\n230     ) -> None:\n231         name = \"pointsback123\"\n232         p = tmp_path.joinpath(name + \".py\")\n233         p.touch()\n234         for ending in (\".pyc\", \".pyo\"):\n235             mod = ModuleType(name)\n236             pseudopath = tmp_path.joinpath(name + ending)\n237             pseudopath.touch()\n238             mod.__file__ = str(pseudopath)\n239             monkeypatch.setitem(sys.modules, name, mod)\n240             newmod = import_path(p, root=tmp_path)\n241             assert mod == newmod\n242         monkeypatch.undo()\n243         mod = ModuleType(name)\n244         pseudopath = tmp_path.joinpath(name + \"123.py\")\n245         pseudopath.touch()\n246         mod.__file__ = str(pseudopath)\n247         monkeypatch.setitem(sys.modules, name, mod)\n248         with pytest.raises(ImportPathMismatchError) as excinfo:\n249             import_path(p, root=tmp_path)\n250         modname, modfile, orig = excinfo.value.args\n251         assert modname == name\n252         assert modfile == str(pseudopath)\n253         assert orig == p\n254         assert issubclass(ImportPathMismatchError, ImportError)\n255 \n256     def test_issue131_on__init__(self, tmp_path: Path) -> None:\n257         # __init__.py files may be namespace packages, and thus the\n258         # __file__ of an imported module may not be ourselves\n259         # see issue\n260         tmp_path.joinpath(\"proja\").mkdir()\n261         p1 = tmp_path.joinpath(\"proja\", \"__init__.py\")\n262         p1.touch()\n263         tmp_path.joinpath(\"sub\", \"proja\").mkdir(parents=True)\n264         p2 = tmp_path.joinpath(\"sub\", \"proja\", \"__init__.py\")\n265         p2.touch()\n266         m1 = import_path(p1, root=tmp_path)\n267         m2 = import_path(p2, root=tmp_path)\n268         assert m1 == m2\n269 \n270     def test_ensuresyspath_append(self, tmp_path: Path) -> None:\n271         root1 = tmp_path / \"root1\"\n272         root1.mkdir()\n273         file1 = root1 / \"x123.py\"\n274         file1.touch()\n275         assert str(root1) not in sys.path\n276         import_path(file1, mode=\"append\", root=tmp_path)\n277         assert str(root1) == sys.path[-1]\n278         assert str(root1) not in sys.path[:-1]\n279 \n280     def test_invalid_path(self, tmp_path: Path) -> None:\n281         with pytest.raises(ImportError):\n282             import_path(tmp_path / \"invalid.py\", root=tmp_path)\n283 \n284     @pytest.fixture\n285     def simple_module(self, tmp_path: Path) -> Path:\n286         fn = tmp_path / \"_src/tests/mymod.py\"\n287         fn.parent.mkdir(parents=True)\n288         fn.write_text(\"def foo(x): return 40 + x\", encoding=\"utf-8\")\n289         return fn\n290 \n291     def test_importmode_importlib(self, simple_module: Path, tmp_path: Path) -> None:\n292         \"\"\"`importlib` mode does not change sys.path.\"\"\"\n293         module = import_path(simple_module, mode=\"importlib\", root=tmp_path)\n294         assert module.foo(2) == 42  # type: ignore[attr-defined]\n295         assert str(simple_module.parent) not in sys.path\n296         assert module.__name__ in sys.modules\n297         assert module.__name__ == \"_src.tests.mymod\"\n298         assert \"_src\" in sys.modules\n299         assert \"_src.tests\" in sys.modules\n300 \n301     def test_importmode_twice_is_different_module(\n302         self, simple_module: Path, tmp_path: Path\n303     ) -> None:\n304         \"\"\"`importlib` mode always returns a new module.\"\"\"\n305         module1 = import_path(simple_module, mode=\"importlib\", root=tmp_path)\n306         module2 = import_path(simple_module, mode=\"importlib\", root=tmp_path)\n307         assert module1 is not module2\n308 \n309     def test_no_meta_path_found(\n310         self, simple_module: Path, monkeypatch: MonkeyPatch, tmp_path: Path\n311     ) -> None:\n312         \"\"\"Even without any meta_path should still import module.\"\"\"\n313         monkeypatch.setattr(sys, \"meta_path\", [])\n314         module = import_path(simple_module, mode=\"importlib\", root=tmp_path)\n315         assert module.foo(2) == 42  # type: ignore[attr-defined]\n316 \n317         # mode='importlib' fails if no spec is found to load the module\n318         import importlib.util\n319 \n320         monkeypatch.setattr(\n321             importlib.util, \"spec_from_file_location\", lambda *args: None\n322         )\n323         with pytest.raises(ImportError):\n324             import_path(simple_module, mode=\"importlib\", root=tmp_path)\n325 \n326 \n327 def test_resolve_package_path(tmp_path: Path) -> None:\n328     pkg = tmp_path / \"pkg1\"\n329     pkg.mkdir()\n330     (pkg / \"__init__.py\").touch()\n331     (pkg / \"subdir\").mkdir()\n332     (pkg / \"subdir/__init__.py\").touch()\n333     assert resolve_package_path(pkg) == pkg\n334     assert resolve_package_path(pkg.joinpath(\"subdir\", \"__init__.py\")) == pkg\n335 \n336 \n337 def test_package_unimportable(tmp_path: Path) -> None:\n338     pkg = tmp_path / \"pkg1-1\"\n339     pkg.mkdir()\n340     pkg.joinpath(\"__init__.py\").touch()\n341     subdir = pkg.joinpath(\"subdir\")\n342     subdir.mkdir()\n343     pkg.joinpath(\"subdir/__init__.py\").touch()\n344     assert resolve_package_path(subdir) == subdir\n345     xyz = subdir.joinpath(\"xyz.py\")\n346     xyz.touch()\n347     assert resolve_package_path(xyz) == subdir\n348     assert not resolve_package_path(pkg)\n349 \n350 \n351 def test_access_denied_during_cleanup(tmp_path: Path, monkeypatch: MonkeyPatch) -> None:\n352     \"\"\"Ensure that deleting a numbered dir does not fail because of OSErrors (#4262).\"\"\"\n353     path = tmp_path / \"temp-1\"\n354     path.mkdir()\n355 \n356     def renamed_failed(*args):\n357         raise OSError(\"access denied\")\n358 \n359     monkeypatch.setattr(Path, \"rename\", renamed_failed)\n360 \n361     lock_path = get_lock_path(path)\n362     maybe_delete_a_numbered_dir(path)\n363     assert not lock_path.is_file()\n364 \n365 \n366 def test_long_path_during_cleanup(tmp_path: Path) -> None:\n367     \"\"\"Ensure that deleting long path works (particularly on Windows (#6775)).\"\"\"\n368     path = (tmp_path / (\"a\" * 250)).resolve()\n369     if sys.platform == \"win32\":\n370         # make sure that the full path is > 260 characters without any\n371         # component being over 260 characters\n372         assert len(str(path)) > 260\n373         extended_path = \"\\\\\\\\?\\\\\" + str(path)\n374     else:\n375         extended_path = str(path)\n376     os.mkdir(extended_path)\n377     assert os.path.isdir(extended_path)\n378     maybe_delete_a_numbered_dir(path)\n379     assert not os.path.isdir(extended_path)\n380 \n381 \n382 def test_get_extended_length_path_str() -> None:\n383     assert get_extended_length_path_str(r\"c:\\foo\") == r\"\\\\?\\c:\\foo\"\n384     assert get_extended_length_path_str(r\"\\\\share\\foo\") == r\"\\\\?\\UNC\\share\\foo\"\n385     assert get_extended_length_path_str(r\"\\\\?\\UNC\\share\\foo\") == r\"\\\\?\\UNC\\share\\foo\"\n386     assert get_extended_length_path_str(r\"\\\\?\\c:\\foo\") == r\"\\\\?\\c:\\foo\"\n387 \n388 \n389 def test_suppress_error_removing_lock(tmp_path: Path) -> None:\n390     \"\"\"ensure_deletable should be resilient if lock file cannot be removed (#5456, #7491)\"\"\"\n391     path = tmp_path / \"dir\"\n392     path.mkdir()\n393     lock = get_lock_path(path)\n394     lock.touch()\n395     mtime = lock.stat().st_mtime\n396 \n397     with unittest.mock.patch.object(Path, \"unlink\", side_effect=OSError) as m:\n398         assert not ensure_deletable(\n399             path, consider_lock_dead_if_created_before=mtime + 30\n400         )\n401         assert m.call_count == 1\n402     assert lock.is_file()\n403 \n404     with unittest.mock.patch.object(Path, \"is_file\", side_effect=OSError) as m:\n405         assert not ensure_deletable(\n406             path, consider_lock_dead_if_created_before=mtime + 30\n407         )\n408         assert m.call_count == 1\n409     assert lock.is_file()\n410 \n411     # check now that we can remove the lock file in normal circumstances\n412     assert ensure_deletable(path, consider_lock_dead_if_created_before=mtime + 30)\n413     assert not lock.is_file()\n414 \n415 \n416 def test_bestrelpath() -> None:\n417     curdir = Path(\"/foo/bar/baz/path\")\n418     assert bestrelpath(curdir, curdir) == \".\"\n419     assert bestrelpath(curdir, curdir / \"hello\" / \"world\") == \"hello\" + os.sep + \"world\"\n420     assert bestrelpath(curdir, curdir.parent / \"sister\") == \"..\" + os.sep + \"sister\"\n421     assert bestrelpath(curdir, curdir.parent) == \"..\"\n422     assert bestrelpath(curdir, Path(\"hello\")) == \"hello\"\n423 \n424 \n425 def test_commonpath() -> None:\n426     path = Path(\"/foo/bar/baz/path\")\n427     subpath = path / \"sampledir\"\n428     assert commonpath(path, subpath) == path\n429     assert commonpath(subpath, path) == path\n430     assert commonpath(Path(str(path) + \"suffix\"), path) == path.parent\n431     assert commonpath(path, path.parent.parent) == path.parent.parent\n432 \n433 \n434 def test_visit_ignores_errors(tmp_path: Path) -> None:\n435     symlink_or_skip(\"recursive\", tmp_path / \"recursive\")\n436     tmp_path.joinpath(\"foo\").write_bytes(b\"\")\n437     tmp_path.joinpath(\"bar\").write_bytes(b\"\")\n438 \n439     assert [\n440         entry.name for entry in visit(str(tmp_path), recurse=lambda entry: False)\n441     ] == [\"bar\", \"foo\"]\n442 \n443 \n444 @pytest.mark.skipif(not sys.platform.startswith(\"win\"), reason=\"Windows only\")\n445 def test_samefile_false_negatives(tmp_path: Path, monkeypatch: MonkeyPatch) -> None:\n446     \"\"\"\n447     import_file() should not raise ImportPathMismatchError if the paths are exactly\n448     equal on Windows. It seems directories mounted as UNC paths make os.path.samefile\n449     return False, even when they are clearly equal.\n450     \"\"\"\n451     module_path = tmp_path.joinpath(\"my_module.py\")\n452     module_path.write_text(\"def foo(): return 42\", encoding=\"utf-8\")\n453     monkeypatch.syspath_prepend(tmp_path)\n454 \n455     with monkeypatch.context() as mp:\n456         # Forcibly make os.path.samefile() return False here to ensure we are comparing\n457         # the paths too. Using a context to narrow the patch as much as possible given\n458         # this is an important system function.\n459         mp.setattr(os.path, \"samefile\", lambda x, y: False)\n460         module = import_path(module_path, root=tmp_path)\n461     assert getattr(module, \"foo\")() == 42\n462 \n463 \n464 class TestImportLibMode:\n465     def test_importmode_importlib_with_dataclass(self, tmp_path: Path) -> None:\n466         \"\"\"Ensure that importlib mode works with a module containing dataclasses (#7856).\"\"\"\n467         fn = tmp_path.joinpath(\"_src/tests/test_dataclass.py\")\n468         fn.parent.mkdir(parents=True)\n469         fn.write_text(\n470             dedent(\n471                 \"\"\"\n472                 from dataclasses import dataclass\n473 \n474                 @dataclass\n475                 class Data:\n476                     value: str\n477                 \"\"\"\n478             ),\n479             encoding=\"utf-8\",\n480         )\n481 \n482         module = import_path(fn, mode=\"importlib\", root=tmp_path)\n483         Data: Any = getattr(module, \"Data\")\n484         data = Data(value=\"foo\")\n485         assert data.value == \"foo\"\n486         assert data.__module__ == \"_src.tests.test_dataclass\"\n487 \n488     def test_importmode_importlib_with_pickle(self, tmp_path: Path) -> None:\n489         \"\"\"Ensure that importlib mode works with pickle (#7859).\"\"\"\n490         fn = tmp_path.joinpath(\"_src/tests/test_pickle.py\")\n491         fn.parent.mkdir(parents=True)\n492         fn.write_text(\n493             dedent(\n494                 \"\"\"\n495                 import pickle\n496 \n497                 def _action():\n498                     return 42\n499 \n500                 def round_trip():\n501                     s = pickle.dumps(_action)\n502                     return pickle.loads(s)\n503                 \"\"\"\n504             ),\n505             encoding=\"utf-8\",\n506         )\n507 \n508         module = import_path(fn, mode=\"importlib\", root=tmp_path)\n509         round_trip = getattr(module, \"round_trip\")\n510         action = round_trip()\n511         assert action() == 42\n512 \n513     def test_importmode_importlib_with_pickle_separate_modules(\n514         self, tmp_path: Path\n515     ) -> None:\n516         \"\"\"\n517         Ensure that importlib mode works can load pickles that look similar but are\n518         defined in separate modules.\n519         \"\"\"\n520         fn1 = tmp_path.joinpath(\"_src/m1/tests/test.py\")\n521         fn1.parent.mkdir(parents=True)\n522         fn1.write_text(\n523             dedent(\n524                 \"\"\"\n525                 import dataclasses\n526                 import pickle\n527 \n528                 @dataclasses.dataclass\n529                 class Data:\n530                     x: int = 42\n531                 \"\"\"\n532             ),\n533             encoding=\"utf-8\",\n534         )\n535 \n536         fn2 = tmp_path.joinpath(\"_src/m2/tests/test.py\")\n537         fn2.parent.mkdir(parents=True)\n538         fn2.write_text(\n539             dedent(\n540                 \"\"\"\n541                 import dataclasses\n542                 import pickle\n543 \n544                 @dataclasses.dataclass\n545                 class Data:\n546                     x: str = \"\"\n547                 \"\"\"\n548             ),\n549             encoding=\"utf-8\",\n550         )\n551 \n552         import pickle\n553 \n554         def round_trip(obj):\n555             s = pickle.dumps(obj)\n556             return pickle.loads(s)\n557 \n558         module = import_path(fn1, mode=\"importlib\", root=tmp_path)\n559         Data1 = getattr(module, \"Data\")\n560 \n561         module = import_path(fn2, mode=\"importlib\", root=tmp_path)\n562         Data2 = getattr(module, \"Data\")\n563 \n564         assert round_trip(Data1(20)) == Data1(20)\n565         assert round_trip(Data2(\"hello\")) == Data2(\"hello\")\n566         assert Data1.__module__ == \"_src.m1.tests.test\"\n567         assert Data2.__module__ == \"_src.m2.tests.test\"\n568 \n569     def test_module_name_from_path(self, tmp_path: Path) -> None:\n570         result = module_name_from_path(tmp_path / \"src/tests/test_foo.py\", tmp_path)\n571         assert result == \"src.tests.test_foo\"\n572 \n573         # Path is not relative to root dir: use the full path to obtain the module name.\n574         result = module_name_from_path(Path(\"/home/foo/test_foo.py\"), Path(\"/bar\"))\n575         assert result == \"home.foo.test_foo\"\n576 \n577     def test_insert_missing_modules(\n578         self, monkeypatch: MonkeyPatch, tmp_path: Path\n579     ) -> None:\n580         monkeypatch.chdir(tmp_path)\n581         # Use 'xxx' and 'xxy' as parent names as they are unlikely to exist and\n582         # don't end up being imported.\n583         modules = {\"xxx.tests.foo\": ModuleType(\"xxx.tests.foo\")}\n584         insert_missing_modules(modules, \"xxx.tests.foo\")\n585         assert sorted(modules) == [\"xxx\", \"xxx.tests\", \"xxx.tests.foo\"]\n586 \n587         mod = ModuleType(\"mod\", doc=\"My Module\")\n588         modules = {\"xxy\": mod}\n589         insert_missing_modules(modules, \"xxy\")\n590         assert modules == {\"xxy\": mod}\n591 \n592         modules = {}\n593         insert_missing_modules(modules, \"\")\n594         assert modules == {}\n595 \n596     def test_parent_contains_child_module_attribute(\n597         self, monkeypatch: MonkeyPatch, tmp_path: Path\n598     ):\n599         monkeypatch.chdir(tmp_path)\n600         # Use 'xxx' and 'xxy' as parent names as they are unlikely to exist and\n601         # don't end up being imported.\n602         modules = {\"xxx.tests.foo\": ModuleType(\"xxx.tests.foo\")}\n603         insert_missing_modules(modules, \"xxx.tests.foo\")\n604         assert sorted(modules) == [\"xxx\", \"xxx.tests\", \"xxx.tests.foo\"]\n605         assert modules[\"xxx\"].tests is modules[\"xxx.tests\"]\n606         assert modules[\"xxx.tests\"].foo is modules[\"xxx.tests.foo\"]\n",
        "intended_behavior": "The code handling namespace packages, both in tests and possibly in the application's core logic (where similar patterns are likely to be present), should ensure consistent and correct import paths to prevent module duplication. This might involve verifying and adjusting how `importlib` is used to import modules part of a namespace package, ensuring that a single instance of each module is maintained across the application."
    },
    {
        "rel_file_path": "testing/_py/test_local.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/pytest-dev__pytest/setup_pytest-dev__pytest__8.0/testing/_py/test_local.py",
        "start": 1,
        "end": 1576,
        "class_name": null,
        "method_name": null,
        "code": "1 import contextlib\n2 import multiprocessing\n3 import os\n4 import sys\n5 import time\n6 import warnings\n7 from unittest import mock\n8 \n9 import pytest\n10 from py import error\n11 from py.path import local\n12 \n13 \n14 @contextlib.contextmanager\n15 def ignore_encoding_warning():\n16     with warnings.catch_warnings():\n17         with contextlib.suppress(NameError):  # new in 3.10\n18             warnings.simplefilter(\"ignore\", EncodingWarning)\n19         yield\n20 \n21 \n22 class CommonFSTests:\n23     def test_constructor_equality(self, path1):\n24         p = path1.__class__(path1)\n25         assert p == path1\n26 \n27     def test_eq_nonstring(self, path1):\n28         p1 = path1.join(\"sampledir\")\n29         p2 = path1.join(\"sampledir\")\n30         assert p1 == p2\n31 \n32     def test_new_identical(self, path1):\n33         assert path1 == path1.new()\n34 \n35     def test_join(self, path1):\n36         p = path1.join(\"sampledir\")\n37         strp = str(p)\n38         assert strp.endswith(\"sampledir\")\n39         assert strp.startswith(str(path1))\n40 \n41     def test_join_normalized(self, path1):\n42         newpath = path1.join(path1.sep + \"sampledir\")\n43         strp = str(newpath)\n44         assert strp.endswith(\"sampledir\")\n45         assert strp.startswith(str(path1))\n46         newpath = path1.join((path1.sep * 2) + \"sampledir\")\n47         strp = str(newpath)\n48         assert strp.endswith(\"sampledir\")\n49         assert strp.startswith(str(path1))\n50 \n51     def test_join_noargs(self, path1):\n52         newpath = path1.join()\n53         assert path1 == newpath\n54 \n55     def test_add_something(self, path1):\n56         p = path1.join(\"sample\")\n57         p = p + \"dir\"\n58         assert p.check()\n59         assert p.exists()\n60         assert p.isdir()\n61         assert not p.isfile()\n62 \n63     def test_parts(self, path1):\n64         newpath = path1.join(\"sampledir\", \"otherfile\")\n65         par = newpath.parts()[-3:]\n66         assert par == [path1, path1.join(\"sampledir\"), newpath]\n67 \n68         revpar = newpath.parts(reverse=True)[:3]\n69         assert revpar == [newpath, path1.join(\"sampledir\"), path1]\n70 \n71     def test_common(self, path1):\n72         other = path1.join(\"sampledir\")\n73         x = other.common(path1)\n74         assert x == path1\n75 \n76     # def test_parents_nonexisting_file(self, path1):\n77     #    newpath = path1 / 'dirnoexist' / 'nonexisting file'\n78     #    par = list(newpath.parents())\n79     #    assert par[:2] == [path1 / 'dirnoexist', path1]\n80 \n81     def test_basename_checks(self, path1):\n82         newpath = path1.join(\"sampledir\")\n83         assert newpath.check(basename=\"sampledir\")\n84         assert newpath.check(notbasename=\"xyz\")\n85         assert newpath.basename == \"sampledir\"\n86 \n87     def test_basename(self, path1):\n88         newpath = path1.join(\"sampledir\")\n89         assert newpath.check(basename=\"sampledir\")\n90         assert newpath.basename, \"sampledir\"\n91 \n92     def test_dirname(self, path1):\n93         newpath = path1.join(\"sampledir\")\n94         assert newpath.dirname == str(path1)\n95 \n96     def test_dirpath(self, path1):\n97         newpath = path1.join(\"sampledir\")\n98         assert newpath.dirpath() == path1\n99 \n100     def test_dirpath_with_args(self, path1):\n101         newpath = path1.join(\"sampledir\")\n102         assert newpath.dirpath(\"x\") == path1.join(\"x\")\n103 \n104     def test_newbasename(self, path1):\n105         newpath = path1.join(\"samplefile\")\n106         newbase = newpath.new(basename=\"samplefile2\")\n107         assert newbase.basename == \"samplefile2\"\n108         assert newbase.dirpath() == newpath.dirpath()\n109 \n110     def test_not_exists(self, path1):\n111         assert not path1.join(\"does_not_exist\").check()\n112         assert path1.join(\"does_not_exist\").check(exists=0)\n113 \n114     def test_exists(self, path1):\n115         assert path1.join(\"samplefile\").check()\n116         assert path1.join(\"samplefile\").check(exists=1)\n117         assert path1.join(\"samplefile\").exists()\n118         assert path1.join(\"samplefile\").isfile()\n119         assert not path1.join(\"samplefile\").isdir()\n120 \n121     def test_dir(self, path1):\n122         # print repr(path1.join(\"sampledir\"))\n123         assert path1.join(\"sampledir\").check(dir=1)\n124         assert path1.join(\"samplefile\").check(notdir=1)\n125         assert not path1.join(\"samplefile\").check(dir=1)\n126         assert path1.join(\"samplefile\").exists()\n127         assert not path1.join(\"samplefile\").isdir()\n128         assert path1.join(\"samplefile\").isfile()\n129 \n130     def test_fnmatch_file(self, path1):\n131         assert path1.join(\"samplefile\").check(fnmatch=\"s*e\")\n132         assert path1.join(\"samplefile\").fnmatch(\"s*e\")\n133         assert not path1.join(\"samplefile\").fnmatch(\"s*x\")\n134         assert not path1.join(\"samplefile\").check(fnmatch=\"s*x\")\n135 \n136     # def test_fnmatch_dir(self, path1):\n137 \n138     #    pattern = path1.sep.join(['s*file'])\n139     #    sfile = path1.join(\"samplefile\")\n140     #    assert sfile.check(fnmatch=pattern)\n141 \n142     def test_relto(self, path1):\n143         p = path1.join(\"sampledir\", \"otherfile\")\n144         assert p.relto(path1) == p.sep.join([\"sampledir\", \"otherfile\"])\n145         assert p.check(relto=path1)\n146         assert path1.check(notrelto=p)\n147         assert not path1.check(relto=p)\n148 \n149     def test_bestrelpath(self, path1):\n150         curdir = path1\n151         sep = curdir.sep\n152         s = curdir.bestrelpath(curdir)\n153         assert s == \".\"\n154         s = curdir.bestrelpath(curdir.join(\"hello\", \"world\"))\n155         assert s == \"hello\" + sep + \"world\"\n156 \n157         s = curdir.bestrelpath(curdir.dirpath().join(\"sister\"))\n158         assert s == \"..\" + sep + \"sister\"\n159         assert curdir.bestrelpath(curdir.dirpath()) == \"..\"\n160 \n161         assert curdir.bestrelpath(\"hello\") == \"hello\"\n162 \n163     def test_relto_not_relative(self, path1):\n164         l1 = path1.join(\"bcde\")\n165         l2 = path1.join(\"b\")\n166         assert not l1.relto(l2)\n167         assert not l2.relto(l1)\n168 \n169     def test_listdir(self, path1):\n170         p = path1.listdir()\n171         assert path1.join(\"sampledir\") in p\n172         assert path1.join(\"samplefile\") in p\n173         with pytest.raises(error.ENOTDIR):\n174             path1.join(\"samplefile\").listdir()\n175 \n176     def test_listdir_fnmatchstring(self, path1):\n177         p = path1.listdir(\"s*dir\")\n178         assert len(p)\n179         assert p[0], path1.join(\"sampledir\")\n180 \n181     def test_listdir_filter(self, path1):\n182         p = path1.listdir(lambda x: x.check(dir=1))\n183         assert path1.join(\"sampledir\") in p\n184         assert not path1.join(\"samplefile\") in p\n185 \n186     def test_listdir_sorted(self, path1):\n187         p = path1.listdir(lambda x: x.check(basestarts=\"sample\"), sort=True)\n188         assert path1.join(\"sampledir\") == p[0]\n189         assert path1.join(\"samplefile\") == p[1]\n190         assert path1.join(\"samplepickle\") == p[2]\n191 \n192     def test_visit_nofilter(self, path1):\n193         lst = []\n194         for i in path1.visit():\n195             lst.append(i.relto(path1))\n196         assert \"sampledir\" in lst\n197         assert path1.sep.join([\"sampledir\", \"otherfile\"]) in lst\n198 \n199     def test_visit_norecurse(self, path1):\n200         lst = []\n201         for i in path1.visit(None, lambda x: x.basename != \"sampledir\"):\n202             lst.append(i.relto(path1))\n203         assert \"sampledir\" in lst\n204         assert not path1.sep.join([\"sampledir\", \"otherfile\"]) in lst\n205 \n206     @pytest.mark.parametrize(\n207         \"fil\",\n208         [\"*dir\", \"*dir\", pytest.mark.skip(\"sys.version_info <\" \" (3,6)\")(b\"*dir\")],\n209     )\n210     def test_visit_filterfunc_is_string(self, path1, fil):\n211         lst = []\n212         for i in path1.visit(fil):\n213             lst.append(i.relto(path1))\n214         assert len(lst), 2\n215         assert \"sampledir\" in lst\n216         assert \"otherdir\" in lst\n217 \n218     def test_visit_ignore(self, path1):\n219         p = path1.join(\"nonexisting\")\n220         assert list(p.visit(ignore=error.ENOENT)) == []\n221 \n222     def test_visit_endswith(self, path1):\n223         p = []\n224         for i in path1.visit(lambda x: x.check(endswith=\"file\")):\n225             p.append(i.relto(path1))\n226         assert path1.sep.join([\"sampledir\", \"otherfile\"]) in p\n227         assert \"samplefile\" in p\n228 \n229     def test_cmp(self, path1):\n230         path1 = path1.join(\"samplefile\")\n231         path2 = path1.join(\"samplefile2\")\n232         assert (path1 < path2) == (\"samplefile\" < \"samplefile2\")\n233         assert not (path1 < path1)\n234 \n235     def test_simple_read(self, path1):\n236         with ignore_encoding_warning():\n237             x = path1.join(\"samplefile\").read(\"r\")\n238         assert x == \"samplefile\\n\"\n239 \n240     def test_join_div_operator(self, path1):\n241         newpath = path1 / \"/sampledir\" / \"/test//\"\n242         newpath2 = path1.join(\"sampledir\", \"test\")\n243         assert newpath == newpath2\n244 \n245     def test_ext(self, path1):\n246         newpath = path1.join(\"sampledir.ext\")\n247         assert newpath.ext == \".ext\"\n248         newpath = path1.join(\"sampledir\")\n249         assert not newpath.ext\n250 \n251     def test_purebasename(self, path1):\n252         newpath = path1.join(\"samplefile.py\")\n253         assert newpath.purebasename == \"samplefile\"\n254 \n255     def test_multiple_parts(self, path1):\n256         newpath = path1.join(\"samplefile.py\")\n257         dirname, purebasename, basename, ext = newpath._getbyspec(\n258             \"dirname,purebasename,basename,ext\"\n259         )\n260         assert str(path1).endswith(dirname)  # be careful with win32 'drive'\n261         assert purebasename == \"samplefile\"\n262         assert basename == \"samplefile.py\"\n263         assert ext == \".py\"\n264 \n265     def test_dotted_name_ext(self, path1):\n266         newpath = path1.join(\"a.b.c\")\n267         ext = newpath.ext\n268         assert ext == \".c\"\n269         assert newpath.ext == \".c\"\n270 \n271     def test_newext(self, path1):\n272         newpath = path1.join(\"samplefile.py\")\n273         newext = newpath.new(ext=\".txt\")\n274         assert newext.basename == \"samplefile.txt\"\n275         assert newext.purebasename == \"samplefile\"\n276 \n277     def test_readlines(self, path1):\n278         fn = path1.join(\"samplefile\")\n279         with ignore_encoding_warning():\n280             contents = fn.readlines()\n281         assert contents == [\"samplefile\\n\"]\n282 \n283     def test_readlines_nocr(self, path1):\n284         fn = path1.join(\"samplefile\")\n285         with ignore_encoding_warning():\n286             contents = fn.readlines(cr=0)\n287         assert contents == [\"samplefile\", \"\"]\n288 \n289     def test_file(self, path1):\n290         assert path1.join(\"samplefile\").check(file=1)\n291 \n292     def test_not_file(self, path1):\n293         assert not path1.join(\"sampledir\").check(file=1)\n294         assert path1.join(\"sampledir\").check(file=0)\n295 \n296     def test_non_existent(self, path1):\n297         assert path1.join(\"sampledir.nothere\").check(dir=0)\n298         assert path1.join(\"sampledir.nothere\").check(file=0)\n299         assert path1.join(\"sampledir.nothere\").check(notfile=1)\n300         assert path1.join(\"sampledir.nothere\").check(notdir=1)\n301         assert path1.join(\"sampledir.nothere\").check(notexists=1)\n302         assert not path1.join(\"sampledir.nothere\").check(notfile=0)\n303 \n304     #    pattern = path1.sep.join(['s*file'])\n305     #    sfile = path1.join(\"samplefile\")\n306     #    assert sfile.check(fnmatch=pattern)\n307 \n308     def test_size(self, path1):\n309         url = path1.join(\"samplefile\")\n310         assert url.size() > len(\"samplefile\")\n311 \n312     def test_mtime(self, path1):\n313         url = path1.join(\"samplefile\")\n314         assert url.mtime() > 0\n315 \n316     def test_relto_wrong_type(self, path1):\n317         with pytest.raises(TypeError):\n318             path1.relto(42)\n319 \n320     def test_load(self, path1):\n321         p = path1.join(\"samplepickle\")\n322         obj = p.load()\n323         assert type(obj) is dict\n324         assert obj.get(\"answer\", None) == 42\n325 \n326     def test_visit_filesonly(self, path1):\n327         p = []\n328         for i in path1.visit(lambda x: x.check(file=1)):\n329             p.append(i.relto(path1))\n330         assert \"sampledir\" not in p\n331         assert path1.sep.join([\"sampledir\", \"otherfile\"]) in p\n332 \n333     def test_visit_nodotfiles(self, path1):\n334         p = []\n335         for i in path1.visit(lambda x: x.check(dotfile=0)):\n336             p.append(i.relto(path1))\n337         assert \"sampledir\" in p\n338         assert path1.sep.join([\"sampledir\", \"otherfile\"]) in p\n339         assert \".dotfile\" not in p\n340 \n341     def test_visit_breadthfirst(self, path1):\n342         lst = []\n343         for i in path1.visit(bf=True):\n344             lst.append(i.relto(path1))\n345         for i, p in enumerate(lst):\n346             if path1.sep in p:\n347                 for j in range(i, len(lst)):\n348                     assert path1.sep in lst[j]\n349                 break\n350         else:\n351             pytest.fail(\"huh\")\n352 \n353     def test_visit_sort(self, path1):\n354         lst = []\n355         for i in path1.visit(bf=True, sort=True):\n356             lst.append(i.relto(path1))\n357         for i, p in enumerate(lst):\n358             if path1.sep in p:\n359                 break\n360         assert lst[:i] == sorted(lst[:i])\n361         assert lst[i:] == sorted(lst[i:])\n362 \n363     def test_endswith(self, path1):\n364         def chk(p):\n365             return p.check(endswith=\"pickle\")\n366 \n367         assert not chk(path1)\n368         assert not chk(path1.join(\"samplefile\"))\n369         assert chk(path1.join(\"somepickle\"))\n370 \n371     def test_copy_file(self, path1):\n372         otherdir = path1.join(\"otherdir\")\n373         initpy = otherdir.join(\"__init__.py\")\n374         copied = otherdir.join(\"copied\")\n375         initpy.copy(copied)\n376         try:\n377             assert copied.check()\n378             s1 = initpy.read_text(encoding=\"utf-8\")\n379             s2 = copied.read_text(encoding=\"utf-8\")\n380             assert s1 == s2\n381         finally:\n382             if copied.check():\n383                 copied.remove()\n384 \n385     def test_copy_dir(self, path1):\n386         otherdir = path1.join(\"otherdir\")\n387         copied = path1.join(\"newdir\")\n388         try:\n389             otherdir.copy(copied)\n390             assert copied.check(dir=1)\n391             assert copied.join(\"__init__.py\").check(file=1)\n392             s1 = otherdir.join(\"__init__.py\").read_text(encoding=\"utf-8\")\n393             s2 = copied.join(\"__init__.py\").read_text(encoding=\"utf-8\")\n394             assert s1 == s2\n395         finally:\n396             if copied.check(dir=1):\n397                 copied.remove(rec=1)\n398 \n399     def test_remove_file(self, path1):\n400         d = path1.ensure(\"todeleted\")\n401         assert d.check()\n402         d.remove()\n403         assert not d.check()\n404 \n405     def test_remove_dir_recursive_by_default(self, path1):\n406         d = path1.ensure(\"to\", \"be\", \"deleted\")\n407         assert d.check()\n408         p = path1.join(\"to\")\n409         p.remove()\n410         assert not p.check()\n411 \n412     def test_ensure_dir(self, path1):\n413         b = path1.ensure_dir(\"001\", \"002\")\n414         assert b.basename == \"002\"\n415         assert b.isdir()\n416 \n417     def test_mkdir_and_remove(self, path1):\n418         tmpdir = path1\n419         with pytest.raises(error.EEXIST):\n420             tmpdir.mkdir(\"sampledir\")\n421         new = tmpdir.join(\"mktest1\")\n422         new.mkdir()\n423         assert new.check(dir=1)\n424         new.remove()\n425 \n426         new = tmpdir.mkdir(\"mktest\")\n427         assert new.check(dir=1)\n428         new.remove()\n429         assert tmpdir.join(\"mktest\") == new\n430 \n431     def test_move_file(self, path1):\n432         p = path1.join(\"samplefile\")\n433         newp = p.dirpath(\"moved_samplefile\")\n434         p.move(newp)\n435         try:\n436             assert newp.check(file=1)\n437             assert not p.check()\n438         finally:\n439             dp = newp.dirpath()\n440             if hasattr(dp, \"revert\"):\n441                 dp.revert()\n442             else:\n443                 newp.move(p)\n444                 assert p.check()\n445 \n446     def test_move_dir(self, path1):\n447         source = path1.join(\"sampledir\")\n448         dest = path1.join(\"moveddir\")\n449         source.move(dest)\n450         assert dest.check(dir=1)\n451         assert dest.join(\"otherfile\").check(file=1)\n452         assert not source.join(\"sampledir\").check()\n453 \n454     def test_fspath_protocol_match_strpath(self, path1):\n455         assert path1.__fspath__() == path1.strpath\n456 \n457     def test_fspath_func_match_strpath(self, path1):\n458         from os import fspath\n459 \n460         assert fspath(path1) == path1.strpath\n461 \n462     @pytest.mark.skip(\"sys.version_info < (3,6)\")\n463     def test_fspath_open(self, path1):\n464         f = path1.join(\"opentestfile\")\n465         open(f)\n466 \n467     @pytest.mark.skip(\"sys.version_info < (3,6)\")\n468     def test_fspath_fsencode(self, path1):\n469         from os import fsencode\n470 \n471         assert fsencode(path1) == fsencode(path1.strpath)\n472 \n473 \n474 def setuptestfs(path):\n475     if path.join(\"samplefile\").check():\n476         return\n477     # print \"setting up test fs for\", repr(path)\n478     samplefile = path.ensure(\"samplefile\")\n479     samplefile.write_text(\"samplefile\\n\", encoding=\"utf-8\")\n480 \n481     execfile = path.ensure(\"execfile\")\n482     execfile.write_text(\"x=42\", encoding=\"utf-8\")\n483 \n484     execfilepy = path.ensure(\"execfile.py\")\n485     execfilepy.write_text(\"x=42\", encoding=\"utf-8\")\n486 \n487     d = {1: 2, \"hello\": \"world\", \"answer\": 42}\n488     path.ensure(\"samplepickle\").dump(d)\n489 \n490     sampledir = path.ensure(\"sampledir\", dir=1)\n491     sampledir.ensure(\"otherfile\")\n492 \n493     otherdir = path.ensure(\"otherdir\", dir=1)\n494     otherdir.ensure(\"__init__.py\")\n495 \n496     module_a = otherdir.ensure(\"a.py\")\n497     module_a.write_text(\"from .b import stuff as result\\n\", encoding=\"utf-8\")\n498     module_b = otherdir.ensure(\"b.py\")\n499     module_b.write_text('stuff=\"got it\"\\n', encoding=\"utf-8\")\n500     module_c = otherdir.ensure(\"c.py\")\n501     module_c.write_text(\n502         \"\"\"import py;\n503 import otherdir.a\n504 value = otherdir.a.result\n505 \"\"\",\n506         encoding=\"utf-8\",\n507     )\n508     module_d = otherdir.ensure(\"d.py\")\n509     module_d.write_text(\n510         \"\"\"import py;\n511 from otherdir import a\n512 value2 = a.result\n513 \"\"\",\n514         encoding=\"utf-8\",\n515     )\n516 \n517 \n518 win32only = pytest.mark.skipif(\n519     \"not (sys.platform == 'win32' or getattr(os, '_name', None) == 'nt')\"\n520 )\n521 skiponwin32 = pytest.mark.skipif(\n522     \"sys.platform == 'win32' or getattr(os, '_name', None) == 'nt'\"\n523 )\n524 \n525 ATIME_RESOLUTION = 0.01\n526 \n527 \n528 @pytest.fixture(scope=\"session\")\n529 def path1(tmpdir_factory):\n530     path = tmpdir_factory.mktemp(\"path\")\n531     setuptestfs(path)\n532     yield path\n533     assert path.join(\"samplefile\").check()\n534 \n535 \n536 @pytest.fixture\n537 def fake_fspath_obj(request):\n538     class FakeFSPathClass:\n539         def __init__(self, path):\n540             self._path = path\n541 \n542         def __fspath__(self):\n543             return self._path\n544 \n545     return FakeFSPathClass(os.path.join(\"this\", \"is\", \"a\", \"fake\", \"path\"))\n546 \n547 \n548 def batch_make_numbered_dirs(rootdir, repeats):\n549     for i in range(repeats):\n550         dir_ = local.make_numbered_dir(prefix=\"repro-\", rootdir=rootdir)\n551         file_ = dir_.join(\"foo\")\n552         file_.write_text(\"%s\" % i, encoding=\"utf-8\")\n553         actual = int(file_.read_text(encoding=\"utf-8\"))\n554         assert (\n555             actual == i\n556         ), f\"int(file_.read_text(encoding='utf-8')) is {actual} instead of {i}\"\n557         dir_.join(\".lock\").remove(ignore_errors=True)\n558     return True\n559 \n560 \n561 class TestLocalPath(CommonFSTests):\n562     def test_join_normpath(self, tmpdir):\n563         assert tmpdir.join(\".\") == tmpdir\n564         p = tmpdir.join(\"../%s\" % tmpdir.basename)\n565         assert p == tmpdir\n566         p = tmpdir.join(\"..//%s/\" % tmpdir.basename)\n567         assert p == tmpdir\n568 \n569     @skiponwin32\n570     def test_dirpath_abs_no_abs(self, tmpdir):\n571         p = tmpdir.join(\"foo\")\n572         assert p.dirpath(\"/bar\") == tmpdir.join(\"bar\")\n573         assert tmpdir.dirpath(\"/bar\", abs=True) == local(\"/bar\")\n574 \n575     def test_gethash(self, tmpdir):\n576         from hashlib import md5\n577         from hashlib import sha1 as sha\n578 \n579         fn = tmpdir.join(\"testhashfile\")\n580         data = b\"hello\"\n581         fn.write(data, mode=\"wb\")\n582         assert fn.computehash(\"md5\") == md5(data).hexdigest()\n583         assert fn.computehash(\"sha1\") == sha(data).hexdigest()\n584         with pytest.raises(ValueError):\n585             fn.computehash(\"asdasd\")\n586 \n587     def test_remove_removes_readonly_file(self, tmpdir):\n588         readonly_file = tmpdir.join(\"readonly\").ensure()\n589         readonly_file.chmod(0)\n590         readonly_file.remove()\n591         assert not readonly_file.check(exists=1)\n592 \n593     def test_remove_removes_readonly_dir(self, tmpdir):\n594         readonly_dir = tmpdir.join(\"readonlydir\").ensure(dir=1)\n595         readonly_dir.chmod(int(\"500\", 8))\n596         readonly_dir.remove()\n597         assert not readonly_dir.check(exists=1)\n598 \n599     def test_remove_removes_dir_and_readonly_file(self, tmpdir):\n600         readonly_dir = tmpdir.join(\"readonlydir\").ensure(dir=1)\n601         readonly_file = readonly_dir.join(\"readonlyfile\").ensure()\n602         readonly_file.chmod(0)\n603         readonly_dir.remove()\n604         assert not readonly_dir.check(exists=1)\n605 \n606     def test_remove_routes_ignore_errors(self, tmpdir, monkeypatch):\n607         lst = []\n608         monkeypatch.setattr(\"shutil.rmtree\", lambda *args, **kwargs: lst.append(kwargs))\n609         tmpdir.remove()\n610         assert not lst[0][\"ignore_errors\"]\n611         for val in (True, False):\n612             lst[:] = []\n613             tmpdir.remove(ignore_errors=val)\n614             assert lst[0][\"ignore_errors\"] == val\n615 \n616     def test_initialize_curdir(self):\n617         assert str(local()) == os.getcwd()\n618 \n619     @skiponwin32\n620     def test_chdir_gone(self, path1):\n621         p = path1.ensure(\"dir_to_be_removed\", dir=1)\n622         p.chdir()\n623         p.remove()\n624         pytest.raises(error.ENOENT, local)\n625         assert path1.chdir() is None\n626         assert os.getcwd() == str(path1)\n627 \n628         with pytest.raises(error.ENOENT):\n629             with p.as_cwd():\n630                 raise NotImplementedError\n631 \n632     @skiponwin32\n633     def test_chdir_gone_in_as_cwd(self, path1):\n634         p = path1.ensure(\"dir_to_be_removed\", dir=1)\n635         p.chdir()\n636         p.remove()\n637 \n638         with path1.as_cwd() as old:\n639             assert old is None\n640 \n641     def test_as_cwd(self, path1):\n642         dir = path1.ensure(\"subdir\", dir=1)\n643         old = local()\n644         with dir.as_cwd() as x:\n645             assert x == old\n646             assert local() == dir\n647         assert os.getcwd() == str(old)\n648 \n649     def test_as_cwd_exception(self, path1):\n650         old = local()\n651         dir = path1.ensure(\"subdir\", dir=1)\n652         with pytest.raises(ValueError):\n653             with dir.as_cwd():\n654                 raise ValueError()\n655         assert old == local()\n656 \n657     def test_initialize_reldir(self, path1):\n658         with path1.as_cwd():\n659             p = local(\"samplefile\")\n660             assert p.check()\n661 \n662     def test_tilde_expansion(self, monkeypatch, tmpdir):\n663         monkeypatch.setenv(\"HOME\", str(tmpdir))\n664         p = local(\"~\", expanduser=True)\n665         assert p == os.path.expanduser(\"~\")\n666 \n667     @pytest.mark.skipif(\n668         not sys.platform.startswith(\"win32\"), reason=\"case insensitive only on windows\"\n669     )\n670     def test_eq_hash_are_case_insensitive_on_windows(self):\n671         a = local(\"/some/path\")\n672         b = local(\"/some/PATH\")\n673         assert a == b\n674         assert hash(a) == hash(b)\n675         assert a in {b}\n676         assert a in {b: \"b\"}\n677 \n678     def test_eq_with_strings(self, path1):\n679         path1 = path1.join(\"sampledir\")\n680         path2 = str(path1)\n681         assert path1 == path2\n682         assert path2 == path1\n683         path3 = path1.join(\"samplefile\")\n684         assert path3 != path2\n685         assert path2 != path3\n686 \n687     def test_eq_with_none(self, path1):\n688         assert path1 != None  # noqa: E711\n689 \n690     def test_eq_non_ascii_unicode(self, path1):\n691         path2 = path1.join(\"temp\")\n692         path3 = path1.join(\"a\u00e7\u00e3o\")\n693         path4 = path1.join(\"\u30c7\u30a3\u30ec\u30af\u30c8\u30ea\")\n694 \n695         assert path2 != path3\n696         assert path2 != path4\n697         assert path4 != path3\n698 \n699     def test_gt_with_strings(self, path1):\n700         path2 = path1.join(\"sampledir\")\n701         path3 = str(path1.join(\"ttt\"))\n702         assert path3 > path2\n703         assert path2 < path3\n704         assert path2 < \"ttt\"\n705         assert \"ttt\" > path2\n706         path4 = path1.join(\"aaa\")\n707         lst = [path2, path4, path3]\n708         assert sorted(lst) == [path4, path2, path3]\n709 \n710     def test_open_and_ensure(self, path1):\n711         p = path1.join(\"sub1\", \"sub2\", \"file\")\n712         with p.open(\"w\", ensure=1, encoding=\"utf-8\") as f:\n713             f.write(\"hello\")\n714         assert p.read_text(encoding=\"utf-8\") == \"hello\"\n715 \n716     def test_write_and_ensure(self, path1):\n717         p = path1.join(\"sub1\", \"sub2\", \"file\")\n718         p.write_text(\"hello\", ensure=1, encoding=\"utf-8\")\n719         assert p.read_text(encoding=\"utf-8\") == \"hello\"\n720 \n721     @pytest.mark.parametrize(\"bin\", (False, True))\n722     def test_dump(self, tmpdir, bin):\n723         path = tmpdir.join(\"dumpfile%s\" % int(bin))\n724         try:\n725             d = {\"answer\": 42}\n726             path.dump(d, bin=bin)\n727             f = path.open(\"rb+\")\n728             import pickle\n729 \n730             dnew = pickle.load(f)\n731             assert d == dnew\n732         finally:\n733             f.close()\n734 \n735     def test_setmtime(self):\n736         import tempfile\n737         import time\n738 \n739         try:\n740             fd, name = tempfile.mkstemp()\n741             os.close(fd)\n742         except AttributeError:\n743             name = tempfile.mktemp()\n744             open(name, \"w\").close()\n745         try:\n746             mtime = int(time.time()) - 100\n747             path = local(name)\n748             assert path.mtime() != mtime\n749             path.setmtime(mtime)\n750             assert path.mtime() == mtime\n751             path.setmtime()\n752             assert path.mtime() != mtime\n753         finally:\n754             os.remove(name)\n755 \n756     def test_normpath(self, path1):\n757         new1 = path1.join(\"/otherdir\")\n758         new2 = path1.join(\"otherdir\")\n759         assert str(new1) == str(new2)\n760 \n761     def test_mkdtemp_creation(self):\n762         d = local.mkdtemp()\n763         try:\n764             assert d.check(dir=1)\n765         finally:\n766             d.remove(rec=1)\n767 \n768     def test_tmproot(self):\n769         d = local.mkdtemp()\n770         tmproot = local.get_temproot()\n771         try:\n772             assert d.check(dir=1)\n773             assert d.dirpath() == tmproot\n774         finally:\n775             d.remove(rec=1)\n776 \n777     def test_chdir(self, tmpdir):\n778         old = local()\n779         try:\n780             res = tmpdir.chdir()\n781             assert str(res) == str(old)\n782             assert os.getcwd() == str(tmpdir)\n783         finally:\n784             old.chdir()\n785 \n786     def test_ensure_filepath_withdir(self, tmpdir):\n787         newfile = tmpdir.join(\"test1\", \"test\")\n788         newfile.ensure()\n789         assert newfile.check(file=1)\n790         newfile.write_text(\"42\", encoding=\"utf-8\")\n791         newfile.ensure()\n792         s = newfile.read_text(encoding=\"utf-8\")\n793         assert s == \"42\"\n794 \n795     def test_ensure_filepath_withoutdir(self, tmpdir):\n796         newfile = tmpdir.join(\"test1file\")\n797         t = newfile.ensure()\n798         assert t == newfile\n799         assert newfile.check(file=1)\n800 \n801     def test_ensure_dirpath(self, tmpdir):\n802         newfile = tmpdir.join(\"test1\", \"testfile\")\n803         t = newfile.ensure(dir=1)\n804         assert t == newfile\n805         assert newfile.check(dir=1)\n806 \n807     def test_ensure_non_ascii_unicode(self, tmpdir):\n808         newfile = tmpdir.join(\"a\u00e7\u00e3o\", \"\u30c7\u30a3\u30ec\u30af\u30c8\u30ea\")\n809         t = newfile.ensure(dir=1)\n810         assert t == newfile\n811         assert newfile.check(dir=1)\n812 \n813     @pytest.mark.xfail(run=False, reason=\"unreliable est for long filenames\")\n814     def test_long_filenames(self, tmpdir):\n815         if sys.platform == \"win32\":\n816             pytest.skip(\"win32: work around needed for path length limit\")\n817         # see http://codespeak.net/pipermail/py-dev/2008q2/000922.html\n818 \n819         # testing paths > 260 chars (which is Windows' limitation, but\n820         # depending on how the paths are used), but > 4096 (which is the\n821         # Linux' limitation) - the behaviour of paths with names > 4096 chars\n822         # is undetermined\n823         newfilename = \"/test\" * 60  # type:ignore[unreachable]\n824         l1 = tmpdir.join(newfilename)\n825         l1.ensure(file=True)\n826         l1.write_text(\"foo\", encoding=\"utf-8\")\n827         l2 = tmpdir.join(newfilename)\n828         assert l2.read_text(encoding=\"utf-8\") == \"foo\"\n829 \n830     def test_visit_depth_first(self, tmpdir):\n831         tmpdir.ensure(\"a\", \"1\")\n832         tmpdir.ensure(\"b\", \"2\")\n833         p3 = tmpdir.ensure(\"breadth\")\n834         lst = list(tmpdir.visit(lambda x: x.check(file=1)))\n835         assert len(lst) == 3\n836         # check that breadth comes last\n837         assert lst[2] == p3\n838 \n839     def test_visit_rec_fnmatch(self, tmpdir):\n840         p1 = tmpdir.ensure(\"a\", \"123\")\n841         tmpdir.ensure(\".b\", \"345\")\n842         lst = list(tmpdir.visit(\"???\", rec=\"[!.]*\"))\n843         assert len(lst) == 1\n844         # check that breadth comes last\n845         assert lst[0] == p1\n846 \n847     def test_fnmatch_file_abspath(self, tmpdir):\n848         b = tmpdir.join(\"a\", \"b\")\n849         assert b.fnmatch(os.sep.join(\"ab\"))\n850         pattern = os.sep.join([str(tmpdir), \"*\", \"b\"])\n851         assert b.fnmatch(pattern)\n852 \n853     def test_sysfind(self):\n854         name = sys.platform == \"win32\" and \"cmd\" or \"test\"\n855         x = local.sysfind(name)\n856         assert x.check(file=1)\n857         assert local.sysfind(\"jaksdkasldqwe\") is None\n858         assert local.sysfind(name, paths=[]) is None\n859         x2 = local.sysfind(name, paths=[x.dirpath()])\n860         assert x2 == x\n861 \n862     def test_fspath_protocol_other_class(self, fake_fspath_obj):\n863         # py.path is always absolute\n864         py_path = local(fake_fspath_obj)\n865         str_path = fake_fspath_obj.__fspath__()\n866         assert py_path.check(endswith=str_path)\n867         assert py_path.join(fake_fspath_obj).strpath == os.path.join(\n868             py_path.strpath, str_path\n869         )\n870 \n871     def test_make_numbered_dir_multiprocess_safe(self, tmpdir):\n872         # https://github.com/pytest-dev/py/issues/30\n873         with multiprocessing.Pool() as pool:\n874             results = [\n875                 pool.apply_async(batch_make_numbered_dirs, [tmpdir, 100])\n876                 for _ in range(20)\n877             ]\n878             for r in results:\n879                 assert r.get()\n880 \n881 \n882 class TestExecutionOnWindows:\n883     pytestmark = win32only\n884 \n885     def test_sysfind_bat_exe_before(self, tmpdir, monkeypatch):\n886         monkeypatch.setenv(\"PATH\", str(tmpdir), prepend=os.pathsep)\n887         tmpdir.ensure(\"hello\")\n888         h = tmpdir.ensure(\"hello.bat\")\n889         x = local.sysfind(\"hello\")\n890         assert x == h\n891 \n892 \n893 class TestExecution:\n894     pytestmark = skiponwin32\n895 \n896     def test_sysfind_no_permisson_ignored(self, monkeypatch, tmpdir):\n897         noperm = tmpdir.ensure(\"noperm\", dir=True)\n898         monkeypatch.setenv(\"PATH\", str(noperm), prepend=\":\")\n899         noperm.chmod(0)\n900         try:\n901             assert local.sysfind(\"jaksdkasldqwe\") is None\n902         finally:\n903             noperm.chmod(0o644)\n904 \n905     def test_sysfind_absolute(self):\n906         x = local.sysfind(\"test\")\n907         assert x.check(file=1)\n908         y = local.sysfind(str(x))\n909         assert y.check(file=1)\n910         assert y == x\n911 \n912     def test_sysfind_multiple(self, tmpdir, monkeypatch):\n913         monkeypatch.setenv(\n914             \"PATH\", \"{}:{}\".format(tmpdir.ensure(\"a\"), tmpdir.join(\"b\")), prepend=\":\"\n915         )\n916         tmpdir.ensure(\"b\", \"a\")\n917         x = local.sysfind(\"a\", checker=lambda x: x.dirpath().basename == \"b\")\n918         assert x.basename == \"a\"\n919         assert x.dirpath().basename == \"b\"\n920         assert local.sysfind(\"a\", checker=lambda x: None) is None\n921 \n922     def test_sysexec(self):\n923         x = local.sysfind(\"ls\")\n924         out = x.sysexec(\"-a\")\n925         for x in local().listdir():\n926             assert out.find(x.basename) != -1\n927 \n928     def test_sysexec_failing(self):\n929         try:\n930             from py._process.cmdexec import ExecutionFailed  # py library\n931         except ImportError:\n932             ExecutionFailed = RuntimeError  # py vendored\n933         x = local.sysfind(\"false\")\n934         with pytest.raises(ExecutionFailed):\n935             x.sysexec(\"aksjdkasjd\")\n936 \n937     def test_make_numbered_dir(self, tmpdir):\n938         tmpdir.ensure(\"base.not_an_int\", dir=1)\n939         for i in range(10):\n940             numdir = local.make_numbered_dir(\n941                 prefix=\"base.\", rootdir=tmpdir, keep=2, lock_timeout=0\n942             )\n943             assert numdir.check()\n944             assert numdir.basename == \"base.%d\" % i\n945             if i >= 1:\n946                 assert numdir.new(ext=str(i - 1)).check()\n947             if i >= 2:\n948                 assert numdir.new(ext=str(i - 2)).check()\n949             if i >= 3:\n950                 assert not numdir.new(ext=str(i - 3)).check()\n951 \n952     def test_make_numbered_dir_case(self, tmpdir):\n953         \"\"\"make_numbered_dir does not make assumptions on the underlying\n954         filesystem based on the platform and will assume it _could_ be case\n955         insensitive.\n956 \n957         See issues:\n958         - https://github.com/pytest-dev/pytest/issues/708\n959         - https://github.com/pytest-dev/pytest/issues/3451\n960         \"\"\"\n961         d1 = local.make_numbered_dir(\n962             prefix=\"CAse.\",\n963             rootdir=tmpdir,\n964             keep=2,\n965             lock_timeout=0,\n966         )\n967         d2 = local.make_numbered_dir(\n968             prefix=\"caSE.\",\n969             rootdir=tmpdir,\n970             keep=2,\n971             lock_timeout=0,\n972         )\n973         assert str(d1).lower() != str(d2).lower()\n974         assert str(d2).endswith(\".1\")\n975 \n976     def test_make_numbered_dir_NotImplemented_Error(self, tmpdir, monkeypatch):\n977         def notimpl(x, y):\n978             raise NotImplementedError(42)\n979 \n980         monkeypatch.setattr(os, \"symlink\", notimpl)\n981         x = tmpdir.make_numbered_dir(rootdir=tmpdir, lock_timeout=0)\n982         assert x.relto(tmpdir)\n983         assert x.check()\n984 \n985     def test_locked_make_numbered_dir(self, tmpdir):\n986         for i in range(10):\n987             numdir = local.make_numbered_dir(prefix=\"base2.\", rootdir=tmpdir, keep=2)\n988             assert numdir.check()\n989             assert numdir.basename == \"base2.%d\" % i\n990             for j in range(i):\n991                 assert numdir.new(ext=str(j)).check()\n992 \n993     def test_error_preservation(self, path1):\n994         pytest.raises(EnvironmentError, path1.join(\"qwoeqiwe\").mtime)\n995         pytest.raises(EnvironmentError, path1.join(\"qwoeqiwe\").read)\n996 \n997     # def test_parentdirmatch(self):\n998     #    local.parentdirmatch('std', startmodule=__name__)\n999     #\n1000 \n1001 \n1002 class TestImport:\n1003     @pytest.fixture(autouse=True)\n1004     def preserve_sys(self):\n1005         with mock.patch.dict(sys.modules):\n1006             with mock.patch.object(sys, \"path\", list(sys.path)):\n1007                 yield\n1008 \n1009     def test_pyimport(self, path1):\n1010         obj = path1.join(\"execfile.py\").pyimport()\n1011         assert obj.x == 42\n1012         assert obj.__name__ == \"execfile\"\n1013 \n1014     def test_pyimport_renamed_dir_creates_mismatch(self, tmpdir, monkeypatch):\n1015         p = tmpdir.ensure(\"a\", \"test_x123.py\")\n1016         p.pyimport()\n1017         tmpdir.join(\"a\").move(tmpdir.join(\"b\"))\n1018         with pytest.raises(tmpdir.ImportMismatchError):\n1019             tmpdir.join(\"b\", \"test_x123.py\").pyimport()\n1020 \n1021         # Errors can be ignored.\n1022         monkeypatch.setenv(\"PY_IGNORE_IMPORTMISMATCH\", \"1\")\n1023         tmpdir.join(\"b\", \"test_x123.py\").pyimport()\n1024 \n1025         # PY_IGNORE_IMPORTMISMATCH=0 does not ignore error.\n1026         monkeypatch.setenv(\"PY_IGNORE_IMPORTMISMATCH\", \"0\")\n1027         with pytest.raises(tmpdir.ImportMismatchError):\n1028             tmpdir.join(\"b\", \"test_x123.py\").pyimport()\n1029 \n1030     def test_pyimport_messy_name(self, tmpdir):\n1031         # http://bitbucket.org/hpk42/py-trunk/issue/129\n1032         path = tmpdir.ensure(\"foo__init__.py\")\n1033         path.pyimport()\n1034 \n1035     def test_pyimport_dir(self, tmpdir):\n1036         p = tmpdir.join(\"hello_123\")\n1037         p_init = p.ensure(\"__init__.py\")\n1038         m = p.pyimport()\n1039         assert m.__name__ == \"hello_123\"\n1040         m = p_init.pyimport()\n1041         assert m.__name__ == \"hello_123\"\n1042 \n1043     def test_pyimport_execfile_different_name(self, path1):\n1044         obj = path1.join(\"execfile.py\").pyimport(modname=\"0x.y.z\")\n1045         assert obj.x == 42\n1046         assert obj.__name__ == \"0x.y.z\"\n1047 \n1048     def test_pyimport_a(self, path1):\n1049         otherdir = path1.join(\"otherdir\")\n1050         mod = otherdir.join(\"a.py\").pyimport()\n1051         assert mod.result == \"got it\"\n1052         assert mod.__name__ == \"otherdir.a\"\n1053 \n1054     def test_pyimport_b(self, path1):\n1055         otherdir = path1.join(\"otherdir\")\n1056         mod = otherdir.join(\"b.py\").pyimport()\n1057         assert mod.stuff == \"got it\"\n1058         assert mod.__name__ == \"otherdir.b\"\n1059 \n1060     def test_pyimport_c(self, path1):\n1061         otherdir = path1.join(\"otherdir\")\n1062         mod = otherdir.join(\"c.py\").pyimport()\n1063         assert mod.value == \"got it\"\n1064 \n1065     def test_pyimport_d(self, path1):\n1066         otherdir = path1.join(\"otherdir\")\n1067         mod = otherdir.join(\"d.py\").pyimport()\n1068         assert mod.value2 == \"got it\"\n1069 \n1070     def test_pyimport_and_import(self, tmpdir):\n1071         tmpdir.ensure(\"xxxpackage\", \"__init__.py\")\n1072         mod1path = tmpdir.ensure(\"xxxpackage\", \"module1.py\")\n1073         mod1 = mod1path.pyimport()\n1074         assert mod1.__name__ == \"xxxpackage.module1\"\n1075         from xxxpackage import module1\n1076 \n1077         assert module1 is mod1\n1078 \n1079     def test_pyimport_check_filepath_consistency(self, monkeypatch, tmpdir):\n1080         name = \"pointsback123\"\n1081         ModuleType = type(os)\n1082         p = tmpdir.ensure(name + \".py\")\n1083         for ending in (\".pyc\", \"$py.class\", \".pyo\"):\n1084             mod = ModuleType(name)\n1085             pseudopath = tmpdir.ensure(name + ending)\n1086             mod.__file__ = str(pseudopath)\n1087             monkeypatch.setitem(sys.modules, name, mod)\n1088             newmod = p.pyimport()\n1089             assert mod == newmod\n1090         monkeypatch.undo()\n1091         mod = ModuleType(name)\n1092         pseudopath = tmpdir.ensure(name + \"123.py\")\n1093         mod.__file__ = str(pseudopath)\n1094         monkeypatch.setitem(sys.modules, name, mod)\n1095         excinfo = pytest.raises(pseudopath.ImportMismatchError, p.pyimport)\n1096         modname, modfile, orig = excinfo.value.args\n1097         assert modname == name\n1098         assert modfile == pseudopath\n1099         assert orig == p\n1100         assert issubclass(pseudopath.ImportMismatchError, ImportError)\n1101 \n1102     def test_issue131_pyimport_on__init__(self, tmpdir):\n1103         # __init__.py files may be namespace packages, and thus the\n1104         # __file__ of an imported module may not be ourselves\n1105         # see issue\n1106         p1 = tmpdir.ensure(\"proja\", \"__init__.py\")\n1107         p2 = tmpdir.ensure(\"sub\", \"proja\", \"__init__.py\")\n1108         m1 = p1.pyimport()\n1109         m2 = p2.pyimport()\n1110         assert m1 == m2\n1111 \n1112     def test_ensuresyspath_append(self, tmpdir):\n1113         root1 = tmpdir.mkdir(\"root1\")\n1114         file1 = root1.ensure(\"x123.py\")\n1115         assert str(root1) not in sys.path\n1116         file1.pyimport(ensuresyspath=\"append\")\n1117         assert str(root1) == sys.path[-1]\n1118         assert str(root1) not in sys.path[:-1]\n1119 \n1120 \n1121 class TestImportlibImport:\n1122     OPTS = {\"ensuresyspath\": \"importlib\"}\n1123 \n1124     def test_pyimport(self, path1):\n1125         obj = path1.join(\"execfile.py\").pyimport(**self.OPTS)\n1126         assert obj.x == 42\n1127         assert obj.__name__ == \"execfile\"\n1128 \n1129     def test_pyimport_dir_fails(self, tmpdir):\n1130         p = tmpdir.join(\"hello_123\")\n1131         p.ensure(\"__init__.py\")\n1132         with pytest.raises(ImportError):\n1133             p.pyimport(**self.OPTS)\n1134 \n1135     def test_pyimport_execfile_different_name(self, path1):\n1136         obj = path1.join(\"execfile.py\").pyimport(modname=\"0x.y.z\", **self.OPTS)\n1137         assert obj.x == 42\n1138         assert obj.__name__ == \"0x.y.z\"\n1139 \n1140     def test_pyimport_relative_import_fails(self, path1):\n1141         otherdir = path1.join(\"otherdir\")\n1142         with pytest.raises(ImportError):\n1143             otherdir.join(\"a.py\").pyimport(**self.OPTS)\n1144 \n1145     def test_pyimport_doesnt_use_sys_modules(self, tmpdir):\n1146         p = tmpdir.ensure(\"file738jsk.py\")\n1147         mod = p.pyimport(**self.OPTS)\n1148         assert mod.__name__ == \"file738jsk\"\n1149         assert \"file738jsk\" not in sys.modules\n1150 \n1151 \n1152 def test_pypkgdir(tmpdir):\n1153     pkg = tmpdir.ensure(\"pkg1\", dir=1)\n1154     pkg.ensure(\"__init__.py\")\n1155     pkg.ensure(\"subdir/__init__.py\")\n1156     assert pkg.pypkgpath() == pkg\n1157     assert pkg.join(\"subdir\", \"__init__.py\").pypkgpath() == pkg\n1158 \n1159 \n1160 def test_pypkgdir_unimportable(tmpdir):\n1161     pkg = tmpdir.ensure(\"pkg1-1\", dir=1)  # unimportable\n1162     pkg.ensure(\"__init__.py\")\n1163     subdir = pkg.ensure(\"subdir/__init__.py\").dirpath()\n1164     assert subdir.pypkgpath() == subdir\n1165     assert subdir.ensure(\"xyz.py\").pypkgpath() == subdir\n1166     assert not pkg.pypkgpath()\n1167 \n1168 \n1169 def test_isimportable():\n1170     try:\n1171         from py.path import isimportable  # py vendored version\n1172     except ImportError:\n1173         from py._path.local import isimportable  # py library\n1174 \n1175     assert not isimportable(\"\")\n1176     assert isimportable(\"x\")\n1177     assert isimportable(\"x1\")\n1178     assert isimportable(\"x_1\")\n1179     assert isimportable(\"_\")\n1180     assert isimportable(\"_1\")\n1181     assert not isimportable(\"x-1\")\n1182     assert not isimportable(\"x:1\")\n1183 \n1184 \n1185 def test_homedir_from_HOME(monkeypatch):\n1186     path = os.getcwd()\n1187     monkeypatch.setenv(\"HOME\", path)\n1188     assert local._gethomedir() == local(path)\n1189 \n1190 \n1191 def test_homedir_not_exists(monkeypatch):\n1192     monkeypatch.delenv(\"HOME\", raising=False)\n1193     monkeypatch.delenv(\"HOMEDRIVE\", raising=False)\n1194     homedir = local._gethomedir()\n1195     assert homedir is None\n1196 \n1197 \n1198 def test_samefile(tmpdir):\n1199     assert tmpdir.samefile(tmpdir)\n1200     p = tmpdir.ensure(\"hello\")\n1201     assert p.samefile(p)\n1202     with p.dirpath().as_cwd():\n1203         assert p.samefile(p.basename)\n1204     if sys.platform == \"win32\":\n1205         p1 = p.__class__(str(p).lower())\n1206         p2 = p.__class__(str(p).upper())\n1207         assert p1.samefile(p2)\n1208 \n1209 \n1210 @pytest.mark.skipif(not hasattr(os, \"symlink\"), reason=\"os.symlink not available\")\n1211 def test_samefile_symlink(tmpdir):\n1212     p1 = tmpdir.ensure(\"foo.txt\")\n1213     p2 = tmpdir.join(\"linked.txt\")\n1214     try:\n1215         os.symlink(str(p1), str(p2))\n1216     except (OSError, NotImplementedError) as e:\n1217         # on Windows this might fail if the user doesn't have special symlink permissions\n1218         # pypy3 on Windows doesn't implement os.symlink and raises NotImplementedError\n1219         pytest.skip(str(e.args[0]))\n1220 \n1221     assert p1.samefile(p2)\n1222 \n1223 \n1224 def test_listdir_single_arg(tmpdir):\n1225     tmpdir.ensure(\"hello\")\n1226     assert tmpdir.listdir(\"hello\")[0].basename == \"hello\"\n1227 \n1228 \n1229 def test_mkdtemp_rootdir(tmpdir):\n1230     dtmp = local.mkdtemp(rootdir=tmpdir)\n1231     assert tmpdir.listdir() == [dtmp]\n1232 \n1233 \n1234 class TestWINLocalPath:\n1235     pytestmark = win32only\n1236 \n1237     def test_owner_group_not_implemented(self, path1):\n1238         with pytest.raises(NotImplementedError):\n1239             path1.stat().owner\n1240         with pytest.raises(NotImplementedError):\n1241             path1.stat().group\n1242 \n1243     def test_chmod_simple_int(self, path1):\n1244         mode = path1.stat().mode\n1245         # Ensure that we actually change the mode to something different.\n1246         path1.chmod(mode == 0 and 1 or 0)\n1247         try:\n1248             print(path1.stat().mode)\n1249             print(mode)\n1250             assert path1.stat().mode != mode\n1251         finally:\n1252             path1.chmod(mode)\n1253             assert path1.stat().mode == mode\n1254 \n1255     def test_path_comparison_lowercase_mixed(self, path1):\n1256         t1 = path1.join(\"a_path\")\n1257         t2 = path1.join(\"A_path\")\n1258         assert t1 == t1\n1259         assert t1 == t2\n1260 \n1261     def test_relto_with_mixed_case(self, path1):\n1262         t1 = path1.join(\"a_path\", \"fiLe\")\n1263         t2 = path1.join(\"A_path\")\n1264         assert t1.relto(t2) == \"fiLe\"\n1265 \n1266     def test_allow_unix_style_paths(self, path1):\n1267         t1 = path1.join(\"a_path\")\n1268         assert t1 == str(path1) + \"\\\\a_path\"\n1269         t1 = path1.join(\"a_path/\")\n1270         assert t1 == str(path1) + \"\\\\a_path\"\n1271         t1 = path1.join(\"dir/a_path\")\n1272         assert t1 == str(path1) + \"\\\\dir\\\\a_path\"\n1273 \n1274     def test_sysfind_in_currentdir(self, path1):\n1275         cmd = local.sysfind(\"cmd\")\n1276         root = cmd.new(dirname=\"\", basename=\"\")  # c:\\ in most installations\n1277         with root.as_cwd():\n1278             x = local.sysfind(cmd.relto(root))\n1279             assert x.check(file=1)\n1280 \n1281     def test_fnmatch_file_abspath_posix_pattern_on_win32(self, tmpdir):\n1282         # path-matching patterns might contain a posix path separator '/'\n1283         # Test that we can match that pattern on windows.\n1284         import posixpath\n1285 \n1286         b = tmpdir.join(\"a\", \"b\")\n1287         assert b.fnmatch(posixpath.sep.join(\"ab\"))\n1288         pattern = posixpath.sep.join([str(tmpdir), \"*\", \"b\"])\n1289         assert b.fnmatch(pattern)\n1290 \n1291 \n1292 class TestPOSIXLocalPath:\n1293     pytestmark = skiponwin32\n1294 \n1295     def test_hardlink(self, tmpdir):\n1296         linkpath = tmpdir.join(\"test\")\n1297         filepath = tmpdir.join(\"file\")\n1298         filepath.write_text(\"Hello\", encoding=\"utf-8\")\n1299         nlink = filepath.stat().nlink\n1300         linkpath.mklinkto(filepath)\n1301         assert filepath.stat().nlink == nlink + 1\n1302 \n1303     def test_symlink_are_identical(self, tmpdir):\n1304         filepath = tmpdir.join(\"file\")\n1305         filepath.write_text(\"Hello\", encoding=\"utf-8\")\n1306         linkpath = tmpdir.join(\"test\")\n1307         linkpath.mksymlinkto(filepath)\n1308         assert linkpath.readlink() == str(filepath)\n1309 \n1310     def test_symlink_isfile(self, tmpdir):\n1311         linkpath = tmpdir.join(\"test\")\n1312         filepath = tmpdir.join(\"file\")\n1313         filepath.write_text(\"\", encoding=\"utf-8\")\n1314         linkpath.mksymlinkto(filepath)\n1315         assert linkpath.check(file=1)\n1316         assert not linkpath.check(link=0, file=1)\n1317         assert linkpath.islink()\n1318 \n1319     def test_symlink_relative(self, tmpdir):\n1320         linkpath = tmpdir.join(\"test\")\n1321         filepath = tmpdir.join(\"file\")\n1322         filepath.write_text(\"Hello\", encoding=\"utf-8\")\n1323         linkpath.mksymlinkto(filepath, absolute=False)\n1324         assert linkpath.readlink() == \"file\"\n1325         assert filepath.read_text(encoding=\"utf-8\") == linkpath.read_text(\n1326             encoding=\"utf-8\"\n1327         )\n1328 \n1329     def test_symlink_not_existing(self, tmpdir):\n1330         linkpath = tmpdir.join(\"testnotexisting\")\n1331         assert not linkpath.check(link=1)\n1332         assert linkpath.check(link=0)\n1333 \n1334     def test_relto_with_root(self, path1, tmpdir):\n1335         y = path1.join(\"x\").relto(local(\"/\"))\n1336         assert y[0] == str(path1)[1]\n1337 \n1338     def test_visit_recursive_symlink(self, tmpdir):\n1339         linkpath = tmpdir.join(\"test\")\n1340         linkpath.mksymlinkto(tmpdir)\n1341         visitor = tmpdir.visit(None, lambda x: x.check(link=0))\n1342         assert list(visitor) == [linkpath]\n1343 \n1344     def test_symlink_isdir(self, tmpdir):\n1345         linkpath = tmpdir.join(\"test\")\n1346         linkpath.mksymlinkto(tmpdir)\n1347         assert linkpath.check(dir=1)\n1348         assert not linkpath.check(link=0, dir=1)\n1349 \n1350     def test_symlink_remove(self, tmpdir):\n1351         linkpath = tmpdir.join(\"test\")\n1352         linkpath.mksymlinkto(linkpath)  # point to itself\n1353         assert linkpath.check(link=1)\n1354         linkpath.remove()\n1355         assert not linkpath.check()\n1356 \n1357     def test_realpath_file(self, tmpdir):\n1358         linkpath = tmpdir.join(\"test\")\n1359         filepath = tmpdir.join(\"file\")\n1360         filepath.write_text(\"\", encoding=\"utf-8\")\n1361         linkpath.mksymlinkto(filepath)\n1362         realpath = linkpath.realpath()\n1363         assert realpath.basename == \"file\"\n1364 \n1365     def test_owner(self, path1, tmpdir):\n1366         from pwd import getpwuid  # type:ignore[attr-defined]\n1367         from grp import getgrgid  # type:ignore[attr-defined]\n1368 \n1369         stat = path1.stat()\n1370         assert stat.path == path1\n1371 \n1372         uid = stat.uid\n1373         gid = stat.gid\n1374         owner = getpwuid(uid)[0]\n1375         group = getgrgid(gid)[0]\n1376 \n1377         assert uid == stat.uid\n1378         assert owner == stat.owner\n1379         assert gid == stat.gid\n1380         assert group == stat.group\n1381 \n1382     def test_stat_helpers(self, tmpdir, monkeypatch):\n1383         path1 = tmpdir.ensure(\"file\")\n1384         stat1 = path1.stat()\n1385         stat2 = tmpdir.stat()\n1386         assert stat1.isfile()\n1387         assert stat2.isdir()\n1388         assert not stat1.islink()\n1389         assert not stat2.islink()\n1390 \n1391     def test_stat_non_raising(self, tmpdir):\n1392         path1 = tmpdir.join(\"file\")\n1393         pytest.raises(error.ENOENT, lambda: path1.stat())\n1394         res = path1.stat(raising=False)\n1395         assert res is None\n1396 \n1397     def test_atime(self, tmpdir):\n1398         import time\n1399 \n1400         path = tmpdir.ensure(\"samplefile\")\n1401         now = time.time()\n1402         atime1 = path.atime()\n1403         # we could wait here but timer resolution is very\n1404         # system dependent\n1405         path.read_binary()\n1406         time.sleep(ATIME_RESOLUTION)\n1407         atime2 = path.atime()\n1408         time.sleep(ATIME_RESOLUTION)\n1409         duration = time.time() - now\n1410         assert (atime2 - atime1) <= duration\n1411 \n1412     def test_commondir(self, path1):\n1413         # XXX This is here in local until we find a way to implement this\n1414         #     using the subversion command line api.\n1415         p1 = path1.join(\"something\")\n1416         p2 = path1.join(\"otherthing\")\n1417         assert p1.common(p2) == path1\n1418         assert p2.common(p1) == path1\n1419 \n1420     def test_commondir_nocommon(self, path1):\n1421         # XXX This is here in local until we find a way to implement this\n1422         #     using the subversion command line api.\n1423         p1 = path1.join(\"something\")\n1424         p2 = local(path1.sep + \"blabla\")\n1425         assert p1.common(p2) == \"/\"\n1426 \n1427     def test_join_to_root(self, path1):\n1428         root = path1.parts()[0]\n1429         assert len(str(root)) == 1\n1430         assert str(root.join(\"a\")) == \"/a\"\n1431 \n1432     def test_join_root_to_root_with_no_abs(self, path1):\n1433         nroot = path1.join(\"/\")\n1434         assert str(path1) == str(nroot)\n1435         assert path1 == nroot\n1436 \n1437     def test_chmod_simple_int(self, path1):\n1438         mode = path1.stat().mode\n1439         path1.chmod(int(mode / 2))\n1440         try:\n1441             assert path1.stat().mode != mode\n1442         finally:\n1443             path1.chmod(mode)\n1444             assert path1.stat().mode == mode\n1445 \n1446     def test_chmod_rec_int(self, path1):\n1447         # XXX fragile test\n1448         def recfilter(x):\n1449             return x.check(dotfile=0, link=0)\n1450 \n1451         oldmodes = {}\n1452         for x in path1.visit(rec=recfilter):\n1453             oldmodes[x] = x.stat().mode\n1454         path1.chmod(int(\"772\", 8), rec=recfilter)\n1455         try:\n1456             for x in path1.visit(rec=recfilter):\n1457                 assert x.stat().mode & int(\"777\", 8) == int(\"772\", 8)\n1458         finally:\n1459             for x, y in oldmodes.items():\n1460                 x.chmod(y)\n1461 \n1462     def test_copy_archiving(self, tmpdir):\n1463         unicode_fn = \"something-\\342\\200\\223.txt\"\n1464         f = tmpdir.ensure(\"a\", unicode_fn)\n1465         a = f.dirpath()\n1466         oldmode = f.stat().mode\n1467         newmode = oldmode ^ 1\n1468         f.chmod(newmode)\n1469         b = tmpdir.join(\"b\")\n1470         a.copy(b, mode=True)\n1471         assert b.join(f.basename).stat().mode == newmode\n1472 \n1473     def test_copy_stat_file(self, tmpdir):\n1474         src = tmpdir.ensure(\"src\")\n1475         dst = tmpdir.join(\"dst\")\n1476         # a small delay before the copy\n1477         time.sleep(ATIME_RESOLUTION)\n1478         src.copy(dst, stat=True)\n1479         oldstat = src.stat()\n1480         newstat = dst.stat()\n1481         assert oldstat.mode == newstat.mode\n1482         assert (dst.atime() - src.atime()) < ATIME_RESOLUTION\n1483         assert (dst.mtime() - src.mtime()) < ATIME_RESOLUTION\n1484 \n1485     def test_copy_stat_dir(self, tmpdir):\n1486         test_files = [\"a\", \"b\", \"c\"]\n1487         src = tmpdir.join(\"src\")\n1488         for f in test_files:\n1489             src.join(f).write_text(f, ensure=True, encoding=\"utf-8\")\n1490         dst = tmpdir.join(\"dst\")\n1491         # a small delay before the copy\n1492         time.sleep(ATIME_RESOLUTION)\n1493         src.copy(dst, stat=True)\n1494         for f in test_files:\n1495             oldstat = src.join(f).stat()\n1496             newstat = dst.join(f).stat()\n1497             assert (newstat.atime - oldstat.atime) < ATIME_RESOLUTION\n1498             assert (newstat.mtime - oldstat.mtime) < ATIME_RESOLUTION\n1499             assert oldstat.mode == newstat.mode\n1500 \n1501     def test_chown_identity(self, path1):\n1502         owner = path1.stat().owner\n1503         group = path1.stat().group\n1504         path1.chown(owner, group)\n1505 \n1506     def test_chown_dangling_link(self, path1):\n1507         owner = path1.stat().owner\n1508         group = path1.stat().group\n1509         x = path1.join(\"hello\")\n1510         x.mksymlinkto(\"qlwkejqwlek\")\n1511         try:\n1512             path1.chown(owner, group, rec=1)\n1513         finally:\n1514             x.remove(rec=0)\n1515 \n1516     def test_chown_identity_rec_mayfail(self, path1):\n1517         owner = path1.stat().owner\n1518         group = path1.stat().group\n1519         path1.chown(owner, group)\n1520 \n1521 \n1522 class TestUnicodePy2Py3:\n1523     def test_join_ensure(self, tmpdir, monkeypatch):\n1524         if sys.version_info >= (3, 0) and \"LANG\" not in os.environ:\n1525             pytest.skip(\"cannot run test without locale\")\n1526         x = local(tmpdir.strpath)\n1527         part = \"h\u00e4llo\"\n1528         y = x.ensure(part)\n1529         assert x.join(part) == y\n1530 \n1531     def test_listdir(self, tmpdir):\n1532         if sys.version_info >= (3, 0) and \"LANG\" not in os.environ:\n1533             pytest.skip(\"cannot run test without locale\")\n1534         x = local(tmpdir.strpath)\n1535         part = \"h\u00e4llo\"\n1536         y = x.ensure(part)\n1537         assert x.listdir(part)[0] == y\n1538 \n1539     @pytest.mark.xfail(reason=\"changing read/write might break existing usages\")\n1540     def test_read_write(self, tmpdir):\n1541         x = tmpdir.join(\"hello\")\n1542         part = \"h\u00e4llo\"\n1543         with ignore_encoding_warning():\n1544             x.write(part)\n1545             assert x.read() == part\n1546             x.write(part.encode(sys.getdefaultencoding()))\n1547             assert x.read() == part.encode(sys.getdefaultencoding())\n1548 \n1549 \n1550 class TestBinaryAndTextMethods:\n1551     def test_read_binwrite(self, tmpdir):\n1552         x = tmpdir.join(\"hello\")\n1553         part = \"h\u00e4llo\"\n1554         part_utf8 = part.encode(\"utf8\")\n1555         x.write_binary(part_utf8)\n1556         assert x.read_binary() == part_utf8\n1557         s = x.read_text(encoding=\"utf8\")\n1558         assert s == part\n1559         assert isinstance(s, str)\n1560 \n1561     def test_read_textwrite(self, tmpdir):\n1562         x = tmpdir.join(\"hello\")\n1563         part = \"h\u00e4llo\"\n1564         part_utf8 = part.encode(\"utf8\")\n1565         x.write_text(part, encoding=\"utf8\")\n1566         assert x.read_binary() == part_utf8\n1567         assert x.read_text(encoding=\"utf8\") == part\n1568 \n1569     def test_default_encoding(self, tmpdir):\n1570         x = tmpdir.join(\"hello\")\n1571         # Can't use UTF8 as the default encoding (ASCII) doesn't support it\n1572         part = \"hello\"\n1573         x.write_text(part, \"ascii\")\n1574         s = x.read_text(\"ascii\")\n1575         assert s == part\n1576         assert type(s) == type(part)\n",
        "intended_behavior": "The code handling namespace packages, both in tests and possibly in the application's core logic (where similar patterns are likely to be present), should ensure consistent and correct import paths to prevent module duplication. This might involve verifying and adjusting how `importlib` is used to import modules part of a namespace package, ensuring that a single instance of each module is maintained across the application."
    },
    {
        "rel_file_path": "src/_pytest/pytester.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/pytest-dev__pytest/setup_pytest-dev__pytest__8.0/src/_pytest/pytester.py",
        "start": 1,
        "end": 1787,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\"(Disabled by default) support for testing pytest and pytest plugins.\n2 \n3 PYTEST_DONT_REWRITE\n4 \"\"\"\n5 import collections.abc\n6 import contextlib\n7 import gc\n8 import importlib\n9 import locale\n10 import os\n11 import platform\n12 import re\n13 import shutil\n14 import subprocess\n15 import sys\n16 import traceback\n17 from fnmatch import fnmatch\n18 from io import StringIO\n19 from pathlib import Path\n20 from typing import Any\n21 from typing import Callable\n22 from typing import Dict\n23 from typing import Final\n24 from typing import final\n25 from typing import Generator\n26 from typing import IO\n27 from typing import Iterable\n28 from typing import List\n29 from typing import Literal\n30 from typing import Optional\n31 from typing import overload\n32 from typing import Sequence\n33 from typing import TextIO\n34 from typing import Tuple\n35 from typing import Type\n36 from typing import TYPE_CHECKING\n37 from typing import Union\n38 from weakref import WeakKeyDictionary\n39 \n40 from iniconfig import IniConfig\n41 from iniconfig import SectionWrapper\n42 \n43 from _pytest import timing\n44 from _pytest._code import Source\n45 from _pytest.capture import _get_multicapture\n46 from _pytest.compat import NOTSET\n47 from _pytest.compat import NotSetType\n48 from _pytest.config import _PluggyPlugin\n49 from _pytest.config import Config\n50 from _pytest.config import ExitCode\n51 from _pytest.config import hookimpl\n52 from _pytest.config import main\n53 from _pytest.config import PytestPluginManager\n54 from _pytest.config.argparsing import Parser\n55 from _pytest.deprecated import check_ispytest\n56 from _pytest.fixtures import fixture\n57 from _pytest.fixtures import FixtureRequest\n58 from _pytest.main import Session\n59 from _pytest.monkeypatch import MonkeyPatch\n60 from _pytest.nodes import Collector\n61 from _pytest.nodes import Item\n62 from _pytest.outcomes import fail\n63 from _pytest.outcomes import importorskip\n64 from _pytest.outcomes import skip\n65 from _pytest.pathlib import bestrelpath\n66 from _pytest.pathlib import copytree\n67 from _pytest.pathlib import make_numbered_dir\n68 from _pytest.reports import CollectReport\n69 from _pytest.reports import TestReport\n70 from _pytest.tmpdir import TempPathFactory\n71 from _pytest.warning_types import PytestWarning\n72 \n73 if TYPE_CHECKING:\n74     import pexpect\n75 \n76 \n77 pytest_plugins = [\"pytester_assertions\"]\n78 \n79 \n80 IGNORE_PAM = [  # filenames added when obtaining details about the current user\n81     \"/var/lib/sss/mc/passwd\"\n82 ]\n83 \n84 \n85 def pytest_addoption(parser: Parser) -> None:\n86     parser.addoption(\n87         \"--lsof\",\n88         action=\"store_true\",\n89         dest=\"lsof\",\n90         default=False,\n91         help=\"Run FD checks if lsof is available\",\n92     )\n93 \n94     parser.addoption(\n95         \"--runpytest\",\n96         default=\"inprocess\",\n97         dest=\"runpytest\",\n98         choices=(\"inprocess\", \"subprocess\"),\n99         help=(\n100             \"Run pytest sub runs in tests using an 'inprocess' \"\n101             \"or 'subprocess' (python -m main) method\"\n102         ),\n103     )\n104 \n105     parser.addini(\n106         \"pytester_example_dir\", help=\"Directory to take the pytester example files from\"\n107     )\n108 \n109 \n110 def pytest_configure(config: Config) -> None:\n111     if config.getvalue(\"lsof\"):\n112         checker = LsofFdLeakChecker()\n113         if checker.matching_platform():\n114             config.pluginmanager.register(checker)\n115 \n116     config.addinivalue_line(\n117         \"markers\",\n118         \"pytester_example_path(*path_segments): join the given path \"\n119         \"segments to `pytester_example_dir` for this test.\",\n120     )\n121 \n122 \n123 class LsofFdLeakChecker:\n124     def get_open_files(self) -> List[Tuple[str, str]]:\n125         out = subprocess.run(\n126             (\"lsof\", \"-Ffn0\", \"-p\", str(os.getpid())),\n127             stdout=subprocess.PIPE,\n128             stderr=subprocess.DEVNULL,\n129             check=True,\n130             text=True,\n131             encoding=locale.getpreferredencoding(False),\n132         ).stdout\n133 \n134         def isopen(line: str) -> bool:\n135             return line.startswith(\"f\") and (\n136                 \"deleted\" not in line\n137                 and \"mem\" not in line\n138                 and \"txt\" not in line\n139                 and \"cwd\" not in line\n140             )\n141 \n142         open_files = []\n143 \n144         for line in out.split(\"\\n\"):\n145             if isopen(line):\n146                 fields = line.split(\"\\0\")\n147                 fd = fields[0][1:]\n148                 filename = fields[1][1:]\n149                 if filename in IGNORE_PAM:\n150                     continue\n151                 if filename.startswith(\"/\"):\n152                     open_files.append((fd, filename))\n153 \n154         return open_files\n155 \n156     def matching_platform(self) -> bool:\n157         try:\n158             subprocess.run((\"lsof\", \"-v\"), check=True)\n159         except (OSError, subprocess.CalledProcessError):\n160             return False\n161         else:\n162             return True\n163 \n164     @hookimpl(hookwrapper=True, tryfirst=True)\n165     def pytest_runtest_protocol(self, item: Item) -> Generator[None, None, None]:\n166         lines1 = self.get_open_files()\n167         yield\n168         if hasattr(sys, \"pypy_version_info\"):\n169             gc.collect()\n170         lines2 = self.get_open_files()\n171 \n172         new_fds = {t[0] for t in lines2} - {t[0] for t in lines1}\n173         leaked_files = [t for t in lines2 if t[0] in new_fds]\n174         if leaked_files:\n175             error = [\n176                 \"***** %s FD leakage detected\" % len(leaked_files),\n177                 *(str(f) for f in leaked_files),\n178                 \"*** Before:\",\n179                 *(str(f) for f in lines1),\n180                 \"*** After:\",\n181                 *(str(f) for f in lines2),\n182                 \"***** %s FD leakage detected\" % len(leaked_files),\n183                 \"*** function %s:%s: %s \" % item.location,\n184                 \"See issue #2366\",\n185             ]\n186             item.warn(PytestWarning(\"\\n\".join(error)))\n187 \n188 \n189 # used at least by pytest-xdist plugin\n190 \n191 \n192 @fixture\n193 def _pytest(request: FixtureRequest) -> \"PytestArg\":\n194     \"\"\"Return a helper which offers a gethookrecorder(hook) method which\n195     returns a HookRecorder instance which helps to make assertions about called\n196     hooks.\"\"\"\n197     return PytestArg(request)\n198 \n199 \n200 class PytestArg:\n201     def __init__(self, request: FixtureRequest) -> None:\n202         self._request = request\n203 \n204     def gethookrecorder(self, hook) -> \"HookRecorder\":\n205         hookrecorder = HookRecorder(hook._pm)\n206         self._request.addfinalizer(hookrecorder.finish_recording)\n207         return hookrecorder\n208 \n209 \n210 def get_public_names(values: Iterable[str]) -> List[str]:\n211     \"\"\"Only return names from iterator values without a leading underscore.\"\"\"\n212     return [x for x in values if x[0] != \"_\"]\n213 \n214 \n215 @final\n216 class RecordedHookCall:\n217     \"\"\"A recorded call to a hook.\n218 \n219     The arguments to the hook call are set as attributes.\n220     For example:\n221 \n222     .. code-block:: python\n223 \n224         calls = hook_recorder.getcalls(\"pytest_runtest_setup\")\n225         # Suppose pytest_runtest_setup was called once with `item=an_item`.\n226         assert calls[0].item is an_item\n227     \"\"\"\n228 \n229     def __init__(self, name: str, kwargs) -> None:\n230         self.__dict__.update(kwargs)\n231         self._name = name\n232 \n233     def __repr__(self) -> str:\n234         d = self.__dict__.copy()\n235         del d[\"_name\"]\n236         return f\"<RecordedHookCall {self._name!r}(**{d!r})>\"\n237 \n238     if TYPE_CHECKING:\n239         # The class has undetermined attributes, this tells mypy about it.\n240         def __getattr__(self, key: str):\n241             ...\n242 \n243 \n244 @final\n245 class HookRecorder:\n246     \"\"\"Record all hooks called in a plugin manager.\n247 \n248     Hook recorders are created by :class:`Pytester`.\n249 \n250     This wraps all the hook calls in the plugin manager, recording each call\n251     before propagating the normal calls.\n252     \"\"\"\n253 \n254     def __init__(\n255         self, pluginmanager: PytestPluginManager, *, _ispytest: bool = False\n256     ) -> None:\n257         check_ispytest(_ispytest)\n258 \n259         self._pluginmanager = pluginmanager\n260         self.calls: List[RecordedHookCall] = []\n261         self.ret: Optional[Union[int, ExitCode]] = None\n262 \n263         def before(hook_name: str, hook_impls, kwargs) -> None:\n264             self.calls.append(RecordedHookCall(hook_name, kwargs))\n265 \n266         def after(outcome, hook_name: str, hook_impls, kwargs) -> None:\n267             pass\n268 \n269         self._undo_wrapping = pluginmanager.add_hookcall_monitoring(before, after)\n270 \n271     def finish_recording(self) -> None:\n272         self._undo_wrapping()\n273 \n274     def getcalls(self, names: Union[str, Iterable[str]]) -> List[RecordedHookCall]:\n275         \"\"\"Get all recorded calls to hooks with the given names (or name).\"\"\"\n276         if isinstance(names, str):\n277             names = names.split()\n278         return [call for call in self.calls if call._name in names]\n279 \n280     def assert_contains(self, entries: Sequence[Tuple[str, str]]) -> None:\n281         __tracebackhide__ = True\n282         i = 0\n283         entries = list(entries)\n284         backlocals = sys._getframe(1).f_locals\n285         while entries:\n286             name, check = entries.pop(0)\n287             for ind, call in enumerate(self.calls[i:]):\n288                 if call._name == name:\n289                     print(\"NAMEMATCH\", name, call)\n290                     if eval(check, backlocals, call.__dict__):\n291                         print(\"CHECKERMATCH\", repr(check), \"->\", call)\n292                     else:\n293                         print(\"NOCHECKERMATCH\", repr(check), \"-\", call)\n294                         continue\n295                     i += ind + 1\n296                     break\n297                 print(\"NONAMEMATCH\", name, \"with\", call)\n298             else:\n299                 fail(f\"could not find {name!r} check {check!r}\")\n300 \n301     def popcall(self, name: str) -> RecordedHookCall:\n302         __tracebackhide__ = True\n303         for i, call in enumerate(self.calls):\n304             if call._name == name:\n305                 del self.calls[i]\n306                 return call\n307         lines = [f\"could not find call {name!r}, in:\"]\n308         lines.extend([\"  %s\" % x for x in self.calls])\n309         fail(\"\\n\".join(lines))\n310 \n311     def getcall(self, name: str) -> RecordedHookCall:\n312         values = self.getcalls(name)\n313         assert len(values) == 1, (name, values)\n314         return values[0]\n315 \n316     # functionality for test reports\n317 \n318     @overload\n319     def getreports(\n320         self,\n321         names: \"Literal['pytest_collectreport']\",\n322     ) -> Sequence[CollectReport]:\n323         ...\n324 \n325     @overload\n326     def getreports(\n327         self,\n328         names: \"Literal['pytest_runtest_logreport']\",\n329     ) -> Sequence[TestReport]:\n330         ...\n331 \n332     @overload\n333     def getreports(\n334         self,\n335         names: Union[str, Iterable[str]] = (\n336             \"pytest_collectreport\",\n337             \"pytest_runtest_logreport\",\n338         ),\n339     ) -> Sequence[Union[CollectReport, TestReport]]:\n340         ...\n341 \n342     def getreports(\n343         self,\n344         names: Union[str, Iterable[str]] = (\n345             \"pytest_collectreport\",\n346             \"pytest_runtest_logreport\",\n347         ),\n348     ) -> Sequence[Union[CollectReport, TestReport]]:\n349         return [x.report for x in self.getcalls(names)]\n350 \n351     def matchreport(\n352         self,\n353         inamepart: str = \"\",\n354         names: Union[str, Iterable[str]] = (\n355             \"pytest_runtest_logreport\",\n356             \"pytest_collectreport\",\n357         ),\n358         when: Optional[str] = None,\n359     ) -> Union[CollectReport, TestReport]:\n360         \"\"\"Return a testreport whose dotted import path matches.\"\"\"\n361         values = []\n362         for rep in self.getreports(names=names):\n363             if not when and rep.when != \"call\" and rep.passed:\n364                 # setup/teardown passing reports - let's ignore those\n365                 continue\n366             if when and rep.when != when:\n367                 continue\n368             if not inamepart or inamepart in rep.nodeid.split(\"::\"):\n369                 values.append(rep)\n370         if not values:\n371             raise ValueError(\n372                 \"could not find test report matching %r: \"\n373                 \"no test reports at all!\" % (inamepart,)\n374             )\n375         if len(values) > 1:\n376             raise ValueError(\n377                 \"found 2 or more testreports matching {!r}: {}\".format(\n378                     inamepart, values\n379                 )\n380             )\n381         return values[0]\n382 \n383     @overload\n384     def getfailures(\n385         self,\n386         names: \"Literal['pytest_collectreport']\",\n387     ) -> Sequence[CollectReport]:\n388         ...\n389 \n390     @overload\n391     def getfailures(\n392         self,\n393         names: \"Literal['pytest_runtest_logreport']\",\n394     ) -> Sequence[TestReport]:\n395         ...\n396 \n397     @overload\n398     def getfailures(\n399         self,\n400         names: Union[str, Iterable[str]] = (\n401             \"pytest_collectreport\",\n402             \"pytest_runtest_logreport\",\n403         ),\n404     ) -> Sequence[Union[CollectReport, TestReport]]:\n405         ...\n406 \n407     def getfailures(\n408         self,\n409         names: Union[str, Iterable[str]] = (\n410             \"pytest_collectreport\",\n411             \"pytest_runtest_logreport\",\n412         ),\n413     ) -> Sequence[Union[CollectReport, TestReport]]:\n414         return [rep for rep in self.getreports(names) if rep.failed]\n415 \n416     def getfailedcollections(self) -> Sequence[CollectReport]:\n417         return self.getfailures(\"pytest_collectreport\")\n418 \n419     def listoutcomes(\n420         self,\n421     ) -> Tuple[\n422         Sequence[TestReport],\n423         Sequence[Union[CollectReport, TestReport]],\n424         Sequence[Union[CollectReport, TestReport]],\n425     ]:\n426         passed = []\n427         skipped = []\n428         failed = []\n429         for rep in self.getreports(\n430             (\"pytest_collectreport\", \"pytest_runtest_logreport\")\n431         ):\n432             if rep.passed:\n433                 if rep.when == \"call\":\n434                     assert isinstance(rep, TestReport)\n435                     passed.append(rep)\n436             elif rep.skipped:\n437                 skipped.append(rep)\n438             else:\n439                 assert rep.failed, f\"Unexpected outcome: {rep!r}\"\n440                 failed.append(rep)\n441         return passed, skipped, failed\n442 \n443     def countoutcomes(self) -> List[int]:\n444         return [len(x) for x in self.listoutcomes()]\n445 \n446     def assertoutcome(self, passed: int = 0, skipped: int = 0, failed: int = 0) -> None:\n447         __tracebackhide__ = True\n448         from _pytest.pytester_assertions import assertoutcome\n449 \n450         outcomes = self.listoutcomes()\n451         assertoutcome(\n452             outcomes,\n453             passed=passed,\n454             skipped=skipped,\n455             failed=failed,\n456         )\n457 \n458     def clear(self) -> None:\n459         self.calls[:] = []\n460 \n461 \n462 @fixture\n463 def linecomp() -> \"LineComp\":\n464     \"\"\"A :class: `LineComp` instance for checking that an input linearly\n465     contains a sequence of strings.\"\"\"\n466     return LineComp()\n467 \n468 \n469 @fixture(name=\"LineMatcher\")\n470 def LineMatcher_fixture(request: FixtureRequest) -> Type[\"LineMatcher\"]:\n471     \"\"\"A reference to the :class: `LineMatcher`.\n472 \n473     This is instantiable with a list of lines (without their trailing newlines).\n474     This is useful for testing large texts, such as the output of commands.\n475     \"\"\"\n476     return LineMatcher\n477 \n478 \n479 @fixture\n480 def pytester(\n481     request: FixtureRequest, tmp_path_factory: TempPathFactory, monkeypatch: MonkeyPatch\n482 ) -> \"Pytester\":\n483     \"\"\"\n484     Facilities to write tests/configuration files, execute pytest in isolation, and match\n485     against expected output, perfect for black-box testing of pytest plugins.\n486 \n487     It attempts to isolate the test run from external factors as much as possible, modifying\n488     the current working directory to ``path`` and environment variables during initialization.\n489 \n490     It is particularly useful for testing plugins. It is similar to the :fixture:`tmp_path`\n491     fixture but provides methods which aid in testing pytest itself.\n492     \"\"\"\n493     return Pytester(request, tmp_path_factory, monkeypatch, _ispytest=True)\n494 \n495 \n496 @fixture\n497 def _sys_snapshot() -> Generator[None, None, None]:\n498     snappaths = SysPathsSnapshot()\n499     snapmods = SysModulesSnapshot()\n500     yield\n501     snapmods.restore()\n502     snappaths.restore()\n503 \n504 \n505 @fixture\n506 def _config_for_test() -> Generator[Config, None, None]:\n507     from _pytest.config import get_config\n508 \n509     config = get_config()\n510     yield config\n511     config._ensure_unconfigure()  # cleanup, e.g. capman closing tmpfiles.\n512 \n513 \n514 # Regex to match the session duration string in the summary: \"74.34s\".\n515 rex_session_duration = re.compile(r\"\\d+\\.\\d\\ds\")\n516 # Regex to match all the counts and phrases in the summary line: \"34 passed, 111 skipped\".\n517 rex_outcome = re.compile(r\"(\\d+) (\\w+)\")\n518 \n519 \n520 @final\n521 class RunResult:\n522     \"\"\"The result of running a command from :class:`~pytest.Pytester`.\"\"\"\n523 \n524     def __init__(\n525         self,\n526         ret: Union[int, ExitCode],\n527         outlines: List[str],\n528         errlines: List[str],\n529         duration: float,\n530     ) -> None:\n531         try:\n532             self.ret: Union[int, ExitCode] = ExitCode(ret)\n533             \"\"\"The return value.\"\"\"\n534         except ValueError:\n535             self.ret = ret\n536         self.outlines = outlines\n537         \"\"\"List of lines captured from stdout.\"\"\"\n538         self.errlines = errlines\n539         \"\"\"List of lines captured from stderr.\"\"\"\n540         self.stdout = LineMatcher(outlines)\n541         \"\"\":class:`~pytest.LineMatcher` of stdout.\n542 \n543         Use e.g. :func:`str(stdout) <pytest.LineMatcher.__str__()>` to reconstruct stdout, or the commonly used\n544         :func:`stdout.fnmatch_lines() <pytest.LineMatcher.fnmatch_lines()>` method.\n545         \"\"\"\n546         self.stderr = LineMatcher(errlines)\n547         \"\"\":class:`~pytest.LineMatcher` of stderr.\"\"\"\n548         self.duration = duration\n549         \"\"\"Duration in seconds.\"\"\"\n550 \n551     def __repr__(self) -> str:\n552         return (\n553             \"<RunResult ret=%s len(stdout.lines)=%d len(stderr.lines)=%d duration=%.2fs>\"\n554             % (self.ret, len(self.stdout.lines), len(self.stderr.lines), self.duration)\n555         )\n556 \n557     def parseoutcomes(self) -> Dict[str, int]:\n558         \"\"\"Return a dictionary of outcome noun -> count from parsing the terminal\n559         output that the test process produced.\n560 \n561         The returned nouns will always be in plural form::\n562 \n563             ======= 1 failed, 1 passed, 1 warning, 1 error in 0.13s ====\n564 \n565         Will return ``{\"failed\": 1, \"passed\": 1, \"warnings\": 1, \"errors\": 1}``.\n566         \"\"\"\n567         return self.parse_summary_nouns(self.outlines)\n568 \n569     @classmethod\n570     def parse_summary_nouns(cls, lines) -> Dict[str, int]:\n571         \"\"\"Extract the nouns from a pytest terminal summary line.\n572 \n573         It always returns the plural noun for consistency::\n574 \n575             ======= 1 failed, 1 passed, 1 warning, 1 error in 0.13s ====\n576 \n577         Will return ``{\"failed\": 1, \"passed\": 1, \"warnings\": 1, \"errors\": 1}``.\n578         \"\"\"\n579         for line in reversed(lines):\n580             if rex_session_duration.search(line):\n581                 outcomes = rex_outcome.findall(line)\n582                 ret = {noun: int(count) for (count, noun) in outcomes}\n583                 break\n584         else:\n585             raise ValueError(\"Pytest terminal summary report not found\")\n586 \n587         to_plural = {\n588             \"warning\": \"warnings\",\n589             \"error\": \"errors\",\n590         }\n591         return {to_plural.get(k, k): v for k, v in ret.items()}\n592 \n593     def assert_outcomes(\n594         self,\n595         passed: int = 0,\n596         skipped: int = 0,\n597         failed: int = 0,\n598         errors: int = 0,\n599         xpassed: int = 0,\n600         xfailed: int = 0,\n601         warnings: Optional[int] = None,\n602         deselected: Optional[int] = None,\n603     ) -> None:\n604         \"\"\"\n605         Assert that the specified outcomes appear with the respective\n606         numbers (0 means it didn't occur) in the text output from a test run.\n607 \n608         ``warnings`` and ``deselected`` are only checked if not None.\n609         \"\"\"\n610         __tracebackhide__ = True\n611         from _pytest.pytester_assertions import assert_outcomes\n612 \n613         outcomes = self.parseoutcomes()\n614         assert_outcomes(\n615             outcomes,\n616             passed=passed,\n617             skipped=skipped,\n618             failed=failed,\n619             errors=errors,\n620             xpassed=xpassed,\n621             xfailed=xfailed,\n622             warnings=warnings,\n623             deselected=deselected,\n624         )\n625 \n626 \n627 class CwdSnapshot:\n628     def __init__(self) -> None:\n629         self.__saved = os.getcwd()\n630 \n631     def restore(self) -> None:\n632         os.chdir(self.__saved)\n633 \n634 \n635 class SysModulesSnapshot:\n636     def __init__(self, preserve: Optional[Callable[[str], bool]] = None) -> None:\n637         self.__preserve = preserve\n638         self.__saved = dict(sys.modules)\n639 \n640     def restore(self) -> None:\n641         if self.__preserve:\n642             self.__saved.update(\n643                 (k, m) for k, m in sys.modules.items() if self.__preserve(k)\n644             )\n645         sys.modules.clear()\n646         sys.modules.update(self.__saved)\n647 \n648 \n649 class SysPathsSnapshot:\n650     def __init__(self) -> None:\n651         self.__saved = list(sys.path), list(sys.meta_path)\n652 \n653     def restore(self) -> None:\n654         sys.path[:], sys.meta_path[:] = self.__saved\n655 \n656 \n657 @final\n658 class Pytester:\n659     \"\"\"\n660     Facilities to write tests/configuration files, execute pytest in isolation, and match\n661     against expected output, perfect for black-box testing of pytest plugins.\n662 \n663     It attempts to isolate the test run from external factors as much as possible, modifying\n664     the current working directory to :attr:`path` and environment variables during initialization.\n665     \"\"\"\n666 \n667     __test__ = False\n668 \n669     CLOSE_STDIN: \"Final\" = NOTSET\n670 \n671     class TimeoutExpired(Exception):\n672         pass\n673 \n674     def __init__(\n675         self,\n676         request: FixtureRequest,\n677         tmp_path_factory: TempPathFactory,\n678         monkeypatch: MonkeyPatch,\n679         *,\n680         _ispytest: bool = False,\n681     ) -> None:\n682         check_ispytest(_ispytest)\n683         self._request = request\n684         self._mod_collections: WeakKeyDictionary[\n685             Collector, List[Union[Item, Collector]]\n686         ] = WeakKeyDictionary()\n687         if request.function:\n688             name: str = request.function.__name__\n689         else:\n690             name = request.node.name\n691         self._name = name\n692         self._path: Path = tmp_path_factory.mktemp(name, numbered=True)\n693         #: A list of plugins to use with :py:meth:`parseconfig` and\n694         #: :py:meth:`runpytest`.  Initially this is an empty list but plugins can\n695         #: be added to the list.  The type of items to add to the list depends on\n696         #: the method using them so refer to them for details.\n697         self.plugins: List[Union[str, _PluggyPlugin]] = []\n698         self._cwd_snapshot = CwdSnapshot()\n699         self._sys_path_snapshot = SysPathsSnapshot()\n700         self._sys_modules_snapshot = self.__take_sys_modules_snapshot()\n701         self.chdir()\n702         self._request.addfinalizer(self._finalize)\n703         self._method = self._request.config.getoption(\"--runpytest\")\n704         self._test_tmproot = tmp_path_factory.mktemp(f\"tmp-{name}\", numbered=True)\n705 \n706         self._monkeypatch = mp = monkeypatch\n707         mp.setenv(\"PYTEST_DEBUG_TEMPROOT\", str(self._test_tmproot))\n708         # Ensure no unexpected caching via tox.\n709         mp.delenv(\"TOX_ENV_DIR\", raising=False)\n710         # Discard outer pytest options.\n711         mp.delenv(\"PYTEST_ADDOPTS\", raising=False)\n712         # Ensure no user config is used.\n713         tmphome = str(self.path)\n714         mp.setenv(\"HOME\", tmphome)\n715         mp.setenv(\"USERPROFILE\", tmphome)\n716         # Do not use colors for inner runs by default.\n717         mp.setenv(\"PY_COLORS\", \"0\")\n718 \n719     @property\n720     def path(self) -> Path:\n721         \"\"\"Temporary directory path used to create files/run tests from, etc.\"\"\"\n722         return self._path\n723 \n724     def __repr__(self) -> str:\n725         return f\"<Pytester {self.path!r}>\"\n726 \n727     def _finalize(self) -> None:\n728         \"\"\"\n729         Clean up global state artifacts.\n730 \n731         Some methods modify the global interpreter state and this tries to\n732         clean this up. It does not remove the temporary directory however so\n733         it can be looked at after the test run has finished.\n734         \"\"\"\n735         self._sys_modules_snapshot.restore()\n736         self._sys_path_snapshot.restore()\n737         self._cwd_snapshot.restore()\n738 \n739     def __take_sys_modules_snapshot(self) -> SysModulesSnapshot:\n740         # Some zope modules used by twisted-related tests keep internal state\n741         # and can't be deleted; we had some trouble in the past with\n742         # `zope.interface` for example.\n743         #\n744         # Preserve readline due to https://bugs.python.org/issue41033.\n745         # pexpect issues a SIGWINCH.\n746         def preserve_module(name):\n747             return name.startswith((\"zope\", \"readline\"))\n748 \n749         return SysModulesSnapshot(preserve=preserve_module)\n750 \n751     def make_hook_recorder(self, pluginmanager: PytestPluginManager) -> HookRecorder:\n752         \"\"\"Create a new :class:`HookRecorder` for a :class:`PytestPluginManager`.\"\"\"\n753         pluginmanager.reprec = reprec = HookRecorder(pluginmanager, _ispytest=True)\n754         self._request.addfinalizer(reprec.finish_recording)\n755         return reprec\n756 \n757     def chdir(self) -> None:\n758         \"\"\"Cd into the temporary directory.\n759 \n760         This is done automatically upon instantiation.\n761         \"\"\"\n762         os.chdir(self.path)\n763 \n764     def _makefile(\n765         self,\n766         ext: str,\n767         lines: Sequence[Union[Any, bytes]],\n768         files: Dict[str, str],\n769         encoding: str = \"utf-8\",\n770     ) -> Path:\n771         items = list(files.items())\n772 \n773         if ext and not ext.startswith(\".\"):\n774             raise ValueError(\n775                 f\"pytester.makefile expects a file extension, try .{ext} instead of {ext}\"\n776             )\n777 \n778         def to_text(s: Union[Any, bytes]) -> str:\n779             return s.decode(encoding) if isinstance(s, bytes) else str(s)\n780 \n781         if lines:\n782             source = \"\\n\".join(to_text(x) for x in lines)\n783             basename = self._name\n784             items.insert(0, (basename, source))\n785 \n786         ret = None\n787         for basename, value in items:\n788             p = self.path.joinpath(basename).with_suffix(ext)\n789             p.parent.mkdir(parents=True, exist_ok=True)\n790             source_ = Source(value)\n791             source = \"\\n\".join(to_text(line) for line in source_.lines)\n792             p.write_text(source.strip(), encoding=encoding)\n793             if ret is None:\n794                 ret = p\n795         assert ret is not None\n796         return ret\n797 \n798     def makefile(self, ext: str, *args: str, **kwargs: str) -> Path:\n799         r\"\"\"Create new text file(s) in the test directory.\n800 \n801         :param ext:\n802             The extension the file(s) should use, including the dot, e.g. `.py`.\n803         :param args:\n804             All args are treated as strings and joined using newlines.\n805             The result is written as contents to the file.  The name of the\n806             file is based on the test function requesting this fixture.\n807         :param kwargs:\n808             Each keyword is the name of a file, while the value of it will\n809             be written as contents of the file.\n810         :returns:\n811             The first created file.\n812 \n813         Examples:\n814 \n815         .. code-block:: python\n816 \n817             pytester.makefile(\".txt\", \"line1\", \"line2\")\n818 \n819             pytester.makefile(\".ini\", pytest=\"[pytest]\\naddopts=-rs\\n\")\n820 \n821         To create binary files, use :meth:`pathlib.Path.write_bytes` directly:\n822 \n823         .. code-block:: python\n824 \n825             filename = pytester.path.joinpath(\"foo.bin\")\n826             filename.write_bytes(b\"...\")\n827         \"\"\"\n828         return self._makefile(ext, args, kwargs)\n829 \n830     def makeconftest(self, source: str) -> Path:\n831         \"\"\"Write a contest.py file.\n832 \n833         :param source: The contents.\n834         :returns: The conftest.py file.\n835         \"\"\"\n836         return self.makepyfile(conftest=source)\n837 \n838     def makeini(self, source: str) -> Path:\n839         \"\"\"Write a tox.ini file.\n840 \n841         :param source: The contents.\n842         :returns: The tox.ini file.\n843         \"\"\"\n844         return self.makefile(\".ini\", tox=source)\n845 \n846     def getinicfg(self, source: str) -> SectionWrapper:\n847         \"\"\"Return the pytest section from the tox.ini config file.\"\"\"\n848         p = self.makeini(source)\n849         return IniConfig(str(p))[\"pytest\"]\n850 \n851     def makepyprojecttoml(self, source: str) -> Path:\n852         \"\"\"Write a pyproject.toml file.\n853 \n854         :param source: The contents.\n855         :returns: The pyproject.ini file.\n856 \n857         .. versionadded:: 6.0\n858         \"\"\"\n859         return self.makefile(\".toml\", pyproject=source)\n860 \n861     def makepyfile(self, *args, **kwargs) -> Path:\n862         r\"\"\"Shortcut for .makefile() with a .py extension.\n863 \n864         Defaults to the test name with a '.py' extension, e.g test_foobar.py, overwriting\n865         existing files.\n866 \n867         Examples:\n868 \n869         .. code-block:: python\n870 \n871             def test_something(pytester):\n872                 # Initial file is created test_something.py.\n873                 pytester.makepyfile(\"foobar\")\n874                 # To create multiple files, pass kwargs accordingly.\n875                 pytester.makepyfile(custom=\"foobar\")\n876                 # At this point, both 'test_something.py' & 'custom.py' exist in the test directory.\n877 \n878         \"\"\"\n879         return self._makefile(\".py\", args, kwargs)\n880 \n881     def maketxtfile(self, *args, **kwargs) -> Path:\n882         r\"\"\"Shortcut for .makefile() with a .txt extension.\n883 \n884         Defaults to the test name with a '.txt' extension, e.g test_foobar.txt, overwriting\n885         existing files.\n886 \n887         Examples:\n888 \n889         .. code-block:: python\n890 \n891             def test_something(pytester):\n892                 # Initial file is created test_something.txt.\n893                 pytester.maketxtfile(\"foobar\")\n894                 # To create multiple files, pass kwargs accordingly.\n895                 pytester.maketxtfile(custom=\"foobar\")\n896                 # At this point, both 'test_something.txt' & 'custom.txt' exist in the test directory.\n897 \n898         \"\"\"\n899         return self._makefile(\".txt\", args, kwargs)\n900 \n901     def syspathinsert(\n902         self, path: Optional[Union[str, \"os.PathLike[str]\"]] = None\n903     ) -> None:\n904         \"\"\"Prepend a directory to sys.path, defaults to :attr:`path`.\n905 \n906         This is undone automatically when this object dies at the end of each\n907         test.\n908 \n909         :param path:\n910             The path.\n911         \"\"\"\n912         if path is None:\n913             path = self.path\n914 \n915         self._monkeypatch.syspath_prepend(str(path))\n916 \n917     def mkdir(self, name: Union[str, \"os.PathLike[str]\"]) -> Path:\n918         \"\"\"Create a new (sub)directory.\n919 \n920         :param name:\n921             The name of the directory, relative to the pytester path.\n922         :returns:\n923             The created directory.\n924         \"\"\"\n925         p = self.path / name\n926         p.mkdir()\n927         return p\n928 \n929     def mkpydir(self, name: Union[str, \"os.PathLike[str]\"]) -> Path:\n930         \"\"\"Create a new python package.\n931 \n932         This creates a (sub)directory with an empty ``__init__.py`` file so it\n933         gets recognised as a Python package.\n934         \"\"\"\n935         p = self.path / name\n936         p.mkdir()\n937         p.joinpath(\"__init__.py\").touch()\n938         return p\n939 \n940     def copy_example(self, name: Optional[str] = None) -> Path:\n941         \"\"\"Copy file from project's directory into the testdir.\n942 \n943         :param name:\n944             The name of the file to copy.\n945         :return:\n946             Path to the copied directory (inside ``self.path``).\n947         \"\"\"\n948         example_dir_ = self._request.config.getini(\"pytester_example_dir\")\n949         if example_dir_ is None:\n950             raise ValueError(\"pytester_example_dir is unset, can't copy examples\")\n951         example_dir: Path = self._request.config.rootpath / example_dir_\n952 \n953         for extra_element in self._request.node.iter_markers(\"pytester_example_path\"):\n954             assert extra_element.args\n955             example_dir = example_dir.joinpath(*extra_element.args)\n956 \n957         if name is None:\n958             func_name = self._name\n959             maybe_dir = example_dir / func_name\n960             maybe_file = example_dir / (func_name + \".py\")\n961 \n962             if maybe_dir.is_dir():\n963                 example_path = maybe_dir\n964             elif maybe_file.is_file():\n965                 example_path = maybe_file\n966             else:\n967                 raise LookupError(\n968                     f\"{func_name} can't be found as module or package in {example_dir}\"\n969                 )\n970         else:\n971             example_path = example_dir.joinpath(name)\n972 \n973         if example_path.is_dir() and not example_path.joinpath(\"__init__.py\").is_file():\n974             copytree(example_path, self.path)\n975             return self.path\n976         elif example_path.is_file():\n977             result = self.path.joinpath(example_path.name)\n978             shutil.copy(example_path, result)\n979             return result\n980         else:\n981             raise LookupError(\n982                 f'example \"{example_path}\" is not found as a file or directory'\n983             )\n984 \n985     def getnode(\n986         self, config: Config, arg: Union[str, \"os.PathLike[str]\"]\n987     ) -> Union[Collector, Item]:\n988         \"\"\"Get the collection node of a file.\n989 \n990         :param config:\n991            A pytest config.\n992            See :py:meth:`parseconfig` and :py:meth:`parseconfigure` for creating it.\n993         :param arg:\n994             Path to the file.\n995         :returns:\n996             The node.\n997         \"\"\"\n998         session = Session.from_config(config)\n999         assert \"::\" not in str(arg)\n1000         p = Path(os.path.abspath(arg))\n1001         config.hook.pytest_sessionstart(session=session)\n1002         res = session.perform_collect([str(p)], genitems=False)[0]\n1003         config.hook.pytest_sessionfinish(session=session, exitstatus=ExitCode.OK)\n1004         return res\n1005 \n1006     def getpathnode(\n1007         self, path: Union[str, \"os.PathLike[str]\"]\n1008     ) -> Union[Collector, Item]:\n1009         \"\"\"Return the collection node of a file.\n1010 \n1011         This is like :py:meth:`getnode` but uses :py:meth:`parseconfigure` to\n1012         create the (configured) pytest Config instance.\n1013 \n1014         :param path:\n1015             Path to the file.\n1016         :returns:\n1017             The node.\n1018         \"\"\"\n1019         path = Path(path)\n1020         config = self.parseconfigure(path)\n1021         session = Session.from_config(config)\n1022         x = bestrelpath(session.path, path)\n1023         config.hook.pytest_sessionstart(session=session)\n1024         res = session.perform_collect([x], genitems=False)[0]\n1025         config.hook.pytest_sessionfinish(session=session, exitstatus=ExitCode.OK)\n1026         return res\n1027 \n1028     def genitems(self, colitems: Sequence[Union[Item, Collector]]) -> List[Item]:\n1029         \"\"\"Generate all test items from a collection node.\n1030 \n1031         This recurses into the collection node and returns a list of all the\n1032         test items contained within.\n1033 \n1034         :param colitems:\n1035             The collection nodes.\n1036         :returns:\n1037             The collected items.\n1038         \"\"\"\n1039         session = colitems[0].session\n1040         result: List[Item] = []\n1041         for colitem in colitems:\n1042             result.extend(session.genitems(colitem))\n1043         return result\n1044 \n1045     def runitem(self, source: str) -> Any:\n1046         \"\"\"Run the \"test_func\" Item.\n1047 \n1048         The calling test instance (class containing the test method) must\n1049         provide a ``.getrunner()`` method which should return a runner which\n1050         can run the test protocol for a single item, e.g.\n1051         :py:func:`_pytest.runner.runtestprotocol`.\n1052         \"\"\"\n1053         # used from runner functional tests\n1054         item = self.getitem(source)\n1055         # the test class where we are called from wants to provide the runner\n1056         testclassinstance = self._request.instance\n1057         runner = testclassinstance.getrunner()\n1058         return runner(item)\n1059 \n1060     def inline_runsource(self, source: str, *cmdlineargs) -> HookRecorder:\n1061         \"\"\"Run a test module in process using ``pytest.main()``.\n1062 \n1063         This run writes \"source\" into a temporary file and runs\n1064         ``pytest.main()`` on it, returning a :py:class:`HookRecorder` instance\n1065         for the result.\n1066 \n1067         :param source: The source code of the test module.\n1068         :param cmdlineargs: Any extra command line arguments to use.\n1069         \"\"\"\n1070         p = self.makepyfile(source)\n1071         values = list(cmdlineargs) + [p]\n1072         return self.inline_run(*values)\n1073 \n1074     def inline_genitems(self, *args) -> Tuple[List[Item], HookRecorder]:\n1075         \"\"\"Run ``pytest.main(['--collectonly'])`` in-process.\n1076 \n1077         Runs the :py:func:`pytest.main` function to run all of pytest inside\n1078         the test process itself like :py:meth:`inline_run`, but returns a\n1079         tuple of the collected items and a :py:class:`HookRecorder` instance.\n1080         \"\"\"\n1081         rec = self.inline_run(\"--collect-only\", *args)\n1082         items = [x.item for x in rec.getcalls(\"pytest_itemcollected\")]\n1083         return items, rec\n1084 \n1085     def inline_run(\n1086         self,\n1087         *args: Union[str, \"os.PathLike[str]\"],\n1088         plugins=(),\n1089         no_reraise_ctrlc: bool = False,\n1090     ) -> HookRecorder:\n1091         \"\"\"Run ``pytest.main()`` in-process, returning a HookRecorder.\n1092 \n1093         Runs the :py:func:`pytest.main` function to run all of pytest inside\n1094         the test process itself.  This means it can return a\n1095         :py:class:`HookRecorder` instance which gives more detailed results\n1096         from that run than can be done by matching stdout/stderr from\n1097         :py:meth:`runpytest`.\n1098 \n1099         :param args:\n1100             Command line arguments to pass to :py:func:`pytest.main`.\n1101         :param plugins:\n1102             Extra plugin instances the ``pytest.main()`` instance should use.\n1103         :param no_reraise_ctrlc:\n1104             Typically we reraise keyboard interrupts from the child run. If\n1105             True, the KeyboardInterrupt exception is captured.\n1106         \"\"\"\n1107         # (maybe a cpython bug?) the importlib cache sometimes isn't updated\n1108         # properly between file creation and inline_run (especially if imports\n1109         # are interspersed with file creation)\n1110         importlib.invalidate_caches()\n1111 \n1112         plugins = list(plugins)\n1113         finalizers = []\n1114         try:\n1115             # Any sys.module or sys.path changes done while running pytest\n1116             # inline should be reverted after the test run completes to avoid\n1117             # clashing with later inline tests run within the same pytest test,\n1118             # e.g. just because they use matching test module names.\n1119             finalizers.append(self.__take_sys_modules_snapshot().restore)\n1120             finalizers.append(SysPathsSnapshot().restore)\n1121 \n1122             # Important note:\n1123             # - our tests should not leave any other references/registrations\n1124             #   laying around other than possibly loaded test modules\n1125             #   referenced from sys.modules, as nothing will clean those up\n1126             #   automatically\n1127 \n1128             rec = []\n1129 \n1130             class Collect:\n1131                 def pytest_configure(x, config: Config) -> None:\n1132                     rec.append(self.make_hook_recorder(config.pluginmanager))\n1133 \n1134             plugins.append(Collect())\n1135             ret = main([str(x) for x in args], plugins=plugins)\n1136             if len(rec) == 1:\n1137                 reprec = rec.pop()\n1138             else:\n1139 \n1140                 class reprec:  # type: ignore\n1141                     pass\n1142 \n1143             reprec.ret = ret\n1144 \n1145             # Typically we reraise keyboard interrupts from the child run\n1146             # because it's our user requesting interruption of the testing.\n1147             if ret == ExitCode.INTERRUPTED and not no_reraise_ctrlc:\n1148                 calls = reprec.getcalls(\"pytest_keyboard_interrupt\")\n1149                 if calls and calls[-1].excinfo.type == KeyboardInterrupt:\n1150                     raise KeyboardInterrupt()\n1151             return reprec\n1152         finally:\n1153             for finalizer in finalizers:\n1154                 finalizer()\n1155 \n1156     def runpytest_inprocess(\n1157         self, *args: Union[str, \"os.PathLike[str]\"], **kwargs: Any\n1158     ) -> RunResult:\n1159         \"\"\"Return result of running pytest in-process, providing a similar\n1160         interface to what self.runpytest() provides.\"\"\"\n1161         syspathinsert = kwargs.pop(\"syspathinsert\", False)\n1162 \n1163         if syspathinsert:\n1164             self.syspathinsert()\n1165         now = timing.time()\n1166         capture = _get_multicapture(\"sys\")\n1167         capture.start_capturing()\n1168         try:\n1169             try:\n1170                 reprec = self.inline_run(*args, **kwargs)\n1171             except SystemExit as e:\n1172                 ret = e.args[0]\n1173                 try:\n1174                     ret = ExitCode(e.args[0])\n1175                 except ValueError:\n1176                     pass\n1177 \n1178                 class reprec:  # type: ignore\n1179                     ret = ret\n1180 \n1181             except Exception:\n1182                 traceback.print_exc()\n1183 \n1184                 class reprec:  # type: ignore\n1185                     ret = ExitCode(3)\n1186 \n1187         finally:\n1188             out, err = capture.readouterr()\n1189             capture.stop_capturing()\n1190             sys.stdout.write(out)\n1191             sys.stderr.write(err)\n1192 \n1193         assert reprec.ret is not None\n1194         res = RunResult(\n1195             reprec.ret, out.splitlines(), err.splitlines(), timing.time() - now\n1196         )\n1197         res.reprec = reprec  # type: ignore\n1198         return res\n1199 \n1200     def runpytest(\n1201         self, *args: Union[str, \"os.PathLike[str]\"], **kwargs: Any\n1202     ) -> RunResult:\n1203         \"\"\"Run pytest inline or in a subprocess, depending on the command line\n1204         option \"--runpytest\" and return a :py:class:`~pytest.RunResult`.\"\"\"\n1205         new_args = self._ensure_basetemp(args)\n1206         if self._method == \"inprocess\":\n1207             return self.runpytest_inprocess(*new_args, **kwargs)\n1208         elif self._method == \"subprocess\":\n1209             return self.runpytest_subprocess(*new_args, **kwargs)\n1210         raise RuntimeError(f\"Unrecognized runpytest option: {self._method}\")\n1211 \n1212     def _ensure_basetemp(\n1213         self, args: Sequence[Union[str, \"os.PathLike[str]\"]]\n1214     ) -> List[Union[str, \"os.PathLike[str]\"]]:\n1215         new_args = list(args)\n1216         for x in new_args:\n1217             if str(x).startswith(\"--basetemp\"):\n1218                 break\n1219         else:\n1220             new_args.append(\"--basetemp=%s\" % self.path.parent.joinpath(\"basetemp\"))\n1221         return new_args\n1222 \n1223     def parseconfig(self, *args: Union[str, \"os.PathLike[str]\"]) -> Config:\n1224         \"\"\"Return a new pytest :class:`pytest.Config` instance from given\n1225         commandline args.\n1226 \n1227         This invokes the pytest bootstrapping code in _pytest.config to create a\n1228         new :py:class:`pytest.PytestPluginManager` and call the\n1229         :hook:`pytest_cmdline_parse` hook to create a new :class:`pytest.Config`\n1230         instance.\n1231 \n1232         If :attr:`plugins` has been populated they should be plugin modules\n1233         to be registered with the plugin manager.\n1234         \"\"\"\n1235         import _pytest.config\n1236 \n1237         new_args = self._ensure_basetemp(args)\n1238         new_args = [str(x) for x in new_args]\n1239 \n1240         config = _pytest.config._prepareconfig(new_args, self.plugins)  # type: ignore[arg-type]\n1241         # we don't know what the test will do with this half-setup config\n1242         # object and thus we make sure it gets unconfigured properly in any\n1243         # case (otherwise capturing could still be active, for example)\n1244         self._request.addfinalizer(config._ensure_unconfigure)\n1245         return config\n1246 \n1247     def parseconfigure(self, *args: Union[str, \"os.PathLike[str]\"]) -> Config:\n1248         \"\"\"Return a new pytest configured Config instance.\n1249 \n1250         Returns a new :py:class:`pytest.Config` instance like\n1251         :py:meth:`parseconfig`, but also calls the :hook:`pytest_configure`\n1252         hook.\n1253         \"\"\"\n1254         config = self.parseconfig(*args)\n1255         config._do_configure()\n1256         return config\n1257 \n1258     def getitem(\n1259         self, source: Union[str, \"os.PathLike[str]\"], funcname: str = \"test_func\"\n1260     ) -> Item:\n1261         \"\"\"Return the test item for a test function.\n1262 \n1263         Writes the source to a python file and runs pytest's collection on\n1264         the resulting module, returning the test item for the requested\n1265         function name.\n1266 \n1267         :param source:\n1268             The module source.\n1269         :param funcname:\n1270             The name of the test function for which to return a test item.\n1271         :returns:\n1272             The test item.\n1273         \"\"\"\n1274         items = self.getitems(source)\n1275         for item in items:\n1276             if item.name == funcname:\n1277                 return item\n1278         assert 0, \"{!r} item not found in module:\\n{}\\nitems: {}\".format(\n1279             funcname, source, items\n1280         )\n1281 \n1282     def getitems(self, source: Union[str, \"os.PathLike[str]\"]) -> List[Item]:\n1283         \"\"\"Return all test items collected from the module.\n1284 \n1285         Writes the source to a Python file and runs pytest's collection on\n1286         the resulting module, returning all test items contained within.\n1287         \"\"\"\n1288         modcol = self.getmodulecol(source)\n1289         return self.genitems([modcol])\n1290 \n1291     def getmodulecol(\n1292         self,\n1293         source: Union[str, \"os.PathLike[str]\"],\n1294         configargs=(),\n1295         *,\n1296         withinit: bool = False,\n1297     ):\n1298         \"\"\"Return the module collection node for ``source``.\n1299 \n1300         Writes ``source`` to a file using :py:meth:`makepyfile` and then\n1301         runs the pytest collection on it, returning the collection node for the\n1302         test module.\n1303 \n1304         :param source:\n1305             The source code of the module to collect.\n1306 \n1307         :param configargs:\n1308             Any extra arguments to pass to :py:meth:`parseconfigure`.\n1309 \n1310         :param withinit:\n1311             Whether to also write an ``__init__.py`` file to the same\n1312             directory to ensure it is a package.\n1313         \"\"\"\n1314         if isinstance(source, os.PathLike):\n1315             path = self.path.joinpath(source)\n1316             assert not withinit, \"not supported for paths\"\n1317         else:\n1318             kw = {self._name: str(source)}\n1319             path = self.makepyfile(**kw)\n1320         if withinit:\n1321             self.makepyfile(__init__=\"#\")\n1322         self.config = config = self.parseconfigure(path, *configargs)\n1323         return self.getnode(config, path)\n1324 \n1325     def collect_by_name(\n1326         self, modcol: Collector, name: str\n1327     ) -> Optional[Union[Item, Collector]]:\n1328         \"\"\"Return the collection node for name from the module collection.\n1329 \n1330         Searches a module collection node for a collection node matching the\n1331         given name.\n1332 \n1333         :param modcol: A module collection node; see :py:meth:`getmodulecol`.\n1334         :param name: The name of the node to return.\n1335         \"\"\"\n1336         if modcol not in self._mod_collections:\n1337             self._mod_collections[modcol] = list(modcol.collect())\n1338         for colitem in self._mod_collections[modcol]:\n1339             if colitem.name == name:\n1340                 return colitem\n1341         return None\n1342 \n1343     def popen(\n1344         self,\n1345         cmdargs: Sequence[Union[str, \"os.PathLike[str]\"]],\n1346         stdout: Union[int, TextIO] = subprocess.PIPE,\n1347         stderr: Union[int, TextIO] = subprocess.PIPE,\n1348         stdin: Union[NotSetType, bytes, IO[Any], int] = CLOSE_STDIN,\n1349         **kw,\n1350     ):\n1351         \"\"\"Invoke :py:class:`subprocess.Popen`.\n1352 \n1353         Calls :py:class:`subprocess.Popen` making sure the current working\n1354         directory is in ``PYTHONPATH``.\n1355 \n1356         You probably want to use :py:meth:`run` instead.\n1357         \"\"\"\n1358         env = os.environ.copy()\n1359         env[\"PYTHONPATH\"] = os.pathsep.join(\n1360             filter(None, [os.getcwd(), env.get(\"PYTHONPATH\", \"\")])\n1361         )\n1362         kw[\"env\"] = env\n1363 \n1364         if stdin is self.CLOSE_STDIN:\n1365             kw[\"stdin\"] = subprocess.PIPE\n1366         elif isinstance(stdin, bytes):\n1367             kw[\"stdin\"] = subprocess.PIPE\n1368         else:\n1369             kw[\"stdin\"] = stdin\n1370 \n1371         popen = subprocess.Popen(cmdargs, stdout=stdout, stderr=stderr, **kw)\n1372         if stdin is self.CLOSE_STDIN:\n1373             assert popen.stdin is not None\n1374             popen.stdin.close()\n1375         elif isinstance(stdin, bytes):\n1376             assert popen.stdin is not None\n1377             popen.stdin.write(stdin)\n1378 \n1379         return popen\n1380 \n1381     def run(\n1382         self,\n1383         *cmdargs: Union[str, \"os.PathLike[str]\"],\n1384         timeout: Optional[float] = None,\n1385         stdin: Union[NotSetType, bytes, IO[Any], int] = CLOSE_STDIN,\n1386     ) -> RunResult:\n1387         \"\"\"Run a command with arguments.\n1388 \n1389         Run a process using :py:class:`subprocess.Popen` saving the stdout and\n1390         stderr.\n1391 \n1392         :param cmdargs:\n1393             The sequence of arguments to pass to :py:class:`subprocess.Popen`,\n1394             with path-like objects being converted to :py:class:`str`\n1395             automatically.\n1396         :param timeout:\n1397             The period in seconds after which to timeout and raise\n1398             :py:class:`Pytester.TimeoutExpired`.\n1399         :param stdin:\n1400             Optional standard input.\n1401 \n1402             - If it is :py:attr:`CLOSE_STDIN` (Default), then this method calls\n1403               :py:class:`subprocess.Popen` with ``stdin=subprocess.PIPE``, and\n1404               the standard input is closed immediately after the new command is\n1405               started.\n1406 \n1407             - If it is of type :py:class:`bytes`, these bytes are sent to the\n1408               standard input of the command.\n1409 \n1410             - Otherwise, it is passed through to :py:class:`subprocess.Popen`.\n1411               For further information in this case, consult the document of the\n1412               ``stdin`` parameter in :py:class:`subprocess.Popen`.\n1413         :returns:\n1414             The result.\n1415         \"\"\"\n1416         __tracebackhide__ = True\n1417 \n1418         cmdargs = tuple(os.fspath(arg) for arg in cmdargs)\n1419         p1 = self.path.joinpath(\"stdout\")\n1420         p2 = self.path.joinpath(\"stderr\")\n1421         print(\"running:\", *cmdargs)\n1422         print(\"     in:\", Path.cwd())\n1423 \n1424         with p1.open(\"w\", encoding=\"utf8\") as f1, p2.open(\"w\", encoding=\"utf8\") as f2:\n1425             now = timing.time()\n1426             popen = self.popen(\n1427                 cmdargs,\n1428                 stdin=stdin,\n1429                 stdout=f1,\n1430                 stderr=f2,\n1431                 close_fds=(sys.platform != \"win32\"),\n1432             )\n1433             if popen.stdin is not None:\n1434                 popen.stdin.close()\n1435 \n1436             def handle_timeout() -> None:\n1437                 __tracebackhide__ = True\n1438 \n1439                 timeout_message = (\n1440                     \"{seconds} second timeout expired running:\"\n1441                     \" {command}\".format(seconds=timeout, command=cmdargs)\n1442                 )\n1443 \n1444                 popen.kill()\n1445                 popen.wait()\n1446                 raise self.TimeoutExpired(timeout_message)\n1447 \n1448             if timeout is None:\n1449                 ret = popen.wait()\n1450             else:\n1451                 try:\n1452                     ret = popen.wait(timeout)\n1453                 except subprocess.TimeoutExpired:\n1454                     handle_timeout()\n1455 \n1456         with p1.open(encoding=\"utf8\") as f1, p2.open(encoding=\"utf8\") as f2:\n1457             out = f1.read().splitlines()\n1458             err = f2.read().splitlines()\n1459 \n1460         self._dump_lines(out, sys.stdout)\n1461         self._dump_lines(err, sys.stderr)\n1462 \n1463         with contextlib.suppress(ValueError):\n1464             ret = ExitCode(ret)\n1465         return RunResult(ret, out, err, timing.time() - now)\n1466 \n1467     def _dump_lines(self, lines, fp):\n1468         try:\n1469             for line in lines:\n1470                 print(line, file=fp)\n1471         except UnicodeEncodeError:\n1472             print(f\"couldn't print to {fp} because of encoding\")\n1473 \n1474     def _getpytestargs(self) -> Tuple[str, ...]:\n1475         return sys.executable, \"-mpytest\"\n1476 \n1477     def runpython(self, script: \"os.PathLike[str]\") -> RunResult:\n1478         \"\"\"Run a python script using sys.executable as interpreter.\"\"\"\n1479         return self.run(sys.executable, script)\n1480 \n1481     def runpython_c(self, command: str) -> RunResult:\n1482         \"\"\"Run ``python -c \"command\"``.\"\"\"\n1483         return self.run(sys.executable, \"-c\", command)\n1484 \n1485     def runpytest_subprocess(\n1486         self, *args: Union[str, \"os.PathLike[str]\"], timeout: Optional[float] = None\n1487     ) -> RunResult:\n1488         \"\"\"Run pytest as a subprocess with given arguments.\n1489 \n1490         Any plugins added to the :py:attr:`plugins` list will be added using the\n1491         ``-p`` command line option.  Additionally ``--basetemp`` is used to put\n1492         any temporary files and directories in a numbered directory prefixed\n1493         with \"runpytest-\" to not conflict with the normal numbered pytest\n1494         location for temporary files and directories.\n1495 \n1496         :param args:\n1497             The sequence of arguments to pass to the pytest subprocess.\n1498         :param timeout:\n1499             The period in seconds after which to timeout and raise\n1500             :py:class:`Pytester.TimeoutExpired`.\n1501         :returns:\n1502             The result.\n1503         \"\"\"\n1504         __tracebackhide__ = True\n1505         p = make_numbered_dir(root=self.path, prefix=\"runpytest-\", mode=0o700)\n1506         args = (\"--basetemp=%s\" % p,) + args\n1507         plugins = [x for x in self.plugins if isinstance(x, str)]\n1508         if plugins:\n1509             args = (\"-p\", plugins[0]) + args\n1510         args = self._getpytestargs() + args\n1511         return self.run(*args, timeout=timeout)\n1512 \n1513     def spawn_pytest(\n1514         self, string: str, expect_timeout: float = 10.0\n1515     ) -> \"pexpect.spawn\":\n1516         \"\"\"Run pytest using pexpect.\n1517 \n1518         This makes sure to use the right pytest and sets up the temporary\n1519         directory locations.\n1520 \n1521         The pexpect child is returned.\n1522         \"\"\"\n1523         basetemp = self.path / \"temp-pexpect\"\n1524         basetemp.mkdir(mode=0o700)\n1525         invoke = \" \".join(map(str, self._getpytestargs()))\n1526         cmd = f\"{invoke} --basetemp={basetemp} {string}\"\n1527         return self.spawn(cmd, expect_timeout=expect_timeout)\n1528 \n1529     def spawn(self, cmd: str, expect_timeout: float = 10.0) -> \"pexpect.spawn\":\n1530         \"\"\"Run a command using pexpect.\n1531 \n1532         The pexpect child is returned.\n1533         \"\"\"\n1534         pexpect = importorskip(\"pexpect\", \"3.0\")\n1535         if hasattr(sys, \"pypy_version_info\") and \"64\" in platform.machine():\n1536             skip(\"pypy-64 bit not supported\")\n1537         if not hasattr(pexpect, \"spawn\"):\n1538             skip(\"pexpect.spawn not available\")\n1539         logfile = self.path.joinpath(\"spawn.out\").open(\"wb\")\n1540 \n1541         child = pexpect.spawn(cmd, logfile=logfile, timeout=expect_timeout)\n1542         self._request.addfinalizer(logfile.close)\n1543         return child\n1544 \n1545 \n1546 class LineComp:\n1547     def __init__(self) -> None:\n1548         self.stringio = StringIO()\n1549         \"\"\":class:`python:io.StringIO()` instance used for input.\"\"\"\n1550 \n1551     def assert_contains_lines(self, lines2: Sequence[str]) -> None:\n1552         \"\"\"Assert that ``lines2`` are contained (linearly) in :attr:`stringio`'s value.\n1553 \n1554         Lines are matched using :func:`LineMatcher.fnmatch_lines <pytest.LineMatcher.fnmatch_lines>`.\n1555         \"\"\"\n1556         __tracebackhide__ = True\n1557         val = self.stringio.getvalue()\n1558         self.stringio.truncate(0)\n1559         self.stringio.seek(0)\n1560         lines1 = val.split(\"\\n\")\n1561         LineMatcher(lines1).fnmatch_lines(lines2)\n1562 \n1563 \n1564 class LineMatcher:\n1565     \"\"\"Flexible matching of text.\n1566 \n1567     This is a convenience class to test large texts like the output of\n1568     commands.\n1569 \n1570     The constructor takes a list of lines without their trailing newlines, i.e.\n1571     ``text.splitlines()``.\n1572     \"\"\"\n1573 \n1574     def __init__(self, lines: List[str]) -> None:\n1575         self.lines = lines\n1576         self._log_output: List[str] = []\n1577 \n1578     def __str__(self) -> str:\n1579         \"\"\"Return the entire original text.\n1580 \n1581         .. versionadded:: 6.2\n1582             You can use :meth:`str` in older versions.\n1583         \"\"\"\n1584         return \"\\n\".join(self.lines)\n1585 \n1586     def _getlines(self, lines2: Union[str, Sequence[str], Source]) -> Sequence[str]:\n1587         if isinstance(lines2, str):\n1588             lines2 = Source(lines2)\n1589         if isinstance(lines2, Source):\n1590             lines2 = lines2.strip().lines\n1591         return lines2\n1592 \n1593     def fnmatch_lines_random(self, lines2: Sequence[str]) -> None:\n1594         \"\"\"Check lines exist in the output in any order (using :func:`python:fnmatch.fnmatch`).\"\"\"\n1595         __tracebackhide__ = True\n1596         self._match_lines_random(lines2, fnmatch)\n1597 \n1598     def re_match_lines_random(self, lines2: Sequence[str]) -> None:\n1599         \"\"\"Check lines exist in the output in any order (using :func:`python:re.match`).\"\"\"\n1600         __tracebackhide__ = True\n1601         self._match_lines_random(lines2, lambda name, pat: bool(re.match(pat, name)))\n1602 \n1603     def _match_lines_random(\n1604         self, lines2: Sequence[str], match_func: Callable[[str, str], bool]\n1605     ) -> None:\n1606         __tracebackhide__ = True\n1607         lines2 = self._getlines(lines2)\n1608         for line in lines2:\n1609             for x in self.lines:\n1610                 if line == x or match_func(x, line):\n1611                     self._log(\"matched: \", repr(line))\n1612                     break\n1613             else:\n1614                 msg = \"line %r not found in output\" % line\n1615                 self._log(msg)\n1616                 self._fail(msg)\n1617 \n1618     def get_lines_after(self, fnline: str) -> Sequence[str]:\n1619         \"\"\"Return all lines following the given line in the text.\n1620 \n1621         The given line can contain glob wildcards.\n1622         \"\"\"\n1623         for i, line in enumerate(self.lines):\n1624             if fnline == line or fnmatch(line, fnline):\n1625                 return self.lines[i + 1 :]\n1626         raise ValueError(\"line %r not found in output\" % fnline)\n1627 \n1628     def _log(self, *args) -> None:\n1629         self._log_output.append(\" \".join(str(x) for x in args))\n1630 \n1631     @property\n1632     def _log_text(self) -> str:\n1633         return \"\\n\".join(self._log_output)\n1634 \n1635     def fnmatch_lines(\n1636         self, lines2: Sequence[str], *, consecutive: bool = False\n1637     ) -> None:\n1638         \"\"\"Check lines exist in the output (using :func:`python:fnmatch.fnmatch`).\n1639 \n1640         The argument is a list of lines which have to match and can use glob\n1641         wildcards.  If they do not match a pytest.fail() is called.  The\n1642         matches and non-matches are also shown as part of the error message.\n1643 \n1644         :param lines2: String patterns to match.\n1645         :param consecutive: Match lines consecutively?\n1646         \"\"\"\n1647         __tracebackhide__ = True\n1648         self._match_lines(lines2, fnmatch, \"fnmatch\", consecutive=consecutive)\n1649 \n1650     def re_match_lines(\n1651         self, lines2: Sequence[str], *, consecutive: bool = False\n1652     ) -> None:\n1653         \"\"\"Check lines exist in the output (using :func:`python:re.match`).\n1654 \n1655         The argument is a list of lines which have to match using ``re.match``.\n1656         If they do not match a pytest.fail() is called.\n1657 \n1658         The matches and non-matches are also shown as part of the error message.\n1659 \n1660         :param lines2: string patterns to match.\n1661         :param consecutive: match lines consecutively?\n1662         \"\"\"\n1663         __tracebackhide__ = True\n1664         self._match_lines(\n1665             lines2,\n1666             lambda name, pat: bool(re.match(pat, name)),\n1667             \"re.match\",\n1668             consecutive=consecutive,\n1669         )\n1670 \n1671     def _match_lines(\n1672         self,\n1673         lines2: Sequence[str],\n1674         match_func: Callable[[str, str], bool],\n1675         match_nickname: str,\n1676         *,\n1677         consecutive: bool = False,\n1678     ) -> None:\n1679         \"\"\"Underlying implementation of ``fnmatch_lines`` and ``re_match_lines``.\n1680 \n1681         :param Sequence[str] lines2:\n1682             List of string patterns to match. The actual format depends on\n1683             ``match_func``.\n1684         :param match_func:\n1685             A callable ``match_func(line, pattern)`` where line is the\n1686             captured line from stdout/stderr and pattern is the matching\n1687             pattern.\n1688         :param str match_nickname:\n1689             The nickname for the match function that will be logged to stdout\n1690             when a match occurs.\n1691         :param consecutive:\n1692             Match lines consecutively?\n1693         \"\"\"\n1694         if not isinstance(lines2, collections.abc.Sequence):\n1695             raise TypeError(f\"invalid type for lines2: {type(lines2).__name__}\")\n1696         lines2 = self._getlines(lines2)\n1697         lines1 = self.lines[:]\n1698         extralines = []\n1699         __tracebackhide__ = True\n1700         wnick = len(match_nickname) + 1\n1701         started = False\n1702         for line in lines2:\n1703             nomatchprinted = False\n1704             while lines1:\n1705                 nextline = lines1.pop(0)\n1706                 if line == nextline:\n1707                     self._log(\"exact match:\", repr(line))\n1708                     started = True\n1709                     break\n1710                 elif match_func(nextline, line):\n1711                     self._log(\"%s:\" % match_nickname, repr(line))\n1712                     self._log(\n1713                         \"{:>{width}}\".format(\"with:\", width=wnick), repr(nextline)\n1714                     )\n1715                     started = True\n1716                     break\n1717                 else:\n1718                     if consecutive and started:\n1719                         msg = f\"no consecutive match: {line!r}\"\n1720                         self._log(msg)\n1721                         self._log(\n1722                             \"{:>{width}}\".format(\"with:\", width=wnick), repr(nextline)\n1723                         )\n1724                         self._fail(msg)\n1725                     if not nomatchprinted:\n1726                         self._log(\n1727                             \"{:>{width}}\".format(\"nomatch:\", width=wnick), repr(line)\n1728                         )\n1729                         nomatchprinted = True\n1730                     self._log(\"{:>{width}}\".format(\"and:\", width=wnick), repr(nextline))\n1731                 extralines.append(nextline)\n1732             else:\n1733                 msg = f\"remains unmatched: {line!r}\"\n1734                 self._log(msg)\n1735                 self._fail(msg)\n1736         self._log_output = []\n1737 \n1738     def no_fnmatch_line(self, pat: str) -> None:\n1739         \"\"\"Ensure captured lines do not match the given pattern, using ``fnmatch.fnmatch``.\n1740 \n1741         :param str pat: The pattern to match lines.\n1742         \"\"\"\n1743         __tracebackhide__ = True\n1744         self._no_match_line(pat, fnmatch, \"fnmatch\")\n1745 \n1746     def no_re_match_line(self, pat: str) -> None:\n1747         \"\"\"Ensure captured lines do not match the given pattern, using ``re.match``.\n1748 \n1749         :param str pat: The regular expression to match lines.\n1750         \"\"\"\n1751         __tracebackhide__ = True\n1752         self._no_match_line(\n1753             pat, lambda name, pat: bool(re.match(pat, name)), \"re.match\"\n1754         )\n1755 \n1756     def _no_match_line(\n1757         self, pat: str, match_func: Callable[[str, str], bool], match_nickname: str\n1758     ) -> None:\n1759         \"\"\"Ensure captured lines does not have a the given pattern, using ``fnmatch.fnmatch``.\n1760 \n1761         :param str pat: The pattern to match lines.\n1762         \"\"\"\n1763         __tracebackhide__ = True\n1764         nomatch_printed = False\n1765         wnick = len(match_nickname) + 1\n1766         for line in self.lines:\n1767             if match_func(line, pat):\n1768                 msg = f\"{match_nickname}: {pat!r}\"\n1769                 self._log(msg)\n1770                 self._log(\"{:>{width}}\".format(\"with:\", width=wnick), repr(line))\n1771                 self._fail(msg)\n1772             else:\n1773                 if not nomatch_printed:\n1774                     self._log(\"{:>{width}}\".format(\"nomatch:\", width=wnick), repr(pat))\n1775                     nomatch_printed = True\n1776                 self._log(\"{:>{width}}\".format(\"and:\", width=wnick), repr(line))\n1777         self._log_output = []\n1778 \n1779     def _fail(self, msg: str) -> None:\n1780         __tracebackhide__ = True\n1781         log_text = self._log_text\n1782         self._log_output = []\n1783         fail(log_text)\n1784 \n1785     def str(self) -> str:\n1786         \"\"\"Return the entire original text.\"\"\"\n1787         return str(self)\n",
        "intended_behavior": "When using `importlib` for dynamic imports, the application should implement checks or strategies to avoid importing the same module under different names or paths, which could lead to the observed issue of having two different versions of `pmxbot.logging`. This might include enhancing the logic around module importation to reference or augment Python's import machinery, ensuring that `sys.modules` is appropriately managed to unify module instances."
    },
    {
        "rel_file_path": "src/_pytest/pathlib.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/pytest-dev__pytest/setup_pytest-dev__pytest__8.0/src/_pytest/pathlib.py",
        "start": 1,
        "end": 787,
        "class_name": null,
        "method_name": null,
        "code": "1 import atexit\n2 import contextlib\n3 import fnmatch\n4 import importlib.util\n5 import itertools\n6 import os\n7 import shutil\n8 import sys\n9 import types\n10 import uuid\n11 import warnings\n12 from enum import Enum\n13 from errno import EBADF\n14 from errno import ELOOP\n15 from errno import ENOENT\n16 from errno import ENOTDIR\n17 from functools import partial\n18 from os.path import expanduser\n19 from os.path import expandvars\n20 from os.path import isabs\n21 from os.path import sep\n22 from pathlib import Path\n23 from pathlib import PurePath\n24 from posixpath import sep as posix_sep\n25 from types import ModuleType\n26 from typing import Callable\n27 from typing import Dict\n28 from typing import Iterable\n29 from typing import Iterator\n30 from typing import List\n31 from typing import Optional\n32 from typing import Set\n33 from typing import Tuple\n34 from typing import Type\n35 from typing import TypeVar\n36 from typing import Union\n37 \n38 from _pytest.compat import assert_never\n39 from _pytest.outcomes import skip\n40 from _pytest.warning_types import PytestWarning\n41 \n42 LOCK_TIMEOUT = 60 * 60 * 24 * 3\n43 \n44 \n45 _AnyPurePath = TypeVar(\"_AnyPurePath\", bound=PurePath)\n46 \n47 # The following function, variables and comments were\n48 # copied from cpython 3.9 Lib/pathlib.py file.\n49 \n50 # EBADF - guard against macOS `stat` throwing EBADF\n51 _IGNORED_ERRORS = (ENOENT, ENOTDIR, EBADF, ELOOP)\n52 \n53 _IGNORED_WINERRORS = (\n54     21,  # ERROR_NOT_READY - drive exists but is not accessible\n55     1921,  # ERROR_CANT_RESOLVE_FILENAME - fix for broken symlink pointing to itself\n56 )\n57 \n58 \n59 def _ignore_error(exception):\n60     return (\n61         getattr(exception, \"errno\", None) in _IGNORED_ERRORS\n62         or getattr(exception, \"winerror\", None) in _IGNORED_WINERRORS\n63     )\n64 \n65 \n66 def get_lock_path(path: _AnyPurePath) -> _AnyPurePath:\n67     return path.joinpath(\".lock\")\n68 \n69 \n70 def on_rm_rf_error(\n71     func,\n72     path: str,\n73     excinfo: Union[\n74         BaseException,\n75         Tuple[Type[BaseException], BaseException, Optional[types.TracebackType]],\n76     ],\n77     *,\n78     start_path: Path,\n79 ) -> bool:\n80     \"\"\"Handle known read-only errors during rmtree.\n81 \n82     The returned value is used only by our own tests.\n83     \"\"\"\n84     if isinstance(excinfo, BaseException):\n85         exc = excinfo\n86     else:\n87         exc = excinfo[1]\n88 \n89     # Another process removed the file in the middle of the \"rm_rf\" (xdist for example).\n90     # More context: https://github.com/pytest-dev/pytest/issues/5974#issuecomment-543799018\n91     if isinstance(exc, FileNotFoundError):\n92         return False\n93 \n94     if not isinstance(exc, PermissionError):\n95         warnings.warn(\n96             PytestWarning(f\"(rm_rf) error removing {path}\\n{type(exc)}: {exc}\")\n97         )\n98         return False\n99 \n100     if func not in (os.rmdir, os.remove, os.unlink):\n101         if func not in (os.open,):\n102             warnings.warn(\n103                 PytestWarning(\n104                     \"(rm_rf) unknown function {} when removing {}:\\n{}: {}\".format(\n105                         func, path, type(exc), exc\n106                     )\n107                 )\n108             )\n109         return False\n110 \n111     # Chmod + retry.\n112     import stat\n113 \n114     def chmod_rw(p: str) -> None:\n115         mode = os.stat(p).st_mode\n116         os.chmod(p, mode | stat.S_IRUSR | stat.S_IWUSR)\n117 \n118     # For files, we need to recursively go upwards in the directories to\n119     # ensure they all are also writable.\n120     p = Path(path)\n121     if p.is_file():\n122         for parent in p.parents:\n123             chmod_rw(str(parent))\n124             # Stop when we reach the original path passed to rm_rf.\n125             if parent == start_path:\n126                 break\n127     chmod_rw(str(path))\n128 \n129     func(path)\n130     return True\n131 \n132 \n133 def ensure_extended_length_path(path: Path) -> Path:\n134     \"\"\"Get the extended-length version of a path (Windows).\n135 \n136     On Windows, by default, the maximum length of a path (MAX_PATH) is 260\n137     characters, and operations on paths longer than that fail. But it is possible\n138     to overcome this by converting the path to \"extended-length\" form before\n139     performing the operation:\n140     https://docs.microsoft.com/en-us/windows/win32/fileio/naming-a-file#maximum-path-length-limitation\n141 \n142     On Windows, this function returns the extended-length absolute version of path.\n143     On other platforms it returns path unchanged.\n144     \"\"\"\n145     if sys.platform.startswith(\"win32\"):\n146         path = path.resolve()\n147         path = Path(get_extended_length_path_str(str(path)))\n148     return path\n149 \n150 \n151 def get_extended_length_path_str(path: str) -> str:\n152     \"\"\"Convert a path to a Windows extended length path.\"\"\"\n153     long_path_prefix = \"\\\\\\\\?\\\\\"\n154     unc_long_path_prefix = \"\\\\\\\\?\\\\UNC\\\\\"\n155     if path.startswith((long_path_prefix, unc_long_path_prefix)):\n156         return path\n157     # UNC\n158     if path.startswith(\"\\\\\\\\\"):\n159         return unc_long_path_prefix + path[2:]\n160     return long_path_prefix + path\n161 \n162 \n163 def rm_rf(path: Path) -> None:\n164     \"\"\"Remove the path contents recursively, even if some elements\n165     are read-only.\"\"\"\n166     path = ensure_extended_length_path(path)\n167     onerror = partial(on_rm_rf_error, start_path=path)\n168     if sys.version_info >= (3, 12):\n169         shutil.rmtree(str(path), onexc=onerror)\n170     else:\n171         shutil.rmtree(str(path), onerror=onerror)\n172 \n173 \n174 def find_prefixed(root: Path, prefix: str) -> Iterator[Path]:\n175     \"\"\"Find all elements in root that begin with the prefix, case insensitive.\"\"\"\n176     l_prefix = prefix.lower()\n177     for x in root.iterdir():\n178         if x.name.lower().startswith(l_prefix):\n179             yield x\n180 \n181 \n182 def extract_suffixes(iter: Iterable[PurePath], prefix: str) -> Iterator[str]:\n183     \"\"\"Return the parts of the paths following the prefix.\n184 \n185     :param iter: Iterator over path names.\n186     :param prefix: Expected prefix of the path names.\n187     \"\"\"\n188     p_len = len(prefix)\n189     for p in iter:\n190         yield p.name[p_len:]\n191 \n192 \n193 def find_suffixes(root: Path, prefix: str) -> Iterator[str]:\n194     \"\"\"Combine find_prefixes and extract_suffixes.\"\"\"\n195     return extract_suffixes(find_prefixed(root, prefix), prefix)\n196 \n197 \n198 def parse_num(maybe_num) -> int:\n199     \"\"\"Parse number path suffixes, returns -1 on error.\"\"\"\n200     try:\n201         return int(maybe_num)\n202     except ValueError:\n203         return -1\n204 \n205 \n206 def _force_symlink(\n207     root: Path, target: Union[str, PurePath], link_to: Union[str, Path]\n208 ) -> None:\n209     \"\"\"Helper to create the current symlink.\n210 \n211     It's full of race conditions that are reasonably OK to ignore\n212     for the context of best effort linking to the latest test run.\n213 \n214     The presumption being that in case of much parallelism\n215     the inaccuracy is going to be acceptable.\n216     \"\"\"\n217     current_symlink = root.joinpath(target)\n218     try:\n219         current_symlink.unlink()\n220     except OSError:\n221         pass\n222     try:\n223         current_symlink.symlink_to(link_to)\n224     except Exception:\n225         pass\n226 \n227 \n228 def make_numbered_dir(root: Path, prefix: str, mode: int = 0o700) -> Path:\n229     \"\"\"Create a directory with an increased number as suffix for the given prefix.\"\"\"\n230     for i in range(10):\n231         # try up to 10 times to create the folder\n232         max_existing = max(map(parse_num, find_suffixes(root, prefix)), default=-1)\n233         new_number = max_existing + 1\n234         new_path = root.joinpath(f\"{prefix}{new_number}\")\n235         try:\n236             new_path.mkdir(mode=mode)\n237         except Exception:\n238             pass\n239         else:\n240             _force_symlink(root, prefix + \"current\", new_path)\n241             return new_path\n242     else:\n243         raise OSError(\n244             \"could not create numbered dir with prefix \"\n245             \"{prefix} in {root} after 10 tries\".format(prefix=prefix, root=root)\n246         )\n247 \n248 \n249 def create_cleanup_lock(p: Path) -> Path:\n250     \"\"\"Create a lock to prevent premature folder cleanup.\"\"\"\n251     lock_path = get_lock_path(p)\n252     try:\n253         fd = os.open(str(lock_path), os.O_WRONLY | os.O_CREAT | os.O_EXCL, 0o644)\n254     except FileExistsError as e:\n255         raise OSError(f\"cannot create lockfile in {p}\") from e\n256     else:\n257         pid = os.getpid()\n258         spid = str(pid).encode()\n259         os.write(fd, spid)\n260         os.close(fd)\n261         if not lock_path.is_file():\n262             raise OSError(\"lock path got renamed after successful creation\")\n263         return lock_path\n264 \n265 \n266 def register_cleanup_lock_removal(lock_path: Path, register=atexit.register):\n267     \"\"\"Register a cleanup function for removing a lock, by default on atexit.\"\"\"\n268     pid = os.getpid()\n269 \n270     def cleanup_on_exit(lock_path: Path = lock_path, original_pid: int = pid) -> None:\n271         current_pid = os.getpid()\n272         if current_pid != original_pid:\n273             # fork\n274             return\n275         try:\n276             lock_path.unlink()\n277         except OSError:\n278             pass\n279 \n280     return register(cleanup_on_exit)\n281 \n282 \n283 def maybe_delete_a_numbered_dir(path: Path) -> None:\n284     \"\"\"Remove a numbered directory if its lock can be obtained and it does\n285     not seem to be in use.\"\"\"\n286     path = ensure_extended_length_path(path)\n287     lock_path = None\n288     try:\n289         lock_path = create_cleanup_lock(path)\n290         parent = path.parent\n291 \n292         garbage = parent.joinpath(f\"garbage-{uuid.uuid4()}\")\n293         path.rename(garbage)\n294         rm_rf(garbage)\n295     except OSError:\n296         #  known races:\n297         #  * other process did a cleanup at the same time\n298         #  * deletable folder was found\n299         #  * process cwd (Windows)\n300         return\n301     finally:\n302         # If we created the lock, ensure we remove it even if we failed\n303         # to properly remove the numbered dir.\n304         if lock_path is not None:\n305             try:\n306                 lock_path.unlink()\n307             except OSError:\n308                 pass\n309 \n310 \n311 def ensure_deletable(path: Path, consider_lock_dead_if_created_before: float) -> bool:\n312     \"\"\"Check if `path` is deletable based on whether the lock file is expired.\"\"\"\n313     if path.is_symlink():\n314         return False\n315     lock = get_lock_path(path)\n316     try:\n317         if not lock.is_file():\n318             return True\n319     except OSError:\n320         # we might not have access to the lock file at all, in this case assume\n321         # we don't have access to the entire directory (#7491).\n322         return False\n323     try:\n324         lock_time = lock.stat().st_mtime\n325     except Exception:\n326         return False\n327     else:\n328         if lock_time < consider_lock_dead_if_created_before:\n329             # We want to ignore any errors while trying to remove the lock such as:\n330             # - PermissionDenied, like the file permissions have changed since the lock creation;\n331             # - FileNotFoundError, in case another pytest process got here first;\n332             # and any other cause of failure.\n333             with contextlib.suppress(OSError):\n334                 lock.unlink()\n335                 return True\n336         return False\n337 \n338 \n339 def try_cleanup(path: Path, consider_lock_dead_if_created_before: float) -> None:\n340     \"\"\"Try to cleanup a folder if we can ensure it's deletable.\"\"\"\n341     if ensure_deletable(path, consider_lock_dead_if_created_before):\n342         maybe_delete_a_numbered_dir(path)\n343 \n344 \n345 def cleanup_candidates(root: Path, prefix: str, keep: int) -> Iterator[Path]:\n346     \"\"\"List candidates for numbered directories to be removed - follows py.path.\"\"\"\n347     max_existing = max(map(parse_num, find_suffixes(root, prefix)), default=-1)\n348     max_delete = max_existing - keep\n349     paths = find_prefixed(root, prefix)\n350     paths, paths2 = itertools.tee(paths)\n351     numbers = map(parse_num, extract_suffixes(paths2, prefix))\n352     for path, number in zip(paths, numbers):\n353         if number <= max_delete:\n354             yield path\n355 \n356 \n357 def cleanup_dead_symlinks(root: Path):\n358     for left_dir in root.iterdir():\n359         if left_dir.is_symlink():\n360             if not left_dir.resolve().exists():\n361                 left_dir.unlink()\n362 \n363 \n364 def cleanup_numbered_dir(\n365     root: Path, prefix: str, keep: int, consider_lock_dead_if_created_before: float\n366 ) -> None:\n367     \"\"\"Cleanup for lock driven numbered directories.\"\"\"\n368     if not root.exists():\n369         return\n370     for path in cleanup_candidates(root, prefix, keep):\n371         try_cleanup(path, consider_lock_dead_if_created_before)\n372     for path in root.glob(\"garbage-*\"):\n373         try_cleanup(path, consider_lock_dead_if_created_before)\n374 \n375     cleanup_dead_symlinks(root)\n376 \n377 \n378 def make_numbered_dir_with_cleanup(\n379     root: Path,\n380     prefix: str,\n381     keep: int,\n382     lock_timeout: float,\n383     mode: int,\n384 ) -> Path:\n385     \"\"\"Create a numbered dir with a cleanup lock and remove old ones.\"\"\"\n386     e = None\n387     for i in range(10):\n388         try:\n389             p = make_numbered_dir(root, prefix, mode)\n390             # Only lock the current dir when keep is not 0\n391             if keep != 0:\n392                 lock_path = create_cleanup_lock(p)\n393                 register_cleanup_lock_removal(lock_path)\n394         except Exception as exc:\n395             e = exc\n396         else:\n397             consider_lock_dead_if_created_before = p.stat().st_mtime - lock_timeout\n398             # Register a cleanup for program exit\n399             atexit.register(\n400                 cleanup_numbered_dir,\n401                 root,\n402                 prefix,\n403                 keep,\n404                 consider_lock_dead_if_created_before,\n405             )\n406             return p\n407     assert e is not None\n408     raise e\n409 \n410 \n411 def resolve_from_str(input: str, rootpath: Path) -> Path:\n412     input = expanduser(input)\n413     input = expandvars(input)\n414     if isabs(input):\n415         return Path(input)\n416     else:\n417         return rootpath.joinpath(input)\n418 \n419 \n420 def fnmatch_ex(pattern: str, path: Union[str, \"os.PathLike[str]\"]) -> bool:\n421     \"\"\"A port of FNMatcher from py.path.common which works with PurePath() instances.\n422 \n423     The difference between this algorithm and PurePath.match() is that the\n424     latter matches \"**\" glob expressions for each part of the path, while\n425     this algorithm uses the whole path instead.\n426 \n427     For example:\n428         \"tests/foo/bar/doc/test_foo.py\" matches pattern \"tests/**/doc/test*.py\"\n429         with this algorithm, but not with PurePath.match().\n430 \n431     This algorithm was ported to keep backward-compatibility with existing\n432     settings which assume paths match according this logic.\n433 \n434     References:\n435     * https://bugs.python.org/issue29249\n436     * https://bugs.python.org/issue34731\n437     \"\"\"\n438     path = PurePath(path)\n439     iswin32 = sys.platform.startswith(\"win\")\n440 \n441     if iswin32 and sep not in pattern and posix_sep in pattern:\n442         # Running on Windows, the pattern has no Windows path separators,\n443         # and the pattern has one or more Posix path separators. Replace\n444         # the Posix path separators with the Windows path separator.\n445         pattern = pattern.replace(posix_sep, sep)\n446 \n447     if sep not in pattern:\n448         name = path.name\n449     else:\n450         name = str(path)\n451         if path.is_absolute() and not os.path.isabs(pattern):\n452             pattern = f\"*{os.sep}{pattern}\"\n453     return fnmatch.fnmatch(name, pattern)\n454 \n455 \n456 def parts(s: str) -> Set[str]:\n457     parts = s.split(sep)\n458     return {sep.join(parts[: i + 1]) or sep for i in range(len(parts))}\n459 \n460 \n461 def symlink_or_skip(src, dst, **kwargs):\n462     \"\"\"Make a symlink, or skip the test in case symlinks are not supported.\"\"\"\n463     try:\n464         os.symlink(str(src), str(dst), **kwargs)\n465     except OSError as e:\n466         skip(f\"symlinks not supported: {e}\")\n467 \n468 \n469 class ImportMode(Enum):\n470     \"\"\"Possible values for `mode` parameter of `import_path`.\"\"\"\n471 \n472     prepend = \"prepend\"\n473     append = \"append\"\n474     importlib = \"importlib\"\n475 \n476 \n477 class ImportPathMismatchError(ImportError):\n478     \"\"\"Raised on import_path() if there is a mismatch of __file__'s.\n479 \n480     This can happen when `import_path` is called multiple times with different filenames that has\n481     the same basename but reside in packages\n482     (for example \"/tests1/test_foo.py\" and \"/tests2/test_foo.py\").\n483     \"\"\"\n484 \n485 \n486 def import_path(\n487     p: Union[str, \"os.PathLike[str]\"],\n488     *,\n489     mode: Union[str, ImportMode] = ImportMode.prepend,\n490     root: Path,\n491 ) -> ModuleType:\n492     \"\"\"Import and return a module from the given path, which can be a file (a module) or\n493     a directory (a package).\n494 \n495     The import mechanism used is controlled by the `mode` parameter:\n496 \n497     * `mode == ImportMode.prepend`: the directory containing the module (or package, taking\n498       `__init__.py` files into account) will be put at the *start* of `sys.path` before\n499       being imported with `importlib.import_module`.\n500 \n501     * `mode == ImportMode.append`: same as `prepend`, but the directory will be appended\n502       to the end of `sys.path`, if not already in `sys.path`.\n503 \n504     * `mode == ImportMode.importlib`: uses more fine control mechanisms provided by `importlib`\n505       to import the module, which avoids having to muck with `sys.path` at all. It effectively\n506       allows having same-named test modules in different places.\n507 \n508     :param root:\n509         Used as an anchor when mode == ImportMode.importlib to obtain\n510         a unique name for the module being imported so it can safely be stored\n511         into ``sys.modules``.\n512 \n513     :raises ImportPathMismatchError:\n514         If after importing the given `path` and the module `__file__`\n515         are different. Only raised in `prepend` and `append` modes.\n516     \"\"\"\n517     mode = ImportMode(mode)\n518 \n519     path = Path(p)\n520 \n521     if not path.exists():\n522         raise ImportError(path)\n523 \n524     if mode is ImportMode.importlib:\n525         module_name = module_name_from_path(path, root)\n526 \n527         for meta_importer in sys.meta_path:\n528             spec = meta_importer.find_spec(module_name, [str(path.parent)])\n529             if spec is not None:\n530                 break\n531         else:\n532             spec = importlib.util.spec_from_file_location(module_name, str(path))\n533 \n534         if spec is None:\n535             raise ImportError(f\"Can't find module {module_name} at location {path}\")\n536         mod = importlib.util.module_from_spec(spec)\n537         sys.modules[module_name] = mod\n538         spec.loader.exec_module(mod)  # type: ignore[union-attr]\n539         insert_missing_modules(sys.modules, module_name)\n540         return mod\n541 \n542     pkg_path = resolve_package_path(path)\n543     if pkg_path is not None:\n544         pkg_root = pkg_path.parent\n545         names = list(path.with_suffix(\"\").relative_to(pkg_root).parts)\n546         if names[-1] == \"__init__\":\n547             names.pop()\n548         module_name = \".\".join(names)\n549     else:\n550         pkg_root = path.parent\n551         module_name = path.stem\n552 \n553     # Change sys.path permanently: restoring it at the end of this function would cause surprising\n554     # problems because of delayed imports: for example, a conftest.py file imported by this function\n555     # might have local imports, which would fail at runtime if we restored sys.path.\n556     if mode is ImportMode.append:\n557         if str(pkg_root) not in sys.path:\n558             sys.path.append(str(pkg_root))\n559     elif mode is ImportMode.prepend:\n560         if str(pkg_root) != sys.path[0]:\n561             sys.path.insert(0, str(pkg_root))\n562     else:\n563         assert_never(mode)\n564 \n565     importlib.import_module(module_name)\n566 \n567     mod = sys.modules[module_name]\n568     if path.name == \"__init__.py\":\n569         return mod\n570 \n571     ignore = os.environ.get(\"PY_IGNORE_IMPORTMISMATCH\", \"\")\n572     if ignore != \"1\":\n573         module_file = mod.__file__\n574         if module_file is None:\n575             raise ImportPathMismatchError(module_name, module_file, path)\n576 \n577         if module_file.endswith((\".pyc\", \".pyo\")):\n578             module_file = module_file[:-1]\n579         if module_file.endswith(os.sep + \"__init__.py\"):\n580             module_file = module_file[: -(len(os.sep + \"__init__.py\"))]\n581 \n582         try:\n583             is_same = _is_same(str(path), module_file)\n584         except FileNotFoundError:\n585             is_same = False\n586 \n587         if not is_same:\n588             raise ImportPathMismatchError(module_name, module_file, path)\n589 \n590     return mod\n591 \n592 \n593 # Implement a special _is_same function on Windows which returns True if the two filenames\n594 # compare equal, to circumvent os.path.samefile returning False for mounts in UNC (#7678).\n595 if sys.platform.startswith(\"win\"):\n596 \n597     def _is_same(f1: str, f2: str) -> bool:\n598         return Path(f1) == Path(f2) or os.path.samefile(f1, f2)\n599 \n600 else:\n601 \n602     def _is_same(f1: str, f2: str) -> bool:\n603         return os.path.samefile(f1, f2)\n604 \n605 \n606 def module_name_from_path(path: Path, root: Path) -> str:\n607     \"\"\"\n608     Return a dotted module name based on the given path, anchored on root.\n609 \n610     For example: path=\"projects/src/tests/test_foo.py\" and root=\"/projects\", the\n611     resulting module name will be \"src.tests.test_foo\".\n612     \"\"\"\n613     path = path.with_suffix(\"\")\n614     try:\n615         relative_path = path.relative_to(root)\n616     except ValueError:\n617         # If we can't get a relative path to root, use the full path, except\n618         # for the first part (\"d:\\\\\" or \"/\" depending on the platform, for example).\n619         path_parts = path.parts[1:]\n620     else:\n621         # Use the parts for the relative path to the root path.\n622         path_parts = relative_path.parts\n623 \n624     return \".\".join(path_parts)\n625 \n626 \n627 def insert_missing_modules(modules: Dict[str, ModuleType], module_name: str) -> None:\n628     \"\"\"\n629     Used by ``import_path`` to create intermediate modules when using mode=importlib.\n630 \n631     When we want to import a module as \"src.tests.test_foo\" for example, we need\n632     to create empty modules \"src\" and \"src.tests\" after inserting \"src.tests.test_foo\",\n633     otherwise \"src.tests.test_foo\" is not importable by ``__import__``.\n634     \"\"\"\n635     module_parts = module_name.split(\".\")\n636     child_module: Union[ModuleType, None] = None\n637     module: Union[ModuleType, None] = None\n638     child_name: str = \"\"\n639     while module_name:\n640         if module_name not in modules:\n641             try:\n642                 # If sys.meta_path is empty, calling import_module will issue\n643                 # a warning and raise ModuleNotFoundError. To avoid the\n644                 # warning, we check sys.meta_path explicitly and raise the error\n645                 # ourselves to fall back to creating a dummy module.\n646                 if not sys.meta_path:\n647                     raise ModuleNotFoundError\n648                 module = importlib.import_module(module_name)\n649             except ModuleNotFoundError:\n650                 module = ModuleType(\n651                     module_name,\n652                     doc=\"Empty module created by pytest's importmode=importlib.\",\n653                 )\n654         else:\n655             module = modules[module_name]\n656         if child_module:\n657             # Add child attribute to the parent that can reference the child\n658             # modules.\n659             if not hasattr(module, child_name):\n660                 setattr(module, child_name, child_module)\n661                 modules[module_name] = module\n662         # Keep track of the child module while moving up the tree.\n663         child_module, child_name = module, module_name.rpartition(\".\")[-1]\n664         module_parts.pop(-1)\n665         module_name = \".\".join(module_parts)\n666 \n667 \n668 def resolve_package_path(path: Path) -> Optional[Path]:\n669     \"\"\"Return the Python package path by looking for the last\n670     directory upwards which still contains an __init__.py.\n671 \n672     Returns None if it can not be determined.\n673     \"\"\"\n674     result = None\n675     for parent in itertools.chain((path,), path.parents):\n676         if parent.is_dir():\n677             if not parent.joinpath(\"__init__.py\").is_file():\n678                 break\n679             if not parent.name.isidentifier():\n680                 break\n681             result = parent\n682     return result\n683 \n684 \n685 def scandir(path: Union[str, \"os.PathLike[str]\"]) -> List[\"os.DirEntry[str]\"]:\n686     \"\"\"Scan a directory recursively, in breadth-first order.\n687 \n688     The returned entries are sorted.\n689     \"\"\"\n690     entries = []\n691     with os.scandir(path) as s:\n692         # Skip entries with symlink loops and other brokenness, so the caller\n693         # doesn't have to deal with it.\n694         for entry in s:\n695             try:\n696                 entry.is_file()\n697             except OSError as err:\n698                 if _ignore_error(err):\n699                     continue\n700                 raise\n701             entries.append(entry)\n702     entries.sort(key=lambda entry: entry.name)\n703     return entries\n704 \n705 \n706 def visit(\n707     path: Union[str, \"os.PathLike[str]\"], recurse: Callable[[\"os.DirEntry[str]\"], bool]\n708 ) -> Iterator[\"os.DirEntry[str]\"]:\n709     \"\"\"Walk a directory recursively, in breadth-first order.\n710 \n711     The `recurse` predicate determines whether a directory is recursed.\n712 \n713     Entries at each directory level are sorted.\n714     \"\"\"\n715     entries = scandir(path)\n716     yield from entries\n717     for entry in entries:\n718         if entry.is_dir() and recurse(entry):\n719             yield from visit(entry.path, recurse)\n720 \n721 \n722 def absolutepath(path: Union[Path, str]) -> Path:\n723     \"\"\"Convert a path to an absolute path using os.path.abspath.\n724 \n725     Prefer this over Path.resolve() (see #6523).\n726     Prefer this over Path.absolute() (not public, doesn't normalize).\n727     \"\"\"\n728     return Path(os.path.abspath(str(path)))\n729 \n730 \n731 def commonpath(path1: Path, path2: Path) -> Optional[Path]:\n732     \"\"\"Return the common part shared with the other path, or None if there is\n733     no common part.\n734 \n735     If one path is relative and one is absolute, returns None.\n736     \"\"\"\n737     try:\n738         return Path(os.path.commonpath((str(path1), str(path2))))\n739     except ValueError:\n740         return None\n741 \n742 \n743 def bestrelpath(directory: Path, dest: Path) -> str:\n744     \"\"\"Return a string which is a relative path from directory to dest such\n745     that directory/bestrelpath == dest.\n746 \n747     The paths must be either both absolute or both relative.\n748 \n749     If no such path can be determined, returns dest.\n750     \"\"\"\n751     assert isinstance(directory, Path)\n752     assert isinstance(dest, Path)\n753     if dest == directory:\n754         return os.curdir\n755     # Find the longest common directory.\n756     base = commonpath(directory, dest)\n757     # Can be the case on Windows for two absolute paths on different drives.\n758     # Can be the case for two relative paths without common prefix.\n759     # Can be the case for a relative path and an absolute path.\n760     if not base:\n761         return str(dest)\n762     reldirectory = directory.relative_to(base)\n763     reldest = dest.relative_to(base)\n764     return os.path.join(\n765         # Back from directory to base.\n766         *([os.pardir] * len(reldirectory.parts)),\n767         # Forward from base to dest.\n768         *reldest.parts,\n769     )\n770 \n771 \n772 # Originates from py. path.local.copy(), with siginficant trims and adjustments.\n773 # TODO(py38): Replace with shutil.copytree(..., symlinks=True, dirs_exist_ok=True)\n774 def copytree(source: Path, target: Path) -> None:\n775     \"\"\"Recursively copy a source directory to target.\"\"\"\n776     assert source.is_dir()\n777     for entry in visit(source, recurse=lambda entry: not entry.is_symlink()):\n778         x = Path(entry)\n779         relpath = x.relative_to(source)\n780         newx = target / relpath\n781         newx.parent.mkdir(exist_ok=True)\n782         if x.is_symlink():\n783             newx.symlink_to(os.readlink(x))\n784         elif x.is_file():\n785             shutil.copyfile(x, newx)\n786         elif x.is_dir():\n787             newx.mkdir(exist_ok=True)\n",
        "intended_behavior": "When using `importlib` for dynamic imports, the application should implement checks or strategies to avoid importing the same module under different names or paths, which could lead to the observed issue of having two different versions of `pmxbot.logging`. This might include enhancing the logic around module importation to reference or augment Python's import machinery, ensuring that `sys.modules` is appropriately managed to unify module instances."
    },
    {
        "rel_file_path": "src/_pytest/assertion/rewrite.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/pytest-dev__pytest/setup_pytest-dev__pytest__8.0/src/_pytest/assertion/rewrite.py",
        "start": 1,
        "end": 1171,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\"Rewrite assertion AST to produce nice error messages.\"\"\"\n2 import ast\n3 import errno\n4 import functools\n5 import importlib.abc\n6 import importlib.machinery\n7 import importlib.util\n8 import io\n9 import itertools\n10 import marshal\n11 import os\n12 import struct\n13 import sys\n14 import tokenize\n15 import types\n16 from pathlib import Path\n17 from pathlib import PurePath\n18 from typing import Callable\n19 from typing import Dict\n20 from typing import IO\n21 from typing import Iterable\n22 from typing import Iterator\n23 from typing import List\n24 from typing import Optional\n25 from typing import Sequence\n26 from typing import Set\n27 from typing import Tuple\n28 from typing import TYPE_CHECKING\n29 from typing import Union\n30 \n31 from _pytest._io.saferepr import DEFAULT_REPR_MAX_SIZE\n32 from _pytest._io.saferepr import saferepr\n33 from _pytest._version import version\n34 from _pytest.assertion import util\n35 from _pytest.assertion.util import (  # noqa: F401\n36     format_explanation as _format_explanation,\n37 )\n38 from _pytest.config import Config\n39 from _pytest.main import Session\n40 from _pytest.pathlib import absolutepath\n41 from _pytest.pathlib import fnmatch_ex\n42 from _pytest.stash import StashKey\n43 \n44 if TYPE_CHECKING:\n45     from _pytest.assertion import AssertionState\n46 \n47 \n48 assertstate_key = StashKey[\"AssertionState\"]()\n49 \n50 # pytest caches rewritten pycs in pycache dirs\n51 PYTEST_TAG = f\"{sys.implementation.cache_tag}-pytest-{version}\"\n52 PYC_EXT = \".py\" + (__debug__ and \"c\" or \"o\")\n53 PYC_TAIL = \".\" + PYTEST_TAG + PYC_EXT\n54 \n55 \n56 class AssertionRewritingHook(importlib.abc.MetaPathFinder, importlib.abc.Loader):\n57     \"\"\"PEP302/PEP451 import hook which rewrites asserts.\"\"\"\n58 \n59     def __init__(self, config: Config) -> None:\n60         self.config = config\n61         try:\n62             self.fnpats = config.getini(\"python_files\")\n63         except ValueError:\n64             self.fnpats = [\"test_*.py\", \"*_test.py\"]\n65         self.session: Optional[Session] = None\n66         self._rewritten_names: Dict[str, Path] = {}\n67         self._must_rewrite: Set[str] = set()\n68         # flag to guard against trying to rewrite a pyc file while we are already writing another pyc file,\n69         # which might result in infinite recursion (#3506)\n70         self._writing_pyc = False\n71         self._basenames_to_check_rewrite = {\"conftest\"}\n72         self._marked_for_rewrite_cache: Dict[str, bool] = {}\n73         self._session_paths_checked = False\n74 \n75     def set_session(self, session: Optional[Session]) -> None:\n76         self.session = session\n77         self._session_paths_checked = False\n78 \n79     # Indirection so we can mock calls to find_spec originated from the hook during testing\n80     _find_spec = importlib.machinery.PathFinder.find_spec\n81 \n82     def find_spec(\n83         self,\n84         name: str,\n85         path: Optional[Sequence[Union[str, bytes]]] = None,\n86         target: Optional[types.ModuleType] = None,\n87     ) -> Optional[importlib.machinery.ModuleSpec]:\n88         if self._writing_pyc:\n89             return None\n90         state = self.config.stash[assertstate_key]\n91         if self._early_rewrite_bailout(name, state):\n92             return None\n93         state.trace(\"find_module called for: %s\" % name)\n94 \n95         # Type ignored because mypy is confused about the `self` binding here.\n96         spec = self._find_spec(name, path)  # type: ignore\n97         if (\n98             # the import machinery could not find a file to import\n99             spec is None\n100             # this is a namespace package (without `__init__.py`)\n101             # there's nothing to rewrite there\n102             or spec.origin is None\n103             # we can only rewrite source files\n104             or not isinstance(spec.loader, importlib.machinery.SourceFileLoader)\n105             # if the file doesn't exist, we can't rewrite it\n106             or not os.path.exists(spec.origin)\n107         ):\n108             return None\n109         else:\n110             fn = spec.origin\n111 \n112         if not self._should_rewrite(name, fn, state):\n113             return None\n114 \n115         return importlib.util.spec_from_file_location(\n116             name,\n117             fn,\n118             loader=self,\n119             submodule_search_locations=spec.submodule_search_locations,\n120         )\n121 \n122     def create_module(\n123         self, spec: importlib.machinery.ModuleSpec\n124     ) -> Optional[types.ModuleType]:\n125         return None  # default behaviour is fine\n126 \n127     def exec_module(self, module: types.ModuleType) -> None:\n128         assert module.__spec__ is not None\n129         assert module.__spec__.origin is not None\n130         fn = Path(module.__spec__.origin)\n131         state = self.config.stash[assertstate_key]\n132 \n133         self._rewritten_names[module.__name__] = fn\n134 \n135         # The requested module looks like a test file, so rewrite it. This is\n136         # the most magical part of the process: load the source, rewrite the\n137         # asserts, and load the rewritten source. We also cache the rewritten\n138         # module code in a special pyc. We must be aware of the possibility of\n139         # concurrent pytest processes rewriting and loading pycs. To avoid\n140         # tricky race conditions, we maintain the following invariant: The\n141         # cached pyc is always a complete, valid pyc. Operations on it must be\n142         # atomic. POSIX's atomic rename comes in handy.\n143         write = not sys.dont_write_bytecode\n144         cache_dir = get_cache_dir(fn)\n145         if write:\n146             ok = try_makedirs(cache_dir)\n147             if not ok:\n148                 write = False\n149                 state.trace(f\"read only directory: {cache_dir}\")\n150 \n151         cache_name = fn.name[:-3] + PYC_TAIL\n152         pyc = cache_dir / cache_name\n153         # Notice that even if we're in a read-only directory, I'm going\n154         # to check for a cached pyc. This may not be optimal...\n155         co = _read_pyc(fn, pyc, state.trace)\n156         if co is None:\n157             state.trace(f\"rewriting {fn!r}\")\n158             source_stat, co = _rewrite_test(fn, self.config)\n159             if write:\n160                 self._writing_pyc = True\n161                 try:\n162                     _write_pyc(state, co, source_stat, pyc)\n163                 finally:\n164                     self._writing_pyc = False\n165         else:\n166             state.trace(f\"found cached rewritten pyc for {fn}\")\n167         exec(co, module.__dict__)\n168 \n169     def _early_rewrite_bailout(self, name: str, state: \"AssertionState\") -> bool:\n170         \"\"\"A fast way to get out of rewriting modules.\n171 \n172         Profiling has shown that the call to PathFinder.find_spec (inside of\n173         the find_spec from this class) is a major slowdown, so, this method\n174         tries to filter what we're sure won't be rewritten before getting to\n175         it.\n176         \"\"\"\n177         if self.session is not None and not self._session_paths_checked:\n178             self._session_paths_checked = True\n179             for initial_path in self.session._initialpaths:\n180                 # Make something as c:/projects/my_project/path.py ->\n181                 #     ['c:', 'projects', 'my_project', 'path.py']\n182                 parts = str(initial_path).split(os.sep)\n183                 # add 'path' to basenames to be checked.\n184                 self._basenames_to_check_rewrite.add(os.path.splitext(parts[-1])[0])\n185 \n186         # Note: conftest already by default in _basenames_to_check_rewrite.\n187         parts = name.split(\".\")\n188         if parts[-1] in self._basenames_to_check_rewrite:\n189             return False\n190 \n191         # For matching the name it must be as if it was a filename.\n192         path = PurePath(*parts).with_suffix(\".py\")\n193 \n194         for pat in self.fnpats:\n195             # if the pattern contains subdirectories (\"tests/**.py\" for example) we can't bail out based\n196             # on the name alone because we need to match against the full path\n197             if os.path.dirname(pat):\n198                 return False\n199             if fnmatch_ex(pat, path):\n200                 return False\n201 \n202         if self._is_marked_for_rewrite(name, state):\n203             return False\n204 \n205         state.trace(f\"early skip of rewriting module: {name}\")\n206         return True\n207 \n208     def _should_rewrite(self, name: str, fn: str, state: \"AssertionState\") -> bool:\n209         # always rewrite conftest files\n210         if os.path.basename(fn) == \"conftest.py\":\n211             state.trace(f\"rewriting conftest file: {fn!r}\")\n212             return True\n213 \n214         if self.session is not None:\n215             if self.session.isinitpath(absolutepath(fn)):\n216                 state.trace(f\"matched test file (was specified on cmdline): {fn!r}\")\n217                 return True\n218 \n219         # modules not passed explicitly on the command line are only\n220         # rewritten if they match the naming convention for test files\n221         fn_path = PurePath(fn)\n222         for pat in self.fnpats:\n223             if fnmatch_ex(pat, fn_path):\n224                 state.trace(f\"matched test file {fn!r}\")\n225                 return True\n226 \n227         return self._is_marked_for_rewrite(name, state)\n228 \n229     def _is_marked_for_rewrite(self, name: str, state: \"AssertionState\") -> bool:\n230         try:\n231             return self._marked_for_rewrite_cache[name]\n232         except KeyError:\n233             for marked in self._must_rewrite:\n234                 if name == marked or name.startswith(marked + \".\"):\n235                     state.trace(f\"matched marked file {name!r} (from {marked!r})\")\n236                     self._marked_for_rewrite_cache[name] = True\n237                     return True\n238 \n239             self._marked_for_rewrite_cache[name] = False\n240             return False\n241 \n242     def mark_rewrite(self, *names: str) -> None:\n243         \"\"\"Mark import names as needing to be rewritten.\n244 \n245         The named module or package as well as any nested modules will\n246         be rewritten on import.\n247         \"\"\"\n248         already_imported = (\n249             set(names).intersection(sys.modules).difference(self._rewritten_names)\n250         )\n251         for name in already_imported:\n252             mod = sys.modules[name]\n253             if not AssertionRewriter.is_rewrite_disabled(\n254                 mod.__doc__ or \"\"\n255             ) and not isinstance(mod.__loader__, type(self)):\n256                 self._warn_already_imported(name)\n257         self._must_rewrite.update(names)\n258         self._marked_for_rewrite_cache.clear()\n259 \n260     def _warn_already_imported(self, name: str) -> None:\n261         from _pytest.warning_types import PytestAssertRewriteWarning\n262 \n263         self.config.issue_config_time_warning(\n264             PytestAssertRewriteWarning(\n265                 \"Module already imported so cannot be rewritten: %s\" % name\n266             ),\n267             stacklevel=5,\n268         )\n269 \n270     def get_data(self, pathname: Union[str, bytes]) -> bytes:\n271         \"\"\"Optional PEP302 get_data API.\"\"\"\n272         with open(pathname, \"rb\") as f:\n273             return f.read()\n274 \n275     if sys.version_info >= (3, 10):\n276         if sys.version_info >= (3, 12):\n277             from importlib.resources.abc import TraversableResources\n278         else:\n279             from importlib.abc import TraversableResources\n280 \n281         def get_resource_reader(self, name: str) -> TraversableResources:  # type: ignore\n282             if sys.version_info < (3, 11):\n283                 from importlib.readers import FileReader\n284             else:\n285                 from importlib.resources.readers import FileReader\n286 \n287             return FileReader(  # type:ignore[no-any-return]\n288                 types.SimpleNamespace(path=self._rewritten_names[name])\n289             )\n290 \n291 \n292 def _write_pyc_fp(\n293     fp: IO[bytes], source_stat: os.stat_result, co: types.CodeType\n294 ) -> None:\n295     # Technically, we don't have to have the same pyc format as\n296     # (C)Python, since these \"pycs\" should never be seen by builtin\n297     # import. However, there's little reason to deviate.\n298     fp.write(importlib.util.MAGIC_NUMBER)\n299     # https://www.python.org/dev/peps/pep-0552/\n300     flags = b\"\\x00\\x00\\x00\\x00\"\n301     fp.write(flags)\n302     # as of now, bytecode header expects 32-bit numbers for size and mtime (#4903)\n303     mtime = int(source_stat.st_mtime) & 0xFFFFFFFF\n304     size = source_stat.st_size & 0xFFFFFFFF\n305     # \"<LL\" stands for 2 unsigned longs, little-endian.\n306     fp.write(struct.pack(\"<LL\", mtime, size))\n307     fp.write(marshal.dumps(co))\n308 \n309 \n310 def _write_pyc(\n311     state: \"AssertionState\",\n312     co: types.CodeType,\n313     source_stat: os.stat_result,\n314     pyc: Path,\n315 ) -> bool:\n316     proc_pyc = f\"{pyc}.{os.getpid()}\"\n317     try:\n318         with open(proc_pyc, \"wb\") as fp:\n319             _write_pyc_fp(fp, source_stat, co)\n320     except OSError as e:\n321         state.trace(f\"error writing pyc file at {proc_pyc}: errno={e.errno}\")\n322         return False\n323 \n324     try:\n325         os.replace(proc_pyc, pyc)\n326     except OSError as e:\n327         state.trace(f\"error writing pyc file at {pyc}: {e}\")\n328         # we ignore any failure to write the cache file\n329         # there are many reasons, permission-denied, pycache dir being a\n330         # file etc.\n331         return False\n332     return True\n333 \n334 \n335 def _rewrite_test(fn: Path, config: Config) -> Tuple[os.stat_result, types.CodeType]:\n336     \"\"\"Read and rewrite *fn* and return the code object.\"\"\"\n337     stat = os.stat(fn)\n338     source = fn.read_bytes()\n339     strfn = str(fn)\n340     tree = ast.parse(source, filename=strfn)\n341     rewrite_asserts(tree, source, strfn, config)\n342     co = compile(tree, strfn, \"exec\", dont_inherit=True)\n343     return stat, co\n344 \n345 \n346 def _read_pyc(\n347     source: Path, pyc: Path, trace: Callable[[str], None] = lambda x: None\n348 ) -> Optional[types.CodeType]:\n349     \"\"\"Possibly read a pytest pyc containing rewritten code.\n350 \n351     Return rewritten code if successful or None if not.\n352     \"\"\"\n353     try:\n354         fp = open(pyc, \"rb\")\n355     except OSError:\n356         return None\n357     with fp:\n358         try:\n359             stat_result = os.stat(source)\n360             mtime = int(stat_result.st_mtime)\n361             size = stat_result.st_size\n362             data = fp.read(16)\n363         except OSError as e:\n364             trace(f\"_read_pyc({source}): OSError {e}\")\n365             return None\n366         # Check for invalid or out of date pyc file.\n367         if len(data) != (16):\n368             trace(\"_read_pyc(%s): invalid pyc (too short)\" % source)\n369             return None\n370         if data[:4] != importlib.util.MAGIC_NUMBER:\n371             trace(\"_read_pyc(%s): invalid pyc (bad magic number)\" % source)\n372             return None\n373         if data[4:8] != b\"\\x00\\x00\\x00\\x00\":\n374             trace(\"_read_pyc(%s): invalid pyc (unsupported flags)\" % source)\n375             return None\n376         mtime_data = data[8:12]\n377         if int.from_bytes(mtime_data, \"little\") != mtime & 0xFFFFFFFF:\n378             trace(\"_read_pyc(%s): out of date\" % source)\n379             return None\n380         size_data = data[12:16]\n381         if int.from_bytes(size_data, \"little\") != size & 0xFFFFFFFF:\n382             trace(\"_read_pyc(%s): invalid pyc (incorrect size)\" % source)\n383             return None\n384         try:\n385             co = marshal.load(fp)\n386         except Exception as e:\n387             trace(f\"_read_pyc({source}): marshal.load error {e}\")\n388             return None\n389         if not isinstance(co, types.CodeType):\n390             trace(\"_read_pyc(%s): not a code object\" % source)\n391             return None\n392         return co\n393 \n394 \n395 def rewrite_asserts(\n396     mod: ast.Module,\n397     source: bytes,\n398     module_path: Optional[str] = None,\n399     config: Optional[Config] = None,\n400 ) -> None:\n401     \"\"\"Rewrite the assert statements in mod.\"\"\"\n402     AssertionRewriter(module_path, config, source).run(mod)\n403 \n404 \n405 def _saferepr(obj: object) -> str:\n406     r\"\"\"Get a safe repr of an object for assertion error messages.\n407 \n408     The assertion formatting (util.format_explanation()) requires\n409     newlines to be escaped since they are a special character for it.\n410     Normally assertion.util.format_explanation() does this but for a\n411     custom repr it is possible to contain one of the special escape\n412     sequences, especially '\\n{' and '\\n}' are likely to be present in\n413     JSON reprs.\n414     \"\"\"\n415     maxsize = _get_maxsize_for_saferepr(util._config)\n416     return saferepr(obj, maxsize=maxsize).replace(\"\\n\", \"\\\\n\")\n417 \n418 \n419 def _get_maxsize_for_saferepr(config: Optional[Config]) -> Optional[int]:\n420     \"\"\"Get `maxsize` configuration for saferepr based on the given config object.\"\"\"\n421     verbosity = config.getoption(\"verbose\") if config is not None else 0\n422     if verbosity >= 2:\n423         return None\n424     if verbosity >= 1:\n425         return DEFAULT_REPR_MAX_SIZE * 10\n426     return DEFAULT_REPR_MAX_SIZE\n427 \n428 \n429 def _format_assertmsg(obj: object) -> str:\n430     r\"\"\"Format the custom assertion message given.\n431 \n432     For strings this simply replaces newlines with '\\n~' so that\n433     util.format_explanation() will preserve them instead of escaping\n434     newlines.  For other objects saferepr() is used first.\n435     \"\"\"\n436     # reprlib appears to have a bug which means that if a string\n437     # contains a newline it gets escaped, however if an object has a\n438     # .__repr__() which contains newlines it does not get escaped.\n439     # However in either case we want to preserve the newline.\n440     replaces = [(\"\\n\", \"\\n~\"), (\"%\", \"%%\")]\n441     if not isinstance(obj, str):\n442         obj = saferepr(obj)\n443         replaces.append((\"\\\\n\", \"\\n~\"))\n444 \n445     for r1, r2 in replaces:\n446         obj = obj.replace(r1, r2)\n447 \n448     return obj\n449 \n450 \n451 def _should_repr_global_name(obj: object) -> bool:\n452     if callable(obj):\n453         return False\n454 \n455     try:\n456         return not hasattr(obj, \"__name__\")\n457     except Exception:\n458         return True\n459 \n460 \n461 def _format_boolop(explanations: Iterable[str], is_or: bool) -> str:\n462     explanation = \"(\" + (is_or and \" or \" or \" and \").join(explanations) + \")\"\n463     return explanation.replace(\"%\", \"%%\")\n464 \n465 \n466 def _call_reprcompare(\n467     ops: Sequence[str],\n468     results: Sequence[bool],\n469     expls: Sequence[str],\n470     each_obj: Sequence[object],\n471 ) -> str:\n472     for i, res, expl in zip(range(len(ops)), results, expls):\n473         try:\n474             done = not res\n475         except Exception:\n476             done = True\n477         if done:\n478             break\n479     if util._reprcompare is not None:\n480         custom = util._reprcompare(ops[i], each_obj[i], each_obj[i + 1])\n481         if custom is not None:\n482             return custom\n483     return expl\n484 \n485 \n486 def _call_assertion_pass(lineno: int, orig: str, expl: str) -> None:\n487     if util._assertion_pass is not None:\n488         util._assertion_pass(lineno, orig, expl)\n489 \n490 \n491 def _check_if_assertion_pass_impl() -> bool:\n492     \"\"\"Check if any plugins implement the pytest_assertion_pass hook\n493     in order not to generate explanation unnecessarily (might be expensive).\"\"\"\n494     return True if util._assertion_pass else False\n495 \n496 \n497 UNARY_MAP = {ast.Not: \"not %s\", ast.Invert: \"~%s\", ast.USub: \"-%s\", ast.UAdd: \"+%s\"}\n498 \n499 BINOP_MAP = {\n500     ast.BitOr: \"|\",\n501     ast.BitXor: \"^\",\n502     ast.BitAnd: \"&\",\n503     ast.LShift: \"<<\",\n504     ast.RShift: \">>\",\n505     ast.Add: \"+\",\n506     ast.Sub: \"-\",\n507     ast.Mult: \"*\",\n508     ast.Div: \"/\",\n509     ast.FloorDiv: \"//\",\n510     ast.Mod: \"%%\",  # escaped for string formatting\n511     ast.Eq: \"==\",\n512     ast.NotEq: \"!=\",\n513     ast.Lt: \"<\",\n514     ast.LtE: \"<=\",\n515     ast.Gt: \">\",\n516     ast.GtE: \">=\",\n517     ast.Pow: \"**\",\n518     ast.Is: \"is\",\n519     ast.IsNot: \"is not\",\n520     ast.In: \"in\",\n521     ast.NotIn: \"not in\",\n522     ast.MatMult: \"@\",\n523 }\n524 \n525 \n526 def traverse_node(node: ast.AST) -> Iterator[ast.AST]:\n527     \"\"\"Recursively yield node and all its children in depth-first order.\"\"\"\n528     yield node\n529     for child in ast.iter_child_nodes(node):\n530         yield from traverse_node(child)\n531 \n532 \n533 @functools.lru_cache(maxsize=1)\n534 def _get_assertion_exprs(src: bytes) -> Dict[int, str]:\n535     \"\"\"Return a mapping from {lineno: \"assertion test expression\"}.\"\"\"\n536     ret: Dict[int, str] = {}\n537 \n538     depth = 0\n539     lines: List[str] = []\n540     assert_lineno: Optional[int] = None\n541     seen_lines: Set[int] = set()\n542 \n543     def _write_and_reset() -> None:\n544         nonlocal depth, lines, assert_lineno, seen_lines\n545         assert assert_lineno is not None\n546         ret[assert_lineno] = \"\".join(lines).rstrip().rstrip(\"\\\\\")\n547         depth = 0\n548         lines = []\n549         assert_lineno = None\n550         seen_lines = set()\n551 \n552     tokens = tokenize.tokenize(io.BytesIO(src).readline)\n553     for tp, source, (lineno, offset), _, line in tokens:\n554         if tp == tokenize.NAME and source == \"assert\":\n555             assert_lineno = lineno\n556         elif assert_lineno is not None:\n557             # keep track of depth for the assert-message `,` lookup\n558             if tp == tokenize.OP and source in \"([{\":\n559                 depth += 1\n560             elif tp == tokenize.OP and source in \")]}\":\n561                 depth -= 1\n562 \n563             if not lines:\n564                 lines.append(line[offset:])\n565                 seen_lines.add(lineno)\n566             # a non-nested comma separates the expression from the message\n567             elif depth == 0 and tp == tokenize.OP and source == \",\":\n568                 # one line assert with message\n569                 if lineno in seen_lines and len(lines) == 1:\n570                     offset_in_trimmed = offset + len(lines[-1]) - len(line)\n571                     lines[-1] = lines[-1][:offset_in_trimmed]\n572                 # multi-line assert with message\n573                 elif lineno in seen_lines:\n574                     lines[-1] = lines[-1][:offset]\n575                 # multi line assert with escapd newline before message\n576                 else:\n577                     lines.append(line[:offset])\n578                 _write_and_reset()\n579             elif tp in {tokenize.NEWLINE, tokenize.ENDMARKER}:\n580                 _write_and_reset()\n581             elif lines and lineno not in seen_lines:\n582                 lines.append(line)\n583                 seen_lines.add(lineno)\n584 \n585     return ret\n586 \n587 \n588 class AssertionRewriter(ast.NodeVisitor):\n589     \"\"\"Assertion rewriting implementation.\n590 \n591     The main entrypoint is to call .run() with an ast.Module instance,\n592     this will then find all the assert statements and rewrite them to\n593     provide intermediate values and a detailed assertion error.  See\n594     http://pybites.blogspot.be/2011/07/behind-scenes-of-pytests-new-assertion.html\n595     for an overview of how this works.\n596 \n597     The entry point here is .run() which will iterate over all the\n598     statements in an ast.Module and for each ast.Assert statement it\n599     finds call .visit() with it.  Then .visit_Assert() takes over and\n600     is responsible for creating new ast statements to replace the\n601     original assert statement: it rewrites the test of an assertion\n602     to provide intermediate values and replace it with an if statement\n603     which raises an assertion error with a detailed explanation in\n604     case the expression is false and calls pytest_assertion_pass hook\n605     if expression is true.\n606 \n607     For this .visit_Assert() uses the visitor pattern to visit all the\n608     AST nodes of the ast.Assert.test field, each visit call returning\n609     an AST node and the corresponding explanation string.  During this\n610     state is kept in several instance attributes:\n611 \n612     :statements: All the AST statements which will replace the assert\n613        statement.\n614 \n615     :variables: This is populated by .variable() with each variable\n616        used by the statements so that they can all be set to None at\n617        the end of the statements.\n618 \n619     :variable_counter: Counter to create new unique variables needed\n620        by statements.  Variables are created using .variable() and\n621        have the form of \"@py_assert0\".\n622 \n623     :expl_stmts: The AST statements which will be executed to get\n624        data from the assertion.  This is the code which will construct\n625        the detailed assertion message that is used in the AssertionError\n626        or for the pytest_assertion_pass hook.\n627 \n628     :explanation_specifiers: A dict filled by .explanation_param()\n629        with %-formatting placeholders and their corresponding\n630        expressions to use in the building of an assertion message.\n631        This is used by .pop_format_context() to build a message.\n632 \n633     :stack: A stack of the explanation_specifiers dicts maintained by\n634        .push_format_context() and .pop_format_context() which allows\n635        to build another %-formatted string while already building one.\n636 \n637     :variables_overwrite: A dict filled with references to variables\n638        that change value within an assert. This happens when a variable is\n639        reassigned with the walrus operator\n640 \n641     This state, except the variables_overwrite,  is reset on every new assert\n642     statement visited and used by the other visitors.\n643     \"\"\"\n644 \n645     def __init__(\n646         self, module_path: Optional[str], config: Optional[Config], source: bytes\n647     ) -> None:\n648         super().__init__()\n649         self.module_path = module_path\n650         self.config = config\n651         if config is not None:\n652             self.enable_assertion_pass_hook = config.getini(\n653                 \"enable_assertion_pass_hook\"\n654             )\n655         else:\n656             self.enable_assertion_pass_hook = False\n657         self.source = source\n658         self.variables_overwrite: Dict[str, str] = {}\n659 \n660     def run(self, mod: ast.Module) -> None:\n661         \"\"\"Find all assert statements in *mod* and rewrite them.\"\"\"\n662         if not mod.body:\n663             # Nothing to do.\n664             return\n665 \n666         # We'll insert some special imports at the top of the module, but after any\n667         # docstrings and __future__ imports, so first figure out where that is.\n668         doc = getattr(mod, \"docstring\", None)\n669         expect_docstring = doc is None\n670         if doc is not None and self.is_rewrite_disabled(doc):\n671             return\n672         pos = 0\n673         item = None\n674         for item in mod.body:\n675             if (\n676                 expect_docstring\n677                 and isinstance(item, ast.Expr)\n678                 and isinstance(item.value, ast.Constant)\n679             ):\n680                 doc = item.value.value\n681                 if self.is_rewrite_disabled(doc):\n682                     return\n683                 expect_docstring = False\n684             elif (\n685                 isinstance(item, ast.ImportFrom)\n686                 and item.level == 0\n687                 and item.module == \"__future__\"\n688             ):\n689                 pass\n690             else:\n691                 break\n692             pos += 1\n693         # Special case: for a decorated function, set the lineno to that of the\n694         # first decorator, not the `def`. Issue #4984.\n695         if isinstance(item, ast.FunctionDef) and item.decorator_list:\n696             lineno = item.decorator_list[0].lineno\n697         else:\n698             lineno = item.lineno\n699         # Now actually insert the special imports.\n700         if sys.version_info >= (3, 10):\n701             aliases = [\n702                 ast.alias(\"builtins\", \"@py_builtins\", lineno=lineno, col_offset=0),\n703                 ast.alias(\n704                     \"_pytest.assertion.rewrite\",\n705                     \"@pytest_ar\",\n706                     lineno=lineno,\n707                     col_offset=0,\n708                 ),\n709             ]\n710         else:\n711             aliases = [\n712                 ast.alias(\"builtins\", \"@py_builtins\"),\n713                 ast.alias(\"_pytest.assertion.rewrite\", \"@pytest_ar\"),\n714             ]\n715         imports = [\n716             ast.Import([alias], lineno=lineno, col_offset=0) for alias in aliases\n717         ]\n718         mod.body[pos:pos] = imports\n719 \n720         # Collect asserts.\n721         nodes: List[ast.AST] = [mod]\n722         while nodes:\n723             node = nodes.pop()\n724             for name, field in ast.iter_fields(node):\n725                 if isinstance(field, list):\n726                     new: List[ast.AST] = []\n727                     for i, child in enumerate(field):\n728                         if isinstance(child, ast.Assert):\n729                             # Transform assert.\n730                             new.extend(self.visit(child))\n731                         else:\n732                             new.append(child)\n733                             if isinstance(child, ast.AST):\n734                                 nodes.append(child)\n735                     setattr(node, name, new)\n736                 elif (\n737                     isinstance(field, ast.AST)\n738                     # Don't recurse into expressions as they can't contain\n739                     # asserts.\n740                     and not isinstance(field, ast.expr)\n741                 ):\n742                     nodes.append(field)\n743 \n744     @staticmethod\n745     def is_rewrite_disabled(docstring: str) -> bool:\n746         return \"PYTEST_DONT_REWRITE\" in docstring\n747 \n748     def variable(self) -> str:\n749         \"\"\"Get a new variable.\"\"\"\n750         # Use a character invalid in python identifiers to avoid clashing.\n751         name = \"@py_assert\" + str(next(self.variable_counter))\n752         self.variables.append(name)\n753         return name\n754 \n755     def assign(self, expr: ast.expr) -> ast.Name:\n756         \"\"\"Give *expr* a name.\"\"\"\n757         name = self.variable()\n758         self.statements.append(ast.Assign([ast.Name(name, ast.Store())], expr))\n759         return ast.Name(name, ast.Load())\n760 \n761     def display(self, expr: ast.expr) -> ast.expr:\n762         \"\"\"Call saferepr on the expression.\"\"\"\n763         return self.helper(\"_saferepr\", expr)\n764 \n765     def helper(self, name: str, *args: ast.expr) -> ast.expr:\n766         \"\"\"Call a helper in this module.\"\"\"\n767         py_name = ast.Name(\"@pytest_ar\", ast.Load())\n768         attr = ast.Attribute(py_name, name, ast.Load())\n769         return ast.Call(attr, list(args), [])\n770 \n771     def builtin(self, name: str) -> ast.Attribute:\n772         \"\"\"Return the builtin called *name*.\"\"\"\n773         builtin_name = ast.Name(\"@py_builtins\", ast.Load())\n774         return ast.Attribute(builtin_name, name, ast.Load())\n775 \n776     def explanation_param(self, expr: ast.expr) -> str:\n777         \"\"\"Return a new named %-formatting placeholder for expr.\n778 \n779         This creates a %-formatting placeholder for expr in the\n780         current formatting context, e.g. ``%(py0)s``.  The placeholder\n781         and expr are placed in the current format context so that it\n782         can be used on the next call to .pop_format_context().\n783         \"\"\"\n784         specifier = \"py\" + str(next(self.variable_counter))\n785         self.explanation_specifiers[specifier] = expr\n786         return \"%(\" + specifier + \")s\"\n787 \n788     def push_format_context(self) -> None:\n789         \"\"\"Create a new formatting context.\n790 \n791         The format context is used for when an explanation wants to\n792         have a variable value formatted in the assertion message.  In\n793         this case the value required can be added using\n794         .explanation_param().  Finally .pop_format_context() is used\n795         to format a string of %-formatted values as added by\n796         .explanation_param().\n797         \"\"\"\n798         self.explanation_specifiers: Dict[str, ast.expr] = {}\n799         self.stack.append(self.explanation_specifiers)\n800 \n801     def pop_format_context(self, expl_expr: ast.expr) -> ast.Name:\n802         \"\"\"Format the %-formatted string with current format context.\n803 \n804         The expl_expr should be an str ast.expr instance constructed from\n805         the %-placeholders created by .explanation_param().  This will\n806         add the required code to format said string to .expl_stmts and\n807         return the ast.Name instance of the formatted string.\n808         \"\"\"\n809         current = self.stack.pop()\n810         if self.stack:\n811             self.explanation_specifiers = self.stack[-1]\n812         keys = [ast.Constant(key) for key in current.keys()]\n813         format_dict = ast.Dict(keys, list(current.values()))\n814         form = ast.BinOp(expl_expr, ast.Mod(), format_dict)\n815         name = \"@py_format\" + str(next(self.variable_counter))\n816         if self.enable_assertion_pass_hook:\n817             self.format_variables.append(name)\n818         self.expl_stmts.append(ast.Assign([ast.Name(name, ast.Store())], form))\n819         return ast.Name(name, ast.Load())\n820 \n821     def generic_visit(self, node: ast.AST) -> Tuple[ast.Name, str]:\n822         \"\"\"Handle expressions we don't have custom code for.\"\"\"\n823         assert isinstance(node, ast.expr)\n824         res = self.assign(node)\n825         return res, self.explanation_param(self.display(res))\n826 \n827     def visit_Assert(self, assert_: ast.Assert) -> List[ast.stmt]:\n828         \"\"\"Return the AST statements to replace the ast.Assert instance.\n829 \n830         This rewrites the test of an assertion to provide\n831         intermediate values and replace it with an if statement which\n832         raises an assertion error with a detailed explanation in case\n833         the expression is false.\n834         \"\"\"\n835         if isinstance(assert_.test, ast.Tuple) and len(assert_.test.elts) >= 1:\n836             from _pytest.warning_types import PytestAssertRewriteWarning\n837             import warnings\n838 \n839             # TODO: This assert should not be needed.\n840             assert self.module_path is not None\n841             warnings.warn_explicit(\n842                 PytestAssertRewriteWarning(\n843                     \"assertion is always true, perhaps remove parentheses?\"\n844                 ),\n845                 category=None,\n846                 filename=self.module_path,\n847                 lineno=assert_.lineno,\n848             )\n849 \n850         self.statements: List[ast.stmt] = []\n851         self.variables: List[str] = []\n852         self.variable_counter = itertools.count()\n853 \n854         if self.enable_assertion_pass_hook:\n855             self.format_variables: List[str] = []\n856 \n857         self.stack: List[Dict[str, ast.expr]] = []\n858         self.expl_stmts: List[ast.stmt] = []\n859         self.push_format_context()\n860         # Rewrite assert into a bunch of statements.\n861         top_condition, explanation = self.visit(assert_.test)\n862 \n863         negation = ast.UnaryOp(ast.Not(), top_condition)\n864 \n865         if self.enable_assertion_pass_hook:  # Experimental pytest_assertion_pass hook\n866             msg = self.pop_format_context(ast.Constant(explanation))\n867 \n868             # Failed\n869             if assert_.msg:\n870                 assertmsg = self.helper(\"_format_assertmsg\", assert_.msg)\n871                 gluestr = \"\\n>assert \"\n872             else:\n873                 assertmsg = ast.Constant(\"\")\n874                 gluestr = \"assert \"\n875             err_explanation = ast.BinOp(ast.Constant(gluestr), ast.Add(), msg)\n876             err_msg = ast.BinOp(assertmsg, ast.Add(), err_explanation)\n877             err_name = ast.Name(\"AssertionError\", ast.Load())\n878             fmt = self.helper(\"_format_explanation\", err_msg)\n879             exc = ast.Call(err_name, [fmt], [])\n880             raise_ = ast.Raise(exc, None)\n881             statements_fail = []\n882             statements_fail.extend(self.expl_stmts)\n883             statements_fail.append(raise_)\n884 \n885             # Passed\n886             fmt_pass = self.helper(\"_format_explanation\", msg)\n887             orig = _get_assertion_exprs(self.source)[assert_.lineno]\n888             hook_call_pass = ast.Expr(\n889                 self.helper(\n890                     \"_call_assertion_pass\",\n891                     ast.Constant(assert_.lineno),\n892                     ast.Constant(orig),\n893                     fmt_pass,\n894                 )\n895             )\n896             # If any hooks implement assert_pass hook\n897             hook_impl_test = ast.If(\n898                 self.helper(\"_check_if_assertion_pass_impl\"),\n899                 self.expl_stmts + [hook_call_pass],\n900                 [],\n901             )\n902             statements_pass = [hook_impl_test]\n903 \n904             # Test for assertion condition\n905             main_test = ast.If(negation, statements_fail, statements_pass)\n906             self.statements.append(main_test)\n907             if self.format_variables:\n908                 variables = [\n909                     ast.Name(name, ast.Store()) for name in self.format_variables\n910                 ]\n911                 clear_format = ast.Assign(variables, ast.Constant(None))\n912                 self.statements.append(clear_format)\n913 \n914         else:  # Original assertion rewriting\n915             # Create failure message.\n916             body = self.expl_stmts\n917             self.statements.append(ast.If(negation, body, []))\n918             if assert_.msg:\n919                 assertmsg = self.helper(\"_format_assertmsg\", assert_.msg)\n920                 explanation = \"\\n>assert \" + explanation\n921             else:\n922                 assertmsg = ast.Constant(\"\")\n923                 explanation = \"assert \" + explanation\n924             template = ast.BinOp(assertmsg, ast.Add(), ast.Constant(explanation))\n925             msg = self.pop_format_context(template)\n926             fmt = self.helper(\"_format_explanation\", msg)\n927             err_name = ast.Name(\"AssertionError\", ast.Load())\n928             exc = ast.Call(err_name, [fmt], [])\n929             raise_ = ast.Raise(exc, None)\n930 \n931             body.append(raise_)\n932 \n933         # Clear temporary variables by setting them to None.\n934         if self.variables:\n935             variables = [ast.Name(name, ast.Store()) for name in self.variables]\n936             clear = ast.Assign(variables, ast.Constant(None))\n937             self.statements.append(clear)\n938         # Fix locations (line numbers/column offsets).\n939         for stmt in self.statements:\n940             for node in traverse_node(stmt):\n941                 ast.copy_location(node, assert_)\n942         return self.statements\n943 \n944     def visit_NamedExpr(self, name: ast.NamedExpr) -> Tuple[ast.NamedExpr, str]:\n945         # This method handles the 'walrus operator' repr of the target\n946         # name if it's a local variable or _should_repr_global_name()\n947         # thinks it's acceptable.\n948         locs = ast.Call(self.builtin(\"locals\"), [], [])\n949         target_id = name.target.id  # type: ignore[attr-defined]\n950         inlocs = ast.Compare(ast.Constant(target_id), [ast.In()], [locs])\n951         dorepr = self.helper(\"_should_repr_global_name\", name)\n952         test = ast.BoolOp(ast.Or(), [inlocs, dorepr])\n953         expr = ast.IfExp(test, self.display(name), ast.Constant(target_id))\n954         return name, self.explanation_param(expr)\n955 \n956     def visit_Name(self, name: ast.Name) -> Tuple[ast.Name, str]:\n957         # Display the repr of the name if it's a local variable or\n958         # _should_repr_global_name() thinks it's acceptable.\n959         locs = ast.Call(self.builtin(\"locals\"), [], [])\n960         inlocs = ast.Compare(ast.Constant(name.id), [ast.In()], [locs])\n961         dorepr = self.helper(\"_should_repr_global_name\", name)\n962         test = ast.BoolOp(ast.Or(), [inlocs, dorepr])\n963         expr = ast.IfExp(test, self.display(name), ast.Constant(name.id))\n964         return name, self.explanation_param(expr)\n965 \n966     def visit_BoolOp(self, boolop: ast.BoolOp) -> Tuple[ast.Name, str]:\n967         res_var = self.variable()\n968         expl_list = self.assign(ast.List([], ast.Load()))\n969         app = ast.Attribute(expl_list, \"append\", ast.Load())\n970         is_or = int(isinstance(boolop.op, ast.Or))\n971         body = save = self.statements\n972         fail_save = self.expl_stmts\n973         levels = len(boolop.values) - 1\n974         self.push_format_context()\n975         # Process each operand, short-circuiting if needed.\n976         for i, v in enumerate(boolop.values):\n977             if i:\n978                 fail_inner: List[ast.stmt] = []\n979                 # cond is set in a prior loop iteration below\n980                 self.expl_stmts.append(ast.If(cond, fail_inner, []))  # noqa\n981                 self.expl_stmts = fail_inner\n982                 # Check if the left operand is a ast.NamedExpr and the value has already been visited\n983                 if (\n984                     isinstance(v, ast.Compare)\n985                     and isinstance(v.left, ast.NamedExpr)\n986                     and v.left.target.id\n987                     in [\n988                         ast_expr.id\n989                         for ast_expr in boolop.values[:i]\n990                         if hasattr(ast_expr, \"id\")\n991                     ]\n992                 ):\n993                     pytest_temp = self.variable()\n994                     self.variables_overwrite[\n995                         v.left.target.id\n996                     ] = v.left  # type:ignore[assignment]\n997                     v.left.target.id = pytest_temp\n998             self.push_format_context()\n999             res, expl = self.visit(v)\n1000             body.append(ast.Assign([ast.Name(res_var, ast.Store())], res))\n1001             expl_format = self.pop_format_context(ast.Constant(expl))\n1002             call = ast.Call(app, [expl_format], [])\n1003             self.expl_stmts.append(ast.Expr(call))\n1004             if i < levels:\n1005                 cond: ast.expr = res\n1006                 if is_or:\n1007                     cond = ast.UnaryOp(ast.Not(), cond)\n1008                 inner: List[ast.stmt] = []\n1009                 self.statements.append(ast.If(cond, inner, []))\n1010                 self.statements = body = inner\n1011         self.statements = save\n1012         self.expl_stmts = fail_save\n1013         expl_template = self.helper(\"_format_boolop\", expl_list, ast.Constant(is_or))\n1014         expl = self.pop_format_context(expl_template)\n1015         return ast.Name(res_var, ast.Load()), self.explanation_param(expl)\n1016 \n1017     def visit_UnaryOp(self, unary: ast.UnaryOp) -> Tuple[ast.Name, str]:\n1018         pattern = UNARY_MAP[unary.op.__class__]\n1019         operand_res, operand_expl = self.visit(unary.operand)\n1020         res = self.assign(ast.UnaryOp(unary.op, operand_res))\n1021         return res, pattern % (operand_expl,)\n1022 \n1023     def visit_BinOp(self, binop: ast.BinOp) -> Tuple[ast.Name, str]:\n1024         symbol = BINOP_MAP[binop.op.__class__]\n1025         left_expr, left_expl = self.visit(binop.left)\n1026         right_expr, right_expl = self.visit(binop.right)\n1027         explanation = f\"({left_expl} {symbol} {right_expl})\"\n1028         res = self.assign(ast.BinOp(left_expr, binop.op, right_expr))\n1029         return res, explanation\n1030 \n1031     def visit_Call(self, call: ast.Call) -> Tuple[ast.Name, str]:\n1032         new_func, func_expl = self.visit(call.func)\n1033         arg_expls = []\n1034         new_args = []\n1035         new_kwargs = []\n1036         for arg in call.args:\n1037             if isinstance(arg, ast.Name) and arg.id in self.variables_overwrite:\n1038                 arg = self.variables_overwrite[arg.id]  # type:ignore[assignment]\n1039             res, expl = self.visit(arg)\n1040             arg_expls.append(expl)\n1041             new_args.append(res)\n1042         for keyword in call.keywords:\n1043             if (\n1044                 isinstance(keyword.value, ast.Name)\n1045                 and keyword.value.id in self.variables_overwrite\n1046             ):\n1047                 keyword.value = self.variables_overwrite[\n1048                     keyword.value.id\n1049                 ]  # type:ignore[assignment]\n1050             res, expl = self.visit(keyword.value)\n1051             new_kwargs.append(ast.keyword(keyword.arg, res))\n1052             if keyword.arg:\n1053                 arg_expls.append(keyword.arg + \"=\" + expl)\n1054             else:  # **args have `arg` keywords with an .arg of None\n1055                 arg_expls.append(\"**\" + expl)\n1056 \n1057         expl = \"{}({})\".format(func_expl, \", \".join(arg_expls))\n1058         new_call = ast.Call(new_func, new_args, new_kwargs)\n1059         res = self.assign(new_call)\n1060         res_expl = self.explanation_param(self.display(res))\n1061         outer_expl = f\"{res_expl}\\n{{{res_expl} = {expl}\\n}}\"\n1062         return res, outer_expl\n1063 \n1064     def visit_Starred(self, starred: ast.Starred) -> Tuple[ast.Starred, str]:\n1065         # A Starred node can appear in a function call.\n1066         res, expl = self.visit(starred.value)\n1067         new_starred = ast.Starred(res, starred.ctx)\n1068         return new_starred, \"*\" + expl\n1069 \n1070     def visit_Attribute(self, attr: ast.Attribute) -> Tuple[ast.Name, str]:\n1071         if not isinstance(attr.ctx, ast.Load):\n1072             return self.generic_visit(attr)\n1073         value, value_expl = self.visit(attr.value)\n1074         res = self.assign(ast.Attribute(value, attr.attr, ast.Load()))\n1075         res_expl = self.explanation_param(self.display(res))\n1076         pat = \"%s\\n{%s = %s.%s\\n}\"\n1077         expl = pat % (res_expl, res_expl, value_expl, attr.attr)\n1078         return res, expl\n1079 \n1080     def visit_Compare(self, comp: ast.Compare) -> Tuple[ast.expr, str]:\n1081         self.push_format_context()\n1082         # We first check if we have overwritten a variable in the previous assert\n1083         if isinstance(comp.left, ast.Name) and comp.left.id in self.variables_overwrite:\n1084             comp.left = self.variables_overwrite[\n1085                 comp.left.id\n1086             ]  # type:ignore[assignment]\n1087         if isinstance(comp.left, ast.NamedExpr):\n1088             self.variables_overwrite[\n1089                 comp.left.target.id\n1090             ] = comp.left  # type:ignore[assignment]\n1091         left_res, left_expl = self.visit(comp.left)\n1092         if isinstance(comp.left, (ast.Compare, ast.BoolOp)):\n1093             left_expl = f\"({left_expl})\"\n1094         res_variables = [self.variable() for i in range(len(comp.ops))]\n1095         load_names = [ast.Name(v, ast.Load()) for v in res_variables]\n1096         store_names = [ast.Name(v, ast.Store()) for v in res_variables]\n1097         it = zip(range(len(comp.ops)), comp.ops, comp.comparators)\n1098         expls = []\n1099         syms = []\n1100         results = [left_res]\n1101         for i, op, next_operand in it:\n1102             if (\n1103                 isinstance(next_operand, ast.NamedExpr)\n1104                 and isinstance(left_res, ast.Name)\n1105                 and next_operand.target.id == left_res.id\n1106             ):\n1107                 next_operand.target.id = self.variable()\n1108                 self.variables_overwrite[\n1109                     left_res.id\n1110                 ] = next_operand  # type:ignore[assignment]\n1111             next_res, next_expl = self.visit(next_operand)\n1112             if isinstance(next_operand, (ast.Compare, ast.BoolOp)):\n1113                 next_expl = f\"({next_expl})\"\n1114             results.append(next_res)\n1115             sym = BINOP_MAP[op.__class__]\n1116             syms.append(ast.Constant(sym))\n1117             expl = f\"{left_expl} {sym} {next_expl}\"\n1118             expls.append(ast.Constant(expl))\n1119             res_expr = ast.Compare(left_res, [op], [next_res])\n1120             self.statements.append(ast.Assign([store_names[i]], res_expr))\n1121             left_res, left_expl = next_res, next_expl\n1122         # Use pytest.assertion.util._reprcompare if that's available.\n1123         expl_call = self.helper(\n1124             \"_call_reprcompare\",\n1125             ast.Tuple(syms, ast.Load()),\n1126             ast.Tuple(load_names, ast.Load()),\n1127             ast.Tuple(expls, ast.Load()),\n1128             ast.Tuple(results, ast.Load()),\n1129         )\n1130         if len(comp.ops) > 1:\n1131             res: ast.expr = ast.BoolOp(ast.And(), load_names)\n1132         else:\n1133             res = load_names[0]\n1134 \n1135         return res, self.explanation_param(self.pop_format_context(expl_call))\n1136 \n1137 \n1138 def try_makedirs(cache_dir: Path) -> bool:\n1139     \"\"\"Attempt to create the given directory and sub-directories exist.\n1140 \n1141     Returns True if successful or if it already exists.\n1142     \"\"\"\n1143     try:\n1144         os.makedirs(cache_dir, exist_ok=True)\n1145     except (FileNotFoundError, NotADirectoryError, FileExistsError):\n1146         # One of the path components was not a directory:\n1147         # - we're in a zip file\n1148         # - it is a file\n1149         return False\n1150     except PermissionError:\n1151         return False\n1152     except OSError as e:\n1153         # as of now, EROFS doesn't have an equivalent OSError-subclass\n1154         if e.errno == errno.EROFS:\n1155             return False\n1156         raise\n1157     return True\n1158 \n1159 \n1160 def get_cache_dir(file_path: Path) -> Path:\n1161     \"\"\"Return the cache directory to write .pyc files for the given .py file path.\"\"\"\n1162     if sys.pycache_prefix:\n1163         # given:\n1164         #   prefix = '/tmp/pycs'\n1165         #   path = '/home/user/proj/test_app.py'\n1166         # we want:\n1167         #   '/tmp/pycs/home/user/proj'\n1168         return Path(sys.pycache_prefix) / Path(*file_path.parts[1:-1])\n1169     else:\n1170         # classic pycache directory\n1171         return file_path.parent / \"__pycache__\"\n",
        "intended_behavior": "When using `importlib` for dynamic imports, the application should implement checks or strategies to avoid importing the same module under different names or paths, which could lead to the observed issue of having two different versions of `pmxbot.logging`. This might include enhancing the logic around module importation to reference or augment Python's import machinery, ensuring that `sys.modules` is appropriately managed to unify module instances."
    }
]