2025-10-18 16:11:52.446 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-18 16:11:54.170 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=826, output_tokens=12, cost=0.008620
2025-10-18 16:11:54.171 | INFO     | Test agent decides that the issue statement does not contain reproduction steps; skipping reproducer tracing
2025-10-18 16:11:54.175 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 16:12:02.636 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1123, output_tokens=322, cost=0.020890
2025-10-18 16:12:02.643 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 16:12:05.844 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=676, output_tokens=60, cost=0.008560
2025-10-18 16:12:05.845 | DEBUG    | Extracted a valid json.
2025-10-18 16:12:05.845 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_class(\"Logger\")",
        "search_method_in_class(\"initialize\", \"core\")",
        "search_code(\"import pmxbot.logging\")",
        "search_code(\"ConfigDict.from_yaml\")"
    ],
    "bug_locations": []
}
2025-10-18 16:12:05.876 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-18 16:12:05.876 | DEBUG    | <Agent search> Analyzing search results.
2025-10-18 16:12:20.318 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1647, output_tokens=589, cost=0.034140
2025-10-18 16:12:20.333 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 16:12:31.354 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2452, output_tokens=470, cost=0.038620
2025-10-18 16:12:31.364 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 16:12:37.257 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=824, output_tokens=217, cost=0.014750
2025-10-18 16:12:37.258 | DEBUG    | Extracted a valid json.
2025-10-18 16:12:37.258 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations":[
        {
            "file": "pmxbot/logging.py",
            "class": "Logger",
            "method": "",
            "intended_behavior": "Ensure that the Logger class has a class level variable store that is correctly initialized and accessible across all imports of the pmxbot.logging module. If the module is imported multiple times under different references, consider implementing a mechanism to ensure that Logger behaves as a singleton or its state is shared appropriately, preserving functionality across these disparate module imports."
        },
        {
            "file": "",
            "class": "",
            "method": "initialize",
            "intended_behavior": "In the initialization process, care must be taken to properly configure and instantiate namespace packages under PEP 420, ensuring that importlib is used consistently and avoids creating duplicate modules in sys.modules. The initialization should verify that the logging configuration is correctly applied only once and is globally accessible, thereby preventing the issue where Logger.store does not reflect expected changes due to module duplication."
        }
    ]
}
2025-10-18 16:12:37.263 | DEBUG    | Failed to retrieve code from all bug locations. Asking search agent to re-generate response.
2025-10-18 16:12:37.264 | DEBUG    | <Agent search> Downstream could not consume our last response. Will retry.
2025-10-18 16:12:37.264 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 16:12:43.649 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2956, output_tokens=288, cost=0.038200
2025-10-18 16:12:43.656 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 16:12:46.270 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=642, output_tokens=43, cost=0.007710
2025-10-18 16:12:46.271 | DEBUG    | Extracted a valid json.
2025-10-18 16:12:46.272 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_code(\"class Logger\")",
        "search_code(\"def initialize\")",
        "search_code(\"logging setup\")"
    ],
    "bug_locations":[]
}
2025-10-18 16:12:46.316 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-18 16:12:46.316 | DEBUG    | <Agent search> Analyzing search results.
2025-10-18 16:12:58.961 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=3415, output_tokens=545, cost=0.050500
2025-10-18 16:12:58.974 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 16:13:07.812 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=4176, output_tokens=394, cost=0.053580
2025-10-18 16:13:07.819 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 16:13:09.873 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=748, output_tokens=14, cost=0.007900
2025-10-18 16:13:09.874 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-18 16:13:09.874 | DEBUG    | Trying to convert API calls/bug locations into json. Try 2 of 5.
2025-10-18 16:13:11.724 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=748, output_tokens=14, cost=0.007900
2025-10-18 16:13:11.725 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-18 16:13:11.725 | DEBUG    | Trying to convert API calls/bug locations into json. Try 3 of 5.
2025-10-18 16:13:12.775 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=748, output_tokens=14, cost=0.007900
2025-10-18 16:13:12.776 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-18 16:13:12.776 | DEBUG    | Trying to convert API calls/bug locations into json. Try 4 of 5.
2025-10-18 16:13:14.419 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=748, output_tokens=14, cost=0.007900
2025-10-18 16:13:14.420 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-18 16:13:14.420 | DEBUG    | Trying to convert API calls/bug locations into json. Try 5 of 5.
2025-10-18 16:13:16.450 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=748, output_tokens=14, cost=0.007900
2025-10-18 16:13:16.452 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-18 16:13:16.452 | DEBUG    | Agent proxy return the following json: None
2025-10-18 16:13:16.452 | DEBUG    | Could not extract API calls from agent search response, asking search agent to re-generate response.
2025-10-18 16:13:16.453 | DEBUG    | <Agent search> Downstream could not consume our last response. Will retry.
2025-10-18 16:13:16.453 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 16:13:23.464 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=4597, output_tokens=263, cost=0.053860
2025-10-18 16:13:23.469 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 16:13:26.611 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=617, output_tokens=14, cost=0.006590
2025-10-18 16:13:26.612 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-18 16:13:26.612 | DEBUG    | Trying to convert API calls/bug locations into json. Try 2 of 5.
2025-10-18 16:13:27.885 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=617, output_tokens=14, cost=0.006590
2025-10-18 16:13:27.886 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-18 16:13:27.886 | DEBUG    | Trying to convert API calls/bug locations into json. Try 3 of 5.
2025-10-18 16:13:30.859 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=617, output_tokens=14, cost=0.006590
2025-10-18 16:13:30.860 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-18 16:13:30.861 | DEBUG    | Trying to convert API calls/bug locations into json. Try 4 of 5.
2025-10-18 16:13:33.165 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=617, output_tokens=14, cost=0.006590
2025-10-18 16:13:33.166 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-18 16:13:33.167 | DEBUG    | Trying to convert API calls/bug locations into json. Try 5 of 5.
2025-10-18 16:13:36.094 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=617, output_tokens=14, cost=0.006590
2025-10-18 16:13:36.095 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-18 16:13:36.101 | DEBUG    | Agent proxy return the following json: None
2025-10-18 16:13:36.102 | DEBUG    | Could not extract API calls from agent search response, asking search agent to re-generate response.
2025-10-18 16:13:36.103 | DEBUG    | <Agent search> Downstream could not consume our last response. Will retry.
2025-10-18 16:13:36.103 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 16:13:42.278 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=4887, output_tokens=248, cost=0.056310
2025-10-18 16:13:42.284 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 16:13:45.307 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=602, output_tokens=14, cost=0.006440
2025-10-18 16:13:45.308 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-18 16:13:45.308 | DEBUG    | Trying to convert API calls/bug locations into json. Try 2 of 5.
2025-10-18 16:13:48.424 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=602, output_tokens=14, cost=0.006440
2025-10-18 16:13:48.425 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-18 16:13:48.425 | DEBUG    | Trying to convert API calls/bug locations into json. Try 3 of 5.
2025-10-18 16:13:51.601 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=602, output_tokens=14, cost=0.006440
2025-10-18 16:13:51.602 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-18 16:13:51.602 | DEBUG    | Trying to convert API calls/bug locations into json. Try 4 of 5.
2025-10-18 16:13:52.925 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=602, output_tokens=14, cost=0.006440
2025-10-18 16:13:52.926 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-18 16:13:52.932 | DEBUG    | Trying to convert API calls/bug locations into json. Try 5 of 5.
2025-10-18 16:13:55.778 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=602, output_tokens=14, cost=0.006440
2025-10-18 16:13:55.779 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-18 16:13:55.779 | DEBUG    | Agent proxy return the following json: None
2025-10-18 16:13:55.779 | DEBUG    | Could not extract API calls from agent search response, asking search agent to re-generate response.
2025-10-18 16:13:55.780 | DEBUG    | <Agent search> Downstream could not consume our last response. Will retry.
2025-10-18 16:13:55.780 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 16:14:05.816 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=5162, output_tokens=300, cost=0.060620
2025-10-18 16:14:05.822 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 16:14:08.240 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=654, output_tokens=14, cost=0.006960
2025-10-18 16:14:08.241 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-18 16:14:08.241 | DEBUG    | Trying to convert API calls/bug locations into json. Try 2 of 5.
2025-10-18 16:14:09.959 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=654, output_tokens=24, cost=0.007260
2025-10-18 16:14:09.960 | DEBUG    | Extracted a valid json.
2025-10-18 16:14:09.960 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_class(\"Logger\")"
    ],
    "bug_locations": []
}
2025-10-18 16:14:09.963 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-18 16:14:09.964 | DEBUG    | <Agent search> Analyzing search results.
2025-10-18 16:14:25.041 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=5591, output_tokens=607, cost=0.074120
2025-10-18 16:14:25.053 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 16:14:34.049 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=6414, output_tokens=358, cost=0.074880
2025-10-18 16:14:34.056 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 16:14:35.314 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=712, output_tokens=14, cost=0.007540
2025-10-18 16:14:35.315 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-18 16:14:35.315 | DEBUG    | Trying to convert API calls/bug locations into json. Try 2 of 5.
2025-10-18 16:14:37.280 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=712, output_tokens=14, cost=0.007540
2025-10-18 16:14:37.281 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-18 16:14:37.281 | DEBUG    | Trying to convert API calls/bug locations into json. Try 3 of 5.
2025-10-18 16:14:38.410 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=712, output_tokens=14, cost=0.007540
2025-10-18 16:14:38.411 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-18 16:14:38.411 | DEBUG    | Trying to convert API calls/bug locations into json. Try 4 of 5.
2025-10-18 16:14:39.494 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=712, output_tokens=14, cost=0.007540
2025-10-18 16:14:39.495 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-18 16:14:39.501 | DEBUG    | Trying to convert API calls/bug locations into json. Try 5 of 5.
2025-10-18 16:14:40.615 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=712, output_tokens=14, cost=0.007540
2025-10-18 16:14:40.616 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-18 16:14:40.616 | DEBUG    | Agent proxy return the following json: None
2025-10-18 16:14:40.616 | DEBUG    | Could not extract API calls from agent search response, asking search agent to re-generate response.
2025-10-18 16:14:40.617 | DEBUG    | <Agent search> Downstream could not consume our last response. Will retry.
2025-10-18 16:14:40.617 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 16:14:50.298 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=6799, output_tokens=395, cost=0.079840
2025-10-18 16:14:50.306 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 16:14:52.299 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=749, output_tokens=14, cost=0.007910
2025-10-18 16:14:52.300 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-18 16:14:52.300 | DEBUG    | Trying to convert API calls/bug locations into json. Try 2 of 5.
2025-10-18 16:14:54.883 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=749, output_tokens=64, cost=0.009410
2025-10-18 16:14:54.885 | DEBUG    | Extracted a valid json.
2025-10-18 16:14:54.885 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_class(\"Logger\")",
        "search_method_in_class(\"store\", \"Logger\")",
        "search_code(\"importlib\")",
        "search_code(\"namespace packages\")",
        "search_method(\"core.initialize\")"
    ],
    "bug_locations": []
}
2025-10-18 16:14:54.998 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-18 16:14:54.998 | DEBUG    | <Agent search> Analyzing search results.
2025-10-18 16:15:16.025 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=8019, output_tokens=679, cost=0.100560
2025-10-18 16:15:16.037 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 16:15:27.789 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=8914, output_tokens=444, cost=0.102460
2025-10-18 16:15:27.798 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 16:15:41.419 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=798, output_tokens=576, cost=0.025260
2025-10-18 16:15:41.420 | DEBUG    | Extracted a valid json.
2025-10-18 16:15:41.420 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "testing/test_pathlib.py",
            "class": "",
            "method": "",
            "intended_behavior": "The code handling namespace packages, both in tests and possibly in the application's core logic (where similar patterns are likely to be present), should ensure consistent and correct import paths to prevent module duplication. This might involve verifying and adjusting how `importlib` is used to import modules part of a namespace package, ensuring that a single instance of each module is maintained across the application."
        },
        {
            "file": "testing/_py/test_local.py",
            "class": "",
            "method": "",
            "intended_behavior": "The code handling namespace packages, both in tests and possibly in the application's core logic (where similar patterns are likely to be present), should ensure consistent and correct import paths to prevent module duplication. This might involve verifying and adjusting how `importlib` is used to import modules part of a namespace package, ensuring that a single instance of each module is maintained across the application."
        },
        {
            "file": "src/_pytest/pytester.py",
            "class": "",
            "method": "",
            "intended_behavior": "When using `importlib` for dynamic imports, the application should implement checks or strategies to avoid importing the same module under different names or paths, which could lead to the observed issue of having two different versions of `pmxbot.logging`. This might include enhancing the logic around module importation to reference or augment Python's import machinery, ensuring that `sys.modules` is appropriately managed to unify module instances."
        },
        {
            "file": "src/_pytest/pathlib.py",
            "class": "",
            "method": "",
            "intended_behavior": "When using `importlib` for dynamic imports, the application should implement checks or strategies to avoid importing the same module under different names or paths, which could lead to the observed issue of having two different versions of `pmxbot.logging`. This might include enhancing the logic around module importation to reference or augment Python's import machinery, ensuring that `sys.modules` is appropriately managed to unify module instances."
        },
        {
            "file": "src/_pytest/assertion/rewrite.py",
            "class": "",
            "method": "",
            "intended_behavior": "When using `importlib` for dynamic imports, the application should implement checks or strategies to avoid importing the same module under different names or paths, which could lead to the observed issue of having two different versions of `pmxbot.logging`. This might include enhancing the logic around module importation to reference or augment Python's import machinery, ensuring that `sys.modules` is appropriately managed to unify module instances."
        }
    ]
}
2025-10-18 16:15:41.442 | DEBUG    | Bug location extracted successfully: [<file>testing/test_pathlib.py</file>
<class>None</class>
<method>None</method>
<code>
1 import os.path
2 import pickle
3 import sys
4 import unittest.mock
5 from pathlib import Path
6 from textwrap import dedent
7 from types import ModuleType
8 from typing import Any
9 from typing import Generator
10 
11 import pytest
12 from _pytest.monkeypatch import MonkeyPatch
13 from _pytest.pathlib import bestrelpath
14 from _pytest.pathlib import commonpath
15 from _pytest.pathlib import ensure_deletable
16 from _pytest.pathlib import fnmatch_ex
17 from _pytest.pathlib import get_extended_length_path_str
18 from _pytest.pathlib import get_lock_path
19 from _pytest.pathlib import import_path
20 from _pytest.pathlib import ImportPathMismatchError
21 from _pytest.pathlib import insert_missing_modules
22 from _pytest.pathlib import maybe_delete_a_numbered_dir
23 from _pytest.pathlib import module_name_from_path
24 from _pytest.pathlib import resolve_package_path
25 from _pytest.pathlib import symlink_or_skip
26 from _pytest.pathlib import visit
27 from _pytest.tmpdir import TempPathFactory
28 
29 
30 class TestFNMatcherPort:
31     """Test our port of py.common.FNMatcher (fnmatch_ex)."""
32 
33     if sys.platform == "win32":
34         drv1 = "c:"
35         drv2 = "d:"
36     else:
37         drv1 = "/c"
38         drv2 = "/d"
39 
40     @pytest.mark.parametrize(
41         "pattern, path",
42         [
43             ("*.py", "foo.py"),
44             ("*.py", "bar/foo.py"),
45             ("test_*.py", "foo/test_foo.py"),
46             ("tests/*.py", "tests/foo.py"),
47             (f"{drv1}/*.py", f"{drv1}/foo.py"),
48             (f"{drv1}/foo/*.py", f"{drv1}/foo/foo.py"),
49             ("tests/**/test*.py", "tests/foo/test_foo.py"),
50             ("tests/**/doc/test*.py", "tests/foo/bar/doc/test_foo.py"),
51             ("tests/**/doc/**/test*.py", "tests/foo/doc/bar/test_foo.py"),
52         ],
53     )
54     def test_matching(self, pattern: str, path: str) -> None:
55         assert fnmatch_ex(pattern, path)
56 
57     def test_matching_abspath(self) -> None:
58         abspath = os.path.abspath(os.path.join("tests/foo.py"))
59         assert fnmatch_ex("tests/foo.py", abspath)
60 
61     @pytest.mark.parametrize(
62         "pattern, path",
63         [
64             ("*.py", "foo.pyc"),
65             ("*.py", "foo/foo.pyc"),
66             ("tests/*.py", "foo/foo.py"),
67             (f"{drv1}/*.py", f"{drv2}/foo.py"),
68             (f"{drv1}/foo/*.py", f"{drv2}/foo/foo.py"),
69             ("tests/**/test*.py", "tests/foo.py"),
70             ("tests/**/test*.py", "foo/test_foo.py"),
71             ("tests/**/doc/test*.py", "tests/foo/bar/doc/foo.py"),
72             ("tests/**/doc/test*.py", "tests/foo/bar/test_foo.py"),
73         ],
74     )
75     def test_not_matching(self, pattern: str, path: str) -> None:
76         assert not fnmatch_ex(pattern, path)
77 
78 
79 class TestImportPath:
80     """
81 
82     Most of the tests here were copied from py lib's tests for "py.local.path.pyimport".
83 
84     Having our own pyimport-like function is inline with removing py.path dependency in the future.
85     """
86 
87     @pytest.fixture(scope="session")
88     def path1(self, tmp_path_factory: TempPathFactory) -> Generator[Path, None, None]:
89         path = tmp_path_factory.mktemp("path")
90         self.setuptestfs(path)
91         yield path
92         assert path.joinpath("samplefile").exists()
93 
94     @pytest.fixture(autouse=True)
95     def preserve_sys(self):
96         with unittest.mock.patch.dict(sys.modules):
97             with unittest.mock.patch.object(sys, "path", list(sys.path)):
98                 yield
99 
100     def setuptestfs(self, path: Path) -> None:
101         # print "setting up test fs for", repr(path)
102         samplefile = path / "samplefile"
103         samplefile.write_text("samplefile\n", encoding="utf-8")
104 
105         execfile = path / "execfile"
106         execfile.write_text("x=42", encoding="utf-8")
107 
108         execfilepy = path / "execfile.py"
109         execfilepy.write_text("x=42", encoding="utf-8")
110 
111         d = {1: 2, "hello": "world", "answer": 42}
112         path.joinpath("samplepickle").write_bytes(pickle.dumps(d, 1))
113 
114         sampledir = path / "sampledir"
115         sampledir.mkdir()
116         sampledir.joinpath("otherfile").touch()
117 
118         otherdir = path / "otherdir"
119         otherdir.mkdir()
120         otherdir.joinpath("__init__.py").touch()
121 
122         module_a = otherdir / "a.py"
123         module_a.write_text("from .b import stuff as result\n", encoding="utf-8")
124         module_b = otherdir / "b.py"
125         module_b.write_text('stuff="got it"\n', encoding="utf-8")
126         module_c = otherdir / "c.py"
127         module_c.write_text(
128             dedent(
129                 """
130             import pluggy;
131             import otherdir.a
132             value = otherdir.a.result
133         """
134             ),
135             encoding="utf-8",
136         )
137         module_d = otherdir / "d.py"
138         module_d.write_text(
139             dedent(
140                 """
141             import pluggy;
142             from otherdir import a
143             value2 = a.result
144         """
145             ),
146             encoding="utf-8",
147         )
148 
149     def test_smoke_test(self, path1: Path) -> None:
150         obj = import_path(path1 / "execfile.py", root=path1)
151         assert obj.x == 42  # type: ignore[attr-defined]
152         assert obj.__name__ == "execfile"
153 
154     def test_import_path_missing_file(self, path1: Path) -> None:
155         with pytest.raises(ImportPathMismatchError):
156             import_path(path1 / "sampledir", root=path1)
157 
158     def test_renamed_dir_creates_mismatch(
159         self, tmp_path: Path, monkeypatch: MonkeyPatch
160     ) -> None:
161         tmp_path.joinpath("a").mkdir()
162         p = tmp_path.joinpath("a", "test_x123.py")
163         p.touch()
164         import_path(p, root=tmp_path)
165         tmp_path.joinpath("a").rename(tmp_path.joinpath("b"))
166         with pytest.raises(ImportPathMismatchError):
167             import_path(tmp_path.joinpath("b", "test_x123.py"), root=tmp_path)
168 
169         # Errors can be ignored.
170         monkeypatch.setenv("PY_IGNORE_IMPORTMISMATCH", "1")
171         import_path(tmp_path.joinpath("b", "test_x123.py"), root=tmp_path)
172 
173         # PY_IGNORE_IMPORTMISMATCH=0 does not ignore error.
174         monkeypatch.setenv("PY_IGNORE_IMPORTMISMATCH", "0")
175         with pytest.raises(ImportPathMismatchError):
176             import_path(tmp_path.joinpath("b", "test_x123.py"), root=tmp_path)
177 
178     def test_messy_name(self, tmp_path: Path) -> None:
179         # https://bitbucket.org/hpk42/py-trunk/issue/129
180         path = tmp_path / "foo__init__.py"
181         path.touch()
182         module = import_path(path, root=tmp_path)
183         assert module.__name__ == "foo__init__"
184 
185     def test_dir(self, tmp_path: Path) -> None:
186         p = tmp_path / "hello_123"
187         p.mkdir()
188         p_init = p / "__init__.py"
189         p_init.touch()
190         m = import_path(p, root=tmp_path)
191         assert m.__name__ == "hello_123"
192         m = import_path(p_init, root=tmp_path)
193         assert m.__name__ == "hello_123"
194 
195     def test_a(self, path1: Path) -> None:
196         otherdir = path1 / "otherdir"
197         mod = import_path(otherdir / "a.py", root=path1)
198         assert mod.result == "got it"  # type: ignore[attr-defined]
199         assert mod.__name__ == "otherdir.a"
200 
201     def test_b(self, path1: Path) -> None:
202         otherdir = path1 / "otherdir"
203         mod = import_path(otherdir / "b.py", root=path1)
204         assert mod.stuff == "got it"  # type: ignore[attr-defined]
205         assert mod.__name__ == "otherdir.b"
206 
207     def test_c(self, path1: Path) -> None:
208         otherdir = path1 / "otherdir"
209         mod = import_path(otherdir / "c.py", root=path1)
210         assert mod.value == "got it"  # type: ignore[attr-defined]
211 
212     def test_d(self, path1: Path) -> None:
213         otherdir = path1 / "otherdir"
214         mod = import_path(otherdir / "d.py", root=path1)
215         assert mod.value2 == "got it"  # type: ignore[attr-defined]
216 
217     def test_import_after(self, tmp_path: Path) -> None:
218         tmp_path.joinpath("xxxpackage").mkdir()
219         tmp_path.joinpath("xxxpackage", "__init__.py").touch()
220         mod1path = tmp_path.joinpath("xxxpackage", "module1.py")
221         mod1path.touch()
222         mod1 = import_path(mod1path, root=tmp_path)
223         assert mod1.__name__ == "xxxpackage.module1"
224         from xxxpackage import module1
225 
226         assert module1 is mod1
227 
228     def test_check_filepath_consistency(
229         self, monkeypatch: MonkeyPatch, tmp_path: Path
230     ) -> None:
231         name = "pointsback123"
232         p = tmp_path.joinpath(name + ".py")
233         p.touch()
234         for ending in (".pyc", ".pyo"):
235             mod = ModuleType(name)
236             pseudopath = tmp_path.joinpath(name + ending)
237             pseudopath.touch()
238             mod.__file__ = str(pseudopath)
239             monkeypatch.setitem(sys.modules, name, mod)
240             newmod = import_path(p, root=tmp_path)
241             assert mod == newmod
242         monkeypatch.undo()
243         mod = ModuleType(name)
244         pseudopath = tmp_path.joinpath(name + "123.py")
245         pseudopath.touch()
246         mod.__file__ = str(pseudopath)
247         monkeypatch.setitem(sys.modules, name, mod)
248         with pytest.raises(ImportPathMismatchError) as excinfo:
249             import_path(p, root=tmp_path)
250         modname, modfile, orig = excinfo.value.args
251         assert modname == name
252         assert modfile == str(pseudopath)
253         assert orig == p
254         assert issubclass(ImportPathMismatchError, ImportError)
255 
256     def test_issue131_on__init__(self, tmp_path: Path) -> None:
257         # __init__.py files may be namespace packages, and thus the
258         # __file__ of an imported module may not be ourselves
259         # see issue
260         tmp_path.joinpath("proja").mkdir()
261         p1 = tmp_path.joinpath("proja", "__init__.py")
262         p1.touch()
263         tmp_path.joinpath("sub", "proja").mkdir(parents=True)
264         p2 = tmp_path.joinpath("sub", "proja", "__init__.py")
265         p2.touch()
266         m1 = import_path(p1, root=tmp_path)
267         m2 = import_path(p2, root=tmp_path)
268         assert m1 == m2
269 
270     def test_ensuresyspath_append(self, tmp_path: Path) -> None:
271         root1 = tmp_path / "root1"
272         root1.mkdir()
273         file1 = root1 / "x123.py"
274         file1.touch()
275         assert str(root1) not in sys.path
276         import_path(file1, mode="append", root=tmp_path)
277         assert str(root1) == sys.path[-1]
278         assert str(root1) not in sys.path[:-1]
279 
280     def test_invalid_path(self, tmp_path: Path) -> None:
281         with pytest.raises(ImportError):
282             import_path(tmp_path / "invalid.py", root=tmp_path)
283 
284     @pytest.fixture
285     def simple_module(self, tmp_path: Path) -> Path:
286         fn = tmp_path / "_src/tests/mymod.py"
287         fn.parent.mkdir(parents=True)
288         fn.write_text("def foo(x): return 40 + x", encoding="utf-8")
289         return fn
290 
291     def test_importmode_importlib(self, simple_module: Path, tmp_path: Path) -> None:
292         """`importlib` mode does not change sys.path."""
293         module = import_path(simple_module, mode="importlib", root=tmp_path)
294         assert module.foo(2) == 42  # type: ignore[attr-defined]
295         assert str(simple_module.parent) not in sys.path
296         assert module.__name__ in sys.modules
297         assert module.__name__ == "_src.tests.mymod"
298         assert "_src" in sys.modules
299         assert "_src.tests" in sys.modules
300 
301     def test_importmode_twice_is_different_module(
302         self, simple_module: Path, tmp_path: Path
303     ) -> None:
304         """`importlib` mode always returns a new module."""
305         module1 = import_path(simple_module, mode="importlib", root=tmp_path)
306         module2 = import_path(simple_module, mode="importlib", root=tmp_path)
307         assert module1 is not module2
308 
309     def test_no_meta_path_found(
310         self, simple_module: Path, monkeypatch: MonkeyPatch, tmp_path: Path
311     ) -> None:
312         """Even without any meta_path should still import module."""
313         monkeypatch.setattr(sys, "meta_path", [])
314         module = import_path(simple_module, mode="importlib", root=tmp_path)
315         assert module.foo(2) == 42  # type: ignore[attr-defined]
316 
317         # mode='importlib' fails if no spec is found to load the module
318         import importlib.util
319 
320         monkeypatch.setattr(
321             importlib.util, "spec_from_file_location", lambda *args: None
322         )
323         with pytest.raises(ImportError):
324             import_path(simple_module, mode="importlib", root=tmp_path)
325 
326 
327 def test_resolve_package_path(tmp_path: Path) -> None:
328     pkg = tmp_path / "pkg1"
329     pkg.mkdir()
330     (pkg / "__init__.py").touch()
331     (pkg / "subdir").mkdir()
332     (pkg / "subdir/__init__.py").touch()
333     assert resolve_package_path(pkg) == pkg
334     assert resolve_package_path(pkg.joinpath("subdir", "__init__.py")) == pkg
335 
336 
337 def test_package_unimportable(tmp_path: Path) -> None:
338     pkg = tmp_path / "pkg1-1"
339     pkg.mkdir()
340     pkg.joinpath("__init__.py").touch()
341     subdir = pkg.joinpath("subdir")
342     subdir.mkdir()
343     pkg.joinpath("subdir/__init__.py").touch()
344     assert resolve_package_path(subdir) == subdir
345     xyz = subdir.joinpath("xyz.py")
346     xyz.touch()
347     assert resolve_package_path(xyz) == subdir
348     assert not resolve_package_path(pkg)
349 
350 
351 def test_access_denied_during_cleanup(tmp_path: Path, monkeypatch: MonkeyPatch) -> None:
352     """Ensure that deleting a numbered dir does not fail because of OSErrors (#4262)."""
353     path = tmp_path / "temp-1"
354     path.mkdir()
355 
356     def renamed_failed(*args):
357         raise OSError("access denied")
358 
359     monkeypatch.setattr(Path, "rename", renamed_failed)
360 
361     lock_path = get_lock_path(path)
362     maybe_delete_a_numbered_dir(path)
363     assert not lock_path.is_file()
364 
365 
366 def test_long_path_during_cleanup(tmp_path: Path) -> None:
367     """Ensure that deleting long path works (particularly on Windows (#6775))."""
368     path = (tmp_path / ("a" * 250)).resolve()
369     if sys.platform == "win32":
370         # make sure that the full path is > 260 characters without any
371         # component being over 260 characters
372         assert len(str(path)) > 260
373         extended_path = "\\\\?\\" + str(path)
374     else:
375         extended_path = str(path)
376     os.mkdir(extended_path)
377     assert os.path.isdir(extended_path)
378     maybe_delete_a_numbered_dir(path)
379     assert not os.path.isdir(extended_path)
380 
381 
382 def test_get_extended_length_path_str() -> None:
383     assert get_extended_length_path_str(r"c:\foo") == r"\\?\c:\foo"
384     assert get_extended_length_path_str(r"\\share\foo") == r"\\?\UNC\share\foo"
385     assert get_extended_length_path_str(r"\\?\UNC\share\foo") == r"\\?\UNC\share\foo"
386     assert get_extended_length_path_str(r"\\?\c:\foo") == r"\\?\c:\foo"
387 
388 
389 def test_suppress_error_removing_lock(tmp_path: Path) -> None:
390     """ensure_deletable should be resilient if lock file cannot be removed (#5456, #7491)"""
391     path = tmp_path / "dir"
392     path.mkdir()
393     lock = get_lock_path(path)
394     lock.touch()
395     mtime = lock.stat().st_mtime
396 
397     with unittest.mock.patch.object(Path, "unlink", side_effect=OSError) as m:
398         assert not ensure_deletable(
399             path, consider_lock_dead_if_created_before=mtime + 30
400         )
401         assert m.call_count == 1
402     assert lock.is_file()
403 
404     with unittest.mock.patch.object(Path, "is_file", side_effect=OSError) as m:
405         assert not ensure_deletable(
406             path, consider_lock_dead_if_created_before=mtime + 30
407         )
408         assert m.call_count == 1
409     assert lock.is_file()
410 
411     # check now that we can remove the lock file in normal circumstances
412     assert ensure_deletable(path, consider_lock_dead_if_created_before=mtime + 30)
413     assert not lock.is_file()
414 
415 
416 def test_bestrelpath() -> None:
417     curdir = Path("/foo/bar/baz/path")
418     assert bestrelpath(curdir, curdir) == "."
419     assert bestrelpath(curdir, curdir / "hello" / "world") == "hello" + os.sep + "world"
420     assert bestrelpath(curdir, curdir.parent / "sister") == ".." + os.sep + "sister"
421     assert bestrelpath(curdir, curdir.parent) == ".."
422     assert bestrelpath(curdir, Path("hello")) == "hello"
423 
424 
425 def test_commonpath() -> None:
426     path = Path("/foo/bar/baz/path")
427     subpath = path / "sampledir"
428     assert commonpath(path, subpath) == path
429     assert commonpath(subpath, path) == path
430     assert commonpath(Path(str(path) + "suffix"), path) == path.parent
431     assert commonpath(path, path.parent.parent) == path.parent.parent
432 
433 
434 def test_visit_ignores_errors(tmp_path: Path) -> None:
435     symlink_or_skip("recursive", tmp_path / "recursive")
436     tmp_path.joinpath("foo").write_bytes(b"")
437     tmp_path.joinpath("bar").write_bytes(b"")
438 
439     assert [
440         entry.name for entry in visit(str(tmp_path), recurse=lambda entry: False)
441     ] == ["bar", "foo"]
442 
443 
444 @pytest.mark.skipif(not sys.platform.startswith("win"), reason="Windows only")
445 def test_samefile_false_negatives(tmp_path: Path, monkeypatch: MonkeyPatch) -> None:
446     """
447     import_file() should not raise ImportPathMismatchError if the paths are exactly
448     equal on Windows. It seems directories mounted as UNC paths make os.path.samefile
449     return False, even when they are clearly equal.
450     """
451     module_path = tmp_path.joinpath("my_module.py")
452     module_path.write_text("def foo(): return 42", encoding="utf-8")
453     monkeypatch.syspath_prepend(tmp_path)
454 
455     with monkeypatch.context() as mp:
456         # Forcibly make os.path.samefile() return False here to ensure we are comparing
457         # the paths too. Using a context to narrow the patch as much as possible given
458         # this is an important system function.
459         mp.setattr(os.path, "samefile", lambda x, y: False)
460         module = import_path(module_path, root=tmp_path)
461     assert getattr(module, "foo")() == 42
462 
463 
464 class TestImportLibMode:
465     def test_importmode_importlib_with_dataclass(self, tmp_path: Path) -> None:
466         """Ensure that importlib mode works with a module containing dataclasses (#7856)."""
467         fn = tmp_path.joinpath("_src/tests/test_dataclass.py")
468         fn.parent.mkdir(parents=True)
469         fn.write_text(
470             dedent(
471                 """
472                 from dataclasses import dataclass
473 
474                 @dataclass
475                 class Data:
476                     value: str
477                 """
478             ),
479             encoding="utf-8",
480         )
481 
482         module = import_path(fn, mode="importlib", root=tmp_path)
483         Data: Any = getattr(module, "Data")
484         data = Data(value="foo")
485         assert data.value == "foo"
486         assert data.__module__ == "_src.tests.test_dataclass"
487 
488     def test_importmode_importlib_with_pickle(self, tmp_path: Path) -> None:
489         """Ensure that importlib mode works with pickle (#7859)."""
490         fn = tmp_path.joinpath("_src/tests/test_pickle.py")
491         fn.parent.mkdir(parents=True)
492         fn.write_text(
493             dedent(
494                 """
495                 import pickle
496 
497                 def _action():
498                     return 42
499 
500                 def round_trip():
501                     s = pickle.dumps(_action)
502                     return pickle.loads(s)
503                 """
504             ),
505             encoding="utf-8",
506         )
507 
508         module = import_path(fn, mode="importlib", root=tmp_path)
509         round_trip = getattr(module, "round_trip")
510         action = round_trip()
511         assert action() == 42
512 
513     def test_importmode_importlib_with_pickle_separate_modules(
514         self, tmp_path: Path
515     ) -> None:
516         """
517         Ensure that importlib mode works can load pickles that look similar but are
518         defined in separate modules.
519         """
520         fn1 = tmp_path.joinpath("_src/m1/tests/test.py")
521         fn1.parent.mkdir(parents=True)
522         fn1.write_text(
523             dedent(
524                 """
525                 import dataclasses
526                 import pickle
527 
528                 @dataclasses.dataclass
529                 class Data:
530                     x: int = 42
531                 """
532             ),
533             encoding="utf-8",
534         )
535 
536         fn2 = tmp_path.joinpath("_src/m2/tests/test.py")
537         fn2.parent.mkdir(parents=True)
538         fn2.write_text(
539             dedent(
540                 """
541                 import dataclasses
542                 import pickle
543 
544                 @dataclasses.dataclass
545                 class Data:
546                     x: str = ""
547                 """
548             ),
549             encoding="utf-8",
550         )
551 
552         import pickle
553 
554         def round_trip(obj):
555             s = pickle.dumps(obj)
556             return pickle.loads(s)
557 
558         module = import_path(fn1, mode="importlib", root=tmp_path)
559         Data1 = getattr(module, "Data")
560 
561         module = import_path(fn2, mode="importlib", root=tmp_path)
562         Data2 = getattr(module, "Data")
563 
564         assert round_trip(Data1(20)) == Data1(20)
565         assert round_trip(Data2("hello")) == Data2("hello")
566         assert Data1.__module__ == "_src.m1.tests.test"
567         assert Data2.__module__ == "_src.m2.tests.test"
568 
569     def test_module_name_from_path(self, tmp_path: Path) -> None:
570         result = module_name_from_path(tmp_path / "src/tests/test_foo.py", tmp_path)
571         assert result == "src.tests.test_foo"
572 
573         # Path is not relative to root dir: use the full path to obtain the module name.
574         result = module_name_from_path(Path("/home/foo/test_foo.py"), Path("/bar"))
575         assert result == "home.foo.test_foo"
576 
577     def test_insert_missing_modules(
578         self, monkeypatch: MonkeyPatch, tmp_path: Path
579     ) -> None:
580         monkeypatch.chdir(tmp_path)
581         # Use 'xxx' and 'xxy' as parent names as they are unlikely to exist and
582         # don't end up being imported.
583         modules = {"xxx.tests.foo": ModuleType("xxx.tests.foo")}
584         insert_missing_modules(modules, "xxx.tests.foo")
585         assert sorted(modules) == ["xxx", "xxx.tests", "xxx.tests.foo"]
586 
587         mod = ModuleType("mod", doc="My Module")
588         modules = {"xxy": mod}
589         insert_missing_modules(modules, "xxy")
590         assert modules == {"xxy": mod}
591 
592         modules = {}
593         insert_missing_modules(modules, "")
594         assert modules == {}
595 
596     def test_parent_contains_child_module_attribute(
597         self, monkeypatch: MonkeyPatch, tmp_path: Path
598     ):
599         monkeypatch.chdir(tmp_path)
600         # Use 'xxx' and 'xxy' as parent names as they are unlikely to exist and
601         # don't end up being imported.
602         modules = {"xxx.tests.foo": ModuleType("xxx.tests.foo")}
603         insert_missing_modules(modules, "xxx.tests.foo")
604         assert sorted(modules) == ["xxx", "xxx.tests", "xxx.tests.foo"]
605         assert modules["xxx"].tests is modules["xxx.tests"]
606         assert modules["xxx.tests"].foo is modules["xxx.tests.foo"]

</code><intended_behavior>The code handling namespace packages, both in tests and possibly in the application's core logic (where similar patterns are likely to be present), should ensure consistent and correct import paths to prevent module duplication. This might involve verifying and adjusting how `importlib` is used to import modules part of a namespace package, ensuring that a single instance of each module is maintained across the application.</intended_behavior>, <file>testing/_py/test_local.py</file>
<class>None</class>
<method>None</method>
<code>
1 import contextlib
2 import multiprocessing
3 import os
4 import sys
5 import time
6 import warnings
7 from unittest import mock
8 
9 import pytest
10 from py import error
11 from py.path import local
12 
13 
14 @contextlib.contextmanager
15 def ignore_encoding_warning():
16     with warnings.catch_warnings():
17         with contextlib.suppress(NameError):  # new in 3.10
18             warnings.simplefilter("ignore", EncodingWarning)
19         yield
20 
21 
22 class CommonFSTests:
23     def test_constructor_equality(self, path1):
24         p = path1.__class__(path1)
25         assert p == path1
26 
27     def test_eq_nonstring(self, path1):
28         p1 = path1.join("sampledir")
29         p2 = path1.join("sampledir")
30         assert p1 == p2
31 
32     def test_new_identical(self, path1):
33         assert path1 == path1.new()
34 
35     def test_join(self, path1):
36         p = path1.join("sampledir")
37         strp = str(p)
38         assert strp.endswith("sampledir")
39         assert strp.startswith(str(path1))
40 
41     def test_join_normalized(self, path1):
42         newpath = path1.join(path1.sep + "sampledir")
43         strp = str(newpath)
44         assert strp.endswith("sampledir")
45         assert strp.startswith(str(path1))
46         newpath = path1.join((path1.sep * 2) + "sampledir")
47         strp = str(newpath)
48         assert strp.endswith("sampledir")
49         assert strp.startswith(str(path1))
50 
51     def test_join_noargs(self, path1):
52         newpath = path1.join()
53         assert path1 == newpath
54 
55     def test_add_something(self, path1):
56         p = path1.join("sample")
57         p = p + "dir"
58         assert p.check()
59         assert p.exists()
60         assert p.isdir()
61         assert not p.isfile()
62 
63     def test_parts(self, path1):
64         newpath = path1.join("sampledir", "otherfile")
65         par = newpath.parts()[-3:]
66         assert par == [path1, path1.join("sampledir"), newpath]
67 
68         revpar = newpath.parts(reverse=True)[:3]
69         assert revpar == [newpath, path1.join("sampledir"), path1]
70 
71     def test_common(self, path1):
72         other = path1.join("sampledir")
73         x = other.common(path1)
74         assert x == path1
75 
76     # def test_parents_nonexisting_file(self, path1):
77     #    newpath = path1 / 'dirnoexist' / 'nonexisting file'
78     #    par = list(newpath.parents())
79     #    assert par[:2] == [path1 / 'dirnoexist', path1]
80 
81     def test_basename_checks(self, path1):
82         newpath = path1.join("sampledir")
83         assert newpath.check(basename="sampledir")
84         assert newpath.check(notbasename="xyz")
85         assert newpath.basename == "sampledir"
86 
87     def test_basename(self, path1):
88         newpath = path1.join("sampledir")
89         assert newpath.check(basename="sampledir")
90         assert newpath.basename, "sampledir"
91 
92     def test_dirname(self, path1):
93         newpath = path1.join("sampledir")
94         assert newpath.dirname == str(path1)
95 
96     def test_dirpath(self, path1):
97         newpath = path1.join("sampledir")
98         assert newpath.dirpath() == path1
99 
100     def test_dirpath_with_args(self, path1):
101         newpath = path1.join("sampledir")
102         assert newpath.dirpath("x") == path1.join("x")
103 
104     def test_newbasename(self, path1):
105         newpath = path1.join("samplefile")
106         newbase = newpath.new(basename="samplefile2")
107         assert newbase.basename == "samplefile2"
108         assert newbase.dirpath() == newpath.dirpath()
109 
110     def test_not_exists(self, path1):
111         assert not path1.join("does_not_exist").check()
112         assert path1.join("does_not_exist").check(exists=0)
113 
114     def test_exists(self, path1):
115         assert path1.join("samplefile").check()
116         assert path1.join("samplefile").check(exists=1)
117         assert path1.join("samplefile").exists()
118         assert path1.join("samplefile").isfile()
119         assert not path1.join("samplefile").isdir()
120 
121     def test_dir(self, path1):
122         # print repr(path1.join("sampledir"))
123         assert path1.join("sampledir").check(dir=1)
124         assert path1.join("samplefile").check(notdir=1)
125         assert not path1.join("samplefile").check(dir=1)
126         assert path1.join("samplefile").exists()
127         assert not path1.join("samplefile").isdir()
128         assert path1.join("samplefile").isfile()
129 
130     def test_fnmatch_file(self, path1):
131         assert path1.join("samplefile").check(fnmatch="s*e")
132         assert path1.join("samplefile").fnmatch("s*e")
133         assert not path1.join("samplefile").fnmatch("s*x")
134         assert not path1.join("samplefile").check(fnmatch="s*x")
135 
136     # def test_fnmatch_dir(self, path1):
137 
138     #    pattern = path1.sep.join(['s*file'])
139     #    sfile = path1.join("samplefile")
140     #    assert sfile.check(fnmatch=pattern)
141 
142     def test_relto(self, path1):
143         p = path1.join("sampledir", "otherfile")
144         assert p.relto(path1) == p.sep.join(["sampledir", "otherfile"])
145         assert p.check(relto=path1)
146         assert path1.check(notrelto=p)
147         assert not path1.check(relto=p)
148 
149     def test_bestrelpath(self, path1):
150         curdir = path1
151         sep = curdir.sep
152         s = curdir.bestrelpath(curdir)
153         assert s == "."
154         s = curdir.bestrelpath(curdir.join("hello", "world"))
155         assert s == "hello" + sep + "world"
156 
157         s = curdir.bestrelpath(curdir.dirpath().join("sister"))
158         assert s == ".." + sep + "sister"
159         assert curdir.bestrelpath(curdir.dirpath()) == ".."
160 
161         assert curdir.bestrelpath("hello") == "hello"
162 
163     def test_relto_not_relative(self, path1):
164         l1 = path1.join("bcde")
165         l2 = path1.join("b")
166         assert not l1.relto(l2)
167         assert not l2.relto(l1)
168 
169     def test_listdir(self, path1):
170         p = path1.listdir()
171         assert path1.join("sampledir") in p
172         assert path1.join("samplefile") in p
173         with pytest.raises(error.ENOTDIR):
174             path1.join("samplefile").listdir()
175 
176     def test_listdir_fnmatchstring(self, path1):
177         p = path1.listdir("s*dir")
178         assert len(p)
179         assert p[0], path1.join("sampledir")
180 
181     def test_listdir_filter(self, path1):
182         p = path1.listdir(lambda x: x.check(dir=1))
183         assert path1.join("sampledir") in p
184         assert not path1.join("samplefile") in p
185 
186     def test_listdir_sorted(self, path1):
187         p = path1.listdir(lambda x: x.check(basestarts="sample"), sort=True)
188         assert path1.join("sampledir") == p[0]
189         assert path1.join("samplefile") == p[1]
190         assert path1.join("samplepickle") == p[2]
191 
192     def test_visit_nofilter(self, path1):
193         lst = []
194         for i in path1.visit():
195             lst.append(i.relto(path1))
196         assert "sampledir" in lst
197         assert path1.sep.join(["sampledir", "otherfile"]) in lst
198 
199     def test_visit_norecurse(self, path1):
200         lst = []
201         for i in path1.visit(None, lambda x: x.basename != "sampledir"):
202             lst.append(i.relto(path1))
203         assert "sampledir" in lst
204         assert not path1.sep.join(["sampledir", "otherfile"]) in lst
205 
206     @pytest.mark.parametrize(
207         "fil",
208         ["*dir", "*dir", pytest.mark.skip("sys.version_info <" " (3,6)")(b"*dir")],
209     )
210     def test_visit_filterfunc_is_string(self, path1, fil):
211         lst = []
212         for i in path1.visit(fil):
213             lst.append(i.relto(path1))
214         assert len(lst), 2
215         assert "sampledir" in lst
216         assert "otherdir" in lst
217 
218     def test_visit_ignore(self, path1):
219         p = path1.join("nonexisting")
220         assert list(p.visit(ignore=error.ENOENT)) == []
221 
222     def test_visit_endswith(self, path1):
223         p = []
224         for i in path1.visit(lambda x: x.check(endswith="file")):
225             p.append(i.relto(path1))
226         assert path1.sep.join(["sampledir", "otherfile"]) in p
227         assert "samplefile" in p
228 
229     def test_cmp(self, path1):
230         path1 = path1.join("samplefile")
231         path2 = path1.join("samplefile2")
232         assert (path1 < path2) == ("samplefile" < "samplefile2")
233         assert not (path1 < path1)
234 
235     def test_simple_read(self, path1):
236         with ignore_encoding_warning():
237             x = path1.join("samplefile").read("r")
238         assert x == "samplefile\n"
239 
240     def test_join_div_operator(self, path1):
241         newpath = path1 / "/sampledir" / "/test//"
242         newpath2 = path1.join("sampledir", "test")
243         assert newpath == newpath2
244 
245     def test_ext(self, path1):
246         newpath = path1.join("sampledir.ext")
247         assert newpath.ext == ".ext"
248         newpath = path1.join("sampledir")
249         assert not newpath.ext
250 
251     def test_purebasename(self, path1):
252         newpath = path1.join("samplefile.py")
253         assert newpath.purebasename == "samplefile"
254 
255     def test_multiple_parts(self, path1):
256         newpath = path1.join("samplefile.py")
257         dirname, purebasename, basename, ext = newpath._getbyspec(
258             "dirname,purebasename,basename,ext"
259         )
260         assert str(path1).endswith(dirname)  # be careful with win32 'drive'
261         assert purebasename == "samplefile"
262         assert basename == "samplefile.py"
263         assert ext == ".py"
264 
265     def test_dotted_name_ext(self, path1):
266         newpath = path1.join("a.b.c")
267         ext = newpath.ext
268         assert ext == ".c"
269         assert newpath.ext == ".c"
270 
271     def test_newext(self, path1):
272         newpath = path1.join("samplefile.py")
273         newext = newpath.new(ext=".txt")
274         assert newext.basename == "samplefile.txt"
275         assert newext.purebasename == "samplefile"
276 
277     def test_readlines(self, path1):
278         fn = path1.join("samplefile")
279         with ignore_encoding_warning():
280             contents = fn.readlines()
281         assert contents == ["samplefile\n"]
282 
283     def test_readlines_nocr(self, path1):
284         fn = path1.join("samplefile")
285         with ignore_encoding_warning():
286             contents = fn.readlines(cr=0)
287         assert contents == ["samplefile", ""]
288 
289     def test_file(self, path1):
290         assert path1.join("samplefile").check(file=1)
291 
292     def test_not_file(self, path1):
293         assert not path1.join("sampledir").check(file=1)
294         assert path1.join("sampledir").check(file=0)
295 
296     def test_non_existent(self, path1):
297         assert path1.join("sampledir.nothere").check(dir=0)
298         assert path1.join("sampledir.nothere").check(file=0)
299         assert path1.join("sampledir.nothere").check(notfile=1)
300         assert path1.join("sampledir.nothere").check(notdir=1)
301         assert path1.join("sampledir.nothere").check(notexists=1)
302         assert not path1.join("sampledir.nothere").check(notfile=0)
303 
304     #    pattern = path1.sep.join(['s*file'])
305     #    sfile = path1.join("samplefile")
306     #    assert sfile.check(fnmatch=pattern)
307 
308     def test_size(self, path1):
309         url = path1.join("samplefile")
310         assert url.size() > len("samplefile")
311 
312     def test_mtime(self, path1):
313         url = path1.join("samplefile")
314         assert url.mtime() > 0
315 
316     def test_relto_wrong_type(self, path1):
317         with pytest.raises(TypeError):
318             path1.relto(42)
319 
320     def test_load(self, path1):
321         p = path1.join("samplepickle")
322         obj = p.load()
323         assert type(obj) is dict
324         assert obj.get("answer", None) == 42
325 
326     def test_visit_filesonly(self, path1):
327         p = []
328         for i in path1.visit(lambda x: x.check(file=1)):
329             p.append(i.relto(path1))
330         assert "sampledir" not in p
331         assert path1.sep.join(["sampledir", "otherfile"]) in p
332 
333     def test_visit_nodotfiles(self, path1):
334         p = []
335         for i in path1.visit(lambda x: x.check(dotfile=0)):
336             p.append(i.relto(path1))
337         assert "sampledir" in p
338         assert path1.sep.join(["sampledir", "otherfile"]) in p
339         assert ".dotfile" not in p
340 
341     def test_visit_breadthfirst(self, path1):
342         lst = []
343         for i in path1.visit(bf=True):
344             lst.append(i.relto(path1))
345         for i, p in enumerate(lst):
346             if path1.sep in p:
347                 for j in range(i, len(lst)):
348                     assert path1.sep in lst[j]
349                 break
350         else:
351             pytest.fail("huh")
352 
353     def test_visit_sort(self, path1):
354         lst = []
355         for i in path1.visit(bf=True, sort=True):
356             lst.append(i.relto(path1))
357         for i, p in enumerate(lst):
358             if path1.sep in p:
359                 break
360         assert lst[:i] == sorted(lst[:i])
361         assert lst[i:] == sorted(lst[i:])
362 
363     def test_endswith(self, path1):
364         def chk(p):
365             return p.check(endswith="pickle")
366 
367         assert not chk(path1)
368         assert not chk(path1.join("samplefile"))
369         assert chk(path1.join("somepickle"))
370 
371     def test_copy_file(self, path1):
372         otherdir = path1.join("otherdir")
373         initpy = otherdir.join("__init__.py")
374         copied = otherdir.join("copied")
375         initpy.copy(copied)
376         try:
377             assert copied.check()
378             s1 = initpy.read_text(encoding="utf-8")
379             s2 = copied.read_text(encoding="utf-8")
380             assert s1 == s2
381         finally:
382             if copied.check():
383                 copied.remove()
384 
385     def test_copy_dir(self, path1):
386         otherdir = path1.join("otherdir")
387         copied = path1.join("newdir")
388         try:
389             otherdir.copy(copied)
390             assert copied.check(dir=1)
391             assert copied.join("__init__.py").check(file=1)
392             s1 = otherdir.join("__init__.py").read_text(encoding="utf-8")
393             s2 = copied.join("__init__.py").read_text(encoding="utf-8")
394             assert s1 == s2
395         finally:
396             if copied.check(dir=1):
397                 copied.remove(rec=1)
398 
399     def test_remove_file(self, path1):
400         d = path1.ensure("todeleted")
401         assert d.check()
402         d.remove()
403         assert not d.check()
404 
405     def test_remove_dir_recursive_by_default(self, path1):
406         d = path1.ensure("to", "be", "deleted")
407         assert d.check()
408         p = path1.join("to")
409         p.remove()
410         assert not p.check()
411 
412     def test_ensure_dir(self, path1):
413         b = path1.ensure_dir("001", "002")
414         assert b.basename == "002"
415         assert b.isdir()
416 
417     def test_mkdir_and_remove(self, path1):
418         tmpdir = path1
419         with pytest.raises(error.EEXIST):
420             tmpdir.mkdir("sampledir")
421         new = tmpdir.join("mktest1")
422         new.mkdir()
423         assert new.check(dir=1)
424         new.remove()
425 
426         new = tmpdir.mkdir("mktest")
427         assert new.check(dir=1)
428         new.remove()
429         assert tmpdir.join("mktest") == new
430 
431     def test_move_file(self, path1):
432         p = path1.join("samplefile")
433         newp = p.dirpath("moved_samplefile")
434         p.move(newp)
435         try:
436             assert newp.check(file=1)
437             assert not p.check()
438         finally:
439             dp = newp.dirpath()
440             if hasattr(dp, "revert"):
441                 dp.revert()
442             else:
443                 newp.move(p)
444                 assert p.check()
445 
446     def test_move_dir(self, path1):
447         source = path1.join("sampledir")
448         dest = path1.join("moveddir")
449         source.move(dest)
450         assert dest.check(dir=1)
451         assert dest.join("otherfile").check(file=1)
452         assert not source.join("sampledir").check()
453 
454     def test_fspath_protocol_match_strpath(self, path1):
455         assert path1.__fspath__() == path1.strpath
456 
457     def test_fspath_func_match_strpath(self, path1):
458         from os import fspath
459 
460         assert fspath(path1) == path1.strpath
461 
462     @pytest.mark.skip("sys.version_info < (3,6)")
463     def test_fspath_open(self, path1):
464         f = path1.join("opentestfile")
465         open(f)
466 
467     @pytest.mark.skip("sys.version_info < (3,6)")
468     def test_fspath_fsencode(self, path1):
469         from os import fsencode
470 
471         assert fsencode(path1) == fsencode(path1.strpath)
472 
473 
474 def setuptestfs(path):
475     if path.join("samplefile").check():
476         return
477     # print "setting up test fs for", repr(path)
478     samplefile = path.ensure("samplefile")
479     samplefile.write_text("samplefile\n", encoding="utf-8")
480 
481     execfile = path.ensure("execfile")
482     execfile.write_text("x=42", encoding="utf-8")
483 
484     execfilepy = path.ensure("execfile.py")
485     execfilepy.write_text("x=42", encoding="utf-8")
486 
487     d = {1: 2, "hello": "world", "answer": 42}
488     path.ensure("samplepickle").dump(d)
489 
490     sampledir = path.ensure("sampledir", dir=1)
491     sampledir.ensure("otherfile")
492 
493     otherdir = path.ensure("otherdir", dir=1)
494     otherdir.ensure("__init__.py")
495 
496     module_a = otherdir.ensure("a.py")
497     module_a.write_text("from .b import stuff as result\n", encoding="utf-8")
498     module_b = otherdir.ensure("b.py")
499     module_b.write_text('stuff="got it"\n', encoding="utf-8")
500     module_c = otherdir.ensure("c.py")
501     module_c.write_text(
502         """import py;
503 import otherdir.a
504 value = otherdir.a.result
505 """,
506         encoding="utf-8",
507     )
508     module_d = otherdir.ensure("d.py")
509     module_d.write_text(
510         """import py;
511 from otherdir import a
512 value2 = a.result
513 """,
514         encoding="utf-8",
515     )
516 
517 
518 win32only = pytest.mark.skipif(
519     "not (sys.platform == 'win32' or getattr(os, '_name', None) == 'nt')"
520 )
521 skiponwin32 = pytest.mark.skipif(
522     "sys.platform == 'win32' or getattr(os, '_name', None) == 'nt'"
523 )
524 
525 ATIME_RESOLUTION = 0.01
526 
527 
528 @pytest.fixture(scope="session")
529 def path1(tmpdir_factory):
530     path = tmpdir_factory.mktemp("path")
531     setuptestfs(path)
532     yield path
533     assert path.join("samplefile").check()
534 
535 
536 @pytest.fixture
537 def fake_fspath_obj(request):
538     class FakeFSPathClass:
539         def __init__(self, path):
540             self._path = path
541 
542         def __fspath__(self):
543             return self._path
544 
545     return FakeFSPathClass(os.path.join("this", "is", "a", "fake", "path"))
546 
547 
548 def batch_make_numbered_dirs(rootdir, repeats):
549     for i in range(repeats):
550         dir_ = local.make_numbered_dir(prefix="repro-", rootdir=rootdir)
551         file_ = dir_.join("foo")
552         file_.write_text("%s" % i, encoding="utf-8")
553         actual = int(file_.read_text(encoding="utf-8"))
554         assert (
555             actual == i
556         ), f"int(file_.read_text(encoding='utf-8')) is {actual} instead of {i}"
557         dir_.join(".lock").remove(ignore_errors=True)
558     return True
559 
560 
561 class TestLocalPath(CommonFSTests):
562     def test_join_normpath(self, tmpdir):
563         assert tmpdir.join(".") == tmpdir
564         p = tmpdir.join("../%s" % tmpdir.basename)
565         assert p == tmpdir
566         p = tmpdir.join("..//%s/" % tmpdir.basename)
567         assert p == tmpdir
568 
569     @skiponwin32
570     def test_dirpath_abs_no_abs(self, tmpdir):
571         p = tmpdir.join("foo")
572         assert p.dirpath("/bar") == tmpdir.join("bar")
573         assert tmpdir.dirpath("/bar", abs=True) == local("/bar")
574 
575     def test_gethash(self, tmpdir):
576         from hashlib import md5
577         from hashlib import sha1 as sha
578 
579         fn = tmpdir.join("testhashfile")
580         data = b"hello"
581         fn.write(data, mode="wb")
582         assert fn.computehash("md5") == md5(data).hexdigest()
583         assert fn.computehash("sha1") == sha(data).hexdigest()
584         with pytest.raises(ValueError):
585             fn.computehash("asdasd")
586 
587     def test_remove_removes_readonly_file(self, tmpdir):
588         readonly_file = tmpdir.join("readonly").ensure()
589         readonly_file.chmod(0)
590         readonly_file.remove()
591         assert not readonly_file.check(exists=1)
592 
593     def test_remove_removes_readonly_dir(self, tmpdir):
594         readonly_dir = tmpdir.join("readonlydir").ensure(dir=1)
595         readonly_dir.chmod(int("500", 8))
596         readonly_dir.remove()
597         assert not readonly_dir.check(exists=1)
598 
599     def test_remove_removes_dir_and_readonly_file(self, tmpdir):
600         readonly_dir = tmpdir.join("readonlydir").ensure(dir=1)
601         readonly_file = readonly_dir.join("readonlyfile").ensure()
602         readonly_file.chmod(0)
603         readonly_dir.remove()
604         assert not readonly_dir.check(exists=1)
605 
606     def test_remove_routes_ignore_errors(self, tmpdir, monkeypatch):
607         lst = []
608         monkeypatch.setattr("shutil.rmtree", lambda *args, **kwargs: lst.append(kwargs))
609         tmpdir.remove()
610         assert not lst[0]["ignore_errors"]
611         for val in (True, False):
612             lst[:] = []
613             tmpdir.remove(ignore_errors=val)
614             assert lst[0]["ignore_errors"] == val
615 
616     def test_initialize_curdir(self):
617         assert str(local()) == os.getcwd()
618 
619     @skiponwin32
620     def test_chdir_gone(self, path1):
621         p = path1.ensure("dir_to_be_removed", dir=1)
622         p.chdir()
623         p.remove()
624         pytest.raises(error.ENOENT, local)
625         assert path1.chdir() is None
626         assert os.getcwd() == str(path1)
627 
628         with pytest.raises(error.ENOENT):
629             with p.as_cwd():
630                 raise NotImplementedError
631 
632     @skiponwin32
633     def test_chdir_gone_in_as_cwd(self, path1):
634         p = path1.ensure("dir_to_be_removed", dir=1)
635         p.chdir()
636         p.remove()
637 
638         with path1.as_cwd() as old:
639             assert old is None
640 
641     def test_as_cwd(self, path1):
642         dir = path1.ensure("subdir", dir=1)
643         old = local()
644         with dir.as_cwd() as x:
645             assert x == old
646             assert local() == dir
647         assert os.getcwd() == str(old)
648 
649     def test_as_cwd_exception(self, path1):
650         old = local()
651         dir = path1.ensure("subdir", dir=1)
652         with pytest.raises(ValueError):
653             with dir.as_cwd():
654                 raise ValueError()
655         assert old == local()
656 
657     def test_initialize_reldir(self, path1):
658         with path1.as_cwd():
659             p = local("samplefile")
660             assert p.check()
661 
662     def test_tilde_expansion(self, monkeypatch, tmpdir):
663         monkeypatch.setenv("HOME", str(tmpdir))
664         p = local("~", expanduser=True)
665         assert p == os.path.expanduser("~")
666 
667     @pytest.mark.skipif(
668         not sys.platform.startswith("win32"), reason="case insensitive only on windows"
669     )
670     def test_eq_hash_are_case_insensitive_on_windows(self):
671         a = local("/some/path")
672         b = local("/some/PATH")
673         assert a == b
674         assert hash(a) == hash(b)
675         assert a in {b}
676         assert a in {b: "b"}
677 
678     def test_eq_with_strings(self, path1):
679         path1 = path1.join("sampledir")
680         path2 = str(path1)
681         assert path1 == path2
682         assert path2 == path1
683         path3 = path1.join("samplefile")
684         assert path3 != path2
685         assert path2 != path3
686 
687     def test_eq_with_none(self, path1):
688         assert path1 != None  # noqa: E711
689 
690     def test_eq_non_ascii_unicode(self, path1):
691         path2 = path1.join("temp")
692         path3 = path1.join("ao")
693         path4 = path1.join("")
694 
695         assert path2 != path3
696         assert path2 != path4
697         assert path4 != path3
698 
699     def test_gt_with_strings(self, path1):
700         path2 = path1.join("sampledir")
701         path3 = str(path1.join("ttt"))
702         assert path3 > path2
703         assert path2 < path3
704         assert path2 < "ttt"
705         assert "ttt" > path2
706         path4 = path1.join("aaa")
707         lst = [path2, path4, path3]
708         assert sorted(lst) == [path4, path2, path3]
709 
710     def test_open_and_ensure(self, path1):
711         p = path1.join("sub1", "sub2", "file")
712         with p.open("w", ensure=1, encoding="utf-8") as f:
713             f.write("hello")
714         assert p.read_text(encoding="utf-8") == "hello"
715 
716     def test_write_and_ensure(self, path1):
717         p = path1.join("sub1", "sub2", "file")
718         p.write_text("hello", ensure=1, encoding="utf-8")
719         assert p.read_text(encoding="utf-8") == "hello"
720 
721     @pytest.mark.parametrize("bin", (False, True))
722     def test_dump(self, tmpdir, bin):
723         path = tmpdir.join("dumpfile%s" % int(bin))
724         try:
725             d = {"answer": 42}
726             path.dump(d, bin=bin)
727             f = path.open("rb+")
728             import pickle
729 
730             dnew = pickle.load(f)
731             assert d == dnew
732         finally:
733             f.close()
734 
735     def test_setmtime(self):
736         import tempfile
737         import time
738 
739         try:
740             fd, name = tempfile.mkstemp()
741             os.close(fd)
742         except AttributeError:
743             name = tempfile.mktemp()
744             open(name, "w").close()
745         try:
746             mtime = int(time.time()) - 100
747             path = local(name)
748             assert path.mtime() != mtime
749             path.setmtime(mtime)
750             assert path.mtime() == mtime
751             path.setmtime()
752             assert path.mtime() != mtime
753         finally:
754             os.remove(name)
755 
756     def test_normpath(self, path1):
757         new1 = path1.join("/otherdir")
758         new2 = path1.join("otherdir")
759         assert str(new1) == str(new2)
760 
761     def test_mkdtemp_creation(self):
762         d = local.mkdtemp()
763         try:
764             assert d.check(dir=1)
765         finally:
766             d.remove(rec=1)
767 
768     def test_tmproot(self):
769         d = local.mkdtemp()
770         tmproot = local.get_temproot()
771         try:
772             assert d.check(dir=1)
773             assert d.dirpath() == tmproot
774         finally:
775             d.remove(rec=1)
776 
777     def test_chdir(self, tmpdir):
778         old = local()
779         try:
780             res = tmpdir.chdir()
781             assert str(res) == str(old)
782             assert os.getcwd() == str(tmpdir)
783         finally:
784             old.chdir()
785 
786     def test_ensure_filepath_withdir(self, tmpdir):
787         newfile = tmpdir.join("test1", "test")
788         newfile.ensure()
789         assert newfile.check(file=1)
790         newfile.write_text("42", encoding="utf-8")
791         newfile.ensure()
792         s = newfile.read_text(encoding="utf-8")
793         assert s == "42"
794 
795     def test_ensure_filepath_withoutdir(self, tmpdir):
796         newfile = tmpdir.join("test1file")
797         t = newfile.ensure()
798         assert t == newfile
799         assert newfile.check(file=1)
800 
801     def test_ensure_dirpath(self, tmpdir):
802         newfile = tmpdir.join("test1", "testfile")
803         t = newfile.ensure(dir=1)
804         assert t == newfile
805         assert newfile.check(dir=1)
806 
807     def test_ensure_non_ascii_unicode(self, tmpdir):
808         newfile = tmpdir.join("ao", "")
809         t = newfile.ensure(dir=1)
810         assert t == newfile
811         assert newfile.check(dir=1)
812 
813     @pytest.mark.xfail(run=False, reason="unreliable est for long filenames")
814     def test_long_filenames(self, tmpdir):
815         if sys.platform == "win32":
816             pytest.skip("win32: work around needed for path length limit")
817         # see http://codespeak.net/pipermail/py-dev/2008q2/000922.html
818 
819         # testing paths > 260 chars (which is Windows' limitation, but
820         # depending on how the paths are used), but > 4096 (which is the
821         # Linux' limitation) - the behaviour of paths with names > 4096 chars
822         # is undetermined
823         newfilename = "/test" * 60  # type:ignore[unreachable]
824         l1 = tmpdir.join(newfilename)
825         l1.ensure(file=True)
826         l1.write_text("foo", encoding="utf-8")
827         l2 = tmpdir.join(newfilename)
828         assert l2.read_text(encoding="utf-8") == "foo"
829 
830     def test_visit_depth_first(self, tmpdir):
831         tmpdir.ensure("a", "1")
832         tmpdir.ensure("b", "2")
833         p3 = tmpdir.ensure("breadth")
834         lst = list(tmpdir.visit(lambda x: x.check(file=1)))
835         assert len(lst) == 3
836         # check that breadth comes last
837         assert lst[2] == p3
838 
839     def test_visit_rec_fnmatch(self, tmpdir):
840         p1 = tmpdir.ensure("a", "123")
841         tmpdir.ensure(".b", "345")
842         lst = list(tmpdir.visit("???", rec="[!.]*"))
843         assert len(lst) == 1
844         # check that breadth comes last
845         assert lst[0] == p1
846 
847     def test_fnmatch_file_abspath(self, tmpdir):
848         b = tmpdir.join("a", "b")
849         assert b.fnmatch(os.sep.join("ab"))
850         pattern = os.sep.join([str(tmpdir), "*", "b"])
851         assert b.fnmatch(pattern)
852 
853     def test_sysfind(self):
854         name = sys.platform == "win32" and "cmd" or "test"
855         x = local.sysfind(name)
856         assert x.check(file=1)
857         assert local.sysfind("jaksdkasldqwe") is None
858         assert local.sysfind(name, paths=[]) is None
859         x2 = local.sysfind(name, paths=[x.dirpath()])
860         assert x2 == x
861 
862     def test_fspath_protocol_other_class(self, fake_fspath_obj):
863         # py.path is always absolute
864         py_path = local(fake_fspath_obj)
865         str_path = fake_fspath_obj.__fspath__()
866         assert py_path.check(endswith=str_path)
867         assert py_path.join(fake_fspath_obj).strpath == os.path.join(
868             py_path.strpath, str_path
869         )
870 
871     def test_make_numbered_dir_multiprocess_safe(self, tmpdir):
872         # https://github.com/pytest-dev/py/issues/30
873         with multiprocessing.Pool() as pool:
874             results = [
875                 pool.apply_async(batch_make_numbered_dirs, [tmpdir, 100])
876                 for _ in range(20)
877             ]
878             for r in results:
879                 assert r.get()
880 
881 
882 class TestExecutionOnWindows:
883     pytestmark = win32only
884 
885     def test_sysfind_bat_exe_before(self, tmpdir, monkeypatch):
886         monkeypatch.setenv("PATH", str(tmpdir), prepend=os.pathsep)
887         tmpdir.ensure("hello")
888         h = tmpdir.ensure("hello.bat")
889         x = local.sysfind("hello")
890         assert x == h
891 
892 
893 class TestExecution:
894     pytestmark = skiponwin32
895 
896     def test_sysfind_no_permisson_ignored(self, monkeypatch, tmpdir):
897         noperm = tmpdir.ensure("noperm", dir=True)
898         monkeypatch.setenv("PATH", str(noperm), prepend=":")
899         noperm.chmod(0)
900         try:
901             assert local.sysfind("jaksdkasldqwe") is None
902         finally:
903             noperm.chmod(0o644)
904 
905     def test_sysfind_absolute(self):
906         x = local.sysfind("test")
907         assert x.check(file=1)
908         y = local.sysfind(str(x))
909         assert y.check(file=1)
910         assert y == x
911 
912     def test_sysfind_multiple(self, tmpdir, monkeypatch):
913         monkeypatch.setenv(
914             "PATH", "{}:{}".format(tmpdir.ensure("a"), tmpdir.join("b")), prepend=":"
915         )
916         tmpdir.ensure("b", "a")
917         x = local.sysfind("a", checker=lambda x: x.dirpath().basename == "b")
918         assert x.basename == "a"
919         assert x.dirpath().basename == "b"
920         assert local.sysfind("a", checker=lambda x: None) is None
921 
922     def test_sysexec(self):
923         x = local.sysfind("ls")
924         out = x.sysexec("-a")
925         for x in local().listdir():
926             assert out.find(x.basename) != -1
927 
928     def test_sysexec_failing(self):
929         try:
930             from py._process.cmdexec import ExecutionFailed  # py library
931         except ImportError:
932             ExecutionFailed = RuntimeError  # py vendored
933         x = local.sysfind("false")
934         with pytest.raises(ExecutionFailed):
935             x.sysexec("aksjdkasjd")
936 
937     def test_make_numbered_dir(self, tmpdir):
938         tmpdir.ensure("base.not_an_int", dir=1)
939         for i in range(10):
940             numdir = local.make_numbered_dir(
941                 prefix="base.", rootdir=tmpdir, keep=2, lock_timeout=0
942             )
943             assert numdir.check()
944             assert numdir.basename == "base.%d" % i
945             if i >= 1:
946                 assert numdir.new(ext=str(i - 1)).check()
947             if i >= 2:
948                 assert numdir.new(ext=str(i - 2)).check()
949             if i >= 3:
950                 assert not numdir.new(ext=str(i - 3)).check()
951 
952     def test_make_numbered_dir_case(self, tmpdir):
953         """make_numbered_dir does not make assumptions on the underlying
954         filesystem based on the platform and will assume it _could_ be case
955         insensitive.
956 
957         See issues:
958         - https://github.com/pytest-dev/pytest/issues/708
959         - https://github.com/pytest-dev/pytest/issues/3451
960         """
961         d1 = local.make_numbered_dir(
962             prefix="CAse.",
963             rootdir=tmpdir,
964             keep=2,
965             lock_timeout=0,
966         )
967         d2 = local.make_numbered_dir(
968             prefix="caSE.",
969             rootdir=tmpdir,
970             keep=2,
971             lock_timeout=0,
972         )
973         assert str(d1).lower() != str(d2).lower()
974         assert str(d2).endswith(".1")
975 
976     def test_make_numbered_dir_NotImplemented_Error(self, tmpdir, monkeypatch):
977         def notimpl(x, y):
978             raise NotImplementedError(42)
979 
980         monkeypatch.setattr(os, "symlink", notimpl)
981         x = tmpdir.make_numbered_dir(rootdir=tmpdir, lock_timeout=0)
982         assert x.relto(tmpdir)
983         assert x.check()
984 
985     def test_locked_make_numbered_dir(self, tmpdir):
986         for i in range(10):
987             numdir = local.make_numbered_dir(prefix="base2.", rootdir=tmpdir, keep=2)
988             assert numdir.check()
989             assert numdir.basename == "base2.%d" % i
990             for j in range(i):
991                 assert numdir.new(ext=str(j)).check()
992 
993     def test_error_preservation(self, path1):
994         pytest.raises(EnvironmentError, path1.join("qwoeqiwe").mtime)
995         pytest.raises(EnvironmentError, path1.join("qwoeqiwe").read)
996 
997     # def test_parentdirmatch(self):
998     #    local.parentdirmatch('std', startmodule=__name__)
999     #
1000 
1001 
1002 class TestImport:
1003     @pytest.fixture(autouse=True)
1004     def preserve_sys(self):
1005         with mock.patch.dict(sys.modules):
1006             with mock.patch.object(sys, "path", list(sys.path)):
1007                 yield
1008 
1009     def test_pyimport(self, path1):
1010         obj = path1.join("execfile.py").pyimport()
1011         assert obj.x == 42
1012         assert obj.__name__ == "execfile"
1013 
1014     def test_pyimport_renamed_dir_creates_mismatch(self, tmpdir, monkeypatch):
1015         p = tmpdir.ensure("a", "test_x123.py")
1016         p.pyimport()
1017         tmpdir.join("a").move(tmpdir.join("b"))
1018         with pytest.raises(tmpdir.ImportMismatchError):
1019             tmpdir.join("b", "test_x123.py").pyimport()
1020 
1021         # Errors can be ignored.
1022         monkeypatch.setenv("PY_IGNORE_IMPORTMISMATCH", "1")
1023         tmpdir.join("b", "test_x123.py").pyimport()
1024 
1025         # PY_IGNORE_IMPORTMISMATCH=0 does not ignore error.
1026         monkeypatch.setenv("PY_IGNORE_IMPORTMISMATCH", "0")
1027         with pytest.raises(tmpdir.ImportMismatchError):
1028             tmpdir.join("b", "test_x123.py").pyimport()
1029 
1030     def test_pyimport_messy_name(self, tmpdir):
1031         # http://bitbucket.org/hpk42/py-trunk/issue/129
1032         path = tmpdir.ensure("foo__init__.py")
1033         path.pyimport()
1034 
1035     def test_pyimport_dir(self, tmpdir):
1036         p = tmpdir.join("hello_123")
1037         p_init = p.ensure("__init__.py")
1038         m = p.pyimport()
1039         assert m.__name__ == "hello_123"
1040         m = p_init.pyimport()
1041         assert m.__name__ == "hello_123"
1042 
1043     def test_pyimport_execfile_different_name(self, path1):
1044         obj = path1.join("execfile.py").pyimport(modname="0x.y.z")
1045         assert obj.x == 42
1046         assert obj.__name__ == "0x.y.z"
1047 
1048     def test_pyimport_a(self, path1):
1049         otherdir = path1.join("otherdir")
1050         mod = otherdir.join("a.py").pyimport()
1051         assert mod.result == "got it"
1052         assert mod.__name__ == "otherdir.a"
1053 
1054     def test_pyimport_b(self, path1):
1055         otherdir = path1.join("otherdir")
1056         mod = otherdir.join("b.py").pyimport()
1057         assert mod.stuff == "got it"
1058         assert mod.__name__ == "otherdir.b"
1059 
1060     def test_pyimport_c(self, path1):
1061         otherdir = path1.join("otherdir")
1062         mod = otherdir.join("c.py").pyimport()
1063         assert mod.value == "got it"
1064 
1065     def test_pyimport_d(self, path1):
1066         otherdir = path1.join("otherdir")
1067         mod = otherdir.join("d.py").pyimport()
1068         assert mod.value2 == "got it"
1069 
1070     def test_pyimport_and_import(self, tmpdir):
1071         tmpdir.ensure("xxxpackage", "__init__.py")
1072         mod1path = tmpdir.ensure("xxxpackage", "module1.py")
1073         mod1 = mod1path.pyimport()
1074         assert mod1.__name__ == "xxxpackage.module1"
1075         from xxxpackage import module1
1076 
1077         assert module1 is mod1
1078 
1079     def test_pyimport_check_filepath_consistency(self, monkeypatch, tmpdir):
1080         name = "pointsback123"
1081         ModuleType = type(os)
1082         p = tmpdir.ensure(name + ".py")
1083         for ending in (".pyc", "$py.class", ".pyo"):
1084             mod = ModuleType(name)
1085             pseudopath = tmpdir.ensure(name + ending)
1086             mod.__file__ = str(pseudopath)
1087             monkeypatch.setitem(sys.modules, name, mod)
1088             newmod = p.pyimport()
1089             assert mod == newmod
1090         monkeypatch.undo()
1091         mod = ModuleType(name)
1092         pseudopath = tmpdir.ensure(name + "123.py")
1093         mod.__file__ = str(pseudopath)
1094         monkeypatch.setitem(sys.modules, name, mod)
1095         excinfo = pytest.raises(pseudopath.ImportMismatchError, p.pyimport)
1096         modname, modfile, orig = excinfo.value.args
1097         assert modname == name
1098         assert modfile == pseudopath
1099         assert orig == p
1100         assert issubclass(pseudopath.ImportMismatchError, ImportError)
1101 
1102     def test_issue131_pyimport_on__init__(self, tmpdir):
1103         # __init__.py files may be namespace packages, and thus the
1104         # __file__ of an imported module may not be ourselves
1105         # see issue
1106         p1 = tmpdir.ensure("proja", "__init__.py")
1107         p2 = tmpdir.ensure("sub", "proja", "__init__.py")
1108         m1 = p1.pyimport()
1109         m2 = p2.pyimport()
1110         assert m1 == m2
1111 
1112     def test_ensuresyspath_append(self, tmpdir):
1113         root1 = tmpdir.mkdir("root1")
1114         file1 = root1.ensure("x123.py")
1115         assert str(root1) not in sys.path
1116         file1.pyimport(ensuresyspath="append")
1117         assert str(root1) == sys.path[-1]
1118         assert str(root1) not in sys.path[:-1]
1119 
1120 
1121 class TestImportlibImport:
1122     OPTS = {"ensuresyspath": "importlib"}
1123 
1124     def test_pyimport(self, path1):
1125         obj = path1.join("execfile.py").pyimport(**self.OPTS)
1126         assert obj.x == 42
1127         assert obj.__name__ == "execfile"
1128 
1129     def test_pyimport_dir_fails(self, tmpdir):
1130         p = tmpdir.join("hello_123")
1131         p.ensure("__init__.py")
1132         with pytest.raises(ImportError):
1133             p.pyimport(**self.OPTS)
1134 
1135     def test_pyimport_execfile_different_name(self, path1):
1136         obj = path1.join("execfile.py").pyimport(modname="0x.y.z", **self.OPTS)
1137         assert obj.x == 42
1138         assert obj.__name__ == "0x.y.z"
1139 
1140     def test_pyimport_relative_import_fails(self, path1):
1141         otherdir = path1.join("otherdir")
1142         with pytest.raises(ImportError):
1143             otherdir.join("a.py").pyimport(**self.OPTS)
1144 
1145     def test_pyimport_doesnt_use_sys_modules(self, tmpdir):
1146         p = tmpdir.ensure("file738jsk.py")
1147         mod = p.pyimport(**self.OPTS)
1148         assert mod.__name__ == "file738jsk"
1149         assert "file738jsk" not in sys.modules
1150 
1151 
1152 def test_pypkgdir(tmpdir):
1153     pkg = tmpdir.ensure("pkg1", dir=1)
1154     pkg.ensure("__init__.py")
1155     pkg.ensure("subdir/__init__.py")
1156     assert pkg.pypkgpath() == pkg
1157     assert pkg.join("subdir", "__init__.py").pypkgpath() == pkg
1158 
1159 
1160 def test_pypkgdir_unimportable(tmpdir):
1161     pkg = tmpdir.ensure("pkg1-1", dir=1)  # unimportable
1162     pkg.ensure("__init__.py")
1163     subdir = pkg.ensure("subdir/__init__.py").dirpath()
1164     assert subdir.pypkgpath() == subdir
1165     assert subdir.ensure("xyz.py").pypkgpath() == subdir
1166     assert not pkg.pypkgpath()
1167 
1168 
1169 def test_isimportable():
1170     try:
1171         from py.path import isimportable  # py vendored version
1172     except ImportError:
1173         from py._path.local import isimportable  # py library
1174 
1175     assert not isimportable("")
1176     assert isimportable("x")
1177     assert isimportable("x1")
1178     assert isimportable("x_1")
1179     assert isimportable("_")
1180     assert isimportable("_1")
1181     assert not isimportable("x-1")
1182     assert not isimportable("x:1")
1183 
1184 
1185 def test_homedir_from_HOME(monkeypatch):
1186     path = os.getcwd()
1187     monkeypatch.setenv("HOME", path)
1188     assert local._gethomedir() == local(path)
1189 
1190 
1191 def test_homedir_not_exists(monkeypatch):
1192     monkeypatch.delenv("HOME", raising=False)
1193     monkeypatch.delenv("HOMEDRIVE", raising=False)
1194     homedir = local._gethomedir()
1195     assert homedir is None
1196 
1197 
1198 def test_samefile(tmpdir):
1199     assert tmpdir.samefile(tmpdir)
1200     p = tmpdir.ensure("hello")
1201     assert p.samefile(p)
1202     with p.dirpath().as_cwd():
1203         assert p.samefile(p.basename)
1204     if sys.platform == "win32":
1205         p1 = p.__class__(str(p).lower())
1206         p2 = p.__class__(str(p).upper())
1207         assert p1.samefile(p2)
1208 
1209 
1210 @pytest.mark.skipif(not hasattr(os, "symlink"), reason="os.symlink not available")
1211 def test_samefile_symlink(tmpdir):
1212     p1 = tmpdir.ensure("foo.txt")
1213     p2 = tmpdir.join("linked.txt")
1214     try:
1215         os.symlink(str(p1), str(p2))
1216     except (OSError, NotImplementedError) as e:
1217         # on Windows this might fail if the user doesn't have special symlink permissions
1218         # pypy3 on Windows doesn't implement os.symlink and raises NotImplementedError
1219         pytest.skip(str(e.args[0]))
1220 
1221     assert p1.samefile(p2)
1222 
1223 
1224 def test_listdir_single_arg(tmpdir):
1225     tmpdir.ensure("hello")
1226     assert tmpdir.listdir("hello")[0].basename == "hello"
1227 
1228 
1229 def test_mkdtemp_rootdir(tmpdir):
1230     dtmp = local.mkdtemp(rootdir=tmpdir)
1231     assert tmpdir.listdir() == [dtmp]
1232 
1233 
1234 class TestWINLocalPath:
1235     pytestmark = win32only
1236 
1237     def test_owner_group_not_implemented(self, path1):
1238         with pytest.raises(NotImplementedError):
1239             path1.stat().owner
1240         with pytest.raises(NotImplementedError):
1241             path1.stat().group
1242 
1243     def test_chmod_simple_int(self, path1):
1244         mode = path1.stat().mode
1245         # Ensure that we actually change the mode to something different.
1246         path1.chmod(mode == 0 and 1 or 0)
1247         try:
1248             print(path1.stat().mode)
1249             print(mode)
1250             assert path1.stat().mode != mode
1251         finally:
1252             path1.chmod(mode)
1253             assert path1.stat().mode == mode
1254 
1255     def test_path_comparison_lowercase_mixed(self, path1):
1256         t1 = path1.join("a_path")
1257         t2 = path1.join("A_path")
1258         assert t1 == t1
1259         assert t1 == t2
1260 
1261     def test_relto_with_mixed_case(self, path1):
1262         t1 = path1.join("a_path", "fiLe")
1263         t2 = path1.join("A_path")
1264         assert t1.relto(t2) == "fiLe"
1265 
1266     def test_allow_unix_style_paths(self, path1):
1267         t1 = path1.join("a_path")
1268         assert t1 == str(path1) + "\\a_path"
1269         t1 = path1.join("a_path/")
1270         assert t1 == str(path1) + "\\a_path"
1271         t1 = path1.join("dir/a_path")
1272         assert t1 == str(path1) + "\\dir\\a_path"
1273 
1274     def test_sysfind_in_currentdir(self, path1):
1275         cmd = local.sysfind("cmd")
1276         root = cmd.new(dirname="", basename="")  # c:\ in most installations
1277         with root.as_cwd():
1278             x = local.sysfind(cmd.relto(root))
1279             assert x.check(file=1)
1280 
1281     def test_fnmatch_file_abspath_posix_pattern_on_win32(self, tmpdir):
1282         # path-matching patterns might contain a posix path separator '/'
1283         # Test that we can match that pattern on windows.
1284         import posixpath
1285 
1286         b = tmpdir.join("a", "b")
1287         assert b.fnmatch(posixpath.sep.join("ab"))
1288         pattern = posixpath.sep.join([str(tmpdir), "*", "b"])
1289         assert b.fnmatch(pattern)
1290 
1291 
1292 class TestPOSIXLocalPath:
1293     pytestmark = skiponwin32
1294 
1295     def test_hardlink(self, tmpdir):
1296         linkpath = tmpdir.join("test")
1297         filepath = tmpdir.join("file")
1298         filepath.write_text("Hello", encoding="utf-8")
1299         nlink = filepath.stat().nlink
1300         linkpath.mklinkto(filepath)
1301         assert filepath.stat().nlink == nlink + 1
1302 
1303     def test_symlink_are_identical(self, tmpdir):
1304         filepath = tmpdir.join("file")
1305         filepath.write_text("Hello", encoding="utf-8")
1306         linkpath = tmpdir.join("test")
1307         linkpath.mksymlinkto(filepath)
1308         assert linkpath.readlink() == str(filepath)
1309 
1310     def test_symlink_isfile(self, tmpdir):
1311         linkpath = tmpdir.join("test")
1312         filepath = tmpdir.join("file")
1313         filepath.write_text("", encoding="utf-8")
1314         linkpath.mksymlinkto(filepath)
1315         assert linkpath.check(file=1)
1316         assert not linkpath.check(link=0, file=1)
1317         assert linkpath.islink()
1318 
1319     def test_symlink_relative(self, tmpdir):
1320         linkpath = tmpdir.join("test")
1321         filepath = tmpdir.join("file")
1322         filepath.write_text("Hello", encoding="utf-8")
1323         linkpath.mksymlinkto(filepath, absolute=False)
1324         assert linkpath.readlink() == "file"
1325         assert filepath.read_text(encoding="utf-8") == linkpath.read_text(
1326             encoding="utf-8"
1327         )
1328 
1329     def test_symlink_not_existing(self, tmpdir):
1330         linkpath = tmpdir.join("testnotexisting")
1331         assert not linkpath.check(link=1)
1332         assert linkpath.check(link=0)
1333 
1334     def test_relto_with_root(self, path1, tmpdir):
1335         y = path1.join("x").relto(local("/"))
1336         assert y[0] == str(path1)[1]
1337 
1338     def test_visit_recursive_symlink(self, tmpdir):
1339         linkpath = tmpdir.join("test")
1340         linkpath.mksymlinkto(tmpdir)
1341         visitor = tmpdir.visit(None, lambda x: x.check(link=0))
1342         assert list(visitor) == [linkpath]
1343 
1344     def test_symlink_isdir(self, tmpdir):
1345         linkpath = tmpdir.join("test")
1346         linkpath.mksymlinkto(tmpdir)
1347         assert linkpath.check(dir=1)
1348         assert not linkpath.check(link=0, dir=1)
1349 
1350     def test_symlink_remove(self, tmpdir):
1351         linkpath = tmpdir.join("test")
1352         linkpath.mksymlinkto(linkpath)  # point to itself
1353         assert linkpath.check(link=1)
1354         linkpath.remove()
1355         assert not linkpath.check()
1356 
1357     def test_realpath_file(self, tmpdir):
1358         linkpath = tmpdir.join("test")
1359         filepath = tmpdir.join("file")
1360         filepath.write_text("", encoding="utf-8")
1361         linkpath.mksymlinkto(filepath)
1362         realpath = linkpath.realpath()
1363         assert realpath.basename == "file"
1364 
1365     def test_owner(self, path1, tmpdir):
1366         from pwd import getpwuid  # type:ignore[attr-defined]
1367         from grp import getgrgid  # type:ignore[attr-defined]
1368 
1369         stat = path1.stat()
1370         assert stat.path == path1
1371 
1372         uid = stat.uid
1373         gid = stat.gid
1374         owner = getpwuid(uid)[0]
1375         group = getgrgid(gid)[0]
1376 
1377         assert uid == stat.uid
1378         assert owner == stat.owner
1379         assert gid == stat.gid
1380         assert group == stat.group
1381 
1382     def test_stat_helpers(self, tmpdir, monkeypatch):
1383         path1 = tmpdir.ensure("file")
1384         stat1 = path1.stat()
1385         stat2 = tmpdir.stat()
1386         assert stat1.isfile()
1387         assert stat2.isdir()
1388         assert not stat1.islink()
1389         assert not stat2.islink()
1390 
1391     def test_stat_non_raising(self, tmpdir):
1392         path1 = tmpdir.join("file")
1393         pytest.raises(error.ENOENT, lambda: path1.stat())
1394         res = path1.stat(raising=False)
1395         assert res is None
1396 
1397     def test_atime(self, tmpdir):
1398         import time
1399 
1400         path = tmpdir.ensure("samplefile")
1401         now = time.time()
1402         atime1 = path.atime()
1403         # we could wait here but timer resolution is very
1404         # system dependent
1405         path.read_binary()
1406         time.sleep(ATIME_RESOLUTION)
1407         atime2 = path.atime()
1408         time.sleep(ATIME_RESOLUTION)
1409         duration = time.time() - now
1410         assert (atime2 - atime1) <= duration
1411 
1412     def test_commondir(self, path1):
1413         # XXX This is here in local until we find a way to implement this
1414         #     using the subversion command line api.
1415         p1 = path1.join("something")
1416         p2 = path1.join("otherthing")
1417         assert p1.common(p2) == path1
1418         assert p2.common(p1) == path1
1419 
1420     def test_commondir_nocommon(self, path1):
1421         # XXX This is here in local until we find a way to implement this
1422         #     using the subversion command line api.
1423         p1 = path1.join("something")
1424         p2 = local(path1.sep + "blabla")
1425         assert p1.common(p2) == "/"
1426 
1427     def test_join_to_root(self, path1):
1428         root = path1.parts()[0]
1429         assert len(str(root)) == 1
1430         assert str(root.join("a")) == "/a"
1431 
1432     def test_join_root_to_root_with_no_abs(self, path1):
1433         nroot = path1.join("/")
1434         assert str(path1) == str(nroot)
1435         assert path1 == nroot
1436 
1437     def test_chmod_simple_int(self, path1):
1438         mode = path1.stat().mode
1439         path1.chmod(int(mode / 2))
1440         try:
1441             assert path1.stat().mode != mode
1442         finally:
1443             path1.chmod(mode)
1444             assert path1.stat().mode == mode
1445 
1446     def test_chmod_rec_int(self, path1):
1447         # XXX fragile test
1448         def recfilter(x):
1449             return x.check(dotfile=0, link=0)
1450 
1451         oldmodes = {}
1452         for x in path1.visit(rec=recfilter):
1453             oldmodes[x] = x.stat().mode
1454         path1.chmod(int("772", 8), rec=recfilter)
1455         try:
1456             for x in path1.visit(rec=recfilter):
1457                 assert x.stat().mode & int("777", 8) == int("772", 8)
1458         finally:
1459             for x, y in oldmodes.items():
1460                 x.chmod(y)
1461 
1462     def test_copy_archiving(self, tmpdir):
1463         unicode_fn = "something-\342\200\223.txt"
1464         f = tmpdir.ensure("a", unicode_fn)
1465         a = f.dirpath()
1466         oldmode = f.stat().mode
1467         newmode = oldmode ^ 1
1468         f.chmod(newmode)
1469         b = tmpdir.join("b")
1470         a.copy(b, mode=True)
1471         assert b.join(f.basename).stat().mode == newmode
1472 
1473     def test_copy_stat_file(self, tmpdir):
1474         src = tmpdir.ensure("src")
1475         dst = tmpdir.join("dst")
1476         # a small delay before the copy
1477         time.sleep(ATIME_RESOLUTION)
1478         src.copy(dst, stat=True)
1479         oldstat = src.stat()
1480         newstat = dst.stat()
1481         assert oldstat.mode == newstat.mode
1482         assert (dst.atime() - src.atime()) < ATIME_RESOLUTION
1483         assert (dst.mtime() - src.mtime()) < ATIME_RESOLUTION
1484 
1485     def test_copy_stat_dir(self, tmpdir):
1486         test_files = ["a", "b", "c"]
1487         src = tmpdir.join("src")
1488         for f in test_files:
1489             src.join(f).write_text(f, ensure=True, encoding="utf-8")
1490         dst = tmpdir.join("dst")
1491         # a small delay before the copy
1492         time.sleep(ATIME_RESOLUTION)
1493         src.copy(dst, stat=True)
1494         for f in test_files:
1495             oldstat = src.join(f).stat()
1496             newstat = dst.join(f).stat()
1497             assert (newstat.atime - oldstat.atime) < ATIME_RESOLUTION
1498             assert (newstat.mtime - oldstat.mtime) < ATIME_RESOLUTION
1499             assert oldstat.mode == newstat.mode
1500 
1501     def test_chown_identity(self, path1):
1502         owner = path1.stat().owner
1503         group = path1.stat().group
1504         path1.chown(owner, group)
1505 
1506     def test_chown_dangling_link(self, path1):
1507         owner = path1.stat().owner
1508         group = path1.stat().group
1509         x = path1.join("hello")
1510         x.mksymlinkto("qlwkejqwlek")
1511         try:
1512             path1.chown(owner, group, rec=1)
1513         finally:
1514             x.remove(rec=0)
1515 
1516     def test_chown_identity_rec_mayfail(self, path1):
1517         owner = path1.stat().owner
1518         group = path1.stat().group
1519         path1.chown(owner, group)
1520 
1521 
1522 class TestUnicodePy2Py3:
1523     def test_join_ensure(self, tmpdir, monkeypatch):
1524         if sys.version_info >= (3, 0) and "LANG" not in os.environ:
1525             pytest.skip("cannot run test without locale")
1526         x = local(tmpdir.strpath)
1527         part = "hllo"
1528         y = x.ensure(part)
1529         assert x.join(part) == y
1530 
1531     def test_listdir(self, tmpdir):
1532         if sys.version_info >= (3, 0) and "LANG" not in os.environ:
1533             pytest.skip("cannot run test without locale")
1534         x = local(tmpdir.strpath)
1535         part = "hllo"
1536         y = x.ensure(part)
1537         assert x.listdir(part)[0] == y
1538 
1539     @pytest.mark.xfail(reason="changing read/write might break existing usages")
1540     def test_read_write(self, tmpdir):
1541         x = tmpdir.join("hello")
1542         part = "hllo"
1543         with ignore_encoding_warning():
1544             x.write(part)
1545             assert x.read() == part
1546             x.write(part.encode(sys.getdefaultencoding()))
1547             assert x.read() == part.encode(sys.getdefaultencoding())
1548 
1549 
1550 class TestBinaryAndTextMethods:
1551     def test_read_binwrite(self, tmpdir):
1552         x = tmpdir.join("hello")
1553         part = "hllo"
1554         part_utf8 = part.encode("utf8")
1555         x.write_binary(part_utf8)
1556         assert x.read_binary() == part_utf8
1557         s = x.read_text(encoding="utf8")
1558         assert s == part
1559         assert isinstance(s, str)
1560 
1561     def test_read_textwrite(self, tmpdir):
1562         x = tmpdir.join("hello")
1563         part = "hllo"
1564         part_utf8 = part.encode("utf8")
1565         x.write_text(part, encoding="utf8")
1566         assert x.read_binary() == part_utf8
1567         assert x.read_text(encoding="utf8") == part
1568 
1569     def test_default_encoding(self, tmpdir):
1570         x = tmpdir.join("hello")
1571         # Can't use UTF8 as the default encoding (ASCII) doesn't support it
1572         part = "hello"
1573         x.write_text(part, "ascii")
1574         s = x.read_text("ascii")
1575         assert s == part
1576         assert type(s) == type(part)

</code><intended_behavior>The code handling namespace packages, both in tests and possibly in the application's core logic (where similar patterns are likely to be present), should ensure consistent and correct import paths to prevent module duplication. This might involve verifying and adjusting how `importlib` is used to import modules part of a namespace package, ensuring that a single instance of each module is maintained across the application.</intended_behavior>, <file>src/_pytest/pytester.py</file>
<class>None</class>
<method>None</method>
<code>
1 """(Disabled by default) support for testing pytest and pytest plugins.
2 
3 PYTEST_DONT_REWRITE
4 """
5 import collections.abc
6 import contextlib
7 import gc
8 import importlib
9 import locale
10 import os
11 import platform
12 import re
13 import shutil
14 import subprocess
15 import sys
16 import traceback
17 from fnmatch import fnmatch
18 from io import StringIO
19 from pathlib import Path
20 from typing import Any
21 from typing import Callable
22 from typing import Dict
23 from typing import Final
24 from typing import final
25 from typing import Generator
26 from typing import IO
27 from typing import Iterable
28 from typing import List
29 from typing import Literal
30 from typing import Optional
31 from typing import overload
32 from typing import Sequence
33 from typing import TextIO
34 from typing import Tuple
35 from typing import Type
36 from typing import TYPE_CHECKING
37 from typing import Union
38 from weakref import WeakKeyDictionary
39 
40 from iniconfig import IniConfig
41 from iniconfig import SectionWrapper
42 
43 from _pytest import timing
44 from _pytest._code import Source
45 from _pytest.capture import _get_multicapture
46 from _pytest.compat import NOTSET
47 from _pytest.compat import NotSetType
48 from _pytest.config import _PluggyPlugin
49 from _pytest.config import Config
50 from _pytest.config import ExitCode
51 from _pytest.config import hookimpl
52 from _pytest.config import main
53 from _pytest.config import PytestPluginManager
54 from _pytest.config.argparsing import Parser
55 from _pytest.deprecated import check_ispytest
56 from _pytest.fixtures import fixture
57 from _pytest.fixtures import FixtureRequest
58 from _pytest.main import Session
59 from _pytest.monkeypatch import MonkeyPatch
60 from _pytest.nodes import Collector
61 from _pytest.nodes import Item
62 from _pytest.outcomes import fail
63 from _pytest.outcomes import importorskip
64 from _pytest.outcomes import skip
65 from _pytest.pathlib import bestrelpath
66 from _pytest.pathlib import copytree
67 from _pytest.pathlib import make_numbered_dir
68 from _pytest.reports import CollectReport
69 from _pytest.reports import TestReport
70 from _pytest.tmpdir import TempPathFactory
71 from _pytest.warning_types import PytestWarning
72 
73 if TYPE_CHECKING:
74     import pexpect
75 
76 
77 pytest_plugins = ["pytester_assertions"]
78 
79 
80 IGNORE_PAM = [  # filenames added when obtaining details about the current user
81     "/var/lib/sss/mc/passwd"
82 ]
83 
84 
85 def pytest_addoption(parser: Parser) -> None:
86     parser.addoption(
87         "--lsof",
88         action="store_true",
89         dest="lsof",
90         default=False,
91         help="Run FD checks if lsof is available",
92     )
93 
94     parser.addoption(
95         "--runpytest",
96         default="inprocess",
97         dest="runpytest",
98         choices=("inprocess", "subprocess"),
99         help=(
100             "Run pytest sub runs in tests using an 'inprocess' "
101             "or 'subprocess' (python -m main) method"
102         ),
103     )
104 
105     parser.addini(
106         "pytester_example_dir", help="Directory to take the pytester example files from"
107     )
108 
109 
110 def pytest_configure(config: Config) -> None:
111     if config.getvalue("lsof"):
112         checker = LsofFdLeakChecker()
113         if checker.matching_platform():
114             config.pluginmanager.register(checker)
115 
116     config.addinivalue_line(
117         "markers",
118         "pytester_example_path(*path_segments): join the given path "
119         "segments to `pytester_example_dir` for this test.",
120     )
121 
122 
123 class LsofFdLeakChecker:
124     def get_open_files(self) -> List[Tuple[str, str]]:
125         out = subprocess.run(
126             ("lsof", "-Ffn0", "-p", str(os.getpid())),
127             stdout=subprocess.PIPE,
128             stderr=subprocess.DEVNULL,
129             check=True,
130             text=True,
131             encoding=locale.getpreferredencoding(False),
132         ).stdout
133 
134         def isopen(line: str) -> bool:
135             return line.startswith("f") and (
136                 "deleted" not in line
137                 and "mem" not in line
138                 and "txt" not in line
139                 and "cwd" not in line
140             )
141 
142         open_files = []
143 
144         for line in out.split("\n"):
145             if isopen(line):
146                 fields = line.split("\0")
147                 fd = fields[0][1:]
148                 filename = fields[1][1:]
149                 if filename in IGNORE_PAM:
150                     continue
151                 if filename.startswith("/"):
152                     open_files.append((fd, filename))
153 
154         return open_files
155 
156     def matching_platform(self) -> bool:
157         try:
158             subprocess.run(("lsof", "-v"), check=True)
159         except (OSError, subprocess.CalledProcessError):
160             return False
161         else:
162             return True
163 
164     @hookimpl(hookwrapper=True, tryfirst=True)
165     def pytest_runtest_protocol(self, item: Item) -> Generator[None, None, None]:
166         lines1 = self.get_open_files()
167         yield
168         if hasattr(sys, "pypy_version_info"):
169             gc.collect()
170         lines2 = self.get_open_files()
171 
172         new_fds = {t[0] for t in lines2} - {t[0] for t in lines1}
173         leaked_files = [t for t in lines2 if t[0] in new_fds]
174         if leaked_files:
175             error = [
176                 "***** %s FD leakage detected" % len(leaked_files),
177                 *(str(f) for f in leaked_files),
178                 "*** Before:",
179                 *(str(f) for f in lines1),
180                 "*** After:",
181                 *(str(f) for f in lines2),
182                 "***** %s FD leakage detected" % len(leaked_files),
183                 "*** function %s:%s: %s " % item.location,
184                 "See issue #2366",
185             ]
186             item.warn(PytestWarning("\n".join(error)))
187 
188 
189 # used at least by pytest-xdist plugin
190 
191 
192 @fixture
193 def _pytest(request: FixtureRequest) -> "PytestArg":
194     """Return a helper which offers a gethookrecorder(hook) method which
195     returns a HookRecorder instance which helps to make assertions about called
196     hooks."""
197     return PytestArg(request)
198 
199 
200 class PytestArg:
201     def __init__(self, request: FixtureRequest) -> None:
202         self._request = request
203 
204     def gethookrecorder(self, hook) -> "HookRecorder":
205         hookrecorder = HookRecorder(hook._pm)
206         self._request.addfinalizer(hookrecorder.finish_recording)
207         return hookrecorder
208 
209 
210 def get_public_names(values: Iterable[str]) -> List[str]:
211     """Only return names from iterator values without a leading underscore."""
212     return [x for x in values if x[0] != "_"]
213 
214 
215 @final
216 class RecordedHookCall:
217     """A recorded call to a hook.
218 
219     The arguments to the hook call are set as attributes.
220     For example:
221 
222     .. code-block:: python
223 
224         calls = hook_recorder.getcalls("pytest_runtest_setup")
225         # Suppose pytest_runtest_setup was called once with `item=an_item`.
226         assert calls[0].item is an_item
227     """
228 
229     def __init__(self, name: str, kwargs) -> None:
230         self.__dict__.update(kwargs)
231         self._name = name
232 
233     def __repr__(self) -> str:
234         d = self.__dict__.copy()
235         del d["_name"]
236         return f"<RecordedHookCall {self._name!r}(**{d!r})>"
237 
238     if TYPE_CHECKING:
239         # The class has undetermined attributes, this tells mypy about it.
240         def __getattr__(self, key: str):
241             ...
242 
243 
244 @final
245 class HookRecorder:
246     """Record all hooks called in a plugin manager.
247 
248     Hook recorders are created by :class:`Pytester`.
249 
250     This wraps all the hook calls in the plugin manager, recording each call
251     before propagating the normal calls.
252     """
253 
254     def __init__(
255         self, pluginmanager: PytestPluginManager, *, _ispytest: bool = False
256     ) -> None:
257         check_ispytest(_ispytest)
258 
259         self._pluginmanager = pluginmanager
260         self.calls: List[RecordedHookCall] = []
261         self.ret: Optional[Union[int, ExitCode]] = None
262 
263         def before(hook_name: str, hook_impls, kwargs) -> None:
264             self.calls.append(RecordedHookCall(hook_name, kwargs))
265 
266         def after(outcome, hook_name: str, hook_impls, kwargs) -> None:
267             pass
268 
269         self._undo_wrapping = pluginmanager.add_hookcall_monitoring(before, after)
270 
271     def finish_recording(self) -> None:
272         self._undo_wrapping()
273 
274     def getcalls(self, names: Union[str, Iterable[str]]) -> List[RecordedHookCall]:
275         """Get all recorded calls to hooks with the given names (or name)."""
276         if isinstance(names, str):
277             names = names.split()
278         return [call for call in self.calls if call._name in names]
279 
280     def assert_contains(self, entries: Sequence[Tuple[str, str]]) -> None:
281         __tracebackhide__ = True
282         i = 0
283         entries = list(entries)
284         backlocals = sys._getframe(1).f_locals
285         while entries:
286             name, check = entries.pop(0)
287             for ind, call in enumerate(self.calls[i:]):
288                 if call._name == name:
289                     print("NAMEMATCH", name, call)
290                     if eval(check, backlocals, call.__dict__):
291                         print("CHECKERMATCH", repr(check), "->", call)
292                     else:
293                         print("NOCHECKERMATCH", repr(check), "-", call)
294                         continue
295                     i += ind + 1
296                     break
297                 print("NONAMEMATCH", name, "with", call)
298             else:
299                 fail(f"could not find {name!r} check {check!r}")
300 
301     def popcall(self, name: str) -> RecordedHookCall:
302         __tracebackhide__ = True
303         for i, call in enumerate(self.calls):
304             if call._name == name:
305                 del self.calls[i]
306                 return call
307         lines = [f"could not find call {name!r}, in:"]
308         lines.extend(["  %s" % x for x in self.calls])
309         fail("\n".join(lines))
310 
311     def getcall(self, name: str) -> RecordedHookCall:
312         values = self.getcalls(name)
313         assert len(values) == 1, (name, values)
314         return values[0]
315 
316     # functionality for test reports
317 
318     @overload
319     def getreports(
320         self,
321         names: "Literal['pytest_collectreport']",
322     ) -> Sequence[CollectReport]:
323         ...
324 
325     @overload
326     def getreports(
327         self,
328         names: "Literal['pytest_runtest_logreport']",
329     ) -> Sequence[TestReport]:
330         ...
331 
332     @overload
333     def getreports(
334         self,
335         names: Union[str, Iterable[str]] = (
336             "pytest_collectreport",
337             "pytest_runtest_logreport",
338         ),
339     ) -> Sequence[Union[CollectReport, TestReport]]:
340         ...
341 
342     def getreports(
343         self,
344         names: Union[str, Iterable[str]] = (
345             "pytest_collectreport",
346             "pytest_runtest_logreport",
347         ),
348     ) -> Sequence[Union[CollectReport, TestReport]]:
349         return [x.report for x in self.getcalls(names)]
350 
351     def matchreport(
352         self,
353         inamepart: str = "",
354         names: Union[str, Iterable[str]] = (
355             "pytest_runtest_logreport",
356             "pytest_collectreport",
357         ),
358         when: Optional[str] = None,
359     ) -> Union[CollectReport, TestReport]:
360         """Return a testreport whose dotted import path matches."""
361         values = []
362         for rep in self.getreports(names=names):
363             if not when and rep.when != "call" and rep.passed:
364                 # setup/teardown passing reports - let's ignore those
365                 continue
366             if when and rep.when != when:
367                 continue
368             if not inamepart or inamepart in rep.nodeid.split("::"):
369                 values.append(rep)
370         if not values:
371             raise ValueError(
372                 "could not find test report matching %r: "
373                 "no test reports at all!" % (inamepart,)
374             )
375         if len(values) > 1:
376             raise ValueError(
377                 "found 2 or more testreports matching {!r}: {}".format(
378                     inamepart, values
379                 )
380             )
381         return values[0]
382 
383     @overload
384     def getfailures(
385         self,
386         names: "Literal['pytest_collectreport']",
387     ) -> Sequence[CollectReport]:
388         ...
389 
390     @overload
391     def getfailures(
392         self,
393         names: "Literal['pytest_runtest_logreport']",
394     ) -> Sequence[TestReport]:
395         ...
396 
397     @overload
398     def getfailures(
399         self,
400         names: Union[str, Iterable[str]] = (
401             "pytest_collectreport",
402             "pytest_runtest_logreport",
403         ),
404     ) -> Sequence[Union[CollectReport, TestReport]]:
405         ...
406 
407     def getfailures(
408         self,
409         names: Union[str, Iterable[str]] = (
410             "pytest_collectreport",
411             "pytest_runtest_logreport",
412         ),
413     ) -> Sequence[Union[CollectReport, TestReport]]:
414         return [rep for rep in self.getreports(names) if rep.failed]
415 
416     def getfailedcollections(self) -> Sequence[CollectReport]:
417         return self.getfailures("pytest_collectreport")
418 
419     def listoutcomes(
420         self,
421     ) -> Tuple[
422         Sequence[TestReport],
423         Sequence[Union[CollectReport, TestReport]],
424         Sequence[Union[CollectReport, TestReport]],
425     ]:
426         passed = []
427         skipped = []
428         failed = []
429         for rep in self.getreports(
430             ("pytest_collectreport", "pytest_runtest_logreport")
431         ):
432             if rep.passed:
433                 if rep.when == "call":
434                     assert isinstance(rep, TestReport)
435                     passed.append(rep)
436             elif rep.skipped:
437                 skipped.append(rep)
438             else:
439                 assert rep.failed, f"Unexpected outcome: {rep!r}"
440                 failed.append(rep)
441         return passed, skipped, failed
442 
443     def countoutcomes(self) -> List[int]:
444         return [len(x) for x in self.listoutcomes()]
445 
446     def assertoutcome(self, passed: int = 0, skipped: int = 0, failed: int = 0) -> None:
447         __tracebackhide__ = True
448         from _pytest.pytester_assertions import assertoutcome
449 
450         outcomes = self.listoutcomes()
451         assertoutcome(
452             outcomes,
453             passed=passed,
454             skipped=skipped,
455             failed=failed,
456         )
457 
458     def clear(self) -> None:
459         self.calls[:] = []
460 
461 
462 @fixture
463 def linecomp() -> "LineComp":
464     """A :class: `LineComp` instance for checking that an input linearly
465     contains a sequence of strings."""
466     return LineComp()
467 
468 
469 @fixture(name="LineMatcher")
470 def LineMatcher_fixture(request: FixtureRequest) -> Type["LineMatcher"]:
471     """A reference to the :class: `LineMatcher`.
472 
473     This is instantiable with a list of lines (without their trailing newlines).
474     This is useful for testing large texts, such as the output of commands.
475     """
476     return LineMatcher
477 
478 
479 @fixture
480 def pytester(
481     request: FixtureRequest, tmp_path_factory: TempPathFactory, monkeypatch: MonkeyPatch
482 ) -> "Pytester":
483     """
484     Facilities to write tests/configuration files, execute pytest in isolation, and match
485     against expected output, perfect for black-box testing of pytest plugins.
486 
487     It attempts to isolate the test run from external factors as much as possible, modifying
488     the current working directory to ``path`` and environment variables during initialization.
489 
490     It is particularly useful for testing plugins. It is similar to the :fixture:`tmp_path`
491     fixture but provides methods which aid in testing pytest itself.
492     """
493     return Pytester(request, tmp_path_factory, monkeypatch, _ispytest=True)
494 
495 
496 @fixture
497 def _sys_snapshot() -> Generator[None, None, None]:
498     snappaths = SysPathsSnapshot()
499     snapmods = SysModulesSnapshot()
500     yield
501     snapmods.restore()
502     snappaths.restore()
503 
504 
505 @fixture
506 def _config_for_test() -> Generator[Config, None, None]:
507     from _pytest.config import get_config
508 
509     config = get_config()
510     yield config
511     config._ensure_unconfigure()  # cleanup, e.g. capman closing tmpfiles.
512 
513 
514 # Regex to match the session duration string in the summary: "74.34s".
515 rex_session_duration = re.compile(r"\d+\.\d\ds")
516 # Regex to match all the counts and phrases in the summary line: "34 passed, 111 skipped".
517 rex_outcome = re.compile(r"(\d+) (\w+)")
518 
519 
520 @final
521 class RunResult:
522     """The result of running a command from :class:`~pytest.Pytester`."""
523 
524     def __init__(
525         self,
526         ret: Union[int, ExitCode],
527         outlines: List[str],
528         errlines: List[str],
529         duration: float,
530     ) -> None:
531         try:
532             self.ret: Union[int, ExitCode] = ExitCode(ret)
533             """The return value."""
534         except ValueError:
535             self.ret = ret
536         self.outlines = outlines
537         """List of lines captured from stdout."""
538         self.errlines = errlines
539         """List of lines captured from stderr."""
540         self.stdout = LineMatcher(outlines)
541         """:class:`~pytest.LineMatcher` of stdout.
542 
543         Use e.g. :func:`str(stdout) <pytest.LineMatcher.__str__()>` to reconstruct stdout, or the commonly used
544         :func:`stdout.fnmatch_lines() <pytest.LineMatcher.fnmatch_lines()>` method.
545         """
546         self.stderr = LineMatcher(errlines)
547         """:class:`~pytest.LineMatcher` of stderr."""
548         self.duration = duration
549         """Duration in seconds."""
550 
551     def __repr__(self) -> str:
552         return (
553             "<RunResult ret=%s len(stdout.lines)=%d len(stderr.lines)=%d duration=%.2fs>"
554             % (self.ret, len(self.stdout.lines), len(self.stderr.lines), self.duration)
555         )
556 
557     def parseoutcomes(self) -> Dict[str, int]:
558         """Return a dictionary of outcome noun -> count from parsing the terminal
559         output that the test process produced.
560 
561         The returned nouns will always be in plural form::
562 
563             ======= 1 failed, 1 passed, 1 warning, 1 error in 0.13s ====
564 
565         Will return ``{"failed": 1, "passed": 1, "warnings": 1, "errors": 1}``.
566         """
567         return self.parse_summary_nouns(self.outlines)
568 
569     @classmethod
570     def parse_summary_nouns(cls, lines) -> Dict[str, int]:
571         """Extract the nouns from a pytest terminal summary line.
572 
573         It always returns the plural noun for consistency::
574 
575             ======= 1 failed, 1 passed, 1 warning, 1 error in 0.13s ====
576 
577         Will return ``{"failed": 1, "passed": 1, "warnings": 1, "errors": 1}``.
578         """
579         for line in reversed(lines):
580             if rex_session_duration.search(line):
581                 outcomes = rex_outcome.findall(line)
582                 ret = {noun: int(count) for (count, noun) in outcomes}
583                 break
584         else:
585             raise ValueError("Pytest terminal summary report not found")
586 
587         to_plural = {
588             "warning": "warnings",
589             "error": "errors",
590         }
591         return {to_plural.get(k, k): v for k, v in ret.items()}
592 
593     def assert_outcomes(
594         self,
595         passed: int = 0,
596         skipped: int = 0,
597         failed: int = 0,
598         errors: int = 0,
599         xpassed: int = 0,
600         xfailed: int = 0,
601         warnings: Optional[int] = None,
602         deselected: Optional[int] = None,
603     ) -> None:
604         """
605         Assert that the specified outcomes appear with the respective
606         numbers (0 means it didn't occur) in the text output from a test run.
607 
608         ``warnings`` and ``deselected`` are only checked if not None.
609         """
610         __tracebackhide__ = True
611         from _pytest.pytester_assertions import assert_outcomes
612 
613         outcomes = self.parseoutcomes()
614         assert_outcomes(
615             outcomes,
616             passed=passed,
617             skipped=skipped,
618             failed=failed,
619             errors=errors,
620             xpassed=xpassed,
621             xfailed=xfailed,
622             warnings=warnings,
623             deselected=deselected,
624         )
625 
626 
627 class CwdSnapshot:
628     def __init__(self) -> None:
629         self.__saved = os.getcwd()
630 
631     def restore(self) -> None:
632         os.chdir(self.__saved)
633 
634 
635 class SysModulesSnapshot:
636     def __init__(self, preserve: Optional[Callable[[str], bool]] = None) -> None:
637         self.__preserve = preserve
638         self.__saved = dict(sys.modules)
639 
640     def restore(self) -> None:
641         if self.__preserve:
642             self.__saved.update(
643                 (k, m) for k, m in sys.modules.items() if self.__preserve(k)
644             )
645         sys.modules.clear()
646         sys.modules.update(self.__saved)
647 
648 
649 class SysPathsSnapshot:
650     def __init__(self) -> None:
651         self.__saved = list(sys.path), list(sys.meta_path)
652 
653     def restore(self) -> None:
654         sys.path[:], sys.meta_path[:] = self.__saved
655 
656 
657 @final
658 class Pytester:
659     """
660     Facilities to write tests/configuration files, execute pytest in isolation, and match
661     against expected output, perfect for black-box testing of pytest plugins.
662 
663     It attempts to isolate the test run from external factors as much as possible, modifying
664     the current working directory to :attr:`path` and environment variables during initialization.
665     """
666 
667     __test__ = False
668 
669     CLOSE_STDIN: "Final" = NOTSET
670 
671     class TimeoutExpired(Exception):
672         pass
673 
674     def __init__(
675         self,
676         request: FixtureRequest,
677         tmp_path_factory: TempPathFactory,
678         monkeypatch: MonkeyPatch,
679         *,
680         _ispytest: bool = False,
681     ) -> None:
682         check_ispytest(_ispytest)
683         self._request = request
684         self._mod_collections: WeakKeyDictionary[
685             Collector, List[Union[Item, Collector]]
686         ] = WeakKeyDictionary()
687         if request.function:
688             name: str = request.function.__name__
689         else:
690             name = request.node.name
691         self._name = name
692         self._path: Path = tmp_path_factory.mktemp(name, numbered=True)
693         #: A list of plugins to use with :py:meth:`parseconfig` and
694         #: :py:meth:`runpytest`.  Initially this is an empty list but plugins can
695         #: be added to the list.  The type of items to add to the list depends on
696         #: the method using them so refer to them for details.
697         self.plugins: List[Union[str, _PluggyPlugin]] = []
698         self._cwd_snapshot = CwdSnapshot()
699         self._sys_path_snapshot = SysPathsSnapshot()
700         self._sys_modules_snapshot = self.__take_sys_modules_snapshot()
701         self.chdir()
702         self._request.addfinalizer(self._finalize)
703         self._method = self._request.config.getoption("--runpytest")
704         self._test_tmproot = tmp_path_factory.mktemp(f"tmp-{name}", numbered=True)
705 
706         self._monkeypatch = mp = monkeypatch
707         mp.setenv("PYTEST_DEBUG_TEMPROOT", str(self._test_tmproot))
708         # Ensure no unexpected caching via tox.
709         mp.delenv("TOX_ENV_DIR", raising=False)
710         # Discard outer pytest options.
711         mp.delenv("PYTEST_ADDOPTS", raising=False)
712         # Ensure no user config is used.
713         tmphome = str(self.path)
714         mp.setenv("HOME", tmphome)
715         mp.setenv("USERPROFILE", tmphome)
716         # Do not use colors for inner runs by default.
717         mp.setenv("PY_COLORS", "0")
718 
719     @property
720     def path(self) -> Path:
721         """Temporary directory path used to create files/run tests from, etc."""
722         return self._path
723 
724     def __repr__(self) -> str:
725         return f"<Pytester {self.path!r}>"
726 
727     def _finalize(self) -> None:
728         """
729         Clean up global state artifacts.
730 
731         Some methods modify the global interpreter state and this tries to
732         clean this up. It does not remove the temporary directory however so
733         it can be looked at after the test run has finished.
734         """
735         self._sys_modules_snapshot.restore()
736         self._sys_path_snapshot.restore()
737         self._cwd_snapshot.restore()
738 
739     def __take_sys_modules_snapshot(self) -> SysModulesSnapshot:
740         # Some zope modules used by twisted-related tests keep internal state
741         # and can't be deleted; we had some trouble in the past with
742         # `zope.interface` for example.
743         #
744         # Preserve readline due to https://bugs.python.org/issue41033.
745         # pexpect issues a SIGWINCH.
746         def preserve_module(name):
747             return name.startswith(("zope", "readline"))
748 
749         return SysModulesSnapshot(preserve=preserve_module)
750 
751     def make_hook_recorder(self, pluginmanager: PytestPluginManager) -> HookRecorder:
752         """Create a new :class:`HookRecorder` for a :class:`PytestPluginManager`."""
753         pluginmanager.reprec = reprec = HookRecorder(pluginmanager, _ispytest=True)
754         self._request.addfinalizer(reprec.finish_recording)
755         return reprec
756 
757     def chdir(self) -> None:
758         """Cd into the temporary directory.
759 
760         This is done automatically upon instantiation.
761         """
762         os.chdir(self.path)
763 
764     def _makefile(
765         self,
766         ext: str,
767         lines: Sequence[Union[Any, bytes]],
768         files: Dict[str, str],
769         encoding: str = "utf-8",
770     ) -> Path:
771         items = list(files.items())
772 
773         if ext and not ext.startswith("."):
774             raise ValueError(
775                 f"pytester.makefile expects a file extension, try .{ext} instead of {ext}"
776             )
777 
778         def to_text(s: Union[Any, bytes]) -> str:
779             return s.decode(encoding) if isinstance(s, bytes) else str(s)
780 
781         if lines:
782             source = "\n".join(to_text(x) for x in lines)
783             basename = self._name
784             items.insert(0, (basename, source))
785 
786         ret = None
787         for basename, value in items:
788             p = self.path.joinpath(basename).with_suffix(ext)
789             p.parent.mkdir(parents=True, exist_ok=True)
790             source_ = Source(value)
791             source = "\n".join(to_text(line) for line in source_.lines)
792             p.write_text(source.strip(), encoding=encoding)
793             if ret is None:
794                 ret = p
795         assert ret is not None
796         return ret
797 
798     def makefile(self, ext: str, *args: str, **kwargs: str) -> Path:
799         r"""Create new text file(s) in the test directory.
800 
801         :param ext:
802             The extension the file(s) should use, including the dot, e.g. `.py`.
803         :param args:
804             All args are treated as strings and joined using newlines.
805             The result is written as contents to the file.  The name of the
806             file is based on the test function requesting this fixture.
807         :param kwargs:
808             Each keyword is the name of a file, while the value of it will
809             be written as contents of the file.
810         :returns:
811             The first created file.
812 
813         Examples:
814 
815         .. code-block:: python
816 
817             pytester.makefile(".txt", "line1", "line2")
818 
819             pytester.makefile(".ini", pytest="[pytest]\naddopts=-rs\n")
820 
821         To create binary files, use :meth:`pathlib.Path.write_bytes` directly:
822 
823         .. code-block:: python
824 
825             filename = pytester.path.joinpath("foo.bin")
826             filename.write_bytes(b"...")
827         """
828         return self._makefile(ext, args, kwargs)
829 
830     def makeconftest(self, source: str) -> Path:
831         """Write a contest.py file.
832 
833         :param source: The contents.
834         :returns: The conftest.py file.
835         """
836         return self.makepyfile(conftest=source)
837 
838     def makeini(self, source: str) -> Path:
839         """Write a tox.ini file.
840 
841         :param source: The contents.
842         :returns: The tox.ini file.
843         """
844         return self.makefile(".ini", tox=source)
845 
846     def getinicfg(self, source: str) -> SectionWrapper:
847         """Return the pytest section from the tox.ini config file."""
848         p = self.makeini(source)
849         return IniConfig(str(p))["pytest"]
850 
851     def makepyprojecttoml(self, source: str) -> Path:
852         """Write a pyproject.toml file.
853 
854         :param source: The contents.
855         :returns: The pyproject.ini file.
856 
857         .. versionadded:: 6.0
858         """
859         return self.makefile(".toml", pyproject=source)
860 
861     def makepyfile(self, *args, **kwargs) -> Path:
862         r"""Shortcut for .makefile() with a .py extension.
863 
864         Defaults to the test name with a '.py' extension, e.g test_foobar.py, overwriting
865         existing files.
866 
867         Examples:
868 
869         .. code-block:: python
870 
871             def test_something(pytester):
872                 # Initial file is created test_something.py.
873                 pytester.makepyfile("foobar")
874                 # To create multiple files, pass kwargs accordingly.
875                 pytester.makepyfile(custom="foobar")
876                 # At this point, both 'test_something.py' & 'custom.py' exist in the test directory.
877 
878         """
879         return self._makefile(".py", args, kwargs)
880 
881     def maketxtfile(self, *args, **kwargs) -> Path:
882         r"""Shortcut for .makefile() with a .txt extension.
883 
884         Defaults to the test name with a '.txt' extension, e.g test_foobar.txt, overwriting
885         existing files.
886 
887         Examples:
888 
889         .. code-block:: python
890 
891             def test_something(pytester):
892                 # Initial file is created test_something.txt.
893                 pytester.maketxtfile("foobar")
894                 # To create multiple files, pass kwargs accordingly.
895                 pytester.maketxtfile(custom="foobar")
896                 # At this point, both 'test_something.txt' & 'custom.txt' exist in the test directory.
897 
898         """
899         return self._makefile(".txt", args, kwargs)
900 
901     def syspathinsert(
902         self, path: Optional[Union[str, "os.PathLike[str]"]] = None
903     ) -> None:
904         """Prepend a directory to sys.path, defaults to :attr:`path`.
905 
906         This is undone automatically when this object dies at the end of each
907         test.
908 
909         :param path:
910             The path.
911         """
912         if path is None:
913             path = self.path
914 
915         self._monkeypatch.syspath_prepend(str(path))
916 
917     def mkdir(self, name: Union[str, "os.PathLike[str]"]) -> Path:
918         """Create a new (sub)directory.
919 
920         :param name:
921             The name of the directory, relative to the pytester path.
922         :returns:
923             The created directory.
924         """
925         p = self.path / name
926         p.mkdir()
927         return p
928 
929     def mkpydir(self, name: Union[str, "os.PathLike[str]"]) -> Path:
930         """Create a new python package.
931 
932         This creates a (sub)directory with an empty ``__init__.py`` file so it
933         gets recognised as a Python package.
934         """
935         p = self.path / name
936         p.mkdir()
937         p.joinpath("__init__.py").touch()
938         return p
939 
940     def copy_example(self, name: Optional[str] = None) -> Path:
941         """Copy file from project's directory into the testdir.
942 
943         :param name:
944             The name of the file to copy.
945         :return:
946             Path to the copied directory (inside ``self.path``).
947         """
948         example_dir_ = self._request.config.getini("pytester_example_dir")
949         if example_dir_ is None:
950             raise ValueError("pytester_example_dir is unset, can't copy examples")
951         example_dir: Path = self._request.config.rootpath / example_dir_
952 
953         for extra_element in self._request.node.iter_markers("pytester_example_path"):
954             assert extra_element.args
955             example_dir = example_dir.joinpath(*extra_element.args)
956 
957         if name is None:
958             func_name = self._name
959             maybe_dir = example_dir / func_name
960             maybe_file = example_dir / (func_name + ".py")
961 
962             if maybe_dir.is_dir():
963                 example_path = maybe_dir
964             elif maybe_file.is_file():
965                 example_path = maybe_file
966             else:
967                 raise LookupError(
968                     f"{func_name} can't be found as module or package in {example_dir}"
969                 )
970         else:
971             example_path = example_dir.joinpath(name)
972 
973         if example_path.is_dir() and not example_path.joinpath("__init__.py").is_file():
974             copytree(example_path, self.path)
975             return self.path
976         elif example_path.is_file():
977             result = self.path.joinpath(example_path.name)
978             shutil.copy(example_path, result)
979             return result
980         else:
981             raise LookupError(
982                 f'example "{example_path}" is not found as a file or directory'
983             )
984 
985     def getnode(
986         self, config: Config, arg: Union[str, "os.PathLike[str]"]
987     ) -> Union[Collector, Item]:
988         """Get the collection node of a file.
989 
990         :param config:
991            A pytest config.
992            See :py:meth:`parseconfig` and :py:meth:`parseconfigure` for creating it.
993         :param arg:
994             Path to the file.
995         :returns:
996             The node.
997         """
998         session = Session.from_config(config)
999         assert "::" not in str(arg)
1000         p = Path(os.path.abspath(arg))
1001         config.hook.pytest_sessionstart(session=session)
1002         res = session.perform_collect([str(p)], genitems=False)[0]
1003         config.hook.pytest_sessionfinish(session=session, exitstatus=ExitCode.OK)
1004         return res
1005 
1006     def getpathnode(
1007         self, path: Union[str, "os.PathLike[str]"]
1008     ) -> Union[Collector, Item]:
1009         """Return the collection node of a file.
1010 
1011         This is like :py:meth:`getnode` but uses :py:meth:`parseconfigure` to
1012         create the (configured) pytest Config instance.
1013 
1014         :param path:
1015             Path to the file.
1016         :returns:
1017             The node.
1018         """
1019         path = Path(path)
1020         config = self.parseconfigure(path)
1021         session = Session.from_config(config)
1022         x = bestrelpath(session.path, path)
1023         config.hook.pytest_sessionstart(session=session)
1024         res = session.perform_collect([x], genitems=False)[0]
1025         config.hook.pytest_sessionfinish(session=session, exitstatus=ExitCode.OK)
1026         return res
1027 
1028     def genitems(self, colitems: Sequence[Union[Item, Collector]]) -> List[Item]:
1029         """Generate all test items from a collection node.
1030 
1031         This recurses into the collection node and returns a list of all the
1032         test items contained within.
1033 
1034         :param colitems:
1035             The collection nodes.
1036         :returns:
1037             The collected items.
1038         """
1039         session = colitems[0].session
1040         result: List[Item] = []
1041         for colitem in colitems:
1042             result.extend(session.genitems(colitem))
1043         return result
1044 
1045     def runitem(self, source: str) -> Any:
1046         """Run the "test_func" Item.
1047 
1048         The calling test instance (class containing the test method) must
1049         provide a ``.getrunner()`` method which should return a runner which
1050         can run the test protocol for a single item, e.g.
1051         :py:func:`_pytest.runner.runtestprotocol`.
1052         """
1053         # used from runner functional tests
1054         item = self.getitem(source)
1055         # the test class where we are called from wants to provide the runner
1056         testclassinstance = self._request.instance
1057         runner = testclassinstance.getrunner()
1058         return runner(item)
1059 
1060     def inline_runsource(self, source: str, *cmdlineargs) -> HookRecorder:
1061         """Run a test module in process using ``pytest.main()``.
1062 
1063         This run writes "source" into a temporary file and runs
1064         ``pytest.main()`` on it, returning a :py:class:`HookRecorder` instance
1065         for the result.
1066 
1067         :param source: The source code of the test module.
1068         :param cmdlineargs: Any extra command line arguments to use.
1069         """
1070         p = self.makepyfile(source)
1071         values = list(cmdlineargs) + [p]
1072         return self.inline_run(*values)
1073 
1074     def inline_genitems(self, *args) -> Tuple[List[Item], HookRecorder]:
1075         """Run ``pytest.main(['--collectonly'])`` in-process.
1076 
1077         Runs the :py:func:`pytest.main` function to run all of pytest inside
1078         the test process itself like :py:meth:`inline_run`, but returns a
1079         tuple of the collected items and a :py:class:`HookRecorder` instance.
1080         """
1081         rec = self.inline_run("--collect-only", *args)
1082         items = [x.item for x in rec.getcalls("pytest_itemcollected")]
1083         return items, rec
1084 
1085     def inline_run(
1086         self,
1087         *args: Union[str, "os.PathLike[str]"],
1088         plugins=(),
1089         no_reraise_ctrlc: bool = False,
1090     ) -> HookRecorder:
1091         """Run ``pytest.main()`` in-process, returning a HookRecorder.
1092 
1093         Runs the :py:func:`pytest.main` function to run all of pytest inside
1094         the test process itself.  This means it can return a
1095         :py:class:`HookRecorder` instance which gives more detailed results
1096         from that run than can be done by matching stdout/stderr from
1097         :py:meth:`runpytest`.
1098 
1099         :param args:
1100             Command line arguments to pass to :py:func:`pytest.main`.
1101         :param plugins:
1102             Extra plugin instances the ``pytest.main()`` instance should use.
1103         :param no_reraise_ctrlc:
1104             Typically we reraise keyboard interrupts from the child run. If
1105             True, the KeyboardInterrupt exception is captured.
1106         """
1107         # (maybe a cpython bug?) the importlib cache sometimes isn't updated
1108         # properly between file creation and inline_run (especially if imports
1109         # are interspersed with file creation)
1110         importlib.invalidate_caches()
1111 
1112         plugins = list(plugins)
1113         finalizers = []
1114         try:
1115             # Any sys.module or sys.path changes done while running pytest
1116             # inline should be reverted after the test run completes to avoid
1117             # clashing with later inline tests run within the same pytest test,
1118             # e.g. just because they use matching test module names.
1119             finalizers.append(self.__take_sys_modules_snapshot().restore)
1120             finalizers.append(SysPathsSnapshot().restore)
1121 
1122             # Important note:
1123             # - our tests should not leave any other references/registrations
1124             #   laying around other than possibly loaded test modules
1125             #   referenced from sys.modules, as nothing will clean those up
1126             #   automatically
1127 
1128             rec = []
1129 
1130             class Collect:
1131                 def pytest_configure(x, config: Config) -> None:
1132                     rec.append(self.make_hook_recorder(config.pluginmanager))
1133 
1134             plugins.append(Collect())
1135             ret = main([str(x) for x in args], plugins=plugins)
1136             if len(rec) == 1:
1137                 reprec = rec.pop()
1138             else:
1139 
1140                 class reprec:  # type: ignore
1141                     pass
1142 
1143             reprec.ret = ret
1144 
1145             # Typically we reraise keyboard interrupts from the child run
1146             # because it's our user requesting interruption of the testing.
1147             if ret == ExitCode.INTERRUPTED and not no_reraise_ctrlc:
1148                 calls = reprec.getcalls("pytest_keyboard_interrupt")
1149                 if calls and calls[-1].excinfo.type == KeyboardInterrupt:
1150                     raise KeyboardInterrupt()
1151             return reprec
1152         finally:
1153             for finalizer in finalizers:
1154                 finalizer()
1155 
1156     def runpytest_inprocess(
1157         self, *args: Union[str, "os.PathLike[str]"], **kwargs: Any
1158     ) -> RunResult:
1159         """Return result of running pytest in-process, providing a similar
1160         interface to what self.runpytest() provides."""
1161         syspathinsert = kwargs.pop("syspathinsert", False)
1162 
1163         if syspathinsert:
1164             self.syspathinsert()
1165         now = timing.time()
1166         capture = _get_multicapture("sys")
1167         capture.start_capturing()
1168         try:
1169             try:
1170                 reprec = self.inline_run(*args, **kwargs)
1171             except SystemExit as e:
1172                 ret = e.args[0]
1173                 try:
1174                     ret = ExitCode(e.args[0])
1175                 except ValueError:
1176                     pass
1177 
1178                 class reprec:  # type: ignore
1179                     ret = ret
1180 
1181             except Exception:
1182                 traceback.print_exc()
1183 
1184                 class reprec:  # type: ignore
1185                     ret = ExitCode(3)
1186 
1187         finally:
1188             out, err = capture.readouterr()
1189             capture.stop_capturing()
1190             sys.stdout.write(out)
1191             sys.stderr.write(err)
1192 
1193         assert reprec.ret is not None
1194         res = RunResult(
1195             reprec.ret, out.splitlines(), err.splitlines(), timing.time() - now
1196         )
1197         res.reprec = reprec  # type: ignore
1198         return res
1199 
1200     def runpytest(
1201         self, *args: Union[str, "os.PathLike[str]"], **kwargs: Any
1202     ) -> RunResult:
1203         """Run pytest inline or in a subprocess, depending on the command line
1204         option "--runpytest" and return a :py:class:`~pytest.RunResult`."""
1205         new_args = self._ensure_basetemp(args)
1206         if self._method == "inprocess":
1207             return self.runpytest_inprocess(*new_args, **kwargs)
1208         elif self._method == "subprocess":
1209             return self.runpytest_subprocess(*new_args, **kwargs)
1210         raise RuntimeError(f"Unrecognized runpytest option: {self._method}")
1211 
1212     def _ensure_basetemp(
1213         self, args: Sequence[Union[str, "os.PathLike[str]"]]
1214     ) -> List[Union[str, "os.PathLike[str]"]]:
1215         new_args = list(args)
1216         for x in new_args:
1217             if str(x).startswith("--basetemp"):
1218                 break
1219         else:
1220             new_args.append("--basetemp=%s" % self.path.parent.joinpath("basetemp"))
1221         return new_args
1222 
1223     def parseconfig(self, *args: Union[str, "os.PathLike[str]"]) -> Config:
1224         """Return a new pytest :class:`pytest.Config` instance from given
1225         commandline args.
1226 
1227         This invokes the pytest bootstrapping code in _pytest.config to create a
1228         new :py:class:`pytest.PytestPluginManager` and call the
1229         :hook:`pytest_cmdline_parse` hook to create a new :class:`pytest.Config`
1230         instance.
1231 
1232         If :attr:`plugins` has been populated they should be plugin modules
1233         to be registered with the plugin manager.
1234         """
1235         import _pytest.config
1236 
1237         new_args = self._ensure_basetemp(args)
1238         new_args = [str(x) for x in new_args]
1239 
1240         config = _pytest.config._prepareconfig(new_args, self.plugins)  # type: ignore[arg-type]
1241         # we don't know what the test will do with this half-setup config
1242         # object and thus we make sure it gets unconfigured properly in any
1243         # case (otherwise capturing could still be active, for example)
1244         self._request.addfinalizer(config._ensure_unconfigure)
1245         return config
1246 
1247     def parseconfigure(self, *args: Union[str, "os.PathLike[str]"]) -> Config:
1248         """Return a new pytest configured Config instance.
1249 
1250         Returns a new :py:class:`pytest.Config` instance like
1251         :py:meth:`parseconfig`, but also calls the :hook:`pytest_configure`
1252         hook.
1253         """
1254         config = self.parseconfig(*args)
1255         config._do_configure()
1256         return config
1257 
1258     def getitem(
1259         self, source: Union[str, "os.PathLike[str]"], funcname: str = "test_func"
1260     ) -> Item:
1261         """Return the test item for a test function.
1262 
1263         Writes the source to a python file and runs pytest's collection on
1264         the resulting module, returning the test item for the requested
1265         function name.
1266 
1267         :param source:
1268             The module source.
1269         :param funcname:
1270             The name of the test function for which to return a test item.
1271         :returns:
1272             The test item.
1273         """
1274         items = self.getitems(source)
1275         for item in items:
1276             if item.name == funcname:
1277                 return item
1278         assert 0, "{!r} item not found in module:\n{}\nitems: {}".format(
1279             funcname, source, items
1280         )
1281 
1282     def getitems(self, source: Union[str, "os.PathLike[str]"]) -> List[Item]:
1283         """Return all test items collected from the module.
1284 
1285         Writes the source to a Python file and runs pytest's collection on
1286         the resulting module, returning all test items contained within.
1287         """
1288         modcol = self.getmodulecol(source)
1289         return self.genitems([modcol])
1290 
1291     def getmodulecol(
1292         self,
1293         source: Union[str, "os.PathLike[str]"],
1294         configargs=(),
1295         *,
1296         withinit: bool = False,
1297     ):
1298         """Return the module collection node for ``source``.
1299 
1300         Writes ``source`` to a file using :py:meth:`makepyfile` and then
1301         runs the pytest collection on it, returning the collection node for the
1302         test module.
1303 
1304         :param source:
1305             The source code of the module to collect.
1306 
1307         :param configargs:
1308             Any extra arguments to pass to :py:meth:`parseconfigure`.
1309 
1310         :param withinit:
1311             Whether to also write an ``__init__.py`` file to the same
1312             directory to ensure it is a package.
1313         """
1314         if isinstance(source, os.PathLike):
1315             path = self.path.joinpath(source)
1316             assert not withinit, "not supported for paths"
1317         else:
1318             kw = {self._name: str(source)}
1319             path = self.makepyfile(**kw)
1320         if withinit:
1321             self.makepyfile(__init__="#")
1322         self.config = config = self.parseconfigure(path, *configargs)
1323         return self.getnode(config, path)
1324 
1325     def collect_by_name(
1326         self, modcol: Collector, name: str
1327     ) -> Optional[Union[Item, Collector]]:
1328         """Return the collection node for name from the module collection.
1329 
1330         Searches a module collection node for a collection node matching the
1331         given name.
1332 
1333         :param modcol: A module collection node; see :py:meth:`getmodulecol`.
1334         :param name: The name of the node to return.
1335         """
1336         if modcol not in self._mod_collections:
1337             self._mod_collections[modcol] = list(modcol.collect())
1338         for colitem in self._mod_collections[modcol]:
1339             if colitem.name == name:
1340                 return colitem
1341         return None
1342 
1343     def popen(
1344         self,
1345         cmdargs: Sequence[Union[str, "os.PathLike[str]"]],
1346         stdout: Union[int, TextIO] = subprocess.PIPE,
1347         stderr: Union[int, TextIO] = subprocess.PIPE,
1348         stdin: Union[NotSetType, bytes, IO[Any], int] = CLOSE_STDIN,
1349         **kw,
1350     ):
1351         """Invoke :py:class:`subprocess.Popen`.
1352 
1353         Calls :py:class:`subprocess.Popen` making sure the current working
1354         directory is in ``PYTHONPATH``.
1355 
1356         You probably want to use :py:meth:`run` instead.
1357         """
1358         env = os.environ.copy()
1359         env["PYTHONPATH"] = os.pathsep.join(
1360             filter(None, [os.getcwd(), env.get("PYTHONPATH", "")])
1361         )
1362         kw["env"] = env
1363 
1364         if stdin is self.CLOSE_STDIN:
1365             kw["stdin"] = subprocess.PIPE
1366         elif isinstance(stdin, bytes):
1367             kw["stdin"] = subprocess.PIPE
1368         else:
1369             kw["stdin"] = stdin
1370 
1371         popen = subprocess.Popen(cmdargs, stdout=stdout, stderr=stderr, **kw)
1372         if stdin is self.CLOSE_STDIN:
1373             assert popen.stdin is not None
1374             popen.stdin.close()
1375         elif isinstance(stdin, bytes):
1376             assert popen.stdin is not None
1377             popen.stdin.write(stdin)
1378 
1379         return popen
1380 
1381     def run(
1382         self,
1383         *cmdargs: Union[str, "os.PathLike[str]"],
1384         timeout: Optional[float] = None,
1385         stdin: Union[NotSetType, bytes, IO[Any], int] = CLOSE_STDIN,
1386     ) -> RunResult:
1387         """Run a command with arguments.
1388 
1389         Run a process using :py:class:`subprocess.Popen` saving the stdout and
1390         stderr.
1391 
1392         :param cmdargs:
1393             The sequence of arguments to pass to :py:class:`subprocess.Popen`,
1394             with path-like objects being converted to :py:class:`str`
1395             automatically.
1396         :param timeout:
1397             The period in seconds after which to timeout and raise
1398             :py:class:`Pytester.TimeoutExpired`.
1399         :param stdin:
1400             Optional standard input.
1401 
1402             - If it is :py:attr:`CLOSE_STDIN` (Default), then this method calls
1403               :py:class:`subprocess.Popen` with ``stdin=subprocess.PIPE``, and
1404               the standard input is closed immediately after the new command is
1405               started.
1406 
1407             - If it is of type :py:class:`bytes`, these bytes are sent to the
1408               standard input of the command.
1409 
1410             - Otherwise, it is passed through to :py:class:`subprocess.Popen`.
1411               For further information in this case, consult the document of the
1412               ``stdin`` parameter in :py:class:`subprocess.Popen`.
1413         :returns:
1414             The result.
1415         """
1416         __tracebackhide__ = True
1417 
1418         cmdargs = tuple(os.fspath(arg) for arg in cmdargs)
1419         p1 = self.path.joinpath("stdout")
1420         p2 = self.path.joinpath("stderr")
1421         print("running:", *cmdargs)
1422         print("     in:", Path.cwd())
1423 
1424         with p1.open("w", encoding="utf8") as f1, p2.open("w", encoding="utf8") as f2:
1425             now = timing.time()
1426             popen = self.popen(
1427                 cmdargs,
1428                 stdin=stdin,
1429                 stdout=f1,
1430                 stderr=f2,
1431                 close_fds=(sys.platform != "win32"),
1432             )
1433             if popen.stdin is not None:
1434                 popen.stdin.close()
1435 
1436             def handle_timeout() -> None:
1437                 __tracebackhide__ = True
1438 
1439                 timeout_message = (
1440                     "{seconds} second timeout expired running:"
1441                     " {command}".format(seconds=timeout, command=cmdargs)
1442                 )
1443 
1444                 popen.kill()
1445                 popen.wait()
1446                 raise self.TimeoutExpired(timeout_message)
1447 
1448             if timeout is None:
1449                 ret = popen.wait()
1450             else:
1451                 try:
1452                     ret = popen.wait(timeout)
1453                 except subprocess.TimeoutExpired:
1454                     handle_timeout()
1455 
1456         with p1.open(encoding="utf8") as f1, p2.open(encoding="utf8") as f2:
1457             out = f1.read().splitlines()
1458             err = f2.read().splitlines()
1459 
1460         self._dump_lines(out, sys.stdout)
1461         self._dump_lines(err, sys.stderr)
1462 
1463         with contextlib.suppress(ValueError):
1464             ret = ExitCode(ret)
1465         return RunResult(ret, out, err, timing.time() - now)
1466 
1467     def _dump_lines(self, lines, fp):
1468         try:
1469             for line in lines:
1470                 print(line, file=fp)
1471         except UnicodeEncodeError:
1472             print(f"couldn't print to {fp} because of encoding")
1473 
1474     def _getpytestargs(self) -> Tuple[str, ...]:
1475         return sys.executable, "-mpytest"
1476 
1477     def runpython(self, script: "os.PathLike[str]") -> RunResult:
1478         """Run a python script using sys.executable as interpreter."""
1479         return self.run(sys.executable, script)
1480 
1481     def runpython_c(self, command: str) -> RunResult:
1482         """Run ``python -c "command"``."""
1483         return self.run(sys.executable, "-c", command)
1484 
1485     def runpytest_subprocess(
1486         self, *args: Union[str, "os.PathLike[str]"], timeout: Optional[float] = None
1487     ) -> RunResult:
1488         """Run pytest as a subprocess with given arguments.
1489 
1490         Any plugins added to the :py:attr:`plugins` list will be added using the
1491         ``-p`` command line option.  Additionally ``--basetemp`` is used to put
1492         any temporary files and directories in a numbered directory prefixed
1493         with "runpytest-" to not conflict with the normal numbered pytest
1494         location for temporary files and directories.
1495 
1496         :param args:
1497             The sequence of arguments to pass to the pytest subprocess.
1498         :param timeout:
1499             The period in seconds after which to timeout and raise
1500             :py:class:`Pytester.TimeoutExpired`.
1501         :returns:
1502             The result.
1503         """
1504         __tracebackhide__ = True
1505         p = make_numbered_dir(root=self.path, prefix="runpytest-", mode=0o700)
1506         args = ("--basetemp=%s" % p,) + args
1507         plugins = [x for x in self.plugins if isinstance(x, str)]
1508         if plugins:
1509             args = ("-p", plugins[0]) + args
1510         args = self._getpytestargs() + args
1511         return self.run(*args, timeout=timeout)
1512 
1513     def spawn_pytest(
1514         self, string: str, expect_timeout: float = 10.0
1515     ) -> "pexpect.spawn":
1516         """Run pytest using pexpect.
1517 
1518         This makes sure to use the right pytest and sets up the temporary
1519         directory locations.
1520 
1521         The pexpect child is returned.
1522         """
1523         basetemp = self.path / "temp-pexpect"
1524         basetemp.mkdir(mode=0o700)
1525         invoke = " ".join(map(str, self._getpytestargs()))
1526         cmd = f"{invoke} --basetemp={basetemp} {string}"
1527         return self.spawn(cmd, expect_timeout=expect_timeout)
1528 
1529     def spawn(self, cmd: str, expect_timeout: float = 10.0) -> "pexpect.spawn":
1530         """Run a command using pexpect.
1531 
1532         The pexpect child is returned.
1533         """
1534         pexpect = importorskip("pexpect", "3.0")
1535         if hasattr(sys, "pypy_version_info") and "64" in platform.machine():
1536             skip("pypy-64 bit not supported")
1537         if not hasattr(pexpect, "spawn"):
1538             skip("pexpect.spawn not available")
1539         logfile = self.path.joinpath("spawn.out").open("wb")
1540 
1541         child = pexpect.spawn(cmd, logfile=logfile, timeout=expect_timeout)
1542         self._request.addfinalizer(logfile.close)
1543         return child
1544 
1545 
1546 class LineComp:
1547     def __init__(self) -> None:
1548         self.stringio = StringIO()
1549         """:class:`python:io.StringIO()` instance used for input."""
1550 
1551     def assert_contains_lines(self, lines2: Sequence[str]) -> None:
1552         """Assert that ``lines2`` are contained (linearly) in :attr:`stringio`'s value.
1553 
1554         Lines are matched using :func:`LineMatcher.fnmatch_lines <pytest.LineMatcher.fnmatch_lines>`.
1555         """
1556         __tracebackhide__ = True
1557         val = self.stringio.getvalue()
1558         self.stringio.truncate(0)
1559         self.stringio.seek(0)
1560         lines1 = val.split("\n")
1561         LineMatcher(lines1).fnmatch_lines(lines2)
1562 
1563 
1564 class LineMatcher:
1565     """Flexible matching of text.
1566 
1567     This is a convenience class to test large texts like the output of
1568     commands.
1569 
1570     The constructor takes a list of lines without their trailing newlines, i.e.
1571     ``text.splitlines()``.
1572     """
1573 
1574     def __init__(self, lines: List[str]) -> None:
1575         self.lines = lines
1576         self._log_output: List[str] = []
1577 
1578     def __str__(self) -> str:
1579         """Return the entire original text.
1580 
1581         .. versionadded:: 6.2
1582             You can use :meth:`str` in older versions.
1583         """
1584         return "\n".join(self.lines)
1585 
1586     def _getlines(self, lines2: Union[str, Sequence[str], Source]) -> Sequence[str]:
1587         if isinstance(lines2, str):
1588             lines2 = Source(lines2)
1589         if isinstance(lines2, Source):
1590             lines2 = lines2.strip().lines
1591         return lines2
1592 
1593     def fnmatch_lines_random(self, lines2: Sequence[str]) -> None:
1594         """Check lines exist in the output in any order (using :func:`python:fnmatch.fnmatch`)."""
1595         __tracebackhide__ = True
1596         self._match_lines_random(lines2, fnmatch)
1597 
1598     def re_match_lines_random(self, lines2: Sequence[str]) -> None:
1599         """Check lines exist in the output in any order (using :func:`python:re.match`)."""
1600         __tracebackhide__ = True
1601         self._match_lines_random(lines2, lambda name, pat: bool(re.match(pat, name)))
1602 
1603     def _match_lines_random(
1604         self, lines2: Sequence[str], match_func: Callable[[str, str], bool]
1605     ) -> None:
1606         __tracebackhide__ = True
1607         lines2 = self._getlines(lines2)
1608         for line in lines2:
1609             for x in self.lines:
1610                 if line == x or match_func(x, line):
1611                     self._log("matched: ", repr(line))
1612                     break
1613             else:
1614                 msg = "line %r not found in output" % line
1615                 self._log(msg)
1616                 self._fail(msg)
1617 
1618     def get_lines_after(self, fnline: str) -> Sequence[str]:
1619         """Return all lines following the given line in the text.
1620 
1621         The given line can contain glob wildcards.
1622         """
1623         for i, line in enumerate(self.lines):
1624             if fnline == line or fnmatch(line, fnline):
1625                 return self.lines[i + 1 :]
1626         raise ValueError("line %r not found in output" % fnline)
1627 
1628     def _log(self, *args) -> None:
1629         self._log_output.append(" ".join(str(x) for x in args))
1630 
1631     @property
1632     def _log_text(self) -> str:
1633         return "\n".join(self._log_output)
1634 
1635     def fnmatch_lines(
1636         self, lines2: Sequence[str], *, consecutive: bool = False
1637     ) -> None:
1638         """Check lines exist in the output (using :func:`python:fnmatch.fnmatch`).
1639 
1640         The argument is a list of lines which have to match and can use glob
1641         wildcards.  If they do not match a pytest.fail() is called.  The
1642         matches and non-matches are also shown as part of the error message.
1643 
1644         :param lines2: String patterns to match.
1645         :param consecutive: Match lines consecutively?
1646         """
1647         __tracebackhide__ = True
1648         self._match_lines(lines2, fnmatch, "fnmatch", consecutive=consecutive)
1649 
1650     def re_match_lines(
1651         self, lines2: Sequence[str], *, consecutive: bool = False
1652     ) -> None:
1653         """Check lines exist in the output (using :func:`python:re.match`).
1654 
1655         The argument is a list of lines which have to match using ``re.match``.
1656         If they do not match a pytest.fail() is called.
1657 
1658         The matches and non-matches are also shown as part of the error message.
1659 
1660         :param lines2: string patterns to match.
1661         :param consecutive: match lines consecutively?
1662         """
1663         __tracebackhide__ = True
1664         self._match_lines(
1665             lines2,
1666             lambda name, pat: bool(re.match(pat, name)),
1667             "re.match",
1668             consecutive=consecutive,
1669         )
1670 
1671     def _match_lines(
1672         self,
1673         lines2: Sequence[str],
1674         match_func: Callable[[str, str], bool],
1675         match_nickname: str,
1676         *,
1677         consecutive: bool = False,
1678     ) -> None:
1679         """Underlying implementation of ``fnmatch_lines`` and ``re_match_lines``.
1680 
1681         :param Sequence[str] lines2:
1682             List of string patterns to match. The actual format depends on
1683             ``match_func``.
1684         :param match_func:
1685             A callable ``match_func(line, pattern)`` where line is the
1686             captured line from stdout/stderr and pattern is the matching
1687             pattern.
1688         :param str match_nickname:
1689             The nickname for the match function that will be logged to stdout
1690             when a match occurs.
1691         :param consecutive:
1692             Match lines consecutively?
1693         """
1694         if not isinstance(lines2, collections.abc.Sequence):
1695             raise TypeError(f"invalid type for lines2: {type(lines2).__name__}")
1696         lines2 = self._getlines(lines2)
1697         lines1 = self.lines[:]
1698         extralines = []
1699         __tracebackhide__ = True
1700         wnick = len(match_nickname) + 1
1701         started = False
1702         for line in lines2:
1703             nomatchprinted = False
1704             while lines1:
1705                 nextline = lines1.pop(0)
1706                 if line == nextline:
1707                     self._log("exact match:", repr(line))
1708                     started = True
1709                     break
1710                 elif match_func(nextline, line):
1711                     self._log("%s:" % match_nickname, repr(line))
1712                     self._log(
1713                         "{:>{width}}".format("with:", width=wnick), repr(nextline)
1714                     )
1715                     started = True
1716                     break
1717                 else:
1718                     if consecutive and started:
1719                         msg = f"no consecutive match: {line!r}"
1720                         self._log(msg)
1721                         self._log(
1722                             "{:>{width}}".format("with:", width=wnick), repr(nextline)
1723                         )
1724                         self._fail(msg)
1725                     if not nomatchprinted:
1726                         self._log(
1727                             "{:>{width}}".format("nomatch:", width=wnick), repr(line)
1728                         )
1729                         nomatchprinted = True
1730                     self._log("{:>{width}}".format("and:", width=wnick), repr(nextline))
1731                 extralines.append(nextline)
1732             else:
1733                 msg = f"remains unmatched: {line!r}"
1734                 self._log(msg)
1735                 self._fail(msg)
1736         self._log_output = []
1737 
1738     def no_fnmatch_line(self, pat: str) -> None:
1739         """Ensure captured lines do not match the given pattern, using ``fnmatch.fnmatch``.
1740 
1741         :param str pat: The pattern to match lines.
1742         """
1743         __tracebackhide__ = True
1744         self._no_match_line(pat, fnmatch, "fnmatch")
1745 
1746     def no_re_match_line(self, pat: str) -> None:
1747         """Ensure captured lines do not match the given pattern, using ``re.match``.
1748 
1749         :param str pat: The regular expression to match lines.
1750         """
1751         __tracebackhide__ = True
1752         self._no_match_line(
1753             pat, lambda name, pat: bool(re.match(pat, name)), "re.match"
1754         )
1755 
1756     def _no_match_line(
1757         self, pat: str, match_func: Callable[[str, str], bool], match_nickname: str
1758     ) -> None:
1759         """Ensure captured lines does not have a the given pattern, using ``fnmatch.fnmatch``.
1760 
1761         :param str pat: The pattern to match lines.
1762         """
1763         __tracebackhide__ = True
1764         nomatch_printed = False
1765         wnick = len(match_nickname) + 1
1766         for line in self.lines:
1767             if match_func(line, pat):
1768                 msg = f"{match_nickname}: {pat!r}"
1769                 self._log(msg)
1770                 self._log("{:>{width}}".format("with:", width=wnick), repr(line))
1771                 self._fail(msg)
1772             else:
1773                 if not nomatch_printed:
1774                     self._log("{:>{width}}".format("nomatch:", width=wnick), repr(pat))
1775                     nomatch_printed = True
1776                 self._log("{:>{width}}".format("and:", width=wnick), repr(line))
1777         self._log_output = []
1778 
1779     def _fail(self, msg: str) -> None:
1780         __tracebackhide__ = True
1781         log_text = self._log_text
1782         self._log_output = []
1783         fail(log_text)
1784 
1785     def str(self) -> str:
1786         """Return the entire original text."""
1787         return str(self)

</code><intended_behavior>When using `importlib` for dynamic imports, the application should implement checks or strategies to avoid importing the same module under different names or paths, which could lead to the observed issue of having two different versions of `pmxbot.logging`. This might include enhancing the logic around module importation to reference or augment Python's import machinery, ensuring that `sys.modules` is appropriately managed to unify module instances.</intended_behavior>, <file>src/_pytest/pathlib.py</file>
<class>None</class>
<method>None</method>
<code>
1 import atexit
2 import contextlib
3 import fnmatch
4 import importlib.util
5 import itertools
6 import os
7 import shutil
8 import sys
9 import types
10 import uuid
11 import warnings
12 from enum import Enum
13 from errno import EBADF
14 from errno import ELOOP
15 from errno import ENOENT
16 from errno import ENOTDIR
17 from functools import partial
18 from os.path import expanduser
19 from os.path import expandvars
20 from os.path import isabs
21 from os.path import sep
22 from pathlib import Path
23 from pathlib import PurePath
24 from posixpath import sep as posix_sep
25 from types import ModuleType
26 from typing import Callable
27 from typing import Dict
28 from typing import Iterable
29 from typing import Iterator
30 from typing import List
31 from typing import Optional
32 from typing import Set
33 from typing import Tuple
34 from typing import Type
35 from typing import TypeVar
36 from typing import Union
37 
38 from _pytest.compat import assert_never
39 from _pytest.outcomes import skip
40 from _pytest.warning_types import PytestWarning
41 
42 LOCK_TIMEOUT = 60 * 60 * 24 * 3
43 
44 
45 _AnyPurePath = TypeVar("_AnyPurePath", bound=PurePath)
46 
47 # The following function, variables and comments were
48 # copied from cpython 3.9 Lib/pathlib.py file.
49 
50 # EBADF - guard against macOS `stat` throwing EBADF
51 _IGNORED_ERRORS = (ENOENT, ENOTDIR, EBADF, ELOOP)
52 
53 _IGNORED_WINERRORS = (
54     21,  # ERROR_NOT_READY - drive exists but is not accessible
55     1921,  # ERROR_CANT_RESOLVE_FILENAME - fix for broken symlink pointing to itself
56 )
57 
58 
59 def _ignore_error(exception):
60     return (
61         getattr(exception, "errno", None) in _IGNORED_ERRORS
62         or getattr(exception, "winerror", None) in _IGNORED_WINERRORS
63     )
64 
65 
66 def get_lock_path(path: _AnyPurePath) -> _AnyPurePath:
67     return path.joinpath(".lock")
68 
69 
70 def on_rm_rf_error(
71     func,
72     path: str,
73     excinfo: Union[
74         BaseException,
75         Tuple[Type[BaseException], BaseException, Optional[types.TracebackType]],
76     ],
77     *,
78     start_path: Path,
79 ) -> bool:
80     """Handle known read-only errors during rmtree.
81 
82     The returned value is used only by our own tests.
83     """
84     if isinstance(excinfo, BaseException):
85         exc = excinfo
86     else:
87         exc = excinfo[1]
88 
89     # Another process removed the file in the middle of the "rm_rf" (xdist for example).
90     # More context: https://github.com/pytest-dev/pytest/issues/5974#issuecomment-543799018
91     if isinstance(exc, FileNotFoundError):
92         return False
93 
94     if not isinstance(exc, PermissionError):
95         warnings.warn(
96             PytestWarning(f"(rm_rf) error removing {path}\n{type(exc)}: {exc}")
97         )
98         return False
99 
100     if func not in (os.rmdir, os.remove, os.unlink):
101         if func not in (os.open,):
102             warnings.warn(
103                 PytestWarning(
104                     "(rm_rf) unknown function {} when removing {}:\n{}: {}".format(
105                         func, path, type(exc), exc
106                     )
107                 )
108             )
109         return False
110 
111     # Chmod + retry.
112     import stat
113 
114     def chmod_rw(p: str) -> None:
115         mode = os.stat(p).st_mode
116         os.chmod(p, mode | stat.S_IRUSR | stat.S_IWUSR)
117 
118     # For files, we need to recursively go upwards in the directories to
119     # ensure they all are also writable.
120     p = Path(path)
121     if p.is_file():
122         for parent in p.parents:
123             chmod_rw(str(parent))
124             # Stop when we reach the original path passed to rm_rf.
125             if parent == start_path:
126                 break
127     chmod_rw(str(path))
128 
129     func(path)
130     return True
131 
132 
133 def ensure_extended_length_path(path: Path) -> Path:
134     """Get the extended-length version of a path (Windows).
135 
136     On Windows, by default, the maximum length of a path (MAX_PATH) is 260
137     characters, and operations on paths longer than that fail. But it is possible
138     to overcome this by converting the path to "extended-length" form before
139     performing the operation:
140     https://docs.microsoft.com/en-us/windows/win32/fileio/naming-a-file#maximum-path-length-limitation
141 
142     On Windows, this function returns the extended-length absolute version of path.
143     On other platforms it returns path unchanged.
144     """
145     if sys.platform.startswith("win32"):
146         path = path.resolve()
147         path = Path(get_extended_length_path_str(str(path)))
148     return path
149 
150 
151 def get_extended_length_path_str(path: str) -> str:
152     """Convert a path to a Windows extended length path."""
153     long_path_prefix = "\\\\?\\"
154     unc_long_path_prefix = "\\\\?\\UNC\\"
155     if path.startswith((long_path_prefix, unc_long_path_prefix)):
156         return path
157     # UNC
158     if path.startswith("\\\\"):
159         return unc_long_path_prefix + path[2:]
160     return long_path_prefix + path
161 
162 
163 def rm_rf(path: Path) -> None:
164     """Remove the path contents recursively, even if some elements
165     are read-only."""
166     path = ensure_extended_length_path(path)
167     onerror = partial(on_rm_rf_error, start_path=path)
168     if sys.version_info >= (3, 12):
169         shutil.rmtree(str(path), onexc=onerror)
170     else:
171         shutil.rmtree(str(path), onerror=onerror)
172 
173 
174 def find_prefixed(root: Path, prefix: str) -> Iterator[Path]:
175     """Find all elements in root that begin with the prefix, case insensitive."""
176     l_prefix = prefix.lower()
177     for x in root.iterdir():
178         if x.name.lower().startswith(l_prefix):
179             yield x
180 
181 
182 def extract_suffixes(iter: Iterable[PurePath], prefix: str) -> Iterator[str]:
183     """Return the parts of the paths following the prefix.
184 
185     :param iter: Iterator over path names.
186     :param prefix: Expected prefix of the path names.
187     """
188     p_len = len(prefix)
189     for p in iter:
190         yield p.name[p_len:]
191 
192 
193 def find_suffixes(root: Path, prefix: str) -> Iterator[str]:
194     """Combine find_prefixes and extract_suffixes."""
195     return extract_suffixes(find_prefixed(root, prefix), prefix)
196 
197 
198 def parse_num(maybe_num) -> int:
199     """Parse number path suffixes, returns -1 on error."""
200     try:
201         return int(maybe_num)
202     except ValueError:
203         return -1
204 
205 
206 def _force_symlink(
207     root: Path, target: Union[str, PurePath], link_to: Union[str, Path]
208 ) -> None:
209     """Helper to create the current symlink.
210 
211     It's full of race conditions that are reasonably OK to ignore
212     for the context of best effort linking to the latest test run.
213 
214     The presumption being that in case of much parallelism
215     the inaccuracy is going to be acceptable.
216     """
217     current_symlink = root.joinpath(target)
218     try:
219         current_symlink.unlink()
220     except OSError:
221         pass
222     try:
223         current_symlink.symlink_to(link_to)
224     except Exception:
225         pass
226 
227 
228 def make_numbered_dir(root: Path, prefix: str, mode: int = 0o700) -> Path:
229     """Create a directory with an increased number as suffix for the given prefix."""
230     for i in range(10):
231         # try up to 10 times to create the folder
232         max_existing = max(map(parse_num, find_suffixes(root, prefix)), default=-1)
233         new_number = max_existing + 1
234         new_path = root.joinpath(f"{prefix}{new_number}")
235         try:
236             new_path.mkdir(mode=mode)
237         except Exception:
238             pass
239         else:
240             _force_symlink(root, prefix + "current", new_path)
241             return new_path
242     else:
243         raise OSError(
244             "could not create numbered dir with prefix "
245             "{prefix} in {root} after 10 tries".format(prefix=prefix, root=root)
246         )
247 
248 
249 def create_cleanup_lock(p: Path) -> Path:
250     """Create a lock to prevent premature folder cleanup."""
251     lock_path = get_lock_path(p)
252     try:
253         fd = os.open(str(lock_path), os.O_WRONLY | os.O_CREAT | os.O_EXCL, 0o644)
254     except FileExistsError as e:
255         raise OSError(f"cannot create lockfile in {p}") from e
256     else:
257         pid = os.getpid()
258         spid = str(pid).encode()
259         os.write(fd, spid)
260         os.close(fd)
261         if not lock_path.is_file():
262             raise OSError("lock path got renamed after successful creation")
263         return lock_path
264 
265 
266 def register_cleanup_lock_removal(lock_path: Path, register=atexit.register):
267     """Register a cleanup function for removing a lock, by default on atexit."""
268     pid = os.getpid()
269 
270     def cleanup_on_exit(lock_path: Path = lock_path, original_pid: int = pid) -> None:
271         current_pid = os.getpid()
272         if current_pid != original_pid:
273             # fork
274             return
275         try:
276             lock_path.unlink()
277         except OSError:
278             pass
279 
280     return register(cleanup_on_exit)
281 
282 
283 def maybe_delete_a_numbered_dir(path: Path) -> None:
284     """Remove a numbered directory if its lock can be obtained and it does
285     not seem to be in use."""
286     path = ensure_extended_length_path(path)
287     lock_path = None
288     try:
289         lock_path = create_cleanup_lock(path)
290         parent = path.parent
291 
292         garbage = parent.joinpath(f"garbage-{uuid.uuid4()}")
293         path.rename(garbage)
294         rm_rf(garbage)
295     except OSError:
296         #  known races:
297         #  * other process did a cleanup at the same time
298         #  * deletable folder was found
299         #  * process cwd (Windows)
300         return
301     finally:
302         # If we created the lock, ensure we remove it even if we failed
303         # to properly remove the numbered dir.
304         if lock_path is not None:
305             try:
306                 lock_path.unlink()
307             except OSError:
308                 pass
309 
310 
311 def ensure_deletable(path: Path, consider_lock_dead_if_created_before: float) -> bool:
312     """Check if `path` is deletable based on whether the lock file is expired."""
313     if path.is_symlink():
314         return False
315     lock = get_lock_path(path)
316     try:
317         if not lock.is_file():
318             return True
319     except OSError:
320         # we might not have access to the lock file at all, in this case assume
321         # we don't have access to the entire directory (#7491).
322         return False
323     try:
324         lock_time = lock.stat().st_mtime
325     except Exception:
326         return False
327     else:
328         if lock_time < consider_lock_dead_if_created_before:
329             # We want to ignore any errors while trying to remove the lock such as:
330             # - PermissionDenied, like the file permissions have changed since the lock creation;
331             # - FileNotFoundError, in case another pytest process got here first;
332             # and any other cause of failure.
333             with contextlib.suppress(OSError):
334                 lock.unlink()
335                 return True
336         return False
337 
338 
339 def try_cleanup(path: Path, consider_lock_dead_if_created_before: float) -> None:
340     """Try to cleanup a folder if we can ensure it's deletable."""
341     if ensure_deletable(path, consider_lock_dead_if_created_before):
342         maybe_delete_a_numbered_dir(path)
343 
344 
345 def cleanup_candidates(root: Path, prefix: str, keep: int) -> Iterator[Path]:
346     """List candidates for numbered directories to be removed - follows py.path."""
347     max_existing = max(map(parse_num, find_suffixes(root, prefix)), default=-1)
348     max_delete = max_existing - keep
349     paths = find_prefixed(root, prefix)
350     paths, paths2 = itertools.tee(paths)
351     numbers = map(parse_num, extract_suffixes(paths2, prefix))
352     for path, number in zip(paths, numbers):
353         if number <= max_delete:
354             yield path
355 
356 
357 def cleanup_dead_symlinks(root: Path):
358     for left_dir in root.iterdir():
359         if left_dir.is_symlink():
360             if not left_dir.resolve().exists():
361                 left_dir.unlink()
362 
363 
364 def cleanup_numbered_dir(
365     root: Path, prefix: str, keep: int, consider_lock_dead_if_created_before: float
366 ) -> None:
367     """Cleanup for lock driven numbered directories."""
368     if not root.exists():
369         return
370     for path in cleanup_candidates(root, prefix, keep):
371         try_cleanup(path, consider_lock_dead_if_created_before)
372     for path in root.glob("garbage-*"):
373         try_cleanup(path, consider_lock_dead_if_created_before)
374 
375     cleanup_dead_symlinks(root)
376 
377 
378 def make_numbered_dir_with_cleanup(
379     root: Path,
380     prefix: str,
381     keep: int,
382     lock_timeout: float,
383     mode: int,
384 ) -> Path:
385     """Create a numbered dir with a cleanup lock and remove old ones."""
386     e = None
387     for i in range(10):
388         try:
389             p = make_numbered_dir(root, prefix, mode)
390             # Only lock the current dir when keep is not 0
391             if keep != 0:
392                 lock_path = create_cleanup_lock(p)
393                 register_cleanup_lock_removal(lock_path)
394         except Exception as exc:
395             e = exc
396         else:
397             consider_lock_dead_if_created_before = p.stat().st_mtime - lock_timeout
398             # Register a cleanup for program exit
399             atexit.register(
400                 cleanup_numbered_dir,
401                 root,
402                 prefix,
403                 keep,
404                 consider_lock_dead_if_created_before,
405             )
406             return p
407     assert e is not None
408     raise e
409 
410 
411 def resolve_from_str(input: str, rootpath: Path) -> Path:
412     input = expanduser(input)
413     input = expandvars(input)
414     if isabs(input):
415         return Path(input)
416     else:
417         return rootpath.joinpath(input)
418 
419 
420 def fnmatch_ex(pattern: str, path: Union[str, "os.PathLike[str]"]) -> bool:
421     """A port of FNMatcher from py.path.common which works with PurePath() instances.
422 
423     The difference between this algorithm and PurePath.match() is that the
424     latter matches "**" glob expressions for each part of the path, while
425     this algorithm uses the whole path instead.
426 
427     For example:
428         "tests/foo/bar/doc/test_foo.py" matches pattern "tests/**/doc/test*.py"
429         with this algorithm, but not with PurePath.match().
430 
431     This algorithm was ported to keep backward-compatibility with existing
432     settings which assume paths match according this logic.
433 
434     References:
435     * https://bugs.python.org/issue29249
436     * https://bugs.python.org/issue34731
437     """
438     path = PurePath(path)
439     iswin32 = sys.platform.startswith("win")
440 
441     if iswin32 and sep not in pattern and posix_sep in pattern:
442         # Running on Windows, the pattern has no Windows path separators,
443         # and the pattern has one or more Posix path separators. Replace
444         # the Posix path separators with the Windows path separator.
445         pattern = pattern.replace(posix_sep, sep)
446 
447     if sep not in pattern:
448         name = path.name
449     else:
450         name = str(path)
451         if path.is_absolute() and not os.path.isabs(pattern):
452             pattern = f"*{os.sep}{pattern}"
453     return fnmatch.fnmatch(name, pattern)
454 
455 
456 def parts(s: str) -> Set[str]:
457     parts = s.split(sep)
458     return {sep.join(parts[: i + 1]) or sep for i in range(len(parts))}
459 
460 
461 def symlink_or_skip(src, dst, **kwargs):
462     """Make a symlink, or skip the test in case symlinks are not supported."""
463     try:
464         os.symlink(str(src), str(dst), **kwargs)
465     except OSError as e:
466         skip(f"symlinks not supported: {e}")
467 
468 
469 class ImportMode(Enum):
470     """Possible values for `mode` parameter of `import_path`."""
471 
472     prepend = "prepend"
473     append = "append"
474     importlib = "importlib"
475 
476 
477 class ImportPathMismatchError(ImportError):
478     """Raised on import_path() if there is a mismatch of __file__'s.
479 
480     This can happen when `import_path` is called multiple times with different filenames that has
481     the same basename but reside in packages
482     (for example "/tests1/test_foo.py" and "/tests2/test_foo.py").
483     """
484 
485 
486 def import_path(
487     p: Union[str, "os.PathLike[str]"],
488     *,
489     mode: Union[str, ImportMode] = ImportMode.prepend,
490     root: Path,
491 ) -> ModuleType:
492     """Import and return a module from the given path, which can be a file (a module) or
493     a directory (a package).
494 
495     The import mechanism used is controlled by the `mode` parameter:
496 
497     * `mode == ImportMode.prepend`: the directory containing the module (or package, taking
498       `__init__.py` files into account) will be put at the *start* of `sys.path` before
499       being imported with `importlib.import_module`.
500 
501     * `mode == ImportMode.append`: same as `prepend`, but the directory will be appended
502       to the end of `sys.path`, if not already in `sys.path`.
503 
504     * `mode == ImportMode.importlib`: uses more fine control mechanisms provided by `importlib`
505       to import the module, which avoids having to muck with `sys.path` at all. It effectively
506       allows having same-named test modules in different places.
507 
508     :param root:
509         Used as an anchor when mode == ImportMode.importlib to obtain
510         a unique name for the module being imported so it can safely be stored
511         into ``sys.modules``.
512 
513     :raises ImportPathMismatchError:
514         If after importing the given `path` and the module `__file__`
515         are different. Only raised in `prepend` and `append` modes.
516     """
517     mode = ImportMode(mode)
518 
519     path = Path(p)
520 
521     if not path.exists():
522         raise ImportError(path)
523 
524     if mode is ImportMode.importlib:
525         module_name = module_name_from_path(path, root)
526 
527         for meta_importer in sys.meta_path:
528             spec = meta_importer.find_spec(module_name, [str(path.parent)])
529             if spec is not None:
530                 break
531         else:
532             spec = importlib.util.spec_from_file_location(module_name, str(path))
533 
534         if spec is None:
535             raise ImportError(f"Can't find module {module_name} at location {path}")
536         mod = importlib.util.module_from_spec(spec)
537         sys.modules[module_name] = mod
538         spec.loader.exec_module(mod)  # type: ignore[union-attr]
539         insert_missing_modules(sys.modules, module_name)
540         return mod
541 
542     pkg_path = resolve_package_path(path)
543     if pkg_path is not None:
544         pkg_root = pkg_path.parent
545         names = list(path.with_suffix("").relative_to(pkg_root).parts)
546         if names[-1] == "__init__":
547             names.pop()
548         module_name = ".".join(names)
549     else:
550         pkg_root = path.parent
551         module_name = path.stem
552 
553     # Change sys.path permanently: restoring it at the end of this function would cause surprising
554     # problems because of delayed imports: for example, a conftest.py file imported by this function
555     # might have local imports, which would fail at runtime if we restored sys.path.
556     if mode is ImportMode.append:
557         if str(pkg_root) not in sys.path:
558             sys.path.append(str(pkg_root))
559     elif mode is ImportMode.prepend:
560         if str(pkg_root) != sys.path[0]:
561             sys.path.insert(0, str(pkg_root))
562     else:
563         assert_never(mode)
564 
565     importlib.import_module(module_name)
566 
567     mod = sys.modules[module_name]
568     if path.name == "__init__.py":
569         return mod
570 
571     ignore = os.environ.get("PY_IGNORE_IMPORTMISMATCH", "")
572     if ignore != "1":
573         module_file = mod.__file__
574         if module_file is None:
575             raise ImportPathMismatchError(module_name, module_file, path)
576 
577         if module_file.endswith((".pyc", ".pyo")):
578             module_file = module_file[:-1]
579         if module_file.endswith(os.sep + "__init__.py"):
580             module_file = module_file[: -(len(os.sep + "__init__.py"))]
581 
582         try:
583             is_same = _is_same(str(path), module_file)
584         except FileNotFoundError:
585             is_same = False
586 
587         if not is_same:
588             raise ImportPathMismatchError(module_name, module_file, path)
589 
590     return mod
591 
592 
593 # Implement a special _is_same function on Windows which returns True if the two filenames
594 # compare equal, to circumvent os.path.samefile returning False for mounts in UNC (#7678).
595 if sys.platform.startswith("win"):
596 
597     def _is_same(f1: str, f2: str) -> bool:
598         return Path(f1) == Path(f2) or os.path.samefile(f1, f2)
599 
600 else:
601 
602     def _is_same(f1: str, f2: str) -> bool:
603         return os.path.samefile(f1, f2)
604 
605 
606 def module_name_from_path(path: Path, root: Path) -> str:
607     """
608     Return a dotted module name based on the given path, anchored on root.
609 
610     For example: path="projects/src/tests/test_foo.py" and root="/projects", the
611     resulting module name will be "src.tests.test_foo".
612     """
613     path = path.with_suffix("")
614     try:
615         relative_path = path.relative_to(root)
616     except ValueError:
617         # If we can't get a relative path to root, use the full path, except
618         # for the first part ("d:\\" or "/" depending on the platform, for example).
619         path_parts = path.parts[1:]
620     else:
621         # Use the parts for the relative path to the root path.
622         path_parts = relative_path.parts
623 
624     return ".".join(path_parts)
625 
626 
627 def insert_missing_modules(modules: Dict[str, ModuleType], module_name: str) -> None:
628     """
629     Used by ``import_path`` to create intermediate modules when using mode=importlib.
630 
631     When we want to import a module as "src.tests.test_foo" for example, we need
632     to create empty modules "src" and "src.tests" after inserting "src.tests.test_foo",
633     otherwise "src.tests.test_foo" is not importable by ``__import__``.
634     """
635     module_parts = module_name.split(".")
636     child_module: Union[ModuleType, None] = None
637     module: Union[ModuleType, None] = None
638     child_name: str = ""
639     while module_name:
640         if module_name not in modules:
641             try:
642                 # If sys.meta_path is empty, calling import_module will issue
643                 # a warning and raise ModuleNotFoundError. To avoid the
644                 # warning, we check sys.meta_path explicitly and raise the error
645                 # ourselves to fall back to creating a dummy module.
646                 if not sys.meta_path:
647                     raise ModuleNotFoundError
648                 module = importlib.import_module(module_name)
649             except ModuleNotFoundError:
650                 module = ModuleType(
651                     module_name,
652                     doc="Empty module created by pytest's importmode=importlib.",
653                 )
654         else:
655             module = modules[module_name]
656         if child_module:
657             # Add child attribute to the parent that can reference the child
658             # modules.
659             if not hasattr(module, child_name):
660                 setattr(module, child_name, child_module)
661                 modules[module_name] = module
662         # Keep track of the child module while moving up the tree.
663         child_module, child_name = module, module_name.rpartition(".")[-1]
664         module_parts.pop(-1)
665         module_name = ".".join(module_parts)
666 
667 
668 def resolve_package_path(path: Path) -> Optional[Path]:
669     """Return the Python package path by looking for the last
670     directory upwards which still contains an __init__.py.
671 
672     Returns None if it can not be determined.
673     """
674     result = None
675     for parent in itertools.chain((path,), path.parents):
676         if parent.is_dir():
677             if not parent.joinpath("__init__.py").is_file():
678                 break
679             if not parent.name.isidentifier():
680                 break
681             result = parent
682     return result
683 
684 
685 def scandir(path: Union[str, "os.PathLike[str]"]) -> List["os.DirEntry[str]"]:
686     """Scan a directory recursively, in breadth-first order.
687 
688     The returned entries are sorted.
689     """
690     entries = []
691     with os.scandir(path) as s:
692         # Skip entries with symlink loops and other brokenness, so the caller
693         # doesn't have to deal with it.
694         for entry in s:
695             try:
696                 entry.is_file()
697             except OSError as err:
698                 if _ignore_error(err):
699                     continue
700                 raise
701             entries.append(entry)
702     entries.sort(key=lambda entry: entry.name)
703     return entries
704 
705 
706 def visit(
707     path: Union[str, "os.PathLike[str]"], recurse: Callable[["os.DirEntry[str]"], bool]
708 ) -> Iterator["os.DirEntry[str]"]:
709     """Walk a directory recursively, in breadth-first order.
710 
711     The `recurse` predicate determines whether a directory is recursed.
712 
713     Entries at each directory level are sorted.
714     """
715     entries = scandir(path)
716     yield from entries
717     for entry in entries:
718         if entry.is_dir() and recurse(entry):
719             yield from visit(entry.path, recurse)
720 
721 
722 def absolutepath(path: Union[Path, str]) -> Path:
723     """Convert a path to an absolute path using os.path.abspath.
724 
725     Prefer this over Path.resolve() (see #6523).
726     Prefer this over Path.absolute() (not public, doesn't normalize).
727     """
728     return Path(os.path.abspath(str(path)))
729 
730 
731 def commonpath(path1: Path, path2: Path) -> Optional[Path]:
732     """Return the common part shared with the other path, or None if there is
733     no common part.
734 
735     If one path is relative and one is absolute, returns None.
736     """
737     try:
738         return Path(os.path.commonpath((str(path1), str(path2))))
739     except ValueError:
740         return None
741 
742 
743 def bestrelpath(directory: Path, dest: Path) -> str:
744     """Return a string which is a relative path from directory to dest such
745     that directory/bestrelpath == dest.
746 
747     The paths must be either both absolute or both relative.
748 
749     If no such path can be determined, returns dest.
750     """
751     assert isinstance(directory, Path)
752     assert isinstance(dest, Path)
753     if dest == directory:
754         return os.curdir
755     # Find the longest common directory.
756     base = commonpath(directory, dest)
757     # Can be the case on Windows for two absolute paths on different drives.
758     # Can be the case for two relative paths without common prefix.
759     # Can be the case for a relative path and an absolute path.
760     if not base:
761         return str(dest)
762     reldirectory = directory.relative_to(base)
763     reldest = dest.relative_to(base)
764     return os.path.join(
765         # Back from directory to base.
766         *([os.pardir] * len(reldirectory.parts)),
767         # Forward from base to dest.
768         *reldest.parts,
769     )
770 
771 
772 # Originates from py. path.local.copy(), with siginficant trims and adjustments.
773 # TODO(py38): Replace with shutil.copytree(..., symlinks=True, dirs_exist_ok=True)
774 def copytree(source: Path, target: Path) -> None:
775     """Recursively copy a source directory to target."""
776     assert source.is_dir()
777     for entry in visit(source, recurse=lambda entry: not entry.is_symlink()):
778         x = Path(entry)
779         relpath = x.relative_to(source)
780         newx = target / relpath
781         newx.parent.mkdir(exist_ok=True)
782         if x.is_symlink():
783             newx.symlink_to(os.readlink(x))
784         elif x.is_file():
785             shutil.copyfile(x, newx)
786         elif x.is_dir():
787             newx.mkdir(exist_ok=True)

</code><intended_behavior>When using `importlib` for dynamic imports, the application should implement checks or strategies to avoid importing the same module under different names or paths, which could lead to the observed issue of having two different versions of `pmxbot.logging`. This might include enhancing the logic around module importation to reference or augment Python's import machinery, ensuring that `sys.modules` is appropriately managed to unify module instances.</intended_behavior>, <file>src/_pytest/assertion/rewrite.py</file>
<class>None</class>
<method>None</method>
<code>
1 """Rewrite assertion AST to produce nice error messages."""
2 import ast
3 import errno
4 import functools
5 import importlib.abc
6 import importlib.machinery
7 import importlib.util
8 import io
9 import itertools
10 import marshal
11 import os
12 import struct
13 import sys
14 import tokenize
15 import types
16 from pathlib import Path
17 from pathlib import PurePath
18 from typing import Callable
19 from typing import Dict
20 from typing import IO
21 from typing import Iterable
22 from typing import Iterator
23 from typing import List
24 from typing import Optional
25 from typing import Sequence
26 from typing import Set
27 from typing import Tuple
28 from typing import TYPE_CHECKING
29 from typing import Union
30 
31 from _pytest._io.saferepr import DEFAULT_REPR_MAX_SIZE
32 from _pytest._io.saferepr import saferepr
33 from _pytest._version import version
34 from _pytest.assertion import util
35 from _pytest.assertion.util import (  # noqa: F401
36     format_explanation as _format_explanation,
37 )
38 from _pytest.config import Config
39 from _pytest.main import Session
40 from _pytest.pathlib import absolutepath
41 from _pytest.pathlib import fnmatch_ex
42 from _pytest.stash import StashKey
43 
44 if TYPE_CHECKING:
45     from _pytest.assertion import AssertionState
46 
47 
48 assertstate_key = StashKey["AssertionState"]()
49 
50 # pytest caches rewritten pycs in pycache dirs
51 PYTEST_TAG = f"{sys.implementation.cache_tag}-pytest-{version}"
52 PYC_EXT = ".py" + (__debug__ and "c" or "o")
53 PYC_TAIL = "." + PYTEST_TAG + PYC_EXT
54 
55 
56 class AssertionRewritingHook(importlib.abc.MetaPathFinder, importlib.abc.Loader):
57     """PEP302/PEP451 import hook which rewrites asserts."""
58 
59     def __init__(self, config: Config) -> None:
60         self.config = config
61         try:
62             self.fnpats = config.getini("python_files")
63         except ValueError:
64             self.fnpats = ["test_*.py", "*_test.py"]
65         self.session: Optional[Session] = None
66         self._rewritten_names: Dict[str, Path] = {}
67         self._must_rewrite: Set[str] = set()
68         # flag to guard against trying to rewrite a pyc file while we are already writing another pyc file,
69         # which might result in infinite recursion (#3506)
70         self._writing_pyc = False
71         self._basenames_to_check_rewrite = {"conftest"}
72         self._marked_for_rewrite_cache: Dict[str, bool] = {}
73         self._session_paths_checked = False
74 
75     def set_session(self, session: Optional[Session]) -> None:
76         self.session = session
77         self._session_paths_checked = False
78 
79     # Indirection so we can mock calls to find_spec originated from the hook during testing
80     _find_spec = importlib.machinery.PathFinder.find_spec
81 
82     def find_spec(
83         self,
84         name: str,
85         path: Optional[Sequence[Union[str, bytes]]] = None,
86         target: Optional[types.ModuleType] = None,
87     ) -> Optional[importlib.machinery.ModuleSpec]:
88         if self._writing_pyc:
89             return None
90         state = self.config.stash[assertstate_key]
91         if self._early_rewrite_bailout(name, state):
92             return None
93         state.trace("find_module called for: %s" % name)
94 
95         # Type ignored because mypy is confused about the `self` binding here.
96         spec = self._find_spec(name, path)  # type: ignore
97         if (
98             # the import machinery could not find a file to import
99             spec is None
100             # this is a namespace package (without `__init__.py`)
101             # there's nothing to rewrite there
102             or spec.origin is None
103             # we can only rewrite source files
104             or not isinstance(spec.loader, importlib.machinery.SourceFileLoader)
105             # if the file doesn't exist, we can't rewrite it
106             or not os.path.exists(spec.origin)
107         ):
108             return None
109         else:
110             fn = spec.origin
111 
112         if not self._should_rewrite(name, fn, state):
113             return None
114 
115         return importlib.util.spec_from_file_location(
116             name,
117             fn,
118             loader=self,
119             submodule_search_locations=spec.submodule_search_locations,
120         )
121 
122     def create_module(
123         self, spec: importlib.machinery.ModuleSpec
124     ) -> Optional[types.ModuleType]:
125         return None  # default behaviour is fine
126 
127     def exec_module(self, module: types.ModuleType) -> None:
128         assert module.__spec__ is not None
129         assert module.__spec__.origin is not None
130         fn = Path(module.__spec__.origin)
131         state = self.config.stash[assertstate_key]
132 
133         self._rewritten_names[module.__name__] = fn
134 
135         # The requested module looks like a test file, so rewrite it. This is
136         # the most magical part of the process: load the source, rewrite the
137         # asserts, and load the rewritten source. We also cache the rewritten
138         # module code in a special pyc. We must be aware of the possibility of
139         # concurrent pytest processes rewriting and loading pycs. To avoid
140         # tricky race conditions, we maintain the following invariant: The
141         # cached pyc is always a complete, valid pyc. Operations on it must be
142         # atomic. POSIX's atomic rename comes in handy.
143         write = not sys.dont_write_bytecode
144         cache_dir = get_cache_dir(fn)
145         if write:
146             ok = try_makedirs(cache_dir)
147             if not ok:
148                 write = False
149                 state.trace(f"read only directory: {cache_dir}")
150 
151         cache_name = fn.name[:-3] + PYC_TAIL
152         pyc = cache_dir / cache_name
153         # Notice that even if we're in a read-only directory, I'm going
154         # to check for a cached pyc. This may not be optimal...
155         co = _read_pyc(fn, pyc, state.trace)
156         if co is None:
157             state.trace(f"rewriting {fn!r}")
158             source_stat, co = _rewrite_test(fn, self.config)
159             if write:
160                 self._writing_pyc = True
161                 try:
162                     _write_pyc(state, co, source_stat, pyc)
163                 finally:
164                     self._writing_pyc = False
165         else:
166             state.trace(f"found cached rewritten pyc for {fn}")
167         exec(co, module.__dict__)
168 
169     def _early_rewrite_bailout(self, name: str, state: "AssertionState") -> bool:
170         """A fast way to get out of rewriting modules.
171 
172         Profiling has shown that the call to PathFinder.find_spec (inside of
173         the find_spec from this class) is a major slowdown, so, this method
174         tries to filter what we're sure won't be rewritten before getting to
175         it.
176         """
177         if self.session is not None and not self._session_paths_checked:
178             self._session_paths_checked = True
179             for initial_path in self.session._initialpaths:
180                 # Make something as c:/projects/my_project/path.py ->
181                 #     ['c:', 'projects', 'my_project', 'path.py']
182                 parts = str(initial_path).split(os.sep)
183                 # add 'path' to basenames to be checked.
184                 self._basenames_to_check_rewrite.add(os.path.splitext(parts[-1])[0])
185 
186         # Note: conftest already by default in _basenames_to_check_rewrite.
187         parts = name.split(".")
188         if parts[-1] in self._basenames_to_check_rewrite:
189             return False
190 
191         # For matching the name it must be as if it was a filename.
192         path = PurePath(*parts).with_suffix(".py")
193 
194         for pat in self.fnpats:
195             # if the pattern contains subdirectories ("tests/**.py" for example) we can't bail out based
196             # on the name alone because we need to match against the full path
197             if os.path.dirname(pat):
198                 return False
199             if fnmatch_ex(pat, path):
200                 return False
201 
202         if self._is_marked_for_rewrite(name, state):
203             return False
204 
205         state.trace(f"early skip of rewriting module: {name}")
206         return True
207 
208     def _should_rewrite(self, name: str, fn: str, state: "AssertionState") -> bool:
209         # always rewrite conftest files
210         if os.path.basename(fn) == "conftest.py":
211             state.trace(f"rewriting conftest file: {fn!r}")
212             return True
213 
214         if self.session is not None:
215             if self.session.isinitpath(absolutepath(fn)):
216                 state.trace(f"matched test file (was specified on cmdline): {fn!r}")
217                 return True
218 
219         # modules not passed explicitly on the command line are only
220         # rewritten if they match the naming convention for test files
221         fn_path = PurePath(fn)
222         for pat in self.fnpats:
223             if fnmatch_ex(pat, fn_path):
224                 state.trace(f"matched test file {fn!r}")
225                 return True
226 
227         return self._is_marked_for_rewrite(name, state)
228 
229     def _is_marked_for_rewrite(self, name: str, state: "AssertionState") -> bool:
230         try:
231             return self._marked_for_rewrite_cache[name]
232         except KeyError:
233             for marked in self._must_rewrite:
234                 if name == marked or name.startswith(marked + "."):
235                     state.trace(f"matched marked file {name!r} (from {marked!r})")
236                     self._marked_for_rewrite_cache[name] = True
237                     return True
238 
239             self._marked_for_rewrite_cache[name] = False
240             return False
241 
242     def mark_rewrite(self, *names: str) -> None:
243         """Mark import names as needing to be rewritten.
244 
245         The named module or package as well as any nested modules will
246         be rewritten on import.
247         """
248         already_imported = (
249             set(names).intersection(sys.modules).difference(self._rewritten_names)
250         )
251         for name in already_imported:
252             mod = sys.modules[name]
253             if not AssertionRewriter.is_rewrite_disabled(
254                 mod.__doc__ or ""
255             ) and not isinstance(mod.__loader__, type(self)):
256                 self._warn_already_imported(name)
257         self._must_rewrite.update(names)
258         self._marked_for_rewrite_cache.clear()
259 
260     def _warn_already_imported(self, name: str) -> None:
261         from _pytest.warning_types import PytestAssertRewriteWarning
262 
263         self.config.issue_config_time_warning(
264             PytestAssertRewriteWarning(
265                 "Module already imported so cannot be rewritten: %s" % name
266             ),
267             stacklevel=5,
268         )
269 
270     def get_data(self, pathname: Union[str, bytes]) -> bytes:
271         """Optional PEP302 get_data API."""
272         with open(pathname, "rb") as f:
273             return f.read()
274 
275     if sys.version_info >= (3, 10):
276         if sys.version_info >= (3, 12):
277             from importlib.resources.abc import TraversableResources
278         else:
279             from importlib.abc import TraversableResources
280 
281         def get_resource_reader(self, name: str) -> TraversableResources:  # type: ignore
282             if sys.version_info < (3, 11):
283                 from importlib.readers import FileReader
284             else:
285                 from importlib.resources.readers import FileReader
286 
287             return FileReader(  # type:ignore[no-any-return]
288                 types.SimpleNamespace(path=self._rewritten_names[name])
289             )
290 
291 
292 def _write_pyc_fp(
293     fp: IO[bytes], source_stat: os.stat_result, co: types.CodeType
294 ) -> None:
295     # Technically, we don't have to have the same pyc format as
296     # (C)Python, since these "pycs" should never be seen by builtin
297     # import. However, there's little reason to deviate.
298     fp.write(importlib.util.MAGIC_NUMBER)
299     # https://www.python.org/dev/peps/pep-0552/
300     flags = b"\x00\x00\x00\x00"
301     fp.write(flags)
302     # as of now, bytecode header expects 32-bit numbers for size and mtime (#4903)
303     mtime = int(source_stat.st_mtime) & 0xFFFFFFFF
304     size = source_stat.st_size & 0xFFFFFFFF
305     # "<LL" stands for 2 unsigned longs, little-endian.
306     fp.write(struct.pack("<LL", mtime, size))
307     fp.write(marshal.dumps(co))
308 
309 
310 def _write_pyc(
311     state: "AssertionState",
312     co: types.CodeType,
313     source_stat: os.stat_result,
314     pyc: Path,
315 ) -> bool:
316     proc_pyc = f"{pyc}.{os.getpid()}"
317     try:
318         with open(proc_pyc, "wb") as fp:
319             _write_pyc_fp(fp, source_stat, co)
320     except OSError as e:
321         state.trace(f"error writing pyc file at {proc_pyc}: errno={e.errno}")
322         return False
323 
324     try:
325         os.replace(proc_pyc, pyc)
326     except OSError as e:
327         state.trace(f"error writing pyc file at {pyc}: {e}")
328         # we ignore any failure to write the cache file
329         # there are many reasons, permission-denied, pycache dir being a
330         # file etc.
331         return False
332     return True
333 
334 
335 def _rewrite_test(fn: Path, config: Config) -> Tuple[os.stat_result, types.CodeType]:
336     """Read and rewrite *fn* and return the code object."""
337     stat = os.stat(fn)
338     source = fn.read_bytes()
339     strfn = str(fn)
340     tree = ast.parse(source, filename=strfn)
341     rewrite_asserts(tree, source, strfn, config)
342     co = compile(tree, strfn, "exec", dont_inherit=True)
343     return stat, co
344 
345 
346 def _read_pyc(
347     source: Path, pyc: Path, trace: Callable[[str], None] = lambda x: None
348 ) -> Optional[types.CodeType]:
349     """Possibly read a pytest pyc containing rewritten code.
350 
351     Return rewritten code if successful or None if not.
352     """
353     try:
354         fp = open(pyc, "rb")
355     except OSError:
356         return None
357     with fp:
358         try:
359             stat_result = os.stat(source)
360             mtime = int(stat_result.st_mtime)
361             size = stat_result.st_size
362             data = fp.read(16)
363         except OSError as e:
364             trace(f"_read_pyc({source}): OSError {e}")
365             return None
366         # Check for invalid or out of date pyc file.
367         if len(data) != (16):
368             trace("_read_pyc(%s): invalid pyc (too short)" % source)
369             return None
370         if data[:4] != importlib.util.MAGIC_NUMBER:
371             trace("_read_pyc(%s): invalid pyc (bad magic number)" % source)
372             return None
373         if data[4:8] != b"\x00\x00\x00\x00":
374             trace("_read_pyc(%s): invalid pyc (unsupported flags)" % source)
375             return None
376         mtime_data = data[8:12]
377         if int.from_bytes(mtime_data, "little") != mtime & 0xFFFFFFFF:
378             trace("_read_pyc(%s): out of date" % source)
379             return None
380         size_data = data[12:16]
381         if int.from_bytes(size_data, "little") != size & 0xFFFFFFFF:
382             trace("_read_pyc(%s): invalid pyc (incorrect size)" % source)
383             return None
384         try:
385             co = marshal.load(fp)
386         except Exception as e:
387             trace(f"_read_pyc({source}): marshal.load error {e}")
388             return None
389         if not isinstance(co, types.CodeType):
390             trace("_read_pyc(%s): not a code object" % source)
391             return None
392         return co
393 
394 
395 def rewrite_asserts(
396     mod: ast.Module,
397     source: bytes,
398     module_path: Optional[str] = None,
399     config: Optional[Config] = None,
400 ) -> None:
401     """Rewrite the assert statements in mod."""
402     AssertionRewriter(module_path, config, source).run(mod)
403 
404 
405 def _saferepr(obj: object) -> str:
406     r"""Get a safe repr of an object for assertion error messages.
407 
408     The assertion formatting (util.format_explanation()) requires
409     newlines to be escaped since they are a special character for it.
410     Normally assertion.util.format_explanation() does this but for a
411     custom repr it is possible to contain one of the special escape
412     sequences, especially '\n{' and '\n}' are likely to be present in
413     JSON reprs.
414     """
415     maxsize = _get_maxsize_for_saferepr(util._config)
416     return saferepr(obj, maxsize=maxsize).replace("\n", "\\n")
417 
418 
419 def _get_maxsize_for_saferepr(config: Optional[Config]) -> Optional[int]:
420     """Get `maxsize` configuration for saferepr based on the given config object."""
421     verbosity = config.getoption("verbose") if config is not None else 0
422     if verbosity >= 2:
423         return None
424     if verbosity >= 1:
425         return DEFAULT_REPR_MAX_SIZE * 10
426     return DEFAULT_REPR_MAX_SIZE
427 
428 
429 def _format_assertmsg(obj: object) -> str:
430     r"""Format the custom assertion message given.
431 
432     For strings this simply replaces newlines with '\n~' so that
433     util.format_explanation() will preserve them instead of escaping
434     newlines.  For other objects saferepr() is used first.
435     """
436     # reprlib appears to have a bug which means that if a string
437     # contains a newline it gets escaped, however if an object has a
438     # .__repr__() which contains newlines it does not get escaped.
439     # However in either case we want to preserve the newline.
440     replaces = [("\n", "\n~"), ("%", "%%")]
441     if not isinstance(obj, str):
442         obj = saferepr(obj)
443         replaces.append(("\\n", "\n~"))
444 
445     for r1, r2 in replaces:
446         obj = obj.replace(r1, r2)
447 
448     return obj
449 
450 
451 def _should_repr_global_name(obj: object) -> bool:
452     if callable(obj):
453         return False
454 
455     try:
456         return not hasattr(obj, "__name__")
457     except Exception:
458         return True
459 
460 
461 def _format_boolop(explanations: Iterable[str], is_or: bool) -> str:
462     explanation = "(" + (is_or and " or " or " and ").join(explanations) + ")"
463     return explanation.replace("%", "%%")
464 
465 
466 def _call_reprcompare(
467     ops: Sequence[str],
468     results: Sequence[bool],
469     expls: Sequence[str],
470     each_obj: Sequence[object],
471 ) -> str:
472     for i, res, expl in zip(range(len(ops)), results, expls):
473         try:
474             done = not res
475         except Exception:
476             done = True
477         if done:
478             break
479     if util._reprcompare is not None:
480         custom = util._reprcompare(ops[i], each_obj[i], each_obj[i + 1])
481         if custom is not None:
482             return custom
483     return expl
484 
485 
486 def _call_assertion_pass(lineno: int, orig: str, expl: str) -> None:
487     if util._assertion_pass is not None:
488         util._assertion_pass(lineno, orig, expl)
489 
490 
491 def _check_if_assertion_pass_impl() -> bool:
492     """Check if any plugins implement the pytest_assertion_pass hook
493     in order not to generate explanation unnecessarily (might be expensive)."""
494     return True if util._assertion_pass else False
495 
496 
497 UNARY_MAP = {ast.Not: "not %s", ast.Invert: "~%s", ast.USub: "-%s", ast.UAdd: "+%s"}
498 
499 BINOP_MAP = {
500     ast.BitOr: "|",
501     ast.BitXor: "^",
502     ast.BitAnd: "&",
503     ast.LShift: "<<",
504     ast.RShift: ">>",
505     ast.Add: "+",
506     ast.Sub: "-",
507     ast.Mult: "*",
508     ast.Div: "/",
509     ast.FloorDiv: "//",
510     ast.Mod: "%%",  # escaped for string formatting
511     ast.Eq: "==",
512     ast.NotEq: "!=",
513     ast.Lt: "<",
514     ast.LtE: "<=",
515     ast.Gt: ">",
516     ast.GtE: ">=",
517     ast.Pow: "**",
518     ast.Is: "is",
519     ast.IsNot: "is not",
520     ast.In: "in",
521     ast.NotIn: "not in",
522     ast.MatMult: "@",
523 }
524 
525 
526 def traverse_node(node: ast.AST) -> Iterator[ast.AST]:
527     """Recursively yield node and all its children in depth-first order."""
528     yield node
529     for child in ast.iter_child_nodes(node):
530         yield from traverse_node(child)
531 
532 
533 @functools.lru_cache(maxsize=1)
534 def _get_assertion_exprs(src: bytes) -> Dict[int, str]:
535     """Return a mapping from {lineno: "assertion test expression"}."""
536     ret: Dict[int, str] = {}
537 
538     depth = 0
539     lines: List[str] = []
540     assert_lineno: Optional[int] = None
541     seen_lines: Set[int] = set()
542 
543     def _write_and_reset() -> None:
544         nonlocal depth, lines, assert_lineno, seen_lines
545         assert assert_lineno is not None
546         ret[assert_lineno] = "".join(lines).rstrip().rstrip("\\")
547         depth = 0
548         lines = []
549         assert_lineno = None
550         seen_lines = set()
551 
552     tokens = tokenize.tokenize(io.BytesIO(src).readline)
553     for tp, source, (lineno, offset), _, line in tokens:
554         if tp == tokenize.NAME and source == "assert":
555             assert_lineno = lineno
556         elif assert_lineno is not None:
557             # keep track of depth for the assert-message `,` lookup
558             if tp == tokenize.OP and source in "([{":
559                 depth += 1
560             elif tp == tokenize.OP and source in ")]}":
561                 depth -= 1
562 
563             if not lines:
564                 lines.append(line[offset:])
565                 seen_lines.add(lineno)
566             # a non-nested comma separates the expression from the message
567             elif depth == 0 and tp == tokenize.OP and source == ",":
568                 # one line assert with message
569                 if lineno in seen_lines and len(lines) == 1:
570                     offset_in_trimmed = offset + len(lines[-1]) - len(line)
571                     lines[-1] = lines[-1][:offset_in_trimmed]
572                 # multi-line assert with message
573                 elif lineno in seen_lines:
574                     lines[-1] = lines[-1][:offset]
575                 # multi line assert with escapd newline before message
576                 else:
577                     lines.append(line[:offset])
578                 _write_and_reset()
579             elif tp in {tokenize.NEWLINE, tokenize.ENDMARKER}:
580                 _write_and_reset()
581             elif lines and lineno not in seen_lines:
582                 lines.append(line)
583                 seen_lines.add(lineno)
584 
585     return ret
586 
587 
588 class AssertionRewriter(ast.NodeVisitor):
589     """Assertion rewriting implementation.
590 
591     The main entrypoint is to call .run() with an ast.Module instance,
592     this will then find all the assert statements and rewrite them to
593     provide intermediate values and a detailed assertion error.  See
594     http://pybites.blogspot.be/2011/07/behind-scenes-of-pytests-new-assertion.html
595     for an overview of how this works.
596 
597     The entry point here is .run() which will iterate over all the
598     statements in an ast.Module and for each ast.Assert statement it
599     finds call .visit() with it.  Then .visit_Assert() takes over and
600     is responsible for creating new ast statements to replace the
601     original assert statement: it rewrites the test of an assertion
602     to provide intermediate values and replace it with an if statement
603     which raises an assertion error with a detailed explanation in
604     case the expression is false and calls pytest_assertion_pass hook
605     if expression is true.
606 
607     For this .visit_Assert() uses the visitor pattern to visit all the
608     AST nodes of the ast.Assert.test field, each visit call returning
609     an AST node and the corresponding explanation string.  During this
610     state is kept in several instance attributes:
611 
612     :statements: All the AST statements which will replace the assert
613        statement.
614 
615     :variables: This is populated by .variable() with each variable
616        used by the statements so that they can all be set to None at
617        the end of the statements.
618 
619     :variable_counter: Counter to create new unique variables needed
620        by statements.  Variables are created using .variable() and
621        have the form of "@py_assert0".
622 
623     :expl_stmts: The AST statements which will be executed to get
624        data from the assertion.  This is the code which will construct
625        the detailed assertion message that is used in the AssertionError
626        or for the pytest_assertion_pass hook.
627 
628     :explanation_specifiers: A dict filled by .explanation_param()
629        with %-formatting placeholders and their corresponding
630        expressions to use in the building of an assertion message.
631        This is used by .pop_format_context() to build a message.
632 
633     :stack: A stack of the explanation_specifiers dicts maintained by
634        .push_format_context() and .pop_format_context() which allows
635        to build another %-formatted string while already building one.
636 
637     :variables_overwrite: A dict filled with references to variables
638        that change value within an assert. This happens when a variable is
639        reassigned with the walrus operator
640 
641     This state, except the variables_overwrite,  is reset on every new assert
642     statement visited and used by the other visitors.
643     """
644 
645     def __init__(
646         self, module_path: Optional[str], config: Optional[Config], source: bytes
647     ) -> None:
648         super().__init__()
649         self.module_path = module_path
650         self.config = config
651         if config is not None:
652             self.enable_assertion_pass_hook = config.getini(
653                 "enable_assertion_pass_hook"
654             )
655         else:
656             self.enable_assertion_pass_hook = False
657         self.source = source
658         self.variables_overwrite: Dict[str, str] = {}
659 
660     def run(self, mod: ast.Module) -> None:
661         """Find all assert statements in *mod* and rewrite them."""
662         if not mod.body:
663             # Nothing to do.
664             return
665 
666         # We'll insert some special imports at the top of the module, but after any
667         # docstrings and __future__ imports, so first figure out where that is.
668         doc = getattr(mod, "docstring", None)
669         expect_docstring = doc is None
670         if doc is not None and self.is_rewrite_disabled(doc):
671             return
672         pos = 0
673         item = None
674         for item in mod.body:
675             if (
676                 expect_docstring
677                 and isinstance(item, ast.Expr)
678                 and isinstance(item.value, ast.Constant)
679             ):
680                 doc = item.value.value
681                 if self.is_rewrite_disabled(doc):
682                     return
683                 expect_docstring = False
684             elif (
685                 isinstance(item, ast.ImportFrom)
686                 and item.level == 0
687                 and item.module == "__future__"
688             ):
689                 pass
690             else:
691                 break
692             pos += 1
693         # Special case: for a decorated function, set the lineno to that of the
694         # first decorator, not the `def`. Issue #4984.
695         if isinstance(item, ast.FunctionDef) and item.decorator_list:
696             lineno = item.decorator_list[0].lineno
697         else:
698             lineno = item.lineno
699         # Now actually insert the special imports.
700         if sys.version_info >= (3, 10):
701             aliases = [
702                 ast.alias("builtins", "@py_builtins", lineno=lineno, col_offset=0),
703                 ast.alias(
704                     "_pytest.assertion.rewrite",
705                     "@pytest_ar",
706                     lineno=lineno,
707                     col_offset=0,
708                 ),
709             ]
710         else:
711             aliases = [
712                 ast.alias("builtins", "@py_builtins"),
713                 ast.alias("_pytest.assertion.rewrite", "@pytest_ar"),
714             ]
715         imports = [
716             ast.Import([alias], lineno=lineno, col_offset=0) for alias in aliases
717         ]
718         mod.body[pos:pos] = imports
719 
720         # Collect asserts.
721         nodes: List[ast.AST] = [mod]
722         while nodes:
723             node = nodes.pop()
724             for name, field in ast.iter_fields(node):
725                 if isinstance(field, list):
726                     new: List[ast.AST] = []
727                     for i, child in enumerate(field):
728                         if isinstance(child, ast.Assert):
729                             # Transform assert.
730                             new.extend(self.visit(child))
731                         else:
732                             new.append(child)
733                             if isinstance(child, ast.AST):
734                                 nodes.append(child)
735                     setattr(node, name, new)
736                 elif (
737                     isinstance(field, ast.AST)
738                     # Don't recurse into expressions as they can't contain
739                     # asserts.
740                     and not isinstance(field, ast.expr)
741                 ):
742                     nodes.append(field)
743 
744     @staticmethod
745     def is_rewrite_disabled(docstring: str) -> bool:
746         return "PYTEST_DONT_REWRITE" in docstring
747 
748     def variable(self) -> str:
749         """Get a new variable."""
750         # Use a character invalid in python identifiers to avoid clashing.
751         name = "@py_assert" + str(next(self.variable_counter))
752         self.variables.append(name)
753         return name
754 
755     def assign(self, expr: ast.expr) -> ast.Name:
756         """Give *expr* a name."""
757         name = self.variable()
758         self.statements.append(ast.Assign([ast.Name(name, ast.Store())], expr))
759         return ast.Name(name, ast.Load())
760 
761     def display(self, expr: ast.expr) -> ast.expr:
762         """Call saferepr on the expression."""
763         return self.helper("_saferepr", expr)
764 
765     def helper(self, name: str, *args: ast.expr) -> ast.expr:
766         """Call a helper in this module."""
767         py_name = ast.Name("@pytest_ar", ast.Load())
768         attr = ast.Attribute(py_name, name, ast.Load())
769         return ast.Call(attr, list(args), [])
770 
771     def builtin(self, name: str) -> ast.Attribute:
772         """Return the builtin called *name*."""
773         builtin_name = ast.Name("@py_builtins", ast.Load())
774         return ast.Attribute(builtin_name, name, ast.Load())
775 
776     def explanation_param(self, expr: ast.expr) -> str:
777         """Return a new named %-formatting placeholder for expr.
778 
779         This creates a %-formatting placeholder for expr in the
780         current formatting context, e.g. ``%(py0)s``.  The placeholder
781         and expr are placed in the current format context so that it
782         can be used on the next call to .pop_format_context().
783         """
784         specifier = "py" + str(next(self.variable_counter))
785         self.explanation_specifiers[specifier] = expr
786         return "%(" + specifier + ")s"
787 
788     def push_format_context(self) -> None:
789         """Create a new formatting context.
790 
791         The format context is used for when an explanation wants to
792         have a variable value formatted in the assertion message.  In
793         this case the value required can be added using
794         .explanation_param().  Finally .pop_format_context() is used
795         to format a string of %-formatted values as added by
796         .explanation_param().
797         """
798         self.explanation_specifiers: Dict[str, ast.expr] = {}
799         self.stack.append(self.explanation_specifiers)
800 
801     def pop_format_context(self, expl_expr: ast.expr) -> ast.Name:
802         """Format the %-formatted string with current format context.
803 
804         The expl_expr should be an str ast.expr instance constructed from
805         the %-placeholders created by .explanation_param().  This will
806         add the required code to format said string to .expl_stmts and
807         return the ast.Name instance of the formatted string.
808         """
809         current = self.stack.pop()
810         if self.stack:
811             self.explanation_specifiers = self.stack[-1]
812         keys = [ast.Constant(key) for key in current.keys()]
813         format_dict = ast.Dict(keys, list(current.values()))
814         form = ast.BinOp(expl_expr, ast.Mod(), format_dict)
815         name = "@py_format" + str(next(self.variable_counter))
816         if self.enable_assertion_pass_hook:
817             self.format_variables.append(name)
818         self.expl_stmts.append(ast.Assign([ast.Name(name, ast.Store())], form))
819         return ast.Name(name, ast.Load())
820 
821     def generic_visit(self, node: ast.AST) -> Tuple[ast.Name, str]:
822         """Handle expressions we don't have custom code for."""
823         assert isinstance(node, ast.expr)
824         res = self.assign(node)
825         return res, self.explanation_param(self.display(res))
826 
827     def visit_Assert(self, assert_: ast.Assert) -> List[ast.stmt]:
828         """Return the AST statements to replace the ast.Assert instance.
829 
830         This rewrites the test of an assertion to provide
831         intermediate values and replace it with an if statement which
832         raises an assertion error with a detailed explanation in case
833         the expression is false.
834         """
835         if isinstance(assert_.test, ast.Tuple) and len(assert_.test.elts) >= 1:
836             from _pytest.warning_types import PytestAssertRewriteWarning
837             import warnings
838 
839             # TODO: This assert should not be needed.
840             assert self.module_path is not None
841             warnings.warn_explicit(
842                 PytestAssertRewriteWarning(
843                     "assertion is always true, perhaps remove parentheses?"
844                 ),
845                 category=None,
846                 filename=self.module_path,
847                 lineno=assert_.lineno,
848             )
849 
850         self.statements: List[ast.stmt] = []
851         self.variables: List[str] = []
852         self.variable_counter = itertools.count()
853 
854         if self.enable_assertion_pass_hook:
855             self.format_variables: List[str] = []
856 
857         self.stack: List[Dict[str, ast.expr]] = []
858         self.expl_stmts: List[ast.stmt] = []
859         self.push_format_context()
860         # Rewrite assert into a bunch of statements.
861         top_condition, explanation = self.visit(assert_.test)
862 
863         negation = ast.UnaryOp(ast.Not(), top_condition)
864 
865         if self.enable_assertion_pass_hook:  # Experimental pytest_assertion_pass hook
866             msg = self.pop_format_context(ast.Constant(explanation))
867 
868             # Failed
869             if assert_.msg:
870                 assertmsg = self.helper("_format_assertmsg", assert_.msg)
871                 gluestr = "\n>assert "
872             else:
873                 assertmsg = ast.Constant("")
874                 gluestr = "assert "
875             err_explanation = ast.BinOp(ast.Constant(gluestr), ast.Add(), msg)
876             err_msg = ast.BinOp(assertmsg, ast.Add(), err_explanation)
877             err_name = ast.Name("AssertionError", ast.Load())
878             fmt = self.helper("_format_explanation", err_msg)
879             exc = ast.Call(err_name, [fmt], [])
880             raise_ = ast.Raise(exc, None)
881             statements_fail = []
882             statements_fail.extend(self.expl_stmts)
883             statements_fail.append(raise_)
884 
885             # Passed
886             fmt_pass = self.helper("_format_explanation", msg)
887             orig = _get_assertion_exprs(self.source)[assert_.lineno]
888             hook_call_pass = ast.Expr(
889                 self.helper(
890                     "_call_assertion_pass",
891                     ast.Constant(assert_.lineno),
892                     ast.Constant(orig),
893                     fmt_pass,
894                 )
895             )
896             # If any hooks implement assert_pass hook
897             hook_impl_test = ast.If(
898                 self.helper("_check_if_assertion_pass_impl"),
899                 self.expl_stmts + [hook_call_pass],
900                 [],
901             )
902             statements_pass = [hook_impl_test]
903 
904             # Test for assertion condition
905             main_test = ast.If(negation, statements_fail, statements_pass)
906             self.statements.append(main_test)
907             if self.format_variables:
908                 variables = [
909                     ast.Name(name, ast.Store()) for name in self.format_variables
910                 ]
911                 clear_format = ast.Assign(variables, ast.Constant(None))
912                 self.statements.append(clear_format)
913 
914         else:  # Original assertion rewriting
915             # Create failure message.
916             body = self.expl_stmts
917             self.statements.append(ast.If(negation, body, []))
918             if assert_.msg:
919                 assertmsg = self.helper("_format_assertmsg", assert_.msg)
920                 explanation = "\n>assert " + explanation
921             else:
922                 assertmsg = ast.Constant("")
923                 explanation = "assert " + explanation
924             template = ast.BinOp(assertmsg, ast.Add(), ast.Constant(explanation))
925             msg = self.pop_format_context(template)
926             fmt = self.helper("_format_explanation", msg)
927             err_name = ast.Name("AssertionError", ast.Load())
928             exc = ast.Call(err_name, [fmt], [])
929             raise_ = ast.Raise(exc, None)
930 
931             body.append(raise_)
932 
933         # Clear temporary variables by setting them to None.
934         if self.variables:
935             variables = [ast.Name(name, ast.Store()) for name in self.variables]
936             clear = ast.Assign(variables, ast.Constant(None))
937             self.statements.append(clear)
938         # Fix locations (line numbers/column offsets).
939         for stmt in self.statements:
940             for node in traverse_node(stmt):
941                 ast.copy_location(node, assert_)
942         return self.statements
943 
944     def visit_NamedExpr(self, name: ast.NamedExpr) -> Tuple[ast.NamedExpr, str]:
945         # This method handles the 'walrus operator' repr of the target
946         # name if it's a local variable or _should_repr_global_name()
947         # thinks it's acceptable.
948         locs = ast.Call(self.builtin("locals"), [], [])
949         target_id = name.target.id  # type: ignore[attr-defined]
950         inlocs = ast.Compare(ast.Constant(target_id), [ast.In()], [locs])
951         dorepr = self.helper("_should_repr_global_name", name)
952         test = ast.BoolOp(ast.Or(), [inlocs, dorepr])
953         expr = ast.IfExp(test, self.display(name), ast.Constant(target_id))
954         return name, self.explanation_param(expr)
955 
956     def visit_Name(self, name: ast.Name) -> Tuple[ast.Name, str]:
957         # Display the repr of the name if it's a local variable or
958         # _should_repr_global_name() thinks it's acceptable.
959         locs = ast.Call(self.builtin("locals"), [], [])
960         inlocs = ast.Compare(ast.Constant(name.id), [ast.In()], [locs])
961         dorepr = self.helper("_should_repr_global_name", name)
962         test = ast.BoolOp(ast.Or(), [inlocs, dorepr])
963         expr = ast.IfExp(test, self.display(name), ast.Constant(name.id))
964         return name, self.explanation_param(expr)
965 
966     def visit_BoolOp(self, boolop: ast.BoolOp) -> Tuple[ast.Name, str]:
967         res_var = self.variable()
968         expl_list = self.assign(ast.List([], ast.Load()))
969         app = ast.Attribute(expl_list, "append", ast.Load())
970         is_or = int(isinstance(boolop.op, ast.Or))
971         body = save = self.statements
972         fail_save = self.expl_stmts
973         levels = len(boolop.values) - 1
974         self.push_format_context()
975         # Process each operand, short-circuiting if needed.
976         for i, v in enumerate(boolop.values):
977             if i:
978                 fail_inner: List[ast.stmt] = []
979                 # cond is set in a prior loop iteration below
980                 self.expl_stmts.append(ast.If(cond, fail_inner, []))  # noqa
981                 self.expl_stmts = fail_inner
982                 # Check if the left operand is a ast.NamedExpr and the value has already been visited
983                 if (
984                     isinstance(v, ast.Compare)
985                     and isinstance(v.left, ast.NamedExpr)
986                     and v.left.target.id
987                     in [
988                         ast_expr.id
989                         for ast_expr in boolop.values[:i]
990                         if hasattr(ast_expr, "id")
991                     ]
992                 ):
993                     pytest_temp = self.variable()
994                     self.variables_overwrite[
995                         v.left.target.id
996                     ] = v.left  # type:ignore[assignment]
997                     v.left.target.id = pytest_temp
998             self.push_format_context()
999             res, expl = self.visit(v)
1000             body.append(ast.Assign([ast.Name(res_var, ast.Store())], res))
1001             expl_format = self.pop_format_context(ast.Constant(expl))
1002             call = ast.Call(app, [expl_format], [])
1003             self.expl_stmts.append(ast.Expr(call))
1004             if i < levels:
1005                 cond: ast.expr = res
1006                 if is_or:
1007                     cond = ast.UnaryOp(ast.Not(), cond)
1008                 inner: List[ast.stmt] = []
1009                 self.statements.append(ast.If(cond, inner, []))
1010                 self.statements = body = inner
1011         self.statements = save
1012         self.expl_stmts = fail_save
1013         expl_template = self.helper("_format_boolop", expl_list, ast.Constant(is_or))
1014         expl = self.pop_format_context(expl_template)
1015         return ast.Name(res_var, ast.Load()), self.explanation_param(expl)
1016 
1017     def visit_UnaryOp(self, unary: ast.UnaryOp) -> Tuple[ast.Name, str]:
1018         pattern = UNARY_MAP[unary.op.__class__]
1019         operand_res, operand_expl = self.visit(unary.operand)
1020         res = self.assign(ast.UnaryOp(unary.op, operand_res))
1021         return res, pattern % (operand_expl,)
1022 
1023     def visit_BinOp(self, binop: ast.BinOp) -> Tuple[ast.Name, str]:
1024         symbol = BINOP_MAP[binop.op.__class__]
1025         left_expr, left_expl = self.visit(binop.left)
1026         right_expr, right_expl = self.visit(binop.right)
1027         explanation = f"({left_expl} {symbol} {right_expl})"
1028         res = self.assign(ast.BinOp(left_expr, binop.op, right_expr))
1029         return res, explanation
1030 
1031     def visit_Call(self, call: ast.Call) -> Tuple[ast.Name, str]:
1032         new_func, func_expl = self.visit(call.func)
1033         arg_expls = []
1034         new_args = []
1035         new_kwargs = []
1036         for arg in call.args:
1037             if isinstance(arg, ast.Name) and arg.id in self.variables_overwrite:
1038                 arg = self.variables_overwrite[arg.id]  # type:ignore[assignment]
1039             res, expl = self.visit(arg)
1040             arg_expls.append(expl)
1041             new_args.append(res)
1042         for keyword in call.keywords:
1043             if (
1044                 isinstance(keyword.value, ast.Name)
1045                 and keyword.value.id in self.variables_overwrite
1046             ):
1047                 keyword.value = self.variables_overwrite[
1048                     keyword.value.id
1049                 ]  # type:ignore[assignment]
1050             res, expl = self.visit(keyword.value)
1051             new_kwargs.append(ast.keyword(keyword.arg, res))
1052             if keyword.arg:
1053                 arg_expls.append(keyword.arg + "=" + expl)
1054             else:  # **args have `arg` keywords with an .arg of None
1055                 arg_expls.append("**" + expl)
1056 
1057         expl = "{}({})".format(func_expl, ", ".join(arg_expls))
1058         new_call = ast.Call(new_func, new_args, new_kwargs)
1059         res = self.assign(new_call)
1060         res_expl = self.explanation_param(self.display(res))
1061         outer_expl = f"{res_expl}\n{{{res_expl} = {expl}\n}}"
1062         return res, outer_expl
1063 
1064     def visit_Starred(self, starred: ast.Starred) -> Tuple[ast.Starred, str]:
1065         # A Starred node can appear in a function call.
1066         res, expl = self.visit(starred.value)
1067         new_starred = ast.Starred(res, starred.ctx)
1068         return new_starred, "*" + expl
1069 
1070     def visit_Attribute(self, attr: ast.Attribute) -> Tuple[ast.Name, str]:
1071         if not isinstance(attr.ctx, ast.Load):
1072             return self.generic_visit(attr)
1073         value, value_expl = self.visit(attr.value)
1074         res = self.assign(ast.Attribute(value, attr.attr, ast.Load()))
1075         res_expl = self.explanation_param(self.display(res))
1076         pat = "%s\n{%s = %s.%s\n}"
1077         expl = pat % (res_expl, res_expl, value_expl, attr.attr)
1078         return res, expl
1079 
1080     def visit_Compare(self, comp: ast.Compare) -> Tuple[ast.expr, str]:
1081         self.push_format_context()
1082         # We first check if we have overwritten a variable in the previous assert
1083         if isinstance(comp.left, ast.Name) and comp.left.id in self.variables_overwrite:
1084             comp.left = self.variables_overwrite[
1085                 comp.left.id
1086             ]  # type:ignore[assignment]
1087         if isinstance(comp.left, ast.NamedExpr):
1088             self.variables_overwrite[
1089                 comp.left.target.id
1090             ] = comp.left  # type:ignore[assignment]
1091         left_res, left_expl = self.visit(comp.left)
1092         if isinstance(comp.left, (ast.Compare, ast.BoolOp)):
1093             left_expl = f"({left_expl})"
1094         res_variables = [self.variable() for i in range(len(comp.ops))]
1095         load_names = [ast.Name(v, ast.Load()) for v in res_variables]
1096         store_names = [ast.Name(v, ast.Store()) for v in res_variables]
1097         it = zip(range(len(comp.ops)), comp.ops, comp.comparators)
1098         expls = []
1099         syms = []
1100         results = [left_res]
1101         for i, op, next_operand in it:
1102             if (
1103                 isinstance(next_operand, ast.NamedExpr)
1104                 and isinstance(left_res, ast.Name)
1105                 and next_operand.target.id == left_res.id
1106             ):
1107                 next_operand.target.id = self.variable()
1108                 self.variables_overwrite[
1109                     left_res.id
1110                 ] = next_operand  # type:ignore[assignment]
1111             next_res, next_expl = self.visit(next_operand)
1112             if isinstance(next_operand, (ast.Compare, ast.BoolOp)):
1113                 next_expl = f"({next_expl})"
1114             results.append(next_res)
1115             sym = BINOP_MAP[op.__class__]
1116             syms.append(ast.Constant(sym))
1117             expl = f"{left_expl} {sym} {next_expl}"
1118             expls.append(ast.Constant(expl))
1119             res_expr = ast.Compare(left_res, [op], [next_res])
1120             self.statements.append(ast.Assign([store_names[i]], res_expr))
1121             left_res, left_expl = next_res, next_expl
1122         # Use pytest.assertion.util._reprcompare if that's available.
1123         expl_call = self.helper(
1124             "_call_reprcompare",
1125             ast.Tuple(syms, ast.Load()),
1126             ast.Tuple(load_names, ast.Load()),
1127             ast.Tuple(expls, ast.Load()),
1128             ast.Tuple(results, ast.Load()),
1129         )
1130         if len(comp.ops) > 1:
1131             res: ast.expr = ast.BoolOp(ast.And(), load_names)
1132         else:
1133             res = load_names[0]
1134 
1135         return res, self.explanation_param(self.pop_format_context(expl_call))
1136 
1137 
1138 def try_makedirs(cache_dir: Path) -> bool:
1139     """Attempt to create the given directory and sub-directories exist.
1140 
1141     Returns True if successful or if it already exists.
1142     """
1143     try:
1144         os.makedirs(cache_dir, exist_ok=True)
1145     except (FileNotFoundError, NotADirectoryError, FileExistsError):
1146         # One of the path components was not a directory:
1147         # - we're in a zip file
1148         # - it is a file
1149         return False
1150     except PermissionError:
1151         return False
1152     except OSError as e:
1153         # as of now, EROFS doesn't have an equivalent OSError-subclass
1154         if e.errno == errno.EROFS:
1155             return False
1156         raise
1157     return True
1158 
1159 
1160 def get_cache_dir(file_path: Path) -> Path:
1161     """Return the cache directory to write .pyc files for the given .py file path."""
1162     if sys.pycache_prefix:
1163         # given:
1164         #   prefix = '/tmp/pycs'
1165         #   path = '/home/user/proj/test_app.py'
1166         # we want:
1167         #   '/tmp/pycs/home/user/proj'
1168         return Path(sys.pycache_prefix) / Path(*file_path.parts[1:-1])
1169     else:
1170         # classic pycache directory
1171         return file_path.parent / "__pycache__"

</code><intended_behavior>When using `importlib` for dynamic imports, the application should implement checks or strategies to avoid importing the same module under different names or paths, which could lead to the observed issue of having two different versions of `pmxbot.logging`. This might include enhancing the logic around module importation to reference or augment Python's import machinery, ensuring that `sys.modules` is appropriately managed to unify module instances.</intended_behavior>]
2025-10-18 16:15:41.443 | INFO     | Search completed. Bug locations: [<file>testing/test_pathlib.py</file>
<class>None</class>
<method>None</method>
<code>
1 import os.path
2 import pickle
3 import sys
4 import unittest.mock
5 from pathlib import Path
6 from textwrap import dedent
7 from types import ModuleType
8 from typing import Any
9 from typing import Generator
10 
11 import pytest
12 from _pytest.monkeypatch import MonkeyPatch
13 from _pytest.pathlib import bestrelpath
14 from _pytest.pathlib import commonpath
15 from _pytest.pathlib import ensure_deletable
16 from _pytest.pathlib import fnmatch_ex
17 from _pytest.pathlib import get_extended_length_path_str
18 from _pytest.pathlib import get_lock_path
19 from _pytest.pathlib import import_path
20 from _pytest.pathlib import ImportPathMismatchError
21 from _pytest.pathlib import insert_missing_modules
22 from _pytest.pathlib import maybe_delete_a_numbered_dir
23 from _pytest.pathlib import module_name_from_path
24 from _pytest.pathlib import resolve_package_path
25 from _pytest.pathlib import symlink_or_skip
26 from _pytest.pathlib import visit
27 from _pytest.tmpdir import TempPathFactory
28 
29 
30 class TestFNMatcherPort:
31     """Test our port of py.common.FNMatcher (fnmatch_ex)."""
32 
33     if sys.platform == "win32":
34         drv1 = "c:"
35         drv2 = "d:"
36     else:
37         drv1 = "/c"
38         drv2 = "/d"
39 
40     @pytest.mark.parametrize(
41         "pattern, path",
42         [
43             ("*.py", "foo.py"),
44             ("*.py", "bar/foo.py"),
45             ("test_*.py", "foo/test_foo.py"),
46             ("tests/*.py", "tests/foo.py"),
47             (f"{drv1}/*.py", f"{drv1}/foo.py"),
48             (f"{drv1}/foo/*.py", f"{drv1}/foo/foo.py"),
49             ("tests/**/test*.py", "tests/foo/test_foo.py"),
50             ("tests/**/doc/test*.py", "tests/foo/bar/doc/test_foo.py"),
51             ("tests/**/doc/**/test*.py", "tests/foo/doc/bar/test_foo.py"),
52         ],
53     )
54     def test_matching(self, pattern: str, path: str) -> None:
55         assert fnmatch_ex(pattern, path)
56 
57     def test_matching_abspath(self) -> None:
58         abspath = os.path.abspath(os.path.join("tests/foo.py"))
59         assert fnmatch_ex("tests/foo.py", abspath)
60 
61     @pytest.mark.parametrize(
62         "pattern, path",
63         [
64             ("*.py", "foo.pyc"),
65             ("*.py", "foo/foo.pyc"),
66             ("tests/*.py", "foo/foo.py"),
67             (f"{drv1}/*.py", f"{drv2}/foo.py"),
68             (f"{drv1}/foo/*.py", f"{drv2}/foo/foo.py"),
69             ("tests/**/test*.py", "tests/foo.py"),
70             ("tests/**/test*.py", "foo/test_foo.py"),
71             ("tests/**/doc/test*.py", "tests/foo/bar/doc/foo.py"),
72             ("tests/**/doc/test*.py", "tests/foo/bar/test_foo.py"),
73         ],
74     )
75     def test_not_matching(self, pattern: str, path: str) -> None:
76         assert not fnmatch_ex(pattern, path)
77 
78 
79 class TestImportPath:
80     """
81 
82     Most of the tests here were copied from py lib's tests for "py.local.path.pyimport".
83 
84     Having our own pyimport-like function is inline with removing py.path dependency in the future.
85     """
86 
87     @pytest.fixture(scope="session")
88     def path1(self, tmp_path_factory: TempPathFactory) -> Generator[Path, None, None]:
89         path = tmp_path_factory.mktemp("path")
90         self.setuptestfs(path)
91         yield path
92         assert path.joinpath("samplefile").exists()
93 
94     @pytest.fixture(autouse=True)
95     def preserve_sys(self):
96         with unittest.mock.patch.dict(sys.modules):
97             with unittest.mock.patch.object(sys, "path", list(sys.path)):
98                 yield
99 
100     def setuptestfs(self, path: Path) -> None:
101         # print "setting up test fs for", repr(path)
102         samplefile = path / "samplefile"
103         samplefile.write_text("samplefile\n", encoding="utf-8")
104 
105         execfile = path / "execfile"
106         execfile.write_text("x=42", encoding="utf-8")
107 
108         execfilepy = path / "execfile.py"
109         execfilepy.write_text("x=42", encoding="utf-8")
110 
111         d = {1: 2, "hello": "world", "answer": 42}
112         path.joinpath("samplepickle").write_bytes(pickle.dumps(d, 1))
113 
114         sampledir = path / "sampledir"
115         sampledir.mkdir()
116         sampledir.joinpath("otherfile").touch()
117 
118         otherdir = path / "otherdir"
119         otherdir.mkdir()
120         otherdir.joinpath("__init__.py").touch()
121 
122         module_a = otherdir / "a.py"
123         module_a.write_text("from .b import stuff as result\n", encoding="utf-8")
124         module_b = otherdir / "b.py"
125         module_b.write_text('stuff="got it"\n', encoding="utf-8")
126         module_c = otherdir / "c.py"
127         module_c.write_text(
128             dedent(
129                 """
130             import pluggy;
131             import otherdir.a
132             value = otherdir.a.result
133         """
134             ),
135             encoding="utf-8",
136         )
137         module_d = otherdir / "d.py"
138         module_d.write_text(
139             dedent(
140                 """
141             import pluggy;
142             from otherdir import a
143             value2 = a.result
144         """
145             ),
146             encoding="utf-8",
147         )
148 
149     def test_smoke_test(self, path1: Path) -> None:
150         obj = import_path(path1 / "execfile.py", root=path1)
151         assert obj.x == 42  # type: ignore[attr-defined]
152         assert obj.__name__ == "execfile"
153 
154     def test_import_path_missing_file(self, path1: Path) -> None:
155         with pytest.raises(ImportPathMismatchError):
156             import_path(path1 / "sampledir", root=path1)
157 
158     def test_renamed_dir_creates_mismatch(
159         self, tmp_path: Path, monkeypatch: MonkeyPatch
160     ) -> None:
161         tmp_path.joinpath("a").mkdir()
162         p = tmp_path.joinpath("a", "test_x123.py")
163         p.touch()
164         import_path(p, root=tmp_path)
165         tmp_path.joinpath("a").rename(tmp_path.joinpath("b"))
166         with pytest.raises(ImportPathMismatchError):
167             import_path(tmp_path.joinpath("b", "test_x123.py"), root=tmp_path)
168 
169         # Errors can be ignored.
170         monkeypatch.setenv("PY_IGNORE_IMPORTMISMATCH", "1")
171         import_path(tmp_path.joinpath("b", "test_x123.py"), root=tmp_path)
172 
173         # PY_IGNORE_IMPORTMISMATCH=0 does not ignore error.
174         monkeypatch.setenv("PY_IGNORE_IMPORTMISMATCH", "0")
175         with pytest.raises(ImportPathMismatchError):
176             import_path(tmp_path.joinpath("b", "test_x123.py"), root=tmp_path)
177 
178     def test_messy_name(self, tmp_path: Path) -> None:
179         # https://bitbucket.org/hpk42/py-trunk/issue/129
180         path = tmp_path / "foo__init__.py"
181         path.touch()
182         module = import_path(path, root=tmp_path)
183         assert module.__name__ == "foo__init__"
184 
185     def test_dir(self, tmp_path: Path) -> None:
186         p = tmp_path / "hello_123"
187         p.mkdir()
188         p_init = p / "__init__.py"
189         p_init.touch()
190         m = import_path(p, root=tmp_path)
191         assert m.__name__ == "hello_123"
192         m = import_path(p_init, root=tmp_path)
193         assert m.__name__ == "hello_123"
194 
195     def test_a(self, path1: Path) -> None:
196         otherdir = path1 / "otherdir"
197         mod = import_path(otherdir / "a.py", root=path1)
198         assert mod.result == "got it"  # type: ignore[attr-defined]
199         assert mod.__name__ == "otherdir.a"
200 
201     def test_b(self, path1: Path) -> None:
202         otherdir = path1 / "otherdir"
203         mod = import_path(otherdir / "b.py", root=path1)
204         assert mod.stuff == "got it"  # type: ignore[attr-defined]
205         assert mod.__name__ == "otherdir.b"
206 
207     def test_c(self, path1: Path) -> None:
208         otherdir = path1 / "otherdir"
209         mod = import_path(otherdir / "c.py", root=path1)
210         assert mod.value == "got it"  # type: ignore[attr-defined]
211 
212     def test_d(self, path1: Path) -> None:
213         otherdir = path1 / "otherdir"
214         mod = import_path(otherdir / "d.py", root=path1)
215         assert mod.value2 == "got it"  # type: ignore[attr-defined]
216 
217     def test_import_after(self, tmp_path: Path) -> None:
218         tmp_path.joinpath("xxxpackage").mkdir()
219         tmp_path.joinpath("xxxpackage", "__init__.py").touch()
220         mod1path = tmp_path.joinpath("xxxpackage", "module1.py")
221         mod1path.touch()
222         mod1 = import_path(mod1path, root=tmp_path)
223         assert mod1.__name__ == "xxxpackage.module1"
224         from xxxpackage import module1
225 
226         assert module1 is mod1
227 
228     def test_check_filepath_consistency(
229         self, monkeypatch: MonkeyPatch, tmp_path: Path
230     ) -> None:
231         name = "pointsback123"
232         p = tmp_path.joinpath(name + ".py")
233         p.touch()
234         for ending in (".pyc", ".pyo"):
235             mod = ModuleType(name)
236             pseudopath = tmp_path.joinpath(name + ending)
237             pseudopath.touch()
238             mod.__file__ = str(pseudopath)
239             monkeypatch.setitem(sys.modules, name, mod)
240             newmod = import_path(p, root=tmp_path)
241             assert mod == newmod
242         monkeypatch.undo()
243         mod = ModuleType(name)
244         pseudopath = tmp_path.joinpath(name + "123.py")
245         pseudopath.touch()
246         mod.__file__ = str(pseudopath)
247         monkeypatch.setitem(sys.modules, name, mod)
248         with pytest.raises(ImportPathMismatchError) as excinfo:
249             import_path(p, root=tmp_path)
250         modname, modfile, orig = excinfo.value.args
251         assert modname == name
252         assert modfile == str(pseudopath)
253         assert orig == p
254         assert issubclass(ImportPathMismatchError, ImportError)
255 
256     def test_issue131_on__init__(self, tmp_path: Path) -> None:
257         # __init__.py files may be namespace packages, and thus the
258         # __file__ of an imported module may not be ourselves
259         # see issue
260         tmp_path.joinpath("proja").mkdir()
261         p1 = tmp_path.joinpath("proja", "__init__.py")
262         p1.touch()
263         tmp_path.joinpath("sub", "proja").mkdir(parents=True)
264         p2 = tmp_path.joinpath("sub", "proja", "__init__.py")
265         p2.touch()
266         m1 = import_path(p1, root=tmp_path)
267         m2 = import_path(p2, root=tmp_path)
268         assert m1 == m2
269 
270     def test_ensuresyspath_append(self, tmp_path: Path) -> None:
271         root1 = tmp_path / "root1"
272         root1.mkdir()
273         file1 = root1 / "x123.py"
274         file1.touch()
275         assert str(root1) not in sys.path
276         import_path(file1, mode="append", root=tmp_path)
277         assert str(root1) == sys.path[-1]
278         assert str(root1) not in sys.path[:-1]
279 
280     def test_invalid_path(self, tmp_path: Path) -> None:
281         with pytest.raises(ImportError):
282             import_path(tmp_path / "invalid.py", root=tmp_path)
283 
284     @pytest.fixture
285     def simple_module(self, tmp_path: Path) -> Path:
286         fn = tmp_path / "_src/tests/mymod.py"
287         fn.parent.mkdir(parents=True)
288         fn.write_text("def foo(x): return 40 + x", encoding="utf-8")
289         return fn
290 
291     def test_importmode_importlib(self, simple_module: Path, tmp_path: Path) -> None:
292         """`importlib` mode does not change sys.path."""
293         module = import_path(simple_module, mode="importlib", root=tmp_path)
294         assert module.foo(2) == 42  # type: ignore[attr-defined]
295         assert str(simple_module.parent) not in sys.path
296         assert module.__name__ in sys.modules
297         assert module.__name__ == "_src.tests.mymod"
298         assert "_src" in sys.modules
299         assert "_src.tests" in sys.modules
300 
301     def test_importmode_twice_is_different_module(
302         self, simple_module: Path, tmp_path: Path
303     ) -> None:
304         """`importlib` mode always returns a new module."""
305         module1 = import_path(simple_module, mode="importlib", root=tmp_path)
306         module2 = import_path(simple_module, mode="importlib", root=tmp_path)
307         assert module1 is not module2
308 
309     def test_no_meta_path_found(
310         self, simple_module: Path, monkeypatch: MonkeyPatch, tmp_path: Path
311     ) -> None:
312         """Even without any meta_path should still import module."""
313         monkeypatch.setattr(sys, "meta_path", [])
314         module = import_path(simple_module, mode="importlib", root=tmp_path)
315         assert module.foo(2) == 42  # type: ignore[attr-defined]
316 
317         # mode='importlib' fails if no spec is found to load the module
318         import importlib.util
319 
320         monkeypatch.setattr(
321             importlib.util, "spec_from_file_location", lambda *args: None
322         )
323         with pytest.raises(ImportError):
324             import_path(simple_module, mode="importlib", root=tmp_path)
325 
326 
327 def test_resolve_package_path(tmp_path: Path) -> None:
328     pkg = tmp_path / "pkg1"
329     pkg.mkdir()
330     (pkg / "__init__.py").touch()
331     (pkg / "subdir").mkdir()
332     (pkg / "subdir/__init__.py").touch()
333     assert resolve_package_path(pkg) == pkg
334     assert resolve_package_path(pkg.joinpath("subdir", "__init__.py")) == pkg
335 
336 
337 def test_package_unimportable(tmp_path: Path) -> None:
338     pkg = tmp_path / "pkg1-1"
339     pkg.mkdir()
340     pkg.joinpath("__init__.py").touch()
341     subdir = pkg.joinpath("subdir")
342     subdir.mkdir()
343     pkg.joinpath("subdir/__init__.py").touch()
344     assert resolve_package_path(subdir) == subdir
345     xyz = subdir.joinpath("xyz.py")
346     xyz.touch()
347     assert resolve_package_path(xyz) == subdir
348     assert not resolve_package_path(pkg)
349 
350 
351 def test_access_denied_during_cleanup(tmp_path: Path, monkeypatch: MonkeyPatch) -> None:
352     """Ensure that deleting a numbered dir does not fail because of OSErrors (#4262)."""
353     path = tmp_path / "temp-1"
354     path.mkdir()
355 
356     def renamed_failed(*args):
357         raise OSError("access denied")
358 
359     monkeypatch.setattr(Path, "rename", renamed_failed)
360 
361     lock_path = get_lock_path(path)
362     maybe_delete_a_numbered_dir(path)
363     assert not lock_path.is_file()
364 
365 
366 def test_long_path_during_cleanup(tmp_path: Path) -> None:
367     """Ensure that deleting long path works (particularly on Windows (#6775))."""
368     path = (tmp_path / ("a" * 250)).resolve()
369     if sys.platform == "win32":
370         # make sure that the full path is > 260 characters without any
371         # component being over 260 characters
372         assert len(str(path)) > 260
373         extended_path = "\\\\?\\" + str(path)
374     else:
375         extended_path = str(path)
376     os.mkdir(extended_path)
377     assert os.path.isdir(extended_path)
378     maybe_delete_a_numbered_dir(path)
379     assert not os.path.isdir(extended_path)
380 
381 
382 def test_get_extended_length_path_str() -> None:
383     assert get_extended_length_path_str(r"c:\foo") == r"\\?\c:\foo"
384     assert get_extended_length_path_str(r"\\share\foo") == r"\\?\UNC\share\foo"
385     assert get_extended_length_path_str(r"\\?\UNC\share\foo") == r"\\?\UNC\share\foo"
386     assert get_extended_length_path_str(r"\\?\c:\foo") == r"\\?\c:\foo"
387 
388 
389 def test_suppress_error_removing_lock(tmp_path: Path) -> None:
390     """ensure_deletable should be resilient if lock file cannot be removed (#5456, #7491)"""
391     path = tmp_path / "dir"
392     path.mkdir()
393     lock = get_lock_path(path)
394     lock.touch()
395     mtime = lock.stat().st_mtime
396 
397     with unittest.mock.patch.object(Path, "unlink", side_effect=OSError) as m:
398         assert not ensure_deletable(
399             path, consider_lock_dead_if_created_before=mtime + 30
400         )
401         assert m.call_count == 1
402     assert lock.is_file()
403 
404     with unittest.mock.patch.object(Path, "is_file", side_effect=OSError) as m:
405         assert not ensure_deletable(
406             path, consider_lock_dead_if_created_before=mtime + 30
407         )
408         assert m.call_count == 1
409     assert lock.is_file()
410 
411     # check now that we can remove the lock file in normal circumstances
412     assert ensure_deletable(path, consider_lock_dead_if_created_before=mtime + 30)
413     assert not lock.is_file()
414 
415 
416 def test_bestrelpath() -> None:
417     curdir = Path("/foo/bar/baz/path")
418     assert bestrelpath(curdir, curdir) == "."
419     assert bestrelpath(curdir, curdir / "hello" / "world") == "hello" + os.sep + "world"
420     assert bestrelpath(curdir, curdir.parent / "sister") == ".." + os.sep + "sister"
421     assert bestrelpath(curdir, curdir.parent) == ".."
422     assert bestrelpath(curdir, Path("hello")) == "hello"
423 
424 
425 def test_commonpath() -> None:
426     path = Path("/foo/bar/baz/path")
427     subpath = path / "sampledir"
428     assert commonpath(path, subpath) == path
429     assert commonpath(subpath, path) == path
430     assert commonpath(Path(str(path) + "suffix"), path) == path.parent
431     assert commonpath(path, path.parent.parent) == path.parent.parent
432 
433 
434 def test_visit_ignores_errors(tmp_path: Path) -> None:
435     symlink_or_skip("recursive", tmp_path / "recursive")
436     tmp_path.joinpath("foo").write_bytes(b"")
437     tmp_path.joinpath("bar").write_bytes(b"")
438 
439     assert [
440         entry.name for entry in visit(str(tmp_path), recurse=lambda entry: False)
441     ] == ["bar", "foo"]
442 
443 
444 @pytest.mark.skipif(not sys.platform.startswith("win"), reason="Windows only")
445 def test_samefile_false_negatives(tmp_path: Path, monkeypatch: MonkeyPatch) -> None:
446     """
447     import_file() should not raise ImportPathMismatchError if the paths are exactly
448     equal on Windows. It seems directories mounted as UNC paths make os.path.samefile
449     return False, even when they are clearly equal.
450     """
451     module_path = tmp_path.joinpath("my_module.py")
452     module_path.write_text("def foo(): return 42", encoding="utf-8")
453     monkeypatch.syspath_prepend(tmp_path)
454 
455     with monkeypatch.context() as mp:
456         # Forcibly make os.path.samefile() return False here to ensure we are comparing
457         # the paths too. Using a context to narrow the patch as much as possible given
458         # this is an important system function.
459         mp.setattr(os.path, "samefile", lambda x, y: False)
460         module = import_path(module_path, root=tmp_path)
461     assert getattr(module, "foo")() == 42
462 
463 
464 class TestImportLibMode:
465     def test_importmode_importlib_with_dataclass(self, tmp_path: Path) -> None:
466         """Ensure that importlib mode works with a module containing dataclasses (#7856)."""
467         fn = tmp_path.joinpath("_src/tests/test_dataclass.py")
468         fn.parent.mkdir(parents=True)
469         fn.write_text(
470             dedent(
471                 """
472                 from dataclasses import dataclass
473 
474                 @dataclass
475                 class Data:
476                     value: str
477                 """
478             ),
479             encoding="utf-8",
480         )
481 
482         module = import_path(fn, mode="importlib", root=tmp_path)
483         Data: Any = getattr(module, "Data")
484         data = Data(value="foo")
485         assert data.value == "foo"
486         assert data.__module__ == "_src.tests.test_dataclass"
487 
488     def test_importmode_importlib_with_pickle(self, tmp_path: Path) -> None:
489         """Ensure that importlib mode works with pickle (#7859)."""
490         fn = tmp_path.joinpath("_src/tests/test_pickle.py")
491         fn.parent.mkdir(parents=True)
492         fn.write_text(
493             dedent(
494                 """
495                 import pickle
496 
497                 def _action():
498                     return 42
499 
500                 def round_trip():
501                     s = pickle.dumps(_action)
502                     return pickle.loads(s)
503                 """
504             ),
505             encoding="utf-8",
506         )
507 
508         module = import_path(fn, mode="importlib", root=tmp_path)
509         round_trip = getattr(module, "round_trip")
510         action = round_trip()
511         assert action() == 42
512 
513     def test_importmode_importlib_with_pickle_separate_modules(
514         self, tmp_path: Path
515     ) -> None:
516         """
517         Ensure that importlib mode works can load pickles that look similar but are
518         defined in separate modules.
519         """
520         fn1 = tmp_path.joinpath("_src/m1/tests/test.py")
521         fn1.parent.mkdir(parents=True)
522         fn1.write_text(
523             dedent(
524                 """
525                 import dataclasses
526                 import pickle
527 
528                 @dataclasses.dataclass
529                 class Data:
530                     x: int = 42
531                 """
532             ),
533             encoding="utf-8",
534         )
535 
536         fn2 = tmp_path.joinpath("_src/m2/tests/test.py")
537         fn2.parent.mkdir(parents=True)
538         fn2.write_text(
539             dedent(
540                 """
541                 import dataclasses
542                 import pickle
543 
544                 @dataclasses.dataclass
545                 class Data:
546                     x: str = ""
547                 """
548             ),
549             encoding="utf-8",
550         )
551 
552         import pickle
553 
554         def round_trip(obj):
555             s = pickle.dumps(obj)
556             return pickle.loads(s)
557 
558         module = import_path(fn1, mode="importlib", root=tmp_path)
559         Data1 = getattr(module, "Data")
560 
561         module = import_path(fn2, mode="importlib", root=tmp_path)
562         Data2 = getattr(module, "Data")
563 
564         assert round_trip(Data1(20)) == Data1(20)
565         assert round_trip(Data2("hello")) == Data2("hello")
566         assert Data1.__module__ == "_src.m1.tests.test"
567         assert Data2.__module__ == "_src.m2.tests.test"
568 
569     def test_module_name_from_path(self, tmp_path: Path) -> None:
570         result = module_name_from_path(tmp_path / "src/tests/test_foo.py", tmp_path)
571         assert result == "src.tests.test_foo"
572 
573         # Path is not relative to root dir: use the full path to obtain the module name.
574         result = module_name_from_path(Path("/home/foo/test_foo.py"), Path("/bar"))
575         assert result == "home.foo.test_foo"
576 
577     def test_insert_missing_modules(
578         self, monkeypatch: MonkeyPatch, tmp_path: Path
579     ) -> None:
580         monkeypatch.chdir(tmp_path)
581         # Use 'xxx' and 'xxy' as parent names as they are unlikely to exist and
582         # don't end up being imported.
583         modules = {"xxx.tests.foo": ModuleType("xxx.tests.foo")}
584         insert_missing_modules(modules, "xxx.tests.foo")
585         assert sorted(modules) == ["xxx", "xxx.tests", "xxx.tests.foo"]
586 
587         mod = ModuleType("mod", doc="My Module")
588         modules = {"xxy": mod}
589         insert_missing_modules(modules, "xxy")
590         assert modules == {"xxy": mod}
591 
592         modules = {}
593         insert_missing_modules(modules, "")
594         assert modules == {}
595 
596     def test_parent_contains_child_module_attribute(
597         self, monkeypatch: MonkeyPatch, tmp_path: Path
598     ):
599         monkeypatch.chdir(tmp_path)
600         # Use 'xxx' and 'xxy' as parent names as they are unlikely to exist and
601         # don't end up being imported.
602         modules = {"xxx.tests.foo": ModuleType("xxx.tests.foo")}
603         insert_missing_modules(modules, "xxx.tests.foo")
604         assert sorted(modules) == ["xxx", "xxx.tests", "xxx.tests.foo"]
605         assert modules["xxx"].tests is modules["xxx.tests"]
606         assert modules["xxx.tests"].foo is modules["xxx.tests.foo"]

</code><intended_behavior>The code handling namespace packages, both in tests and possibly in the application's core logic (where similar patterns are likely to be present), should ensure consistent and correct import paths to prevent module duplication. This might involve verifying and adjusting how `importlib` is used to import modules part of a namespace package, ensuring that a single instance of each module is maintained across the application.</intended_behavior>, <file>testing/_py/test_local.py</file>
<class>None</class>
<method>None</method>
<code>
1 import contextlib
2 import multiprocessing
3 import os
4 import sys
5 import time
6 import warnings
7 from unittest import mock
8 
9 import pytest
10 from py import error
11 from py.path import local
12 
13 
14 @contextlib.contextmanager
15 def ignore_encoding_warning():
16     with warnings.catch_warnings():
17         with contextlib.suppress(NameError):  # new in 3.10
18             warnings.simplefilter("ignore", EncodingWarning)
19         yield
20 
21 
22 class CommonFSTests:
23     def test_constructor_equality(self, path1):
24         p = path1.__class__(path1)
25         assert p == path1
26 
27     def test_eq_nonstring(self, path1):
28         p1 = path1.join("sampledir")
29         p2 = path1.join("sampledir")
30         assert p1 == p2
31 
32     def test_new_identical(self, path1):
33         assert path1 == path1.new()
34 
35     def test_join(self, path1):
36         p = path1.join("sampledir")
37         strp = str(p)
38         assert strp.endswith("sampledir")
39         assert strp.startswith(str(path1))
40 
41     def test_join_normalized(self, path1):
42         newpath = path1.join(path1.sep + "sampledir")
43         strp = str(newpath)
44         assert strp.endswith("sampledir")
45         assert strp.startswith(str(path1))
46         newpath = path1.join((path1.sep * 2) + "sampledir")
47         strp = str(newpath)
48         assert strp.endswith("sampledir")
49         assert strp.startswith(str(path1))
50 
51     def test_join_noargs(self, path1):
52         newpath = path1.join()
53         assert path1 == newpath
54 
55     def test_add_something(self, path1):
56         p = path1.join("sample")
57         p = p + "dir"
58         assert p.check()
59         assert p.exists()
60         assert p.isdir()
61         assert not p.isfile()
62 
63     def test_parts(self, path1):
64         newpath = path1.join("sampledir", "otherfile")
65         par = newpath.parts()[-3:]
66         assert par == [path1, path1.join("sampledir"), newpath]
67 
68         revpar = newpath.parts(reverse=True)[:3]
69         assert revpar == [newpath, path1.join("sampledir"), path1]
70 
71     def test_common(self, path1):
72         other = path1.join("sampledir")
73         x = other.common(path1)
74         assert x == path1
75 
76     # def test_parents_nonexisting_file(self, path1):
77     #    newpath = path1 / 'dirnoexist' / 'nonexisting file'
78     #    par = list(newpath.parents())
79     #    assert par[:2] == [path1 / 'dirnoexist', path1]
80 
81     def test_basename_checks(self, path1):
82         newpath = path1.join("sampledir")
83         assert newpath.check(basename="sampledir")
84         assert newpath.check(notbasename="xyz")
85         assert newpath.basename == "sampledir"
86 
87     def test_basename(self, path1):
88         newpath = path1.join("sampledir")
89         assert newpath.check(basename="sampledir")
90         assert newpath.basename, "sampledir"
91 
92     def test_dirname(self, path1):
93         newpath = path1.join("sampledir")
94         assert newpath.dirname == str(path1)
95 
96     def test_dirpath(self, path1):
97         newpath = path1.join("sampledir")
98         assert newpath.dirpath() == path1
99 
100     def test_dirpath_with_args(self, path1):
101         newpath = path1.join("sampledir")
102         assert newpath.dirpath("x") == path1.join("x")
103 
104     def test_newbasename(self, path1):
105         newpath = path1.join("samplefile")
106         newbase = newpath.new(basename="samplefile2")
107         assert newbase.basename == "samplefile2"
108         assert newbase.dirpath() == newpath.dirpath()
109 
110     def test_not_exists(self, path1):
111         assert not path1.join("does_not_exist").check()
112         assert path1.join("does_not_exist").check(exists=0)
113 
114     def test_exists(self, path1):
115         assert path1.join("samplefile").check()
116         assert path1.join("samplefile").check(exists=1)
117         assert path1.join("samplefile").exists()
118         assert path1.join("samplefile").isfile()
119         assert not path1.join("samplefile").isdir()
120 
121     def test_dir(self, path1):
122         # print repr(path1.join("sampledir"))
123         assert path1.join("sampledir").check(dir=1)
124         assert path1.join("samplefile").check(notdir=1)
125         assert not path1.join("samplefile").check(dir=1)
126         assert path1.join("samplefile").exists()
127         assert not path1.join("samplefile").isdir()
128         assert path1.join("samplefile").isfile()
129 
130     def test_fnmatch_file(self, path1):
131         assert path1.join("samplefile").check(fnmatch="s*e")
132         assert path1.join("samplefile").fnmatch("s*e")
133         assert not path1.join("samplefile").fnmatch("s*x")
134         assert not path1.join("samplefile").check(fnmatch="s*x")
135 
136     # def test_fnmatch_dir(self, path1):
137 
138     #    pattern = path1.sep.join(['s*file'])
139     #    sfile = path1.join("samplefile")
140     #    assert sfile.check(fnmatch=pattern)
141 
142     def test_relto(self, path1):
143         p = path1.join("sampledir", "otherfile")
144         assert p.relto(path1) == p.sep.join(["sampledir", "otherfile"])
145         assert p.check(relto=path1)
146         assert path1.check(notrelto=p)
147         assert not path1.check(relto=p)
148 
149     def test_bestrelpath(self, path1):
150         curdir = path1
151         sep = curdir.sep
152         s = curdir.bestrelpath(curdir)
153         assert s == "."
154         s = curdir.bestrelpath(curdir.join("hello", "world"))
155         assert s == "hello" + sep + "world"
156 
157         s = curdir.bestrelpath(curdir.dirpath().join("sister"))
158         assert s == ".." + sep + "sister"
159         assert curdir.bestrelpath(curdir.dirpath()) == ".."
160 
161         assert curdir.bestrelpath("hello") == "hello"
162 
163     def test_relto_not_relative(self, path1):
164         l1 = path1.join("bcde")
165         l2 = path1.join("b")
166         assert not l1.relto(l2)
167         assert not l2.relto(l1)
168 
169     def test_listdir(self, path1):
170         p = path1.listdir()
171         assert path1.join("sampledir") in p
172         assert path1.join("samplefile") in p
173         with pytest.raises(error.ENOTDIR):
174             path1.join("samplefile").listdir()
175 
176     def test_listdir_fnmatchstring(self, path1):
177         p = path1.listdir("s*dir")
178         assert len(p)
179         assert p[0], path1.join("sampledir")
180 
181     def test_listdir_filter(self, path1):
182         p = path1.listdir(lambda x: x.check(dir=1))
183         assert path1.join("sampledir") in p
184         assert not path1.join("samplefile") in p
185 
186     def test_listdir_sorted(self, path1):
187         p = path1.listdir(lambda x: x.check(basestarts="sample"), sort=True)
188         assert path1.join("sampledir") == p[0]
189         assert path1.join("samplefile") == p[1]
190         assert path1.join("samplepickle") == p[2]
191 
192     def test_visit_nofilter(self, path1):
193         lst = []
194         for i in path1.visit():
195             lst.append(i.relto(path1))
196         assert "sampledir" in lst
197         assert path1.sep.join(["sampledir", "otherfile"]) in lst
198 
199     def test_visit_norecurse(self, path1):
200         lst = []
201         for i in path1.visit(None, lambda x: x.basename != "sampledir"):
202             lst.append(i.relto(path1))
203         assert "sampledir" in lst
204         assert not path1.sep.join(["sampledir", "otherfile"]) in lst
205 
206     @pytest.mark.parametrize(
207         "fil",
208         ["*dir", "*dir", pytest.mark.skip("sys.version_info <" " (3,6)")(b"*dir")],
209     )
210     def test_visit_filterfunc_is_string(self, path1, fil):
211         lst = []
212         for i in path1.visit(fil):
213             lst.append(i.relto(path1))
214         assert len(lst), 2
215         assert "sampledir" in lst
216         assert "otherdir" in lst
217 
218     def test_visit_ignore(self, path1):
219         p = path1.join("nonexisting")
220         assert list(p.visit(ignore=error.ENOENT)) == []
221 
222     def test_visit_endswith(self, path1):
223         p = []
224         for i in path1.visit(lambda x: x.check(endswith="file")):
225             p.append(i.relto(path1))
226         assert path1.sep.join(["sampledir", "otherfile"]) in p
227         assert "samplefile" in p
228 
229     def test_cmp(self, path1):
230         path1 = path1.join("samplefile")
231         path2 = path1.join("samplefile2")
232         assert (path1 < path2) == ("samplefile" < "samplefile2")
233         assert not (path1 < path1)
234 
235     def test_simple_read(self, path1):
236         with ignore_encoding_warning():
237             x = path1.join("samplefile").read("r")
238         assert x == "samplefile\n"
239 
240     def test_join_div_operator(self, path1):
241         newpath = path1 / "/sampledir" / "/test//"
242         newpath2 = path1.join("sampledir", "test")
243         assert newpath == newpath2
244 
245     def test_ext(self, path1):
246         newpath = path1.join("sampledir.ext")
247         assert newpath.ext == ".ext"
248         newpath = path1.join("sampledir")
249         assert not newpath.ext
250 
251     def test_purebasename(self, path1):
252         newpath = path1.join("samplefile.py")
253         assert newpath.purebasename == "samplefile"
254 
255     def test_multiple_parts(self, path1):
256         newpath = path1.join("samplefile.py")
257         dirname, purebasename, basename, ext = newpath._getbyspec(
258             "dirname,purebasename,basename,ext"
259         )
260         assert str(path1).endswith(dirname)  # be careful with win32 'drive'
261         assert purebasename == "samplefile"
262         assert basename == "samplefile.py"
263         assert ext == ".py"
264 
265     def test_dotted_name_ext(self, path1):
266         newpath = path1.join("a.b.c")
267         ext = newpath.ext
268         assert ext == ".c"
269         assert newpath.ext == ".c"
270 
271     def test_newext(self, path1):
272         newpath = path1.join("samplefile.py")
273         newext = newpath.new(ext=".txt")
274         assert newext.basename == "samplefile.txt"
275         assert newext.purebasename == "samplefile"
276 
277     def test_readlines(self, path1):
278         fn = path1.join("samplefile")
279         with ignore_encoding_warning():
280             contents = fn.readlines()
281         assert contents == ["samplefile\n"]
282 
283     def test_readlines_nocr(self, path1):
284         fn = path1.join("samplefile")
285         with ignore_encoding_warning():
286             contents = fn.readlines(cr=0)
287         assert contents == ["samplefile", ""]
288 
289     def test_file(self, path1):
290         assert path1.join("samplefile").check(file=1)
291 
292     def test_not_file(self, path1):
293         assert not path1.join("sampledir").check(file=1)
294         assert path1.join("sampledir").check(file=0)
295 
296     def test_non_existent(self, path1):
297         assert path1.join("sampledir.nothere").check(dir=0)
298         assert path1.join("sampledir.nothere").check(file=0)
299         assert path1.join("sampledir.nothere").check(notfile=1)
300         assert path1.join("sampledir.nothere").check(notdir=1)
301         assert path1.join("sampledir.nothere").check(notexists=1)
302         assert not path1.join("sampledir.nothere").check(notfile=0)
303 
304     #    pattern = path1.sep.join(['s*file'])
305     #    sfile = path1.join("samplefile")
306     #    assert sfile.check(fnmatch=pattern)
307 
308     def test_size(self, path1):
309         url = path1.join("samplefile")
310         assert url.size() > len("samplefile")
311 
312     def test_mtime(self, path1):
313         url = path1.join("samplefile")
314         assert url.mtime() > 0
315 
316     def test_relto_wrong_type(self, path1):
317         with pytest.raises(TypeError):
318             path1.relto(42)
319 
320     def test_load(self, path1):
321         p = path1.join("samplepickle")
322         obj = p.load()
323         assert type(obj) is dict
324         assert obj.get("answer", None) == 42
325 
326     def test_visit_filesonly(self, path1):
327         p = []
328         for i in path1.visit(lambda x: x.check(file=1)):
329             p.append(i.relto(path1))
330         assert "sampledir" not in p
331         assert path1.sep.join(["sampledir", "otherfile"]) in p
332 
333     def test_visit_nodotfiles(self, path1):
334         p = []
335         for i in path1.visit(lambda x: x.check(dotfile=0)):
336             p.append(i.relto(path1))
337         assert "sampledir" in p
338         assert path1.sep.join(["sampledir", "otherfile"]) in p
339         assert ".dotfile" not in p
340 
341     def test_visit_breadthfirst(self, path1):
342         lst = []
343         for i in path1.visit(bf=True):
344             lst.append(i.relto(path1))
345         for i, p in enumerate(lst):
346             if path1.sep in p:
347                 for j in range(i, len(lst)):
348                     assert path1.sep in lst[j]
349                 break
350         else:
351             pytest.fail("huh")
352 
353     def test_visit_sort(self, path1):
354         lst = []
355         for i in path1.visit(bf=True, sort=True):
356             lst.append(i.relto(path1))
357         for i, p in enumerate(lst):
358             if path1.sep in p:
359                 break
360         assert lst[:i] == sorted(lst[:i])
361         assert lst[i:] == sorted(lst[i:])
362 
363     def test_endswith(self, path1):
364         def chk(p):
365             return p.check(endswith="pickle")
366 
367         assert not chk(path1)
368         assert not chk(path1.join("samplefile"))
369         assert chk(path1.join("somepickle"))
370 
371     def test_copy_file(self, path1):
372         otherdir = path1.join("otherdir")
373         initpy = otherdir.join("__init__.py")
374         copied = otherdir.join("copied")
375         initpy.copy(copied)
376         try:
377             assert copied.check()
378             s1 = initpy.read_text(encoding="utf-8")
379             s2 = copied.read_text(encoding="utf-8")
380             assert s1 == s2
381         finally:
382             if copied.check():
383                 copied.remove()
384 
385     def test_copy_dir(self, path1):
386         otherdir = path1.join("otherdir")
387         copied = path1.join("newdir")
388         try:
389             otherdir.copy(copied)
390             assert copied.check(dir=1)
391             assert copied.join("__init__.py").check(file=1)
392             s1 = otherdir.join("__init__.py").read_text(encoding="utf-8")
393             s2 = copied.join("__init__.py").read_text(encoding="utf-8")
394             assert s1 == s2
395         finally:
396             if copied.check(dir=1):
397                 copied.remove(rec=1)
398 
399     def test_remove_file(self, path1):
400         d = path1.ensure("todeleted")
401         assert d.check()
402         d.remove()
403         assert not d.check()
404 
405     def test_remove_dir_recursive_by_default(self, path1):
406         d = path1.ensure("to", "be", "deleted")
407         assert d.check()
408         p = path1.join("to")
409         p.remove()
410         assert not p.check()
411 
412     def test_ensure_dir(self, path1):
413         b = path1.ensure_dir("001", "002")
414         assert b.basename == "002"
415         assert b.isdir()
416 
417     def test_mkdir_and_remove(self, path1):
418         tmpdir = path1
419         with pytest.raises(error.EEXIST):
420             tmpdir.mkdir("sampledir")
421         new = tmpdir.join("mktest1")
422         new.mkdir()
423         assert new.check(dir=1)
424         new.remove()
425 
426         new = tmpdir.mkdir("mktest")
427         assert new.check(dir=1)
428         new.remove()
429         assert tmpdir.join("mktest") == new
430 
431     def test_move_file(self, path1):
432         p = path1.join("samplefile")
433         newp = p.dirpath("moved_samplefile")
434         p.move(newp)
435         try:
436             assert newp.check(file=1)
437             assert not p.check()
438         finally:
439             dp = newp.dirpath()
440             if hasattr(dp, "revert"):
441                 dp.revert()
442             else:
443                 newp.move(p)
444                 assert p.check()
445 
446     def test_move_dir(self, path1):
447         source = path1.join("sampledir")
448         dest = path1.join("moveddir")
449         source.move(dest)
450         assert dest.check(dir=1)
451         assert dest.join("otherfile").check(file=1)
452         assert not source.join("sampledir").check()
453 
454     def test_fspath_protocol_match_strpath(self, path1):
455         assert path1.__fspath__() == path1.strpath
456 
457     def test_fspath_func_match_strpath(self, path1):
458         from os import fspath
459 
460         assert fspath(path1) == path1.strpath
461 
462     @pytest.mark.skip("sys.version_info < (3,6)")
463     def test_fspath_open(self, path1):
464         f = path1.join("opentestfile")
465         open(f)
466 
467     @pytest.mark.skip("sys.version_info < (3,6)")
468     def test_fspath_fsencode(self, path1):
469         from os import fsencode
470 
471         assert fsencode(path1) == fsencode(path1.strpath)
472 
473 
474 def setuptestfs(path):
475     if path.join("samplefile").check():
476         return
477     # print "setting up test fs for", repr(path)
478     samplefile = path.ensure("samplefile")
479     samplefile.write_text("samplefile\n", encoding="utf-8")
480 
481     execfile = path.ensure("execfile")
482     execfile.write_text("x=42", encoding="utf-8")
483 
484     execfilepy = path.ensure("execfile.py")
485     execfilepy.write_text("x=42", encoding="utf-8")
486 
487     d = {1: 2, "hello": "world", "answer": 42}
488     path.ensure("samplepickle").dump(d)
489 
490     sampledir = path.ensure("sampledir", dir=1)
491     sampledir.ensure("otherfile")
492 
493     otherdir = path.ensure("otherdir", dir=1)
494     otherdir.ensure("__init__.py")
495 
496     module_a = otherdir.ensure("a.py")
497     module_a.write_text("from .b import stuff as result\n", encoding="utf-8")
498     module_b = otherdir.ensure("b.py")
499     module_b.write_text('stuff="got it"\n', encoding="utf-8")
500     module_c = otherdir.ensure("c.py")
501     module_c.write_text(
502         """import py;
503 import otherdir.a
504 value = otherdir.a.result
505 """,
506         encoding="utf-8",
507     )
508     module_d = otherdir.ensure("d.py")
509     module_d.write_text(
510         """import py;
511 from otherdir import a
512 value2 = a.result
513 """,
514         encoding="utf-8",
515     )
516 
517 
518 win32only = pytest.mark.skipif(
519     "not (sys.platform == 'win32' or getattr(os, '_name', None) == 'nt')"
520 )
521 skiponwin32 = pytest.mark.skipif(
522     "sys.platform == 'win32' or getattr(os, '_name', None) == 'nt'"
523 )
524 
525 ATIME_RESOLUTION = 0.01
526 
527 
528 @pytest.fixture(scope="session")
529 def path1(tmpdir_factory):
530     path = tmpdir_factory.mktemp("path")
531     setuptestfs(path)
532     yield path
533     assert path.join("samplefile").check()
534 
535 
536 @pytest.fixture
537 def fake_fspath_obj(request):
538     class FakeFSPathClass:
539         def __init__(self, path):
540             self._path = path
541 
542         def __fspath__(self):
543             return self._path
544 
545     return FakeFSPathClass(os.path.join("this", "is", "a", "fake", "path"))
546 
547 
548 def batch_make_numbered_dirs(rootdir, repeats):
549     for i in range(repeats):
550         dir_ = local.make_numbered_dir(prefix="repro-", rootdir=rootdir)
551         file_ = dir_.join("foo")
552         file_.write_text("%s" % i, encoding="utf-8")
553         actual = int(file_.read_text(encoding="utf-8"))
554         assert (
555             actual == i
556         ), f"int(file_.read_text(encoding='utf-8')) is {actual} instead of {i}"
557         dir_.join(".lock").remove(ignore_errors=True)
558     return True
559 
560 
561 class TestLocalPath(CommonFSTests):
562     def test_join_normpath(self, tmpdir):
563         assert tmpdir.join(".") == tmpdir
564         p = tmpdir.join("../%s" % tmpdir.basename)
565         assert p == tmpdir
566         p = tmpdir.join("..//%s/" % tmpdir.basename)
567         assert p == tmpdir
568 
569     @skiponwin32
570     def test_dirpath_abs_no_abs(self, tmpdir):
571         p = tmpdir.join("foo")
572         assert p.dirpath("/bar") == tmpdir.join("bar")
573         assert tmpdir.dirpath("/bar", abs=True) == local("/bar")
574 
575     def test_gethash(self, tmpdir):
576         from hashlib import md5
577         from hashlib import sha1 as sha
578 
579         fn = tmpdir.join("testhashfile")
580         data = b"hello"
581         fn.write(data, mode="wb")
582         assert fn.computehash("md5") == md5(data).hexdigest()
583         assert fn.computehash("sha1") == sha(data).hexdigest()
584         with pytest.raises(ValueError):
585             fn.computehash("asdasd")
586 
587     def test_remove_removes_readonly_file(self, tmpdir):
588         readonly_file = tmpdir.join("readonly").ensure()
589         readonly_file.chmod(0)
590         readonly_file.remove()
591         assert not readonly_file.check(exists=1)
592 
593     def test_remove_removes_readonly_dir(self, tmpdir):
594         readonly_dir = tmpdir.join("readonlydir").ensure(dir=1)
595         readonly_dir.chmod(int("500", 8))
596         readonly_dir.remove()
597         assert not readonly_dir.check(exists=1)
598 
599     def test_remove_removes_dir_and_readonly_file(self, tmpdir):
600         readonly_dir = tmpdir.join("readonlydir").ensure(dir=1)
601         readonly_file = readonly_dir.join("readonlyfile").ensure()
602         readonly_file.chmod(0)
603         readonly_dir.remove()
604         assert not readonly_dir.check(exists=1)
605 
606     def test_remove_routes_ignore_errors(self, tmpdir, monkeypatch):
607         lst = []
608         monkeypatch.setattr("shutil.rmtree", lambda *args, **kwargs: lst.append(kwargs))
609         tmpdir.remove()
610         assert not lst[0]["ignore_errors"]
611         for val in (True, False):
612             lst[:] = []
613             tmpdir.remove(ignore_errors=val)
614             assert lst[0]["ignore_errors"] == val
615 
616     def test_initialize_curdir(self):
617         assert str(local()) == os.getcwd()
618 
619     @skiponwin32
620     def test_chdir_gone(self, path1):
621         p = path1.ensure("dir_to_be_removed", dir=1)
622         p.chdir()
623         p.remove()
624         pytest.raises(error.ENOENT, local)
625         assert path1.chdir() is None
626         assert os.getcwd() == str(path1)
627 
628         with pytest.raises(error.ENOENT):
629             with p.as_cwd():
630                 raise NotImplementedError
631 
632     @skiponwin32
633     def test_chdir_gone_in_as_cwd(self, path1):
634         p = path1.ensure("dir_to_be_removed", dir=1)
635         p.chdir()
636         p.remove()
637 
638         with path1.as_cwd() as old:
639             assert old is None
640 
641     def test_as_cwd(self, path1):
642         dir = path1.ensure("subdir", dir=1)
643         old = local()
644         with dir.as_cwd() as x:
645             assert x == old
646             assert local() == dir
647         assert os.getcwd() == str(old)
648 
649     def test_as_cwd_exception(self, path1):
650         old = local()
651         dir = path1.ensure("subdir", dir=1)
652         with pytest.raises(ValueError):
653             with dir.as_cwd():
654                 raise ValueError()
655         assert old == local()
656 
657     def test_initialize_reldir(self, path1):
658         with path1.as_cwd():
659             p = local("samplefile")
660             assert p.check()
661 
662     def test_tilde_expansion(self, monkeypatch, tmpdir):
663         monkeypatch.setenv("HOME", str(tmpdir))
664         p = local("~", expanduser=True)
665         assert p == os.path.expanduser("~")
666 
667     @pytest.mark.skipif(
668         not sys.platform.startswith("win32"), reason="case insensitive only on windows"
669     )
670     def test_eq_hash_are_case_insensitive_on_windows(self):
671         a = local("/some/path")
672         b = local("/some/PATH")
673         assert a == b
674         assert hash(a) == hash(b)
675         assert a in {b}
676         assert a in {b: "b"}
677 
678     def test_eq_with_strings(self, path1):
679         path1 = path1.join("sampledir")
680         path2 = str(path1)
681         assert path1 == path2
682         assert path2 == path1
683         path3 = path1.join("samplefile")
684         assert path3 != path2
685         assert path2 != path3
686 
687     def test_eq_with_none(self, path1):
688         assert path1 != None  # noqa: E711
689 
690     def test_eq_non_ascii_unicode(self, path1):
691         path2 = path1.join("temp")
692         path3 = path1.join("ao")
693         path4 = path1.join("")
694 
695         assert path2 != path3
696         assert path2 != path4
697         assert path4 != path3
698 
699     def test_gt_with_strings(self, path1):
700         path2 = path1.join("sampledir")
701         path3 = str(path1.join("ttt"))
702         assert path3 > path2
703         assert path2 < path3
704         assert path2 < "ttt"
705         assert "ttt" > path2
706         path4 = path1.join("aaa")
707         lst = [path2, path4, path3]
708         assert sorted(lst) == [path4, path2, path3]
709 
710     def test_open_and_ensure(self, path1):
711         p = path1.join("sub1", "sub2", "file")
712         with p.open("w", ensure=1, encoding="utf-8") as f:
713             f.write("hello")
714         assert p.read_text(encoding="utf-8") == "hello"
715 
716     def test_write_and_ensure(self, path1):
717         p = path1.join("sub1", "sub2", "file")
718         p.write_text("hello", ensure=1, encoding="utf-8")
719         assert p.read_text(encoding="utf-8") == "hello"
720 
721     @pytest.mark.parametrize("bin", (False, True))
722     def test_dump(self, tmpdir, bin):
723         path = tmpdir.join("dumpfile%s" % int(bin))
724         try:
725             d = {"answer": 42}
726             path.dump(d, bin=bin)
727             f = path.open("rb+")
728             import pickle
729 
730             dnew = pickle.load(f)
731             assert d == dnew
732         finally:
733             f.close()
734 
735     def test_setmtime(self):
736         import tempfile
737         import time
738 
739         try:
740             fd, name = tempfile.mkstemp()
741             os.close(fd)
742         except AttributeError:
743             name = tempfile.mktemp()
744             open(name, "w").close()
745         try:
746             mtime = int(time.time()) - 100
747             path = local(name)
748             assert path.mtime() != mtime
749             path.setmtime(mtime)
750             assert path.mtime() == mtime
751             path.setmtime()
752             assert path.mtime() != mtime
753         finally:
754             os.remove(name)
755 
756     def test_normpath(self, path1):
757         new1 = path1.join("/otherdir")
758         new2 = path1.join("otherdir")
759         assert str(new1) == str(new2)
760 
761     def test_mkdtemp_creation(self):
762         d = local.mkdtemp()
763         try:
764             assert d.check(dir=1)
765         finally:
766             d.remove(rec=1)
767 
768     def test_tmproot(self):
769         d = local.mkdtemp()
770         tmproot = local.get_temproot()
771         try:
772             assert d.check(dir=1)
773             assert d.dirpath() == tmproot
774         finally:
775             d.remove(rec=1)
776 
777     def test_chdir(self, tmpdir):
778         old = local()
779         try:
780             res = tmpdir.chdir()
781             assert str(res) == str(old)
782             assert os.getcwd() == str(tmpdir)
783         finally:
784             old.chdir()
785 
786     def test_ensure_filepath_withdir(self, tmpdir):
787         newfile = tmpdir.join("test1", "test")
788         newfile.ensure()
789         assert newfile.check(file=1)
790         newfile.write_text("42", encoding="utf-8")
791         newfile.ensure()
792         s = newfile.read_text(encoding="utf-8")
793         assert s == "42"
794 
795     def test_ensure_filepath_withoutdir(self, tmpdir):
796         newfile = tmpdir.join("test1file")
797         t = newfile.ensure()
798         assert t == newfile
799         assert newfile.check(file=1)
800 
801     def test_ensure_dirpath(self, tmpdir):
802         newfile = tmpdir.join("test1", "testfile")
803         t = newfile.ensure(dir=1)
804         assert t == newfile
805         assert newfile.check(dir=1)
806 
807     def test_ensure_non_ascii_unicode(self, tmpdir):
808         newfile = tmpdir.join("ao", "")
809         t = newfile.ensure(dir=1)
810         assert t == newfile
811         assert newfile.check(dir=1)
812 
813     @pytest.mark.xfail(run=False, reason="unreliable est for long filenames")
814     def test_long_filenames(self, tmpdir):
815         if sys.platform == "win32":
816             pytest.skip("win32: work around needed for path length limit")
817         # see http://codespeak.net/pipermail/py-dev/2008q2/000922.html
818 
819         # testing paths > 260 chars (which is Windows' limitation, but
820         # depending on how the paths are used), but > 4096 (which is the
821         # Linux' limitation) - the behaviour of paths with names > 4096 chars
822         # is undetermined
823         newfilename = "/test" * 60  # type:ignore[unreachable]
824         l1 = tmpdir.join(newfilename)
825         l1.ensure(file=True)
826         l1.write_text("foo", encoding="utf-8")
827         l2 = tmpdir.join(newfilename)
828         assert l2.read_text(encoding="utf-8") == "foo"
829 
830     def test_visit_depth_first(self, tmpdir):
831         tmpdir.ensure("a", "1")
832         tmpdir.ensure("b", "2")
833         p3 = tmpdir.ensure("breadth")
834         lst = list(tmpdir.visit(lambda x: x.check(file=1)))
835         assert len(lst) == 3
836         # check that breadth comes last
837         assert lst[2] == p3
838 
839     def test_visit_rec_fnmatch(self, tmpdir):
840         p1 = tmpdir.ensure("a", "123")
841         tmpdir.ensure(".b", "345")
842         lst = list(tmpdir.visit("???", rec="[!.]*"))
843         assert len(lst) == 1
844         # check that breadth comes last
845         assert lst[0] == p1
846 
847     def test_fnmatch_file_abspath(self, tmpdir):
848         b = tmpdir.join("a", "b")
849         assert b.fnmatch(os.sep.join("ab"))
850         pattern = os.sep.join([str(tmpdir), "*", "b"])
851         assert b.fnmatch(pattern)
852 
853     def test_sysfind(self):
854         name = sys.platform == "win32" and "cmd" or "test"
855         x = local.sysfind(name)
856         assert x.check(file=1)
857         assert local.sysfind("jaksdkasldqwe") is None
858         assert local.sysfind(name, paths=[]) is None
859         x2 = local.sysfind(name, paths=[x.dirpath()])
860         assert x2 == x
861 
862     def test_fspath_protocol_other_class(self, fake_fspath_obj):
863         # py.path is always absolute
864         py_path = local(fake_fspath_obj)
865         str_path = fake_fspath_obj.__fspath__()
866         assert py_path.check(endswith=str_path)
867         assert py_path.join(fake_fspath_obj).strpath == os.path.join(
868             py_path.strpath, str_path
869         )
870 
871     def test_make_numbered_dir_multiprocess_safe(self, tmpdir):
872         # https://github.com/pytest-dev/py/issues/30
873         with multiprocessing.Pool() as pool:
874             results = [
875                 pool.apply_async(batch_make_numbered_dirs, [tmpdir, 100])
876                 for _ in range(20)
877             ]
878             for r in results:
879                 assert r.get()
880 
881 
882 class TestExecutionOnWindows:
883     pytestmark = win32only
884 
885     def test_sysfind_bat_exe_before(self, tmpdir, monkeypatch):
886         monkeypatch.setenv("PATH", str(tmpdir), prepend=os.pathsep)
887         tmpdir.ensure("hello")
888         h = tmpdir.ensure("hello.bat")
889         x = local.sysfind("hello")
890         assert x == h
891 
892 
893 class TestExecution:
894     pytestmark = skiponwin32
895 
896     def test_sysfind_no_permisson_ignored(self, monkeypatch, tmpdir):
897         noperm = tmpdir.ensure("noperm", dir=True)
898         monkeypatch.setenv("PATH", str(noperm), prepend=":")
899         noperm.chmod(0)
900         try:
901             assert local.sysfind("jaksdkasldqwe") is None
902         finally:
903             noperm.chmod(0o644)
904 
905     def test_sysfind_absolute(self):
906         x = local.sysfind("test")
907         assert x.check(file=1)
908         y = local.sysfind(str(x))
909         assert y.check(file=1)
910         assert y == x
911 
912     def test_sysfind_multiple(self, tmpdir, monkeypatch):
913         monkeypatch.setenv(
914             "PATH", "{}:{}".format(tmpdir.ensure("a"), tmpdir.join("b")), prepend=":"
915         )
916         tmpdir.ensure("b", "a")
917         x = local.sysfind("a", checker=lambda x: x.dirpath().basename == "b")
918         assert x.basename == "a"
919         assert x.dirpath().basename == "b"
920         assert local.sysfind("a", checker=lambda x: None) is None
921 
922     def test_sysexec(self):
923         x = local.sysfind("ls")
924         out = x.sysexec("-a")
925         for x in local().listdir():
926             assert out.find(x.basename) != -1
927 
928     def test_sysexec_failing(self):
929         try:
930             from py._process.cmdexec import ExecutionFailed  # py library
931         except ImportError:
932             ExecutionFailed = RuntimeError  # py vendored
933         x = local.sysfind("false")
934         with pytest.raises(ExecutionFailed):
935             x.sysexec("aksjdkasjd")
936 
937     def test_make_numbered_dir(self, tmpdir):
938         tmpdir.ensure("base.not_an_int", dir=1)
939         for i in range(10):
940             numdir = local.make_numbered_dir(
941                 prefix="base.", rootdir=tmpdir, keep=2, lock_timeout=0
942             )
943             assert numdir.check()
944             assert numdir.basename == "base.%d" % i
945             if i >= 1:
946                 assert numdir.new(ext=str(i - 1)).check()
947             if i >= 2:
948                 assert numdir.new(ext=str(i - 2)).check()
949             if i >= 3:
950                 assert not numdir.new(ext=str(i - 3)).check()
951 
952     def test_make_numbered_dir_case(self, tmpdir):
953         """make_numbered_dir does not make assumptions on the underlying
954         filesystem based on the platform and will assume it _could_ be case
955         insensitive.
956 
957         See issues:
958         - https://github.com/pytest-dev/pytest/issues/708
959         - https://github.com/pytest-dev/pytest/issues/3451
960         """
961         d1 = local.make_numbered_dir(
962             prefix="CAse.",
963             rootdir=tmpdir,
964             keep=2,
965             lock_timeout=0,
966         )
967         d2 = local.make_numbered_dir(
968             prefix="caSE.",
969             rootdir=tmpdir,
970             keep=2,
971             lock_timeout=0,
972         )
973         assert str(d1).lower() != str(d2).lower()
974         assert str(d2).endswith(".1")
975 
976     def test_make_numbered_dir_NotImplemented_Error(self, tmpdir, monkeypatch):
977         def notimpl(x, y):
978             raise NotImplementedError(42)
979 
980         monkeypatch.setattr(os, "symlink", notimpl)
981         x = tmpdir.make_numbered_dir(rootdir=tmpdir, lock_timeout=0)
982         assert x.relto(tmpdir)
983         assert x.check()
984 
985     def test_locked_make_numbered_dir(self, tmpdir):
986         for i in range(10):
987             numdir = local.make_numbered_dir(prefix="base2.", rootdir=tmpdir, keep=2)
988             assert numdir.check()
989             assert numdir.basename == "base2.%d" % i
990             for j in range(i):
991                 assert numdir.new(ext=str(j)).check()
992 
993     def test_error_preservation(self, path1):
994         pytest.raises(EnvironmentError, path1.join("qwoeqiwe").mtime)
995         pytest.raises(EnvironmentError, path1.join("qwoeqiwe").read)
996 
997     # def test_parentdirmatch(self):
998     #    local.parentdirmatch('std', startmodule=__name__)
999     #
1000 
1001 
1002 class TestImport:
1003     @pytest.fixture(autouse=True)
1004     def preserve_sys(self):
1005         with mock.patch.dict(sys.modules):
1006             with mock.patch.object(sys, "path", list(sys.path)):
1007                 yield
1008 
1009     def test_pyimport(self, path1):
1010         obj = path1.join("execfile.py").pyimport()
1011         assert obj.x == 42
1012         assert obj.__name__ == "execfile"
1013 
1014     def test_pyimport_renamed_dir_creates_mismatch(self, tmpdir, monkeypatch):
1015         p = tmpdir.ensure("a", "test_x123.py")
1016         p.pyimport()
1017         tmpdir.join("a").move(tmpdir.join("b"))
1018         with pytest.raises(tmpdir.ImportMismatchError):
1019             tmpdir.join("b", "test_x123.py").pyimport()
1020 
1021         # Errors can be ignored.
1022         monkeypatch.setenv("PY_IGNORE_IMPORTMISMATCH", "1")
1023         tmpdir.join("b", "test_x123.py").pyimport()
1024 
1025         # PY_IGNORE_IMPORTMISMATCH=0 does not ignore error.
1026         monkeypatch.setenv("PY_IGNORE_IMPORTMISMATCH", "0")
1027         with pytest.raises(tmpdir.ImportMismatchError):
1028             tmpdir.join("b", "test_x123.py").pyimport()
1029 
1030     def test_pyimport_messy_name(self, tmpdir):
1031         # http://bitbucket.org/hpk42/py-trunk/issue/129
1032         path = tmpdir.ensure("foo__init__.py")
1033         path.pyimport()
1034 
1035     def test_pyimport_dir(self, tmpdir):
1036         p = tmpdir.join("hello_123")
1037         p_init = p.ensure("__init__.py")
1038         m = p.pyimport()
1039         assert m.__name__ == "hello_123"
1040         m = p_init.pyimport()
1041         assert m.__name__ == "hello_123"
1042 
1043     def test_pyimport_execfile_different_name(self, path1):
1044         obj = path1.join("execfile.py").pyimport(modname="0x.y.z")
1045         assert obj.x == 42
1046         assert obj.__name__ == "0x.y.z"
1047 
1048     def test_pyimport_a(self, path1):
1049         otherdir = path1.join("otherdir")
1050         mod = otherdir.join("a.py").pyimport()
1051         assert mod.result == "got it"
1052         assert mod.__name__ == "otherdir.a"
1053 
1054     def test_pyimport_b(self, path1):
1055         otherdir = path1.join("otherdir")
1056         mod = otherdir.join("b.py").pyimport()
1057         assert mod.stuff == "got it"
1058         assert mod.__name__ == "otherdir.b"
1059 
1060     def test_pyimport_c(self, path1):
1061         otherdir = path1.join("otherdir")
1062         mod = otherdir.join("c.py").pyimport()
1063         assert mod.value == "got it"
1064 
1065     def test_pyimport_d(self, path1):
1066         otherdir = path1.join("otherdir")
1067         mod = otherdir.join("d.py").pyimport()
1068         assert mod.value2 == "got it"
1069 
1070     def test_pyimport_and_import(self, tmpdir):
1071         tmpdir.ensure("xxxpackage", "__init__.py")
1072         mod1path = tmpdir.ensure("xxxpackage", "module1.py")
1073         mod1 = mod1path.pyimport()
1074         assert mod1.__name__ == "xxxpackage.module1"
1075         from xxxpackage import module1
1076 
1077         assert module1 is mod1
1078 
1079     def test_pyimport_check_filepath_consistency(self, monkeypatch, tmpdir):
1080         name = "pointsback123"
1081         ModuleType = type(os)
1082         p = tmpdir.ensure(name + ".py")
1083         for ending in (".pyc", "$py.class", ".pyo"):
1084             mod = ModuleType(name)
1085             pseudopath = tmpdir.ensure(name + ending)
1086             mod.__file__ = str(pseudopath)
1087             monkeypatch.setitem(sys.modules, name, mod)
1088             newmod = p.pyimport()
1089             assert mod == newmod
1090         monkeypatch.undo()
1091         mod = ModuleType(name)
1092         pseudopath = tmpdir.ensure(name + "123.py")
1093         mod.__file__ = str(pseudopath)
1094         monkeypatch.setitem(sys.modules, name, mod)
1095         excinfo = pytest.raises(pseudopath.ImportMismatchError, p.pyimport)
1096         modname, modfile, orig = excinfo.value.args
1097         assert modname == name
1098         assert modfile == pseudopath
1099         assert orig == p
1100         assert issubclass(pseudopath.ImportMismatchError, ImportError)
1101 
1102     def test_issue131_pyimport_on__init__(self, tmpdir):
1103         # __init__.py files may be namespace packages, and thus the
1104         # __file__ of an imported module may not be ourselves
1105         # see issue
1106         p1 = tmpdir.ensure("proja", "__init__.py")
1107         p2 = tmpdir.ensure("sub", "proja", "__init__.py")
1108         m1 = p1.pyimport()
1109         m2 = p2.pyimport()
1110         assert m1 == m2
1111 
1112     def test_ensuresyspath_append(self, tmpdir):
1113         root1 = tmpdir.mkdir("root1")
1114         file1 = root1.ensure("x123.py")
1115         assert str(root1) not in sys.path
1116         file1.pyimport(ensuresyspath="append")
1117         assert str(root1) == sys.path[-1]
1118         assert str(root1) not in sys.path[:-1]
1119 
1120 
1121 class TestImportlibImport:
1122     OPTS = {"ensuresyspath": "importlib"}
1123 
1124     def test_pyimport(self, path1):
1125         obj = path1.join("execfile.py").pyimport(**self.OPTS)
1126         assert obj.x == 42
1127         assert obj.__name__ == "execfile"
1128 
1129     def test_pyimport_dir_fails(self, tmpdir):
1130         p = tmpdir.join("hello_123")
1131         p.ensure("__init__.py")
1132         with pytest.raises(ImportError):
1133             p.pyimport(**self.OPTS)
1134 
1135     def test_pyimport_execfile_different_name(self, path1):
1136         obj = path1.join("execfile.py").pyimport(modname="0x.y.z", **self.OPTS)
1137         assert obj.x == 42
1138         assert obj.__name__ == "0x.y.z"
1139 
1140     def test_pyimport_relative_import_fails(self, path1):
1141         otherdir = path1.join("otherdir")
1142         with pytest.raises(ImportError):
1143             otherdir.join("a.py").pyimport(**self.OPTS)
1144 
1145     def test_pyimport_doesnt_use_sys_modules(self, tmpdir):
1146         p = tmpdir.ensure("file738jsk.py")
1147         mod = p.pyimport(**self.OPTS)
1148         assert mod.__name__ == "file738jsk"
1149         assert "file738jsk" not in sys.modules
1150 
1151 
1152 def test_pypkgdir(tmpdir):
1153     pkg = tmpdir.ensure("pkg1", dir=1)
1154     pkg.ensure("__init__.py")
1155     pkg.ensure("subdir/__init__.py")
1156     assert pkg.pypkgpath() == pkg
1157     assert pkg.join("subdir", "__init__.py").pypkgpath() == pkg
1158 
1159 
1160 def test_pypkgdir_unimportable(tmpdir):
1161     pkg = tmpdir.ensure("pkg1-1", dir=1)  # unimportable
1162     pkg.ensure("__init__.py")
1163     subdir = pkg.ensure("subdir/__init__.py").dirpath()
1164     assert subdir.pypkgpath() == subdir
1165     assert subdir.ensure("xyz.py").pypkgpath() == subdir
1166     assert not pkg.pypkgpath()
1167 
1168 
1169 def test_isimportable():
1170     try:
1171         from py.path import isimportable  # py vendored version
1172     except ImportError:
1173         from py._path.local import isimportable  # py library
1174 
1175     assert not isimportable("")
1176     assert isimportable("x")
1177     assert isimportable("x1")
1178     assert isimportable("x_1")
1179     assert isimportable("_")
1180     assert isimportable("_1")
1181     assert not isimportable("x-1")
1182     assert not isimportable("x:1")
1183 
1184 
1185 def test_homedir_from_HOME(monkeypatch):
1186     path = os.getcwd()
1187     monkeypatch.setenv("HOME", path)
1188     assert local._gethomedir() == local(path)
1189 
1190 
1191 def test_homedir_not_exists(monkeypatch):
1192     monkeypatch.delenv("HOME", raising=False)
1193     monkeypatch.delenv("HOMEDRIVE", raising=False)
1194     homedir = local._gethomedir()
1195     assert homedir is None
1196 
1197 
1198 def test_samefile(tmpdir):
1199     assert tmpdir.samefile(tmpdir)
1200     p = tmpdir.ensure("hello")
1201     assert p.samefile(p)
1202     with p.dirpath().as_cwd():
1203         assert p.samefile(p.basename)
1204     if sys.platform == "win32":
1205         p1 = p.__class__(str(p).lower())
1206         p2 = p.__class__(str(p).upper())
1207         assert p1.samefile(p2)
1208 
1209 
1210 @pytest.mark.skipif(not hasattr(os, "symlink"), reason="os.symlink not available")
1211 def test_samefile_symlink(tmpdir):
1212     p1 = tmpdir.ensure("foo.txt")
1213     p2 = tmpdir.join("linked.txt")
1214     try:
1215         os.symlink(str(p1), str(p2))
1216     except (OSError, NotImplementedError) as e:
1217         # on Windows this might fail if the user doesn't have special symlink permissions
1218         # pypy3 on Windows doesn't implement os.symlink and raises NotImplementedError
1219         pytest.skip(str(e.args[0]))
1220 
1221     assert p1.samefile(p2)
1222 
1223 
1224 def test_listdir_single_arg(tmpdir):
1225     tmpdir.ensure("hello")
1226     assert tmpdir.listdir("hello")[0].basename == "hello"
1227 
1228 
1229 def test_mkdtemp_rootdir(tmpdir):
1230     dtmp = local.mkdtemp(rootdir=tmpdir)
1231     assert tmpdir.listdir() == [dtmp]
1232 
1233 
1234 class TestWINLocalPath:
1235     pytestmark = win32only
1236 
1237     def test_owner_group_not_implemented(self, path1):
1238         with pytest.raises(NotImplementedError):
1239             path1.stat().owner
1240         with pytest.raises(NotImplementedError):
1241             path1.stat().group
1242 
1243     def test_chmod_simple_int(self, path1):
1244         mode = path1.stat().mode
1245         # Ensure that we actually change the mode to something different.
1246         path1.chmod(mode == 0 and 1 or 0)
1247         try:
1248             print(path1.stat().mode)
1249             print(mode)
1250             assert path1.stat().mode != mode
1251         finally:
1252             path1.chmod(mode)
1253             assert path1.stat().mode == mode
1254 
1255     def test_path_comparison_lowercase_mixed(self, path1):
1256         t1 = path1.join("a_path")
1257         t2 = path1.join("A_path")
1258         assert t1 == t1
1259         assert t1 == t2
1260 
1261     def test_relto_with_mixed_case(self, path1):
1262         t1 = path1.join("a_path", "fiLe")
1263         t2 = path1.join("A_path")
1264         assert t1.relto(t2) == "fiLe"
1265 
1266     def test_allow_unix_style_paths(self, path1):
1267         t1 = path1.join("a_path")
1268         assert t1 == str(path1) + "\\a_path"
1269         t1 = path1.join("a_path/")
1270         assert t1 == str(path1) + "\\a_path"
1271         t1 = path1.join("dir/a_path")
1272         assert t1 == str(path1) + "\\dir\\a_path"
1273 
1274     def test_sysfind_in_currentdir(self, path1):
1275         cmd = local.sysfind("cmd")
1276         root = cmd.new(dirname="", basename="")  # c:\ in most installations
1277         with root.as_cwd():
1278             x = local.sysfind(cmd.relto(root))
1279             assert x.check(file=1)
1280 
1281     def test_fnmatch_file_abspath_posix_pattern_on_win32(self, tmpdir):
1282         # path-matching patterns might contain a posix path separator '/'
1283         # Test that we can match that pattern on windows.
1284         import posixpath
1285 
1286         b = tmpdir.join("a", "b")
1287         assert b.fnmatch(posixpath.sep.join("ab"))
1288         pattern = posixpath.sep.join([str(tmpdir), "*", "b"])
1289         assert b.fnmatch(pattern)
1290 
1291 
1292 class TestPOSIXLocalPath:
1293     pytestmark = skiponwin32
1294 
1295     def test_hardlink(self, tmpdir):
1296         linkpath = tmpdir.join("test")
1297         filepath = tmpdir.join("file")
1298         filepath.write_text("Hello", encoding="utf-8")
1299         nlink = filepath.stat().nlink
1300         linkpath.mklinkto(filepath)
1301         assert filepath.stat().nlink == nlink + 1
1302 
1303     def test_symlink_are_identical(self, tmpdir):
1304         filepath = tmpdir.join("file")
1305         filepath.write_text("Hello", encoding="utf-8")
1306         linkpath = tmpdir.join("test")
1307         linkpath.mksymlinkto(filepath)
1308         assert linkpath.readlink() == str(filepath)
1309 
1310     def test_symlink_isfile(self, tmpdir):
1311         linkpath = tmpdir.join("test")
1312         filepath = tmpdir.join("file")
1313         filepath.write_text("", encoding="utf-8")
1314         linkpath.mksymlinkto(filepath)
1315         assert linkpath.check(file=1)
1316         assert not linkpath.check(link=0, file=1)
1317         assert linkpath.islink()
1318 
1319     def test_symlink_relative(self, tmpdir):
1320         linkpath = tmpdir.join("test")
1321         filepath = tmpdir.join("file")
1322         filepath.write_text("Hello", encoding="utf-8")
1323         linkpath.mksymlinkto(filepath, absolute=False)
1324         assert linkpath.readlink() == "file"
1325         assert filepath.read_text(encoding="utf-8") == linkpath.read_text(
1326             encoding="utf-8"
1327         )
1328 
1329     def test_symlink_not_existing(self, tmpdir):
1330         linkpath = tmpdir.join("testnotexisting")
1331         assert not linkpath.check(link=1)
1332         assert linkpath.check(link=0)
1333 
1334     def test_relto_with_root(self, path1, tmpdir):
1335         y = path1.join("x").relto(local("/"))
1336         assert y[0] == str(path1)[1]
1337 
1338     def test_visit_recursive_symlink(self, tmpdir):
1339         linkpath = tmpdir.join("test")
1340         linkpath.mksymlinkto(tmpdir)
1341         visitor = tmpdir.visit(None, lambda x: x.check(link=0))
1342         assert list(visitor) == [linkpath]
1343 
1344     def test_symlink_isdir(self, tmpdir):
1345         linkpath = tmpdir.join("test")
1346         linkpath.mksymlinkto(tmpdir)
1347         assert linkpath.check(dir=1)
1348         assert not linkpath.check(link=0, dir=1)
1349 
1350     def test_symlink_remove(self, tmpdir):
1351         linkpath = tmpdir.join("test")
1352         linkpath.mksymlinkto(linkpath)  # point to itself
1353         assert linkpath.check(link=1)
1354         linkpath.remove()
1355         assert not linkpath.check()
1356 
1357     def test_realpath_file(self, tmpdir):
1358         linkpath = tmpdir.join("test")
1359         filepath = tmpdir.join("file")
1360         filepath.write_text("", encoding="utf-8")
1361         linkpath.mksymlinkto(filepath)
1362         realpath = linkpath.realpath()
1363         assert realpath.basename == "file"
1364 
1365     def test_owner(self, path1, tmpdir):
1366         from pwd import getpwuid  # type:ignore[attr-defined]
1367         from grp import getgrgid  # type:ignore[attr-defined]
1368 
1369         stat = path1.stat()
1370         assert stat.path == path1
1371 
1372         uid = stat.uid
1373         gid = stat.gid
1374         owner = getpwuid(uid)[0]
1375         group = getgrgid(gid)[0]
1376 
1377         assert uid == stat.uid
1378         assert owner == stat.owner
1379         assert gid == stat.gid
1380         assert group == stat.group
1381 
1382     def test_stat_helpers(self, tmpdir, monkeypatch):
1383         path1 = tmpdir.ensure("file")
1384         stat1 = path1.stat()
1385         stat2 = tmpdir.stat()
1386         assert stat1.isfile()
1387         assert stat2.isdir()
1388         assert not stat1.islink()
1389         assert not stat2.islink()
1390 
1391     def test_stat_non_raising(self, tmpdir):
1392         path1 = tmpdir.join("file")
1393         pytest.raises(error.ENOENT, lambda: path1.stat())
1394         res = path1.stat(raising=False)
1395         assert res is None
1396 
1397     def test_atime(self, tmpdir):
1398         import time
1399 
1400         path = tmpdir.ensure("samplefile")
1401         now = time.time()
1402         atime1 = path.atime()
1403         # we could wait here but timer resolution is very
1404         # system dependent
1405         path.read_binary()
1406         time.sleep(ATIME_RESOLUTION)
1407         atime2 = path.atime()
1408         time.sleep(ATIME_RESOLUTION)
1409         duration = time.time() - now
1410         assert (atime2 - atime1) <= duration
1411 
1412     def test_commondir(self, path1):
1413         # XXX This is here in local until we find a way to implement this
1414         #     using the subversion command line api.
1415         p1 = path1.join("something")
1416         p2 = path1.join("otherthing")
1417         assert p1.common(p2) == path1
1418         assert p2.common(p1) == path1
1419 
1420     def test_commondir_nocommon(self, path1):
1421         # XXX This is here in local until we find a way to implement this
1422         #     using the subversion command line api.
1423         p1 = path1.join("something")
1424         p2 = local(path1.sep + "blabla")
1425         assert p1.common(p2) == "/"
1426 
1427     def test_join_to_root(self, path1):
1428         root = path1.parts()[0]
1429         assert len(str(root)) == 1
1430         assert str(root.join("a")) == "/a"
1431 
1432     def test_join_root_to_root_with_no_abs(self, path1):
1433         nroot = path1.join("/")
1434         assert str(path1) == str(nroot)
1435         assert path1 == nroot
1436 
1437     def test_chmod_simple_int(self, path1):
1438         mode = path1.stat().mode
1439         path1.chmod(int(mode / 2))
1440         try:
1441             assert path1.stat().mode != mode
1442         finally:
1443             path1.chmod(mode)
1444             assert path1.stat().mode == mode
1445 
1446     def test_chmod_rec_int(self, path1):
1447         # XXX fragile test
1448         def recfilter(x):
1449             return x.check(dotfile=0, link=0)
1450 
1451         oldmodes = {}
1452         for x in path1.visit(rec=recfilter):
1453             oldmodes[x] = x.stat().mode
1454         path1.chmod(int("772", 8), rec=recfilter)
1455         try:
1456             for x in path1.visit(rec=recfilter):
1457                 assert x.stat().mode & int("777", 8) == int("772", 8)
1458         finally:
1459             for x, y in oldmodes.items():
1460                 x.chmod(y)
1461 
1462     def test_copy_archiving(self, tmpdir):
1463         unicode_fn = "something-\342\200\223.txt"
1464         f = tmpdir.ensure("a", unicode_fn)
1465         a = f.dirpath()
1466         oldmode = f.stat().mode
1467         newmode = oldmode ^ 1
1468         f.chmod(newmode)
1469         b = tmpdir.join("b")
1470         a.copy(b, mode=True)
1471         assert b.join(f.basename).stat().mode == newmode
1472 
1473     def test_copy_stat_file(self, tmpdir):
1474         src = tmpdir.ensure("src")
1475         dst = tmpdir.join("dst")
1476         # a small delay before the copy
1477         time.sleep(ATIME_RESOLUTION)
1478         src.copy(dst, stat=True)
1479         oldstat = src.stat()
1480         newstat = dst.stat()
1481         assert oldstat.mode == newstat.mode
1482         assert (dst.atime() - src.atime()) < ATIME_RESOLUTION
1483         assert (dst.mtime() - src.mtime()) < ATIME_RESOLUTION
1484 
1485     def test_copy_stat_dir(self, tmpdir):
1486         test_files = ["a", "b", "c"]
1487         src = tmpdir.join("src")
1488         for f in test_files:
1489             src.join(f).write_text(f, ensure=True, encoding="utf-8")
1490         dst = tmpdir.join("dst")
1491         # a small delay before the copy
1492         time.sleep(ATIME_RESOLUTION)
1493         src.copy(dst, stat=True)
1494         for f in test_files:
1495             oldstat = src.join(f).stat()
1496             newstat = dst.join(f).stat()
1497             assert (newstat.atime - oldstat.atime) < ATIME_RESOLUTION
1498             assert (newstat.mtime - oldstat.mtime) < ATIME_RESOLUTION
1499             assert oldstat.mode == newstat.mode
1500 
1501     def test_chown_identity(self, path1):
1502         owner = path1.stat().owner
1503         group = path1.stat().group
1504         path1.chown(owner, group)
1505 
1506     def test_chown_dangling_link(self, path1):
1507         owner = path1.stat().owner
1508         group = path1.stat().group
1509         x = path1.join("hello")
1510         x.mksymlinkto("qlwkejqwlek")
1511         try:
1512             path1.chown(owner, group, rec=1)
1513         finally:
1514             x.remove(rec=0)
1515 
1516     def test_chown_identity_rec_mayfail(self, path1):
1517         owner = path1.stat().owner
1518         group = path1.stat().group
1519         path1.chown(owner, group)
1520 
1521 
1522 class TestUnicodePy2Py3:
1523     def test_join_ensure(self, tmpdir, monkeypatch):
1524         if sys.version_info >= (3, 0) and "LANG" not in os.environ:
1525             pytest.skip("cannot run test without locale")
1526         x = local(tmpdir.strpath)
1527         part = "hllo"
1528         y = x.ensure(part)
1529         assert x.join(part) == y
1530 
1531     def test_listdir(self, tmpdir):
1532         if sys.version_info >= (3, 0) and "LANG" not in os.environ:
1533             pytest.skip("cannot run test without locale")
1534         x = local(tmpdir.strpath)
1535         part = "hllo"
1536         y = x.ensure(part)
1537         assert x.listdir(part)[0] == y
1538 
1539     @pytest.mark.xfail(reason="changing read/write might break existing usages")
1540     def test_read_write(self, tmpdir):
1541         x = tmpdir.join("hello")
1542         part = "hllo"
1543         with ignore_encoding_warning():
1544             x.write(part)
1545             assert x.read() == part
1546             x.write(part.encode(sys.getdefaultencoding()))
1547             assert x.read() == part.encode(sys.getdefaultencoding())
1548 
1549 
1550 class TestBinaryAndTextMethods:
1551     def test_read_binwrite(self, tmpdir):
1552         x = tmpdir.join("hello")
1553         part = "hllo"
1554         part_utf8 = part.encode("utf8")
1555         x.write_binary(part_utf8)
1556         assert x.read_binary() == part_utf8
1557         s = x.read_text(encoding="utf8")
1558         assert s == part
1559         assert isinstance(s, str)
1560 
1561     def test_read_textwrite(self, tmpdir):
1562         x = tmpdir.join("hello")
1563         part = "hllo"
1564         part_utf8 = part.encode("utf8")
1565         x.write_text(part, encoding="utf8")
1566         assert x.read_binary() == part_utf8
1567         assert x.read_text(encoding="utf8") == part
1568 
1569     def test_default_encoding(self, tmpdir):
1570         x = tmpdir.join("hello")
1571         # Can't use UTF8 as the default encoding (ASCII) doesn't support it
1572         part = "hello"
1573         x.write_text(part, "ascii")
1574         s = x.read_text("ascii")
1575         assert s == part
1576         assert type(s) == type(part)

</code><intended_behavior>The code handling namespace packages, both in tests and possibly in the application's core logic (where similar patterns are likely to be present), should ensure consistent and correct import paths to prevent module duplication. This might involve verifying and adjusting how `importlib` is used to import modules part of a namespace package, ensuring that a single instance of each module is maintained across the application.</intended_behavior>, <file>src/_pytest/pytester.py</file>
<class>None</class>
<method>None</method>
<code>
1 """(Disabled by default) support for testing pytest and pytest plugins.
2 
3 PYTEST_DONT_REWRITE
4 """
5 import collections.abc
6 import contextlib
7 import gc
8 import importlib
9 import locale
10 import os
11 import platform
12 import re
13 import shutil
14 import subprocess
15 import sys
16 import traceback
17 from fnmatch import fnmatch
18 from io import StringIO
19 from pathlib import Path
20 from typing import Any
21 from typing import Callable
22 from typing import Dict
23 from typing import Final
24 from typing import final
25 from typing import Generator
26 from typing import IO
27 from typing import Iterable
28 from typing import List
29 from typing import Literal
30 from typing import Optional
31 from typing import overload
32 from typing import Sequence
33 from typing import TextIO
34 from typing import Tuple
35 from typing import Type
36 from typing import TYPE_CHECKING
37 from typing import Union
38 from weakref import WeakKeyDictionary
39 
40 from iniconfig import IniConfig
41 from iniconfig import SectionWrapper
42 
43 from _pytest import timing
44 from _pytest._code import Source
45 from _pytest.capture import _get_multicapture
46 from _pytest.compat import NOTSET
47 from _pytest.compat import NotSetType
48 from _pytest.config import _PluggyPlugin
49 from _pytest.config import Config
50 from _pytest.config import ExitCode
51 from _pytest.config import hookimpl
52 from _pytest.config import main
53 from _pytest.config import PytestPluginManager
54 from _pytest.config.argparsing import Parser
55 from _pytest.deprecated import check_ispytest
56 from _pytest.fixtures import fixture
57 from _pytest.fixtures import FixtureRequest
58 from _pytest.main import Session
59 from _pytest.monkeypatch import MonkeyPatch
60 from _pytest.nodes import Collector
61 from _pytest.nodes import Item
62 from _pytest.outcomes import fail
63 from _pytest.outcomes import importorskip
64 from _pytest.outcomes import skip
65 from _pytest.pathlib import bestrelpath
66 from _pytest.pathlib import copytree
67 from _pytest.pathlib import make_numbered_dir
68 from _pytest.reports import CollectReport
69 from _pytest.reports import TestReport
70 from _pytest.tmpdir import TempPathFactory
71 from _pytest.warning_types import PytestWarning
72 
73 if TYPE_CHECKING:
74     import pexpect
75 
76 
77 pytest_plugins = ["pytester_assertions"]
78 
79 
80 IGNORE_PAM = [  # filenames added when obtaining details about the current user
81     "/var/lib/sss/mc/passwd"
82 ]
83 
84 
85 def pytest_addoption(parser: Parser) -> None:
86     parser.addoption(
87         "--lsof",
88         action="store_true",
89         dest="lsof",
90         default=False,
91         help="Run FD checks if lsof is available",
92     )
93 
94     parser.addoption(
95         "--runpytest",
96         default="inprocess",
97         dest="runpytest",
98         choices=("inprocess", "subprocess"),
99         help=(
100             "Run pytest sub runs in tests using an 'inprocess' "
101             "or 'subprocess' (python -m main) method"
102         ),
103     )
104 
105     parser.addini(
106         "pytester_example_dir", help="Directory to take the pytester example files from"
107     )
108 
109 
110 def pytest_configure(config: Config) -> None:
111     if config.getvalue("lsof"):
112         checker = LsofFdLeakChecker()
113         if checker.matching_platform():
114             config.pluginmanager.register(checker)
115 
116     config.addinivalue_line(
117         "markers",
118         "pytester_example_path(*path_segments): join the given path "
119         "segments to `pytester_example_dir` for this test.",
120     )
121 
122 
123 class LsofFdLeakChecker:
124     def get_open_files(self) -> List[Tuple[str, str]]:
125         out = subprocess.run(
126             ("lsof", "-Ffn0", "-p", str(os.getpid())),
127             stdout=subprocess.PIPE,
128             stderr=subprocess.DEVNULL,
129             check=True,
130             text=True,
131             encoding=locale.getpreferredencoding(False),
132         ).stdout
133 
134         def isopen(line: str) -> bool:
135             return line.startswith("f") and (
136                 "deleted" not in line
137                 and "mem" not in line
138                 and "txt" not in line
139                 and "cwd" not in line
140             )
141 
142         open_files = []
143 
144         for line in out.split("\n"):
145             if isopen(line):
146                 fields = line.split("\0")
147                 fd = fields[0][1:]
148                 filename = fields[1][1:]
149                 if filename in IGNORE_PAM:
150                     continue
151                 if filename.startswith("/"):
152                     open_files.append((fd, filename))
153 
154         return open_files
155 
156     def matching_platform(self) -> bool:
157         try:
158             subprocess.run(("lsof", "-v"), check=True)
159         except (OSError, subprocess.CalledProcessError):
160             return False
161         else:
162             return True
163 
164     @hookimpl(hookwrapper=True, tryfirst=True)
165     def pytest_runtest_protocol(self, item: Item) -> Generator[None, None, None]:
166         lines1 = self.get_open_files()
167         yield
168         if hasattr(sys, "pypy_version_info"):
169             gc.collect()
170         lines2 = self.get_open_files()
171 
172         new_fds = {t[0] for t in lines2} - {t[0] for t in lines1}
173         leaked_files = [t for t in lines2 if t[0] in new_fds]
174         if leaked_files:
175             error = [
176                 "***** %s FD leakage detected" % len(leaked_files),
177                 *(str(f) for f in leaked_files),
178                 "*** Before:",
179                 *(str(f) for f in lines1),
180                 "*** After:",
181                 *(str(f) for f in lines2),
182                 "***** %s FD leakage detected" % len(leaked_files),
183                 "*** function %s:%s: %s " % item.location,
184                 "See issue #2366",
185             ]
186             item.warn(PytestWarning("\n".join(error)))
187 
188 
189 # used at least by pytest-xdist plugin
190 
191 
192 @fixture
193 def _pytest(request: FixtureRequest) -> "PytestArg":
194     """Return a helper which offers a gethookrecorder(hook) method which
195     returns a HookRecorder instance which helps to make assertions about called
196     hooks."""
197     return PytestArg(request)
198 
199 
200 class PytestArg:
201     def __init__(self, request: FixtureRequest) -> None:
202         self._request = request
203 
204     def gethookrecorder(self, hook) -> "HookRecorder":
205         hookrecorder = HookRecorder(hook._pm)
206         self._request.addfinalizer(hookrecorder.finish_recording)
207         return hookrecorder
208 
209 
210 def get_public_names(values: Iterable[str]) -> List[str]:
211     """Only return names from iterator values without a leading underscore."""
212     return [x for x in values if x[0] != "_"]
213 
214 
215 @final
216 class RecordedHookCall:
217     """A recorded call to a hook.
218 
219     The arguments to the hook call are set as attributes.
220     For example:
221 
222     .. code-block:: python
223 
224         calls = hook_recorder.getcalls("pytest_runtest_setup")
225         # Suppose pytest_runtest_setup was called once with `item=an_item`.
226         assert calls[0].item is an_item
227     """
228 
229     def __init__(self, name: str, kwargs) -> None:
230         self.__dict__.update(kwargs)
231         self._name = name
232 
233     def __repr__(self) -> str:
234         d = self.__dict__.copy()
235         del d["_name"]
236         return f"<RecordedHookCall {self._name!r}(**{d!r})>"
237 
238     if TYPE_CHECKING:
239         # The class has undetermined attributes, this tells mypy about it.
240         def __getattr__(self, key: str):
241             ...
242 
243 
244 @final
245 class HookRecorder:
246     """Record all hooks called in a plugin manager.
247 
248     Hook recorders are created by :class:`Pytester`.
249 
250     This wraps all the hook calls in the plugin manager, recording each call
251     before propagating the normal calls.
252     """
253 
254     def __init__(
255         self, pluginmanager: PytestPluginManager, *, _ispytest: bool = False
256     ) -> None:
257         check_ispytest(_ispytest)
258 
259         self._pluginmanager = pluginmanager
260         self.calls: List[RecordedHookCall] = []
261         self.ret: Optional[Union[int, ExitCode]] = None
262 
263         def before(hook_name: str, hook_impls, kwargs) -> None:
264             self.calls.append(RecordedHookCall(hook_name, kwargs))
265 
266         def after(outcome, hook_name: str, hook_impls, kwargs) -> None:
267             pass
268 
269         self._undo_wrapping = pluginmanager.add_hookcall_monitoring(before, after)
270 
271     def finish_recording(self) -> None:
272         self._undo_wrapping()
273 
274     def getcalls(self, names: Union[str, Iterable[str]]) -> List[RecordedHookCall]:
275         """Get all recorded calls to hooks with the given names (or name)."""
276         if isinstance(names, str):
277             names = names.split()
278         return [call for call in self.calls if call._name in names]
279 
280     def assert_contains(self, entries: Sequence[Tuple[str, str]]) -> None:
281         __tracebackhide__ = True
282         i = 0
283         entries = list(entries)
284         backlocals = sys._getframe(1).f_locals
285         while entries:
286             name, check = entries.pop(0)
287             for ind, call in enumerate(self.calls[i:]):
288                 if call._name == name:
289                     print("NAMEMATCH", name, call)
290                     if eval(check, backlocals, call.__dict__):
291                         print("CHECKERMATCH", repr(check), "->", call)
292                     else:
293                         print("NOCHECKERMATCH", repr(check), "-", call)
294                         continue
295                     i += ind + 1
296                     break
297                 print("NONAMEMATCH", name, "with", call)
298             else:
299                 fail(f"could not find {name!r} check {check!r}")
300 
301     def popcall(self, name: str) -> RecordedHookCall:
302         __tracebackhide__ = True
303         for i, call in enumerate(self.calls):
304             if call._name == name:
305                 del self.calls[i]
306                 return call
307         lines = [f"could not find call {name!r}, in:"]
308         lines.extend(["  %s" % x for x in self.calls])
309         fail("\n".join(lines))
310 
311     def getcall(self, name: str) -> RecordedHookCall:
312         values = self.getcalls(name)
313         assert len(values) == 1, (name, values)
314         return values[0]
315 
316     # functionality for test reports
317 
318     @overload
319     def getreports(
320         self,
321         names: "Literal['pytest_collectreport']",
322     ) -> Sequence[CollectReport]:
323         ...
324 
325     @overload
326     def getreports(
327         self,
328         names: "Literal['pytest_runtest_logreport']",
329     ) -> Sequence[TestReport]:
330         ...
331 
332     @overload
333     def getreports(
334         self,
335         names: Union[str, Iterable[str]] = (
336             "pytest_collectreport",
337             "pytest_runtest_logreport",
338         ),
339     ) -> Sequence[Union[CollectReport, TestReport]]:
340         ...
341 
342     def getreports(
343         self,
344         names: Union[str, Iterable[str]] = (
345             "pytest_collectreport",
346             "pytest_runtest_logreport",
347         ),
348     ) -> Sequence[Union[CollectReport, TestReport]]:
349         return [x.report for x in self.getcalls(names)]
350 
351     def matchreport(
352         self,
353         inamepart: str = "",
354         names: Union[str, Iterable[str]] = (
355             "pytest_runtest_logreport",
356             "pytest_collectreport",
357         ),
358         when: Optional[str] = None,
359     ) -> Union[CollectReport, TestReport]:
360         """Return a testreport whose dotted import path matches."""
361         values = []
362         for rep in self.getreports(names=names):
363             if not when and rep.when != "call" and rep.passed:
364                 # setup/teardown passing reports - let's ignore those
365                 continue
366             if when and rep.when != when:
367                 continue
368             if not inamepart or inamepart in rep.nodeid.split("::"):
369                 values.append(rep)
370         if not values:
371             raise ValueError(
372                 "could not find test report matching %r: "
373                 "no test reports at all!" % (inamepart,)
374             )
375         if len(values) > 1:
376             raise ValueError(
377                 "found 2 or more testreports matching {!r}: {}".format(
378                     inamepart, values
379                 )
380             )
381         return values[0]
382 
383     @overload
384     def getfailures(
385         self,
386         names: "Literal['pytest_collectreport']",
387     ) -> Sequence[CollectReport]:
388         ...
389 
390     @overload
391     def getfailures(
392         self,
393         names: "Literal['pytest_runtest_logreport']",
394     ) -> Sequence[TestReport]:
395         ...
396 
397     @overload
398     def getfailures(
399         self,
400         names: Union[str, Iterable[str]] = (
401             "pytest_collectreport",
402             "pytest_runtest_logreport",
403         ),
404     ) -> Sequence[Union[CollectReport, TestReport]]:
405         ...
406 
407     def getfailures(
408         self,
409         names: Union[str, Iterable[str]] = (
410             "pytest_collectreport",
411             "pytest_runtest_logreport",
412         ),
413     ) -> Sequence[Union[CollectReport, TestReport]]:
414         return [rep for rep in self.getreports(names) if rep.failed]
415 
416     def getfailedcollections(self) -> Sequence[CollectReport]:
417         return self.getfailures("pytest_collectreport")
418 
419     def listoutcomes(
420         self,
421     ) -> Tuple[
422         Sequence[TestReport],
423         Sequence[Union[CollectReport, TestReport]],
424         Sequence[Union[CollectReport, TestReport]],
425     ]:
426         passed = []
427         skipped = []
428         failed = []
429         for rep in self.getreports(
430             ("pytest_collectreport", "pytest_runtest_logreport")
431         ):
432             if rep.passed:
433                 if rep.when == "call":
434                     assert isinstance(rep, TestReport)
435                     passed.append(rep)
436             elif rep.skipped:
437                 skipped.append(rep)
438             else:
439                 assert rep.failed, f"Unexpected outcome: {rep!r}"
440                 failed.append(rep)
441         return passed, skipped, failed
442 
443     def countoutcomes(self) -> List[int]:
444         return [len(x) for x in self.listoutcomes()]
445 
446     def assertoutcome(self, passed: int = 0, skipped: int = 0, failed: int = 0) -> None:
447         __tracebackhide__ = True
448         from _pytest.pytester_assertions import assertoutcome
449 
450         outcomes = self.listoutcomes()
451         assertoutcome(
452             outcomes,
453             passed=passed,
454             skipped=skipped,
455             failed=failed,
456         )
457 
458     def clear(self) -> None:
459         self.calls[:] = []
460 
461 
462 @fixture
463 def linecomp() -> "LineComp":
464     """A :class: `LineComp` instance for checking that an input linearly
465     contains a sequence of strings."""
466     return LineComp()
467 
468 
469 @fixture(name="LineMatcher")
470 def LineMatcher_fixture(request: FixtureRequest) -> Type["LineMatcher"]:
471     """A reference to the :class: `LineMatcher`.
472 
473     This is instantiable with a list of lines (without their trailing newlines).
474     This is useful for testing large texts, such as the output of commands.
475     """
476     return LineMatcher
477 
478 
479 @fixture
480 def pytester(
481     request: FixtureRequest, tmp_path_factory: TempPathFactory, monkeypatch: MonkeyPatch
482 ) -> "Pytester":
483     """
484     Facilities to write tests/configuration files, execute pytest in isolation, and match
485     against expected output, perfect for black-box testing of pytest plugins.
486 
487     It attempts to isolate the test run from external factors as much as possible, modifying
488     the current working directory to ``path`` and environment variables during initialization.
489 
490     It is particularly useful for testing plugins. It is similar to the :fixture:`tmp_path`
491     fixture but provides methods which aid in testing pytest itself.
492     """
493     return Pytester(request, tmp_path_factory, monkeypatch, _ispytest=True)
494 
495 
496 @fixture
497 def _sys_snapshot() -> Generator[None, None, None]:
498     snappaths = SysPathsSnapshot()
499     snapmods = SysModulesSnapshot()
500     yield
501     snapmods.restore()
502     snappaths.restore()
503 
504 
505 @fixture
506 def _config_for_test() -> Generator[Config, None, None]:
507     from _pytest.config import get_config
508 
509     config = get_config()
510     yield config
511     config._ensure_unconfigure()  # cleanup, e.g. capman closing tmpfiles.
512 
513 
514 # Regex to match the session duration string in the summary: "74.34s".
515 rex_session_duration = re.compile(r"\d+\.\d\ds")
516 # Regex to match all the counts and phrases in the summary line: "34 passed, 111 skipped".
517 rex_outcome = re.compile(r"(\d+) (\w+)")
518 
519 
520 @final
521 class RunResult:
522     """The result of running a command from :class:`~pytest.Pytester`."""
523 
524     def __init__(
525         self,
526         ret: Union[int, ExitCode],
527         outlines: List[str],
528         errlines: List[str],
529         duration: float,
530     ) -> None:
531         try:
532             self.ret: Union[int, ExitCode] = ExitCode(ret)
533             """The return value."""
534         except ValueError:
535             self.ret = ret
536         self.outlines = outlines
537         """List of lines captured from stdout."""
538         self.errlines = errlines
539         """List of lines captured from stderr."""
540         self.stdout = LineMatcher(outlines)
541         """:class:`~pytest.LineMatcher` of stdout.
542 
543         Use e.g. :func:`str(stdout) <pytest.LineMatcher.__str__()>` to reconstruct stdout, or the commonly used
544         :func:`stdout.fnmatch_lines() <pytest.LineMatcher.fnmatch_lines()>` method.
545         """
546         self.stderr = LineMatcher(errlines)
547         """:class:`~pytest.LineMatcher` of stderr."""
548         self.duration = duration
549         """Duration in seconds."""
550 
551     def __repr__(self) -> str:
552         return (
553             "<RunResult ret=%s len(stdout.lines)=%d len(stderr.lines)=%d duration=%.2fs>"
554             % (self.ret, len(self.stdout.lines), len(self.stderr.lines), self.duration)
555         )
556 
557     def parseoutcomes(self) -> Dict[str, int]:
558         """Return a dictionary of outcome noun -> count from parsing the terminal
559         output that the test process produced.
560 
561         The returned nouns will always be in plural form::
562 
563             ======= 1 failed, 1 passed, 1 warning, 1 error in 0.13s ====
564 
565         Will return ``{"failed": 1, "passed": 1, "warnings": 1, "errors": 1}``.
566         """
567         return self.parse_summary_nouns(self.outlines)
568 
569     @classmethod
570     def parse_summary_nouns(cls, lines) -> Dict[str, int]:
571         """Extract the nouns from a pytest terminal summary line.
572 
573         It always returns the plural noun for consistency::
574 
575             ======= 1 failed, 1 passed, 1 warning, 1 error in 0.13s ====
576 
577         Will return ``{"failed": 1, "passed": 1, "warnings": 1, "errors": 1}``.
578         """
579         for line in reversed(lines):
580             if rex_session_duration.search(line):
581                 outcomes = rex_outcome.findall(line)
582                 ret = {noun: int(count) for (count, noun) in outcomes}
583                 break
584         else:
585             raise ValueError("Pytest terminal summary report not found")
586 
587         to_plural = {
588             "warning": "warnings",
589             "error": "errors",
590         }
591         return {to_plural.get(k, k): v for k, v in ret.items()}
592 
593     def assert_outcomes(
594         self,
595         passed: int = 0,
596         skipped: int = 0,
597         failed: int = 0,
598         errors: int = 0,
599         xpassed: int = 0,
600         xfailed: int = 0,
601         warnings: Optional[int] = None,
602         deselected: Optional[int] = None,
603     ) -> None:
604         """
605         Assert that the specified outcomes appear with the respective
606         numbers (0 means it didn't occur) in the text output from a test run.
607 
608         ``warnings`` and ``deselected`` are only checked if not None.
609         """
610         __tracebackhide__ = True
611         from _pytest.pytester_assertions import assert_outcomes
612 
613         outcomes = self.parseoutcomes()
614         assert_outcomes(
615             outcomes,
616             passed=passed,
617             skipped=skipped,
618             failed=failed,
619             errors=errors,
620             xpassed=xpassed,
621             xfailed=xfailed,
622             warnings=warnings,
623             deselected=deselected,
624         )
625 
626 
627 class CwdSnapshot:
628     def __init__(self) -> None:
629         self.__saved = os.getcwd()
630 
631     def restore(self) -> None:
632         os.chdir(self.__saved)
633 
634 
635 class SysModulesSnapshot:
636     def __init__(self, preserve: Optional[Callable[[str], bool]] = None) -> None:
637         self.__preserve = preserve
638         self.__saved = dict(sys.modules)
639 
640     def restore(self) -> None:
641         if self.__preserve:
642             self.__saved.update(
643                 (k, m) for k, m in sys.modules.items() if self.__preserve(k)
644             )
645         sys.modules.clear()
646         sys.modules.update(self.__saved)
647 
648 
649 class SysPathsSnapshot:
650     def __init__(self) -> None:
651         self.__saved = list(sys.path), list(sys.meta_path)
652 
653     def restore(self) -> None:
654         sys.path[:], sys.meta_path[:] = self.__saved
655 
656 
657 @final
658 class Pytester:
659     """
660     Facilities to write tests/configuration files, execute pytest in isolation, and match
661     against expected output, perfect for black-box testing of pytest plugins.
662 
663     It attempts to isolate the test run from external factors as much as possible, modifying
664     the current working directory to :attr:`path` and environment variables during initialization.
665     """
666 
667     __test__ = False
668 
669     CLOSE_STDIN: "Final" = NOTSET
670 
671     class TimeoutExpired(Exception):
672         pass
673 
674     def __init__(
675         self,
676         request: FixtureRequest,
677         tmp_path_factory: TempPathFactory,
678         monkeypatch: MonkeyPatch,
679         *,
680         _ispytest: bool = False,
681     ) -> None:
682         check_ispytest(_ispytest)
683         self._request = request
684         self._mod_collections: WeakKeyDictionary[
685             Collector, List[Union[Item, Collector]]
686         ] = WeakKeyDictionary()
687         if request.function:
688             name: str = request.function.__name__
689         else:
690             name = request.node.name
691         self._name = name
692         self._path: Path = tmp_path_factory.mktemp(name, numbered=True)
693         #: A list of plugins to use with :py:meth:`parseconfig` and
694         #: :py:meth:`runpytest`.  Initially this is an empty list but plugins can
695         #: be added to the list.  The type of items to add to the list depends on
696         #: the method using them so refer to them for details.
697         self.plugins: List[Union[str, _PluggyPlugin]] = []
698         self._cwd_snapshot = CwdSnapshot()
699         self._sys_path_snapshot = SysPathsSnapshot()
700         self._sys_modules_snapshot = self.__take_sys_modules_snapshot()
701         self.chdir()
702         self._request.addfinalizer(self._finalize)
703         self._method = self._request.config.getoption("--runpytest")
704         self._test_tmproot = tmp_path_factory.mktemp(f"tmp-{name}", numbered=True)
705 
706         self._monkeypatch = mp = monkeypatch
707         mp.setenv("PYTEST_DEBUG_TEMPROOT", str(self._test_tmproot))
708         # Ensure no unexpected caching via tox.
709         mp.delenv("TOX_ENV_DIR", raising=False)
710         # Discard outer pytest options.
711         mp.delenv("PYTEST_ADDOPTS", raising=False)
712         # Ensure no user config is used.
713         tmphome = str(self.path)
714         mp.setenv("HOME", tmphome)
715         mp.setenv("USERPROFILE", tmphome)
716         # Do not use colors for inner runs by default.
717         mp.setenv("PY_COLORS", "0")
718 
719     @property
720     def path(self) -> Path:
721         """Temporary directory path used to create files/run tests from, etc."""
722         return self._path
723 
724     def __repr__(self) -> str:
725         return f"<Pytester {self.path!r}>"
726 
727     def _finalize(self) -> None:
728         """
729         Clean up global state artifacts.
730 
731         Some methods modify the global interpreter state and this tries to
732         clean this up. It does not remove the temporary directory however so
733         it can be looked at after the test run has finished.
734         """
735         self._sys_modules_snapshot.restore()
736         self._sys_path_snapshot.restore()
737         self._cwd_snapshot.restore()
738 
739     def __take_sys_modules_snapshot(self) -> SysModulesSnapshot:
740         # Some zope modules used by twisted-related tests keep internal state
741         # and can't be deleted; we had some trouble in the past with
742         # `zope.interface` for example.
743         #
744         # Preserve readline due to https://bugs.python.org/issue41033.
745         # pexpect issues a SIGWINCH.
746         def preserve_module(name):
747             return name.startswith(("zope", "readline"))
748 
749         return SysModulesSnapshot(preserve=preserve_module)
750 
751     def make_hook_recorder(self, pluginmanager: PytestPluginManager) -> HookRecorder:
752         """Create a new :class:`HookRecorder` for a :class:`PytestPluginManager`."""
753         pluginmanager.reprec = reprec = HookRecorder(pluginmanager, _ispytest=True)
754         self._request.addfinalizer(reprec.finish_recording)
755         return reprec
756 
757     def chdir(self) -> None:
758         """Cd into the temporary directory.
759 
760         This is done automatically upon instantiation.
761         """
762         os.chdir(self.path)
763 
764     def _makefile(
765         self,
766         ext: str,
767         lines: Sequence[Union[Any, bytes]],
768         files: Dict[str, str],
769         encoding: str = "utf-8",
770     ) -> Path:
771         items = list(files.items())
772 
773         if ext and not ext.startswith("."):
774             raise ValueError(
775                 f"pytester.makefile expects a file extension, try .{ext} instead of {ext}"
776             )
777 
778         def to_text(s: Union[Any, bytes]) -> str:
779             return s.decode(encoding) if isinstance(s, bytes) else str(s)
780 
781         if lines:
782             source = "\n".join(to_text(x) for x in lines)
783             basename = self._name
784             items.insert(0, (basename, source))
785 
786         ret = None
787         for basename, value in items:
788             p = self.path.joinpath(basename).with_suffix(ext)
789             p.parent.mkdir(parents=True, exist_ok=True)
790             source_ = Source(value)
791             source = "\n".join(to_text(line) for line in source_.lines)
792             p.write_text(source.strip(), encoding=encoding)
793             if ret is None:
794                 ret = p
795         assert ret is not None
796         return ret
797 
798     def makefile(self, ext: str, *args: str, **kwargs: str) -> Path:
799         r"""Create new text file(s) in the test directory.
800 
801         :param ext:
802             The extension the file(s) should use, including the dot, e.g. `.py`.
803         :param args:
804             All args are treated as strings and joined using newlines.
805             The result is written as contents to the file.  The name of the
806             file is based on the test function requesting this fixture.
807         :param kwargs:
808             Each keyword is the name of a file, while the value of it will
809             be written as contents of the file.
810         :returns:
811             The first created file.
812 
813         Examples:
814 
815         .. code-block:: python
816 
817             pytester.makefile(".txt", "line1", "line2")
818 
819             pytester.makefile(".ini", pytest="[pytest]\naddopts=-rs\n")
820 
821         To create binary files, use :meth:`pathlib.Path.write_bytes` directly:
822 
823         .. code-block:: python
824 
825             filename = pytester.path.joinpath("foo.bin")
826             filename.write_bytes(b"...")
827         """
828         return self._makefile(ext, args, kwargs)
829 
830     def makeconftest(self, source: str) -> Path:
831         """Write a contest.py file.
832 
833         :param source: The contents.
834         :returns: The conftest.py file.
835         """
836         return self.makepyfile(conftest=source)
837 
838     def makeini(self, source: str) -> Path:
839         """Write a tox.ini file.
840 
841         :param source: The contents.
842         :returns: The tox.ini file.
843         """
844         return self.makefile(".ini", tox=source)
845 
846     def getinicfg(self, source: str) -> SectionWrapper:
847         """Return the pytest section from the tox.ini config file."""
848         p = self.makeini(source)
849         return IniConfig(str(p))["pytest"]
850 
851     def makepyprojecttoml(self, source: str) -> Path:
852         """Write a pyproject.toml file.
853 
854         :param source: The contents.
855         :returns: The pyproject.ini file.
856 
857         .. versionadded:: 6.0
858         """
859         return self.makefile(".toml", pyproject=source)
860 
861     def makepyfile(self, *args, **kwargs) -> Path:
862         r"""Shortcut for .makefile() with a .py extension.
863 
864         Defaults to the test name with a '.py' extension, e.g test_foobar.py, overwriting
865         existing files.
866 
867         Examples:
868 
869         .. code-block:: python
870 
871             def test_something(pytester):
872                 # Initial file is created test_something.py.
873                 pytester.makepyfile("foobar")
874                 # To create multiple files, pass kwargs accordingly.
875                 pytester.makepyfile(custom="foobar")
876                 # At this point, both 'test_something.py' & 'custom.py' exist in the test directory.
877 
878         """
879         return self._makefile(".py", args, kwargs)
880 
881     def maketxtfile(self, *args, **kwargs) -> Path:
882         r"""Shortcut for .makefile() with a .txt extension.
883 
884         Defaults to the test name with a '.txt' extension, e.g test_foobar.txt, overwriting
885         existing files.
886 
887         Examples:
888 
889         .. code-block:: python
890 
891             def test_something(pytester):
892                 # Initial file is created test_something.txt.
893                 pytester.maketxtfile("foobar")
894                 # To create multiple files, pass kwargs accordingly.
895                 pytester.maketxtfile(custom="foobar")
896                 # At this point, both 'test_something.txt' & 'custom.txt' exist in the test directory.
897 
898         """
899         return self._makefile(".txt", args, kwargs)
900 
901     def syspathinsert(
902         self, path: Optional[Union[str, "os.PathLike[str]"]] = None
903     ) -> None:
904         """Prepend a directory to sys.path, defaults to :attr:`path`.
905 
906         This is undone automatically when this object dies at the end of each
907         test.
908 
909         :param path:
910             The path.
911         """
912         if path is None:
913             path = self.path
914 
915         self._monkeypatch.syspath_prepend(str(path))
916 
917     def mkdir(self, name: Union[str, "os.PathLike[str]"]) -> Path:
918         """Create a new (sub)directory.
919 
920         :param name:
921             The name of the directory, relative to the pytester path.
922         :returns:
923             The created directory.
924         """
925         p = self.path / name
926         p.mkdir()
927         return p
928 
929     def mkpydir(self, name: Union[str, "os.PathLike[str]"]) -> Path:
930         """Create a new python package.
931 
932         This creates a (sub)directory with an empty ``__init__.py`` file so it
933         gets recognised as a Python package.
934         """
935         p = self.path / name
936         p.mkdir()
937         p.joinpath("__init__.py").touch()
938         return p
939 
940     def copy_example(self, name: Optional[str] = None) -> Path:
941         """Copy file from project's directory into the testdir.
942 
943         :param name:
944             The name of the file to copy.
945         :return:
946             Path to the copied directory (inside ``self.path``).
947         """
948         example_dir_ = self._request.config.getini("pytester_example_dir")
949         if example_dir_ is None:
950             raise ValueError("pytester_example_dir is unset, can't copy examples")
951         example_dir: Path = self._request.config.rootpath / example_dir_
952 
953         for extra_element in self._request.node.iter_markers("pytester_example_path"):
954             assert extra_element.args
955             example_dir = example_dir.joinpath(*extra_element.args)
956 
957         if name is None:
958             func_name = self._name
959             maybe_dir = example_dir / func_name
960             maybe_file = example_dir / (func_name + ".py")
961 
962             if maybe_dir.is_dir():
963                 example_path = maybe_dir
964             elif maybe_file.is_file():
965                 example_path = maybe_file
966             else:
967                 raise LookupError(
968                     f"{func_name} can't be found as module or package in {example_dir}"
969                 )
970         else:
971             example_path = example_dir.joinpath(name)
972 
973         if example_path.is_dir() and not example_path.joinpath("__init__.py").is_file():
974             copytree(example_path, self.path)
975             return self.path
976         elif example_path.is_file():
977             result = self.path.joinpath(example_path.name)
978             shutil.copy(example_path, result)
979             return result
980         else:
981             raise LookupError(
982                 f'example "{example_path}" is not found as a file or directory'
983             )
984 
985     def getnode(
986         self, config: Config, arg: Union[str, "os.PathLike[str]"]
987     ) -> Union[Collector, Item]:
988         """Get the collection node of a file.
989 
990         :param config:
991            A pytest config.
992            See :py:meth:`parseconfig` and :py:meth:`parseconfigure` for creating it.
993         :param arg:
994             Path to the file.
995         :returns:
996             The node.
997         """
998         session = Session.from_config(config)
999         assert "::" not in str(arg)
1000         p = Path(os.path.abspath(arg))
1001         config.hook.pytest_sessionstart(session=session)
1002         res = session.perform_collect([str(p)], genitems=False)[0]
1003         config.hook.pytest_sessionfinish(session=session, exitstatus=ExitCode.OK)
1004         return res
1005 
1006     def getpathnode(
1007         self, path: Union[str, "os.PathLike[str]"]
1008     ) -> Union[Collector, Item]:
1009         """Return the collection node of a file.
1010 
1011         This is like :py:meth:`getnode` but uses :py:meth:`parseconfigure` to
1012         create the (configured) pytest Config instance.
1013 
1014         :param path:
1015             Path to the file.
1016         :returns:
1017             The node.
1018         """
1019         path = Path(path)
1020         config = self.parseconfigure(path)
1021         session = Session.from_config(config)
1022         x = bestrelpath(session.path, path)
1023         config.hook.pytest_sessionstart(session=session)
1024         res = session.perform_collect([x], genitems=False)[0]
1025         config.hook.pytest_sessionfinish(session=session, exitstatus=ExitCode.OK)
1026         return res
1027 
1028     def genitems(self, colitems: Sequence[Union[Item, Collector]]) -> List[Item]:
1029         """Generate all test items from a collection node.
1030 
1031         This recurses into the collection node and returns a list of all the
1032         test items contained within.
1033 
1034         :param colitems:
1035             The collection nodes.
1036         :returns:
1037             The collected items.
1038         """
1039         session = colitems[0].session
1040         result: List[Item] = []
1041         for colitem in colitems:
1042             result.extend(session.genitems(colitem))
1043         return result
1044 
1045     def runitem(self, source: str) -> Any:
1046         """Run the "test_func" Item.
1047 
1048         The calling test instance (class containing the test method) must
1049         provide a ``.getrunner()`` method which should return a runner which
1050         can run the test protocol for a single item, e.g.
1051         :py:func:`_pytest.runner.runtestprotocol`.
1052         """
1053         # used from runner functional tests
1054         item = self.getitem(source)
1055         # the test class where we are called from wants to provide the runner
1056         testclassinstance = self._request.instance
1057         runner = testclassinstance.getrunner()
1058         return runner(item)
1059 
1060     def inline_runsource(self, source: str, *cmdlineargs) -> HookRecorder:
1061         """Run a test module in process using ``pytest.main()``.
1062 
1063         This run writes "source" into a temporary file and runs
1064         ``pytest.main()`` on it, returning a :py:class:`HookRecorder` instance
1065         for the result.
1066 
1067         :param source: The source code of the test module.
1068         :param cmdlineargs: Any extra command line arguments to use.
1069         """
1070         p = self.makepyfile(source)
1071         values = list(cmdlineargs) + [p]
1072         return self.inline_run(*values)
1073 
1074     def inline_genitems(self, *args) -> Tuple[List[Item], HookRecorder]:
1075         """Run ``pytest.main(['--collectonly'])`` in-process.
1076 
1077         Runs the :py:func:`pytest.main` function to run all of pytest inside
1078         the test process itself like :py:meth:`inline_run`, but returns a
1079         tuple of the collected items and a :py:class:`HookRecorder` instance.
1080         """
1081         rec = self.inline_run("--collect-only", *args)
1082         items = [x.item for x in rec.getcalls("pytest_itemcollected")]
1083         return items, rec
1084 
1085     def inline_run(
1086         self,
1087         *args: Union[str, "os.PathLike[str]"],
1088         plugins=(),
1089         no_reraise_ctrlc: bool = False,
1090     ) -> HookRecorder:
1091         """Run ``pytest.main()`` in-process, returning a HookRecorder.
1092 
1093         Runs the :py:func:`pytest.main` function to run all of pytest inside
1094         the test process itself.  This means it can return a
1095         :py:class:`HookRecorder` instance which gives more detailed results
1096         from that run than can be done by matching stdout/stderr from
1097         :py:meth:`runpytest`.
1098 
1099         :param args:
1100             Command line arguments to pass to :py:func:`pytest.main`.
1101         :param plugins:
1102             Extra plugin instances the ``pytest.main()`` instance should use.
1103         :param no_reraise_ctrlc:
1104             Typically we reraise keyboard interrupts from the child run. If
1105             True, the KeyboardInterrupt exception is captured.
1106         """
1107         # (maybe a cpython bug?) the importlib cache sometimes isn't updated
1108         # properly between file creation and inline_run (especially if imports
1109         # are interspersed with file creation)
1110         importlib.invalidate_caches()
1111 
1112         plugins = list(plugins)
1113         finalizers = []
1114         try:
1115             # Any sys.module or sys.path changes done while running pytest
1116             # inline should be reverted after the test run completes to avoid
1117             # clashing with later inline tests run within the same pytest test,
1118             # e.g. just because they use matching test module names.
1119             finalizers.append(self.__take_sys_modules_snapshot().restore)
1120             finalizers.append(SysPathsSnapshot().restore)
1121 
1122             # Important note:
1123             # - our tests should not leave any other references/registrations
1124             #   laying around other than possibly loaded test modules
1125             #   referenced from sys.modules, as nothing will clean those up
1126             #   automatically
1127 
1128             rec = []
1129 
1130             class Collect:
1131                 def pytest_configure(x, config: Config) -> None:
1132                     rec.append(self.make_hook_recorder(config.pluginmanager))
1133 
1134             plugins.append(Collect())
1135             ret = main([str(x) for x in args], plugins=plugins)
1136             if len(rec) == 1:
1137                 reprec = rec.pop()
1138             else:
1139 
1140                 class reprec:  # type: ignore
1141                     pass
1142 
1143             reprec.ret = ret
1144 
1145             # Typically we reraise keyboard interrupts from the child run
1146             # because it's our user requesting interruption of the testing.
1147             if ret == ExitCode.INTERRUPTED and not no_reraise_ctrlc:
1148                 calls = reprec.getcalls("pytest_keyboard_interrupt")
1149                 if calls and calls[-1].excinfo.type == KeyboardInterrupt:
1150                     raise KeyboardInterrupt()
1151             return reprec
1152         finally:
1153             for finalizer in finalizers:
1154                 finalizer()
1155 
1156     def runpytest_inprocess(
1157         self, *args: Union[str, "os.PathLike[str]"], **kwargs: Any
1158     ) -> RunResult:
1159         """Return result of running pytest in-process, providing a similar
1160         interface to what self.runpytest() provides."""
1161         syspathinsert = kwargs.pop("syspathinsert", False)
1162 
1163         if syspathinsert:
1164             self.syspathinsert()
1165         now = timing.time()
1166         capture = _get_multicapture("sys")
1167         capture.start_capturing()
1168         try:
1169             try:
1170                 reprec = self.inline_run(*args, **kwargs)
1171             except SystemExit as e:
1172                 ret = e.args[0]
1173                 try:
1174                     ret = ExitCode(e.args[0])
1175                 except ValueError:
1176                     pass
1177 
1178                 class reprec:  # type: ignore
1179                     ret = ret
1180 
1181             except Exception:
1182                 traceback.print_exc()
1183 
1184                 class reprec:  # type: ignore
1185                     ret = ExitCode(3)
1186 
1187         finally:
1188             out, err = capture.readouterr()
1189             capture.stop_capturing()
1190             sys.stdout.write(out)
1191             sys.stderr.write(err)
1192 
1193         assert reprec.ret is not None
1194         res = RunResult(
1195             reprec.ret, out.splitlines(), err.splitlines(), timing.time() - now
1196         )
1197         res.reprec = reprec  # type: ignore
1198         return res
1199 
1200     def runpytest(
1201         self, *args: Union[str, "os.PathLike[str]"], **kwargs: Any
1202     ) -> RunResult:
1203         """Run pytest inline or in a subprocess, depending on the command line
1204         option "--runpytest" and return a :py:class:`~pytest.RunResult`."""
1205         new_args = self._ensure_basetemp(args)
1206         if self._method == "inprocess":
1207             return self.runpytest_inprocess(*new_args, **kwargs)
1208         elif self._method == "subprocess":
1209             return self.runpytest_subprocess(*new_args, **kwargs)
1210         raise RuntimeError(f"Unrecognized runpytest option: {self._method}")
1211 
1212     def _ensure_basetemp(
1213         self, args: Sequence[Union[str, "os.PathLike[str]"]]
1214     ) -> List[Union[str, "os.PathLike[str]"]]:
1215         new_args = list(args)
1216         for x in new_args:
1217             if str(x).startswith("--basetemp"):
1218                 break
1219         else:
1220             new_args.append("--basetemp=%s" % self.path.parent.joinpath("basetemp"))
1221         return new_args
1222 
1223     def parseconfig(self, *args: Union[str, "os.PathLike[str]"]) -> Config:
1224         """Return a new pytest :class:`pytest.Config` instance from given
1225         commandline args.
1226 
1227         This invokes the pytest bootstrapping code in _pytest.config to create a
1228         new :py:class:`pytest.PytestPluginManager` and call the
1229         :hook:`pytest_cmdline_parse` hook to create a new :class:`pytest.Config`
1230         instance.
1231 
1232         If :attr:`plugins` has been populated they should be plugin modules
1233         to be registered with the plugin manager.
1234         """
1235         import _pytest.config
1236 
1237         new_args = self._ensure_basetemp(args)
1238         new_args = [str(x) for x in new_args]
1239 
1240         config = _pytest.config._prepareconfig(new_args, self.plugins)  # type: ignore[arg-type]
1241         # we don't know what the test will do with this half-setup config
1242         # object and thus we make sure it gets unconfigured properly in any
1243         # case (otherwise capturing could still be active, for example)
1244         self._request.addfinalizer(config._ensure_unconfigure)
1245         return config
1246 
1247     def parseconfigure(self, *args: Union[str, "os.PathLike[str]"]) -> Config:
1248         """Return a new pytest configured Config instance.
1249 
1250         Returns a new :py:class:`pytest.Config` instance like
1251         :py:meth:`parseconfig`, but also calls the :hook:`pytest_configure`
1252         hook.
1253         """
1254         config = self.parseconfig(*args)
1255         config._do_configure()
1256         return config
1257 
1258     def getitem(
1259         self, source: Union[str, "os.PathLike[str]"], funcname: str = "test_func"
1260     ) -> Item:
1261         """Return the test item for a test function.
1262 
1263         Writes the source to a python file and runs pytest's collection on
1264         the resulting module, returning the test item for the requested
1265         function name.
1266 
1267         :param source:
1268             The module source.
1269         :param funcname:
1270             The name of the test function for which to return a test item.
1271         :returns:
1272             The test item.
1273         """
1274         items = self.getitems(source)
1275         for item in items:
1276             if item.name == funcname:
1277                 return item
1278         assert 0, "{!r} item not found in module:\n{}\nitems: {}".format(
1279             funcname, source, items
1280         )
1281 
1282     def getitems(self, source: Union[str, "os.PathLike[str]"]) -> List[Item]:
1283         """Return all test items collected from the module.
1284 
1285         Writes the source to a Python file and runs pytest's collection on
1286         the resulting module, returning all test items contained within.
1287         """
1288         modcol = self.getmodulecol(source)
1289         return self.genitems([modcol])
1290 
1291     def getmodulecol(
1292         self,
1293         source: Union[str, "os.PathLike[str]"],
1294         configargs=(),
1295         *,
1296         withinit: bool = False,
1297     ):
1298         """Return the module collection node for ``source``.
1299 
1300         Writes ``source`` to a file using :py:meth:`makepyfile` and then
1301         runs the pytest collection on it, returning the collection node for the
1302         test module.
1303 
1304         :param source:
1305             The source code of the module to collect.
1306 
1307         :param configargs:
1308             Any extra arguments to pass to :py:meth:`parseconfigure`.
1309 
1310         :param withinit:
1311             Whether to also write an ``__init__.py`` file to the same
1312             directory to ensure it is a package.
1313         """
1314         if isinstance(source, os.PathLike):
1315             path = self.path.joinpath(source)
1316             assert not withinit, "not supported for paths"
1317         else:
1318             kw = {self._name: str(source)}
1319             path = self.makepyfile(**kw)
1320         if withinit:
1321             self.makepyfile(__init__="#")
1322         self.config = config = self.parseconfigure(path, *configargs)
1323         return self.getnode(config, path)
1324 
1325     def collect_by_name(
1326         self, modcol: Collector, name: str
1327     ) -> Optional[Union[Item, Collector]]:
1328         """Return the collection node for name from the module collection.
1329 
1330         Searches a module collection node for a collection node matching the
1331         given name.
1332 
1333         :param modcol: A module collection node; see :py:meth:`getmodulecol`.
1334         :param name: The name of the node to return.
1335         """
1336         if modcol not in self._mod_collections:
1337             self._mod_collections[modcol] = list(modcol.collect())
1338         for colitem in self._mod_collections[modcol]:
1339             if colitem.name == name:
1340                 return colitem
1341         return None
1342 
1343     def popen(
1344         self,
1345         cmdargs: Sequence[Union[str, "os.PathLike[str]"]],
1346         stdout: Union[int, TextIO] = subprocess.PIPE,
1347         stderr: Union[int, TextIO] = subprocess.PIPE,
1348         stdin: Union[NotSetType, bytes, IO[Any], int] = CLOSE_STDIN,
1349         **kw,
1350     ):
1351         """Invoke :py:class:`subprocess.Popen`.
1352 
1353         Calls :py:class:`subprocess.Popen` making sure the current working
1354         directory is in ``PYTHONPATH``.
1355 
1356         You probably want to use :py:meth:`run` instead.
1357         """
1358         env = os.environ.copy()
1359         env["PYTHONPATH"] = os.pathsep.join(
1360             filter(None, [os.getcwd(), env.get("PYTHONPATH", "")])
1361         )
1362         kw["env"] = env
1363 
1364         if stdin is self.CLOSE_STDIN:
1365             kw["stdin"] = subprocess.PIPE
1366         elif isinstance(stdin, bytes):
1367             kw["stdin"] = subprocess.PIPE
1368         else:
1369             kw["stdin"] = stdin
1370 
1371         popen = subprocess.Popen(cmdargs, stdout=stdout, stderr=stderr, **kw)
1372         if stdin is self.CLOSE_STDIN:
1373             assert popen.stdin is not None
1374             popen.stdin.close()
1375         elif isinstance(stdin, bytes):
1376             assert popen.stdin is not None
1377             popen.stdin.write(stdin)
1378 
1379         return popen
1380 
1381     def run(
1382         self,
1383         *cmdargs: Union[str, "os.PathLike[str]"],
1384         timeout: Optional[float] = None,
1385         stdin: Union[NotSetType, bytes, IO[Any], int] = CLOSE_STDIN,
1386     ) -> RunResult:
1387         """Run a command with arguments.
1388 
1389         Run a process using :py:class:`subprocess.Popen` saving the stdout and
1390         stderr.
1391 
1392         :param cmdargs:
1393             The sequence of arguments to pass to :py:class:`subprocess.Popen`,
1394             with path-like objects being converted to :py:class:`str`
1395             automatically.
1396         :param timeout:
1397             The period in seconds after which to timeout and raise
1398             :py:class:`Pytester.TimeoutExpired`.
1399         :param stdin:
1400             Optional standard input.
1401 
1402             - If it is :py:attr:`CLOSE_STDIN` (Default), then this method calls
1403               :py:class:`subprocess.Popen` with ``stdin=subprocess.PIPE``, and
1404               the standard input is closed immediately after the new command is
1405               started.
1406 
1407             - If it is of type :py:class:`bytes`, these bytes are sent to the
1408               standard input of the command.
1409 
1410             - Otherwise, it is passed through to :py:class:`subprocess.Popen`.
1411               For further information in this case, consult the document of the
1412               ``stdin`` parameter in :py:class:`subprocess.Popen`.
1413         :returns:
1414             The result.
1415         """
1416         __tracebackhide__ = True
1417 
1418         cmdargs = tuple(os.fspath(arg) for arg in cmdargs)
1419         p1 = self.path.joinpath("stdout")
1420         p2 = self.path.joinpath("stderr")
1421         print("running:", *cmdargs)
1422         print("     in:", Path.cwd())
1423 
1424         with p1.open("w", encoding="utf8") as f1, p2.open("w", encoding="utf8") as f2:
1425             now = timing.time()
1426             popen = self.popen(
1427                 cmdargs,
1428                 stdin=stdin,
1429                 stdout=f1,
1430                 stderr=f2,
1431                 close_fds=(sys.platform != "win32"),
1432             )
1433             if popen.stdin is not None:
1434                 popen.stdin.close()
1435 
1436             def handle_timeout() -> None:
1437                 __tracebackhide__ = True
1438 
1439                 timeout_message = (
1440                     "{seconds} second timeout expired running:"
1441                     " {command}".format(seconds=timeout, command=cmdargs)
1442                 )
1443 
1444                 popen.kill()
1445                 popen.wait()
1446                 raise self.TimeoutExpired(timeout_message)
1447 
1448             if timeout is None:
1449                 ret = popen.wait()
1450             else:
1451                 try:
1452                     ret = popen.wait(timeout)
1453                 except subprocess.TimeoutExpired:
1454                     handle_timeout()
1455 
1456         with p1.open(encoding="utf8") as f1, p2.open(encoding="utf8") as f2:
1457             out = f1.read().splitlines()
1458             err = f2.read().splitlines()
1459 
1460         self._dump_lines(out, sys.stdout)
1461         self._dump_lines(err, sys.stderr)
1462 
1463         with contextlib.suppress(ValueError):
1464             ret = ExitCode(ret)
1465         return RunResult(ret, out, err, timing.time() - now)
1466 
1467     def _dump_lines(self, lines, fp):
1468         try:
1469             for line in lines:
1470                 print(line, file=fp)
1471         except UnicodeEncodeError:
1472             print(f"couldn't print to {fp} because of encoding")
1473 
1474     def _getpytestargs(self) -> Tuple[str, ...]:
1475         return sys.executable, "-mpytest"
1476 
1477     def runpython(self, script: "os.PathLike[str]") -> RunResult:
1478         """Run a python script using sys.executable as interpreter."""
1479         return self.run(sys.executable, script)
1480 
1481     def runpython_c(self, command: str) -> RunResult:
1482         """Run ``python -c "command"``."""
1483         return self.run(sys.executable, "-c", command)
1484 
1485     def runpytest_subprocess(
1486         self, *args: Union[str, "os.PathLike[str]"], timeout: Optional[float] = None
1487     ) -> RunResult:
1488         """Run pytest as a subprocess with given arguments.
1489 
1490         Any plugins added to the :py:attr:`plugins` list will be added using the
1491         ``-p`` command line option.  Additionally ``--basetemp`` is used to put
1492         any temporary files and directories in a numbered directory prefixed
1493         with "runpytest-" to not conflict with the normal numbered pytest
1494         location for temporary files and directories.
1495 
1496         :param args:
1497             The sequence of arguments to pass to the pytest subprocess.
1498         :param timeout:
1499             The period in seconds after which to timeout and raise
1500             :py:class:`Pytester.TimeoutExpired`.
1501         :returns:
1502             The result.
1503         """
1504         __tracebackhide__ = True
1505         p = make_numbered_dir(root=self.path, prefix="runpytest-", mode=0o700)
1506         args = ("--basetemp=%s" % p,) + args
1507         plugins = [x for x in self.plugins if isinstance(x, str)]
1508         if plugins:
1509             args = ("-p", plugins[0]) + args
1510         args = self._getpytestargs() + args
1511         return self.run(*args, timeout=timeout)
1512 
1513     def spawn_pytest(
1514         self, string: str, expect_timeout: float = 10.0
1515     ) -> "pexpect.spawn":
1516         """Run pytest using pexpect.
1517 
1518         This makes sure to use the right pytest and sets up the temporary
1519         directory locations.
1520 
1521         The pexpect child is returned.
1522         """
1523         basetemp = self.path / "temp-pexpect"
1524         basetemp.mkdir(mode=0o700)
1525         invoke = " ".join(map(str, self._getpytestargs()))
1526         cmd = f"{invoke} --basetemp={basetemp} {string}"
1527         return self.spawn(cmd, expect_timeout=expect_timeout)
1528 
1529     def spawn(self, cmd: str, expect_timeout: float = 10.0) -> "pexpect.spawn":
1530         """Run a command using pexpect.
1531 
1532         The pexpect child is returned.
1533         """
1534         pexpect = importorskip("pexpect", "3.0")
1535         if hasattr(sys, "pypy_version_info") and "64" in platform.machine():
1536             skip("pypy-64 bit not supported")
1537         if not hasattr(pexpect, "spawn"):
1538             skip("pexpect.spawn not available")
1539         logfile = self.path.joinpath("spawn.out").open("wb")
1540 
1541         child = pexpect.spawn(cmd, logfile=logfile, timeout=expect_timeout)
1542         self._request.addfinalizer(logfile.close)
1543         return child
1544 
1545 
1546 class LineComp:
1547     def __init__(self) -> None:
1548         self.stringio = StringIO()
1549         """:class:`python:io.StringIO()` instance used for input."""
1550 
1551     def assert_contains_lines(self, lines2: Sequence[str]) -> None:
1552         """Assert that ``lines2`` are contained (linearly) in :attr:`stringio`'s value.
1553 
1554         Lines are matched using :func:`LineMatcher.fnmatch_lines <pytest.LineMatcher.fnmatch_lines>`.
1555         """
1556         __tracebackhide__ = True
1557         val = self.stringio.getvalue()
1558         self.stringio.truncate(0)
1559         self.stringio.seek(0)
1560         lines1 = val.split("\n")
1561         LineMatcher(lines1).fnmatch_lines(lines2)
1562 
1563 
1564 class LineMatcher:
1565     """Flexible matching of text.
1566 
1567     This is a convenience class to test large texts like the output of
1568     commands.
1569 
1570     The constructor takes a list of lines without their trailing newlines, i.e.
1571     ``text.splitlines()``.
1572     """
1573 
1574     def __init__(self, lines: List[str]) -> None:
1575         self.lines = lines
1576         self._log_output: List[str] = []
1577 
1578     def __str__(self) -> str:
1579         """Return the entire original text.
1580 
1581         .. versionadded:: 6.2
1582             You can use :meth:`str` in older versions.
1583         """
1584         return "\n".join(self.lines)
1585 
1586     def _getlines(self, lines2: Union[str, Sequence[str], Source]) -> Sequence[str]:
1587         if isinstance(lines2, str):
1588             lines2 = Source(lines2)
1589         if isinstance(lines2, Source):
1590             lines2 = lines2.strip().lines
1591         return lines2
1592 
1593     def fnmatch_lines_random(self, lines2: Sequence[str]) -> None:
1594         """Check lines exist in the output in any order (using :func:`python:fnmatch.fnmatch`)."""
1595         __tracebackhide__ = True
1596         self._match_lines_random(lines2, fnmatch)
1597 
1598     def re_match_lines_random(self, lines2: Sequence[str]) -> None:
1599         """Check lines exist in the output in any order (using :func:`python:re.match`)."""
1600         __tracebackhide__ = True
1601         self._match_lines_random(lines2, lambda name, pat: bool(re.match(pat, name)))
1602 
1603     def _match_lines_random(
1604         self, lines2: Sequence[str], match_func: Callable[[str, str], bool]
1605     ) -> None:
1606         __tracebackhide__ = True
1607         lines2 = self._getlines(lines2)
1608         for line in lines2:
1609             for x in self.lines:
1610                 if line == x or match_func(x, line):
1611                     self._log("matched: ", repr(line))
1612                     break
1613             else:
1614                 msg = "line %r not found in output" % line
1615                 self._log(msg)
1616                 self._fail(msg)
1617 
1618     def get_lines_after(self, fnline: str) -> Sequence[str]:
1619         """Return all lines following the given line in the text.
1620 
1621         The given line can contain glob wildcards.
1622         """
1623         for i, line in enumerate(self.lines):
1624             if fnline == line or fnmatch(line, fnline):
1625                 return self.lines[i + 1 :]
1626         raise ValueError("line %r not found in output" % fnline)
1627 
1628     def _log(self, *args) -> None:
1629         self._log_output.append(" ".join(str(x) for x in args))
1630 
1631     @property
1632     def _log_text(self) -> str:
1633         return "\n".join(self._log_output)
1634 
1635     def fnmatch_lines(
1636         self, lines2: Sequence[str], *, consecutive: bool = False
1637     ) -> None:
1638         """Check lines exist in the output (using :func:`python:fnmatch.fnmatch`).
1639 
1640         The argument is a list of lines which have to match and can use glob
1641         wildcards.  If they do not match a pytest.fail() is called.  The
1642         matches and non-matches are also shown as part of the error message.
1643 
1644         :param lines2: String patterns to match.
1645         :param consecutive: Match lines consecutively?
1646         """
1647         __tracebackhide__ = True
1648         self._match_lines(lines2, fnmatch, "fnmatch", consecutive=consecutive)
1649 
1650     def re_match_lines(
1651         self, lines2: Sequence[str], *, consecutive: bool = False
1652     ) -> None:
1653         """Check lines exist in the output (using :func:`python:re.match`).
1654 
1655         The argument is a list of lines which have to match using ``re.match``.
1656         If they do not match a pytest.fail() is called.
1657 
1658         The matches and non-matches are also shown as part of the error message.
1659 
1660         :param lines2: string patterns to match.
1661         :param consecutive: match lines consecutively?
1662         """
1663         __tracebackhide__ = True
1664         self._match_lines(
1665             lines2,
1666             lambda name, pat: bool(re.match(pat, name)),
1667             "re.match",
1668             consecutive=consecutive,
1669         )
1670 
1671     def _match_lines(
1672         self,
1673         lines2: Sequence[str],
1674         match_func: Callable[[str, str], bool],
1675         match_nickname: str,
1676         *,
1677         consecutive: bool = False,
1678     ) -> None:
1679         """Underlying implementation of ``fnmatch_lines`` and ``re_match_lines``.
1680 
1681         :param Sequence[str] lines2:
1682             List of string patterns to match. The actual format depends on
1683             ``match_func``.
1684         :param match_func:
1685             A callable ``match_func(line, pattern)`` where line is the
1686             captured line from stdout/stderr and pattern is the matching
1687             pattern.
1688         :param str match_nickname:
1689             The nickname for the match function that will be logged to stdout
1690             when a match occurs.
1691         :param consecutive:
1692             Match lines consecutively?
1693         """
1694         if not isinstance(lines2, collections.abc.Sequence):
1695             raise TypeError(f"invalid type for lines2: {type(lines2).__name__}")
1696         lines2 = self._getlines(lines2)
1697         lines1 = self.lines[:]
1698         extralines = []
1699         __tracebackhide__ = True
1700         wnick = len(match_nickname) + 1
1701         started = False
1702         for line in lines2:
1703             nomatchprinted = False
1704             while lines1:
1705                 nextline = lines1.pop(0)
1706                 if line == nextline:
1707                     self._log("exact match:", repr(line))
1708                     started = True
1709                     break
1710                 elif match_func(nextline, line):
1711                     self._log("%s:" % match_nickname, repr(line))
1712                     self._log(
1713                         "{:>{width}}".format("with:", width=wnick), repr(nextline)
1714                     )
1715                     started = True
1716                     break
1717                 else:
1718                     if consecutive and started:
1719                         msg = f"no consecutive match: {line!r}"
1720                         self._log(msg)
1721                         self._log(
1722                             "{:>{width}}".format("with:", width=wnick), repr(nextline)
1723                         )
1724                         self._fail(msg)
1725                     if not nomatchprinted:
1726                         self._log(
1727                             "{:>{width}}".format("nomatch:", width=wnick), repr(line)
1728                         )
1729                         nomatchprinted = True
1730                     self._log("{:>{width}}".format("and:", width=wnick), repr(nextline))
1731                 extralines.append(nextline)
1732             else:
1733                 msg = f"remains unmatched: {line!r}"
1734                 self._log(msg)
1735                 self._fail(msg)
1736         self._log_output = []
1737 
1738     def no_fnmatch_line(self, pat: str) -> None:
1739         """Ensure captured lines do not match the given pattern, using ``fnmatch.fnmatch``.
1740 
1741         :param str pat: The pattern to match lines.
1742         """
1743         __tracebackhide__ = True
1744         self._no_match_line(pat, fnmatch, "fnmatch")
1745 
1746     def no_re_match_line(self, pat: str) -> None:
1747         """Ensure captured lines do not match the given pattern, using ``re.match``.
1748 
1749         :param str pat: The regular expression to match lines.
1750         """
1751         __tracebackhide__ = True
1752         self._no_match_line(
1753             pat, lambda name, pat: bool(re.match(pat, name)), "re.match"
1754         )
1755 
1756     def _no_match_line(
1757         self, pat: str, match_func: Callable[[str, str], bool], match_nickname: str
1758     ) -> None:
1759         """Ensure captured lines does not have a the given pattern, using ``fnmatch.fnmatch``.
1760 
1761         :param str pat: The pattern to match lines.
1762         """
1763         __tracebackhide__ = True
1764         nomatch_printed = False
1765         wnick = len(match_nickname) + 1
1766         for line in self.lines:
1767             if match_func(line, pat):
1768                 msg = f"{match_nickname}: {pat!r}"
1769                 self._log(msg)
1770                 self._log("{:>{width}}".format("with:", width=wnick), repr(line))
1771                 self._fail(msg)
1772             else:
1773                 if not nomatch_printed:
1774                     self._log("{:>{width}}".format("nomatch:", width=wnick), repr(pat))
1775                     nomatch_printed = True
1776                 self._log("{:>{width}}".format("and:", width=wnick), repr(line))
1777         self._log_output = []
1778 
1779     def _fail(self, msg: str) -> None:
1780         __tracebackhide__ = True
1781         log_text = self._log_text
1782         self._log_output = []
1783         fail(log_text)
1784 
1785     def str(self) -> str:
1786         """Return the entire original text."""
1787         return str(self)

</code><intended_behavior>When using `importlib` for dynamic imports, the application should implement checks or strategies to avoid importing the same module under different names or paths, which could lead to the observed issue of having two different versions of `pmxbot.logging`. This might include enhancing the logic around module importation to reference or augment Python's import machinery, ensuring that `sys.modules` is appropriately managed to unify module instances.</intended_behavior>, <file>src/_pytest/pathlib.py</file>
<class>None</class>
<method>None</method>
<code>
1 import atexit
2 import contextlib
3 import fnmatch
4 import importlib.util
5 import itertools
6 import os
7 import shutil
8 import sys
9 import types
10 import uuid
11 import warnings
12 from enum import Enum
13 from errno import EBADF
14 from errno import ELOOP
15 from errno import ENOENT
16 from errno import ENOTDIR
17 from functools import partial
18 from os.path import expanduser
19 from os.path import expandvars
20 from os.path import isabs
21 from os.path import sep
22 from pathlib import Path
23 from pathlib import PurePath
24 from posixpath import sep as posix_sep
25 from types import ModuleType
26 from typing import Callable
27 from typing import Dict
28 from typing import Iterable
29 from typing import Iterator
30 from typing import List
31 from typing import Optional
32 from typing import Set
33 from typing import Tuple
34 from typing import Type
35 from typing import TypeVar
36 from typing import Union
37 
38 from _pytest.compat import assert_never
39 from _pytest.outcomes import skip
40 from _pytest.warning_types import PytestWarning
41 
42 LOCK_TIMEOUT = 60 * 60 * 24 * 3
43 
44 
45 _AnyPurePath = TypeVar("_AnyPurePath", bound=PurePath)
46 
47 # The following function, variables and comments were
48 # copied from cpython 3.9 Lib/pathlib.py file.
49 
50 # EBADF - guard against macOS `stat` throwing EBADF
51 _IGNORED_ERRORS = (ENOENT, ENOTDIR, EBADF, ELOOP)
52 
53 _IGNORED_WINERRORS = (
54     21,  # ERROR_NOT_READY - drive exists but is not accessible
55     1921,  # ERROR_CANT_RESOLVE_FILENAME - fix for broken symlink pointing to itself
56 )
57 
58 
59 def _ignore_error(exception):
60     return (
61         getattr(exception, "errno", None) in _IGNORED_ERRORS
62         or getattr(exception, "winerror", None) in _IGNORED_WINERRORS
63     )
64 
65 
66 def get_lock_path(path: _AnyPurePath) -> _AnyPurePath:
67     return path.joinpath(".lock")
68 
69 
70 def on_rm_rf_error(
71     func,
72     path: str,
73     excinfo: Union[
74         BaseException,
75         Tuple[Type[BaseException], BaseException, Optional[types.TracebackType]],
76     ],
77     *,
78     start_path: Path,
79 ) -> bool:
80     """Handle known read-only errors during rmtree.
81 
82     The returned value is used only by our own tests.
83     """
84     if isinstance(excinfo, BaseException):
85         exc = excinfo
86     else:
87         exc = excinfo[1]
88 
89     # Another process removed the file in the middle of the "rm_rf" (xdist for example).
90     # More context: https://github.com/pytest-dev/pytest/issues/5974#issuecomment-543799018
91     if isinstance(exc, FileNotFoundError):
92         return False
93 
94     if not isinstance(exc, PermissionError):
95         warnings.warn(
96             PytestWarning(f"(rm_rf) error removing {path}\n{type(exc)}: {exc}")
97         )
98         return False
99 
100     if func not in (os.rmdir, os.remove, os.unlink):
101         if func not in (os.open,):
102             warnings.warn(
103                 PytestWarning(
104                     "(rm_rf) unknown function {} when removing {}:\n{}: {}".format(
105                         func, path, type(exc), exc
106                     )
107                 )
108             )
109         return False
110 
111     # Chmod + retry.
112     import stat
113 
114     def chmod_rw(p: str) -> None:
115         mode = os.stat(p).st_mode
116         os.chmod(p, mode | stat.S_IRUSR | stat.S_IWUSR)
117 
118     # For files, we need to recursively go upwards in the directories to
119     # ensure they all are also writable.
120     p = Path(path)
121     if p.is_file():
122         for parent in p.parents:
123             chmod_rw(str(parent))
124             # Stop when we reach the original path passed to rm_rf.
125             if parent == start_path:
126                 break
127     chmod_rw(str(path))
128 
129     func(path)
130     return True
131 
132 
133 def ensure_extended_length_path(path: Path) -> Path:
134     """Get the extended-length version of a path (Windows).
135 
136     On Windows, by default, the maximum length of a path (MAX_PATH) is 260
137     characters, and operations on paths longer than that fail. But it is possible
138     to overcome this by converting the path to "extended-length" form before
139     performing the operation:
140     https://docs.microsoft.com/en-us/windows/win32/fileio/naming-a-file#maximum-path-length-limitation
141 
142     On Windows, this function returns the extended-length absolute version of path.
143     On other platforms it returns path unchanged.
144     """
145     if sys.platform.startswith("win32"):
146         path = path.resolve()
147         path = Path(get_extended_length_path_str(str(path)))
148     return path
149 
150 
151 def get_extended_length_path_str(path: str) -> str:
152     """Convert a path to a Windows extended length path."""
153     long_path_prefix = "\\\\?\\"
154     unc_long_path_prefix = "\\\\?\\UNC\\"
155     if path.startswith((long_path_prefix, unc_long_path_prefix)):
156         return path
157     # UNC
158     if path.startswith("\\\\"):
159         return unc_long_path_prefix + path[2:]
160     return long_path_prefix + path
161 
162 
163 def rm_rf(path: Path) -> None:
164     """Remove the path contents recursively, even if some elements
165     are read-only."""
166     path = ensure_extended_length_path(path)
167     onerror = partial(on_rm_rf_error, start_path=path)
168     if sys.version_info >= (3, 12):
169         shutil.rmtree(str(path), onexc=onerror)
170     else:
171         shutil.rmtree(str(path), onerror=onerror)
172 
173 
174 def find_prefixed(root: Path, prefix: str) -> Iterator[Path]:
175     """Find all elements in root that begin with the prefix, case insensitive."""
176     l_prefix = prefix.lower()
177     for x in root.iterdir():
178         if x.name.lower().startswith(l_prefix):
179             yield x
180 
181 
182 def extract_suffixes(iter: Iterable[PurePath], prefix: str) -> Iterator[str]:
183     """Return the parts of the paths following the prefix.
184 
185     :param iter: Iterator over path names.
186     :param prefix: Expected prefix of the path names.
187     """
188     p_len = len(prefix)
189     for p in iter:
190         yield p.name[p_len:]
191 
192 
193 def find_suffixes(root: Path, prefix: str) -> Iterator[str]:
194     """Combine find_prefixes and extract_suffixes."""
195     return extract_suffixes(find_prefixed(root, prefix), prefix)
196 
197 
198 def parse_num(maybe_num) -> int:
199     """Parse number path suffixes, returns -1 on error."""
200     try:
201         return int(maybe_num)
202     except ValueError:
203         return -1
204 
205 
206 def _force_symlink(
207     root: Path, target: Union[str, PurePath], link_to: Union[str, Path]
208 ) -> None:
209     """Helper to create the current symlink.
210 
211     It's full of race conditions that are reasonably OK to ignore
212     for the context of best effort linking to the latest test run.
213 
214     The presumption being that in case of much parallelism
215     the inaccuracy is going to be acceptable.
216     """
217     current_symlink = root.joinpath(target)
218     try:
219         current_symlink.unlink()
220     except OSError:
221         pass
222     try:
223         current_symlink.symlink_to(link_to)
224     except Exception:
225         pass
226 
227 
228 def make_numbered_dir(root: Path, prefix: str, mode: int = 0o700) -> Path:
229     """Create a directory with an increased number as suffix for the given prefix."""
230     for i in range(10):
231         # try up to 10 times to create the folder
232         max_existing = max(map(parse_num, find_suffixes(root, prefix)), default=-1)
233         new_number = max_existing + 1
234         new_path = root.joinpath(f"{prefix}{new_number}")
235         try:
236             new_path.mkdir(mode=mode)
237         except Exception:
238             pass
239         else:
240             _force_symlink(root, prefix + "current", new_path)
241             return new_path
242     else:
243         raise OSError(
244             "could not create numbered dir with prefix "
245             "{prefix} in {root} after 10 tries".format(prefix=prefix, root=root)
246         )
247 
248 
249 def create_cleanup_lock(p: Path) -> Path:
250     """Create a lock to prevent premature folder cleanup."""
251     lock_path = get_lock_path(p)
252     try:
253         fd = os.open(str(lock_path), os.O_WRONLY | os.O_CREAT | os.O_EXCL, 0o644)
254     except FileExistsError as e:
255         raise OSError(f"cannot create lockfile in {p}") from e
256     else:
257         pid = os.getpid()
258         spid = str(pid).encode()
259         os.write(fd, spid)
260         os.close(fd)
261         if not lock_path.is_file():
262             raise OSError("lock path got renamed after successful creation")
263         return lock_path
264 
265 
266 def register_cleanup_lock_removal(lock_path: Path, register=atexit.register):
267     """Register a cleanup function for removing a lock, by default on atexit."""
268     pid = os.getpid()
269 
270     def cleanup_on_exit(lock_path: Path = lock_path, original_pid: int = pid) -> None:
271         current_pid = os.getpid()
272         if current_pid != original_pid:
273             # fork
274             return
275         try:
276             lock_path.unlink()
277         except OSError:
278             pass
279 
280     return register(cleanup_on_exit)
281 
282 
283 def maybe_delete_a_numbered_dir(path: Path) -> None:
284     """Remove a numbered directory if its lock can be obtained and it does
285     not seem to be in use."""
286     path = ensure_extended_length_path(path)
287     lock_path = None
288     try:
289         lock_path = create_cleanup_lock(path)
290         parent = path.parent
291 
292         garbage = parent.joinpath(f"garbage-{uuid.uuid4()}")
293         path.rename(garbage)
294         rm_rf(garbage)
295     except OSError:
296         #  known races:
297         #  * other process did a cleanup at the same time
298         #  * deletable folder was found
299         #  * process cwd (Windows)
300         return
301     finally:
302         # If we created the lock, ensure we remove it even if we failed
303         # to properly remove the numbered dir.
304         if lock_path is not None:
305             try:
306                 lock_path.unlink()
307             except OSError:
308                 pass
309 
310 
311 def ensure_deletable(path: Path, consider_lock_dead_if_created_before: float) -> bool:
312     """Check if `path` is deletable based on whether the lock file is expired."""
313     if path.is_symlink():
314         return False
315     lock = get_lock_path(path)
316     try:
317         if not lock.is_file():
318             return True
319     except OSError:
320         # we might not have access to the lock file at all, in this case assume
321         # we don't have access to the entire directory (#7491).
322         return False
323     try:
324         lock_time = lock.stat().st_mtime
325     except Exception:
326         return False
327     else:
328         if lock_time < consider_lock_dead_if_created_before:
329             # We want to ignore any errors while trying to remove the lock such as:
330             # - PermissionDenied, like the file permissions have changed since the lock creation;
331             # - FileNotFoundError, in case another pytest process got here first;
332             # and any other cause of failure.
333             with contextlib.suppress(OSError):
334                 lock.unlink()
335                 return True
336         return False
337 
338 
339 def try_cleanup(path: Path, consider_lock_dead_if_created_before: float) -> None:
340     """Try to cleanup a folder if we can ensure it's deletable."""
341     if ensure_deletable(path, consider_lock_dead_if_created_before):
342         maybe_delete_a_numbered_dir(path)
343 
344 
345 def cleanup_candidates(root: Path, prefix: str, keep: int) -> Iterator[Path]:
346     """List candidates for numbered directories to be removed - follows py.path."""
347     max_existing = max(map(parse_num, find_suffixes(root, prefix)), default=-1)
348     max_delete = max_existing - keep
349     paths = find_prefixed(root, prefix)
350     paths, paths2 = itertools.tee(paths)
351     numbers = map(parse_num, extract_suffixes(paths2, prefix))
352     for path, number in zip(paths, numbers):
353         if number <= max_delete:
354             yield path
355 
356 
357 def cleanup_dead_symlinks(root: Path):
358     for left_dir in root.iterdir():
359         if left_dir.is_symlink():
360             if not left_dir.resolve().exists():
361                 left_dir.unlink()
362 
363 
364 def cleanup_numbered_dir(
365     root: Path, prefix: str, keep: int, consider_lock_dead_if_created_before: float
366 ) -> None:
367     """Cleanup for lock driven numbered directories."""
368     if not root.exists():
369         return
370     for path in cleanup_candidates(root, prefix, keep):
371         try_cleanup(path, consider_lock_dead_if_created_before)
372     for path in root.glob("garbage-*"):
373         try_cleanup(path, consider_lock_dead_if_created_before)
374 
375     cleanup_dead_symlinks(root)
376 
377 
378 def make_numbered_dir_with_cleanup(
379     root: Path,
380     prefix: str,
381     keep: int,
382     lock_timeout: float,
383     mode: int,
384 ) -> Path:
385     """Create a numbered dir with a cleanup lock and remove old ones."""
386     e = None
387     for i in range(10):
388         try:
389             p = make_numbered_dir(root, prefix, mode)
390             # Only lock the current dir when keep is not 0
391             if keep != 0:
392                 lock_path = create_cleanup_lock(p)
393                 register_cleanup_lock_removal(lock_path)
394         except Exception as exc:
395             e = exc
396         else:
397             consider_lock_dead_if_created_before = p.stat().st_mtime - lock_timeout
398             # Register a cleanup for program exit
399             atexit.register(
400                 cleanup_numbered_dir,
401                 root,
402                 prefix,
403                 keep,
404                 consider_lock_dead_if_created_before,
405             )
406             return p
407     assert e is not None
408     raise e
409 
410 
411 def resolve_from_str(input: str, rootpath: Path) -> Path:
412     input = expanduser(input)
413     input = expandvars(input)
414     if isabs(input):
415         return Path(input)
416     else:
417         return rootpath.joinpath(input)
418 
419 
420 def fnmatch_ex(pattern: str, path: Union[str, "os.PathLike[str]"]) -> bool:
421     """A port of FNMatcher from py.path.common which works with PurePath() instances.
422 
423     The difference between this algorithm and PurePath.match() is that the
424     latter matches "**" glob expressions for each part of the path, while
425     this algorithm uses the whole path instead.
426 
427     For example:
428         "tests/foo/bar/doc/test_foo.py" matches pattern "tests/**/doc/test*.py"
429         with this algorithm, but not with PurePath.match().
430 
431     This algorithm was ported to keep backward-compatibility with existing
432     settings which assume paths match according this logic.
433 
434     References:
435     * https://bugs.python.org/issue29249
436     * https://bugs.python.org/issue34731
437     """
438     path = PurePath(path)
439     iswin32 = sys.platform.startswith("win")
440 
441     if iswin32 and sep not in pattern and posix_sep in pattern:
442         # Running on Windows, the pattern has no Windows path separators,
443         # and the pattern has one or more Posix path separators. Replace
444         # the Posix path separators with the Windows path separator.
445         pattern = pattern.replace(posix_sep, sep)
446 
447     if sep not in pattern:
448         name = path.name
449     else:
450         name = str(path)
451         if path.is_absolute() and not os.path.isabs(pattern):
452             pattern = f"*{os.sep}{pattern}"
453     return fnmatch.fnmatch(name, pattern)
454 
455 
456 def parts(s: str) -> Set[str]:
457     parts = s.split(sep)
458     return {sep.join(parts[: i + 1]) or sep for i in range(len(parts))}
459 
460 
461 def symlink_or_skip(src, dst, **kwargs):
462     """Make a symlink, or skip the test in case symlinks are not supported."""
463     try:
464         os.symlink(str(src), str(dst), **kwargs)
465     except OSError as e:
466         skip(f"symlinks not supported: {e}")
467 
468 
469 class ImportMode(Enum):
470     """Possible values for `mode` parameter of `import_path`."""
471 
472     prepend = "prepend"
473     append = "append"
474     importlib = "importlib"
475 
476 
477 class ImportPathMismatchError(ImportError):
478     """Raised on import_path() if there is a mismatch of __file__'s.
479 
480     This can happen when `import_path` is called multiple times with different filenames that has
481     the same basename but reside in packages
482     (for example "/tests1/test_foo.py" and "/tests2/test_foo.py").
483     """
484 
485 
486 def import_path(
487     p: Union[str, "os.PathLike[str]"],
488     *,
489     mode: Union[str, ImportMode] = ImportMode.prepend,
490     root: Path,
491 ) -> ModuleType:
492     """Import and return a module from the given path, which can be a file (a module) or
493     a directory (a package).
494 
495     The import mechanism used is controlled by the `mode` parameter:
496 
497     * `mode == ImportMode.prepend`: the directory containing the module (or package, taking
498       `__init__.py` files into account) will be put at the *start* of `sys.path` before
499       being imported with `importlib.import_module`.
500 
501     * `mode == ImportMode.append`: same as `prepend`, but the directory will be appended
502       to the end of `sys.path`, if not already in `sys.path`.
503 
504     * `mode == ImportMode.importlib`: uses more fine control mechanisms provided by `importlib`
505       to import the module, which avoids having to muck with `sys.path` at all. It effectively
506       allows having same-named test modules in different places.
507 
508     :param root:
509         Used as an anchor when mode == ImportMode.importlib to obtain
510         a unique name for the module being imported so it can safely be stored
511         into ``sys.modules``.
512 
513     :raises ImportPathMismatchError:
514         If after importing the given `path` and the module `__file__`
515         are different. Only raised in `prepend` and `append` modes.
516     """
517     mode = ImportMode(mode)
518 
519     path = Path(p)
520 
521     if not path.exists():
522         raise ImportError(path)
523 
524     if mode is ImportMode.importlib:
525         module_name = module_name_from_path(path, root)
526 
527         for meta_importer in sys.meta_path:
528             spec = meta_importer.find_spec(module_name, [str(path.parent)])
529             if spec is not None:
530                 break
531         else:
532             spec = importlib.util.spec_from_file_location(module_name, str(path))
533 
534         if spec is None:
535             raise ImportError(f"Can't find module {module_name} at location {path}")
536         mod = importlib.util.module_from_spec(spec)
537         sys.modules[module_name] = mod
538         spec.loader.exec_module(mod)  # type: ignore[union-attr]
539         insert_missing_modules(sys.modules, module_name)
540         return mod
541 
542     pkg_path = resolve_package_path(path)
543     if pkg_path is not None:
544         pkg_root = pkg_path.parent
545         names = list(path.with_suffix("").relative_to(pkg_root).parts)
546         if names[-1] == "__init__":
547             names.pop()
548         module_name = ".".join(names)
549     else:
550         pkg_root = path.parent
551         module_name = path.stem
552 
553     # Change sys.path permanently: restoring it at the end of this function would cause surprising
554     # problems because of delayed imports: for example, a conftest.py file imported by this function
555     # might have local imports, which would fail at runtime if we restored sys.path.
556     if mode is ImportMode.append:
557         if str(pkg_root) not in sys.path:
558             sys.path.append(str(pkg_root))
559     elif mode is ImportMode.prepend:
560         if str(pkg_root) != sys.path[0]:
561             sys.path.insert(0, str(pkg_root))
562     else:
563         assert_never(mode)
564 
565     importlib.import_module(module_name)
566 
567     mod = sys.modules[module_name]
568     if path.name == "__init__.py":
569         return mod
570 
571     ignore = os.environ.get("PY_IGNORE_IMPORTMISMATCH", "")
572     if ignore != "1":
573         module_file = mod.__file__
574         if module_file is None:
575             raise ImportPathMismatchError(module_name, module_file, path)
576 
577         if module_file.endswith((".pyc", ".pyo")):
578             module_file = module_file[:-1]
579         if module_file.endswith(os.sep + "__init__.py"):
580             module_file = module_file[: -(len(os.sep + "__init__.py"))]
581 
582         try:
583             is_same = _is_same(str(path), module_file)
584         except FileNotFoundError:
585             is_same = False
586 
587         if not is_same:
588             raise ImportPathMismatchError(module_name, module_file, path)
589 
590     return mod
591 
592 
593 # Implement a special _is_same function on Windows which returns True if the two filenames
594 # compare equal, to circumvent os.path.samefile returning False for mounts in UNC (#7678).
595 if sys.platform.startswith("win"):
596 
597     def _is_same(f1: str, f2: str) -> bool:
598         return Path(f1) == Path(f2) or os.path.samefile(f1, f2)
599 
600 else:
601 
602     def _is_same(f1: str, f2: str) -> bool:
603         return os.path.samefile(f1, f2)
604 
605 
606 def module_name_from_path(path: Path, root: Path) -> str:
607     """
608     Return a dotted module name based on the given path, anchored on root.
609 
610     For example: path="projects/src/tests/test_foo.py" and root="/projects", the
611     resulting module name will be "src.tests.test_foo".
612     """
613     path = path.with_suffix("")
614     try:
615         relative_path = path.relative_to(root)
616     except ValueError:
617         # If we can't get a relative path to root, use the full path, except
618         # for the first part ("d:\\" or "/" depending on the platform, for example).
619         path_parts = path.parts[1:]
620     else:
621         # Use the parts for the relative path to the root path.
622         path_parts = relative_path.parts
623 
624     return ".".join(path_parts)
625 
626 
627 def insert_missing_modules(modules: Dict[str, ModuleType], module_name: str) -> None:
628     """
629     Used by ``import_path`` to create intermediate modules when using mode=importlib.
630 
631     When we want to import a module as "src.tests.test_foo" for example, we need
632     to create empty modules "src" and "src.tests" after inserting "src.tests.test_foo",
633     otherwise "src.tests.test_foo" is not importable by ``__import__``.
634     """
635     module_parts = module_name.split(".")
636     child_module: Union[ModuleType, None] = None
637     module: Union[ModuleType, None] = None
638     child_name: str = ""
639     while module_name:
640         if module_name not in modules:
641             try:
642                 # If sys.meta_path is empty, calling import_module will issue
643                 # a warning and raise ModuleNotFoundError. To avoid the
644                 # warning, we check sys.meta_path explicitly and raise the error
645                 # ourselves to fall back to creating a dummy module.
646                 if not sys.meta_path:
647                     raise ModuleNotFoundError
648                 module = importlib.import_module(module_name)
649             except ModuleNotFoundError:
650                 module = ModuleType(
651                     module_name,
652                     doc="Empty module created by pytest's importmode=importlib.",
653                 )
654         else:
655             module = modules[module_name]
656         if child_module:
657             # Add child attribute to the parent that can reference the child
658             # modules.
659             if not hasattr(module, child_name):
660                 setattr(module, child_name, child_module)
661                 modules[module_name] = module
662         # Keep track of the child module while moving up the tree.
663         child_module, child_name = module, module_name.rpartition(".")[-1]
664         module_parts.pop(-1)
665         module_name = ".".join(module_parts)
666 
667 
668 def resolve_package_path(path: Path) -> Optional[Path]:
669     """Return the Python package path by looking for the last
670     directory upwards which still contains an __init__.py.
671 
672     Returns None if it can not be determined.
673     """
674     result = None
675     for parent in itertools.chain((path,), path.parents):
676         if parent.is_dir():
677             if not parent.joinpath("__init__.py").is_file():
678                 break
679             if not parent.name.isidentifier():
680                 break
681             result = parent
682     return result
683 
684 
685 def scandir(path: Union[str, "os.PathLike[str]"]) -> List["os.DirEntry[str]"]:
686     """Scan a directory recursively, in breadth-first order.
687 
688     The returned entries are sorted.
689     """
690     entries = []
691     with os.scandir(path) as s:
692         # Skip entries with symlink loops and other brokenness, so the caller
693         # doesn't have to deal with it.
694         for entry in s:
695             try:
696                 entry.is_file()
697             except OSError as err:
698                 if _ignore_error(err):
699                     continue
700                 raise
701             entries.append(entry)
702     entries.sort(key=lambda entry: entry.name)
703     return entries
704 
705 
706 def visit(
707     path: Union[str, "os.PathLike[str]"], recurse: Callable[["os.DirEntry[str]"], bool]
708 ) -> Iterator["os.DirEntry[str]"]:
709     """Walk a directory recursively, in breadth-first order.
710 
711     The `recurse` predicate determines whether a directory is recursed.
712 
713     Entries at each directory level are sorted.
714     """
715     entries = scandir(path)
716     yield from entries
717     for entry in entries:
718         if entry.is_dir() and recurse(entry):
719             yield from visit(entry.path, recurse)
720 
721 
722 def absolutepath(path: Union[Path, str]) -> Path:
723     """Convert a path to an absolute path using os.path.abspath.
724 
725     Prefer this over Path.resolve() (see #6523).
726     Prefer this over Path.absolute() (not public, doesn't normalize).
727     """
728     return Path(os.path.abspath(str(path)))
729 
730 
731 def commonpath(path1: Path, path2: Path) -> Optional[Path]:
732     """Return the common part shared with the other path, or None if there is
733     no common part.
734 
735     If one path is relative and one is absolute, returns None.
736     """
737     try:
738         return Path(os.path.commonpath((str(path1), str(path2))))
739     except ValueError:
740         return None
741 
742 
743 def bestrelpath(directory: Path, dest: Path) -> str:
744     """Return a string which is a relative path from directory to dest such
745     that directory/bestrelpath == dest.
746 
747     The paths must be either both absolute or both relative.
748 
749     If no such path can be determined, returns dest.
750     """
751     assert isinstance(directory, Path)
752     assert isinstance(dest, Path)
753     if dest == directory:
754         return os.curdir
755     # Find the longest common directory.
756     base = commonpath(directory, dest)
757     # Can be the case on Windows for two absolute paths on different drives.
758     # Can be the case for two relative paths without common prefix.
759     # Can be the case for a relative path and an absolute path.
760     if not base:
761         return str(dest)
762     reldirectory = directory.relative_to(base)
763     reldest = dest.relative_to(base)
764     return os.path.join(
765         # Back from directory to base.
766         *([os.pardir] * len(reldirectory.parts)),
767         # Forward from base to dest.
768         *reldest.parts,
769     )
770 
771 
772 # Originates from py. path.local.copy(), with siginficant trims and adjustments.
773 # TODO(py38): Replace with shutil.copytree(..., symlinks=True, dirs_exist_ok=True)
774 def copytree(source: Path, target: Path) -> None:
775     """Recursively copy a source directory to target."""
776     assert source.is_dir()
777     for entry in visit(source, recurse=lambda entry: not entry.is_symlink()):
778         x = Path(entry)
779         relpath = x.relative_to(source)
780         newx = target / relpath
781         newx.parent.mkdir(exist_ok=True)
782         if x.is_symlink():
783             newx.symlink_to(os.readlink(x))
784         elif x.is_file():
785             shutil.copyfile(x, newx)
786         elif x.is_dir():
787             newx.mkdir(exist_ok=True)

</code><intended_behavior>When using `importlib` for dynamic imports, the application should implement checks or strategies to avoid importing the same module under different names or paths, which could lead to the observed issue of having two different versions of `pmxbot.logging`. This might include enhancing the logic around module importation to reference or augment Python's import machinery, ensuring that `sys.modules` is appropriately managed to unify module instances.</intended_behavior>, <file>src/_pytest/assertion/rewrite.py</file>
<class>None</class>
<method>None</method>
<code>
1 """Rewrite assertion AST to produce nice error messages."""
2 import ast
3 import errno
4 import functools
5 import importlib.abc
6 import importlib.machinery
7 import importlib.util
8 import io
9 import itertools
10 import marshal
11 import os
12 import struct
13 import sys
14 import tokenize
15 import types
16 from pathlib import Path
17 from pathlib import PurePath
18 from typing import Callable
19 from typing import Dict
20 from typing import IO
21 from typing import Iterable
22 from typing import Iterator
23 from typing import List
24 from typing import Optional
25 from typing import Sequence
26 from typing import Set
27 from typing import Tuple
28 from typing import TYPE_CHECKING
29 from typing import Union
30 
31 from _pytest._io.saferepr import DEFAULT_REPR_MAX_SIZE
32 from _pytest._io.saferepr import saferepr
33 from _pytest._version import version
34 from _pytest.assertion import util
35 from _pytest.assertion.util import (  # noqa: F401
36     format_explanation as _format_explanation,
37 )
38 from _pytest.config import Config
39 from _pytest.main import Session
40 from _pytest.pathlib import absolutepath
41 from _pytest.pathlib import fnmatch_ex
42 from _pytest.stash import StashKey
43 
44 if TYPE_CHECKING:
45     from _pytest.assertion import AssertionState
46 
47 
48 assertstate_key = StashKey["AssertionState"]()
49 
50 # pytest caches rewritten pycs in pycache dirs
51 PYTEST_TAG = f"{sys.implementation.cache_tag}-pytest-{version}"
52 PYC_EXT = ".py" + (__debug__ and "c" or "o")
53 PYC_TAIL = "." + PYTEST_TAG + PYC_EXT
54 
55 
56 class AssertionRewritingHook(importlib.abc.MetaPathFinder, importlib.abc.Loader):
57     """PEP302/PEP451 import hook which rewrites asserts."""
58 
59     def __init__(self, config: Config) -> None:
60         self.config = config
61         try:
62             self.fnpats = config.getini("python_files")
63         except ValueError:
64             self.fnpats = ["test_*.py", "*_test.py"]
65         self.session: Optional[Session] = None
66         self._rewritten_names: Dict[str, Path] = {}
67         self._must_rewrite: Set[str] = set()
68         # flag to guard against trying to rewrite a pyc file while we are already writing another pyc file,
69         # which might result in infinite recursion (#3506)
70         self._writing_pyc = False
71         self._basenames_to_check_rewrite = {"conftest"}
72         self._marked_for_rewrite_cache: Dict[str, bool] = {}
73         self._session_paths_checked = False
74 
75     def set_session(self, session: Optional[Session]) -> None:
76         self.session = session
77         self._session_paths_checked = False
78 
79     # Indirection so we can mock calls to find_spec originated from the hook during testing
80     _find_spec = importlib.machinery.PathFinder.find_spec
81 
82     def find_spec(
83         self,
84         name: str,
85         path: Optional[Sequence[Union[str, bytes]]] = None,
86         target: Optional[types.ModuleType] = None,
87     ) -> Optional[importlib.machinery.ModuleSpec]:
88         if self._writing_pyc:
89             return None
90         state = self.config.stash[assertstate_key]
91         if self._early_rewrite_bailout(name, state):
92             return None
93         state.trace("find_module called for: %s" % name)
94 
95         # Type ignored because mypy is confused about the `self` binding here.
96         spec = self._find_spec(name, path)  # type: ignore
97         if (
98             # the import machinery could not find a file to import
99             spec is None
100             # this is a namespace package (without `__init__.py`)
101             # there's nothing to rewrite there
102             or spec.origin is None
103             # we can only rewrite source files
104             or not isinstance(spec.loader, importlib.machinery.SourceFileLoader)
105             # if the file doesn't exist, we can't rewrite it
106             or not os.path.exists(spec.origin)
107         ):
108             return None
109         else:
110             fn = spec.origin
111 
112         if not self._should_rewrite(name, fn, state):
113             return None
114 
115         return importlib.util.spec_from_file_location(
116             name,
117             fn,
118             loader=self,
119             submodule_search_locations=spec.submodule_search_locations,
120         )
121 
122     def create_module(
123         self, spec: importlib.machinery.ModuleSpec
124     ) -> Optional[types.ModuleType]:
125         return None  # default behaviour is fine
126 
127     def exec_module(self, module: types.ModuleType) -> None:
128         assert module.__spec__ is not None
129         assert module.__spec__.origin is not None
130         fn = Path(module.__spec__.origin)
131         state = self.config.stash[assertstate_key]
132 
133         self._rewritten_names[module.__name__] = fn
134 
135         # The requested module looks like a test file, so rewrite it. This is
136         # the most magical part of the process: load the source, rewrite the
137         # asserts, and load the rewritten source. We also cache the rewritten
138         # module code in a special pyc. We must be aware of the possibility of
139         # concurrent pytest processes rewriting and loading pycs. To avoid
140         # tricky race conditions, we maintain the following invariant: The
141         # cached pyc is always a complete, valid pyc. Operations on it must be
142         # atomic. POSIX's atomic rename comes in handy.
143         write = not sys.dont_write_bytecode
144         cache_dir = get_cache_dir(fn)
145         if write:
146             ok = try_makedirs(cache_dir)
147             if not ok:
148                 write = False
149                 state.trace(f"read only directory: {cache_dir}")
150 
151         cache_name = fn.name[:-3] + PYC_TAIL
152         pyc = cache_dir / cache_name
153         # Notice that even if we're in a read-only directory, I'm going
154         # to check for a cached pyc. This may not be optimal...
155         co = _read_pyc(fn, pyc, state.trace)
156         if co is None:
157             state.trace(f"rewriting {fn!r}")
158             source_stat, co = _rewrite_test(fn, self.config)
159             if write:
160                 self._writing_pyc = True
161                 try:
162                     _write_pyc(state, co, source_stat, pyc)
163                 finally:
164                     self._writing_pyc = False
165         else:
166             state.trace(f"found cached rewritten pyc for {fn}")
167         exec(co, module.__dict__)
168 
169     def _early_rewrite_bailout(self, name: str, state: "AssertionState") -> bool:
170         """A fast way to get out of rewriting modules.
171 
172         Profiling has shown that the call to PathFinder.find_spec (inside of
173         the find_spec from this class) is a major slowdown, so, this method
174         tries to filter what we're sure won't be rewritten before getting to
175         it.
176         """
177         if self.session is not None and not self._session_paths_checked:
178             self._session_paths_checked = True
179             for initial_path in self.session._initialpaths:
180                 # Make something as c:/projects/my_project/path.py ->
181                 #     ['c:', 'projects', 'my_project', 'path.py']
182                 parts = str(initial_path).split(os.sep)
183                 # add 'path' to basenames to be checked.
184                 self._basenames_to_check_rewrite.add(os.path.splitext(parts[-1])[0])
185 
186         # Note: conftest already by default in _basenames_to_check_rewrite.
187         parts = name.split(".")
188         if parts[-1] in self._basenames_to_check_rewrite:
189             return False
190 
191         # For matching the name it must be as if it was a filename.
192         path = PurePath(*parts).with_suffix(".py")
193 
194         for pat in self.fnpats:
195             # if the pattern contains subdirectories ("tests/**.py" for example) we can't bail out based
196             # on the name alone because we need to match against the full path
197             if os.path.dirname(pat):
198                 return False
199             if fnmatch_ex(pat, path):
200                 return False
201 
202         if self._is_marked_for_rewrite(name, state):
203             return False
204 
205         state.trace(f"early skip of rewriting module: {name}")
206         return True
207 
208     def _should_rewrite(self, name: str, fn: str, state: "AssertionState") -> bool:
209         # always rewrite conftest files
210         if os.path.basename(fn) == "conftest.py":
211             state.trace(f"rewriting conftest file: {fn!r}")
212             return True
213 
214         if self.session is not None:
215             if self.session.isinitpath(absolutepath(fn)):
216                 state.trace(f"matched test file (was specified on cmdline): {fn!r}")
217                 return True
218 
219         # modules not passed explicitly on the command line are only
220         # rewritten if they match the naming convention for test files
221         fn_path = PurePath(fn)
222         for pat in self.fnpats:
223             if fnmatch_ex(pat, fn_path):
224                 state.trace(f"matched test file {fn!r}")
225                 return True
226 
227         return self._is_marked_for_rewrite(name, state)
228 
229     def _is_marked_for_rewrite(self, name: str, state: "AssertionState") -> bool:
230         try:
231             return self._marked_for_rewrite_cache[name]
232         except KeyError:
233             for marked in self._must_rewrite:
234                 if name == marked or name.startswith(marked + "."):
235                     state.trace(f"matched marked file {name!r} (from {marked!r})")
236                     self._marked_for_rewrite_cache[name] = True
237                     return True
238 
239             self._marked_for_rewrite_cache[name] = False
240             return False
241 
242     def mark_rewrite(self, *names: str) -> None:
243         """Mark import names as needing to be rewritten.
244 
245         The named module or package as well as any nested modules will
246         be rewritten on import.
247         """
248         already_imported = (
249             set(names).intersection(sys.modules).difference(self._rewritten_names)
250         )
251         for name in already_imported:
252             mod = sys.modules[name]
253             if not AssertionRewriter.is_rewrite_disabled(
254                 mod.__doc__ or ""
255             ) and not isinstance(mod.__loader__, type(self)):
256                 self._warn_already_imported(name)
257         self._must_rewrite.update(names)
258         self._marked_for_rewrite_cache.clear()
259 
260     def _warn_already_imported(self, name: str) -> None:
261         from _pytest.warning_types import PytestAssertRewriteWarning
262 
263         self.config.issue_config_time_warning(
264             PytestAssertRewriteWarning(
265                 "Module already imported so cannot be rewritten: %s" % name
266             ),
267             stacklevel=5,
268         )
269 
270     def get_data(self, pathname: Union[str, bytes]) -> bytes:
271         """Optional PEP302 get_data API."""
272         with open(pathname, "rb") as f:
273             return f.read()
274 
275     if sys.version_info >= (3, 10):
276         if sys.version_info >= (3, 12):
277             from importlib.resources.abc import TraversableResources
278         else:
279             from importlib.abc import TraversableResources
280 
281         def get_resource_reader(self, name: str) -> TraversableResources:  # type: ignore
282             if sys.version_info < (3, 11):
283                 from importlib.readers import FileReader
284             else:
285                 from importlib.resources.readers import FileReader
286 
287             return FileReader(  # type:ignore[no-any-return]
288                 types.SimpleNamespace(path=self._rewritten_names[name])
289             )
290 
291 
292 def _write_pyc_fp(
293     fp: IO[bytes], source_stat: os.stat_result, co: types.CodeType
294 ) -> None:
295     # Technically, we don't have to have the same pyc format as
296     # (C)Python, since these "pycs" should never be seen by builtin
297     # import. However, there's little reason to deviate.
298     fp.write(importlib.util.MAGIC_NUMBER)
299     # https://www.python.org/dev/peps/pep-0552/
300     flags = b"\x00\x00\x00\x00"
301     fp.write(flags)
302     # as of now, bytecode header expects 32-bit numbers for size and mtime (#4903)
303     mtime = int(source_stat.st_mtime) & 0xFFFFFFFF
304     size = source_stat.st_size & 0xFFFFFFFF
305     # "<LL" stands for 2 unsigned longs, little-endian.
306     fp.write(struct.pack("<LL", mtime, size))
307     fp.write(marshal.dumps(co))
308 
309 
310 def _write_pyc(
311     state: "AssertionState",
312     co: types.CodeType,
313     source_stat: os.stat_result,
314     pyc: Path,
315 ) -> bool:
316     proc_pyc = f"{pyc}.{os.getpid()}"
317     try:
318         with open(proc_pyc, "wb") as fp:
319             _write_pyc_fp(fp, source_stat, co)
320     except OSError as e:
321         state.trace(f"error writing pyc file at {proc_pyc}: errno={e.errno}")
322         return False
323 
324     try:
325         os.replace(proc_pyc, pyc)
326     except OSError as e:
327         state.trace(f"error writing pyc file at {pyc}: {e}")
328         # we ignore any failure to write the cache file
329         # there are many reasons, permission-denied, pycache dir being a
330         # file etc.
331         return False
332     return True
333 
334 
335 def _rewrite_test(fn: Path, config: Config) -> Tuple[os.stat_result, types.CodeType]:
336     """Read and rewrite *fn* and return the code object."""
337     stat = os.stat(fn)
338     source = fn.read_bytes()
339     strfn = str(fn)
340     tree = ast.parse(source, filename=strfn)
341     rewrite_asserts(tree, source, strfn, config)
342     co = compile(tree, strfn, "exec", dont_inherit=True)
343     return stat, co
344 
345 
346 def _read_pyc(
347     source: Path, pyc: Path, trace: Callable[[str], None] = lambda x: None
348 ) -> Optional[types.CodeType]:
349     """Possibly read a pytest pyc containing rewritten code.
350 
351     Return rewritten code if successful or None if not.
352     """
353     try:
354         fp = open(pyc, "rb")
355     except OSError:
356         return None
357     with fp:
358         try:
359             stat_result = os.stat(source)
360             mtime = int(stat_result.st_mtime)
361             size = stat_result.st_size
362             data = fp.read(16)
363         except OSError as e:
364             trace(f"_read_pyc({source}): OSError {e}")
365             return None
366         # Check for invalid or out of date pyc file.
367         if len(data) != (16):
368             trace("_read_pyc(%s): invalid pyc (too short)" % source)
369             return None
370         if data[:4] != importlib.util.MAGIC_NUMBER:
371             trace("_read_pyc(%s): invalid pyc (bad magic number)" % source)
372             return None
373         if data[4:8] != b"\x00\x00\x00\x00":
374             trace("_read_pyc(%s): invalid pyc (unsupported flags)" % source)
375             return None
376         mtime_data = data[8:12]
377         if int.from_bytes(mtime_data, "little") != mtime & 0xFFFFFFFF:
378             trace("_read_pyc(%s): out of date" % source)
379             return None
380         size_data = data[12:16]
381         if int.from_bytes(size_data, "little") != size & 0xFFFFFFFF:
382             trace("_read_pyc(%s): invalid pyc (incorrect size)" % source)
383             return None
384         try:
385             co = marshal.load(fp)
386         except Exception as e:
387             trace(f"_read_pyc({source}): marshal.load error {e}")
388             return None
389         if not isinstance(co, types.CodeType):
390             trace("_read_pyc(%s): not a code object" % source)
391             return None
392         return co
393 
394 
395 def rewrite_asserts(
396     mod: ast.Module,
397     source: bytes,
398     module_path: Optional[str] = None,
399     config: Optional[Config] = None,
400 ) -> None:
401     """Rewrite the assert statements in mod."""
402     AssertionRewriter(module_path, config, source).run(mod)
403 
404 
405 def _saferepr(obj: object) -> str:
406     r"""Get a safe repr of an object for assertion error messages.
407 
408     The assertion formatting (util.format_explanation()) requires
409     newlines to be escaped since they are a special character for it.
410     Normally assertion.util.format_explanation() does this but for a
411     custom repr it is possible to contain one of the special escape
412     sequences, especially '\n{' and '\n}' are likely to be present in
413     JSON reprs.
414     """
415     maxsize = _get_maxsize_for_saferepr(util._config)
416     return saferepr(obj, maxsize=maxsize).replace("\n", "\\n")
417 
418 
419 def _get_maxsize_for_saferepr(config: Optional[Config]) -> Optional[int]:
420     """Get `maxsize` configuration for saferepr based on the given config object."""
421     verbosity = config.getoption("verbose") if config is not None else 0
422     if verbosity >= 2:
423         return None
424     if verbosity >= 1:
425         return DEFAULT_REPR_MAX_SIZE * 10
426     return DEFAULT_REPR_MAX_SIZE
427 
428 
429 def _format_assertmsg(obj: object) -> str:
430     r"""Format the custom assertion message given.
431 
432     For strings this simply replaces newlines with '\n~' so that
433     util.format_explanation() will preserve them instead of escaping
434     newlines.  For other objects saferepr() is used first.
435     """
436     # reprlib appears to have a bug which means that if a string
437     # contains a newline it gets escaped, however if an object has a
438     # .__repr__() which contains newlines it does not get escaped.
439     # However in either case we want to preserve the newline.
440     replaces = [("\n", "\n~"), ("%", "%%")]
441     if not isinstance(obj, str):
442         obj = saferepr(obj)
443         replaces.append(("\\n", "\n~"))
444 
445     for r1, r2 in replaces:
446         obj = obj.replace(r1, r2)
447 
448     return obj
449 
450 
451 def _should_repr_global_name(obj: object) -> bool:
452     if callable(obj):
453         return False
454 
455     try:
456         return not hasattr(obj, "__name__")
457     except Exception:
458         return True
459 
460 
461 def _format_boolop(explanations: Iterable[str], is_or: bool) -> str:
462     explanation = "(" + (is_or and " or " or " and ").join(explanations) + ")"
463     return explanation.replace("%", "%%")
464 
465 
466 def _call_reprcompare(
467     ops: Sequence[str],
468     results: Sequence[bool],
469     expls: Sequence[str],
470     each_obj: Sequence[object],
471 ) -> str:
472     for i, res, expl in zip(range(len(ops)), results, expls):
473         try:
474             done = not res
475         except Exception:
476             done = True
477         if done:
478             break
479     if util._reprcompare is not None:
480         custom = util._reprcompare(ops[i], each_obj[i], each_obj[i + 1])
481         if custom is not None:
482             return custom
483     return expl
484 
485 
486 def _call_assertion_pass(lineno: int, orig: str, expl: str) -> None:
487     if util._assertion_pass is not None:
488         util._assertion_pass(lineno, orig, expl)
489 
490 
491 def _check_if_assertion_pass_impl() -> bool:
492     """Check if any plugins implement the pytest_assertion_pass hook
493     in order not to generate explanation unnecessarily (might be expensive)."""
494     return True if util._assertion_pass else False
495 
496 
497 UNARY_MAP = {ast.Not: "not %s", ast.Invert: "~%s", ast.USub: "-%s", ast.UAdd: "+%s"}
498 
499 BINOP_MAP = {
500     ast.BitOr: "|",
501     ast.BitXor: "^",
502     ast.BitAnd: "&",
503     ast.LShift: "<<",
504     ast.RShift: ">>",
505     ast.Add: "+",
506     ast.Sub: "-",
507     ast.Mult: "*",
508     ast.Div: "/",
509     ast.FloorDiv: "//",
510     ast.Mod: "%%",  # escaped for string formatting
511     ast.Eq: "==",
512     ast.NotEq: "!=",
513     ast.Lt: "<",
514     ast.LtE: "<=",
515     ast.Gt: ">",
516     ast.GtE: ">=",
517     ast.Pow: "**",
518     ast.Is: "is",
519     ast.IsNot: "is not",
520     ast.In: "in",
521     ast.NotIn: "not in",
522     ast.MatMult: "@",
523 }
524 
525 
526 def traverse_node(node: ast.AST) -> Iterator[ast.AST]:
527     """Recursively yield node and all its children in depth-first order."""
528     yield node
529     for child in ast.iter_child_nodes(node):
530         yield from traverse_node(child)
531 
532 
533 @functools.lru_cache(maxsize=1)
534 def _get_assertion_exprs(src: bytes) -> Dict[int, str]:
535     """Return a mapping from {lineno: "assertion test expression"}."""
536     ret: Dict[int, str] = {}
537 
538     depth = 0
539     lines: List[str] = []
540     assert_lineno: Optional[int] = None
541     seen_lines: Set[int] = set()
542 
543     def _write_and_reset() -> None:
544         nonlocal depth, lines, assert_lineno, seen_lines
545         assert assert_lineno is not None
546         ret[assert_lineno] = "".join(lines).rstrip().rstrip("\\")
547         depth = 0
548         lines = []
549         assert_lineno = None
550         seen_lines = set()
551 
552     tokens = tokenize.tokenize(io.BytesIO(src).readline)
553     for tp, source, (lineno, offset), _, line in tokens:
554         if tp == tokenize.NAME and source == "assert":
555             assert_lineno = lineno
556         elif assert_lineno is not None:
557             # keep track of depth for the assert-message `,` lookup
558             if tp == tokenize.OP and source in "([{":
559                 depth += 1
560             elif tp == tokenize.OP and source in ")]}":
561                 depth -= 1
562 
563             if not lines:
564                 lines.append(line[offset:])
565                 seen_lines.add(lineno)
566             # a non-nested comma separates the expression from the message
567             elif depth == 0 and tp == tokenize.OP and source == ",":
568                 # one line assert with message
569                 if lineno in seen_lines and len(lines) == 1:
570                     offset_in_trimmed = offset + len(lines[-1]) - len(line)
571                     lines[-1] = lines[-1][:offset_in_trimmed]
572                 # multi-line assert with message
573                 elif lineno in seen_lines:
574                     lines[-1] = lines[-1][:offset]
575                 # multi line assert with escapd newline before message
576                 else:
577                     lines.append(line[:offset])
578                 _write_and_reset()
579             elif tp in {tokenize.NEWLINE, tokenize.ENDMARKER}:
580                 _write_and_reset()
581             elif lines and lineno not in seen_lines:
582                 lines.append(line)
583                 seen_lines.add(lineno)
584 
585     return ret
586 
587 
588 class AssertionRewriter(ast.NodeVisitor):
589     """Assertion rewriting implementation.
590 
591     The main entrypoint is to call .run() with an ast.Module instance,
592     this will then find all the assert statements and rewrite them to
593     provide intermediate values and a detailed assertion error.  See
594     http://pybites.blogspot.be/2011/07/behind-scenes-of-pytests-new-assertion.html
595     for an overview of how this works.
596 
597     The entry point here is .run() which will iterate over all the
598     statements in an ast.Module and for each ast.Assert statement it
599     finds call .visit() with it.  Then .visit_Assert() takes over and
600     is responsible for creating new ast statements to replace the
601     original assert statement: it rewrites the test of an assertion
602     to provide intermediate values and replace it with an if statement
603     which raises an assertion error with a detailed explanation in
604     case the expression is false and calls pytest_assertion_pass hook
605     if expression is true.
606 
607     For this .visit_Assert() uses the visitor pattern to visit all the
608     AST nodes of the ast.Assert.test field, each visit call returning
609     an AST node and the corresponding explanation string.  During this
610     state is kept in several instance attributes:
611 
612     :statements: All the AST statements which will replace the assert
613        statement.
614 
615     :variables: This is populated by .variable() with each variable
616        used by the statements so that they can all be set to None at
617        the end of the statements.
618 
619     :variable_counter: Counter to create new unique variables needed
620        by statements.  Variables are created using .variable() and
621        have the form of "@py_assert0".
622 
623     :expl_stmts: The AST statements which will be executed to get
624        data from the assertion.  This is the code which will construct
625        the detailed assertion message that is used in the AssertionError
626        or for the pytest_assertion_pass hook.
627 
628     :explanation_specifiers: A dict filled by .explanation_param()
629        with %-formatting placeholders and their corresponding
630        expressions to use in the building of an assertion message.
631        This is used by .pop_format_context() to build a message.
632 
633     :stack: A stack of the explanation_specifiers dicts maintained by
634        .push_format_context() and .pop_format_context() which allows
635        to build another %-formatted string while already building one.
636 
637     :variables_overwrite: A dict filled with references to variables
638        that change value within an assert. This happens when a variable is
639        reassigned with the walrus operator
640 
641     This state, except the variables_overwrite,  is reset on every new assert
642     statement visited and used by the other visitors.
643     """
644 
645     def __init__(
646         self, module_path: Optional[str], config: Optional[Config], source: bytes
647     ) -> None:
648         super().__init__()
649         self.module_path = module_path
650         self.config = config
651         if config is not None:
652             self.enable_assertion_pass_hook = config.getini(
653                 "enable_assertion_pass_hook"
654             )
655         else:
656             self.enable_assertion_pass_hook = False
657         self.source = source
658         self.variables_overwrite: Dict[str, str] = {}
659 
660     def run(self, mod: ast.Module) -> None:
661         """Find all assert statements in *mod* and rewrite them."""
662         if not mod.body:
663             # Nothing to do.
664             return
665 
666         # We'll insert some special imports at the top of the module, but after any
667         # docstrings and __future__ imports, so first figure out where that is.
668         doc = getattr(mod, "docstring", None)
669         expect_docstring = doc is None
670         if doc is not None and self.is_rewrite_disabled(doc):
671             return
672         pos = 0
673         item = None
674         for item in mod.body:
675             if (
676                 expect_docstring
677                 and isinstance(item, ast.Expr)
678                 and isinstance(item.value, ast.Constant)
679             ):
680                 doc = item.value.value
681                 if self.is_rewrite_disabled(doc):
682                     return
683                 expect_docstring = False
684             elif (
685                 isinstance(item, ast.ImportFrom)
686                 and item.level == 0
687                 and item.module == "__future__"
688             ):
689                 pass
690             else:
691                 break
692             pos += 1
693         # Special case: for a decorated function, set the lineno to that of the
694         # first decorator, not the `def`. Issue #4984.
695         if isinstance(item, ast.FunctionDef) and item.decorator_list:
696             lineno = item.decorator_list[0].lineno
697         else:
698             lineno = item.lineno
699         # Now actually insert the special imports.
700         if sys.version_info >= (3, 10):
701             aliases = [
702                 ast.alias("builtins", "@py_builtins", lineno=lineno, col_offset=0),
703                 ast.alias(
704                     "_pytest.assertion.rewrite",
705                     "@pytest_ar",
706                     lineno=lineno,
707                     col_offset=0,
708                 ),
709             ]
710         else:
711             aliases = [
712                 ast.alias("builtins", "@py_builtins"),
713                 ast.alias("_pytest.assertion.rewrite", "@pytest_ar"),
714             ]
715         imports = [
716             ast.Import([alias], lineno=lineno, col_offset=0) for alias in aliases
717         ]
718         mod.body[pos:pos] = imports
719 
720         # Collect asserts.
721         nodes: List[ast.AST] = [mod]
722         while nodes:
723             node = nodes.pop()
724             for name, field in ast.iter_fields(node):
725                 if isinstance(field, list):
726                     new: List[ast.AST] = []
727                     for i, child in enumerate(field):
728                         if isinstance(child, ast.Assert):
729                             # Transform assert.
730                             new.extend(self.visit(child))
731                         else:
732                             new.append(child)
733                             if isinstance(child, ast.AST):
734                                 nodes.append(child)
735                     setattr(node, name, new)
736                 elif (
737                     isinstance(field, ast.AST)
738                     # Don't recurse into expressions as they can't contain
739                     # asserts.
740                     and not isinstance(field, ast.expr)
741                 ):
742                     nodes.append(field)
743 
744     @staticmethod
745     def is_rewrite_disabled(docstring: str) -> bool:
746         return "PYTEST_DONT_REWRITE" in docstring
747 
748     def variable(self) -> str:
749         """Get a new variable."""
750         # Use a character invalid in python identifiers to avoid clashing.
751         name = "@py_assert" + str(next(self.variable_counter))
752         self.variables.append(name)
753         return name
754 
755     def assign(self, expr: ast.expr) -> ast.Name:
756         """Give *expr* a name."""
757         name = self.variable()
758         self.statements.append(ast.Assign([ast.Name(name, ast.Store())], expr))
759         return ast.Name(name, ast.Load())
760 
761     def display(self, expr: ast.expr) -> ast.expr:
762         """Call saferepr on the expression."""
763         return self.helper("_saferepr", expr)
764 
765     def helper(self, name: str, *args: ast.expr) -> ast.expr:
766         """Call a helper in this module."""
767         py_name = ast.Name("@pytest_ar", ast.Load())
768         attr = ast.Attribute(py_name, name, ast.Load())
769         return ast.Call(attr, list(args), [])
770 
771     def builtin(self, name: str) -> ast.Attribute:
772         """Return the builtin called *name*."""
773         builtin_name = ast.Name("@py_builtins", ast.Load())
774         return ast.Attribute(builtin_name, name, ast.Load())
775 
776     def explanation_param(self, expr: ast.expr) -> str:
777         """Return a new named %-formatting placeholder for expr.
778 
779         This creates a %-formatting placeholder for expr in the
780         current formatting context, e.g. ``%(py0)s``.  The placeholder
781         and expr are placed in the current format context so that it
782         can be used on the next call to .pop_format_context().
783         """
784         specifier = "py" + str(next(self.variable_counter))
785         self.explanation_specifiers[specifier] = expr
786         return "%(" + specifier + ")s"
787 
788     def push_format_context(self) -> None:
789         """Create a new formatting context.
790 
791         The format context is used for when an explanation wants to
792         have a variable value formatted in the assertion message.  In
793         this case the value required can be added using
794         .explanation_param().  Finally .pop_format_context() is used
795         to format a string of %-formatted values as added by
796         .explanation_param().
797         """
798         self.explanation_specifiers: Dict[str, ast.expr] = {}
799         self.stack.append(self.explanation_specifiers)
800 
801     def pop_format_context(self, expl_expr: ast.expr) -> ast.Name:
802         """Format the %-formatted string with current format context.
803 
804         The expl_expr should be an str ast.expr instance constructed from
805         the %-placeholders created by .explanation_param().  This will
806         add the required code to format said string to .expl_stmts and
807         return the ast.Name instance of the formatted string.
808         """
809         current = self.stack.pop()
810         if self.stack:
811             self.explanation_specifiers = self.stack[-1]
812         keys = [ast.Constant(key) for key in current.keys()]
813         format_dict = ast.Dict(keys, list(current.values()))
814         form = ast.BinOp(expl_expr, ast.Mod(), format_dict)
815         name = "@py_format" + str(next(self.variable_counter))
816         if self.enable_assertion_pass_hook:
817             self.format_variables.append(name)
818         self.expl_stmts.append(ast.Assign([ast.Name(name, ast.Store())], form))
819         return ast.Name(name, ast.Load())
820 
821     def generic_visit(self, node: ast.AST) -> Tuple[ast.Name, str]:
822         """Handle expressions we don't have custom code for."""
823         assert isinstance(node, ast.expr)
824         res = self.assign(node)
825         return res, self.explanation_param(self.display(res))
826 
827     def visit_Assert(self, assert_: ast.Assert) -> List[ast.stmt]:
828         """Return the AST statements to replace the ast.Assert instance.
829 
830         This rewrites the test of an assertion to provide
831         intermediate values and replace it with an if statement which
832         raises an assertion error with a detailed explanation in case
833         the expression is false.
834         """
835         if isinstance(assert_.test, ast.Tuple) and len(assert_.test.elts) >= 1:
836             from _pytest.warning_types import PytestAssertRewriteWarning
837             import warnings
838 
839             # TODO: This assert should not be needed.
840             assert self.module_path is not None
841             warnings.warn_explicit(
842                 PytestAssertRewriteWarning(
843                     "assertion is always true, perhaps remove parentheses?"
844                 ),
845                 category=None,
846                 filename=self.module_path,
847                 lineno=assert_.lineno,
848             )
849 
850         self.statements: List[ast.stmt] = []
851         self.variables: List[str] = []
852         self.variable_counter = itertools.count()
853 
854         if self.enable_assertion_pass_hook:
855             self.format_variables: List[str] = []
856 
857         self.stack: List[Dict[str, ast.expr]] = []
858         self.expl_stmts: List[ast.stmt] = []
859         self.push_format_context()
860         # Rewrite assert into a bunch of statements.
861         top_condition, explanation = self.visit(assert_.test)
862 
863         negation = ast.UnaryOp(ast.Not(), top_condition)
864 
865         if self.enable_assertion_pass_hook:  # Experimental pytest_assertion_pass hook
866             msg = self.pop_format_context(ast.Constant(explanation))
867 
868             # Failed
869             if assert_.msg:
870                 assertmsg = self.helper("_format_assertmsg", assert_.msg)
871                 gluestr = "\n>assert "
872             else:
873                 assertmsg = ast.Constant("")
874                 gluestr = "assert "
875             err_explanation = ast.BinOp(ast.Constant(gluestr), ast.Add(), msg)
876             err_msg = ast.BinOp(assertmsg, ast.Add(), err_explanation)
877             err_name = ast.Name("AssertionError", ast.Load())
878             fmt = self.helper("_format_explanation", err_msg)
879             exc = ast.Call(err_name, [fmt], [])
880             raise_ = ast.Raise(exc, None)
881             statements_fail = []
882             statements_fail.extend(self.expl_stmts)
883             statements_fail.append(raise_)
884 
885             # Passed
886             fmt_pass = self.helper("_format_explanation", msg)
887             orig = _get_assertion_exprs(self.source)[assert_.lineno]
888             hook_call_pass = ast.Expr(
889                 self.helper(
890                     "_call_assertion_pass",
891                     ast.Constant(assert_.lineno),
892                     ast.Constant(orig),
893                     fmt_pass,
894                 )
895             )
896             # If any hooks implement assert_pass hook
897             hook_impl_test = ast.If(
898                 self.helper("_check_if_assertion_pass_impl"),
899                 self.expl_stmts + [hook_call_pass],
900                 [],
901             )
902             statements_pass = [hook_impl_test]
903 
904             # Test for assertion condition
905             main_test = ast.If(negation, statements_fail, statements_pass)
906             self.statements.append(main_test)
907             if self.format_variables:
908                 variables = [
909                     ast.Name(name, ast.Store()) for name in self.format_variables
910                 ]
911                 clear_format = ast.Assign(variables, ast.Constant(None))
912                 self.statements.append(clear_format)
913 
914         else:  # Original assertion rewriting
915             # Create failure message.
916             body = self.expl_stmts
917             self.statements.append(ast.If(negation, body, []))
918             if assert_.msg:
919                 assertmsg = self.helper("_format_assertmsg", assert_.msg)
920                 explanation = "\n>assert " + explanation
921             else:
922                 assertmsg = ast.Constant("")
923                 explanation = "assert " + explanation
924             template = ast.BinOp(assertmsg, ast.Add(), ast.Constant(explanation))
925             msg = self.pop_format_context(template)
926             fmt = self.helper("_format_explanation", msg)
927             err_name = ast.Name("AssertionError", ast.Load())
928             exc = ast.Call(err_name, [fmt], [])
929             raise_ = ast.Raise(exc, None)
930 
931             body.append(raise_)
932 
933         # Clear temporary variables by setting them to None.
934         if self.variables:
935             variables = [ast.Name(name, ast.Store()) for name in self.variables]
936             clear = ast.Assign(variables, ast.Constant(None))
937             self.statements.append(clear)
938         # Fix locations (line numbers/column offsets).
939         for stmt in self.statements:
940             for node in traverse_node(stmt):
941                 ast.copy_location(node, assert_)
942         return self.statements
943 
944     def visit_NamedExpr(self, name: ast.NamedExpr) -> Tuple[ast.NamedExpr, str]:
945         # This method handles the 'walrus operator' repr of the target
946         # name if it's a local variable or _should_repr_global_name()
947         # thinks it's acceptable.
948         locs = ast.Call(self.builtin("locals"), [], [])
949         target_id = name.target.id  # type: ignore[attr-defined]
950         inlocs = ast.Compare(ast.Constant(target_id), [ast.In()], [locs])
951         dorepr = self.helper("_should_repr_global_name", name)
952         test = ast.BoolOp(ast.Or(), [inlocs, dorepr])
953         expr = ast.IfExp(test, self.display(name), ast.Constant(target_id))
954         return name, self.explanation_param(expr)
955 
956     def visit_Name(self, name: ast.Name) -> Tuple[ast.Name, str]:
957         # Display the repr of the name if it's a local variable or
958         # _should_repr_global_name() thinks it's acceptable.
959         locs = ast.Call(self.builtin("locals"), [], [])
960         inlocs = ast.Compare(ast.Constant(name.id), [ast.In()], [locs])
961         dorepr = self.helper("_should_repr_global_name", name)
962         test = ast.BoolOp(ast.Or(), [inlocs, dorepr])
963         expr = ast.IfExp(test, self.display(name), ast.Constant(name.id))
964         return name, self.explanation_param(expr)
965 
966     def visit_BoolOp(self, boolop: ast.BoolOp) -> Tuple[ast.Name, str]:
967         res_var = self.variable()
968         expl_list = self.assign(ast.List([], ast.Load()))
969         app = ast.Attribute(expl_list, "append", ast.Load())
970         is_or = int(isinstance(boolop.op, ast.Or))
971         body = save = self.statements
972         fail_save = self.expl_stmts
973         levels = len(boolop.values) - 1
974         self.push_format_context()
975         # Process each operand, short-circuiting if needed.
976         for i, v in enumerate(boolop.values):
977             if i:
978                 fail_inner: List[ast.stmt] = []
979                 # cond is set in a prior loop iteration below
980                 self.expl_stmts.append(ast.If(cond, fail_inner, []))  # noqa
981                 self.expl_stmts = fail_inner
982                 # Check if the left operand is a ast.NamedExpr and the value has already been visited
983                 if (
984                     isinstance(v, ast.Compare)
985                     and isinstance(v.left, ast.NamedExpr)
986                     and v.left.target.id
987                     in [
988                         ast_expr.id
989                         for ast_expr in boolop.values[:i]
990                         if hasattr(ast_expr, "id")
991                     ]
992                 ):
993                     pytest_temp = self.variable()
994                     self.variables_overwrite[
995                         v.left.target.id
996                     ] = v.left  # type:ignore[assignment]
997                     v.left.target.id = pytest_temp
998             self.push_format_context()
999             res, expl = self.visit(v)
1000             body.append(ast.Assign([ast.Name(res_var, ast.Store())], res))
1001             expl_format = self.pop_format_context(ast.Constant(expl))
1002             call = ast.Call(app, [expl_format], [])
1003             self.expl_stmts.append(ast.Expr(call))
1004             if i < levels:
1005                 cond: ast.expr = res
1006                 if is_or:
1007                     cond = ast.UnaryOp(ast.Not(), cond)
1008                 inner: List[ast.stmt] = []
1009                 self.statements.append(ast.If(cond, inner, []))
1010                 self.statements = body = inner
1011         self.statements = save
1012         self.expl_stmts = fail_save
1013         expl_template = self.helper("_format_boolop", expl_list, ast.Constant(is_or))
1014         expl = self.pop_format_context(expl_template)
1015         return ast.Name(res_var, ast.Load()), self.explanation_param(expl)
1016 
1017     def visit_UnaryOp(self, unary: ast.UnaryOp) -> Tuple[ast.Name, str]:
1018         pattern = UNARY_MAP[unary.op.__class__]
1019         operand_res, operand_expl = self.visit(unary.operand)
1020         res = self.assign(ast.UnaryOp(unary.op, operand_res))
1021         return res, pattern % (operand_expl,)
1022 
1023     def visit_BinOp(self, binop: ast.BinOp) -> Tuple[ast.Name, str]:
1024         symbol = BINOP_MAP[binop.op.__class__]
1025         left_expr, left_expl = self.visit(binop.left)
1026         right_expr, right_expl = self.visit(binop.right)
1027         explanation = f"({left_expl} {symbol} {right_expl})"
1028         res = self.assign(ast.BinOp(left_expr, binop.op, right_expr))
1029         return res, explanation
1030 
1031     def visit_Call(self, call: ast.Call) -> Tuple[ast.Name, str]:
1032         new_func, func_expl = self.visit(call.func)
1033         arg_expls = []
1034         new_args = []
1035         new_kwargs = []
1036         for arg in call.args:
1037             if isinstance(arg, ast.Name) and arg.id in self.variables_overwrite:
1038                 arg = self.variables_overwrite[arg.id]  # type:ignore[assignment]
1039             res, expl = self.visit(arg)
1040             arg_expls.append(expl)
1041             new_args.append(res)
1042         for keyword in call.keywords:
1043             if (
1044                 isinstance(keyword.value, ast.Name)
1045                 and keyword.value.id in self.variables_overwrite
1046             ):
1047                 keyword.value = self.variables_overwrite[
1048                     keyword.value.id
1049                 ]  # type:ignore[assignment]
1050             res, expl = self.visit(keyword.value)
1051             new_kwargs.append(ast.keyword(keyword.arg, res))
1052             if keyword.arg:
1053                 arg_expls.append(keyword.arg + "=" + expl)
1054             else:  # **args have `arg` keywords with an .arg of None
1055                 arg_expls.append("**" + expl)
1056 
1057         expl = "{}({})".format(func_expl, ", ".join(arg_expls))
1058         new_call = ast.Call(new_func, new_args, new_kwargs)
1059         res = self.assign(new_call)
1060         res_expl = self.explanation_param(self.display(res))
1061         outer_expl = f"{res_expl}\n{{{res_expl} = {expl}\n}}"
1062         return res, outer_expl
1063 
1064     def visit_Starred(self, starred: ast.Starred) -> Tuple[ast.Starred, str]:
1065         # A Starred node can appear in a function call.
1066         res, expl = self.visit(starred.value)
1067         new_starred = ast.Starred(res, starred.ctx)
1068         return new_starred, "*" + expl
1069 
1070     def visit_Attribute(self, attr: ast.Attribute) -> Tuple[ast.Name, str]:
1071         if not isinstance(attr.ctx, ast.Load):
1072             return self.generic_visit(attr)
1073         value, value_expl = self.visit(attr.value)
1074         res = self.assign(ast.Attribute(value, attr.attr, ast.Load()))
1075         res_expl = self.explanation_param(self.display(res))
1076         pat = "%s\n{%s = %s.%s\n}"
1077         expl = pat % (res_expl, res_expl, value_expl, attr.attr)
1078         return res, expl
1079 
1080     def visit_Compare(self, comp: ast.Compare) -> Tuple[ast.expr, str]:
1081         self.push_format_context()
1082         # We first check if we have overwritten a variable in the previous assert
1083         if isinstance(comp.left, ast.Name) and comp.left.id in self.variables_overwrite:
1084             comp.left = self.variables_overwrite[
1085                 comp.left.id
1086             ]  # type:ignore[assignment]
1087         if isinstance(comp.left, ast.NamedExpr):
1088             self.variables_overwrite[
1089                 comp.left.target.id
1090             ] = comp.left  # type:ignore[assignment]
1091         left_res, left_expl = self.visit(comp.left)
1092         if isinstance(comp.left, (ast.Compare, ast.BoolOp)):
1093             left_expl = f"({left_expl})"
1094         res_variables = [self.variable() for i in range(len(comp.ops))]
1095         load_names = [ast.Name(v, ast.Load()) for v in res_variables]
1096         store_names = [ast.Name(v, ast.Store()) for v in res_variables]
1097         it = zip(range(len(comp.ops)), comp.ops, comp.comparators)
1098         expls = []
1099         syms = []
1100         results = [left_res]
1101         for i, op, next_operand in it:
1102             if (
1103                 isinstance(next_operand, ast.NamedExpr)
1104                 and isinstance(left_res, ast.Name)
1105                 and next_operand.target.id == left_res.id
1106             ):
1107                 next_operand.target.id = self.variable()
1108                 self.variables_overwrite[
1109                     left_res.id
1110                 ] = next_operand  # type:ignore[assignment]
1111             next_res, next_expl = self.visit(next_operand)
1112             if isinstance(next_operand, (ast.Compare, ast.BoolOp)):
1113                 next_expl = f"({next_expl})"
1114             results.append(next_res)
1115             sym = BINOP_MAP[op.__class__]
1116             syms.append(ast.Constant(sym))
1117             expl = f"{left_expl} {sym} {next_expl}"
1118             expls.append(ast.Constant(expl))
1119             res_expr = ast.Compare(left_res, [op], [next_res])
1120             self.statements.append(ast.Assign([store_names[i]], res_expr))
1121             left_res, left_expl = next_res, next_expl
1122         # Use pytest.assertion.util._reprcompare if that's available.
1123         expl_call = self.helper(
1124             "_call_reprcompare",
1125             ast.Tuple(syms, ast.Load()),
1126             ast.Tuple(load_names, ast.Load()),
1127             ast.Tuple(expls, ast.Load()),
1128             ast.Tuple(results, ast.Load()),
1129         )
1130         if len(comp.ops) > 1:
1131             res: ast.expr = ast.BoolOp(ast.And(), load_names)
1132         else:
1133             res = load_names[0]
1134 
1135         return res, self.explanation_param(self.pop_format_context(expl_call))
1136 
1137 
1138 def try_makedirs(cache_dir: Path) -> bool:
1139     """Attempt to create the given directory and sub-directories exist.
1140 
1141     Returns True if successful or if it already exists.
1142     """
1143     try:
1144         os.makedirs(cache_dir, exist_ok=True)
1145     except (FileNotFoundError, NotADirectoryError, FileExistsError):
1146         # One of the path components was not a directory:
1147         # - we're in a zip file
1148         # - it is a file
1149         return False
1150     except PermissionError:
1151         return False
1152     except OSError as e:
1153         # as of now, EROFS doesn't have an equivalent OSError-subclass
1154         if e.errno == errno.EROFS:
1155             return False
1156         raise
1157     return True
1158 
1159 
1160 def get_cache_dir(file_path: Path) -> Path:
1161     """Return the cache directory to write .pyc files for the given .py file path."""
1162     if sys.pycache_prefix:
1163         # given:
1164         #   prefix = '/tmp/pycs'
1165         #   path = '/home/user/proj/test_app.py'
1166         # we want:
1167         #   '/tmp/pycs/home/user/proj'
1168         return Path(sys.pycache_prefix) / Path(*file_path.parts[1:-1])
1169     else:
1170         # classic pycache directory
1171         return file_path.parent / "__pycache__"

</code><intended_behavior>When using `importlib` for dynamic imports, the application should implement checks or strategies to avoid importing the same module under different names or paths, which could lead to the observed issue of having two different versions of `pmxbot.logging`. This might include enhancing the logic around module importation to reference or augment Python's import machinery, ensuring that `sys.modules` is appropriately managed to unify module instances.</intended_behavior>]
2025-10-18 16:15:41.444 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-18 16:15:41.445 | INFO     | Search-only: skipping patch selection
2025-10-18 16:15:41.519 | INFO     | Task pytest-dev__pytest-11148 completed successfully.
2025-10-18 16:15:41.520 | INFO     | No patch generated. You can try running ACR again.
