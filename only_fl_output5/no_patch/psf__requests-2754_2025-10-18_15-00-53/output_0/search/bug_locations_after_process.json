[
    {
        "rel_file_path": "requests/models.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/psf__requests/setup_psf__requests__3.0/requests/models.py",
        "start": 326,
        "end": 404,
        "class_name": "PreparedRequest",
        "method_name": "prepare_url",
        "code": "326     def prepare_url(self, url, params):\n327         \"\"\"Prepares the given HTTP URL.\"\"\"\n328         #: Accept objects that have string representations.\n329         #: We're unable to blindly call unicode/str functions\n330         #: as this will include the bytestring indicator (b'')\n331         #: on python 3.x.\n332         #: https://github.com/kennethreitz/requests/pull/2238\n333         if isinstance(url, bytes):\n334             url = url.decode('utf8')\n335         else:\n336             url = unicode(url) if is_py2 else str(url)\n337 \n338         # Ignore any leading and trailing whitespace characters.\n339         url = url.strip()\n340 \n341         # Don't do any URL preparation for non-HTTP schemes like `mailto`,\n342         # `data` etc to work around exceptions from `url_parse`, which\n343         # handles RFC 3986 only.\n344         if ':' in url and not url.lower().startswith('http'):\n345             self.url = url\n346             return\n347 \n348         # Support for unicode domain names and paths.\n349         try:\n350             scheme, auth, host, port, path, query, fragment = parse_url(url)\n351         except LocationParseError as e:\n352             raise InvalidURL(*e.args)\n353 \n354         if not scheme:\n355             error = (\"Invalid URL {0!r}: No scheme supplied. Perhaps you meant http://{0}?\")\n356             error = error.format(to_native_string(url, 'utf8'))\n357 \n358             raise MissingScheme(error)\n359 \n360         if not host:\n361             raise InvalidURL(\"Invalid URL %r: No host supplied\" % url)\n362 \n363         # Only want to apply IDNA to the hostname\n364         try:\n365             host = host.encode('idna').decode('utf-8')\n366         except UnicodeError:\n367             raise InvalidURL('URL has an invalid label.')\n368 \n369         # Carefully reconstruct the network location\n370         netloc = auth or ''\n371         if netloc:\n372             netloc += '@'\n373         netloc += host\n374         if port:\n375             netloc += ':' + str(port)\n376 \n377         # Bare domains aren't valid URLs.\n378         if not path:\n379             path = '/'\n380 \n381         if is_py2:\n382             if isinstance(scheme, str):\n383                 scheme = scheme.encode('utf-8')\n384             if isinstance(netloc, str):\n385                 netloc = netloc.encode('utf-8')\n386             if isinstance(path, str):\n387                 path = path.encode('utf-8')\n388             if isinstance(query, str):\n389                 query = query.encode('utf-8')\n390             if isinstance(fragment, str):\n391                 fragment = fragment.encode('utf-8')\n392 \n393         if isinstance(params, (str, bytes)):\n394             params = to_native_string(params)\n395 \n396         enc_params = self._encode_params(params)\n397         if enc_params:\n398             if query:\n399                 query = '%s&%s' % (query, enc_params)\n400             else:\n401                 query = enc_params\n402 \n403         url = requote_uri(urlunparse([scheme, netloc, path, None, query, fragment]))\n404         self.url = url\n",
        "intended_behavior": "The method should be enhanced to ensure that the path component of a URL, when containing non-ASCII characters, is properly encoded to prevent issues during redirects. While the domain part of the URL is properly encoded to IDNA, the method should also ensure characters in the path are percent-encoded as per RFC 3986. This includes characters in scripts other than Latin, such as Japanese, ensuring they are preserved correctly in the URL and not misrepresented, leading to 404 errors. The enhancement should maintain the current functionality for ASCII paths, only applying additional encoding steps where necessary for non-ASCII characters."
    },
    {
        "rel_file_path": "requests/models.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/psf__requests/setup_psf__requests__3.0/requests/models.py",
        "start": 255,
        "end": 538,
        "class_name": "PreparedRequest",
        "method_name": null,
        "code": "255 class PreparedRequest(RequestEncodingMixin, RequestHooksMixin):\n256     \"\"\"The fully mutable :class:`PreparedRequest <PreparedRequest>` object,\n257     containing the exact bytes that will be sent to the server.\n258 \n259     Generated from either a :class:`Request <Request>` object or manually.\n260 \n261     Usage::\n262 \n263       >>> import requests\n264       >>> req = requests.Request('GET', 'http://httpbin.org/get')\n265       >>> r = req.prepare()\n266       <PreparedRequest [GET]>\n267 \n268       >>> s = requests.Session()\n269       >>> s.send(r)\n270       <Response [200]>\n271 \n272     \"\"\"\n273 \n274     def __init__(self):\n275         #: HTTP verb to send to the server.\n276         self.method = None\n277         #: HTTP URL to send the request to.\n278         self.url = None\n279         #: dictionary of HTTP headers.\n280         self.headers = None\n281         # The `CookieJar` used to create the Cookie header will be stored here\n282         # after prepare_cookies is called\n283         self._cookies = None\n284         #: request body to send to the server.\n285         self.body = None\n286         #: dictionary of callback hooks, for internal usage.\n287         self.hooks = default_hooks()\n288 \n289     def prepare(self, method=None, url=None, headers=None, files=None,\n290         data=None, params=None, auth=None, cookies=None, hooks=None, json=None):\n291         \"\"\"Prepares the entire request with the given parameters.\"\"\"\n292 \n293         self.prepare_method(method)\n294         self.prepare_url(url, params)\n295         self.prepare_headers(headers)\n296         self.prepare_cookies(cookies)\n297         self.prepare_body(data, files, json)\n298         self.prepare_auth(auth, url)\n299 \n300         # Note that prepare_auth must be last to enable authentication schemes\n301         # such as OAuth to work on a fully prepared request.\n302 \n303         # This MUST go after prepare_auth. Authenticators could add a hook\n304         self.prepare_hooks(hooks)\n305 \n306     def __repr__(self):\n307         return '<PreparedRequest [%s]>' % (self.method)\n308 \n309     def copy(self):\n310         p = PreparedRequest()\n311         p.method = self.method\n312         p.url = self.url\n313         p.headers = self.headers.copy() if self.headers is not None else None\n314         p._cookies = _copy_cookie_jar(self._cookies)\n315         p.body = self.body\n316         p.hooks = self.hooks\n317         return p\n318 \n319     def prepare_method(self, method):\n320         \"\"\"Prepares the given HTTP method.\"\"\"\n321         self.method = method\n322         if self.method is None:\n323             raise ValueError('Request method cannot be \"None\"')\n324         self.method = to_native_string(self.method).upper()\n325 \n326     def prepare_url(self, url, params):\n327         \"\"\"Prepares the given HTTP URL.\"\"\"\n328         #: Accept objects that have string representations.\n329         #: We're unable to blindly call unicode/str functions\n330         #: as this will include the bytestring indicator (b'')\n331         #: on python 3.x.\n332         #: https://github.com/kennethreitz/requests/pull/2238\n333         if isinstance(url, bytes):\n334             url = url.decode('utf8')\n335         else:\n336             url = unicode(url) if is_py2 else str(url)\n337 \n338         # Ignore any leading and trailing whitespace characters.\n339         url = url.strip()\n340 \n341         # Don't do any URL preparation for non-HTTP schemes like `mailto`,\n342         # `data` etc to work around exceptions from `url_parse`, which\n343         # handles RFC 3986 only.\n344         if ':' in url and not url.lower().startswith('http'):\n345             self.url = url\n346             return\n347 \n348         # Support for unicode domain names and paths.\n349         try:\n350             scheme, auth, host, port, path, query, fragment = parse_url(url)\n351         except LocationParseError as e:\n352             raise InvalidURL(*e.args)\n353 \n354         if not scheme:\n355             error = (\"Invalid URL {0!r}: No scheme supplied. Perhaps you meant http://{0}?\")\n356             error = error.format(to_native_string(url, 'utf8'))\n357 \n358             raise MissingScheme(error)\n359 \n360         if not host:\n361             raise InvalidURL(\"Invalid URL %r: No host supplied\" % url)\n362 \n363         # Only want to apply IDNA to the hostname\n364         try:\n365             host = host.encode('idna').decode('utf-8')\n366         except UnicodeError:\n367             raise InvalidURL('URL has an invalid label.')\n368 \n369         # Carefully reconstruct the network location\n370         netloc = auth or ''\n371         if netloc:\n372             netloc += '@'\n373         netloc += host\n374         if port:\n375             netloc += ':' + str(port)\n376 \n377         # Bare domains aren't valid URLs.\n378         if not path:\n379             path = '/'\n380 \n381         if is_py2:\n382             if isinstance(scheme, str):\n383                 scheme = scheme.encode('utf-8')\n384             if isinstance(netloc, str):\n385                 netloc = netloc.encode('utf-8')\n386             if isinstance(path, str):\n387                 path = path.encode('utf-8')\n388             if isinstance(query, str):\n389                 query = query.encode('utf-8')\n390             if isinstance(fragment, str):\n391                 fragment = fragment.encode('utf-8')\n392 \n393         if isinstance(params, (str, bytes)):\n394             params = to_native_string(params)\n395 \n396         enc_params = self._encode_params(params)\n397         if enc_params:\n398             if query:\n399                 query = '%s&%s' % (query, enc_params)\n400             else:\n401                 query = enc_params\n402 \n403         url = requote_uri(urlunparse([scheme, netloc, path, None, query, fragment]))\n404         self.url = url\n405 \n406     def prepare_headers(self, headers):\n407         \"\"\"Prepares the given HTTP headers.\"\"\"\n408 \n409         if headers:\n410             self.headers = CaseInsensitiveDict((to_native_string(name), value) for name, value in headers.items())\n411         else:\n412             self.headers = CaseInsensitiveDict()\n413 \n414     def prepare_body(self, data, files, json=None):\n415         \"\"\"Prepares the given HTTP body data.\"\"\"\n416 \n417         # Check if file, fo, generator, iterator.\n418         # If not, run through normal process.\n419 \n420         # Nottin' on you.\n421         body = None\n422         content_type = None\n423         length = None\n424 \n425         if not data and json is not None:\n426             content_type = 'application/json'\n427             body = complexjson.dumps(json)\n428 \n429         is_stream = all([\n430             hasattr(data, '__iter__'),\n431             not isinstance(data, (basestring, list, tuple, dict))\n432         ])\n433 \n434         try:\n435             length = super_len(data)\n436         except (TypeError, AttributeError, UnsupportedOperation):\n437             length = None\n438 \n439         if is_stream:\n440             body = data\n441 \n442             if files:\n443                 raise NotImplementedError('Streamed bodies and files are mutually exclusive.')\n444 \n445             if length:\n446                 self.headers['Content-Length'] = builtin_str(length)\n447             else:\n448                 self.headers['Transfer-Encoding'] = 'chunked'\n449         else:\n450             # Multi-part file uploads.\n451             if files:\n452                 (body, content_type) = self._encode_files(files, data)\n453             else:\n454                 if data:\n455                     body = self._encode_params(data)\n456                     if isinstance(data, basestring) or hasattr(data, 'read'):\n457                         content_type = None\n458                     else:\n459                         content_type = 'application/x-www-form-urlencoded'\n460 \n461             self.prepare_content_length(body)\n462 \n463             # Add content-type if it wasn't explicitly provided.\n464             if content_type and ('content-type' not in self.headers):\n465                 self.headers['Content-Type'] = content_type\n466 \n467         self.body = body\n468 \n469     def prepare_content_length(self, body):\n470         if hasattr(body, 'seek') and hasattr(body, 'tell'):\n471             body.seek(0, 2)\n472             self.headers['Content-Length'] = builtin_str(body.tell())\n473             body.seek(0, 0)\n474         elif body is not None:\n475             l = super_len(body)\n476             if l:\n477                 self.headers['Content-Length'] = builtin_str(l)\n478         elif (self.method not in ('GET', 'HEAD')) and (self.headers.get('Content-Length') is None):\n479             self.headers['Content-Length'] = '0'\n480 \n481     def prepare_auth(self, auth, url=''):\n482         \"\"\"Prepares the given HTTP auth data.\"\"\"\n483 \n484         # If no Auth is explicitly provided, extract it from the URL first.\n485         if auth is None:\n486             url_auth = get_auth_from_url(self.url)\n487             auth = url_auth if any(url_auth) else None\n488 \n489         if auth:\n490             if isinstance(auth, tuple) and len(auth) == 2:\n491                 # special-case basic HTTP auth\n492                 auth = HTTPBasicAuth(*auth)\n493 \n494             # Allow auth to make its changes.\n495             r = auth(self)\n496 \n497             # Update self to reflect the auth changes.\n498             self.__dict__.update(r.__dict__)\n499 \n500             # Recompute Content-Length\n501             self.prepare_content_length(self.body)\n502 \n503     def prepare_cookies(self, cookies):\n504         \"\"\"Prepares the given HTTP cookie data.\n505 \n506         This function eventually generates a ``Cookie`` header from the\n507         given cookies using cookielib. Due to cookielib's design, the header\n508         will not be regenerated if it already exists, meaning this function\n509         can only be called once for the life of the\n510         :class:`PreparedRequest <PreparedRequest>` object. Any subsequent calls\n511         to ``prepare_cookies`` will have no actual effect, unless the \"Cookie\"\n512         header is removed beforehand.\"\"\"\n513 \n514         if isinstance(cookies, cookielib.CookieJar):\n515             self._cookies = cookies\n516         else:\n517             self._cookies = cookiejar_from_dict(cookies)\n518 \n519         cookie_header = get_cookie_header(self._cookies, self)\n520         if cookie_header is not None:\n521             self.headers['Cookie'] = cookie_header\n522 \n523     def prepare_hooks(self, hooks):\n524         \"\"\"Prepares the given hooks.\"\"\"\n525         # hooks can be passed as None to the prepare method and to this\n526         # method. To prevent iterating over None, simply use an empty list\n527         # if hooks is False-y\n528         hooks = hooks or []\n529         for event in hooks:\n530             self.register_hook(event, hooks[event])\n531 \n532     def send(self, session=None, **send_kwargs):\n533         \"\"\"Sends the PreparedRequest to the given Session.\n534         If none is provided, one is created for you.\"\"\"\n535         session = requests.Session() if session is None else session\n536 \n537         with session:\n538             return session.send(self, **send_kwargs)\n",
        "intended_behavior": "This class provides additional context to the issue."
    }
]