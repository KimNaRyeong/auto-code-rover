[
    {
        "rel_file_path": "django/template/loaders/cached.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.2/django/template/loaders/cached.py",
        "start": 24,
        "end": 60,
        "class_name": null,
        "method_name": "get_template",
        "code": "24     def get_template(self, template_name, skip=None):\n25         \"\"\"\n26         Perform the caching that gives this loader its name. Often many of the\n27         templates attempted will be missing, so memory use is of concern here.\n28         To keep it in check, caching behavior is a little complicated when a\n29         template is not found. See ticket #26306 for more details.\n30 \n31         With template debugging disabled, cache the TemplateDoesNotExist class\n32         for every missing template and raise a new instance of it after\n33         fetching it from the cache.\n34 \n35         With template debugging enabled, a unique TemplateDoesNotExist object\n36         is cached for each missing template to preserve debug data. When\n37         raising an exception, Python sets __traceback__, __context__, and\n38         __cause__ attributes on it. Those attributes can contain references to\n39         all sorts of objects up the call chain and caching them creates a\n40         memory leak. Thus, unraised copies of the exceptions are cached and\n41         copies of those copies are raised after they're fetched from the cache.\n42         \"\"\"\n43         key = self.cache_key(template_name, skip)\n44         cached = self.get_template_cache.get(key)\n45         if cached:\n46             if isinstance(cached, type) and issubclass(cached, TemplateDoesNotExist):\n47                 raise cached(template_name)\n48             elif isinstance(cached, TemplateDoesNotExist):\n49                 raise copy_exception(cached)\n50             return cached\n51 \n52         try:\n53             template = super().get_template(template_name, skip)\n54         except TemplateDoesNotExist as e:\n55             self.get_template_cache[key] = copy_exception(e) if self.engine.debug else TemplateDoesNotExist\n56             raise\n57         else:\n58             self.get_template_cache[key] = template\n59 \n60         return template\n",
        "intended_behavior": "Modify the `get_template` function to check if the template's last modification time is newer than the time it was cached. If so, invalidate the cached template and reload it from its source. This ensures that any changes made to the template are reflected immediately without needing to restart the server, enhancing the development experience. To efficiently implement this, a mechanism for tracking the modification times and comparing them upon each template load request is needed. This behavior should be controlled by the `autoreload` option such that it is only active in development environments or when explicitly enabled to avoid any performance impact in production."
    },
    {
        "rel_file_path": "django/template/loaders/cached.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.2/django/template/loaders/cached.py",
        "start": 24,
        "end": 60,
        "class_name": "Loader",
        "method_name": "get_template",
        "code": "24     def get_template(self, template_name, skip=None):\n25         \"\"\"\n26         Perform the caching that gives this loader its name. Often many of the\n27         templates attempted will be missing, so memory use is of concern here.\n28         To keep it in check, caching behavior is a little complicated when a\n29         template is not found. See ticket #26306 for more details.\n30 \n31         With template debugging disabled, cache the TemplateDoesNotExist class\n32         for every missing template and raise a new instance of it after\n33         fetching it from the cache.\n34 \n35         With template debugging enabled, a unique TemplateDoesNotExist object\n36         is cached for each missing template to preserve debug data. When\n37         raising an exception, Python sets __traceback__, __context__, and\n38         __cause__ attributes on it. Those attributes can contain references to\n39         all sorts of objects up the call chain and caching them creates a\n40         memory leak. Thus, unraised copies of the exceptions are cached and\n41         copies of those copies are raised after they're fetched from the cache.\n42         \"\"\"\n43         key = self.cache_key(template_name, skip)\n44         cached = self.get_template_cache.get(key)\n45         if cached:\n46             if isinstance(cached, type) and issubclass(cached, TemplateDoesNotExist):\n47                 raise cached(template_name)\n48             elif isinstance(cached, TemplateDoesNotExist):\n49                 raise copy_exception(cached)\n50             return cached\n51 \n52         try:\n53             template = super().get_template(template_name, skip)\n54         except TemplateDoesNotExist as e:\n55             self.get_template_cache[key] = copy_exception(e) if self.engine.debug else TemplateDoesNotExist\n56             raise\n57         else:\n58             self.get_template_cache[key] = template\n59 \n60         return template\n",
        "intended_behavior": "Modify the `get_template` function to check if the template's last modification time is newer than the time it was cached. If so, invalidate the cached template and reload it from its source. This ensures that any changes made to the template are reflected immediately without needing to restart the server, enhancing the development experience. To efficiently implement this, a mechanism for tracking the modification times and comparing them upon each template load request is needed. This behavior should be controlled by the `autoreload` option such that it is only active in development environments or when explicitly enabled to avoid any performance impact in production."
    },
    {
        "rel_file_path": "django/template/backends/django.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.2/django/template/backends/django.py",
        "start": 14,
        "end": 45,
        "class_name": "DjangoTemplates",
        "method_name": null,
        "code": "14 class DjangoTemplates(BaseEngine):\n15 \n16     app_dirname = 'templates'\n17 \n18     def __init__(self, params):\n19         params = params.copy()\n20         options = params.pop('OPTIONS').copy()\n21         options.setdefault('autoescape', True)\n22         options.setdefault('debug', settings.DEBUG)\n23         options.setdefault('file_charset', 'utf-8')\n24         libraries = options.get('libraries', {})\n25         options['libraries'] = self.get_templatetag_libraries(libraries)\n26         super().__init__(params)\n27         self.engine = Engine(self.dirs, self.app_dirs, **options)\n28 \n29     def from_string(self, template_code):\n30         return Template(self.engine.from_string(template_code), self)\n31 \n32     def get_template(self, template_name):\n33         try:\n34             return Template(self.engine.get_template(template_name), self)\n35         except TemplateDoesNotExist as exc:\n36             reraise(exc, self)\n37 \n38     def get_templatetag_libraries(self, custom_libraries):\n39         \"\"\"\n40         Return a collation of template tag libraries from installed\n41         applications and the supplied custom_libraries argument.\n42         \"\"\"\n43         libraries = get_installed_libraries()\n44         libraries.update(custom_libraries)\n45         return libraries\n",
        "intended_behavior": "Ensure the backend's processing of the `TEMPLATES` configuration includes logic to interpret and apply the `autoreload` option. This might involve passing the `autoreload` flag down to the loader level where the template caching and loading logic can access it. Essentially, this adjustment would bridge the gap between the configuration and its practical application in template loading and caching behavior."
    }
]