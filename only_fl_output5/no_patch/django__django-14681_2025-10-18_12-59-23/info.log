2025-10-18 12:59:23.604 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-18 12:59:27.456 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=391, output_tokens=12, cost=0.004270
2025-10-18 12:59:49.052 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=571, output_tokens=902, cost=0.032770
2025-10-18 12:59:50.157 | INFO     | registered non reproducing test 0
2025-10-18 13:00:07.041 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=3063, output_tokens=674, cost=0.050850
2025-10-18 13:00:08.244 | INFO     | registered non reproducing test 1
2025-10-18 13:00:25.298 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2024, output_tokens=712, cost=0.041600
2025-10-18 13:00:26.358 | INFO     | registered non reproducing test 2
2025-10-18 13:00:26.358 | WARNING  | Failed to write a reproducer test; skipping reproducer tracing
2025-10-18 13:00:26.365 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 13:00:35.237 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=698, output_tokens=390, cost=0.018680
2025-10-18 13:00:35.245 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 13:00:38.005 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=744, output_tokens=74, cost=0.009660
2025-10-18 13:00:38.007 | DEBUG    | Extracted a valid json.
2025-10-18 13:00:38.007 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_class(\"File\")",
        "search_code(\"CSRF\")",
        "search_method(\"FileField\")",
        "search_code(\"FILE_UPLOAD_MAX_MEMORY_SIZE\")",
        "search_code(\"MEDIA_ROOT\")",
        "search_code(\"FILE_UPLOAD_TEMP_DIR\")"
    ],
    "bug_locations": []
}
2025-10-18 13:00:38.235 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-18 13:00:38.236 | DEBUG    | <Agent search> Analyzing search results.
2025-10-18 13:00:59.242 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2239, output_tokens=837, cost=0.047500
2025-10-18 13:00:59.255 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 13:01:05.092 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=3292, output_tokens=241, cost=0.040150
2025-10-18 13:01:05.098 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 13:01:13.718 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=595, output_tokens=263, cost=0.013840
2025-10-18 13:01:13.719 | DEBUG    | Extracted a valid json.
2025-10-18 13:01:13.719 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations":[
        {
            "file": "django/core/files/uploadhandler.py",
            "class": "MemoryFileUploadHandler",
            "method": "handle_raw_input",
            "intended_behavior": "Incorporate a check or exception handling around the storage operations to accurately report filesystem-related errors during the upload process. If a filesystem error is detected, such as inability to create or write to the FILE_UPLOAD_TEMP_DIR, raise a specific exception related to file storage instead of indirectly causing a CSRF verification failure. Preserve the existing functionality of determining whether the upload should be kept in memory or moved to filesystem based on size."
        },
        {
            "file": "django/middleware/csrf.py",
            "class": "",
            "method": "",
            "intended_behavior": "Modify the CSRF middleware to better handle exceptions that aren't directly related to CSRF token mismatches or absences, particularly those arising from filesystem interactions during file uploads. Ensure that CSRF verification failures are reported correctly as such, and other exceptions or errors (like those related to file storage or directory permissions) are not mistakenly reported as CSRF errors. This might involve adjusting error handling or exception catching in the middleware to discriminate between different types of errors more effectively."
        }
    ]
}
2025-10-18 13:01:13.723 | DEBUG    | Found override of handle_raw_input in FileUploadHandler
2025-10-18 13:01:13.723 | ERROR    | SearchBackend.search_method_in_class() missing 1 required positional argument: 'class_name'
Traceback (most recent call last):

  File "/home/kimnal0/auto-code-rover/app/main.py", line 656, in <module>
    main()
    └ <function main at 0x761e6b526c00>

  File "/home/kimnal0/auto-code-rover/app/main.py", line 120, in main
    run_task_groups(groups, num_processes, organize_output=True)
    │               │       └ 1
    │               └ {'setup_astropy__astropy__4.3': [<app.raw_tasks.RawSweTask object at 0x761d78dc37d0>, <app.raw_tasks.RawSweTask object at 0x7...
    └ <function run_task_groups at 0x761d7b11a3e0>

  File "/home/kimnal0/auto-code-rover/app/main.py", line 396, in run_task_groups
    run_tasks_serial(all_tasks)
    │                └ [<app.raw_tasks.RawSweTask object at 0x761d78dc37d0>, <app.raw_tasks.RawSweTask object at 0x761d78dc3800>, <app.raw_tasks.Raw...
    └ <function run_tasks_serial at 0x761d7b11a480>

  File "/home/kimnal0/auto-code-rover/app/main.py", line 414, in run_tasks_serial
    run_task_in_subprocess(task)
    │                      └ <app.raw_tasks.RawSweTask object at 0x761d78d3a870>
    └ <function run_task_in_subprocess at 0x761d7b11a660>

  File "/home/kimnal0/auto-code-rover/app/main.py", line 462, in run_task_in_subprocess
    executor.submit(run_raw_task, task)
    │        │      │             └ <app.raw_tasks.RawSweTask object at 0x761d78d3a870>
    │        │      └ <function run_raw_task at 0x761d7b11a700>
    │        └ <function ProcessPoolExecutor.submit at 0x761e6ae72020>
    └ <concurrent.futures.process.ProcessPoolExecutor object at 0x761d7b1d56d0>

  File "/home/kimnal0/miniconda3/envs/auto-code-rover/lib/python3.12/concurrent/futures/process.py", line 831, in submit
    self._start_executor_manager_thread()
    │    └ <function ProcessPoolExecutor._start_executor_manager_thread at 0x761e6ae71da0>
    └ <concurrent.futures.process.ProcessPoolExecutor object at 0x761d7b1d56d0>
  File "/home/kimnal0/miniconda3/envs/auto-code-rover/lib/python3.12/concurrent/futures/process.py", line 770, in _start_executor_manager_thread
    self._launch_processes()
    │    └ <function ProcessPoolExecutor._launch_processes at 0x761e6ae71ee0>
    └ <concurrent.futures.process.ProcessPoolExecutor object at 0x761d7b1d56d0>
  File "/home/kimnal0/miniconda3/envs/auto-code-rover/lib/python3.12/concurrent/futures/process.py", line 797, in _launch_processes
    self._spawn_process()
    │    └ <function ProcessPoolExecutor._spawn_process at 0x761e6ae71f80>
    └ <concurrent.futures.process.ProcessPoolExecutor object at 0x761d7b1d56d0>
  File "/home/kimnal0/miniconda3/envs/auto-code-rover/lib/python3.12/concurrent/futures/process.py", line 807, in _spawn_process
    p.start()
    │ └ <function BaseProcess.start at 0x761e6b02cea0>
    └ <ForkProcess name='ForkProcess-169' parent=497161 started>
  File "/home/kimnal0/miniconda3/envs/auto-code-rover/lib/python3.12/multiprocessing/process.py", line 121, in start
    self._popen = self._Popen(self)
    │    │        │    │      └ <ForkProcess name='ForkProcess-169' parent=497161 started>
    │    │        │    └ <staticmethod(<function ForkProcess._Popen at 0x761e6b09e0c0>)>
    │    │        └ <ForkProcess name='ForkProcess-169' parent=497161 started>
    │    └ None
    └ <ForkProcess name='ForkProcess-169' parent=497161 started>
  File "/home/kimnal0/miniconda3/envs/auto-code-rover/lib/python3.12/multiprocessing/context.py", line 282, in _Popen
    return Popen(process_obj)
           │     └ <ForkProcess name='ForkProcess-169' parent=497161 started>
           └ <class 'multiprocessing.popen_fork.Popen'>
  File "/home/kimnal0/miniconda3/envs/auto-code-rover/lib/python3.12/multiprocessing/popen_fork.py", line 19, in __init__
    self._launch(process_obj)
    │    │       └ <ForkProcess name='ForkProcess-169' parent=497161 started>
    │    └ <function Popen._launch at 0x761d7911b7e0>
    └ <multiprocessing.popen_fork.Popen object at 0x761d7a57e0c0>
  File "/home/kimnal0/miniconda3/envs/auto-code-rover/lib/python3.12/multiprocessing/popen_fork.py", line 71, in _launch
    code = process_obj._bootstrap(parent_sentinel=child_r)
           │           │                          └ 13
           │           └ <function BaseProcess._bootstrap at 0x761e6b02d8a0>
           └ <ForkProcess name='ForkProcess-169' parent=497161 started>
  File "/home/kimnal0/miniconda3/envs/auto-code-rover/lib/python3.12/multiprocessing/process.py", line 314, in _bootstrap
    self.run()
    │    └ <function BaseProcess.run at 0x761e6b02ce00>
    └ <ForkProcess name='ForkProcess-169' parent=497161 started>
  File "/home/kimnal0/miniconda3/envs/auto-code-rover/lib/python3.12/multiprocessing/process.py", line 108, in run
    self._target(*self._args, **self._kwargs)
    │    │        │    │        │    └ {}
    │    │        │    │        └ <ForkProcess name='ForkProcess-169' parent=497161 started>
    │    │        │    └ (<concurrent.futures.process._SafeQueue object at 0x761d795c47d0>, <multiprocessing.queues.SimpleQueue object at 0x761d795c79...
    │    │        └ <ForkProcess name='ForkProcess-169' parent=497161 started>
    │    └ <function _process_worker at 0x761e6ae711c0>
    └ <ForkProcess name='ForkProcess-169' parent=497161 started>
  File "/home/kimnal0/miniconda3/envs/auto-code-rover/lib/python3.12/concurrent/futures/process.py", line 263, in _process_worker
    r = call_item.fn(*call_item.args, **call_item.kwargs)
        │         │   │         │       │         └ {}
        │         │   │         │       └ <concurrent.futures.process._CallItem object at 0x761d7b442db0>
        │         │   │         └ (<app.raw_tasks.RawSweTask object at 0x761d7a57e660>,)
        │         │   └ <concurrent.futures.process._CallItem object at 0x761d7b442db0>
        │         └ <function run_raw_task at 0x761d7b11a700>
        └ <concurrent.futures.process._CallItem object at 0x761d7b442db0>

  File "/home/kimnal0/auto-code-rover/app/main.py", line 494, in run_raw_task
    run_ok = do_inference(task.to_task(), task_output_dir)
             │            │    │          └ '/home/kimnal0/auto-code-rover/only_fl_output5/django__django-14681_2025-10-18_12-59-23'
             │            │    └ <function RawSweTask.to_task at 0x761d7b1196c0>
             │            └ <app.raw_tasks.RawSweTask object at 0x761d7a57e660>
             └ <function do_inference at 0x761d7b11a8e0>

  File "/home/kimnal0/auto-code-rover/app/main.py", line 590, in do_inference
    run_ok = inference.run_one_task(
             │         └ <function run_one_task at 0x761d7b228400>
             └ <module 'app.inference' from '/home/kimnal0/auto-code-rover/app/inference.py'>

  File "/home/kimnal0/auto-code-rover/app/inference.py", line 128, in run_one_task
    if _run_one_task(str(out_dir), api_manager, task.get_issue_statement()):
       │                 │         │            │    └ <function SweTask.get_issue_statement at 0x761d7b9b84a0>
       │                 │         │            └ SweTask(task_id='django__django-14681', problem_statement="CSRF failure incorrectly reported on upload when there is a proble...
       │                 │         └ <app.manage.ProjectApiManager object at 0x761d7b21d610>
       │                 └ Path('/home/kimnal0/auto-code-rover/only_fl_output5/django__django-14681_2025-10-18_12-59-23/output_0')
       └ <function _run_one_task at 0x761d7b2298a0>

  File "/home/kimnal0/auto-code-rover/app/inference.py", line 303, in _run_one_task
    bug_locs, search_msg_thread = api_manager.search_manager.search_iterative(
                                  │           │              └ <function SearchManager.search_iterative at 0x761d7b431bc0>
                                  │           └ <app.search.search_manage.SearchManager object at 0x761d795c7ec0>
                                  └ <app.manage.ProjectApiManager object at 0x761d7b21d610>

  File "/home/kimnal0/auto-code-rover/app/search/search_manage.py", line 125, in search_iterative
    new_bug_locations.extend(self.backend.get_bug_loc_snippets_new(loc))
    │                 │      │    │       │                        └ {'file': 'django/core/files/uploadhandler.py', 'class': 'MemoryFileUploadHandler', 'method': 'handle_raw_input', 'intended_be...
    │                 │      │    │       └ <function SearchBackend.get_bug_loc_snippets_new at 0x761d7b4318a0>
    │                 │      │    └ <app.search.search_backend.SearchBackend object at 0x761d7b6a3170>
    │                 │      └ <app.search.search_manage.SearchManager object at 0x761d795c7ec0>
    │                 └ <method 'extend' of 'list' objects>
    └ []

  File "/home/kimnal0/auto-code-rover/app/search/search_backend.py", line 825, in get_bug_loc_snippets_new
    self._get_inherited_methods(res.class_name, res.func_name)
    │    │                      │   │           │   └ 'handle_raw_input'
    │    │                      │   │           └ SearchResult(file_path='/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__4.0/django/core/...
    │    │                      │   └ 'MemoryFileUploadHandler'
    │    │                      └ SearchResult(file_path='/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__4.0/django/core/...
    │    └ <function SearchBackend._get_inherited_methods at 0x761d7b431800>
    └ <app.search.search_backend.SearchBackend object at 0x761d7b6a3170>

  File "/home/kimnal0/auto-code-rover/app/search/search_backend.py", line 748, in _get_inherited_methods
    output, search_res, call_ok = self.search_method_in_class(super_call)
                                  │    │                      └ {'class_name': 'FileUploadHandler', 'method_name': 'handle_raw_input'}
                                  │    └ <function SearchBackend.search_method_in_class at 0x761d7b430f40>
                                  └ <app.search.search_backend.SearchBackend object at 0x761d7b6a3170>

> File "/home/kimnal0/auto-code-rover/app/utils.py", line 343, in wrapper
    return func(*args, **kwargs)
           │     │       └ {}
           │     └ (<app.search.search_backend.SearchBackend object at 0x761d7b6a3170>, {'class_name': 'FileUploadHandler', 'method_name': 'hand...
           └ <function SearchBackend.search_method_in_class at 0x761d7b430ea0>

TypeError: SearchBackend.search_method_in_class() missing 1 required positional argument: 'class_name'
2025-10-18 13:01:13.730 | DEBUG    | Bug location extracted successfully: [<file>django/core/files/uploadhandler.py</file>
<class>MemoryFileUploadHandler</class>
<method>handle_raw_input</method>
<code>
172     def handle_raw_input(self, input_data, META, content_length, boundary, encoding=None):
173         """
174         Use the content_length to signal whether or not this handler should be
175         used.
176         """
177         # Check the content-length header to see if we should
178         # If the post is too large, we cannot use the Memory handler.
179         self.activated = content_length <= settings.FILE_UPLOAD_MAX_MEMORY_SIZE

</code><intended_behavior>Incorporate a check or exception handling around the storage operations to accurately report filesystem-related errors during the upload process. If a filesystem error is detected, such as inability to create or write to the FILE_UPLOAD_TEMP_DIR, raise a specific exception related to file storage instead of indirectly causing a CSRF verification failure. Preserve the existing functionality of determining whether the upload should be kept in memory or moved to filesystem based on size.</intended_behavior>, <file>django/core/files/uploadhandler.py</file>
<class>MemoryFileUploadHandler</class>
<method>None</method>
<code>
167 class MemoryFileUploadHandler(FileUploadHandler):
168     """
169     File upload handler to stream uploads into memory (used for small files).
170     """
171 
172     def handle_raw_input(self, input_data, META, content_length, boundary, encoding=None):
173         """
174         Use the content_length to signal whether or not this handler should be
175         used.
176         """
177         # Check the content-length header to see if we should
178         # If the post is too large, we cannot use the Memory handler.
179         self.activated = content_length <= settings.FILE_UPLOAD_MAX_MEMORY_SIZE
180 
181     def new_file(self, *args, **kwargs):
182         super().new_file(*args, **kwargs)
183         if self.activated:
184             self.file = BytesIO()
185             raise StopFutureHandlers()
186 
187     def receive_data_chunk(self, raw_data, start):
188         """Add the data to the BytesIO file."""
189         if self.activated:
190             self.file.write(raw_data)
191         else:
192             return raw_data
193 
194     def file_complete(self, file_size):
195         """Return a file object if this handler is activated."""
196         if not self.activated:
197             return
198 
199         self.file.seek(0)
200         return InMemoryUploadedFile(
201             file=self.file,
202             field_name=self.field_name,
203             name=self.file_name,
204             content_type=self.content_type,
205             size=file_size,
206             charset=self.charset,
207             content_type_extra=self.content_type_extra
208         )

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>, <file>django/middleware/csrf.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2 Cross Site Request Forgery Middleware.
3 
4 This module provides a middleware that implements protection
5 against request forgeries from other sites.
6 """
7 import logging
8 import string
9 from collections import defaultdict
10 from urllib.parse import urlparse
11 
12 from django.conf import settings
13 from django.core.exceptions import DisallowedHost, ImproperlyConfigured
14 from django.http.request import HttpHeaders
15 from django.urls import get_callable
16 from django.utils.cache import patch_vary_headers
17 from django.utils.crypto import constant_time_compare, get_random_string
18 from django.utils.deprecation import MiddlewareMixin
19 from django.utils.functional import cached_property
20 from django.utils.http import is_same_domain
21 from django.utils.log import log_response
22 from django.utils.regex_helper import _lazy_re_compile
23 
24 logger = logging.getLogger('django.security.csrf')
25 # This matches if any character is not in CSRF_ALLOWED_CHARS.
26 invalid_token_chars_re = _lazy_re_compile('[^a-zA-Z0-9]')
27 
28 REASON_BAD_ORIGIN = "Origin checking failed - %s does not match any trusted origins."
29 REASON_NO_REFERER = "Referer checking failed - no Referer."
30 REASON_BAD_REFERER = "Referer checking failed - %s does not match any trusted origins."
31 REASON_NO_CSRF_COOKIE = "CSRF cookie not set."
32 REASON_CSRF_TOKEN_MISSING = 'CSRF token missing.'
33 REASON_MALFORMED_REFERER = "Referer checking failed - Referer is malformed."
34 REASON_INSECURE_REFERER = "Referer checking failed - Referer is insecure while host is secure."
35 # The reason strings below are for passing to InvalidTokenFormat. They are
36 # phrases without a subject because they can be in reference to either the CSRF
37 # cookie or non-cookie token.
38 REASON_INCORRECT_LENGTH = 'has incorrect length'
39 REASON_INVALID_CHARACTERS = 'has invalid characters'
40 
41 CSRF_SECRET_LENGTH = 32
42 CSRF_TOKEN_LENGTH = 2 * CSRF_SECRET_LENGTH
43 CSRF_ALLOWED_CHARS = string.ascii_letters + string.digits
44 CSRF_SESSION_KEY = '_csrftoken'
45 
46 
47 def _get_failure_view():
48     """Return the view to be used for CSRF rejections."""
49     return get_callable(settings.CSRF_FAILURE_VIEW)
50 
51 
52 def _get_new_csrf_string():
53     return get_random_string(CSRF_SECRET_LENGTH, allowed_chars=CSRF_ALLOWED_CHARS)
54 
55 
56 def _mask_cipher_secret(secret):
57     """
58     Given a secret (assumed to be a string of CSRF_ALLOWED_CHARS), generate a
59     token by adding a mask and applying it to the secret.
60     """
61     mask = _get_new_csrf_string()
62     chars = CSRF_ALLOWED_CHARS
63     pairs = zip((chars.index(x) for x in secret), (chars.index(x) for x in mask))
64     cipher = ''.join(chars[(x + y) % len(chars)] for x, y in pairs)
65     return mask + cipher
66 
67 
68 def _unmask_cipher_token(token):
69     """
70     Given a token (assumed to be a string of CSRF_ALLOWED_CHARS, of length
71     CSRF_TOKEN_LENGTH, and that its first half is a mask), use it to decrypt
72     the second half to produce the original secret.
73     """
74     mask = token[:CSRF_SECRET_LENGTH]
75     token = token[CSRF_SECRET_LENGTH:]
76     chars = CSRF_ALLOWED_CHARS
77     pairs = zip((chars.index(x) for x in token), (chars.index(x) for x in mask))
78     return ''.join(chars[x - y] for x, y in pairs)  # Note negative values are ok
79 
80 
81 def _get_new_csrf_token():
82     return _mask_cipher_secret(_get_new_csrf_string())
83 
84 
85 def get_token(request):
86     """
87     Return the CSRF token required for a POST form. The token is an
88     alphanumeric value. A new token is created if one is not already set.
89 
90     A side effect of calling this function is to make the csrf_protect
91     decorator and the CsrfViewMiddleware add a CSRF cookie and a 'Vary: Cookie'
92     header to the outgoing response.  For this reason, you may need to use this
93     function lazily, as is done by the csrf context processor.
94     """
95     if "CSRF_COOKIE" not in request.META:
96         csrf_secret = _get_new_csrf_string()
97         request.META["CSRF_COOKIE"] = _mask_cipher_secret(csrf_secret)
98     else:
99         csrf_secret = _unmask_cipher_token(request.META["CSRF_COOKIE"])
100     request.META["CSRF_COOKIE_USED"] = True
101     return _mask_cipher_secret(csrf_secret)
102 
103 
104 def rotate_token(request):
105     """
106     Change the CSRF token in use for a request - should be done on login
107     for security purposes.
108     """
109     request.META.update({
110         "CSRF_COOKIE_USED": True,
111         "CSRF_COOKIE": _get_new_csrf_token(),
112     })
113     request.csrf_cookie_needs_reset = True
114 
115 
116 class InvalidTokenFormat(Exception):
117     def __init__(self, reason):
118         self.reason = reason
119 
120 
121 def _sanitize_token(token):
122     if len(token) not in (CSRF_TOKEN_LENGTH, CSRF_SECRET_LENGTH):
123         raise InvalidTokenFormat(REASON_INCORRECT_LENGTH)
124     # Make sure all characters are in CSRF_ALLOWED_CHARS.
125     if invalid_token_chars_re.search(token):
126         raise InvalidTokenFormat(REASON_INVALID_CHARACTERS)
127     if len(token) == CSRF_SECRET_LENGTH:
128         # Older Django versions set cookies to values of CSRF_SECRET_LENGTH
129         # alphanumeric characters. For backwards compatibility, accept
130         # such values as unmasked secrets.
131         # It's easier to mask here and be consistent later, rather than add
132         # different code paths in the checks, although that might be a tad more
133         # efficient.
134         return _mask_cipher_secret(token)
135     return token
136 
137 
138 def _compare_masked_tokens(request_csrf_token, csrf_token):
139     # Assume both arguments are sanitized -- that is, strings of
140     # length CSRF_TOKEN_LENGTH, all CSRF_ALLOWED_CHARS.
141     return constant_time_compare(
142         _unmask_cipher_token(request_csrf_token),
143         _unmask_cipher_token(csrf_token),
144     )
145 
146 
147 class RejectRequest(Exception):
148     def __init__(self, reason):
149         self.reason = reason
150 
151 
152 class CsrfViewMiddleware(MiddlewareMixin):
153     """
154     Require a present and correct csrfmiddlewaretoken for POST requests that
155     have a CSRF cookie, and set an outgoing CSRF cookie.
156 
157     This middleware should be used in conjunction with the {% csrf_token %}
158     template tag.
159     """
160     @cached_property
161     def csrf_trusted_origins_hosts(self):
162         return [
163             urlparse(origin).netloc.lstrip('*')
164             for origin in settings.CSRF_TRUSTED_ORIGINS
165         ]
166 
167     @cached_property
168     def allowed_origins_exact(self):
169         return {
170             origin for origin in settings.CSRF_TRUSTED_ORIGINS
171             if '*' not in origin
172         }
173 
174     @cached_property
175     def allowed_origin_subdomains(self):
176         """
177         A mapping of allowed schemes to list of allowed netlocs, where all
178         subdomains of the netloc are allowed.
179         """
180         allowed_origin_subdomains = defaultdict(list)
181         for parsed in (urlparse(origin) for origin in settings.CSRF_TRUSTED_ORIGINS if '*' in origin):
182             allowed_origin_subdomains[parsed.scheme].append(parsed.netloc.lstrip('*'))
183         return allowed_origin_subdomains
184 
185     # The _accept and _reject methods currently only exist for the sake of the
186     # requires_csrf_token decorator.
187     def _accept(self, request):
188         # Avoid checking the request twice by adding a custom attribute to
189         # request.  This will be relevant when both decorator and middleware
190         # are used.
191         request.csrf_processing_done = True
192         return None
193 
194     def _reject(self, request, reason):
195         response = _get_failure_view()(request, reason=reason)
196         log_response(
197             'Forbidden (%s): %s', reason, request.path,
198             response=response,
199             request=request,
200             logger=logger,
201         )
202         return response
203 
204     def _get_token(self, request):
205         if settings.CSRF_USE_SESSIONS:
206             try:
207                 return request.session.get(CSRF_SESSION_KEY)
208             except AttributeError:
209                 raise ImproperlyConfigured(
210                     'CSRF_USE_SESSIONS is enabled, but request.session is not '
211                     'set. SessionMiddleware must appear before CsrfViewMiddleware '
212                     'in MIDDLEWARE.'
213                 )
214         else:
215             try:
216                 cookie_token = request.COOKIES[settings.CSRF_COOKIE_NAME]
217             except KeyError:
218                 return None
219 
220             # This can raise InvalidTokenFormat.
221             csrf_token = _sanitize_token(cookie_token)
222 
223             if csrf_token != cookie_token:
224                 # Then the cookie token had length CSRF_SECRET_LENGTH, so flag
225                 # to replace it with the masked version.
226                 request.csrf_cookie_needs_reset = True
227             return csrf_token
228 
229     def _set_token(self, request, response):
230         if settings.CSRF_USE_SESSIONS:
231             if request.session.get(CSRF_SESSION_KEY) != request.META['CSRF_COOKIE']:
232                 request.session[CSRF_SESSION_KEY] = request.META['CSRF_COOKIE']
233         else:
234             response.set_cookie(
235                 settings.CSRF_COOKIE_NAME,
236                 request.META['CSRF_COOKIE'],
237                 max_age=settings.CSRF_COOKIE_AGE,
238                 domain=settings.CSRF_COOKIE_DOMAIN,
239                 path=settings.CSRF_COOKIE_PATH,
240                 secure=settings.CSRF_COOKIE_SECURE,
241                 httponly=settings.CSRF_COOKIE_HTTPONLY,
242                 samesite=settings.CSRF_COOKIE_SAMESITE,
243             )
244             # Set the Vary header since content varies with the CSRF cookie.
245             patch_vary_headers(response, ('Cookie',))
246 
247     def _origin_verified(self, request):
248         request_origin = request.META['HTTP_ORIGIN']
249         try:
250             good_host = request.get_host()
251         except DisallowedHost:
252             pass
253         else:
254             good_origin = '%s://%s' % (
255                 'https' if request.is_secure() else 'http',
256                 good_host,
257             )
258             if request_origin == good_origin:
259                 return True
260         if request_origin in self.allowed_origins_exact:
261             return True
262         try:
263             parsed_origin = urlparse(request_origin)
264         except ValueError:
265             return False
266         request_scheme = parsed_origin.scheme
267         request_netloc = parsed_origin.netloc
268         return any(
269             is_same_domain(request_netloc, host)
270             for host in self.allowed_origin_subdomains.get(request_scheme, ())
271         )
272 
273     def _check_referer(self, request):
274         referer = request.META.get('HTTP_REFERER')
275         if referer is None:
276             raise RejectRequest(REASON_NO_REFERER)
277 
278         try:
279             referer = urlparse(referer)
280         except ValueError:
281             raise RejectRequest(REASON_MALFORMED_REFERER)
282 
283         # Make sure we have a valid URL for Referer.
284         if '' in (referer.scheme, referer.netloc):
285             raise RejectRequest(REASON_MALFORMED_REFERER)
286 
287         # Ensure that our Referer is also secure.
288         if referer.scheme != 'https':
289             raise RejectRequest(REASON_INSECURE_REFERER)
290 
291         if any(
292             is_same_domain(referer.netloc, host)
293             for host in self.csrf_trusted_origins_hosts
294         ):
295             return
296         # Allow matching the configured cookie domain.
297         good_referer = (
298             settings.SESSION_COOKIE_DOMAIN
299             if settings.CSRF_USE_SESSIONS
300             else settings.CSRF_COOKIE_DOMAIN
301         )
302         if good_referer is None:
303             # If no cookie domain is configured, allow matching the current
304             # host:port exactly if it's permitted by ALLOWED_HOSTS.
305             try:
306                 # request.get_host() includes the port.
307                 good_referer = request.get_host()
308             except DisallowedHost:
309                 raise RejectRequest(REASON_BAD_REFERER % referer.geturl())
310         else:
311             server_port = request.get_port()
312             if server_port not in ('443', '80'):
313                 good_referer = '%s:%s' % (good_referer, server_port)
314 
315         if not is_same_domain(referer.netloc, good_referer):
316             raise RejectRequest(REASON_BAD_REFERER % referer.geturl())
317 
318     def _bad_token_message(self, reason, token_source):
319         if token_source != 'POST':
320             # Assume it is a settings.CSRF_HEADER_NAME value.
321             header_name = HttpHeaders.parse_header_name(token_source)
322             token_source = f'the {header_name!r} HTTP header'
323         return f'CSRF token from {token_source} {reason}.'
324 
325     def _check_token(self, request):
326         # Access csrf_token via self._get_token() as rotate_token() may have
327         # been called by an authentication middleware during the
328         # process_request() phase.
329         try:
330             csrf_token = self._get_token(request)
331         except InvalidTokenFormat as exc:
332             raise RejectRequest(f'CSRF cookie {exc.reason}.')
333 
334         if csrf_token is None:
335             # No CSRF cookie. For POST requests, we insist on a CSRF cookie,
336             # and in this way we can avoid all CSRF attacks, including login
337             # CSRF.
338             raise RejectRequest(REASON_NO_CSRF_COOKIE)
339 
340         # Check non-cookie token for match.
341         request_csrf_token = ''
342         if request.method == 'POST':
343             try:
344                 request_csrf_token = request.POST.get('csrfmiddlewaretoken', '')
345             except OSError:
346                 # Handle a broken connection before we've completed reading the
347                 # POST data. process_view shouldn't raise any exceptions, so
348                 # we'll ignore and serve the user a 403 (assuming they're still
349                 # listening, which they probably aren't because of the error).
350                 pass
351 
352         if request_csrf_token == '':
353             # Fall back to X-CSRFToken, to make things easier for AJAX, and
354             # possible for PUT/DELETE.
355             try:
356                 request_csrf_token = request.META[settings.CSRF_HEADER_NAME]
357             except KeyError:
358                 raise RejectRequest(REASON_CSRF_TOKEN_MISSING)
359             token_source = settings.CSRF_HEADER_NAME
360         else:
361             token_source = 'POST'
362 
363         try:
364             request_csrf_token = _sanitize_token(request_csrf_token)
365         except InvalidTokenFormat as exc:
366             reason = self._bad_token_message(exc.reason, token_source)
367             raise RejectRequest(reason)
368 
369         if not _compare_masked_tokens(request_csrf_token, csrf_token):
370             reason = self._bad_token_message('incorrect', token_source)
371             raise RejectRequest(reason)
372 
373     def process_request(self, request):
374         try:
375             csrf_token = self._get_token(request)
376         except InvalidTokenFormat:
377             csrf_token = _get_new_csrf_token()
378             request.csrf_cookie_needs_reset = True
379 
380         if csrf_token is not None:
381             # Use same token next time.
382             request.META['CSRF_COOKIE'] = csrf_token
383 
384     def process_view(self, request, callback, callback_args, callback_kwargs):
385         if getattr(request, 'csrf_processing_done', False):
386             return None
387 
388         # Wait until request.META["CSRF_COOKIE"] has been manipulated before
389         # bailing out, so that get_token still works
390         if getattr(callback, 'csrf_exempt', False):
391             return None
392 
393         # Assume that anything not defined as 'safe' by RFC7231 needs protection
394         if request.method in ('GET', 'HEAD', 'OPTIONS', 'TRACE'):
395             return self._accept(request)
396 
397         if getattr(request, '_dont_enforce_csrf_checks', False):
398             # Mechanism to turn off CSRF checks for test suite. It comes after
399             # the creation of CSRF cookies, so that everything else continues
400             # to work exactly the same (e.g. cookies are sent, etc.), but
401             # before any branches that call the _reject method.
402             return self._accept(request)
403 
404         # Reject the request if the Origin header doesn't match an allowed
405         # value.
406         if 'HTTP_ORIGIN' in request.META:
407             if not self._origin_verified(request):
408                 return self._reject(request, REASON_BAD_ORIGIN % request.META['HTTP_ORIGIN'])
409         elif request.is_secure():
410             # If the Origin header wasn't provided, reject HTTPS requests if
411             # the Referer header doesn't match an allowed value.
412             #
413             # Suppose user visits http://example.com/
414             # An active network attacker (man-in-the-middle, MITM) sends a
415             # POST form that targets https://example.com/detonate-bomb/ and
416             # submits it via JavaScript.
417             #
418             # The attacker will need to provide a CSRF cookie and token, but
419             # that's no problem for a MITM and the session-independent secret
420             # we're using. So the MITM can circumvent the CSRF protection. This
421             # is true for any HTTP connection, but anyone using HTTPS expects
422             # better! For this reason, for https://example.com/ we need
423             # additional protection that treats http://example.com/ as
424             # completely untrusted. Under HTTPS, Barth et al. found that the
425             # Referer header is missing for same-domain requests in only about
426             # 0.2% of cases or less, so we can use strict Referer checking.
427             try:
428                 self._check_referer(request)
429             except RejectRequest as exc:
430                 return self._reject(request, exc.reason)
431 
432         try:
433             self._check_token(request)
434         except RejectRequest as exc:
435             return self._reject(request, exc.reason)
436 
437         return self._accept(request)
438 
439     def process_response(self, request, response):
440         # Send the CSRF cookie whenever the cookie is being used (even if the
441         # client already has it) in order to renew the expiry timer, but only
442         # if it hasn't already been sent during this request-response cycle.
443         # Also, send the cookie no matter what if a reset was requested.
444         if (
445             getattr(request, 'csrf_cookie_needs_reset', False) or (
446                 request.META.get('CSRF_COOKIE_USED') and
447                 not getattr(response, 'csrf_cookie_set', False)
448             )
449         ):
450             self._set_token(request, response)
451             # Update state to prevent _set_token() from being unnecessarily
452             # called again in process_response() by other instances of
453             # CsrfViewMiddleware. This can happen e.g. when both a decorator
454             # and middleware are used. However, the csrf_cookie_needs_reset
455             # attribute is still respected in subsequent calls e.g. in case
456             # rotate_token() is called in process_response() later by custom
457             # middleware but before those subsequent calls.
458             response.csrf_cookie_set = True
459             request.csrf_cookie_needs_reset = False
460 
461         return response

</code><intended_behavior>Modify the CSRF middleware to better handle exceptions that aren't directly related to CSRF token mismatches or absences, particularly those arising from filesystem interactions during file uploads. Ensure that CSRF verification failures are reported correctly as such, and other exceptions or errors (like those related to file storage or directory permissions) are not mistakenly reported as CSRF errors. This might involve adjusting error handling or exception catching in the middleware to discriminate between different types of errors more effectively.</intended_behavior>]
2025-10-18 13:01:13.730 | INFO     | Search completed. Bug locations: [<file>django/core/files/uploadhandler.py</file>
<class>MemoryFileUploadHandler</class>
<method>handle_raw_input</method>
<code>
172     def handle_raw_input(self, input_data, META, content_length, boundary, encoding=None):
173         """
174         Use the content_length to signal whether or not this handler should be
175         used.
176         """
177         # Check the content-length header to see if we should
178         # If the post is too large, we cannot use the Memory handler.
179         self.activated = content_length <= settings.FILE_UPLOAD_MAX_MEMORY_SIZE

</code><intended_behavior>Incorporate a check or exception handling around the storage operations to accurately report filesystem-related errors during the upload process. If a filesystem error is detected, such as inability to create or write to the FILE_UPLOAD_TEMP_DIR, raise a specific exception related to file storage instead of indirectly causing a CSRF verification failure. Preserve the existing functionality of determining whether the upload should be kept in memory or moved to filesystem based on size.</intended_behavior>, <file>django/core/files/uploadhandler.py</file>
<class>MemoryFileUploadHandler</class>
<method>None</method>
<code>
167 class MemoryFileUploadHandler(FileUploadHandler):
168     """
169     File upload handler to stream uploads into memory (used for small files).
170     """
171 
172     def handle_raw_input(self, input_data, META, content_length, boundary, encoding=None):
173         """
174         Use the content_length to signal whether or not this handler should be
175         used.
176         """
177         # Check the content-length header to see if we should
178         # If the post is too large, we cannot use the Memory handler.
179         self.activated = content_length <= settings.FILE_UPLOAD_MAX_MEMORY_SIZE
180 
181     def new_file(self, *args, **kwargs):
182         super().new_file(*args, **kwargs)
183         if self.activated:
184             self.file = BytesIO()
185             raise StopFutureHandlers()
186 
187     def receive_data_chunk(self, raw_data, start):
188         """Add the data to the BytesIO file."""
189         if self.activated:
190             self.file.write(raw_data)
191         else:
192             return raw_data
193 
194     def file_complete(self, file_size):
195         """Return a file object if this handler is activated."""
196         if not self.activated:
197             return
198 
199         self.file.seek(0)
200         return InMemoryUploadedFile(
201             file=self.file,
202             field_name=self.field_name,
203             name=self.file_name,
204             content_type=self.content_type,
205             size=file_size,
206             charset=self.charset,
207             content_type_extra=self.content_type_extra
208         )

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>, <file>django/middleware/csrf.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2 Cross Site Request Forgery Middleware.
3 
4 This module provides a middleware that implements protection
5 against request forgeries from other sites.
6 """
7 import logging
8 import string
9 from collections import defaultdict
10 from urllib.parse import urlparse
11 
12 from django.conf import settings
13 from django.core.exceptions import DisallowedHost, ImproperlyConfigured
14 from django.http.request import HttpHeaders
15 from django.urls import get_callable
16 from django.utils.cache import patch_vary_headers
17 from django.utils.crypto import constant_time_compare, get_random_string
18 from django.utils.deprecation import MiddlewareMixin
19 from django.utils.functional import cached_property
20 from django.utils.http import is_same_domain
21 from django.utils.log import log_response
22 from django.utils.regex_helper import _lazy_re_compile
23 
24 logger = logging.getLogger('django.security.csrf')
25 # This matches if any character is not in CSRF_ALLOWED_CHARS.
26 invalid_token_chars_re = _lazy_re_compile('[^a-zA-Z0-9]')
27 
28 REASON_BAD_ORIGIN = "Origin checking failed - %s does not match any trusted origins."
29 REASON_NO_REFERER = "Referer checking failed - no Referer."
30 REASON_BAD_REFERER = "Referer checking failed - %s does not match any trusted origins."
31 REASON_NO_CSRF_COOKIE = "CSRF cookie not set."
32 REASON_CSRF_TOKEN_MISSING = 'CSRF token missing.'
33 REASON_MALFORMED_REFERER = "Referer checking failed - Referer is malformed."
34 REASON_INSECURE_REFERER = "Referer checking failed - Referer is insecure while host is secure."
35 # The reason strings below are for passing to InvalidTokenFormat. They are
36 # phrases without a subject because they can be in reference to either the CSRF
37 # cookie or non-cookie token.
38 REASON_INCORRECT_LENGTH = 'has incorrect length'
39 REASON_INVALID_CHARACTERS = 'has invalid characters'
40 
41 CSRF_SECRET_LENGTH = 32
42 CSRF_TOKEN_LENGTH = 2 * CSRF_SECRET_LENGTH
43 CSRF_ALLOWED_CHARS = string.ascii_letters + string.digits
44 CSRF_SESSION_KEY = '_csrftoken'
45 
46 
47 def _get_failure_view():
48     """Return the view to be used for CSRF rejections."""
49     return get_callable(settings.CSRF_FAILURE_VIEW)
50 
51 
52 def _get_new_csrf_string():
53     return get_random_string(CSRF_SECRET_LENGTH, allowed_chars=CSRF_ALLOWED_CHARS)
54 
55 
56 def _mask_cipher_secret(secret):
57     """
58     Given a secret (assumed to be a string of CSRF_ALLOWED_CHARS), generate a
59     token by adding a mask and applying it to the secret.
60     """
61     mask = _get_new_csrf_string()
62     chars = CSRF_ALLOWED_CHARS
63     pairs = zip((chars.index(x) for x in secret), (chars.index(x) for x in mask))
64     cipher = ''.join(chars[(x + y) % len(chars)] for x, y in pairs)
65     return mask + cipher
66 
67 
68 def _unmask_cipher_token(token):
69     """
70     Given a token (assumed to be a string of CSRF_ALLOWED_CHARS, of length
71     CSRF_TOKEN_LENGTH, and that its first half is a mask), use it to decrypt
72     the second half to produce the original secret.
73     """
74     mask = token[:CSRF_SECRET_LENGTH]
75     token = token[CSRF_SECRET_LENGTH:]
76     chars = CSRF_ALLOWED_CHARS
77     pairs = zip((chars.index(x) for x in token), (chars.index(x) for x in mask))
78     return ''.join(chars[x - y] for x, y in pairs)  # Note negative values are ok
79 
80 
81 def _get_new_csrf_token():
82     return _mask_cipher_secret(_get_new_csrf_string())
83 
84 
85 def get_token(request):
86     """
87     Return the CSRF token required for a POST form. The token is an
88     alphanumeric value. A new token is created if one is not already set.
89 
90     A side effect of calling this function is to make the csrf_protect
91     decorator and the CsrfViewMiddleware add a CSRF cookie and a 'Vary: Cookie'
92     header to the outgoing response.  For this reason, you may need to use this
93     function lazily, as is done by the csrf context processor.
94     """
95     if "CSRF_COOKIE" not in request.META:
96         csrf_secret = _get_new_csrf_string()
97         request.META["CSRF_COOKIE"] = _mask_cipher_secret(csrf_secret)
98     else:
99         csrf_secret = _unmask_cipher_token(request.META["CSRF_COOKIE"])
100     request.META["CSRF_COOKIE_USED"] = True
101     return _mask_cipher_secret(csrf_secret)
102 
103 
104 def rotate_token(request):
105     """
106     Change the CSRF token in use for a request - should be done on login
107     for security purposes.
108     """
109     request.META.update({
110         "CSRF_COOKIE_USED": True,
111         "CSRF_COOKIE": _get_new_csrf_token(),
112     })
113     request.csrf_cookie_needs_reset = True
114 
115 
116 class InvalidTokenFormat(Exception):
117     def __init__(self, reason):
118         self.reason = reason
119 
120 
121 def _sanitize_token(token):
122     if len(token) not in (CSRF_TOKEN_LENGTH, CSRF_SECRET_LENGTH):
123         raise InvalidTokenFormat(REASON_INCORRECT_LENGTH)
124     # Make sure all characters are in CSRF_ALLOWED_CHARS.
125     if invalid_token_chars_re.search(token):
126         raise InvalidTokenFormat(REASON_INVALID_CHARACTERS)
127     if len(token) == CSRF_SECRET_LENGTH:
128         # Older Django versions set cookies to values of CSRF_SECRET_LENGTH
129         # alphanumeric characters. For backwards compatibility, accept
130         # such values as unmasked secrets.
131         # It's easier to mask here and be consistent later, rather than add
132         # different code paths in the checks, although that might be a tad more
133         # efficient.
134         return _mask_cipher_secret(token)
135     return token
136 
137 
138 def _compare_masked_tokens(request_csrf_token, csrf_token):
139     # Assume both arguments are sanitized -- that is, strings of
140     # length CSRF_TOKEN_LENGTH, all CSRF_ALLOWED_CHARS.
141     return constant_time_compare(
142         _unmask_cipher_token(request_csrf_token),
143         _unmask_cipher_token(csrf_token),
144     )
145 
146 
147 class RejectRequest(Exception):
148     def __init__(self, reason):
149         self.reason = reason
150 
151 
152 class CsrfViewMiddleware(MiddlewareMixin):
153     """
154     Require a present and correct csrfmiddlewaretoken for POST requests that
155     have a CSRF cookie, and set an outgoing CSRF cookie.
156 
157     This middleware should be used in conjunction with the {% csrf_token %}
158     template tag.
159     """
160     @cached_property
161     def csrf_trusted_origins_hosts(self):
162         return [
163             urlparse(origin).netloc.lstrip('*')
164             for origin in settings.CSRF_TRUSTED_ORIGINS
165         ]
166 
167     @cached_property
168     def allowed_origins_exact(self):
169         return {
170             origin for origin in settings.CSRF_TRUSTED_ORIGINS
171             if '*' not in origin
172         }
173 
174     @cached_property
175     def allowed_origin_subdomains(self):
176         """
177         A mapping of allowed schemes to list of allowed netlocs, where all
178         subdomains of the netloc are allowed.
179         """
180         allowed_origin_subdomains = defaultdict(list)
181         for parsed in (urlparse(origin) for origin in settings.CSRF_TRUSTED_ORIGINS if '*' in origin):
182             allowed_origin_subdomains[parsed.scheme].append(parsed.netloc.lstrip('*'))
183         return allowed_origin_subdomains
184 
185     # The _accept and _reject methods currently only exist for the sake of the
186     # requires_csrf_token decorator.
187     def _accept(self, request):
188         # Avoid checking the request twice by adding a custom attribute to
189         # request.  This will be relevant when both decorator and middleware
190         # are used.
191         request.csrf_processing_done = True
192         return None
193 
194     def _reject(self, request, reason):
195         response = _get_failure_view()(request, reason=reason)
196         log_response(
197             'Forbidden (%s): %s', reason, request.path,
198             response=response,
199             request=request,
200             logger=logger,
201         )
202         return response
203 
204     def _get_token(self, request):
205         if settings.CSRF_USE_SESSIONS:
206             try:
207                 return request.session.get(CSRF_SESSION_KEY)
208             except AttributeError:
209                 raise ImproperlyConfigured(
210                     'CSRF_USE_SESSIONS is enabled, but request.session is not '
211                     'set. SessionMiddleware must appear before CsrfViewMiddleware '
212                     'in MIDDLEWARE.'
213                 )
214         else:
215             try:
216                 cookie_token = request.COOKIES[settings.CSRF_COOKIE_NAME]
217             except KeyError:
218                 return None
219 
220             # This can raise InvalidTokenFormat.
221             csrf_token = _sanitize_token(cookie_token)
222 
223             if csrf_token != cookie_token:
224                 # Then the cookie token had length CSRF_SECRET_LENGTH, so flag
225                 # to replace it with the masked version.
226                 request.csrf_cookie_needs_reset = True
227             return csrf_token
228 
229     def _set_token(self, request, response):
230         if settings.CSRF_USE_SESSIONS:
231             if request.session.get(CSRF_SESSION_KEY) != request.META['CSRF_COOKIE']:
232                 request.session[CSRF_SESSION_KEY] = request.META['CSRF_COOKIE']
233         else:
234             response.set_cookie(
235                 settings.CSRF_COOKIE_NAME,
236                 request.META['CSRF_COOKIE'],
237                 max_age=settings.CSRF_COOKIE_AGE,
238                 domain=settings.CSRF_COOKIE_DOMAIN,
239                 path=settings.CSRF_COOKIE_PATH,
240                 secure=settings.CSRF_COOKIE_SECURE,
241                 httponly=settings.CSRF_COOKIE_HTTPONLY,
242                 samesite=settings.CSRF_COOKIE_SAMESITE,
243             )
244             # Set the Vary header since content varies with the CSRF cookie.
245             patch_vary_headers(response, ('Cookie',))
246 
247     def _origin_verified(self, request):
248         request_origin = request.META['HTTP_ORIGIN']
249         try:
250             good_host = request.get_host()
251         except DisallowedHost:
252             pass
253         else:
254             good_origin = '%s://%s' % (
255                 'https' if request.is_secure() else 'http',
256                 good_host,
257             )
258             if request_origin == good_origin:
259                 return True
260         if request_origin in self.allowed_origins_exact:
261             return True
262         try:
263             parsed_origin = urlparse(request_origin)
264         except ValueError:
265             return False
266         request_scheme = parsed_origin.scheme
267         request_netloc = parsed_origin.netloc
268         return any(
269             is_same_domain(request_netloc, host)
270             for host in self.allowed_origin_subdomains.get(request_scheme, ())
271         )
272 
273     def _check_referer(self, request):
274         referer = request.META.get('HTTP_REFERER')
275         if referer is None:
276             raise RejectRequest(REASON_NO_REFERER)
277 
278         try:
279             referer = urlparse(referer)
280         except ValueError:
281             raise RejectRequest(REASON_MALFORMED_REFERER)
282 
283         # Make sure we have a valid URL for Referer.
284         if '' in (referer.scheme, referer.netloc):
285             raise RejectRequest(REASON_MALFORMED_REFERER)
286 
287         # Ensure that our Referer is also secure.
288         if referer.scheme != 'https':
289             raise RejectRequest(REASON_INSECURE_REFERER)
290 
291         if any(
292             is_same_domain(referer.netloc, host)
293             for host in self.csrf_trusted_origins_hosts
294         ):
295             return
296         # Allow matching the configured cookie domain.
297         good_referer = (
298             settings.SESSION_COOKIE_DOMAIN
299             if settings.CSRF_USE_SESSIONS
300             else settings.CSRF_COOKIE_DOMAIN
301         )
302         if good_referer is None:
303             # If no cookie domain is configured, allow matching the current
304             # host:port exactly if it's permitted by ALLOWED_HOSTS.
305             try:
306                 # request.get_host() includes the port.
307                 good_referer = request.get_host()
308             except DisallowedHost:
309                 raise RejectRequest(REASON_BAD_REFERER % referer.geturl())
310         else:
311             server_port = request.get_port()
312             if server_port not in ('443', '80'):
313                 good_referer = '%s:%s' % (good_referer, server_port)
314 
315         if not is_same_domain(referer.netloc, good_referer):
316             raise RejectRequest(REASON_BAD_REFERER % referer.geturl())
317 
318     def _bad_token_message(self, reason, token_source):
319         if token_source != 'POST':
320             # Assume it is a settings.CSRF_HEADER_NAME value.
321             header_name = HttpHeaders.parse_header_name(token_source)
322             token_source = f'the {header_name!r} HTTP header'
323         return f'CSRF token from {token_source} {reason}.'
324 
325     def _check_token(self, request):
326         # Access csrf_token via self._get_token() as rotate_token() may have
327         # been called by an authentication middleware during the
328         # process_request() phase.
329         try:
330             csrf_token = self._get_token(request)
331         except InvalidTokenFormat as exc:
332             raise RejectRequest(f'CSRF cookie {exc.reason}.')
333 
334         if csrf_token is None:
335             # No CSRF cookie. For POST requests, we insist on a CSRF cookie,
336             # and in this way we can avoid all CSRF attacks, including login
337             # CSRF.
338             raise RejectRequest(REASON_NO_CSRF_COOKIE)
339 
340         # Check non-cookie token for match.
341         request_csrf_token = ''
342         if request.method == 'POST':
343             try:
344                 request_csrf_token = request.POST.get('csrfmiddlewaretoken', '')
345             except OSError:
346                 # Handle a broken connection before we've completed reading the
347                 # POST data. process_view shouldn't raise any exceptions, so
348                 # we'll ignore and serve the user a 403 (assuming they're still
349                 # listening, which they probably aren't because of the error).
350                 pass
351 
352         if request_csrf_token == '':
353             # Fall back to X-CSRFToken, to make things easier for AJAX, and
354             # possible for PUT/DELETE.
355             try:
356                 request_csrf_token = request.META[settings.CSRF_HEADER_NAME]
357             except KeyError:
358                 raise RejectRequest(REASON_CSRF_TOKEN_MISSING)
359             token_source = settings.CSRF_HEADER_NAME
360         else:
361             token_source = 'POST'
362 
363         try:
364             request_csrf_token = _sanitize_token(request_csrf_token)
365         except InvalidTokenFormat as exc:
366             reason = self._bad_token_message(exc.reason, token_source)
367             raise RejectRequest(reason)
368 
369         if not _compare_masked_tokens(request_csrf_token, csrf_token):
370             reason = self._bad_token_message('incorrect', token_source)
371             raise RejectRequest(reason)
372 
373     def process_request(self, request):
374         try:
375             csrf_token = self._get_token(request)
376         except InvalidTokenFormat:
377             csrf_token = _get_new_csrf_token()
378             request.csrf_cookie_needs_reset = True
379 
380         if csrf_token is not None:
381             # Use same token next time.
382             request.META['CSRF_COOKIE'] = csrf_token
383 
384     def process_view(self, request, callback, callback_args, callback_kwargs):
385         if getattr(request, 'csrf_processing_done', False):
386             return None
387 
388         # Wait until request.META["CSRF_COOKIE"] has been manipulated before
389         # bailing out, so that get_token still works
390         if getattr(callback, 'csrf_exempt', False):
391             return None
392 
393         # Assume that anything not defined as 'safe' by RFC7231 needs protection
394         if request.method in ('GET', 'HEAD', 'OPTIONS', 'TRACE'):
395             return self._accept(request)
396 
397         if getattr(request, '_dont_enforce_csrf_checks', False):
398             # Mechanism to turn off CSRF checks for test suite. It comes after
399             # the creation of CSRF cookies, so that everything else continues
400             # to work exactly the same (e.g. cookies are sent, etc.), but
401             # before any branches that call the _reject method.
402             return self._accept(request)
403 
404         # Reject the request if the Origin header doesn't match an allowed
405         # value.
406         if 'HTTP_ORIGIN' in request.META:
407             if not self._origin_verified(request):
408                 return self._reject(request, REASON_BAD_ORIGIN % request.META['HTTP_ORIGIN'])
409         elif request.is_secure():
410             # If the Origin header wasn't provided, reject HTTPS requests if
411             # the Referer header doesn't match an allowed value.
412             #
413             # Suppose user visits http://example.com/
414             # An active network attacker (man-in-the-middle, MITM) sends a
415             # POST form that targets https://example.com/detonate-bomb/ and
416             # submits it via JavaScript.
417             #
418             # The attacker will need to provide a CSRF cookie and token, but
419             # that's no problem for a MITM and the session-independent secret
420             # we're using. So the MITM can circumvent the CSRF protection. This
421             # is true for any HTTP connection, but anyone using HTTPS expects
422             # better! For this reason, for https://example.com/ we need
423             # additional protection that treats http://example.com/ as
424             # completely untrusted. Under HTTPS, Barth et al. found that the
425             # Referer header is missing for same-domain requests in only about
426             # 0.2% of cases or less, so we can use strict Referer checking.
427             try:
428                 self._check_referer(request)
429             except RejectRequest as exc:
430                 return self._reject(request, exc.reason)
431 
432         try:
433             self._check_token(request)
434         except RejectRequest as exc:
435             return self._reject(request, exc.reason)
436 
437         return self._accept(request)
438 
439     def process_response(self, request, response):
440         # Send the CSRF cookie whenever the cookie is being used (even if the
441         # client already has it) in order to renew the expiry timer, but only
442         # if it hasn't already been sent during this request-response cycle.
443         # Also, send the cookie no matter what if a reset was requested.
444         if (
445             getattr(request, 'csrf_cookie_needs_reset', False) or (
446                 request.META.get('CSRF_COOKIE_USED') and
447                 not getattr(response, 'csrf_cookie_set', False)
448             )
449         ):
450             self._set_token(request, response)
451             # Update state to prevent _set_token() from being unnecessarily
452             # called again in process_response() by other instances of
453             # CsrfViewMiddleware. This can happen e.g. when both a decorator
454             # and middleware are used. However, the csrf_cookie_needs_reset
455             # attribute is still respected in subsequent calls e.g. in case
456             # rotate_token() is called in process_response() later by custom
457             # middleware but before those subsequent calls.
458             response.csrf_cookie_set = True
459             request.csrf_cookie_needs_reset = False
460 
461         return response

</code><intended_behavior>Modify the CSRF middleware to better handle exceptions that aren't directly related to CSRF token mismatches or absences, particularly those arising from filesystem interactions during file uploads. Ensure that CSRF verification failures are reported correctly as such, and other exceptions or errors (like those related to file storage or directory permissions) are not mistakenly reported as CSRF errors. This might involve adjusting error handling or exception catching in the middleware to discriminate between different types of errors more effectively.</intended_behavior>]
2025-10-18 13:01:13.731 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-18 13:01:13.731 | INFO     | Search-only: skipping patch selection
2025-10-18 13:01:13.885 | INFO     | Task django__django-14681 completed successfully.
2025-10-18 13:01:13.885 | INFO     | No patch generated. You can try running ACR again.
