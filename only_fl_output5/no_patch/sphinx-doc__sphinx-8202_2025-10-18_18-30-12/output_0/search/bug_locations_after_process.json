[
    {
        "rel_file_path": "sphinx/ext/napoleon/docstring.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sphinx-doc__sphinx/setup_sphinx-doc__sphinx__3.3/sphinx/ext/napoleon/docstring.py",
        "start": 1,
        "end": 1264,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\"\n2     sphinx.ext.napoleon.docstring\n3     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n4 \n5 \n6     Classes for docstring parsing and formatting.\n7 \n8 \n9     :copyright: Copyright 2007-2020 by the Sphinx team, see AUTHORS.\n10     :license: BSD, see LICENSE for details.\n11 \"\"\"\n12 \n13 import collections\n14 import inspect\n15 import re\n16 from functools import partial\n17 from typing import Any, Callable, Dict, List, Tuple, Union\n18 \n19 from sphinx.application import Sphinx\n20 from sphinx.config import Config as SphinxConfig\n21 from sphinx.ext.napoleon.iterators import modify_iter\n22 from sphinx.locale import _, __\n23 from sphinx.util import logging\n24 \n25 if False:\n26     # For type annotation\n27     from typing import Type  # for python3.5.1\n28 \n29 \n30 logger = logging.getLogger(__name__)\n31 \n32 _directive_regex = re.compile(r'\\.\\. \\S+::')\n33 _google_section_regex = re.compile(r'^(\\s|\\w)+:\\s*$')\n34 _google_typed_arg_regex = re.compile(r'\\s*(.+?)\\s*\\(\\s*(.*[^\\s]+)\\s*\\)')\n35 _numpy_section_regex = re.compile(r'^[=\\-`:\\'\"~^_*+#<>]{2,}\\s*$')\n36 _single_colon_regex = re.compile(r'(?<!:):(?!:)')\n37 _xref_or_code_regex = re.compile(\n38     r'((?::(?:[a-zA-Z0-9]+[\\-_+:.])*[a-zA-Z0-9]+:`.+?`)|'\n39     r'(?:``.+?``))')\n40 _xref_regex = re.compile(\n41     r'(?:(?::(?:[a-zA-Z0-9]+[\\-_+:.])*[a-zA-Z0-9]+:)?`.+?`)'\n42 )\n43 _bullet_list_regex = re.compile(r'^(\\*|\\+|\\-)(\\s+\\S|\\s*$)')\n44 _enumerated_list_regex = re.compile(\n45     r'^(?P<paren>\\()?'\n46     r'(\\d+|#|[ivxlcdm]+|[IVXLCDM]+|[a-zA-Z])'\n47     r'(?(paren)\\)|\\.)(\\s+\\S|\\s*$)')\n48 _token_regex = re.compile(\n49     r\"(,\\sor\\s|\\sor\\s|\\sof\\s|:\\s|\\sto\\s|,\\sand\\s|\\sand\\s|,\\s\"\n50     r\"|[{]|[}]\"\n51     r'|\"(?:\\\\\"|[^\"])*\"'\n52     r\"|'(?:\\\\'|[^'])*')\"\n53 )\n54 _default_regex = re.compile(\n55     r\"^default[^_0-9A-Za-z].*$\",\n56 )\n57 _SINGLETONS = (\"None\", \"True\", \"False\", \"Ellipsis\")\n58 \n59 \n60 class GoogleDocstring:\n61     \"\"\"Convert Google style docstrings to reStructuredText.\n62 \n63     Parameters\n64     ----------\n65     docstring : :obj:`str` or :obj:`list` of :obj:`str`\n66         The docstring to parse, given either as a string or split into\n67         individual lines.\n68     config: :obj:`sphinx.ext.napoleon.Config` or :obj:`sphinx.config.Config`\n69         The configuration settings to use. If not given, defaults to the\n70         config object on `app`; or if `app` is not given defaults to the\n71         a new :class:`sphinx.ext.napoleon.Config` object.\n72 \n73 \n74     Other Parameters\n75     ----------------\n76     app : :class:`sphinx.application.Sphinx`, optional\n77         Application object representing the Sphinx process.\n78     what : :obj:`str`, optional\n79         A string specifying the type of the object to which the docstring\n80         belongs. Valid values: \"module\", \"class\", \"exception\", \"function\",\n81         \"method\", \"attribute\".\n82     name : :obj:`str`, optional\n83         The fully qualified name of the object.\n84     obj : module, class, exception, function, method, or attribute\n85         The object to which the docstring belongs.\n86     options : :class:`sphinx.ext.autodoc.Options`, optional\n87         The options given to the directive: an object with attributes\n88         inherited_members, undoc_members, show_inheritance and noindex that\n89         are True if the flag option of same name was given to the auto\n90         directive.\n91 \n92 \n93     Example\n94     -------\n95     >>> from sphinx.ext.napoleon import Config\n96     >>> config = Config(napoleon_use_param=True, napoleon_use_rtype=True)\n97     >>> docstring = '''One line summary.\n98     ...\n99     ... Extended description.\n100     ...\n101     ... Args:\n102     ...   arg1(int): Description of `arg1`\n103     ...   arg2(str): Description of `arg2`\n104     ... Returns:\n105     ...   str: Description of return value.\n106     ... '''\n107     >>> print(GoogleDocstring(docstring, config))\n108     One line summary.\n109     <BLANKLINE>\n110     Extended description.\n111     <BLANKLINE>\n112     :param arg1: Description of `arg1`\n113     :type arg1: int\n114     :param arg2: Description of `arg2`\n115     :type arg2: str\n116     <BLANKLINE>\n117     :returns: Description of return value.\n118     :rtype: str\n119     <BLANKLINE>\n120 \n121     \"\"\"\n122 \n123     _name_rgx = re.compile(r\"^\\s*((?::(?P<role>\\S+):)?`(?P<name>~?[a-zA-Z0-9_.-]+)`|\"\n124                            r\" (?P<name2>~?[a-zA-Z0-9_.-]+))\\s*\", re.X)\n125 \n126     def __init__(self, docstring: Union[str, List[str]], config: SphinxConfig = None,\n127                  app: Sphinx = None, what: str = '', name: str = '',\n128                  obj: Any = None, options: Any = None) -> None:\n129         self._config = config\n130         self._app = app\n131 \n132         if not self._config:\n133             from sphinx.ext.napoleon import Config\n134             self._config = self._app.config if self._app else Config()  # type: ignore\n135 \n136         if not what:\n137             if inspect.isclass(obj):\n138                 what = 'class'\n139             elif inspect.ismodule(obj):\n140                 what = 'module'\n141             elif callable(obj):\n142                 what = 'function'\n143             else:\n144                 what = 'object'\n145 \n146         self._what = what\n147         self._name = name\n148         self._obj = obj\n149         self._opt = options\n150         if isinstance(docstring, str):\n151             lines = docstring.splitlines()\n152         else:\n153             lines = docstring\n154         self._line_iter = modify_iter(lines, modifier=lambda s: s.rstrip())\n155         self._parsed_lines = []  # type: List[str]\n156         self._is_in_section = False\n157         self._section_indent = 0\n158         if not hasattr(self, '_directive_sections'):\n159             self._directive_sections = []  # type: List[str]\n160         if not hasattr(self, '_sections'):\n161             self._sections = {\n162                 'args': self._parse_parameters_section,\n163                 'arguments': self._parse_parameters_section,\n164                 'attention': partial(self._parse_admonition, 'attention'),\n165                 'attributes': self._parse_attributes_section,\n166                 'caution': partial(self._parse_admonition, 'caution'),\n167                 'danger': partial(self._parse_admonition, 'danger'),\n168                 'error': partial(self._parse_admonition, 'error'),\n169                 'example': self._parse_examples_section,\n170                 'examples': self._parse_examples_section,\n171                 'hint': partial(self._parse_admonition, 'hint'),\n172                 'important': partial(self._parse_admonition, 'important'),\n173                 'keyword args': self._parse_keyword_arguments_section,\n174                 'keyword arguments': self._parse_keyword_arguments_section,\n175                 'methods': self._parse_methods_section,\n176                 'note': partial(self._parse_admonition, 'note'),\n177                 'notes': self._parse_notes_section,\n178                 'other parameters': self._parse_other_parameters_section,\n179                 'parameters': self._parse_parameters_section,\n180                 'return': self._parse_returns_section,\n181                 'returns': self._parse_returns_section,\n182                 'raise': self._parse_raises_section,\n183                 'raises': self._parse_raises_section,\n184                 'references': self._parse_references_section,\n185                 'see also': self._parse_see_also_section,\n186                 'tip': partial(self._parse_admonition, 'tip'),\n187                 'todo': partial(self._parse_admonition, 'todo'),\n188                 'warning': partial(self._parse_admonition, 'warning'),\n189                 'warnings': partial(self._parse_admonition, 'warning'),\n190                 'warn': self._parse_warns_section,\n191                 'warns': self._parse_warns_section,\n192                 'yield': self._parse_yields_section,\n193                 'yields': self._parse_yields_section,\n194             }  # type: Dict[str, Callable]\n195 \n196         self._load_custom_sections()\n197 \n198         self._parse()\n199 \n200     def __str__(self) -> str:\n201         \"\"\"Return the parsed docstring in reStructuredText format.\n202 \n203         Returns\n204         -------\n205         unicode\n206             Unicode version of the docstring.\n207 \n208         \"\"\"\n209         return '\\n'.join(self.lines())\n210 \n211     def lines(self) -> List[str]:\n212         \"\"\"Return the parsed lines of the docstring in reStructuredText format.\n213 \n214         Returns\n215         -------\n216         list(str)\n217             The lines of the docstring in a list.\n218 \n219         \"\"\"\n220         return self._parsed_lines\n221 \n222     def _consume_indented_block(self, indent: int = 1) -> List[str]:\n223         lines = []\n224         line = self._line_iter.peek()\n225         while(not self._is_section_break() and\n226               (not line or self._is_indented(line, indent))):\n227             lines.append(next(self._line_iter))\n228             line = self._line_iter.peek()\n229         return lines\n230 \n231     def _consume_contiguous(self) -> List[str]:\n232         lines = []\n233         while (self._line_iter.has_next() and\n234                self._line_iter.peek() and\n235                not self._is_section_header()):\n236             lines.append(next(self._line_iter))\n237         return lines\n238 \n239     def _consume_empty(self) -> List[str]:\n240         lines = []\n241         line = self._line_iter.peek()\n242         while self._line_iter.has_next() and not line:\n243             lines.append(next(self._line_iter))\n244             line = self._line_iter.peek()\n245         return lines\n246 \n247     def _consume_field(self, parse_type: bool = True, prefer_type: bool = False\n248                        ) -> Tuple[str, str, List[str]]:\n249         line = next(self._line_iter)\n250 \n251         before, colon, after = self._partition_field_on_colon(line)\n252         _name, _type, _desc = before, '', after\n253 \n254         if parse_type:\n255             match = _google_typed_arg_regex.match(before)\n256             if match:\n257                 _name = match.group(1)\n258                 _type = match.group(2)\n259 \n260         _name = self._escape_args_and_kwargs(_name)\n261 \n262         if prefer_type and not _type:\n263             _type, _name = _name, _type\n264         indent = self._get_indent(line) + 1\n265         _descs = [_desc] + self._dedent(self._consume_indented_block(indent))\n266         _descs = self.__class__(_descs, self._config).lines()\n267         return _name, _type, _descs\n268 \n269     def _consume_fields(self, parse_type: bool = True, prefer_type: bool = False,\n270                         multiple: bool = False) -> List[Tuple[str, str, List[str]]]:\n271         self._consume_empty()\n272         fields = []\n273         while not self._is_section_break():\n274             _name, _type, _desc = self._consume_field(parse_type, prefer_type)\n275             if multiple and _name:\n276                 for name in _name.split(\",\"):\n277                     fields.append((name.strip(), _type, _desc))\n278             elif _name or _type or _desc:\n279                 fields.append((_name, _type, _desc,))\n280         return fields\n281 \n282     def _consume_inline_attribute(self) -> Tuple[str, List[str]]:\n283         line = next(self._line_iter)\n284         _type, colon, _desc = self._partition_field_on_colon(line)\n285         if not colon or not _desc:\n286             _type, _desc = _desc, _type\n287             _desc += colon\n288         _descs = [_desc] + self._dedent(self._consume_to_end())\n289         _descs = self.__class__(_descs, self._config).lines()\n290         return _type, _descs\n291 \n292     def _consume_returns_section(self) -> List[Tuple[str, str, List[str]]]:\n293         lines = self._dedent(self._consume_to_next_section())\n294         if lines:\n295             before, colon, after = self._partition_field_on_colon(lines[0])\n296             _name, _type, _desc = '', '', lines\n297 \n298             if colon:\n299                 if after:\n300                     _desc = [after] + lines[1:]\n301                 else:\n302                     _desc = lines[1:]\n303 \n304                 _type = before\n305 \n306             _desc = self.__class__(_desc, self._config).lines()\n307             return [(_name, _type, _desc,)]\n308         else:\n309             return []\n310 \n311     def _consume_usage_section(self) -> List[str]:\n312         lines = self._dedent(self._consume_to_next_section())\n313         return lines\n314 \n315     def _consume_section_header(self) -> str:\n316         section = next(self._line_iter)\n317         stripped_section = section.strip(':')\n318         if stripped_section.lower() in self._sections:\n319             section = stripped_section\n320         return section\n321 \n322     def _consume_to_end(self) -> List[str]:\n323         lines = []\n324         while self._line_iter.has_next():\n325             lines.append(next(self._line_iter))\n326         return lines\n327 \n328     def _consume_to_next_section(self) -> List[str]:\n329         self._consume_empty()\n330         lines = []\n331         while not self._is_section_break():\n332             lines.append(next(self._line_iter))\n333         return lines + self._consume_empty()\n334 \n335     def _dedent(self, lines: List[str], full: bool = False) -> List[str]:\n336         if full:\n337             return [line.lstrip() for line in lines]\n338         else:\n339             min_indent = self._get_min_indent(lines)\n340             return [line[min_indent:] for line in lines]\n341 \n342     def _escape_args_and_kwargs(self, name: str) -> str:\n343         if name.endswith('_') and getattr(self._config, 'strip_signature_backslash', False):\n344             name = name[:-1] + r'\\_'\n345 \n346         if name[:2] == '**':\n347             return r'\\*\\*' + name[2:]\n348         elif name[:1] == '*':\n349             return r'\\*' + name[1:]\n350         else:\n351             return name\n352 \n353     def _fix_field_desc(self, desc: List[str]) -> List[str]:\n354         if self._is_list(desc):\n355             desc = [''] + desc\n356         elif desc[0].endswith('::'):\n357             desc_block = desc[1:]\n358             indent = self._get_indent(desc[0])\n359             block_indent = self._get_initial_indent(desc_block)\n360             if block_indent > indent:\n361                 desc = [''] + desc\n362             else:\n363                 desc = ['', desc[0]] + self._indent(desc_block, 4)\n364         return desc\n365 \n366     def _format_admonition(self, admonition: str, lines: List[str]) -> List[str]:\n367         lines = self._strip_empty(lines)\n368         if len(lines) == 1:\n369             return ['.. %s:: %s' % (admonition, lines[0].strip()), '']\n370         elif lines:\n371             lines = self._indent(self._dedent(lines), 3)\n372             return ['.. %s::' % admonition, ''] + lines + ['']\n373         else:\n374             return ['.. %s::' % admonition, '']\n375 \n376     def _format_block(self, prefix: str, lines: List[str], padding: str = None) -> List[str]:\n377         if lines:\n378             if padding is None:\n379                 padding = ' ' * len(prefix)\n380             result_lines = []\n381             for i, line in enumerate(lines):\n382                 if i == 0:\n383                     result_lines.append((prefix + line).rstrip())\n384                 elif line:\n385                     result_lines.append(padding + line)\n386                 else:\n387                     result_lines.append('')\n388             return result_lines\n389         else:\n390             return [prefix]\n391 \n392     def _format_docutils_params(self, fields: List[Tuple[str, str, List[str]]],\n393                                 field_role: str = 'param', type_role: str = 'type'\n394                                 ) -> List[str]:\n395         lines = []\n396         for _name, _type, _desc in fields:\n397             _desc = self._strip_empty(_desc)\n398             if any(_desc):\n399                 _desc = self._fix_field_desc(_desc)\n400                 field = ':%s %s: ' % (field_role, _name)\n401                 lines.extend(self._format_block(field, _desc))\n402             else:\n403                 lines.append(':%s %s:' % (field_role, _name))\n404 \n405             if _type:\n406                 lines.append(':%s %s: %s' % (type_role, _name, _type))\n407         return lines + ['']\n408 \n409     def _format_field(self, _name: str, _type: str, _desc: List[str]) -> List[str]:\n410         _desc = self._strip_empty(_desc)\n411         has_desc = any(_desc)\n412         separator = ' -- ' if has_desc else ''\n413         if _name:\n414             if _type:\n415                 if '`' in _type:\n416                     field = '**%s** (%s)%s' % (_name, _type, separator)\n417                 else:\n418                     field = '**%s** (*%s*)%s' % (_name, _type, separator)\n419             else:\n420                 field = '**%s**%s' % (_name, separator)\n421         elif _type:\n422             if '`' in _type:\n423                 field = '%s%s' % (_type, separator)\n424             else:\n425                 field = '*%s*%s' % (_type, separator)\n426         else:\n427             field = ''\n428 \n429         if has_desc:\n430             _desc = self._fix_field_desc(_desc)\n431             if _desc[0]:\n432                 return [field + _desc[0]] + _desc[1:]\n433             else:\n434                 return [field] + _desc\n435         else:\n436             return [field]\n437 \n438     def _format_fields(self, field_type: str, fields: List[Tuple[str, str, List[str]]]\n439                        ) -> List[str]:\n440         field_type = ':%s:' % field_type.strip()\n441         padding = ' ' * len(field_type)\n442         multi = len(fields) > 1\n443         lines = []  # type: List[str]\n444         for _name, _type, _desc in fields:\n445             field = self._format_field(_name, _type, _desc)\n446             if multi:\n447                 if lines:\n448                     lines.extend(self._format_block(padding + ' * ', field))\n449                 else:\n450                     lines.extend(self._format_block(field_type + ' * ', field))\n451             else:\n452                 lines.extend(self._format_block(field_type + ' ', field))\n453         if lines and lines[-1]:\n454             lines.append('')\n455         return lines\n456 \n457     def _get_current_indent(self, peek_ahead: int = 0) -> int:\n458         line = self._line_iter.peek(peek_ahead + 1)[peek_ahead]\n459         while line != self._line_iter.sentinel:\n460             if line:\n461                 return self._get_indent(line)\n462             peek_ahead += 1\n463             line = self._line_iter.peek(peek_ahead + 1)[peek_ahead]\n464         return 0\n465 \n466     def _get_indent(self, line: str) -> int:\n467         for i, s in enumerate(line):\n468             if not s.isspace():\n469                 return i\n470         return len(line)\n471 \n472     def _get_initial_indent(self, lines: List[str]) -> int:\n473         for line in lines:\n474             if line:\n475                 return self._get_indent(line)\n476         return 0\n477 \n478     def _get_min_indent(self, lines: List[str]) -> int:\n479         min_indent = None\n480         for line in lines:\n481             if line:\n482                 indent = self._get_indent(line)\n483                 if min_indent is None:\n484                     min_indent = indent\n485                 elif indent < min_indent:\n486                     min_indent = indent\n487         return min_indent or 0\n488 \n489     def _indent(self, lines: List[str], n: int = 4) -> List[str]:\n490         return [(' ' * n) + line for line in lines]\n491 \n492     def _is_indented(self, line: str, indent: int = 1) -> bool:\n493         for i, s in enumerate(line):\n494             if i >= indent:\n495                 return True\n496             elif not s.isspace():\n497                 return False\n498         return False\n499 \n500     def _is_list(self, lines: List[str]) -> bool:\n501         if not lines:\n502             return False\n503         if _bullet_list_regex.match(lines[0]):\n504             return True\n505         if _enumerated_list_regex.match(lines[0]):\n506             return True\n507         if len(lines) < 2 or lines[0].endswith('::'):\n508             return False\n509         indent = self._get_indent(lines[0])\n510         next_indent = indent\n511         for line in lines[1:]:\n512             if line:\n513                 next_indent = self._get_indent(line)\n514                 break\n515         return next_indent > indent\n516 \n517     def _is_section_header(self) -> bool:\n518         section = self._line_iter.peek().lower()\n519         match = _google_section_regex.match(section)\n520         if match and section.strip(':') in self._sections:\n521             header_indent = self._get_indent(section)\n522             section_indent = self._get_current_indent(peek_ahead=1)\n523             return section_indent > header_indent\n524         elif self._directive_sections:\n525             if _directive_regex.match(section):\n526                 for directive_section in self._directive_sections:\n527                     if section.startswith(directive_section):\n528                         return True\n529         return False\n530 \n531     def _is_section_break(self) -> bool:\n532         line = self._line_iter.peek()\n533         return (not self._line_iter.has_next() or\n534                 self._is_section_header() or\n535                 (self._is_in_section and\n536                     line and\n537                     not self._is_indented(line, self._section_indent)))\n538 \n539     def _load_custom_sections(self) -> None:\n540         if self._config.napoleon_custom_sections is not None:\n541             for entry in self._config.napoleon_custom_sections:\n542                 if isinstance(entry, str):\n543                     # if entry is just a label, add to sections list,\n544                     # using generic section logic.\n545                     self._sections[entry.lower()] = self._parse_custom_generic_section\n546                 else:\n547                     # otherwise, assume entry is container;\n548                     # [0] is new section, [1] is the section to alias.\n549                     # in the case of key mismatch, just handle as generic section.\n550                     self._sections[entry[0].lower()] = \\\n551                         self._sections.get(entry[1].lower(),\n552                                            self._parse_custom_generic_section)\n553 \n554     def _parse(self) -> None:\n555         self._parsed_lines = self._consume_empty()\n556 \n557         if self._name and self._what in ('attribute', 'data', 'property'):\n558             # Implicit stop using StopIteration no longer allowed in\n559             # Python 3.7; see PEP 479\n560             res = []  # type: List[str]\n561             try:\n562                 res = self._parse_attribute_docstring()\n563             except StopIteration:\n564                 pass\n565             self._parsed_lines.extend(res)\n566             return\n567 \n568         while self._line_iter.has_next():\n569             if self._is_section_header():\n570                 try:\n571                     section = self._consume_section_header()\n572                     self._is_in_section = True\n573                     self._section_indent = self._get_current_indent()\n574                     if _directive_regex.match(section):\n575                         lines = [section] + self._consume_to_next_section()\n576                     else:\n577                         lines = self._sections[section.lower()](section)\n578                 finally:\n579                     self._is_in_section = False\n580                     self._section_indent = 0\n581             else:\n582                 if not self._parsed_lines:\n583                     lines = self._consume_contiguous() + self._consume_empty()\n584                 else:\n585                     lines = self._consume_to_next_section()\n586             self._parsed_lines.extend(lines)\n587 \n588     def _parse_admonition(self, admonition: str, section: str) -> List[str]:\n589         # type (str, str) -> List[str]\n590         lines = self._consume_to_next_section()\n591         return self._format_admonition(admonition, lines)\n592 \n593     def _parse_attribute_docstring(self) -> List[str]:\n594         _type, _desc = self._consume_inline_attribute()\n595         lines = self._format_field('', '', _desc)\n596         if _type:\n597             lines.extend(['', ':type: %s' % _type])\n598         return lines\n599 \n600     def _parse_attributes_section(self, section: str) -> List[str]:\n601         lines = []\n602         for _name, _type, _desc in self._consume_fields():\n603             if self._config.napoleon_use_ivar:\n604                 _name = self._qualify_name(_name, self._obj)\n605                 field = ':ivar %s: ' % _name\n606                 lines.extend(self._format_block(field, _desc))\n607                 if _type:\n608                     lines.append(':vartype %s: %s' % (_name, _type))\n609             else:\n610                 lines.append('.. attribute:: ' + _name)\n611                 if self._opt and 'noindex' in self._opt:\n612                     lines.append('   :noindex:')\n613                 lines.append('')\n614 \n615                 fields = self._format_field('', '', _desc)\n616                 lines.extend(self._indent(fields, 3))\n617                 if _type:\n618                     lines.append('')\n619                     lines.extend(self._indent([':type: %s' % _type], 3))\n620                 lines.append('')\n621         if self._config.napoleon_use_ivar:\n622             lines.append('')\n623         return lines\n624 \n625     def _parse_examples_section(self, section: str) -> List[str]:\n626         labels = {\n627             'example': _('Example'),\n628             'examples': _('Examples'),\n629         }\n630         use_admonition = self._config.napoleon_use_admonition_for_examples\n631         label = labels.get(section.lower(), section)\n632         return self._parse_generic_section(label, use_admonition)\n633 \n634     def _parse_custom_generic_section(self, section: str) -> List[str]:\n635         # for now, no admonition for simple custom sections\n636         return self._parse_generic_section(section, False)\n637 \n638     def _parse_usage_section(self, section: str) -> List[str]:\n639         header = ['.. rubric:: Usage:', '']\n640         block = ['.. code-block:: python', '']\n641         lines = self._consume_usage_section()\n642         lines = self._indent(lines, 3)\n643         return header + block + lines + ['']\n644 \n645     def _parse_generic_section(self, section: str, use_admonition: bool) -> List[str]:\n646         lines = self._strip_empty(self._consume_to_next_section())\n647         lines = self._dedent(lines)\n648         if use_admonition:\n649             header = '.. admonition:: %s' % section\n650             lines = self._indent(lines, 3)\n651         else:\n652             header = '.. rubric:: %s' % section\n653         if lines:\n654             return [header, ''] + lines + ['']\n655         else:\n656             return [header, '']\n657 \n658     def _parse_keyword_arguments_section(self, section: str) -> List[str]:\n659         fields = self._consume_fields()\n660         if self._config.napoleon_use_keyword:\n661             return self._format_docutils_params(\n662                 fields,\n663                 field_role=\"keyword\",\n664                 type_role=\"kwtype\")\n665         else:\n666             return self._format_fields(_('Keyword Arguments'), fields)\n667 \n668     def _parse_methods_section(self, section: str) -> List[str]:\n669         lines = []  # type: List[str]\n670         for _name, _type, _desc in self._consume_fields(parse_type=False):\n671             lines.append('.. method:: %s' % _name)\n672             if self._opt and 'noindex' in self._opt:\n673                 lines.append('   :noindex:')\n674             if _desc:\n675                 lines.extend([''] + self._indent(_desc, 3))\n676             lines.append('')\n677         return lines\n678 \n679     def _parse_notes_section(self, section: str) -> List[str]:\n680         use_admonition = self._config.napoleon_use_admonition_for_notes\n681         return self._parse_generic_section(_('Notes'), use_admonition)\n682 \n683     def _parse_other_parameters_section(self, section: str) -> List[str]:\n684         return self._format_fields(_('Other Parameters'), self._consume_fields())\n685 \n686     def _parse_parameters_section(self, section: str) -> List[str]:\n687         if self._config.napoleon_use_param:\n688             # Allow to declare multiple parameters at once (ex: x, y: int)\n689             fields = self._consume_fields(multiple=True)\n690             return self._format_docutils_params(fields)\n691         else:\n692             fields = self._consume_fields()\n693             return self._format_fields(_('Parameters'), fields)\n694 \n695     def _parse_raises_section(self, section: str) -> List[str]:\n696         fields = self._consume_fields(parse_type=False, prefer_type=True)\n697         lines = []  # type: List[str]\n698         for _name, _type, _desc in fields:\n699             m = self._name_rgx.match(_type)\n700             if m and m.group('name'):\n701                 _type = m.group('name')\n702             _type = ' ' + _type if _type else ''\n703             _desc = self._strip_empty(_desc)\n704             _descs = ' ' + '\\n    '.join(_desc) if any(_desc) else ''\n705             lines.append(':raises%s:%s' % (_type, _descs))\n706         if lines:\n707             lines.append('')\n708         return lines\n709 \n710     def _parse_references_section(self, section: str) -> List[str]:\n711         use_admonition = self._config.napoleon_use_admonition_for_references\n712         return self._parse_generic_section(_('References'), use_admonition)\n713 \n714     def _parse_returns_section(self, section: str) -> List[str]:\n715         fields = self._consume_returns_section()\n716         multi = len(fields) > 1\n717         if multi:\n718             use_rtype = False\n719         else:\n720             use_rtype = self._config.napoleon_use_rtype\n721 \n722         lines = []  # type: List[str]\n723         for _name, _type, _desc in fields:\n724             if use_rtype:\n725                 field = self._format_field(_name, '', _desc)\n726             else:\n727                 field = self._format_field(_name, _type, _desc)\n728 \n729             if multi:\n730                 if lines:\n731                     lines.extend(self._format_block('          * ', field))\n732                 else:\n733                     lines.extend(self._format_block(':returns: * ', field))\n734             else:\n735                 lines.extend(self._format_block(':returns: ', field))\n736                 if _type and use_rtype:\n737                     lines.extend([':rtype: %s' % _type, ''])\n738         if lines and lines[-1]:\n739             lines.append('')\n740         return lines\n741 \n742     def _parse_see_also_section(self, section: str) -> List[str]:\n743         return self._parse_admonition('seealso', section)\n744 \n745     def _parse_warns_section(self, section: str) -> List[str]:\n746         return self._format_fields(_('Warns'), self._consume_fields())\n747 \n748     def _parse_yields_section(self, section: str) -> List[str]:\n749         fields = self._consume_returns_section()\n750         return self._format_fields(_('Yields'), fields)\n751 \n752     def _partition_field_on_colon(self, line: str) -> Tuple[str, str, str]:\n753         before_colon = []\n754         after_colon = []\n755         colon = ''\n756         found_colon = False\n757         for i, source in enumerate(_xref_or_code_regex.split(line)):\n758             if found_colon:\n759                 after_colon.append(source)\n760             else:\n761                 m = _single_colon_regex.search(source)\n762                 if (i % 2) == 0 and m:\n763                     found_colon = True\n764                     colon = source[m.start(): m.end()]\n765                     before_colon.append(source[:m.start()])\n766                     after_colon.append(source[m.end():])\n767                 else:\n768                     before_colon.append(source)\n769 \n770         return (\"\".join(before_colon).strip(),\n771                 colon,\n772                 \"\".join(after_colon).strip())\n773 \n774     def _qualify_name(self, attr_name: str, klass: \"Type\") -> str:\n775         if klass and '.' not in attr_name:\n776             if attr_name.startswith('~'):\n777                 attr_name = attr_name[1:]\n778             try:\n779                 q = klass.__qualname__\n780             except AttributeError:\n781                 q = klass.__name__\n782             return '~%s.%s' % (q, attr_name)\n783         return attr_name\n784 \n785     def _strip_empty(self, lines: List[str]) -> List[str]:\n786         if lines:\n787             start = -1\n788             for i, line in enumerate(lines):\n789                 if line:\n790                     start = i\n791                     break\n792             if start == -1:\n793                 lines = []\n794             end = -1\n795             for i in reversed(range(len(lines))):\n796                 line = lines[i]\n797                 if line:\n798                     end = i\n799                     break\n800             if start > 0 or end + 1 < len(lines):\n801                 lines = lines[start:end + 1]\n802         return lines\n803 \n804 \n805 def _recombine_set_tokens(tokens: List[str]) -> List[str]:\n806     token_queue = collections.deque(tokens)\n807     keywords = (\"optional\", \"default\")\n808 \n809     def takewhile_set(tokens):\n810         open_braces = 0\n811         previous_token = None\n812         while True:\n813             try:\n814                 token = tokens.popleft()\n815             except IndexError:\n816                 break\n817 \n818             if token == \", \":\n819                 previous_token = token\n820                 continue\n821 \n822             if not token.strip():\n823                 continue\n824 \n825             if token in keywords:\n826                 tokens.appendleft(token)\n827                 if previous_token is not None:\n828                     tokens.appendleft(previous_token)\n829                 break\n830 \n831             if previous_token is not None:\n832                 yield previous_token\n833                 previous_token = None\n834 \n835             if token == \"{\":\n836                 open_braces += 1\n837             elif token == \"}\":\n838                 open_braces -= 1\n839 \n840             yield token\n841 \n842             if open_braces == 0:\n843                 break\n844 \n845     def combine_set(tokens):\n846         while True:\n847             try:\n848                 token = tokens.popleft()\n849             except IndexError:\n850                 break\n851 \n852             if token == \"{\":\n853                 tokens.appendleft(\"{\")\n854                 yield \"\".join(takewhile_set(tokens))\n855             else:\n856                 yield token\n857 \n858     return list(combine_set(token_queue))\n859 \n860 \n861 def _tokenize_type_spec(spec: str) -> List[str]:\n862     def postprocess(item):\n863         if _default_regex.match(item):\n864             default = item[:7]\n865             # can't be separated by anything other than a single space\n866             # for now\n867             other = item[8:]\n868 \n869             return [default, \" \", other]\n870         else:\n871             return [item]\n872 \n873     tokens = list(\n874         item\n875         for raw_token in _token_regex.split(spec)\n876         for item in postprocess(raw_token)\n877         if item\n878     )\n879     return tokens\n880 \n881 \n882 def _token_type(token: str, location: str = None) -> str:\n883     def is_numeric(token):\n884         try:\n885             # use complex to make sure every numeric value is detected as literal\n886             complex(token)\n887         except ValueError:\n888             return False\n889         else:\n890             return True\n891 \n892     if token.startswith(\" \") or token.endswith(\" \"):\n893         type_ = \"delimiter\"\n894     elif (\n895             is_numeric(token) or\n896             (token.startswith(\"{\") and token.endswith(\"}\")) or\n897             (token.startswith('\"') and token.endswith('\"')) or\n898             (token.startswith(\"'\") and token.endswith(\"'\"))\n899     ):\n900         type_ = \"literal\"\n901     elif token.startswith(\"{\"):\n902         logger.warning(\n903             __(\"invalid value set (missing closing brace): %s\"),\n904             token,\n905             location=location,\n906         )\n907         type_ = \"literal\"\n908     elif token.endswith(\"}\"):\n909         logger.warning(\n910             __(\"invalid value set (missing opening brace): %s\"),\n911             token,\n912             location=location,\n913         )\n914         type_ = \"literal\"\n915     elif token.startswith(\"'\") or token.startswith('\"'):\n916         logger.warning(\n917             __(\"malformed string literal (missing closing quote): %s\"),\n918             token,\n919             location=location,\n920         )\n921         type_ = \"literal\"\n922     elif token.endswith(\"'\") or token.endswith('\"'):\n923         logger.warning(\n924             __(\"malformed string literal (missing opening quote): %s\"),\n925             token,\n926             location=location,\n927         )\n928         type_ = \"literal\"\n929     elif token in (\"optional\", \"default\"):\n930         # default is not a official keyword (yet) but supported by the\n931         # reference implementation (numpydoc) and widely used\n932         type_ = \"control\"\n933     elif _xref_regex.match(token):\n934         type_ = \"reference\"\n935     else:\n936         type_ = \"obj\"\n937 \n938     return type_\n939 \n940 \n941 def _convert_numpy_type_spec(_type: str, location: str = None, translations: dict = {}) -> str:\n942     def convert_obj(obj, translations, default_translation):\n943         translation = translations.get(obj, obj)\n944 \n945         # use :class: (the default) only if obj is not a standard singleton\n946         if translation in _SINGLETONS and default_translation == \":class:`%s`\":\n947             default_translation = \":obj:`%s`\"\n948         elif translation == \"...\" and default_translation == \":class:`%s`\":\n949             # allow referencing the builtin ...\n950             default_translation = \":obj:`%s <Ellipsis>`\"\n951 \n952         if _xref_regex.match(translation) is None:\n953             translation = default_translation % translation\n954 \n955         return translation\n956 \n957     tokens = _tokenize_type_spec(_type)\n958     combined_tokens = _recombine_set_tokens(tokens)\n959     types = [\n960         (token, _token_type(token, location))\n961         for token in combined_tokens\n962     ]\n963 \n964     converters = {\n965         \"literal\": lambda x: \"``%s``\" % x,\n966         \"obj\": lambda x: convert_obj(x, translations, \":class:`%s`\"),\n967         \"control\": lambda x: \"*%s*\" % x,\n968         \"delimiter\": lambda x: x,\n969         \"reference\": lambda x: x,\n970     }\n971 \n972     converted = \"\".join(converters.get(type_)(token) for token, type_ in types)\n973 \n974     return converted\n975 \n976 \n977 class NumpyDocstring(GoogleDocstring):\n978     \"\"\"Convert NumPy style docstrings to reStructuredText.\n979 \n980     Parameters\n981     ----------\n982     docstring : :obj:`str` or :obj:`list` of :obj:`str`\n983         The docstring to parse, given either as a string or split into\n984         individual lines.\n985     config: :obj:`sphinx.ext.napoleon.Config` or :obj:`sphinx.config.Config`\n986         The configuration settings to use. If not given, defaults to the\n987         config object on `app`; or if `app` is not given defaults to the\n988         a new :class:`sphinx.ext.napoleon.Config` object.\n989 \n990 \n991     Other Parameters\n992     ----------------\n993     app : :class:`sphinx.application.Sphinx`, optional\n994         Application object representing the Sphinx process.\n995     what : :obj:`str`, optional\n996         A string specifying the type of the object to which the docstring\n997         belongs. Valid values: \"module\", \"class\", \"exception\", \"function\",\n998         \"method\", \"attribute\".\n999     name : :obj:`str`, optional\n1000         The fully qualified name of the object.\n1001     obj : module, class, exception, function, method, or attribute\n1002         The object to which the docstring belongs.\n1003     options : :class:`sphinx.ext.autodoc.Options`, optional\n1004         The options given to the directive: an object with attributes\n1005         inherited_members, undoc_members, show_inheritance and noindex that\n1006         are True if the flag option of same name was given to the auto\n1007         directive.\n1008 \n1009 \n1010     Example\n1011     -------\n1012     >>> from sphinx.ext.napoleon import Config\n1013     >>> config = Config(napoleon_use_param=True, napoleon_use_rtype=True)\n1014     >>> docstring = '''One line summary.\n1015     ...\n1016     ... Extended description.\n1017     ...\n1018     ... Parameters\n1019     ... ----------\n1020     ... arg1 : int\n1021     ...     Description of `arg1`\n1022     ... arg2 : str\n1023     ...     Description of `arg2`\n1024     ... Returns\n1025     ... -------\n1026     ... str\n1027     ...     Description of return value.\n1028     ... '''\n1029     >>> print(NumpyDocstring(docstring, config))\n1030     One line summary.\n1031     <BLANKLINE>\n1032     Extended description.\n1033     <BLANKLINE>\n1034     :param arg1: Description of `arg1`\n1035     :type arg1: int\n1036     :param arg2: Description of `arg2`\n1037     :type arg2: str\n1038     <BLANKLINE>\n1039     :returns: Description of return value.\n1040     :rtype: str\n1041     <BLANKLINE>\n1042 \n1043     Methods\n1044     -------\n1045     __str__()\n1046         Return the parsed docstring in reStructuredText format.\n1047 \n1048         Returns\n1049         -------\n1050         str\n1051             UTF-8 encoded version of the docstring.\n1052 \n1053     __unicode__()\n1054         Return the parsed docstring in reStructuredText format.\n1055 \n1056         Returns\n1057         -------\n1058         unicode\n1059             Unicode version of the docstring.\n1060 \n1061     lines()\n1062         Return the parsed lines of the docstring in reStructuredText format.\n1063 \n1064         Returns\n1065         -------\n1066         list(str)\n1067             The lines of the docstring in a list.\n1068 \n1069     \"\"\"\n1070     def __init__(self, docstring: Union[str, List[str]], config: SphinxConfig = None,\n1071                  app: Sphinx = None, what: str = '', name: str = '',\n1072                  obj: Any = None, options: Any = None) -> None:\n1073         self._directive_sections = ['.. index::']\n1074         super().__init__(docstring, config, app, what, name, obj, options)\n1075 \n1076     def _get_location(self) -> str:\n1077         try:\n1078             filepath = inspect.getfile(self._obj) if self._obj is not None else None\n1079         except TypeError:\n1080             filepath = None\n1081         name = self._name\n1082 \n1083         if filepath is None and name is None:\n1084             return None\n1085         elif filepath is None:\n1086             filepath = \"\"\n1087 \n1088         return \":\".join([filepath, \"docstring of %s\" % name])\n1089 \n1090     def _escape_args_and_kwargs(self, name: str) -> str:\n1091         func = super()._escape_args_and_kwargs\n1092 \n1093         if \", \" in name:\n1094             return \", \".join(func(param) for param in name.split(\", \"))\n1095         else:\n1096             return func(name)\n1097 \n1098     def _consume_field(self, parse_type: bool = True, prefer_type: bool = False\n1099                        ) -> Tuple[str, str, List[str]]:\n1100         line = next(self._line_iter)\n1101         if parse_type:\n1102             _name, _, _type = self._partition_field_on_colon(line)\n1103         else:\n1104             _name, _type = line, ''\n1105         _name, _type = _name.strip(), _type.strip()\n1106         _name = self._escape_args_and_kwargs(_name)\n1107         if self._config.napoleon_preprocess_types:\n1108             _type = _convert_numpy_type_spec(\n1109                 _type,\n1110                 location=self._get_location(),\n1111                 translations=self._config.napoleon_type_aliases or {},\n1112             )\n1113 \n1114         if prefer_type and not _type:\n1115             _type, _name = _name, _type\n1116         indent = self._get_indent(line) + 1\n1117         _desc = self._dedent(self._consume_indented_block(indent))\n1118         _desc = self.__class__(_desc, self._config).lines()\n1119         return _name, _type, _desc\n1120 \n1121     def _consume_returns_section(self) -> List[Tuple[str, str, List[str]]]:\n1122         return self._consume_fields(prefer_type=True)\n1123 \n1124     def _consume_section_header(self) -> str:\n1125         section = next(self._line_iter)\n1126         if not _directive_regex.match(section):\n1127             # Consume the header underline\n1128             next(self._line_iter)\n1129         return section\n1130 \n1131     def _is_section_break(self) -> bool:\n1132         line1, line2 = self._line_iter.peek(2)\n1133         return (not self._line_iter.has_next() or\n1134                 self._is_section_header() or\n1135                 ['', ''] == [line1, line2] or\n1136                 (self._is_in_section and\n1137                     line1 and\n1138                     not self._is_indented(line1, self._section_indent)))\n1139 \n1140     def _is_section_header(self) -> bool:\n1141         section, underline = self._line_iter.peek(2)\n1142         section = section.lower()\n1143         if section in self._sections and isinstance(underline, str):\n1144             return bool(_numpy_section_regex.match(underline))\n1145         elif self._directive_sections:\n1146             if _directive_regex.match(section):\n1147                 for directive_section in self._directive_sections:\n1148                     if section.startswith(directive_section):\n1149                         return True\n1150         return False\n1151 \n1152     def _parse_see_also_section(self, section: str) -> List[str]:\n1153         lines = self._consume_to_next_section()\n1154         try:\n1155             return self._parse_numpydoc_see_also_section(lines)\n1156         except ValueError:\n1157             return self._format_admonition('seealso', lines)\n1158 \n1159     def _parse_numpydoc_see_also_section(self, content: List[str]) -> List[str]:\n1160         \"\"\"\n1161         Derived from the NumpyDoc implementation of _parse_see_also.\n1162 \n1163         See Also\n1164         --------\n1165         func_name : Descriptive text\n1166             continued text\n1167         another_func_name : Descriptive text\n1168         func_name1, func_name2, :meth:`func_name`, func_name3\n1169 \n1170         \"\"\"\n1171         items = []\n1172 \n1173         def parse_item_name(text: str) -> Tuple[str, str]:\n1174             \"\"\"Match ':role:`name`' or 'name'\"\"\"\n1175             m = self._name_rgx.match(text)\n1176             if m:\n1177                 g = m.groups()\n1178                 if g[1] is None:\n1179                     return g[3], None\n1180                 else:\n1181                     return g[2], g[1]\n1182             raise ValueError(\"%s is not a item name\" % text)\n1183 \n1184         def push_item(name: str, rest: List[str]) -> None:\n1185             if not name:\n1186                 return\n1187             name, role = parse_item_name(name)\n1188             items.append((name, list(rest), role))\n1189             del rest[:]\n1190 \n1191         current_func = None\n1192         rest = []  # type: List[str]\n1193 \n1194         for line in content:\n1195             if not line.strip():\n1196                 continue\n1197 \n1198             m = self._name_rgx.match(line)\n1199             if m and line[m.end():].strip().startswith(':'):\n1200                 push_item(current_func, rest)\n1201                 current_func, line = line[:m.end()], line[m.end():]\n1202                 rest = [line.split(':', 1)[1].strip()]\n1203                 if not rest[0]:\n1204                     rest = []\n1205             elif not line.startswith(' '):\n1206                 push_item(current_func, rest)\n1207                 current_func = None\n1208                 if ',' in line:\n1209                     for func in line.split(','):\n1210                         if func.strip():\n1211                             push_item(func, [])\n1212                 elif line.strip():\n1213                     current_func = line\n1214             elif current_func is not None:\n1215                 rest.append(line.strip())\n1216         push_item(current_func, rest)\n1217 \n1218         if not items:\n1219             return []\n1220 \n1221         roles = {\n1222             'method': 'meth',\n1223             'meth': 'meth',\n1224             'function': 'func',\n1225             'func': 'func',\n1226             'class': 'class',\n1227             'exception': 'exc',\n1228             'exc': 'exc',\n1229             'object': 'obj',\n1230             'obj': 'obj',\n1231             'module': 'mod',\n1232             'mod': 'mod',\n1233             'data': 'data',\n1234             'constant': 'const',\n1235             'const': 'const',\n1236             'attribute': 'attr',\n1237             'attr': 'attr'\n1238         }\n1239         if self._what is None:\n1240             func_role = 'obj'\n1241         else:\n1242             func_role = roles.get(self._what, '')\n1243         lines = []  # type: List[str]\n1244         last_had_desc = True\n1245         for func, desc, role in items:\n1246             if role:\n1247                 link = ':%s:`%s`' % (role, func)\n1248             elif func_role:\n1249                 link = ':%s:`%s`' % (func_role, func)\n1250             else:\n1251                 link = \"`%s`_\" % func\n1252             if desc or last_had_desc:\n1253                 lines += ['']\n1254                 lines += [link]\n1255             else:\n1256                 lines[-1] += \", %s\" % link\n1257             if desc:\n1258                 lines += self._indent([' '.join(desc)])\n1259                 last_had_desc = True\n1260             else:\n1261                 last_had_desc = False\n1262         lines += ['']\n1263 \n1264         return self._format_admonition('seealso', lines)\n",
        "intended_behavior": "Ensure that the napoleon extension properly interprets and translates complex types in docstrings into the correct reStructuredText format without causing syntax warnings."
    },
    {
        "rel_file_path": "sphinx/ext/napoleon/__init__.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sphinx-doc__sphinx/setup_sphinx-doc__sphinx__3.3/sphinx/ext/napoleon/__init__.py",
        "start": 1,
        "end": 475,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\"\n2     sphinx.ext.napoleon\n3     ~~~~~~~~~~~~~~~~~~~\n4 \n5     Support for NumPy and Google style docstrings.\n6 \n7     :copyright: Copyright 2007-2020 by the Sphinx team, see AUTHORS.\n8     :license: BSD, see LICENSE for details.\n9 \"\"\"\n10 \n11 from typing import Any, Dict, List\n12 \n13 from sphinx import __display_version__ as __version__\n14 from sphinx.application import Sphinx\n15 from sphinx.ext.napoleon.docstring import GoogleDocstring, NumpyDocstring\n16 from sphinx.util import inspect\n17 \n18 \n19 class Config:\n20     \"\"\"Sphinx napoleon extension settings in `conf.py`.\n21 \n22     Listed below are all the settings used by napoleon and their default\n23     values. These settings can be changed in the Sphinx `conf.py` file. Make\n24     sure that \"sphinx.ext.napoleon\" is enabled in `conf.py`::\n25 \n26         # conf.py\n27 \n28         # Add any Sphinx extension module names here, as strings\n29         extensions = ['sphinx.ext.napoleon']\n30 \n31         # Napoleon settings\n32         napoleon_google_docstring = True\n33         napoleon_numpy_docstring = True\n34         napoleon_include_init_with_doc = False\n35         napoleon_include_private_with_doc = False\n36         napoleon_include_special_with_doc = False\n37         napoleon_use_admonition_for_examples = False\n38         napoleon_use_admonition_for_notes = False\n39         napoleon_use_admonition_for_references = False\n40         napoleon_use_ivar = False\n41         napoleon_use_param = True\n42         napoleon_use_rtype = True\n43         napoleon_use_keyword = True\n44         napoleon_preprocess_types = False\n45         napoleon_type_aliases = None\n46         napoleon_custom_sections = None\n47 \n48     .. _Google style:\n49        https://google.github.io/styleguide/pyguide.html\n50     .. _NumPy style:\n51        https://github.com/numpy/numpy/blob/master/doc/HOWTO_DOCUMENT.rst.txt\n52 \n53     Attributes\n54     ----------\n55     napoleon_google_docstring : :obj:`bool` (Defaults to True)\n56         True to parse `Google style`_ docstrings. False to disable support\n57         for Google style docstrings.\n58     napoleon_numpy_docstring : :obj:`bool` (Defaults to True)\n59         True to parse `NumPy style`_ docstrings. False to disable support\n60         for NumPy style docstrings.\n61     napoleon_include_init_with_doc : :obj:`bool` (Defaults to False)\n62         True to list ``__init___`` docstrings separately from the class\n63         docstring. False to fall back to Sphinx's default behavior, which\n64         considers the ``__init___`` docstring as part of the class\n65         documentation.\n66 \n67         **If True**::\n68 \n69             def __init__(self):\n70                 \\\"\\\"\\\"\n71                 This will be included in the docs because it has a docstring\n72                 \\\"\\\"\\\"\n73 \n74             def __init__(self):\n75                 # This will NOT be included in the docs\n76 \n77     napoleon_include_private_with_doc : :obj:`bool` (Defaults to False)\n78         True to include private members (like ``_membername``) with docstrings\n79         in the documentation. False to fall back to Sphinx's default behavior.\n80 \n81         **If True**::\n82 \n83             def _included(self):\n84                 \\\"\\\"\\\"\n85                 This will be included in the docs because it has a docstring\n86                 \\\"\\\"\\\"\n87                 pass\n88 \n89             def _skipped(self):\n90                 # This will NOT be included in the docs\n91                 pass\n92 \n93     napoleon_include_special_with_doc : :obj:`bool` (Defaults to False)\n94         True to include special members (like ``__membername__``) with\n95         docstrings in the documentation. False to fall back to Sphinx's\n96         default behavior.\n97 \n98         **If True**::\n99 \n100             def __str__(self):\n101                 \\\"\\\"\\\"\n102                 This will be included in the docs because it has a docstring\n103                 \\\"\\\"\\\"\n104                 return unicode(self).encode('utf-8')\n105 \n106             def __unicode__(self):\n107                 # This will NOT be included in the docs\n108                 return unicode(self.__class__.__name__)\n109 \n110     napoleon_use_admonition_for_examples : :obj:`bool` (Defaults to False)\n111         True to use the ``.. admonition::`` directive for the **Example** and\n112         **Examples** sections. False to use the ``.. rubric::`` directive\n113         instead. One may look better than the other depending on what HTML\n114         theme is used.\n115 \n116         This `NumPy style`_ snippet will be converted as follows::\n117 \n118             Example\n119             -------\n120             This is just a quick example\n121 \n122         **If True**::\n123 \n124             .. admonition:: Example\n125 \n126                This is just a quick example\n127 \n128         **If False**::\n129 \n130             .. rubric:: Example\n131 \n132             This is just a quick example\n133 \n134     napoleon_use_admonition_for_notes : :obj:`bool` (Defaults to False)\n135         True to use the ``.. admonition::`` directive for **Notes** sections.\n136         False to use the ``.. rubric::`` directive instead.\n137 \n138         Note\n139         ----\n140         The singular **Note** section will always be converted to a\n141         ``.. note::`` directive.\n142 \n143         See Also\n144         --------\n145         :attr:`napoleon_use_admonition_for_examples`\n146 \n147     napoleon_use_admonition_for_references : :obj:`bool` (Defaults to False)\n148         True to use the ``.. admonition::`` directive for **References**\n149         sections. False to use the ``.. rubric::`` directive instead.\n150 \n151         See Also\n152         --------\n153         :attr:`napoleon_use_admonition_for_examples`\n154 \n155     napoleon_use_ivar : :obj:`bool` (Defaults to False)\n156         True to use the ``:ivar:`` role for instance variables. False to use\n157         the ``.. attribute::`` directive instead.\n158 \n159         This `NumPy style`_ snippet will be converted as follows::\n160 \n161             Attributes\n162             ----------\n163             attr1 : int\n164                 Description of `attr1`\n165 \n166         **If True**::\n167 \n168             :ivar attr1: Description of `attr1`\n169             :vartype attr1: int\n170 \n171         **If False**::\n172 \n173             .. attribute:: attr1\n174 \n175                Description of `attr1`\n176 \n177                :type: int\n178 \n179     napoleon_use_param : :obj:`bool` (Defaults to True)\n180         True to use a ``:param:`` role for each function parameter. False to\n181         use a single ``:parameters:`` role for all the parameters.\n182 \n183         This `NumPy style`_ snippet will be converted as follows::\n184 \n185             Parameters\n186             ----------\n187             arg1 : str\n188                 Description of `arg1`\n189             arg2 : int, optional\n190                 Description of `arg2`, defaults to 0\n191 \n192         **If True**::\n193 \n194             :param arg1: Description of `arg1`\n195             :type arg1: str\n196             :param arg2: Description of `arg2`, defaults to 0\n197             :type arg2: int, optional\n198 \n199         **If False**::\n200 \n201             :parameters: * **arg1** (*str*) --\n202                            Description of `arg1`\n203                          * **arg2** (*int, optional*) --\n204                            Description of `arg2`, defaults to 0\n205 \n206     napoleon_use_keyword : :obj:`bool` (Defaults to True)\n207         True to use a ``:keyword:`` role for each function keyword argument.\n208         False to use a single ``:keyword arguments:`` role for all the\n209         keywords.\n210 \n211         This behaves similarly to  :attr:`napoleon_use_param`. Note unlike\n212         docutils, ``:keyword:`` and ``:param:`` will not be treated the same\n213         way - there will be a separate \"Keyword Arguments\" section, rendered\n214         in the same fashion as \"Parameters\" section (type links created if\n215         possible)\n216 \n217         See Also\n218         --------\n219         :attr:`napoleon_use_param`\n220 \n221     napoleon_use_rtype : :obj:`bool` (Defaults to True)\n222         True to use the ``:rtype:`` role for the return type. False to output\n223         the return type inline with the description.\n224 \n225         This `NumPy style`_ snippet will be converted as follows::\n226 \n227             Returns\n228             -------\n229             bool\n230                 True if successful, False otherwise\n231 \n232         **If True**::\n233 \n234             :returns: True if successful, False otherwise\n235             :rtype: bool\n236 \n237         **If False**::\n238 \n239             :returns: *bool* -- True if successful, False otherwise\n240 \n241     napoleon_preprocess_types : :obj:`bool` (Defaults to False)\n242         Enable the type preprocessor for numpy style docstrings.\n243 \n244     napoleon_type_aliases : :obj:`dict` (Defaults to None)\n245         Add a mapping of strings to string, translating types in numpy\n246         style docstrings. Only works if ``napoleon_preprocess_types = True``.\n247 \n248     napoleon_custom_sections : :obj:`list` (Defaults to None)\n249         Add a list of custom sections to include, expanding the list of parsed sections.\n250 \n251         The entries can either be strings or tuples, depending on the intention:\n252           * To create a custom \"generic\" section, just pass a string.\n253           * To create an alias for an existing section, pass a tuple containing the\n254             alias name and the original, in that order.\n255 \n256         If an entry is just a string, it is interpreted as a header for a generic\n257         section. If the entry is a tuple/list/indexed container, the first entry\n258         is the name of the section, the second is the section key to emulate.\n259 \n260 \n261     \"\"\"\n262     _config_values = {\n263         'napoleon_google_docstring': (True, 'env'),\n264         'napoleon_numpy_docstring': (True, 'env'),\n265         'napoleon_include_init_with_doc': (False, 'env'),\n266         'napoleon_include_private_with_doc': (False, 'env'),\n267         'napoleon_include_special_with_doc': (False, 'env'),\n268         'napoleon_use_admonition_for_examples': (False, 'env'),\n269         'napoleon_use_admonition_for_notes': (False, 'env'),\n270         'napoleon_use_admonition_for_references': (False, 'env'),\n271         'napoleon_use_ivar': (False, 'env'),\n272         'napoleon_use_param': (True, 'env'),\n273         'napoleon_use_rtype': (True, 'env'),\n274         'napoleon_use_keyword': (True, 'env'),\n275         'napoleon_preprocess_types': (False, 'env'),\n276         'napoleon_type_aliases': (None, 'env'),\n277         'napoleon_custom_sections': (None, 'env')\n278     }\n279 \n280     def __init__(self, **settings: Any) -> None:\n281         for name, (default, rebuild) in self._config_values.items():\n282             setattr(self, name, default)\n283         for name, value in settings.items():\n284             setattr(self, name, value)\n285 \n286 \n287 def setup(app: Sphinx) -> Dict[str, Any]:\n288     \"\"\"Sphinx extension setup function.\n289 \n290     When the extension is loaded, Sphinx imports this module and executes\n291     the ``setup()`` function, which in turn notifies Sphinx of everything\n292     the extension offers.\n293 \n294     Parameters\n295     ----------\n296     app : sphinx.application.Sphinx\n297         Application object representing the Sphinx process\n298 \n299     See Also\n300     --------\n301     `The Sphinx documentation on Extensions\n302     <http://sphinx-doc.org/extensions.html>`_\n303 \n304     `The Extension Tutorial <http://sphinx-doc.org/extdev/tutorial.html>`_\n305 \n306     `The Extension API <http://sphinx-doc.org/extdev/appapi.html>`_\n307 \n308     \"\"\"\n309     if not isinstance(app, Sphinx):\n310         # probably called by tests\n311         return {'version': __version__, 'parallel_read_safe': True}\n312 \n313     _patch_python_domain()\n314 \n315     app.setup_extension('sphinx.ext.autodoc')\n316     app.connect('autodoc-process-docstring', _process_docstring)\n317     app.connect('autodoc-skip-member', _skip_member)\n318 \n319     for name, (default, rebuild) in Config._config_values.items():\n320         app.add_config_value(name, default, rebuild)\n321     return {'version': __version__, 'parallel_read_safe': True}\n322 \n323 \n324 def _patch_python_domain() -> None:\n325     try:\n326         from sphinx.domains.python import PyTypedField\n327     except ImportError:\n328         pass\n329     else:\n330         import sphinx.domains.python\n331         from sphinx.locale import _\n332         for doc_field in sphinx.domains.python.PyObject.doc_field_types:\n333             if doc_field.name == 'parameter':\n334                 doc_field.names = ('param', 'parameter', 'arg', 'argument')\n335                 break\n336         sphinx.domains.python.PyObject.doc_field_types.append(\n337             PyTypedField('keyword', label=_('Keyword Arguments'),\n338                          names=('keyword', 'kwarg', 'kwparam'),\n339                          typerolename='obj', typenames=('paramtype', 'kwtype'),\n340                          can_collapse=True))\n341 \n342 \n343 def _process_docstring(app: Sphinx, what: str, name: str, obj: Any,\n344                        options: Any, lines: List[str]) -> None:\n345     \"\"\"Process the docstring for a given python object.\n346 \n347     Called when autodoc has read and processed a docstring. `lines` is a list\n348     of docstring lines that `_process_docstring` modifies in place to change\n349     what Sphinx outputs.\n350 \n351     The following settings in conf.py control what styles of docstrings will\n352     be parsed:\n353 \n354     * ``napoleon_google_docstring`` -- parse Google style docstrings\n355     * ``napoleon_numpy_docstring`` -- parse NumPy style docstrings\n356 \n357     Parameters\n358     ----------\n359     app : sphinx.application.Sphinx\n360         Application object representing the Sphinx process.\n361     what : str\n362         A string specifying the type of the object to which the docstring\n363         belongs. Valid values: \"module\", \"class\", \"exception\", \"function\",\n364         \"method\", \"attribute\".\n365     name : str\n366         The fully qualified name of the object.\n367     obj : module, class, exception, function, method, or attribute\n368         The object to which the docstring belongs.\n369     options : sphinx.ext.autodoc.Options\n370         The options given to the directive: an object with attributes\n371         inherited_members, undoc_members, show_inheritance and noindex that\n372         are True if the flag option of same name was given to the auto\n373         directive.\n374     lines : list of str\n375         The lines of the docstring, see above.\n376 \n377         .. note:: `lines` is modified *in place*\n378 \n379     \"\"\"\n380     result_lines = lines\n381     docstring = None  # type: GoogleDocstring\n382     if app.config.napoleon_numpy_docstring:\n383         docstring = NumpyDocstring(result_lines, app.config, app, what, name,\n384                                    obj, options)\n385         result_lines = docstring.lines()\n386     if app.config.napoleon_google_docstring:\n387         docstring = GoogleDocstring(result_lines, app.config, app, what, name,\n388                                     obj, options)\n389         result_lines = docstring.lines()\n390     lines[:] = result_lines[:]\n391 \n392 \n393 def _skip_member(app: Sphinx, what: str, name: str, obj: Any,\n394                  skip: bool, options: Any) -> bool:\n395     \"\"\"Determine if private and special class members are included in docs.\n396 \n397     The following settings in conf.py determine if private and special class\n398     members or init methods are included in the generated documentation:\n399 \n400     * ``napoleon_include_init_with_doc`` --\n401       include init methods if they have docstrings\n402     * ``napoleon_include_private_with_doc`` --\n403       include private members if they have docstrings\n404     * ``napoleon_include_special_with_doc`` --\n405       include special members if they have docstrings\n406 \n407     Parameters\n408     ----------\n409     app : sphinx.application.Sphinx\n410         Application object representing the Sphinx process\n411     what : str\n412         A string specifying the type of the object to which the member\n413         belongs. Valid values: \"module\", \"class\", \"exception\", \"function\",\n414         \"method\", \"attribute\".\n415     name : str\n416         The name of the member.\n417     obj : module, class, exception, function, method, or attribute.\n418         For example, if the member is the __init__ method of class A, then\n419         `obj` will be `A.__init__`.\n420     skip : bool\n421         A boolean indicating if autodoc will skip this member if `_skip_member`\n422         does not override the decision\n423     options : sphinx.ext.autodoc.Options\n424         The options given to the directive: an object with attributes\n425         inherited_members, undoc_members, show_inheritance and noindex that\n426         are True if the flag option of same name was given to the auto\n427         directive.\n428 \n429     Returns\n430     -------\n431     bool\n432         True if the member should be skipped during creation of the docs,\n433         False if it should be included in the docs.\n434 \n435     \"\"\"\n436     has_doc = getattr(obj, '__doc__', False)\n437     is_member = (what == 'class' or what == 'exception' or what == 'module')\n438     if name != '__weakref__' and has_doc and is_member:\n439         cls_is_owner = False\n440         if what == 'class' or what == 'exception':\n441             qualname = getattr(obj, '__qualname__', '')\n442             cls_path, _, _ = qualname.rpartition('.')\n443             if cls_path:\n444                 try:\n445                     if '.' in cls_path:\n446                         import importlib\n447                         import functools\n448 \n449                         mod = importlib.import_module(obj.__module__)\n450                         mod_path = cls_path.split('.')\n451                         cls = functools.reduce(getattr, mod_path, mod)\n452                     else:\n453                         cls = inspect.unwrap(obj).__globals__[cls_path]\n454                 except Exception:\n455                     cls_is_owner = False\n456                 else:\n457                     cls_is_owner = (cls and hasattr(cls, name) and  # type: ignore\n458                                     name in cls.__dict__)\n459             else:\n460                 cls_is_owner = False\n461 \n462         if what == 'module' or cls_is_owner:\n463             is_init = (name == '__init__')\n464             is_special = (not is_init and name.startswith('__') and\n465                           name.endswith('__'))\n466             is_private = (not is_init and not is_special and\n467                           name.startswith('_'))\n468             inc_init = app.config.napoleon_include_init_with_doc\n469             inc_special = app.config.napoleon_include_special_with_doc\n470             inc_private = app.config.napoleon_include_private_with_doc\n471             if ((is_special and inc_special) or\n472                     (is_private and inc_private) or\n473                     (is_init and inc_init)):\n474                 return False\n475     return None\n",
        "intended_behavior": "Adjust parsing rules or the way certain annotations are handled to prevent misinterpretation that leads to warnings."
    },
    {
        "rel_file_path": "doc/usage/extensions/example_google.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sphinx-doc__sphinx/setup_sphinx-doc__sphinx__3.3/doc/usage/extensions/example_google.py",
        "start": 1,
        "end": 296,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\"Example Google style docstrings.\n2 \n3 This module demonstrates documentation as specified by the `Google Python\n4 Style Guide`_. Docstrings may extend over multiple lines. Sections are created\n5 with a section header and a colon followed by a block of indented text.\n6 \n7 Example:\n8     Examples can be given using either the ``Example`` or ``Examples``\n9     sections. Sections support any reStructuredText formatting, including\n10     literal blocks::\n11 \n12         $ python example_google.py\n13 \n14 Section breaks are created by resuming unindented text. Section breaks\n15 are also implicitly created anytime a new section starts.\n16 \n17 Attributes:\n18     module_level_variable1 (int): Module level variables may be documented in\n19         either the ``Attributes`` section of the module docstring, or in an\n20         inline docstring immediately following the variable.\n21 \n22         Either form is acceptable, but the two should not be mixed. Choose\n23         one convention to document module level variables and be consistent\n24         with it.\n25 \n26 Todo:\n27     * For module TODOs\n28     * You have to also use ``sphinx.ext.todo`` extension\n29 \n30 .. _Google Python Style Guide:\n31    https://google.github.io/styleguide/pyguide.html\n32 \n33 \"\"\"\n34 \n35 module_level_variable1 = 12345\n36 \n37 module_level_variable2 = 98765\n38 \"\"\"int: Module level variable documented inline.\n39 \n40 The docstring may span multiple lines. The type may optionally be specified\n41 on the first line, separated by a colon.\n42 \"\"\"\n43 \n44 \n45 def function_with_types_in_docstring(param1, param2):\n46     \"\"\"Example function with types documented in the docstring.\n47 \n48     `PEP 484`_ type annotations are supported. If attribute, parameter, and\n49     return types are annotated according to `PEP 484`_, they do not need to be\n50     included in the docstring:\n51 \n52     Args:\n53         param1 (int): The first parameter.\n54         param2 (str): The second parameter.\n55 \n56     Returns:\n57         bool: The return value. True for success, False otherwise.\n58 \n59     .. _PEP 484:\n60         https://www.python.org/dev/peps/pep-0484/\n61 \n62     \"\"\"\n63 \n64 \n65 def function_with_pep484_type_annotations(param1: int, param2: str) -> bool:\n66     \"\"\"Example function with PEP 484 type annotations.\n67 \n68     Args:\n69         param1: The first parameter.\n70         param2: The second parameter.\n71 \n72     Returns:\n73         The return value. True for success, False otherwise.\n74 \n75     \"\"\"\n76 \n77 \n78 def module_level_function(param1, param2=None, *args, **kwargs):\n79     \"\"\"This is an example of a module level function.\n80 \n81     Function parameters should be documented in the ``Args`` section. The name\n82     of each parameter is required. The type and description of each parameter\n83     is optional, but should be included if not obvious.\n84 \n85     If ``*args`` or ``**kwargs`` are accepted,\n86     they should be listed as ``*args`` and ``**kwargs``.\n87 \n88     The format for a parameter is::\n89 \n90         name (type): description\n91             The description may span multiple lines. Following\n92             lines should be indented. The \"(type)\" is optional.\n93 \n94             Multiple paragraphs are supported in parameter\n95             descriptions.\n96 \n97     Args:\n98         param1 (int): The first parameter.\n99         param2 (:obj:`str`, optional): The second parameter. Defaults to None.\n100             Second line of description should be indented.\n101         *args: Variable length argument list.\n102         **kwargs: Arbitrary keyword arguments.\n103 \n104     Returns:\n105         bool: True if successful, False otherwise.\n106 \n107         The return type is optional and may be specified at the beginning of\n108         the ``Returns`` section followed by a colon.\n109 \n110         The ``Returns`` section may span multiple lines and paragraphs.\n111         Following lines should be indented to match the first line.\n112 \n113         The ``Returns`` section supports any reStructuredText formatting,\n114         including literal blocks::\n115 \n116             {\n117                 'param1': param1,\n118                 'param2': param2\n119             }\n120 \n121     Raises:\n122         AttributeError: The ``Raises`` section is a list of all exceptions\n123             that are relevant to the interface.\n124         ValueError: If `param2` is equal to `param1`.\n125 \n126     \"\"\"\n127     if param1 == param2:\n128         raise ValueError('param1 may not be equal to param2')\n129     return True\n130 \n131 \n132 def example_generator(n):\n133     \"\"\"Generators have a ``Yields`` section instead of a ``Returns`` section.\n134 \n135     Args:\n136         n (int): The upper limit of the range to generate, from 0 to `n` - 1.\n137 \n138     Yields:\n139         int: The next number in the range of 0 to `n` - 1.\n140 \n141     Examples:\n142         Examples should be written in doctest format, and should illustrate how\n143         to use the function.\n144 \n145         >>> print([i for i in example_generator(4)])\n146         [0, 1, 2, 3]\n147 \n148     \"\"\"\n149     for i in range(n):\n150         yield i\n151 \n152 \n153 class ExampleError(Exception):\n154     \"\"\"Exceptions are documented in the same way as classes.\n155 \n156     The __init__ method may be documented in either the class level\n157     docstring, or as a docstring on the __init__ method itself.\n158 \n159     Either form is acceptable, but the two should not be mixed. Choose one\n160     convention to document the __init__ method and be consistent with it.\n161 \n162     Note:\n163         Do not include the `self` parameter in the ``Args`` section.\n164 \n165     Args:\n166         msg (str): Human readable string describing the exception.\n167         code (:obj:`int`, optional): Error code.\n168 \n169     Attributes:\n170         msg (str): Human readable string describing the exception.\n171         code (int): Exception error code.\n172 \n173     \"\"\"\n174 \n175     def __init__(self, msg, code):\n176         self.msg = msg\n177         self.code = code\n178 \n179 \n180 class ExampleClass:\n181     \"\"\"The summary line for a class docstring should fit on one line.\n182 \n183     If the class has public attributes, they may be documented here\n184     in an ``Attributes`` section and follow the same formatting as a\n185     function's ``Args`` section. Alternatively, attributes may be documented\n186     inline with the attribute's declaration (see __init__ method below).\n187 \n188     Properties created with the ``@property`` decorator should be documented\n189     in the property's getter method.\n190 \n191     Attributes:\n192         attr1 (str): Description of `attr1`.\n193         attr2 (:obj:`int`, optional): Description of `attr2`.\n194 \n195     \"\"\"\n196 \n197     def __init__(self, param1, param2, param3):\n198         \"\"\"Example of docstring on the __init__ method.\n199 \n200         The __init__ method may be documented in either the class level\n201         docstring, or as a docstring on the __init__ method itself.\n202 \n203         Either form is acceptable, but the two should not be mixed. Choose one\n204         convention to document the __init__ method and be consistent with it.\n205 \n206         Note:\n207             Do not include the `self` parameter in the ``Args`` section.\n208 \n209         Args:\n210             param1 (str): Description of `param1`.\n211             param2 (:obj:`int`, optional): Description of `param2`. Multiple\n212                 lines are supported.\n213             param3 (list(str)): Description of `param3`.\n214 \n215         \"\"\"\n216         self.attr1 = param1\n217         self.attr2 = param2\n218         self.attr3 = param3  #: Doc comment *inline* with attribute\n219 \n220         #: list(str): Doc comment *before* attribute, with type specified\n221         self.attr4 = ['attr4']\n222 \n223         self.attr5 = None\n224         \"\"\"str: Docstring *after* attribute, with type specified.\"\"\"\n225 \n226     @property\n227     def readonly_property(self):\n228         \"\"\"str: Properties should be documented in their getter method.\"\"\"\n229         return 'readonly_property'\n230 \n231     @property\n232     def readwrite_property(self):\n233         \"\"\"list(str): Properties with both a getter and setter\n234         should only be documented in their getter method.\n235 \n236         If the setter method contains notable behavior, it should be\n237         mentioned here.\n238         \"\"\"\n239         return ['readwrite_property']\n240 \n241     @readwrite_property.setter\n242     def readwrite_property(self, value):\n243         value\n244 \n245     def example_method(self, param1, param2):\n246         \"\"\"Class methods are similar to regular functions.\n247 \n248         Note:\n249             Do not include the `self` parameter in the ``Args`` section.\n250 \n251         Args:\n252             param1: The first parameter.\n253             param2: The second parameter.\n254 \n255         Returns:\n256             True if successful, False otherwise.\n257 \n258         \"\"\"\n259         return True\n260 \n261     def __special__(self):\n262         \"\"\"By default special members with docstrings are not included.\n263 \n264         Special members are any methods or attributes that start with and\n265         end with a double underscore. Any special member with a docstring\n266         will be included in the output, if\n267         ``napoleon_include_special_with_doc`` is set to True.\n268 \n269         This behavior can be enabled by changing the following setting in\n270         Sphinx's conf.py::\n271 \n272             napoleon_include_special_with_doc = True\n273 \n274         \"\"\"\n275         pass\n276 \n277     def __special_without_docstring__(self):\n278         pass\n279 \n280     def _private(self):\n281         \"\"\"By default private members are not included.\n282 \n283         Private members are any methods or attributes that start with an\n284         underscore and are *not* special. By default they are not included\n285         in the output.\n286 \n287         This behavior can be changed such that private members *are* included\n288         by changing the following setting in Sphinx's conf.py::\n289 \n290             napoleon_include_private_with_doc = True\n291 \n292         \"\"\"\n293         pass\n294 \n295     def _private_without_docstring(self):\n296         pass\n",
        "intended_behavior": "Review documentation examples for handling generics in docstrings to ensure correct parsing and rendering without syntax warnings."
    },
    {
        "rel_file_path": "doc/usage/extensions/example_numpy.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sphinx-doc__sphinx/setup_sphinx-doc__sphinx__3.3/doc/usage/extensions/example_numpy.py",
        "start": 1,
        "end": 355,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\"Example NumPy style docstrings.\n2 \n3 This module demonstrates documentation as specified by the `NumPy\n4 Documentation HOWTO`_. Docstrings may extend over multiple lines. Sections\n5 are created with a section header followed by an underline of equal length.\n6 \n7 Example\n8 -------\n9 Examples can be given using either the ``Example`` or ``Examples``\n10 sections. Sections support any reStructuredText formatting, including\n11 literal blocks::\n12 \n13     $ python example_numpy.py\n14 \n15 \n16 Section breaks are created with two blank lines. Section breaks are also\n17 implicitly created anytime a new section starts. Section bodies *may* be\n18 indented:\n19 \n20 Notes\n21 -----\n22     This is an example of an indented section. It's like any other section,\n23     but the body is indented to help it stand out from surrounding text.\n24 \n25 If a section is indented, then a section break is created by\n26 resuming unindented text.\n27 \n28 Attributes\n29 ----------\n30 module_level_variable1 : int\n31     Module level variables may be documented in either the ``Attributes``\n32     section of the module docstring, or in an inline docstring immediately\n33     following the variable.\n34 \n35     Either form is acceptable, but the two should not be mixed. Choose\n36     one convention to document module level variables and be consistent\n37     with it.\n38 \n39 \n40 .. _NumPy Documentation HOWTO:\n41    https://github.com/numpy/numpy/blob/master/doc/HOWTO_DOCUMENT.rst.txt\n42 \n43 \"\"\"\n44 \n45 module_level_variable1 = 12345\n46 \n47 module_level_variable2 = 98765\n48 \"\"\"int: Module level variable documented inline.\n49 \n50 The docstring may span multiple lines. The type may optionally be specified\n51 on the first line, separated by a colon.\n52 \"\"\"\n53 \n54 \n55 def function_with_types_in_docstring(param1, param2):\n56     \"\"\"Example function with types documented in the docstring.\n57 \n58     `PEP 484`_ type annotations are supported. If attribute, parameter, and\n59     return types are annotated according to `PEP 484`_, they do not need to be\n60     included in the docstring:\n61 \n62     Parameters\n63     ----------\n64     param1 : int\n65         The first parameter.\n66     param2 : str\n67         The second parameter.\n68 \n69     Returns\n70     -------\n71     bool\n72         True if successful, False otherwise.\n73 \n74     .. _PEP 484:\n75         https://www.python.org/dev/peps/pep-0484/\n76 \n77     \"\"\"\n78 \n79 \n80 def function_with_pep484_type_annotations(param1: int, param2: str) -> bool:\n81     \"\"\"Example function with PEP 484 type annotations.\n82 \n83     The return type must be duplicated in the docstring to comply\n84     with the NumPy docstring style.\n85 \n86     Parameters\n87     ----------\n88     param1\n89         The first parameter.\n90     param2\n91         The second parameter.\n92 \n93     Returns\n94     -------\n95     bool\n96         True if successful, False otherwise.\n97 \n98     \"\"\"\n99 \n100 \n101 def module_level_function(param1, param2=None, *args, **kwargs):\n102     \"\"\"This is an example of a module level function.\n103 \n104     Function parameters should be documented in the ``Parameters`` section.\n105     The name of each parameter is required. The type and description of each\n106     parameter is optional, but should be included if not obvious.\n107 \n108     If ``*args`` or ``**kwargs`` are accepted,\n109     they should be listed as ``*args`` and ``**kwargs``.\n110 \n111     The format for a parameter is::\n112 \n113         name : type\n114             description\n115 \n116             The description may span multiple lines. Following lines\n117             should be indented to match the first line of the description.\n118             The \": type\" is optional.\n119 \n120             Multiple paragraphs are supported in parameter\n121             descriptions.\n122 \n123     Parameters\n124     ----------\n125     param1 : int\n126         The first parameter.\n127     param2 : :obj:`str`, optional\n128         The second parameter.\n129     *args\n130         Variable length argument list.\n131     **kwargs\n132         Arbitrary keyword arguments.\n133 \n134     Returns\n135     -------\n136     bool\n137         True if successful, False otherwise.\n138 \n139         The return type is not optional. The ``Returns`` section may span\n140         multiple lines and paragraphs. Following lines should be indented to\n141         match the first line of the description.\n142 \n143         The ``Returns`` section supports any reStructuredText formatting,\n144         including literal blocks::\n145 \n146             {\n147                 'param1': param1,\n148                 'param2': param2\n149             }\n150 \n151     Raises\n152     ------\n153     AttributeError\n154         The ``Raises`` section is a list of all exceptions\n155         that are relevant to the interface.\n156     ValueError\n157         If `param2` is equal to `param1`.\n158 \n159     \"\"\"\n160     if param1 == param2:\n161         raise ValueError('param1 may not be equal to param2')\n162     return True\n163 \n164 \n165 def example_generator(n):\n166     \"\"\"Generators have a ``Yields`` section instead of a ``Returns`` section.\n167 \n168     Parameters\n169     ----------\n170     n : int\n171         The upper limit of the range to generate, from 0 to `n` - 1.\n172 \n173     Yields\n174     ------\n175     int\n176         The next number in the range of 0 to `n` - 1.\n177 \n178     Examples\n179     --------\n180     Examples should be written in doctest format, and should illustrate how\n181     to use the function.\n182 \n183     >>> print([i for i in example_generator(4)])\n184     [0, 1, 2, 3]\n185 \n186     \"\"\"\n187     for i in range(n):\n188         yield i\n189 \n190 \n191 class ExampleError(Exception):\n192     \"\"\"Exceptions are documented in the same way as classes.\n193 \n194     The __init__ method may be documented in either the class level\n195     docstring, or as a docstring on the __init__ method itself.\n196 \n197     Either form is acceptable, but the two should not be mixed. Choose one\n198     convention to document the __init__ method and be consistent with it.\n199 \n200     Note\n201     ----\n202     Do not include the `self` parameter in the ``Parameters`` section.\n203 \n204     Parameters\n205     ----------\n206     msg : str\n207         Human readable string describing the exception.\n208     code : :obj:`int`, optional\n209         Numeric error code.\n210 \n211     Attributes\n212     ----------\n213     msg : str\n214         Human readable string describing the exception.\n215     code : int\n216         Numeric error code.\n217 \n218     \"\"\"\n219 \n220     def __init__(self, msg, code):\n221         self.msg = msg\n222         self.code = code\n223 \n224 \n225 class ExampleClass:\n226     \"\"\"The summary line for a class docstring should fit on one line.\n227 \n228     If the class has public attributes, they may be documented here\n229     in an ``Attributes`` section and follow the same formatting as a\n230     function's ``Args`` section. Alternatively, attributes may be documented\n231     inline with the attribute's declaration (see __init__ method below).\n232 \n233     Properties created with the ``@property`` decorator should be documented\n234     in the property's getter method.\n235 \n236     Attributes\n237     ----------\n238     attr1 : str\n239         Description of `attr1`.\n240     attr2 : :obj:`int`, optional\n241         Description of `attr2`.\n242 \n243     \"\"\"\n244 \n245     def __init__(self, param1, param2, param3):\n246         \"\"\"Example of docstring on the __init__ method.\n247 \n248         The __init__ method may be documented in either the class level\n249         docstring, or as a docstring on the __init__ method itself.\n250 \n251         Either form is acceptable, but the two should not be mixed. Choose one\n252         convention to document the __init__ method and be consistent with it.\n253 \n254         Note\n255         ----\n256         Do not include the `self` parameter in the ``Parameters`` section.\n257 \n258         Parameters\n259         ----------\n260         param1 : str\n261             Description of `param1`.\n262         param2 : list(str)\n263             Description of `param2`. Multiple\n264             lines are supported.\n265         param3 : :obj:`int`, optional\n266             Description of `param3`.\n267 \n268         \"\"\"\n269         self.attr1 = param1\n270         self.attr2 = param2\n271         self.attr3 = param3  #: Doc comment *inline* with attribute\n272 \n273         #: list(str): Doc comment *before* attribute, with type specified\n274         self.attr4 = [\"attr4\"]\n275 \n276         self.attr5 = None\n277         \"\"\"str: Docstring *after* attribute, with type specified.\"\"\"\n278 \n279     @property\n280     def readonly_property(self):\n281         \"\"\"str: Properties should be documented in their getter method.\"\"\"\n282         return \"readonly_property\"\n283 \n284     @property\n285     def readwrite_property(self):\n286         \"\"\"list(str): Properties with both a getter and setter\n287         should only be documented in their getter method.\n288 \n289         If the setter method contains notable behavior, it should be\n290         mentioned here.\n291         \"\"\"\n292         return [\"readwrite_property\"]\n293 \n294     @readwrite_property.setter\n295     def readwrite_property(self, value):\n296         value\n297 \n298     def example_method(self, param1, param2):\n299         \"\"\"Class methods are similar to regular functions.\n300 \n301         Note\n302         ----\n303         Do not include the `self` parameter in the ``Parameters`` section.\n304 \n305         Parameters\n306         ----------\n307         param1\n308             The first parameter.\n309         param2\n310             The second parameter.\n311 \n312         Returns\n313         -------\n314         bool\n315             True if successful, False otherwise.\n316 \n317         \"\"\"\n318         return True\n319 \n320     def __special__(self):\n321         \"\"\"By default special members with docstrings are not included.\n322 \n323         Special members are any methods or attributes that start with and\n324         end with a double underscore. Any special member with a docstring\n325         will be included in the output, if\n326         ``napoleon_include_special_with_doc`` is set to True.\n327 \n328         This behavior can be enabled by changing the following setting in\n329         Sphinx's conf.py::\n330 \n331             napoleon_include_special_with_doc = True\n332 \n333         \"\"\"\n334         pass\n335 \n336     def __special_without_docstring__(self):\n337         pass\n338 \n339     def _private(self):\n340         \"\"\"By default private members are not included.\n341 \n342         Private members are any methods or attributes that start with an\n343         underscore and are *not* special. By default they are not included\n344         in the output.\n345 \n346         This behavior can be changed such that private members *are* included\n347         by changing the following setting in Sphinx's conf.py::\n348 \n349             napoleon_include_private_with_doc = True\n350 \n351         \"\"\"\n352         pass\n353 \n354     def _private_without_docstring(self):\n355         pass\n",
        "intended_behavior": "Ensure documentation practices for generics and class variables in docstrings are correctly interpreted by Sphinx, particularly in the example files."
    }
]