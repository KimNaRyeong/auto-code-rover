2025-10-18 18:30:12.387 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-18 18:30:15.073 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=569, output_tokens=12, cost=0.006050
2025-10-18 18:30:31.290 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=749, output_tokens=637, cost=0.026600
2025-10-18 18:30:32.302 | INFO     | registered non reproducing test 0
2025-10-18 18:30:45.332 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1665, output_tokens=658, cost=0.036390
2025-10-18 18:30:46.308 | INFO     | registered non reproducing test 1
2025-10-18 18:31:03.568 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1951, output_tokens=670, cost=0.039610
2025-10-18 18:31:04.539 | INFO     | registered non reproducing test 2
2025-10-18 18:31:04.540 | WARNING  | Failed to write a reproducer test; skipping reproducer tracing
2025-10-18 18:31:04.543 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 18:31:15.036 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=859, output_tokens=455, cost=0.022240
2025-10-18 18:31:15.040 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 18:31:18.624 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=809, output_tokens=81, cost=0.010520
2025-10-18 18:31:18.626 | DEBUG    | the API call 'search_file("conf.py")' calls a non-existent function. Will retry.
2025-10-18 18:31:18.626 | DEBUG    | Trying to convert API calls/bug locations into json. Try 2 of 5.
2025-10-18 18:31:22.380 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=809, output_tokens=72, cost=0.010250
2025-10-18 18:31:22.381 | DEBUG    | Extracted a valid json.
2025-10-18 18:31:22.381 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_class(\"MyGeneric\")",
        "search_class(\"MyGenericChild\")",
        "search_method_in_class(\"__init__\", \"MyGenericChild\")",
        "search_code(\"some_type: ClassVar[Type['MyGenericChild']]\")"
    ],
    "bug_locations": []
}
2025-10-18 18:31:22.390 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-18 18:31:22.390 | DEBUG    | <Agent search> Analyzing search results.
2025-10-18 18:31:34.703 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1535, output_tokens=542, cost=0.031610
2025-10-18 18:31:34.709 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 18:31:45.668 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2293, output_tokens=523, cost=0.038620
2025-10-18 18:31:45.679 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 18:31:46.880 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=877, output_tokens=14, cost=0.009190
2025-10-18 18:31:46.882 | DEBUG    | Both API_calls and bug_locations are empty. Will retry.
2025-10-18 18:31:46.882 | DEBUG    | Trying to convert API calls/bug locations into json. Try 2 of 5.
2025-10-18 18:31:51.531 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=877, output_tokens=152, cost=0.013330
2025-10-18 18:31:51.532 | DEBUG    | Extracted a valid json.
2025-10-18 18:31:51.532 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_code(\"Sphinx documentation generation\")",
        "search_code(\"sphinx_autodoc_typehints\")",
        "search_code(\"napoleon\")"
    ],
    "bug_locations": [
        {
            "file": "conf.py",
            "class": "",
            "method": "",
            "intended_behavior": "Adjusting the doc comment format to comply with Sphinxâ€™s expectations and reviewing/modifying Sphinx extension configurations to better handle generics."
        },
        {
            "file": "",
            "class": "",
            "method": "",
            "intended_behavior": "Creating or updating custom Sphinx handlers or extensions to correctly interpret and render documentation for generic classes and their subclasses."
        }
    ]
}
2025-10-18 18:31:51.649 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-18 18:31:51.649 | DEBUG    | <Agent search> Analyzing search results.
2025-10-18 18:32:05.921 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=3105, output_tokens=633, cost=0.050040
2025-10-18 18:32:05.932 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 18:32:18.776 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=3954, output_tokens=562, cost=0.056400
2025-10-18 18:32:18.787 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 18:32:24.401 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=916, output_tokens=247, cost=0.016570
2025-10-18 18:32:24.402 | DEBUG    | Extracted a valid json.
2025-10-18 18:32:24.403 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "sphinx/ext/napoleon/docstring.py",
            "class": "",
            "method": "",
            "intended_behavior": "Ensure that the napoleon extension properly interprets and translates complex types in docstrings into the correct reStructuredText format without causing syntax warnings."
        },
        {
            "file": "sphinx/ext/napoleon/__init__.py",
            "class": "",
            "method": "",
            "intended_behavior": "Adjust parsing rules or the way certain annotations are handled to prevent misinterpretation that leads to warnings."
        },
        {
            "file": "doc/usage/extensions/example_google.py",
            "class": "",
            "method": "",
            "intended_behavior": "Review documentation examples for handling generics in docstrings to ensure correct parsing and rendering without syntax warnings."
        },
        {
            "file": "doc/usage/extensions/example_numpy.py",
            "class": "",
            "method": "",
            "intended_behavior": "Ensure documentation practices for generics and class variables in docstrings are correctly interpreted by Sphinx, particularly in the example files."
        }
    ]
}
2025-10-18 18:32:24.411 | DEBUG    | Bug location extracted successfully: [<file>sphinx/ext/napoleon/docstring.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2     sphinx.ext.napoleon.docstring
3     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
4 
5 
6     Classes for docstring parsing and formatting.
7 
8 
9     :copyright: Copyright 2007-2020 by the Sphinx team, see AUTHORS.
10     :license: BSD, see LICENSE for details.
11 """
12 
13 import collections
14 import inspect
15 import re
16 from functools import partial
17 from typing import Any, Callable, Dict, List, Tuple, Union
18 
19 from sphinx.application import Sphinx
20 from sphinx.config import Config as SphinxConfig
21 from sphinx.ext.napoleon.iterators import modify_iter
22 from sphinx.locale import _, __
23 from sphinx.util import logging
24 
25 if False:
26     # For type annotation
27     from typing import Type  # for python3.5.1
28 
29 
30 logger = logging.getLogger(__name__)
31 
32 _directive_regex = re.compile(r'\.\. \S+::')
33 _google_section_regex = re.compile(r'^(\s|\w)+:\s*$')
34 _google_typed_arg_regex = re.compile(r'\s*(.+?)\s*\(\s*(.*[^\s]+)\s*\)')
35 _numpy_section_regex = re.compile(r'^[=\-`:\'"~^_*+#<>]{2,}\s*$')
36 _single_colon_regex = re.compile(r'(?<!:):(?!:)')
37 _xref_or_code_regex = re.compile(
38     r'((?::(?:[a-zA-Z0-9]+[\-_+:.])*[a-zA-Z0-9]+:`.+?`)|'
39     r'(?:``.+?``))')
40 _xref_regex = re.compile(
41     r'(?:(?::(?:[a-zA-Z0-9]+[\-_+:.])*[a-zA-Z0-9]+:)?`.+?`)'
42 )
43 _bullet_list_regex = re.compile(r'^(\*|\+|\-)(\s+\S|\s*$)')
44 _enumerated_list_regex = re.compile(
45     r'^(?P<paren>\()?'
46     r'(\d+|#|[ivxlcdm]+|[IVXLCDM]+|[a-zA-Z])'
47     r'(?(paren)\)|\.)(\s+\S|\s*$)')
48 _token_regex = re.compile(
49     r"(,\sor\s|\sor\s|\sof\s|:\s|\sto\s|,\sand\s|\sand\s|,\s"
50     r"|[{]|[}]"
51     r'|"(?:\\"|[^"])*"'
52     r"|'(?:\\'|[^'])*')"
53 )
54 _default_regex = re.compile(
55     r"^default[^_0-9A-Za-z].*$",
56 )
57 _SINGLETONS = ("None", "True", "False", "Ellipsis")
58 
59 
60 class GoogleDocstring:
61     """Convert Google style docstrings to reStructuredText.
62 
63     Parameters
64     ----------
65     docstring : :obj:`str` or :obj:`list` of :obj:`str`
66         The docstring to parse, given either as a string or split into
67         individual lines.
68     config: :obj:`sphinx.ext.napoleon.Config` or :obj:`sphinx.config.Config`
69         The configuration settings to use. If not given, defaults to the
70         config object on `app`; or if `app` is not given defaults to the
71         a new :class:`sphinx.ext.napoleon.Config` object.
72 
73 
74     Other Parameters
75     ----------------
76     app : :class:`sphinx.application.Sphinx`, optional
77         Application object representing the Sphinx process.
78     what : :obj:`str`, optional
79         A string specifying the type of the object to which the docstring
80         belongs. Valid values: "module", "class", "exception", "function",
81         "method", "attribute".
82     name : :obj:`str`, optional
83         The fully qualified name of the object.
84     obj : module, class, exception, function, method, or attribute
85         The object to which the docstring belongs.
86     options : :class:`sphinx.ext.autodoc.Options`, optional
87         The options given to the directive: an object with attributes
88         inherited_members, undoc_members, show_inheritance and noindex that
89         are True if the flag option of same name was given to the auto
90         directive.
91 
92 
93     Example
94     -------
95     >>> from sphinx.ext.napoleon import Config
96     >>> config = Config(napoleon_use_param=True, napoleon_use_rtype=True)
97     >>> docstring = '''One line summary.
98     ...
99     ... Extended description.
100     ...
101     ... Args:
102     ...   arg1(int): Description of `arg1`
103     ...   arg2(str): Description of `arg2`
104     ... Returns:
105     ...   str: Description of return value.
106     ... '''
107     >>> print(GoogleDocstring(docstring, config))
108     One line summary.
109     <BLANKLINE>
110     Extended description.
111     <BLANKLINE>
112     :param arg1: Description of `arg1`
113     :type arg1: int
114     :param arg2: Description of `arg2`
115     :type arg2: str
116     <BLANKLINE>
117     :returns: Description of return value.
118     :rtype: str
119     <BLANKLINE>
120 
121     """
122 
123     _name_rgx = re.compile(r"^\s*((?::(?P<role>\S+):)?`(?P<name>~?[a-zA-Z0-9_.-]+)`|"
124                            r" (?P<name2>~?[a-zA-Z0-9_.-]+))\s*", re.X)
125 
126     def __init__(self, docstring: Union[str, List[str]], config: SphinxConfig = None,
127                  app: Sphinx = None, what: str = '', name: str = '',
128                  obj: Any = None, options: Any = None) -> None:
129         self._config = config
130         self._app = app
131 
132         if not self._config:
133             from sphinx.ext.napoleon import Config
134             self._config = self._app.config if self._app else Config()  # type: ignore
135 
136         if not what:
137             if inspect.isclass(obj):
138                 what = 'class'
139             elif inspect.ismodule(obj):
140                 what = 'module'
141             elif callable(obj):
142                 what = 'function'
143             else:
144                 what = 'object'
145 
146         self._what = what
147         self._name = name
148         self._obj = obj
149         self._opt = options
150         if isinstance(docstring, str):
151             lines = docstring.splitlines()
152         else:
153             lines = docstring
154         self._line_iter = modify_iter(lines, modifier=lambda s: s.rstrip())
155         self._parsed_lines = []  # type: List[str]
156         self._is_in_section = False
157         self._section_indent = 0
158         if not hasattr(self, '_directive_sections'):
159             self._directive_sections = []  # type: List[str]
160         if not hasattr(self, '_sections'):
161             self._sections = {
162                 'args': self._parse_parameters_section,
163                 'arguments': self._parse_parameters_section,
164                 'attention': partial(self._parse_admonition, 'attention'),
165                 'attributes': self._parse_attributes_section,
166                 'caution': partial(self._parse_admonition, 'caution'),
167                 'danger': partial(self._parse_admonition, 'danger'),
168                 'error': partial(self._parse_admonition, 'error'),
169                 'example': self._parse_examples_section,
170                 'examples': self._parse_examples_section,
171                 'hint': partial(self._parse_admonition, 'hint'),
172                 'important': partial(self._parse_admonition, 'important'),
173                 'keyword args': self._parse_keyword_arguments_section,
174                 'keyword arguments': self._parse_keyword_arguments_section,
175                 'methods': self._parse_methods_section,
176                 'note': partial(self._parse_admonition, 'note'),
177                 'notes': self._parse_notes_section,
178                 'other parameters': self._parse_other_parameters_section,
179                 'parameters': self._parse_parameters_section,
180                 'return': self._parse_returns_section,
181                 'returns': self._parse_returns_section,
182                 'raise': self._parse_raises_section,
183                 'raises': self._parse_raises_section,
184                 'references': self._parse_references_section,
185                 'see also': self._parse_see_also_section,
186                 'tip': partial(self._parse_admonition, 'tip'),
187                 'todo': partial(self._parse_admonition, 'todo'),
188                 'warning': partial(self._parse_admonition, 'warning'),
189                 'warnings': partial(self._parse_admonition, 'warning'),
190                 'warn': self._parse_warns_section,
191                 'warns': self._parse_warns_section,
192                 'yield': self._parse_yields_section,
193                 'yields': self._parse_yields_section,
194             }  # type: Dict[str, Callable]
195 
196         self._load_custom_sections()
197 
198         self._parse()
199 
200     def __str__(self) -> str:
201         """Return the parsed docstring in reStructuredText format.
202 
203         Returns
204         -------
205         unicode
206             Unicode version of the docstring.
207 
208         """
209         return '\n'.join(self.lines())
210 
211     def lines(self) -> List[str]:
212         """Return the parsed lines of the docstring in reStructuredText format.
213 
214         Returns
215         -------
216         list(str)
217             The lines of the docstring in a list.
218 
219         """
220         return self._parsed_lines
221 
222     def _consume_indented_block(self, indent: int = 1) -> List[str]:
223         lines = []
224         line = self._line_iter.peek()
225         while(not self._is_section_break() and
226               (not line or self._is_indented(line, indent))):
227             lines.append(next(self._line_iter))
228             line = self._line_iter.peek()
229         return lines
230 
231     def _consume_contiguous(self) -> List[str]:
232         lines = []
233         while (self._line_iter.has_next() and
234                self._line_iter.peek() and
235                not self._is_section_header()):
236             lines.append(next(self._line_iter))
237         return lines
238 
239     def _consume_empty(self) -> List[str]:
240         lines = []
241         line = self._line_iter.peek()
242         while self._line_iter.has_next() and not line:
243             lines.append(next(self._line_iter))
244             line = self._line_iter.peek()
245         return lines
246 
247     def _consume_field(self, parse_type: bool = True, prefer_type: bool = False
248                        ) -> Tuple[str, str, List[str]]:
249         line = next(self._line_iter)
250 
251         before, colon, after = self._partition_field_on_colon(line)
252         _name, _type, _desc = before, '', after
253 
254         if parse_type:
255             match = _google_typed_arg_regex.match(before)
256             if match:
257                 _name = match.group(1)
258                 _type = match.group(2)
259 
260         _name = self._escape_args_and_kwargs(_name)
261 
262         if prefer_type and not _type:
263             _type, _name = _name, _type
264         indent = self._get_indent(line) + 1
265         _descs = [_desc] + self._dedent(self._consume_indented_block(indent))
266         _descs = self.__class__(_descs, self._config).lines()
267         return _name, _type, _descs
268 
269     def _consume_fields(self, parse_type: bool = True, prefer_type: bool = False,
270                         multiple: bool = False) -> List[Tuple[str, str, List[str]]]:
271         self._consume_empty()
272         fields = []
273         while not self._is_section_break():
274             _name, _type, _desc = self._consume_field(parse_type, prefer_type)
275             if multiple and _name:
276                 for name in _name.split(","):
277                     fields.append((name.strip(), _type, _desc))
278             elif _name or _type or _desc:
279                 fields.append((_name, _type, _desc,))
280         return fields
281 
282     def _consume_inline_attribute(self) -> Tuple[str, List[str]]:
283         line = next(self._line_iter)
284         _type, colon, _desc = self._partition_field_on_colon(line)
285         if not colon or not _desc:
286             _type, _desc = _desc, _type
287             _desc += colon
288         _descs = [_desc] + self._dedent(self._consume_to_end())
289         _descs = self.__class__(_descs, self._config).lines()
290         return _type, _descs
291 
292     def _consume_returns_section(self) -> List[Tuple[str, str, List[str]]]:
293         lines = self._dedent(self._consume_to_next_section())
294         if lines:
295             before, colon, after = self._partition_field_on_colon(lines[0])
296             _name, _type, _desc = '', '', lines
297 
298             if colon:
299                 if after:
300                     _desc = [after] + lines[1:]
301                 else:
302                     _desc = lines[1:]
303 
304                 _type = before
305 
306             _desc = self.__class__(_desc, self._config).lines()
307             return [(_name, _type, _desc,)]
308         else:
309             return []
310 
311     def _consume_usage_section(self) -> List[str]:
312         lines = self._dedent(self._consume_to_next_section())
313         return lines
314 
315     def _consume_section_header(self) -> str:
316         section = next(self._line_iter)
317         stripped_section = section.strip(':')
318         if stripped_section.lower() in self._sections:
319             section = stripped_section
320         return section
321 
322     def _consume_to_end(self) -> List[str]:
323         lines = []
324         while self._line_iter.has_next():
325             lines.append(next(self._line_iter))
326         return lines
327 
328     def _consume_to_next_section(self) -> List[str]:
329         self._consume_empty()
330         lines = []
331         while not self._is_section_break():
332             lines.append(next(self._line_iter))
333         return lines + self._consume_empty()
334 
335     def _dedent(self, lines: List[str], full: bool = False) -> List[str]:
336         if full:
337             return [line.lstrip() for line in lines]
338         else:
339             min_indent = self._get_min_indent(lines)
340             return [line[min_indent:] for line in lines]
341 
342     def _escape_args_and_kwargs(self, name: str) -> str:
343         if name.endswith('_') and getattr(self._config, 'strip_signature_backslash', False):
344             name = name[:-1] + r'\_'
345 
346         if name[:2] == '**':
347             return r'\*\*' + name[2:]
348         elif name[:1] == '*':
349             return r'\*' + name[1:]
350         else:
351             return name
352 
353     def _fix_field_desc(self, desc: List[str]) -> List[str]:
354         if self._is_list(desc):
355             desc = [''] + desc
356         elif desc[0].endswith('::'):
357             desc_block = desc[1:]
358             indent = self._get_indent(desc[0])
359             block_indent = self._get_initial_indent(desc_block)
360             if block_indent > indent:
361                 desc = [''] + desc
362             else:
363                 desc = ['', desc[0]] + self._indent(desc_block, 4)
364         return desc
365 
366     def _format_admonition(self, admonition: str, lines: List[str]) -> List[str]:
367         lines = self._strip_empty(lines)
368         if len(lines) == 1:
369             return ['.. %s:: %s' % (admonition, lines[0].strip()), '']
370         elif lines:
371             lines = self._indent(self._dedent(lines), 3)
372             return ['.. %s::' % admonition, ''] + lines + ['']
373         else:
374             return ['.. %s::' % admonition, '']
375 
376     def _format_block(self, prefix: str, lines: List[str], padding: str = None) -> List[str]:
377         if lines:
378             if padding is None:
379                 padding = ' ' * len(prefix)
380             result_lines = []
381             for i, line in enumerate(lines):
382                 if i == 0:
383                     result_lines.append((prefix + line).rstrip())
384                 elif line:
385                     result_lines.append(padding + line)
386                 else:
387                     result_lines.append('')
388             return result_lines
389         else:
390             return [prefix]
391 
392     def _format_docutils_params(self, fields: List[Tuple[str, str, List[str]]],
393                                 field_role: str = 'param', type_role: str = 'type'
394                                 ) -> List[str]:
395         lines = []
396         for _name, _type, _desc in fields:
397             _desc = self._strip_empty(_desc)
398             if any(_desc):
399                 _desc = self._fix_field_desc(_desc)
400                 field = ':%s %s: ' % (field_role, _name)
401                 lines.extend(self._format_block(field, _desc))
402             else:
403                 lines.append(':%s %s:' % (field_role, _name))
404 
405             if _type:
406                 lines.append(':%s %s: %s' % (type_role, _name, _type))
407         return lines + ['']
408 
409     def _format_field(self, _name: str, _type: str, _desc: List[str]) -> List[str]:
410         _desc = self._strip_empty(_desc)
411         has_desc = any(_desc)
412         separator = ' -- ' if has_desc else ''
413         if _name:
414             if _type:
415                 if '`' in _type:
416                     field = '**%s** (%s)%s' % (_name, _type, separator)
417                 else:
418                     field = '**%s** (*%s*)%s' % (_name, _type, separator)
419             else:
420                 field = '**%s**%s' % (_name, separator)
421         elif _type:
422             if '`' in _type:
423                 field = '%s%s' % (_type, separator)
424             else:
425                 field = '*%s*%s' % (_type, separator)
426         else:
427             field = ''
428 
429         if has_desc:
430             _desc = self._fix_field_desc(_desc)
431             if _desc[0]:
432                 return [field + _desc[0]] + _desc[1:]
433             else:
434                 return [field] + _desc
435         else:
436             return [field]
437 
438     def _format_fields(self, field_type: str, fields: List[Tuple[str, str, List[str]]]
439                        ) -> List[str]:
440         field_type = ':%s:' % field_type.strip()
441         padding = ' ' * len(field_type)
442         multi = len(fields) > 1
443         lines = []  # type: List[str]
444         for _name, _type, _desc in fields:
445             field = self._format_field(_name, _type, _desc)
446             if multi:
447                 if lines:
448                     lines.extend(self._format_block(padding + ' * ', field))
449                 else:
450                     lines.extend(self._format_block(field_type + ' * ', field))
451             else:
452                 lines.extend(self._format_block(field_type + ' ', field))
453         if lines and lines[-1]:
454             lines.append('')
455         return lines
456 
457     def _get_current_indent(self, peek_ahead: int = 0) -> int:
458         line = self._line_iter.peek(peek_ahead + 1)[peek_ahead]
459         while line != self._line_iter.sentinel:
460             if line:
461                 return self._get_indent(line)
462             peek_ahead += 1
463             line = self._line_iter.peek(peek_ahead + 1)[peek_ahead]
464         return 0
465 
466     def _get_indent(self, line: str) -> int:
467         for i, s in enumerate(line):
468             if not s.isspace():
469                 return i
470         return len(line)
471 
472     def _get_initial_indent(self, lines: List[str]) -> int:
473         for line in lines:
474             if line:
475                 return self._get_indent(line)
476         return 0
477 
478     def _get_min_indent(self, lines: List[str]) -> int:
479         min_indent = None
480         for line in lines:
481             if line:
482                 indent = self._get_indent(line)
483                 if min_indent is None:
484                     min_indent = indent
485                 elif indent < min_indent:
486                     min_indent = indent
487         return min_indent or 0
488 
489     def _indent(self, lines: List[str], n: int = 4) -> List[str]:
490         return [(' ' * n) + line for line in lines]
491 
492     def _is_indented(self, line: str, indent: int = 1) -> bool:
493         for i, s in enumerate(line):
494             if i >= indent:
495                 return True
496             elif not s.isspace():
497                 return False
498         return False
499 
500     def _is_list(self, lines: List[str]) -> bool:
501         if not lines:
502             return False
503         if _bullet_list_regex.match(lines[0]):
504             return True
505         if _enumerated_list_regex.match(lines[0]):
506             return True
507         if len(lines) < 2 or lines[0].endswith('::'):
508             return False
509         indent = self._get_indent(lines[0])
510         next_indent = indent
511         for line in lines[1:]:
512             if line:
513                 next_indent = self._get_indent(line)
514                 break
515         return next_indent > indent
516 
517     def _is_section_header(self) -> bool:
518         section = self._line_iter.peek().lower()
519         match = _google_section_regex.match(section)
520         if match and section.strip(':') in self._sections:
521             header_indent = self._get_indent(section)
522             section_indent = self._get_current_indent(peek_ahead=1)
523             return section_indent > header_indent
524         elif self._directive_sections:
525             if _directive_regex.match(section):
526                 for directive_section in self._directive_sections:
527                     if section.startswith(directive_section):
528                         return True
529         return False
530 
531     def _is_section_break(self) -> bool:
532         line = self._line_iter.peek()
533         return (not self._line_iter.has_next() or
534                 self._is_section_header() or
535                 (self._is_in_section and
536                     line and
537                     not self._is_indented(line, self._section_indent)))
538 
539     def _load_custom_sections(self) -> None:
540         if self._config.napoleon_custom_sections is not None:
541             for entry in self._config.napoleon_custom_sections:
542                 if isinstance(entry, str):
543                     # if entry is just a label, add to sections list,
544                     # using generic section logic.
545                     self._sections[entry.lower()] = self._parse_custom_generic_section
546                 else:
547                     # otherwise, assume entry is container;
548                     # [0] is new section, [1] is the section to alias.
549                     # in the case of key mismatch, just handle as generic section.
550                     self._sections[entry[0].lower()] = \
551                         self._sections.get(entry[1].lower(),
552                                            self._parse_custom_generic_section)
553 
554     def _parse(self) -> None:
555         self._parsed_lines = self._consume_empty()
556 
557         if self._name and self._what in ('attribute', 'data', 'property'):
558             # Implicit stop using StopIteration no longer allowed in
559             # Python 3.7; see PEP 479
560             res = []  # type: List[str]
561             try:
562                 res = self._parse_attribute_docstring()
563             except StopIteration:
564                 pass
565             self._parsed_lines.extend(res)
566             return
567 
568         while self._line_iter.has_next():
569             if self._is_section_header():
570                 try:
571                     section = self._consume_section_header()
572                     self._is_in_section = True
573                     self._section_indent = self._get_current_indent()
574                     if _directive_regex.match(section):
575                         lines = [section] + self._consume_to_next_section()
576                     else:
577                         lines = self._sections[section.lower()](section)
578                 finally:
579                     self._is_in_section = False
580                     self._section_indent = 0
581             else:
582                 if not self._parsed_lines:
583                     lines = self._consume_contiguous() + self._consume_empty()
584                 else:
585                     lines = self._consume_to_next_section()
586             self._parsed_lines.extend(lines)
587 
588     def _parse_admonition(self, admonition: str, section: str) -> List[str]:
589         # type (str, str) -> List[str]
590         lines = self._consume_to_next_section()
591         return self._format_admonition(admonition, lines)
592 
593     def _parse_attribute_docstring(self) -> List[str]:
594         _type, _desc = self._consume_inline_attribute()
595         lines = self._format_field('', '', _desc)
596         if _type:
597             lines.extend(['', ':type: %s' % _type])
598         return lines
599 
600     def _parse_attributes_section(self, section: str) -> List[str]:
601         lines = []
602         for _name, _type, _desc in self._consume_fields():
603             if self._config.napoleon_use_ivar:
604                 _name = self._qualify_name(_name, self._obj)
605                 field = ':ivar %s: ' % _name
606                 lines.extend(self._format_block(field, _desc))
607                 if _type:
608                     lines.append(':vartype %s: %s' % (_name, _type))
609             else:
610                 lines.append('.. attribute:: ' + _name)
611                 if self._opt and 'noindex' in self._opt:
612                     lines.append('   :noindex:')
613                 lines.append('')
614 
615                 fields = self._format_field('', '', _desc)
616                 lines.extend(self._indent(fields, 3))
617                 if _type:
618                     lines.append('')
619                     lines.extend(self._indent([':type: %s' % _type], 3))
620                 lines.append('')
621         if self._config.napoleon_use_ivar:
622             lines.append('')
623         return lines
624 
625     def _parse_examples_section(self, section: str) -> List[str]:
626         labels = {
627             'example': _('Example'),
628             'examples': _('Examples'),
629         }
630         use_admonition = self._config.napoleon_use_admonition_for_examples
631         label = labels.get(section.lower(), section)
632         return self._parse_generic_section(label, use_admonition)
633 
634     def _parse_custom_generic_section(self, section: str) -> List[str]:
635         # for now, no admonition for simple custom sections
636         return self._parse_generic_section(section, False)
637 
638     def _parse_usage_section(self, section: str) -> List[str]:
639         header = ['.. rubric:: Usage:', '']
640         block = ['.. code-block:: python', '']
641         lines = self._consume_usage_section()
642         lines = self._indent(lines, 3)
643         return header + block + lines + ['']
644 
645     def _parse_generic_section(self, section: str, use_admonition: bool) -> List[str]:
646         lines = self._strip_empty(self._consume_to_next_section())
647         lines = self._dedent(lines)
648         if use_admonition:
649             header = '.. admonition:: %s' % section
650             lines = self._indent(lines, 3)
651         else:
652             header = '.. rubric:: %s' % section
653         if lines:
654             return [header, ''] + lines + ['']
655         else:
656             return [header, '']
657 
658     def _parse_keyword_arguments_section(self, section: str) -> List[str]:
659         fields = self._consume_fields()
660         if self._config.napoleon_use_keyword:
661             return self._format_docutils_params(
662                 fields,
663                 field_role="keyword",
664                 type_role="kwtype")
665         else:
666             return self._format_fields(_('Keyword Arguments'), fields)
667 
668     def _parse_methods_section(self, section: str) -> List[str]:
669         lines = []  # type: List[str]
670         for _name, _type, _desc in self._consume_fields(parse_type=False):
671             lines.append('.. method:: %s' % _name)
672             if self._opt and 'noindex' in self._opt:
673                 lines.append('   :noindex:')
674             if _desc:
675                 lines.extend([''] + self._indent(_desc, 3))
676             lines.append('')
677         return lines
678 
679     def _parse_notes_section(self, section: str) -> List[str]:
680         use_admonition = self._config.napoleon_use_admonition_for_notes
681         return self._parse_generic_section(_('Notes'), use_admonition)
682 
683     def _parse_other_parameters_section(self, section: str) -> List[str]:
684         return self._format_fields(_('Other Parameters'), self._consume_fields())
685 
686     def _parse_parameters_section(self, section: str) -> List[str]:
687         if self._config.napoleon_use_param:
688             # Allow to declare multiple parameters at once (ex: x, y: int)
689             fields = self._consume_fields(multiple=True)
690             return self._format_docutils_params(fields)
691         else:
692             fields = self._consume_fields()
693             return self._format_fields(_('Parameters'), fields)
694 
695     def _parse_raises_section(self, section: str) -> List[str]:
696         fields = self._consume_fields(parse_type=False, prefer_type=True)
697         lines = []  # type: List[str]
698         for _name, _type, _desc in fields:
699             m = self._name_rgx.match(_type)
700             if m and m.group('name'):
701                 _type = m.group('name')
702             _type = ' ' + _type if _type else ''
703             _desc = self._strip_empty(_desc)
704             _descs = ' ' + '\n    '.join(_desc) if any(_desc) else ''
705             lines.append(':raises%s:%s' % (_type, _descs))
706         if lines:
707             lines.append('')
708         return lines
709 
710     def _parse_references_section(self, section: str) -> List[str]:
711         use_admonition = self._config.napoleon_use_admonition_for_references
712         return self._parse_generic_section(_('References'), use_admonition)
713 
714     def _parse_returns_section(self, section: str) -> List[str]:
715         fields = self._consume_returns_section()
716         multi = len(fields) > 1
717         if multi:
718             use_rtype = False
719         else:
720             use_rtype = self._config.napoleon_use_rtype
721 
722         lines = []  # type: List[str]
723         for _name, _type, _desc in fields:
724             if use_rtype:
725                 field = self._format_field(_name, '', _desc)
726             else:
727                 field = self._format_field(_name, _type, _desc)
728 
729             if multi:
730                 if lines:
731                     lines.extend(self._format_block('          * ', field))
732                 else:
733                     lines.extend(self._format_block(':returns: * ', field))
734             else:
735                 lines.extend(self._format_block(':returns: ', field))
736                 if _type and use_rtype:
737                     lines.extend([':rtype: %s' % _type, ''])
738         if lines and lines[-1]:
739             lines.append('')
740         return lines
741 
742     def _parse_see_also_section(self, section: str) -> List[str]:
743         return self._parse_admonition('seealso', section)
744 
745     def _parse_warns_section(self, section: str) -> List[str]:
746         return self._format_fields(_('Warns'), self._consume_fields())
747 
748     def _parse_yields_section(self, section: str) -> List[str]:
749         fields = self._consume_returns_section()
750         return self._format_fields(_('Yields'), fields)
751 
752     def _partition_field_on_colon(self, line: str) -> Tuple[str, str, str]:
753         before_colon = []
754         after_colon = []
755         colon = ''
756         found_colon = False
757         for i, source in enumerate(_xref_or_code_regex.split(line)):
758             if found_colon:
759                 after_colon.append(source)
760             else:
761                 m = _single_colon_regex.search(source)
762                 if (i % 2) == 0 and m:
763                     found_colon = True
764                     colon = source[m.start(): m.end()]
765                     before_colon.append(source[:m.start()])
766                     after_colon.append(source[m.end():])
767                 else:
768                     before_colon.append(source)
769 
770         return ("".join(before_colon).strip(),
771                 colon,
772                 "".join(after_colon).strip())
773 
774     def _qualify_name(self, attr_name: str, klass: "Type") -> str:
775         if klass and '.' not in attr_name:
776             if attr_name.startswith('~'):
777                 attr_name = attr_name[1:]
778             try:
779                 q = klass.__qualname__
780             except AttributeError:
781                 q = klass.__name__
782             return '~%s.%s' % (q, attr_name)
783         return attr_name
784 
785     def _strip_empty(self, lines: List[str]) -> List[str]:
786         if lines:
787             start = -1
788             for i, line in enumerate(lines):
789                 if line:
790                     start = i
791                     break
792             if start == -1:
793                 lines = []
794             end = -1
795             for i in reversed(range(len(lines))):
796                 line = lines[i]
797                 if line:
798                     end = i
799                     break
800             if start > 0 or end + 1 < len(lines):
801                 lines = lines[start:end + 1]
802         return lines
803 
804 
805 def _recombine_set_tokens(tokens: List[str]) -> List[str]:
806     token_queue = collections.deque(tokens)
807     keywords = ("optional", "default")
808 
809     def takewhile_set(tokens):
810         open_braces = 0
811         previous_token = None
812         while True:
813             try:
814                 token = tokens.popleft()
815             except IndexError:
816                 break
817 
818             if token == ", ":
819                 previous_token = token
820                 continue
821 
822             if not token.strip():
823                 continue
824 
825             if token in keywords:
826                 tokens.appendleft(token)
827                 if previous_token is not None:
828                     tokens.appendleft(previous_token)
829                 break
830 
831             if previous_token is not None:
832                 yield previous_token
833                 previous_token = None
834 
835             if token == "{":
836                 open_braces += 1
837             elif token == "}":
838                 open_braces -= 1
839 
840             yield token
841 
842             if open_braces == 0:
843                 break
844 
845     def combine_set(tokens):
846         while True:
847             try:
848                 token = tokens.popleft()
849             except IndexError:
850                 break
851 
852             if token == "{":
853                 tokens.appendleft("{")
854                 yield "".join(takewhile_set(tokens))
855             else:
856                 yield token
857 
858     return list(combine_set(token_queue))
859 
860 
861 def _tokenize_type_spec(spec: str) -> List[str]:
862     def postprocess(item):
863         if _default_regex.match(item):
864             default = item[:7]
865             # can't be separated by anything other than a single space
866             # for now
867             other = item[8:]
868 
869             return [default, " ", other]
870         else:
871             return [item]
872 
873     tokens = list(
874         item
875         for raw_token in _token_regex.split(spec)
876         for item in postprocess(raw_token)
877         if item
878     )
879     return tokens
880 
881 
882 def _token_type(token: str, location: str = None) -> str:
883     def is_numeric(token):
884         try:
885             # use complex to make sure every numeric value is detected as literal
886             complex(token)
887         except ValueError:
888             return False
889         else:
890             return True
891 
892     if token.startswith(" ") or token.endswith(" "):
893         type_ = "delimiter"
894     elif (
895             is_numeric(token) or
896             (token.startswith("{") and token.endswith("}")) or
897             (token.startswith('"') and token.endswith('"')) or
898             (token.startswith("'") and token.endswith("'"))
899     ):
900         type_ = "literal"
901     elif token.startswith("{"):
902         logger.warning(
903             __("invalid value set (missing closing brace): %s"),
904             token,
905             location=location,
906         )
907         type_ = "literal"
908     elif token.endswith("}"):
909         logger.warning(
910             __("invalid value set (missing opening brace): %s"),
911             token,
912             location=location,
913         )
914         type_ = "literal"
915     elif token.startswith("'") or token.startswith('"'):
916         logger.warning(
917             __("malformed string literal (missing closing quote): %s"),
918             token,
919             location=location,
920         )
921         type_ = "literal"
922     elif token.endswith("'") or token.endswith('"'):
923         logger.warning(
924             __("malformed string literal (missing opening quote): %s"),
925             token,
926             location=location,
927         )
928         type_ = "literal"
929     elif token in ("optional", "default"):
930         # default is not a official keyword (yet) but supported by the
931         # reference implementation (numpydoc) and widely used
932         type_ = "control"
933     elif _xref_regex.match(token):
934         type_ = "reference"
935     else:
936         type_ = "obj"
937 
938     return type_
939 
940 
941 def _convert_numpy_type_spec(_type: str, location: str = None, translations: dict = {}) -> str:
942     def convert_obj(obj, translations, default_translation):
943         translation = translations.get(obj, obj)
944 
945         # use :class: (the default) only if obj is not a standard singleton
946         if translation in _SINGLETONS and default_translation == ":class:`%s`":
947             default_translation = ":obj:`%s`"
948         elif translation == "..." and default_translation == ":class:`%s`":
949             # allow referencing the builtin ...
950             default_translation = ":obj:`%s <Ellipsis>`"
951 
952         if _xref_regex.match(translation) is None:
953             translation = default_translation % translation
954 
955         return translation
956 
957     tokens = _tokenize_type_spec(_type)
958     combined_tokens = _recombine_set_tokens(tokens)
959     types = [
960         (token, _token_type(token, location))
961         for token in combined_tokens
962     ]
963 
964     converters = {
965         "literal": lambda x: "``%s``" % x,
966         "obj": lambda x: convert_obj(x, translations, ":class:`%s`"),
967         "control": lambda x: "*%s*" % x,
968         "delimiter": lambda x: x,
969         "reference": lambda x: x,
970     }
971 
972     converted = "".join(converters.get(type_)(token) for token, type_ in types)
973 
974     return converted
975 
976 
977 class NumpyDocstring(GoogleDocstring):
978     """Convert NumPy style docstrings to reStructuredText.
979 
980     Parameters
981     ----------
982     docstring : :obj:`str` or :obj:`list` of :obj:`str`
983         The docstring to parse, given either as a string or split into
984         individual lines.
985     config: :obj:`sphinx.ext.napoleon.Config` or :obj:`sphinx.config.Config`
986         The configuration settings to use. If not given, defaults to the
987         config object on `app`; or if `app` is not given defaults to the
988         a new :class:`sphinx.ext.napoleon.Config` object.
989 
990 
991     Other Parameters
992     ----------------
993     app : :class:`sphinx.application.Sphinx`, optional
994         Application object representing the Sphinx process.
995     what : :obj:`str`, optional
996         A string specifying the type of the object to which the docstring
997         belongs. Valid values: "module", "class", "exception", "function",
998         "method", "attribute".
999     name : :obj:`str`, optional
1000         The fully qualified name of the object.
1001     obj : module, class, exception, function, method, or attribute
1002         The object to which the docstring belongs.
1003     options : :class:`sphinx.ext.autodoc.Options`, optional
1004         The options given to the directive: an object with attributes
1005         inherited_members, undoc_members, show_inheritance and noindex that
1006         are True if the flag option of same name was given to the auto
1007         directive.
1008 
1009 
1010     Example
1011     -------
1012     >>> from sphinx.ext.napoleon import Config
1013     >>> config = Config(napoleon_use_param=True, napoleon_use_rtype=True)
1014     >>> docstring = '''One line summary.
1015     ...
1016     ... Extended description.
1017     ...
1018     ... Parameters
1019     ... ----------
1020     ... arg1 : int
1021     ...     Description of `arg1`
1022     ... arg2 : str
1023     ...     Description of `arg2`
1024     ... Returns
1025     ... -------
1026     ... str
1027     ...     Description of return value.
1028     ... '''
1029     >>> print(NumpyDocstring(docstring, config))
1030     One line summary.
1031     <BLANKLINE>
1032     Extended description.
1033     <BLANKLINE>
1034     :param arg1: Description of `arg1`
1035     :type arg1: int
1036     :param arg2: Description of `arg2`
1037     :type arg2: str
1038     <BLANKLINE>
1039     :returns: Description of return value.
1040     :rtype: str
1041     <BLANKLINE>
1042 
1043     Methods
1044     -------
1045     __str__()
1046         Return the parsed docstring in reStructuredText format.
1047 
1048         Returns
1049         -------
1050         str
1051             UTF-8 encoded version of the docstring.
1052 
1053     __unicode__()
1054         Return the parsed docstring in reStructuredText format.
1055 
1056         Returns
1057         -------
1058         unicode
1059             Unicode version of the docstring.
1060 
1061     lines()
1062         Return the parsed lines of the docstring in reStructuredText format.
1063 
1064         Returns
1065         -------
1066         list(str)
1067             The lines of the docstring in a list.
1068 
1069     """
1070     def __init__(self, docstring: Union[str, List[str]], config: SphinxConfig = None,
1071                  app: Sphinx = None, what: str = '', name: str = '',
1072                  obj: Any = None, options: Any = None) -> None:
1073         self._directive_sections = ['.. index::']
1074         super().__init__(docstring, config, app, what, name, obj, options)
1075 
1076     def _get_location(self) -> str:
1077         try:
1078             filepath = inspect.getfile(self._obj) if self._obj is not None else None
1079         except TypeError:
1080             filepath = None
1081         name = self._name
1082 
1083         if filepath is None and name is None:
1084             return None
1085         elif filepath is None:
1086             filepath = ""
1087 
1088         return ":".join([filepath, "docstring of %s" % name])
1089 
1090     def _escape_args_and_kwargs(self, name: str) -> str:
1091         func = super()._escape_args_and_kwargs
1092 
1093         if ", " in name:
1094             return ", ".join(func(param) for param in name.split(", "))
1095         else:
1096             return func(name)
1097 
1098     def _consume_field(self, parse_type: bool = True, prefer_type: bool = False
1099                        ) -> Tuple[str, str, List[str]]:
1100         line = next(self._line_iter)
1101         if parse_type:
1102             _name, _, _type = self._partition_field_on_colon(line)
1103         else:
1104             _name, _type = line, ''
1105         _name, _type = _name.strip(), _type.strip()
1106         _name = self._escape_args_and_kwargs(_name)
1107         if self._config.napoleon_preprocess_types:
1108             _type = _convert_numpy_type_spec(
1109                 _type,
1110                 location=self._get_location(),
1111                 translations=self._config.napoleon_type_aliases or {},
1112             )
1113 
1114         if prefer_type and not _type:
1115             _type, _name = _name, _type
1116         indent = self._get_indent(line) + 1
1117         _desc = self._dedent(self._consume_indented_block(indent))
1118         _desc = self.__class__(_desc, self._config).lines()
1119         return _name, _type, _desc
1120 
1121     def _consume_returns_section(self) -> List[Tuple[str, str, List[str]]]:
1122         return self._consume_fields(prefer_type=True)
1123 
1124     def _consume_section_header(self) -> str:
1125         section = next(self._line_iter)
1126         if not _directive_regex.match(section):
1127             # Consume the header underline
1128             next(self._line_iter)
1129         return section
1130 
1131     def _is_section_break(self) -> bool:
1132         line1, line2 = self._line_iter.peek(2)
1133         return (not self._line_iter.has_next() or
1134                 self._is_section_header() or
1135                 ['', ''] == [line1, line2] or
1136                 (self._is_in_section and
1137                     line1 and
1138                     not self._is_indented(line1, self._section_indent)))
1139 
1140     def _is_section_header(self) -> bool:
1141         section, underline = self._line_iter.peek(2)
1142         section = section.lower()
1143         if section in self._sections and isinstance(underline, str):
1144             return bool(_numpy_section_regex.match(underline))
1145         elif self._directive_sections:
1146             if _directive_regex.match(section):
1147                 for directive_section in self._directive_sections:
1148                     if section.startswith(directive_section):
1149                         return True
1150         return False
1151 
1152     def _parse_see_also_section(self, section: str) -> List[str]:
1153         lines = self._consume_to_next_section()
1154         try:
1155             return self._parse_numpydoc_see_also_section(lines)
1156         except ValueError:
1157             return self._format_admonition('seealso', lines)
1158 
1159     def _parse_numpydoc_see_also_section(self, content: List[str]) -> List[str]:
1160         """
1161         Derived from the NumpyDoc implementation of _parse_see_also.
1162 
1163         See Also
1164         --------
1165         func_name : Descriptive text
1166             continued text
1167         another_func_name : Descriptive text
1168         func_name1, func_name2, :meth:`func_name`, func_name3
1169 
1170         """
1171         items = []
1172 
1173         def parse_item_name(text: str) -> Tuple[str, str]:
1174             """Match ':role:`name`' or 'name'"""
1175             m = self._name_rgx.match(text)
1176             if m:
1177                 g = m.groups()
1178                 if g[1] is None:
1179                     return g[3], None
1180                 else:
1181                     return g[2], g[1]
1182             raise ValueError("%s is not a item name" % text)
1183 
1184         def push_item(name: str, rest: List[str]) -> None:
1185             if not name:
1186                 return
1187             name, role = parse_item_name(name)
1188             items.append((name, list(rest), role))
1189             del rest[:]
1190 
1191         current_func = None
1192         rest = []  # type: List[str]
1193 
1194         for line in content:
1195             if not line.strip():
1196                 continue
1197 
1198             m = self._name_rgx.match(line)
1199             if m and line[m.end():].strip().startswith(':'):
1200                 push_item(current_func, rest)
1201                 current_func, line = line[:m.end()], line[m.end():]
1202                 rest = [line.split(':', 1)[1].strip()]
1203                 if not rest[0]:
1204                     rest = []
1205             elif not line.startswith(' '):
1206                 push_item(current_func, rest)
1207                 current_func = None
1208                 if ',' in line:
1209                     for func in line.split(','):
1210                         if func.strip():
1211                             push_item(func, [])
1212                 elif line.strip():
1213                     current_func = line
1214             elif current_func is not None:
1215                 rest.append(line.strip())
1216         push_item(current_func, rest)
1217 
1218         if not items:
1219             return []
1220 
1221         roles = {
1222             'method': 'meth',
1223             'meth': 'meth',
1224             'function': 'func',
1225             'func': 'func',
1226             'class': 'class',
1227             'exception': 'exc',
1228             'exc': 'exc',
1229             'object': 'obj',
1230             'obj': 'obj',
1231             'module': 'mod',
1232             'mod': 'mod',
1233             'data': 'data',
1234             'constant': 'const',
1235             'const': 'const',
1236             'attribute': 'attr',
1237             'attr': 'attr'
1238         }
1239         if self._what is None:
1240             func_role = 'obj'
1241         else:
1242             func_role = roles.get(self._what, '')
1243         lines = []  # type: List[str]
1244         last_had_desc = True
1245         for func, desc, role in items:
1246             if role:
1247                 link = ':%s:`%s`' % (role, func)
1248             elif func_role:
1249                 link = ':%s:`%s`' % (func_role, func)
1250             else:
1251                 link = "`%s`_" % func
1252             if desc or last_had_desc:
1253                 lines += ['']
1254                 lines += [link]
1255             else:
1256                 lines[-1] += ", %s" % link
1257             if desc:
1258                 lines += self._indent([' '.join(desc)])
1259                 last_had_desc = True
1260             else:
1261                 last_had_desc = False
1262         lines += ['']
1263 
1264         return self._format_admonition('seealso', lines)

</code><intended_behavior>Ensure that the napoleon extension properly interprets and translates complex types in docstrings into the correct reStructuredText format without causing syntax warnings.</intended_behavior>, <file>sphinx/ext/napoleon/__init__.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2     sphinx.ext.napoleon
3     ~~~~~~~~~~~~~~~~~~~
4 
5     Support for NumPy and Google style docstrings.
6 
7     :copyright: Copyright 2007-2020 by the Sphinx team, see AUTHORS.
8     :license: BSD, see LICENSE for details.
9 """
10 
11 from typing import Any, Dict, List
12 
13 from sphinx import __display_version__ as __version__
14 from sphinx.application import Sphinx
15 from sphinx.ext.napoleon.docstring import GoogleDocstring, NumpyDocstring
16 from sphinx.util import inspect
17 
18 
19 class Config:
20     """Sphinx napoleon extension settings in `conf.py`.
21 
22     Listed below are all the settings used by napoleon and their default
23     values. These settings can be changed in the Sphinx `conf.py` file. Make
24     sure that "sphinx.ext.napoleon" is enabled in `conf.py`::
25 
26         # conf.py
27 
28         # Add any Sphinx extension module names here, as strings
29         extensions = ['sphinx.ext.napoleon']
30 
31         # Napoleon settings
32         napoleon_google_docstring = True
33         napoleon_numpy_docstring = True
34         napoleon_include_init_with_doc = False
35         napoleon_include_private_with_doc = False
36         napoleon_include_special_with_doc = False
37         napoleon_use_admonition_for_examples = False
38         napoleon_use_admonition_for_notes = False
39         napoleon_use_admonition_for_references = False
40         napoleon_use_ivar = False
41         napoleon_use_param = True
42         napoleon_use_rtype = True
43         napoleon_use_keyword = True
44         napoleon_preprocess_types = False
45         napoleon_type_aliases = None
46         napoleon_custom_sections = None
47 
48     .. _Google style:
49        https://google.github.io/styleguide/pyguide.html
50     .. _NumPy style:
51        https://github.com/numpy/numpy/blob/master/doc/HOWTO_DOCUMENT.rst.txt
52 
53     Attributes
54     ----------
55     napoleon_google_docstring : :obj:`bool` (Defaults to True)
56         True to parse `Google style`_ docstrings. False to disable support
57         for Google style docstrings.
58     napoleon_numpy_docstring : :obj:`bool` (Defaults to True)
59         True to parse `NumPy style`_ docstrings. False to disable support
60         for NumPy style docstrings.
61     napoleon_include_init_with_doc : :obj:`bool` (Defaults to False)
62         True to list ``__init___`` docstrings separately from the class
63         docstring. False to fall back to Sphinx's default behavior, which
64         considers the ``__init___`` docstring as part of the class
65         documentation.
66 
67         **If True**::
68 
69             def __init__(self):
70                 \"\"\"
71                 This will be included in the docs because it has a docstring
72                 \"\"\"
73 
74             def __init__(self):
75                 # This will NOT be included in the docs
76 
77     napoleon_include_private_with_doc : :obj:`bool` (Defaults to False)
78         True to include private members (like ``_membername``) with docstrings
79         in the documentation. False to fall back to Sphinx's default behavior.
80 
81         **If True**::
82 
83             def _included(self):
84                 \"\"\"
85                 This will be included in the docs because it has a docstring
86                 \"\"\"
87                 pass
88 
89             def _skipped(self):
90                 # This will NOT be included in the docs
91                 pass
92 
93     napoleon_include_special_with_doc : :obj:`bool` (Defaults to False)
94         True to include special members (like ``__membername__``) with
95         docstrings in the documentation. False to fall back to Sphinx's
96         default behavior.
97 
98         **If True**::
99 
100             def __str__(self):
101                 \"\"\"
102                 This will be included in the docs because it has a docstring
103                 \"\"\"
104                 return unicode(self).encode('utf-8')
105 
106             def __unicode__(self):
107                 # This will NOT be included in the docs
108                 return unicode(self.__class__.__name__)
109 
110     napoleon_use_admonition_for_examples : :obj:`bool` (Defaults to False)
111         True to use the ``.. admonition::`` directive for the **Example** and
112         **Examples** sections. False to use the ``.. rubric::`` directive
113         instead. One may look better than the other depending on what HTML
114         theme is used.
115 
116         This `NumPy style`_ snippet will be converted as follows::
117 
118             Example
119             -------
120             This is just a quick example
121 
122         **If True**::
123 
124             .. admonition:: Example
125 
126                This is just a quick example
127 
128         **If False**::
129 
130             .. rubric:: Example
131 
132             This is just a quick example
133 
134     napoleon_use_admonition_for_notes : :obj:`bool` (Defaults to False)
135         True to use the ``.. admonition::`` directive for **Notes** sections.
136         False to use the ``.. rubric::`` directive instead.
137 
138         Note
139         ----
140         The singular **Note** section will always be converted to a
141         ``.. note::`` directive.
142 
143         See Also
144         --------
145         :attr:`napoleon_use_admonition_for_examples`
146 
147     napoleon_use_admonition_for_references : :obj:`bool` (Defaults to False)
148         True to use the ``.. admonition::`` directive for **References**
149         sections. False to use the ``.. rubric::`` directive instead.
150 
151         See Also
152         --------
153         :attr:`napoleon_use_admonition_for_examples`
154 
155     napoleon_use_ivar : :obj:`bool` (Defaults to False)
156         True to use the ``:ivar:`` role for instance variables. False to use
157         the ``.. attribute::`` directive instead.
158 
159         This `NumPy style`_ snippet will be converted as follows::
160 
161             Attributes
162             ----------
163             attr1 : int
164                 Description of `attr1`
165 
166         **If True**::
167 
168             :ivar attr1: Description of `attr1`
169             :vartype attr1: int
170 
171         **If False**::
172 
173             .. attribute:: attr1
174 
175                Description of `attr1`
176 
177                :type: int
178 
179     napoleon_use_param : :obj:`bool` (Defaults to True)
180         True to use a ``:param:`` role for each function parameter. False to
181         use a single ``:parameters:`` role for all the parameters.
182 
183         This `NumPy style`_ snippet will be converted as follows::
184 
185             Parameters
186             ----------
187             arg1 : str
188                 Description of `arg1`
189             arg2 : int, optional
190                 Description of `arg2`, defaults to 0
191 
192         **If True**::
193 
194             :param arg1: Description of `arg1`
195             :type arg1: str
196             :param arg2: Description of `arg2`, defaults to 0
197             :type arg2: int, optional
198 
199         **If False**::
200 
201             :parameters: * **arg1** (*str*) --
202                            Description of `arg1`
203                          * **arg2** (*int, optional*) --
204                            Description of `arg2`, defaults to 0
205 
206     napoleon_use_keyword : :obj:`bool` (Defaults to True)
207         True to use a ``:keyword:`` role for each function keyword argument.
208         False to use a single ``:keyword arguments:`` role for all the
209         keywords.
210 
211         This behaves similarly to  :attr:`napoleon_use_param`. Note unlike
212         docutils, ``:keyword:`` and ``:param:`` will not be treated the same
213         way - there will be a separate "Keyword Arguments" section, rendered
214         in the same fashion as "Parameters" section (type links created if
215         possible)
216 
217         See Also
218         --------
219         :attr:`napoleon_use_param`
220 
221     napoleon_use_rtype : :obj:`bool` (Defaults to True)
222         True to use the ``:rtype:`` role for the return type. False to output
223         the return type inline with the description.
224 
225         This `NumPy style`_ snippet will be converted as follows::
226 
227             Returns
228             -------
229             bool
230                 True if successful, False otherwise
231 
232         **If True**::
233 
234             :returns: True if successful, False otherwise
235             :rtype: bool
236 
237         **If False**::
238 
239             :returns: *bool* -- True if successful, False otherwise
240 
241     napoleon_preprocess_types : :obj:`bool` (Defaults to False)
242         Enable the type preprocessor for numpy style docstrings.
243 
244     napoleon_type_aliases : :obj:`dict` (Defaults to None)
245         Add a mapping of strings to string, translating types in numpy
246         style docstrings. Only works if ``napoleon_preprocess_types = True``.
247 
248     napoleon_custom_sections : :obj:`list` (Defaults to None)
249         Add a list of custom sections to include, expanding the list of parsed sections.
250 
251         The entries can either be strings or tuples, depending on the intention:
252           * To create a custom "generic" section, just pass a string.
253           * To create an alias for an existing section, pass a tuple containing the
254             alias name and the original, in that order.
255 
256         If an entry is just a string, it is interpreted as a header for a generic
257         section. If the entry is a tuple/list/indexed container, the first entry
258         is the name of the section, the second is the section key to emulate.
259 
260 
261     """
262     _config_values = {
263         'napoleon_google_docstring': (True, 'env'),
264         'napoleon_numpy_docstring': (True, 'env'),
265         'napoleon_include_init_with_doc': (False, 'env'),
266         'napoleon_include_private_with_doc': (False, 'env'),
267         'napoleon_include_special_with_doc': (False, 'env'),
268         'napoleon_use_admonition_for_examples': (False, 'env'),
269         'napoleon_use_admonition_for_notes': (False, 'env'),
270         'napoleon_use_admonition_for_references': (False, 'env'),
271         'napoleon_use_ivar': (False, 'env'),
272         'napoleon_use_param': (True, 'env'),
273         'napoleon_use_rtype': (True, 'env'),
274         'napoleon_use_keyword': (True, 'env'),
275         'napoleon_preprocess_types': (False, 'env'),
276         'napoleon_type_aliases': (None, 'env'),
277         'napoleon_custom_sections': (None, 'env')
278     }
279 
280     def __init__(self, **settings: Any) -> None:
281         for name, (default, rebuild) in self._config_values.items():
282             setattr(self, name, default)
283         for name, value in settings.items():
284             setattr(self, name, value)
285 
286 
287 def setup(app: Sphinx) -> Dict[str, Any]:
288     """Sphinx extension setup function.
289 
290     When the extension is loaded, Sphinx imports this module and executes
291     the ``setup()`` function, which in turn notifies Sphinx of everything
292     the extension offers.
293 
294     Parameters
295     ----------
296     app : sphinx.application.Sphinx
297         Application object representing the Sphinx process
298 
299     See Also
300     --------
301     `The Sphinx documentation on Extensions
302     <http://sphinx-doc.org/extensions.html>`_
303 
304     `The Extension Tutorial <http://sphinx-doc.org/extdev/tutorial.html>`_
305 
306     `The Extension API <http://sphinx-doc.org/extdev/appapi.html>`_
307 
308     """
309     if not isinstance(app, Sphinx):
310         # probably called by tests
311         return {'version': __version__, 'parallel_read_safe': True}
312 
313     _patch_python_domain()
314 
315     app.setup_extension('sphinx.ext.autodoc')
316     app.connect('autodoc-process-docstring', _process_docstring)
317     app.connect('autodoc-skip-member', _skip_member)
318 
319     for name, (default, rebuild) in Config._config_values.items():
320         app.add_config_value(name, default, rebuild)
321     return {'version': __version__, 'parallel_read_safe': True}
322 
323 
324 def _patch_python_domain() -> None:
325     try:
326         from sphinx.domains.python import PyTypedField
327     except ImportError:
328         pass
329     else:
330         import sphinx.domains.python
331         from sphinx.locale import _
332         for doc_field in sphinx.domains.python.PyObject.doc_field_types:
333             if doc_field.name == 'parameter':
334                 doc_field.names = ('param', 'parameter', 'arg', 'argument')
335                 break
336         sphinx.domains.python.PyObject.doc_field_types.append(
337             PyTypedField('keyword', label=_('Keyword Arguments'),
338                          names=('keyword', 'kwarg', 'kwparam'),
339                          typerolename='obj', typenames=('paramtype', 'kwtype'),
340                          can_collapse=True))
341 
342 
343 def _process_docstring(app: Sphinx, what: str, name: str, obj: Any,
344                        options: Any, lines: List[str]) -> None:
345     """Process the docstring for a given python object.
346 
347     Called when autodoc has read and processed a docstring. `lines` is a list
348     of docstring lines that `_process_docstring` modifies in place to change
349     what Sphinx outputs.
350 
351     The following settings in conf.py control what styles of docstrings will
352     be parsed:
353 
354     * ``napoleon_google_docstring`` -- parse Google style docstrings
355     * ``napoleon_numpy_docstring`` -- parse NumPy style docstrings
356 
357     Parameters
358     ----------
359     app : sphinx.application.Sphinx
360         Application object representing the Sphinx process.
361     what : str
362         A string specifying the type of the object to which the docstring
363         belongs. Valid values: "module", "class", "exception", "function",
364         "method", "attribute".
365     name : str
366         The fully qualified name of the object.
367     obj : module, class, exception, function, method, or attribute
368         The object to which the docstring belongs.
369     options : sphinx.ext.autodoc.Options
370         The options given to the directive: an object with attributes
371         inherited_members, undoc_members, show_inheritance and noindex that
372         are True if the flag option of same name was given to the auto
373         directive.
374     lines : list of str
375         The lines of the docstring, see above.
376 
377         .. note:: `lines` is modified *in place*
378 
379     """
380     result_lines = lines
381     docstring = None  # type: GoogleDocstring
382     if app.config.napoleon_numpy_docstring:
383         docstring = NumpyDocstring(result_lines, app.config, app, what, name,
384                                    obj, options)
385         result_lines = docstring.lines()
386     if app.config.napoleon_google_docstring:
387         docstring = GoogleDocstring(result_lines, app.config, app, what, name,
388                                     obj, options)
389         result_lines = docstring.lines()
390     lines[:] = result_lines[:]
391 
392 
393 def _skip_member(app: Sphinx, what: str, name: str, obj: Any,
394                  skip: bool, options: Any) -> bool:
395     """Determine if private and special class members are included in docs.
396 
397     The following settings in conf.py determine if private and special class
398     members or init methods are included in the generated documentation:
399 
400     * ``napoleon_include_init_with_doc`` --
401       include init methods if they have docstrings
402     * ``napoleon_include_private_with_doc`` --
403       include private members if they have docstrings
404     * ``napoleon_include_special_with_doc`` --
405       include special members if they have docstrings
406 
407     Parameters
408     ----------
409     app : sphinx.application.Sphinx
410         Application object representing the Sphinx process
411     what : str
412         A string specifying the type of the object to which the member
413         belongs. Valid values: "module", "class", "exception", "function",
414         "method", "attribute".
415     name : str
416         The name of the member.
417     obj : module, class, exception, function, method, or attribute.
418         For example, if the member is the __init__ method of class A, then
419         `obj` will be `A.__init__`.
420     skip : bool
421         A boolean indicating if autodoc will skip this member if `_skip_member`
422         does not override the decision
423     options : sphinx.ext.autodoc.Options
424         The options given to the directive: an object with attributes
425         inherited_members, undoc_members, show_inheritance and noindex that
426         are True if the flag option of same name was given to the auto
427         directive.
428 
429     Returns
430     -------
431     bool
432         True if the member should be skipped during creation of the docs,
433         False if it should be included in the docs.
434 
435     """
436     has_doc = getattr(obj, '__doc__', False)
437     is_member = (what == 'class' or what == 'exception' or what == 'module')
438     if name != '__weakref__' and has_doc and is_member:
439         cls_is_owner = False
440         if what == 'class' or what == 'exception':
441             qualname = getattr(obj, '__qualname__', '')
442             cls_path, _, _ = qualname.rpartition('.')
443             if cls_path:
444                 try:
445                     if '.' in cls_path:
446                         import importlib
447                         import functools
448 
449                         mod = importlib.import_module(obj.__module__)
450                         mod_path = cls_path.split('.')
451                         cls = functools.reduce(getattr, mod_path, mod)
452                     else:
453                         cls = inspect.unwrap(obj).__globals__[cls_path]
454                 except Exception:
455                     cls_is_owner = False
456                 else:
457                     cls_is_owner = (cls and hasattr(cls, name) and  # type: ignore
458                                     name in cls.__dict__)
459             else:
460                 cls_is_owner = False
461 
462         if what == 'module' or cls_is_owner:
463             is_init = (name == '__init__')
464             is_special = (not is_init and name.startswith('__') and
465                           name.endswith('__'))
466             is_private = (not is_init and not is_special and
467                           name.startswith('_'))
468             inc_init = app.config.napoleon_include_init_with_doc
469             inc_special = app.config.napoleon_include_special_with_doc
470             inc_private = app.config.napoleon_include_private_with_doc
471             if ((is_special and inc_special) or
472                     (is_private and inc_private) or
473                     (is_init and inc_init)):
474                 return False
475     return None

</code><intended_behavior>Adjust parsing rules or the way certain annotations are handled to prevent misinterpretation that leads to warnings.</intended_behavior>, <file>doc/usage/extensions/example_google.py</file>
<class>None</class>
<method>None</method>
<code>
1 """Example Google style docstrings.
2 
3 This module demonstrates documentation as specified by the `Google Python
4 Style Guide`_. Docstrings may extend over multiple lines. Sections are created
5 with a section header and a colon followed by a block of indented text.
6 
7 Example:
8     Examples can be given using either the ``Example`` or ``Examples``
9     sections. Sections support any reStructuredText formatting, including
10     literal blocks::
11 
12         $ python example_google.py
13 
14 Section breaks are created by resuming unindented text. Section breaks
15 are also implicitly created anytime a new section starts.
16 
17 Attributes:
18     module_level_variable1 (int): Module level variables may be documented in
19         either the ``Attributes`` section of the module docstring, or in an
20         inline docstring immediately following the variable.
21 
22         Either form is acceptable, but the two should not be mixed. Choose
23         one convention to document module level variables and be consistent
24         with it.
25 
26 Todo:
27     * For module TODOs
28     * You have to also use ``sphinx.ext.todo`` extension
29 
30 .. _Google Python Style Guide:
31    https://google.github.io/styleguide/pyguide.html
32 
33 """
34 
35 module_level_variable1 = 12345
36 
37 module_level_variable2 = 98765
38 """int: Module level variable documented inline.
39 
40 The docstring may span multiple lines. The type may optionally be specified
41 on the first line, separated by a colon.
42 """
43 
44 
45 def function_with_types_in_docstring(param1, param2):
46     """Example function with types documented in the docstring.
47 
48     `PEP 484`_ type annotations are supported. If attribute, parameter, and
49     return types are annotated according to `PEP 484`_, they do not need to be
50     included in the docstring:
51 
52     Args:
53         param1 (int): The first parameter.
54         param2 (str): The second parameter.
55 
56     Returns:
57         bool: The return value. True for success, False otherwise.
58 
59     .. _PEP 484:
60         https://www.python.org/dev/peps/pep-0484/
61 
62     """
63 
64 
65 def function_with_pep484_type_annotations(param1: int, param2: str) -> bool:
66     """Example function with PEP 484 type annotations.
67 
68     Args:
69         param1: The first parameter.
70         param2: The second parameter.
71 
72     Returns:
73         The return value. True for success, False otherwise.
74 
75     """
76 
77 
78 def module_level_function(param1, param2=None, *args, **kwargs):
79     """This is an example of a module level function.
80 
81     Function parameters should be documented in the ``Args`` section. The name
82     of each parameter is required. The type and description of each parameter
83     is optional, but should be included if not obvious.
84 
85     If ``*args`` or ``**kwargs`` are accepted,
86     they should be listed as ``*args`` and ``**kwargs``.
87 
88     The format for a parameter is::
89 
90         name (type): description
91             The description may span multiple lines. Following
92             lines should be indented. The "(type)" is optional.
93 
94             Multiple paragraphs are supported in parameter
95             descriptions.
96 
97     Args:
98         param1 (int): The first parameter.
99         param2 (:obj:`str`, optional): The second parameter. Defaults to None.
100             Second line of description should be indented.
101         *args: Variable length argument list.
102         **kwargs: Arbitrary keyword arguments.
103 
104     Returns:
105         bool: True if successful, False otherwise.
106 
107         The return type is optional and may be specified at the beginning of
108         the ``Returns`` section followed by a colon.
109 
110         The ``Returns`` section may span multiple lines and paragraphs.
111         Following lines should be indented to match the first line.
112 
113         The ``Returns`` section supports any reStructuredText formatting,
114         including literal blocks::
115 
116             {
117                 'param1': param1,
118                 'param2': param2
119             }
120 
121     Raises:
122         AttributeError: The ``Raises`` section is a list of all exceptions
123             that are relevant to the interface.
124         ValueError: If `param2` is equal to `param1`.
125 
126     """
127     if param1 == param2:
128         raise ValueError('param1 may not be equal to param2')
129     return True
130 
131 
132 def example_generator(n):
133     """Generators have a ``Yields`` section instead of a ``Returns`` section.
134 
135     Args:
136         n (int): The upper limit of the range to generate, from 0 to `n` - 1.
137 
138     Yields:
139         int: The next number in the range of 0 to `n` - 1.
140 
141     Examples:
142         Examples should be written in doctest format, and should illustrate how
143         to use the function.
144 
145         >>> print([i for i in example_generator(4)])
146         [0, 1, 2, 3]
147 
148     """
149     for i in range(n):
150         yield i
151 
152 
153 class ExampleError(Exception):
154     """Exceptions are documented in the same way as classes.
155 
156     The __init__ method may be documented in either the class level
157     docstring, or as a docstring on the __init__ method itself.
158 
159     Either form is acceptable, but the two should not be mixed. Choose one
160     convention to document the __init__ method and be consistent with it.
161 
162     Note:
163         Do not include the `self` parameter in the ``Args`` section.
164 
165     Args:
166         msg (str): Human readable string describing the exception.
167         code (:obj:`int`, optional): Error code.
168 
169     Attributes:
170         msg (str): Human readable string describing the exception.
171         code (int): Exception error code.
172 
173     """
174 
175     def __init__(self, msg, code):
176         self.msg = msg
177         self.code = code
178 
179 
180 class ExampleClass:
181     """The summary line for a class docstring should fit on one line.
182 
183     If the class has public attributes, they may be documented here
184     in an ``Attributes`` section and follow the same formatting as a
185     function's ``Args`` section. Alternatively, attributes may be documented
186     inline with the attribute's declaration (see __init__ method below).
187 
188     Properties created with the ``@property`` decorator should be documented
189     in the property's getter method.
190 
191     Attributes:
192         attr1 (str): Description of `attr1`.
193         attr2 (:obj:`int`, optional): Description of `attr2`.
194 
195     """
196 
197     def __init__(self, param1, param2, param3):
198         """Example of docstring on the __init__ method.
199 
200         The __init__ method may be documented in either the class level
201         docstring, or as a docstring on the __init__ method itself.
202 
203         Either form is acceptable, but the two should not be mixed. Choose one
204         convention to document the __init__ method and be consistent with it.
205 
206         Note:
207             Do not include the `self` parameter in the ``Args`` section.
208 
209         Args:
210             param1 (str): Description of `param1`.
211             param2 (:obj:`int`, optional): Description of `param2`. Multiple
212                 lines are supported.
213             param3 (list(str)): Description of `param3`.
214 
215         """
216         self.attr1 = param1
217         self.attr2 = param2
218         self.attr3 = param3  #: Doc comment *inline* with attribute
219 
220         #: list(str): Doc comment *before* attribute, with type specified
221         self.attr4 = ['attr4']
222 
223         self.attr5 = None
224         """str: Docstring *after* attribute, with type specified."""
225 
226     @property
227     def readonly_property(self):
228         """str: Properties should be documented in their getter method."""
229         return 'readonly_property'
230 
231     @property
232     def readwrite_property(self):
233         """list(str): Properties with both a getter and setter
234         should only be documented in their getter method.
235 
236         If the setter method contains notable behavior, it should be
237         mentioned here.
238         """
239         return ['readwrite_property']
240 
241     @readwrite_property.setter
242     def readwrite_property(self, value):
243         value
244 
245     def example_method(self, param1, param2):
246         """Class methods are similar to regular functions.
247 
248         Note:
249             Do not include the `self` parameter in the ``Args`` section.
250 
251         Args:
252             param1: The first parameter.
253             param2: The second parameter.
254 
255         Returns:
256             True if successful, False otherwise.
257 
258         """
259         return True
260 
261     def __special__(self):
262         """By default special members with docstrings are not included.
263 
264         Special members are any methods or attributes that start with and
265         end with a double underscore. Any special member with a docstring
266         will be included in the output, if
267         ``napoleon_include_special_with_doc`` is set to True.
268 
269         This behavior can be enabled by changing the following setting in
270         Sphinx's conf.py::
271 
272             napoleon_include_special_with_doc = True
273 
274         """
275         pass
276 
277     def __special_without_docstring__(self):
278         pass
279 
280     def _private(self):
281         """By default private members are not included.
282 
283         Private members are any methods or attributes that start with an
284         underscore and are *not* special. By default they are not included
285         in the output.
286 
287         This behavior can be changed such that private members *are* included
288         by changing the following setting in Sphinx's conf.py::
289 
290             napoleon_include_private_with_doc = True
291 
292         """
293         pass
294 
295     def _private_without_docstring(self):
296         pass

</code><intended_behavior>Review documentation examples for handling generics in docstrings to ensure correct parsing and rendering without syntax warnings.</intended_behavior>, <file>doc/usage/extensions/example_numpy.py</file>
<class>None</class>
<method>None</method>
<code>
1 """Example NumPy style docstrings.
2 
3 This module demonstrates documentation as specified by the `NumPy
4 Documentation HOWTO`_. Docstrings may extend over multiple lines. Sections
5 are created with a section header followed by an underline of equal length.
6 
7 Example
8 -------
9 Examples can be given using either the ``Example`` or ``Examples``
10 sections. Sections support any reStructuredText formatting, including
11 literal blocks::
12 
13     $ python example_numpy.py
14 
15 
16 Section breaks are created with two blank lines. Section breaks are also
17 implicitly created anytime a new section starts. Section bodies *may* be
18 indented:
19 
20 Notes
21 -----
22     This is an example of an indented section. It's like any other section,
23     but the body is indented to help it stand out from surrounding text.
24 
25 If a section is indented, then a section break is created by
26 resuming unindented text.
27 
28 Attributes
29 ----------
30 module_level_variable1 : int
31     Module level variables may be documented in either the ``Attributes``
32     section of the module docstring, or in an inline docstring immediately
33     following the variable.
34 
35     Either form is acceptable, but the two should not be mixed. Choose
36     one convention to document module level variables and be consistent
37     with it.
38 
39 
40 .. _NumPy Documentation HOWTO:
41    https://github.com/numpy/numpy/blob/master/doc/HOWTO_DOCUMENT.rst.txt
42 
43 """
44 
45 module_level_variable1 = 12345
46 
47 module_level_variable2 = 98765
48 """int: Module level variable documented inline.
49 
50 The docstring may span multiple lines. The type may optionally be specified
51 on the first line, separated by a colon.
52 """
53 
54 
55 def function_with_types_in_docstring(param1, param2):
56     """Example function with types documented in the docstring.
57 
58     `PEP 484`_ type annotations are supported. If attribute, parameter, and
59     return types are annotated according to `PEP 484`_, they do not need to be
60     included in the docstring:
61 
62     Parameters
63     ----------
64     param1 : int
65         The first parameter.
66     param2 : str
67         The second parameter.
68 
69     Returns
70     -------
71     bool
72         True if successful, False otherwise.
73 
74     .. _PEP 484:
75         https://www.python.org/dev/peps/pep-0484/
76 
77     """
78 
79 
80 def function_with_pep484_type_annotations(param1: int, param2: str) -> bool:
81     """Example function with PEP 484 type annotations.
82 
83     The return type must be duplicated in the docstring to comply
84     with the NumPy docstring style.
85 
86     Parameters
87     ----------
88     param1
89         The first parameter.
90     param2
91         The second parameter.
92 
93     Returns
94     -------
95     bool
96         True if successful, False otherwise.
97 
98     """
99 
100 
101 def module_level_function(param1, param2=None, *args, **kwargs):
102     """This is an example of a module level function.
103 
104     Function parameters should be documented in the ``Parameters`` section.
105     The name of each parameter is required. The type and description of each
106     parameter is optional, but should be included if not obvious.
107 
108     If ``*args`` or ``**kwargs`` are accepted,
109     they should be listed as ``*args`` and ``**kwargs``.
110 
111     The format for a parameter is::
112 
113         name : type
114             description
115 
116             The description may span multiple lines. Following lines
117             should be indented to match the first line of the description.
118             The ": type" is optional.
119 
120             Multiple paragraphs are supported in parameter
121             descriptions.
122 
123     Parameters
124     ----------
125     param1 : int
126         The first parameter.
127     param2 : :obj:`str`, optional
128         The second parameter.
129     *args
130         Variable length argument list.
131     **kwargs
132         Arbitrary keyword arguments.
133 
134     Returns
135     -------
136     bool
137         True if successful, False otherwise.
138 
139         The return type is not optional. The ``Returns`` section may span
140         multiple lines and paragraphs. Following lines should be indented to
141         match the first line of the description.
142 
143         The ``Returns`` section supports any reStructuredText formatting,
144         including literal blocks::
145 
146             {
147                 'param1': param1,
148                 'param2': param2
149             }
150 
151     Raises
152     ------
153     AttributeError
154         The ``Raises`` section is a list of all exceptions
155         that are relevant to the interface.
156     ValueError
157         If `param2` is equal to `param1`.
158 
159     """
160     if param1 == param2:
161         raise ValueError('param1 may not be equal to param2')
162     return True
163 
164 
165 def example_generator(n):
166     """Generators have a ``Yields`` section instead of a ``Returns`` section.
167 
168     Parameters
169     ----------
170     n : int
171         The upper limit of the range to generate, from 0 to `n` - 1.
172 
173     Yields
174     ------
175     int
176         The next number in the range of 0 to `n` - 1.
177 
178     Examples
179     --------
180     Examples should be written in doctest format, and should illustrate how
181     to use the function.
182 
183     >>> print([i for i in example_generator(4)])
184     [0, 1, 2, 3]
185 
186     """
187     for i in range(n):
188         yield i
189 
190 
191 class ExampleError(Exception):
192     """Exceptions are documented in the same way as classes.
193 
194     The __init__ method may be documented in either the class level
195     docstring, or as a docstring on the __init__ method itself.
196 
197     Either form is acceptable, but the two should not be mixed. Choose one
198     convention to document the __init__ method and be consistent with it.
199 
200     Note
201     ----
202     Do not include the `self` parameter in the ``Parameters`` section.
203 
204     Parameters
205     ----------
206     msg : str
207         Human readable string describing the exception.
208     code : :obj:`int`, optional
209         Numeric error code.
210 
211     Attributes
212     ----------
213     msg : str
214         Human readable string describing the exception.
215     code : int
216         Numeric error code.
217 
218     """
219 
220     def __init__(self, msg, code):
221         self.msg = msg
222         self.code = code
223 
224 
225 class ExampleClass:
226     """The summary line for a class docstring should fit on one line.
227 
228     If the class has public attributes, they may be documented here
229     in an ``Attributes`` section and follow the same formatting as a
230     function's ``Args`` section. Alternatively, attributes may be documented
231     inline with the attribute's declaration (see __init__ method below).
232 
233     Properties created with the ``@property`` decorator should be documented
234     in the property's getter method.
235 
236     Attributes
237     ----------
238     attr1 : str
239         Description of `attr1`.
240     attr2 : :obj:`int`, optional
241         Description of `attr2`.
242 
243     """
244 
245     def __init__(self, param1, param2, param3):
246         """Example of docstring on the __init__ method.
247 
248         The __init__ method may be documented in either the class level
249         docstring, or as a docstring on the __init__ method itself.
250 
251         Either form is acceptable, but the two should not be mixed. Choose one
252         convention to document the __init__ method and be consistent with it.
253 
254         Note
255         ----
256         Do not include the `self` parameter in the ``Parameters`` section.
257 
258         Parameters
259         ----------
260         param1 : str
261             Description of `param1`.
262         param2 : list(str)
263             Description of `param2`. Multiple
264             lines are supported.
265         param3 : :obj:`int`, optional
266             Description of `param3`.
267 
268         """
269         self.attr1 = param1
270         self.attr2 = param2
271         self.attr3 = param3  #: Doc comment *inline* with attribute
272 
273         #: list(str): Doc comment *before* attribute, with type specified
274         self.attr4 = ["attr4"]
275 
276         self.attr5 = None
277         """str: Docstring *after* attribute, with type specified."""
278 
279     @property
280     def readonly_property(self):
281         """str: Properties should be documented in their getter method."""
282         return "readonly_property"
283 
284     @property
285     def readwrite_property(self):
286         """list(str): Properties with both a getter and setter
287         should only be documented in their getter method.
288 
289         If the setter method contains notable behavior, it should be
290         mentioned here.
291         """
292         return ["readwrite_property"]
293 
294     @readwrite_property.setter
295     def readwrite_property(self, value):
296         value
297 
298     def example_method(self, param1, param2):
299         """Class methods are similar to regular functions.
300 
301         Note
302         ----
303         Do not include the `self` parameter in the ``Parameters`` section.
304 
305         Parameters
306         ----------
307         param1
308             The first parameter.
309         param2
310             The second parameter.
311 
312         Returns
313         -------
314         bool
315             True if successful, False otherwise.
316 
317         """
318         return True
319 
320     def __special__(self):
321         """By default special members with docstrings are not included.
322 
323         Special members are any methods or attributes that start with and
324         end with a double underscore. Any special member with a docstring
325         will be included in the output, if
326         ``napoleon_include_special_with_doc`` is set to True.
327 
328         This behavior can be enabled by changing the following setting in
329         Sphinx's conf.py::
330 
331             napoleon_include_special_with_doc = True
332 
333         """
334         pass
335 
336     def __special_without_docstring__(self):
337         pass
338 
339     def _private(self):
340         """By default private members are not included.
341 
342         Private members are any methods or attributes that start with an
343         underscore and are *not* special. By default they are not included
344         in the output.
345 
346         This behavior can be changed such that private members *are* included
347         by changing the following setting in Sphinx's conf.py::
348 
349             napoleon_include_private_with_doc = True
350 
351         """
352         pass
353 
354     def _private_without_docstring(self):
355         pass

</code><intended_behavior>Ensure documentation practices for generics and class variables in docstrings are correctly interpreted by Sphinx, particularly in the example files.</intended_behavior>]
2025-10-18 18:32:24.411 | INFO     | Search completed. Bug locations: [<file>sphinx/ext/napoleon/docstring.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2     sphinx.ext.napoleon.docstring
3     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
4 
5 
6     Classes for docstring parsing and formatting.
7 
8 
9     :copyright: Copyright 2007-2020 by the Sphinx team, see AUTHORS.
10     :license: BSD, see LICENSE for details.
11 """
12 
13 import collections
14 import inspect
15 import re
16 from functools import partial
17 from typing import Any, Callable, Dict, List, Tuple, Union
18 
19 from sphinx.application import Sphinx
20 from sphinx.config import Config as SphinxConfig
21 from sphinx.ext.napoleon.iterators import modify_iter
22 from sphinx.locale import _, __
23 from sphinx.util import logging
24 
25 if False:
26     # For type annotation
27     from typing import Type  # for python3.5.1
28 
29 
30 logger = logging.getLogger(__name__)
31 
32 _directive_regex = re.compile(r'\.\. \S+::')
33 _google_section_regex = re.compile(r'^(\s|\w)+:\s*$')
34 _google_typed_arg_regex = re.compile(r'\s*(.+?)\s*\(\s*(.*[^\s]+)\s*\)')
35 _numpy_section_regex = re.compile(r'^[=\-`:\'"~^_*+#<>]{2,}\s*$')
36 _single_colon_regex = re.compile(r'(?<!:):(?!:)')
37 _xref_or_code_regex = re.compile(
38     r'((?::(?:[a-zA-Z0-9]+[\-_+:.])*[a-zA-Z0-9]+:`.+?`)|'
39     r'(?:``.+?``))')
40 _xref_regex = re.compile(
41     r'(?:(?::(?:[a-zA-Z0-9]+[\-_+:.])*[a-zA-Z0-9]+:)?`.+?`)'
42 )
43 _bullet_list_regex = re.compile(r'^(\*|\+|\-)(\s+\S|\s*$)')
44 _enumerated_list_regex = re.compile(
45     r'^(?P<paren>\()?'
46     r'(\d+|#|[ivxlcdm]+|[IVXLCDM]+|[a-zA-Z])'
47     r'(?(paren)\)|\.)(\s+\S|\s*$)')
48 _token_regex = re.compile(
49     r"(,\sor\s|\sor\s|\sof\s|:\s|\sto\s|,\sand\s|\sand\s|,\s"
50     r"|[{]|[}]"
51     r'|"(?:\\"|[^"])*"'
52     r"|'(?:\\'|[^'])*')"
53 )
54 _default_regex = re.compile(
55     r"^default[^_0-9A-Za-z].*$",
56 )
57 _SINGLETONS = ("None", "True", "False", "Ellipsis")
58 
59 
60 class GoogleDocstring:
61     """Convert Google style docstrings to reStructuredText.
62 
63     Parameters
64     ----------
65     docstring : :obj:`str` or :obj:`list` of :obj:`str`
66         The docstring to parse, given either as a string or split into
67         individual lines.
68     config: :obj:`sphinx.ext.napoleon.Config` or :obj:`sphinx.config.Config`
69         The configuration settings to use. If not given, defaults to the
70         config object on `app`; or if `app` is not given defaults to the
71         a new :class:`sphinx.ext.napoleon.Config` object.
72 
73 
74     Other Parameters
75     ----------------
76     app : :class:`sphinx.application.Sphinx`, optional
77         Application object representing the Sphinx process.
78     what : :obj:`str`, optional
79         A string specifying the type of the object to which the docstring
80         belongs. Valid values: "module", "class", "exception", "function",
81         "method", "attribute".
82     name : :obj:`str`, optional
83         The fully qualified name of the object.
84     obj : module, class, exception, function, method, or attribute
85         The object to which the docstring belongs.
86     options : :class:`sphinx.ext.autodoc.Options`, optional
87         The options given to the directive: an object with attributes
88         inherited_members, undoc_members, show_inheritance and noindex that
89         are True if the flag option of same name was given to the auto
90         directive.
91 
92 
93     Example
94     -------
95     >>> from sphinx.ext.napoleon import Config
96     >>> config = Config(napoleon_use_param=True, napoleon_use_rtype=True)
97     >>> docstring = '''One line summary.
98     ...
99     ... Extended description.
100     ...
101     ... Args:
102     ...   arg1(int): Description of `arg1`
103     ...   arg2(str): Description of `arg2`
104     ... Returns:
105     ...   str: Description of return value.
106     ... '''
107     >>> print(GoogleDocstring(docstring, config))
108     One line summary.
109     <BLANKLINE>
110     Extended description.
111     <BLANKLINE>
112     :param arg1: Description of `arg1`
113     :type arg1: int
114     :param arg2: Description of `arg2`
115     :type arg2: str
116     <BLANKLINE>
117     :returns: Description of return value.
118     :rtype: str
119     <BLANKLINE>
120 
121     """
122 
123     _name_rgx = re.compile(r"^\s*((?::(?P<role>\S+):)?`(?P<name>~?[a-zA-Z0-9_.-]+)`|"
124                            r" (?P<name2>~?[a-zA-Z0-9_.-]+))\s*", re.X)
125 
126     def __init__(self, docstring: Union[str, List[str]], config: SphinxConfig = None,
127                  app: Sphinx = None, what: str = '', name: str = '',
128                  obj: Any = None, options: Any = None) -> None:
129         self._config = config
130         self._app = app
131 
132         if not self._config:
133             from sphinx.ext.napoleon import Config
134             self._config = self._app.config if self._app else Config()  # type: ignore
135 
136         if not what:
137             if inspect.isclass(obj):
138                 what = 'class'
139             elif inspect.ismodule(obj):
140                 what = 'module'
141             elif callable(obj):
142                 what = 'function'
143             else:
144                 what = 'object'
145 
146         self._what = what
147         self._name = name
148         self._obj = obj
149         self._opt = options
150         if isinstance(docstring, str):
151             lines = docstring.splitlines()
152         else:
153             lines = docstring
154         self._line_iter = modify_iter(lines, modifier=lambda s: s.rstrip())
155         self._parsed_lines = []  # type: List[str]
156         self._is_in_section = False
157         self._section_indent = 0
158         if not hasattr(self, '_directive_sections'):
159             self._directive_sections = []  # type: List[str]
160         if not hasattr(self, '_sections'):
161             self._sections = {
162                 'args': self._parse_parameters_section,
163                 'arguments': self._parse_parameters_section,
164                 'attention': partial(self._parse_admonition, 'attention'),
165                 'attributes': self._parse_attributes_section,
166                 'caution': partial(self._parse_admonition, 'caution'),
167                 'danger': partial(self._parse_admonition, 'danger'),
168                 'error': partial(self._parse_admonition, 'error'),
169                 'example': self._parse_examples_section,
170                 'examples': self._parse_examples_section,
171                 'hint': partial(self._parse_admonition, 'hint'),
172                 'important': partial(self._parse_admonition, 'important'),
173                 'keyword args': self._parse_keyword_arguments_section,
174                 'keyword arguments': self._parse_keyword_arguments_section,
175                 'methods': self._parse_methods_section,
176                 'note': partial(self._parse_admonition, 'note'),
177                 'notes': self._parse_notes_section,
178                 'other parameters': self._parse_other_parameters_section,
179                 'parameters': self._parse_parameters_section,
180                 'return': self._parse_returns_section,
181                 'returns': self._parse_returns_section,
182                 'raise': self._parse_raises_section,
183                 'raises': self._parse_raises_section,
184                 'references': self._parse_references_section,
185                 'see also': self._parse_see_also_section,
186                 'tip': partial(self._parse_admonition, 'tip'),
187                 'todo': partial(self._parse_admonition, 'todo'),
188                 'warning': partial(self._parse_admonition, 'warning'),
189                 'warnings': partial(self._parse_admonition, 'warning'),
190                 'warn': self._parse_warns_section,
191                 'warns': self._parse_warns_section,
192                 'yield': self._parse_yields_section,
193                 'yields': self._parse_yields_section,
194             }  # type: Dict[str, Callable]
195 
196         self._load_custom_sections()
197 
198         self._parse()
199 
200     def __str__(self) -> str:
201         """Return the parsed docstring in reStructuredText format.
202 
203         Returns
204         -------
205         unicode
206             Unicode version of the docstring.
207 
208         """
209         return '\n'.join(self.lines())
210 
211     def lines(self) -> List[str]:
212         """Return the parsed lines of the docstring in reStructuredText format.
213 
214         Returns
215         -------
216         list(str)
217             The lines of the docstring in a list.
218 
219         """
220         return self._parsed_lines
221 
222     def _consume_indented_block(self, indent: int = 1) -> List[str]:
223         lines = []
224         line = self._line_iter.peek()
225         while(not self._is_section_break() and
226               (not line or self._is_indented(line, indent))):
227             lines.append(next(self._line_iter))
228             line = self._line_iter.peek()
229         return lines
230 
231     def _consume_contiguous(self) -> List[str]:
232         lines = []
233         while (self._line_iter.has_next() and
234                self._line_iter.peek() and
235                not self._is_section_header()):
236             lines.append(next(self._line_iter))
237         return lines
238 
239     def _consume_empty(self) -> List[str]:
240         lines = []
241         line = self._line_iter.peek()
242         while self._line_iter.has_next() and not line:
243             lines.append(next(self._line_iter))
244             line = self._line_iter.peek()
245         return lines
246 
247     def _consume_field(self, parse_type: bool = True, prefer_type: bool = False
248                        ) -> Tuple[str, str, List[str]]:
249         line = next(self._line_iter)
250 
251         before, colon, after = self._partition_field_on_colon(line)
252         _name, _type, _desc = before, '', after
253 
254         if parse_type:
255             match = _google_typed_arg_regex.match(before)
256             if match:
257                 _name = match.group(1)
258                 _type = match.group(2)
259 
260         _name = self._escape_args_and_kwargs(_name)
261 
262         if prefer_type and not _type:
263             _type, _name = _name, _type
264         indent = self._get_indent(line) + 1
265         _descs = [_desc] + self._dedent(self._consume_indented_block(indent))
266         _descs = self.__class__(_descs, self._config).lines()
267         return _name, _type, _descs
268 
269     def _consume_fields(self, parse_type: bool = True, prefer_type: bool = False,
270                         multiple: bool = False) -> List[Tuple[str, str, List[str]]]:
271         self._consume_empty()
272         fields = []
273         while not self._is_section_break():
274             _name, _type, _desc = self._consume_field(parse_type, prefer_type)
275             if multiple and _name:
276                 for name in _name.split(","):
277                     fields.append((name.strip(), _type, _desc))
278             elif _name or _type or _desc:
279                 fields.append((_name, _type, _desc,))
280         return fields
281 
282     def _consume_inline_attribute(self) -> Tuple[str, List[str]]:
283         line = next(self._line_iter)
284         _type, colon, _desc = self._partition_field_on_colon(line)
285         if not colon or not _desc:
286             _type, _desc = _desc, _type
287             _desc += colon
288         _descs = [_desc] + self._dedent(self._consume_to_end())
289         _descs = self.__class__(_descs, self._config).lines()
290         return _type, _descs
291 
292     def _consume_returns_section(self) -> List[Tuple[str, str, List[str]]]:
293         lines = self._dedent(self._consume_to_next_section())
294         if lines:
295             before, colon, after = self._partition_field_on_colon(lines[0])
296             _name, _type, _desc = '', '', lines
297 
298             if colon:
299                 if after:
300                     _desc = [after] + lines[1:]
301                 else:
302                     _desc = lines[1:]
303 
304                 _type = before
305 
306             _desc = self.__class__(_desc, self._config).lines()
307             return [(_name, _type, _desc,)]
308         else:
309             return []
310 
311     def _consume_usage_section(self) -> List[str]:
312         lines = self._dedent(self._consume_to_next_section())
313         return lines
314 
315     def _consume_section_header(self) -> str:
316         section = next(self._line_iter)
317         stripped_section = section.strip(':')
318         if stripped_section.lower() in self._sections:
319             section = stripped_section
320         return section
321 
322     def _consume_to_end(self) -> List[str]:
323         lines = []
324         while self._line_iter.has_next():
325             lines.append(next(self._line_iter))
326         return lines
327 
328     def _consume_to_next_section(self) -> List[str]:
329         self._consume_empty()
330         lines = []
331         while not self._is_section_break():
332             lines.append(next(self._line_iter))
333         return lines + self._consume_empty()
334 
335     def _dedent(self, lines: List[str], full: bool = False) -> List[str]:
336         if full:
337             return [line.lstrip() for line in lines]
338         else:
339             min_indent = self._get_min_indent(lines)
340             return [line[min_indent:] for line in lines]
341 
342     def _escape_args_and_kwargs(self, name: str) -> str:
343         if name.endswith('_') and getattr(self._config, 'strip_signature_backslash', False):
344             name = name[:-1] + r'\_'
345 
346         if name[:2] == '**':
347             return r'\*\*' + name[2:]
348         elif name[:1] == '*':
349             return r'\*' + name[1:]
350         else:
351             return name
352 
353     def _fix_field_desc(self, desc: List[str]) -> List[str]:
354         if self._is_list(desc):
355             desc = [''] + desc
356         elif desc[0].endswith('::'):
357             desc_block = desc[1:]
358             indent = self._get_indent(desc[0])
359             block_indent = self._get_initial_indent(desc_block)
360             if block_indent > indent:
361                 desc = [''] + desc
362             else:
363                 desc = ['', desc[0]] + self._indent(desc_block, 4)
364         return desc
365 
366     def _format_admonition(self, admonition: str, lines: List[str]) -> List[str]:
367         lines = self._strip_empty(lines)
368         if len(lines) == 1:
369             return ['.. %s:: %s' % (admonition, lines[0].strip()), '']
370         elif lines:
371             lines = self._indent(self._dedent(lines), 3)
372             return ['.. %s::' % admonition, ''] + lines + ['']
373         else:
374             return ['.. %s::' % admonition, '']
375 
376     def _format_block(self, prefix: str, lines: List[str], padding: str = None) -> List[str]:
377         if lines:
378             if padding is None:
379                 padding = ' ' * len(prefix)
380             result_lines = []
381             for i, line in enumerate(lines):
382                 if i == 0:
383                     result_lines.append((prefix + line).rstrip())
384                 elif line:
385                     result_lines.append(padding + line)
386                 else:
387                     result_lines.append('')
388             return result_lines
389         else:
390             return [prefix]
391 
392     def _format_docutils_params(self, fields: List[Tuple[str, str, List[str]]],
393                                 field_role: str = 'param', type_role: str = 'type'
394                                 ) -> List[str]:
395         lines = []
396         for _name, _type, _desc in fields:
397             _desc = self._strip_empty(_desc)
398             if any(_desc):
399                 _desc = self._fix_field_desc(_desc)
400                 field = ':%s %s: ' % (field_role, _name)
401                 lines.extend(self._format_block(field, _desc))
402             else:
403                 lines.append(':%s %s:' % (field_role, _name))
404 
405             if _type:
406                 lines.append(':%s %s: %s' % (type_role, _name, _type))
407         return lines + ['']
408 
409     def _format_field(self, _name: str, _type: str, _desc: List[str]) -> List[str]:
410         _desc = self._strip_empty(_desc)
411         has_desc = any(_desc)
412         separator = ' -- ' if has_desc else ''
413         if _name:
414             if _type:
415                 if '`' in _type:
416                     field = '**%s** (%s)%s' % (_name, _type, separator)
417                 else:
418                     field = '**%s** (*%s*)%s' % (_name, _type, separator)
419             else:
420                 field = '**%s**%s' % (_name, separator)
421         elif _type:
422             if '`' in _type:
423                 field = '%s%s' % (_type, separator)
424             else:
425                 field = '*%s*%s' % (_type, separator)
426         else:
427             field = ''
428 
429         if has_desc:
430             _desc = self._fix_field_desc(_desc)
431             if _desc[0]:
432                 return [field + _desc[0]] + _desc[1:]
433             else:
434                 return [field] + _desc
435         else:
436             return [field]
437 
438     def _format_fields(self, field_type: str, fields: List[Tuple[str, str, List[str]]]
439                        ) -> List[str]:
440         field_type = ':%s:' % field_type.strip()
441         padding = ' ' * len(field_type)
442         multi = len(fields) > 1
443         lines = []  # type: List[str]
444         for _name, _type, _desc in fields:
445             field = self._format_field(_name, _type, _desc)
446             if multi:
447                 if lines:
448                     lines.extend(self._format_block(padding + ' * ', field))
449                 else:
450                     lines.extend(self._format_block(field_type + ' * ', field))
451             else:
452                 lines.extend(self._format_block(field_type + ' ', field))
453         if lines and lines[-1]:
454             lines.append('')
455         return lines
456 
457     def _get_current_indent(self, peek_ahead: int = 0) -> int:
458         line = self._line_iter.peek(peek_ahead + 1)[peek_ahead]
459         while line != self._line_iter.sentinel:
460             if line:
461                 return self._get_indent(line)
462             peek_ahead += 1
463             line = self._line_iter.peek(peek_ahead + 1)[peek_ahead]
464         return 0
465 
466     def _get_indent(self, line: str) -> int:
467         for i, s in enumerate(line):
468             if not s.isspace():
469                 return i
470         return len(line)
471 
472     def _get_initial_indent(self, lines: List[str]) -> int:
473         for line in lines:
474             if line:
475                 return self._get_indent(line)
476         return 0
477 
478     def _get_min_indent(self, lines: List[str]) -> int:
479         min_indent = None
480         for line in lines:
481             if line:
482                 indent = self._get_indent(line)
483                 if min_indent is None:
484                     min_indent = indent
485                 elif indent < min_indent:
486                     min_indent = indent
487         return min_indent or 0
488 
489     def _indent(self, lines: List[str], n: int = 4) -> List[str]:
490         return [(' ' * n) + line for line in lines]
491 
492     def _is_indented(self, line: str, indent: int = 1) -> bool:
493         for i, s in enumerate(line):
494             if i >= indent:
495                 return True
496             elif not s.isspace():
497                 return False
498         return False
499 
500     def _is_list(self, lines: List[str]) -> bool:
501         if not lines:
502             return False
503         if _bullet_list_regex.match(lines[0]):
504             return True
505         if _enumerated_list_regex.match(lines[0]):
506             return True
507         if len(lines) < 2 or lines[0].endswith('::'):
508             return False
509         indent = self._get_indent(lines[0])
510         next_indent = indent
511         for line in lines[1:]:
512             if line:
513                 next_indent = self._get_indent(line)
514                 break
515         return next_indent > indent
516 
517     def _is_section_header(self) -> bool:
518         section = self._line_iter.peek().lower()
519         match = _google_section_regex.match(section)
520         if match and section.strip(':') in self._sections:
521             header_indent = self._get_indent(section)
522             section_indent = self._get_current_indent(peek_ahead=1)
523             return section_indent > header_indent
524         elif self._directive_sections:
525             if _directive_regex.match(section):
526                 for directive_section in self._directive_sections:
527                     if section.startswith(directive_section):
528                         return True
529         return False
530 
531     def _is_section_break(self) -> bool:
532         line = self._line_iter.peek()
533         return (not self._line_iter.has_next() or
534                 self._is_section_header() or
535                 (self._is_in_section and
536                     line and
537                     not self._is_indented(line, self._section_indent)))
538 
539     def _load_custom_sections(self) -> None:
540         if self._config.napoleon_custom_sections is not None:
541             for entry in self._config.napoleon_custom_sections:
542                 if isinstance(entry, str):
543                     # if entry is just a label, add to sections list,
544                     # using generic section logic.
545                     self._sections[entry.lower()] = self._parse_custom_generic_section
546                 else:
547                     # otherwise, assume entry is container;
548                     # [0] is new section, [1] is the section to alias.
549                     # in the case of key mismatch, just handle as generic section.
550                     self._sections[entry[0].lower()] = \
551                         self._sections.get(entry[1].lower(),
552                                            self._parse_custom_generic_section)
553 
554     def _parse(self) -> None:
555         self._parsed_lines = self._consume_empty()
556 
557         if self._name and self._what in ('attribute', 'data', 'property'):
558             # Implicit stop using StopIteration no longer allowed in
559             # Python 3.7; see PEP 479
560             res = []  # type: List[str]
561             try:
562                 res = self._parse_attribute_docstring()
563             except StopIteration:
564                 pass
565             self._parsed_lines.extend(res)
566             return
567 
568         while self._line_iter.has_next():
569             if self._is_section_header():
570                 try:
571                     section = self._consume_section_header()
572                     self._is_in_section = True
573                     self._section_indent = self._get_current_indent()
574                     if _directive_regex.match(section):
575                         lines = [section] + self._consume_to_next_section()
576                     else:
577                         lines = self._sections[section.lower()](section)
578                 finally:
579                     self._is_in_section = False
580                     self._section_indent = 0
581             else:
582                 if not self._parsed_lines:
583                     lines = self._consume_contiguous() + self._consume_empty()
584                 else:
585                     lines = self._consume_to_next_section()
586             self._parsed_lines.extend(lines)
587 
588     def _parse_admonition(self, admonition: str, section: str) -> List[str]:
589         # type (str, str) -> List[str]
590         lines = self._consume_to_next_section()
591         return self._format_admonition(admonition, lines)
592 
593     def _parse_attribute_docstring(self) -> List[str]:
594         _type, _desc = self._consume_inline_attribute()
595         lines = self._format_field('', '', _desc)
596         if _type:
597             lines.extend(['', ':type: %s' % _type])
598         return lines
599 
600     def _parse_attributes_section(self, section: str) -> List[str]:
601         lines = []
602         for _name, _type, _desc in self._consume_fields():
603             if self._config.napoleon_use_ivar:
604                 _name = self._qualify_name(_name, self._obj)
605                 field = ':ivar %s: ' % _name
606                 lines.extend(self._format_block(field, _desc))
607                 if _type:
608                     lines.append(':vartype %s: %s' % (_name, _type))
609             else:
610                 lines.append('.. attribute:: ' + _name)
611                 if self._opt and 'noindex' in self._opt:
612                     lines.append('   :noindex:')
613                 lines.append('')
614 
615                 fields = self._format_field('', '', _desc)
616                 lines.extend(self._indent(fields, 3))
617                 if _type:
618                     lines.append('')
619                     lines.extend(self._indent([':type: %s' % _type], 3))
620                 lines.append('')
621         if self._config.napoleon_use_ivar:
622             lines.append('')
623         return lines
624 
625     def _parse_examples_section(self, section: str) -> List[str]:
626         labels = {
627             'example': _('Example'),
628             'examples': _('Examples'),
629         }
630         use_admonition = self._config.napoleon_use_admonition_for_examples
631         label = labels.get(section.lower(), section)
632         return self._parse_generic_section(label, use_admonition)
633 
634     def _parse_custom_generic_section(self, section: str) -> List[str]:
635         # for now, no admonition for simple custom sections
636         return self._parse_generic_section(section, False)
637 
638     def _parse_usage_section(self, section: str) -> List[str]:
639         header = ['.. rubric:: Usage:', '']
640         block = ['.. code-block:: python', '']
641         lines = self._consume_usage_section()
642         lines = self._indent(lines, 3)
643         return header + block + lines + ['']
644 
645     def _parse_generic_section(self, section: str, use_admonition: bool) -> List[str]:
646         lines = self._strip_empty(self._consume_to_next_section())
647         lines = self._dedent(lines)
648         if use_admonition:
649             header = '.. admonition:: %s' % section
650             lines = self._indent(lines, 3)
651         else:
652             header = '.. rubric:: %s' % section
653         if lines:
654             return [header, ''] + lines + ['']
655         else:
656             return [header, '']
657 
658     def _parse_keyword_arguments_section(self, section: str) -> List[str]:
659         fields = self._consume_fields()
660         if self._config.napoleon_use_keyword:
661             return self._format_docutils_params(
662                 fields,
663                 field_role="keyword",
664                 type_role="kwtype")
665         else:
666             return self._format_fields(_('Keyword Arguments'), fields)
667 
668     def _parse_methods_section(self, section: str) -> List[str]:
669         lines = []  # type: List[str]
670         for _name, _type, _desc in self._consume_fields(parse_type=False):
671             lines.append('.. method:: %s' % _name)
672             if self._opt and 'noindex' in self._opt:
673                 lines.append('   :noindex:')
674             if _desc:
675                 lines.extend([''] + self._indent(_desc, 3))
676             lines.append('')
677         return lines
678 
679     def _parse_notes_section(self, section: str) -> List[str]:
680         use_admonition = self._config.napoleon_use_admonition_for_notes
681         return self._parse_generic_section(_('Notes'), use_admonition)
682 
683     def _parse_other_parameters_section(self, section: str) -> List[str]:
684         return self._format_fields(_('Other Parameters'), self._consume_fields())
685 
686     def _parse_parameters_section(self, section: str) -> List[str]:
687         if self._config.napoleon_use_param:
688             # Allow to declare multiple parameters at once (ex: x, y: int)
689             fields = self._consume_fields(multiple=True)
690             return self._format_docutils_params(fields)
691         else:
692             fields = self._consume_fields()
693             return self._format_fields(_('Parameters'), fields)
694 
695     def _parse_raises_section(self, section: str) -> List[str]:
696         fields = self._consume_fields(parse_type=False, prefer_type=True)
697         lines = []  # type: List[str]
698         for _name, _type, _desc in fields:
699             m = self._name_rgx.match(_type)
700             if m and m.group('name'):
701                 _type = m.group('name')
702             _type = ' ' + _type if _type else ''
703             _desc = self._strip_empty(_desc)
704             _descs = ' ' + '\n    '.join(_desc) if any(_desc) else ''
705             lines.append(':raises%s:%s' % (_type, _descs))
706         if lines:
707             lines.append('')
708         return lines
709 
710     def _parse_references_section(self, section: str) -> List[str]:
711         use_admonition = self._config.napoleon_use_admonition_for_references
712         return self._parse_generic_section(_('References'), use_admonition)
713 
714     def _parse_returns_section(self, section: str) -> List[str]:
715         fields = self._consume_returns_section()
716         multi = len(fields) > 1
717         if multi:
718             use_rtype = False
719         else:
720             use_rtype = self._config.napoleon_use_rtype
721 
722         lines = []  # type: List[str]
723         for _name, _type, _desc in fields:
724             if use_rtype:
725                 field = self._format_field(_name, '', _desc)
726             else:
727                 field = self._format_field(_name, _type, _desc)
728 
729             if multi:
730                 if lines:
731                     lines.extend(self._format_block('          * ', field))
732                 else:
733                     lines.extend(self._format_block(':returns: * ', field))
734             else:
735                 lines.extend(self._format_block(':returns: ', field))
736                 if _type and use_rtype:
737                     lines.extend([':rtype: %s' % _type, ''])
738         if lines and lines[-1]:
739             lines.append('')
740         return lines
741 
742     def _parse_see_also_section(self, section: str) -> List[str]:
743         return self._parse_admonition('seealso', section)
744 
745     def _parse_warns_section(self, section: str) -> List[str]:
746         return self._format_fields(_('Warns'), self._consume_fields())
747 
748     def _parse_yields_section(self, section: str) -> List[str]:
749         fields = self._consume_returns_section()
750         return self._format_fields(_('Yields'), fields)
751 
752     def _partition_field_on_colon(self, line: str) -> Tuple[str, str, str]:
753         before_colon = []
754         after_colon = []
755         colon = ''
756         found_colon = False
757         for i, source in enumerate(_xref_or_code_regex.split(line)):
758             if found_colon:
759                 after_colon.append(source)
760             else:
761                 m = _single_colon_regex.search(source)
762                 if (i % 2) == 0 and m:
763                     found_colon = True
764                     colon = source[m.start(): m.end()]
765                     before_colon.append(source[:m.start()])
766                     after_colon.append(source[m.end():])
767                 else:
768                     before_colon.append(source)
769 
770         return ("".join(before_colon).strip(),
771                 colon,
772                 "".join(after_colon).strip())
773 
774     def _qualify_name(self, attr_name: str, klass: "Type") -> str:
775         if klass and '.' not in attr_name:
776             if attr_name.startswith('~'):
777                 attr_name = attr_name[1:]
778             try:
779                 q = klass.__qualname__
780             except AttributeError:
781                 q = klass.__name__
782             return '~%s.%s' % (q, attr_name)
783         return attr_name
784 
785     def _strip_empty(self, lines: List[str]) -> List[str]:
786         if lines:
787             start = -1
788             for i, line in enumerate(lines):
789                 if line:
790                     start = i
791                     break
792             if start == -1:
793                 lines = []
794             end = -1
795             for i in reversed(range(len(lines))):
796                 line = lines[i]
797                 if line:
798                     end = i
799                     break
800             if start > 0 or end + 1 < len(lines):
801                 lines = lines[start:end + 1]
802         return lines
803 
804 
805 def _recombine_set_tokens(tokens: List[str]) -> List[str]:
806     token_queue = collections.deque(tokens)
807     keywords = ("optional", "default")
808 
809     def takewhile_set(tokens):
810         open_braces = 0
811         previous_token = None
812         while True:
813             try:
814                 token = tokens.popleft()
815             except IndexError:
816                 break
817 
818             if token == ", ":
819                 previous_token = token
820                 continue
821 
822             if not token.strip():
823                 continue
824 
825             if token in keywords:
826                 tokens.appendleft(token)
827                 if previous_token is not None:
828                     tokens.appendleft(previous_token)
829                 break
830 
831             if previous_token is not None:
832                 yield previous_token
833                 previous_token = None
834 
835             if token == "{":
836                 open_braces += 1
837             elif token == "}":
838                 open_braces -= 1
839 
840             yield token
841 
842             if open_braces == 0:
843                 break
844 
845     def combine_set(tokens):
846         while True:
847             try:
848                 token = tokens.popleft()
849             except IndexError:
850                 break
851 
852             if token == "{":
853                 tokens.appendleft("{")
854                 yield "".join(takewhile_set(tokens))
855             else:
856                 yield token
857 
858     return list(combine_set(token_queue))
859 
860 
861 def _tokenize_type_spec(spec: str) -> List[str]:
862     def postprocess(item):
863         if _default_regex.match(item):
864             default = item[:7]
865             # can't be separated by anything other than a single space
866             # for now
867             other = item[8:]
868 
869             return [default, " ", other]
870         else:
871             return [item]
872 
873     tokens = list(
874         item
875         for raw_token in _token_regex.split(spec)
876         for item in postprocess(raw_token)
877         if item
878     )
879     return tokens
880 
881 
882 def _token_type(token: str, location: str = None) -> str:
883     def is_numeric(token):
884         try:
885             # use complex to make sure every numeric value is detected as literal
886             complex(token)
887         except ValueError:
888             return False
889         else:
890             return True
891 
892     if token.startswith(" ") or token.endswith(" "):
893         type_ = "delimiter"
894     elif (
895             is_numeric(token) or
896             (token.startswith("{") and token.endswith("}")) or
897             (token.startswith('"') and token.endswith('"')) or
898             (token.startswith("'") and token.endswith("'"))
899     ):
900         type_ = "literal"
901     elif token.startswith("{"):
902         logger.warning(
903             __("invalid value set (missing closing brace): %s"),
904             token,
905             location=location,
906         )
907         type_ = "literal"
908     elif token.endswith("}"):
909         logger.warning(
910             __("invalid value set (missing opening brace): %s"),
911             token,
912             location=location,
913         )
914         type_ = "literal"
915     elif token.startswith("'") or token.startswith('"'):
916         logger.warning(
917             __("malformed string literal (missing closing quote): %s"),
918             token,
919             location=location,
920         )
921         type_ = "literal"
922     elif token.endswith("'") or token.endswith('"'):
923         logger.warning(
924             __("malformed string literal (missing opening quote): %s"),
925             token,
926             location=location,
927         )
928         type_ = "literal"
929     elif token in ("optional", "default"):
930         # default is not a official keyword (yet) but supported by the
931         # reference implementation (numpydoc) and widely used
932         type_ = "control"
933     elif _xref_regex.match(token):
934         type_ = "reference"
935     else:
936         type_ = "obj"
937 
938     return type_
939 
940 
941 def _convert_numpy_type_spec(_type: str, location: str = None, translations: dict = {}) -> str:
942     def convert_obj(obj, translations, default_translation):
943         translation = translations.get(obj, obj)
944 
945         # use :class: (the default) only if obj is not a standard singleton
946         if translation in _SINGLETONS and default_translation == ":class:`%s`":
947             default_translation = ":obj:`%s`"
948         elif translation == "..." and default_translation == ":class:`%s`":
949             # allow referencing the builtin ...
950             default_translation = ":obj:`%s <Ellipsis>`"
951 
952         if _xref_regex.match(translation) is None:
953             translation = default_translation % translation
954 
955         return translation
956 
957     tokens = _tokenize_type_spec(_type)
958     combined_tokens = _recombine_set_tokens(tokens)
959     types = [
960         (token, _token_type(token, location))
961         for token in combined_tokens
962     ]
963 
964     converters = {
965         "literal": lambda x: "``%s``" % x,
966         "obj": lambda x: convert_obj(x, translations, ":class:`%s`"),
967         "control": lambda x: "*%s*" % x,
968         "delimiter": lambda x: x,
969         "reference": lambda x: x,
970     }
971 
972     converted = "".join(converters.get(type_)(token) for token, type_ in types)
973 
974     return converted
975 
976 
977 class NumpyDocstring(GoogleDocstring):
978     """Convert NumPy style docstrings to reStructuredText.
979 
980     Parameters
981     ----------
982     docstring : :obj:`str` or :obj:`list` of :obj:`str`
983         The docstring to parse, given either as a string or split into
984         individual lines.
985     config: :obj:`sphinx.ext.napoleon.Config` or :obj:`sphinx.config.Config`
986         The configuration settings to use. If not given, defaults to the
987         config object on `app`; or if `app` is not given defaults to the
988         a new :class:`sphinx.ext.napoleon.Config` object.
989 
990 
991     Other Parameters
992     ----------------
993     app : :class:`sphinx.application.Sphinx`, optional
994         Application object representing the Sphinx process.
995     what : :obj:`str`, optional
996         A string specifying the type of the object to which the docstring
997         belongs. Valid values: "module", "class", "exception", "function",
998         "method", "attribute".
999     name : :obj:`str`, optional
1000         The fully qualified name of the object.
1001     obj : module, class, exception, function, method, or attribute
1002         The object to which the docstring belongs.
1003     options : :class:`sphinx.ext.autodoc.Options`, optional
1004         The options given to the directive: an object with attributes
1005         inherited_members, undoc_members, show_inheritance and noindex that
1006         are True if the flag option of same name was given to the auto
1007         directive.
1008 
1009 
1010     Example
1011     -------
1012     >>> from sphinx.ext.napoleon import Config
1013     >>> config = Config(napoleon_use_param=True, napoleon_use_rtype=True)
1014     >>> docstring = '''One line summary.
1015     ...
1016     ... Extended description.
1017     ...
1018     ... Parameters
1019     ... ----------
1020     ... arg1 : int
1021     ...     Description of `arg1`
1022     ... arg2 : str
1023     ...     Description of `arg2`
1024     ... Returns
1025     ... -------
1026     ... str
1027     ...     Description of return value.
1028     ... '''
1029     >>> print(NumpyDocstring(docstring, config))
1030     One line summary.
1031     <BLANKLINE>
1032     Extended description.
1033     <BLANKLINE>
1034     :param arg1: Description of `arg1`
1035     :type arg1: int
1036     :param arg2: Description of `arg2`
1037     :type arg2: str
1038     <BLANKLINE>
1039     :returns: Description of return value.
1040     :rtype: str
1041     <BLANKLINE>
1042 
1043     Methods
1044     -------
1045     __str__()
1046         Return the parsed docstring in reStructuredText format.
1047 
1048         Returns
1049         -------
1050         str
1051             UTF-8 encoded version of the docstring.
1052 
1053     __unicode__()
1054         Return the parsed docstring in reStructuredText format.
1055 
1056         Returns
1057         -------
1058         unicode
1059             Unicode version of the docstring.
1060 
1061     lines()
1062         Return the parsed lines of the docstring in reStructuredText format.
1063 
1064         Returns
1065         -------
1066         list(str)
1067             The lines of the docstring in a list.
1068 
1069     """
1070     def __init__(self, docstring: Union[str, List[str]], config: SphinxConfig = None,
1071                  app: Sphinx = None, what: str = '', name: str = '',
1072                  obj: Any = None, options: Any = None) -> None:
1073         self._directive_sections = ['.. index::']
1074         super().__init__(docstring, config, app, what, name, obj, options)
1075 
1076     def _get_location(self) -> str:
1077         try:
1078             filepath = inspect.getfile(self._obj) if self._obj is not None else None
1079         except TypeError:
1080             filepath = None
1081         name = self._name
1082 
1083         if filepath is None and name is None:
1084             return None
1085         elif filepath is None:
1086             filepath = ""
1087 
1088         return ":".join([filepath, "docstring of %s" % name])
1089 
1090     def _escape_args_and_kwargs(self, name: str) -> str:
1091         func = super()._escape_args_and_kwargs
1092 
1093         if ", " in name:
1094             return ", ".join(func(param) for param in name.split(", "))
1095         else:
1096             return func(name)
1097 
1098     def _consume_field(self, parse_type: bool = True, prefer_type: bool = False
1099                        ) -> Tuple[str, str, List[str]]:
1100         line = next(self._line_iter)
1101         if parse_type:
1102             _name, _, _type = self._partition_field_on_colon(line)
1103         else:
1104             _name, _type = line, ''
1105         _name, _type = _name.strip(), _type.strip()
1106         _name = self._escape_args_and_kwargs(_name)
1107         if self._config.napoleon_preprocess_types:
1108             _type = _convert_numpy_type_spec(
1109                 _type,
1110                 location=self._get_location(),
1111                 translations=self._config.napoleon_type_aliases or {},
1112             )
1113 
1114         if prefer_type and not _type:
1115             _type, _name = _name, _type
1116         indent = self._get_indent(line) + 1
1117         _desc = self._dedent(self._consume_indented_block(indent))
1118         _desc = self.__class__(_desc, self._config).lines()
1119         return _name, _type, _desc
1120 
1121     def _consume_returns_section(self) -> List[Tuple[str, str, List[str]]]:
1122         return self._consume_fields(prefer_type=True)
1123 
1124     def _consume_section_header(self) -> str:
1125         section = next(self._line_iter)
1126         if not _directive_regex.match(section):
1127             # Consume the header underline
1128             next(self._line_iter)
1129         return section
1130 
1131     def _is_section_break(self) -> bool:
1132         line1, line2 = self._line_iter.peek(2)
1133         return (not self._line_iter.has_next() or
1134                 self._is_section_header() or
1135                 ['', ''] == [line1, line2] or
1136                 (self._is_in_section and
1137                     line1 and
1138                     not self._is_indented(line1, self._section_indent)))
1139 
1140     def _is_section_header(self) -> bool:
1141         section, underline = self._line_iter.peek(2)
1142         section = section.lower()
1143         if section in self._sections and isinstance(underline, str):
1144             return bool(_numpy_section_regex.match(underline))
1145         elif self._directive_sections:
1146             if _directive_regex.match(section):
1147                 for directive_section in self._directive_sections:
1148                     if section.startswith(directive_section):
1149                         return True
1150         return False
1151 
1152     def _parse_see_also_section(self, section: str) -> List[str]:
1153         lines = self._consume_to_next_section()
1154         try:
1155             return self._parse_numpydoc_see_also_section(lines)
1156         except ValueError:
1157             return self._format_admonition('seealso', lines)
1158 
1159     def _parse_numpydoc_see_also_section(self, content: List[str]) -> List[str]:
1160         """
1161         Derived from the NumpyDoc implementation of _parse_see_also.
1162 
1163         See Also
1164         --------
1165         func_name : Descriptive text
1166             continued text
1167         another_func_name : Descriptive text
1168         func_name1, func_name2, :meth:`func_name`, func_name3
1169 
1170         """
1171         items = []
1172 
1173         def parse_item_name(text: str) -> Tuple[str, str]:
1174             """Match ':role:`name`' or 'name'"""
1175             m = self._name_rgx.match(text)
1176             if m:
1177                 g = m.groups()
1178                 if g[1] is None:
1179                     return g[3], None
1180                 else:
1181                     return g[2], g[1]
1182             raise ValueError("%s is not a item name" % text)
1183 
1184         def push_item(name: str, rest: List[str]) -> None:
1185             if not name:
1186                 return
1187             name, role = parse_item_name(name)
1188             items.append((name, list(rest), role))
1189             del rest[:]
1190 
1191         current_func = None
1192         rest = []  # type: List[str]
1193 
1194         for line in content:
1195             if not line.strip():
1196                 continue
1197 
1198             m = self._name_rgx.match(line)
1199             if m and line[m.end():].strip().startswith(':'):
1200                 push_item(current_func, rest)
1201                 current_func, line = line[:m.end()], line[m.end():]
1202                 rest = [line.split(':', 1)[1].strip()]
1203                 if not rest[0]:
1204                     rest = []
1205             elif not line.startswith(' '):
1206                 push_item(current_func, rest)
1207                 current_func = None
1208                 if ',' in line:
1209                     for func in line.split(','):
1210                         if func.strip():
1211                             push_item(func, [])
1212                 elif line.strip():
1213                     current_func = line
1214             elif current_func is not None:
1215                 rest.append(line.strip())
1216         push_item(current_func, rest)
1217 
1218         if not items:
1219             return []
1220 
1221         roles = {
1222             'method': 'meth',
1223             'meth': 'meth',
1224             'function': 'func',
1225             'func': 'func',
1226             'class': 'class',
1227             'exception': 'exc',
1228             'exc': 'exc',
1229             'object': 'obj',
1230             'obj': 'obj',
1231             'module': 'mod',
1232             'mod': 'mod',
1233             'data': 'data',
1234             'constant': 'const',
1235             'const': 'const',
1236             'attribute': 'attr',
1237             'attr': 'attr'
1238         }
1239         if self._what is None:
1240             func_role = 'obj'
1241         else:
1242             func_role = roles.get(self._what, '')
1243         lines = []  # type: List[str]
1244         last_had_desc = True
1245         for func, desc, role in items:
1246             if role:
1247                 link = ':%s:`%s`' % (role, func)
1248             elif func_role:
1249                 link = ':%s:`%s`' % (func_role, func)
1250             else:
1251                 link = "`%s`_" % func
1252             if desc or last_had_desc:
1253                 lines += ['']
1254                 lines += [link]
1255             else:
1256                 lines[-1] += ", %s" % link
1257             if desc:
1258                 lines += self._indent([' '.join(desc)])
1259                 last_had_desc = True
1260             else:
1261                 last_had_desc = False
1262         lines += ['']
1263 
1264         return self._format_admonition('seealso', lines)

</code><intended_behavior>Ensure that the napoleon extension properly interprets and translates complex types in docstrings into the correct reStructuredText format without causing syntax warnings.</intended_behavior>, <file>sphinx/ext/napoleon/__init__.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2     sphinx.ext.napoleon
3     ~~~~~~~~~~~~~~~~~~~
4 
5     Support for NumPy and Google style docstrings.
6 
7     :copyright: Copyright 2007-2020 by the Sphinx team, see AUTHORS.
8     :license: BSD, see LICENSE for details.
9 """
10 
11 from typing import Any, Dict, List
12 
13 from sphinx import __display_version__ as __version__
14 from sphinx.application import Sphinx
15 from sphinx.ext.napoleon.docstring import GoogleDocstring, NumpyDocstring
16 from sphinx.util import inspect
17 
18 
19 class Config:
20     """Sphinx napoleon extension settings in `conf.py`.
21 
22     Listed below are all the settings used by napoleon and their default
23     values. These settings can be changed in the Sphinx `conf.py` file. Make
24     sure that "sphinx.ext.napoleon" is enabled in `conf.py`::
25 
26         # conf.py
27 
28         # Add any Sphinx extension module names here, as strings
29         extensions = ['sphinx.ext.napoleon']
30 
31         # Napoleon settings
32         napoleon_google_docstring = True
33         napoleon_numpy_docstring = True
34         napoleon_include_init_with_doc = False
35         napoleon_include_private_with_doc = False
36         napoleon_include_special_with_doc = False
37         napoleon_use_admonition_for_examples = False
38         napoleon_use_admonition_for_notes = False
39         napoleon_use_admonition_for_references = False
40         napoleon_use_ivar = False
41         napoleon_use_param = True
42         napoleon_use_rtype = True
43         napoleon_use_keyword = True
44         napoleon_preprocess_types = False
45         napoleon_type_aliases = None
46         napoleon_custom_sections = None
47 
48     .. _Google style:
49        https://google.github.io/styleguide/pyguide.html
50     .. _NumPy style:
51        https://github.com/numpy/numpy/blob/master/doc/HOWTO_DOCUMENT.rst.txt
52 
53     Attributes
54     ----------
55     napoleon_google_docstring : :obj:`bool` (Defaults to True)
56         True to parse `Google style`_ docstrings. False to disable support
57         for Google style docstrings.
58     napoleon_numpy_docstring : :obj:`bool` (Defaults to True)
59         True to parse `NumPy style`_ docstrings. False to disable support
60         for NumPy style docstrings.
61     napoleon_include_init_with_doc : :obj:`bool` (Defaults to False)
62         True to list ``__init___`` docstrings separately from the class
63         docstring. False to fall back to Sphinx's default behavior, which
64         considers the ``__init___`` docstring as part of the class
65         documentation.
66 
67         **If True**::
68 
69             def __init__(self):
70                 \"\"\"
71                 This will be included in the docs because it has a docstring
72                 \"\"\"
73 
74             def __init__(self):
75                 # This will NOT be included in the docs
76 
77     napoleon_include_private_with_doc : :obj:`bool` (Defaults to False)
78         True to include private members (like ``_membername``) with docstrings
79         in the documentation. False to fall back to Sphinx's default behavior.
80 
81         **If True**::
82 
83             def _included(self):
84                 \"\"\"
85                 This will be included in the docs because it has a docstring
86                 \"\"\"
87                 pass
88 
89             def _skipped(self):
90                 # This will NOT be included in the docs
91                 pass
92 
93     napoleon_include_special_with_doc : :obj:`bool` (Defaults to False)
94         True to include special members (like ``__membername__``) with
95         docstrings in the documentation. False to fall back to Sphinx's
96         default behavior.
97 
98         **If True**::
99 
100             def __str__(self):
101                 \"\"\"
102                 This will be included in the docs because it has a docstring
103                 \"\"\"
104                 return unicode(self).encode('utf-8')
105 
106             def __unicode__(self):
107                 # This will NOT be included in the docs
108                 return unicode(self.__class__.__name__)
109 
110     napoleon_use_admonition_for_examples : :obj:`bool` (Defaults to False)
111         True to use the ``.. admonition::`` directive for the **Example** and
112         **Examples** sections. False to use the ``.. rubric::`` directive
113         instead. One may look better than the other depending on what HTML
114         theme is used.
115 
116         This `NumPy style`_ snippet will be converted as follows::
117 
118             Example
119             -------
120             This is just a quick example
121 
122         **If True**::
123 
124             .. admonition:: Example
125 
126                This is just a quick example
127 
128         **If False**::
129 
130             .. rubric:: Example
131 
132             This is just a quick example
133 
134     napoleon_use_admonition_for_notes : :obj:`bool` (Defaults to False)
135         True to use the ``.. admonition::`` directive for **Notes** sections.
136         False to use the ``.. rubric::`` directive instead.
137 
138         Note
139         ----
140         The singular **Note** section will always be converted to a
141         ``.. note::`` directive.
142 
143         See Also
144         --------
145         :attr:`napoleon_use_admonition_for_examples`
146 
147     napoleon_use_admonition_for_references : :obj:`bool` (Defaults to False)
148         True to use the ``.. admonition::`` directive for **References**
149         sections. False to use the ``.. rubric::`` directive instead.
150 
151         See Also
152         --------
153         :attr:`napoleon_use_admonition_for_examples`
154 
155     napoleon_use_ivar : :obj:`bool` (Defaults to False)
156         True to use the ``:ivar:`` role for instance variables. False to use
157         the ``.. attribute::`` directive instead.
158 
159         This `NumPy style`_ snippet will be converted as follows::
160 
161             Attributes
162             ----------
163             attr1 : int
164                 Description of `attr1`
165 
166         **If True**::
167 
168             :ivar attr1: Description of `attr1`
169             :vartype attr1: int
170 
171         **If False**::
172 
173             .. attribute:: attr1
174 
175                Description of `attr1`
176 
177                :type: int
178 
179     napoleon_use_param : :obj:`bool` (Defaults to True)
180         True to use a ``:param:`` role for each function parameter. False to
181         use a single ``:parameters:`` role for all the parameters.
182 
183         This `NumPy style`_ snippet will be converted as follows::
184 
185             Parameters
186             ----------
187             arg1 : str
188                 Description of `arg1`
189             arg2 : int, optional
190                 Description of `arg2`, defaults to 0
191 
192         **If True**::
193 
194             :param arg1: Description of `arg1`
195             :type arg1: str
196             :param arg2: Description of `arg2`, defaults to 0
197             :type arg2: int, optional
198 
199         **If False**::
200 
201             :parameters: * **arg1** (*str*) --
202                            Description of `arg1`
203                          * **arg2** (*int, optional*) --
204                            Description of `arg2`, defaults to 0
205 
206     napoleon_use_keyword : :obj:`bool` (Defaults to True)
207         True to use a ``:keyword:`` role for each function keyword argument.
208         False to use a single ``:keyword arguments:`` role for all the
209         keywords.
210 
211         This behaves similarly to  :attr:`napoleon_use_param`. Note unlike
212         docutils, ``:keyword:`` and ``:param:`` will not be treated the same
213         way - there will be a separate "Keyword Arguments" section, rendered
214         in the same fashion as "Parameters" section (type links created if
215         possible)
216 
217         See Also
218         --------
219         :attr:`napoleon_use_param`
220 
221     napoleon_use_rtype : :obj:`bool` (Defaults to True)
222         True to use the ``:rtype:`` role for the return type. False to output
223         the return type inline with the description.
224 
225         This `NumPy style`_ snippet will be converted as follows::
226 
227             Returns
228             -------
229             bool
230                 True if successful, False otherwise
231 
232         **If True**::
233 
234             :returns: True if successful, False otherwise
235             :rtype: bool
236 
237         **If False**::
238 
239             :returns: *bool* -- True if successful, False otherwise
240 
241     napoleon_preprocess_types : :obj:`bool` (Defaults to False)
242         Enable the type preprocessor for numpy style docstrings.
243 
244     napoleon_type_aliases : :obj:`dict` (Defaults to None)
245         Add a mapping of strings to string, translating types in numpy
246         style docstrings. Only works if ``napoleon_preprocess_types = True``.
247 
248     napoleon_custom_sections : :obj:`list` (Defaults to None)
249         Add a list of custom sections to include, expanding the list of parsed sections.
250 
251         The entries can either be strings or tuples, depending on the intention:
252           * To create a custom "generic" section, just pass a string.
253           * To create an alias for an existing section, pass a tuple containing the
254             alias name and the original, in that order.
255 
256         If an entry is just a string, it is interpreted as a header for a generic
257         section. If the entry is a tuple/list/indexed container, the first entry
258         is the name of the section, the second is the section key to emulate.
259 
260 
261     """
262     _config_values = {
263         'napoleon_google_docstring': (True, 'env'),
264         'napoleon_numpy_docstring': (True, 'env'),
265         'napoleon_include_init_with_doc': (False, 'env'),
266         'napoleon_include_private_with_doc': (False, 'env'),
267         'napoleon_include_special_with_doc': (False, 'env'),
268         'napoleon_use_admonition_for_examples': (False, 'env'),
269         'napoleon_use_admonition_for_notes': (False, 'env'),
270         'napoleon_use_admonition_for_references': (False, 'env'),
271         'napoleon_use_ivar': (False, 'env'),
272         'napoleon_use_param': (True, 'env'),
273         'napoleon_use_rtype': (True, 'env'),
274         'napoleon_use_keyword': (True, 'env'),
275         'napoleon_preprocess_types': (False, 'env'),
276         'napoleon_type_aliases': (None, 'env'),
277         'napoleon_custom_sections': (None, 'env')
278     }
279 
280     def __init__(self, **settings: Any) -> None:
281         for name, (default, rebuild) in self._config_values.items():
282             setattr(self, name, default)
283         for name, value in settings.items():
284             setattr(self, name, value)
285 
286 
287 def setup(app: Sphinx) -> Dict[str, Any]:
288     """Sphinx extension setup function.
289 
290     When the extension is loaded, Sphinx imports this module and executes
291     the ``setup()`` function, which in turn notifies Sphinx of everything
292     the extension offers.
293 
294     Parameters
295     ----------
296     app : sphinx.application.Sphinx
297         Application object representing the Sphinx process
298 
299     See Also
300     --------
301     `The Sphinx documentation on Extensions
302     <http://sphinx-doc.org/extensions.html>`_
303 
304     `The Extension Tutorial <http://sphinx-doc.org/extdev/tutorial.html>`_
305 
306     `The Extension API <http://sphinx-doc.org/extdev/appapi.html>`_
307 
308     """
309     if not isinstance(app, Sphinx):
310         # probably called by tests
311         return {'version': __version__, 'parallel_read_safe': True}
312 
313     _patch_python_domain()
314 
315     app.setup_extension('sphinx.ext.autodoc')
316     app.connect('autodoc-process-docstring', _process_docstring)
317     app.connect('autodoc-skip-member', _skip_member)
318 
319     for name, (default, rebuild) in Config._config_values.items():
320         app.add_config_value(name, default, rebuild)
321     return {'version': __version__, 'parallel_read_safe': True}
322 
323 
324 def _patch_python_domain() -> None:
325     try:
326         from sphinx.domains.python import PyTypedField
327     except ImportError:
328         pass
329     else:
330         import sphinx.domains.python
331         from sphinx.locale import _
332         for doc_field in sphinx.domains.python.PyObject.doc_field_types:
333             if doc_field.name == 'parameter':
334                 doc_field.names = ('param', 'parameter', 'arg', 'argument')
335                 break
336         sphinx.domains.python.PyObject.doc_field_types.append(
337             PyTypedField('keyword', label=_('Keyword Arguments'),
338                          names=('keyword', 'kwarg', 'kwparam'),
339                          typerolename='obj', typenames=('paramtype', 'kwtype'),
340                          can_collapse=True))
341 
342 
343 def _process_docstring(app: Sphinx, what: str, name: str, obj: Any,
344                        options: Any, lines: List[str]) -> None:
345     """Process the docstring for a given python object.
346 
347     Called when autodoc has read and processed a docstring. `lines` is a list
348     of docstring lines that `_process_docstring` modifies in place to change
349     what Sphinx outputs.
350 
351     The following settings in conf.py control what styles of docstrings will
352     be parsed:
353 
354     * ``napoleon_google_docstring`` -- parse Google style docstrings
355     * ``napoleon_numpy_docstring`` -- parse NumPy style docstrings
356 
357     Parameters
358     ----------
359     app : sphinx.application.Sphinx
360         Application object representing the Sphinx process.
361     what : str
362         A string specifying the type of the object to which the docstring
363         belongs. Valid values: "module", "class", "exception", "function",
364         "method", "attribute".
365     name : str
366         The fully qualified name of the object.
367     obj : module, class, exception, function, method, or attribute
368         The object to which the docstring belongs.
369     options : sphinx.ext.autodoc.Options
370         The options given to the directive: an object with attributes
371         inherited_members, undoc_members, show_inheritance and noindex that
372         are True if the flag option of same name was given to the auto
373         directive.
374     lines : list of str
375         The lines of the docstring, see above.
376 
377         .. note:: `lines` is modified *in place*
378 
379     """
380     result_lines = lines
381     docstring = None  # type: GoogleDocstring
382     if app.config.napoleon_numpy_docstring:
383         docstring = NumpyDocstring(result_lines, app.config, app, what, name,
384                                    obj, options)
385         result_lines = docstring.lines()
386     if app.config.napoleon_google_docstring:
387         docstring = GoogleDocstring(result_lines, app.config, app, what, name,
388                                     obj, options)
389         result_lines = docstring.lines()
390     lines[:] = result_lines[:]
391 
392 
393 def _skip_member(app: Sphinx, what: str, name: str, obj: Any,
394                  skip: bool, options: Any) -> bool:
395     """Determine if private and special class members are included in docs.
396 
397     The following settings in conf.py determine if private and special class
398     members or init methods are included in the generated documentation:
399 
400     * ``napoleon_include_init_with_doc`` --
401       include init methods if they have docstrings
402     * ``napoleon_include_private_with_doc`` --
403       include private members if they have docstrings
404     * ``napoleon_include_special_with_doc`` --
405       include special members if they have docstrings
406 
407     Parameters
408     ----------
409     app : sphinx.application.Sphinx
410         Application object representing the Sphinx process
411     what : str
412         A string specifying the type of the object to which the member
413         belongs. Valid values: "module", "class", "exception", "function",
414         "method", "attribute".
415     name : str
416         The name of the member.
417     obj : module, class, exception, function, method, or attribute.
418         For example, if the member is the __init__ method of class A, then
419         `obj` will be `A.__init__`.
420     skip : bool
421         A boolean indicating if autodoc will skip this member if `_skip_member`
422         does not override the decision
423     options : sphinx.ext.autodoc.Options
424         The options given to the directive: an object with attributes
425         inherited_members, undoc_members, show_inheritance and noindex that
426         are True if the flag option of same name was given to the auto
427         directive.
428 
429     Returns
430     -------
431     bool
432         True if the member should be skipped during creation of the docs,
433         False if it should be included in the docs.
434 
435     """
436     has_doc = getattr(obj, '__doc__', False)
437     is_member = (what == 'class' or what == 'exception' or what == 'module')
438     if name != '__weakref__' and has_doc and is_member:
439         cls_is_owner = False
440         if what == 'class' or what == 'exception':
441             qualname = getattr(obj, '__qualname__', '')
442             cls_path, _, _ = qualname.rpartition('.')
443             if cls_path:
444                 try:
445                     if '.' in cls_path:
446                         import importlib
447                         import functools
448 
449                         mod = importlib.import_module(obj.__module__)
450                         mod_path = cls_path.split('.')
451                         cls = functools.reduce(getattr, mod_path, mod)
452                     else:
453                         cls = inspect.unwrap(obj).__globals__[cls_path]
454                 except Exception:
455                     cls_is_owner = False
456                 else:
457                     cls_is_owner = (cls and hasattr(cls, name) and  # type: ignore
458                                     name in cls.__dict__)
459             else:
460                 cls_is_owner = False
461 
462         if what == 'module' or cls_is_owner:
463             is_init = (name == '__init__')
464             is_special = (not is_init and name.startswith('__') and
465                           name.endswith('__'))
466             is_private = (not is_init and not is_special and
467                           name.startswith('_'))
468             inc_init = app.config.napoleon_include_init_with_doc
469             inc_special = app.config.napoleon_include_special_with_doc
470             inc_private = app.config.napoleon_include_private_with_doc
471             if ((is_special and inc_special) or
472                     (is_private and inc_private) or
473                     (is_init and inc_init)):
474                 return False
475     return None

</code><intended_behavior>Adjust parsing rules or the way certain annotations are handled to prevent misinterpretation that leads to warnings.</intended_behavior>, <file>doc/usage/extensions/example_google.py</file>
<class>None</class>
<method>None</method>
<code>
1 """Example Google style docstrings.
2 
3 This module demonstrates documentation as specified by the `Google Python
4 Style Guide`_. Docstrings may extend over multiple lines. Sections are created
5 with a section header and a colon followed by a block of indented text.
6 
7 Example:
8     Examples can be given using either the ``Example`` or ``Examples``
9     sections. Sections support any reStructuredText formatting, including
10     literal blocks::
11 
12         $ python example_google.py
13 
14 Section breaks are created by resuming unindented text. Section breaks
15 are also implicitly created anytime a new section starts.
16 
17 Attributes:
18     module_level_variable1 (int): Module level variables may be documented in
19         either the ``Attributes`` section of the module docstring, or in an
20         inline docstring immediately following the variable.
21 
22         Either form is acceptable, but the two should not be mixed. Choose
23         one convention to document module level variables and be consistent
24         with it.
25 
26 Todo:
27     * For module TODOs
28     * You have to also use ``sphinx.ext.todo`` extension
29 
30 .. _Google Python Style Guide:
31    https://google.github.io/styleguide/pyguide.html
32 
33 """
34 
35 module_level_variable1 = 12345
36 
37 module_level_variable2 = 98765
38 """int: Module level variable documented inline.
39 
40 The docstring may span multiple lines. The type may optionally be specified
41 on the first line, separated by a colon.
42 """
43 
44 
45 def function_with_types_in_docstring(param1, param2):
46     """Example function with types documented in the docstring.
47 
48     `PEP 484`_ type annotations are supported. If attribute, parameter, and
49     return types are annotated according to `PEP 484`_, they do not need to be
50     included in the docstring:
51 
52     Args:
53         param1 (int): The first parameter.
54         param2 (str): The second parameter.
55 
56     Returns:
57         bool: The return value. True for success, False otherwise.
58 
59     .. _PEP 484:
60         https://www.python.org/dev/peps/pep-0484/
61 
62     """
63 
64 
65 def function_with_pep484_type_annotations(param1: int, param2: str) -> bool:
66     """Example function with PEP 484 type annotations.
67 
68     Args:
69         param1: The first parameter.
70         param2: The second parameter.
71 
72     Returns:
73         The return value. True for success, False otherwise.
74 
75     """
76 
77 
78 def module_level_function(param1, param2=None, *args, **kwargs):
79     """This is an example of a module level function.
80 
81     Function parameters should be documented in the ``Args`` section. The name
82     of each parameter is required. The type and description of each parameter
83     is optional, but should be included if not obvious.
84 
85     If ``*args`` or ``**kwargs`` are accepted,
86     they should be listed as ``*args`` and ``**kwargs``.
87 
88     The format for a parameter is::
89 
90         name (type): description
91             The description may span multiple lines. Following
92             lines should be indented. The "(type)" is optional.
93 
94             Multiple paragraphs are supported in parameter
95             descriptions.
96 
97     Args:
98         param1 (int): The first parameter.
99         param2 (:obj:`str`, optional): The second parameter. Defaults to None.
100             Second line of description should be indented.
101         *args: Variable length argument list.
102         **kwargs: Arbitrary keyword arguments.
103 
104     Returns:
105         bool: True if successful, False otherwise.
106 
107         The return type is optional and may be specified at the beginning of
108         the ``Returns`` section followed by a colon.
109 
110         The ``Returns`` section may span multiple lines and paragraphs.
111         Following lines should be indented to match the first line.
112 
113         The ``Returns`` section supports any reStructuredText formatting,
114         including literal blocks::
115 
116             {
117                 'param1': param1,
118                 'param2': param2
119             }
120 
121     Raises:
122         AttributeError: The ``Raises`` section is a list of all exceptions
123             that are relevant to the interface.
124         ValueError: If `param2` is equal to `param1`.
125 
126     """
127     if param1 == param2:
128         raise ValueError('param1 may not be equal to param2')
129     return True
130 
131 
132 def example_generator(n):
133     """Generators have a ``Yields`` section instead of a ``Returns`` section.
134 
135     Args:
136         n (int): The upper limit of the range to generate, from 0 to `n` - 1.
137 
138     Yields:
139         int: The next number in the range of 0 to `n` - 1.
140 
141     Examples:
142         Examples should be written in doctest format, and should illustrate how
143         to use the function.
144 
145         >>> print([i for i in example_generator(4)])
146         [0, 1, 2, 3]
147 
148     """
149     for i in range(n):
150         yield i
151 
152 
153 class ExampleError(Exception):
154     """Exceptions are documented in the same way as classes.
155 
156     The __init__ method may be documented in either the class level
157     docstring, or as a docstring on the __init__ method itself.
158 
159     Either form is acceptable, but the two should not be mixed. Choose one
160     convention to document the __init__ method and be consistent with it.
161 
162     Note:
163         Do not include the `self` parameter in the ``Args`` section.
164 
165     Args:
166         msg (str): Human readable string describing the exception.
167         code (:obj:`int`, optional): Error code.
168 
169     Attributes:
170         msg (str): Human readable string describing the exception.
171         code (int): Exception error code.
172 
173     """
174 
175     def __init__(self, msg, code):
176         self.msg = msg
177         self.code = code
178 
179 
180 class ExampleClass:
181     """The summary line for a class docstring should fit on one line.
182 
183     If the class has public attributes, they may be documented here
184     in an ``Attributes`` section and follow the same formatting as a
185     function's ``Args`` section. Alternatively, attributes may be documented
186     inline with the attribute's declaration (see __init__ method below).
187 
188     Properties created with the ``@property`` decorator should be documented
189     in the property's getter method.
190 
191     Attributes:
192         attr1 (str): Description of `attr1`.
193         attr2 (:obj:`int`, optional): Description of `attr2`.
194 
195     """
196 
197     def __init__(self, param1, param2, param3):
198         """Example of docstring on the __init__ method.
199 
200         The __init__ method may be documented in either the class level
201         docstring, or as a docstring on the __init__ method itself.
202 
203         Either form is acceptable, but the two should not be mixed. Choose one
204         convention to document the __init__ method and be consistent with it.
205 
206         Note:
207             Do not include the `self` parameter in the ``Args`` section.
208 
209         Args:
210             param1 (str): Description of `param1`.
211             param2 (:obj:`int`, optional): Description of `param2`. Multiple
212                 lines are supported.
213             param3 (list(str)): Description of `param3`.
214 
215         """
216         self.attr1 = param1
217         self.attr2 = param2
218         self.attr3 = param3  #: Doc comment *inline* with attribute
219 
220         #: list(str): Doc comment *before* attribute, with type specified
221         self.attr4 = ['attr4']
222 
223         self.attr5 = None
224         """str: Docstring *after* attribute, with type specified."""
225 
226     @property
227     def readonly_property(self):
228         """str: Properties should be documented in their getter method."""
229         return 'readonly_property'
230 
231     @property
232     def readwrite_property(self):
233         """list(str): Properties with both a getter and setter
234         should only be documented in their getter method.
235 
236         If the setter method contains notable behavior, it should be
237         mentioned here.
238         """
239         return ['readwrite_property']
240 
241     @readwrite_property.setter
242     def readwrite_property(self, value):
243         value
244 
245     def example_method(self, param1, param2):
246         """Class methods are similar to regular functions.
247 
248         Note:
249             Do not include the `self` parameter in the ``Args`` section.
250 
251         Args:
252             param1: The first parameter.
253             param2: The second parameter.
254 
255         Returns:
256             True if successful, False otherwise.
257 
258         """
259         return True
260 
261     def __special__(self):
262         """By default special members with docstrings are not included.
263 
264         Special members are any methods or attributes that start with and
265         end with a double underscore. Any special member with a docstring
266         will be included in the output, if
267         ``napoleon_include_special_with_doc`` is set to True.
268 
269         This behavior can be enabled by changing the following setting in
270         Sphinx's conf.py::
271 
272             napoleon_include_special_with_doc = True
273 
274         """
275         pass
276 
277     def __special_without_docstring__(self):
278         pass
279 
280     def _private(self):
281         """By default private members are not included.
282 
283         Private members are any methods or attributes that start with an
284         underscore and are *not* special. By default they are not included
285         in the output.
286 
287         This behavior can be changed such that private members *are* included
288         by changing the following setting in Sphinx's conf.py::
289 
290             napoleon_include_private_with_doc = True
291 
292         """
293         pass
294 
295     def _private_without_docstring(self):
296         pass

</code><intended_behavior>Review documentation examples for handling generics in docstrings to ensure correct parsing and rendering without syntax warnings.</intended_behavior>, <file>doc/usage/extensions/example_numpy.py</file>
<class>None</class>
<method>None</method>
<code>
1 """Example NumPy style docstrings.
2 
3 This module demonstrates documentation as specified by the `NumPy
4 Documentation HOWTO`_. Docstrings may extend over multiple lines. Sections
5 are created with a section header followed by an underline of equal length.
6 
7 Example
8 -------
9 Examples can be given using either the ``Example`` or ``Examples``
10 sections. Sections support any reStructuredText formatting, including
11 literal blocks::
12 
13     $ python example_numpy.py
14 
15 
16 Section breaks are created with two blank lines. Section breaks are also
17 implicitly created anytime a new section starts. Section bodies *may* be
18 indented:
19 
20 Notes
21 -----
22     This is an example of an indented section. It's like any other section,
23     but the body is indented to help it stand out from surrounding text.
24 
25 If a section is indented, then a section break is created by
26 resuming unindented text.
27 
28 Attributes
29 ----------
30 module_level_variable1 : int
31     Module level variables may be documented in either the ``Attributes``
32     section of the module docstring, or in an inline docstring immediately
33     following the variable.
34 
35     Either form is acceptable, but the two should not be mixed. Choose
36     one convention to document module level variables and be consistent
37     with it.
38 
39 
40 .. _NumPy Documentation HOWTO:
41    https://github.com/numpy/numpy/blob/master/doc/HOWTO_DOCUMENT.rst.txt
42 
43 """
44 
45 module_level_variable1 = 12345
46 
47 module_level_variable2 = 98765
48 """int: Module level variable documented inline.
49 
50 The docstring may span multiple lines. The type may optionally be specified
51 on the first line, separated by a colon.
52 """
53 
54 
55 def function_with_types_in_docstring(param1, param2):
56     """Example function with types documented in the docstring.
57 
58     `PEP 484`_ type annotations are supported. If attribute, parameter, and
59     return types are annotated according to `PEP 484`_, they do not need to be
60     included in the docstring:
61 
62     Parameters
63     ----------
64     param1 : int
65         The first parameter.
66     param2 : str
67         The second parameter.
68 
69     Returns
70     -------
71     bool
72         True if successful, False otherwise.
73 
74     .. _PEP 484:
75         https://www.python.org/dev/peps/pep-0484/
76 
77     """
78 
79 
80 def function_with_pep484_type_annotations(param1: int, param2: str) -> bool:
81     """Example function with PEP 484 type annotations.
82 
83     The return type must be duplicated in the docstring to comply
84     with the NumPy docstring style.
85 
86     Parameters
87     ----------
88     param1
89         The first parameter.
90     param2
91         The second parameter.
92 
93     Returns
94     -------
95     bool
96         True if successful, False otherwise.
97 
98     """
99 
100 
101 def module_level_function(param1, param2=None, *args, **kwargs):
102     """This is an example of a module level function.
103 
104     Function parameters should be documented in the ``Parameters`` section.
105     The name of each parameter is required. The type and description of each
106     parameter is optional, but should be included if not obvious.
107 
108     If ``*args`` or ``**kwargs`` are accepted,
109     they should be listed as ``*args`` and ``**kwargs``.
110 
111     The format for a parameter is::
112 
113         name : type
114             description
115 
116             The description may span multiple lines. Following lines
117             should be indented to match the first line of the description.
118             The ": type" is optional.
119 
120             Multiple paragraphs are supported in parameter
121             descriptions.
122 
123     Parameters
124     ----------
125     param1 : int
126         The first parameter.
127     param2 : :obj:`str`, optional
128         The second parameter.
129     *args
130         Variable length argument list.
131     **kwargs
132         Arbitrary keyword arguments.
133 
134     Returns
135     -------
136     bool
137         True if successful, False otherwise.
138 
139         The return type is not optional. The ``Returns`` section may span
140         multiple lines and paragraphs. Following lines should be indented to
141         match the first line of the description.
142 
143         The ``Returns`` section supports any reStructuredText formatting,
144         including literal blocks::
145 
146             {
147                 'param1': param1,
148                 'param2': param2
149             }
150 
151     Raises
152     ------
153     AttributeError
154         The ``Raises`` section is a list of all exceptions
155         that are relevant to the interface.
156     ValueError
157         If `param2` is equal to `param1`.
158 
159     """
160     if param1 == param2:
161         raise ValueError('param1 may not be equal to param2')
162     return True
163 
164 
165 def example_generator(n):
166     """Generators have a ``Yields`` section instead of a ``Returns`` section.
167 
168     Parameters
169     ----------
170     n : int
171         The upper limit of the range to generate, from 0 to `n` - 1.
172 
173     Yields
174     ------
175     int
176         The next number in the range of 0 to `n` - 1.
177 
178     Examples
179     --------
180     Examples should be written in doctest format, and should illustrate how
181     to use the function.
182 
183     >>> print([i for i in example_generator(4)])
184     [0, 1, 2, 3]
185 
186     """
187     for i in range(n):
188         yield i
189 
190 
191 class ExampleError(Exception):
192     """Exceptions are documented in the same way as classes.
193 
194     The __init__ method may be documented in either the class level
195     docstring, or as a docstring on the __init__ method itself.
196 
197     Either form is acceptable, but the two should not be mixed. Choose one
198     convention to document the __init__ method and be consistent with it.
199 
200     Note
201     ----
202     Do not include the `self` parameter in the ``Parameters`` section.
203 
204     Parameters
205     ----------
206     msg : str
207         Human readable string describing the exception.
208     code : :obj:`int`, optional
209         Numeric error code.
210 
211     Attributes
212     ----------
213     msg : str
214         Human readable string describing the exception.
215     code : int
216         Numeric error code.
217 
218     """
219 
220     def __init__(self, msg, code):
221         self.msg = msg
222         self.code = code
223 
224 
225 class ExampleClass:
226     """The summary line for a class docstring should fit on one line.
227 
228     If the class has public attributes, they may be documented here
229     in an ``Attributes`` section and follow the same formatting as a
230     function's ``Args`` section. Alternatively, attributes may be documented
231     inline with the attribute's declaration (see __init__ method below).
232 
233     Properties created with the ``@property`` decorator should be documented
234     in the property's getter method.
235 
236     Attributes
237     ----------
238     attr1 : str
239         Description of `attr1`.
240     attr2 : :obj:`int`, optional
241         Description of `attr2`.
242 
243     """
244 
245     def __init__(self, param1, param2, param3):
246         """Example of docstring on the __init__ method.
247 
248         The __init__ method may be documented in either the class level
249         docstring, or as a docstring on the __init__ method itself.
250 
251         Either form is acceptable, but the two should not be mixed. Choose one
252         convention to document the __init__ method and be consistent with it.
253 
254         Note
255         ----
256         Do not include the `self` parameter in the ``Parameters`` section.
257 
258         Parameters
259         ----------
260         param1 : str
261             Description of `param1`.
262         param2 : list(str)
263             Description of `param2`. Multiple
264             lines are supported.
265         param3 : :obj:`int`, optional
266             Description of `param3`.
267 
268         """
269         self.attr1 = param1
270         self.attr2 = param2
271         self.attr3 = param3  #: Doc comment *inline* with attribute
272 
273         #: list(str): Doc comment *before* attribute, with type specified
274         self.attr4 = ["attr4"]
275 
276         self.attr5 = None
277         """str: Docstring *after* attribute, with type specified."""
278 
279     @property
280     def readonly_property(self):
281         """str: Properties should be documented in their getter method."""
282         return "readonly_property"
283 
284     @property
285     def readwrite_property(self):
286         """list(str): Properties with both a getter and setter
287         should only be documented in their getter method.
288 
289         If the setter method contains notable behavior, it should be
290         mentioned here.
291         """
292         return ["readwrite_property"]
293 
294     @readwrite_property.setter
295     def readwrite_property(self, value):
296         value
297 
298     def example_method(self, param1, param2):
299         """Class methods are similar to regular functions.
300 
301         Note
302         ----
303         Do not include the `self` parameter in the ``Parameters`` section.
304 
305         Parameters
306         ----------
307         param1
308             The first parameter.
309         param2
310             The second parameter.
311 
312         Returns
313         -------
314         bool
315             True if successful, False otherwise.
316 
317         """
318         return True
319 
320     def __special__(self):
321         """By default special members with docstrings are not included.
322 
323         Special members are any methods or attributes that start with and
324         end with a double underscore. Any special member with a docstring
325         will be included in the output, if
326         ``napoleon_include_special_with_doc`` is set to True.
327 
328         This behavior can be enabled by changing the following setting in
329         Sphinx's conf.py::
330 
331             napoleon_include_special_with_doc = True
332 
333         """
334         pass
335 
336     def __special_without_docstring__(self):
337         pass
338 
339     def _private(self):
340         """By default private members are not included.
341 
342         Private members are any methods or attributes that start with an
343         underscore and are *not* special. By default they are not included
344         in the output.
345 
346         This behavior can be changed such that private members *are* included
347         by changing the following setting in Sphinx's conf.py::
348 
349             napoleon_include_private_with_doc = True
350 
351         """
352         pass
353 
354     def _private_without_docstring(self):
355         pass

</code><intended_behavior>Ensure documentation practices for generics and class variables in docstrings are correctly interpreted by Sphinx, particularly in the example files.</intended_behavior>]
2025-10-18 18:32:24.412 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-18 18:32:24.412 | INFO     | Search-only: skipping patch selection
2025-10-18 18:32:24.533 | INFO     | Task sphinx-doc__sphinx-8202 completed successfully.
2025-10-18 18:32:24.534 | INFO     | No patch generated. You can try running ACR again.
