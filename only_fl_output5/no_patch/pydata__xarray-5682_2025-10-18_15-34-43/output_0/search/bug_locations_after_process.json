[
    {
        "rel_file_path": "xarray/plot/utils.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/pydata__xarray/setup_pydata__xarray__0.19/xarray/plot/utils.py",
        "start": 1,
        "end": 1138,
        "class_name": null,
        "method_name": null,
        "code": "1 import itertools\n2 import textwrap\n3 import warnings\n4 from datetime import datetime\n5 from inspect import getfullargspec\n6 from typing import Any, Iterable, Mapping, Tuple, Union\n7 \n8 import numpy as np\n9 import pandas as pd\n10 \n11 from ..core.options import OPTIONS\n12 from ..core.pycompat import DuckArrayModule\n13 from ..core.utils import is_scalar\n14 \n15 try:\n16     import nc_time_axis  # noqa: F401\n17 \n18     nc_time_axis_available = True\n19 except ImportError:\n20     nc_time_axis_available = False\n21 \n22 ROBUST_PERCENTILE = 2.0\n23 \n24 \n25 _registered = False\n26 \n27 \n28 def register_pandas_datetime_converter_if_needed():\n29     # based on https://github.com/pandas-dev/pandas/pull/17710\n30     global _registered\n31     if not _registered:\n32         pd.plotting.register_matplotlib_converters()\n33         _registered = True\n34 \n35 \n36 def import_matplotlib_pyplot():\n37     \"\"\"Import pyplot as register appropriate converters.\"\"\"\n38     register_pandas_datetime_converter_if_needed()\n39     import matplotlib.pyplot as plt\n40 \n41     return plt\n42 \n43 \n44 def _determine_extend(calc_data, vmin, vmax):\n45     extend_min = calc_data.min() < vmin\n46     extend_max = calc_data.max() > vmax\n47     if extend_min and extend_max:\n48         return \"both\"\n49     elif extend_min:\n50         return \"min\"\n51     elif extend_max:\n52         return \"max\"\n53     else:\n54         return \"neither\"\n55 \n56 \n57 def _build_discrete_cmap(cmap, levels, extend, filled):\n58     \"\"\"\n59     Build a discrete colormap and normalization of the data.\n60     \"\"\"\n61     import matplotlib as mpl\n62 \n63     if len(levels) == 1:\n64         levels = [levels[0], levels[0]]\n65 \n66     if not filled:\n67         # non-filled contour plots\n68         extend = \"max\"\n69 \n70     if extend == \"both\":\n71         ext_n = 2\n72     elif extend in [\"min\", \"max\"]:\n73         ext_n = 1\n74     else:\n75         ext_n = 0\n76 \n77     n_colors = len(levels) + ext_n - 1\n78     pal = _color_palette(cmap, n_colors)\n79 \n80     new_cmap, cnorm = mpl.colors.from_levels_and_colors(levels, pal, extend=extend)\n81     # copy the old cmap name, for easier testing\n82     new_cmap.name = getattr(cmap, \"name\", cmap)\n83 \n84     # copy colors to use for bad, under, and over values in case they have been\n85     # set to non-default values\n86     try:\n87         # matplotlib<3.2 only uses bad color for masked values\n88         bad = cmap(np.ma.masked_invalid([np.nan]))[0]\n89     except TypeError:\n90         # cmap was a str or list rather than a color-map object, so there are\n91         # no bad, under or over values to check or copy\n92         pass\n93     else:\n94         under = cmap(-np.inf)\n95         over = cmap(np.inf)\n96 \n97         new_cmap.set_bad(bad)\n98 \n99         # Only update under and over if they were explicitly changed by the user\n100         # (i.e. are different from the lowest or highest values in cmap). Otherwise\n101         # leave unchanged so new_cmap uses its default values (its own lowest and\n102         # highest values).\n103         if under != cmap(0):\n104             new_cmap.set_under(under)\n105         if over != cmap(cmap.N - 1):\n106             new_cmap.set_over(over)\n107 \n108     return new_cmap, cnorm\n109 \n110 \n111 def _color_palette(cmap, n_colors):\n112     import matplotlib.pyplot as plt\n113     from matplotlib.colors import ListedColormap\n114 \n115     colors_i = np.linspace(0, 1.0, n_colors)\n116     if isinstance(cmap, (list, tuple)):\n117         # we have a list of colors\n118         cmap = ListedColormap(cmap, N=n_colors)\n119         pal = cmap(colors_i)\n120     elif isinstance(cmap, str):\n121         # we have some sort of named palette\n122         try:\n123             # is this a matplotlib cmap?\n124             cmap = plt.get_cmap(cmap)\n125             pal = cmap(colors_i)\n126         except ValueError:\n127             # ValueError happens when mpl doesn't like a colormap, try seaborn\n128             try:\n129                 from seaborn import color_palette\n130 \n131                 pal = color_palette(cmap, n_colors=n_colors)\n132             except (ValueError, ImportError):\n133                 # or maybe we just got a single color as a string\n134                 cmap = ListedColormap([cmap], N=n_colors)\n135                 pal = cmap(colors_i)\n136     else:\n137         # cmap better be a LinearSegmentedColormap (e.g. viridis)\n138         pal = cmap(colors_i)\n139 \n140     return pal\n141 \n142 \n143 # _determine_cmap_params is adapted from Seaborn:\n144 # https://github.com/mwaskom/seaborn/blob/v0.6/seaborn/matrix.py#L158\n145 # Used under the terms of Seaborn's license, see licenses/SEABORN_LICENSE.\n146 \n147 \n148 def _determine_cmap_params(\n149     plot_data,\n150     vmin=None,\n151     vmax=None,\n152     cmap=None,\n153     center=None,\n154     robust=False,\n155     extend=None,\n156     levels=None,\n157     filled=True,\n158     norm=None,\n159     _is_facetgrid=False,\n160 ):\n161     \"\"\"\n162     Use some heuristics to set good defaults for colorbar and range.\n163 \n164     Parameters\n165     ----------\n166     plot_data : Numpy array\n167         Doesn't handle xarray objects\n168 \n169     Returns\n170     -------\n171     cmap_params : dict\n172         Use depends on the type of the plotting function\n173     \"\"\"\n174     import matplotlib as mpl\n175 \n176     if isinstance(levels, Iterable):\n177         levels = sorted(levels)\n178 \n179     calc_data = np.ravel(plot_data[np.isfinite(plot_data)])\n180 \n181     # Handle all-NaN input data gracefully\n182     if calc_data.size == 0:\n183         # Arbitrary default for when all values are NaN\n184         calc_data = np.array(0.0)\n185 \n186     # Setting center=False prevents a divergent cmap\n187     possibly_divergent = center is not False\n188 \n189     # Set center to 0 so math below makes sense but remember its state\n190     center_is_none = False\n191     if center is None:\n192         center = 0\n193         center_is_none = True\n194 \n195     # Setting both vmin and vmax prevents a divergent cmap\n196     if (vmin is not None) and (vmax is not None):\n197         possibly_divergent = False\n198 \n199     # Setting vmin or vmax implies linspaced levels\n200     user_minmax = (vmin is not None) or (vmax is not None)\n201 \n202     # vlim might be computed below\n203     vlim = None\n204 \n205     # save state; needed later\n206     vmin_was_none = vmin is None\n207     vmax_was_none = vmax is None\n208 \n209     if vmin is None:\n210         if robust:\n211             vmin = np.percentile(calc_data, ROBUST_PERCENTILE)\n212         else:\n213             vmin = calc_data.min()\n214     elif possibly_divergent:\n215         vlim = abs(vmin - center)\n216 \n217     if vmax is None:\n218         if robust:\n219             vmax = np.percentile(calc_data, 100 - ROBUST_PERCENTILE)\n220         else:\n221             vmax = calc_data.max()\n222     elif possibly_divergent:\n223         vlim = abs(vmax - center)\n224 \n225     if possibly_divergent:\n226         levels_are_divergent = (\n227             isinstance(levels, Iterable) and levels[0] * levels[-1] < 0\n228         )\n229         # kwargs not specific about divergent or not: infer defaults from data\n230         divergent = (\n231             ((vmin < 0) and (vmax > 0)) or not center_is_none or levels_are_divergent\n232         )\n233     else:\n234         divergent = False\n235 \n236     # A divergent map should be symmetric around the center value\n237     if divergent:\n238         if vlim is None:\n239             vlim = max(abs(vmin - center), abs(vmax - center))\n240         vmin, vmax = -vlim, vlim\n241 \n242     # Now add in the centering value and set the limits\n243     vmin += center\n244     vmax += center\n245 \n246     # now check norm and harmonize with vmin, vmax\n247     if norm is not None:\n248         if norm.vmin is None:\n249             norm.vmin = vmin\n250         else:\n251             if not vmin_was_none and vmin != norm.vmin:\n252                 raise ValueError(\"Cannot supply vmin and a norm with a different vmin.\")\n253             vmin = norm.vmin\n254 \n255         if norm.vmax is None:\n256             norm.vmax = vmax\n257         else:\n258             if not vmax_was_none and vmax != norm.vmax:\n259                 raise ValueError(\"Cannot supply vmax and a norm with a different vmax.\")\n260             vmax = norm.vmax\n261 \n262     # if BoundaryNorm, then set levels\n263     if isinstance(norm, mpl.colors.BoundaryNorm):\n264         levels = norm.boundaries\n265 \n266     # Choose default colormaps if not provided\n267     if cmap is None:\n268         if divergent:\n269             cmap = OPTIONS[\"cmap_divergent\"]\n270         else:\n271             cmap = OPTIONS[\"cmap_sequential\"]\n272 \n273     # Handle discrete levels\n274     if levels is not None:\n275         if is_scalar(levels):\n276             if user_minmax:\n277                 levels = np.linspace(vmin, vmax, levels)\n278             elif levels == 1:\n279                 levels = np.asarray([(vmin + vmax) / 2])\n280             else:\n281                 # N in MaxNLocator refers to bins, not ticks\n282                 ticker = mpl.ticker.MaxNLocator(levels - 1)\n283                 levels = ticker.tick_values(vmin, vmax)\n284         vmin, vmax = levels[0], levels[-1]\n285 \n286     # GH3734\n287     if vmin == vmax:\n288         vmin, vmax = mpl.ticker.LinearLocator(2).tick_values(vmin, vmax)\n289 \n290     if extend is None:\n291         extend = _determine_extend(calc_data, vmin, vmax)\n292 \n293     if levels is not None or isinstance(norm, mpl.colors.BoundaryNorm):\n294         cmap, newnorm = _build_discrete_cmap(cmap, levels, extend, filled)\n295         norm = newnorm if norm is None else norm\n296 \n297     # vmin & vmax needs to be None if norm is passed\n298     # TODO: always return a norm with vmin and vmax\n299     if norm is not None:\n300         vmin = None\n301         vmax = None\n302 \n303     return dict(\n304         vmin=vmin, vmax=vmax, cmap=cmap, extend=extend, levels=levels, norm=norm\n305     )\n306 \n307 \n308 def _infer_xy_labels_3d(darray, x, y, rgb):\n309     \"\"\"\n310     Determine x and y labels for showing RGB images.\n311 \n312     Attempts to infer which dimension is RGB/RGBA by size and order of dims.\n313 \n314     \"\"\"\n315     assert rgb is None or rgb != x\n316     assert rgb is None or rgb != y\n317     # Start by detecting and reporting invalid combinations of arguments\n318     assert darray.ndim == 3\n319     not_none = [a for a in (x, y, rgb) if a is not None]\n320     if len(set(not_none)) < len(not_none):\n321         raise ValueError(\n322             \"Dimension names must be None or unique strings, but imshow was \"\n323             f\"passed x={x!r}, y={y!r}, and rgb={rgb!r}.\"\n324         )\n325     for label in not_none:\n326         if label not in darray.dims:\n327             raise ValueError(f\"{label!r} is not a dimension\")\n328 \n329     # Then calculate rgb dimension if certain and check validity\n330     could_be_color = [\n331         label\n332         for label in darray.dims\n333         if darray[label].size in (3, 4) and label not in (x, y)\n334     ]\n335     if rgb is None and not could_be_color:\n336         raise ValueError(\n337             \"A 3-dimensional array was passed to imshow(), but there is no \"\n338             \"dimension that could be color.  At least one dimension must be \"\n339             \"of size 3 (RGB) or 4 (RGBA), and not given as x or y.\"\n340         )\n341     if rgb is None and len(could_be_color) == 1:\n342         rgb = could_be_color[0]\n343     if rgb is not None and darray[rgb].size not in (3, 4):\n344         raise ValueError(\n345             f\"Cannot interpret dim {rgb!r} of size {darray[rgb].size} as RGB or RGBA.\"\n346         )\n347 \n348     # If rgb dimension is still unknown, there must be two or three dimensions\n349     # in could_be_color.  We therefore warn, and use a heuristic to break ties.\n350     if rgb is None:\n351         assert len(could_be_color) in (2, 3)\n352         rgb = could_be_color[-1]\n353         warnings.warn(\n354             \"Several dimensions of this array could be colors.  Xarray \"\n355             f\"will use the last possible dimension ({rgb!r}) to match \"\n356             \"matplotlib.pyplot.imshow.  You can pass names of x, y, \"\n357             \"and/or rgb dimensions to override this guess.\"\n358         )\n359     assert rgb is not None\n360 \n361     # Finally, we pick out the red slice and delegate to the 2D version:\n362     return _infer_xy_labels(darray.isel(**{rgb: 0}), x, y)\n363 \n364 \n365 def _infer_xy_labels(darray, x, y, imshow=False, rgb=None):\n366     \"\"\"\n367     Determine x and y labels. For use in _plot2d\n368 \n369     darray must be a 2 dimensional data array, or 3d for imshow only.\n370     \"\"\"\n371     if (x is not None) and (x == y):\n372         raise ValueError(\"x and y cannot be equal.\")\n373 \n374     if imshow and darray.ndim == 3:\n375         return _infer_xy_labels_3d(darray, x, y, rgb)\n376 \n377     if x is None and y is None:\n378         if darray.ndim != 2:\n379             raise ValueError(\"DataArray must be 2d\")\n380         y, x = darray.dims\n381     elif x is None:\n382         _assert_valid_xy(darray, y, \"y\")\n383         x = darray.dims[0] if y == darray.dims[1] else darray.dims[1]\n384     elif y is None:\n385         _assert_valid_xy(darray, x, \"x\")\n386         y = darray.dims[0] if x == darray.dims[1] else darray.dims[1]\n387     else:\n388         _assert_valid_xy(darray, x, \"x\")\n389         _assert_valid_xy(darray, y, \"y\")\n390 \n391         if (\n392             all(k in darray._level_coords for k in (x, y))\n393             and darray._level_coords[x] == darray._level_coords[y]\n394         ):\n395             raise ValueError(\"x and y cannot be levels of the same MultiIndex\")\n396 \n397     return x, y\n398 \n399 \n400 def _assert_valid_xy(darray, xy, name):\n401     \"\"\"\n402     make sure x and y passed to plotting functions are valid\n403     \"\"\"\n404 \n405     # MultiIndex cannot be plotted; no point in allowing them here\n406     multiindex = {darray._level_coords[lc] for lc in darray._level_coords}\n407 \n408     valid_xy = (\n409         set(darray.dims) | set(darray.coords) | set(darray._level_coords)\n410     ) - multiindex\n411 \n412     if xy not in valid_xy:\n413         valid_xy_str = \"', '\".join(sorted(valid_xy))\n414         raise ValueError(f\"{name} must be one of None, '{valid_xy_str}'\")\n415 \n416 \n417 def get_axis(figsize=None, size=None, aspect=None, ax=None, **kwargs):\n418     try:\n419         import matplotlib as mpl\n420         import matplotlib.pyplot as plt\n421     except ImportError:\n422         raise ImportError(\"matplotlib is required for plot.utils.get_axis\")\n423 \n424     if figsize is not None:\n425         if ax is not None:\n426             raise ValueError(\"cannot provide both `figsize` and `ax` arguments\")\n427         if size is not None:\n428             raise ValueError(\"cannot provide both `figsize` and `size` arguments\")\n429         _, ax = plt.subplots(figsize=figsize)\n430     elif size is not None:\n431         if ax is not None:\n432             raise ValueError(\"cannot provide both `size` and `ax` arguments\")\n433         if aspect is None:\n434             width, height = mpl.rcParams[\"figure.figsize\"]\n435             aspect = width / height\n436         figsize = (size * aspect, size)\n437         _, ax = plt.subplots(figsize=figsize)\n438     elif aspect is not None:\n439         raise ValueError(\"cannot provide `aspect` argument without `size`\")\n440 \n441     if kwargs and ax is not None:\n442         raise ValueError(\"cannot use subplot_kws with existing ax\")\n443 \n444     if ax is None:\n445         ax = _maybe_gca(**kwargs)\n446 \n447     return ax\n448 \n449 \n450 def _maybe_gca(**kwargs):\n451 \n452     import matplotlib.pyplot as plt\n453 \n454     # can call gcf unconditionally: either it exists or would be created by plt.axes\n455     f = plt.gcf()\n456 \n457     # only call gca if an active axes exists\n458     if f.axes:\n459         # can not pass kwargs to active axes\n460         return plt.gca()\n461 \n462     return plt.axes(**kwargs)\n463 \n464 \n465 def label_from_attrs(da, extra=\"\"):\n466     \"\"\"Makes informative labels if variable metadata (attrs) follows\n467     CF conventions.\"\"\"\n468 \n469     if da.attrs.get(\"long_name\"):\n470         name = da.attrs[\"long_name\"]\n471     elif da.attrs.get(\"standard_name\"):\n472         name = da.attrs[\"standard_name\"]\n473     elif da.name is not None:\n474         name = da.name\n475     else:\n476         name = \"\"\n477 \n478     def _get_units_from_attrs(da):\n479         if da.attrs.get(\"units\"):\n480             units = \" [{}]\".format(da.attrs[\"units\"])\n481         elif da.attrs.get(\"unit\"):\n482             units = \" [{}]\".format(da.attrs[\"unit\"])\n483         else:\n484             units = \"\"\n485         return units\n486 \n487     pint_array_type = DuckArrayModule(\"pint\").type\n488     if isinstance(da.data, pint_array_type):\n489         units = \" [{}]\".format(str(da.data.units))\n490     else:\n491         units = _get_units_from_attrs(da)\n492 \n493     return \"\\n\".join(textwrap.wrap(name + extra + units, 30))\n494 \n495 \n496 def _interval_to_mid_points(array):\n497     \"\"\"\n498     Helper function which returns an array\n499     with the Intervals' mid points.\n500     \"\"\"\n501 \n502     return np.array([x.mid for x in array])\n503 \n504 \n505 def _interval_to_bound_points(array):\n506     \"\"\"\n507     Helper function which returns an array\n508     with the Intervals' boundaries.\n509     \"\"\"\n510 \n511     array_boundaries = np.array([x.left for x in array])\n512     array_boundaries = np.concatenate((array_boundaries, np.array([array[-1].right])))\n513 \n514     return array_boundaries\n515 \n516 \n517 def _interval_to_double_bound_points(xarray, yarray):\n518     \"\"\"\n519     Helper function to deal with a xarray consisting of pd.Intervals. Each\n520     interval is replaced with both boundaries. I.e. the length of xarray\n521     doubles. yarray is modified so it matches the new shape of xarray.\n522     \"\"\"\n523 \n524     xarray1 = np.array([x.left for x in xarray])\n525     xarray2 = np.array([x.right for x in xarray])\n526 \n527     xarray = list(itertools.chain.from_iterable(zip(xarray1, xarray2)))\n528     yarray = list(itertools.chain.from_iterable(zip(yarray, yarray)))\n529 \n530     return xarray, yarray\n531 \n532 \n533 def _resolve_intervals_1dplot(xval, yval, kwargs):\n534     \"\"\"\n535     Helper function to replace the values of x and/or y coordinate arrays\n536     containing pd.Interval with their mid-points or - for step plots - double\n537     points which double the length.\n538     \"\"\"\n539     x_suffix = \"\"\n540     y_suffix = \"\"\n541 \n542     # Is it a step plot? (see matplotlib.Axes.step)\n543     if kwargs.get(\"drawstyle\", \"\").startswith(\"steps-\"):\n544 \n545         remove_drawstyle = False\n546         # Convert intervals to double points\n547         if _valid_other_type(np.array([xval, yval]), [pd.Interval]):\n548             raise TypeError(\"Can't step plot intervals against intervals.\")\n549         if _valid_other_type(xval, [pd.Interval]):\n550             xval, yval = _interval_to_double_bound_points(xval, yval)\n551             remove_drawstyle = True\n552         if _valid_other_type(yval, [pd.Interval]):\n553             yval, xval = _interval_to_double_bound_points(yval, xval)\n554             remove_drawstyle = True\n555 \n556         # Remove steps-* to be sure that matplotlib is not confused\n557         if remove_drawstyle:\n558             del kwargs[\"drawstyle\"]\n559 \n560     # Is it another kind of plot?\n561     else:\n562 \n563         # Convert intervals to mid points and adjust labels\n564         if _valid_other_type(xval, [pd.Interval]):\n565             xval = _interval_to_mid_points(xval)\n566             x_suffix = \"_center\"\n567         if _valid_other_type(yval, [pd.Interval]):\n568             yval = _interval_to_mid_points(yval)\n569             y_suffix = \"_center\"\n570 \n571     # return converted arguments\n572     return xval, yval, x_suffix, y_suffix, kwargs\n573 \n574 \n575 def _resolve_intervals_2dplot(val, func_name):\n576     \"\"\"\n577     Helper function to replace the values of a coordinate array containing\n578     pd.Interval with their mid-points or - for pcolormesh - boundaries which\n579     increases length by 1.\n580     \"\"\"\n581     label_extra = \"\"\n582     if _valid_other_type(val, [pd.Interval]):\n583         if func_name == \"pcolormesh\":\n584             val = _interval_to_bound_points(val)\n585         else:\n586             val = _interval_to_mid_points(val)\n587             label_extra = \"_center\"\n588 \n589     return val, label_extra\n590 \n591 \n592 def _valid_other_type(x, types):\n593     \"\"\"\n594     Do all elements of x have a type from types?\n595     \"\"\"\n596     return all(any(isinstance(el, t) for t in types) for el in np.ravel(x))\n597 \n598 \n599 def _valid_numpy_subdtype(x, numpy_types):\n600     \"\"\"\n601     Is any dtype from numpy_types superior to the dtype of x?\n602     \"\"\"\n603     # If any of the types given in numpy_types is understood as numpy.generic,\n604     # all possible x will be considered valid.  This is probably unwanted.\n605     for t in numpy_types:\n606         assert not np.issubdtype(np.generic, t)\n607 \n608     return any(np.issubdtype(x.dtype, t) for t in numpy_types)\n609 \n610 \n611 def _ensure_plottable(*args):\n612     \"\"\"\n613     Raise exception if there is anything in args that can't be plotted on an\n614     axis by matplotlib.\n615     \"\"\"\n616     numpy_types = [\n617         np.floating,\n618         np.integer,\n619         np.timedelta64,\n620         np.datetime64,\n621         np.bool_,\n622         np.str_,\n623     ]\n624     other_types = [datetime]\n625     try:\n626         import cftime\n627 \n628         cftime_datetime = [cftime.datetime]\n629     except ImportError:\n630         cftime_datetime = []\n631     other_types = other_types + cftime_datetime\n632     for x in args:\n633         if not (\n634             _valid_numpy_subdtype(np.array(x), numpy_types)\n635             or _valid_other_type(np.array(x), other_types)\n636         ):\n637             raise TypeError(\n638                 \"Plotting requires coordinates to be numeric, boolean, \"\n639                 \"or dates of type numpy.datetime64, \"\n640                 \"datetime.datetime, cftime.datetime or \"\n641                 f\"pandas.Interval. Received data of type {np.array(x).dtype} instead.\"\n642             )\n643         if (\n644             _valid_other_type(np.array(x), cftime_datetime)\n645             and not nc_time_axis_available\n646         ):\n647             raise ImportError(\n648                 \"Plotting of arrays of cftime.datetime \"\n649                 \"objects or arrays indexed by \"\n650                 \"cftime.datetime objects requires the \"\n651                 \"optional `nc-time-axis` (v1.2.0 or later) \"\n652                 \"package.\"\n653             )\n654 \n655 \n656 def _is_numeric(arr):\n657     numpy_types = [np.floating, np.integer]\n658     return _valid_numpy_subdtype(arr, numpy_types)\n659 \n660 \n661 def _add_colorbar(primitive, ax, cbar_ax, cbar_kwargs, cmap_params):\n662 \n663     cbar_kwargs.setdefault(\"extend\", cmap_params[\"extend\"])\n664     if cbar_ax is None:\n665         cbar_kwargs.setdefault(\"ax\", ax)\n666     else:\n667         cbar_kwargs.setdefault(\"cax\", cbar_ax)\n668 \n669     # dont pass extend as kwarg if it is in the mappable\n670     if hasattr(primitive, \"extend\"):\n671         cbar_kwargs.pop(\"extend\")\n672 \n673     fig = ax.get_figure()\n674     cbar = fig.colorbar(primitive, **cbar_kwargs)\n675 \n676     return cbar\n677 \n678 \n679 def _rescale_imshow_rgb(darray, vmin, vmax, robust):\n680     assert robust or vmin is not None or vmax is not None\n681 \n682     # Calculate vmin and vmax automatically for `robust=True`\n683     if robust:\n684         if vmax is None:\n685             vmax = np.nanpercentile(darray, 100 - ROBUST_PERCENTILE)\n686         if vmin is None:\n687             vmin = np.nanpercentile(darray, ROBUST_PERCENTILE)\n688     # If not robust and one bound is None, calculate the default other bound\n689     # and check that an interval between them exists.\n690     elif vmax is None:\n691         vmax = 255 if np.issubdtype(darray.dtype, np.integer) else 1\n692         if vmax < vmin:\n693             raise ValueError(\n694                 f\"vmin={vmin!r} is less than the default vmax ({vmax!r}) - you must supply \"\n695                 \"a vmax > vmin in this case.\"\n696             )\n697     elif vmin is None:\n698         vmin = 0\n699         if vmin > vmax:\n700             raise ValueError(\n701                 f\"vmax={vmax!r} is less than the default vmin (0) - you must supply \"\n702                 \"a vmin < vmax in this case.\"\n703             )\n704     # Scale interval [vmin .. vmax] to [0 .. 1], with darray as 64-bit float\n705     # to avoid precision loss, integer over/underflow, etc with extreme inputs.\n706     # After scaling, downcast to 32-bit float.  This substantially reduces\n707     # memory usage after we hand `darray` off to matplotlib.\n708     darray = ((darray.astype(\"f8\") - vmin) / (vmax - vmin)).astype(\"f4\")\n709     return np.minimum(np.maximum(darray, 0), 1)\n710 \n711 \n712 def _update_axes(\n713     ax,\n714     xincrease,\n715     yincrease,\n716     xscale=None,\n717     yscale=None,\n718     xticks=None,\n719     yticks=None,\n720     xlim=None,\n721     ylim=None,\n722 ):\n723     \"\"\"\n724     Update axes with provided parameters\n725     \"\"\"\n726     if xincrease is None:\n727         pass\n728     elif xincrease and ax.xaxis_inverted():\n729         ax.invert_xaxis()\n730     elif not xincrease and not ax.xaxis_inverted():\n731         ax.invert_xaxis()\n732 \n733     if yincrease is None:\n734         pass\n735     elif yincrease and ax.yaxis_inverted():\n736         ax.invert_yaxis()\n737     elif not yincrease and not ax.yaxis_inverted():\n738         ax.invert_yaxis()\n739 \n740     # The default xscale, yscale needs to be None.\n741     # If we set a scale it resets the axes formatters,\n742     # This means that set_xscale('linear') on a datetime axis\n743     # will remove the date labels. So only set the scale when explicitly\n744     # asked to. https://github.com/matplotlib/matplotlib/issues/8740\n745     if xscale is not None:\n746         ax.set_xscale(xscale)\n747     if yscale is not None:\n748         ax.set_yscale(yscale)\n749 \n750     if xticks is not None:\n751         ax.set_xticks(xticks)\n752     if yticks is not None:\n753         ax.set_yticks(yticks)\n754 \n755     if xlim is not None:\n756         ax.set_xlim(xlim)\n757     if ylim is not None:\n758         ax.set_ylim(ylim)\n759 \n760 \n761 def _is_monotonic(coord, axis=0):\n762     \"\"\"\n763     >>> _is_monotonic(np.array([0, 1, 2]))\n764     True\n765     >>> _is_monotonic(np.array([2, 1, 0]))\n766     True\n767     >>> _is_monotonic(np.array([0, 2, 1]))\n768     False\n769     \"\"\"\n770     if coord.shape[axis] < 3:\n771         return True\n772     else:\n773         n = coord.shape[axis]\n774         delta_pos = coord.take(np.arange(1, n), axis=axis) >= coord.take(\n775             np.arange(0, n - 1), axis=axis\n776         )\n777         delta_neg = coord.take(np.arange(1, n), axis=axis) <= coord.take(\n778             np.arange(0, n - 1), axis=axis\n779         )\n780         return np.all(delta_pos) or np.all(delta_neg)\n781 \n782 \n783 def _infer_interval_breaks(coord, axis=0, scale=None, check_monotonic=False):\n784     \"\"\"\n785     >>> _infer_interval_breaks(np.arange(5))\n786     array([-0.5,  0.5,  1.5,  2.5,  3.5,  4.5])\n787     >>> _infer_interval_breaks([[0, 1], [3, 4]], axis=1)\n788     array([[-0.5,  0.5,  1.5],\n789            [ 2.5,  3.5,  4.5]])\n790     >>> _infer_interval_breaks(np.logspace(-2, 2, 5), scale=\"log\")\n791     array([3.16227766e-03, 3.16227766e-02, 3.16227766e-01, 3.16227766e+00,\n792            3.16227766e+01, 3.16227766e+02])\n793     \"\"\"\n794     coord = np.asarray(coord)\n795 \n796     if check_monotonic and not _is_monotonic(coord, axis=axis):\n797         raise ValueError(\n798             \"The input coordinate is not sorted in increasing \"\n799             \"order along axis %d. This can lead to unexpected \"\n800             \"results. Consider calling the `sortby` method on \"\n801             \"the input DataArray. To plot data with categorical \"\n802             \"axes, consider using the `heatmap` function from \"\n803             \"the `seaborn` statistical plotting library.\" % axis\n804         )\n805 \n806     # If logscale, compute the intervals in the logarithmic space\n807     if scale == \"log\":\n808         if (coord <= 0).any():\n809             raise ValueError(\n810                 \"Found negative or zero value in coordinates. \"\n811                 + \"Coordinates must be positive on logscale plots.\"\n812             )\n813         coord = np.log10(coord)\n814 \n815     deltas = 0.5 * np.diff(coord, axis=axis)\n816     if deltas.size == 0:\n817         deltas = np.array(0.0)\n818     first = np.take(coord, [0], axis=axis) - np.take(deltas, [0], axis=axis)\n819     last = np.take(coord, [-1], axis=axis) + np.take(deltas, [-1], axis=axis)\n820     trim_last = tuple(\n821         slice(None, -1) if n == axis else slice(None) for n in range(coord.ndim)\n822     )\n823     interval_breaks = np.concatenate(\n824         [first, coord[trim_last] + deltas, last], axis=axis\n825     )\n826     if scale == \"log\":\n827         # Recovert the intervals into the linear space\n828         return np.power(10, interval_breaks)\n829     return interval_breaks\n830 \n831 \n832 def _process_cmap_cbar_kwargs(\n833     func,\n834     data,\n835     cmap=None,\n836     colors=None,\n837     cbar_kwargs: Union[Iterable[Tuple[str, Any]], Mapping[str, Any]] = None,\n838     levels=None,\n839     _is_facetgrid=False,\n840     **kwargs,\n841 ):\n842     \"\"\"\n843     Parameters\n844     ----------\n845     func : plotting function\n846     data : ndarray,\n847         Data values\n848 \n849     Returns\n850     -------\n851     cmap_params\n852     cbar_kwargs\n853     \"\"\"\n854     if func.__name__ == \"surface\":\n855         # Leave user to specify cmap settings for surface plots\n856         kwargs[\"cmap\"] = cmap\n857         return {\n858             k: kwargs.get(k, None)\n859             for k in [\"vmin\", \"vmax\", \"cmap\", \"extend\", \"levels\", \"norm\"]\n860         }, {}\n861 \n862     cbar_kwargs = {} if cbar_kwargs is None else dict(cbar_kwargs)\n863 \n864     if \"contour\" in func.__name__ and levels is None:\n865         levels = 7  # this is the matplotlib default\n866 \n867     # colors is mutually exclusive with cmap\n868     if cmap and colors:\n869         raise ValueError(\"Can't specify both cmap and colors.\")\n870 \n871     # colors is only valid when levels is supplied or the plot is of type\n872     # contour or contourf\n873     if colors and ((\"contour\" not in func.__name__) and (levels is None)):\n874         raise ValueError(\"Can only specify colors with contour or levels\")\n875 \n876     # we should not be getting a list of colors in cmap anymore\n877     # is there a better way to do this test?\n878     if isinstance(cmap, (list, tuple)):\n879         raise ValueError(\n880             \"Specifying a list of colors in cmap is deprecated. \"\n881             \"Use colors keyword instead.\"\n882         )\n883 \n884     cmap_kwargs = {\n885         \"plot_data\": data,\n886         \"levels\": levels,\n887         \"cmap\": colors if colors else cmap,\n888         \"filled\": func.__name__ != \"contour\",\n889     }\n890 \n891     cmap_args = getfullargspec(_determine_cmap_params).args\n892     cmap_kwargs.update((a, kwargs[a]) for a in cmap_args if a in kwargs)\n893     if not _is_facetgrid:\n894         cmap_params = _determine_cmap_params(**cmap_kwargs)\n895     else:\n896         cmap_params = {\n897             k: cmap_kwargs[k]\n898             for k in [\"vmin\", \"vmax\", \"cmap\", \"extend\", \"levels\", \"norm\"]\n899         }\n900 \n901     return cmap_params, cbar_kwargs\n902 \n903 \n904 def _get_nice_quiver_magnitude(u, v):\n905     import matplotlib as mpl\n906 \n907     ticker = mpl.ticker.MaxNLocator(3)\n908     mean = np.mean(np.hypot(u.to_numpy(), v.to_numpy()))\n909     magnitude = ticker.tick_values(0, mean)[-2]\n910     return magnitude\n911 \n912 \n913 # Copied from matplotlib, tweaked so func can return strings.\n914 # https://github.com/matplotlib/matplotlib/issues/19555\n915 def legend_elements(\n916     self, prop=\"colors\", num=\"auto\", fmt=None, func=lambda x: x, **kwargs\n917 ):\n918     \"\"\"\n919     Create legend handles and labels for a PathCollection.\n920 \n921     Each legend handle is a `.Line2D` representing the Path that was drawn,\n922     and each label is a string what each Path represents.\n923 \n924     This is useful for obtaining a legend for a `~.Axes.scatter` plot;\n925     e.g.::\n926 \n927         scatter = plt.scatter([1, 2, 3],  [4, 5, 6],  c=[7, 2, 3])\n928         plt.legend(*scatter.legend_elements())\n929 \n930     creates three legend elements, one for each color with the numerical\n931     values passed to *c* as the labels.\n932 \n933     Also see the :ref:`automatedlegendcreation` example.\n934 \n935 \n936     Parameters\n937     ----------\n938     prop : {\"colors\", \"sizes\"}, default: \"colors\"\n939         If \"colors\", the legend handles will show the different colors of\n940         the collection. If \"sizes\", the legend will show the different\n941         sizes. To set both, use *kwargs* to directly edit the `.Line2D`\n942         properties.\n943     num : int, None, \"auto\" (default), array-like, or `~.ticker.Locator`\n944         Target number of elements to create.\n945         If None, use all unique elements of the mappable array. If an\n946         integer, target to use *num* elements in the normed range.\n947         If *\"auto\"*, try to determine which option better suits the nature\n948         of the data.\n949         The number of created elements may slightly deviate from *num* due\n950         to a `~.ticker.Locator` being used to find useful locations.\n951         If a list or array, use exactly those elements for the legend.\n952         Finally, a `~.ticker.Locator` can be provided.\n953     fmt : str, `~matplotlib.ticker.Formatter`, or None (default)\n954         The format or formatter to use for the labels. If a string must be\n955         a valid input for a `~.StrMethodFormatter`. If None (the default),\n956         use a `~.ScalarFormatter`.\n957     func : function, default: ``lambda x: x``\n958         Function to calculate the labels.  Often the size (or color)\n959         argument to `~.Axes.scatter` will have been pre-processed by the\n960         user using a function ``s = f(x)`` to make the markers visible;\n961         e.g. ``size = np.log10(x)``.  Providing the inverse of this\n962         function here allows that pre-processing to be inverted, so that\n963         the legend labels have the correct values; e.g. ``func = lambda\n964         x: 10**x``.\n965     **kwargs\n966         Allowed keyword arguments are *color* and *size*. E.g. it may be\n967         useful to set the color of the markers if *prop=\"sizes\"* is used;\n968         similarly to set the size of the markers if *prop=\"colors\"* is\n969         used. Any further parameters are passed onto the `.Line2D`\n970         instance. This may be useful to e.g. specify a different\n971         *markeredgecolor* or *alpha* for the legend handles.\n972 \n973     Returns\n974     -------\n975     handles : list of `.Line2D`\n976         Visual representation of each element of the legend.\n977     labels : list of str\n978         The string labels for elements of the legend.\n979     \"\"\"\n980     import warnings\n981 \n982     import matplotlib as mpl\n983 \n984     mlines = mpl.lines\n985 \n986     handles = []\n987     labels = []\n988 \n989     if prop == \"colors\":\n990         arr = self.get_array()\n991         if arr is None:\n992             warnings.warn(\n993                 \"Collection without array used. Make sure to \"\n994                 \"specify the values to be colormapped via the \"\n995                 \"`c` argument.\"\n996             )\n997             return handles, labels\n998         _size = kwargs.pop(\"size\", mpl.rcParams[\"lines.markersize\"])\n999 \n1000         def _get_color_and_size(value):\n1001             return self.cmap(self.norm(value)), _size\n1002 \n1003     elif prop == \"sizes\":\n1004         arr = self.get_sizes()\n1005         _color = kwargs.pop(\"color\", \"k\")\n1006 \n1007         def _get_color_and_size(value):\n1008             return _color, np.sqrt(value)\n1009 \n1010     else:\n1011         raise ValueError(\n1012             \"Valid values for `prop` are 'colors' or \"\n1013             f\"'sizes'. You supplied '{prop}' instead.\"\n1014         )\n1015 \n1016     # Get the unique values and their labels:\n1017     values = np.unique(arr)\n1018     label_values = np.asarray(func(values))\n1019     label_values_are_numeric = np.issubdtype(label_values.dtype, np.number)\n1020 \n1021     # Handle the label format:\n1022     if fmt is None and label_values_are_numeric:\n1023         fmt = mpl.ticker.ScalarFormatter(useOffset=False, useMathText=True)\n1024     elif fmt is None and not label_values_are_numeric:\n1025         fmt = mpl.ticker.StrMethodFormatter(\"{x}\")\n1026     elif isinstance(fmt, str):\n1027         fmt = mpl.ticker.StrMethodFormatter(fmt)\n1028     fmt.create_dummy_axis()\n1029 \n1030     if num == \"auto\":\n1031         num = 9\n1032         if len(values) <= num:\n1033             num = None\n1034 \n1035     if label_values_are_numeric:\n1036         label_values_min = label_values.min()\n1037         label_values_max = label_values.max()\n1038         fmt.set_bounds(label_values_min, label_values_max)\n1039 \n1040         if num is not None:\n1041             # Labels are numerical but larger than the target\n1042             # number of elements, reduce to target using matplotlibs\n1043             # ticker classes:\n1044             if isinstance(num, mpl.ticker.Locator):\n1045                 loc = num\n1046             elif np.iterable(num):\n1047                 loc = mpl.ticker.FixedLocator(num)\n1048             else:\n1049                 num = int(num)\n1050                 loc = mpl.ticker.MaxNLocator(\n1051                     nbins=num, min_n_ticks=num - 1, steps=[1, 2, 2.5, 3, 5, 6, 8, 10]\n1052                 )\n1053 \n1054             # Get nicely spaced label_values:\n1055             label_values = loc.tick_values(label_values_min, label_values_max)\n1056 \n1057             # Remove extrapolated label_values:\n1058             cond = (label_values >= label_values_min) & (\n1059                 label_values <= label_values_max\n1060             )\n1061             label_values = label_values[cond]\n1062 \n1063             # Get the corresponding values by creating a linear interpolant\n1064             # with small step size:\n1065             values_interp = np.linspace(values.min(), values.max(), 256)\n1066             label_values_interp = func(values_interp)\n1067             ix = np.argsort(label_values_interp)\n1068             values = np.interp(label_values, label_values_interp[ix], values_interp[ix])\n1069     elif num is not None and not label_values_are_numeric:\n1070         # Labels are not numerical so modifying label_values is not\n1071         # possible, instead filter the array with nicely distributed\n1072         # indexes:\n1073         if type(num) == int:\n1074             loc = mpl.ticker.LinearLocator(num)\n1075         else:\n1076             raise ValueError(\"`num` only supports integers for non-numeric labels.\")\n1077 \n1078         ind = loc.tick_values(0, len(label_values) - 1).astype(int)\n1079         label_values = label_values[ind]\n1080         values = values[ind]\n1081 \n1082     # Some formatters requires set_locs:\n1083     if hasattr(fmt, \"set_locs\"):\n1084         fmt.set_locs(label_values)\n1085 \n1086     # Default settings for handles, add or override with kwargs:\n1087     kw = dict(markeredgewidth=self.get_linewidths()[0], alpha=self.get_alpha())\n1088     kw.update(kwargs)\n1089 \n1090     for val, lab in zip(values, label_values):\n1091         color, size = _get_color_and_size(val)\n1092         h = mlines.Line2D(\n1093             [0], [0], ls=\"\", color=color, ms=size, marker=self.get_paths()[0], **kw\n1094         )\n1095         handles.append(h)\n1096         labels.append(fmt(lab))\n1097 \n1098     return handles, labels\n1099 \n1100 \n1101 def _legend_add_subtitle(handles, labels, text, func):\n1102     \"\"\"Add a subtitle to legend handles.\"\"\"\n1103     if text and len(handles) > 1:\n1104         # Create a blank handle that's not visible, the\n1105         # invisibillity will be used to discern which are subtitles\n1106         # or not:\n1107         blank_handle = func([], [], label=text)\n1108         blank_handle.set_visible(False)\n1109 \n1110         # Subtitles are shown first:\n1111         handles = [blank_handle] + handles\n1112         labels = [text] + labels\n1113 \n1114     return handles, labels\n1115 \n1116 \n1117 def _adjust_legend_subtitles(legend):\n1118     \"\"\"Make invisible-handle \"subtitles\" entries look more like titles.\"\"\"\n1119     plt = import_matplotlib_pyplot()\n1120 \n1121     # Legend title not in rcParams until 3.0\n1122     font_size = plt.rcParams.get(\"legend.title_fontsize\", None)\n1123     hpackers = legend.findobj(plt.matplotlib.offsetbox.VPacker)[0].get_children()\n1124     for hpack in hpackers:\n1125         draw_area, text_area = hpack.get_children()\n1126         handles = draw_area.get_children()\n1127 \n1128         # Assume that all artists that are not visible are\n1129         # subtitles:\n1130         if not all(artist.get_visible() for artist in handles):\n1131             # Remove the dummy marker which will bring the text\n1132             # more to the center:\n1133             draw_area.set_width(0)\n1134             for text in text_area.get_children():\n1135                 if font_size is not None:\n1136                     # The sutbtitles should have the same font size\n1137                     # as normal legend titles:\n1138                     text.set_size(font_size)\n",
        "intended_behavior": "This code should be analyzed and potentially modified to ensure that complex LaTeX expressions within 'long_name' attributes are recognized and rendered correctly when plots are generated."
    },
    {
        "rel_file_path": "xarray/plot/plot.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/pydata__xarray/setup_pydata__xarray__0.19/xarray/plot/plot.py",
        "start": 1,
        "end": 1496,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\"\n2 Use this module directly:\n3     import xarray.plot as xplt\n4 \n5 Or use the methods on a DataArray or Dataset:\n6     DataArray.plot._____\n7     Dataset.plot._____\n8 \"\"\"\n9 import functools\n10 from distutils.version import LooseVersion\n11 \n12 import numpy as np\n13 import pandas as pd\n14 \n15 from ..core.alignment import broadcast\n16 from .facetgrid import _easy_facetgrid\n17 from .utils import (\n18     _add_colorbar,\n19     _adjust_legend_subtitles,\n20     _assert_valid_xy,\n21     _ensure_plottable,\n22     _infer_interval_breaks,\n23     _infer_xy_labels,\n24     _is_numeric,\n25     _legend_add_subtitle,\n26     _process_cmap_cbar_kwargs,\n27     _rescale_imshow_rgb,\n28     _resolve_intervals_1dplot,\n29     _resolve_intervals_2dplot,\n30     _update_axes,\n31     get_axis,\n32     import_matplotlib_pyplot,\n33     label_from_attrs,\n34     legend_elements,\n35 )\n36 \n37 # copied from seaborn\n38 _MARKERSIZE_RANGE = np.array([18.0, 72.0])\n39 \n40 \n41 def _infer_scatter_metadata(darray, x, z, hue, hue_style, size):\n42     def _determine_array(darray, name, array_style):\n43         \"\"\"Find and determine what type of array it is.\"\"\"\n44         array = darray[name]\n45         array_is_numeric = _is_numeric(array.values)\n46 \n47         if array_style is None:\n48             array_style = \"continuous\" if array_is_numeric else \"discrete\"\n49         elif array_style not in [\"discrete\", \"continuous\"]:\n50             raise ValueError(\n51                 f\"The style '{array_style}' is not valid, \"\n52                 \"valid options are None, 'discrete' or 'continuous'.\"\n53             )\n54 \n55         array_label = label_from_attrs(array)\n56 \n57         return array, array_style, array_label\n58 \n59     # Add nice looking labels:\n60     out = dict(ylabel=label_from_attrs(darray))\n61     out.update(\n62         {\n63             k: label_from_attrs(darray[v]) if v in darray.coords else None\n64             for k, v in [(\"xlabel\", x), (\"zlabel\", z)]\n65         }\n66     )\n67 \n68     # Add styles and labels for the dataarrays:\n69     for type_, a, style in [(\"hue\", hue, hue_style), (\"size\", size, None)]:\n70         tp, stl, lbl = f\"{type_}\", f\"{type_}_style\", f\"{type_}_label\"\n71         if a:\n72             out[tp], out[stl], out[lbl] = _determine_array(darray, a, style)\n73         else:\n74             out[tp], out[stl], out[lbl] = None, None, None\n75 \n76     return out\n77 \n78 \n79 # copied from seaborn\n80 def _parse_size(data, norm, width):\n81     \"\"\"\n82     Determine what type of data it is. Then normalize it to width.\n83 \n84     If the data is categorical, normalize it to numbers.\n85     \"\"\"\n86     plt = import_matplotlib_pyplot()\n87 \n88     if data is None:\n89         return None\n90 \n91     data = data.values.ravel()\n92 \n93     if not _is_numeric(data):\n94         # Data is categorical.\n95         # Use pd.unique instead of np.unique because that keeps\n96         # the order of the labels:\n97         levels = pd.unique(data)\n98         numbers = np.arange(1, 1 + len(levels))\n99     else:\n100         levels = numbers = np.sort(np.unique(data))\n101 \n102     min_width, max_width = width\n103     # width_range = min_width, max_width\n104 \n105     if norm is None:\n106         norm = plt.Normalize()\n107     elif isinstance(norm, tuple):\n108         norm = plt.Normalize(*norm)\n109     elif not isinstance(norm, plt.Normalize):\n110         err = \"``size_norm`` must be None, tuple, or Normalize object.\"\n111         raise ValueError(err)\n112 \n113     norm.clip = True\n114     if not norm.scaled():\n115         norm(np.asarray(numbers))\n116     # limits = norm.vmin, norm.vmax\n117 \n118     scl = norm(numbers)\n119     widths = np.asarray(min_width + scl * (max_width - min_width))\n120     if scl.mask.any():\n121         widths[scl.mask] = 0\n122     sizes = dict(zip(levels, widths))\n123 \n124     return pd.Series(sizes)\n125 \n126 \n127 def _infer_scatter_data(\n128     darray, x, z, hue, size, size_norm, size_mapping=None, size_range=(1, 10)\n129 ):\n130     # Broadcast together all the chosen variables:\n131     to_broadcast = dict(y=darray)\n132     to_broadcast.update(\n133         {k: darray[v] for k, v in dict(x=x, z=z).items() if v is not None}\n134     )\n135     to_broadcast.update(\n136         {k: darray[v] for k, v in dict(hue=hue, size=size).items() if v in darray.dims}\n137     )\n138     broadcasted = dict(zip(to_broadcast.keys(), broadcast(*(to_broadcast.values()))))\n139 \n140     # Normalize hue and size and create lookup tables:\n141     for type_, mapping, norm, width in [\n142         (\"hue\", None, None, [0, 1]),\n143         (\"size\", size_mapping, size_norm, size_range),\n144     ]:\n145         broadcasted_type = broadcasted.get(type_, None)\n146         if broadcasted_type is not None:\n147             if mapping is None:\n148                 mapping = _parse_size(broadcasted_type, norm, width)\n149 \n150             broadcasted[type_] = broadcasted_type.copy(\n151                 data=np.reshape(\n152                     mapping.loc[broadcasted_type.values.ravel()].values,\n153                     broadcasted_type.shape,\n154                 )\n155             )\n156             broadcasted[f\"{type_}_to_label\"] = pd.Series(mapping.index, index=mapping)\n157 \n158     return broadcasted\n159 \n160 \n161 def _infer_line_data(darray, x, y, hue):\n162 \n163     ndims = len(darray.dims)\n164 \n165     if x is not None and y is not None:\n166         raise ValueError(\"Cannot specify both x and y kwargs for line plots.\")\n167 \n168     if x is not None:\n169         _assert_valid_xy(darray, x, \"x\")\n170 \n171     if y is not None:\n172         _assert_valid_xy(darray, y, \"y\")\n173 \n174     if ndims == 1:\n175         huename = None\n176         hueplt = None\n177         huelabel = \"\"\n178 \n179         if x is not None:\n180             xplt = darray[x]\n181             yplt = darray\n182 \n183         elif y is not None:\n184             xplt = darray\n185             yplt = darray[y]\n186 \n187         else:  # Both x & y are None\n188             dim = darray.dims[0]\n189             xplt = darray[dim]\n190             yplt = darray\n191 \n192     else:\n193         if x is None and y is None and hue is None:\n194             raise ValueError(\"For 2D inputs, please specify either hue, x or y.\")\n195 \n196         if y is None:\n197             if hue is not None:\n198                 _assert_valid_xy(darray, hue, \"hue\")\n199             xname, huename = _infer_xy_labels(darray=darray, x=x, y=hue)\n200             xplt = darray[xname]\n201             if xplt.ndim > 1:\n202                 if huename in darray.dims:\n203                     otherindex = 1 if darray.dims.index(huename) == 0 else 0\n204                     otherdim = darray.dims[otherindex]\n205                     yplt = darray.transpose(otherdim, huename, transpose_coords=False)\n206                     xplt = xplt.transpose(otherdim, huename, transpose_coords=False)\n207                 else:\n208                     raise ValueError(\n209                         \"For 2D inputs, hue must be a dimension\"\n210                         \" i.e. one of \" + repr(darray.dims)\n211                     )\n212 \n213             else:\n214                 (xdim,) = darray[xname].dims\n215                 (huedim,) = darray[huename].dims\n216                 yplt = darray.transpose(xdim, huedim)\n217 \n218         else:\n219             yname, huename = _infer_xy_labels(darray=darray, x=y, y=hue)\n220             yplt = darray[yname]\n221             if yplt.ndim > 1:\n222                 if huename in darray.dims:\n223                     otherindex = 1 if darray.dims.index(huename) == 0 else 0\n224                     otherdim = darray.dims[otherindex]\n225                     xplt = darray.transpose(otherdim, huename, transpose_coords=False)\n226                     yplt = yplt.transpose(otherdim, huename, transpose_coords=False)\n227                 else:\n228                     raise ValueError(\n229                         \"For 2D inputs, hue must be a dimension\"\n230                         \" i.e. one of \" + repr(darray.dims)\n231                     )\n232 \n233             else:\n234                 (ydim,) = darray[yname].dims\n235                 (huedim,) = darray[huename].dims\n236                 xplt = darray.transpose(ydim, huedim)\n237 \n238         huelabel = label_from_attrs(darray[huename])\n239         hueplt = darray[huename]\n240 \n241     return xplt, yplt, hueplt, huelabel\n242 \n243 \n244 def plot(\n245     darray,\n246     row=None,\n247     col=None,\n248     col_wrap=None,\n249     ax=None,\n250     hue=None,\n251     rtol=0.01,\n252     subplot_kws=None,\n253     **kwargs,\n254 ):\n255     \"\"\"\n256     Default plot of DataArray using :py:mod:`matplotlib:matplotlib.pyplot`.\n257 \n258     Calls xarray plotting function based on the dimensions of\n259     the squeezed DataArray.\n260 \n261     =============== ===========================\n262     Dimensions      Plotting function\n263     =============== ===========================\n264     1               :py:func:`xarray.plot.line`\n265     2               :py:func:`xarray.plot.pcolormesh`\n266     Anything else   :py:func:`xarray.plot.hist`\n267     =============== ===========================\n268 \n269     Parameters\n270     ----------\n271     darray : DataArray\n272     row : str, optional\n273         If passed, make row faceted plots on this dimension name.\n274     col : str, optional\n275         If passed, make column faceted plots on this dimension name.\n276     hue : str, optional\n277         If passed, make faceted line plots with hue on this dimension name.\n278     col_wrap : int, optional\n279         Use together with ``col`` to wrap faceted plots.\n280     ax : matplotlib axes object, optional\n281         If ``None``, use the current axes. Not applicable when using facets.\n282     rtol : float, optional\n283         Relative tolerance used to determine if the indexes\n284         are uniformly spaced. Usually a small positive number.\n285     subplot_kws : dict, optional\n286         Dictionary of keyword arguments for Matplotlib subplots\n287         (see :py:meth:`matplotlib:matplotlib.figure.Figure.add_subplot`).\n288     **kwargs : optional\n289         Additional keyword arguments for Matplotlib.\n290 \n291     See Also\n292     --------\n293     xarray.DataArray.squeeze\n294     \"\"\"\n295     darray = darray.squeeze().compute()\n296 \n297     plot_dims = set(darray.dims)\n298     plot_dims.discard(row)\n299     plot_dims.discard(col)\n300     plot_dims.discard(hue)\n301 \n302     ndims = len(plot_dims)\n303 \n304     error_msg = (\n305         \"Only 1d and 2d plots are supported for facets in xarray. \"\n306         \"See the package `Seaborn` for more options.\"\n307     )\n308 \n309     if ndims in [1, 2]:\n310         if row or col:\n311             kwargs[\"subplot_kws\"] = subplot_kws\n312             kwargs[\"row\"] = row\n313             kwargs[\"col\"] = col\n314             kwargs[\"col_wrap\"] = col_wrap\n315         if ndims == 1:\n316             plotfunc = line\n317             kwargs[\"hue\"] = hue\n318         elif ndims == 2:\n319             if hue:\n320                 plotfunc = line\n321                 kwargs[\"hue\"] = hue\n322             else:\n323                 plotfunc = pcolormesh\n324                 kwargs[\"subplot_kws\"] = subplot_kws\n325     else:\n326         if row or col or hue:\n327             raise ValueError(error_msg)\n328         plotfunc = hist\n329 \n330     kwargs[\"ax\"] = ax\n331 \n332     return plotfunc(darray, **kwargs)\n333 \n334 \n335 # This function signature should not change so that it can use\n336 # matplotlib format strings\n337 def line(\n338     darray,\n339     *args,\n340     row=None,\n341     col=None,\n342     figsize=None,\n343     aspect=None,\n344     size=None,\n345     ax=None,\n346     hue=None,\n347     x=None,\n348     y=None,\n349     xincrease=None,\n350     yincrease=None,\n351     xscale=None,\n352     yscale=None,\n353     xticks=None,\n354     yticks=None,\n355     xlim=None,\n356     ylim=None,\n357     add_legend=True,\n358     _labels=True,\n359     **kwargs,\n360 ):\n361     \"\"\"\n362     Line plot of DataArray values.\n363 \n364     Wraps :py:func:`matplotlib:matplotlib.pyplot.plot`.\n365 \n366     Parameters\n367     ----------\n368     darray : DataArray\n369         Either 1D or 2D. If 2D, one of ``hue``, ``x`` or ``y`` must be provided.\n370     figsize : tuple, optional\n371         A tuple (width, height) of the figure in inches.\n372         Mutually exclusive with ``size`` and ``ax``.\n373     aspect : scalar, optional\n374         Aspect ratio of plot, so that ``aspect * size`` gives the *width* in\n375         inches. Only used if a ``size`` is provided.\n376     size : scalar, optional\n377         If provided, create a new figure for the plot with the given size:\n378         *height* (in inches) of each plot. See also: ``aspect``.\n379     ax : matplotlib axes object, optional\n380         Axes on which to plot. By default, the current is used.\n381         Mutually exclusive with ``size`` and ``figsize``.\n382     hue : str, optional\n383         Dimension or coordinate for which you want multiple lines plotted.\n384         If plotting against a 2D coordinate, ``hue`` must be a dimension.\n385     x, y : str, optional\n386         Dimension, coordinate or multi-index level for *x*, *y* axis.\n387         Only one of these may be specified.\n388         The other will be used for values from the DataArray on which this\n389         plot method is called.\n390     xscale, yscale : {'linear', 'symlog', 'log', 'logit'}, optional\n391         Specifies scaling for the *x*- and *y*-axis, respectively.\n392     xticks, yticks : array-like, optional\n393         Specify tick locations for *x*- and *y*-axis.\n394     xlim, ylim : array-like, optional\n395         Specify *x*- and *y*-axis limits.\n396     xincrease : None, True, or False, optional\n397         Should the values on the *x* axis be increasing from left to right?\n398         if ``None``, use the default for the Matplotlib function.\n399     yincrease : None, True, or False, optional\n400         Should the values on the *y* axis be increasing from top to bottom?\n401         if ``None``, use the default for the Matplotlib function.\n402     add_legend : bool, optional\n403         Add legend with *y* axis coordinates (2D inputs only).\n404     *args, **kwargs : optional\n405         Additional arguments to :py:func:`matplotlib:matplotlib.pyplot.plot`.\n406     \"\"\"\n407     # Handle facetgrids first\n408     if row or col:\n409         allargs = locals().copy()\n410         allargs.update(allargs.pop(\"kwargs\"))\n411         allargs.pop(\"darray\")\n412         return _easy_facetgrid(darray, line, kind=\"line\", **allargs)\n413 \n414     ndims = len(darray.dims)\n415     if ndims > 2:\n416         raise ValueError(\n417             \"Line plots are for 1- or 2-dimensional DataArrays. \"\n418             \"Passed DataArray has {ndims} \"\n419             \"dimensions\".format(ndims=ndims)\n420         )\n421 \n422     # The allargs dict passed to _easy_facetgrid above contains args\n423     if args == ():\n424         args = kwargs.pop(\"args\", ())\n425     else:\n426         assert \"args\" not in kwargs\n427 \n428     ax = get_axis(figsize, size, aspect, ax)\n429     xplt, yplt, hueplt, hue_label = _infer_line_data(darray, x, y, hue)\n430 \n431     # Remove pd.Intervals if contained in xplt.values and/or yplt.values.\n432     xplt_val, yplt_val, x_suffix, y_suffix, kwargs = _resolve_intervals_1dplot(\n433         xplt.to_numpy(), yplt.to_numpy(), kwargs\n434     )\n435     xlabel = label_from_attrs(xplt, extra=x_suffix)\n436     ylabel = label_from_attrs(yplt, extra=y_suffix)\n437 \n438     _ensure_plottable(xplt_val, yplt_val)\n439 \n440     primitive = ax.plot(xplt_val, yplt_val, *args, **kwargs)\n441 \n442     if _labels:\n443         if xlabel is not None:\n444             ax.set_xlabel(xlabel)\n445 \n446         if ylabel is not None:\n447             ax.set_ylabel(ylabel)\n448 \n449         ax.set_title(darray._title_for_slice())\n450 \n451     if darray.ndim == 2 and add_legend:\n452         ax.legend(handles=primitive, labels=list(hueplt.to_numpy()), title=hue_label)\n453 \n454     # Rotate dates on xlabels\n455     # Do this without calling autofmt_xdate so that x-axes ticks\n456     # on other subplots (if any) are not deleted.\n457     # https://stackoverflow.com/questions/17430105/autofmt-xdate-deletes-x-axis-labels-of-all-subplots\n458     if np.issubdtype(xplt.dtype, np.datetime64):\n459         for xlabels in ax.get_xticklabels():\n460             xlabels.set_rotation(30)\n461             xlabels.set_ha(\"right\")\n462 \n463     _update_axes(ax, xincrease, yincrease, xscale, yscale, xticks, yticks, xlim, ylim)\n464 \n465     return primitive\n466 \n467 \n468 def step(darray, *args, where=\"pre\", drawstyle=None, ds=None, **kwargs):\n469     \"\"\"\n470     Step plot of DataArray values.\n471 \n472     Similar to :py:func:`matplotlib:matplotlib.pyplot.step`.\n473 \n474     Parameters\n475     ----------\n476     where : {'pre', 'post', 'mid'}, default: 'pre'\n477         Define where the steps should be placed:\n478 \n479         - ``'pre'``: The y value is continued constantly to the left from\n480           every *x* position, i.e. the interval ``(x[i-1], x[i]]`` has the\n481           value ``y[i]``.\n482         - ``'post'``: The y value is continued constantly to the right from\n483           every *x* position, i.e. the interval ``[x[i], x[i+1])`` has the\n484           value ``y[i]``.\n485         - ``'mid'``: Steps occur half-way between the *x* positions.\n486 \n487         Note that this parameter is ignored if one coordinate consists of\n488         :py:class:`pandas.Interval` values, e.g. as a result of\n489         :py:func:`xarray.Dataset.groupby_bins`. In this case, the actual\n490         boundaries of the interval are used.\n491     *args, **kwargs : optional\n492         Additional arguments for :py:func:`xarray.plot.line`.\n493     \"\"\"\n494     if where not in {\"pre\", \"post\", \"mid\"}:\n495         raise ValueError(\"'where' argument to step must be 'pre', 'post' or 'mid'\")\n496 \n497     if ds is not None:\n498         if drawstyle is None:\n499             drawstyle = ds\n500         else:\n501             raise TypeError(\"ds and drawstyle are mutually exclusive\")\n502     if drawstyle is None:\n503         drawstyle = \"\"\n504     drawstyle = \"steps-\" + where + drawstyle\n505 \n506     return line(darray, *args, drawstyle=drawstyle, **kwargs)\n507 \n508 \n509 def hist(\n510     darray,\n511     figsize=None,\n512     size=None,\n513     aspect=None,\n514     ax=None,\n515     xincrease=None,\n516     yincrease=None,\n517     xscale=None,\n518     yscale=None,\n519     xticks=None,\n520     yticks=None,\n521     xlim=None,\n522     ylim=None,\n523     **kwargs,\n524 ):\n525     \"\"\"\n526     Histogram of DataArray.\n527 \n528     Wraps :py:func:`matplotlib:matplotlib.pyplot.hist`.\n529 \n530     Plots *N*-dimensional arrays by first flattening the array.\n531 \n532     Parameters\n533     ----------\n534     darray : DataArray\n535         Can have any number of dimensions.\n536     figsize : tuple, optional\n537         A tuple (width, height) of the figure in inches.\n538         Mutually exclusive with ``size`` and ``ax``.\n539     aspect : scalar, optional\n540         Aspect ratio of plot, so that ``aspect * size`` gives the *width* in\n541         inches. Only used if a ``size`` is provided.\n542     size : scalar, optional\n543         If provided, create a new figure for the plot with the given size:\n544         *height* (in inches) of each plot. See also: ``aspect``.\n545     ax : matplotlib axes object, optional\n546         Axes on which to plot. By default, use the current axes.\n547         Mutually exclusive with ``size`` and ``figsize``.\n548     **kwargs : optional\n549         Additional keyword arguments to :py:func:`matplotlib:matplotlib.pyplot.hist`.\n550 \n551     \"\"\"\n552     ax = get_axis(figsize, size, aspect, ax)\n553 \n554     no_nan = np.ravel(darray.to_numpy())\n555     no_nan = no_nan[pd.notnull(no_nan)]\n556 \n557     primitive = ax.hist(no_nan, **kwargs)\n558 \n559     ax.set_title(\"Histogram\")\n560     ax.set_xlabel(label_from_attrs(darray))\n561 \n562     _update_axes(ax, xincrease, yincrease, xscale, yscale, xticks, yticks, xlim, ylim)\n563 \n564     return primitive\n565 \n566 \n567 def scatter(\n568     darray,\n569     *args,\n570     row=None,\n571     col=None,\n572     figsize=None,\n573     aspect=None,\n574     size=None,\n575     ax=None,\n576     hue=None,\n577     hue_style=None,\n578     x=None,\n579     z=None,\n580     xincrease=None,\n581     yincrease=None,\n582     xscale=None,\n583     yscale=None,\n584     xticks=None,\n585     yticks=None,\n586     xlim=None,\n587     ylim=None,\n588     add_legend=None,\n589     add_colorbar=None,\n590     cbar_kwargs=None,\n591     cbar_ax=None,\n592     vmin=None,\n593     vmax=None,\n594     norm=None,\n595     infer_intervals=None,\n596     center=None,\n597     levels=None,\n598     robust=None,\n599     colors=None,\n600     extend=None,\n601     cmap=None,\n602     _labels=True,\n603     **kwargs,\n604 ):\n605     \"\"\"\n606     Scatter plot a DataArray along some coordinates.\n607 \n608     Parameters\n609     ----------\n610     darray : DataArray\n611         Dataarray to plot.\n612     x, y : str\n613         Variable names for x, y axis.\n614     hue: str, optional\n615         Variable by which to color scattered points\n616     hue_style: str, optional\n617         Can be either 'discrete' (legend) or 'continuous' (color bar).\n618     markersize: str, optional\n619         scatter only. Variable by which to vary size of scattered points.\n620     size_norm: optional\n621         Either None or 'Norm' instance to normalize the 'markersize' variable.\n622     add_guide: bool, optional\n623         Add a guide that depends on hue_style\n624             - for \"discrete\", build a legend.\n625               This is the default for non-numeric `hue` variables.\n626             - for \"continuous\",  build a colorbar\n627     row : str, optional\n628         If passed, make row faceted plots on this dimension name\n629     col : str, optional\n630         If passed, make column faceted plots on this dimension name\n631     col_wrap : int, optional\n632         Use together with ``col`` to wrap faceted plots\n633     ax : matplotlib axes object, optional\n634         If None, uses the current axis. Not applicable when using facets.\n635     subplot_kws : dict, optional\n636         Dictionary of keyword arguments for matplotlib subplots. Only applies\n637         to FacetGrid plotting.\n638     aspect : scalar, optional\n639         Aspect ratio of plot, so that ``aspect * size`` gives the width in\n640         inches. Only used if a ``size`` is provided.\n641     size : scalar, optional\n642         If provided, create a new figure for the plot with the given size.\n643         Height (in inches) of each plot. See also: ``aspect``.\n644     norm : ``matplotlib.colors.Normalize`` instance, optional\n645         If the ``norm`` has vmin or vmax specified, the corresponding kwarg\n646         must be None.\n647     vmin, vmax : float, optional\n648         Values to anchor the colormap, otherwise they are inferred from the\n649         data and other keyword arguments. When a diverging dataset is inferred,\n650         setting one of these values will fix the other by symmetry around\n651         ``center``. Setting both values prevents use of a diverging colormap.\n652         If discrete levels are provided as an explicit list, both of these\n653         values are ignored.\n654     cmap : str or colormap, optional\n655         The mapping from data values to color space. Either a\n656         matplotlib colormap name or object. If not provided, this will\n657         be either ``viridis`` (if the function infers a sequential\n658         dataset) or ``RdBu_r`` (if the function infers a diverging\n659         dataset).  When `Seaborn` is installed, ``cmap`` may also be a\n660         `seaborn` color palette. If ``cmap`` is seaborn color palette\n661         and the plot type is not ``contour`` or ``contourf``, ``levels``\n662         must also be specified.\n663     colors : color-like or list of color-like, optional\n664         A single color or a list of colors. If the plot type is not ``contour``\n665         or ``contourf``, the ``levels`` argument is required.\n666     center : float, optional\n667         The value at which to center the colormap. Passing this value implies\n668         use of a diverging colormap. Setting it to ``False`` prevents use of a\n669         diverging colormap.\n670     robust : bool, optional\n671         If True and ``vmin`` or ``vmax`` are absent, the colormap range is\n672         computed with 2nd and 98th percentiles instead of the extreme values.\n673     extend : {\"neither\", \"both\", \"min\", \"max\"}, optional\n674         How to draw arrows extending the colorbar beyond its limits. If not\n675         provided, extend is inferred from vmin, vmax and the data limits.\n676     levels : int or list-like object, optional\n677         Split the colormap (cmap) into discrete color intervals. If an integer\n678         is provided, \"nice\" levels are chosen based on the data range: this can\n679         imply that the final number of levels is not exactly the expected one.\n680         Setting ``vmin`` and/or ``vmax`` with ``levels=N`` is equivalent to\n681         setting ``levels=np.linspace(vmin, vmax, N)``.\n682     **kwargs : optional\n683         Additional keyword arguments to matplotlib\n684     \"\"\"\n685     plt = import_matplotlib_pyplot()\n686 \n687     # Handle facetgrids first\n688     if row or col:\n689         allargs = locals().copy()\n690         allargs.update(allargs.pop(\"kwargs\"))\n691         allargs.pop(\"darray\")\n692         subplot_kws = dict(projection=\"3d\") if z is not None else None\n693         return _easy_facetgrid(\n694             darray, scatter, kind=\"dataarray\", subplot_kws=subplot_kws, **allargs\n695         )\n696 \n697     # Further\n698     _is_facetgrid = kwargs.pop(\"_is_facetgrid\", False)\n699     if _is_facetgrid:\n700         # Why do I need to pop these here?\n701         kwargs.pop(\"y\", None)\n702         kwargs.pop(\"args\", None)\n703         kwargs.pop(\"add_labels\", None)\n704 \n705     _sizes = kwargs.pop(\"markersize\", kwargs.pop(\"linewidth\", None))\n706     size_norm = kwargs.pop(\"size_norm\", None)\n707     size_mapping = kwargs.pop(\"size_mapping\", None)  # set by facetgrid\n708     cmap_params = kwargs.pop(\"cmap_params\", None)\n709 \n710     figsize = kwargs.pop(\"figsize\", None)\n711     subplot_kws = dict()\n712     if z is not None and ax is None:\n713         # TODO: Importing Axes3D is not necessary in matplotlib >= 3.2.\n714         # Remove when minimum requirement of matplotlib is 3.2:\n715         from mpl_toolkits.mplot3d import Axes3D  # type: ignore # noqa\n716 \n717         subplot_kws.update(projection=\"3d\")\n718         ax = get_axis(figsize, size, aspect, ax, **subplot_kws)\n719         # Using 30, 30 minimizes rotation of the plot. Making it easier to\n720         # build on your intuition from 2D plots:\n721         if LooseVersion(plt.matplotlib.__version__) < \"3.5.0\":\n722             ax.view_init(azim=30, elev=30)\n723         else:\n724             # https://github.com/matplotlib/matplotlib/pull/19873\n725             ax.view_init(azim=30, elev=30, vertical_axis=\"y\")\n726     else:\n727         ax = get_axis(figsize, size, aspect, ax, **subplot_kws)\n728 \n729     _data = _infer_scatter_metadata(darray, x, z, hue, hue_style, _sizes)\n730 \n731     add_guide = kwargs.pop(\"add_guide\", None)\n732     if add_legend is not None:\n733         pass\n734     elif add_guide is None or add_guide is True:\n735         add_legend = True if _data[\"hue_style\"] == \"discrete\" else False\n736     elif add_legend is None:\n737         add_legend = False\n738 \n739     if add_colorbar is not None:\n740         pass\n741     elif add_guide is None or add_guide is True:\n742         add_colorbar = True if _data[\"hue_style\"] == \"continuous\" else False\n743     else:\n744         add_colorbar = False\n745 \n746     # need to infer size_mapping with full dataset\n747     _data.update(\n748         _infer_scatter_data(\n749             darray,\n750             x,\n751             z,\n752             hue,\n753             _sizes,\n754             size_norm,\n755             size_mapping,\n756             _MARKERSIZE_RANGE,\n757         )\n758     )\n759 \n760     cmap_params_subset = {}\n761     if _data[\"hue\"] is not None:\n762         kwargs.update(c=_data[\"hue\"].values.ravel())\n763         cmap_params, cbar_kwargs = _process_cmap_cbar_kwargs(\n764             scatter, _data[\"hue\"].values, **locals()\n765         )\n766 \n767         # subset that can be passed to scatter, hist2d\n768         cmap_params_subset = {\n769             vv: cmap_params[vv] for vv in [\"vmin\", \"vmax\", \"norm\", \"cmap\"]\n770         }\n771 \n772     if _data[\"size\"] is not None:\n773         kwargs.update(s=_data[\"size\"].values.ravel())\n774 \n775     if LooseVersion(plt.matplotlib.__version__) < \"3.5.0\":\n776         # Plot the data. 3d plots has the z value in upward direction\n777         # instead of y. To make jumping between 2d and 3d easy and intuitive\n778         # switch the order so that z is shown in the depthwise direction:\n779         axis_order = [\"x\", \"z\", \"y\"]\n780     else:\n781         # Switching axis order not needed in 3.5.0, can also simplify the code\n782         # that uses axis_order:\n783         # https://github.com/matplotlib/matplotlib/pull/19873\n784         axis_order = [\"x\", \"y\", \"z\"]\n785 \n786     primitive = ax.scatter(\n787         *[\n788             _data[v].values.ravel()\n789             for v in axis_order\n790             if _data.get(v, None) is not None\n791         ],\n792         **cmap_params_subset,\n793         **kwargs,\n794     )\n795 \n796     # Set x, y, z labels:\n797     i = 0\n798     set_label = [ax.set_xlabel, ax.set_ylabel, getattr(ax, \"set_zlabel\", None)]\n799     for v in axis_order:\n800         if _data.get(f\"{v}label\", None) is not None:\n801             set_label[i](_data[f\"{v}label\"])\n802             i += 1\n803 \n804     if add_legend:\n805 \n806         def to_label(data, key, x):\n807             \"\"\"Map prop values back to its original values.\"\"\"\n808             if key in data:\n809                 # Use reindex to be less sensitive to float errors.\n810                 # Return as numpy array since legend_elements\n811                 # seems to require that:\n812                 return data[key].reindex(x, method=\"nearest\").to_numpy()\n813             else:\n814                 return x\n815 \n816         handles, labels = [], []\n817         for subtitle, prop, func in [\n818             (\n819                 _data[\"hue_label\"],\n820                 \"colors\",\n821                 functools.partial(to_label, _data, \"hue_to_label\"),\n822             ),\n823             (\n824                 _data[\"size_label\"],\n825                 \"sizes\",\n826                 functools.partial(to_label, _data, \"size_to_label\"),\n827             ),\n828         ]:\n829             if subtitle:\n830                 # Get legend handles and labels that displays the\n831                 # values correctly. Order might be different because\n832                 # legend_elements uses np.unique instead of pd.unique,\n833                 # FacetGrid.add_legend might have troubles with this:\n834                 hdl, lbl = legend_elements(primitive, prop, num=\"auto\", func=func)\n835                 hdl, lbl = _legend_add_subtitle(hdl, lbl, subtitle, ax.scatter)\n836                 handles += hdl\n837                 labels += lbl\n838         legend = ax.legend(handles, labels, framealpha=0.5)\n839         _adjust_legend_subtitles(legend)\n840 \n841     if add_colorbar and _data[\"hue_label\"]:\n842         if _data[\"hue_style\"] == \"discrete\":\n843             raise NotImplementedError(\"Cannot create a colorbar for non numerics.\")\n844         cbar_kwargs = {} if cbar_kwargs is None else cbar_kwargs\n845         if \"label\" not in cbar_kwargs:\n846             cbar_kwargs[\"label\"] = _data[\"hue_label\"]\n847         _add_colorbar(primitive, ax, cbar_ax, cbar_kwargs, cmap_params)\n848 \n849     return primitive\n850 \n851 \n852 # MUST run before any 2d plotting functions are defined since\n853 # _plot2d decorator adds them as methods here.\n854 class _PlotMethods:\n855     \"\"\"\n856     Enables use of xarray.plot functions as attributes on a DataArray.\n857     For example, DataArray.plot.imshow\n858     \"\"\"\n859 \n860     __slots__ = (\"_da\",)\n861 \n862     def __init__(self, darray):\n863         self._da = darray\n864 \n865     def __call__(self, **kwargs):\n866         return plot(self._da, **kwargs)\n867 \n868     # we can't use functools.wraps here since that also modifies the name / qualname\n869     __doc__ = __call__.__doc__ = plot.__doc__\n870     __call__.__wrapped__ = plot  # type: ignore[attr-defined]\n871     __call__.__annotations__ = plot.__annotations__\n872 \n873     @functools.wraps(hist)\n874     def hist(self, ax=None, **kwargs):\n875         return hist(self._da, ax=ax, **kwargs)\n876 \n877     @functools.wraps(line)\n878     def line(self, *args, **kwargs):\n879         return line(self._da, *args, **kwargs)\n880 \n881     @functools.wraps(step)\n882     def step(self, *args, **kwargs):\n883         return step(self._da, *args, **kwargs)\n884 \n885     @functools.wraps(scatter)\n886     def _scatter(self, *args, **kwargs):\n887         return scatter(self._da, *args, **kwargs)\n888 \n889 \n890 def override_signature(f):\n891     def wrapper(func):\n892         func.__wrapped__ = f\n893 \n894         return func\n895 \n896     return wrapper\n897 \n898 \n899 def _plot2d(plotfunc):\n900     \"\"\"\n901     Decorator for common 2d plotting logic\n902 \n903     Also adds the 2d plot method to class _PlotMethods\n904     \"\"\"\n905     commondoc = \"\"\"\n906     Parameters\n907     ----------\n908     darray : DataArray\n909         Must be two-dimensional, unless creating faceted plots.\n910     x : str, optional\n911         Coordinate for *x* axis. If ``None``, use ``darray.dims[1]``.\n912     y : str, optional\n913         Coordinate for *y* axis. If ``None``, use ``darray.dims[0]``.\n914     figsize : tuple, optional\n915         A tuple (width, height) of the figure in inches.\n916         Mutually exclusive with ``size`` and ``ax``.\n917     aspect : scalar, optional\n918         Aspect ratio of plot, so that ``aspect * size`` gives the *width* in\n919         inches. Only used if a ``size`` is provided.\n920     size : scalar, optional\n921         If provided, create a new figure for the plot with the given size:\n922         *height* (in inches) of each plot. See also: ``aspect``.\n923     ax : matplotlib axes object, optional\n924         Axes on which to plot. By default, use the current axes.\n925         Mutually exclusive with ``size`` and ``figsize``.\n926     row : string, optional\n927         If passed, make row faceted plots on this dimension name.\n928     col : string, optional\n929         If passed, make column faceted plots on this dimension name.\n930     col_wrap : int, optional\n931         Use together with ``col`` to wrap faceted plots.\n932     xscale, yscale : {'linear', 'symlog', 'log', 'logit'}, optional\n933         Specifies scaling for the *x*- and *y*-axis, respectively.\n934     xticks, yticks : array-like, optional\n935         Specify tick locations for *x*- and *y*-axis.\n936     xlim, ylim : array-like, optional\n937         Specify *x*- and *y*-axis limits.\n938     xincrease : None, True, or False, optional\n939         Should the values on the *x* axis be increasing from left to right?\n940         If ``None``, use the default for the Matplotlib function.\n941     yincrease : None, True, or False, optional\n942         Should the values on the *y* axis be increasing from top to bottom?\n943         If ``None``, use the default for the Matplotlib function.\n944     add_colorbar : bool, optional\n945         Add colorbar to axes.\n946     add_labels : bool, optional\n947         Use xarray metadata to label axes.\n948     norm : matplotlib.colors.Normalize, optional\n949         If ``norm`` has ``vmin`` or ``vmax`` specified, the corresponding\n950         kwarg must be ``None``.\n951     vmin, vmax : float, optional\n952         Values to anchor the colormap, otherwise they are inferred from the\n953         data and other keyword arguments. When a diverging dataset is inferred,\n954         setting one of these values will fix the other by symmetry around\n955         ``center``. Setting both values prevents use of a diverging colormap.\n956         If discrete levels are provided as an explicit list, both of these\n957         values are ignored.\n958     cmap : matplotlib colormap name or colormap, optional\n959         The mapping from data values to color space. If not provided, this\n960         will be either be ``'viridis'`` (if the function infers a sequential\n961         dataset) or ``'RdBu_r'`` (if the function infers a diverging dataset).\n962         See :doc:`Choosing Colormaps in Matplotlib <matplotlib:tutorials/colors/colormaps>`\n963         for more information.\n964 \n965         If *seaborn* is installed, ``cmap`` may also be a\n966         `seaborn color palette <https://seaborn.pydata.org/tutorial/color_palettes.html>`_.\n967         Note: if ``cmap`` is a seaborn color palette and the plot type\n968         is not ``'contour'`` or ``'contourf'``, ``levels`` must also be specified.\n969     colors : str or array-like of color-like, optional\n970         A single color or a sequence of colors. If the plot type is not ``'contour'``\n971         or ``'contourf'``, the ``levels`` argument is required.\n972     center : float, optional\n973         The value at which to center the colormap. Passing this value implies\n974         use of a diverging colormap. Setting it to ``False`` prevents use of a\n975         diverging colormap.\n976     robust : bool, optional\n977         If ``True`` and ``vmin`` or ``vmax`` are absent, the colormap range is\n978         computed with 2nd and 98th percentiles instead of the extreme values.\n979     extend : {'neither', 'both', 'min', 'max'}, optional\n980         How to draw arrows extending the colorbar beyond its limits. If not\n981         provided, ``extend`` is inferred from ``vmin``, ``vmax`` and the data limits.\n982     levels : int or array-like, optional\n983         Split the colormap (``cmap``) into discrete color intervals. If an integer\n984         is provided, \"nice\" levels are chosen based on the data range: this can\n985         imply that the final number of levels is not exactly the expected one.\n986         Setting ``vmin`` and/or ``vmax`` with ``levels=N`` is equivalent to\n987         setting ``levels=np.linspace(vmin, vmax, N)``.\n988     infer_intervals : bool, optional\n989         Only applies to pcolormesh. If ``True``, the coordinate intervals are\n990         passed to pcolormesh. If ``False``, the original coordinates are used\n991         (this can be useful for certain map projections). The default is to\n992         always infer intervals, unless the mesh is irregular and plotted on\n993         a map projection.\n994     subplot_kws : dict, optional\n995         Dictionary of keyword arguments for Matplotlib subplots. Only used\n996         for 2D and faceted plots.\n997         (see :py:meth:`matplotlib:matplotlib.figure.Figure.add_subplot`).\n998     cbar_ax : matplotlib axes object, optional\n999         Axes in which to draw the colorbar.\n1000     cbar_kwargs : dict, optional\n1001         Dictionary of keyword arguments to pass to the colorbar\n1002         (see :meth:`matplotlib:matplotlib.figure.Figure.colorbar`).\n1003     **kwargs : optional\n1004         Additional keyword arguments to wrapped Matplotlib function.\n1005 \n1006     Returns\n1007     -------\n1008     artist :\n1009         The same type of primitive artist that the wrapped Matplotlib\n1010         function returns.\n1011     \"\"\"\n1012 \n1013     # Build on the original docstring\n1014     plotfunc.__doc__ = f\"{plotfunc.__doc__}\\n{commondoc}\"\n1015 \n1016     # plotfunc and newplotfunc have different signatures:\n1017     # - plotfunc: (x, y, z, ax, **kwargs)\n1018     # - newplotfunc: (darray, x, y, **kwargs)\n1019     # where plotfunc accepts numpy arrays, while newplotfunc accepts a DataArray\n1020     # and variable names. newplotfunc also explicitly lists most kwargs, so we\n1021     # need to shorten it\n1022     def signature(darray, x, y, **kwargs):\n1023         pass\n1024 \n1025     @override_signature(signature)\n1026     @functools.wraps(plotfunc)\n1027     def newplotfunc(\n1028         darray,\n1029         x=None,\n1030         y=None,\n1031         figsize=None,\n1032         size=None,\n1033         aspect=None,\n1034         ax=None,\n1035         row=None,\n1036         col=None,\n1037         col_wrap=None,\n1038         xincrease=True,\n1039         yincrease=True,\n1040         add_colorbar=None,\n1041         add_labels=True,\n1042         vmin=None,\n1043         vmax=None,\n1044         cmap=None,\n1045         center=None,\n1046         robust=False,\n1047         extend=None,\n1048         levels=None,\n1049         infer_intervals=None,\n1050         colors=None,\n1051         subplot_kws=None,\n1052         cbar_ax=None,\n1053         cbar_kwargs=None,\n1054         xscale=None,\n1055         yscale=None,\n1056         xticks=None,\n1057         yticks=None,\n1058         xlim=None,\n1059         ylim=None,\n1060         norm=None,\n1061         **kwargs,\n1062     ):\n1063         # All 2d plots in xarray share this function signature.\n1064         # Method signature below should be consistent.\n1065 \n1066         # Decide on a default for the colorbar before facetgrids\n1067         if add_colorbar is None:\n1068             add_colorbar = True\n1069             if plotfunc.__name__ == \"contour\" or (\n1070                 plotfunc.__name__ == \"surface\" and cmap is None\n1071             ):\n1072                 add_colorbar = False\n1073         imshow_rgb = plotfunc.__name__ == \"imshow\" and darray.ndim == (\n1074             3 + (row is not None) + (col is not None)\n1075         )\n1076         if imshow_rgb:\n1077             # Don't add a colorbar when showing an image with explicit colors\n1078             add_colorbar = False\n1079             # Matplotlib does not support normalising RGB data, so do it here.\n1080             # See eg. https://github.com/matplotlib/matplotlib/pull/10220\n1081             if robust or vmax is not None or vmin is not None:\n1082                 darray = _rescale_imshow_rgb(darray, vmin, vmax, robust)\n1083                 vmin, vmax, robust = None, None, False\n1084 \n1085         if subplot_kws is None:\n1086             subplot_kws = dict()\n1087 \n1088         if plotfunc.__name__ == \"surface\" and not kwargs.get(\"_is_facetgrid\", False):\n1089             if ax is None:\n1090                 # TODO: Importing Axes3D is no longer necessary in matplotlib >= 3.2.\n1091                 # Remove when minimum requirement of matplotlib is 3.2:\n1092                 from mpl_toolkits.mplot3d import Axes3D  # type: ignore  # noqa: F401\n1093 \n1094                 # delete so it does not end up in locals()\n1095                 del Axes3D\n1096 \n1097                 # Need to create a \"3d\" Axes instance for surface plots\n1098                 subplot_kws[\"projection\"] = \"3d\"\n1099 \n1100             # In facet grids, shared axis labels don't make sense for surface plots\n1101             sharex = False\n1102             sharey = False\n1103 \n1104         # Handle facetgrids first\n1105         if row or col:\n1106             allargs = locals().copy()\n1107             del allargs[\"darray\"]\n1108             del allargs[\"imshow_rgb\"]\n1109             allargs.update(allargs.pop(\"kwargs\"))\n1110             # Need the decorated plotting function\n1111             allargs[\"plotfunc\"] = globals()[plotfunc.__name__]\n1112             return _easy_facetgrid(darray, kind=\"dataarray\", **allargs)\n1113 \n1114         plt = import_matplotlib_pyplot()\n1115 \n1116         if (\n1117             plotfunc.__name__ == \"surface\"\n1118             and not kwargs.get(\"_is_facetgrid\", False)\n1119             and ax is not None\n1120         ):\n1121             import mpl_toolkits  # type: ignore\n1122 \n1123             if not isinstance(ax, mpl_toolkits.mplot3d.Axes3D):\n1124                 raise ValueError(\n1125                     \"If ax is passed to surface(), it must be created with \"\n1126                     'projection=\"3d\"'\n1127                 )\n1128 \n1129         rgb = kwargs.pop(\"rgb\", None)\n1130         if rgb is not None and plotfunc.__name__ != \"imshow\":\n1131             raise ValueError('The \"rgb\" keyword is only valid for imshow()')\n1132         elif rgb is not None and not imshow_rgb:\n1133             raise ValueError(\n1134                 'The \"rgb\" keyword is only valid for imshow()'\n1135                 \"with a three-dimensional array (per facet)\"\n1136             )\n1137 \n1138         xlab, ylab = _infer_xy_labels(\n1139             darray=darray, x=x, y=y, imshow=imshow_rgb, rgb=rgb\n1140         )\n1141 \n1142         xval = darray[xlab]\n1143         yval = darray[ylab]\n1144 \n1145         if xval.ndim > 1 or yval.ndim > 1 or plotfunc.__name__ == \"surface\":\n1146             # Passing 2d coordinate values, need to ensure they are transposed the same\n1147             # way as darray.\n1148             # Also surface plots always need 2d coordinates\n1149             xval = xval.broadcast_like(darray)\n1150             yval = yval.broadcast_like(darray)\n1151             dims = darray.dims\n1152         else:\n1153             dims = (yval.dims[0], xval.dims[0])\n1154 \n1155         # better to pass the ndarrays directly to plotting functions\n1156         xval = xval.to_numpy()\n1157         yval = yval.to_numpy()\n1158 \n1159         # May need to transpose for correct x, y labels\n1160         # xlab may be the name of a coord, we have to check for dim names\n1161         if imshow_rgb:\n1162             # For RGB[A] images, matplotlib requires the color dimension\n1163             # to be last.  In Xarray the order should be unimportant, so\n1164             # we transpose to (y, x, color) to make this work.\n1165             yx_dims = (ylab, xlab)\n1166             dims = yx_dims + tuple(d for d in darray.dims if d not in yx_dims)\n1167 \n1168         if dims != darray.dims:\n1169             darray = darray.transpose(*dims, transpose_coords=True)\n1170 \n1171         # Pass the data as a masked ndarray too\n1172         zval = darray.to_masked_array(copy=False)\n1173 \n1174         # Replace pd.Intervals if contained in xval or yval.\n1175         xplt, xlab_extra = _resolve_intervals_2dplot(xval, plotfunc.__name__)\n1176         yplt, ylab_extra = _resolve_intervals_2dplot(yval, plotfunc.__name__)\n1177 \n1178         _ensure_plottable(xplt, yplt, zval)\n1179 \n1180         cmap_params, cbar_kwargs = _process_cmap_cbar_kwargs(\n1181             plotfunc,\n1182             zval.data,\n1183             **locals(),\n1184             _is_facetgrid=kwargs.pop(\"_is_facetgrid\", False),\n1185         )\n1186 \n1187         if \"contour\" in plotfunc.__name__:\n1188             # extend is a keyword argument only for contour and contourf, but\n1189             # passing it to the colorbar is sufficient for imshow and\n1190             # pcolormesh\n1191             kwargs[\"extend\"] = cmap_params[\"extend\"]\n1192             kwargs[\"levels\"] = cmap_params[\"levels\"]\n1193             # if colors == a single color, matplotlib draws dashed negative\n1194             # contours. we lose this feature if we pass cmap and not colors\n1195             if isinstance(colors, str):\n1196                 cmap_params[\"cmap\"] = None\n1197                 kwargs[\"colors\"] = colors\n1198 \n1199         if \"pcolormesh\" == plotfunc.__name__:\n1200             kwargs[\"infer_intervals\"] = infer_intervals\n1201             kwargs[\"xscale\"] = xscale\n1202             kwargs[\"yscale\"] = yscale\n1203 \n1204         if \"imshow\" == plotfunc.__name__ and isinstance(aspect, str):\n1205             # forbid usage of mpl strings\n1206             raise ValueError(\"plt.imshow's `aspect` kwarg is not available in xarray\")\n1207 \n1208         ax = get_axis(figsize, size, aspect, ax, **subplot_kws)\n1209 \n1210         primitive = plotfunc(\n1211             xplt,\n1212             yplt,\n1213             zval,\n1214             ax=ax,\n1215             cmap=cmap_params[\"cmap\"],\n1216             vmin=cmap_params[\"vmin\"],\n1217             vmax=cmap_params[\"vmax\"],\n1218             norm=cmap_params[\"norm\"],\n1219             **kwargs,\n1220         )\n1221 \n1222         # Label the plot with metadata\n1223         if add_labels:\n1224             ax.set_xlabel(label_from_attrs(darray[xlab], xlab_extra))\n1225             ax.set_ylabel(label_from_attrs(darray[ylab], ylab_extra))\n1226             ax.set_title(darray._title_for_slice())\n1227             if plotfunc.__name__ == \"surface\":\n1228                 ax.set_zlabel(label_from_attrs(darray))\n1229 \n1230         if add_colorbar:\n1231             if add_labels and \"label\" not in cbar_kwargs:\n1232                 cbar_kwargs[\"label\"] = label_from_attrs(darray)\n1233             cbar = _add_colorbar(primitive, ax, cbar_ax, cbar_kwargs, cmap_params)\n1234         elif cbar_ax is not None or cbar_kwargs:\n1235             # inform the user about keywords which aren't used\n1236             raise ValueError(\n1237                 \"cbar_ax and cbar_kwargs can't be used with add_colorbar=False.\"\n1238             )\n1239 \n1240         # origin kwarg overrides yincrease\n1241         if \"origin\" in kwargs:\n1242             yincrease = None\n1243 \n1244         _update_axes(\n1245             ax, xincrease, yincrease, xscale, yscale, xticks, yticks, xlim, ylim\n1246         )\n1247 \n1248         # Rotate dates on xlabels\n1249         # Do this without calling autofmt_xdate so that x-axes ticks\n1250         # on other subplots (if any) are not deleted.\n1251         # https://stackoverflow.com/questions/17430105/autofmt-xdate-deletes-x-axis-labels-of-all-subplots\n1252         if np.issubdtype(xplt.dtype, np.datetime64):\n1253             for xlabels in ax.get_xticklabels():\n1254                 xlabels.set_rotation(30)\n1255                 xlabels.set_ha(\"right\")\n1256 \n1257         return primitive\n1258 \n1259     # For use as DataArray.plot.plotmethod\n1260     @functools.wraps(newplotfunc)\n1261     def plotmethod(\n1262         _PlotMethods_obj,\n1263         x=None,\n1264         y=None,\n1265         figsize=None,\n1266         size=None,\n1267         aspect=None,\n1268         ax=None,\n1269         row=None,\n1270         col=None,\n1271         col_wrap=None,\n1272         xincrease=True,\n1273         yincrease=True,\n1274         add_colorbar=None,\n1275         add_labels=True,\n1276         vmin=None,\n1277         vmax=None,\n1278         cmap=None,\n1279         colors=None,\n1280         center=None,\n1281         robust=False,\n1282         extend=None,\n1283         levels=None,\n1284         infer_intervals=None,\n1285         subplot_kws=None,\n1286         cbar_ax=None,\n1287         cbar_kwargs=None,\n1288         xscale=None,\n1289         yscale=None,\n1290         xticks=None,\n1291         yticks=None,\n1292         xlim=None,\n1293         ylim=None,\n1294         norm=None,\n1295         **kwargs,\n1296     ):\n1297         \"\"\"\n1298         The method should have the same signature as the function.\n1299 \n1300         This just makes the method work on Plotmethods objects,\n1301         and passes all the other arguments straight through.\n1302         \"\"\"\n1303         allargs = locals()\n1304         allargs[\"darray\"] = _PlotMethods_obj._da\n1305         allargs.update(kwargs)\n1306         for arg in [\"_PlotMethods_obj\", \"newplotfunc\", \"kwargs\"]:\n1307             del allargs[arg]\n1308         return newplotfunc(**allargs)\n1309 \n1310     # Add to class _PlotMethods\n1311     setattr(_PlotMethods, plotmethod.__name__, plotmethod)\n1312 \n1313     return newplotfunc\n1314 \n1315 \n1316 @_plot2d\n1317 def imshow(x, y, z, ax, **kwargs):\n1318     \"\"\"\n1319     Image plot of 2D DataArray.\n1320 \n1321     Wraps :py:func:`matplotlib:matplotlib.pyplot.imshow`.\n1322 \n1323     While other plot methods require the DataArray to be strictly\n1324     two-dimensional, ``imshow`` also accepts a 3D array where some\n1325     dimension can be interpreted as RGB or RGBA color channels and\n1326     allows this dimension to be specified via the kwarg ``rgb=``.\n1327 \n1328     Unlike :py:func:`matplotlib:matplotlib.pyplot.imshow`, which ignores ``vmin``/``vmax``\n1329     for RGB(A) data,\n1330     xarray *will* use ``vmin`` and ``vmax`` for RGB(A) data\n1331     by applying a single scaling factor and offset to all bands.\n1332     Passing  ``robust=True`` infers ``vmin`` and ``vmax``\n1333     :ref:`in the usual way <robust-plotting>`.\n1334 \n1335     .. note::\n1336         This function needs uniformly spaced coordinates to\n1337         properly label the axes. Call :py:meth:`DataArray.plot` to check.\n1338 \n1339     The pixels are centered on the coordinates. For example, if the coordinate\n1340     value is 3.2, then the pixels for those coordinates will be centered on 3.2.\n1341     \"\"\"\n1342 \n1343     if x.ndim != 1 or y.ndim != 1:\n1344         raise ValueError(\n1345             \"imshow requires 1D coordinates, try using pcolormesh or contour(f)\"\n1346         )\n1347 \n1348     def _center_pixels(x):\n1349         \"\"\"Center the pixels on the coordinates.\"\"\"\n1350         if np.issubdtype(x.dtype, str):\n1351             # When using strings as inputs imshow converts it to\n1352             # integers. Choose extent values which puts the indices in\n1353             # in the center of the pixels:\n1354             return 0 - 0.5, len(x) - 0.5\n1355 \n1356         try:\n1357             # Center the pixels assuming uniform spacing:\n1358             xstep = 0.5 * (x[1] - x[0])\n1359         except IndexError:\n1360             # Arbitrary default value, similar to matplotlib behaviour:\n1361             xstep = 0.1\n1362 \n1363         return x[0] - xstep, x[-1] + xstep\n1364 \n1365     # Center the pixels:\n1366     left, right = _center_pixels(x)\n1367     top, bottom = _center_pixels(y)\n1368 \n1369     defaults = {\"origin\": \"upper\", \"interpolation\": \"nearest\"}\n1370 \n1371     if not hasattr(ax, \"projection\"):\n1372         # not for cartopy geoaxes\n1373         defaults[\"aspect\"] = \"auto\"\n1374 \n1375     # Allow user to override these defaults\n1376     defaults.update(kwargs)\n1377 \n1378     if defaults[\"origin\"] == \"upper\":\n1379         defaults[\"extent\"] = [left, right, bottom, top]\n1380     else:\n1381         defaults[\"extent\"] = [left, right, top, bottom]\n1382 \n1383     if z.ndim == 3:\n1384         # matplotlib imshow uses black for missing data, but Xarray makes\n1385         # missing data transparent.  We therefore add an alpha channel if\n1386         # there isn't one, and set it to transparent where data is masked.\n1387         if z.shape[-1] == 3:\n1388             alpha = np.ma.ones(z.shape[:2] + (1,), dtype=z.dtype)\n1389             if np.issubdtype(z.dtype, np.integer):\n1390                 alpha *= 255\n1391             z = np.ma.concatenate((z, alpha), axis=2)\n1392         else:\n1393             z = z.copy()\n1394         z[np.any(z.mask, axis=-1), -1] = 0\n1395 \n1396     primitive = ax.imshow(z, **defaults)\n1397 \n1398     # If x or y are strings the ticklabels have been replaced with\n1399     # integer indices. Replace them back to strings:\n1400     for axis, v in [(\"x\", x), (\"y\", y)]:\n1401         if np.issubdtype(v.dtype, str):\n1402             getattr(ax, f\"set_{axis}ticks\")(np.arange(len(v)))\n1403             getattr(ax, f\"set_{axis}ticklabels\")(v)\n1404 \n1405     return primitive\n1406 \n1407 \n1408 @_plot2d\n1409 def contour(x, y, z, ax, **kwargs):\n1410     \"\"\"\n1411     Contour plot of 2D DataArray.\n1412 \n1413     Wraps :py:func:`matplotlib:matplotlib.pyplot.contour`.\n1414     \"\"\"\n1415     primitive = ax.contour(x, y, z, **kwargs)\n1416     return primitive\n1417 \n1418 \n1419 @_plot2d\n1420 def contourf(x, y, z, ax, **kwargs):\n1421     \"\"\"\n1422     Filled contour plot of 2D DataArray.\n1423 \n1424     Wraps :py:func:`matplotlib:matplotlib.pyplot.contourf`.\n1425     \"\"\"\n1426     primitive = ax.contourf(x, y, z, **kwargs)\n1427     return primitive\n1428 \n1429 \n1430 @_plot2d\n1431 def pcolormesh(x, y, z, ax, xscale=None, yscale=None, infer_intervals=None, **kwargs):\n1432     \"\"\"\n1433     Pseudocolor plot of 2D DataArray.\n1434 \n1435     Wraps :py:func:`matplotlib:matplotlib.pyplot.pcolormesh`.\n1436     \"\"\"\n1437 \n1438     # decide on a default for infer_intervals (GH781)\n1439     x = np.asarray(x)\n1440     if infer_intervals is None:\n1441         if hasattr(ax, \"projection\"):\n1442             if len(x.shape) == 1:\n1443                 infer_intervals = True\n1444             else:\n1445                 infer_intervals = False\n1446         else:\n1447             infer_intervals = True\n1448 \n1449     if (\n1450         infer_intervals\n1451         and not np.issubdtype(x.dtype, str)\n1452         and (\n1453             (np.shape(x)[0] == np.shape(z)[1])\n1454             or ((x.ndim > 1) and (np.shape(x)[1] == np.shape(z)[1]))\n1455         )\n1456     ):\n1457         if len(x.shape) == 1:\n1458             x = _infer_interval_breaks(x, check_monotonic=True, scale=xscale)\n1459         else:\n1460             # we have to infer the intervals on both axes\n1461             x = _infer_interval_breaks(x, axis=1, scale=xscale)\n1462             x = _infer_interval_breaks(x, axis=0, scale=xscale)\n1463 \n1464     if (\n1465         infer_intervals\n1466         and not np.issubdtype(y.dtype, str)\n1467         and (np.shape(y)[0] == np.shape(z)[0])\n1468     ):\n1469         if len(y.shape) == 1:\n1470             y = _infer_interval_breaks(y, check_monotonic=True, scale=yscale)\n1471         else:\n1472             # we have to infer the intervals on both axes\n1473             y = _infer_interval_breaks(y, axis=1, scale=yscale)\n1474             y = _infer_interval_breaks(y, axis=0, scale=yscale)\n1475 \n1476     primitive = ax.pcolormesh(x, y, z, **kwargs)\n1477 \n1478     # by default, pcolormesh picks \"round\" values for bounds\n1479     # this results in ugly looking plots with lots of surrounding whitespace\n1480     if not hasattr(ax, \"projection\") and x.ndim == 1 and y.ndim == 1:\n1481         # not a cartopy geoaxis\n1482         ax.set_xlim(x[0], x[-1])\n1483         ax.set_ylim(y[0], y[-1])\n1484 \n1485     return primitive\n1486 \n1487 \n1488 @_plot2d\n1489 def surface(x, y, z, ax, **kwargs):\n1490     \"\"\"\n1491     Surface plot of 2D DataArray.\n1492 \n1493     Wraps :py:meth:`matplotlib:mpl_toolkits.mplot3d.axes3d.Axes3D.plot_surface`.\n1494     \"\"\"\n1495     primitive = ax.plot_surface(x, y, z, **kwargs)\n1496     return primitive\n",
        "intended_behavior": "Modify the way in which labels are set so that LaTeX encoded 'long_name' attributes are correctly interpreted and displayed by matplotlib."
    }
]