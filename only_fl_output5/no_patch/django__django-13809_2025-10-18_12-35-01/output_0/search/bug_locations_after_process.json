[
    {
        "rel_file_path": "django/core/management/commands/runserver.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__4.0/django/core/management/commands/runserver.py",
        "start": 24,
        "end": 158,
        "class_name": "Command",
        "method_name": null,
        "code": "24 class Command(BaseCommand):\n25     help = \"Starts a lightweight Web server for development.\"\n26 \n27     # Validation is called explicitly each time the server is reloaded.\n28     requires_system_checks = []\n29     stealth_options = ('shutdown_message',)\n30 \n31     default_addr = '127.0.0.1'\n32     default_addr_ipv6 = '::1'\n33     default_port = '8000'\n34     protocol = 'http'\n35     server_cls = WSGIServer\n36 \n37     def add_arguments(self, parser):\n38         parser.add_argument(\n39             'addrport', nargs='?',\n40             help='Optional port number, or ipaddr:port'\n41         )\n42         parser.add_argument(\n43             '--ipv6', '-6', action='store_true', dest='use_ipv6',\n44             help='Tells Django to use an IPv6 address.',\n45         )\n46         parser.add_argument(\n47             '--nothreading', action='store_false', dest='use_threading',\n48             help='Tells Django to NOT use threading.',\n49         )\n50         parser.add_argument(\n51             '--noreload', action='store_false', dest='use_reloader',\n52             help='Tells Django to NOT use the auto-reloader.',\n53         )\n54 \n55     def execute(self, *args, **options):\n56         if options['no_color']:\n57             # We rely on the environment because it's currently the only\n58             # way to reach WSGIRequestHandler. This seems an acceptable\n59             # compromise considering `runserver` runs indefinitely.\n60             os.environ[\"DJANGO_COLORS\"] = \"nocolor\"\n61         super().execute(*args, **options)\n62 \n63     def get_handler(self, *args, **options):\n64         \"\"\"Return the default WSGI handler for the runner.\"\"\"\n65         return get_internal_wsgi_application()\n66 \n67     def handle(self, *args, **options):\n68         if not settings.DEBUG and not settings.ALLOWED_HOSTS:\n69             raise CommandError('You must set settings.ALLOWED_HOSTS if DEBUG is False.')\n70 \n71         self.use_ipv6 = options['use_ipv6']\n72         if self.use_ipv6 and not socket.has_ipv6:\n73             raise CommandError('Your Python does not support IPv6.')\n74         self._raw_ipv6 = False\n75         if not options['addrport']:\n76             self.addr = ''\n77             self.port = self.default_port\n78         else:\n79             m = re.match(naiveip_re, options['addrport'])\n80             if m is None:\n81                 raise CommandError('\"%s\" is not a valid port number '\n82                                    'or address:port pair.' % options['addrport'])\n83             self.addr, _ipv4, _ipv6, _fqdn, self.port = m.groups()\n84             if not self.port.isdigit():\n85                 raise CommandError(\"%r is not a valid port number.\" % self.port)\n86             if self.addr:\n87                 if _ipv6:\n88                     self.addr = self.addr[1:-1]\n89                     self.use_ipv6 = True\n90                     self._raw_ipv6 = True\n91                 elif self.use_ipv6 and not _fqdn:\n92                     raise CommandError('\"%s\" is not a valid IPv6 address.' % self.addr)\n93         if not self.addr:\n94             self.addr = self.default_addr_ipv6 if self.use_ipv6 else self.default_addr\n95             self._raw_ipv6 = self.use_ipv6\n96         self.run(**options)\n97 \n98     def run(self, **options):\n99         \"\"\"Run the server, using the autoreloader if needed.\"\"\"\n100         use_reloader = options['use_reloader']\n101 \n102         if use_reloader:\n103             autoreload.run_with_reloader(self.inner_run, **options)\n104         else:\n105             self.inner_run(None, **options)\n106 \n107     def inner_run(self, *args, **options):\n108         # If an exception was silenced in ManagementUtility.execute in order\n109         # to be raised in the child process, raise it now.\n110         autoreload.raise_last_exception()\n111 \n112         threading = options['use_threading']\n113         # 'shutdown_message' is a stealth option.\n114         shutdown_message = options.get('shutdown_message', '')\n115         quit_command = 'CTRL-BREAK' if sys.platform == 'win32' else 'CONTROL-C'\n116 \n117         self.stdout.write(\"Performing system checks...\\n\\n\")\n118         self.check(display_num_errors=True)\n119         # Need to check migrations here, so can't use the\n120         # requires_migrations_check attribute.\n121         self.check_migrations()\n122         now = datetime.now().strftime('%B %d, %Y - %X')\n123         self.stdout.write(now)\n124         self.stdout.write((\n125             \"Django version %(version)s, using settings %(settings)r\\n\"\n126             \"Starting development server at %(protocol)s://%(addr)s:%(port)s/\\n\"\n127             \"Quit the server with %(quit_command)s.\"\n128         ) % {\n129             \"version\": self.get_version(),\n130             \"settings\": settings.SETTINGS_MODULE,\n131             \"protocol\": self.protocol,\n132             \"addr\": '[%s]' % self.addr if self._raw_ipv6 else self.addr,\n133             \"port\": self.port,\n134             \"quit_command\": quit_command,\n135         })\n136 \n137         try:\n138             handler = self.get_handler(*args, **options)\n139             run(self.addr, int(self.port), handler,\n140                 ipv6=self.use_ipv6, threading=threading, server_cls=self.server_cls)\n141         except OSError as e:\n142             # Use helpful error messages instead of ugly tracebacks.\n143             ERRORS = {\n144                 errno.EACCES: \"You don't have permission to access that port.\",\n145                 errno.EADDRINUSE: \"That port is already in use.\",\n146                 errno.EADDRNOTAVAIL: \"That IP address can't be assigned to.\",\n147             }\n148             try:\n149                 error_text = ERRORS[e.errno]\n150             except KeyError:\n151                 error_text = e\n152             self.stderr.write(\"Error: %s\" % error_text)\n153             # Need to use an OS exit because sys.exit doesn't work in a thread\n154             os._exit(1)\n155         except KeyboardInterrupt:\n156             if shutdown_message:\n157                 self.stdout.write(shutdown_message)\n158             sys.exit(0)\n",
        "intended_behavior": "The `Command` class in this file should be enhanced to include a new command-line option `--skip-checks`. This involves:\n     - Adding a new option to the command-line arguments parser to recognize `--skip-checks`.\n     - Modifying the `handle` method (or wherever the system checks are invoked) to conditionally execute system checks. If the `--skip-checks` option is provided, the command should bypass the normal system checks' execution flow while preserving all other functionalities of the `runserver` command. This option would ideally be designed to be consistent with the way other management command options are implemented in Django, using the framework's capabilities for defining and handling command-line options.\n     - The preservation of existing functionality is crucial. That means system checks should still run by default unless the `--skip-checks` option is explicitly provided by the user. This ensures that the default behavior of the `runserver` command remains unchanged, maintaining backward compatibility and following Django's design principles."
    }
]