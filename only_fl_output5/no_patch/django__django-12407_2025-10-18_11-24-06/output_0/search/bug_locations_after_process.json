[
    {
        "rel_file_path": "django/template/loader_tags.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.1/django/template/loader_tags.py",
        "start": 1,
        "end": 317,
        "class_name": null,
        "method_name": null,
        "code": "1 import posixpath\n2 from collections import defaultdict\n3 \n4 from django.utils.safestring import mark_safe\n5 \n6 from .base import (\n7     Node, Template, TemplateSyntaxError, TextNode, Variable, token_kwargs,\n8 )\n9 from .library import Library\n10 \n11 register = Library()\n12 \n13 BLOCK_CONTEXT_KEY = 'block_context'\n14 \n15 \n16 class BlockContext:\n17     def __init__(self):\n18         # Dictionary of FIFO queues.\n19         self.blocks = defaultdict(list)\n20 \n21     def add_blocks(self, blocks):\n22         for name, block in blocks.items():\n23             self.blocks[name].insert(0, block)\n24 \n25     def pop(self, name):\n26         try:\n27             return self.blocks[name].pop()\n28         except IndexError:\n29             return None\n30 \n31     def push(self, name, block):\n32         self.blocks[name].append(block)\n33 \n34     def get_block(self, name):\n35         try:\n36             return self.blocks[name][-1]\n37         except IndexError:\n38             return None\n39 \n40 \n41 class BlockNode(Node):\n42     def __init__(self, name, nodelist, parent=None):\n43         self.name, self.nodelist, self.parent = name, nodelist, parent\n44 \n45     def __repr__(self):\n46         return \"<Block Node: %s. Contents: %r>\" % (self.name, self.nodelist)\n47 \n48     def render(self, context):\n49         block_context = context.render_context.get(BLOCK_CONTEXT_KEY)\n50         with context.push():\n51             if block_context is None:\n52                 context['block'] = self\n53                 result = self.nodelist.render(context)\n54             else:\n55                 push = block = block_context.pop(self.name)\n56                 if block is None:\n57                     block = self\n58                 # Create new block so we can store context without thread-safety issues.\n59                 block = type(self)(block.name, block.nodelist)\n60                 block.context = context\n61                 context['block'] = block\n62                 result = block.nodelist.render(context)\n63                 if push is not None:\n64                     block_context.push(self.name, push)\n65         return result\n66 \n67     def super(self):\n68         if not hasattr(self, 'context'):\n69             raise TemplateSyntaxError(\n70                 \"'%s' object has no attribute 'context'. Did you use \"\n71                 \"{{ block.super }} in a base template?\" % self.__class__.__name__\n72             )\n73         render_context = self.context.render_context\n74         if (BLOCK_CONTEXT_KEY in render_context and\n75                 render_context[BLOCK_CONTEXT_KEY].get_block(self.name) is not None):\n76             return mark_safe(self.render(self.context))\n77         return ''\n78 \n79 \n80 class ExtendsNode(Node):\n81     must_be_first = True\n82     context_key = 'extends_context'\n83 \n84     def __init__(self, nodelist, parent_name, template_dirs=None):\n85         self.nodelist = nodelist\n86         self.parent_name = parent_name\n87         self.template_dirs = template_dirs\n88         self.blocks = {n.name: n for n in nodelist.get_nodes_by_type(BlockNode)}\n89 \n90     def __repr__(self):\n91         return '<%s: extends %s>' % (self.__class__.__name__, self.parent_name.token)\n92 \n93     def find_template(self, template_name, context):\n94         \"\"\"\n95         This is a wrapper around engine.find_template(). A history is kept in\n96         the render_context attribute between successive extends calls and\n97         passed as the skip argument. This enables extends to work recursively\n98         without extending the same template twice.\n99         \"\"\"\n100         history = context.render_context.setdefault(\n101             self.context_key, [self.origin],\n102         )\n103         template, origin = context.template.engine.find_template(\n104             template_name, skip=history,\n105         )\n106         history.append(origin)\n107         return template\n108 \n109     def get_parent(self, context):\n110         parent = self.parent_name.resolve(context)\n111         if not parent:\n112             error_msg = \"Invalid template name in 'extends' tag: %r.\" % parent\n113             if self.parent_name.filters or\\\n114                     isinstance(self.parent_name.var, Variable):\n115                 error_msg += \" Got this from the '%s' variable.\" %\\\n116                     self.parent_name.token\n117             raise TemplateSyntaxError(error_msg)\n118         if isinstance(parent, Template):\n119             # parent is a django.template.Template\n120             return parent\n121         if isinstance(getattr(parent, 'template', None), Template):\n122             # parent is a django.template.backends.django.Template\n123             return parent.template\n124         return self.find_template(parent, context)\n125 \n126     def render(self, context):\n127         compiled_parent = self.get_parent(context)\n128 \n129         if BLOCK_CONTEXT_KEY not in context.render_context:\n130             context.render_context[BLOCK_CONTEXT_KEY] = BlockContext()\n131         block_context = context.render_context[BLOCK_CONTEXT_KEY]\n132 \n133         # Add the block nodes from this node to the block context\n134         block_context.add_blocks(self.blocks)\n135 \n136         # If this block's parent doesn't have an extends node it is the root,\n137         # and its block nodes also need to be added to the block context.\n138         for node in compiled_parent.nodelist:\n139             # The ExtendsNode has to be the first non-text node.\n140             if not isinstance(node, TextNode):\n141                 if not isinstance(node, ExtendsNode):\n142                     blocks = {n.name: n for n in\n143                               compiled_parent.nodelist.get_nodes_by_type(BlockNode)}\n144                     block_context.add_blocks(blocks)\n145                 break\n146 \n147         # Call Template._render explicitly so the parser context stays\n148         # the same.\n149         with context.render_context.push_state(compiled_parent, isolated_context=False):\n150             return compiled_parent._render(context)\n151 \n152 \n153 class IncludeNode(Node):\n154     context_key = '__include_context'\n155 \n156     def __init__(self, template, *args, extra_context=None, isolated_context=False, **kwargs):\n157         self.template = template\n158         self.extra_context = extra_context or {}\n159         self.isolated_context = isolated_context\n160         super().__init__(*args, **kwargs)\n161 \n162     def render(self, context):\n163         \"\"\"\n164         Render the specified template and context. Cache the template object\n165         in render_context to avoid reparsing and loading when used in a for\n166         loop.\n167         \"\"\"\n168         template = self.template.resolve(context)\n169         # Does this quack like a Template?\n170         if not callable(getattr(template, 'render', None)):\n171             # If not, try the cache and get_template().\n172             template_name = template\n173             cache = context.render_context.dicts[0].setdefault(self, {})\n174             template = cache.get(template_name)\n175             if template is None:\n176                 template = context.template.engine.get_template(template_name)\n177                 cache[template_name] = template\n178         # Use the base.Template of a backends.django.Template.\n179         elif hasattr(template, 'template'):\n180             template = template.template\n181         values = {\n182             name: var.resolve(context)\n183             for name, var in self.extra_context.items()\n184         }\n185         if self.isolated_context:\n186             return template.render(context.new(values))\n187         with context.push(**values):\n188             return template.render(context)\n189 \n190 \n191 @register.tag('block')\n192 def do_block(parser, token):\n193     \"\"\"\n194     Define a block that can be overridden by child templates.\n195     \"\"\"\n196     # token.split_contents() isn't useful here because this tag doesn't accept variable as arguments\n197     bits = token.contents.split()\n198     if len(bits) != 2:\n199         raise TemplateSyntaxError(\"'%s' tag takes only one argument\" % bits[0])\n200     block_name = bits[1]\n201     # Keep track of the names of BlockNodes found in this template, so we can\n202     # check for duplication.\n203     try:\n204         if block_name in parser.__loaded_blocks:\n205             raise TemplateSyntaxError(\"'%s' tag with name '%s' appears more than once\" % (bits[0], block_name))\n206         parser.__loaded_blocks.append(block_name)\n207     except AttributeError:  # parser.__loaded_blocks isn't a list yet\n208         parser.__loaded_blocks = [block_name]\n209     nodelist = parser.parse(('endblock',))\n210 \n211     # This check is kept for backwards-compatibility. See #3100.\n212     endblock = parser.next_token()\n213     acceptable_endblocks = ('endblock', 'endblock %s' % block_name)\n214     if endblock.contents not in acceptable_endblocks:\n215         parser.invalid_block_tag(endblock, 'endblock', acceptable_endblocks)\n216 \n217     return BlockNode(block_name, nodelist)\n218 \n219 \n220 def construct_relative_path(current_template_name, relative_name):\n221     \"\"\"\n222     Convert a relative path (starting with './' or '../') to the full template\n223     name based on the current_template_name.\n224     \"\"\"\n225     if not relative_name.startswith((\"'./\", \"'../\", '\"./', '\"../')):\n226         # relative_name is a variable or a literal that doesn't contain a\n227         # relative path.\n228         return relative_name\n229 \n230     new_name = posixpath.normpath(\n231         posixpath.join(\n232             posixpath.dirname(current_template_name.lstrip('/')),\n233             relative_name.strip('\\'\"')\n234         )\n235     )\n236     if new_name.startswith('../'):\n237         raise TemplateSyntaxError(\n238             \"The relative path '%s' points outside the file hierarchy that \"\n239             \"template '%s' is in.\" % (relative_name, current_template_name)\n240         )\n241     if current_template_name.lstrip('/') == new_name:\n242         raise TemplateSyntaxError(\n243             \"The relative path '%s' was translated to template name '%s', the \"\n244             \"same template in which the tag appears.\"\n245             % (relative_name, current_template_name)\n246         )\n247     return '\"%s\"' % new_name\n248 \n249 \n250 @register.tag('extends')\n251 def do_extends(parser, token):\n252     \"\"\"\n253     Signal that this template extends a parent template.\n254 \n255     This tag may be used in two ways: ``{% extends \"base\" %}`` (with quotes)\n256     uses the literal value \"base\" as the name of the parent template to extend,\n257     or ``{% extends variable %}`` uses the value of ``variable`` as either the\n258     name of the parent template to extend (if it evaluates to a string) or as\n259     the parent template itself (if it evaluates to a Template object).\n260     \"\"\"\n261     bits = token.split_contents()\n262     if len(bits) != 2:\n263         raise TemplateSyntaxError(\"'%s' takes one argument\" % bits[0])\n264     bits[1] = construct_relative_path(parser.origin.template_name, bits[1])\n265     parent_name = parser.compile_filter(bits[1])\n266     nodelist = parser.parse()\n267     if nodelist.get_nodes_by_type(ExtendsNode):\n268         raise TemplateSyntaxError(\"'%s' cannot appear more than once in the same template\" % bits[0])\n269     return ExtendsNode(nodelist, parent_name)\n270 \n271 \n272 @register.tag('include')\n273 def do_include(parser, token):\n274     \"\"\"\n275     Load a template and render it with the current context. You can pass\n276     additional context using keyword arguments.\n277 \n278     Example::\n279 \n280         {% include \"foo/some_include\" %}\n281         {% include \"foo/some_include\" with bar=\"BAZZ!\" baz=\"BING!\" %}\n282 \n283     Use the ``only`` argument to exclude the current context when rendering\n284     the included template::\n285 \n286         {% include \"foo/some_include\" only %}\n287         {% include \"foo/some_include\" with bar=\"1\" only %}\n288     \"\"\"\n289     bits = token.split_contents()\n290     if len(bits) < 2:\n291         raise TemplateSyntaxError(\n292             \"%r tag takes at least one argument: the name of the template to \"\n293             \"be included.\" % bits[0]\n294         )\n295     options = {}\n296     remaining_bits = bits[2:]\n297     while remaining_bits:\n298         option = remaining_bits.pop(0)\n299         if option in options:\n300             raise TemplateSyntaxError('The %r option was specified more '\n301                                       'than once.' % option)\n302         if option == 'with':\n303             value = token_kwargs(remaining_bits, parser, support_legacy=False)\n304             if not value:\n305                 raise TemplateSyntaxError('\"with\" in %r tag needs at least '\n306                                           'one keyword argument.' % bits[0])\n307         elif option == 'only':\n308             value = True\n309         else:\n310             raise TemplateSyntaxError('Unknown argument for %r tag: %r.' %\n311                                       (bits[0], option))\n312         options[option] = value\n313     isolated_context = options.get('only', False)\n314     namemap = options.get('with', {})\n315     bits[1] = construct_relative_path(parser.origin.template_name, bits[1])\n316     return IncludeNode(parser.compile_filter(bits[1]), extra_context=namemap,\n317                        isolated_context=isolated_context)\n",
        "intended_behavior": "This method or section of code currently uses `get_template` to load a single template specified by the `var` variable in the `{% include var %}` syntax. The intended behavior is to modify this implementation to use `select_template` instead. This change would allow the `{% include %}` tag to accept an iterable of template names (`var` becoming a list of template names) and use the first template that exists, rather than failing when the first option does not exist. This maintains the existing functionality for single template names while extending versatility to support fallback templates. This adjustment would thus enable template fallback mechanism, reinforcing Django's robust template rendering capabilities and addressing the issue of template loading inflexibility highlighted in the submitted issue."
    }
]