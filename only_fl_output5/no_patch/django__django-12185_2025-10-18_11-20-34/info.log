2025-10-18 11:20:34.451 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-18 11:20:37.421 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=269, output_tokens=12, cost=0.003050
2025-10-18 11:20:49.859 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=449, output_tokens=510, cost=0.019790
2025-10-18 11:20:51.053 | INFO     | registered non reproducing test 0
2025-10-18 11:21:07.739 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1314, output_tokens=781, cost=0.036570
2025-10-18 11:21:08.938 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 11:21:17.473 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=567, output_tokens=338, cost=0.015810
2025-10-18 11:21:17.480 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 11:21:19.806 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=692, output_tokens=50, cost=0.008420
2025-10-18 11:21:19.807 | DEBUG    | Extracted a valid json.
2025-10-18 11:21:19.807 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_class(\"Window\")",
        "search_class(\"Case\")",
        "search_method(\"annotate\")",
        "search_code(\"NotSupportedError\")"
    ],
    "bug_locations": []
}
2025-10-18 11:21:19.922 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-18 11:21:19.922 | DEBUG    | <Agent search> Analyzing search results.
2025-10-18 11:21:37.804 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2751, output_tokens=717, cost=0.049020
2025-10-18 11:21:37.812 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 11:21:49.178 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=3684, output_tokens=508, cost=0.052080
2025-10-18 11:21:49.186 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 11:21:55.127 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=862, output_tokens=204, cost=0.014740
2025-10-18 11:21:55.128 | DEBUG    | Extracted a valid json.
2025-10-18 11:21:55.129 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations":[
        {
            "file": "django/db/models/sql/compiler.py",
            "class": "SQLCompiler",
            "method": "as_sql",
            "intended_behavior": "This method should be adjusted to allow window expressions within `Case` statements inside the `SELECT` clause. It should correctly identify and permit the referencing of window function results when used as part of conditionals within `SELECT`, ensuring they are not misinterpreted as being part of disallowed clauses like `WHERE`."
        },
        {
            "file": "django/db/models/expressions.py",
            "class": "Window, Case",
            "method": "resolve_expression, as_sql",
            "intended_behavior": "Ensure that when `Case` expressions include `Window` functions, they are processed in a way that the window function's result is accessible and usable in a `SELECT` clause without raising `NotSupportedError`."
        }
    ]
}
2025-10-18 11:21:55.143 | DEBUG    | Bug location extracted successfully: [<file>django/db/models/sql/compiler.py</file>
<class>SQLCompiler</class>
<method>as_sql</method>
<code>
472     def as_sql(self, with_limits=True, with_col_aliases=False):
473         """
474         Create the SQL for this query. Return the SQL string and list of
475         parameters.
476 
477         If 'with_limits' is False, any limit/offset information is not included
478         in the query.
479         """
480         refcounts_before = self.query.alias_refcount.copy()
481         try:
482             extra_select, order_by, group_by = self.pre_sql_setup()
483             for_update_part = None
484             # Is a LIMIT/OFFSET clause needed?
485             with_limit_offset = with_limits and (self.query.high_mark is not None or self.query.low_mark)
486             combinator = self.query.combinator
487             features = self.connection.features
488             if combinator:
489                 if not getattr(features, 'supports_select_{}'.format(combinator)):
490                     raise NotSupportedError('{} is not supported on this database backend.'.format(combinator))
491                 result, params = self.get_combinator_sql(combinator, self.query.combinator_all)
492             else:
493                 distinct_fields, distinct_params = self.get_distinct()
494                 # This must come after 'select', 'ordering', and 'distinct'
495                 # (see docstring of get_from_clause() for details).
496                 from_, f_params = self.get_from_clause()
497                 where, w_params = self.compile(self.where) if self.where is not None else ("", [])
498                 having, h_params = self.compile(self.having) if self.having is not None else ("", [])
499                 result = ['SELECT']
500                 params = []
501 
502                 if self.query.distinct:
503                     distinct_result, distinct_params = self.connection.ops.distinct_sql(
504                         distinct_fields,
505                         distinct_params,
506                     )
507                     result += distinct_result
508                     params += distinct_params
509 
510                 out_cols = []
511                 col_idx = 1
512                 for _, (s_sql, s_params), alias in self.select + extra_select:
513                     if alias:
514                         s_sql = '%s AS %s' % (s_sql, self.connection.ops.quote_name(alias))
515                     elif with_col_aliases:
516                         s_sql = '%s AS %s' % (s_sql, 'Col%d' % col_idx)
517                         col_idx += 1
518                     params.extend(s_params)
519                     out_cols.append(s_sql)
520 
521                 result += [', '.join(out_cols), 'FROM', *from_]
522                 params.extend(f_params)
523 
524                 if self.query.select_for_update and self.connection.features.has_select_for_update:
525                     if self.connection.get_autocommit():
526                         raise TransactionManagementError('select_for_update cannot be used outside of a transaction.')
527 
528                     if with_limit_offset and not self.connection.features.supports_select_for_update_with_limit:
529                         raise NotSupportedError(
530                             'LIMIT/OFFSET is not supported with '
531                             'select_for_update on this database backend.'
532                         )
533                     nowait = self.query.select_for_update_nowait
534                     skip_locked = self.query.select_for_update_skip_locked
535                     of = self.query.select_for_update_of
536                     # If it's a NOWAIT/SKIP LOCKED/OF query but the backend
537                     # doesn't support it, raise NotSupportedError to prevent a
538                     # possible deadlock.
539                     if nowait and not self.connection.features.has_select_for_update_nowait:
540                         raise NotSupportedError('NOWAIT is not supported on this database backend.')
541                     elif skip_locked and not self.connection.features.has_select_for_update_skip_locked:
542                         raise NotSupportedError('SKIP LOCKED is not supported on this database backend.')
543                     elif of and not self.connection.features.has_select_for_update_of:
544                         raise NotSupportedError('FOR UPDATE OF is not supported on this database backend.')
545                     for_update_part = self.connection.ops.for_update_sql(
546                         nowait=nowait,
547                         skip_locked=skip_locked,
548                         of=self.get_select_for_update_of_arguments(),
549                     )
550 
551                 if for_update_part and self.connection.features.for_update_after_from:
552                     result.append(for_update_part)
553 
554                 if where:
555                     result.append('WHERE %s' % where)
556                     params.extend(w_params)
557 
558                 grouping = []
559                 for g_sql, g_params in group_by:
560                     grouping.append(g_sql)
561                     params.extend(g_params)
562                 if grouping:
563                     if distinct_fields:
564                         raise NotImplementedError('annotate() + distinct(fields) is not implemented.')
565                     order_by = order_by or self.connection.ops.force_no_ordering()
566                     result.append('GROUP BY %s' % ', '.join(grouping))
567                     if self._meta_ordering:
568                         order_by = None
569                 if having:
570                     result.append('HAVING %s' % having)
571                     params.extend(h_params)
572 
573             if self.query.explain_query:
574                 result.insert(0, self.connection.ops.explain_query_prefix(
575                     self.query.explain_format,
576                     **self.query.explain_options
577                 ))
578 
579             if order_by:
580                 ordering = []
581                 for _, (o_sql, o_params, _) in order_by:
582                     ordering.append(o_sql)
583                     params.extend(o_params)
584                 result.append('ORDER BY %s' % ', '.join(ordering))
585 
586             if with_limit_offset:
587                 result.append(self.connection.ops.limit_offset_sql(self.query.low_mark, self.query.high_mark))
588 
589             if for_update_part and not self.connection.features.for_update_after_from:
590                 result.append(for_update_part)
591 
592             if self.query.subquery and extra_select:
593                 # If the query is used as a subquery, the extra selects would
594                 # result in more columns than the left-hand side expression is
595                 # expecting. This can happen when a subquery uses a combination
596                 # of order_by() and distinct(), forcing the ordering expressions
597                 # to be selected as well. Wrap the query in another subquery
598                 # to exclude extraneous selects.
599                 sub_selects = []
600                 sub_params = []
601                 for index, (select, _, alias) in enumerate(self.select, start=1):
602                     if not alias and with_col_aliases:
603                         alias = 'col%d' % index
604                     if alias:
605                         sub_selects.append("%s.%s" % (
606                             self.connection.ops.quote_name('subquery'),
607                             self.connection.ops.quote_name(alias),
608                         ))
609                     else:
610                         select_clone = select.relabeled_clone({select.alias: 'subquery'})
611                         subselect, subparams = select_clone.as_sql(self, self.connection)
612                         sub_selects.append(subselect)
613                         sub_params.extend(subparams)
614                 return 'SELECT %s FROM (%s) subquery' % (
615                     ', '.join(sub_selects),
616                     ' '.join(result),
617                 ), tuple(sub_params + params)
618 
619             return ' '.join(result), tuple(params)
620         finally:
621             # Finally do cleanup - get rid of the joins we created above.
622             self.query.reset_refcounts(refcounts_before)

</code><intended_behavior>This method should be adjusted to allow window expressions within `Case` statements inside the `SELECT` clause. It should correctly identify and permit the referencing of window function results when used as part of conditionals within `SELECT`, ensuring they are not misinterpreted as being part of disallowed clauses like `WHERE`.</intended_behavior>, <file>django/db/models/sql/compiler.py</file>
<class>SQLCompiler</class>
<method>None</method>
<code>
21 class SQLCompiler:
22     def __init__(self, query, connection, using):
23         self.query = query
24         self.connection = connection
25         self.using = using
26         self.quote_cache = {'*': '*'}
27         # The select, klass_info, and annotations are needed by QuerySet.iterator()
28         # these are set as a side-effect of executing the query. Note that we calculate
29         # separately a list of extra select columns needed for grammatical correctness
30         # of the query, but these columns are not included in self.select.
31         self.select = None
32         self.annotation_col_map = None
33         self.klass_info = None
34         # Multiline ordering SQL clause may appear from RawSQL.
35         self.ordering_parts = re.compile(r'^(.*)\s(ASC|DESC)(.*)', re.MULTILINE | re.DOTALL)
36         self._meta_ordering = None
37 
38     def setup_query(self):
39         if all(self.query.alias_refcount[a] == 0 for a in self.query.alias_map):
40             self.query.get_initial_alias()
41         self.select, self.klass_info, self.annotation_col_map = self.get_select()
42         self.col_count = len(self.select)
43 
44     def pre_sql_setup(self):
45         """
46         Do any necessary class setup immediately prior to producing SQL. This
47         is for things that can't necessarily be done in __init__ because we
48         might not have all the pieces in place at that time.
49         """
50         self.setup_query()
51         order_by = self.get_order_by()
52         self.where, self.having = self.query.where.split_having()
53         extra_select = self.get_extra_select(order_by, self.select)
54         self.has_extra_select = bool(extra_select)
55         group_by = self.get_group_by(self.select + extra_select, order_by)
56         return extra_select, order_by, group_by
57 
58     def get_group_by(self, select, order_by):
59         """
60         Return a list of 2-tuples of form (sql, params).
61 
62         The logic of what exactly the GROUP BY clause contains is hard
63         to describe in other words than "if it passes the test suite,
64         then it is correct".
65         """
66         # Some examples:
67         #     SomeModel.objects.annotate(Count('somecol'))
68         #     GROUP BY: all fields of the model
69         #
70         #    SomeModel.objects.values('name').annotate(Count('somecol'))
71         #    GROUP BY: name
72         #
73         #    SomeModel.objects.annotate(Count('somecol')).values('name')
74         #    GROUP BY: all cols of the model
75         #
76         #    SomeModel.objects.values('name', 'pk').annotate(Count('somecol')).values('pk')
77         #    GROUP BY: name, pk
78         #
79         #    SomeModel.objects.values('name').annotate(Count('somecol')).values('pk')
80         #    GROUP BY: name, pk
81         #
82         # In fact, the self.query.group_by is the minimal set to GROUP BY. It
83         # can't be ever restricted to a smaller set, but additional columns in
84         # HAVING, ORDER BY, and SELECT clauses are added to it. Unfortunately
85         # the end result is that it is impossible to force the query to have
86         # a chosen GROUP BY clause - you can almost do this by using the form:
87         #     .values(*wanted_cols).annotate(AnAggregate())
88         # but any later annotations, extra selects, values calls that
89         # refer some column outside of the wanted_cols, order_by, or even
90         # filter calls can alter the GROUP BY clause.
91 
92         # The query.group_by is either None (no GROUP BY at all), True
93         # (group by select fields), or a list of expressions to be added
94         # to the group by.
95         if self.query.group_by is None:
96             return []
97         expressions = []
98         if self.query.group_by is not True:
99             # If the group by is set to a list (by .values() call most likely),
100             # then we need to add everything in it to the GROUP BY clause.
101             # Backwards compatibility hack for setting query.group_by. Remove
102             # when  we have public API way of forcing the GROUP BY clause.
103             # Converts string references to expressions.
104             for expr in self.query.group_by:
105                 if not hasattr(expr, 'as_sql'):
106                     expressions.append(self.query.resolve_ref(expr))
107                 else:
108                     expressions.append(expr)
109         # Note that even if the group_by is set, it is only the minimal
110         # set to group by. So, we need to add cols in select, order_by, and
111         # having into the select in any case.
112         for expr, _, _ in select:
113             cols = expr.get_group_by_cols()
114             for col in cols:
115                 expressions.append(col)
116         for expr, (sql, params, is_ref) in order_by:
117             # Skip References to the select clause, as all expressions in the
118             # select clause are already part of the group by.
119             if not expr.contains_aggregate and not is_ref:
120                 expressions.extend(expr.get_source_expressions())
121         having_group_by = self.having.get_group_by_cols() if self.having else ()
122         for expr in having_group_by:
123             expressions.append(expr)
124         result = []
125         seen = set()
126         expressions = self.collapse_group_by(expressions, having_group_by)
127 
128         for expr in expressions:
129             sql, params = self.compile(expr)
130             params_hash = make_hashable(params)
131             if (sql, params_hash) not in seen:
132                 result.append((sql, params))
133                 seen.add((sql, params_hash))
134         return result
135 
136     def collapse_group_by(self, expressions, having):
137         # If the DB can group by primary key, then group by the primary key of
138         # query's main model. Note that for PostgreSQL the GROUP BY clause must
139         # include the primary key of every table, but for MySQL it is enough to
140         # have the main table's primary key.
141         if self.connection.features.allows_group_by_pk:
142             # Determine if the main model's primary key is in the query.
143             pk = None
144             for expr in expressions:
145                 # Is this a reference to query's base table primary key? If the
146                 # expression isn't a Col-like, then skip the expression.
147                 if (getattr(expr, 'target', None) == self.query.model._meta.pk and
148                         getattr(expr, 'alias', None) == self.query.base_table):
149                     pk = expr
150                     break
151             # If the main model's primary key is in the query, group by that
152             # field, HAVING expressions, and expressions associated with tables
153             # that don't have a primary key included in the grouped columns.
154             if pk:
155                 pk_aliases = {
156                     expr.alias for expr in expressions
157                     if hasattr(expr, 'target') and expr.target.primary_key
158                 }
159                 expressions = [pk] + [
160                     expr for expr in expressions
161                     if expr in having or (
162                         getattr(expr, 'alias', None) is not None and expr.alias not in pk_aliases
163                     )
164                 ]
165         elif self.connection.features.allows_group_by_selected_pks:
166             # Filter out all expressions associated with a table's primary key
167             # present in the grouped columns. This is done by identifying all
168             # tables that have their primary key included in the grouped
169             # columns and removing non-primary key columns referring to them.
170             # Unmanaged models are excluded because they could be representing
171             # database views on which the optimization might not be allowed.
172             pks = {
173                 expr for expr in expressions
174                 if (
175                     hasattr(expr, 'target') and
176                     expr.target.primary_key and
177                     self.connection.features.allows_group_by_selected_pks_on_model(expr.target.model)
178                 )
179             }
180             aliases = {expr.alias for expr in pks}
181             expressions = [
182                 expr for expr in expressions if expr in pks or getattr(expr, 'alias', None) not in aliases
183             ]
184         return expressions
185 
186     def get_select(self):
187         """
188         Return three values:
189         - a list of 3-tuples of (expression, (sql, params), alias)
190         - a klass_info structure,
191         - a dictionary of annotations
192 
193         The (sql, params) is what the expression will produce, and alias is the
194         "AS alias" for the column (possibly None).
195 
196         The klass_info structure contains the following information:
197         - The base model of the query.
198         - Which columns for that model are present in the query (by
199           position of the select clause).
200         - related_klass_infos: [f, klass_info] to descent into
201 
202         The annotations is a dictionary of {'attname': column position} values.
203         """
204         select = []
205         klass_info = None
206         annotations = {}
207         select_idx = 0
208         for alias, (sql, params) in self.query.extra_select.items():
209             annotations[alias] = select_idx
210             select.append((RawSQL(sql, params), alias))
211             select_idx += 1
212         assert not (self.query.select and self.query.default_cols)
213         if self.query.default_cols:
214             cols = self.get_default_columns()
215         else:
216             # self.query.select is a special case. These columns never go to
217             # any model.
218             cols = self.query.select
219         if cols:
220             select_list = []
221             for col in cols:
222                 select_list.append(select_idx)
223                 select.append((col, None))
224                 select_idx += 1
225             klass_info = {
226                 'model': self.query.model,
227                 'select_fields': select_list,
228             }
229         for alias, annotation in self.query.annotation_select.items():
230             annotations[alias] = select_idx
231             select.append((annotation, alias))
232             select_idx += 1
233 
234         if self.query.select_related:
235             related_klass_infos = self.get_related_selections(select)
236             klass_info['related_klass_infos'] = related_klass_infos
237 
238             def get_select_from_parent(klass_info):
239                 for ki in klass_info['related_klass_infos']:
240                     if ki['from_parent']:
241                         ki['select_fields'] = (klass_info['select_fields'] +
242                                                ki['select_fields'])
243                     get_select_from_parent(ki)
244             get_select_from_parent(klass_info)
245 
246         ret = []
247         for col, alias in select:
248             try:
249                 sql, params = self.compile(col)
250             except EmptyResultSet:
251                 # Select a predicate that's always False.
252                 sql, params = '0', ()
253             else:
254                 sql, params = col.select_format(self, sql, params)
255             ret.append((col, (sql, params), alias))
256         return ret, klass_info, annotations
257 
258     def get_order_by(self):
259         """
260         Return a list of 2-tuples of form (expr, (sql, params, is_ref)) for the
261         ORDER BY clause.
262 
263         The order_by clause can alter the select clause (for example it
264         can add aliases to clauses that do not yet have one, or it can
265         add totally new select clauses).
266         """
267         if self.query.extra_order_by:
268             ordering = self.query.extra_order_by
269         elif not self.query.default_ordering:
270             ordering = self.query.order_by
271         elif self.query.order_by:
272             ordering = self.query.order_by
273         elif self.query.get_meta().ordering:
274             ordering = self.query.get_meta().ordering
275             self._meta_ordering = ordering
276         else:
277             ordering = []
278         if self.query.standard_ordering:
279             asc, desc = ORDER_DIR['ASC']
280         else:
281             asc, desc = ORDER_DIR['DESC']
282 
283         order_by = []
284         for field in ordering:
285             if hasattr(field, 'resolve_expression'):
286                 if isinstance(field, Value):
287                     # output_field must be resolved for constants.
288                     field = Cast(field, field.output_field)
289                 if not isinstance(field, OrderBy):
290                     field = field.asc()
291                 if not self.query.standard_ordering:
292                     field = field.copy()
293                     field.reverse_ordering()
294                 order_by.append((field, False))
295                 continue
296             if field == '?':  # random
297                 order_by.append((OrderBy(Random()), False))
298                 continue
299 
300             col, order = get_order_dir(field, asc)
301             descending = order == 'DESC'
302 
303             if col in self.query.annotation_select:
304                 # Reference to expression in SELECT clause
305                 order_by.append((
306                     OrderBy(Ref(col, self.query.annotation_select[col]), descending=descending),
307                     True))
308                 continue
309             if col in self.query.annotations:
310                 # References to an expression which is masked out of the SELECT
311                 # clause.
312                 expr = self.query.annotations[col]
313                 if isinstance(expr, Value):
314                     # output_field must be resolved for constants.
315                     expr = Cast(expr, expr.output_field)
316                 order_by.append((OrderBy(expr, descending=descending), False))
317                 continue
318 
319             if '.' in field:
320                 # This came in through an extra(order_by=...) addition. Pass it
321                 # on verbatim.
322                 table, col = col.split('.', 1)
323                 order_by.append((
324                     OrderBy(
325                         RawSQL('%s.%s' % (self.quote_name_unless_alias(table), col), []),
326                         descending=descending
327                     ), False))
328                 continue
329 
330             if not self.query.extra or col not in self.query.extra:
331                 # 'col' is of the form 'field' or 'field1__field2' or
332                 # '-field1__field2__field', etc.
333                 order_by.extend(self.find_ordering_name(
334                     field, self.query.get_meta(), default_order=asc))
335             else:
336                 if col not in self.query.extra_select:
337                     order_by.append((
338                         OrderBy(RawSQL(*self.query.extra[col]), descending=descending),
339                         False))
340                 else:
341                     order_by.append((
342                         OrderBy(Ref(col, RawSQL(*self.query.extra[col])), descending=descending),
343                         True))
344         result = []
345         seen = set()
346 
347         for expr, is_ref in order_by:
348             resolved = expr.resolve_expression(self.query, allow_joins=True, reuse=None)
349             if self.query.combinator:
350                 src = resolved.get_source_expressions()[0]
351                 # Relabel order by columns to raw numbers if this is a combined
352                 # query; necessary since the columns can't be referenced by the
353                 # fully qualified name and the simple column names may collide.
354                 for idx, (sel_expr, _, col_alias) in enumerate(self.select):
355                     if is_ref and col_alias == src.refs:
356                         src = src.source
357                     elif col_alias:
358                         continue
359                     if src == sel_expr:
360                         resolved.set_source_expressions([RawSQL('%d' % (idx + 1), ())])
361                         break
362                 else:
363                     if col_alias:
364                         raise DatabaseError('ORDER BY term does not match any column in the result set.')
365                     # Add column used in ORDER BY clause without an alias to
366                     # the selected columns.
367                     self.query.add_select_col(src)
368                     resolved.set_source_expressions([RawSQL('%d' % len(self.query.select), ())])
369             sql, params = self.compile(resolved)
370             # Don't add the same column twice, but the order direction is
371             # not taken into account so we strip it. When this entire method
372             # is refactored into expressions, then we can check each part as we
373             # generate it.
374             without_ordering = self.ordering_parts.search(sql).group(1)
375             params_hash = make_hashable(params)
376             if (without_ordering, params_hash) in seen:
377                 continue
378             seen.add((without_ordering, params_hash))
379             result.append((resolved, (sql, params, is_ref)))
380         return result
381 
382     def get_extra_select(self, order_by, select):
383         extra_select = []
384         if self.query.distinct and not self.query.distinct_fields:
385             select_sql = [t[1] for t in select]
386             for expr, (sql, params, is_ref) in order_by:
387                 without_ordering = self.ordering_parts.search(sql).group(1)
388                 if not is_ref and (without_ordering, params) not in select_sql:
389                     extra_select.append((expr, (without_ordering, params), None))
390         return extra_select
391 
392     def quote_name_unless_alias(self, name):
393         """
394         A wrapper around connection.ops.quote_name that doesn't quote aliases
395         for table names. This avoids problems with some SQL dialects that treat
396         quoted strings specially (e.g. PostgreSQL).
397         """
398         if name in self.quote_cache:
399             return self.quote_cache[name]
400         if ((name in self.query.alias_map and name not in self.query.table_map) or
401                 name in self.query.extra_select or (
402                     name in self.query.external_aliases and name not in self.query.table_map)):
403             self.quote_cache[name] = name
404             return name
405         r = self.connection.ops.quote_name(name)
406         self.quote_cache[name] = r
407         return r
408 
409     def compile(self, node):
410         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
411         if vendor_impl:
412             sql, params = vendor_impl(self, self.connection)
413         else:
414             sql, params = node.as_sql(self, self.connection)
415         return sql, params
416 
417     def get_combinator_sql(self, combinator, all):
418         features = self.connection.features
419         compilers = [
420             query.get_compiler(self.using, self.connection)
421             for query in self.query.combined_queries if not query.is_empty()
422         ]
423         if not features.supports_slicing_ordering_in_compound:
424             for query, compiler in zip(self.query.combined_queries, compilers):
425                 if query.low_mark or query.high_mark:
426                     raise DatabaseError('LIMIT/OFFSET not allowed in subqueries of compound statements.')
427                 if compiler.get_order_by():
428                     raise DatabaseError('ORDER BY not allowed in subqueries of compound statements.')
429         parts = ()
430         for compiler in compilers:
431             try:
432                 # If the columns list is limited, then all combined queries
433                 # must have the same columns list. Set the selects defined on
434                 # the query on all combined queries, if not already set.
435                 if not compiler.query.values_select and self.query.values_select:
436                     compiler.query = compiler.query.clone()
437                     compiler.query.set_values((
438                         *self.query.extra_select,
439                         *self.query.values_select,
440                         *self.query.annotation_select,
441                     ))
442                 part_sql, part_args = compiler.as_sql()
443                 if compiler.query.combinator:
444                     # Wrap in a subquery if wrapping in parentheses isn't
445                     # supported.
446                     if not features.supports_parentheses_in_compound:
447                         part_sql = 'SELECT * FROM ({})'.format(part_sql)
448                     # Add parentheses when combining with compound query if not
449                     # already added for all compound queries.
450                     elif not features.supports_slicing_ordering_in_compound:
451                         part_sql = '({})'.format(part_sql)
452                 parts += ((part_sql, part_args),)
453             except EmptyResultSet:
454                 # Omit the empty queryset with UNION and with DIFFERENCE if the
455                 # first queryset is nonempty.
456                 if combinator == 'union' or (combinator == 'difference' and parts):
457                     continue
458                 raise
459         if not parts:
460             raise EmptyResultSet
461         combinator_sql = self.connection.ops.set_operators[combinator]
462         if all and combinator == 'union':
463             combinator_sql += ' ALL'
464         braces = '({})' if features.supports_slicing_ordering_in_compound else '{}'
465         sql_parts, args_parts = zip(*((braces.format(sql), args) for sql, args in parts))
466         result = [' {} '.format(combinator_sql).join(sql_parts)]
467         params = []
468         for part in args_parts:
469             params.extend(part)
470         return result, params
471 
472     def as_sql(self, with_limits=True, with_col_aliases=False):
473         """
474         Create the SQL for this query. Return the SQL string and list of
475         parameters.
476 
477         If 'with_limits' is False, any limit/offset information is not included
478         in the query.
479         """
480         refcounts_before = self.query.alias_refcount.copy()
481         try:
482             extra_select, order_by, group_by = self.pre_sql_setup()
483             for_update_part = None
484             # Is a LIMIT/OFFSET clause needed?
485             with_limit_offset = with_limits and (self.query.high_mark is not None or self.query.low_mark)
486             combinator = self.query.combinator
487             features = self.connection.features
488             if combinator:
489                 if not getattr(features, 'supports_select_{}'.format(combinator)):
490                     raise NotSupportedError('{} is not supported on this database backend.'.format(combinator))
491                 result, params = self.get_combinator_sql(combinator, self.query.combinator_all)
492             else:
493                 distinct_fields, distinct_params = self.get_distinct()
494                 # This must come after 'select', 'ordering', and 'distinct'
495                 # (see docstring of get_from_clause() for details).
496                 from_, f_params = self.get_from_clause()
497                 where, w_params = self.compile(self.where) if self.where is not None else ("", [])
498                 having, h_params = self.compile(self.having) if self.having is not None else ("", [])
499                 result = ['SELECT']
500                 params = []
501 
502                 if self.query.distinct:
503                     distinct_result, distinct_params = self.connection.ops.distinct_sql(
504                         distinct_fields,
505                         distinct_params,
506                     )
507                     result += distinct_result
508                     params += distinct_params
509 
510                 out_cols = []
511                 col_idx = 1
512                 for _, (s_sql, s_params), alias in self.select + extra_select:
513                     if alias:
514                         s_sql = '%s AS %s' % (s_sql, self.connection.ops.quote_name(alias))
515                     elif with_col_aliases:
516                         s_sql = '%s AS %s' % (s_sql, 'Col%d' % col_idx)
517                         col_idx += 1
518                     params.extend(s_params)
519                     out_cols.append(s_sql)
520 
521                 result += [', '.join(out_cols), 'FROM', *from_]
522                 params.extend(f_params)
523 
524                 if self.query.select_for_update and self.connection.features.has_select_for_update:
525                     if self.connection.get_autocommit():
526                         raise TransactionManagementError('select_for_update cannot be used outside of a transaction.')
527 
528                     if with_limit_offset and not self.connection.features.supports_select_for_update_with_limit:
529                         raise NotSupportedError(
530                             'LIMIT/OFFSET is not supported with '
531                             'select_for_update on this database backend.'
532                         )
533                     nowait = self.query.select_for_update_nowait
534                     skip_locked = self.query.select_for_update_skip_locked
535                     of = self.query.select_for_update_of
536                     # If it's a NOWAIT/SKIP LOCKED/OF query but the backend
537                     # doesn't support it, raise NotSupportedError to prevent a
538                     # possible deadlock.
539                     if nowait and not self.connection.features.has_select_for_update_nowait:
540                         raise NotSupportedError('NOWAIT is not supported on this database backend.')
541                     elif skip_locked and not self.connection.features.has_select_for_update_skip_locked:
542                         raise NotSupportedError('SKIP LOCKED is not supported on this database backend.')
543                     elif of and not self.connection.features.has_select_for_update_of:
544                         raise NotSupportedError('FOR UPDATE OF is not supported on this database backend.')
545                     for_update_part = self.connection.ops.for_update_sql(
546                         nowait=nowait,
547                         skip_locked=skip_locked,
548                         of=self.get_select_for_update_of_arguments(),
549                     )
550 
551                 if for_update_part and self.connection.features.for_update_after_from:
552                     result.append(for_update_part)
553 
554                 if where:
555                     result.append('WHERE %s' % where)
556                     params.extend(w_params)
557 
558                 grouping = []
559                 for g_sql, g_params in group_by:
560                     grouping.append(g_sql)
561                     params.extend(g_params)
562                 if grouping:
563                     if distinct_fields:
564                         raise NotImplementedError('annotate() + distinct(fields) is not implemented.')
565                     order_by = order_by or self.connection.ops.force_no_ordering()
566                     result.append('GROUP BY %s' % ', '.join(grouping))
567                     if self._meta_ordering:
568                         order_by = None
569                 if having:
570                     result.append('HAVING %s' % having)
571                     params.extend(h_params)
572 
573             if self.query.explain_query:
574                 result.insert(0, self.connection.ops.explain_query_prefix(
575                     self.query.explain_format,
576                     **self.query.explain_options
577                 ))
578 
579             if order_by:
580                 ordering = []
581                 for _, (o_sql, o_params, _) in order_by:
582                     ordering.append(o_sql)
583                     params.extend(o_params)
584                 result.append('ORDER BY %s' % ', '.join(ordering))
585 
586             if with_limit_offset:
587                 result.append(self.connection.ops.limit_offset_sql(self.query.low_mark, self.query.high_mark))
588 
589             if for_update_part and not self.connection.features.for_update_after_from:
590                 result.append(for_update_part)
591 
592             if self.query.subquery and extra_select:
593                 # If the query is used as a subquery, the extra selects would
594                 # result in more columns than the left-hand side expression is
595                 # expecting. This can happen when a subquery uses a combination
596                 # of order_by() and distinct(), forcing the ordering expressions
597                 # to be selected as well. Wrap the query in another subquery
598                 # to exclude extraneous selects.
599                 sub_selects = []
600                 sub_params = []
601                 for index, (select, _, alias) in enumerate(self.select, start=1):
602                     if not alias and with_col_aliases:
603                         alias = 'col%d' % index
604                     if alias:
605                         sub_selects.append("%s.%s" % (
606                             self.connection.ops.quote_name('subquery'),
607                             self.connection.ops.quote_name(alias),
608                         ))
609                     else:
610                         select_clone = select.relabeled_clone({select.alias: 'subquery'})
611                         subselect, subparams = select_clone.as_sql(self, self.connection)
612                         sub_selects.append(subselect)
613                         sub_params.extend(subparams)
614                 return 'SELECT %s FROM (%s) subquery' % (
615                     ', '.join(sub_selects),
616                     ' '.join(result),
617                 ), tuple(sub_params + params)
618 
619             return ' '.join(result), tuple(params)
620         finally:
621             # Finally do cleanup - get rid of the joins we created above.
622             self.query.reset_refcounts(refcounts_before)
623 
624     def get_default_columns(self, start_alias=None, opts=None, from_parent=None):
625         """
626         Compute the default columns for selecting every field in the base
627         model. Will sometimes be called to pull in related models (e.g. via
628         select_related), in which case "opts" and "start_alias" will be given
629         to provide a starting point for the traversal.
630 
631         Return a list of strings, quoted appropriately for use in SQL
632         directly, as well as a set of aliases used in the select statement (if
633         'as_pairs' is True, return a list of (alias, col_name) pairs instead
634         of strings as the first component and None as the second component).
635         """
636         result = []
637         if opts is None:
638             opts = self.query.get_meta()
639         only_load = self.deferred_to_columns()
640         start_alias = start_alias or self.query.get_initial_alias()
641         # The 'seen_models' is used to optimize checking the needed parent
642         # alias for a given field. This also includes None -> start_alias to
643         # be used by local fields.
644         seen_models = {None: start_alias}
645 
646         for field in opts.concrete_fields:
647             model = field.model._meta.concrete_model
648             # A proxy model will have a different model and concrete_model. We
649             # will assign None if the field belongs to this model.
650             if model == opts.model:
651                 model = None
652             if from_parent and model is not None and issubclass(
653                     from_parent._meta.concrete_model, model._meta.concrete_model):
654                 # Avoid loading data for already loaded parents.
655                 # We end up here in the case select_related() resolution
656                 # proceeds from parent model to child model. In that case the
657                 # parent model data is already present in the SELECT clause,
658                 # and we want to avoid reloading the same data again.
659                 continue
660             if field.model in only_load and field.attname not in only_load[field.model]:
661                 continue
662             alias = self.query.join_parent_model(opts, model, start_alias,
663                                                  seen_models)
664             column = field.get_col(alias)
665             result.append(column)
666         return result
667 
668     def get_distinct(self):
669         """
670         Return a quoted list of fields to use in DISTINCT ON part of the query.
671 
672         This method can alter the tables in the query, and thus it must be
673         called before get_from_clause().
674         """
675         result = []
676         params = []
677         opts = self.query.get_meta()
678 
679         for name in self.query.distinct_fields:
680             parts = name.split(LOOKUP_SEP)
681             _, targets, alias, joins, path, _, transform_function = self._setup_joins(parts, opts, None)
682             targets, alias, _ = self.query.trim_joins(targets, joins, path)
683             for target in targets:
684                 if name in self.query.annotation_select:
685                     result.append(name)
686                 else:
687                     r, p = self.compile(transform_function(target, alias))
688                     result.append(r)
689                     params.append(p)
690         return result, params
691 
692     def find_ordering_name(self, name, opts, alias=None, default_order='ASC',
693                            already_seen=None):
694         """
695         Return the table alias (the name might be ambiguous, the alias will
696         not be) and column name for ordering by the given 'name' parameter.
697         The 'name' is of the form 'field1__field2__...__fieldN'.
698         """
699         name, order = get_order_dir(name, default_order)
700         descending = order == 'DESC'
701         pieces = name.split(LOOKUP_SEP)
702         field, targets, alias, joins, path, opts, transform_function = self._setup_joins(pieces, opts, alias)
703 
704         # If we get to this point and the field is a relation to another model,
705         # append the default ordering for that model unless the attribute name
706         # of the field is specified.
707         if field.is_relation and opts.ordering and getattr(field, 'attname', None) != name:
708             # Firstly, avoid infinite loops.
709             already_seen = already_seen or set()
710             join_tuple = tuple(getattr(self.query.alias_map[j], 'join_cols', None) for j in joins)
711             if join_tuple in already_seen:
712                 raise FieldError('Infinite loop caused by ordering.')
713             already_seen.add(join_tuple)
714 
715             results = []
716             for item in opts.ordering:
717                 if hasattr(item, 'resolve_expression') and not isinstance(item, OrderBy):
718                     item = item.desc() if descending else item.asc()
719                 if isinstance(item, OrderBy):
720                     results.append((item, False))
721                     continue
722                 results.extend(self.find_ordering_name(item, opts, alias,
723                                                        order, already_seen))
724             return results
725         targets, alias, _ = self.query.trim_joins(targets, joins, path)
726         return [(OrderBy(transform_function(t, alias), descending=descending), False) for t in targets]
727 
728     def _setup_joins(self, pieces, opts, alias):
729         """
730         Helper method for get_order_by() and get_distinct().
731 
732         get_ordering() and get_distinct() must produce same target columns on
733         same input, as the prefixes of get_ordering() and get_distinct() must
734         match. Executing SQL where this is not true is an error.
735         """
736         alias = alias or self.query.get_initial_alias()
737         field, targets, opts, joins, path, transform_function = self.query.setup_joins(pieces, opts, alias)
738         alias = joins[-1]
739         return field, targets, alias, joins, path, opts, transform_function
740 
741     def get_from_clause(self):
742         """
743         Return a list of strings that are joined together to go after the
744         "FROM" part of the query, as well as a list any extra parameters that
745         need to be included. Subclasses, can override this to create a
746         from-clause via a "select".
747 
748         This should only be called after any SQL construction methods that
749         might change the tables that are needed. This means the select columns,
750         ordering, and distinct must be done first.
751         """
752         result = []
753         params = []
754         for alias in tuple(self.query.alias_map):
755             if not self.query.alias_refcount[alias]:
756                 continue
757             try:
758                 from_clause = self.query.alias_map[alias]
759             except KeyError:
760                 # Extra tables can end up in self.tables, but not in the
761                 # alias_map if they aren't in a join. That's OK. We skip them.
762                 continue
763             clause_sql, clause_params = self.compile(from_clause)
764             result.append(clause_sql)
765             params.extend(clause_params)
766         for t in self.query.extra_tables:
767             alias, _ = self.query.table_alias(t)
768             # Only add the alias if it's not already present (the table_alias()
769             # call increments the refcount, so an alias refcount of one means
770             # this is the only reference).
771             if alias not in self.query.alias_map or self.query.alias_refcount[alias] == 1:
772                 result.append(', %s' % self.quote_name_unless_alias(alias))
773         return result, params
774 
775     def get_related_selections(self, select, opts=None, root_alias=None, cur_depth=1,
776                                requested=None, restricted=None):
777         """
778         Fill in the information needed for a select_related query. The current
779         depth is measured as the number of connections away from the root model
780         (for example, cur_depth=1 means we are looking at models with direct
781         connections to the root model).
782         """
783         def _get_field_choices():
784             direct_choices = (f.name for f in opts.fields if f.is_relation)
785             reverse_choices = (
786                 f.field.related_query_name()
787                 for f in opts.related_objects if f.field.unique
788             )
789             return chain(direct_choices, reverse_choices, self.query._filtered_relations)
790 
791         related_klass_infos = []
792         if not restricted and cur_depth > self.query.max_depth:
793             # We've recursed far enough; bail out.
794             return related_klass_infos
795 
796         if not opts:
797             opts = self.query.get_meta()
798             root_alias = self.query.get_initial_alias()
799         only_load = self.query.get_loaded_field_names()
800 
801         # Setup for the case when only particular related fields should be
802         # included in the related selection.
803         fields_found = set()
804         if requested is None:
805             restricted = isinstance(self.query.select_related, dict)
806             if restricted:
807                 requested = self.query.select_related
808 
809         def get_related_klass_infos(klass_info, related_klass_infos):
810             klass_info['related_klass_infos'] = related_klass_infos
811 
812         for f in opts.fields:
813             field_model = f.model._meta.concrete_model
814             fields_found.add(f.name)
815 
816             if restricted:
817                 next = requested.get(f.name, {})
818                 if not f.is_relation:
819                     # If a non-related field is used like a relation,
820                     # or if a single non-relational field is given.
821                     if next or f.name in requested:
822                         raise FieldError(
823                             "Non-relational field given in select_related: '%s'. "
824                             "Choices are: %s" % (
825                                 f.name,
826                                 ", ".join(_get_field_choices()) or '(none)',
827                             )
828                         )
829             else:
830                 next = False
831 
832             if not select_related_descend(f, restricted, requested,
833                                           only_load.get(field_model)):
834                 continue
835             klass_info = {
836                 'model': f.remote_field.model,
837                 'field': f,
838                 'reverse': False,
839                 'local_setter': f.set_cached_value,
840                 'remote_setter': f.remote_field.set_cached_value if f.unique else lambda x, y: None,
841                 'from_parent': False,
842             }
843             related_klass_infos.append(klass_info)
844             select_fields = []
845             _, _, _, joins, _, _ = self.query.setup_joins(
846                 [f.name], opts, root_alias)
847             alias = joins[-1]
848             columns = self.get_default_columns(start_alias=alias, opts=f.remote_field.model._meta)
849             for col in columns:
850                 select_fields.append(len(select))
851                 select.append((col, None))
852             klass_info['select_fields'] = select_fields
853             next_klass_infos = self.get_related_selections(
854                 select, f.remote_field.model._meta, alias, cur_depth + 1, next, restricted)
855             get_related_klass_infos(klass_info, next_klass_infos)
856 
857         if restricted:
858             related_fields = [
859                 (o.field, o.related_model)
860                 for o in opts.related_objects
861                 if o.field.unique and not o.many_to_many
862             ]
863             for f, model in related_fields:
864                 if not select_related_descend(f, restricted, requested,
865                                               only_load.get(model), reverse=True):
866                     continue
867 
868                 related_field_name = f.related_query_name()
869                 fields_found.add(related_field_name)
870 
871                 join_info = self.query.setup_joins([related_field_name], opts, root_alias)
872                 alias = join_info.joins[-1]
873                 from_parent = issubclass(model, opts.model) and model is not opts.model
874                 klass_info = {
875                     'model': model,
876                     'field': f,
877                     'reverse': True,
878                     'local_setter': f.remote_field.set_cached_value,
879                     'remote_setter': f.set_cached_value,
880                     'from_parent': from_parent,
881                 }
882                 related_klass_infos.append(klass_info)
883                 select_fields = []
884                 columns = self.get_default_columns(
885                     start_alias=alias, opts=model._meta, from_parent=opts.model)
886                 for col in columns:
887                     select_fields.append(len(select))
888                     select.append((col, None))
889                 klass_info['select_fields'] = select_fields
890                 next = requested.get(f.related_query_name(), {})
891                 next_klass_infos = self.get_related_selections(
892                     select, model._meta, alias, cur_depth + 1,
893                     next, restricted)
894                 get_related_klass_infos(klass_info, next_klass_infos)
895 
896             def local_setter(obj, from_obj):
897                 # Set a reverse fk object when relation is non-empty.
898                 if from_obj:
899                     f.remote_field.set_cached_value(from_obj, obj)
900 
901             def remote_setter(name, obj, from_obj):
902                 setattr(from_obj, name, obj)
903 
904             for name in list(requested):
905                 # Filtered relations work only on the topmost level.
906                 if cur_depth > 1:
907                     break
908                 if name in self.query._filtered_relations:
909                     fields_found.add(name)
910                     f, _, join_opts, joins, _, _ = self.query.setup_joins([name], opts, root_alias)
911                     model = join_opts.model
912                     alias = joins[-1]
913                     from_parent = issubclass(model, opts.model) and model is not opts.model
914                     klass_info = {
915                         'model': model,
916                         'field': f,
917                         'reverse': True,
918                         'local_setter': local_setter,
919                         'remote_setter': partial(remote_setter, name),
920                         'from_parent': from_parent,
921                     }
922                     related_klass_infos.append(klass_info)
923                     select_fields = []
924                     columns = self.get_default_columns(
925                         start_alias=alias, opts=model._meta,
926                         from_parent=opts.model,
927                     )
928                     for col in columns:
929                         select_fields.append(len(select))
930                         select.append((col, None))
931                     klass_info['select_fields'] = select_fields
932                     next_requested = requested.get(name, {})
933                     next_klass_infos = self.get_related_selections(
934                         select, opts=model._meta, root_alias=alias,
935                         cur_depth=cur_depth + 1, requested=next_requested,
936                         restricted=restricted,
937                     )
938                     get_related_klass_infos(klass_info, next_klass_infos)
939             fields_not_found = set(requested).difference(fields_found)
940             if fields_not_found:
941                 invalid_fields = ("'%s'" % s for s in fields_not_found)
942                 raise FieldError(
943                     'Invalid field name(s) given in select_related: %s. '
944                     'Choices are: %s' % (
945                         ', '.join(invalid_fields),
946                         ', '.join(_get_field_choices()) or '(none)',
947                     )
948                 )
949         return related_klass_infos
950 
951     def get_select_for_update_of_arguments(self):
952         """
953         Return a quoted list of arguments for the SELECT FOR UPDATE OF part of
954         the query.
955         """
956         def _get_parent_klass_info(klass_info):
957             return (
958                 {
959                     'model': parent_model,
960                     'field': parent_link,
961                     'reverse': False,
962                     'select_fields': [
963                         select_index
964                         for select_index in klass_info['select_fields']
965                         if self.select[select_index][0].target.model == parent_model
966                     ],
967                 }
968                 for parent_model, parent_link in klass_info['model']._meta.parents.items()
969             )
970 
971         def _get_field_choices():
972             """Yield all allowed field paths in breadth-first search order."""
973             queue = collections.deque([(None, self.klass_info)])
974             while queue:
975                 parent_path, klass_info = queue.popleft()
976                 if parent_path is None:
977                     path = []
978                     yield 'self'
979                 else:
980                     field = klass_info['field']
981                     if klass_info['reverse']:
982                         field = field.remote_field
983                     path = parent_path + [field.name]
984                     yield LOOKUP_SEP.join(path)
985                 queue.extend(
986                     (path, klass_info)
987                     for klass_info in _get_parent_klass_info(klass_info)
988                 )
989                 queue.extend(
990                     (path, klass_info)
991                     for klass_info in klass_info.get('related_klass_infos', [])
992                 )
993         result = []
994         invalid_names = []
995         for name in self.query.select_for_update_of:
996             klass_info = self.klass_info
997             if name == 'self':
998                 # Find the first selected column from a base model. If it
999                 # doesn't exist, don't lock a base model.
1000                 for select_index in klass_info['select_fields']:
1001                     if self.select[select_index][0].target.model == klass_info['model']:
1002                         col = self.select[select_index][0]
1003                         break
1004                 else:
1005                     col = None
1006             else:
1007                 for part in name.split(LOOKUP_SEP):
1008                     klass_infos = (
1009                         *klass_info.get('related_klass_infos', []),
1010                         *_get_parent_klass_info(klass_info),
1011                     )
1012                     for related_klass_info in klass_infos:
1013                         field = related_klass_info['field']
1014                         if related_klass_info['reverse']:
1015                             field = field.remote_field
1016                         if field.name == part:
1017                             klass_info = related_klass_info
1018                             break
1019                     else:
1020                         klass_info = None
1021                         break
1022                 if klass_info is None:
1023                     invalid_names.append(name)
1024                     continue
1025                 select_index = klass_info['select_fields'][0]
1026                 col = self.select[select_index][0]
1027             if col is not None:
1028                 if self.connection.features.select_for_update_of_column:
1029                     result.append(self.compile(col)[0])
1030                 else:
1031                     result.append(self.quote_name_unless_alias(col.alias))
1032         if invalid_names:
1033             raise FieldError(
1034                 'Invalid field name(s) given in select_for_update(of=(...)): %s. '
1035                 'Only relational fields followed in the query are allowed. '
1036                 'Choices are: %s.' % (
1037                     ', '.join(invalid_names),
1038                     ', '.join(_get_field_choices()),
1039                 )
1040             )
1041         return result
1042 
1043     def deferred_to_columns(self):
1044         """
1045         Convert the self.deferred_loading data structure to mapping of table
1046         names to sets of column names which are to be loaded. Return the
1047         dictionary.
1048         """
1049         columns = {}
1050         self.query.deferred_to_data(columns, self.query.get_loaded_field_names_cb)
1051         return columns
1052 
1053     def get_converters(self, expressions):
1054         converters = {}
1055         for i, expression in enumerate(expressions):
1056             if expression:
1057                 backend_converters = self.connection.ops.get_db_converters(expression)
1058                 field_converters = expression.get_db_converters(self.connection)
1059                 if backend_converters or field_converters:
1060                     converters[i] = (backend_converters + field_converters, expression)
1061         return converters
1062 
1063     def apply_converters(self, rows, converters):
1064         connection = self.connection
1065         converters = list(converters.items())
1066         for row in map(list, rows):
1067             for pos, (convs, expression) in converters:
1068                 value = row[pos]
1069                 for converter in convs:
1070                     value = converter(value, expression, connection)
1071                 row[pos] = value
1072             yield row
1073 
1074     def results_iter(self, results=None, tuple_expected=False, chunked_fetch=False,
1075                      chunk_size=GET_ITERATOR_CHUNK_SIZE):
1076         """Return an iterator over the results from executing this query."""
1077         if results is None:
1078             results = self.execute_sql(MULTI, chunked_fetch=chunked_fetch, chunk_size=chunk_size)
1079         fields = [s[0] for s in self.select[0:self.col_count]]
1080         converters = self.get_converters(fields)
1081         rows = chain.from_iterable(results)
1082         if converters:
1083             rows = self.apply_converters(rows, converters)
1084             if tuple_expected:
1085                 rows = map(tuple, rows)
1086         return rows
1087 
1088     def has_results(self):
1089         """
1090         Backends (e.g. NoSQL) can override this in order to use optimized
1091         versions of "query has any results."
1092         """
1093         # This is always executed on a query clone, so we can modify self.query
1094         self.query.add_extra({'a': 1}, None, None, None, None, None)
1095         self.query.set_extra_mask(['a'])
1096         return bool(self.execute_sql(SINGLE))
1097 
1098     def execute_sql(self, result_type=MULTI, chunked_fetch=False, chunk_size=GET_ITERATOR_CHUNK_SIZE):
1099         """
1100         Run the query against the database and return the result(s). The
1101         return value is a single data item if result_type is SINGLE, or an
1102         iterator over the results if the result_type is MULTI.
1103 
1104         result_type is either MULTI (use fetchmany() to retrieve all rows),
1105         SINGLE (only retrieve a single row), or None. In this last case, the
1106         cursor is returned if any query is executed, since it's used by
1107         subclasses such as InsertQuery). It's possible, however, that no query
1108         is needed, as the filters describe an empty set. In that case, None is
1109         returned, to avoid any unnecessary database interaction.
1110         """
1111         result_type = result_type or NO_RESULTS
1112         try:
1113             sql, params = self.as_sql()
1114             if not sql:
1115                 raise EmptyResultSet
1116         except EmptyResultSet:
1117             if result_type == MULTI:
1118                 return iter([])
1119             else:
1120                 return
1121         if chunked_fetch:
1122             cursor = self.connection.chunked_cursor()
1123         else:
1124             cursor = self.connection.cursor()
1125         try:
1126             cursor.execute(sql, params)
1127         except Exception:
1128             # Might fail for server-side cursors (e.g. connection closed)
1129             cursor.close()
1130             raise
1131 
1132         if result_type == CURSOR:
1133             # Give the caller the cursor to process and close.
1134             return cursor
1135         if result_type == SINGLE:
1136             try:
1137                 val = cursor.fetchone()
1138                 if val:
1139                     return val[0:self.col_count]
1140                 return val
1141             finally:
1142                 # done with the cursor
1143                 cursor.close()
1144         if result_type == NO_RESULTS:
1145             cursor.close()
1146             return
1147 
1148         result = cursor_iter(
1149             cursor, self.connection.features.empty_fetchmany_value,
1150             self.col_count if self.has_extra_select else None,
1151             chunk_size,
1152         )
1153         if not chunked_fetch or not self.connection.features.can_use_chunked_reads:
1154             try:
1155                 # If we are using non-chunked reads, we return the same data
1156                 # structure as normally, but ensure it is all read into memory
1157                 # before going any further. Use chunked_fetch if requested,
1158                 # unless the database doesn't support it.
1159                 return list(result)
1160             finally:
1161                 # done with the cursor
1162                 cursor.close()
1163         return result
1164 
1165     def as_subquery_condition(self, alias, columns, compiler):
1166         qn = compiler.quote_name_unless_alias
1167         qn2 = self.connection.ops.quote_name
1168 
1169         for index, select_col in enumerate(self.query.select):
1170             lhs_sql, lhs_params = self.compile(select_col)
1171             rhs = '%s.%s' % (qn(alias), qn2(columns[index]))
1172             self.query.where.add(
1173                 RawSQL('%s = %s' % (lhs_sql, rhs), lhs_params), 'AND')
1174 
1175         sql, params = self.as_sql()
1176         return 'EXISTS (%s)' % sql, params
1177 
1178     def explain_query(self):
1179         result = list(self.execute_sql())
1180         # Some backends return 1 item tuples with strings, and others return
1181         # tuples with integers and strings. Flatten them out into strings.
1182         for row in result[0]:
1183             if not isinstance(row, str):
1184                 yield ' '.join(str(c) for c in row)
1185             else:
1186                 yield row

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>, <file>django/db/models/expressions.py</file>
<class>None</class>
<method>None</method>
<code>
1 import copy
2 import datetime
3 import inspect
4 from decimal import Decimal
5 
6 from django.core.exceptions import EmptyResultSet, FieldError
7 from django.db import connection
8 from django.db.models import fields
9 from django.db.models.query_utils import Q
10 from django.db.utils import NotSupportedError
11 from django.utils.deconstruct import deconstructible
12 from django.utils.functional import cached_property
13 from django.utils.hashable import make_hashable
14 
15 
16 class SQLiteNumericMixin:
17     """
18     Some expressions with output_field=DecimalField() must be cast to
19     numeric to be properly filtered.
20     """
21     def as_sqlite(self, compiler, connection, **extra_context):
22         sql, params = self.as_sql(compiler, connection, **extra_context)
23         try:
24             if self.output_field.get_internal_type() == 'DecimalField':
25                 sql = 'CAST(%s AS NUMERIC)' % sql
26         except FieldError:
27             pass
28         return sql, params
29 
30 
31 class Combinable:
32     """
33     Provide the ability to combine one or two objects with
34     some connector. For example F('foo') + F('bar').
35     """
36 
37     # Arithmetic connectors
38     ADD = '+'
39     SUB = '-'
40     MUL = '*'
41     DIV = '/'
42     POW = '^'
43     # The following is a quoted % operator - it is quoted because it can be
44     # used in strings that also have parameter substitution.
45     MOD = '%%'
46 
47     # Bitwise operators - note that these are generated by .bitand()
48     # and .bitor(), the '&' and '|' are reserved for boolean operator
49     # usage.
50     BITAND = '&'
51     BITOR = '|'
52     BITLEFTSHIFT = '<<'
53     BITRIGHTSHIFT = '>>'
54 
55     def _combine(self, other, connector, reversed):
56         if not hasattr(other, 'resolve_expression'):
57             # everything must be resolvable to an expression
58             if isinstance(other, datetime.timedelta):
59                 other = DurationValue(other, output_field=fields.DurationField())
60             else:
61                 other = Value(other)
62 
63         if reversed:
64             return CombinedExpression(other, connector, self)
65         return CombinedExpression(self, connector, other)
66 
67     #############
68     # OPERATORS #
69     #############
70 
71     def __neg__(self):
72         return self._combine(-1, self.MUL, False)
73 
74     def __add__(self, other):
75         return self._combine(other, self.ADD, False)
76 
77     def __sub__(self, other):
78         return self._combine(other, self.SUB, False)
79 
80     def __mul__(self, other):
81         return self._combine(other, self.MUL, False)
82 
83     def __truediv__(self, other):
84         return self._combine(other, self.DIV, False)
85 
86     def __mod__(self, other):
87         return self._combine(other, self.MOD, False)
88 
89     def __pow__(self, other):
90         return self._combine(other, self.POW, False)
91 
92     def __and__(self, other):
93         if getattr(self, 'conditional', False) and getattr(other, 'conditional', False):
94             return Q(self) & Q(other)
95         raise NotImplementedError(
96             "Use .bitand() and .bitor() for bitwise logical operations."
97         )
98 
99     def bitand(self, other):
100         return self._combine(other, self.BITAND, False)
101 
102     def bitleftshift(self, other):
103         return self._combine(other, self.BITLEFTSHIFT, False)
104 
105     def bitrightshift(self, other):
106         return self._combine(other, self.BITRIGHTSHIFT, False)
107 
108     def __or__(self, other):
109         if getattr(self, 'conditional', False) and getattr(other, 'conditional', False):
110             return Q(self) | Q(other)
111         raise NotImplementedError(
112             "Use .bitand() and .bitor() for bitwise logical operations."
113         )
114 
115     def bitor(self, other):
116         return self._combine(other, self.BITOR, False)
117 
118     def __radd__(self, other):
119         return self._combine(other, self.ADD, True)
120 
121     def __rsub__(self, other):
122         return self._combine(other, self.SUB, True)
123 
124     def __rmul__(self, other):
125         return self._combine(other, self.MUL, True)
126 
127     def __rtruediv__(self, other):
128         return self._combine(other, self.DIV, True)
129 
130     def __rmod__(self, other):
131         return self._combine(other, self.MOD, True)
132 
133     def __rpow__(self, other):
134         return self._combine(other, self.POW, True)
135 
136     def __rand__(self, other):
137         raise NotImplementedError(
138             "Use .bitand() and .bitor() for bitwise logical operations."
139         )
140 
141     def __ror__(self, other):
142         raise NotImplementedError(
143             "Use .bitand() and .bitor() for bitwise logical operations."
144         )
145 
146 
147 @deconstructible
148 class BaseExpression:
149     """Base class for all query expressions."""
150 
151     # aggregate specific fields
152     is_summary = False
153     _output_field_resolved_to_none = False
154     # Can the expression be used in a WHERE clause?
155     filterable = True
156     # Can the expression can be used as a source expression in Window?
157     window_compatible = False
158 
159     def __init__(self, output_field=None):
160         if output_field is not None:
161             self.output_field = output_field
162 
163     def __getstate__(self):
164         state = self.__dict__.copy()
165         state.pop('convert_value', None)
166         return state
167 
168     def get_db_converters(self, connection):
169         return (
170             []
171             if self.convert_value is self._convert_value_noop else
172             [self.convert_value]
173         ) + self.output_field.get_db_converters(connection)
174 
175     def get_source_expressions(self):
176         return []
177 
178     def set_source_expressions(self, exprs):
179         assert not exprs
180 
181     def _parse_expressions(self, *expressions):
182         return [
183             arg if hasattr(arg, 'resolve_expression') else (
184                 F(arg) if isinstance(arg, str) else Value(arg)
185             ) for arg in expressions
186         ]
187 
188     def as_sql(self, compiler, connection):
189         """
190         Responsible for returning a (sql, [params]) tuple to be included
191         in the current query.
192 
193         Different backends can provide their own implementation, by
194         providing an `as_{vendor}` method and patching the Expression:
195 
196         ```
197         def override_as_sql(self, compiler, connection):
198             # custom logic
199             return super().as_sql(compiler, connection)
200         setattr(Expression, 'as_' + connection.vendor, override_as_sql)
201         ```
202 
203         Arguments:
204          * compiler: the query compiler responsible for generating the query.
205            Must have a compile method, returning a (sql, [params]) tuple.
206            Calling compiler(value) will return a quoted `value`.
207 
208          * connection: the database connection used for the current query.
209 
210         Return: (sql, params)
211           Where `sql` is a string containing ordered sql parameters to be
212           replaced with the elements of the list `params`.
213         """
214         raise NotImplementedError("Subclasses must implement as_sql()")
215 
216     @cached_property
217     def contains_aggregate(self):
218         return any(expr and expr.contains_aggregate for expr in self.get_source_expressions())
219 
220     @cached_property
221     def contains_over_clause(self):
222         return any(expr and expr.contains_over_clause for expr in self.get_source_expressions())
223 
224     @cached_property
225     def contains_column_references(self):
226         return any(expr and expr.contains_column_references for expr in self.get_source_expressions())
227 
228     def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):
229         """
230         Provide the chance to do any preprocessing or validation before being
231         added to the query.
232 
233         Arguments:
234          * query: the backend query implementation
235          * allow_joins: boolean allowing or denying use of joins
236            in this query
237          * reuse: a set of reusable joins for multijoins
238          * summarize: a terminal aggregate clause
239          * for_save: whether this expression about to be used in a save or update
240 
241         Return: an Expression to be added to the query.
242         """
243         c = self.copy()
244         c.is_summary = summarize
245         c.set_source_expressions([
246             expr.resolve_expression(query, allow_joins, reuse, summarize)
247             if expr else None
248             for expr in c.get_source_expressions()
249         ])
250         return c
251 
252     @property
253     def conditional(self):
254         return isinstance(self.output_field, fields.BooleanField)
255 
256     @property
257     def field(self):
258         return self.output_field
259 
260     @cached_property
261     def output_field(self):
262         """Return the output type of this expressions."""
263         output_field = self._resolve_output_field()
264         if output_field is None:
265             self._output_field_resolved_to_none = True
266             raise FieldError('Cannot resolve expression type, unknown output_field')
267         return output_field
268 
269     @cached_property
270     def _output_field_or_none(self):
271         """
272         Return the output field of this expression, or None if
273         _resolve_output_field() didn't return an output type.
274         """
275         try:
276             return self.output_field
277         except FieldError:
278             if not self._output_field_resolved_to_none:
279                 raise
280 
281     def _resolve_output_field(self):
282         """
283         Attempt to infer the output type of the expression. If the output
284         fields of all source fields match then, simply infer the same type
285         here. This isn't always correct, but it makes sense most of the time.
286 
287         Consider the difference between `2 + 2` and `2 / 3`. Inferring
288         the type here is a convenience for the common case. The user should
289         supply their own output_field with more complex computations.
290 
291         If a source's output field resolves to None, exclude it from this check.
292         If all sources are None, then an error is raised higher up the stack in
293         the output_field property.
294         """
295         sources_iter = (source for source in self.get_source_fields() if source is not None)
296         for output_field in sources_iter:
297             for source in sources_iter:
298                 if not isinstance(output_field, source.__class__):
299                     raise FieldError(
300                         'Expression contains mixed types: %s, %s. You must '
301                         'set output_field.' % (
302                             output_field.__class__.__name__,
303                             source.__class__.__name__,
304                         )
305                     )
306             return output_field
307 
308     @staticmethod
309     def _convert_value_noop(value, expression, connection):
310         return value
311 
312     @cached_property
313     def convert_value(self):
314         """
315         Expressions provide their own converters because users have the option
316         of manually specifying the output_field which may be a different type
317         from the one the database returns.
318         """
319         field = self.output_field
320         internal_type = field.get_internal_type()
321         if internal_type == 'FloatField':
322             return lambda value, expression, connection: None if value is None else float(value)
323         elif internal_type.endswith('IntegerField'):
324             return lambda value, expression, connection: None if value is None else int(value)
325         elif internal_type == 'DecimalField':
326             return lambda value, expression, connection: None if value is None else Decimal(value)
327         return self._convert_value_noop
328 
329     def get_lookup(self, lookup):
330         return self.output_field.get_lookup(lookup)
331 
332     def get_transform(self, name):
333         return self.output_field.get_transform(name)
334 
335     def relabeled_clone(self, change_map):
336         clone = self.copy()
337         clone.set_source_expressions([
338             e.relabeled_clone(change_map) if e is not None else None
339             for e in self.get_source_expressions()
340         ])
341         return clone
342 
343     def copy(self):
344         return copy.copy(self)
345 
346     def get_group_by_cols(self, alias=None):
347         if not self.contains_aggregate:
348             return [self]
349         cols = []
350         for source in self.get_source_expressions():
351             cols.extend(source.get_group_by_cols())
352         return cols
353 
354     def get_source_fields(self):
355         """Return the underlying field types used by this aggregate."""
356         return [e._output_field_or_none for e in self.get_source_expressions()]
357 
358     def asc(self, **kwargs):
359         return OrderBy(self, **kwargs)
360 
361     def desc(self, **kwargs):
362         return OrderBy(self, descending=True, **kwargs)
363 
364     def reverse_ordering(self):
365         return self
366 
367     def flatten(self):
368         """
369         Recursively yield this expression and all subexpressions, in
370         depth-first order.
371         """
372         yield self
373         for expr in self.get_source_expressions():
374             if expr:
375                 yield from expr.flatten()
376 
377     def select_format(self, compiler, sql, params):
378         """
379         Custom format for select clauses. For example, EXISTS expressions need
380         to be wrapped in CASE WHEN on Oracle.
381         """
382         return self.output_field.select_format(compiler, sql, params)
383 
384     @cached_property
385     def identity(self):
386         constructor_signature = inspect.signature(self.__init__)
387         args, kwargs = self._constructor_args
388         signature = constructor_signature.bind_partial(*args, **kwargs)
389         signature.apply_defaults()
390         arguments = signature.arguments.items()
391         identity = [self.__class__]
392         for arg, value in arguments:
393             if isinstance(value, fields.Field):
394                 if value.name and value.model:
395                     value = (value.model._meta.label, value.name)
396                 else:
397                     value = type(value)
398             else:
399                 value = make_hashable(value)
400             identity.append((arg, value))
401         return tuple(identity)
402 
403     def __eq__(self, other):
404         if not isinstance(other, BaseExpression):
405             return NotImplemented
406         return other.identity == self.identity
407 
408     def __hash__(self):
409         return hash(self.identity)
410 
411 
412 class Expression(BaseExpression, Combinable):
413     """An expression that can be combined with other expressions."""
414     pass
415 
416 
417 class CombinedExpression(SQLiteNumericMixin, Expression):
418 
419     def __init__(self, lhs, connector, rhs, output_field=None):
420         super().__init__(output_field=output_field)
421         self.connector = connector
422         self.lhs = lhs
423         self.rhs = rhs
424 
425     def __repr__(self):
426         return "<{}: {}>".format(self.__class__.__name__, self)
427 
428     def __str__(self):
429         return "{} {} {}".format(self.lhs, self.connector, self.rhs)
430 
431     def get_source_expressions(self):
432         return [self.lhs, self.rhs]
433 
434     def set_source_expressions(self, exprs):
435         self.lhs, self.rhs = exprs
436 
437     def as_sql(self, compiler, connection):
438         try:
439             lhs_output = self.lhs.output_field
440         except FieldError:
441             lhs_output = None
442         try:
443             rhs_output = self.rhs.output_field
444         except FieldError:
445             rhs_output = None
446         if (not connection.features.has_native_duration_field and
447                 ((lhs_output and lhs_output.get_internal_type() == 'DurationField') or
448                  (rhs_output and rhs_output.get_internal_type() == 'DurationField'))):
449             return DurationExpression(self.lhs, self.connector, self.rhs).as_sql(compiler, connection)
450         if (lhs_output and rhs_output and self.connector == self.SUB and
451             lhs_output.get_internal_type() in {'DateField', 'DateTimeField', 'TimeField'} and
452                 lhs_output.get_internal_type() == rhs_output.get_internal_type()):
453             return TemporalSubtraction(self.lhs, self.rhs).as_sql(compiler, connection)
454         expressions = []
455         expression_params = []
456         sql, params = compiler.compile(self.lhs)
457         expressions.append(sql)
458         expression_params.extend(params)
459         sql, params = compiler.compile(self.rhs)
460         expressions.append(sql)
461         expression_params.extend(params)
462         # order of precedence
463         expression_wrapper = '(%s)'
464         sql = connection.ops.combine_expression(self.connector, expressions)
465         return expression_wrapper % sql, expression_params
466 
467     def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):
468         c = self.copy()
469         c.is_summary = summarize
470         c.lhs = c.lhs.resolve_expression(query, allow_joins, reuse, summarize, for_save)
471         c.rhs = c.rhs.resolve_expression(query, allow_joins, reuse, summarize, for_save)
472         return c
473 
474 
475 class DurationExpression(CombinedExpression):
476     def compile(self, side, compiler, connection):
477         if not isinstance(side, DurationValue):
478             try:
479                 output = side.output_field
480             except FieldError:
481                 pass
482             else:
483                 if output.get_internal_type() == 'DurationField':
484                     sql, params = compiler.compile(side)
485                     return connection.ops.format_for_duration_arithmetic(sql), params
486         return compiler.compile(side)
487 
488     def as_sql(self, compiler, connection):
489         connection.ops.check_expression_support(self)
490         expressions = []
491         expression_params = []
492         sql, params = self.compile(self.lhs, compiler, connection)
493         expressions.append(sql)
494         expression_params.extend(params)
495         sql, params = self.compile(self.rhs, compiler, connection)
496         expressions.append(sql)
497         expression_params.extend(params)
498         # order of precedence
499         expression_wrapper = '(%s)'
500         sql = connection.ops.combine_duration_expression(self.connector, expressions)
501         return expression_wrapper % sql, expression_params
502 
503 
504 class TemporalSubtraction(CombinedExpression):
505     output_field = fields.DurationField()
506 
507     def __init__(self, lhs, rhs):
508         super().__init__(lhs, self.SUB, rhs)
509 
510     def as_sql(self, compiler, connection):
511         connection.ops.check_expression_support(self)
512         lhs = compiler.compile(self.lhs)
513         rhs = compiler.compile(self.rhs)
514         return connection.ops.subtract_temporals(self.lhs.output_field.get_internal_type(), lhs, rhs)
515 
516 
517 @deconstructible
518 class F(Combinable):
519     """An object capable of resolving references to existing query objects."""
520 
521     def __init__(self, name):
522         """
523         Arguments:
524          * name: the name of the field this expression references
525         """
526         self.name = name
527 
528     def __repr__(self):
529         return "{}({})".format(self.__class__.__name__, self.name)
530 
531     def resolve_expression(self, query=None, allow_joins=True, reuse=None,
532                            summarize=False, for_save=False):
533         return query.resolve_ref(self.name, allow_joins, reuse, summarize)
534 
535     def asc(self, **kwargs):
536         return OrderBy(self, **kwargs)
537 
538     def desc(self, **kwargs):
539         return OrderBy(self, descending=True, **kwargs)
540 
541     def __eq__(self, other):
542         return self.__class__ == other.__class__ and self.name == other.name
543 
544     def __hash__(self):
545         return hash(self.name)
546 
547 
548 class ResolvedOuterRef(F):
549     """
550     An object that contains a reference to an outer query.
551 
552     In this case, the reference to the outer query has been resolved because
553     the inner query has been used as a subquery.
554     """
555     contains_aggregate = False
556 
557     def as_sql(self, *args, **kwargs):
558         raise ValueError(
559             'This queryset contains a reference to an outer query and may '
560             'only be used in a subquery.'
561         )
562 
563     def relabeled_clone(self, relabels):
564         return self
565 
566 
567 class OuterRef(F):
568     def resolve_expression(self, *args, **kwargs):
569         if isinstance(self.name, self.__class__):
570             return self.name
571         return ResolvedOuterRef(self.name)
572 
573 
574 class Func(SQLiteNumericMixin, Expression):
575     """An SQL function call."""
576     function = None
577     template = '%(function)s(%(expressions)s)'
578     arg_joiner = ', '
579     arity = None  # The number of arguments the function accepts.
580 
581     def __init__(self, *expressions, output_field=None, **extra):
582         if self.arity is not None and len(expressions) != self.arity:
583             raise TypeError(
584                 "'%s' takes exactly %s %s (%s given)" % (
585                     self.__class__.__name__,
586                     self.arity,
587                     "argument" if self.arity == 1 else "arguments",
588                     len(expressions),
589                 )
590             )
591         super().__init__(output_field=output_field)
592         self.source_expressions = self._parse_expressions(*expressions)
593         self.extra = extra
594 
595     def __repr__(self):
596         args = self.arg_joiner.join(str(arg) for arg in self.source_expressions)
597         extra = {**self.extra, **self._get_repr_options()}
598         if extra:
599             extra = ', '.join(str(key) + '=' + str(val) for key, val in sorted(extra.items()))
600             return "{}({}, {})".format(self.__class__.__name__, args, extra)
601         return "{}({})".format(self.__class__.__name__, args)
602 
603     def _get_repr_options(self):
604         """Return a dict of extra __init__() options to include in the repr."""
605         return {}
606 
607     def get_source_expressions(self):
608         return self.source_expressions
609 
610     def set_source_expressions(self, exprs):
611         self.source_expressions = exprs
612 
613     def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):
614         c = self.copy()
615         c.is_summary = summarize
616         for pos, arg in enumerate(c.source_expressions):
617             c.source_expressions[pos] = arg.resolve_expression(query, allow_joins, reuse, summarize, for_save)
618         return c
619 
620     def as_sql(self, compiler, connection, function=None, template=None, arg_joiner=None, **extra_context):
621         connection.ops.check_expression_support(self)
622         sql_parts = []
623         params = []
624         for arg in self.source_expressions:
625             arg_sql, arg_params = compiler.compile(arg)
626             sql_parts.append(arg_sql)
627             params.extend(arg_params)
628         data = {**self.extra, **extra_context}
629         # Use the first supplied value in this order: the parameter to this
630         # method, a value supplied in __init__()'s **extra (the value in
631         # `data`), or the value defined on the class.
632         if function is not None:
633             data['function'] = function
634         else:
635             data.setdefault('function', self.function)
636         template = template or data.get('template', self.template)
637         arg_joiner = arg_joiner or data.get('arg_joiner', self.arg_joiner)
638         data['expressions'] = data['field'] = arg_joiner.join(sql_parts)
639         return template % data, params
640 
641     def copy(self):
642         copy = super().copy()
643         copy.source_expressions = self.source_expressions[:]
644         copy.extra = self.extra.copy()
645         return copy
646 
647 
648 class Value(Expression):
649     """Represent a wrapped value as a node within an expression."""
650     def __init__(self, value, output_field=None):
651         """
652         Arguments:
653          * value: the value this expression represents. The value will be
654            added into the sql parameter list and properly quoted.
655 
656          * output_field: an instance of the model field type that this
657            expression will return, such as IntegerField() or CharField().
658         """
659         super().__init__(output_field=output_field)
660         self.value = value
661 
662     def __repr__(self):
663         return "{}({})".format(self.__class__.__name__, self.value)
664 
665     def as_sql(self, compiler, connection):
666         connection.ops.check_expression_support(self)
667         val = self.value
668         output_field = self._output_field_or_none
669         if output_field is not None:
670             if self.for_save:
671                 val = output_field.get_db_prep_save(val, connection=connection)
672             else:
673                 val = output_field.get_db_prep_value(val, connection=connection)
674             if hasattr(output_field, 'get_placeholder'):
675                 return output_field.get_placeholder(val, compiler, connection), [val]
676         if val is None:
677             # cx_Oracle does not always convert None to the appropriate
678             # NULL type (like in case expressions using numbers), so we
679             # use a literal SQL NULL
680             return 'NULL', []
681         return '%s', [val]
682 
683     def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):
684         c = super().resolve_expression(query, allow_joins, reuse, summarize, for_save)
685         c.for_save = for_save
686         return c
687 
688     def get_group_by_cols(self, alias=None):
689         return []
690 
691 
692 class DurationValue(Value):
693     def as_sql(self, compiler, connection):
694         connection.ops.check_expression_support(self)
695         if connection.features.has_native_duration_field:
696             return super().as_sql(compiler, connection)
697         return connection.ops.date_interval_sql(self.value), []
698 
699 
700 class RawSQL(Expression):
701     def __init__(self, sql, params, output_field=None):
702         if output_field is None:
703             output_field = fields.Field()
704         self.sql, self.params = sql, params
705         super().__init__(output_field=output_field)
706 
707     def __repr__(self):
708         return "{}({}, {})".format(self.__class__.__name__, self.sql, self.params)
709 
710     def as_sql(self, compiler, connection):
711         return '(%s)' % self.sql, self.params
712 
713     def get_group_by_cols(self, alias=None):
714         return [self]
715 
716     def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):
717         # Resolve parents fields used in raw SQL.
718         for parent in query.model._meta.get_parent_list():
719             for parent_field in parent._meta.local_fields:
720                 _, column_name = parent_field.get_attname_column()
721                 if column_name.lower() in self.sql.lower():
722                     query.resolve_ref(parent_field.name, allow_joins, reuse, summarize)
723                     break
724         return super().resolve_expression(query, allow_joins, reuse, summarize, for_save)
725 
726 
727 class Star(Expression):
728     def __repr__(self):
729         return "'*'"
730 
731     def as_sql(self, compiler, connection):
732         return '*', []
733 
734 
735 class Random(Expression):
736     output_field = fields.FloatField()
737 
738     def __repr__(self):
739         return "Random()"
740 
741     def as_sql(self, compiler, connection):
742         return connection.ops.random_function_sql(), []
743 
744 
745 class Col(Expression):
746 
747     contains_column_references = True
748 
749     def __init__(self, alias, target, output_field=None):
750         if output_field is None:
751             output_field = target
752         super().__init__(output_field=output_field)
753         self.alias, self.target = alias, target
754 
755     def __repr__(self):
756         alias, target = self.alias, self.target
757         identifiers = (alias, str(target)) if alias else (str(target),)
758         return '{}({})'.format(self.__class__.__name__, ', '.join(identifiers))
759 
760     def as_sql(self, compiler, connection):
761         alias, column = self.alias, self.target.column
762         identifiers = (alias, column) if alias else (column,)
763         sql = '.'.join(map(compiler.quote_name_unless_alias, identifiers))
764         return sql, []
765 
766     def relabeled_clone(self, relabels):
767         if self.alias is None:
768             return self
769         return self.__class__(relabels.get(self.alias, self.alias), self.target, self.output_field)
770 
771     def get_group_by_cols(self, alias=None):
772         return [self]
773 
774     def get_db_converters(self, connection):
775         if self.target == self.output_field:
776             return self.output_field.get_db_converters(connection)
777         return (self.output_field.get_db_converters(connection) +
778                 self.target.get_db_converters(connection))
779 
780 
781 class Ref(Expression):
782     """
783     Reference to column alias of the query. For example, Ref('sum_cost') in
784     qs.annotate(sum_cost=Sum('cost')) query.
785     """
786     def __init__(self, refs, source):
787         super().__init__()
788         self.refs, self.source = refs, source
789 
790     def __repr__(self):
791         return "{}({}, {})".format(self.__class__.__name__, self.refs, self.source)
792 
793     def get_source_expressions(self):
794         return [self.source]
795 
796     def set_source_expressions(self, exprs):
797         self.source, = exprs
798 
799     def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):
800         # The sub-expression `source` has already been resolved, as this is
801         # just a reference to the name of `source`.
802         return self
803 
804     def relabeled_clone(self, relabels):
805         return self
806 
807     def as_sql(self, compiler, connection):
808         return connection.ops.quote_name(self.refs), []
809 
810     def get_group_by_cols(self, alias=None):
811         return [self]
812 
813 
814 class ExpressionList(Func):
815     """
816     An expression containing multiple expressions. Can be used to provide a
817     list of expressions as an argument to another expression, like an
818     ordering clause.
819     """
820     template = '%(expressions)s'
821 
822     def __init__(self, *expressions, **extra):
823         if not expressions:
824             raise ValueError('%s requires at least one expression.' % self.__class__.__name__)
825         super().__init__(*expressions, **extra)
826 
827     def __str__(self):
828         return self.arg_joiner.join(str(arg) for arg in self.source_expressions)
829 
830 
831 class ExpressionWrapper(Expression):
832     """
833     An expression that can wrap another expression so that it can provide
834     extra context to the inner expression, such as the output_field.
835     """
836 
837     def __init__(self, expression, output_field):
838         super().__init__(output_field=output_field)
839         self.expression = expression
840 
841     def set_source_expressions(self, exprs):
842         self.expression = exprs[0]
843 
844     def get_source_expressions(self):
845         return [self.expression]
846 
847     def as_sql(self, compiler, connection):
848         return self.expression.as_sql(compiler, connection)
849 
850     def __repr__(self):
851         return "{}({})".format(self.__class__.__name__, self.expression)
852 
853 
854 class When(Expression):
855     template = 'WHEN %(condition)s THEN %(result)s'
856     # This isn't a complete conditional expression, must be used in Case().
857     conditional = False
858 
859     def __init__(self, condition=None, then=None, **lookups):
860         if lookups and condition is None:
861             condition, lookups = Q(**lookups), None
862         if condition is None or not getattr(condition, 'conditional', False) or lookups:
863             raise TypeError(
864                 'When() supports a Q object, a boolean expression, or lookups '
865                 'as a condition.'
866             )
867         if isinstance(condition, Q) and not condition:
868             raise ValueError("An empty Q() can't be used as a When() condition.")
869         super().__init__(output_field=None)
870         self.condition = condition
871         self.result = self._parse_expressions(then)[0]
872 
873     def __str__(self):
874         return "WHEN %r THEN %r" % (self.condition, self.result)
875 
876     def __repr__(self):
877         return "<%s: %s>" % (self.__class__.__name__, self)
878 
879     def get_source_expressions(self):
880         return [self.condition, self.result]
881 
882     def set_source_expressions(self, exprs):
883         self.condition, self.result = exprs
884 
885     def get_source_fields(self):
886         # We're only interested in the fields of the result expressions.
887         return [self.result._output_field_or_none]
888 
889     def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):
890         c = self.copy()
891         c.is_summary = summarize
892         if hasattr(c.condition, 'resolve_expression'):
893             c.condition = c.condition.resolve_expression(query, allow_joins, reuse, summarize, False)
894         c.result = c.result.resolve_expression(query, allow_joins, reuse, summarize, for_save)
895         return c
896 
897     def as_sql(self, compiler, connection, template=None, **extra_context):
898         connection.ops.check_expression_support(self)
899         template_params = extra_context
900         sql_params = []
901         condition_sql, condition_params = compiler.compile(self.condition)
902         template_params['condition'] = condition_sql
903         sql_params.extend(condition_params)
904         result_sql, result_params = compiler.compile(self.result)
905         template_params['result'] = result_sql
906         sql_params.extend(result_params)
907         template = template or self.template
908         return template % template_params, sql_params
909 
910     def get_group_by_cols(self, alias=None):
911         # This is not a complete expression and cannot be used in GROUP BY.
912         cols = []
913         for source in self.get_source_expressions():
914             cols.extend(source.get_group_by_cols())
915         return cols
916 
917 
918 class Case(Expression):
919     """
920     An SQL searched CASE expression:
921 
922         CASE
923             WHEN n > 0
924                 THEN 'positive'
925             WHEN n < 0
926                 THEN 'negative'
927             ELSE 'zero'
928         END
929     """
930     template = 'CASE %(cases)s ELSE %(default)s END'
931     case_joiner = ' '
932 
933     def __init__(self, *cases, default=None, output_field=None, **extra):
934         if not all(isinstance(case, When) for case in cases):
935             raise TypeError("Positional arguments must all be When objects.")
936         super().__init__(output_field)
937         self.cases = list(cases)
938         self.default = self._parse_expressions(default)[0]
939         self.extra = extra
940 
941     def __str__(self):
942         return "CASE %s, ELSE %r" % (', '.join(str(c) for c in self.cases), self.default)
943 
944     def __repr__(self):
945         return "<%s: %s>" % (self.__class__.__name__, self)
946 
947     def get_source_expressions(self):
948         return self.cases + [self.default]
949 
950     def set_source_expressions(self, exprs):
951         *self.cases, self.default = exprs
952 
953     def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):
954         c = self.copy()
955         c.is_summary = summarize
956         for pos, case in enumerate(c.cases):
957             c.cases[pos] = case.resolve_expression(query, allow_joins, reuse, summarize, for_save)
958         c.default = c.default.resolve_expression(query, allow_joins, reuse, summarize, for_save)
959         return c
960 
961     def copy(self):
962         c = super().copy()
963         c.cases = c.cases[:]
964         return c
965 
966     def as_sql(self, compiler, connection, template=None, case_joiner=None, **extra_context):
967         connection.ops.check_expression_support(self)
968         if not self.cases:
969             return compiler.compile(self.default)
970         template_params = {**self.extra, **extra_context}
971         case_parts = []
972         sql_params = []
973         for case in self.cases:
974             try:
975                 case_sql, case_params = compiler.compile(case)
976             except EmptyResultSet:
977                 continue
978             case_parts.append(case_sql)
979             sql_params.extend(case_params)
980         default_sql, default_params = compiler.compile(self.default)
981         if not case_parts:
982             return default_sql, default_params
983         case_joiner = case_joiner or self.case_joiner
984         template_params['cases'] = case_joiner.join(case_parts)
985         template_params['default'] = default_sql
986         sql_params.extend(default_params)
987         template = template or template_params.get('template', self.template)
988         sql = template % template_params
989         if self._output_field_or_none is not None:
990             sql = connection.ops.unification_cast_sql(self.output_field) % sql
991         return sql, sql_params
992 
993 
994 class Subquery(Expression):
995     """
996     An explicit subquery. It may contain OuterRef() references to the outer
997     query which will be resolved when it is applied to that query.
998     """
999     template = '(%(subquery)s)'
1000     contains_aggregate = False
1001 
1002     def __init__(self, queryset, output_field=None, **extra):
1003         self.query = queryset.query
1004         self.extra = extra
1005         super().__init__(output_field)
1006 
1007     def __getstate__(self):
1008         state = super().__getstate__()
1009         state.pop('_constructor_args', None)
1010         return state
1011 
1012     def get_source_expressions(self):
1013         return [self.query]
1014 
1015     def set_source_expressions(self, exprs):
1016         self.query = exprs[0]
1017 
1018     def _resolve_output_field(self):
1019         return self.query.output_field
1020 
1021     def copy(self):
1022         clone = super().copy()
1023         clone.query = clone.query.clone()
1024         return clone
1025 
1026     @property
1027     def external_aliases(self):
1028         return self.query.external_aliases
1029 
1030     def as_sql(self, compiler, connection, template=None, **extra_context):
1031         connection.ops.check_expression_support(self)
1032         template_params = {**self.extra, **extra_context}
1033         subquery_sql, sql_params = self.query.as_sql(compiler, connection)
1034         template_params['subquery'] = subquery_sql[1:-1]
1035 
1036         template = template or template_params.get('template', self.template)
1037         sql = template % template_params
1038         return sql, sql_params
1039 
1040     def get_group_by_cols(self, alias=None):
1041         if alias:
1042             return [Ref(alias, self)]
1043         return []
1044 
1045 
1046 class Exists(Subquery):
1047     template = 'EXISTS(%(subquery)s)'
1048     output_field = fields.BooleanField()
1049 
1050     def __init__(self, queryset, negated=False, **kwargs):
1051         # As a performance optimization, remove ordering since EXISTS doesn't
1052         # care about it, just whether or not a row matches.
1053         queryset = queryset.order_by()
1054         self.negated = negated
1055         super().__init__(queryset, **kwargs)
1056 
1057     def __invert__(self):
1058         clone = self.copy()
1059         clone.negated = not self.negated
1060         return clone
1061 
1062     def as_sql(self, compiler, connection, template=None, **extra_context):
1063         sql, params = super().as_sql(compiler, connection, template, **extra_context)
1064         if self.negated:
1065             sql = 'NOT {}'.format(sql)
1066         return sql, params
1067 
1068     def select_format(self, compiler, sql, params):
1069         # Wrap EXISTS() with a CASE WHEN expression if a database backend
1070         # (e.g. Oracle) doesn't support boolean expression in the SELECT list.
1071         if not compiler.connection.features.supports_boolean_expr_in_select_clause:
1072             sql = 'CASE WHEN {} THEN 1 ELSE 0 END'.format(sql)
1073         return sql, params
1074 
1075 
1076 class OrderBy(BaseExpression):
1077     template = '%(expression)s %(ordering)s'
1078     conditional = False
1079 
1080     def __init__(self, expression, descending=False, nulls_first=False, nulls_last=False):
1081         if nulls_first and nulls_last:
1082             raise ValueError('nulls_first and nulls_last are mutually exclusive')
1083         self.nulls_first = nulls_first
1084         self.nulls_last = nulls_last
1085         self.descending = descending
1086         if not hasattr(expression, 'resolve_expression'):
1087             raise ValueError('expression must be an expression type')
1088         self.expression = expression
1089 
1090     def __repr__(self):
1091         return "{}({}, descending={})".format(
1092             self.__class__.__name__, self.expression, self.descending)
1093 
1094     def set_source_expressions(self, exprs):
1095         self.expression = exprs[0]
1096 
1097     def get_source_expressions(self):
1098         return [self.expression]
1099 
1100     def as_sql(self, compiler, connection, template=None, **extra_context):
1101         template = template or self.template
1102         if connection.features.supports_order_by_nulls_modifier:
1103             if self.nulls_last:
1104                 template = '%s NULLS LAST' % template
1105             elif self.nulls_first:
1106                 template = '%s NULLS FIRST' % template
1107         else:
1108             if self.nulls_last:
1109                 template = '%%(expression)s IS NULL, %s' % template
1110             elif self.nulls_first:
1111                 template = '%%(expression)s IS NOT NULL, %s' % template
1112         connection.ops.check_expression_support(self)
1113         expression_sql, params = compiler.compile(self.expression)
1114         placeholders = {
1115             'expression': expression_sql,
1116             'ordering': 'DESC' if self.descending else 'ASC',
1117             **extra_context,
1118         }
1119         template = template or self.template
1120         params *= template.count('%(expression)s')
1121         return (template % placeholders).rstrip(), params
1122 
1123     def as_oracle(self, compiler, connection):
1124         # Oracle doesn't allow ORDER BY EXISTS() unless it's wrapped in
1125         # a CASE WHEN.
1126         if isinstance(self.expression, Exists):
1127             copy = self.copy()
1128             copy.expression = Case(
1129                 When(self.expression, then=True),
1130                 default=False,
1131                 output_field=fields.BooleanField(),
1132             )
1133             return copy.as_sql(compiler, connection)
1134         return self.as_sql(compiler, connection)
1135 
1136     def get_group_by_cols(self, alias=None):
1137         cols = []
1138         for source in self.get_source_expressions():
1139             cols.extend(source.get_group_by_cols())
1140         return cols
1141 
1142     def reverse_ordering(self):
1143         self.descending = not self.descending
1144         if self.nulls_first or self.nulls_last:
1145             self.nulls_first = not self.nulls_first
1146             self.nulls_last = not self.nulls_last
1147         return self
1148 
1149     def asc(self):
1150         self.descending = False
1151 
1152     def desc(self):
1153         self.descending = True
1154 
1155 
1156 class Window(Expression):
1157     template = '%(expression)s OVER (%(window)s)'
1158     # Although the main expression may either be an aggregate or an
1159     # expression with an aggregate function, the GROUP BY that will
1160     # be introduced in the query as a result is not desired.
1161     contains_aggregate = False
1162     contains_over_clause = True
1163     filterable = False
1164 
1165     def __init__(self, expression, partition_by=None, order_by=None, frame=None, output_field=None):
1166         self.partition_by = partition_by
1167         self.order_by = order_by
1168         self.frame = frame
1169 
1170         if not getattr(expression, 'window_compatible', False):
1171             raise ValueError(
1172                 "Expression '%s' isn't compatible with OVER clauses." %
1173                 expression.__class__.__name__
1174             )
1175 
1176         if self.partition_by is not None:
1177             if not isinstance(self.partition_by, (tuple, list)):
1178                 self.partition_by = (self.partition_by,)
1179             self.partition_by = ExpressionList(*self.partition_by)
1180 
1181         if self.order_by is not None:
1182             if isinstance(self.order_by, (list, tuple)):
1183                 self.order_by = ExpressionList(*self.order_by)
1184             elif not isinstance(self.order_by, BaseExpression):
1185                 raise ValueError(
1186                     'order_by must be either an Expression or a sequence of '
1187                     'expressions.'
1188                 )
1189         super().__init__(output_field=output_field)
1190         self.source_expression = self._parse_expressions(expression)[0]
1191 
1192     def _resolve_output_field(self):
1193         return self.source_expression.output_field
1194 
1195     def get_source_expressions(self):
1196         return [self.source_expression, self.partition_by, self.order_by, self.frame]
1197 
1198     def set_source_expressions(self, exprs):
1199         self.source_expression, self.partition_by, self.order_by, self.frame = exprs
1200 
1201     def as_sql(self, compiler, connection, template=None):
1202         connection.ops.check_expression_support(self)
1203         if not connection.features.supports_over_clause:
1204             raise NotSupportedError('This backend does not support window expressions.')
1205         expr_sql, params = compiler.compile(self.source_expression)
1206         window_sql, window_params = [], []
1207 
1208         if self.partition_by is not None:
1209             sql_expr, sql_params = self.partition_by.as_sql(
1210                 compiler=compiler, connection=connection,
1211                 template='PARTITION BY %(expressions)s',
1212             )
1213             window_sql.extend(sql_expr)
1214             window_params.extend(sql_params)
1215 
1216         if self.order_by is not None:
1217             window_sql.append(' ORDER BY ')
1218             order_sql, order_params = compiler.compile(self.order_by)
1219             window_sql.extend(order_sql)
1220             window_params.extend(order_params)
1221 
1222         if self.frame:
1223             frame_sql, frame_params = compiler.compile(self.frame)
1224             window_sql.append(' ' + frame_sql)
1225             window_params.extend(frame_params)
1226 
1227         params.extend(window_params)
1228         template = template or self.template
1229 
1230         return template % {
1231             'expression': expr_sql,
1232             'window': ''.join(window_sql).strip()
1233         }, params
1234 
1235     def __str__(self):
1236         return '{} OVER ({}{}{})'.format(
1237             str(self.source_expression),
1238             'PARTITION BY ' + str(self.partition_by) if self.partition_by else '',
1239             'ORDER BY ' + str(self.order_by) if self.order_by else '',
1240             str(self.frame or ''),
1241         )
1242 
1243     def __repr__(self):
1244         return '<%s: %s>' % (self.__class__.__name__, self)
1245 
1246     def get_group_by_cols(self, alias=None):
1247         return []
1248 
1249 
1250 class WindowFrame(Expression):
1251     """
1252     Model the frame clause in window expressions. There are two types of frame
1253     clauses which are subclasses, however, all processing and validation (by no
1254     means intended to be complete) is done here. Thus, providing an end for a
1255     frame is optional (the default is UNBOUNDED FOLLOWING, which is the last
1256     row in the frame).
1257     """
1258     template = '%(frame_type)s BETWEEN %(start)s AND %(end)s'
1259 
1260     def __init__(self, start=None, end=None):
1261         self.start = Value(start)
1262         self.end = Value(end)
1263 
1264     def set_source_expressions(self, exprs):
1265         self.start, self.end = exprs
1266 
1267     def get_source_expressions(self):
1268         return [self.start, self.end]
1269 
1270     def as_sql(self, compiler, connection):
1271         connection.ops.check_expression_support(self)
1272         start, end = self.window_frame_start_end(connection, self.start.value, self.end.value)
1273         return self.template % {
1274             'frame_type': self.frame_type,
1275             'start': start,
1276             'end': end,
1277         }, []
1278 
1279     def __repr__(self):
1280         return '<%s: %s>' % (self.__class__.__name__, self)
1281 
1282     def get_group_by_cols(self, alias=None):
1283         return []
1284 
1285     def __str__(self):
1286         if self.start.value is not None and self.start.value < 0:
1287             start = '%d %s' % (abs(self.start.value), connection.ops.PRECEDING)
1288         elif self.start.value is not None and self.start.value == 0:
1289             start = connection.ops.CURRENT_ROW
1290         else:
1291             start = connection.ops.UNBOUNDED_PRECEDING
1292 
1293         if self.end.value is not None and self.end.value > 0:
1294             end = '%d %s' % (self.end.value, connection.ops.FOLLOWING)
1295         elif self.end.value is not None and self.end.value == 0:
1296             end = connection.ops.CURRENT_ROW
1297         else:
1298             end = connection.ops.UNBOUNDED_FOLLOWING
1299         return self.template % {
1300             'frame_type': self.frame_type,
1301             'start': start,
1302             'end': end,
1303         }
1304 
1305     def window_frame_start_end(self, connection, start, end):
1306         raise NotImplementedError('Subclasses must implement window_frame_start_end().')
1307 
1308 
1309 class RowRange(WindowFrame):
1310     frame_type = 'ROWS'
1311 
1312     def window_frame_start_end(self, connection, start, end):
1313         return connection.ops.window_frame_rows_start_end(start, end)
1314 
1315 
1316 class ValueRange(WindowFrame):
1317     frame_type = 'RANGE'
1318 
1319     def window_frame_start_end(self, connection, start, end):
1320         return connection.ops.window_frame_range_start_end(start, end)

</code><intended_behavior>Ensure that when `Case` expressions include `Window` functions, they are processed in a way that the window function's result is accessible and usable in a `SELECT` clause without raising `NotSupportedError`.</intended_behavior>]
2025-10-18 11:21:55.144 | INFO     | Search completed. Bug locations: [<file>django/db/models/sql/compiler.py</file>
<class>SQLCompiler</class>
<method>as_sql</method>
<code>
472     def as_sql(self, with_limits=True, with_col_aliases=False):
473         """
474         Create the SQL for this query. Return the SQL string and list of
475         parameters.
476 
477         If 'with_limits' is False, any limit/offset information is not included
478         in the query.
479         """
480         refcounts_before = self.query.alias_refcount.copy()
481         try:
482             extra_select, order_by, group_by = self.pre_sql_setup()
483             for_update_part = None
484             # Is a LIMIT/OFFSET clause needed?
485             with_limit_offset = with_limits and (self.query.high_mark is not None or self.query.low_mark)
486             combinator = self.query.combinator
487             features = self.connection.features
488             if combinator:
489                 if not getattr(features, 'supports_select_{}'.format(combinator)):
490                     raise NotSupportedError('{} is not supported on this database backend.'.format(combinator))
491                 result, params = self.get_combinator_sql(combinator, self.query.combinator_all)
492             else:
493                 distinct_fields, distinct_params = self.get_distinct()
494                 # This must come after 'select', 'ordering', and 'distinct'
495                 # (see docstring of get_from_clause() for details).
496                 from_, f_params = self.get_from_clause()
497                 where, w_params = self.compile(self.where) if self.where is not None else ("", [])
498                 having, h_params = self.compile(self.having) if self.having is not None else ("", [])
499                 result = ['SELECT']
500                 params = []
501 
502                 if self.query.distinct:
503                     distinct_result, distinct_params = self.connection.ops.distinct_sql(
504                         distinct_fields,
505                         distinct_params,
506                     )
507                     result += distinct_result
508                     params += distinct_params
509 
510                 out_cols = []
511                 col_idx = 1
512                 for _, (s_sql, s_params), alias in self.select + extra_select:
513                     if alias:
514                         s_sql = '%s AS %s' % (s_sql, self.connection.ops.quote_name(alias))
515                     elif with_col_aliases:
516                         s_sql = '%s AS %s' % (s_sql, 'Col%d' % col_idx)
517                         col_idx += 1
518                     params.extend(s_params)
519                     out_cols.append(s_sql)
520 
521                 result += [', '.join(out_cols), 'FROM', *from_]
522                 params.extend(f_params)
523 
524                 if self.query.select_for_update and self.connection.features.has_select_for_update:
525                     if self.connection.get_autocommit():
526                         raise TransactionManagementError('select_for_update cannot be used outside of a transaction.')
527 
528                     if with_limit_offset and not self.connection.features.supports_select_for_update_with_limit:
529                         raise NotSupportedError(
530                             'LIMIT/OFFSET is not supported with '
531                             'select_for_update on this database backend.'
532                         )
533                     nowait = self.query.select_for_update_nowait
534                     skip_locked = self.query.select_for_update_skip_locked
535                     of = self.query.select_for_update_of
536                     # If it's a NOWAIT/SKIP LOCKED/OF query but the backend
537                     # doesn't support it, raise NotSupportedError to prevent a
538                     # possible deadlock.
539                     if nowait and not self.connection.features.has_select_for_update_nowait:
540                         raise NotSupportedError('NOWAIT is not supported on this database backend.')
541                     elif skip_locked and not self.connection.features.has_select_for_update_skip_locked:
542                         raise NotSupportedError('SKIP LOCKED is not supported on this database backend.')
543                     elif of and not self.connection.features.has_select_for_update_of:
544                         raise NotSupportedError('FOR UPDATE OF is not supported on this database backend.')
545                     for_update_part = self.connection.ops.for_update_sql(
546                         nowait=nowait,
547                         skip_locked=skip_locked,
548                         of=self.get_select_for_update_of_arguments(),
549                     )
550 
551                 if for_update_part and self.connection.features.for_update_after_from:
552                     result.append(for_update_part)
553 
554                 if where:
555                     result.append('WHERE %s' % where)
556                     params.extend(w_params)
557 
558                 grouping = []
559                 for g_sql, g_params in group_by:
560                     grouping.append(g_sql)
561                     params.extend(g_params)
562                 if grouping:
563                     if distinct_fields:
564                         raise NotImplementedError('annotate() + distinct(fields) is not implemented.')
565                     order_by = order_by or self.connection.ops.force_no_ordering()
566                     result.append('GROUP BY %s' % ', '.join(grouping))
567                     if self._meta_ordering:
568                         order_by = None
569                 if having:
570                     result.append('HAVING %s' % having)
571                     params.extend(h_params)
572 
573             if self.query.explain_query:
574                 result.insert(0, self.connection.ops.explain_query_prefix(
575                     self.query.explain_format,
576                     **self.query.explain_options
577                 ))
578 
579             if order_by:
580                 ordering = []
581                 for _, (o_sql, o_params, _) in order_by:
582                     ordering.append(o_sql)
583                     params.extend(o_params)
584                 result.append('ORDER BY %s' % ', '.join(ordering))
585 
586             if with_limit_offset:
587                 result.append(self.connection.ops.limit_offset_sql(self.query.low_mark, self.query.high_mark))
588 
589             if for_update_part and not self.connection.features.for_update_after_from:
590                 result.append(for_update_part)
591 
592             if self.query.subquery and extra_select:
593                 # If the query is used as a subquery, the extra selects would
594                 # result in more columns than the left-hand side expression is
595                 # expecting. This can happen when a subquery uses a combination
596                 # of order_by() and distinct(), forcing the ordering expressions
597                 # to be selected as well. Wrap the query in another subquery
598                 # to exclude extraneous selects.
599                 sub_selects = []
600                 sub_params = []
601                 for index, (select, _, alias) in enumerate(self.select, start=1):
602                     if not alias and with_col_aliases:
603                         alias = 'col%d' % index
604                     if alias:
605                         sub_selects.append("%s.%s" % (
606                             self.connection.ops.quote_name('subquery'),
607                             self.connection.ops.quote_name(alias),
608                         ))
609                     else:
610                         select_clone = select.relabeled_clone({select.alias: 'subquery'})
611                         subselect, subparams = select_clone.as_sql(self, self.connection)
612                         sub_selects.append(subselect)
613                         sub_params.extend(subparams)
614                 return 'SELECT %s FROM (%s) subquery' % (
615                     ', '.join(sub_selects),
616                     ' '.join(result),
617                 ), tuple(sub_params + params)
618 
619             return ' '.join(result), tuple(params)
620         finally:
621             # Finally do cleanup - get rid of the joins we created above.
622             self.query.reset_refcounts(refcounts_before)

</code><intended_behavior>This method should be adjusted to allow window expressions within `Case` statements inside the `SELECT` clause. It should correctly identify and permit the referencing of window function results when used as part of conditionals within `SELECT`, ensuring they are not misinterpreted as being part of disallowed clauses like `WHERE`.</intended_behavior>, <file>django/db/models/sql/compiler.py</file>
<class>SQLCompiler</class>
<method>None</method>
<code>
21 class SQLCompiler:
22     def __init__(self, query, connection, using):
23         self.query = query
24         self.connection = connection
25         self.using = using
26         self.quote_cache = {'*': '*'}
27         # The select, klass_info, and annotations are needed by QuerySet.iterator()
28         # these are set as a side-effect of executing the query. Note that we calculate
29         # separately a list of extra select columns needed for grammatical correctness
30         # of the query, but these columns are not included in self.select.
31         self.select = None
32         self.annotation_col_map = None
33         self.klass_info = None
34         # Multiline ordering SQL clause may appear from RawSQL.
35         self.ordering_parts = re.compile(r'^(.*)\s(ASC|DESC)(.*)', re.MULTILINE | re.DOTALL)
36         self._meta_ordering = None
37 
38     def setup_query(self):
39         if all(self.query.alias_refcount[a] == 0 for a in self.query.alias_map):
40             self.query.get_initial_alias()
41         self.select, self.klass_info, self.annotation_col_map = self.get_select()
42         self.col_count = len(self.select)
43 
44     def pre_sql_setup(self):
45         """
46         Do any necessary class setup immediately prior to producing SQL. This
47         is for things that can't necessarily be done in __init__ because we
48         might not have all the pieces in place at that time.
49         """
50         self.setup_query()
51         order_by = self.get_order_by()
52         self.where, self.having = self.query.where.split_having()
53         extra_select = self.get_extra_select(order_by, self.select)
54         self.has_extra_select = bool(extra_select)
55         group_by = self.get_group_by(self.select + extra_select, order_by)
56         return extra_select, order_by, group_by
57 
58     def get_group_by(self, select, order_by):
59         """
60         Return a list of 2-tuples of form (sql, params).
61 
62         The logic of what exactly the GROUP BY clause contains is hard
63         to describe in other words than "if it passes the test suite,
64         then it is correct".
65         """
66         # Some examples:
67         #     SomeModel.objects.annotate(Count('somecol'))
68         #     GROUP BY: all fields of the model
69         #
70         #    SomeModel.objects.values('name').annotate(Count('somecol'))
71         #    GROUP BY: name
72         #
73         #    SomeModel.objects.annotate(Count('somecol')).values('name')
74         #    GROUP BY: all cols of the model
75         #
76         #    SomeModel.objects.values('name', 'pk').annotate(Count('somecol')).values('pk')
77         #    GROUP BY: name, pk
78         #
79         #    SomeModel.objects.values('name').annotate(Count('somecol')).values('pk')
80         #    GROUP BY: name, pk
81         #
82         # In fact, the self.query.group_by is the minimal set to GROUP BY. It
83         # can't be ever restricted to a smaller set, but additional columns in
84         # HAVING, ORDER BY, and SELECT clauses are added to it. Unfortunately
85         # the end result is that it is impossible to force the query to have
86         # a chosen GROUP BY clause - you can almost do this by using the form:
87         #     .values(*wanted_cols).annotate(AnAggregate())
88         # but any later annotations, extra selects, values calls that
89         # refer some column outside of the wanted_cols, order_by, or even
90         # filter calls can alter the GROUP BY clause.
91 
92         # The query.group_by is either None (no GROUP BY at all), True
93         # (group by select fields), or a list of expressions to be added
94         # to the group by.
95         if self.query.group_by is None:
96             return []
97         expressions = []
98         if self.query.group_by is not True:
99             # If the group by is set to a list (by .values() call most likely),
100             # then we need to add everything in it to the GROUP BY clause.
101             # Backwards compatibility hack for setting query.group_by. Remove
102             # when  we have public API way of forcing the GROUP BY clause.
103             # Converts string references to expressions.
104             for expr in self.query.group_by:
105                 if not hasattr(expr, 'as_sql'):
106                     expressions.append(self.query.resolve_ref(expr))
107                 else:
108                     expressions.append(expr)
109         # Note that even if the group_by is set, it is only the minimal
110         # set to group by. So, we need to add cols in select, order_by, and
111         # having into the select in any case.
112         for expr, _, _ in select:
113             cols = expr.get_group_by_cols()
114             for col in cols:
115                 expressions.append(col)
116         for expr, (sql, params, is_ref) in order_by:
117             # Skip References to the select clause, as all expressions in the
118             # select clause are already part of the group by.
119             if not expr.contains_aggregate and not is_ref:
120                 expressions.extend(expr.get_source_expressions())
121         having_group_by = self.having.get_group_by_cols() if self.having else ()
122         for expr in having_group_by:
123             expressions.append(expr)
124         result = []
125         seen = set()
126         expressions = self.collapse_group_by(expressions, having_group_by)
127 
128         for expr in expressions:
129             sql, params = self.compile(expr)
130             params_hash = make_hashable(params)
131             if (sql, params_hash) not in seen:
132                 result.append((sql, params))
133                 seen.add((sql, params_hash))
134         return result
135 
136     def collapse_group_by(self, expressions, having):
137         # If the DB can group by primary key, then group by the primary key of
138         # query's main model. Note that for PostgreSQL the GROUP BY clause must
139         # include the primary key of every table, but for MySQL it is enough to
140         # have the main table's primary key.
141         if self.connection.features.allows_group_by_pk:
142             # Determine if the main model's primary key is in the query.
143             pk = None
144             for expr in expressions:
145                 # Is this a reference to query's base table primary key? If the
146                 # expression isn't a Col-like, then skip the expression.
147                 if (getattr(expr, 'target', None) == self.query.model._meta.pk and
148                         getattr(expr, 'alias', None) == self.query.base_table):
149                     pk = expr
150                     break
151             # If the main model's primary key is in the query, group by that
152             # field, HAVING expressions, and expressions associated with tables
153             # that don't have a primary key included in the grouped columns.
154             if pk:
155                 pk_aliases = {
156                     expr.alias for expr in expressions
157                     if hasattr(expr, 'target') and expr.target.primary_key
158                 }
159                 expressions = [pk] + [
160                     expr for expr in expressions
161                     if expr in having or (
162                         getattr(expr, 'alias', None) is not None and expr.alias not in pk_aliases
163                     )
164                 ]
165         elif self.connection.features.allows_group_by_selected_pks:
166             # Filter out all expressions associated with a table's primary key
167             # present in the grouped columns. This is done by identifying all
168             # tables that have their primary key included in the grouped
169             # columns and removing non-primary key columns referring to them.
170             # Unmanaged models are excluded because they could be representing
171             # database views on which the optimization might not be allowed.
172             pks = {
173                 expr for expr in expressions
174                 if (
175                     hasattr(expr, 'target') and
176                     expr.target.primary_key and
177                     self.connection.features.allows_group_by_selected_pks_on_model(expr.target.model)
178                 )
179             }
180             aliases = {expr.alias for expr in pks}
181             expressions = [
182                 expr for expr in expressions if expr in pks or getattr(expr, 'alias', None) not in aliases
183             ]
184         return expressions
185 
186     def get_select(self):
187         """
188         Return three values:
189         - a list of 3-tuples of (expression, (sql, params), alias)
190         - a klass_info structure,
191         - a dictionary of annotations
192 
193         The (sql, params) is what the expression will produce, and alias is the
194         "AS alias" for the column (possibly None).
195 
196         The klass_info structure contains the following information:
197         - The base model of the query.
198         - Which columns for that model are present in the query (by
199           position of the select clause).
200         - related_klass_infos: [f, klass_info] to descent into
201 
202         The annotations is a dictionary of {'attname': column position} values.
203         """
204         select = []
205         klass_info = None
206         annotations = {}
207         select_idx = 0
208         for alias, (sql, params) in self.query.extra_select.items():
209             annotations[alias] = select_idx
210             select.append((RawSQL(sql, params), alias))
211             select_idx += 1
212         assert not (self.query.select and self.query.default_cols)
213         if self.query.default_cols:
214             cols = self.get_default_columns()
215         else:
216             # self.query.select is a special case. These columns never go to
217             # any model.
218             cols = self.query.select
219         if cols:
220             select_list = []
221             for col in cols:
222                 select_list.append(select_idx)
223                 select.append((col, None))
224                 select_idx += 1
225             klass_info = {
226                 'model': self.query.model,
227                 'select_fields': select_list,
228             }
229         for alias, annotation in self.query.annotation_select.items():
230             annotations[alias] = select_idx
231             select.append((annotation, alias))
232             select_idx += 1
233 
234         if self.query.select_related:
235             related_klass_infos = self.get_related_selections(select)
236             klass_info['related_klass_infos'] = related_klass_infos
237 
238             def get_select_from_parent(klass_info):
239                 for ki in klass_info['related_klass_infos']:
240                     if ki['from_parent']:
241                         ki['select_fields'] = (klass_info['select_fields'] +
242                                                ki['select_fields'])
243                     get_select_from_parent(ki)
244             get_select_from_parent(klass_info)
245 
246         ret = []
247         for col, alias in select:
248             try:
249                 sql, params = self.compile(col)
250             except EmptyResultSet:
251                 # Select a predicate that's always False.
252                 sql, params = '0', ()
253             else:
254                 sql, params = col.select_format(self, sql, params)
255             ret.append((col, (sql, params), alias))
256         return ret, klass_info, annotations
257 
258     def get_order_by(self):
259         """
260         Return a list of 2-tuples of form (expr, (sql, params, is_ref)) for the
261         ORDER BY clause.
262 
263         The order_by clause can alter the select clause (for example it
264         can add aliases to clauses that do not yet have one, or it can
265         add totally new select clauses).
266         """
267         if self.query.extra_order_by:
268             ordering = self.query.extra_order_by
269         elif not self.query.default_ordering:
270             ordering = self.query.order_by
271         elif self.query.order_by:
272             ordering = self.query.order_by
273         elif self.query.get_meta().ordering:
274             ordering = self.query.get_meta().ordering
275             self._meta_ordering = ordering
276         else:
277             ordering = []
278         if self.query.standard_ordering:
279             asc, desc = ORDER_DIR['ASC']
280         else:
281             asc, desc = ORDER_DIR['DESC']
282 
283         order_by = []
284         for field in ordering:
285             if hasattr(field, 'resolve_expression'):
286                 if isinstance(field, Value):
287                     # output_field must be resolved for constants.
288                     field = Cast(field, field.output_field)
289                 if not isinstance(field, OrderBy):
290                     field = field.asc()
291                 if not self.query.standard_ordering:
292                     field = field.copy()
293                     field.reverse_ordering()
294                 order_by.append((field, False))
295                 continue
296             if field == '?':  # random
297                 order_by.append((OrderBy(Random()), False))
298                 continue
299 
300             col, order = get_order_dir(field, asc)
301             descending = order == 'DESC'
302 
303             if col in self.query.annotation_select:
304                 # Reference to expression in SELECT clause
305                 order_by.append((
306                     OrderBy(Ref(col, self.query.annotation_select[col]), descending=descending),
307                     True))
308                 continue
309             if col in self.query.annotations:
310                 # References to an expression which is masked out of the SELECT
311                 # clause.
312                 expr = self.query.annotations[col]
313                 if isinstance(expr, Value):
314                     # output_field must be resolved for constants.
315                     expr = Cast(expr, expr.output_field)
316                 order_by.append((OrderBy(expr, descending=descending), False))
317                 continue
318 
319             if '.' in field:
320                 # This came in through an extra(order_by=...) addition. Pass it
321                 # on verbatim.
322                 table, col = col.split('.', 1)
323                 order_by.append((
324                     OrderBy(
325                         RawSQL('%s.%s' % (self.quote_name_unless_alias(table), col), []),
326                         descending=descending
327                     ), False))
328                 continue
329 
330             if not self.query.extra or col not in self.query.extra:
331                 # 'col' is of the form 'field' or 'field1__field2' or
332                 # '-field1__field2__field', etc.
333                 order_by.extend(self.find_ordering_name(
334                     field, self.query.get_meta(), default_order=asc))
335             else:
336                 if col not in self.query.extra_select:
337                     order_by.append((
338                         OrderBy(RawSQL(*self.query.extra[col]), descending=descending),
339                         False))
340                 else:
341                     order_by.append((
342                         OrderBy(Ref(col, RawSQL(*self.query.extra[col])), descending=descending),
343                         True))
344         result = []
345         seen = set()
346 
347         for expr, is_ref in order_by:
348             resolved = expr.resolve_expression(self.query, allow_joins=True, reuse=None)
349             if self.query.combinator:
350                 src = resolved.get_source_expressions()[0]
351                 # Relabel order by columns to raw numbers if this is a combined
352                 # query; necessary since the columns can't be referenced by the
353                 # fully qualified name and the simple column names may collide.
354                 for idx, (sel_expr, _, col_alias) in enumerate(self.select):
355                     if is_ref and col_alias == src.refs:
356                         src = src.source
357                     elif col_alias:
358                         continue
359                     if src == sel_expr:
360                         resolved.set_source_expressions([RawSQL('%d' % (idx + 1), ())])
361                         break
362                 else:
363                     if col_alias:
364                         raise DatabaseError('ORDER BY term does not match any column in the result set.')
365                     # Add column used in ORDER BY clause without an alias to
366                     # the selected columns.
367                     self.query.add_select_col(src)
368                     resolved.set_source_expressions([RawSQL('%d' % len(self.query.select), ())])
369             sql, params = self.compile(resolved)
370             # Don't add the same column twice, but the order direction is
371             # not taken into account so we strip it. When this entire method
372             # is refactored into expressions, then we can check each part as we
373             # generate it.
374             without_ordering = self.ordering_parts.search(sql).group(1)
375             params_hash = make_hashable(params)
376             if (without_ordering, params_hash) in seen:
377                 continue
378             seen.add((without_ordering, params_hash))
379             result.append((resolved, (sql, params, is_ref)))
380         return result
381 
382     def get_extra_select(self, order_by, select):
383         extra_select = []
384         if self.query.distinct and not self.query.distinct_fields:
385             select_sql = [t[1] for t in select]
386             for expr, (sql, params, is_ref) in order_by:
387                 without_ordering = self.ordering_parts.search(sql).group(1)
388                 if not is_ref and (without_ordering, params) not in select_sql:
389                     extra_select.append((expr, (without_ordering, params), None))
390         return extra_select
391 
392     def quote_name_unless_alias(self, name):
393         """
394         A wrapper around connection.ops.quote_name that doesn't quote aliases
395         for table names. This avoids problems with some SQL dialects that treat
396         quoted strings specially (e.g. PostgreSQL).
397         """
398         if name in self.quote_cache:
399             return self.quote_cache[name]
400         if ((name in self.query.alias_map and name not in self.query.table_map) or
401                 name in self.query.extra_select or (
402                     name in self.query.external_aliases and name not in self.query.table_map)):
403             self.quote_cache[name] = name
404             return name
405         r = self.connection.ops.quote_name(name)
406         self.quote_cache[name] = r
407         return r
408 
409     def compile(self, node):
410         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
411         if vendor_impl:
412             sql, params = vendor_impl(self, self.connection)
413         else:
414             sql, params = node.as_sql(self, self.connection)
415         return sql, params
416 
417     def get_combinator_sql(self, combinator, all):
418         features = self.connection.features
419         compilers = [
420             query.get_compiler(self.using, self.connection)
421             for query in self.query.combined_queries if not query.is_empty()
422         ]
423         if not features.supports_slicing_ordering_in_compound:
424             for query, compiler in zip(self.query.combined_queries, compilers):
425                 if query.low_mark or query.high_mark:
426                     raise DatabaseError('LIMIT/OFFSET not allowed in subqueries of compound statements.')
427                 if compiler.get_order_by():
428                     raise DatabaseError('ORDER BY not allowed in subqueries of compound statements.')
429         parts = ()
430         for compiler in compilers:
431             try:
432                 # If the columns list is limited, then all combined queries
433                 # must have the same columns list. Set the selects defined on
434                 # the query on all combined queries, if not already set.
435                 if not compiler.query.values_select and self.query.values_select:
436                     compiler.query = compiler.query.clone()
437                     compiler.query.set_values((
438                         *self.query.extra_select,
439                         *self.query.values_select,
440                         *self.query.annotation_select,
441                     ))
442                 part_sql, part_args = compiler.as_sql()
443                 if compiler.query.combinator:
444                     # Wrap in a subquery if wrapping in parentheses isn't
445                     # supported.
446                     if not features.supports_parentheses_in_compound:
447                         part_sql = 'SELECT * FROM ({})'.format(part_sql)
448                     # Add parentheses when combining with compound query if not
449                     # already added for all compound queries.
450                     elif not features.supports_slicing_ordering_in_compound:
451                         part_sql = '({})'.format(part_sql)
452                 parts += ((part_sql, part_args),)
453             except EmptyResultSet:
454                 # Omit the empty queryset with UNION and with DIFFERENCE if the
455                 # first queryset is nonempty.
456                 if combinator == 'union' or (combinator == 'difference' and parts):
457                     continue
458                 raise
459         if not parts:
460             raise EmptyResultSet
461         combinator_sql = self.connection.ops.set_operators[combinator]
462         if all and combinator == 'union':
463             combinator_sql += ' ALL'
464         braces = '({})' if features.supports_slicing_ordering_in_compound else '{}'
465         sql_parts, args_parts = zip(*((braces.format(sql), args) for sql, args in parts))
466         result = [' {} '.format(combinator_sql).join(sql_parts)]
467         params = []
468         for part in args_parts:
469             params.extend(part)
470         return result, params
471 
472     def as_sql(self, with_limits=True, with_col_aliases=False):
473         """
474         Create the SQL for this query. Return the SQL string and list of
475         parameters.
476 
477         If 'with_limits' is False, any limit/offset information is not included
478         in the query.
479         """
480         refcounts_before = self.query.alias_refcount.copy()
481         try:
482             extra_select, order_by, group_by = self.pre_sql_setup()
483             for_update_part = None
484             # Is a LIMIT/OFFSET clause needed?
485             with_limit_offset = with_limits and (self.query.high_mark is not None or self.query.low_mark)
486             combinator = self.query.combinator
487             features = self.connection.features
488             if combinator:
489                 if not getattr(features, 'supports_select_{}'.format(combinator)):
490                     raise NotSupportedError('{} is not supported on this database backend.'.format(combinator))
491                 result, params = self.get_combinator_sql(combinator, self.query.combinator_all)
492             else:
493                 distinct_fields, distinct_params = self.get_distinct()
494                 # This must come after 'select', 'ordering', and 'distinct'
495                 # (see docstring of get_from_clause() for details).
496                 from_, f_params = self.get_from_clause()
497                 where, w_params = self.compile(self.where) if self.where is not None else ("", [])
498                 having, h_params = self.compile(self.having) if self.having is not None else ("", [])
499                 result = ['SELECT']
500                 params = []
501 
502                 if self.query.distinct:
503                     distinct_result, distinct_params = self.connection.ops.distinct_sql(
504                         distinct_fields,
505                         distinct_params,
506                     )
507                     result += distinct_result
508                     params += distinct_params
509 
510                 out_cols = []
511                 col_idx = 1
512                 for _, (s_sql, s_params), alias in self.select + extra_select:
513                     if alias:
514                         s_sql = '%s AS %s' % (s_sql, self.connection.ops.quote_name(alias))
515                     elif with_col_aliases:
516                         s_sql = '%s AS %s' % (s_sql, 'Col%d' % col_idx)
517                         col_idx += 1
518                     params.extend(s_params)
519                     out_cols.append(s_sql)
520 
521                 result += [', '.join(out_cols), 'FROM', *from_]
522                 params.extend(f_params)
523 
524                 if self.query.select_for_update and self.connection.features.has_select_for_update:
525                     if self.connection.get_autocommit():
526                         raise TransactionManagementError('select_for_update cannot be used outside of a transaction.')
527 
528                     if with_limit_offset and not self.connection.features.supports_select_for_update_with_limit:
529                         raise NotSupportedError(
530                             'LIMIT/OFFSET is not supported with '
531                             'select_for_update on this database backend.'
532                         )
533                     nowait = self.query.select_for_update_nowait
534                     skip_locked = self.query.select_for_update_skip_locked
535                     of = self.query.select_for_update_of
536                     # If it's a NOWAIT/SKIP LOCKED/OF query but the backend
537                     # doesn't support it, raise NotSupportedError to prevent a
538                     # possible deadlock.
539                     if nowait and not self.connection.features.has_select_for_update_nowait:
540                         raise NotSupportedError('NOWAIT is not supported on this database backend.')
541                     elif skip_locked and not self.connection.features.has_select_for_update_skip_locked:
542                         raise NotSupportedError('SKIP LOCKED is not supported on this database backend.')
543                     elif of and not self.connection.features.has_select_for_update_of:
544                         raise NotSupportedError('FOR UPDATE OF is not supported on this database backend.')
545                     for_update_part = self.connection.ops.for_update_sql(
546                         nowait=nowait,
547                         skip_locked=skip_locked,
548                         of=self.get_select_for_update_of_arguments(),
549                     )
550 
551                 if for_update_part and self.connection.features.for_update_after_from:
552                     result.append(for_update_part)
553 
554                 if where:
555                     result.append('WHERE %s' % where)
556                     params.extend(w_params)
557 
558                 grouping = []
559                 for g_sql, g_params in group_by:
560                     grouping.append(g_sql)
561                     params.extend(g_params)
562                 if grouping:
563                     if distinct_fields:
564                         raise NotImplementedError('annotate() + distinct(fields) is not implemented.')
565                     order_by = order_by or self.connection.ops.force_no_ordering()
566                     result.append('GROUP BY %s' % ', '.join(grouping))
567                     if self._meta_ordering:
568                         order_by = None
569                 if having:
570                     result.append('HAVING %s' % having)
571                     params.extend(h_params)
572 
573             if self.query.explain_query:
574                 result.insert(0, self.connection.ops.explain_query_prefix(
575                     self.query.explain_format,
576                     **self.query.explain_options
577                 ))
578 
579             if order_by:
580                 ordering = []
581                 for _, (o_sql, o_params, _) in order_by:
582                     ordering.append(o_sql)
583                     params.extend(o_params)
584                 result.append('ORDER BY %s' % ', '.join(ordering))
585 
586             if with_limit_offset:
587                 result.append(self.connection.ops.limit_offset_sql(self.query.low_mark, self.query.high_mark))
588 
589             if for_update_part and not self.connection.features.for_update_after_from:
590                 result.append(for_update_part)
591 
592             if self.query.subquery and extra_select:
593                 # If the query is used as a subquery, the extra selects would
594                 # result in more columns than the left-hand side expression is
595                 # expecting. This can happen when a subquery uses a combination
596                 # of order_by() and distinct(), forcing the ordering expressions
597                 # to be selected as well. Wrap the query in another subquery
598                 # to exclude extraneous selects.
599                 sub_selects = []
600                 sub_params = []
601                 for index, (select, _, alias) in enumerate(self.select, start=1):
602                     if not alias and with_col_aliases:
603                         alias = 'col%d' % index
604                     if alias:
605                         sub_selects.append("%s.%s" % (
606                             self.connection.ops.quote_name('subquery'),
607                             self.connection.ops.quote_name(alias),
608                         ))
609                     else:
610                         select_clone = select.relabeled_clone({select.alias: 'subquery'})
611                         subselect, subparams = select_clone.as_sql(self, self.connection)
612                         sub_selects.append(subselect)
613                         sub_params.extend(subparams)
614                 return 'SELECT %s FROM (%s) subquery' % (
615                     ', '.join(sub_selects),
616                     ' '.join(result),
617                 ), tuple(sub_params + params)
618 
619             return ' '.join(result), tuple(params)
620         finally:
621             # Finally do cleanup - get rid of the joins we created above.
622             self.query.reset_refcounts(refcounts_before)
623 
624     def get_default_columns(self, start_alias=None, opts=None, from_parent=None):
625         """
626         Compute the default columns for selecting every field in the base
627         model. Will sometimes be called to pull in related models (e.g. via
628         select_related), in which case "opts" and "start_alias" will be given
629         to provide a starting point for the traversal.
630 
631         Return a list of strings, quoted appropriately for use in SQL
632         directly, as well as a set of aliases used in the select statement (if
633         'as_pairs' is True, return a list of (alias, col_name) pairs instead
634         of strings as the first component and None as the second component).
635         """
636         result = []
637         if opts is None:
638             opts = self.query.get_meta()
639         only_load = self.deferred_to_columns()
640         start_alias = start_alias or self.query.get_initial_alias()
641         # The 'seen_models' is used to optimize checking the needed parent
642         # alias for a given field. This also includes None -> start_alias to
643         # be used by local fields.
644         seen_models = {None: start_alias}
645 
646         for field in opts.concrete_fields:
647             model = field.model._meta.concrete_model
648             # A proxy model will have a different model and concrete_model. We
649             # will assign None if the field belongs to this model.
650             if model == opts.model:
651                 model = None
652             if from_parent and model is not None and issubclass(
653                     from_parent._meta.concrete_model, model._meta.concrete_model):
654                 # Avoid loading data for already loaded parents.
655                 # We end up here in the case select_related() resolution
656                 # proceeds from parent model to child model. In that case the
657                 # parent model data is already present in the SELECT clause,
658                 # and we want to avoid reloading the same data again.
659                 continue
660             if field.model in only_load and field.attname not in only_load[field.model]:
661                 continue
662             alias = self.query.join_parent_model(opts, model, start_alias,
663                                                  seen_models)
664             column = field.get_col(alias)
665             result.append(column)
666         return result
667 
668     def get_distinct(self):
669         """
670         Return a quoted list of fields to use in DISTINCT ON part of the query.
671 
672         This method can alter the tables in the query, and thus it must be
673         called before get_from_clause().
674         """
675         result = []
676         params = []
677         opts = self.query.get_meta()
678 
679         for name in self.query.distinct_fields:
680             parts = name.split(LOOKUP_SEP)
681             _, targets, alias, joins, path, _, transform_function = self._setup_joins(parts, opts, None)
682             targets, alias, _ = self.query.trim_joins(targets, joins, path)
683             for target in targets:
684                 if name in self.query.annotation_select:
685                     result.append(name)
686                 else:
687                     r, p = self.compile(transform_function(target, alias))
688                     result.append(r)
689                     params.append(p)
690         return result, params
691 
692     def find_ordering_name(self, name, opts, alias=None, default_order='ASC',
693                            already_seen=None):
694         """
695         Return the table alias (the name might be ambiguous, the alias will
696         not be) and column name for ordering by the given 'name' parameter.
697         The 'name' is of the form 'field1__field2__...__fieldN'.
698         """
699         name, order = get_order_dir(name, default_order)
700         descending = order == 'DESC'
701         pieces = name.split(LOOKUP_SEP)
702         field, targets, alias, joins, path, opts, transform_function = self._setup_joins(pieces, opts, alias)
703 
704         # If we get to this point and the field is a relation to another model,
705         # append the default ordering for that model unless the attribute name
706         # of the field is specified.
707         if field.is_relation and opts.ordering and getattr(field, 'attname', None) != name:
708             # Firstly, avoid infinite loops.
709             already_seen = already_seen or set()
710             join_tuple = tuple(getattr(self.query.alias_map[j], 'join_cols', None) for j in joins)
711             if join_tuple in already_seen:
712                 raise FieldError('Infinite loop caused by ordering.')
713             already_seen.add(join_tuple)
714 
715             results = []
716             for item in opts.ordering:
717                 if hasattr(item, 'resolve_expression') and not isinstance(item, OrderBy):
718                     item = item.desc() if descending else item.asc()
719                 if isinstance(item, OrderBy):
720                     results.append((item, False))
721                     continue
722                 results.extend(self.find_ordering_name(item, opts, alias,
723                                                        order, already_seen))
724             return results
725         targets, alias, _ = self.query.trim_joins(targets, joins, path)
726         return [(OrderBy(transform_function(t, alias), descending=descending), False) for t in targets]
727 
728     def _setup_joins(self, pieces, opts, alias):
729         """
730         Helper method for get_order_by() and get_distinct().
731 
732         get_ordering() and get_distinct() must produce same target columns on
733         same input, as the prefixes of get_ordering() and get_distinct() must
734         match. Executing SQL where this is not true is an error.
735         """
736         alias = alias or self.query.get_initial_alias()
737         field, targets, opts, joins, path, transform_function = self.query.setup_joins(pieces, opts, alias)
738         alias = joins[-1]
739         return field, targets, alias, joins, path, opts, transform_function
740 
741     def get_from_clause(self):
742         """
743         Return a list of strings that are joined together to go after the
744         "FROM" part of the query, as well as a list any extra parameters that
745         need to be included. Subclasses, can override this to create a
746         from-clause via a "select".
747 
748         This should only be called after any SQL construction methods that
749         might change the tables that are needed. This means the select columns,
750         ordering, and distinct must be done first.
751         """
752         result = []
753         params = []
754         for alias in tuple(self.query.alias_map):
755             if not self.query.alias_refcount[alias]:
756                 continue
757             try:
758                 from_clause = self.query.alias_map[alias]
759             except KeyError:
760                 # Extra tables can end up in self.tables, but not in the
761                 # alias_map if they aren't in a join. That's OK. We skip them.
762                 continue
763             clause_sql, clause_params = self.compile(from_clause)
764             result.append(clause_sql)
765             params.extend(clause_params)
766         for t in self.query.extra_tables:
767             alias, _ = self.query.table_alias(t)
768             # Only add the alias if it's not already present (the table_alias()
769             # call increments the refcount, so an alias refcount of one means
770             # this is the only reference).
771             if alias not in self.query.alias_map or self.query.alias_refcount[alias] == 1:
772                 result.append(', %s' % self.quote_name_unless_alias(alias))
773         return result, params
774 
775     def get_related_selections(self, select, opts=None, root_alias=None, cur_depth=1,
776                                requested=None, restricted=None):
777         """
778         Fill in the information needed for a select_related query. The current
779         depth is measured as the number of connections away from the root model
780         (for example, cur_depth=1 means we are looking at models with direct
781         connections to the root model).
782         """
783         def _get_field_choices():
784             direct_choices = (f.name for f in opts.fields if f.is_relation)
785             reverse_choices = (
786                 f.field.related_query_name()
787                 for f in opts.related_objects if f.field.unique
788             )
789             return chain(direct_choices, reverse_choices, self.query._filtered_relations)
790 
791         related_klass_infos = []
792         if not restricted and cur_depth > self.query.max_depth:
793             # We've recursed far enough; bail out.
794             return related_klass_infos
795 
796         if not opts:
797             opts = self.query.get_meta()
798             root_alias = self.query.get_initial_alias()
799         only_load = self.query.get_loaded_field_names()
800 
801         # Setup for the case when only particular related fields should be
802         # included in the related selection.
803         fields_found = set()
804         if requested is None:
805             restricted = isinstance(self.query.select_related, dict)
806             if restricted:
807                 requested = self.query.select_related
808 
809         def get_related_klass_infos(klass_info, related_klass_infos):
810             klass_info['related_klass_infos'] = related_klass_infos
811 
812         for f in opts.fields:
813             field_model = f.model._meta.concrete_model
814             fields_found.add(f.name)
815 
816             if restricted:
817                 next = requested.get(f.name, {})
818                 if not f.is_relation:
819                     # If a non-related field is used like a relation,
820                     # or if a single non-relational field is given.
821                     if next or f.name in requested:
822                         raise FieldError(
823                             "Non-relational field given in select_related: '%s'. "
824                             "Choices are: %s" % (
825                                 f.name,
826                                 ", ".join(_get_field_choices()) or '(none)',
827                             )
828                         )
829             else:
830                 next = False
831 
832             if not select_related_descend(f, restricted, requested,
833                                           only_load.get(field_model)):
834                 continue
835             klass_info = {
836                 'model': f.remote_field.model,
837                 'field': f,
838                 'reverse': False,
839                 'local_setter': f.set_cached_value,
840                 'remote_setter': f.remote_field.set_cached_value if f.unique else lambda x, y: None,
841                 'from_parent': False,
842             }
843             related_klass_infos.append(klass_info)
844             select_fields = []
845             _, _, _, joins, _, _ = self.query.setup_joins(
846                 [f.name], opts, root_alias)
847             alias = joins[-1]
848             columns = self.get_default_columns(start_alias=alias, opts=f.remote_field.model._meta)
849             for col in columns:
850                 select_fields.append(len(select))
851                 select.append((col, None))
852             klass_info['select_fields'] = select_fields
853             next_klass_infos = self.get_related_selections(
854                 select, f.remote_field.model._meta, alias, cur_depth + 1, next, restricted)
855             get_related_klass_infos(klass_info, next_klass_infos)
856 
857         if restricted:
858             related_fields = [
859                 (o.field, o.related_model)
860                 for o in opts.related_objects
861                 if o.field.unique and not o.many_to_many
862             ]
863             for f, model in related_fields:
864                 if not select_related_descend(f, restricted, requested,
865                                               only_load.get(model), reverse=True):
866                     continue
867 
868                 related_field_name = f.related_query_name()
869                 fields_found.add(related_field_name)
870 
871                 join_info = self.query.setup_joins([related_field_name], opts, root_alias)
872                 alias = join_info.joins[-1]
873                 from_parent = issubclass(model, opts.model) and model is not opts.model
874                 klass_info = {
875                     'model': model,
876                     'field': f,
877                     'reverse': True,
878                     'local_setter': f.remote_field.set_cached_value,
879                     'remote_setter': f.set_cached_value,
880                     'from_parent': from_parent,
881                 }
882                 related_klass_infos.append(klass_info)
883                 select_fields = []
884                 columns = self.get_default_columns(
885                     start_alias=alias, opts=model._meta, from_parent=opts.model)
886                 for col in columns:
887                     select_fields.append(len(select))
888                     select.append((col, None))
889                 klass_info['select_fields'] = select_fields
890                 next = requested.get(f.related_query_name(), {})
891                 next_klass_infos = self.get_related_selections(
892                     select, model._meta, alias, cur_depth + 1,
893                     next, restricted)
894                 get_related_klass_infos(klass_info, next_klass_infos)
895 
896             def local_setter(obj, from_obj):
897                 # Set a reverse fk object when relation is non-empty.
898                 if from_obj:
899                     f.remote_field.set_cached_value(from_obj, obj)
900 
901             def remote_setter(name, obj, from_obj):
902                 setattr(from_obj, name, obj)
903 
904             for name in list(requested):
905                 # Filtered relations work only on the topmost level.
906                 if cur_depth > 1:
907                     break
908                 if name in self.query._filtered_relations:
909                     fields_found.add(name)
910                     f, _, join_opts, joins, _, _ = self.query.setup_joins([name], opts, root_alias)
911                     model = join_opts.model
912                     alias = joins[-1]
913                     from_parent = issubclass(model, opts.model) and model is not opts.model
914                     klass_info = {
915                         'model': model,
916                         'field': f,
917                         'reverse': True,
918                         'local_setter': local_setter,
919                         'remote_setter': partial(remote_setter, name),
920                         'from_parent': from_parent,
921                     }
922                     related_klass_infos.append(klass_info)
923                     select_fields = []
924                     columns = self.get_default_columns(
925                         start_alias=alias, opts=model._meta,
926                         from_parent=opts.model,
927                     )
928                     for col in columns:
929                         select_fields.append(len(select))
930                         select.append((col, None))
931                     klass_info['select_fields'] = select_fields
932                     next_requested = requested.get(name, {})
933                     next_klass_infos = self.get_related_selections(
934                         select, opts=model._meta, root_alias=alias,
935                         cur_depth=cur_depth + 1, requested=next_requested,
936                         restricted=restricted,
937                     )
938                     get_related_klass_infos(klass_info, next_klass_infos)
939             fields_not_found = set(requested).difference(fields_found)
940             if fields_not_found:
941                 invalid_fields = ("'%s'" % s for s in fields_not_found)
942                 raise FieldError(
943                     'Invalid field name(s) given in select_related: %s. '
944                     'Choices are: %s' % (
945                         ', '.join(invalid_fields),
946                         ', '.join(_get_field_choices()) or '(none)',
947                     )
948                 )
949         return related_klass_infos
950 
951     def get_select_for_update_of_arguments(self):
952         """
953         Return a quoted list of arguments for the SELECT FOR UPDATE OF part of
954         the query.
955         """
956         def _get_parent_klass_info(klass_info):
957             return (
958                 {
959                     'model': parent_model,
960                     'field': parent_link,
961                     'reverse': False,
962                     'select_fields': [
963                         select_index
964                         for select_index in klass_info['select_fields']
965                         if self.select[select_index][0].target.model == parent_model
966                     ],
967                 }
968                 for parent_model, parent_link in klass_info['model']._meta.parents.items()
969             )
970 
971         def _get_field_choices():
972             """Yield all allowed field paths in breadth-first search order."""
973             queue = collections.deque([(None, self.klass_info)])
974             while queue:
975                 parent_path, klass_info = queue.popleft()
976                 if parent_path is None:
977                     path = []
978                     yield 'self'
979                 else:
980                     field = klass_info['field']
981                     if klass_info['reverse']:
982                         field = field.remote_field
983                     path = parent_path + [field.name]
984                     yield LOOKUP_SEP.join(path)
985                 queue.extend(
986                     (path, klass_info)
987                     for klass_info in _get_parent_klass_info(klass_info)
988                 )
989                 queue.extend(
990                     (path, klass_info)
991                     for klass_info in klass_info.get('related_klass_infos', [])
992                 )
993         result = []
994         invalid_names = []
995         for name in self.query.select_for_update_of:
996             klass_info = self.klass_info
997             if name == 'self':
998                 # Find the first selected column from a base model. If it
999                 # doesn't exist, don't lock a base model.
1000                 for select_index in klass_info['select_fields']:
1001                     if self.select[select_index][0].target.model == klass_info['model']:
1002                         col = self.select[select_index][0]
1003                         break
1004                 else:
1005                     col = None
1006             else:
1007                 for part in name.split(LOOKUP_SEP):
1008                     klass_infos = (
1009                         *klass_info.get('related_klass_infos', []),
1010                         *_get_parent_klass_info(klass_info),
1011                     )
1012                     for related_klass_info in klass_infos:
1013                         field = related_klass_info['field']
1014                         if related_klass_info['reverse']:
1015                             field = field.remote_field
1016                         if field.name == part:
1017                             klass_info = related_klass_info
1018                             break
1019                     else:
1020                         klass_info = None
1021                         break
1022                 if klass_info is None:
1023                     invalid_names.append(name)
1024                     continue
1025                 select_index = klass_info['select_fields'][0]
1026                 col = self.select[select_index][0]
1027             if col is not None:
1028                 if self.connection.features.select_for_update_of_column:
1029                     result.append(self.compile(col)[0])
1030                 else:
1031                     result.append(self.quote_name_unless_alias(col.alias))
1032         if invalid_names:
1033             raise FieldError(
1034                 'Invalid field name(s) given in select_for_update(of=(...)): %s. '
1035                 'Only relational fields followed in the query are allowed. '
1036                 'Choices are: %s.' % (
1037                     ', '.join(invalid_names),
1038                     ', '.join(_get_field_choices()),
1039                 )
1040             )
1041         return result
1042 
1043     def deferred_to_columns(self):
1044         """
1045         Convert the self.deferred_loading data structure to mapping of table
1046         names to sets of column names which are to be loaded. Return the
1047         dictionary.
1048         """
1049         columns = {}
1050         self.query.deferred_to_data(columns, self.query.get_loaded_field_names_cb)
1051         return columns
1052 
1053     def get_converters(self, expressions):
1054         converters = {}
1055         for i, expression in enumerate(expressions):
1056             if expression:
1057                 backend_converters = self.connection.ops.get_db_converters(expression)
1058                 field_converters = expression.get_db_converters(self.connection)
1059                 if backend_converters or field_converters:
1060                     converters[i] = (backend_converters + field_converters, expression)
1061         return converters
1062 
1063     def apply_converters(self, rows, converters):
1064         connection = self.connection
1065         converters = list(converters.items())
1066         for row in map(list, rows):
1067             for pos, (convs, expression) in converters:
1068                 value = row[pos]
1069                 for converter in convs:
1070                     value = converter(value, expression, connection)
1071                 row[pos] = value
1072             yield row
1073 
1074     def results_iter(self, results=None, tuple_expected=False, chunked_fetch=False,
1075                      chunk_size=GET_ITERATOR_CHUNK_SIZE):
1076         """Return an iterator over the results from executing this query."""
1077         if results is None:
1078             results = self.execute_sql(MULTI, chunked_fetch=chunked_fetch, chunk_size=chunk_size)
1079         fields = [s[0] for s in self.select[0:self.col_count]]
1080         converters = self.get_converters(fields)
1081         rows = chain.from_iterable(results)
1082         if converters:
1083             rows = self.apply_converters(rows, converters)
1084             if tuple_expected:
1085                 rows = map(tuple, rows)
1086         return rows
1087 
1088     def has_results(self):
1089         """
1090         Backends (e.g. NoSQL) can override this in order to use optimized
1091         versions of "query has any results."
1092         """
1093         # This is always executed on a query clone, so we can modify self.query
1094         self.query.add_extra({'a': 1}, None, None, None, None, None)
1095         self.query.set_extra_mask(['a'])
1096         return bool(self.execute_sql(SINGLE))
1097 
1098     def execute_sql(self, result_type=MULTI, chunked_fetch=False, chunk_size=GET_ITERATOR_CHUNK_SIZE):
1099         """
1100         Run the query against the database and return the result(s). The
1101         return value is a single data item if result_type is SINGLE, or an
1102         iterator over the results if the result_type is MULTI.
1103 
1104         result_type is either MULTI (use fetchmany() to retrieve all rows),
1105         SINGLE (only retrieve a single row), or None. In this last case, the
1106         cursor is returned if any query is executed, since it's used by
1107         subclasses such as InsertQuery). It's possible, however, that no query
1108         is needed, as the filters describe an empty set. In that case, None is
1109         returned, to avoid any unnecessary database interaction.
1110         """
1111         result_type = result_type or NO_RESULTS
1112         try:
1113             sql, params = self.as_sql()
1114             if not sql:
1115                 raise EmptyResultSet
1116         except EmptyResultSet:
1117             if result_type == MULTI:
1118                 return iter([])
1119             else:
1120                 return
1121         if chunked_fetch:
1122             cursor = self.connection.chunked_cursor()
1123         else:
1124             cursor = self.connection.cursor()
1125         try:
1126             cursor.execute(sql, params)
1127         except Exception:
1128             # Might fail for server-side cursors (e.g. connection closed)
1129             cursor.close()
1130             raise
1131 
1132         if result_type == CURSOR:
1133             # Give the caller the cursor to process and close.
1134             return cursor
1135         if result_type == SINGLE:
1136             try:
1137                 val = cursor.fetchone()
1138                 if val:
1139                     return val[0:self.col_count]
1140                 return val
1141             finally:
1142                 # done with the cursor
1143                 cursor.close()
1144         if result_type == NO_RESULTS:
1145             cursor.close()
1146             return
1147 
1148         result = cursor_iter(
1149             cursor, self.connection.features.empty_fetchmany_value,
1150             self.col_count if self.has_extra_select else None,
1151             chunk_size,
1152         )
1153         if not chunked_fetch or not self.connection.features.can_use_chunked_reads:
1154             try:
1155                 # If we are using non-chunked reads, we return the same data
1156                 # structure as normally, but ensure it is all read into memory
1157                 # before going any further. Use chunked_fetch if requested,
1158                 # unless the database doesn't support it.
1159                 return list(result)
1160             finally:
1161                 # done with the cursor
1162                 cursor.close()
1163         return result
1164 
1165     def as_subquery_condition(self, alias, columns, compiler):
1166         qn = compiler.quote_name_unless_alias
1167         qn2 = self.connection.ops.quote_name
1168 
1169         for index, select_col in enumerate(self.query.select):
1170             lhs_sql, lhs_params = self.compile(select_col)
1171             rhs = '%s.%s' % (qn(alias), qn2(columns[index]))
1172             self.query.where.add(
1173                 RawSQL('%s = %s' % (lhs_sql, rhs), lhs_params), 'AND')
1174 
1175         sql, params = self.as_sql()
1176         return 'EXISTS (%s)' % sql, params
1177 
1178     def explain_query(self):
1179         result = list(self.execute_sql())
1180         # Some backends return 1 item tuples with strings, and others return
1181         # tuples with integers and strings. Flatten them out into strings.
1182         for row in result[0]:
1183             if not isinstance(row, str):
1184                 yield ' '.join(str(c) for c in row)
1185             else:
1186                 yield row

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>, <file>django/db/models/expressions.py</file>
<class>None</class>
<method>None</method>
<code>
1 import copy
2 import datetime
3 import inspect
4 from decimal import Decimal
5 
6 from django.core.exceptions import EmptyResultSet, FieldError
7 from django.db import connection
8 from django.db.models import fields
9 from django.db.models.query_utils import Q
10 from django.db.utils import NotSupportedError
11 from django.utils.deconstruct import deconstructible
12 from django.utils.functional import cached_property
13 from django.utils.hashable import make_hashable
14 
15 
16 class SQLiteNumericMixin:
17     """
18     Some expressions with output_field=DecimalField() must be cast to
19     numeric to be properly filtered.
20     """
21     def as_sqlite(self, compiler, connection, **extra_context):
22         sql, params = self.as_sql(compiler, connection, **extra_context)
23         try:
24             if self.output_field.get_internal_type() == 'DecimalField':
25                 sql = 'CAST(%s AS NUMERIC)' % sql
26         except FieldError:
27             pass
28         return sql, params
29 
30 
31 class Combinable:
32     """
33     Provide the ability to combine one or two objects with
34     some connector. For example F('foo') + F('bar').
35     """
36 
37     # Arithmetic connectors
38     ADD = '+'
39     SUB = '-'
40     MUL = '*'
41     DIV = '/'
42     POW = '^'
43     # The following is a quoted % operator - it is quoted because it can be
44     # used in strings that also have parameter substitution.
45     MOD = '%%'
46 
47     # Bitwise operators - note that these are generated by .bitand()
48     # and .bitor(), the '&' and '|' are reserved for boolean operator
49     # usage.
50     BITAND = '&'
51     BITOR = '|'
52     BITLEFTSHIFT = '<<'
53     BITRIGHTSHIFT = '>>'
54 
55     def _combine(self, other, connector, reversed):
56         if not hasattr(other, 'resolve_expression'):
57             # everything must be resolvable to an expression
58             if isinstance(other, datetime.timedelta):
59                 other = DurationValue(other, output_field=fields.DurationField())
60             else:
61                 other = Value(other)
62 
63         if reversed:
64             return CombinedExpression(other, connector, self)
65         return CombinedExpression(self, connector, other)
66 
67     #############
68     # OPERATORS #
69     #############
70 
71     def __neg__(self):
72         return self._combine(-1, self.MUL, False)
73 
74     def __add__(self, other):
75         return self._combine(other, self.ADD, False)
76 
77     def __sub__(self, other):
78         return self._combine(other, self.SUB, False)
79 
80     def __mul__(self, other):
81         return self._combine(other, self.MUL, False)
82 
83     def __truediv__(self, other):
84         return self._combine(other, self.DIV, False)
85 
86     def __mod__(self, other):
87         return self._combine(other, self.MOD, False)
88 
89     def __pow__(self, other):
90         return self._combine(other, self.POW, False)
91 
92     def __and__(self, other):
93         if getattr(self, 'conditional', False) and getattr(other, 'conditional', False):
94             return Q(self) & Q(other)
95         raise NotImplementedError(
96             "Use .bitand() and .bitor() for bitwise logical operations."
97         )
98 
99     def bitand(self, other):
100         return self._combine(other, self.BITAND, False)
101 
102     def bitleftshift(self, other):
103         return self._combine(other, self.BITLEFTSHIFT, False)
104 
105     def bitrightshift(self, other):
106         return self._combine(other, self.BITRIGHTSHIFT, False)
107 
108     def __or__(self, other):
109         if getattr(self, 'conditional', False) and getattr(other, 'conditional', False):
110             return Q(self) | Q(other)
111         raise NotImplementedError(
112             "Use .bitand() and .bitor() for bitwise logical operations."
113         )
114 
115     def bitor(self, other):
116         return self._combine(other, self.BITOR, False)
117 
118     def __radd__(self, other):
119         return self._combine(other, self.ADD, True)
120 
121     def __rsub__(self, other):
122         return self._combine(other, self.SUB, True)
123 
124     def __rmul__(self, other):
125         return self._combine(other, self.MUL, True)
126 
127     def __rtruediv__(self, other):
128         return self._combine(other, self.DIV, True)
129 
130     def __rmod__(self, other):
131         return self._combine(other, self.MOD, True)
132 
133     def __rpow__(self, other):
134         return self._combine(other, self.POW, True)
135 
136     def __rand__(self, other):
137         raise NotImplementedError(
138             "Use .bitand() and .bitor() for bitwise logical operations."
139         )
140 
141     def __ror__(self, other):
142         raise NotImplementedError(
143             "Use .bitand() and .bitor() for bitwise logical operations."
144         )
145 
146 
147 @deconstructible
148 class BaseExpression:
149     """Base class for all query expressions."""
150 
151     # aggregate specific fields
152     is_summary = False
153     _output_field_resolved_to_none = False
154     # Can the expression be used in a WHERE clause?
155     filterable = True
156     # Can the expression can be used as a source expression in Window?
157     window_compatible = False
158 
159     def __init__(self, output_field=None):
160         if output_field is not None:
161             self.output_field = output_field
162 
163     def __getstate__(self):
164         state = self.__dict__.copy()
165         state.pop('convert_value', None)
166         return state
167 
168     def get_db_converters(self, connection):
169         return (
170             []
171             if self.convert_value is self._convert_value_noop else
172             [self.convert_value]
173         ) + self.output_field.get_db_converters(connection)
174 
175     def get_source_expressions(self):
176         return []
177 
178     def set_source_expressions(self, exprs):
179         assert not exprs
180 
181     def _parse_expressions(self, *expressions):
182         return [
183             arg if hasattr(arg, 'resolve_expression') else (
184                 F(arg) if isinstance(arg, str) else Value(arg)
185             ) for arg in expressions
186         ]
187 
188     def as_sql(self, compiler, connection):
189         """
190         Responsible for returning a (sql, [params]) tuple to be included
191         in the current query.
192 
193         Different backends can provide their own implementation, by
194         providing an `as_{vendor}` method and patching the Expression:
195 
196         ```
197         def override_as_sql(self, compiler, connection):
198             # custom logic
199             return super().as_sql(compiler, connection)
200         setattr(Expression, 'as_' + connection.vendor, override_as_sql)
201         ```
202 
203         Arguments:
204          * compiler: the query compiler responsible for generating the query.
205            Must have a compile method, returning a (sql, [params]) tuple.
206            Calling compiler(value) will return a quoted `value`.
207 
208          * connection: the database connection used for the current query.
209 
210         Return: (sql, params)
211           Where `sql` is a string containing ordered sql parameters to be
212           replaced with the elements of the list `params`.
213         """
214         raise NotImplementedError("Subclasses must implement as_sql()")
215 
216     @cached_property
217     def contains_aggregate(self):
218         return any(expr and expr.contains_aggregate for expr in self.get_source_expressions())
219 
220     @cached_property
221     def contains_over_clause(self):
222         return any(expr and expr.contains_over_clause for expr in self.get_source_expressions())
223 
224     @cached_property
225     def contains_column_references(self):
226         return any(expr and expr.contains_column_references for expr in self.get_source_expressions())
227 
228     def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):
229         """
230         Provide the chance to do any preprocessing or validation before being
231         added to the query.
232 
233         Arguments:
234          * query: the backend query implementation
235          * allow_joins: boolean allowing or denying use of joins
236            in this query
237          * reuse: a set of reusable joins for multijoins
238          * summarize: a terminal aggregate clause
239          * for_save: whether this expression about to be used in a save or update
240 
241         Return: an Expression to be added to the query.
242         """
243         c = self.copy()
244         c.is_summary = summarize
245         c.set_source_expressions([
246             expr.resolve_expression(query, allow_joins, reuse, summarize)
247             if expr else None
248             for expr in c.get_source_expressions()
249         ])
250         return c
251 
252     @property
253     def conditional(self):
254         return isinstance(self.output_field, fields.BooleanField)
255 
256     @property
257     def field(self):
258         return self.output_field
259 
260     @cached_property
261     def output_field(self):
262         """Return the output type of this expressions."""
263         output_field = self._resolve_output_field()
264         if output_field is None:
265             self._output_field_resolved_to_none = True
266             raise FieldError('Cannot resolve expression type, unknown output_field')
267         return output_field
268 
269     @cached_property
270     def _output_field_or_none(self):
271         """
272         Return the output field of this expression, or None if
273         _resolve_output_field() didn't return an output type.
274         """
275         try:
276             return self.output_field
277         except FieldError:
278             if not self._output_field_resolved_to_none:
279                 raise
280 
281     def _resolve_output_field(self):
282         """
283         Attempt to infer the output type of the expression. If the output
284         fields of all source fields match then, simply infer the same type
285         here. This isn't always correct, but it makes sense most of the time.
286 
287         Consider the difference between `2 + 2` and `2 / 3`. Inferring
288         the type here is a convenience for the common case. The user should
289         supply their own output_field with more complex computations.
290 
291         If a source's output field resolves to None, exclude it from this check.
292         If all sources are None, then an error is raised higher up the stack in
293         the output_field property.
294         """
295         sources_iter = (source for source in self.get_source_fields() if source is not None)
296         for output_field in sources_iter:
297             for source in sources_iter:
298                 if not isinstance(output_field, source.__class__):
299                     raise FieldError(
300                         'Expression contains mixed types: %s, %s. You must '
301                         'set output_field.' % (
302                             output_field.__class__.__name__,
303                             source.__class__.__name__,
304                         )
305                     )
306             return output_field
307 
308     @staticmethod
309     def _convert_value_noop(value, expression, connection):
310         return value
311 
312     @cached_property
313     def convert_value(self):
314         """
315         Expressions provide their own converters because users have the option
316         of manually specifying the output_field which may be a different type
317         from the one the database returns.
318         """
319         field = self.output_field
320         internal_type = field.get_internal_type()
321         if internal_type == 'FloatField':
322             return lambda value, expression, connection: None if value is None else float(value)
323         elif internal_type.endswith('IntegerField'):
324             return lambda value, expression, connection: None if value is None else int(value)
325         elif internal_type == 'DecimalField':
326             return lambda value, expression, connection: None if value is None else Decimal(value)
327         return self._convert_value_noop
328 
329     def get_lookup(self, lookup):
330         return self.output_field.get_lookup(lookup)
331 
332     def get_transform(self, name):
333         return self.output_field.get_transform(name)
334 
335     def relabeled_clone(self, change_map):
336         clone = self.copy()
337         clone.set_source_expressions([
338             e.relabeled_clone(change_map) if e is not None else None
339             for e in self.get_source_expressions()
340         ])
341         return clone
342 
343     def copy(self):
344         return copy.copy(self)
345 
346     def get_group_by_cols(self, alias=None):
347         if not self.contains_aggregate:
348             return [self]
349         cols = []
350         for source in self.get_source_expressions():
351             cols.extend(source.get_group_by_cols())
352         return cols
353 
354     def get_source_fields(self):
355         """Return the underlying field types used by this aggregate."""
356         return [e._output_field_or_none for e in self.get_source_expressions()]
357 
358     def asc(self, **kwargs):
359         return OrderBy(self, **kwargs)
360 
361     def desc(self, **kwargs):
362         return OrderBy(self, descending=True, **kwargs)
363 
364     def reverse_ordering(self):
365         return self
366 
367     def flatten(self):
368         """
369         Recursively yield this expression and all subexpressions, in
370         depth-first order.
371         """
372         yield self
373         for expr in self.get_source_expressions():
374             if expr:
375                 yield from expr.flatten()
376 
377     def select_format(self, compiler, sql, params):
378         """
379         Custom format for select clauses. For example, EXISTS expressions need
380         to be wrapped in CASE WHEN on Oracle.
381         """
382         return self.output_field.select_format(compiler, sql, params)
383 
384     @cached_property
385     def identity(self):
386         constructor_signature = inspect.signature(self.__init__)
387         args, kwargs = self._constructor_args
388         signature = constructor_signature.bind_partial(*args, **kwargs)
389         signature.apply_defaults()
390         arguments = signature.arguments.items()
391         identity = [self.__class__]
392         for arg, value in arguments:
393             if isinstance(value, fields.Field):
394                 if value.name and value.model:
395                     value = (value.model._meta.label, value.name)
396                 else:
397                     value = type(value)
398             else:
399                 value = make_hashable(value)
400             identity.append((arg, value))
401         return tuple(identity)
402 
403     def __eq__(self, other):
404         if not isinstance(other, BaseExpression):
405             return NotImplemented
406         return other.identity == self.identity
407 
408     def __hash__(self):
409         return hash(self.identity)
410 
411 
412 class Expression(BaseExpression, Combinable):
413     """An expression that can be combined with other expressions."""
414     pass
415 
416 
417 class CombinedExpression(SQLiteNumericMixin, Expression):
418 
419     def __init__(self, lhs, connector, rhs, output_field=None):
420         super().__init__(output_field=output_field)
421         self.connector = connector
422         self.lhs = lhs
423         self.rhs = rhs
424 
425     def __repr__(self):
426         return "<{}: {}>".format(self.__class__.__name__, self)
427 
428     def __str__(self):
429         return "{} {} {}".format(self.lhs, self.connector, self.rhs)
430 
431     def get_source_expressions(self):
432         return [self.lhs, self.rhs]
433 
434     def set_source_expressions(self, exprs):
435         self.lhs, self.rhs = exprs
436 
437     def as_sql(self, compiler, connection):
438         try:
439             lhs_output = self.lhs.output_field
440         except FieldError:
441             lhs_output = None
442         try:
443             rhs_output = self.rhs.output_field
444         except FieldError:
445             rhs_output = None
446         if (not connection.features.has_native_duration_field and
447                 ((lhs_output and lhs_output.get_internal_type() == 'DurationField') or
448                  (rhs_output and rhs_output.get_internal_type() == 'DurationField'))):
449             return DurationExpression(self.lhs, self.connector, self.rhs).as_sql(compiler, connection)
450         if (lhs_output and rhs_output and self.connector == self.SUB and
451             lhs_output.get_internal_type() in {'DateField', 'DateTimeField', 'TimeField'} and
452                 lhs_output.get_internal_type() == rhs_output.get_internal_type()):
453             return TemporalSubtraction(self.lhs, self.rhs).as_sql(compiler, connection)
454         expressions = []
455         expression_params = []
456         sql, params = compiler.compile(self.lhs)
457         expressions.append(sql)
458         expression_params.extend(params)
459         sql, params = compiler.compile(self.rhs)
460         expressions.append(sql)
461         expression_params.extend(params)
462         # order of precedence
463         expression_wrapper = '(%s)'
464         sql = connection.ops.combine_expression(self.connector, expressions)
465         return expression_wrapper % sql, expression_params
466 
467     def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):
468         c = self.copy()
469         c.is_summary = summarize
470         c.lhs = c.lhs.resolve_expression(query, allow_joins, reuse, summarize, for_save)
471         c.rhs = c.rhs.resolve_expression(query, allow_joins, reuse, summarize, for_save)
472         return c
473 
474 
475 class DurationExpression(CombinedExpression):
476     def compile(self, side, compiler, connection):
477         if not isinstance(side, DurationValue):
478             try:
479                 output = side.output_field
480             except FieldError:
481                 pass
482             else:
483                 if output.get_internal_type() == 'DurationField':
484                     sql, params = compiler.compile(side)
485                     return connection.ops.format_for_duration_arithmetic(sql), params
486         return compiler.compile(side)
487 
488     def as_sql(self, compiler, connection):
489         connection.ops.check_expression_support(self)
490         expressions = []
491         expression_params = []
492         sql, params = self.compile(self.lhs, compiler, connection)
493         expressions.append(sql)
494         expression_params.extend(params)
495         sql, params = self.compile(self.rhs, compiler, connection)
496         expressions.append(sql)
497         expression_params.extend(params)
498         # order of precedence
499         expression_wrapper = '(%s)'
500         sql = connection.ops.combine_duration_expression(self.connector, expressions)
501         return expression_wrapper % sql, expression_params
502 
503 
504 class TemporalSubtraction(CombinedExpression):
505     output_field = fields.DurationField()
506 
507     def __init__(self, lhs, rhs):
508         super().__init__(lhs, self.SUB, rhs)
509 
510     def as_sql(self, compiler, connection):
511         connection.ops.check_expression_support(self)
512         lhs = compiler.compile(self.lhs)
513         rhs = compiler.compile(self.rhs)
514         return connection.ops.subtract_temporals(self.lhs.output_field.get_internal_type(), lhs, rhs)
515 
516 
517 @deconstructible
518 class F(Combinable):
519     """An object capable of resolving references to existing query objects."""
520 
521     def __init__(self, name):
522         """
523         Arguments:
524          * name: the name of the field this expression references
525         """
526         self.name = name
527 
528     def __repr__(self):
529         return "{}({})".format(self.__class__.__name__, self.name)
530 
531     def resolve_expression(self, query=None, allow_joins=True, reuse=None,
532                            summarize=False, for_save=False):
533         return query.resolve_ref(self.name, allow_joins, reuse, summarize)
534 
535     def asc(self, **kwargs):
536         return OrderBy(self, **kwargs)
537 
538     def desc(self, **kwargs):
539         return OrderBy(self, descending=True, **kwargs)
540 
541     def __eq__(self, other):
542         return self.__class__ == other.__class__ and self.name == other.name
543 
544     def __hash__(self):
545         return hash(self.name)
546 
547 
548 class ResolvedOuterRef(F):
549     """
550     An object that contains a reference to an outer query.
551 
552     In this case, the reference to the outer query has been resolved because
553     the inner query has been used as a subquery.
554     """
555     contains_aggregate = False
556 
557     def as_sql(self, *args, **kwargs):
558         raise ValueError(
559             'This queryset contains a reference to an outer query and may '
560             'only be used in a subquery.'
561         )
562 
563     def relabeled_clone(self, relabels):
564         return self
565 
566 
567 class OuterRef(F):
568     def resolve_expression(self, *args, **kwargs):
569         if isinstance(self.name, self.__class__):
570             return self.name
571         return ResolvedOuterRef(self.name)
572 
573 
574 class Func(SQLiteNumericMixin, Expression):
575     """An SQL function call."""
576     function = None
577     template = '%(function)s(%(expressions)s)'
578     arg_joiner = ', '
579     arity = None  # The number of arguments the function accepts.
580 
581     def __init__(self, *expressions, output_field=None, **extra):
582         if self.arity is not None and len(expressions) != self.arity:
583             raise TypeError(
584                 "'%s' takes exactly %s %s (%s given)" % (
585                     self.__class__.__name__,
586                     self.arity,
587                     "argument" if self.arity == 1 else "arguments",
588                     len(expressions),
589                 )
590             )
591         super().__init__(output_field=output_field)
592         self.source_expressions = self._parse_expressions(*expressions)
593         self.extra = extra
594 
595     def __repr__(self):
596         args = self.arg_joiner.join(str(arg) for arg in self.source_expressions)
597         extra = {**self.extra, **self._get_repr_options()}
598         if extra:
599             extra = ', '.join(str(key) + '=' + str(val) for key, val in sorted(extra.items()))
600             return "{}({}, {})".format(self.__class__.__name__, args, extra)
601         return "{}({})".format(self.__class__.__name__, args)
602 
603     def _get_repr_options(self):
604         """Return a dict of extra __init__() options to include in the repr."""
605         return {}
606 
607     def get_source_expressions(self):
608         return self.source_expressions
609 
610     def set_source_expressions(self, exprs):
611         self.source_expressions = exprs
612 
613     def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):
614         c = self.copy()
615         c.is_summary = summarize
616         for pos, arg in enumerate(c.source_expressions):
617             c.source_expressions[pos] = arg.resolve_expression(query, allow_joins, reuse, summarize, for_save)
618         return c
619 
620     def as_sql(self, compiler, connection, function=None, template=None, arg_joiner=None, **extra_context):
621         connection.ops.check_expression_support(self)
622         sql_parts = []
623         params = []
624         for arg in self.source_expressions:
625             arg_sql, arg_params = compiler.compile(arg)
626             sql_parts.append(arg_sql)
627             params.extend(arg_params)
628         data = {**self.extra, **extra_context}
629         # Use the first supplied value in this order: the parameter to this
630         # method, a value supplied in __init__()'s **extra (the value in
631         # `data`), or the value defined on the class.
632         if function is not None:
633             data['function'] = function
634         else:
635             data.setdefault('function', self.function)
636         template = template or data.get('template', self.template)
637         arg_joiner = arg_joiner or data.get('arg_joiner', self.arg_joiner)
638         data['expressions'] = data['field'] = arg_joiner.join(sql_parts)
639         return template % data, params
640 
641     def copy(self):
642         copy = super().copy()
643         copy.source_expressions = self.source_expressions[:]
644         copy.extra = self.extra.copy()
645         return copy
646 
647 
648 class Value(Expression):
649     """Represent a wrapped value as a node within an expression."""
650     def __init__(self, value, output_field=None):
651         """
652         Arguments:
653          * value: the value this expression represents. The value will be
654            added into the sql parameter list and properly quoted.
655 
656          * output_field: an instance of the model field type that this
657            expression will return, such as IntegerField() or CharField().
658         """
659         super().__init__(output_field=output_field)
660         self.value = value
661 
662     def __repr__(self):
663         return "{}({})".format(self.__class__.__name__, self.value)
664 
665     def as_sql(self, compiler, connection):
666         connection.ops.check_expression_support(self)
667         val = self.value
668         output_field = self._output_field_or_none
669         if output_field is not None:
670             if self.for_save:
671                 val = output_field.get_db_prep_save(val, connection=connection)
672             else:
673                 val = output_field.get_db_prep_value(val, connection=connection)
674             if hasattr(output_field, 'get_placeholder'):
675                 return output_field.get_placeholder(val, compiler, connection), [val]
676         if val is None:
677             # cx_Oracle does not always convert None to the appropriate
678             # NULL type (like in case expressions using numbers), so we
679             # use a literal SQL NULL
680             return 'NULL', []
681         return '%s', [val]
682 
683     def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):
684         c = super().resolve_expression(query, allow_joins, reuse, summarize, for_save)
685         c.for_save = for_save
686         return c
687 
688     def get_group_by_cols(self, alias=None):
689         return []
690 
691 
692 class DurationValue(Value):
693     def as_sql(self, compiler, connection):
694         connection.ops.check_expression_support(self)
695         if connection.features.has_native_duration_field:
696             return super().as_sql(compiler, connection)
697         return connection.ops.date_interval_sql(self.value), []
698 
699 
700 class RawSQL(Expression):
701     def __init__(self, sql, params, output_field=None):
702         if output_field is None:
703             output_field = fields.Field()
704         self.sql, self.params = sql, params
705         super().__init__(output_field=output_field)
706 
707     def __repr__(self):
708         return "{}({}, {})".format(self.__class__.__name__, self.sql, self.params)
709 
710     def as_sql(self, compiler, connection):
711         return '(%s)' % self.sql, self.params
712 
713     def get_group_by_cols(self, alias=None):
714         return [self]
715 
716     def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):
717         # Resolve parents fields used in raw SQL.
718         for parent in query.model._meta.get_parent_list():
719             for parent_field in parent._meta.local_fields:
720                 _, column_name = parent_field.get_attname_column()
721                 if column_name.lower() in self.sql.lower():
722                     query.resolve_ref(parent_field.name, allow_joins, reuse, summarize)
723                     break
724         return super().resolve_expression(query, allow_joins, reuse, summarize, for_save)
725 
726 
727 class Star(Expression):
728     def __repr__(self):
729         return "'*'"
730 
731     def as_sql(self, compiler, connection):
732         return '*', []
733 
734 
735 class Random(Expression):
736     output_field = fields.FloatField()
737 
738     def __repr__(self):
739         return "Random()"
740 
741     def as_sql(self, compiler, connection):
742         return connection.ops.random_function_sql(), []
743 
744 
745 class Col(Expression):
746 
747     contains_column_references = True
748 
749     def __init__(self, alias, target, output_field=None):
750         if output_field is None:
751             output_field = target
752         super().__init__(output_field=output_field)
753         self.alias, self.target = alias, target
754 
755     def __repr__(self):
756         alias, target = self.alias, self.target
757         identifiers = (alias, str(target)) if alias else (str(target),)
758         return '{}({})'.format(self.__class__.__name__, ', '.join(identifiers))
759 
760     def as_sql(self, compiler, connection):
761         alias, column = self.alias, self.target.column
762         identifiers = (alias, column) if alias else (column,)
763         sql = '.'.join(map(compiler.quote_name_unless_alias, identifiers))
764         return sql, []
765 
766     def relabeled_clone(self, relabels):
767         if self.alias is None:
768             return self
769         return self.__class__(relabels.get(self.alias, self.alias), self.target, self.output_field)
770 
771     def get_group_by_cols(self, alias=None):
772         return [self]
773 
774     def get_db_converters(self, connection):
775         if self.target == self.output_field:
776             return self.output_field.get_db_converters(connection)
777         return (self.output_field.get_db_converters(connection) +
778                 self.target.get_db_converters(connection))
779 
780 
781 class Ref(Expression):
782     """
783     Reference to column alias of the query. For example, Ref('sum_cost') in
784     qs.annotate(sum_cost=Sum('cost')) query.
785     """
786     def __init__(self, refs, source):
787         super().__init__()
788         self.refs, self.source = refs, source
789 
790     def __repr__(self):
791         return "{}({}, {})".format(self.__class__.__name__, self.refs, self.source)
792 
793     def get_source_expressions(self):
794         return [self.source]
795 
796     def set_source_expressions(self, exprs):
797         self.source, = exprs
798 
799     def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):
800         # The sub-expression `source` has already been resolved, as this is
801         # just a reference to the name of `source`.
802         return self
803 
804     def relabeled_clone(self, relabels):
805         return self
806 
807     def as_sql(self, compiler, connection):
808         return connection.ops.quote_name(self.refs), []
809 
810     def get_group_by_cols(self, alias=None):
811         return [self]
812 
813 
814 class ExpressionList(Func):
815     """
816     An expression containing multiple expressions. Can be used to provide a
817     list of expressions as an argument to another expression, like an
818     ordering clause.
819     """
820     template = '%(expressions)s'
821 
822     def __init__(self, *expressions, **extra):
823         if not expressions:
824             raise ValueError('%s requires at least one expression.' % self.__class__.__name__)
825         super().__init__(*expressions, **extra)
826 
827     def __str__(self):
828         return self.arg_joiner.join(str(arg) for arg in self.source_expressions)
829 
830 
831 class ExpressionWrapper(Expression):
832     """
833     An expression that can wrap another expression so that it can provide
834     extra context to the inner expression, such as the output_field.
835     """
836 
837     def __init__(self, expression, output_field):
838         super().__init__(output_field=output_field)
839         self.expression = expression
840 
841     def set_source_expressions(self, exprs):
842         self.expression = exprs[0]
843 
844     def get_source_expressions(self):
845         return [self.expression]
846 
847     def as_sql(self, compiler, connection):
848         return self.expression.as_sql(compiler, connection)
849 
850     def __repr__(self):
851         return "{}({})".format(self.__class__.__name__, self.expression)
852 
853 
854 class When(Expression):
855     template = 'WHEN %(condition)s THEN %(result)s'
856     # This isn't a complete conditional expression, must be used in Case().
857     conditional = False
858 
859     def __init__(self, condition=None, then=None, **lookups):
860         if lookups and condition is None:
861             condition, lookups = Q(**lookups), None
862         if condition is None or not getattr(condition, 'conditional', False) or lookups:
863             raise TypeError(
864                 'When() supports a Q object, a boolean expression, or lookups '
865                 'as a condition.'
866             )
867         if isinstance(condition, Q) and not condition:
868             raise ValueError("An empty Q() can't be used as a When() condition.")
869         super().__init__(output_field=None)
870         self.condition = condition
871         self.result = self._parse_expressions(then)[0]
872 
873     def __str__(self):
874         return "WHEN %r THEN %r" % (self.condition, self.result)
875 
876     def __repr__(self):
877         return "<%s: %s>" % (self.__class__.__name__, self)
878 
879     def get_source_expressions(self):
880         return [self.condition, self.result]
881 
882     def set_source_expressions(self, exprs):
883         self.condition, self.result = exprs
884 
885     def get_source_fields(self):
886         # We're only interested in the fields of the result expressions.
887         return [self.result._output_field_or_none]
888 
889     def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):
890         c = self.copy()
891         c.is_summary = summarize
892         if hasattr(c.condition, 'resolve_expression'):
893             c.condition = c.condition.resolve_expression(query, allow_joins, reuse, summarize, False)
894         c.result = c.result.resolve_expression(query, allow_joins, reuse, summarize, for_save)
895         return c
896 
897     def as_sql(self, compiler, connection, template=None, **extra_context):
898         connection.ops.check_expression_support(self)
899         template_params = extra_context
900         sql_params = []
901         condition_sql, condition_params = compiler.compile(self.condition)
902         template_params['condition'] = condition_sql
903         sql_params.extend(condition_params)
904         result_sql, result_params = compiler.compile(self.result)
905         template_params['result'] = result_sql
906         sql_params.extend(result_params)
907         template = template or self.template
908         return template % template_params, sql_params
909 
910     def get_group_by_cols(self, alias=None):
911         # This is not a complete expression and cannot be used in GROUP BY.
912         cols = []
913         for source in self.get_source_expressions():
914             cols.extend(source.get_group_by_cols())
915         return cols
916 
917 
918 class Case(Expression):
919     """
920     An SQL searched CASE expression:
921 
922         CASE
923             WHEN n > 0
924                 THEN 'positive'
925             WHEN n < 0
926                 THEN 'negative'
927             ELSE 'zero'
928         END
929     """
930     template = 'CASE %(cases)s ELSE %(default)s END'
931     case_joiner = ' '
932 
933     def __init__(self, *cases, default=None, output_field=None, **extra):
934         if not all(isinstance(case, When) for case in cases):
935             raise TypeError("Positional arguments must all be When objects.")
936         super().__init__(output_field)
937         self.cases = list(cases)
938         self.default = self._parse_expressions(default)[0]
939         self.extra = extra
940 
941     def __str__(self):
942         return "CASE %s, ELSE %r" % (', '.join(str(c) for c in self.cases), self.default)
943 
944     def __repr__(self):
945         return "<%s: %s>" % (self.__class__.__name__, self)
946 
947     def get_source_expressions(self):
948         return self.cases + [self.default]
949 
950     def set_source_expressions(self, exprs):
951         *self.cases, self.default = exprs
952 
953     def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):
954         c = self.copy()
955         c.is_summary = summarize
956         for pos, case in enumerate(c.cases):
957             c.cases[pos] = case.resolve_expression(query, allow_joins, reuse, summarize, for_save)
958         c.default = c.default.resolve_expression(query, allow_joins, reuse, summarize, for_save)
959         return c
960 
961     def copy(self):
962         c = super().copy()
963         c.cases = c.cases[:]
964         return c
965 
966     def as_sql(self, compiler, connection, template=None, case_joiner=None, **extra_context):
967         connection.ops.check_expression_support(self)
968         if not self.cases:
969             return compiler.compile(self.default)
970         template_params = {**self.extra, **extra_context}
971         case_parts = []
972         sql_params = []
973         for case in self.cases:
974             try:
975                 case_sql, case_params = compiler.compile(case)
976             except EmptyResultSet:
977                 continue
978             case_parts.append(case_sql)
979             sql_params.extend(case_params)
980         default_sql, default_params = compiler.compile(self.default)
981         if not case_parts:
982             return default_sql, default_params
983         case_joiner = case_joiner or self.case_joiner
984         template_params['cases'] = case_joiner.join(case_parts)
985         template_params['default'] = default_sql
986         sql_params.extend(default_params)
987         template = template or template_params.get('template', self.template)
988         sql = template % template_params
989         if self._output_field_or_none is not None:
990             sql = connection.ops.unification_cast_sql(self.output_field) % sql
991         return sql, sql_params
992 
993 
994 class Subquery(Expression):
995     """
996     An explicit subquery. It may contain OuterRef() references to the outer
997     query which will be resolved when it is applied to that query.
998     """
999     template = '(%(subquery)s)'
1000     contains_aggregate = False
1001 
1002     def __init__(self, queryset, output_field=None, **extra):
1003         self.query = queryset.query
1004         self.extra = extra
1005         super().__init__(output_field)
1006 
1007     def __getstate__(self):
1008         state = super().__getstate__()
1009         state.pop('_constructor_args', None)
1010         return state
1011 
1012     def get_source_expressions(self):
1013         return [self.query]
1014 
1015     def set_source_expressions(self, exprs):
1016         self.query = exprs[0]
1017 
1018     def _resolve_output_field(self):
1019         return self.query.output_field
1020 
1021     def copy(self):
1022         clone = super().copy()
1023         clone.query = clone.query.clone()
1024         return clone
1025 
1026     @property
1027     def external_aliases(self):
1028         return self.query.external_aliases
1029 
1030     def as_sql(self, compiler, connection, template=None, **extra_context):
1031         connection.ops.check_expression_support(self)
1032         template_params = {**self.extra, **extra_context}
1033         subquery_sql, sql_params = self.query.as_sql(compiler, connection)
1034         template_params['subquery'] = subquery_sql[1:-1]
1035 
1036         template = template or template_params.get('template', self.template)
1037         sql = template % template_params
1038         return sql, sql_params
1039 
1040     def get_group_by_cols(self, alias=None):
1041         if alias:
1042             return [Ref(alias, self)]
1043         return []
1044 
1045 
1046 class Exists(Subquery):
1047     template = 'EXISTS(%(subquery)s)'
1048     output_field = fields.BooleanField()
1049 
1050     def __init__(self, queryset, negated=False, **kwargs):
1051         # As a performance optimization, remove ordering since EXISTS doesn't
1052         # care about it, just whether or not a row matches.
1053         queryset = queryset.order_by()
1054         self.negated = negated
1055         super().__init__(queryset, **kwargs)
1056 
1057     def __invert__(self):
1058         clone = self.copy()
1059         clone.negated = not self.negated
1060         return clone
1061 
1062     def as_sql(self, compiler, connection, template=None, **extra_context):
1063         sql, params = super().as_sql(compiler, connection, template, **extra_context)
1064         if self.negated:
1065             sql = 'NOT {}'.format(sql)
1066         return sql, params
1067 
1068     def select_format(self, compiler, sql, params):
1069         # Wrap EXISTS() with a CASE WHEN expression if a database backend
1070         # (e.g. Oracle) doesn't support boolean expression in the SELECT list.
1071         if not compiler.connection.features.supports_boolean_expr_in_select_clause:
1072             sql = 'CASE WHEN {} THEN 1 ELSE 0 END'.format(sql)
1073         return sql, params
1074 
1075 
1076 class OrderBy(BaseExpression):
1077     template = '%(expression)s %(ordering)s'
1078     conditional = False
1079 
1080     def __init__(self, expression, descending=False, nulls_first=False, nulls_last=False):
1081         if nulls_first and nulls_last:
1082             raise ValueError('nulls_first and nulls_last are mutually exclusive')
1083         self.nulls_first = nulls_first
1084         self.nulls_last = nulls_last
1085         self.descending = descending
1086         if not hasattr(expression, 'resolve_expression'):
1087             raise ValueError('expression must be an expression type')
1088         self.expression = expression
1089 
1090     def __repr__(self):
1091         return "{}({}, descending={})".format(
1092             self.__class__.__name__, self.expression, self.descending)
1093 
1094     def set_source_expressions(self, exprs):
1095         self.expression = exprs[0]
1096 
1097     def get_source_expressions(self):
1098         return [self.expression]
1099 
1100     def as_sql(self, compiler, connection, template=None, **extra_context):
1101         template = template or self.template
1102         if connection.features.supports_order_by_nulls_modifier:
1103             if self.nulls_last:
1104                 template = '%s NULLS LAST' % template
1105             elif self.nulls_first:
1106                 template = '%s NULLS FIRST' % template
1107         else:
1108             if self.nulls_last:
1109                 template = '%%(expression)s IS NULL, %s' % template
1110             elif self.nulls_first:
1111                 template = '%%(expression)s IS NOT NULL, %s' % template
1112         connection.ops.check_expression_support(self)
1113         expression_sql, params = compiler.compile(self.expression)
1114         placeholders = {
1115             'expression': expression_sql,
1116             'ordering': 'DESC' if self.descending else 'ASC',
1117             **extra_context,
1118         }
1119         template = template or self.template
1120         params *= template.count('%(expression)s')
1121         return (template % placeholders).rstrip(), params
1122 
1123     def as_oracle(self, compiler, connection):
1124         # Oracle doesn't allow ORDER BY EXISTS() unless it's wrapped in
1125         # a CASE WHEN.
1126         if isinstance(self.expression, Exists):
1127             copy = self.copy()
1128             copy.expression = Case(
1129                 When(self.expression, then=True),
1130                 default=False,
1131                 output_field=fields.BooleanField(),
1132             )
1133             return copy.as_sql(compiler, connection)
1134         return self.as_sql(compiler, connection)
1135 
1136     def get_group_by_cols(self, alias=None):
1137         cols = []
1138         for source in self.get_source_expressions():
1139             cols.extend(source.get_group_by_cols())
1140         return cols
1141 
1142     def reverse_ordering(self):
1143         self.descending = not self.descending
1144         if self.nulls_first or self.nulls_last:
1145             self.nulls_first = not self.nulls_first
1146             self.nulls_last = not self.nulls_last
1147         return self
1148 
1149     def asc(self):
1150         self.descending = False
1151 
1152     def desc(self):
1153         self.descending = True
1154 
1155 
1156 class Window(Expression):
1157     template = '%(expression)s OVER (%(window)s)'
1158     # Although the main expression may either be an aggregate or an
1159     # expression with an aggregate function, the GROUP BY that will
1160     # be introduced in the query as a result is not desired.
1161     contains_aggregate = False
1162     contains_over_clause = True
1163     filterable = False
1164 
1165     def __init__(self, expression, partition_by=None, order_by=None, frame=None, output_field=None):
1166         self.partition_by = partition_by
1167         self.order_by = order_by
1168         self.frame = frame
1169 
1170         if not getattr(expression, 'window_compatible', False):
1171             raise ValueError(
1172                 "Expression '%s' isn't compatible with OVER clauses." %
1173                 expression.__class__.__name__
1174             )
1175 
1176         if self.partition_by is not None:
1177             if not isinstance(self.partition_by, (tuple, list)):
1178                 self.partition_by = (self.partition_by,)
1179             self.partition_by = ExpressionList(*self.partition_by)
1180 
1181         if self.order_by is not None:
1182             if isinstance(self.order_by, (list, tuple)):
1183                 self.order_by = ExpressionList(*self.order_by)
1184             elif not isinstance(self.order_by, BaseExpression):
1185                 raise ValueError(
1186                     'order_by must be either an Expression or a sequence of '
1187                     'expressions.'
1188                 )
1189         super().__init__(output_field=output_field)
1190         self.source_expression = self._parse_expressions(expression)[0]
1191 
1192     def _resolve_output_field(self):
1193         return self.source_expression.output_field
1194 
1195     def get_source_expressions(self):
1196         return [self.source_expression, self.partition_by, self.order_by, self.frame]
1197 
1198     def set_source_expressions(self, exprs):
1199         self.source_expression, self.partition_by, self.order_by, self.frame = exprs
1200 
1201     def as_sql(self, compiler, connection, template=None):
1202         connection.ops.check_expression_support(self)
1203         if not connection.features.supports_over_clause:
1204             raise NotSupportedError('This backend does not support window expressions.')
1205         expr_sql, params = compiler.compile(self.source_expression)
1206         window_sql, window_params = [], []
1207 
1208         if self.partition_by is not None:
1209             sql_expr, sql_params = self.partition_by.as_sql(
1210                 compiler=compiler, connection=connection,
1211                 template='PARTITION BY %(expressions)s',
1212             )
1213             window_sql.extend(sql_expr)
1214             window_params.extend(sql_params)
1215 
1216         if self.order_by is not None:
1217             window_sql.append(' ORDER BY ')
1218             order_sql, order_params = compiler.compile(self.order_by)
1219             window_sql.extend(order_sql)
1220             window_params.extend(order_params)
1221 
1222         if self.frame:
1223             frame_sql, frame_params = compiler.compile(self.frame)
1224             window_sql.append(' ' + frame_sql)
1225             window_params.extend(frame_params)
1226 
1227         params.extend(window_params)
1228         template = template or self.template
1229 
1230         return template % {
1231             'expression': expr_sql,
1232             'window': ''.join(window_sql).strip()
1233         }, params
1234 
1235     def __str__(self):
1236         return '{} OVER ({}{}{})'.format(
1237             str(self.source_expression),
1238             'PARTITION BY ' + str(self.partition_by) if self.partition_by else '',
1239             'ORDER BY ' + str(self.order_by) if self.order_by else '',
1240             str(self.frame or ''),
1241         )
1242 
1243     def __repr__(self):
1244         return '<%s: %s>' % (self.__class__.__name__, self)
1245 
1246     def get_group_by_cols(self, alias=None):
1247         return []
1248 
1249 
1250 class WindowFrame(Expression):
1251     """
1252     Model the frame clause in window expressions. There are two types of frame
1253     clauses which are subclasses, however, all processing and validation (by no
1254     means intended to be complete) is done here. Thus, providing an end for a
1255     frame is optional (the default is UNBOUNDED FOLLOWING, which is the last
1256     row in the frame).
1257     """
1258     template = '%(frame_type)s BETWEEN %(start)s AND %(end)s'
1259 
1260     def __init__(self, start=None, end=None):
1261         self.start = Value(start)
1262         self.end = Value(end)
1263 
1264     def set_source_expressions(self, exprs):
1265         self.start, self.end = exprs
1266 
1267     def get_source_expressions(self):
1268         return [self.start, self.end]
1269 
1270     def as_sql(self, compiler, connection):
1271         connection.ops.check_expression_support(self)
1272         start, end = self.window_frame_start_end(connection, self.start.value, self.end.value)
1273         return self.template % {
1274             'frame_type': self.frame_type,
1275             'start': start,
1276             'end': end,
1277         }, []
1278 
1279     def __repr__(self):
1280         return '<%s: %s>' % (self.__class__.__name__, self)
1281 
1282     def get_group_by_cols(self, alias=None):
1283         return []
1284 
1285     def __str__(self):
1286         if self.start.value is not None and self.start.value < 0:
1287             start = '%d %s' % (abs(self.start.value), connection.ops.PRECEDING)
1288         elif self.start.value is not None and self.start.value == 0:
1289             start = connection.ops.CURRENT_ROW
1290         else:
1291             start = connection.ops.UNBOUNDED_PRECEDING
1292 
1293         if self.end.value is not None and self.end.value > 0:
1294             end = '%d %s' % (self.end.value, connection.ops.FOLLOWING)
1295         elif self.end.value is not None and self.end.value == 0:
1296             end = connection.ops.CURRENT_ROW
1297         else:
1298             end = connection.ops.UNBOUNDED_FOLLOWING
1299         return self.template % {
1300             'frame_type': self.frame_type,
1301             'start': start,
1302             'end': end,
1303         }
1304 
1305     def window_frame_start_end(self, connection, start, end):
1306         raise NotImplementedError('Subclasses must implement window_frame_start_end().')
1307 
1308 
1309 class RowRange(WindowFrame):
1310     frame_type = 'ROWS'
1311 
1312     def window_frame_start_end(self, connection, start, end):
1313         return connection.ops.window_frame_rows_start_end(start, end)
1314 
1315 
1316 class ValueRange(WindowFrame):
1317     frame_type = 'RANGE'
1318 
1319     def window_frame_start_end(self, connection, start, end):
1320         return connection.ops.window_frame_range_start_end(start, end)

</code><intended_behavior>Ensure that when `Case` expressions include `Window` functions, they are processed in a way that the window function's result is accessible and usable in a `SELECT` clause without raising `NotSupportedError`.</intended_behavior>]
2025-10-18 11:21:55.145 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-18 11:21:55.145 | INFO     | Search-only: skipping patch selection
2025-10-18 11:21:55.322 | INFO     | Task django__django-12185 completed successfully.
2025-10-18 11:21:55.323 | INFO     | No patch generated. You can try running ACR again.
