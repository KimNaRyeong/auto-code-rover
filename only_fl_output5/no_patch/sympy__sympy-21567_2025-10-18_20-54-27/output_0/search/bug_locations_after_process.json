[
    {
        "rel_file_path": "sympy/functions/elementary/hyperbolic.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sympy__sympy/setup_sympy__sympy__1.9/sympy/functions/elementary/hyperbolic.py",
        "start": 1,
        "end": 1773,
        "class_name": null,
        "method_name": null,
        "code": "1 from sympy.core.logic import FuzzyBool\n2 \n3 from sympy.core import S, sympify, cacheit, pi, I, Rational\n4 from sympy.core.add import Add\n5 from sympy.core.function import Function, ArgumentIndexError, _coeff_isneg\n6 from sympy.functions.combinatorial.factorials import factorial, RisingFactorial\n7 from sympy.functions.elementary.exponential import exp, log, match_real_imag\n8 from sympy.functions.elementary.miscellaneous import sqrt\n9 from sympy.functions.elementary.integers import floor\n10 \n11 from sympy.core.logic import fuzzy_or, fuzzy_and\n12 \n13 \n14 \n15 def _rewrite_hyperbolics_as_exp(expr):\n16     expr = sympify(expr)\n17     return expr.xreplace({h: h.rewrite(exp)\n18         for h in expr.atoms(HyperbolicFunction)})\n19 \n20 \n21 ###############################################################################\n22 ########################### HYPERBOLIC FUNCTIONS ##############################\n23 ###############################################################################\n24 \n25 \n26 class HyperbolicFunction(Function):\n27     \"\"\"\n28     Base class for hyperbolic functions.\n29 \n30     See Also\n31     ========\n32 \n33     sinh, cosh, tanh, coth\n34     \"\"\"\n35 \n36     unbranched = True\n37 \n38 \n39 def _peeloff_ipi(arg):\n40     \"\"\"\n41     Split ARG into two parts, a \"rest\" and a multiple of I*pi/2.\n42     This assumes ARG to be an Add.\n43     The multiple of I*pi returned in the second position is always a Rational.\n44 \n45     Examples\n46     ========\n47 \n48     >>> from sympy.functions.elementary.hyperbolic import _peeloff_ipi as peel\n49     >>> from sympy import pi, I\n50     >>> from sympy.abc import x, y\n51     >>> peel(x + I*pi/2)\n52     (x, I*pi/2)\n53     >>> peel(x + I*2*pi/3 + I*pi*y)\n54     (x + I*pi*y + I*pi/6, I*pi/2)\n55     \"\"\"\n56     for a in Add.make_args(arg):\n57         if a == S.Pi*S.ImaginaryUnit:\n58             K = S.One\n59             break\n60         elif a.is_Mul:\n61             K, p = a.as_two_terms()\n62             if p == S.Pi*S.ImaginaryUnit and K.is_Rational:\n63                 break\n64     else:\n65         return arg, S.Zero\n66 \n67     m1 = (K % S.Half)*S.Pi*S.ImaginaryUnit\n68     m2 = K*S.Pi*S.ImaginaryUnit - m1\n69     return arg - m2, m2\n70 \n71 \n72 class sinh(HyperbolicFunction):\n73     r\"\"\"\n74     sinh(x) is the hyperbolic sine of x.\n75 \n76     The hyperbolic sine function is $\\frac{e^x - e^{-x}}{2}$.\n77 \n78     Examples\n79     ========\n80 \n81     >>> from sympy import sinh\n82     >>> from sympy.abc import x\n83     >>> sinh(x)\n84     sinh(x)\n85 \n86     See Also\n87     ========\n88 \n89     cosh, tanh, asinh\n90     \"\"\"\n91 \n92     def fdiff(self, argindex=1):\n93         \"\"\"\n94         Returns the first derivative of this function.\n95         \"\"\"\n96         if argindex == 1:\n97             return cosh(self.args[0])\n98         else:\n99             raise ArgumentIndexError(self, argindex)\n100 \n101     def inverse(self, argindex=1):\n102         \"\"\"\n103         Returns the inverse of this function.\n104         \"\"\"\n105         return asinh\n106 \n107     @classmethod\n108     def eval(cls, arg):\n109         from sympy import sin\n110 \n111         arg = sympify(arg)\n112 \n113         if arg.is_Number:\n114             if arg is S.NaN:\n115                 return S.NaN\n116             elif arg is S.Infinity:\n117                 return S.Infinity\n118             elif arg is S.NegativeInfinity:\n119                 return S.NegativeInfinity\n120             elif arg.is_zero:\n121                 return S.Zero\n122             elif arg.is_negative:\n123                 return -cls(-arg)\n124         else:\n125             if arg is S.ComplexInfinity:\n126                 return S.NaN\n127 \n128             i_coeff = arg.as_coefficient(S.ImaginaryUnit)\n129 \n130             if i_coeff is not None:\n131                 return S.ImaginaryUnit * sin(i_coeff)\n132             else:\n133                 if _coeff_isneg(arg):\n134                     return -cls(-arg)\n135 \n136             if arg.is_Add:\n137                 x, m = _peeloff_ipi(arg)\n138                 if m:\n139                     return sinh(m)*cosh(x) + cosh(m)*sinh(x)\n140 \n141             if arg.is_zero:\n142                 return S.Zero\n143 \n144             if arg.func == asinh:\n145                 return arg.args[0]\n146 \n147             if arg.func == acosh:\n148                 x = arg.args[0]\n149                 return sqrt(x - 1) * sqrt(x + 1)\n150 \n151             if arg.func == atanh:\n152                 x = arg.args[0]\n153                 return x/sqrt(1 - x**2)\n154 \n155             if arg.func == acoth:\n156                 x = arg.args[0]\n157                 return 1/(sqrt(x - 1) * sqrt(x + 1))\n158 \n159     @staticmethod\n160     @cacheit\n161     def taylor_term(n, x, *previous_terms):\n162         \"\"\"\n163         Returns the next term in the Taylor series expansion.\n164         \"\"\"\n165         if n < 0 or n % 2 == 0:\n166             return S.Zero\n167         else:\n168             x = sympify(x)\n169 \n170             if len(previous_terms) > 2:\n171                 p = previous_terms[-2]\n172                 return p * x**2 / (n*(n - 1))\n173             else:\n174                 return x**(n) / factorial(n)\n175 \n176     def _eval_conjugate(self):\n177         return self.func(self.args[0].conjugate())\n178 \n179     def as_real_imag(self, deep=True, **hints):\n180         \"\"\"\n181         Returns this function as a complex coordinate.\n182         \"\"\"\n183         from sympy import cos, sin\n184         if self.args[0].is_extended_real:\n185             if deep:\n186                 hints['complex'] = False\n187                 return (self.expand(deep, **hints), S.Zero)\n188             else:\n189                 return (self, S.Zero)\n190         if deep:\n191             re, im = self.args[0].expand(deep, **hints).as_real_imag()\n192         else:\n193             re, im = self.args[0].as_real_imag()\n194         return (sinh(re)*cos(im), cosh(re)*sin(im))\n195 \n196     def _eval_expand_complex(self, deep=True, **hints):\n197         re_part, im_part = self.as_real_imag(deep=deep, **hints)\n198         return re_part + im_part*S.ImaginaryUnit\n199 \n200     def _eval_expand_trig(self, deep=True, **hints):\n201         if deep:\n202             arg = self.args[0].expand(deep, **hints)\n203         else:\n204             arg = self.args[0]\n205         x = None\n206         if arg.is_Add: # TODO, implement more if deep stuff here\n207             x, y = arg.as_two_terms()\n208         else:\n209             coeff, terms = arg.as_coeff_Mul(rational=True)\n210             if coeff is not S.One and coeff.is_Integer and terms is not S.One:\n211                 x = terms\n212                 y = (coeff - 1)*x\n213         if x is not None:\n214             return (sinh(x)*cosh(y) + sinh(y)*cosh(x)).expand(trig=True)\n215         return sinh(arg)\n216 \n217     def _eval_rewrite_as_tractable(self, arg, limitvar=None, **kwargs):\n218         return (exp(arg) - exp(-arg)) / 2\n219 \n220     def _eval_rewrite_as_exp(self, arg, **kwargs):\n221         return (exp(arg) - exp(-arg)) / 2\n222 \n223     def _eval_rewrite_as_cosh(self, arg, **kwargs):\n224         return -S.ImaginaryUnit*cosh(arg + S.Pi*S.ImaginaryUnit/2)\n225 \n226     def _eval_rewrite_as_tanh(self, arg, **kwargs):\n227         tanh_half = tanh(S.Half*arg)\n228         return 2*tanh_half/(1 - tanh_half**2)\n229 \n230     def _eval_rewrite_as_coth(self, arg, **kwargs):\n231         coth_half = coth(S.Half*arg)\n232         return 2*coth_half/(coth_half**2 - 1)\n233 \n234     def _eval_as_leading_term(self, x, cdir=0):\n235         from sympy import Order\n236         arg = self.args[0].as_leading_term(x)\n237 \n238         if x in arg.free_symbols and Order(1, x).contains(arg):\n239             return arg\n240         else:\n241             return self.func(arg)\n242 \n243     def _eval_is_real(self):\n244         arg = self.args[0]\n245         if arg.is_real:\n246             return True\n247 \n248         # if `im` is of the form n*pi\n249         # else, check if it is a number\n250         re, im = arg.as_real_imag()\n251         return (im%pi).is_zero\n252 \n253     def _eval_is_extended_real(self):\n254         if self.args[0].is_extended_real:\n255             return True\n256 \n257     def _eval_is_positive(self):\n258         if self.args[0].is_extended_real:\n259             return self.args[0].is_positive\n260 \n261     def _eval_is_negative(self):\n262         if self.args[0].is_extended_real:\n263             return self.args[0].is_negative\n264 \n265     def _eval_is_finite(self):\n266         arg = self.args[0]\n267         return arg.is_finite\n268 \n269     def _eval_is_zero(self):\n270         arg = self.args[0]\n271         if arg.is_zero:\n272             return True\n273 \n274 \n275 class cosh(HyperbolicFunction):\n276     r\"\"\"\n277     cosh(x) is the hyperbolic cosine of x.\n278 \n279     The hyperbolic cosine function is $\\frac{e^x + e^{-x}}{2}$.\n280 \n281     Examples\n282     ========\n283 \n284     >>> from sympy import cosh\n285     >>> from sympy.abc import x\n286     >>> cosh(x)\n287     cosh(x)\n288 \n289     See Also\n290     ========\n291 \n292     sinh, tanh, acosh\n293     \"\"\"\n294 \n295     def fdiff(self, argindex=1):\n296         if argindex == 1:\n297             return sinh(self.args[0])\n298         else:\n299             raise ArgumentIndexError(self, argindex)\n300 \n301     @classmethod\n302     def eval(cls, arg):\n303         from sympy import cos\n304         arg = sympify(arg)\n305 \n306         if arg.is_Number:\n307             if arg is S.NaN:\n308                 return S.NaN\n309             elif arg is S.Infinity:\n310                 return S.Infinity\n311             elif arg is S.NegativeInfinity:\n312                 return S.Infinity\n313             elif arg.is_zero:\n314                 return S.One\n315             elif arg.is_negative:\n316                 return cls(-arg)\n317         else:\n318             if arg is S.ComplexInfinity:\n319                 return S.NaN\n320 \n321             i_coeff = arg.as_coefficient(S.ImaginaryUnit)\n322 \n323             if i_coeff is not None:\n324                 return cos(i_coeff)\n325             else:\n326                 if _coeff_isneg(arg):\n327                     return cls(-arg)\n328 \n329             if arg.is_Add:\n330                 x, m = _peeloff_ipi(arg)\n331                 if m:\n332                     return cosh(m)*cosh(x) + sinh(m)*sinh(x)\n333 \n334             if arg.is_zero:\n335                 return S.One\n336 \n337             if arg.func == asinh:\n338                 return sqrt(1 + arg.args[0]**2)\n339 \n340             if arg.func == acosh:\n341                 return arg.args[0]\n342 \n343             if arg.func == atanh:\n344                 return 1/sqrt(1 - arg.args[0]**2)\n345 \n346             if arg.func == acoth:\n347                 x = arg.args[0]\n348                 return x/(sqrt(x - 1) * sqrt(x + 1))\n349 \n350     @staticmethod\n351     @cacheit\n352     def taylor_term(n, x, *previous_terms):\n353         if n < 0 or n % 2 == 1:\n354             return S.Zero\n355         else:\n356             x = sympify(x)\n357 \n358             if len(previous_terms) > 2:\n359                 p = previous_terms[-2]\n360                 return p * x**2 / (n*(n - 1))\n361             else:\n362                 return x**(n)/factorial(n)\n363 \n364     def _eval_conjugate(self):\n365         return self.func(self.args[0].conjugate())\n366 \n367     def as_real_imag(self, deep=True, **hints):\n368         from sympy import cos, sin\n369         if self.args[0].is_extended_real:\n370             if deep:\n371                 hints['complex'] = False\n372                 return (self.expand(deep, **hints), S.Zero)\n373             else:\n374                 return (self, S.Zero)\n375         if deep:\n376             re, im = self.args[0].expand(deep, **hints).as_real_imag()\n377         else:\n378             re, im = self.args[0].as_real_imag()\n379 \n380         return (cosh(re)*cos(im), sinh(re)*sin(im))\n381 \n382     def _eval_expand_complex(self, deep=True, **hints):\n383         re_part, im_part = self.as_real_imag(deep=deep, **hints)\n384         return re_part + im_part*S.ImaginaryUnit\n385 \n386     def _eval_expand_trig(self, deep=True, **hints):\n387         if deep:\n388             arg = self.args[0].expand(deep, **hints)\n389         else:\n390             arg = self.args[0]\n391         x = None\n392         if arg.is_Add: # TODO, implement more if deep stuff here\n393             x, y = arg.as_two_terms()\n394         else:\n395             coeff, terms = arg.as_coeff_Mul(rational=True)\n396             if coeff is not S.One and coeff.is_Integer and terms is not S.One:\n397                 x = terms\n398                 y = (coeff - 1)*x\n399         if x is not None:\n400             return (cosh(x)*cosh(y) + sinh(x)*sinh(y)).expand(trig=True)\n401         return cosh(arg)\n402 \n403     def _eval_rewrite_as_tractable(self, arg, limitvar=None, **kwargs):\n404         return (exp(arg) + exp(-arg)) / 2\n405 \n406     def _eval_rewrite_as_exp(self, arg, **kwargs):\n407         return (exp(arg) + exp(-arg)) / 2\n408 \n409     def _eval_rewrite_as_sinh(self, arg, **kwargs):\n410         return -S.ImaginaryUnit*sinh(arg + S.Pi*S.ImaginaryUnit/2)\n411 \n412     def _eval_rewrite_as_tanh(self, arg, **kwargs):\n413         tanh_half = tanh(S.Half*arg)**2\n414         return (1 + tanh_half)/(1 - tanh_half)\n415 \n416     def _eval_rewrite_as_coth(self, arg, **kwargs):\n417         coth_half = coth(S.Half*arg)**2\n418         return (coth_half + 1)/(coth_half - 1)\n419 \n420     def _eval_as_leading_term(self, x, cdir=0):\n421         from sympy import Order\n422         arg = self.args[0].as_leading_term(x)\n423 \n424         if x in arg.free_symbols and Order(1, x).contains(arg):\n425             return S.One\n426         else:\n427             return self.func(arg)\n428 \n429     def _eval_is_real(self):\n430         arg = self.args[0]\n431 \n432         # `cosh(x)` is real for real OR purely imaginary `x`\n433         if arg.is_real or arg.is_imaginary:\n434             return True\n435 \n436         # cosh(a+ib) = cos(b)*cosh(a) + i*sin(b)*sinh(a)\n437         # the imaginary part can be an expression like n*pi\n438         # if not, check if the imaginary part is a number\n439         re, im = arg.as_real_imag()\n440         return (im%pi).is_zero\n441 \n442     def _eval_is_positive(self):\n443         # cosh(x+I*y) = cos(y)*cosh(x) + I*sin(y)*sinh(x)\n444         # cosh(z) is positive iff it is real and the real part is positive.\n445         # So we need sin(y)*sinh(x) = 0 which gives x=0 or y=n*pi\n446         # Case 1 (y=n*pi): cosh(z) = (-1)**n * cosh(x) -> positive for n even\n447         # Case 2 (x=0): cosh(z) = cos(y) -> positive when cos(y) is positive\n448         z = self.args[0]\n449 \n450         x, y = z.as_real_imag()\n451         ymod = y % (2*pi)\n452 \n453         yzero = ymod.is_zero\n454         # shortcut if ymod is zero\n455         if yzero:\n456             return True\n457 \n458         xzero = x.is_zero\n459         # shortcut x is not zero\n460         if xzero is False:\n461             return yzero\n462 \n463         return fuzzy_or([\n464                 # Case 1:\n465                 yzero,\n466                 # Case 2:\n467                 fuzzy_and([\n468                     xzero,\n469                     fuzzy_or([ymod < pi/2, ymod > 3*pi/2])\n470                 ])\n471             ])\n472 \n473 \n474     def _eval_is_nonnegative(self):\n475         z = self.args[0]\n476 \n477         x, y = z.as_real_imag()\n478         ymod = y % (2*pi)\n479 \n480         yzero = ymod.is_zero\n481         # shortcut if ymod is zero\n482         if yzero:\n483             return True\n484 \n485         xzero = x.is_zero\n486         # shortcut x is not zero\n487         if xzero is False:\n488             return yzero\n489 \n490         return fuzzy_or([\n491                 # Case 1:\n492                 yzero,\n493                 # Case 2:\n494                 fuzzy_and([\n495                     xzero,\n496                     fuzzy_or([ymod <= pi/2, ymod >= 3*pi/2])\n497                 ])\n498             ])\n499 \n500     def _eval_is_finite(self):\n501         arg = self.args[0]\n502         return arg.is_finite\n503 \n504 \n505 class tanh(HyperbolicFunction):\n506     r\"\"\"\n507     tanh(x) is the hyperbolic tangent of x.\n508 \n509     The hyperbolic tangent function is $\\frac{\\sinh(x)}{\\cosh(x)}$.\n510 \n511     Examples\n512     ========\n513 \n514     >>> from sympy import tanh\n515     >>> from sympy.abc import x\n516     >>> tanh(x)\n517     tanh(x)\n518 \n519     See Also\n520     ========\n521 \n522     sinh, cosh, atanh\n523     \"\"\"\n524 \n525     def fdiff(self, argindex=1):\n526         if argindex == 1:\n527             return S.One - tanh(self.args[0])**2\n528         else:\n529             raise ArgumentIndexError(self, argindex)\n530 \n531     def inverse(self, argindex=1):\n532         \"\"\"\n533         Returns the inverse of this function.\n534         \"\"\"\n535         return atanh\n536 \n537     @classmethod\n538     def eval(cls, arg):\n539         from sympy import tan\n540         arg = sympify(arg)\n541 \n542         if arg.is_Number:\n543             if arg is S.NaN:\n544                 return S.NaN\n545             elif arg is S.Infinity:\n546                 return S.One\n547             elif arg is S.NegativeInfinity:\n548                 return S.NegativeOne\n549             elif arg.is_zero:\n550                 return S.Zero\n551             elif arg.is_negative:\n552                 return -cls(-arg)\n553         else:\n554             if arg is S.ComplexInfinity:\n555                 return S.NaN\n556 \n557             i_coeff = arg.as_coefficient(S.ImaginaryUnit)\n558 \n559             if i_coeff is not None:\n560                 if _coeff_isneg(i_coeff):\n561                     return -S.ImaginaryUnit * tan(-i_coeff)\n562                 return S.ImaginaryUnit * tan(i_coeff)\n563             else:\n564                 if _coeff_isneg(arg):\n565                     return -cls(-arg)\n566 \n567             if arg.is_Add:\n568                 x, m = _peeloff_ipi(arg)\n569                 if m:\n570                     tanhm = tanh(m)\n571                     if tanhm is S.ComplexInfinity:\n572                         return coth(x)\n573                     else: # tanhm == 0\n574                         return tanh(x)\n575 \n576             if arg.is_zero:\n577                 return S.Zero\n578 \n579             if arg.func == asinh:\n580                 x = arg.args[0]\n581                 return x/sqrt(1 + x**2)\n582 \n583             if arg.func == acosh:\n584                 x = arg.args[0]\n585                 return sqrt(x - 1) * sqrt(x + 1) / x\n586 \n587             if arg.func == atanh:\n588                 return arg.args[0]\n589 \n590             if arg.func == acoth:\n591                 return 1/arg.args[0]\n592 \n593     @staticmethod\n594     @cacheit\n595     def taylor_term(n, x, *previous_terms):\n596         from sympy import bernoulli\n597         if n < 0 or n % 2 == 0:\n598             return S.Zero\n599         else:\n600             x = sympify(x)\n601 \n602             a = 2**(n + 1)\n603 \n604             B = bernoulli(n + 1)\n605             F = factorial(n + 1)\n606 \n607             return a*(a - 1) * B/F * x**n\n608 \n609     def _eval_conjugate(self):\n610         return self.func(self.args[0].conjugate())\n611 \n612     def as_real_imag(self, deep=True, **hints):\n613         from sympy import cos, sin\n614         if self.args[0].is_extended_real:\n615             if deep:\n616                 hints['complex'] = False\n617                 return (self.expand(deep, **hints), S.Zero)\n618             else:\n619                 return (self, S.Zero)\n620         if deep:\n621             re, im = self.args[0].expand(deep, **hints).as_real_imag()\n622         else:\n623             re, im = self.args[0].as_real_imag()\n624         denom = sinh(re)**2 + cos(im)**2\n625         return (sinh(re)*cosh(re)/denom, sin(im)*cos(im)/denom)\n626 \n627     def _eval_expand_trig(self, **hints):\n628         arg = self.args[0]\n629         if arg.is_Add:\n630             from sympy import symmetric_poly\n631             n = len(arg.args)\n632             TX = [tanh(x, evaluate=False)._eval_expand_trig()\n633                 for x in arg.args]\n634             p = [0, 0]  # [den, num]\n635             for i in range(n + 1):\n636                 p[i % 2] += symmetric_poly(i, TX)\n637             return p[1]/p[0]\n638         elif arg.is_Mul:\n639             from sympy.functions.combinatorial.numbers import nC\n640             coeff, terms = arg.as_coeff_Mul()\n641             if coeff.is_Integer and coeff > 1:\n642                 n = []\n643                 d = []\n644                 T = tanh(terms)\n645                 for k in range(1, coeff + 1, 2):\n646                     n.append(nC(range(coeff), k)*T**k)\n647                 for k in range(0, coeff + 1, 2):\n648                     d.append(nC(range(coeff), k)*T**k)\n649                 return Add(*n)/Add(*d)\n650         return tanh(arg)\n651 \n652     def _eval_rewrite_as_tractable(self, arg, limitvar=None, **kwargs):\n653         neg_exp, pos_exp = exp(-arg), exp(arg)\n654         return (pos_exp - neg_exp)/(pos_exp + neg_exp)\n655 \n656     def _eval_rewrite_as_exp(self, arg, **kwargs):\n657         neg_exp, pos_exp = exp(-arg), exp(arg)\n658         return (pos_exp - neg_exp)/(pos_exp + neg_exp)\n659 \n660     def _eval_rewrite_as_sinh(self, arg, **kwargs):\n661         return S.ImaginaryUnit*sinh(arg)/sinh(S.Pi*S.ImaginaryUnit/2 - arg)\n662 \n663     def _eval_rewrite_as_cosh(self, arg, **kwargs):\n664         return S.ImaginaryUnit*cosh(S.Pi*S.ImaginaryUnit/2 - arg)/cosh(arg)\n665 \n666     def _eval_rewrite_as_coth(self, arg, **kwargs):\n667         return 1/coth(arg)\n668 \n669     def _eval_as_leading_term(self, x, cdir=0):\n670         from sympy import Order\n671         arg = self.args[0].as_leading_term(x)\n672 \n673         if x in arg.free_symbols and Order(1, x).contains(arg):\n674             return arg\n675         else:\n676             return self.func(arg)\n677 \n678     def _eval_is_real(self):\n679         arg = self.args[0]\n680         if arg.is_real:\n681             return True\n682 \n683         re, im = arg.as_real_imag()\n684 \n685         # if denom = 0, tanh(arg) = zoo\n686         if re == 0 and im % pi == pi/2:\n687             return None\n688 \n689         # check if im is of the form n*pi/2 to make sin(2*im) = 0\n690         # if not, im could be a number, return False in that case\n691         return (im % (pi/2)).is_zero\n692 \n693     def _eval_is_extended_real(self):\n694         if self.args[0].is_extended_real:\n695             return True\n696 \n697     def _eval_is_positive(self):\n698         if self.args[0].is_extended_real:\n699             return self.args[0].is_positive\n700 \n701     def _eval_is_negative(self):\n702         if self.args[0].is_extended_real:\n703             return self.args[0].is_negative\n704 \n705     def _eval_is_finite(self):\n706         from sympy import sinh, cos\n707         arg = self.args[0]\n708 \n709         re, im = arg.as_real_imag()\n710         denom = cos(im)**2 + sinh(re)**2\n711         if denom == 0:\n712             return False\n713         elif denom.is_number:\n714             return True\n715         if arg.is_extended_real:\n716             return True\n717 \n718     def _eval_is_zero(self):\n719         arg = self.args[0]\n720         if arg.is_zero:\n721             return True\n722 \n723 \n724 class coth(HyperbolicFunction):\n725     r\"\"\"\n726     coth(x) is the hyperbolic cotangent of x.\n727 \n728     The hyperbolic cotangent function is $\\frac{\\cosh(x)}{\\sinh(x)}$.\n729 \n730     Examples\n731     ========\n732 \n733     >>> from sympy import coth\n734     >>> from sympy.abc import x\n735     >>> coth(x)\n736     coth(x)\n737 \n738     See Also\n739     ========\n740 \n741     sinh, cosh, acoth\n742     \"\"\"\n743 \n744     def fdiff(self, argindex=1):\n745         if argindex == 1:\n746             return -1/sinh(self.args[0])**2\n747         else:\n748             raise ArgumentIndexError(self, argindex)\n749 \n750     def inverse(self, argindex=1):\n751         \"\"\"\n752         Returns the inverse of this function.\n753         \"\"\"\n754         return acoth\n755 \n756     @classmethod\n757     def eval(cls, arg):\n758         from sympy import cot\n759         arg = sympify(arg)\n760 \n761         if arg.is_Number:\n762             if arg is S.NaN:\n763                 return S.NaN\n764             elif arg is S.Infinity:\n765                 return S.One\n766             elif arg is S.NegativeInfinity:\n767                 return S.NegativeOne\n768             elif arg.is_zero:\n769                 return S.ComplexInfinity\n770             elif arg.is_negative:\n771                 return -cls(-arg)\n772         else:\n773             if arg is S.ComplexInfinity:\n774                 return S.NaN\n775 \n776             i_coeff = arg.as_coefficient(S.ImaginaryUnit)\n777 \n778             if i_coeff is not None:\n779                 if _coeff_isneg(i_coeff):\n780                     return S.ImaginaryUnit * cot(-i_coeff)\n781                 return -S.ImaginaryUnit * cot(i_coeff)\n782             else:\n783                 if _coeff_isneg(arg):\n784                     return -cls(-arg)\n785 \n786             if arg.is_Add:\n787                 x, m = _peeloff_ipi(arg)\n788                 if m:\n789                     cothm = coth(m)\n790                     if cothm is S.ComplexInfinity:\n791                         return coth(x)\n792                     else: # cothm == 0\n793                         return tanh(x)\n794 \n795             if arg.is_zero:\n796                 return S.ComplexInfinity\n797 \n798             if arg.func == asinh:\n799                 x = arg.args[0]\n800                 return sqrt(1 + x**2)/x\n801 \n802             if arg.func == acosh:\n803                 x = arg.args[0]\n804                 return x/(sqrt(x - 1) * sqrt(x + 1))\n805 \n806             if arg.func == atanh:\n807                 return 1/arg.args[0]\n808 \n809             if arg.func == acoth:\n810                 return arg.args[0]\n811 \n812     @staticmethod\n813     @cacheit\n814     def taylor_term(n, x, *previous_terms):\n815         from sympy import bernoulli\n816         if n == 0:\n817             return 1 / sympify(x)\n818         elif n < 0 or n % 2 == 0:\n819             return S.Zero\n820         else:\n821             x = sympify(x)\n822 \n823             B = bernoulli(n + 1)\n824             F = factorial(n + 1)\n825 \n826             return 2**(n + 1) * B/F * x**n\n827 \n828     def _eval_conjugate(self):\n829         return self.func(self.args[0].conjugate())\n830 \n831     def as_real_imag(self, deep=True, **hints):\n832         from sympy import cos, sin\n833         if self.args[0].is_extended_real:\n834             if deep:\n835                 hints['complex'] = False\n836                 return (self.expand(deep, **hints), S.Zero)\n837             else:\n838                 return (self, S.Zero)\n839         if deep:\n840             re, im = self.args[0].expand(deep, **hints).as_real_imag()\n841         else:\n842             re, im = self.args[0].as_real_imag()\n843         denom = sinh(re)**2 + sin(im)**2\n844         return (sinh(re)*cosh(re)/denom, -sin(im)*cos(im)/denom)\n845 \n846     def _eval_rewrite_as_tractable(self, arg, limitvar=None, **kwargs):\n847         neg_exp, pos_exp = exp(-arg), exp(arg)\n848         return (pos_exp + neg_exp)/(pos_exp - neg_exp)\n849 \n850     def _eval_rewrite_as_exp(self, arg, **kwargs):\n851         neg_exp, pos_exp = exp(-arg), exp(arg)\n852         return (pos_exp + neg_exp)/(pos_exp - neg_exp)\n853 \n854     def _eval_rewrite_as_sinh(self, arg, **kwargs):\n855         return -S.ImaginaryUnit*sinh(S.Pi*S.ImaginaryUnit/2 - arg)/sinh(arg)\n856 \n857     def _eval_rewrite_as_cosh(self, arg, **kwargs):\n858         return -S.ImaginaryUnit*cosh(arg)/cosh(S.Pi*S.ImaginaryUnit/2 - arg)\n859 \n860     def _eval_rewrite_as_tanh(self, arg, **kwargs):\n861         return 1/tanh(arg)\n862 \n863     def _eval_is_positive(self):\n864         if self.args[0].is_extended_real:\n865             return self.args[0].is_positive\n866 \n867     def _eval_is_negative(self):\n868         if self.args[0].is_extended_real:\n869             return self.args[0].is_negative\n870 \n871     def _eval_as_leading_term(self, x, cdir=0):\n872         from sympy import Order\n873         arg = self.args[0].as_leading_term(x)\n874 \n875         if x in arg.free_symbols and Order(1, x).contains(arg):\n876             return 1/arg\n877         else:\n878             return self.func(arg)\n879 \n880 \n881 class ReciprocalHyperbolicFunction(HyperbolicFunction):\n882     \"\"\"Base class for reciprocal functions of hyperbolic functions. \"\"\"\n883 \n884     #To be defined in class\n885     _reciprocal_of = None\n886     _is_even = None  # type: FuzzyBool\n887     _is_odd = None  # type: FuzzyBool\n888 \n889     @classmethod\n890     def eval(cls, arg):\n891         if arg.could_extract_minus_sign():\n892             if cls._is_even:\n893                 return cls(-arg)\n894             if cls._is_odd:\n895                 return -cls(-arg)\n896 \n897         t = cls._reciprocal_of.eval(arg)\n898         if hasattr(arg, 'inverse') and arg.inverse() == cls:\n899             return arg.args[0]\n900         return 1/t if t is not None else t\n901 \n902     def _call_reciprocal(self, method_name, *args, **kwargs):\n903         # Calls method_name on _reciprocal_of\n904         o = self._reciprocal_of(self.args[0])\n905         return getattr(o, method_name)(*args, **kwargs)\n906 \n907     def _calculate_reciprocal(self, method_name, *args, **kwargs):\n908         # If calling method_name on _reciprocal_of returns a value != None\n909         # then return the reciprocal of that value\n910         t = self._call_reciprocal(method_name, *args, **kwargs)\n911         return 1/t if t is not None else t\n912 \n913     def _rewrite_reciprocal(self, method_name, arg):\n914         # Special handling for rewrite functions. If reciprocal rewrite returns\n915         # unmodified expression, then return None\n916         t = self._call_reciprocal(method_name, arg)\n917         if t is not None and t != self._reciprocal_of(arg):\n918             return 1/t\n919 \n920     def _eval_rewrite_as_exp(self, arg, **kwargs):\n921         return self._rewrite_reciprocal(\"_eval_rewrite_as_exp\", arg)\n922 \n923     def _eval_rewrite_as_tractable(self, arg, limitvar=None, **kwargs):\n924         return self._rewrite_reciprocal(\"_eval_rewrite_as_tractable\", arg)\n925 \n926     def _eval_rewrite_as_tanh(self, arg, **kwargs):\n927         return self._rewrite_reciprocal(\"_eval_rewrite_as_tanh\", arg)\n928 \n929     def _eval_rewrite_as_coth(self, arg, **kwargs):\n930         return self._rewrite_reciprocal(\"_eval_rewrite_as_coth\", arg)\n931 \n932     def as_real_imag(self, deep = True, **hints):\n933         return (1 / self._reciprocal_of(self.args[0])).as_real_imag(deep, **hints)\n934 \n935     def _eval_conjugate(self):\n936         return self.func(self.args[0].conjugate())\n937 \n938     def _eval_expand_complex(self, deep=True, **hints):\n939         re_part, im_part = self.as_real_imag(deep=True, **hints)\n940         return re_part + S.ImaginaryUnit*im_part\n941 \n942     def _eval_as_leading_term(self, x, cdir=0):\n943         return (1/self._reciprocal_of(self.args[0]))._eval_as_leading_term(x)\n944 \n945     def _eval_is_extended_real(self):\n946         return self._reciprocal_of(self.args[0]).is_extended_real\n947 \n948     def _eval_is_finite(self):\n949         return (1/self._reciprocal_of(self.args[0])).is_finite\n950 \n951 \n952 class csch(ReciprocalHyperbolicFunction):\n953     r\"\"\"\n954     csch(x) is the hyperbolic cosecant of x.\n955 \n956     The hyperbolic cosecant function is $\\frac{2}{e^x - e^{-x}}$\n957 \n958     Examples\n959     ========\n960 \n961     >>> from sympy import csch\n962     >>> from sympy.abc import x\n963     >>> csch(x)\n964     csch(x)\n965 \n966     See Also\n967     ========\n968 \n969     sinh, cosh, tanh, sech, asinh, acosh\n970     \"\"\"\n971 \n972     _reciprocal_of = sinh\n973     _is_odd = True\n974 \n975     def fdiff(self, argindex=1):\n976         \"\"\"\n977         Returns the first derivative of this function\n978         \"\"\"\n979         if argindex == 1:\n980             return -coth(self.args[0]) * csch(self.args[0])\n981         else:\n982             raise ArgumentIndexError(self, argindex)\n983 \n984     @staticmethod\n985     @cacheit\n986     def taylor_term(n, x, *previous_terms):\n987         \"\"\"\n988         Returns the next term in the Taylor series expansion\n989         \"\"\"\n990         from sympy import bernoulli\n991         if n == 0:\n992             return 1/sympify(x)\n993         elif n < 0 or n % 2 == 0:\n994             return S.Zero\n995         else:\n996             x = sympify(x)\n997 \n998             B = bernoulli(n + 1)\n999             F = factorial(n + 1)\n1000 \n1001             return 2 * (1 - 2**n) * B/F * x**n\n1002 \n1003     def _eval_rewrite_as_cosh(self, arg, **kwargs):\n1004         return S.ImaginaryUnit / cosh(arg + S.ImaginaryUnit * S.Pi / 2)\n1005 \n1006     def _eval_is_positive(self):\n1007         if self.args[0].is_extended_real:\n1008             return self.args[0].is_positive\n1009 \n1010     def _eval_is_negative(self):\n1011         if self.args[0].is_extended_real:\n1012             return self.args[0].is_negative\n1013 \n1014     def _sage_(self):\n1015         import sage.all as sage\n1016         return sage.csch(self.args[0]._sage_())\n1017 \n1018 \n1019 class sech(ReciprocalHyperbolicFunction):\n1020     r\"\"\"\n1021     sech(x) is the hyperbolic secant of x.\n1022 \n1023     The hyperbolic secant function is $\\frac{2}{e^x + e^{-x}}$\n1024 \n1025     Examples\n1026     ========\n1027 \n1028     >>> from sympy import sech\n1029     >>> from sympy.abc import x\n1030     >>> sech(x)\n1031     sech(x)\n1032 \n1033     See Also\n1034     ========\n1035 \n1036     sinh, cosh, tanh, coth, csch, asinh, acosh\n1037     \"\"\"\n1038 \n1039     _reciprocal_of = cosh\n1040     _is_even = True\n1041 \n1042     def fdiff(self, argindex=1):\n1043         if argindex == 1:\n1044             return - tanh(self.args[0])*sech(self.args[0])\n1045         else:\n1046             raise ArgumentIndexError(self, argindex)\n1047 \n1048     @staticmethod\n1049     @cacheit\n1050     def taylor_term(n, x, *previous_terms):\n1051         from sympy.functions.combinatorial.numbers import euler\n1052         if n < 0 or n % 2 == 1:\n1053             return S.Zero\n1054         else:\n1055             x = sympify(x)\n1056             return euler(n) / factorial(n) * x**(n)\n1057 \n1058     def _eval_rewrite_as_sinh(self, arg, **kwargs):\n1059         return S.ImaginaryUnit / sinh(arg + S.ImaginaryUnit * S.Pi /2)\n1060 \n1061     def _eval_is_positive(self):\n1062         if self.args[0].is_extended_real:\n1063             return True\n1064 \n1065     def _sage_(self):\n1066         import sage.all as sage\n1067         return sage.sech(self.args[0]._sage_())\n1068 \n1069 \n1070 \n1071 ###############################################################################\n1072 ############################# HYPERBOLIC INVERSES #############################\n1073 ###############################################################################\n1074 \n1075 class InverseHyperbolicFunction(Function):\n1076     \"\"\"Base class for inverse hyperbolic functions.\"\"\"\n1077 \n1078     pass\n1079 \n1080 \n1081 class asinh(InverseHyperbolicFunction):\n1082     \"\"\"\n1083     asinh(x) is the inverse hyperbolic sine of x.\n1084 \n1085     The inverse hyperbolic sine function.\n1086 \n1087     Examples\n1088     ========\n1089 \n1090     >>> from sympy import asinh\n1091     >>> from sympy.abc import x\n1092     >>> asinh(x).diff(x)\n1093     1/sqrt(x**2 + 1)\n1094     >>> asinh(1)\n1095     log(1 + sqrt(2))\n1096 \n1097     See Also\n1098     ========\n1099 \n1100     acosh, atanh, sinh\n1101     \"\"\"\n1102 \n1103     def fdiff(self, argindex=1):\n1104         if argindex == 1:\n1105             return 1/sqrt(self.args[0]**2 + 1)\n1106         else:\n1107             raise ArgumentIndexError(self, argindex)\n1108 \n1109     @classmethod\n1110     def eval(cls, arg):\n1111         from sympy import asin\n1112         arg = sympify(arg)\n1113 \n1114         if arg.is_Number:\n1115             if arg is S.NaN:\n1116                 return S.NaN\n1117             elif arg is S.Infinity:\n1118                 return S.Infinity\n1119             elif arg is S.NegativeInfinity:\n1120                 return S.NegativeInfinity\n1121             elif arg.is_zero:\n1122                 return S.Zero\n1123             elif arg is S.One:\n1124                 return log(sqrt(2) + 1)\n1125             elif arg is S.NegativeOne:\n1126                 return log(sqrt(2) - 1)\n1127             elif arg.is_negative:\n1128                 return -cls(-arg)\n1129         else:\n1130             if arg is S.ComplexInfinity:\n1131                 return S.ComplexInfinity\n1132 \n1133             if arg.is_zero:\n1134                 return S.Zero\n1135 \n1136             i_coeff = arg.as_coefficient(S.ImaginaryUnit)\n1137 \n1138             if i_coeff is not None:\n1139                 return S.ImaginaryUnit * asin(i_coeff)\n1140             else:\n1141                 if _coeff_isneg(arg):\n1142                     return -cls(-arg)\n1143 \n1144         if isinstance(arg, sinh) and arg.args[0].is_number:\n1145             z = arg.args[0]\n1146             if z.is_real:\n1147                 return z\n1148             r, i = match_real_imag(z)\n1149             if r is not None and i is not None:\n1150                 f = floor((i + pi/2)/pi)\n1151                 m = z - I*pi*f\n1152                 even = f.is_even\n1153                 if even is True:\n1154                     return m\n1155                 elif even is False:\n1156                     return -m\n1157 \n1158     @staticmethod\n1159     @cacheit\n1160     def taylor_term(n, x, *previous_terms):\n1161         if n < 0 or n % 2 == 0:\n1162             return S.Zero\n1163         else:\n1164             x = sympify(x)\n1165             if len(previous_terms) >= 2 and n > 2:\n1166                 p = previous_terms[-2]\n1167                 return -p * (n - 2)**2/(n*(n - 1)) * x**2\n1168             else:\n1169                 k = (n - 1) // 2\n1170                 R = RisingFactorial(S.Half, k)\n1171                 F = factorial(k)\n1172                 return (-1)**k * R / F * x**n / n\n1173 \n1174     def _eval_as_leading_term(self, x, cdir=0):\n1175         from sympy import Order\n1176         arg = self.args[0].as_leading_term(x)\n1177 \n1178         if x in arg.free_symbols and Order(1, x).contains(arg):\n1179             return arg\n1180         else:\n1181             return self.func(arg)\n1182 \n1183     def _eval_rewrite_as_log(self, x, **kwargs):\n1184         return log(x + sqrt(x**2 + 1))\n1185 \n1186     def inverse(self, argindex=1):\n1187         \"\"\"\n1188         Returns the inverse of this function.\n1189         \"\"\"\n1190         return sinh\n1191 \n1192     def _eval_is_zero(self):\n1193         arg = self.args[0]\n1194         if arg.is_zero:\n1195             return True\n1196 \n1197 \n1198 class acosh(InverseHyperbolicFunction):\n1199     \"\"\"\n1200     acosh(x) is the inverse hyperbolic cosine of x.\n1201 \n1202     The inverse hyperbolic cosine function.\n1203 \n1204     Examples\n1205     ========\n1206 \n1207     >>> from sympy import acosh\n1208     >>> from sympy.abc import x\n1209     >>> acosh(x).diff(x)\n1210     1/sqrt(x**2 - 1)\n1211     >>> acosh(1)\n1212     0\n1213 \n1214     See Also\n1215     ========\n1216 \n1217     asinh, atanh, cosh\n1218     \"\"\"\n1219 \n1220     def fdiff(self, argindex=1):\n1221         if argindex == 1:\n1222             return 1/sqrt(self.args[0]**2 - 1)\n1223         else:\n1224             raise ArgumentIndexError(self, argindex)\n1225 \n1226     @classmethod\n1227     def eval(cls, arg):\n1228         arg = sympify(arg)\n1229 \n1230         if arg.is_Number:\n1231             if arg is S.NaN:\n1232                 return S.NaN\n1233             elif arg is S.Infinity:\n1234                 return S.Infinity\n1235             elif arg is S.NegativeInfinity:\n1236                 return S.Infinity\n1237             elif arg.is_zero:\n1238                 return S.Pi*S.ImaginaryUnit / 2\n1239             elif arg is S.One:\n1240                 return S.Zero\n1241             elif arg is S.NegativeOne:\n1242                 return S.Pi*S.ImaginaryUnit\n1243 \n1244         if arg.is_number:\n1245             cst_table = {\n1246                 S.ImaginaryUnit: log(S.ImaginaryUnit*(1 + sqrt(2))),\n1247                 -S.ImaginaryUnit: log(-S.ImaginaryUnit*(1 + sqrt(2))),\n1248                 S.Half: S.Pi/3,\n1249                 Rational(-1, 2): S.Pi*Rational(2, 3),\n1250                 sqrt(2)/2: S.Pi/4,\n1251                 -sqrt(2)/2: S.Pi*Rational(3, 4),\n1252                 1/sqrt(2): S.Pi/4,\n1253                 -1/sqrt(2): S.Pi*Rational(3, 4),\n1254                 sqrt(3)/2: S.Pi/6,\n1255                 -sqrt(3)/2: S.Pi*Rational(5, 6),\n1256                 (sqrt(3) - 1)/sqrt(2**3): S.Pi*Rational(5, 12),\n1257                 -(sqrt(3) - 1)/sqrt(2**3): S.Pi*Rational(7, 12),\n1258                 sqrt(2 + sqrt(2))/2: S.Pi/8,\n1259                 -sqrt(2 + sqrt(2))/2: S.Pi*Rational(7, 8),\n1260                 sqrt(2 - sqrt(2))/2: S.Pi*Rational(3, 8),\n1261                 -sqrt(2 - sqrt(2))/2: S.Pi*Rational(5, 8),\n1262                 (1 + sqrt(3))/(2*sqrt(2)): S.Pi/12,\n1263                 -(1 + sqrt(3))/(2*sqrt(2)): S.Pi*Rational(11, 12),\n1264                 (sqrt(5) + 1)/4: S.Pi/5,\n1265                 -(sqrt(5) + 1)/4: S.Pi*Rational(4, 5)\n1266             }\n1267 \n1268             if arg in cst_table:\n1269                 if arg.is_extended_real:\n1270                     return cst_table[arg]*S.ImaginaryUnit\n1271                 return cst_table[arg]\n1272 \n1273         if arg is S.ComplexInfinity:\n1274             return S.ComplexInfinity\n1275         if arg == S.ImaginaryUnit*S.Infinity:\n1276             return S.Infinity + S.ImaginaryUnit*S.Pi/2\n1277         if arg == -S.ImaginaryUnit*S.Infinity:\n1278             return S.Infinity - S.ImaginaryUnit*S.Pi/2\n1279 \n1280         if arg.is_zero:\n1281             return S.Pi*S.ImaginaryUnit*S.Half\n1282 \n1283         if isinstance(arg, cosh) and arg.args[0].is_number:\n1284             z = arg.args[0]\n1285             if z.is_real:\n1286                 from sympy.functions.elementary.complexes import Abs\n1287                 return Abs(z)\n1288             r, i = match_real_imag(z)\n1289             if r is not None and i is not None:\n1290                 f = floor(i/pi)\n1291                 m = z - I*pi*f\n1292                 even = f.is_even\n1293                 if even is True:\n1294                     if r.is_nonnegative:\n1295                         return m\n1296                     elif r.is_negative:\n1297                         return -m\n1298                 elif even is False:\n1299                     m -= I*pi\n1300                     if r.is_nonpositive:\n1301                         return -m\n1302                     elif r.is_positive:\n1303                         return m\n1304 \n1305     @staticmethod\n1306     @cacheit\n1307     def taylor_term(n, x, *previous_terms):\n1308         if n == 0:\n1309             return S.Pi*S.ImaginaryUnit / 2\n1310         elif n < 0 or n % 2 == 0:\n1311             return S.Zero\n1312         else:\n1313             x = sympify(x)\n1314             if len(previous_terms) >= 2 and n > 2:\n1315                 p = previous_terms[-2]\n1316                 return p * (n - 2)**2/(n*(n - 1)) * x**2\n1317             else:\n1318                 k = (n - 1) // 2\n1319                 R = RisingFactorial(S.Half, k)\n1320                 F = factorial(k)\n1321                 return -R / F * S.ImaginaryUnit * x**n / n\n1322 \n1323     def _eval_as_leading_term(self, x, cdir=0):\n1324         from sympy import Order\n1325         arg = self.args[0].as_leading_term(x)\n1326 \n1327         if x in arg.free_symbols and Order(1, x).contains(arg):\n1328             return S.ImaginaryUnit*S.Pi/2\n1329         else:\n1330             return self.func(arg)\n1331 \n1332     def _eval_rewrite_as_log(self, x, **kwargs):\n1333         return log(x + sqrt(x + 1) * sqrt(x - 1))\n1334 \n1335     def inverse(self, argindex=1):\n1336         \"\"\"\n1337         Returns the inverse of this function.\n1338         \"\"\"\n1339         return cosh\n1340 \n1341 \n1342 class atanh(InverseHyperbolicFunction):\n1343     \"\"\"\n1344     atanh(x) is the inverse hyperbolic tangent of x.\n1345 \n1346     The inverse hyperbolic tangent function.\n1347 \n1348     Examples\n1349     ========\n1350 \n1351     >>> from sympy import atanh\n1352     >>> from sympy.abc import x\n1353     >>> atanh(x).diff(x)\n1354     1/(1 - x**2)\n1355 \n1356     See Also\n1357     ========\n1358 \n1359     asinh, acosh, tanh\n1360     \"\"\"\n1361 \n1362     def fdiff(self, argindex=1):\n1363         if argindex == 1:\n1364             return 1/(1 - self.args[0]**2)\n1365         else:\n1366             raise ArgumentIndexError(self, argindex)\n1367 \n1368     @classmethod\n1369     def eval(cls, arg):\n1370         from sympy import atan\n1371         arg = sympify(arg)\n1372 \n1373         if arg.is_Number:\n1374             if arg is S.NaN:\n1375                 return S.NaN\n1376             elif arg.is_zero:\n1377                 return S.Zero\n1378             elif arg is S.One:\n1379                 return S.Infinity\n1380             elif arg is S.NegativeOne:\n1381                 return S.NegativeInfinity\n1382             elif arg is S.Infinity:\n1383                 return -S.ImaginaryUnit * atan(arg)\n1384             elif arg is S.NegativeInfinity:\n1385                 return S.ImaginaryUnit * atan(-arg)\n1386             elif arg.is_negative:\n1387                 return -cls(-arg)\n1388         else:\n1389             if arg is S.ComplexInfinity:\n1390                 from sympy.calculus.util import AccumBounds\n1391                 return S.ImaginaryUnit*AccumBounds(-S.Pi/2, S.Pi/2)\n1392 \n1393             i_coeff = arg.as_coefficient(S.ImaginaryUnit)\n1394 \n1395             if i_coeff is not None:\n1396                 return S.ImaginaryUnit * atan(i_coeff)\n1397             else:\n1398                 if _coeff_isneg(arg):\n1399                     return -cls(-arg)\n1400 \n1401         if arg.is_zero:\n1402             return S.Zero\n1403 \n1404         if isinstance(arg, tanh) and arg.args[0].is_number:\n1405             z = arg.args[0]\n1406             if z.is_real:\n1407                 return z\n1408             r, i = match_real_imag(z)\n1409             if r is not None and i is not None:\n1410                 f = floor(2*i/pi)\n1411                 even = f.is_even\n1412                 m = z - I*f*pi/2\n1413                 if even is True:\n1414                     return m\n1415                 elif even is False:\n1416                     return m - I*pi/2\n1417 \n1418     @staticmethod\n1419     @cacheit\n1420     def taylor_term(n, x, *previous_terms):\n1421         if n < 0 or n % 2 == 0:\n1422             return S.Zero\n1423         else:\n1424             x = sympify(x)\n1425             return x**n / n\n1426 \n1427     def _eval_as_leading_term(self, x, cdir=0):\n1428         from sympy import Order\n1429         arg = self.args[0].as_leading_term(x)\n1430 \n1431         if x in arg.free_symbols and Order(1, x).contains(arg):\n1432             return arg\n1433         else:\n1434             return self.func(arg)\n1435 \n1436     def _eval_rewrite_as_log(self, x, **kwargs):\n1437         return (log(1 + x) - log(1 - x)) / 2\n1438 \n1439     def _eval_is_zero(self):\n1440         arg = self.args[0]\n1441         if arg.is_zero:\n1442             return True\n1443 \n1444 \n1445     def inverse(self, argindex=1):\n1446         \"\"\"\n1447         Returns the inverse of this function.\n1448         \"\"\"\n1449         return tanh\n1450 \n1451 \n1452 class acoth(InverseHyperbolicFunction):\n1453     \"\"\"\n1454     acoth(x) is the inverse hyperbolic cotangent of x.\n1455 \n1456     The inverse hyperbolic cotangent function.\n1457 \n1458     Examples\n1459     ========\n1460 \n1461     >>> from sympy import acoth\n1462     >>> from sympy.abc import x\n1463     >>> acoth(x).diff(x)\n1464     1/(1 - x**2)\n1465 \n1466     See Also\n1467     ========\n1468 \n1469     asinh, acosh, coth\n1470     \"\"\"\n1471 \n1472     def fdiff(self, argindex=1):\n1473         if argindex == 1:\n1474             return 1/(1 - self.args[0]**2)\n1475         else:\n1476             raise ArgumentIndexError(self, argindex)\n1477 \n1478     @classmethod\n1479     def eval(cls, arg):\n1480         from sympy import acot\n1481         arg = sympify(arg)\n1482 \n1483         if arg.is_Number:\n1484             if arg is S.NaN:\n1485                 return S.NaN\n1486             elif arg is S.Infinity:\n1487                 return S.Zero\n1488             elif arg is S.NegativeInfinity:\n1489                 return S.Zero\n1490             elif arg.is_zero:\n1491                 return S.Pi*S.ImaginaryUnit / 2\n1492             elif arg is S.One:\n1493                 return S.Infinity\n1494             elif arg is S.NegativeOne:\n1495                 return S.NegativeInfinity\n1496             elif arg.is_negative:\n1497                 return -cls(-arg)\n1498         else:\n1499             if arg is S.ComplexInfinity:\n1500                 return S.Zero\n1501 \n1502             i_coeff = arg.as_coefficient(S.ImaginaryUnit)\n1503 \n1504             if i_coeff is not None:\n1505                 return -S.ImaginaryUnit * acot(i_coeff)\n1506             else:\n1507                 if _coeff_isneg(arg):\n1508                     return -cls(-arg)\n1509 \n1510         if arg.is_zero:\n1511             return S.Pi*S.ImaginaryUnit*S.Half\n1512 \n1513     @staticmethod\n1514     @cacheit\n1515     def taylor_term(n, x, *previous_terms):\n1516         if n == 0:\n1517             return S.Pi*S.ImaginaryUnit / 2\n1518         elif n < 0 or n % 2 == 0:\n1519             return S.Zero\n1520         else:\n1521             x = sympify(x)\n1522             return x**n / n\n1523 \n1524     def _eval_as_leading_term(self, x, cdir=0):\n1525         from sympy import Order\n1526         arg = self.args[0].as_leading_term(x)\n1527 \n1528         if x in arg.free_symbols and Order(1, x).contains(arg):\n1529             return S.ImaginaryUnit*S.Pi/2\n1530         else:\n1531             return self.func(arg)\n1532 \n1533     def _eval_rewrite_as_log(self, x, **kwargs):\n1534         return (log(1 + 1/x) - log(1 - 1/x)) / 2\n1535 \n1536     def inverse(self, argindex=1):\n1537         \"\"\"\n1538         Returns the inverse of this function.\n1539         \"\"\"\n1540         return coth\n1541 \n1542 \n1543 class asech(InverseHyperbolicFunction):\n1544     \"\"\"\n1545     asech(x) is the inverse hyperbolic secant of x.\n1546 \n1547     The inverse hyperbolic secant function.\n1548 \n1549     Examples\n1550     ========\n1551 \n1552     >>> from sympy import asech, sqrt, S\n1553     >>> from sympy.abc import x\n1554     >>> asech(x).diff(x)\n1555     -1/(x*sqrt(1 - x**2))\n1556     >>> asech(1).diff(x)\n1557     0\n1558     >>> asech(1)\n1559     0\n1560     >>> asech(S(2))\n1561     I*pi/3\n1562     >>> asech(-sqrt(2))\n1563     3*I*pi/4\n1564     >>> asech((sqrt(6) - sqrt(2)))\n1565     I*pi/12\n1566 \n1567     See Also\n1568     ========\n1569 \n1570     asinh, atanh, cosh, acoth\n1571 \n1572     References\n1573     ==========\n1574 \n1575     .. [1] https://en.wikipedia.org/wiki/Hyperbolic_function\n1576     .. [2] http://dlmf.nist.gov/4.37\n1577     .. [3] http://functions.wolfram.com/ElementaryFunctions/ArcSech/\n1578 \n1579     \"\"\"\n1580 \n1581     def fdiff(self, argindex=1):\n1582         if argindex == 1:\n1583             z = self.args[0]\n1584             return -1/(z*sqrt(1 - z**2))\n1585         else:\n1586             raise ArgumentIndexError(self, argindex)\n1587 \n1588     @classmethod\n1589     def eval(cls, arg):\n1590         arg = sympify(arg)\n1591 \n1592         if arg.is_Number:\n1593             if arg is S.NaN:\n1594                 return S.NaN\n1595             elif arg is S.Infinity:\n1596                 return S.Pi*S.ImaginaryUnit / 2\n1597             elif arg is S.NegativeInfinity:\n1598                 return S.Pi*S.ImaginaryUnit / 2\n1599             elif arg.is_zero:\n1600                 return S.Infinity\n1601             elif arg is S.One:\n1602                 return S.Zero\n1603             elif arg is S.NegativeOne:\n1604                 return S.Pi*S.ImaginaryUnit\n1605 \n1606         if arg.is_number:\n1607             cst_table = {\n1608                 S.ImaginaryUnit: - (S.Pi*S.ImaginaryUnit / 2) + log(1 + sqrt(2)),\n1609                 -S.ImaginaryUnit: (S.Pi*S.ImaginaryUnit / 2) + log(1 + sqrt(2)),\n1610                 (sqrt(6) - sqrt(2)): S.Pi / 12,\n1611                 (sqrt(2) - sqrt(6)): 11*S.Pi / 12,\n1612                 sqrt(2 - 2/sqrt(5)): S.Pi / 10,\n1613                 -sqrt(2 - 2/sqrt(5)): 9*S.Pi / 10,\n1614                 2 / sqrt(2 + sqrt(2)): S.Pi / 8,\n1615                 -2 / sqrt(2 + sqrt(2)): 7*S.Pi / 8,\n1616                 2 / sqrt(3): S.Pi / 6,\n1617                 -2 / sqrt(3): 5*S.Pi / 6,\n1618                 (sqrt(5) - 1): S.Pi / 5,\n1619                 (1 - sqrt(5)): 4*S.Pi / 5,\n1620                 sqrt(2): S.Pi / 4,\n1621                 -sqrt(2): 3*S.Pi / 4,\n1622                 sqrt(2 + 2/sqrt(5)): 3*S.Pi / 10,\n1623                 -sqrt(2 + 2/sqrt(5)): 7*S.Pi / 10,\n1624                 S(2): S.Pi / 3,\n1625                 -S(2): 2*S.Pi / 3,\n1626                 sqrt(2*(2 + sqrt(2))): 3*S.Pi / 8,\n1627                 -sqrt(2*(2 + sqrt(2))): 5*S.Pi / 8,\n1628                 (1 + sqrt(5)): 2*S.Pi / 5,\n1629                 (-1 - sqrt(5)): 3*S.Pi / 5,\n1630                 (sqrt(6) + sqrt(2)): 5*S.Pi / 12,\n1631                 (-sqrt(6) - sqrt(2)): 7*S.Pi / 12,\n1632             }\n1633 \n1634             if arg in cst_table:\n1635                 if arg.is_extended_real:\n1636                     return cst_table[arg]*S.ImaginaryUnit\n1637                 return cst_table[arg]\n1638 \n1639         if arg is S.ComplexInfinity:\n1640             from sympy.calculus.util import AccumBounds\n1641             return S.ImaginaryUnit*AccumBounds(-S.Pi/2, S.Pi/2)\n1642 \n1643         if arg.is_zero:\n1644             return S.Infinity\n1645 \n1646     @staticmethod\n1647     @cacheit\n1648     def expansion_term(n, x, *previous_terms):\n1649         if n == 0:\n1650             return log(2 / x)\n1651         elif n < 0 or n % 2 == 1:\n1652             return S.Zero\n1653         else:\n1654             x = sympify(x)\n1655             if len(previous_terms) > 2 and n > 2:\n1656                 p = previous_terms[-2]\n1657                 return p * (n - 1)**2 // (n // 2)**2 * x**2 / 4\n1658             else:\n1659                 k = n // 2\n1660                 R = RisingFactorial(S.Half , k) *  n\n1661                 F = factorial(k) * n // 2 * n // 2\n1662                 return -1 * R / F * x**n / 4\n1663 \n1664     def inverse(self, argindex=1):\n1665         \"\"\"\n1666         Returns the inverse of this function.\n1667         \"\"\"\n1668         return sech\n1669 \n1670     def _eval_rewrite_as_log(self, arg, **kwargs):\n1671         return log(1/arg + sqrt(1/arg - 1) * sqrt(1/arg + 1))\n1672 \n1673 \n1674 class acsch(InverseHyperbolicFunction):\n1675     \"\"\"\n1676     acsch(x) is the inverse hyperbolic cosecant of x.\n1677 \n1678     The inverse hyperbolic cosecant function.\n1679 \n1680     Examples\n1681     ========\n1682 \n1683     >>> from sympy import acsch, sqrt, S\n1684     >>> from sympy.abc import x\n1685     >>> acsch(x).diff(x)\n1686     -1/(x**2*sqrt(1 + x**(-2)))\n1687     >>> acsch(1).diff(x)\n1688     0\n1689     >>> acsch(1)\n1690     log(1 + sqrt(2))\n1691     >>> acsch(S.ImaginaryUnit)\n1692     -I*pi/2\n1693     >>> acsch(-2*S.ImaginaryUnit)\n1694     I*pi/6\n1695     >>> acsch(S.ImaginaryUnit*(sqrt(6) - sqrt(2)))\n1696     -5*I*pi/12\n1697 \n1698     See Also\n1699     ========\n1700 \n1701     asinh\n1702 \n1703     References\n1704     ==========\n1705 \n1706     .. [1] https://en.wikipedia.org/wiki/Hyperbolic_function\n1707     .. [2] http://dlmf.nist.gov/4.37\n1708     .. [3] http://functions.wolfram.com/ElementaryFunctions/ArcCsch/\n1709 \n1710     \"\"\"\n1711 \n1712     def fdiff(self, argindex=1):\n1713         if argindex == 1:\n1714             z = self.args[0]\n1715             return -1/(z**2*sqrt(1 + 1/z**2))\n1716         else:\n1717             raise ArgumentIndexError(self, argindex)\n1718 \n1719     @classmethod\n1720     def eval(cls, arg):\n1721         arg = sympify(arg)\n1722 \n1723         if arg.is_Number:\n1724             if arg is S.NaN:\n1725                 return S.NaN\n1726             elif arg is S.Infinity:\n1727                 return S.Zero\n1728             elif arg is S.NegativeInfinity:\n1729                 return S.Zero\n1730             elif arg.is_zero:\n1731                 return S.ComplexInfinity\n1732             elif arg is S.One:\n1733                 return log(1 + sqrt(2))\n1734             elif arg is S.NegativeOne:\n1735                 return - log(1 + sqrt(2))\n1736 \n1737         if arg.is_number:\n1738             cst_table = {\n1739                 S.ImaginaryUnit: -S.Pi / 2,\n1740                 S.ImaginaryUnit*(sqrt(2) + sqrt(6)): -S.Pi / 12,\n1741                 S.ImaginaryUnit*(1 + sqrt(5)): -S.Pi / 10,\n1742                 S.ImaginaryUnit*2 / sqrt(2 - sqrt(2)): -S.Pi / 8,\n1743                 S.ImaginaryUnit*2: -S.Pi / 6,\n1744                 S.ImaginaryUnit*sqrt(2 + 2/sqrt(5)): -S.Pi / 5,\n1745                 S.ImaginaryUnit*sqrt(2): -S.Pi / 4,\n1746                 S.ImaginaryUnit*(sqrt(5)-1): -3*S.Pi / 10,\n1747                 S.ImaginaryUnit*2 / sqrt(3): -S.Pi / 3,\n1748                 S.ImaginaryUnit*2 / sqrt(2 + sqrt(2)): -3*S.Pi / 8,\n1749                 S.ImaginaryUnit*sqrt(2 - 2/sqrt(5)): -2*S.Pi / 5,\n1750                 S.ImaginaryUnit*(sqrt(6) - sqrt(2)): -5*S.Pi / 12,\n1751                 S(2): -S.ImaginaryUnit*log((1+sqrt(5))/2),\n1752             }\n1753 \n1754             if arg in cst_table:\n1755                 return cst_table[arg]*S.ImaginaryUnit\n1756 \n1757         if arg is S.ComplexInfinity:\n1758             return S.Zero\n1759 \n1760         if arg.is_zero:\n1761             return S.ComplexInfinity\n1762 \n1763         if _coeff_isneg(arg):\n1764             return -cls(-arg)\n1765 \n1766     def inverse(self, argindex=1):\n1767         \"\"\"\n1768         Returns the inverse of this function.\n1769         \"\"\"\n1770         return csch\n1771 \n1772     def _eval_rewrite_as_log(self, arg, **kwargs):\n1773         return log(1/arg + sqrt(1/arg**2 + 1))\n",
        "intended_behavior": "This file and specifically the classes or methods handling `csch` and `sech` should be modified to include logic that allows the `expand_trig` function to expand these functions correctly. This includes identifying the trigonometric identities for `csch` and `sech` that allow them to be expanded in a manner similar to `csc` and `sec`. The intended behavior is to ensure that when `expand_trig` is called with an expression involving `csch` or `sech`, the function returns an expanded form based on the appropriate identities, thus extending the `expand_trig` utility to cover these hyperbolic functions."
    },
    {
        "rel_file_path": "sympy/core/function.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sympy__sympy/setup_sympy__sympy__1.9/sympy/core/function.py",
        "start": 2960,
        "end": 2975,
        "class_name": null,
        "method_name": "expand_trig",
        "code": "2960 def expand_trig(expr, deep=True):\n2961     \"\"\"\n2962     Wrapper around expand that only uses the trig hint.  See the expand\n2963     docstring for more information.\n2964 \n2965     Examples\n2966     ========\n2967 \n2968     >>> from sympy import expand_trig, sin\n2969     >>> from sympy.abc import x, y\n2970     >>> expand_trig(sin(x+y)*(x+y))\n2971     (x + y)*(sin(x)*cos(y) + sin(y)*cos(x))\n2972 \n2973     \"\"\"\n2974     return sympify(expr).expand(deep=deep, trig=True, basic=False,\n2975     log=False, mul=False, power_exp=False, power_base=False, multinomial=False)\n",
        "intended_behavior": "Although the primary logic to expand `csch` and `sech` might reside in `hyperbolic.py`, the `expand_trig` method itself may require adjustments or enhancements to ensure it correctly invokes the relevant expansion rules for hyperbolic functions. The method should be capable of recognizing when an expression contains `csch` or `sech` and apply the expansion logic defined in their respective implementations. This ensures that `expand_trig` remains a comprehensive tool for expanding trigonometric expressions, including both traditional and hyperbolic trigonometric functions."
    }
]