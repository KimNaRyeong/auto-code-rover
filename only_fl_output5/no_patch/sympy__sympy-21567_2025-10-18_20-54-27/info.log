2025-10-18 20:54:27.673 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-18 20:54:38.470 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=289, output_tokens=12, cost=0.003250
2025-10-18 20:54:53.564 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=469, output_tokens=533, cost=0.020680
2025-10-18 20:54:54.929 | INFO     | registered non reproducing test 0
2025-10-18 20:55:07.200 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1400, output_tokens=589, cost=0.031670
2025-10-18 20:55:08.454 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 20:55:09.902 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=594, output_tokens=35, cost=0.006990
2025-10-18 20:55:09.905 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 20:55:13.486 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=389, output_tokens=32, cost=0.004850
2025-10-18 20:55:13.487 | DEBUG    | Extracted a valid json.
2025-10-18 20:55:13.487 | DEBUG    | Agent proxy return the following json: {
    "API_calls": ["search_method(\"expand_trig\")", "search_class(\"TrigonometricFunction\")"],
    "bug_locations": []
}
2025-10-18 20:55:13.509 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-18 20:55:13.509 | DEBUG    | <Agent search> Analyzing search results.
2025-10-18 20:55:30.006 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1123, output_tokens=697, cost=0.032140
2025-10-18 20:55:30.021 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 20:55:38.507 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2036, output_tokens=407, cost=0.032570
2025-10-18 20:55:38.515 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 20:55:48.581 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=761, output_tokens=336, cost=0.017690
2025-10-18 20:55:48.582 | DEBUG    | Extracted a valid json.
2025-10-18 20:55:48.582 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_method(\"csch\")",
        "search_method(\"sech\")"
    ],
    "bug_locations": [
        {
            "file": "sympy/core/function.py",
            "class": "N/A",
            "method": "expand_trig",
            "intended_behavior": "expand_trig should include additional logic for expanding the hyperbolic trigonometric functions csch and sech. This involves understanding and applying the trigonometric identities for csch(x + y) and sech(x + y) similarly to how csc and sec are expanded. The method needs to preserve its current functionality for other trigonometric functions while adding new cases for csch and sech. These cases should transform csch(x + y) and sech(x + y) into their expanded forms using the appropriate identities, enhancing the method's utility for a broader range of trigonometric expressions."
        },
        {
            "file": "sympy/functions/elementary/trigonometric.py",
            "class": "Potentially within TrigonometricFunction or a class specific to hyperbolic functions if such exists.",
            "method": "N/A",
            "intended_behavior": "If the expansion logic for csch and sech functions directly relates to their class definitions (for example, through a method that is used by expand_trig), it may be necessary to modify this class or an associated hyperbolic function class. This could involve adding or improving methods to support the expansion of these functions, making sure the behavior is consistent with trigonometric identities."
        }
    ]
}
2025-10-18 20:55:48.590 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-18 20:55:48.591 | DEBUG    | <Agent search> Analyzing search results.
2025-10-18 20:56:01.502 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2594, output_tokens=575, cost=0.043190
2025-10-18 20:56:01.508 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 20:56:06.940 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=3385, output_tokens=205, cost=0.040000
2025-10-18 20:56:06.945 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 20:56:10.199 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=559, output_tokens=22, cost=0.006250
2025-10-18 20:56:10.200 | DEBUG    | Extracted a valid json.
2025-10-18 20:56:10.200 | DEBUG    | Agent proxy return the following json: {
    "API_calls": ["search_code(\"hyperbolic\")"],
    "bug_locations": []
}
2025-10-18 20:56:10.898 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-18 20:56:10.898 | DEBUG    | <Agent search> Analyzing search results.
2025-10-18 20:56:24.486 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=4581, output_tokens=584, cost=0.063330
2025-10-18 20:56:24.492 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 20:56:35.033 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=5381, output_tokens=440, cost=0.067010
2025-10-18 20:56:35.041 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 20:56:44.365 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=794, output_tokens=339, cost=0.018110
2025-10-18 20:56:44.366 | DEBUG    | Extracted a valid json.
2025-10-18 20:56:44.366 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "sympy/functions/elementary/hyperbolic.py",
            "class": "",
            "method": "",
            "intended_behavior": "This file and specifically the classes or methods handling `csch` and `sech` should be modified to include logic that allows the `expand_trig` function to expand these functions correctly. This includes identifying the trigonometric identities for `csch` and `sech` that allow them to be expanded in a manner similar to `csc` and `sec`. The intended behavior is to ensure that when `expand_trig` is called with an expression involving `csch` or `sech`, the function returns an expanded form based on the appropriate identities, thus extending the `expand_trig` utility to cover these hyperbolic functions."
        },
        {
            "file": "sympy/core/function.py",
            "class": "",
            "method": "expand_trig",
            "intended_behavior": "Although the primary logic to expand `csch` and `sech` might reside in `hyperbolic.py`, the `expand_trig` method itself may require adjustments or enhancements to ensure it correctly invokes the relevant expansion rules for hyperbolic functions. The method should be capable of recognizing when an expression contains `csch` or `sech` and apply the expansion logic defined in their respective implementations. This ensures that `expand_trig` remains a comprehensive tool for expanding trigonometric expressions, including both traditional and hyperbolic trigonometric functions."
        }
    ]
}
2025-10-18 20:56:44.376 | DEBUG    | Bug location extracted successfully: [<file>sympy/functions/elementary/hyperbolic.py</file>
<class>None</class>
<method>None</method>
<code>
1 from sympy.core.logic import FuzzyBool
2 
3 from sympy.core import S, sympify, cacheit, pi, I, Rational
4 from sympy.core.add import Add
5 from sympy.core.function import Function, ArgumentIndexError, _coeff_isneg
6 from sympy.functions.combinatorial.factorials import factorial, RisingFactorial
7 from sympy.functions.elementary.exponential import exp, log, match_real_imag
8 from sympy.functions.elementary.miscellaneous import sqrt
9 from sympy.functions.elementary.integers import floor
10 
11 from sympy.core.logic import fuzzy_or, fuzzy_and
12 
13 
14 
15 def _rewrite_hyperbolics_as_exp(expr):
16     expr = sympify(expr)
17     return expr.xreplace({h: h.rewrite(exp)
18         for h in expr.atoms(HyperbolicFunction)})
19 
20 
21 ###############################################################################
22 ########################### HYPERBOLIC FUNCTIONS ##############################
23 ###############################################################################
24 
25 
26 class HyperbolicFunction(Function):
27     """
28     Base class for hyperbolic functions.
29 
30     See Also
31     ========
32 
33     sinh, cosh, tanh, coth
34     """
35 
36     unbranched = True
37 
38 
39 def _peeloff_ipi(arg):
40     """
41     Split ARG into two parts, a "rest" and a multiple of I*pi/2.
42     This assumes ARG to be an Add.
43     The multiple of I*pi returned in the second position is always a Rational.
44 
45     Examples
46     ========
47 
48     >>> from sympy.functions.elementary.hyperbolic import _peeloff_ipi as peel
49     >>> from sympy import pi, I
50     >>> from sympy.abc import x, y
51     >>> peel(x + I*pi/2)
52     (x, I*pi/2)
53     >>> peel(x + I*2*pi/3 + I*pi*y)
54     (x + I*pi*y + I*pi/6, I*pi/2)
55     """
56     for a in Add.make_args(arg):
57         if a == S.Pi*S.ImaginaryUnit:
58             K = S.One
59             break
60         elif a.is_Mul:
61             K, p = a.as_two_terms()
62             if p == S.Pi*S.ImaginaryUnit and K.is_Rational:
63                 break
64     else:
65         return arg, S.Zero
66 
67     m1 = (K % S.Half)*S.Pi*S.ImaginaryUnit
68     m2 = K*S.Pi*S.ImaginaryUnit - m1
69     return arg - m2, m2
70 
71 
72 class sinh(HyperbolicFunction):
73     r"""
74     sinh(x) is the hyperbolic sine of x.
75 
76     The hyperbolic sine function is $\frac{e^x - e^{-x}}{2}$.
77 
78     Examples
79     ========
80 
81     >>> from sympy import sinh
82     >>> from sympy.abc import x
83     >>> sinh(x)
84     sinh(x)
85 
86     See Also
87     ========
88 
89     cosh, tanh, asinh
90     """
91 
92     def fdiff(self, argindex=1):
93         """
94         Returns the first derivative of this function.
95         """
96         if argindex == 1:
97             return cosh(self.args[0])
98         else:
99             raise ArgumentIndexError(self, argindex)
100 
101     def inverse(self, argindex=1):
102         """
103         Returns the inverse of this function.
104         """
105         return asinh
106 
107     @classmethod
108     def eval(cls, arg):
109         from sympy import sin
110 
111         arg = sympify(arg)
112 
113         if arg.is_Number:
114             if arg is S.NaN:
115                 return S.NaN
116             elif arg is S.Infinity:
117                 return S.Infinity
118             elif arg is S.NegativeInfinity:
119                 return S.NegativeInfinity
120             elif arg.is_zero:
121                 return S.Zero
122             elif arg.is_negative:
123                 return -cls(-arg)
124         else:
125             if arg is S.ComplexInfinity:
126                 return S.NaN
127 
128             i_coeff = arg.as_coefficient(S.ImaginaryUnit)
129 
130             if i_coeff is not None:
131                 return S.ImaginaryUnit * sin(i_coeff)
132             else:
133                 if _coeff_isneg(arg):
134                     return -cls(-arg)
135 
136             if arg.is_Add:
137                 x, m = _peeloff_ipi(arg)
138                 if m:
139                     return sinh(m)*cosh(x) + cosh(m)*sinh(x)
140 
141             if arg.is_zero:
142                 return S.Zero
143 
144             if arg.func == asinh:
145                 return arg.args[0]
146 
147             if arg.func == acosh:
148                 x = arg.args[0]
149                 return sqrt(x - 1) * sqrt(x + 1)
150 
151             if arg.func == atanh:
152                 x = arg.args[0]
153                 return x/sqrt(1 - x**2)
154 
155             if arg.func == acoth:
156                 x = arg.args[0]
157                 return 1/(sqrt(x - 1) * sqrt(x + 1))
158 
159     @staticmethod
160     @cacheit
161     def taylor_term(n, x, *previous_terms):
162         """
163         Returns the next term in the Taylor series expansion.
164         """
165         if n < 0 or n % 2 == 0:
166             return S.Zero
167         else:
168             x = sympify(x)
169 
170             if len(previous_terms) > 2:
171                 p = previous_terms[-2]
172                 return p * x**2 / (n*(n - 1))
173             else:
174                 return x**(n) / factorial(n)
175 
176     def _eval_conjugate(self):
177         return self.func(self.args[0].conjugate())
178 
179     def as_real_imag(self, deep=True, **hints):
180         """
181         Returns this function as a complex coordinate.
182         """
183         from sympy import cos, sin
184         if self.args[0].is_extended_real:
185             if deep:
186                 hints['complex'] = False
187                 return (self.expand(deep, **hints), S.Zero)
188             else:
189                 return (self, S.Zero)
190         if deep:
191             re, im = self.args[0].expand(deep, **hints).as_real_imag()
192         else:
193             re, im = self.args[0].as_real_imag()
194         return (sinh(re)*cos(im), cosh(re)*sin(im))
195 
196     def _eval_expand_complex(self, deep=True, **hints):
197         re_part, im_part = self.as_real_imag(deep=deep, **hints)
198         return re_part + im_part*S.ImaginaryUnit
199 
200     def _eval_expand_trig(self, deep=True, **hints):
201         if deep:
202             arg = self.args[0].expand(deep, **hints)
203         else:
204             arg = self.args[0]
205         x = None
206         if arg.is_Add: # TODO, implement more if deep stuff here
207             x, y = arg.as_two_terms()
208         else:
209             coeff, terms = arg.as_coeff_Mul(rational=True)
210             if coeff is not S.One and coeff.is_Integer and terms is not S.One:
211                 x = terms
212                 y = (coeff - 1)*x
213         if x is not None:
214             return (sinh(x)*cosh(y) + sinh(y)*cosh(x)).expand(trig=True)
215         return sinh(arg)
216 
217     def _eval_rewrite_as_tractable(self, arg, limitvar=None, **kwargs):
218         return (exp(arg) - exp(-arg)) / 2
219 
220     def _eval_rewrite_as_exp(self, arg, **kwargs):
221         return (exp(arg) - exp(-arg)) / 2
222 
223     def _eval_rewrite_as_cosh(self, arg, **kwargs):
224         return -S.ImaginaryUnit*cosh(arg + S.Pi*S.ImaginaryUnit/2)
225 
226     def _eval_rewrite_as_tanh(self, arg, **kwargs):
227         tanh_half = tanh(S.Half*arg)
228         return 2*tanh_half/(1 - tanh_half**2)
229 
230     def _eval_rewrite_as_coth(self, arg, **kwargs):
231         coth_half = coth(S.Half*arg)
232         return 2*coth_half/(coth_half**2 - 1)
233 
234     def _eval_as_leading_term(self, x, cdir=0):
235         from sympy import Order
236         arg = self.args[0].as_leading_term(x)
237 
238         if x in arg.free_symbols and Order(1, x).contains(arg):
239             return arg
240         else:
241             return self.func(arg)
242 
243     def _eval_is_real(self):
244         arg = self.args[0]
245         if arg.is_real:
246             return True
247 
248         # if `im` is of the form n*pi
249         # else, check if it is a number
250         re, im = arg.as_real_imag()
251         return (im%pi).is_zero
252 
253     def _eval_is_extended_real(self):
254         if self.args[0].is_extended_real:
255             return True
256 
257     def _eval_is_positive(self):
258         if self.args[0].is_extended_real:
259             return self.args[0].is_positive
260 
261     def _eval_is_negative(self):
262         if self.args[0].is_extended_real:
263             return self.args[0].is_negative
264 
265     def _eval_is_finite(self):
266         arg = self.args[0]
267         return arg.is_finite
268 
269     def _eval_is_zero(self):
270         arg = self.args[0]
271         if arg.is_zero:
272             return True
273 
274 
275 class cosh(HyperbolicFunction):
276     r"""
277     cosh(x) is the hyperbolic cosine of x.
278 
279     The hyperbolic cosine function is $\frac{e^x + e^{-x}}{2}$.
280 
281     Examples
282     ========
283 
284     >>> from sympy import cosh
285     >>> from sympy.abc import x
286     >>> cosh(x)
287     cosh(x)
288 
289     See Also
290     ========
291 
292     sinh, tanh, acosh
293     """
294 
295     def fdiff(self, argindex=1):
296         if argindex == 1:
297             return sinh(self.args[0])
298         else:
299             raise ArgumentIndexError(self, argindex)
300 
301     @classmethod
302     def eval(cls, arg):
303         from sympy import cos
304         arg = sympify(arg)
305 
306         if arg.is_Number:
307             if arg is S.NaN:
308                 return S.NaN
309             elif arg is S.Infinity:
310                 return S.Infinity
311             elif arg is S.NegativeInfinity:
312                 return S.Infinity
313             elif arg.is_zero:
314                 return S.One
315             elif arg.is_negative:
316                 return cls(-arg)
317         else:
318             if arg is S.ComplexInfinity:
319                 return S.NaN
320 
321             i_coeff = arg.as_coefficient(S.ImaginaryUnit)
322 
323             if i_coeff is not None:
324                 return cos(i_coeff)
325             else:
326                 if _coeff_isneg(arg):
327                     return cls(-arg)
328 
329             if arg.is_Add:
330                 x, m = _peeloff_ipi(arg)
331                 if m:
332                     return cosh(m)*cosh(x) + sinh(m)*sinh(x)
333 
334             if arg.is_zero:
335                 return S.One
336 
337             if arg.func == asinh:
338                 return sqrt(1 + arg.args[0]**2)
339 
340             if arg.func == acosh:
341                 return arg.args[0]
342 
343             if arg.func == atanh:
344                 return 1/sqrt(1 - arg.args[0]**2)
345 
346             if arg.func == acoth:
347                 x = arg.args[0]
348                 return x/(sqrt(x - 1) * sqrt(x + 1))
349 
350     @staticmethod
351     @cacheit
352     def taylor_term(n, x, *previous_terms):
353         if n < 0 or n % 2 == 1:
354             return S.Zero
355         else:
356             x = sympify(x)
357 
358             if len(previous_terms) > 2:
359                 p = previous_terms[-2]
360                 return p * x**2 / (n*(n - 1))
361             else:
362                 return x**(n)/factorial(n)
363 
364     def _eval_conjugate(self):
365         return self.func(self.args[0].conjugate())
366 
367     def as_real_imag(self, deep=True, **hints):
368         from sympy import cos, sin
369         if self.args[0].is_extended_real:
370             if deep:
371                 hints['complex'] = False
372                 return (self.expand(deep, **hints), S.Zero)
373             else:
374                 return (self, S.Zero)
375         if deep:
376             re, im = self.args[0].expand(deep, **hints).as_real_imag()
377         else:
378             re, im = self.args[0].as_real_imag()
379 
380         return (cosh(re)*cos(im), sinh(re)*sin(im))
381 
382     def _eval_expand_complex(self, deep=True, **hints):
383         re_part, im_part = self.as_real_imag(deep=deep, **hints)
384         return re_part + im_part*S.ImaginaryUnit
385 
386     def _eval_expand_trig(self, deep=True, **hints):
387         if deep:
388             arg = self.args[0].expand(deep, **hints)
389         else:
390             arg = self.args[0]
391         x = None
392         if arg.is_Add: # TODO, implement more if deep stuff here
393             x, y = arg.as_two_terms()
394         else:
395             coeff, terms = arg.as_coeff_Mul(rational=True)
396             if coeff is not S.One and coeff.is_Integer and terms is not S.One:
397                 x = terms
398                 y = (coeff - 1)*x
399         if x is not None:
400             return (cosh(x)*cosh(y) + sinh(x)*sinh(y)).expand(trig=True)
401         return cosh(arg)
402 
403     def _eval_rewrite_as_tractable(self, arg, limitvar=None, **kwargs):
404         return (exp(arg) + exp(-arg)) / 2
405 
406     def _eval_rewrite_as_exp(self, arg, **kwargs):
407         return (exp(arg) + exp(-arg)) / 2
408 
409     def _eval_rewrite_as_sinh(self, arg, **kwargs):
410         return -S.ImaginaryUnit*sinh(arg + S.Pi*S.ImaginaryUnit/2)
411 
412     def _eval_rewrite_as_tanh(self, arg, **kwargs):
413         tanh_half = tanh(S.Half*arg)**2
414         return (1 + tanh_half)/(1 - tanh_half)
415 
416     def _eval_rewrite_as_coth(self, arg, **kwargs):
417         coth_half = coth(S.Half*arg)**2
418         return (coth_half + 1)/(coth_half - 1)
419 
420     def _eval_as_leading_term(self, x, cdir=0):
421         from sympy import Order
422         arg = self.args[0].as_leading_term(x)
423 
424         if x in arg.free_symbols and Order(1, x).contains(arg):
425             return S.One
426         else:
427             return self.func(arg)
428 
429     def _eval_is_real(self):
430         arg = self.args[0]
431 
432         # `cosh(x)` is real for real OR purely imaginary `x`
433         if arg.is_real or arg.is_imaginary:
434             return True
435 
436         # cosh(a+ib) = cos(b)*cosh(a) + i*sin(b)*sinh(a)
437         # the imaginary part can be an expression like n*pi
438         # if not, check if the imaginary part is a number
439         re, im = arg.as_real_imag()
440         return (im%pi).is_zero
441 
442     def _eval_is_positive(self):
443         # cosh(x+I*y) = cos(y)*cosh(x) + I*sin(y)*sinh(x)
444         # cosh(z) is positive iff it is real and the real part is positive.
445         # So we need sin(y)*sinh(x) = 0 which gives x=0 or y=n*pi
446         # Case 1 (y=n*pi): cosh(z) = (-1)**n * cosh(x) -> positive for n even
447         # Case 2 (x=0): cosh(z) = cos(y) -> positive when cos(y) is positive
448         z = self.args[0]
449 
450         x, y = z.as_real_imag()
451         ymod = y % (2*pi)
452 
453         yzero = ymod.is_zero
454         # shortcut if ymod is zero
455         if yzero:
456             return True
457 
458         xzero = x.is_zero
459         # shortcut x is not zero
460         if xzero is False:
461             return yzero
462 
463         return fuzzy_or([
464                 # Case 1:
465                 yzero,
466                 # Case 2:
467                 fuzzy_and([
468                     xzero,
469                     fuzzy_or([ymod < pi/2, ymod > 3*pi/2])
470                 ])
471             ])
472 
473 
474     def _eval_is_nonnegative(self):
475         z = self.args[0]
476 
477         x, y = z.as_real_imag()
478         ymod = y % (2*pi)
479 
480         yzero = ymod.is_zero
481         # shortcut if ymod is zero
482         if yzero:
483             return True
484 
485         xzero = x.is_zero
486         # shortcut x is not zero
487         if xzero is False:
488             return yzero
489 
490         return fuzzy_or([
491                 # Case 1:
492                 yzero,
493                 # Case 2:
494                 fuzzy_and([
495                     xzero,
496                     fuzzy_or([ymod <= pi/2, ymod >= 3*pi/2])
497                 ])
498             ])
499 
500     def _eval_is_finite(self):
501         arg = self.args[0]
502         return arg.is_finite
503 
504 
505 class tanh(HyperbolicFunction):
506     r"""
507     tanh(x) is the hyperbolic tangent of x.
508 
509     The hyperbolic tangent function is $\frac{\sinh(x)}{\cosh(x)}$.
510 
511     Examples
512     ========
513 
514     >>> from sympy import tanh
515     >>> from sympy.abc import x
516     >>> tanh(x)
517     tanh(x)
518 
519     See Also
520     ========
521 
522     sinh, cosh, atanh
523     """
524 
525     def fdiff(self, argindex=1):
526         if argindex == 1:
527             return S.One - tanh(self.args[0])**2
528         else:
529             raise ArgumentIndexError(self, argindex)
530 
531     def inverse(self, argindex=1):
532         """
533         Returns the inverse of this function.
534         """
535         return atanh
536 
537     @classmethod
538     def eval(cls, arg):
539         from sympy import tan
540         arg = sympify(arg)
541 
542         if arg.is_Number:
543             if arg is S.NaN:
544                 return S.NaN
545             elif arg is S.Infinity:
546                 return S.One
547             elif arg is S.NegativeInfinity:
548                 return S.NegativeOne
549             elif arg.is_zero:
550                 return S.Zero
551             elif arg.is_negative:
552                 return -cls(-arg)
553         else:
554             if arg is S.ComplexInfinity:
555                 return S.NaN
556 
557             i_coeff = arg.as_coefficient(S.ImaginaryUnit)
558 
559             if i_coeff is not None:
560                 if _coeff_isneg(i_coeff):
561                     return -S.ImaginaryUnit * tan(-i_coeff)
562                 return S.ImaginaryUnit * tan(i_coeff)
563             else:
564                 if _coeff_isneg(arg):
565                     return -cls(-arg)
566 
567             if arg.is_Add:
568                 x, m = _peeloff_ipi(arg)
569                 if m:
570                     tanhm = tanh(m)
571                     if tanhm is S.ComplexInfinity:
572                         return coth(x)
573                     else: # tanhm == 0
574                         return tanh(x)
575 
576             if arg.is_zero:
577                 return S.Zero
578 
579             if arg.func == asinh:
580                 x = arg.args[0]
581                 return x/sqrt(1 + x**2)
582 
583             if arg.func == acosh:
584                 x = arg.args[0]
585                 return sqrt(x - 1) * sqrt(x + 1) / x
586 
587             if arg.func == atanh:
588                 return arg.args[0]
589 
590             if arg.func == acoth:
591                 return 1/arg.args[0]
592 
593     @staticmethod
594     @cacheit
595     def taylor_term(n, x, *previous_terms):
596         from sympy import bernoulli
597         if n < 0 or n % 2 == 0:
598             return S.Zero
599         else:
600             x = sympify(x)
601 
602             a = 2**(n + 1)
603 
604             B = bernoulli(n + 1)
605             F = factorial(n + 1)
606 
607             return a*(a - 1) * B/F * x**n
608 
609     def _eval_conjugate(self):
610         return self.func(self.args[0].conjugate())
611 
612     def as_real_imag(self, deep=True, **hints):
613         from sympy import cos, sin
614         if self.args[0].is_extended_real:
615             if deep:
616                 hints['complex'] = False
617                 return (self.expand(deep, **hints), S.Zero)
618             else:
619                 return (self, S.Zero)
620         if deep:
621             re, im = self.args[0].expand(deep, **hints).as_real_imag()
622         else:
623             re, im = self.args[0].as_real_imag()
624         denom = sinh(re)**2 + cos(im)**2
625         return (sinh(re)*cosh(re)/denom, sin(im)*cos(im)/denom)
626 
627     def _eval_expand_trig(self, **hints):
628         arg = self.args[0]
629         if arg.is_Add:
630             from sympy import symmetric_poly
631             n = len(arg.args)
632             TX = [tanh(x, evaluate=False)._eval_expand_trig()
633                 for x in arg.args]
634             p = [0, 0]  # [den, num]
635             for i in range(n + 1):
636                 p[i % 2] += symmetric_poly(i, TX)
637             return p[1]/p[0]
638         elif arg.is_Mul:
639             from sympy.functions.combinatorial.numbers import nC
640             coeff, terms = arg.as_coeff_Mul()
641             if coeff.is_Integer and coeff > 1:
642                 n = []
643                 d = []
644                 T = tanh(terms)
645                 for k in range(1, coeff + 1, 2):
646                     n.append(nC(range(coeff), k)*T**k)
647                 for k in range(0, coeff + 1, 2):
648                     d.append(nC(range(coeff), k)*T**k)
649                 return Add(*n)/Add(*d)
650         return tanh(arg)
651 
652     def _eval_rewrite_as_tractable(self, arg, limitvar=None, **kwargs):
653         neg_exp, pos_exp = exp(-arg), exp(arg)
654         return (pos_exp - neg_exp)/(pos_exp + neg_exp)
655 
656     def _eval_rewrite_as_exp(self, arg, **kwargs):
657         neg_exp, pos_exp = exp(-arg), exp(arg)
658         return (pos_exp - neg_exp)/(pos_exp + neg_exp)
659 
660     def _eval_rewrite_as_sinh(self, arg, **kwargs):
661         return S.ImaginaryUnit*sinh(arg)/sinh(S.Pi*S.ImaginaryUnit/2 - arg)
662 
663     def _eval_rewrite_as_cosh(self, arg, **kwargs):
664         return S.ImaginaryUnit*cosh(S.Pi*S.ImaginaryUnit/2 - arg)/cosh(arg)
665 
666     def _eval_rewrite_as_coth(self, arg, **kwargs):
667         return 1/coth(arg)
668 
669     def _eval_as_leading_term(self, x, cdir=0):
670         from sympy import Order
671         arg = self.args[0].as_leading_term(x)
672 
673         if x in arg.free_symbols and Order(1, x).contains(arg):
674             return arg
675         else:
676             return self.func(arg)
677 
678     def _eval_is_real(self):
679         arg = self.args[0]
680         if arg.is_real:
681             return True
682 
683         re, im = arg.as_real_imag()
684 
685         # if denom = 0, tanh(arg) = zoo
686         if re == 0 and im % pi == pi/2:
687             return None
688 
689         # check if im is of the form n*pi/2 to make sin(2*im) = 0
690         # if not, im could be a number, return False in that case
691         return (im % (pi/2)).is_zero
692 
693     def _eval_is_extended_real(self):
694         if self.args[0].is_extended_real:
695             return True
696 
697     def _eval_is_positive(self):
698         if self.args[0].is_extended_real:
699             return self.args[0].is_positive
700 
701     def _eval_is_negative(self):
702         if self.args[0].is_extended_real:
703             return self.args[0].is_negative
704 
705     def _eval_is_finite(self):
706         from sympy import sinh, cos
707         arg = self.args[0]
708 
709         re, im = arg.as_real_imag()
710         denom = cos(im)**2 + sinh(re)**2
711         if denom == 0:
712             return False
713         elif denom.is_number:
714             return True
715         if arg.is_extended_real:
716             return True
717 
718     def _eval_is_zero(self):
719         arg = self.args[0]
720         if arg.is_zero:
721             return True
722 
723 
724 class coth(HyperbolicFunction):
725     r"""
726     coth(x) is the hyperbolic cotangent of x.
727 
728     The hyperbolic cotangent function is $\frac{\cosh(x)}{\sinh(x)}$.
729 
730     Examples
731     ========
732 
733     >>> from sympy import coth
734     >>> from sympy.abc import x
735     >>> coth(x)
736     coth(x)
737 
738     See Also
739     ========
740 
741     sinh, cosh, acoth
742     """
743 
744     def fdiff(self, argindex=1):
745         if argindex == 1:
746             return -1/sinh(self.args[0])**2
747         else:
748             raise ArgumentIndexError(self, argindex)
749 
750     def inverse(self, argindex=1):
751         """
752         Returns the inverse of this function.
753         """
754         return acoth
755 
756     @classmethod
757     def eval(cls, arg):
758         from sympy import cot
759         arg = sympify(arg)
760 
761         if arg.is_Number:
762             if arg is S.NaN:
763                 return S.NaN
764             elif arg is S.Infinity:
765                 return S.One
766             elif arg is S.NegativeInfinity:
767                 return S.NegativeOne
768             elif arg.is_zero:
769                 return S.ComplexInfinity
770             elif arg.is_negative:
771                 return -cls(-arg)
772         else:
773             if arg is S.ComplexInfinity:
774                 return S.NaN
775 
776             i_coeff = arg.as_coefficient(S.ImaginaryUnit)
777 
778             if i_coeff is not None:
779                 if _coeff_isneg(i_coeff):
780                     return S.ImaginaryUnit * cot(-i_coeff)
781                 return -S.ImaginaryUnit * cot(i_coeff)
782             else:
783                 if _coeff_isneg(arg):
784                     return -cls(-arg)
785 
786             if arg.is_Add:
787                 x, m = _peeloff_ipi(arg)
788                 if m:
789                     cothm = coth(m)
790                     if cothm is S.ComplexInfinity:
791                         return coth(x)
792                     else: # cothm == 0
793                         return tanh(x)
794 
795             if arg.is_zero:
796                 return S.ComplexInfinity
797 
798             if arg.func == asinh:
799                 x = arg.args[0]
800                 return sqrt(1 + x**2)/x
801 
802             if arg.func == acosh:
803                 x = arg.args[0]
804                 return x/(sqrt(x - 1) * sqrt(x + 1))
805 
806             if arg.func == atanh:
807                 return 1/arg.args[0]
808 
809             if arg.func == acoth:
810                 return arg.args[0]
811 
812     @staticmethod
813     @cacheit
814     def taylor_term(n, x, *previous_terms):
815         from sympy import bernoulli
816         if n == 0:
817             return 1 / sympify(x)
818         elif n < 0 or n % 2 == 0:
819             return S.Zero
820         else:
821             x = sympify(x)
822 
823             B = bernoulli(n + 1)
824             F = factorial(n + 1)
825 
826             return 2**(n + 1) * B/F * x**n
827 
828     def _eval_conjugate(self):
829         return self.func(self.args[0].conjugate())
830 
831     def as_real_imag(self, deep=True, **hints):
832         from sympy import cos, sin
833         if self.args[0].is_extended_real:
834             if deep:
835                 hints['complex'] = False
836                 return (self.expand(deep, **hints), S.Zero)
837             else:
838                 return (self, S.Zero)
839         if deep:
840             re, im = self.args[0].expand(deep, **hints).as_real_imag()
841         else:
842             re, im = self.args[0].as_real_imag()
843         denom = sinh(re)**2 + sin(im)**2
844         return (sinh(re)*cosh(re)/denom, -sin(im)*cos(im)/denom)
845 
846     def _eval_rewrite_as_tractable(self, arg, limitvar=None, **kwargs):
847         neg_exp, pos_exp = exp(-arg), exp(arg)
848         return (pos_exp + neg_exp)/(pos_exp - neg_exp)
849 
850     def _eval_rewrite_as_exp(self, arg, **kwargs):
851         neg_exp, pos_exp = exp(-arg), exp(arg)
852         return (pos_exp + neg_exp)/(pos_exp - neg_exp)
853 
854     def _eval_rewrite_as_sinh(self, arg, **kwargs):
855         return -S.ImaginaryUnit*sinh(S.Pi*S.ImaginaryUnit/2 - arg)/sinh(arg)
856 
857     def _eval_rewrite_as_cosh(self, arg, **kwargs):
858         return -S.ImaginaryUnit*cosh(arg)/cosh(S.Pi*S.ImaginaryUnit/2 - arg)
859 
860     def _eval_rewrite_as_tanh(self, arg, **kwargs):
861         return 1/tanh(arg)
862 
863     def _eval_is_positive(self):
864         if self.args[0].is_extended_real:
865             return self.args[0].is_positive
866 
867     def _eval_is_negative(self):
868         if self.args[0].is_extended_real:
869             return self.args[0].is_negative
870 
871     def _eval_as_leading_term(self, x, cdir=0):
872         from sympy import Order
873         arg = self.args[0].as_leading_term(x)
874 
875         if x in arg.free_symbols and Order(1, x).contains(arg):
876             return 1/arg
877         else:
878             return self.func(arg)
879 
880 
881 class ReciprocalHyperbolicFunction(HyperbolicFunction):
882     """Base class for reciprocal functions of hyperbolic functions. """
883 
884     #To be defined in class
885     _reciprocal_of = None
886     _is_even = None  # type: FuzzyBool
887     _is_odd = None  # type: FuzzyBool
888 
889     @classmethod
890     def eval(cls, arg):
891         if arg.could_extract_minus_sign():
892             if cls._is_even:
893                 return cls(-arg)
894             if cls._is_odd:
895                 return -cls(-arg)
896 
897         t = cls._reciprocal_of.eval(arg)
898         if hasattr(arg, 'inverse') and arg.inverse() == cls:
899             return arg.args[0]
900         return 1/t if t is not None else t
901 
902     def _call_reciprocal(self, method_name, *args, **kwargs):
903         # Calls method_name on _reciprocal_of
904         o = self._reciprocal_of(self.args[0])
905         return getattr(o, method_name)(*args, **kwargs)
906 
907     def _calculate_reciprocal(self, method_name, *args, **kwargs):
908         # If calling method_name on _reciprocal_of returns a value != None
909         # then return the reciprocal of that value
910         t = self._call_reciprocal(method_name, *args, **kwargs)
911         return 1/t if t is not None else t
912 
913     def _rewrite_reciprocal(self, method_name, arg):
914         # Special handling for rewrite functions. If reciprocal rewrite returns
915         # unmodified expression, then return None
916         t = self._call_reciprocal(method_name, arg)
917         if t is not None and t != self._reciprocal_of(arg):
918             return 1/t
919 
920     def _eval_rewrite_as_exp(self, arg, **kwargs):
921         return self._rewrite_reciprocal("_eval_rewrite_as_exp", arg)
922 
923     def _eval_rewrite_as_tractable(self, arg, limitvar=None, **kwargs):
924         return self._rewrite_reciprocal("_eval_rewrite_as_tractable", arg)
925 
926     def _eval_rewrite_as_tanh(self, arg, **kwargs):
927         return self._rewrite_reciprocal("_eval_rewrite_as_tanh", arg)
928 
929     def _eval_rewrite_as_coth(self, arg, **kwargs):
930         return self._rewrite_reciprocal("_eval_rewrite_as_coth", arg)
931 
932     def as_real_imag(self, deep = True, **hints):
933         return (1 / self._reciprocal_of(self.args[0])).as_real_imag(deep, **hints)
934 
935     def _eval_conjugate(self):
936         return self.func(self.args[0].conjugate())
937 
938     def _eval_expand_complex(self, deep=True, **hints):
939         re_part, im_part = self.as_real_imag(deep=True, **hints)
940         return re_part + S.ImaginaryUnit*im_part
941 
942     def _eval_as_leading_term(self, x, cdir=0):
943         return (1/self._reciprocal_of(self.args[0]))._eval_as_leading_term(x)
944 
945     def _eval_is_extended_real(self):
946         return self._reciprocal_of(self.args[0]).is_extended_real
947 
948     def _eval_is_finite(self):
949         return (1/self._reciprocal_of(self.args[0])).is_finite
950 
951 
952 class csch(ReciprocalHyperbolicFunction):
953     r"""
954     csch(x) is the hyperbolic cosecant of x.
955 
956     The hyperbolic cosecant function is $\frac{2}{e^x - e^{-x}}$
957 
958     Examples
959     ========
960 
961     >>> from sympy import csch
962     >>> from sympy.abc import x
963     >>> csch(x)
964     csch(x)
965 
966     See Also
967     ========
968 
969     sinh, cosh, tanh, sech, asinh, acosh
970     """
971 
972     _reciprocal_of = sinh
973     _is_odd = True
974 
975     def fdiff(self, argindex=1):
976         """
977         Returns the first derivative of this function
978         """
979         if argindex == 1:
980             return -coth(self.args[0]) * csch(self.args[0])
981         else:
982             raise ArgumentIndexError(self, argindex)
983 
984     @staticmethod
985     @cacheit
986     def taylor_term(n, x, *previous_terms):
987         """
988         Returns the next term in the Taylor series expansion
989         """
990         from sympy import bernoulli
991         if n == 0:
992             return 1/sympify(x)
993         elif n < 0 or n % 2 == 0:
994             return S.Zero
995         else:
996             x = sympify(x)
997 
998             B = bernoulli(n + 1)
999             F = factorial(n + 1)
1000 
1001             return 2 * (1 - 2**n) * B/F * x**n
1002 
1003     def _eval_rewrite_as_cosh(self, arg, **kwargs):
1004         return S.ImaginaryUnit / cosh(arg + S.ImaginaryUnit * S.Pi / 2)
1005 
1006     def _eval_is_positive(self):
1007         if self.args[0].is_extended_real:
1008             return self.args[0].is_positive
1009 
1010     def _eval_is_negative(self):
1011         if self.args[0].is_extended_real:
1012             return self.args[0].is_negative
1013 
1014     def _sage_(self):
1015         import sage.all as sage
1016         return sage.csch(self.args[0]._sage_())
1017 
1018 
1019 class sech(ReciprocalHyperbolicFunction):
1020     r"""
1021     sech(x) is the hyperbolic secant of x.
1022 
1023     The hyperbolic secant function is $\frac{2}{e^x + e^{-x}}$
1024 
1025     Examples
1026     ========
1027 
1028     >>> from sympy import sech
1029     >>> from sympy.abc import x
1030     >>> sech(x)
1031     sech(x)
1032 
1033     See Also
1034     ========
1035 
1036     sinh, cosh, tanh, coth, csch, asinh, acosh
1037     """
1038 
1039     _reciprocal_of = cosh
1040     _is_even = True
1041 
1042     def fdiff(self, argindex=1):
1043         if argindex == 1:
1044             return - tanh(self.args[0])*sech(self.args[0])
1045         else:
1046             raise ArgumentIndexError(self, argindex)
1047 
1048     @staticmethod
1049     @cacheit
1050     def taylor_term(n, x, *previous_terms):
1051         from sympy.functions.combinatorial.numbers import euler
1052         if n < 0 or n % 2 == 1:
1053             return S.Zero
1054         else:
1055             x = sympify(x)
1056             return euler(n) / factorial(n) * x**(n)
1057 
1058     def _eval_rewrite_as_sinh(self, arg, **kwargs):
1059         return S.ImaginaryUnit / sinh(arg + S.ImaginaryUnit * S.Pi /2)
1060 
1061     def _eval_is_positive(self):
1062         if self.args[0].is_extended_real:
1063             return True
1064 
1065     def _sage_(self):
1066         import sage.all as sage
1067         return sage.sech(self.args[0]._sage_())
1068 
1069 
1070 
1071 ###############################################################################
1072 ############################# HYPERBOLIC INVERSES #############################
1073 ###############################################################################
1074 
1075 class InverseHyperbolicFunction(Function):
1076     """Base class for inverse hyperbolic functions."""
1077 
1078     pass
1079 
1080 
1081 class asinh(InverseHyperbolicFunction):
1082     """
1083     asinh(x) is the inverse hyperbolic sine of x.
1084 
1085     The inverse hyperbolic sine function.
1086 
1087     Examples
1088     ========
1089 
1090     >>> from sympy import asinh
1091     >>> from sympy.abc import x
1092     >>> asinh(x).diff(x)
1093     1/sqrt(x**2 + 1)
1094     >>> asinh(1)
1095     log(1 + sqrt(2))
1096 
1097     See Also
1098     ========
1099 
1100     acosh, atanh, sinh
1101     """
1102 
1103     def fdiff(self, argindex=1):
1104         if argindex == 1:
1105             return 1/sqrt(self.args[0]**2 + 1)
1106         else:
1107             raise ArgumentIndexError(self, argindex)
1108 
1109     @classmethod
1110     def eval(cls, arg):
1111         from sympy import asin
1112         arg = sympify(arg)
1113 
1114         if arg.is_Number:
1115             if arg is S.NaN:
1116                 return S.NaN
1117             elif arg is S.Infinity:
1118                 return S.Infinity
1119             elif arg is S.NegativeInfinity:
1120                 return S.NegativeInfinity
1121             elif arg.is_zero:
1122                 return S.Zero
1123             elif arg is S.One:
1124                 return log(sqrt(2) + 1)
1125             elif arg is S.NegativeOne:
1126                 return log(sqrt(2) - 1)
1127             elif arg.is_negative:
1128                 return -cls(-arg)
1129         else:
1130             if arg is S.ComplexInfinity:
1131                 return S.ComplexInfinity
1132 
1133             if arg.is_zero:
1134                 return S.Zero
1135 
1136             i_coeff = arg.as_coefficient(S.ImaginaryUnit)
1137 
1138             if i_coeff is not None:
1139                 return S.ImaginaryUnit * asin(i_coeff)
1140             else:
1141                 if _coeff_isneg(arg):
1142                     return -cls(-arg)
1143 
1144         if isinstance(arg, sinh) and arg.args[0].is_number:
1145             z = arg.args[0]
1146             if z.is_real:
1147                 return z
1148             r, i = match_real_imag(z)
1149             if r is not None and i is not None:
1150                 f = floor((i + pi/2)/pi)
1151                 m = z - I*pi*f
1152                 even = f.is_even
1153                 if even is True:
1154                     return m
1155                 elif even is False:
1156                     return -m
1157 
1158     @staticmethod
1159     @cacheit
1160     def taylor_term(n, x, *previous_terms):
1161         if n < 0 or n % 2 == 0:
1162             return S.Zero
1163         else:
1164             x = sympify(x)
1165             if len(previous_terms) >= 2 and n > 2:
1166                 p = previous_terms[-2]
1167                 return -p * (n - 2)**2/(n*(n - 1)) * x**2
1168             else:
1169                 k = (n - 1) // 2
1170                 R = RisingFactorial(S.Half, k)
1171                 F = factorial(k)
1172                 return (-1)**k * R / F * x**n / n
1173 
1174     def _eval_as_leading_term(self, x, cdir=0):
1175         from sympy import Order
1176         arg = self.args[0].as_leading_term(x)
1177 
1178         if x in arg.free_symbols and Order(1, x).contains(arg):
1179             return arg
1180         else:
1181             return self.func(arg)
1182 
1183     def _eval_rewrite_as_log(self, x, **kwargs):
1184         return log(x + sqrt(x**2 + 1))
1185 
1186     def inverse(self, argindex=1):
1187         """
1188         Returns the inverse of this function.
1189         """
1190         return sinh
1191 
1192     def _eval_is_zero(self):
1193         arg = self.args[0]
1194         if arg.is_zero:
1195             return True
1196 
1197 
1198 class acosh(InverseHyperbolicFunction):
1199     """
1200     acosh(x) is the inverse hyperbolic cosine of x.
1201 
1202     The inverse hyperbolic cosine function.
1203 
1204     Examples
1205     ========
1206 
1207     >>> from sympy import acosh
1208     >>> from sympy.abc import x
1209     >>> acosh(x).diff(x)
1210     1/sqrt(x**2 - 1)
1211     >>> acosh(1)
1212     0
1213 
1214     See Also
1215     ========
1216 
1217     asinh, atanh, cosh
1218     """
1219 
1220     def fdiff(self, argindex=1):
1221         if argindex == 1:
1222             return 1/sqrt(self.args[0]**2 - 1)
1223         else:
1224             raise ArgumentIndexError(self, argindex)
1225 
1226     @classmethod
1227     def eval(cls, arg):
1228         arg = sympify(arg)
1229 
1230         if arg.is_Number:
1231             if arg is S.NaN:
1232                 return S.NaN
1233             elif arg is S.Infinity:
1234                 return S.Infinity
1235             elif arg is S.NegativeInfinity:
1236                 return S.Infinity
1237             elif arg.is_zero:
1238                 return S.Pi*S.ImaginaryUnit / 2
1239             elif arg is S.One:
1240                 return S.Zero
1241             elif arg is S.NegativeOne:
1242                 return S.Pi*S.ImaginaryUnit
1243 
1244         if arg.is_number:
1245             cst_table = {
1246                 S.ImaginaryUnit: log(S.ImaginaryUnit*(1 + sqrt(2))),
1247                 -S.ImaginaryUnit: log(-S.ImaginaryUnit*(1 + sqrt(2))),
1248                 S.Half: S.Pi/3,
1249                 Rational(-1, 2): S.Pi*Rational(2, 3),
1250                 sqrt(2)/2: S.Pi/4,
1251                 -sqrt(2)/2: S.Pi*Rational(3, 4),
1252                 1/sqrt(2): S.Pi/4,
1253                 -1/sqrt(2): S.Pi*Rational(3, 4),
1254                 sqrt(3)/2: S.Pi/6,
1255                 -sqrt(3)/2: S.Pi*Rational(5, 6),
1256                 (sqrt(3) - 1)/sqrt(2**3): S.Pi*Rational(5, 12),
1257                 -(sqrt(3) - 1)/sqrt(2**3): S.Pi*Rational(7, 12),
1258                 sqrt(2 + sqrt(2))/2: S.Pi/8,
1259                 -sqrt(2 + sqrt(2))/2: S.Pi*Rational(7, 8),
1260                 sqrt(2 - sqrt(2))/2: S.Pi*Rational(3, 8),
1261                 -sqrt(2 - sqrt(2))/2: S.Pi*Rational(5, 8),
1262                 (1 + sqrt(3))/(2*sqrt(2)): S.Pi/12,
1263                 -(1 + sqrt(3))/(2*sqrt(2)): S.Pi*Rational(11, 12),
1264                 (sqrt(5) + 1)/4: S.Pi/5,
1265                 -(sqrt(5) + 1)/4: S.Pi*Rational(4, 5)
1266             }
1267 
1268             if arg in cst_table:
1269                 if arg.is_extended_real:
1270                     return cst_table[arg]*S.ImaginaryUnit
1271                 return cst_table[arg]
1272 
1273         if arg is S.ComplexInfinity:
1274             return S.ComplexInfinity
1275         if arg == S.ImaginaryUnit*S.Infinity:
1276             return S.Infinity + S.ImaginaryUnit*S.Pi/2
1277         if arg == -S.ImaginaryUnit*S.Infinity:
1278             return S.Infinity - S.ImaginaryUnit*S.Pi/2
1279 
1280         if arg.is_zero:
1281             return S.Pi*S.ImaginaryUnit*S.Half
1282 
1283         if isinstance(arg, cosh) and arg.args[0].is_number:
1284             z = arg.args[0]
1285             if z.is_real:
1286                 from sympy.functions.elementary.complexes import Abs
1287                 return Abs(z)
1288             r, i = match_real_imag(z)
1289             if r is not None and i is not None:
1290                 f = floor(i/pi)
1291                 m = z - I*pi*f
1292                 even = f.is_even
1293                 if even is True:
1294                     if r.is_nonnegative:
1295                         return m
1296                     elif r.is_negative:
1297                         return -m
1298                 elif even is False:
1299                     m -= I*pi
1300                     if r.is_nonpositive:
1301                         return -m
1302                     elif r.is_positive:
1303                         return m
1304 
1305     @staticmethod
1306     @cacheit
1307     def taylor_term(n, x, *previous_terms):
1308         if n == 0:
1309             return S.Pi*S.ImaginaryUnit / 2
1310         elif n < 0 or n % 2 == 0:
1311             return S.Zero
1312         else:
1313             x = sympify(x)
1314             if len(previous_terms) >= 2 and n > 2:
1315                 p = previous_terms[-2]
1316                 return p * (n - 2)**2/(n*(n - 1)) * x**2
1317             else:
1318                 k = (n - 1) // 2
1319                 R = RisingFactorial(S.Half, k)
1320                 F = factorial(k)
1321                 return -R / F * S.ImaginaryUnit * x**n / n
1322 
1323     def _eval_as_leading_term(self, x, cdir=0):
1324         from sympy import Order
1325         arg = self.args[0].as_leading_term(x)
1326 
1327         if x in arg.free_symbols and Order(1, x).contains(arg):
1328             return S.ImaginaryUnit*S.Pi/2
1329         else:
1330             return self.func(arg)
1331 
1332     def _eval_rewrite_as_log(self, x, **kwargs):
1333         return log(x + sqrt(x + 1) * sqrt(x - 1))
1334 
1335     def inverse(self, argindex=1):
1336         """
1337         Returns the inverse of this function.
1338         """
1339         return cosh
1340 
1341 
1342 class atanh(InverseHyperbolicFunction):
1343     """
1344     atanh(x) is the inverse hyperbolic tangent of x.
1345 
1346     The inverse hyperbolic tangent function.
1347 
1348     Examples
1349     ========
1350 
1351     >>> from sympy import atanh
1352     >>> from sympy.abc import x
1353     >>> atanh(x).diff(x)
1354     1/(1 - x**2)
1355 
1356     See Also
1357     ========
1358 
1359     asinh, acosh, tanh
1360     """
1361 
1362     def fdiff(self, argindex=1):
1363         if argindex == 1:
1364             return 1/(1 - self.args[0]**2)
1365         else:
1366             raise ArgumentIndexError(self, argindex)
1367 
1368     @classmethod
1369     def eval(cls, arg):
1370         from sympy import atan
1371         arg = sympify(arg)
1372 
1373         if arg.is_Number:
1374             if arg is S.NaN:
1375                 return S.NaN
1376             elif arg.is_zero:
1377                 return S.Zero
1378             elif arg is S.One:
1379                 return S.Infinity
1380             elif arg is S.NegativeOne:
1381                 return S.NegativeInfinity
1382             elif arg is S.Infinity:
1383                 return -S.ImaginaryUnit * atan(arg)
1384             elif arg is S.NegativeInfinity:
1385                 return S.ImaginaryUnit * atan(-arg)
1386             elif arg.is_negative:
1387                 return -cls(-arg)
1388         else:
1389             if arg is S.ComplexInfinity:
1390                 from sympy.calculus.util import AccumBounds
1391                 return S.ImaginaryUnit*AccumBounds(-S.Pi/2, S.Pi/2)
1392 
1393             i_coeff = arg.as_coefficient(S.ImaginaryUnit)
1394 
1395             if i_coeff is not None:
1396                 return S.ImaginaryUnit * atan(i_coeff)
1397             else:
1398                 if _coeff_isneg(arg):
1399                     return -cls(-arg)
1400 
1401         if arg.is_zero:
1402             return S.Zero
1403 
1404         if isinstance(arg, tanh) and arg.args[0].is_number:
1405             z = arg.args[0]
1406             if z.is_real:
1407                 return z
1408             r, i = match_real_imag(z)
1409             if r is not None and i is not None:
1410                 f = floor(2*i/pi)
1411                 even = f.is_even
1412                 m = z - I*f*pi/2
1413                 if even is True:
1414                     return m
1415                 elif even is False:
1416                     return m - I*pi/2
1417 
1418     @staticmethod
1419     @cacheit
1420     def taylor_term(n, x, *previous_terms):
1421         if n < 0 or n % 2 == 0:
1422             return S.Zero
1423         else:
1424             x = sympify(x)
1425             return x**n / n
1426 
1427     def _eval_as_leading_term(self, x, cdir=0):
1428         from sympy import Order
1429         arg = self.args[0].as_leading_term(x)
1430 
1431         if x in arg.free_symbols and Order(1, x).contains(arg):
1432             return arg
1433         else:
1434             return self.func(arg)
1435 
1436     def _eval_rewrite_as_log(self, x, **kwargs):
1437         return (log(1 + x) - log(1 - x)) / 2
1438 
1439     def _eval_is_zero(self):
1440         arg = self.args[0]
1441         if arg.is_zero:
1442             return True
1443 
1444 
1445     def inverse(self, argindex=1):
1446         """
1447         Returns the inverse of this function.
1448         """
1449         return tanh
1450 
1451 
1452 class acoth(InverseHyperbolicFunction):
1453     """
1454     acoth(x) is the inverse hyperbolic cotangent of x.
1455 
1456     The inverse hyperbolic cotangent function.
1457 
1458     Examples
1459     ========
1460 
1461     >>> from sympy import acoth
1462     >>> from sympy.abc import x
1463     >>> acoth(x).diff(x)
1464     1/(1 - x**2)
1465 
1466     See Also
1467     ========
1468 
1469     asinh, acosh, coth
1470     """
1471 
1472     def fdiff(self, argindex=1):
1473         if argindex == 1:
1474             return 1/(1 - self.args[0]**2)
1475         else:
1476             raise ArgumentIndexError(self, argindex)
1477 
1478     @classmethod
1479     def eval(cls, arg):
1480         from sympy import acot
1481         arg = sympify(arg)
1482 
1483         if arg.is_Number:
1484             if arg is S.NaN:
1485                 return S.NaN
1486             elif arg is S.Infinity:
1487                 return S.Zero
1488             elif arg is S.NegativeInfinity:
1489                 return S.Zero
1490             elif arg.is_zero:
1491                 return S.Pi*S.ImaginaryUnit / 2
1492             elif arg is S.One:
1493                 return S.Infinity
1494             elif arg is S.NegativeOne:
1495                 return S.NegativeInfinity
1496             elif arg.is_negative:
1497                 return -cls(-arg)
1498         else:
1499             if arg is S.ComplexInfinity:
1500                 return S.Zero
1501 
1502             i_coeff = arg.as_coefficient(S.ImaginaryUnit)
1503 
1504             if i_coeff is not None:
1505                 return -S.ImaginaryUnit * acot(i_coeff)
1506             else:
1507                 if _coeff_isneg(arg):
1508                     return -cls(-arg)
1509 
1510         if arg.is_zero:
1511             return S.Pi*S.ImaginaryUnit*S.Half
1512 
1513     @staticmethod
1514     @cacheit
1515     def taylor_term(n, x, *previous_terms):
1516         if n == 0:
1517             return S.Pi*S.ImaginaryUnit / 2
1518         elif n < 0 or n % 2 == 0:
1519             return S.Zero
1520         else:
1521             x = sympify(x)
1522             return x**n / n
1523 
1524     def _eval_as_leading_term(self, x, cdir=0):
1525         from sympy import Order
1526         arg = self.args[0].as_leading_term(x)
1527 
1528         if x in arg.free_symbols and Order(1, x).contains(arg):
1529             return S.ImaginaryUnit*S.Pi/2
1530         else:
1531             return self.func(arg)
1532 
1533     def _eval_rewrite_as_log(self, x, **kwargs):
1534         return (log(1 + 1/x) - log(1 - 1/x)) / 2
1535 
1536     def inverse(self, argindex=1):
1537         """
1538         Returns the inverse of this function.
1539         """
1540         return coth
1541 
1542 
1543 class asech(InverseHyperbolicFunction):
1544     """
1545     asech(x) is the inverse hyperbolic secant of x.
1546 
1547     The inverse hyperbolic secant function.
1548 
1549     Examples
1550     ========
1551 
1552     >>> from sympy import asech, sqrt, S
1553     >>> from sympy.abc import x
1554     >>> asech(x).diff(x)
1555     -1/(x*sqrt(1 - x**2))
1556     >>> asech(1).diff(x)
1557     0
1558     >>> asech(1)
1559     0
1560     >>> asech(S(2))
1561     I*pi/3
1562     >>> asech(-sqrt(2))
1563     3*I*pi/4
1564     >>> asech((sqrt(6) - sqrt(2)))
1565     I*pi/12
1566 
1567     See Also
1568     ========
1569 
1570     asinh, atanh, cosh, acoth
1571 
1572     References
1573     ==========
1574 
1575     .. [1] https://en.wikipedia.org/wiki/Hyperbolic_function
1576     .. [2] http://dlmf.nist.gov/4.37
1577     .. [3] http://functions.wolfram.com/ElementaryFunctions/ArcSech/
1578 
1579     """
1580 
1581     def fdiff(self, argindex=1):
1582         if argindex == 1:
1583             z = self.args[0]
1584             return -1/(z*sqrt(1 - z**2))
1585         else:
1586             raise ArgumentIndexError(self, argindex)
1587 
1588     @classmethod
1589     def eval(cls, arg):
1590         arg = sympify(arg)
1591 
1592         if arg.is_Number:
1593             if arg is S.NaN:
1594                 return S.NaN
1595             elif arg is S.Infinity:
1596                 return S.Pi*S.ImaginaryUnit / 2
1597             elif arg is S.NegativeInfinity:
1598                 return S.Pi*S.ImaginaryUnit / 2
1599             elif arg.is_zero:
1600                 return S.Infinity
1601             elif arg is S.One:
1602                 return S.Zero
1603             elif arg is S.NegativeOne:
1604                 return S.Pi*S.ImaginaryUnit
1605 
1606         if arg.is_number:
1607             cst_table = {
1608                 S.ImaginaryUnit: - (S.Pi*S.ImaginaryUnit / 2) + log(1 + sqrt(2)),
1609                 -S.ImaginaryUnit: (S.Pi*S.ImaginaryUnit / 2) + log(1 + sqrt(2)),
1610                 (sqrt(6) - sqrt(2)): S.Pi / 12,
1611                 (sqrt(2) - sqrt(6)): 11*S.Pi / 12,
1612                 sqrt(2 - 2/sqrt(5)): S.Pi / 10,
1613                 -sqrt(2 - 2/sqrt(5)): 9*S.Pi / 10,
1614                 2 / sqrt(2 + sqrt(2)): S.Pi / 8,
1615                 -2 / sqrt(2 + sqrt(2)): 7*S.Pi / 8,
1616                 2 / sqrt(3): S.Pi / 6,
1617                 -2 / sqrt(3): 5*S.Pi / 6,
1618                 (sqrt(5) - 1): S.Pi / 5,
1619                 (1 - sqrt(5)): 4*S.Pi / 5,
1620                 sqrt(2): S.Pi / 4,
1621                 -sqrt(2): 3*S.Pi / 4,
1622                 sqrt(2 + 2/sqrt(5)): 3*S.Pi / 10,
1623                 -sqrt(2 + 2/sqrt(5)): 7*S.Pi / 10,
1624                 S(2): S.Pi / 3,
1625                 -S(2): 2*S.Pi / 3,
1626                 sqrt(2*(2 + sqrt(2))): 3*S.Pi / 8,
1627                 -sqrt(2*(2 + sqrt(2))): 5*S.Pi / 8,
1628                 (1 + sqrt(5)): 2*S.Pi / 5,
1629                 (-1 - sqrt(5)): 3*S.Pi / 5,
1630                 (sqrt(6) + sqrt(2)): 5*S.Pi / 12,
1631                 (-sqrt(6) - sqrt(2)): 7*S.Pi / 12,
1632             }
1633 
1634             if arg in cst_table:
1635                 if arg.is_extended_real:
1636                     return cst_table[arg]*S.ImaginaryUnit
1637                 return cst_table[arg]
1638 
1639         if arg is S.ComplexInfinity:
1640             from sympy.calculus.util import AccumBounds
1641             return S.ImaginaryUnit*AccumBounds(-S.Pi/2, S.Pi/2)
1642 
1643         if arg.is_zero:
1644             return S.Infinity
1645 
1646     @staticmethod
1647     @cacheit
1648     def expansion_term(n, x, *previous_terms):
1649         if n == 0:
1650             return log(2 / x)
1651         elif n < 0 or n % 2 == 1:
1652             return S.Zero
1653         else:
1654             x = sympify(x)
1655             if len(previous_terms) > 2 and n > 2:
1656                 p = previous_terms[-2]
1657                 return p * (n - 1)**2 // (n // 2)**2 * x**2 / 4
1658             else:
1659                 k = n // 2
1660                 R = RisingFactorial(S.Half , k) *  n
1661                 F = factorial(k) * n // 2 * n // 2
1662                 return -1 * R / F * x**n / 4
1663 
1664     def inverse(self, argindex=1):
1665         """
1666         Returns the inverse of this function.
1667         """
1668         return sech
1669 
1670     def _eval_rewrite_as_log(self, arg, **kwargs):
1671         return log(1/arg + sqrt(1/arg - 1) * sqrt(1/arg + 1))
1672 
1673 
1674 class acsch(InverseHyperbolicFunction):
1675     """
1676     acsch(x) is the inverse hyperbolic cosecant of x.
1677 
1678     The inverse hyperbolic cosecant function.
1679 
1680     Examples
1681     ========
1682 
1683     >>> from sympy import acsch, sqrt, S
1684     >>> from sympy.abc import x
1685     >>> acsch(x).diff(x)
1686     -1/(x**2*sqrt(1 + x**(-2)))
1687     >>> acsch(1).diff(x)
1688     0
1689     >>> acsch(1)
1690     log(1 + sqrt(2))
1691     >>> acsch(S.ImaginaryUnit)
1692     -I*pi/2
1693     >>> acsch(-2*S.ImaginaryUnit)
1694     I*pi/6
1695     >>> acsch(S.ImaginaryUnit*(sqrt(6) - sqrt(2)))
1696     -5*I*pi/12
1697 
1698     See Also
1699     ========
1700 
1701     asinh
1702 
1703     References
1704     ==========
1705 
1706     .. [1] https://en.wikipedia.org/wiki/Hyperbolic_function
1707     .. [2] http://dlmf.nist.gov/4.37
1708     .. [3] http://functions.wolfram.com/ElementaryFunctions/ArcCsch/
1709 
1710     """
1711 
1712     def fdiff(self, argindex=1):
1713         if argindex == 1:
1714             z = self.args[0]
1715             return -1/(z**2*sqrt(1 + 1/z**2))
1716         else:
1717             raise ArgumentIndexError(self, argindex)
1718 
1719     @classmethod
1720     def eval(cls, arg):
1721         arg = sympify(arg)
1722 
1723         if arg.is_Number:
1724             if arg is S.NaN:
1725                 return S.NaN
1726             elif arg is S.Infinity:
1727                 return S.Zero
1728             elif arg is S.NegativeInfinity:
1729                 return S.Zero
1730             elif arg.is_zero:
1731                 return S.ComplexInfinity
1732             elif arg is S.One:
1733                 return log(1 + sqrt(2))
1734             elif arg is S.NegativeOne:
1735                 return - log(1 + sqrt(2))
1736 
1737         if arg.is_number:
1738             cst_table = {
1739                 S.ImaginaryUnit: -S.Pi / 2,
1740                 S.ImaginaryUnit*(sqrt(2) + sqrt(6)): -S.Pi / 12,
1741                 S.ImaginaryUnit*(1 + sqrt(5)): -S.Pi / 10,
1742                 S.ImaginaryUnit*2 / sqrt(2 - sqrt(2)): -S.Pi / 8,
1743                 S.ImaginaryUnit*2: -S.Pi / 6,
1744                 S.ImaginaryUnit*sqrt(2 + 2/sqrt(5)): -S.Pi / 5,
1745                 S.ImaginaryUnit*sqrt(2): -S.Pi / 4,
1746                 S.ImaginaryUnit*(sqrt(5)-1): -3*S.Pi / 10,
1747                 S.ImaginaryUnit*2 / sqrt(3): -S.Pi / 3,
1748                 S.ImaginaryUnit*2 / sqrt(2 + sqrt(2)): -3*S.Pi / 8,
1749                 S.ImaginaryUnit*sqrt(2 - 2/sqrt(5)): -2*S.Pi / 5,
1750                 S.ImaginaryUnit*(sqrt(6) - sqrt(2)): -5*S.Pi / 12,
1751                 S(2): -S.ImaginaryUnit*log((1+sqrt(5))/2),
1752             }
1753 
1754             if arg in cst_table:
1755                 return cst_table[arg]*S.ImaginaryUnit
1756 
1757         if arg is S.ComplexInfinity:
1758             return S.Zero
1759 
1760         if arg.is_zero:
1761             return S.ComplexInfinity
1762 
1763         if _coeff_isneg(arg):
1764             return -cls(-arg)
1765 
1766     def inverse(self, argindex=1):
1767         """
1768         Returns the inverse of this function.
1769         """
1770         return csch
1771 
1772     def _eval_rewrite_as_log(self, arg, **kwargs):
1773         return log(1/arg + sqrt(1/arg**2 + 1))

</code><intended_behavior>This file and specifically the classes or methods handling `csch` and `sech` should be modified to include logic that allows the `expand_trig` function to expand these functions correctly. This includes identifying the trigonometric identities for `csch` and `sech` that allow them to be expanded in a manner similar to `csc` and `sec`. The intended behavior is to ensure that when `expand_trig` is called with an expression involving `csch` or `sech`, the function returns an expanded form based on the appropriate identities, thus extending the `expand_trig` utility to cover these hyperbolic functions.</intended_behavior>, <file>sympy/core/function.py</file>
<class>None</class>
<method>expand_trig</method>
<code>
2960 def expand_trig(expr, deep=True):
2961     """
2962     Wrapper around expand that only uses the trig hint.  See the expand
2963     docstring for more information.
2964 
2965     Examples
2966     ========
2967 
2968     >>> from sympy import expand_trig, sin
2969     >>> from sympy.abc import x, y
2970     >>> expand_trig(sin(x+y)*(x+y))
2971     (x + y)*(sin(x)*cos(y) + sin(y)*cos(x))
2972 
2973     """
2974     return sympify(expr).expand(deep=deep, trig=True, basic=False,
2975     log=False, mul=False, power_exp=False, power_base=False, multinomial=False)

</code><intended_behavior>Although the primary logic to expand `csch` and `sech` might reside in `hyperbolic.py`, the `expand_trig` method itself may require adjustments or enhancements to ensure it correctly invokes the relevant expansion rules for hyperbolic functions. The method should be capable of recognizing when an expression contains `csch` or `sech` and apply the expansion logic defined in their respective implementations. This ensures that `expand_trig` remains a comprehensive tool for expanding trigonometric expressions, including both traditional and hyperbolic trigonometric functions.</intended_behavior>]
2025-10-18 20:56:44.376 | INFO     | Search completed. Bug locations: [<file>sympy/functions/elementary/hyperbolic.py</file>
<class>None</class>
<method>None</method>
<code>
1 from sympy.core.logic import FuzzyBool
2 
3 from sympy.core import S, sympify, cacheit, pi, I, Rational
4 from sympy.core.add import Add
5 from sympy.core.function import Function, ArgumentIndexError, _coeff_isneg
6 from sympy.functions.combinatorial.factorials import factorial, RisingFactorial
7 from sympy.functions.elementary.exponential import exp, log, match_real_imag
8 from sympy.functions.elementary.miscellaneous import sqrt
9 from sympy.functions.elementary.integers import floor
10 
11 from sympy.core.logic import fuzzy_or, fuzzy_and
12 
13 
14 
15 def _rewrite_hyperbolics_as_exp(expr):
16     expr = sympify(expr)
17     return expr.xreplace({h: h.rewrite(exp)
18         for h in expr.atoms(HyperbolicFunction)})
19 
20 
21 ###############################################################################
22 ########################### HYPERBOLIC FUNCTIONS ##############################
23 ###############################################################################
24 
25 
26 class HyperbolicFunction(Function):
27     """
28     Base class for hyperbolic functions.
29 
30     See Also
31     ========
32 
33     sinh, cosh, tanh, coth
34     """
35 
36     unbranched = True
37 
38 
39 def _peeloff_ipi(arg):
40     """
41     Split ARG into two parts, a "rest" and a multiple of I*pi/2.
42     This assumes ARG to be an Add.
43     The multiple of I*pi returned in the second position is always a Rational.
44 
45     Examples
46     ========
47 
48     >>> from sympy.functions.elementary.hyperbolic import _peeloff_ipi as peel
49     >>> from sympy import pi, I
50     >>> from sympy.abc import x, y
51     >>> peel(x + I*pi/2)
52     (x, I*pi/2)
53     >>> peel(x + I*2*pi/3 + I*pi*y)
54     (x + I*pi*y + I*pi/6, I*pi/2)
55     """
56     for a in Add.make_args(arg):
57         if a == S.Pi*S.ImaginaryUnit:
58             K = S.One
59             break
60         elif a.is_Mul:
61             K, p = a.as_two_terms()
62             if p == S.Pi*S.ImaginaryUnit and K.is_Rational:
63                 break
64     else:
65         return arg, S.Zero
66 
67     m1 = (K % S.Half)*S.Pi*S.ImaginaryUnit
68     m2 = K*S.Pi*S.ImaginaryUnit - m1
69     return arg - m2, m2
70 
71 
72 class sinh(HyperbolicFunction):
73     r"""
74     sinh(x) is the hyperbolic sine of x.
75 
76     The hyperbolic sine function is $\frac{e^x - e^{-x}}{2}$.
77 
78     Examples
79     ========
80 
81     >>> from sympy import sinh
82     >>> from sympy.abc import x
83     >>> sinh(x)
84     sinh(x)
85 
86     See Also
87     ========
88 
89     cosh, tanh, asinh
90     """
91 
92     def fdiff(self, argindex=1):
93         """
94         Returns the first derivative of this function.
95         """
96         if argindex == 1:
97             return cosh(self.args[0])
98         else:
99             raise ArgumentIndexError(self, argindex)
100 
101     def inverse(self, argindex=1):
102         """
103         Returns the inverse of this function.
104         """
105         return asinh
106 
107     @classmethod
108     def eval(cls, arg):
109         from sympy import sin
110 
111         arg = sympify(arg)
112 
113         if arg.is_Number:
114             if arg is S.NaN:
115                 return S.NaN
116             elif arg is S.Infinity:
117                 return S.Infinity
118             elif arg is S.NegativeInfinity:
119                 return S.NegativeInfinity
120             elif arg.is_zero:
121                 return S.Zero
122             elif arg.is_negative:
123                 return -cls(-arg)
124         else:
125             if arg is S.ComplexInfinity:
126                 return S.NaN
127 
128             i_coeff = arg.as_coefficient(S.ImaginaryUnit)
129 
130             if i_coeff is not None:
131                 return S.ImaginaryUnit * sin(i_coeff)
132             else:
133                 if _coeff_isneg(arg):
134                     return -cls(-arg)
135 
136             if arg.is_Add:
137                 x, m = _peeloff_ipi(arg)
138                 if m:
139                     return sinh(m)*cosh(x) + cosh(m)*sinh(x)
140 
141             if arg.is_zero:
142                 return S.Zero
143 
144             if arg.func == asinh:
145                 return arg.args[0]
146 
147             if arg.func == acosh:
148                 x = arg.args[0]
149                 return sqrt(x - 1) * sqrt(x + 1)
150 
151             if arg.func == atanh:
152                 x = arg.args[0]
153                 return x/sqrt(1 - x**2)
154 
155             if arg.func == acoth:
156                 x = arg.args[0]
157                 return 1/(sqrt(x - 1) * sqrt(x + 1))
158 
159     @staticmethod
160     @cacheit
161     def taylor_term(n, x, *previous_terms):
162         """
163         Returns the next term in the Taylor series expansion.
164         """
165         if n < 0 or n % 2 == 0:
166             return S.Zero
167         else:
168             x = sympify(x)
169 
170             if len(previous_terms) > 2:
171                 p = previous_terms[-2]
172                 return p * x**2 / (n*(n - 1))
173             else:
174                 return x**(n) / factorial(n)
175 
176     def _eval_conjugate(self):
177         return self.func(self.args[0].conjugate())
178 
179     def as_real_imag(self, deep=True, **hints):
180         """
181         Returns this function as a complex coordinate.
182         """
183         from sympy import cos, sin
184         if self.args[0].is_extended_real:
185             if deep:
186                 hints['complex'] = False
187                 return (self.expand(deep, **hints), S.Zero)
188             else:
189                 return (self, S.Zero)
190         if deep:
191             re, im = self.args[0].expand(deep, **hints).as_real_imag()
192         else:
193             re, im = self.args[0].as_real_imag()
194         return (sinh(re)*cos(im), cosh(re)*sin(im))
195 
196     def _eval_expand_complex(self, deep=True, **hints):
197         re_part, im_part = self.as_real_imag(deep=deep, **hints)
198         return re_part + im_part*S.ImaginaryUnit
199 
200     def _eval_expand_trig(self, deep=True, **hints):
201         if deep:
202             arg = self.args[0].expand(deep, **hints)
203         else:
204             arg = self.args[0]
205         x = None
206         if arg.is_Add: # TODO, implement more if deep stuff here
207             x, y = arg.as_two_terms()
208         else:
209             coeff, terms = arg.as_coeff_Mul(rational=True)
210             if coeff is not S.One and coeff.is_Integer and terms is not S.One:
211                 x = terms
212                 y = (coeff - 1)*x
213         if x is not None:
214             return (sinh(x)*cosh(y) + sinh(y)*cosh(x)).expand(trig=True)
215         return sinh(arg)
216 
217     def _eval_rewrite_as_tractable(self, arg, limitvar=None, **kwargs):
218         return (exp(arg) - exp(-arg)) / 2
219 
220     def _eval_rewrite_as_exp(self, arg, **kwargs):
221         return (exp(arg) - exp(-arg)) / 2
222 
223     def _eval_rewrite_as_cosh(self, arg, **kwargs):
224         return -S.ImaginaryUnit*cosh(arg + S.Pi*S.ImaginaryUnit/2)
225 
226     def _eval_rewrite_as_tanh(self, arg, **kwargs):
227         tanh_half = tanh(S.Half*arg)
228         return 2*tanh_half/(1 - tanh_half**2)
229 
230     def _eval_rewrite_as_coth(self, arg, **kwargs):
231         coth_half = coth(S.Half*arg)
232         return 2*coth_half/(coth_half**2 - 1)
233 
234     def _eval_as_leading_term(self, x, cdir=0):
235         from sympy import Order
236         arg = self.args[0].as_leading_term(x)
237 
238         if x in arg.free_symbols and Order(1, x).contains(arg):
239             return arg
240         else:
241             return self.func(arg)
242 
243     def _eval_is_real(self):
244         arg = self.args[0]
245         if arg.is_real:
246             return True
247 
248         # if `im` is of the form n*pi
249         # else, check if it is a number
250         re, im = arg.as_real_imag()
251         return (im%pi).is_zero
252 
253     def _eval_is_extended_real(self):
254         if self.args[0].is_extended_real:
255             return True
256 
257     def _eval_is_positive(self):
258         if self.args[0].is_extended_real:
259             return self.args[0].is_positive
260 
261     def _eval_is_negative(self):
262         if self.args[0].is_extended_real:
263             return self.args[0].is_negative
264 
265     def _eval_is_finite(self):
266         arg = self.args[0]
267         return arg.is_finite
268 
269     def _eval_is_zero(self):
270         arg = self.args[0]
271         if arg.is_zero:
272             return True
273 
274 
275 class cosh(HyperbolicFunction):
276     r"""
277     cosh(x) is the hyperbolic cosine of x.
278 
279     The hyperbolic cosine function is $\frac{e^x + e^{-x}}{2}$.
280 
281     Examples
282     ========
283 
284     >>> from sympy import cosh
285     >>> from sympy.abc import x
286     >>> cosh(x)
287     cosh(x)
288 
289     See Also
290     ========
291 
292     sinh, tanh, acosh
293     """
294 
295     def fdiff(self, argindex=1):
296         if argindex == 1:
297             return sinh(self.args[0])
298         else:
299             raise ArgumentIndexError(self, argindex)
300 
301     @classmethod
302     def eval(cls, arg):
303         from sympy import cos
304         arg = sympify(arg)
305 
306         if arg.is_Number:
307             if arg is S.NaN:
308                 return S.NaN
309             elif arg is S.Infinity:
310                 return S.Infinity
311             elif arg is S.NegativeInfinity:
312                 return S.Infinity
313             elif arg.is_zero:
314                 return S.One
315             elif arg.is_negative:
316                 return cls(-arg)
317         else:
318             if arg is S.ComplexInfinity:
319                 return S.NaN
320 
321             i_coeff = arg.as_coefficient(S.ImaginaryUnit)
322 
323             if i_coeff is not None:
324                 return cos(i_coeff)
325             else:
326                 if _coeff_isneg(arg):
327                     return cls(-arg)
328 
329             if arg.is_Add:
330                 x, m = _peeloff_ipi(arg)
331                 if m:
332                     return cosh(m)*cosh(x) + sinh(m)*sinh(x)
333 
334             if arg.is_zero:
335                 return S.One
336 
337             if arg.func == asinh:
338                 return sqrt(1 + arg.args[0]**2)
339 
340             if arg.func == acosh:
341                 return arg.args[0]
342 
343             if arg.func == atanh:
344                 return 1/sqrt(1 - arg.args[0]**2)
345 
346             if arg.func == acoth:
347                 x = arg.args[0]
348                 return x/(sqrt(x - 1) * sqrt(x + 1))
349 
350     @staticmethod
351     @cacheit
352     def taylor_term(n, x, *previous_terms):
353         if n < 0 or n % 2 == 1:
354             return S.Zero
355         else:
356             x = sympify(x)
357 
358             if len(previous_terms) > 2:
359                 p = previous_terms[-2]
360                 return p * x**2 / (n*(n - 1))
361             else:
362                 return x**(n)/factorial(n)
363 
364     def _eval_conjugate(self):
365         return self.func(self.args[0].conjugate())
366 
367     def as_real_imag(self, deep=True, **hints):
368         from sympy import cos, sin
369         if self.args[0].is_extended_real:
370             if deep:
371                 hints['complex'] = False
372                 return (self.expand(deep, **hints), S.Zero)
373             else:
374                 return (self, S.Zero)
375         if deep:
376             re, im = self.args[0].expand(deep, **hints).as_real_imag()
377         else:
378             re, im = self.args[0].as_real_imag()
379 
380         return (cosh(re)*cos(im), sinh(re)*sin(im))
381 
382     def _eval_expand_complex(self, deep=True, **hints):
383         re_part, im_part = self.as_real_imag(deep=deep, **hints)
384         return re_part + im_part*S.ImaginaryUnit
385 
386     def _eval_expand_trig(self, deep=True, **hints):
387         if deep:
388             arg = self.args[0].expand(deep, **hints)
389         else:
390             arg = self.args[0]
391         x = None
392         if arg.is_Add: # TODO, implement more if deep stuff here
393             x, y = arg.as_two_terms()
394         else:
395             coeff, terms = arg.as_coeff_Mul(rational=True)
396             if coeff is not S.One and coeff.is_Integer and terms is not S.One:
397                 x = terms
398                 y = (coeff - 1)*x
399         if x is not None:
400             return (cosh(x)*cosh(y) + sinh(x)*sinh(y)).expand(trig=True)
401         return cosh(arg)
402 
403     def _eval_rewrite_as_tractable(self, arg, limitvar=None, **kwargs):
404         return (exp(arg) + exp(-arg)) / 2
405 
406     def _eval_rewrite_as_exp(self, arg, **kwargs):
407         return (exp(arg) + exp(-arg)) / 2
408 
409     def _eval_rewrite_as_sinh(self, arg, **kwargs):
410         return -S.ImaginaryUnit*sinh(arg + S.Pi*S.ImaginaryUnit/2)
411 
412     def _eval_rewrite_as_tanh(self, arg, **kwargs):
413         tanh_half = tanh(S.Half*arg)**2
414         return (1 + tanh_half)/(1 - tanh_half)
415 
416     def _eval_rewrite_as_coth(self, arg, **kwargs):
417         coth_half = coth(S.Half*arg)**2
418         return (coth_half + 1)/(coth_half - 1)
419 
420     def _eval_as_leading_term(self, x, cdir=0):
421         from sympy import Order
422         arg = self.args[0].as_leading_term(x)
423 
424         if x in arg.free_symbols and Order(1, x).contains(arg):
425             return S.One
426         else:
427             return self.func(arg)
428 
429     def _eval_is_real(self):
430         arg = self.args[0]
431 
432         # `cosh(x)` is real for real OR purely imaginary `x`
433         if arg.is_real or arg.is_imaginary:
434             return True
435 
436         # cosh(a+ib) = cos(b)*cosh(a) + i*sin(b)*sinh(a)
437         # the imaginary part can be an expression like n*pi
438         # if not, check if the imaginary part is a number
439         re, im = arg.as_real_imag()
440         return (im%pi).is_zero
441 
442     def _eval_is_positive(self):
443         # cosh(x+I*y) = cos(y)*cosh(x) + I*sin(y)*sinh(x)
444         # cosh(z) is positive iff it is real and the real part is positive.
445         # So we need sin(y)*sinh(x) = 0 which gives x=0 or y=n*pi
446         # Case 1 (y=n*pi): cosh(z) = (-1)**n * cosh(x) -> positive for n even
447         # Case 2 (x=0): cosh(z) = cos(y) -> positive when cos(y) is positive
448         z = self.args[0]
449 
450         x, y = z.as_real_imag()
451         ymod = y % (2*pi)
452 
453         yzero = ymod.is_zero
454         # shortcut if ymod is zero
455         if yzero:
456             return True
457 
458         xzero = x.is_zero
459         # shortcut x is not zero
460         if xzero is False:
461             return yzero
462 
463         return fuzzy_or([
464                 # Case 1:
465                 yzero,
466                 # Case 2:
467                 fuzzy_and([
468                     xzero,
469                     fuzzy_or([ymod < pi/2, ymod > 3*pi/2])
470                 ])
471             ])
472 
473 
474     def _eval_is_nonnegative(self):
475         z = self.args[0]
476 
477         x, y = z.as_real_imag()
478         ymod = y % (2*pi)
479 
480         yzero = ymod.is_zero
481         # shortcut if ymod is zero
482         if yzero:
483             return True
484 
485         xzero = x.is_zero
486         # shortcut x is not zero
487         if xzero is False:
488             return yzero
489 
490         return fuzzy_or([
491                 # Case 1:
492                 yzero,
493                 # Case 2:
494                 fuzzy_and([
495                     xzero,
496                     fuzzy_or([ymod <= pi/2, ymod >= 3*pi/2])
497                 ])
498             ])
499 
500     def _eval_is_finite(self):
501         arg = self.args[0]
502         return arg.is_finite
503 
504 
505 class tanh(HyperbolicFunction):
506     r"""
507     tanh(x) is the hyperbolic tangent of x.
508 
509     The hyperbolic tangent function is $\frac{\sinh(x)}{\cosh(x)}$.
510 
511     Examples
512     ========
513 
514     >>> from sympy import tanh
515     >>> from sympy.abc import x
516     >>> tanh(x)
517     tanh(x)
518 
519     See Also
520     ========
521 
522     sinh, cosh, atanh
523     """
524 
525     def fdiff(self, argindex=1):
526         if argindex == 1:
527             return S.One - tanh(self.args[0])**2
528         else:
529             raise ArgumentIndexError(self, argindex)
530 
531     def inverse(self, argindex=1):
532         """
533         Returns the inverse of this function.
534         """
535         return atanh
536 
537     @classmethod
538     def eval(cls, arg):
539         from sympy import tan
540         arg = sympify(arg)
541 
542         if arg.is_Number:
543             if arg is S.NaN:
544                 return S.NaN
545             elif arg is S.Infinity:
546                 return S.One
547             elif arg is S.NegativeInfinity:
548                 return S.NegativeOne
549             elif arg.is_zero:
550                 return S.Zero
551             elif arg.is_negative:
552                 return -cls(-arg)
553         else:
554             if arg is S.ComplexInfinity:
555                 return S.NaN
556 
557             i_coeff = arg.as_coefficient(S.ImaginaryUnit)
558 
559             if i_coeff is not None:
560                 if _coeff_isneg(i_coeff):
561                     return -S.ImaginaryUnit * tan(-i_coeff)
562                 return S.ImaginaryUnit * tan(i_coeff)
563             else:
564                 if _coeff_isneg(arg):
565                     return -cls(-arg)
566 
567             if arg.is_Add:
568                 x, m = _peeloff_ipi(arg)
569                 if m:
570                     tanhm = tanh(m)
571                     if tanhm is S.ComplexInfinity:
572                         return coth(x)
573                     else: # tanhm == 0
574                         return tanh(x)
575 
576             if arg.is_zero:
577                 return S.Zero
578 
579             if arg.func == asinh:
580                 x = arg.args[0]
581                 return x/sqrt(1 + x**2)
582 
583             if arg.func == acosh:
584                 x = arg.args[0]
585                 return sqrt(x - 1) * sqrt(x + 1) / x
586 
587             if arg.func == atanh:
588                 return arg.args[0]
589 
590             if arg.func == acoth:
591                 return 1/arg.args[0]
592 
593     @staticmethod
594     @cacheit
595     def taylor_term(n, x, *previous_terms):
596         from sympy import bernoulli
597         if n < 0 or n % 2 == 0:
598             return S.Zero
599         else:
600             x = sympify(x)
601 
602             a = 2**(n + 1)
603 
604             B = bernoulli(n + 1)
605             F = factorial(n + 1)
606 
607             return a*(a - 1) * B/F * x**n
608 
609     def _eval_conjugate(self):
610         return self.func(self.args[0].conjugate())
611 
612     def as_real_imag(self, deep=True, **hints):
613         from sympy import cos, sin
614         if self.args[0].is_extended_real:
615             if deep:
616                 hints['complex'] = False
617                 return (self.expand(deep, **hints), S.Zero)
618             else:
619                 return (self, S.Zero)
620         if deep:
621             re, im = self.args[0].expand(deep, **hints).as_real_imag()
622         else:
623             re, im = self.args[0].as_real_imag()
624         denom = sinh(re)**2 + cos(im)**2
625         return (sinh(re)*cosh(re)/denom, sin(im)*cos(im)/denom)
626 
627     def _eval_expand_trig(self, **hints):
628         arg = self.args[0]
629         if arg.is_Add:
630             from sympy import symmetric_poly
631             n = len(arg.args)
632             TX = [tanh(x, evaluate=False)._eval_expand_trig()
633                 for x in arg.args]
634             p = [0, 0]  # [den, num]
635             for i in range(n + 1):
636                 p[i % 2] += symmetric_poly(i, TX)
637             return p[1]/p[0]
638         elif arg.is_Mul:
639             from sympy.functions.combinatorial.numbers import nC
640             coeff, terms = arg.as_coeff_Mul()
641             if coeff.is_Integer and coeff > 1:
642                 n = []
643                 d = []
644                 T = tanh(terms)
645                 for k in range(1, coeff + 1, 2):
646                     n.append(nC(range(coeff), k)*T**k)
647                 for k in range(0, coeff + 1, 2):
648                     d.append(nC(range(coeff), k)*T**k)
649                 return Add(*n)/Add(*d)
650         return tanh(arg)
651 
652     def _eval_rewrite_as_tractable(self, arg, limitvar=None, **kwargs):
653         neg_exp, pos_exp = exp(-arg), exp(arg)
654         return (pos_exp - neg_exp)/(pos_exp + neg_exp)
655 
656     def _eval_rewrite_as_exp(self, arg, **kwargs):
657         neg_exp, pos_exp = exp(-arg), exp(arg)
658         return (pos_exp - neg_exp)/(pos_exp + neg_exp)
659 
660     def _eval_rewrite_as_sinh(self, arg, **kwargs):
661         return S.ImaginaryUnit*sinh(arg)/sinh(S.Pi*S.ImaginaryUnit/2 - arg)
662 
663     def _eval_rewrite_as_cosh(self, arg, **kwargs):
664         return S.ImaginaryUnit*cosh(S.Pi*S.ImaginaryUnit/2 - arg)/cosh(arg)
665 
666     def _eval_rewrite_as_coth(self, arg, **kwargs):
667         return 1/coth(arg)
668 
669     def _eval_as_leading_term(self, x, cdir=0):
670         from sympy import Order
671         arg = self.args[0].as_leading_term(x)
672 
673         if x in arg.free_symbols and Order(1, x).contains(arg):
674             return arg
675         else:
676             return self.func(arg)
677 
678     def _eval_is_real(self):
679         arg = self.args[0]
680         if arg.is_real:
681             return True
682 
683         re, im = arg.as_real_imag()
684 
685         # if denom = 0, tanh(arg) = zoo
686         if re == 0 and im % pi == pi/2:
687             return None
688 
689         # check if im is of the form n*pi/2 to make sin(2*im) = 0
690         # if not, im could be a number, return False in that case
691         return (im % (pi/2)).is_zero
692 
693     def _eval_is_extended_real(self):
694         if self.args[0].is_extended_real:
695             return True
696 
697     def _eval_is_positive(self):
698         if self.args[0].is_extended_real:
699             return self.args[0].is_positive
700 
701     def _eval_is_negative(self):
702         if self.args[0].is_extended_real:
703             return self.args[0].is_negative
704 
705     def _eval_is_finite(self):
706         from sympy import sinh, cos
707         arg = self.args[0]
708 
709         re, im = arg.as_real_imag()
710         denom = cos(im)**2 + sinh(re)**2
711         if denom == 0:
712             return False
713         elif denom.is_number:
714             return True
715         if arg.is_extended_real:
716             return True
717 
718     def _eval_is_zero(self):
719         arg = self.args[0]
720         if arg.is_zero:
721             return True
722 
723 
724 class coth(HyperbolicFunction):
725     r"""
726     coth(x) is the hyperbolic cotangent of x.
727 
728     The hyperbolic cotangent function is $\frac{\cosh(x)}{\sinh(x)}$.
729 
730     Examples
731     ========
732 
733     >>> from sympy import coth
734     >>> from sympy.abc import x
735     >>> coth(x)
736     coth(x)
737 
738     See Also
739     ========
740 
741     sinh, cosh, acoth
742     """
743 
744     def fdiff(self, argindex=1):
745         if argindex == 1:
746             return -1/sinh(self.args[0])**2
747         else:
748             raise ArgumentIndexError(self, argindex)
749 
750     def inverse(self, argindex=1):
751         """
752         Returns the inverse of this function.
753         """
754         return acoth
755 
756     @classmethod
757     def eval(cls, arg):
758         from sympy import cot
759         arg = sympify(arg)
760 
761         if arg.is_Number:
762             if arg is S.NaN:
763                 return S.NaN
764             elif arg is S.Infinity:
765                 return S.One
766             elif arg is S.NegativeInfinity:
767                 return S.NegativeOne
768             elif arg.is_zero:
769                 return S.ComplexInfinity
770             elif arg.is_negative:
771                 return -cls(-arg)
772         else:
773             if arg is S.ComplexInfinity:
774                 return S.NaN
775 
776             i_coeff = arg.as_coefficient(S.ImaginaryUnit)
777 
778             if i_coeff is not None:
779                 if _coeff_isneg(i_coeff):
780                     return S.ImaginaryUnit * cot(-i_coeff)
781                 return -S.ImaginaryUnit * cot(i_coeff)
782             else:
783                 if _coeff_isneg(arg):
784                     return -cls(-arg)
785 
786             if arg.is_Add:
787                 x, m = _peeloff_ipi(arg)
788                 if m:
789                     cothm = coth(m)
790                     if cothm is S.ComplexInfinity:
791                         return coth(x)
792                     else: # cothm == 0
793                         return tanh(x)
794 
795             if arg.is_zero:
796                 return S.ComplexInfinity
797 
798             if arg.func == asinh:
799                 x = arg.args[0]
800                 return sqrt(1 + x**2)/x
801 
802             if arg.func == acosh:
803                 x = arg.args[0]
804                 return x/(sqrt(x - 1) * sqrt(x + 1))
805 
806             if arg.func == atanh:
807                 return 1/arg.args[0]
808 
809             if arg.func == acoth:
810                 return arg.args[0]
811 
812     @staticmethod
813     @cacheit
814     def taylor_term(n, x, *previous_terms):
815         from sympy import bernoulli
816         if n == 0:
817             return 1 / sympify(x)
818         elif n < 0 or n % 2 == 0:
819             return S.Zero
820         else:
821             x = sympify(x)
822 
823             B = bernoulli(n + 1)
824             F = factorial(n + 1)
825 
826             return 2**(n + 1) * B/F * x**n
827 
828     def _eval_conjugate(self):
829         return self.func(self.args[0].conjugate())
830 
831     def as_real_imag(self, deep=True, **hints):
832         from sympy import cos, sin
833         if self.args[0].is_extended_real:
834             if deep:
835                 hints['complex'] = False
836                 return (self.expand(deep, **hints), S.Zero)
837             else:
838                 return (self, S.Zero)
839         if deep:
840             re, im = self.args[0].expand(deep, **hints).as_real_imag()
841         else:
842             re, im = self.args[0].as_real_imag()
843         denom = sinh(re)**2 + sin(im)**2
844         return (sinh(re)*cosh(re)/denom, -sin(im)*cos(im)/denom)
845 
846     def _eval_rewrite_as_tractable(self, arg, limitvar=None, **kwargs):
847         neg_exp, pos_exp = exp(-arg), exp(arg)
848         return (pos_exp + neg_exp)/(pos_exp - neg_exp)
849 
850     def _eval_rewrite_as_exp(self, arg, **kwargs):
851         neg_exp, pos_exp = exp(-arg), exp(arg)
852         return (pos_exp + neg_exp)/(pos_exp - neg_exp)
853 
854     def _eval_rewrite_as_sinh(self, arg, **kwargs):
855         return -S.ImaginaryUnit*sinh(S.Pi*S.ImaginaryUnit/2 - arg)/sinh(arg)
856 
857     def _eval_rewrite_as_cosh(self, arg, **kwargs):
858         return -S.ImaginaryUnit*cosh(arg)/cosh(S.Pi*S.ImaginaryUnit/2 - arg)
859 
860     def _eval_rewrite_as_tanh(self, arg, **kwargs):
861         return 1/tanh(arg)
862 
863     def _eval_is_positive(self):
864         if self.args[0].is_extended_real:
865             return self.args[0].is_positive
866 
867     def _eval_is_negative(self):
868         if self.args[0].is_extended_real:
869             return self.args[0].is_negative
870 
871     def _eval_as_leading_term(self, x, cdir=0):
872         from sympy import Order
873         arg = self.args[0].as_leading_term(x)
874 
875         if x in arg.free_symbols and Order(1, x).contains(arg):
876             return 1/arg
877         else:
878             return self.func(arg)
879 
880 
881 class ReciprocalHyperbolicFunction(HyperbolicFunction):
882     """Base class for reciprocal functions of hyperbolic functions. """
883 
884     #To be defined in class
885     _reciprocal_of = None
886     _is_even = None  # type: FuzzyBool
887     _is_odd = None  # type: FuzzyBool
888 
889     @classmethod
890     def eval(cls, arg):
891         if arg.could_extract_minus_sign():
892             if cls._is_even:
893                 return cls(-arg)
894             if cls._is_odd:
895                 return -cls(-arg)
896 
897         t = cls._reciprocal_of.eval(arg)
898         if hasattr(arg, 'inverse') and arg.inverse() == cls:
899             return arg.args[0]
900         return 1/t if t is not None else t
901 
902     def _call_reciprocal(self, method_name, *args, **kwargs):
903         # Calls method_name on _reciprocal_of
904         o = self._reciprocal_of(self.args[0])
905         return getattr(o, method_name)(*args, **kwargs)
906 
907     def _calculate_reciprocal(self, method_name, *args, **kwargs):
908         # If calling method_name on _reciprocal_of returns a value != None
909         # then return the reciprocal of that value
910         t = self._call_reciprocal(method_name, *args, **kwargs)
911         return 1/t if t is not None else t
912 
913     def _rewrite_reciprocal(self, method_name, arg):
914         # Special handling for rewrite functions. If reciprocal rewrite returns
915         # unmodified expression, then return None
916         t = self._call_reciprocal(method_name, arg)
917         if t is not None and t != self._reciprocal_of(arg):
918             return 1/t
919 
920     def _eval_rewrite_as_exp(self, arg, **kwargs):
921         return self._rewrite_reciprocal("_eval_rewrite_as_exp", arg)
922 
923     def _eval_rewrite_as_tractable(self, arg, limitvar=None, **kwargs):
924         return self._rewrite_reciprocal("_eval_rewrite_as_tractable", arg)
925 
926     def _eval_rewrite_as_tanh(self, arg, **kwargs):
927         return self._rewrite_reciprocal("_eval_rewrite_as_tanh", arg)
928 
929     def _eval_rewrite_as_coth(self, arg, **kwargs):
930         return self._rewrite_reciprocal("_eval_rewrite_as_coth", arg)
931 
932     def as_real_imag(self, deep = True, **hints):
933         return (1 / self._reciprocal_of(self.args[0])).as_real_imag(deep, **hints)
934 
935     def _eval_conjugate(self):
936         return self.func(self.args[0].conjugate())
937 
938     def _eval_expand_complex(self, deep=True, **hints):
939         re_part, im_part = self.as_real_imag(deep=True, **hints)
940         return re_part + S.ImaginaryUnit*im_part
941 
942     def _eval_as_leading_term(self, x, cdir=0):
943         return (1/self._reciprocal_of(self.args[0]))._eval_as_leading_term(x)
944 
945     def _eval_is_extended_real(self):
946         return self._reciprocal_of(self.args[0]).is_extended_real
947 
948     def _eval_is_finite(self):
949         return (1/self._reciprocal_of(self.args[0])).is_finite
950 
951 
952 class csch(ReciprocalHyperbolicFunction):
953     r"""
954     csch(x) is the hyperbolic cosecant of x.
955 
956     The hyperbolic cosecant function is $\frac{2}{e^x - e^{-x}}$
957 
958     Examples
959     ========
960 
961     >>> from sympy import csch
962     >>> from sympy.abc import x
963     >>> csch(x)
964     csch(x)
965 
966     See Also
967     ========
968 
969     sinh, cosh, tanh, sech, asinh, acosh
970     """
971 
972     _reciprocal_of = sinh
973     _is_odd = True
974 
975     def fdiff(self, argindex=1):
976         """
977         Returns the first derivative of this function
978         """
979         if argindex == 1:
980             return -coth(self.args[0]) * csch(self.args[0])
981         else:
982             raise ArgumentIndexError(self, argindex)
983 
984     @staticmethod
985     @cacheit
986     def taylor_term(n, x, *previous_terms):
987         """
988         Returns the next term in the Taylor series expansion
989         """
990         from sympy import bernoulli
991         if n == 0:
992             return 1/sympify(x)
993         elif n < 0 or n % 2 == 0:
994             return S.Zero
995         else:
996             x = sympify(x)
997 
998             B = bernoulli(n + 1)
999             F = factorial(n + 1)
1000 
1001             return 2 * (1 - 2**n) * B/F * x**n
1002 
1003     def _eval_rewrite_as_cosh(self, arg, **kwargs):
1004         return S.ImaginaryUnit / cosh(arg + S.ImaginaryUnit * S.Pi / 2)
1005 
1006     def _eval_is_positive(self):
1007         if self.args[0].is_extended_real:
1008             return self.args[0].is_positive
1009 
1010     def _eval_is_negative(self):
1011         if self.args[0].is_extended_real:
1012             return self.args[0].is_negative
1013 
1014     def _sage_(self):
1015         import sage.all as sage
1016         return sage.csch(self.args[0]._sage_())
1017 
1018 
1019 class sech(ReciprocalHyperbolicFunction):
1020     r"""
1021     sech(x) is the hyperbolic secant of x.
1022 
1023     The hyperbolic secant function is $\frac{2}{e^x + e^{-x}}$
1024 
1025     Examples
1026     ========
1027 
1028     >>> from sympy import sech
1029     >>> from sympy.abc import x
1030     >>> sech(x)
1031     sech(x)
1032 
1033     See Also
1034     ========
1035 
1036     sinh, cosh, tanh, coth, csch, asinh, acosh
1037     """
1038 
1039     _reciprocal_of = cosh
1040     _is_even = True
1041 
1042     def fdiff(self, argindex=1):
1043         if argindex == 1:
1044             return - tanh(self.args[0])*sech(self.args[0])
1045         else:
1046             raise ArgumentIndexError(self, argindex)
1047 
1048     @staticmethod
1049     @cacheit
1050     def taylor_term(n, x, *previous_terms):
1051         from sympy.functions.combinatorial.numbers import euler
1052         if n < 0 or n % 2 == 1:
1053             return S.Zero
1054         else:
1055             x = sympify(x)
1056             return euler(n) / factorial(n) * x**(n)
1057 
1058     def _eval_rewrite_as_sinh(self, arg, **kwargs):
1059         return S.ImaginaryUnit / sinh(arg + S.ImaginaryUnit * S.Pi /2)
1060 
1061     def _eval_is_positive(self):
1062         if self.args[0].is_extended_real:
1063             return True
1064 
1065     def _sage_(self):
1066         import sage.all as sage
1067         return sage.sech(self.args[0]._sage_())
1068 
1069 
1070 
1071 ###############################################################################
1072 ############################# HYPERBOLIC INVERSES #############################
1073 ###############################################################################
1074 
1075 class InverseHyperbolicFunction(Function):
1076     """Base class for inverse hyperbolic functions."""
1077 
1078     pass
1079 
1080 
1081 class asinh(InverseHyperbolicFunction):
1082     """
1083     asinh(x) is the inverse hyperbolic sine of x.
1084 
1085     The inverse hyperbolic sine function.
1086 
1087     Examples
1088     ========
1089 
1090     >>> from sympy import asinh
1091     >>> from sympy.abc import x
1092     >>> asinh(x).diff(x)
1093     1/sqrt(x**2 + 1)
1094     >>> asinh(1)
1095     log(1 + sqrt(2))
1096 
1097     See Also
1098     ========
1099 
1100     acosh, atanh, sinh
1101     """
1102 
1103     def fdiff(self, argindex=1):
1104         if argindex == 1:
1105             return 1/sqrt(self.args[0]**2 + 1)
1106         else:
1107             raise ArgumentIndexError(self, argindex)
1108 
1109     @classmethod
1110     def eval(cls, arg):
1111         from sympy import asin
1112         arg = sympify(arg)
1113 
1114         if arg.is_Number:
1115             if arg is S.NaN:
1116                 return S.NaN
1117             elif arg is S.Infinity:
1118                 return S.Infinity
1119             elif arg is S.NegativeInfinity:
1120                 return S.NegativeInfinity
1121             elif arg.is_zero:
1122                 return S.Zero
1123             elif arg is S.One:
1124                 return log(sqrt(2) + 1)
1125             elif arg is S.NegativeOne:
1126                 return log(sqrt(2) - 1)
1127             elif arg.is_negative:
1128                 return -cls(-arg)
1129         else:
1130             if arg is S.ComplexInfinity:
1131                 return S.ComplexInfinity
1132 
1133             if arg.is_zero:
1134                 return S.Zero
1135 
1136             i_coeff = arg.as_coefficient(S.ImaginaryUnit)
1137 
1138             if i_coeff is not None:
1139                 return S.ImaginaryUnit * asin(i_coeff)
1140             else:
1141                 if _coeff_isneg(arg):
1142                     return -cls(-arg)
1143 
1144         if isinstance(arg, sinh) and arg.args[0].is_number:
1145             z = arg.args[0]
1146             if z.is_real:
1147                 return z
1148             r, i = match_real_imag(z)
1149             if r is not None and i is not None:
1150                 f = floor((i + pi/2)/pi)
1151                 m = z - I*pi*f
1152                 even = f.is_even
1153                 if even is True:
1154                     return m
1155                 elif even is False:
1156                     return -m
1157 
1158     @staticmethod
1159     @cacheit
1160     def taylor_term(n, x, *previous_terms):
1161         if n < 0 or n % 2 == 0:
1162             return S.Zero
1163         else:
1164             x = sympify(x)
1165             if len(previous_terms) >= 2 and n > 2:
1166                 p = previous_terms[-2]
1167                 return -p * (n - 2)**2/(n*(n - 1)) * x**2
1168             else:
1169                 k = (n - 1) // 2
1170                 R = RisingFactorial(S.Half, k)
1171                 F = factorial(k)
1172                 return (-1)**k * R / F * x**n / n
1173 
1174     def _eval_as_leading_term(self, x, cdir=0):
1175         from sympy import Order
1176         arg = self.args[0].as_leading_term(x)
1177 
1178         if x in arg.free_symbols and Order(1, x).contains(arg):
1179             return arg
1180         else:
1181             return self.func(arg)
1182 
1183     def _eval_rewrite_as_log(self, x, **kwargs):
1184         return log(x + sqrt(x**2 + 1))
1185 
1186     def inverse(self, argindex=1):
1187         """
1188         Returns the inverse of this function.
1189         """
1190         return sinh
1191 
1192     def _eval_is_zero(self):
1193         arg = self.args[0]
1194         if arg.is_zero:
1195             return True
1196 
1197 
1198 class acosh(InverseHyperbolicFunction):
1199     """
1200     acosh(x) is the inverse hyperbolic cosine of x.
1201 
1202     The inverse hyperbolic cosine function.
1203 
1204     Examples
1205     ========
1206 
1207     >>> from sympy import acosh
1208     >>> from sympy.abc import x
1209     >>> acosh(x).diff(x)
1210     1/sqrt(x**2 - 1)
1211     >>> acosh(1)
1212     0
1213 
1214     See Also
1215     ========
1216 
1217     asinh, atanh, cosh
1218     """
1219 
1220     def fdiff(self, argindex=1):
1221         if argindex == 1:
1222             return 1/sqrt(self.args[0]**2 - 1)
1223         else:
1224             raise ArgumentIndexError(self, argindex)
1225 
1226     @classmethod
1227     def eval(cls, arg):
1228         arg = sympify(arg)
1229 
1230         if arg.is_Number:
1231             if arg is S.NaN:
1232                 return S.NaN
1233             elif arg is S.Infinity:
1234                 return S.Infinity
1235             elif arg is S.NegativeInfinity:
1236                 return S.Infinity
1237             elif arg.is_zero:
1238                 return S.Pi*S.ImaginaryUnit / 2
1239             elif arg is S.One:
1240                 return S.Zero
1241             elif arg is S.NegativeOne:
1242                 return S.Pi*S.ImaginaryUnit
1243 
1244         if arg.is_number:
1245             cst_table = {
1246                 S.ImaginaryUnit: log(S.ImaginaryUnit*(1 + sqrt(2))),
1247                 -S.ImaginaryUnit: log(-S.ImaginaryUnit*(1 + sqrt(2))),
1248                 S.Half: S.Pi/3,
1249                 Rational(-1, 2): S.Pi*Rational(2, 3),
1250                 sqrt(2)/2: S.Pi/4,
1251                 -sqrt(2)/2: S.Pi*Rational(3, 4),
1252                 1/sqrt(2): S.Pi/4,
1253                 -1/sqrt(2): S.Pi*Rational(3, 4),
1254                 sqrt(3)/2: S.Pi/6,
1255                 -sqrt(3)/2: S.Pi*Rational(5, 6),
1256                 (sqrt(3) - 1)/sqrt(2**3): S.Pi*Rational(5, 12),
1257                 -(sqrt(3) - 1)/sqrt(2**3): S.Pi*Rational(7, 12),
1258                 sqrt(2 + sqrt(2))/2: S.Pi/8,
1259                 -sqrt(2 + sqrt(2))/2: S.Pi*Rational(7, 8),
1260                 sqrt(2 - sqrt(2))/2: S.Pi*Rational(3, 8),
1261                 -sqrt(2 - sqrt(2))/2: S.Pi*Rational(5, 8),
1262                 (1 + sqrt(3))/(2*sqrt(2)): S.Pi/12,
1263                 -(1 + sqrt(3))/(2*sqrt(2)): S.Pi*Rational(11, 12),
1264                 (sqrt(5) + 1)/4: S.Pi/5,
1265                 -(sqrt(5) + 1)/4: S.Pi*Rational(4, 5)
1266             }
1267 
1268             if arg in cst_table:
1269                 if arg.is_extended_real:
1270                     return cst_table[arg]*S.ImaginaryUnit
1271                 return cst_table[arg]
1272 
1273         if arg is S.ComplexInfinity:
1274             return S.ComplexInfinity
1275         if arg == S.ImaginaryUnit*S.Infinity:
1276             return S.Infinity + S.ImaginaryUnit*S.Pi/2
1277         if arg == -S.ImaginaryUnit*S.Infinity:
1278             return S.Infinity - S.ImaginaryUnit*S.Pi/2
1279 
1280         if arg.is_zero:
1281             return S.Pi*S.ImaginaryUnit*S.Half
1282 
1283         if isinstance(arg, cosh) and arg.args[0].is_number:
1284             z = arg.args[0]
1285             if z.is_real:
1286                 from sympy.functions.elementary.complexes import Abs
1287                 return Abs(z)
1288             r, i = match_real_imag(z)
1289             if r is not None and i is not None:
1290                 f = floor(i/pi)
1291                 m = z - I*pi*f
1292                 even = f.is_even
1293                 if even is True:
1294                     if r.is_nonnegative:
1295                         return m
1296                     elif r.is_negative:
1297                         return -m
1298                 elif even is False:
1299                     m -= I*pi
1300                     if r.is_nonpositive:
1301                         return -m
1302                     elif r.is_positive:
1303                         return m
1304 
1305     @staticmethod
1306     @cacheit
1307     def taylor_term(n, x, *previous_terms):
1308         if n == 0:
1309             return S.Pi*S.ImaginaryUnit / 2
1310         elif n < 0 or n % 2 == 0:
1311             return S.Zero
1312         else:
1313             x = sympify(x)
1314             if len(previous_terms) >= 2 and n > 2:
1315                 p = previous_terms[-2]
1316                 return p * (n - 2)**2/(n*(n - 1)) * x**2
1317             else:
1318                 k = (n - 1) // 2
1319                 R = RisingFactorial(S.Half, k)
1320                 F = factorial(k)
1321                 return -R / F * S.ImaginaryUnit * x**n / n
1322 
1323     def _eval_as_leading_term(self, x, cdir=0):
1324         from sympy import Order
1325         arg = self.args[0].as_leading_term(x)
1326 
1327         if x in arg.free_symbols and Order(1, x).contains(arg):
1328             return S.ImaginaryUnit*S.Pi/2
1329         else:
1330             return self.func(arg)
1331 
1332     def _eval_rewrite_as_log(self, x, **kwargs):
1333         return log(x + sqrt(x + 1) * sqrt(x - 1))
1334 
1335     def inverse(self, argindex=1):
1336         """
1337         Returns the inverse of this function.
1338         """
1339         return cosh
1340 
1341 
1342 class atanh(InverseHyperbolicFunction):
1343     """
1344     atanh(x) is the inverse hyperbolic tangent of x.
1345 
1346     The inverse hyperbolic tangent function.
1347 
1348     Examples
1349     ========
1350 
1351     >>> from sympy import atanh
1352     >>> from sympy.abc import x
1353     >>> atanh(x).diff(x)
1354     1/(1 - x**2)
1355 
1356     See Also
1357     ========
1358 
1359     asinh, acosh, tanh
1360     """
1361 
1362     def fdiff(self, argindex=1):
1363         if argindex == 1:
1364             return 1/(1 - self.args[0]**2)
1365         else:
1366             raise ArgumentIndexError(self, argindex)
1367 
1368     @classmethod
1369     def eval(cls, arg):
1370         from sympy import atan
1371         arg = sympify(arg)
1372 
1373         if arg.is_Number:
1374             if arg is S.NaN:
1375                 return S.NaN
1376             elif arg.is_zero:
1377                 return S.Zero
1378             elif arg is S.One:
1379                 return S.Infinity
1380             elif arg is S.NegativeOne:
1381                 return S.NegativeInfinity
1382             elif arg is S.Infinity:
1383                 return -S.ImaginaryUnit * atan(arg)
1384             elif arg is S.NegativeInfinity:
1385                 return S.ImaginaryUnit * atan(-arg)
1386             elif arg.is_negative:
1387                 return -cls(-arg)
1388         else:
1389             if arg is S.ComplexInfinity:
1390                 from sympy.calculus.util import AccumBounds
1391                 return S.ImaginaryUnit*AccumBounds(-S.Pi/2, S.Pi/2)
1392 
1393             i_coeff = arg.as_coefficient(S.ImaginaryUnit)
1394 
1395             if i_coeff is not None:
1396                 return S.ImaginaryUnit * atan(i_coeff)
1397             else:
1398                 if _coeff_isneg(arg):
1399                     return -cls(-arg)
1400 
1401         if arg.is_zero:
1402             return S.Zero
1403 
1404         if isinstance(arg, tanh) and arg.args[0].is_number:
1405             z = arg.args[0]
1406             if z.is_real:
1407                 return z
1408             r, i = match_real_imag(z)
1409             if r is not None and i is not None:
1410                 f = floor(2*i/pi)
1411                 even = f.is_even
1412                 m = z - I*f*pi/2
1413                 if even is True:
1414                     return m
1415                 elif even is False:
1416                     return m - I*pi/2
1417 
1418     @staticmethod
1419     @cacheit
1420     def taylor_term(n, x, *previous_terms):
1421         if n < 0 or n % 2 == 0:
1422             return S.Zero
1423         else:
1424             x = sympify(x)
1425             return x**n / n
1426 
1427     def _eval_as_leading_term(self, x, cdir=0):
1428         from sympy import Order
1429         arg = self.args[0].as_leading_term(x)
1430 
1431         if x in arg.free_symbols and Order(1, x).contains(arg):
1432             return arg
1433         else:
1434             return self.func(arg)
1435 
1436     def _eval_rewrite_as_log(self, x, **kwargs):
1437         return (log(1 + x) - log(1 - x)) / 2
1438 
1439     def _eval_is_zero(self):
1440         arg = self.args[0]
1441         if arg.is_zero:
1442             return True
1443 
1444 
1445     def inverse(self, argindex=1):
1446         """
1447         Returns the inverse of this function.
1448         """
1449         return tanh
1450 
1451 
1452 class acoth(InverseHyperbolicFunction):
1453     """
1454     acoth(x) is the inverse hyperbolic cotangent of x.
1455 
1456     The inverse hyperbolic cotangent function.
1457 
1458     Examples
1459     ========
1460 
1461     >>> from sympy import acoth
1462     >>> from sympy.abc import x
1463     >>> acoth(x).diff(x)
1464     1/(1 - x**2)
1465 
1466     See Also
1467     ========
1468 
1469     asinh, acosh, coth
1470     """
1471 
1472     def fdiff(self, argindex=1):
1473         if argindex == 1:
1474             return 1/(1 - self.args[0]**2)
1475         else:
1476             raise ArgumentIndexError(self, argindex)
1477 
1478     @classmethod
1479     def eval(cls, arg):
1480         from sympy import acot
1481         arg = sympify(arg)
1482 
1483         if arg.is_Number:
1484             if arg is S.NaN:
1485                 return S.NaN
1486             elif arg is S.Infinity:
1487                 return S.Zero
1488             elif arg is S.NegativeInfinity:
1489                 return S.Zero
1490             elif arg.is_zero:
1491                 return S.Pi*S.ImaginaryUnit / 2
1492             elif arg is S.One:
1493                 return S.Infinity
1494             elif arg is S.NegativeOne:
1495                 return S.NegativeInfinity
1496             elif arg.is_negative:
1497                 return -cls(-arg)
1498         else:
1499             if arg is S.ComplexInfinity:
1500                 return S.Zero
1501 
1502             i_coeff = arg.as_coefficient(S.ImaginaryUnit)
1503 
1504             if i_coeff is not None:
1505                 return -S.ImaginaryUnit * acot(i_coeff)
1506             else:
1507                 if _coeff_isneg(arg):
1508                     return -cls(-arg)
1509 
1510         if arg.is_zero:
1511             return S.Pi*S.ImaginaryUnit*S.Half
1512 
1513     @staticmethod
1514     @cacheit
1515     def taylor_term(n, x, *previous_terms):
1516         if n == 0:
1517             return S.Pi*S.ImaginaryUnit / 2
1518         elif n < 0 or n % 2 == 0:
1519             return S.Zero
1520         else:
1521             x = sympify(x)
1522             return x**n / n
1523 
1524     def _eval_as_leading_term(self, x, cdir=0):
1525         from sympy import Order
1526         arg = self.args[0].as_leading_term(x)
1527 
1528         if x in arg.free_symbols and Order(1, x).contains(arg):
1529             return S.ImaginaryUnit*S.Pi/2
1530         else:
1531             return self.func(arg)
1532 
1533     def _eval_rewrite_as_log(self, x, **kwargs):
1534         return (log(1 + 1/x) - log(1 - 1/x)) / 2
1535 
1536     def inverse(self, argindex=1):
1537         """
1538         Returns the inverse of this function.
1539         """
1540         return coth
1541 
1542 
1543 class asech(InverseHyperbolicFunction):
1544     """
1545     asech(x) is the inverse hyperbolic secant of x.
1546 
1547     The inverse hyperbolic secant function.
1548 
1549     Examples
1550     ========
1551 
1552     >>> from sympy import asech, sqrt, S
1553     >>> from sympy.abc import x
1554     >>> asech(x).diff(x)
1555     -1/(x*sqrt(1 - x**2))
1556     >>> asech(1).diff(x)
1557     0
1558     >>> asech(1)
1559     0
1560     >>> asech(S(2))
1561     I*pi/3
1562     >>> asech(-sqrt(2))
1563     3*I*pi/4
1564     >>> asech((sqrt(6) - sqrt(2)))
1565     I*pi/12
1566 
1567     See Also
1568     ========
1569 
1570     asinh, atanh, cosh, acoth
1571 
1572     References
1573     ==========
1574 
1575     .. [1] https://en.wikipedia.org/wiki/Hyperbolic_function
1576     .. [2] http://dlmf.nist.gov/4.37
1577     .. [3] http://functions.wolfram.com/ElementaryFunctions/ArcSech/
1578 
1579     """
1580 
1581     def fdiff(self, argindex=1):
1582         if argindex == 1:
1583             z = self.args[0]
1584             return -1/(z*sqrt(1 - z**2))
1585         else:
1586             raise ArgumentIndexError(self, argindex)
1587 
1588     @classmethod
1589     def eval(cls, arg):
1590         arg = sympify(arg)
1591 
1592         if arg.is_Number:
1593             if arg is S.NaN:
1594                 return S.NaN
1595             elif arg is S.Infinity:
1596                 return S.Pi*S.ImaginaryUnit / 2
1597             elif arg is S.NegativeInfinity:
1598                 return S.Pi*S.ImaginaryUnit / 2
1599             elif arg.is_zero:
1600                 return S.Infinity
1601             elif arg is S.One:
1602                 return S.Zero
1603             elif arg is S.NegativeOne:
1604                 return S.Pi*S.ImaginaryUnit
1605 
1606         if arg.is_number:
1607             cst_table = {
1608                 S.ImaginaryUnit: - (S.Pi*S.ImaginaryUnit / 2) + log(1 + sqrt(2)),
1609                 -S.ImaginaryUnit: (S.Pi*S.ImaginaryUnit / 2) + log(1 + sqrt(2)),
1610                 (sqrt(6) - sqrt(2)): S.Pi / 12,
1611                 (sqrt(2) - sqrt(6)): 11*S.Pi / 12,
1612                 sqrt(2 - 2/sqrt(5)): S.Pi / 10,
1613                 -sqrt(2 - 2/sqrt(5)): 9*S.Pi / 10,
1614                 2 / sqrt(2 + sqrt(2)): S.Pi / 8,
1615                 -2 / sqrt(2 + sqrt(2)): 7*S.Pi / 8,
1616                 2 / sqrt(3): S.Pi / 6,
1617                 -2 / sqrt(3): 5*S.Pi / 6,
1618                 (sqrt(5) - 1): S.Pi / 5,
1619                 (1 - sqrt(5)): 4*S.Pi / 5,
1620                 sqrt(2): S.Pi / 4,
1621                 -sqrt(2): 3*S.Pi / 4,
1622                 sqrt(2 + 2/sqrt(5)): 3*S.Pi / 10,
1623                 -sqrt(2 + 2/sqrt(5)): 7*S.Pi / 10,
1624                 S(2): S.Pi / 3,
1625                 -S(2): 2*S.Pi / 3,
1626                 sqrt(2*(2 + sqrt(2))): 3*S.Pi / 8,
1627                 -sqrt(2*(2 + sqrt(2))): 5*S.Pi / 8,
1628                 (1 + sqrt(5)): 2*S.Pi / 5,
1629                 (-1 - sqrt(5)): 3*S.Pi / 5,
1630                 (sqrt(6) + sqrt(2)): 5*S.Pi / 12,
1631                 (-sqrt(6) - sqrt(2)): 7*S.Pi / 12,
1632             }
1633 
1634             if arg in cst_table:
1635                 if arg.is_extended_real:
1636                     return cst_table[arg]*S.ImaginaryUnit
1637                 return cst_table[arg]
1638 
1639         if arg is S.ComplexInfinity:
1640             from sympy.calculus.util import AccumBounds
1641             return S.ImaginaryUnit*AccumBounds(-S.Pi/2, S.Pi/2)
1642 
1643         if arg.is_zero:
1644             return S.Infinity
1645 
1646     @staticmethod
1647     @cacheit
1648     def expansion_term(n, x, *previous_terms):
1649         if n == 0:
1650             return log(2 / x)
1651         elif n < 0 or n % 2 == 1:
1652             return S.Zero
1653         else:
1654             x = sympify(x)
1655             if len(previous_terms) > 2 and n > 2:
1656                 p = previous_terms[-2]
1657                 return p * (n - 1)**2 // (n // 2)**2 * x**2 / 4
1658             else:
1659                 k = n // 2
1660                 R = RisingFactorial(S.Half , k) *  n
1661                 F = factorial(k) * n // 2 * n // 2
1662                 return -1 * R / F * x**n / 4
1663 
1664     def inverse(self, argindex=1):
1665         """
1666         Returns the inverse of this function.
1667         """
1668         return sech
1669 
1670     def _eval_rewrite_as_log(self, arg, **kwargs):
1671         return log(1/arg + sqrt(1/arg - 1) * sqrt(1/arg + 1))
1672 
1673 
1674 class acsch(InverseHyperbolicFunction):
1675     """
1676     acsch(x) is the inverse hyperbolic cosecant of x.
1677 
1678     The inverse hyperbolic cosecant function.
1679 
1680     Examples
1681     ========
1682 
1683     >>> from sympy import acsch, sqrt, S
1684     >>> from sympy.abc import x
1685     >>> acsch(x).diff(x)
1686     -1/(x**2*sqrt(1 + x**(-2)))
1687     >>> acsch(1).diff(x)
1688     0
1689     >>> acsch(1)
1690     log(1 + sqrt(2))
1691     >>> acsch(S.ImaginaryUnit)
1692     -I*pi/2
1693     >>> acsch(-2*S.ImaginaryUnit)
1694     I*pi/6
1695     >>> acsch(S.ImaginaryUnit*(sqrt(6) - sqrt(2)))
1696     -5*I*pi/12
1697 
1698     See Also
1699     ========
1700 
1701     asinh
1702 
1703     References
1704     ==========
1705 
1706     .. [1] https://en.wikipedia.org/wiki/Hyperbolic_function
1707     .. [2] http://dlmf.nist.gov/4.37
1708     .. [3] http://functions.wolfram.com/ElementaryFunctions/ArcCsch/
1709 
1710     """
1711 
1712     def fdiff(self, argindex=1):
1713         if argindex == 1:
1714             z = self.args[0]
1715             return -1/(z**2*sqrt(1 + 1/z**2))
1716         else:
1717             raise ArgumentIndexError(self, argindex)
1718 
1719     @classmethod
1720     def eval(cls, arg):
1721         arg = sympify(arg)
1722 
1723         if arg.is_Number:
1724             if arg is S.NaN:
1725                 return S.NaN
1726             elif arg is S.Infinity:
1727                 return S.Zero
1728             elif arg is S.NegativeInfinity:
1729                 return S.Zero
1730             elif arg.is_zero:
1731                 return S.ComplexInfinity
1732             elif arg is S.One:
1733                 return log(1 + sqrt(2))
1734             elif arg is S.NegativeOne:
1735                 return - log(1 + sqrt(2))
1736 
1737         if arg.is_number:
1738             cst_table = {
1739                 S.ImaginaryUnit: -S.Pi / 2,
1740                 S.ImaginaryUnit*(sqrt(2) + sqrt(6)): -S.Pi / 12,
1741                 S.ImaginaryUnit*(1 + sqrt(5)): -S.Pi / 10,
1742                 S.ImaginaryUnit*2 / sqrt(2 - sqrt(2)): -S.Pi / 8,
1743                 S.ImaginaryUnit*2: -S.Pi / 6,
1744                 S.ImaginaryUnit*sqrt(2 + 2/sqrt(5)): -S.Pi / 5,
1745                 S.ImaginaryUnit*sqrt(2): -S.Pi / 4,
1746                 S.ImaginaryUnit*(sqrt(5)-1): -3*S.Pi / 10,
1747                 S.ImaginaryUnit*2 / sqrt(3): -S.Pi / 3,
1748                 S.ImaginaryUnit*2 / sqrt(2 + sqrt(2)): -3*S.Pi / 8,
1749                 S.ImaginaryUnit*sqrt(2 - 2/sqrt(5)): -2*S.Pi / 5,
1750                 S.ImaginaryUnit*(sqrt(6) - sqrt(2)): -5*S.Pi / 12,
1751                 S(2): -S.ImaginaryUnit*log((1+sqrt(5))/2),
1752             }
1753 
1754             if arg in cst_table:
1755                 return cst_table[arg]*S.ImaginaryUnit
1756 
1757         if arg is S.ComplexInfinity:
1758             return S.Zero
1759 
1760         if arg.is_zero:
1761             return S.ComplexInfinity
1762 
1763         if _coeff_isneg(arg):
1764             return -cls(-arg)
1765 
1766     def inverse(self, argindex=1):
1767         """
1768         Returns the inverse of this function.
1769         """
1770         return csch
1771 
1772     def _eval_rewrite_as_log(self, arg, **kwargs):
1773         return log(1/arg + sqrt(1/arg**2 + 1))

</code><intended_behavior>This file and specifically the classes or methods handling `csch` and `sech` should be modified to include logic that allows the `expand_trig` function to expand these functions correctly. This includes identifying the trigonometric identities for `csch` and `sech` that allow them to be expanded in a manner similar to `csc` and `sec`. The intended behavior is to ensure that when `expand_trig` is called with an expression involving `csch` or `sech`, the function returns an expanded form based on the appropriate identities, thus extending the `expand_trig` utility to cover these hyperbolic functions.</intended_behavior>, <file>sympy/core/function.py</file>
<class>None</class>
<method>expand_trig</method>
<code>
2960 def expand_trig(expr, deep=True):
2961     """
2962     Wrapper around expand that only uses the trig hint.  See the expand
2963     docstring for more information.
2964 
2965     Examples
2966     ========
2967 
2968     >>> from sympy import expand_trig, sin
2969     >>> from sympy.abc import x, y
2970     >>> expand_trig(sin(x+y)*(x+y))
2971     (x + y)*(sin(x)*cos(y) + sin(y)*cos(x))
2972 
2973     """
2974     return sympify(expr).expand(deep=deep, trig=True, basic=False,
2975     log=False, mul=False, power_exp=False, power_base=False, multinomial=False)

</code><intended_behavior>Although the primary logic to expand `csch` and `sech` might reside in `hyperbolic.py`, the `expand_trig` method itself may require adjustments or enhancements to ensure it correctly invokes the relevant expansion rules for hyperbolic functions. The method should be capable of recognizing when an expression contains `csch` or `sech` and apply the expansion logic defined in their respective implementations. This ensures that `expand_trig` remains a comprehensive tool for expanding trigonometric expressions, including both traditional and hyperbolic trigonometric functions.</intended_behavior>]
2025-10-18 20:56:44.377 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-18 20:56:44.377 | INFO     | Search-only: skipping patch selection
2025-10-18 20:56:44.462 | INFO     | Task sympy__sympy-21567 completed successfully.
2025-10-18 20:56:44.462 | INFO     | No patch generated. You can try running ACR again.
