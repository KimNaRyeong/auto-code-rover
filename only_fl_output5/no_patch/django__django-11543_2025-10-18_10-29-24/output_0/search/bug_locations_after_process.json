[
    {
        "rel_file_path": "django/core/management/commands/runserver.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.0/django/core/management/commands/runserver.py",
        "start": 1,
        "end": 161,
        "class_name": null,
        "method_name": null,
        "code": "1 import errno\n2 import os\n3 import re\n4 import socket\n5 import sys\n6 from datetime import datetime\n7 \n8 from django.conf import settings\n9 from django.core.management.base import BaseCommand, CommandError\n10 from django.core.servers.basehttp import (\n11     WSGIServer, get_internal_wsgi_application, run,\n12 )\n13 from django.utils import autoreload\n14 \n15 naiveip_re = re.compile(r\"\"\"^(?:\n16 (?P<addr>\n17     (?P<ipv4>\\d{1,3}(?:\\.\\d{1,3}){3}) |         # IPv4 address\n18     (?P<ipv6>\\[[a-fA-F0-9:]+\\]) |               # IPv6 address\n19     (?P<fqdn>[a-zA-Z0-9-]+(?:\\.[a-zA-Z0-9-]+)*) # FQDN\n20 ):)?(?P<port>\\d+)$\"\"\", re.X)\n21 \n22 \n23 class Command(BaseCommand):\n24     help = \"Starts a lightweight Web server for development.\"\n25 \n26     # Validation is called explicitly each time the server is reloaded.\n27     requires_system_checks = False\n28     stealth_options = ('shutdown_message',)\n29 \n30     default_addr = '127.0.0.1'\n31     default_addr_ipv6 = '::1'\n32     default_port = '8000'\n33     protocol = 'http'\n34     server_cls = WSGIServer\n35 \n36     def add_arguments(self, parser):\n37         parser.add_argument(\n38             'addrport', nargs='?',\n39             help='Optional port number, or ipaddr:port'\n40         )\n41         parser.add_argument(\n42             '--ipv6', '-6', action='store_true', dest='use_ipv6',\n43             help='Tells Django to use an IPv6 address.',\n44         )\n45         parser.add_argument(\n46             '--nothreading', action='store_false', dest='use_threading',\n47             help='Tells Django to NOT use threading.',\n48         )\n49         parser.add_argument(\n50             '--noreload', action='store_false', dest='use_reloader',\n51             help='Tells Django to NOT use the auto-reloader.',\n52         )\n53 \n54     def execute(self, *args, **options):\n55         if options['no_color']:\n56             # We rely on the environment because it's currently the only\n57             # way to reach WSGIRequestHandler. This seems an acceptable\n58             # compromise considering `runserver` runs indefinitely.\n59             os.environ[\"DJANGO_COLORS\"] = \"nocolor\"\n60         super().execute(*args, **options)\n61 \n62     def get_handler(self, *args, **options):\n63         \"\"\"Return the default WSGI handler for the runner.\"\"\"\n64         return get_internal_wsgi_application()\n65 \n66     def handle(self, *args, **options):\n67         if not settings.DEBUG and not settings.ALLOWED_HOSTS:\n68             raise CommandError('You must set settings.ALLOWED_HOSTS if DEBUG is False.')\n69 \n70         self.use_ipv6 = options['use_ipv6']\n71         if self.use_ipv6 and not socket.has_ipv6:\n72             raise CommandError('Your Python does not support IPv6.')\n73         self._raw_ipv6 = False\n74         if not options['addrport']:\n75             self.addr = ''\n76             self.port = self.default_port\n77         else:\n78             m = re.match(naiveip_re, options['addrport'])\n79             if m is None:\n80                 raise CommandError('\"%s\" is not a valid port number '\n81                                    'or address:port pair.' % options['addrport'])\n82             self.addr, _ipv4, _ipv6, _fqdn, self.port = m.groups()\n83             if not self.port.isdigit():\n84                 raise CommandError(\"%r is not a valid port number.\" % self.port)\n85             if self.addr:\n86                 if _ipv6:\n87                     self.addr = self.addr[1:-1]\n88                     self.use_ipv6 = True\n89                     self._raw_ipv6 = True\n90                 elif self.use_ipv6 and not _fqdn:\n91                     raise CommandError('\"%s\" is not a valid IPv6 address.' % self.addr)\n92         if not self.addr:\n93             self.addr = self.default_addr_ipv6 if self.use_ipv6 else self.default_addr\n94             self._raw_ipv6 = self.use_ipv6\n95         self.run(**options)\n96 \n97     def run(self, **options):\n98         \"\"\"Run the server, using the autoreloader if needed.\"\"\"\n99         use_reloader = options['use_reloader']\n100 \n101         if use_reloader:\n102             autoreload.run_with_reloader(self.inner_run, **options)\n103         else:\n104             self.inner_run(None, **options)\n105 \n106     def inner_run(self, *args, **options):\n107         # If an exception was silenced in ManagementUtility.execute in order\n108         # to be raised in the child process, raise it now.\n109         autoreload.raise_last_exception()\n110 \n111         threading = options['use_threading']\n112         # 'shutdown_message' is a stealth option.\n113         shutdown_message = options.get('shutdown_message', '')\n114         quit_command = 'CTRL-BREAK' if sys.platform == 'win32' else 'CONTROL-C'\n115 \n116         self.stdout.write(\"Performing system checks...\\n\\n\")\n117         self.check(display_num_errors=True)\n118         # Need to check migrations here, so can't use the\n119         # requires_migrations_check attribute.\n120         self.check_migrations()\n121         now = datetime.now().strftime('%B %d, %Y - %X')\n122         self.stdout.write(now)\n123         self.stdout.write((\n124             \"Django version %(version)s, using settings %(settings)r\\n\"\n125             \"Starting development server at %(protocol)s://%(addr)s:%(port)s/\\n\"\n126             \"Quit the server with %(quit_command)s.\\n\"\n127         ) % {\n128             \"version\": self.get_version(),\n129             \"settings\": settings.SETTINGS_MODULE,\n130             \"protocol\": self.protocol,\n131             \"addr\": '[%s]' % self.addr if self._raw_ipv6 else self.addr,\n132             \"port\": self.port,\n133             \"quit_command\": quit_command,\n134         })\n135 \n136         try:\n137             handler = self.get_handler(*args, **options)\n138             run(self.addr, int(self.port), handler,\n139                 ipv6=self.use_ipv6, threading=threading, server_cls=self.server_cls)\n140         except OSError as e:\n141             # Use helpful error messages instead of ugly tracebacks.\n142             ERRORS = {\n143                 errno.EACCES: \"You don't have permission to access that port.\",\n144                 errno.EADDRINUSE: \"That port is already in use.\",\n145                 errno.EADDRNOTAVAIL: \"That IP address can't be assigned to.\",\n146             }\n147             try:\n148                 error_text = ERRORS[e.errno]\n149             except KeyError:\n150                 error_text = e\n151             self.stderr.write(\"Error: %s\" % error_text)\n152             # Need to use an OS exit because sys.exit doesn't work in a thread\n153             os._exit(1)\n154         except KeyboardInterrupt:\n155             if shutdown_message:\n156                 self.stdout.write(shutdown_message)\n157             sys.exit(0)\n158 \n159 \n160 # Kept for backward compatibility\n161 BaseRunserverCommand = Command\n",
        "intended_behavior": "This file's handling of the `--nothreading` option needs to ensure that connections are properly managed. Specifically, when running with `--nothreading`, the server must be capable of terminating or recycling keep-alive connections to prevent a single connection from monopolizing the server. This could involve checking if a connection should be closed after a request completes and explicitly closing it if necessary, while still preserving the ability for a developer to use keep-alive for performance reasons during development."
    },
    {
        "rel_file_path": "django/core/servers/basehttp.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.0/django/core/servers/basehttp.py",
        "start": 1,
        "end": 213,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\"\n2 HTTP server that implements the Python WSGI protocol (PEP 333, rev 1.21).\n3 \n4 Based on wsgiref.simple_server which is part of the standard library since 2.5.\n5 \n6 This is a simple server for use in testing or debugging Django apps. It hasn't\n7 been reviewed for security issues. DON'T USE IT FOR PRODUCTION USE!\n8 \"\"\"\n9 \n10 import logging\n11 import socket\n12 import socketserver\n13 import sys\n14 from wsgiref import simple_server\n15 \n16 from django.core.exceptions import ImproperlyConfigured\n17 from django.core.handlers.wsgi import LimitedStream\n18 from django.core.wsgi import get_wsgi_application\n19 from django.utils.module_loading import import_string\n20 \n21 __all__ = ('WSGIServer', 'WSGIRequestHandler')\n22 \n23 logger = logging.getLogger('django.server')\n24 \n25 \n26 def get_internal_wsgi_application():\n27     \"\"\"\n28     Load and return the WSGI application as configured by the user in\n29     ``settings.WSGI_APPLICATION``. With the default ``startproject`` layout,\n30     this will be the ``application`` object in ``projectname/wsgi.py``.\n31 \n32     This function, and the ``WSGI_APPLICATION`` setting itself, are only useful\n33     for Django's internal server (runserver); external WSGI servers should just\n34     be configured to point to the correct application object directly.\n35 \n36     If settings.WSGI_APPLICATION is not set (is ``None``), return\n37     whatever ``django.core.wsgi.get_wsgi_application`` returns.\n38     \"\"\"\n39     from django.conf import settings\n40     app_path = getattr(settings, 'WSGI_APPLICATION')\n41     if app_path is None:\n42         return get_wsgi_application()\n43 \n44     try:\n45         return import_string(app_path)\n46     except ImportError as err:\n47         raise ImproperlyConfigured(\n48             \"WSGI application '%s' could not be loaded; \"\n49             \"Error importing module.\" % app_path\n50         ) from err\n51 \n52 \n53 def is_broken_pipe_error():\n54     exc_type, _, _ = sys.exc_info()\n55     return issubclass(exc_type, BrokenPipeError)\n56 \n57 \n58 class WSGIServer(simple_server.WSGIServer):\n59     \"\"\"BaseHTTPServer that implements the Python WSGI protocol\"\"\"\n60 \n61     request_queue_size = 10\n62 \n63     def __init__(self, *args, ipv6=False, allow_reuse_address=True, **kwargs):\n64         if ipv6:\n65             self.address_family = socket.AF_INET6\n66         self.allow_reuse_address = allow_reuse_address\n67         super().__init__(*args, **kwargs)\n68 \n69     def handle_error(self, request, client_address):\n70         if is_broken_pipe_error():\n71             logger.info(\"- Broken pipe from %s\\n\", client_address)\n72         else:\n73             super().handle_error(request, client_address)\n74 \n75 \n76 class ThreadedWSGIServer(socketserver.ThreadingMixIn, WSGIServer):\n77     \"\"\"A threaded version of the WSGIServer\"\"\"\n78     daemon_threads = True\n79 \n80 \n81 class ServerHandler(simple_server.ServerHandler):\n82     http_version = '1.1'\n83 \n84     def __init__(self, stdin, stdout, stderr, environ, **kwargs):\n85         \"\"\"\n86         Use a LimitedStream so that unread request data will be ignored at\n87         the end of the request. WSGIRequest uses a LimitedStream but it\n88         shouldn't discard the data since the upstream servers usually do this.\n89         This fix applies only for testserver/runserver.\n90         \"\"\"\n91         try:\n92             content_length = int(environ.get('CONTENT_LENGTH'))\n93         except (ValueError, TypeError):\n94             content_length = 0\n95         super().__init__(LimitedStream(stdin, content_length), stdout, stderr, environ, **kwargs)\n96 \n97     def cleanup_headers(self):\n98         super().cleanup_headers()\n99         # HTTP/1.1 requires support for persistent connections. Send 'close' if\n100         # the content length is unknown to prevent clients from reusing the\n101         # connection.\n102         if 'Content-Length' not in self.headers:\n103             self.headers['Connection'] = 'close'\n104         # Mark the connection for closing if it's set as such above or if the\n105         # application sent the header.\n106         if self.headers.get('Connection') == 'close':\n107             self.request_handler.close_connection = True\n108 \n109     def close(self):\n110         self.get_stdin()._read_limited()\n111         super().close()\n112 \n113     def handle_error(self):\n114         # Ignore broken pipe errors, otherwise pass on\n115         if not is_broken_pipe_error():\n116             super().handle_error()\n117 \n118 \n119 class WSGIRequestHandler(simple_server.WSGIRequestHandler):\n120     protocol_version = 'HTTP/1.1'\n121 \n122     def address_string(self):\n123         # Short-circuit parent method to not call socket.getfqdn\n124         return self.client_address[0]\n125 \n126     def log_message(self, format, *args):\n127         extra = {\n128             'request': self.request,\n129             'server_time': self.log_date_time_string(),\n130         }\n131         if args[1][0] == '4':\n132             # 0x16 = Handshake, 0x03 = SSL 3.0 or TLS 1.x\n133             if args[0].startswith('\\x16\\x03'):\n134                 extra['status_code'] = 500\n135                 logger.error(\n136                     \"You're accessing the development server over HTTPS, but \"\n137                     \"it only supports HTTP.\\n\", extra=extra,\n138                 )\n139                 return\n140 \n141         if args[1].isdigit() and len(args[1]) == 3:\n142             status_code = int(args[1])\n143             extra['status_code'] = status_code\n144 \n145             if status_code >= 500:\n146                 level = logger.error\n147             elif status_code >= 400:\n148                 level = logger.warning\n149             else:\n150                 level = logger.info\n151         else:\n152             level = logger.info\n153 \n154         level(format, *args, extra=extra)\n155 \n156     def get_environ(self):\n157         # Strip all headers with underscores in the name before constructing\n158         # the WSGI environ. This prevents header-spoofing based on ambiguity\n159         # between underscores and dashes both normalized to underscores in WSGI\n160         # env vars. Nginx and Apache 2.4+ both do this as well.\n161         for k in self.headers:\n162             if '_' in k:\n163                 del self.headers[k]\n164 \n165         return super().get_environ()\n166 \n167     def handle(self):\n168         self.close_connection = True\n169         self.handle_one_request()\n170         while not self.close_connection:\n171             self.handle_one_request()\n172         try:\n173             self.connection.shutdown(socket.SHUT_WR)\n174         except (AttributeError, OSError):\n175             pass\n176 \n177     def handle_one_request(self):\n178         \"\"\"Copy of WSGIRequestHandler.handle() but with different ServerHandler\"\"\"\n179         self.raw_requestline = self.rfile.readline(65537)\n180         if len(self.raw_requestline) > 65536:\n181             self.requestline = ''\n182             self.request_version = ''\n183             self.command = ''\n184             self.send_error(414)\n185             return\n186 \n187         if not self.parse_request():  # An error code has been sent, just exit\n188             return\n189 \n190         handler = ServerHandler(\n191             self.rfile, self.wfile, self.get_stderr(), self.get_environ()\n192         )\n193         handler.request_handler = self      # backpointer for logging & connection closing\n194         handler.run(self.server.get_app())\n195 \n196 \n197 def run(addr, port, wsgi_handler, ipv6=False, threading=False, server_cls=WSGIServer):\n198     server_address = (addr, port)\n199     if threading:\n200         httpd_cls = type('WSGIServer', (socketserver.ThreadingMixIn, server_cls), {})\n201     else:\n202         httpd_cls = server_cls\n203     httpd = httpd_cls(server_address, WSGIRequestHandler, ipv6=ipv6)\n204     if threading:\n205         # ThreadingMixIn.daemon_threads indicates how threads will behave on an\n206         # abrupt shutdown; like quitting the server by the user or restarting\n207         # by the auto-reloader. True means the server will not wait for thread\n208         # termination before it quits. This will make auto-reloader faster\n209         # and will prevent the need to kill the server manually if a thread\n210         # isn't terminating correctly.\n211         httpd.daemon_threads = True\n212     httpd.set_app(wsgi_handler)\n213     httpd.serve_forever()\n",
        "intended_behavior": "In the context of non-threaded server operation, this file should implement a strategy for efficiently managing keep-alive connections, preventing the server from hanging when multiple keep-alive connections are initiated by modern web browsers. This might involve setting a timeout on idle keep-alive connections in the non-threaded mode or implementing a mechanism to prioritize accepting new connections when the server is operating without threading. The solution should maintain server responsiveness and ensure that new incoming connections can be served even when older connections are kept alive by the client."
    }
]