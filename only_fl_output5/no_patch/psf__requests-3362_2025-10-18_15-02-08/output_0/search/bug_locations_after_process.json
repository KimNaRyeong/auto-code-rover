[
    {
        "rel_file_path": "requests/models.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/psf__requests/setup_psf__requests__2.10/requests/models.py",
        "start": 653,
        "end": 700,
        "class_name": "Response",
        "method_name": "iter_content",
        "code": "653     def iter_content(self, chunk_size=1, decode_unicode=False):\n654         \"\"\"Iterates over the response data.  When stream=True is set on the\n655         request, this avoids reading the content at once into memory for\n656         large responses.  The chunk size is the number of bytes it should\n657         read into memory.  This is not necessarily the length of each item\n658         returned as decoding can take place.\n659 \n660         If decode_unicode is True, content will be decoded using the best\n661         available encoding based on the response.\n662         \"\"\"\n663 \n664         def generate():\n665             # Special case for urllib3.\n666             if hasattr(self.raw, 'stream'):\n667                 try:\n668                     for chunk in self.raw.stream(chunk_size, decode_content=True):\n669                         yield chunk\n670                 except ProtocolError as e:\n671                     raise ChunkedEncodingError(e)\n672                 except DecodeError as e:\n673                     raise ContentDecodingError(e)\n674                 except ReadTimeoutError as e:\n675                     raise ConnectionError(e)\n676             else:\n677                 # Standard file-like object.\n678                 while True:\n679                     chunk = self.raw.read(chunk_size)\n680                     if not chunk:\n681                         break\n682                     yield chunk\n683 \n684             self._content_consumed = True\n685 \n686         if self._content_consumed and isinstance(self._content, bool):\n687             raise StreamConsumedError()\n688         elif not isinstance(chunk_size, int):\n689             raise TypeError(\"chunk_size must be an int, it is instead a %s.\" % type(chunk_size))\n690         # simulate reading small chunks of the content\n691         reused_chunks = iter_slices(self._content, chunk_size)\n692 \n693         stream_chunks = generate()\n694 \n695         chunks = reused_chunks if self._content_consumed else stream_chunks\n696 \n697         if decode_unicode:\n698             chunks = stream_decode_response_unicode(chunks, self)\n699 \n700         return chunks\n",
        "intended_behavior": "The `iter_content` method should ensure that when `decode_unicode=True` is specified, the chunks yielded are properly decoded unicode strings (using the response's apparent encoding if necessary), not bytes. This implies fixing or enhancing the handling around the `decode_unicode` logic, specifically where it determines whether to decode the chunks and which encoding to use for this. The correction should ensure that when `decode_unicode` is set to `True`, the method reliably yields decoded unicode strings rather than raw bytes, aligning its behavior more closely with the user's expectations and making it consistent with the documentation and the behavior of `r.text`. The existing functionality - allowing users to iterate over the content as bytes when `decode_unicode=False` and the functionality around streaming large responses without loading them into memory at once - should be preserved."
    },
    {
        "rel_file_path": "requests/models.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/psf__requests/setup_psf__requests__2.10/requests/models.py",
        "start": 536,
        "end": 861,
        "class_name": "Response",
        "method_name": null,
        "code": "536 class Response(object):\n537     \"\"\"The :class:`Response <Response>` object, which contains a\n538     server's response to an HTTP request.\n539     \"\"\"\n540 \n541     __attrs__ = [\n542         '_content', 'status_code', 'headers', 'url', 'history',\n543         'encoding', 'reason', 'cookies', 'elapsed', 'request'\n544     ]\n545 \n546     def __init__(self):\n547         super(Response, self).__init__()\n548 \n549         self._content = False\n550         self._content_consumed = False\n551 \n552         #: Integer Code of responded HTTP Status, e.g. 404 or 200.\n553         self.status_code = None\n554 \n555         #: Case-insensitive Dictionary of Response Headers.\n556         #: For example, ``headers['content-encoding']`` will return the\n557         #: value of a ``'Content-Encoding'`` response header.\n558         self.headers = CaseInsensitiveDict()\n559 \n560         #: File-like object representation of response (for advanced usage).\n561         #: Use of ``raw`` requires that ``stream=True`` be set on the request.\n562         # This requirement does not apply for use internally to Requests.\n563         self.raw = None\n564 \n565         #: Final URL location of Response.\n566         self.url = None\n567 \n568         #: Encoding to decode with when accessing r.text.\n569         self.encoding = None\n570 \n571         #: A list of :class:`Response <Response>` objects from\n572         #: the history of the Request. Any redirect responses will end\n573         #: up here. The list is sorted from the oldest to the most recent request.\n574         self.history = []\n575 \n576         #: Textual reason of responded HTTP Status, e.g. \"Not Found\" or \"OK\".\n577         self.reason = None\n578 \n579         #: A CookieJar of Cookies the server sent back.\n580         self.cookies = cookiejar_from_dict({})\n581 \n582         #: The amount of time elapsed between sending the request\n583         #: and the arrival of the response (as a timedelta).\n584         #: This property specifically measures the time taken between sending\n585         #: the first byte of the request and finishing parsing the headers. It\n586         #: is therefore unaffected by consuming the response content or the\n587         #: value of the ``stream`` keyword argument.\n588         self.elapsed = datetime.timedelta(0)\n589 \n590         #: The :class:`PreparedRequest <PreparedRequest>` object to which this\n591         #: is a response.\n592         self.request = None\n593 \n594     def __getstate__(self):\n595         # Consume everything; accessing the content attribute makes\n596         # sure the content has been fully read.\n597         if not self._content_consumed:\n598             self.content\n599 \n600         return dict(\n601             (attr, getattr(self, attr, None))\n602             for attr in self.__attrs__\n603         )\n604 \n605     def __setstate__(self, state):\n606         for name, value in state.items():\n607             setattr(self, name, value)\n608 \n609         # pickled objects do not have .raw\n610         setattr(self, '_content_consumed', True)\n611         setattr(self, 'raw', None)\n612 \n613     def __repr__(self):\n614         return '<Response [%s]>' % (self.status_code)\n615 \n616     def __bool__(self):\n617         \"\"\"Returns true if :attr:`status_code` is 'OK'.\"\"\"\n618         return self.ok\n619 \n620     def __nonzero__(self):\n621         \"\"\"Returns true if :attr:`status_code` is 'OK'.\"\"\"\n622         return self.ok\n623 \n624     def __iter__(self):\n625         \"\"\"Allows you to use a response as an iterator.\"\"\"\n626         return self.iter_content(128)\n627 \n628     @property\n629     def ok(self):\n630         try:\n631             self.raise_for_status()\n632         except HTTPError:\n633             return False\n634         return True\n635 \n636     @property\n637     def is_redirect(self):\n638         \"\"\"True if this Response is a well-formed HTTP redirect that could have\n639         been processed automatically (by :meth:`Session.resolve_redirects`).\n640         \"\"\"\n641         return ('location' in self.headers and self.status_code in REDIRECT_STATI)\n642 \n643     @property\n644     def is_permanent_redirect(self):\n645         \"\"\"True if this Response one of the permanent versions of redirect\"\"\"\n646         return ('location' in self.headers and self.status_code in (codes.moved_permanently, codes.permanent_redirect))\n647 \n648     @property\n649     def apparent_encoding(self):\n650         \"\"\"The apparent encoding, provided by the chardet library\"\"\"\n651         return chardet.detect(self.content)['encoding']\n652 \n653     def iter_content(self, chunk_size=1, decode_unicode=False):\n654         \"\"\"Iterates over the response data.  When stream=True is set on the\n655         request, this avoids reading the content at once into memory for\n656         large responses.  The chunk size is the number of bytes it should\n657         read into memory.  This is not necessarily the length of each item\n658         returned as decoding can take place.\n659 \n660         If decode_unicode is True, content will be decoded using the best\n661         available encoding based on the response.\n662         \"\"\"\n663 \n664         def generate():\n665             # Special case for urllib3.\n666             if hasattr(self.raw, 'stream'):\n667                 try:\n668                     for chunk in self.raw.stream(chunk_size, decode_content=True):\n669                         yield chunk\n670                 except ProtocolError as e:\n671                     raise ChunkedEncodingError(e)\n672                 except DecodeError as e:\n673                     raise ContentDecodingError(e)\n674                 except ReadTimeoutError as e:\n675                     raise ConnectionError(e)\n676             else:\n677                 # Standard file-like object.\n678                 while True:\n679                     chunk = self.raw.read(chunk_size)\n680                     if not chunk:\n681                         break\n682                     yield chunk\n683 \n684             self._content_consumed = True\n685 \n686         if self._content_consumed and isinstance(self._content, bool):\n687             raise StreamConsumedError()\n688         elif not isinstance(chunk_size, int):\n689             raise TypeError(\"chunk_size must be an int, it is instead a %s.\" % type(chunk_size))\n690         # simulate reading small chunks of the content\n691         reused_chunks = iter_slices(self._content, chunk_size)\n692 \n693         stream_chunks = generate()\n694 \n695         chunks = reused_chunks if self._content_consumed else stream_chunks\n696 \n697         if decode_unicode:\n698             chunks = stream_decode_response_unicode(chunks, self)\n699 \n700         return chunks\n701 \n702     def iter_lines(self, chunk_size=ITER_CHUNK_SIZE, decode_unicode=None, delimiter=None):\n703         \"\"\"Iterates over the response data, one line at a time.  When\n704         stream=True is set on the request, this avoids reading the\n705         content at once into memory for large responses.\n706 \n707         .. note:: This method is not reentrant safe.\n708         \"\"\"\n709 \n710         pending = None\n711 \n712         for chunk in self.iter_content(chunk_size=chunk_size, decode_unicode=decode_unicode):\n713 \n714             if pending is not None:\n715                 chunk = pending + chunk\n716 \n717             if delimiter:\n718                 lines = chunk.split(delimiter)\n719             else:\n720                 lines = chunk.splitlines()\n721 \n722             if lines and lines[-1] and chunk and lines[-1][-1] == chunk[-1]:\n723                 pending = lines.pop()\n724             else:\n725                 pending = None\n726 \n727             for line in lines:\n728                 yield line\n729 \n730         if pending is not None:\n731             yield pending\n732 \n733     @property\n734     def content(self):\n735         \"\"\"Content of the response, in bytes.\"\"\"\n736 \n737         if self._content is False:\n738             # Read the contents.\n739             try:\n740                 if self._content_consumed:\n741                     raise RuntimeError(\n742                         'The content for this response was already consumed')\n743 \n744                 if self.status_code == 0:\n745                     self._content = None\n746                 else:\n747                     self._content = bytes().join(self.iter_content(CONTENT_CHUNK_SIZE)) or bytes()\n748 \n749             except AttributeError:\n750                 self._content = None\n751 \n752         self._content_consumed = True\n753         # don't need to release the connection; that's been handled by urllib3\n754         # since we exhausted the data.\n755         return self._content\n756 \n757     @property\n758     def text(self):\n759         \"\"\"Content of the response, in unicode.\n760 \n761         If Response.encoding is None, encoding will be guessed using\n762         ``chardet``.\n763 \n764         The encoding of the response content is determined based solely on HTTP\n765         headers, following RFC 2616 to the letter. If you can take advantage of\n766         non-HTTP knowledge to make a better guess at the encoding, you should\n767         set ``r.encoding`` appropriately before accessing this property.\n768         \"\"\"\n769 \n770         # Try charset from content-type\n771         content = None\n772         encoding = self.encoding\n773 \n774         if not self.content:\n775             return str('')\n776 \n777         # Fallback to auto-detected encoding.\n778         if self.encoding is None:\n779             encoding = self.apparent_encoding\n780 \n781         # Decode unicode from given encoding.\n782         try:\n783             content = str(self.content, encoding, errors='replace')\n784         except (LookupError, TypeError):\n785             # A LookupError is raised if the encoding was not found which could\n786             # indicate a misspelling or similar mistake.\n787             #\n788             # A TypeError can be raised if encoding is None\n789             #\n790             # So we try blindly encoding.\n791             content = str(self.content, errors='replace')\n792 \n793         return content\n794 \n795     def json(self, **kwargs):\n796         \"\"\"Returns the json-encoded content of a response, if any.\n797 \n798         :param \\*\\*kwargs: Optional arguments that ``json.loads`` takes.\n799         \"\"\"\n800 \n801         if not self.encoding and self.content and len(self.content) > 3:\n802             # No encoding set. JSON RFC 4627 section 3 states we should expect\n803             # UTF-8, -16 or -32. Detect which one to use; If the detection or\n804             # decoding fails, fall back to `self.text` (using chardet to make\n805             # a best guess).\n806             encoding = guess_json_utf(self.content)\n807             if encoding is not None:\n808                 try:\n809                     return complexjson.loads(\n810                         self.content.decode(encoding), **kwargs\n811                     )\n812                 except UnicodeDecodeError:\n813                     # Wrong UTF codec detected; usually because it's not UTF-8\n814                     # but some other 8-bit codec.  This is an RFC violation,\n815                     # and the server didn't bother to tell us what codec *was*\n816                     # used.\n817                     pass\n818         return complexjson.loads(self.text, **kwargs)\n819 \n820     @property\n821     def links(self):\n822         \"\"\"Returns the parsed header links of the response, if any.\"\"\"\n823 \n824         header = self.headers.get('link')\n825 \n826         # l = MultiDict()\n827         l = {}\n828 \n829         if header:\n830             links = parse_header_links(header)\n831 \n832             for link in links:\n833                 key = link.get('rel') or link.get('url')\n834                 l[key] = link\n835 \n836         return l\n837 \n838     def raise_for_status(self):\n839         \"\"\"Raises stored :class:`HTTPError`, if one occurred.\"\"\"\n840 \n841         http_error_msg = ''\n842 \n843         if 400 <= self.status_code < 500:\n844             http_error_msg = '%s Client Error: %s for url: %s' % (self.status_code, self.reason, self.url)\n845 \n846         elif 500 <= self.status_code < 600:\n847             http_error_msg = '%s Server Error: %s for url: %s' % (self.status_code, self.reason, self.url)\n848 \n849         if http_error_msg:\n850             raise HTTPError(http_error_msg, response=self)\n851 \n852     def close(self):\n853         \"\"\"Releases the connection back to the pool. Once this method has been\n854         called the underlying ``raw`` object must not be accessed again.\n855 \n856         *Note: Should not normally need to be called explicitly.*\n857         \"\"\"\n858         if not self._content_consumed:\n859             return self.raw.close()\n860 \n861         return self.raw.release_conn()\n",
        "intended_behavior": "This class provides additional context to the issue."
    }
]