[
    {
        "rel_file_path": "django/core/cache/backends/db.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__4.0/django/core/cache/backends/db.py",
        "start": 112,
        "end": 196,
        "class_name": "DatabaseCache",
        "method_name": "_base_set",
        "code": "112     def _base_set(self, mode, key, value, timeout=DEFAULT_TIMEOUT):\n113         timeout = self.get_backend_timeout(timeout)\n114         db = router.db_for_write(self.cache_model_class)\n115         connection = connections[db]\n116         quote_name = connection.ops.quote_name\n117         table = quote_name(self._table)\n118 \n119         with connection.cursor() as cursor:\n120             cursor.execute(\"SELECT COUNT(*) FROM %s\" % table)\n121             num = cursor.fetchone()[0]\n122             now = timezone.now()\n123             now = now.replace(microsecond=0)\n124             if timeout is None:\n125                 exp = datetime.max\n126             else:\n127                 tz = timezone.utc if settings.USE_TZ else None\n128                 exp = datetime.fromtimestamp(timeout, tz=tz)\n129             exp = exp.replace(microsecond=0)\n130             if num > self._max_entries:\n131                 self._cull(db, cursor, now)\n132             pickled = pickle.dumps(value, self.pickle_protocol)\n133             # The DB column is expecting a string, so make sure the value is a\n134             # string, not bytes. Refs #19274.\n135             b64encoded = base64.b64encode(pickled).decode('latin1')\n136             try:\n137                 # Note: typecasting for datetimes is needed by some 3rd party\n138                 # database backends. All core backends work without typecasting,\n139                 # so be careful about changes here - test suite will NOT pick\n140                 # regressions.\n141                 with transaction.atomic(using=db):\n142                     cursor.execute(\n143                         'SELECT %s, %s FROM %s WHERE %s = %%s' % (\n144                             quote_name('cache_key'),\n145                             quote_name('expires'),\n146                             table,\n147                             quote_name('cache_key'),\n148                         ),\n149                         [key]\n150                     )\n151                     result = cursor.fetchone()\n152 \n153                     if result:\n154                         current_expires = result[1]\n155                         expression = models.Expression(output_field=models.DateTimeField())\n156                         for converter in (connection.ops.get_db_converters(expression) +\n157                                           expression.get_db_converters(connection)):\n158                             current_expires = converter(current_expires, expression, connection)\n159 \n160                     exp = connection.ops.adapt_datetimefield_value(exp)\n161                     if result and mode == 'touch':\n162                         cursor.execute(\n163                             'UPDATE %s SET %s = %%s WHERE %s = %%s' % (\n164                                 table,\n165                                 quote_name('expires'),\n166                                 quote_name('cache_key')\n167                             ),\n168                             [exp, key]\n169                         )\n170                     elif result and (mode == 'set' or (mode == 'add' and current_expires < now)):\n171                         cursor.execute(\n172                             'UPDATE %s SET %s = %%s, %s = %%s WHERE %s = %%s' % (\n173                                 table,\n174                                 quote_name('value'),\n175                                 quote_name('expires'),\n176                                 quote_name('cache_key'),\n177                             ),\n178                             [b64encoded, exp, key]\n179                         )\n180                     elif mode != 'touch':\n181                         cursor.execute(\n182                             'INSERT INTO %s (%s, %s, %s) VALUES (%%s, %%s, %%s)' % (\n183                                 table,\n184                                 quote_name('cache_key'),\n185                                 quote_name('value'),\n186                                 quote_name('expires'),\n187                             ),\n188                             [key, b64encoded, exp]\n189                         )\n190                     else:\n191                         return False  # touch failed.\n192             except DatabaseError:\n193                 # To be threadsafe, updates/inserts are allowed to fail silently\n194                 return False\n195             else:\n196                 return True\n",
        "intended_behavior": "In the `_base_set` method, instead of querying the count of rows twice (before and after culling), optimize by passing the initial count obtained to the `_cull` method. This removes the need for a second `SELECT COUNT(*)` query, reducing database load and improving performance. The method should determine if culling is required based on the cache size exceeding `_max_entries`, and if so, activate the culling process with the current count as a parameter."
    },
    {
        "rel_file_path": "django/core/cache/backends/db.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__4.0/django/core/cache/backends/db.py",
        "start": 40,
        "end": 277,
        "class_name": "DatabaseCache",
        "method_name": null,
        "code": "40 class DatabaseCache(BaseDatabaseCache):\n41 \n42     # This class uses cursors provided by the database connection. This means\n43     # it reads expiration values as aware or naive datetimes, depending on the\n44     # value of USE_TZ and whether the database supports time zones. The ORM's\n45     # conversion and adaptation infrastructure is then used to avoid comparing\n46     # aware and naive datetimes accidentally.\n47 \n48     pickle_protocol = pickle.HIGHEST_PROTOCOL\n49 \n50     def get(self, key, default=None, version=None):\n51         return self.get_many([key], version).get(key, default)\n52 \n53     def get_many(self, keys, version=None):\n54         if not keys:\n55             return {}\n56 \n57         key_map = {}\n58         for key in keys:\n59             self.validate_key(key)\n60             key_map[self.make_key(key, version)] = key\n61 \n62         db = router.db_for_read(self.cache_model_class)\n63         connection = connections[db]\n64         quote_name = connection.ops.quote_name\n65         table = quote_name(self._table)\n66 \n67         with connection.cursor() as cursor:\n68             cursor.execute(\n69                 'SELECT %s, %s, %s FROM %s WHERE %s IN (%s)' % (\n70                     quote_name('cache_key'),\n71                     quote_name('value'),\n72                     quote_name('expires'),\n73                     table,\n74                     quote_name('cache_key'),\n75                     ', '.join(['%s'] * len(key_map)),\n76                 ),\n77                 list(key_map),\n78             )\n79             rows = cursor.fetchall()\n80 \n81         result = {}\n82         expired_keys = []\n83         expression = models.Expression(output_field=models.DateTimeField())\n84         converters = (connection.ops.get_db_converters(expression) + expression.get_db_converters(connection))\n85         for key, value, expires in rows:\n86             for converter in converters:\n87                 expires = converter(expires, expression, connection)\n88             if expires < timezone.now():\n89                 expired_keys.append(key)\n90             else:\n91                 value = connection.ops.process_clob(value)\n92                 value = pickle.loads(base64.b64decode(value.encode()))\n93                 result[key_map.get(key)] = value\n94         self._base_delete_many(expired_keys)\n95         return result\n96 \n97     def set(self, key, value, timeout=DEFAULT_TIMEOUT, version=None):\n98         key = self.make_key(key, version=version)\n99         self.validate_key(key)\n100         self._base_set('set', key, value, timeout)\n101 \n102     def add(self, key, value, timeout=DEFAULT_TIMEOUT, version=None):\n103         key = self.make_key(key, version=version)\n104         self.validate_key(key)\n105         return self._base_set('add', key, value, timeout)\n106 \n107     def touch(self, key, timeout=DEFAULT_TIMEOUT, version=None):\n108         key = self.make_key(key, version=version)\n109         self.validate_key(key)\n110         return self._base_set('touch', key, None, timeout)\n111 \n112     def _base_set(self, mode, key, value, timeout=DEFAULT_TIMEOUT):\n113         timeout = self.get_backend_timeout(timeout)\n114         db = router.db_for_write(self.cache_model_class)\n115         connection = connections[db]\n116         quote_name = connection.ops.quote_name\n117         table = quote_name(self._table)\n118 \n119         with connection.cursor() as cursor:\n120             cursor.execute(\"SELECT COUNT(*) FROM %s\" % table)\n121             num = cursor.fetchone()[0]\n122             now = timezone.now()\n123             now = now.replace(microsecond=0)\n124             if timeout is None:\n125                 exp = datetime.max\n126             else:\n127                 tz = timezone.utc if settings.USE_TZ else None\n128                 exp = datetime.fromtimestamp(timeout, tz=tz)\n129             exp = exp.replace(microsecond=0)\n130             if num > self._max_entries:\n131                 self._cull(db, cursor, now)\n132             pickled = pickle.dumps(value, self.pickle_protocol)\n133             # The DB column is expecting a string, so make sure the value is a\n134             # string, not bytes. Refs #19274.\n135             b64encoded = base64.b64encode(pickled).decode('latin1')\n136             try:\n137                 # Note: typecasting for datetimes is needed by some 3rd party\n138                 # database backends. All core backends work without typecasting,\n139                 # so be careful about changes here - test suite will NOT pick\n140                 # regressions.\n141                 with transaction.atomic(using=db):\n142                     cursor.execute(\n143                         'SELECT %s, %s FROM %s WHERE %s = %%s' % (\n144                             quote_name('cache_key'),\n145                             quote_name('expires'),\n146                             table,\n147                             quote_name('cache_key'),\n148                         ),\n149                         [key]\n150                     )\n151                     result = cursor.fetchone()\n152 \n153                     if result:\n154                         current_expires = result[1]\n155                         expression = models.Expression(output_field=models.DateTimeField())\n156                         for converter in (connection.ops.get_db_converters(expression) +\n157                                           expression.get_db_converters(connection)):\n158                             current_expires = converter(current_expires, expression, connection)\n159 \n160                     exp = connection.ops.adapt_datetimefield_value(exp)\n161                     if result and mode == 'touch':\n162                         cursor.execute(\n163                             'UPDATE %s SET %s = %%s WHERE %s = %%s' % (\n164                                 table,\n165                                 quote_name('expires'),\n166                                 quote_name('cache_key')\n167                             ),\n168                             [exp, key]\n169                         )\n170                     elif result and (mode == 'set' or (mode == 'add' and current_expires < now)):\n171                         cursor.execute(\n172                             'UPDATE %s SET %s = %%s, %s = %%s WHERE %s = %%s' % (\n173                                 table,\n174                                 quote_name('value'),\n175                                 quote_name('expires'),\n176                                 quote_name('cache_key'),\n177                             ),\n178                             [b64encoded, exp, key]\n179                         )\n180                     elif mode != 'touch':\n181                         cursor.execute(\n182                             'INSERT INTO %s (%s, %s, %s) VALUES (%%s, %%s, %%s)' % (\n183                                 table,\n184                                 quote_name('cache_key'),\n185                                 quote_name('value'),\n186                                 quote_name('expires'),\n187                             ),\n188                             [key, b64encoded, exp]\n189                         )\n190                     else:\n191                         return False  # touch failed.\n192             except DatabaseError:\n193                 # To be threadsafe, updates/inserts are allowed to fail silently\n194                 return False\n195             else:\n196                 return True\n197 \n198     def delete(self, key, version=None):\n199         self.validate_key(key)\n200         return self._base_delete_many([self.make_key(key, version)])\n201 \n202     def delete_many(self, keys, version=None):\n203         key_list = []\n204         for key in keys:\n205             self.validate_key(key)\n206             key_list.append(self.make_key(key, version))\n207         self._base_delete_many(key_list)\n208 \n209     def _base_delete_many(self, keys):\n210         if not keys:\n211             return False\n212 \n213         db = router.db_for_write(self.cache_model_class)\n214         connection = connections[db]\n215         quote_name = connection.ops.quote_name\n216         table = quote_name(self._table)\n217 \n218         with connection.cursor() as cursor:\n219             cursor.execute(\n220                 'DELETE FROM %s WHERE %s IN (%s)' % (\n221                     table,\n222                     quote_name('cache_key'),\n223                     ', '.join(['%s'] * len(keys)),\n224                 ),\n225                 keys,\n226             )\n227             return bool(cursor.rowcount)\n228 \n229     def has_key(self, key, version=None):\n230         key = self.make_key(key, version=version)\n231         self.validate_key(key)\n232 \n233         db = router.db_for_read(self.cache_model_class)\n234         connection = connections[db]\n235         quote_name = connection.ops.quote_name\n236 \n237         now = timezone.now().replace(microsecond=0, tzinfo=None)\n238 \n239         with connection.cursor() as cursor:\n240             cursor.execute(\n241                 'SELECT %s FROM %s WHERE %s = %%s and expires > %%s' % (\n242                     quote_name('cache_key'),\n243                     quote_name(self._table),\n244                     quote_name('cache_key'),\n245                 ),\n246                 [key, connection.ops.adapt_datetimefield_value(now)]\n247             )\n248             return cursor.fetchone() is not None\n249 \n250     def _cull(self, db, cursor, now):\n251         if self._cull_frequency == 0:\n252             self.clear()\n253         else:\n254             connection = connections[db]\n255             table = connection.ops.quote_name(self._table)\n256             cursor.execute(\"DELETE FROM %s WHERE expires < %%s\" % table,\n257                            [connection.ops.adapt_datetimefield_value(now)])\n258             cursor.execute(\"SELECT COUNT(*) FROM %s\" % table)\n259             num = cursor.fetchone()[0]\n260             if num > self._max_entries:\n261                 cull_num = num // self._cull_frequency\n262                 cursor.execute(\n263                     connection.ops.cache_key_culling_sql() % table,\n264                     [cull_num])\n265                 last_cache_key = cursor.fetchone()\n266                 if last_cache_key:\n267                     cursor.execute(\n268                         'DELETE FROM %s WHERE cache_key < %%s' % table,\n269                         [last_cache_key[0]],\n270                     )\n271 \n272     def clear(self):\n273         db = router.db_for_write(self.cache_model_class)\n274         connection = connections[db]\n275         table = connection.ops.quote_name(self._table)\n276         with connection.cursor() as cursor:\n277             cursor.execute('DELETE FROM %s' % table)\n",
        "intended_behavior": "This class provides additional context to the issue."
    },
    {
        "rel_file_path": "django/core/cache/backends/db.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__4.0/django/core/cache/backends/db.py",
        "start": 250,
        "end": 270,
        "class_name": "DatabaseCache",
        "method_name": "_cull",
        "code": "250     def _cull(self, db, cursor, now):\n251         if self._cull_frequency == 0:\n252             self.clear()\n253         else:\n254             connection = connections[db]\n255             table = connection.ops.quote_name(self._table)\n256             cursor.execute(\"DELETE FROM %s WHERE expires < %%s\" % table,\n257                            [connection.ops.adapt_datetimefield_value(now)])\n258             cursor.execute(\"SELECT COUNT(*) FROM %s\" % table)\n259             num = cursor.fetchone()[0]\n260             if num > self._max_entries:\n261                 cull_num = num // self._cull_frequency\n262                 cursor.execute(\n263                     connection.ops.cache_key_culling_sql() % table,\n264                     [cull_num])\n265                 last_cache_key = cursor.fetchone()\n266                 if last_cache_key:\n267                     cursor.execute(\n268                         'DELETE FROM %s WHERE cache_key < %%s' % table,\n269                         [last_cache_key[0]],\n270                     )\n",
        "intended_behavior": "Modify the `_cull` method to accept an additional parameter, `pre_cull_count`, representing the count of entries before culling begins. After deletion of expired entries, calculate the new count by subtracting `cursor.rowcount` (the number of rows deleted) from `pre_cull_count`. This approach eliminates the need for a subsequent count query. The method proceeds with further culling if the recalculated count still exceeds `_max_entries`. This change aims to preserve the functionality of maintaining cache size within limits while significantly improving efficiency."
    },
    {
        "rel_file_path": "django/core/cache/backends/db.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__4.0/django/core/cache/backends/db.py",
        "start": 40,
        "end": 277,
        "class_name": "DatabaseCache",
        "method_name": null,
        "code": "40 class DatabaseCache(BaseDatabaseCache):\n41 \n42     # This class uses cursors provided by the database connection. This means\n43     # it reads expiration values as aware or naive datetimes, depending on the\n44     # value of USE_TZ and whether the database supports time zones. The ORM's\n45     # conversion and adaptation infrastructure is then used to avoid comparing\n46     # aware and naive datetimes accidentally.\n47 \n48     pickle_protocol = pickle.HIGHEST_PROTOCOL\n49 \n50     def get(self, key, default=None, version=None):\n51         return self.get_many([key], version).get(key, default)\n52 \n53     def get_many(self, keys, version=None):\n54         if not keys:\n55             return {}\n56 \n57         key_map = {}\n58         for key in keys:\n59             self.validate_key(key)\n60             key_map[self.make_key(key, version)] = key\n61 \n62         db = router.db_for_read(self.cache_model_class)\n63         connection = connections[db]\n64         quote_name = connection.ops.quote_name\n65         table = quote_name(self._table)\n66 \n67         with connection.cursor() as cursor:\n68             cursor.execute(\n69                 'SELECT %s, %s, %s FROM %s WHERE %s IN (%s)' % (\n70                     quote_name('cache_key'),\n71                     quote_name('value'),\n72                     quote_name('expires'),\n73                     table,\n74                     quote_name('cache_key'),\n75                     ', '.join(['%s'] * len(key_map)),\n76                 ),\n77                 list(key_map),\n78             )\n79             rows = cursor.fetchall()\n80 \n81         result = {}\n82         expired_keys = []\n83         expression = models.Expression(output_field=models.DateTimeField())\n84         converters = (connection.ops.get_db_converters(expression) + expression.get_db_converters(connection))\n85         for key, value, expires in rows:\n86             for converter in converters:\n87                 expires = converter(expires, expression, connection)\n88             if expires < timezone.now():\n89                 expired_keys.append(key)\n90             else:\n91                 value = connection.ops.process_clob(value)\n92                 value = pickle.loads(base64.b64decode(value.encode()))\n93                 result[key_map.get(key)] = value\n94         self._base_delete_many(expired_keys)\n95         return result\n96 \n97     def set(self, key, value, timeout=DEFAULT_TIMEOUT, version=None):\n98         key = self.make_key(key, version=version)\n99         self.validate_key(key)\n100         self._base_set('set', key, value, timeout)\n101 \n102     def add(self, key, value, timeout=DEFAULT_TIMEOUT, version=None):\n103         key = self.make_key(key, version=version)\n104         self.validate_key(key)\n105         return self._base_set('add', key, value, timeout)\n106 \n107     def touch(self, key, timeout=DEFAULT_TIMEOUT, version=None):\n108         key = self.make_key(key, version=version)\n109         self.validate_key(key)\n110         return self._base_set('touch', key, None, timeout)\n111 \n112     def _base_set(self, mode, key, value, timeout=DEFAULT_TIMEOUT):\n113         timeout = self.get_backend_timeout(timeout)\n114         db = router.db_for_write(self.cache_model_class)\n115         connection = connections[db]\n116         quote_name = connection.ops.quote_name\n117         table = quote_name(self._table)\n118 \n119         with connection.cursor() as cursor:\n120             cursor.execute(\"SELECT COUNT(*) FROM %s\" % table)\n121             num = cursor.fetchone()[0]\n122             now = timezone.now()\n123             now = now.replace(microsecond=0)\n124             if timeout is None:\n125                 exp = datetime.max\n126             else:\n127                 tz = timezone.utc if settings.USE_TZ else None\n128                 exp = datetime.fromtimestamp(timeout, tz=tz)\n129             exp = exp.replace(microsecond=0)\n130             if num > self._max_entries:\n131                 self._cull(db, cursor, now)\n132             pickled = pickle.dumps(value, self.pickle_protocol)\n133             # The DB column is expecting a string, so make sure the value is a\n134             # string, not bytes. Refs #19274.\n135             b64encoded = base64.b64encode(pickled).decode('latin1')\n136             try:\n137                 # Note: typecasting for datetimes is needed by some 3rd party\n138                 # database backends. All core backends work without typecasting,\n139                 # so be careful about changes here - test suite will NOT pick\n140                 # regressions.\n141                 with transaction.atomic(using=db):\n142                     cursor.execute(\n143                         'SELECT %s, %s FROM %s WHERE %s = %%s' % (\n144                             quote_name('cache_key'),\n145                             quote_name('expires'),\n146                             table,\n147                             quote_name('cache_key'),\n148                         ),\n149                         [key]\n150                     )\n151                     result = cursor.fetchone()\n152 \n153                     if result:\n154                         current_expires = result[1]\n155                         expression = models.Expression(output_field=models.DateTimeField())\n156                         for converter in (connection.ops.get_db_converters(expression) +\n157                                           expression.get_db_converters(connection)):\n158                             current_expires = converter(current_expires, expression, connection)\n159 \n160                     exp = connection.ops.adapt_datetimefield_value(exp)\n161                     if result and mode == 'touch':\n162                         cursor.execute(\n163                             'UPDATE %s SET %s = %%s WHERE %s = %%s' % (\n164                                 table,\n165                                 quote_name('expires'),\n166                                 quote_name('cache_key')\n167                             ),\n168                             [exp, key]\n169                         )\n170                     elif result and (mode == 'set' or (mode == 'add' and current_expires < now)):\n171                         cursor.execute(\n172                             'UPDATE %s SET %s = %%s, %s = %%s WHERE %s = %%s' % (\n173                                 table,\n174                                 quote_name('value'),\n175                                 quote_name('expires'),\n176                                 quote_name('cache_key'),\n177                             ),\n178                             [b64encoded, exp, key]\n179                         )\n180                     elif mode != 'touch':\n181                         cursor.execute(\n182                             'INSERT INTO %s (%s, %s, %s) VALUES (%%s, %%s, %%s)' % (\n183                                 table,\n184                                 quote_name('cache_key'),\n185                                 quote_name('value'),\n186                                 quote_name('expires'),\n187                             ),\n188                             [key, b64encoded, exp]\n189                         )\n190                     else:\n191                         return False  # touch failed.\n192             except DatabaseError:\n193                 # To be threadsafe, updates/inserts are allowed to fail silently\n194                 return False\n195             else:\n196                 return True\n197 \n198     def delete(self, key, version=None):\n199         self.validate_key(key)\n200         return self._base_delete_many([self.make_key(key, version)])\n201 \n202     def delete_many(self, keys, version=None):\n203         key_list = []\n204         for key in keys:\n205             self.validate_key(key)\n206             key_list.append(self.make_key(key, version))\n207         self._base_delete_many(key_list)\n208 \n209     def _base_delete_many(self, keys):\n210         if not keys:\n211             return False\n212 \n213         db = router.db_for_write(self.cache_model_class)\n214         connection = connections[db]\n215         quote_name = connection.ops.quote_name\n216         table = quote_name(self._table)\n217 \n218         with connection.cursor() as cursor:\n219             cursor.execute(\n220                 'DELETE FROM %s WHERE %s IN (%s)' % (\n221                     table,\n222                     quote_name('cache_key'),\n223                     ', '.join(['%s'] * len(keys)),\n224                 ),\n225                 keys,\n226             )\n227             return bool(cursor.rowcount)\n228 \n229     def has_key(self, key, version=None):\n230         key = self.make_key(key, version=version)\n231         self.validate_key(key)\n232 \n233         db = router.db_for_read(self.cache_model_class)\n234         connection = connections[db]\n235         quote_name = connection.ops.quote_name\n236 \n237         now = timezone.now().replace(microsecond=0, tzinfo=None)\n238 \n239         with connection.cursor() as cursor:\n240             cursor.execute(\n241                 'SELECT %s FROM %s WHERE %s = %%s and expires > %%s' % (\n242                     quote_name('cache_key'),\n243                     quote_name(self._table),\n244                     quote_name('cache_key'),\n245                 ),\n246                 [key, connection.ops.adapt_datetimefield_value(now)]\n247             )\n248             return cursor.fetchone() is not None\n249 \n250     def _cull(self, db, cursor, now):\n251         if self._cull_frequency == 0:\n252             self.clear()\n253         else:\n254             connection = connections[db]\n255             table = connection.ops.quote_name(self._table)\n256             cursor.execute(\"DELETE FROM %s WHERE expires < %%s\" % table,\n257                            [connection.ops.adapt_datetimefield_value(now)])\n258             cursor.execute(\"SELECT COUNT(*) FROM %s\" % table)\n259             num = cursor.fetchone()[0]\n260             if num > self._max_entries:\n261                 cull_num = num // self._cull_frequency\n262                 cursor.execute(\n263                     connection.ops.cache_key_culling_sql() % table,\n264                     [cull_num])\n265                 last_cache_key = cursor.fetchone()\n266                 if last_cache_key:\n267                     cursor.execute(\n268                         'DELETE FROM %s WHERE cache_key < %%s' % table,\n269                         [last_cache_key[0]],\n270                     )\n271 \n272     def clear(self):\n273         db = router.db_for_write(self.cache_model_class)\n274         connection = connections[db]\n275         table = connection.ops.quote_name(self._table)\n276         with connection.cursor() as cursor:\n277             cursor.execute('DELETE FROM %s' % table)\n",
        "intended_behavior": "This class provides additional context to the issue."
    }
]