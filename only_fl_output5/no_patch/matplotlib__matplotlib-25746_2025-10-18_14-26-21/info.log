2025-10-18 14:26:22.003 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-18 14:26:26.352 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=322, output_tokens=12, cost=0.003580
2025-10-18 14:26:26.353 | INFO     | Test agent decides that the issue statement does not contain reproduction steps; skipping reproducer tracing
2025-10-18 14:26:26.357 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 14:26:31.531 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=474, output_tokens=158, cost=0.009480
2025-10-18 14:26:31.538 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 14:26:33.961 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=512, output_tokens=29, cost=0.005990
2025-10-18 14:26:33.962 | DEBUG    | Extracted a valid json.
2025-10-18 14:26:33.962 | DEBUG    | Agent proxy return the following json: {
    "API_calls": ["search_method(\"tick_params\")", "search_code(\"tick_params\")"],
    "bug_locations": []
}
2025-10-18 14:26:34.150 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-18 14:26:34.151 | DEBUG    | <Agent search> Analyzing search results.
2025-10-18 14:26:48.049 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2061, output_tokens=697, cost=0.041520
2025-10-18 14:26:48.056 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 14:26:56.616 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2974, output_tokens=306, cost=0.038920
2025-10-18 14:26:56.619 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 14:27:04.404 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=660, output_tokens=332, cost=0.016560
2025-10-18 14:27:04.405 | DEBUG    | Extracted a valid json.
2025-10-18 14:27:04.405 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_method_in_file(\"tick_params\", \"lib/matplotlib/axes/_base.py\")",
        "search_method_in_file(\"tick_params\", \"lib/mpl_toolkits/mplot3d/axes3d.py\")"
    ],
    "bug_locations": [
        {
            "file": "lib/matplotlib/axes/_base.py",
            "class": "",
            "method": "tick_params",
            "intended_behavior": "This method should be updated to accept a new `fontfamily` keyword argument. It should then apply this font family to the tick labels of the axes it modifies, without affecting the default font family used elsewhere in the plot. This enhancement must preserve all the existing functionalities and parameters of `tick_params`, ensuring backward compatibility. The implementation should facilitate specifying the font family for tick labels directly, simplifying the customization process for the users."
        },
        {
            "file": "lib/mpl_toolkits/mplot3d/axes3d.py",
            "class": "",
            "method": "tick_params",
            "intended_behavior": "Since `tick_params` might have specific implementations for 3D plots, it should also be updated to support the `fontfamily` argument. The new keyword should function identically to its 2D counterpart, enabling users to customize the font family of tick labels on 3D plots. Care must be taken to ensure that this addition integrates smoothly with 3D axes' unique properties and maintains consistency with the 2D implementation in terms of argument handling and effects on plot appearance."
        }
    ]
}
2025-10-18 14:27:04.462 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-18 14:27:04.463 | DEBUG    | <Agent search> Analyzing search results.
2025-10-18 14:27:18.233 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=5950, output_tokens=580, cost=0.076900
2025-10-18 14:27:18.244 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 14:27:28.726 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=6746, output_tokens=422, cost=0.080120
2025-10-18 14:27:28.734 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 14:27:39.101 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=776, output_tokens=387, cost=0.019370
2025-10-18 14:27:39.102 | DEBUG    | Extracted a valid json.
2025-10-18 14:27:39.103 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "lib/matplotlib/axes/_base.py",
            "class": "_AxesBase",
            "method": "tick_params",
            "intended_behavior": "Modify the `tick_params` method to include a `fontfamily` keyword argument. This argument should allow the user to specify the font family for the tick labels. When processing the `**kwargs` within `tick_params`, the method should apply the specified `fontfamily` to both the x-axis and y-axis tick labels, ensuring that if `fontfamily` is specified, it is respected and applied correctly to the ticks as specified by the `axis` argument. This enhancement must ensure backward compatibility, thus, if `fontfamily` is not specified, the default behavior (using the plot's or the system's default font family) remains unchanged."
        },
        {
            "file": "lib/mpl_toolkits/mplot3d/axes3d.py",
            "class": "Axes3D",
            "method": "tick_params",
            "intended_behavior": "Update the `tick_params` method to accept and correctly apply a `fontfamily` keyword argument for the 'x', 'y', and crucially, the 'z' axis, considering the 3D context. As with the 2D scenario, ensure that specifying `fontfamily` changes the font family of the tick labels according to the user's input while keeping all other functionalities intact. Special attention should be paid to integrating this functionality within the 3D plotting constraints and ensuring compatibility with the generalized matplotlib styles and options framework. Furthermore, since the 3D method calls its 2D counterpart for the 'x' and 'y' axes, care must be taken to harmonize the handling of `fontfamily` between these implementations."
        }
    ]
}
2025-10-18 14:27:39.118 | DEBUG    | Found override of tick_params in _AxesBase
2025-10-18 14:27:39.118 | ERROR    | SearchBackend.search_method_in_class() missing 1 required positional argument: 'class_name'
Traceback (most recent call last):

  File "/home/kimnal0/auto-code-rover/app/main.py", line 656, in <module>
    main()
    └ <function main at 0x761e6b526c00>

  File "/home/kimnal0/auto-code-rover/app/main.py", line 120, in main
    run_task_groups(groups, num_processes, organize_output=True)
    │               │       └ 1
    │               └ {'setup_astropy__astropy__4.3': [<app.raw_tasks.RawSweTask object at 0x761d78dc37d0>, <app.raw_tasks.RawSweTask object at 0x7...
    └ <function run_task_groups at 0x761d7b11a3e0>

  File "/home/kimnal0/auto-code-rover/app/main.py", line 396, in run_task_groups
    run_tasks_serial(all_tasks)
    │                └ [<app.raw_tasks.RawSweTask object at 0x761d78dc37d0>, <app.raw_tasks.RawSweTask object at 0x761d78dc3800>, <app.raw_tasks.Raw...
    └ <function run_tasks_serial at 0x761d7b11a480>

  File "/home/kimnal0/auto-code-rover/app/main.py", line 414, in run_tasks_serial
    run_task_in_subprocess(task)
    │                      └ <app.raw_tasks.RawSweTask object at 0x761d78d3ca70>
    └ <function run_task_in_subprocess at 0x761d7b11a660>

  File "/home/kimnal0/auto-code-rover/app/main.py", line 462, in run_task_in_subprocess
    executor.submit(run_raw_task, task)
    │        │      │             └ <app.raw_tasks.RawSweTask object at 0x761d78d3ca70>
    │        │      └ <function run_raw_task at 0x761d7b11a700>
    │        └ <function ProcessPoolExecutor.submit at 0x761e6ae72020>
    └ <concurrent.futures.process.ProcessPoolExecutor object at 0x761d7b1d56d0>

  File "/home/kimnal0/miniconda3/envs/auto-code-rover/lib/python3.12/concurrent/futures/process.py", line 831, in submit
    self._start_executor_manager_thread()
    │    └ <function ProcessPoolExecutor._start_executor_manager_thread at 0x761e6ae71da0>
    └ <concurrent.futures.process.ProcessPoolExecutor object at 0x761d7b1d56d0>
  File "/home/kimnal0/miniconda3/envs/auto-code-rover/lib/python3.12/concurrent/futures/process.py", line 770, in _start_executor_manager_thread
    self._launch_processes()
    │    └ <function ProcessPoolExecutor._launch_processes at 0x761e6ae71ee0>
    └ <concurrent.futures.process.ProcessPoolExecutor object at 0x761d7b1d56d0>
  File "/home/kimnal0/miniconda3/envs/auto-code-rover/lib/python3.12/concurrent/futures/process.py", line 797, in _launch_processes
    self._spawn_process()
    │    └ <function ProcessPoolExecutor._spawn_process at 0x761e6ae71f80>
    └ <concurrent.futures.process.ProcessPoolExecutor object at 0x761d7b1d56d0>
  File "/home/kimnal0/miniconda3/envs/auto-code-rover/lib/python3.12/concurrent/futures/process.py", line 807, in _spawn_process
    p.start()
    │ └ <function BaseProcess.start at 0x761e6b02cea0>
    └ <ForkProcess name='ForkProcess-232' parent=497161 started>
  File "/home/kimnal0/miniconda3/envs/auto-code-rover/lib/python3.12/multiprocessing/process.py", line 121, in start
    self._popen = self._Popen(self)
    │    │        │    │      └ <ForkProcess name='ForkProcess-232' parent=497161 started>
    │    │        │    └ <staticmethod(<function ForkProcess._Popen at 0x761e6b09e0c0>)>
    │    │        └ <ForkProcess name='ForkProcess-232' parent=497161 started>
    │    └ None
    └ <ForkProcess name='ForkProcess-232' parent=497161 started>
  File "/home/kimnal0/miniconda3/envs/auto-code-rover/lib/python3.12/multiprocessing/context.py", line 282, in _Popen
    return Popen(process_obj)
           │     └ <ForkProcess name='ForkProcess-232' parent=497161 started>
           └ <class 'multiprocessing.popen_fork.Popen'>
  File "/home/kimnal0/miniconda3/envs/auto-code-rover/lib/python3.12/multiprocessing/popen_fork.py", line 19, in __init__
    self._launch(process_obj)
    │    │       └ <ForkProcess name='ForkProcess-232' parent=497161 started>
    │    └ <function Popen._launch at 0x761d7911b7e0>
    └ <multiprocessing.popen_fork.Popen object at 0x761d7a57e450>
  File "/home/kimnal0/miniconda3/envs/auto-code-rover/lib/python3.12/multiprocessing/popen_fork.py", line 71, in _launch
    code = process_obj._bootstrap(parent_sentinel=child_r)
           │           │                          └ 13
           │           └ <function BaseProcess._bootstrap at 0x761e6b02d8a0>
           └ <ForkProcess name='ForkProcess-232' parent=497161 started>
  File "/home/kimnal0/miniconda3/envs/auto-code-rover/lib/python3.12/multiprocessing/process.py", line 314, in _bootstrap
    self.run()
    │    └ <function BaseProcess.run at 0x761e6b02ce00>
    └ <ForkProcess name='ForkProcess-232' parent=497161 started>
  File "/home/kimnal0/miniconda3/envs/auto-code-rover/lib/python3.12/multiprocessing/process.py", line 108, in run
    self._target(*self._args, **self._kwargs)
    │    │        │    │        │    └ {}
    │    │        │    │        └ <ForkProcess name='ForkProcess-232' parent=497161 started>
    │    │        │    └ (<concurrent.futures.process._SafeQueue object at 0x761d79006bd0>, <multiprocessing.queues.SimpleQueue object at 0x761d795c4c...
    │    │        └ <ForkProcess name='ForkProcess-232' parent=497161 started>
    │    └ <function _process_worker at 0x761e6ae711c0>
    └ <ForkProcess name='ForkProcess-232' parent=497161 started>
  File "/home/kimnal0/miniconda3/envs/auto-code-rover/lib/python3.12/concurrent/futures/process.py", line 263, in _process_worker
    r = call_item.fn(*call_item.args, **call_item.kwargs)
        │         │   │         │       │         └ {}
        │         │   │         │       └ <concurrent.futures.process._CallItem object at 0x761d7b442db0>
        │         │   │         └ (<app.raw_tasks.RawSweTask object at 0x761d7a57e690>,)
        │         │   └ <concurrent.futures.process._CallItem object at 0x761d7b442db0>
        │         └ <function run_raw_task at 0x761d7b11a700>
        └ <concurrent.futures.process._CallItem object at 0x761d7b442db0>

  File "/home/kimnal0/auto-code-rover/app/main.py", line 494, in run_raw_task
    run_ok = do_inference(task.to_task(), task_output_dir)
             │            │    │          └ '/home/kimnal0/auto-code-rover/only_fl_output5/matplotlib__matplotlib-25746_2025-10-18_14-26-21'
             │            │    └ <function RawSweTask.to_task at 0x761d7b1196c0>
             │            └ <app.raw_tasks.RawSweTask object at 0x761d7a57e690>
             └ <function do_inference at 0x761d7b11a8e0>

  File "/home/kimnal0/auto-code-rover/app/main.py", line 590, in do_inference
    run_ok = inference.run_one_task(
             │         └ <function run_one_task at 0x761d7b228400>
             └ <module 'app.inference' from '/home/kimnal0/auto-code-rover/app/inference.py'>

  File "/home/kimnal0/auto-code-rover/app/inference.py", line 128, in run_one_task
    if _run_one_task(str(out_dir), api_manager, task.get_issue_statement()):
       │                 │         │            │    └ <function SweTask.get_issue_statement at 0x761d7b9b84a0>
       │                 │         │            └ SweTask(task_id='matplotlib__matplotlib-25746', problem_statement="Add fontfamily/labelfont to tick_params\n<!--\r\nWelcome! ...
       │                 │         └ <app.manage.ProjectApiManager object at 0x761d7b6a3170>
       │                 └ Path('/home/kimnal0/auto-code-rover/only_fl_output5/matplotlib__matplotlib-25746_2025-10-18_14-26-21/output_0')
       └ <function _run_one_task at 0x761d7b2298a0>

  File "/home/kimnal0/auto-code-rover/app/inference.py", line 303, in _run_one_task
    bug_locs, search_msg_thread = api_manager.search_manager.search_iterative(
                                  │           │              └ <function SearchManager.search_iterative at 0x761d7b431bc0>
                                  │           └ <app.search.search_manage.SearchManager object at 0x761d795c7ec0>
                                  └ <app.manage.ProjectApiManager object at 0x761d7b6a3170>

  File "/home/kimnal0/auto-code-rover/app/search/search_manage.py", line 125, in search_iterative
    new_bug_locations.extend(self.backend.get_bug_loc_snippets_new(loc))
    │                 │      │    │       │                        └ {'file': 'lib/mpl_toolkits/mplot3d/axes3d.py', 'class': 'Axes3D', 'method': 'tick_params', 'intended_behavior': "Update the `...
    │                 │      │    │       └ <function SearchBackend.get_bug_loc_snippets_new at 0x761d7b4318a0>
    │                 │      │    └ <app.search.search_backend.SearchBackend object at 0x761d7b21d610>
    │                 │      └ <app.search.search_manage.SearchManager object at 0x761d795c7ec0>
    │                 └ <method 'extend' of 'list' objects>
    └ [<file>lib/matplotlib/axes/_base.py</file>
      <class>_AxesBase</class>
      <method>tick_params</method>
      <code>
      3307     def tick_par...

  File "/home/kimnal0/auto-code-rover/app/search/search_backend.py", line 825, in get_bug_loc_snippets_new
    self._get_inherited_methods(res.class_name, res.func_name)
    │    │                      │   │           │   └ 'tick_params'
    │    │                      │   │           └ SearchResult(file_path='/home/kimnal0/auto-code-rover/SWE-bench/testbed/matplotlib__matplotlib/setup_matplotlib__matplotlib__...
    │    │                      │   └ 'Axes3D'
    │    │                      └ SearchResult(file_path='/home/kimnal0/auto-code-rover/SWE-bench/testbed/matplotlib__matplotlib/setup_matplotlib__matplotlib__...
    │    └ <function SearchBackend._get_inherited_methods at 0x761d7b431800>
    └ <app.search.search_backend.SearchBackend object at 0x761d7b21d610>

  File "/home/kimnal0/auto-code-rover/app/search/search_backend.py", line 748, in _get_inherited_methods
    output, search_res, call_ok = self.search_method_in_class(super_call)
                                  │    │                      └ {'class_name': '_AxesBase', 'method_name': 'tick_params'}
                                  │    └ <function SearchBackend.search_method_in_class at 0x761d7b430f40>
                                  └ <app.search.search_backend.SearchBackend object at 0x761d7b21d610>

> File "/home/kimnal0/auto-code-rover/app/utils.py", line 343, in wrapper
    return func(*args, **kwargs)
           │     │       └ {}
           │     └ (<app.search.search_backend.SearchBackend object at 0x761d7b21d610>, {'class_name': '_AxesBase', 'method_name': 'tick_params'})
           └ <function SearchBackend.search_method_in_class at 0x761d7b430ea0>

TypeError: SearchBackend.search_method_in_class() missing 1 required positional argument: 'class_name'
2025-10-18 14:27:39.135 | DEBUG    | Bug location extracted successfully: [<file>lib/matplotlib/axes/_base.py</file>
<class>_AxesBase</class>
<method>tick_params</method>
<code>
3307     def tick_params(self, axis='both', **kwargs):
3308         """
3309         Change the appearance of ticks, tick labels, and gridlines.
3310 
3311         Tick properties that are not explicitly set using the keyword
3312         arguments remain unchanged unless *reset* is True. For the current
3313         style settings, see `.Axis.get_tick_params`.
3314 
3315         Parameters
3316         ----------
3317         axis : {'x', 'y', 'both'}, default: 'both'
3318             The axis to which the parameters are applied.
3319         which : {'major', 'minor', 'both'}, default: 'major'
3320             The group of ticks to which the parameters are applied.
3321         reset : bool, default: False
3322             Whether to reset the ticks to defaults before updating them.
3323 
3324         Other Parameters
3325         ----------------
3326         direction : {'in', 'out', 'inout'}
3327             Puts ticks inside the Axes, outside the Axes, or both.
3328         length : float
3329             Tick length in points.
3330         width : float
3331             Tick width in points.
3332         color : color
3333             Tick color.
3334         pad : float
3335             Distance in points between tick and label.
3336         labelsize : float or str
3337             Tick label font size in points or as a string (e.g., 'large').
3338         labelcolor : color
3339             Tick label color.
3340         colors : color
3341             Tick color and label color.
3342         zorder : float
3343             Tick and label zorder.
3344         bottom, top, left, right : bool
3345             Whether to draw the respective ticks.
3346         labelbottom, labeltop, labelleft, labelright : bool
3347             Whether to draw the respective tick labels.
3348         labelrotation : float
3349             Tick label rotation
3350         grid_color : color
3351             Gridline color.
3352         grid_alpha : float
3353             Transparency of gridlines: 0 (transparent) to 1 (opaque).
3354         grid_linewidth : float
3355             Width of gridlines in points.
3356         grid_linestyle : str
3357             Any valid `.Line2D` line style spec.
3358 
3359         Examples
3360         --------
3361         ::
3362 
3363             ax.tick_params(direction='out', length=6, width=2, colors='r',
3364                            grid_color='r', grid_alpha=0.5)
3365 
3366         This will make all major ticks be red, pointing out of the box,
3367         and with dimensions 6 points by 2 points.  Tick labels will
3368         also be red.  Gridlines will be red and translucent.
3369 
3370         """
3371         _api.check_in_list(['x', 'y', 'both'], axis=axis)
3372         if axis in ['x', 'both']:
3373             xkw = dict(kwargs)
3374             xkw.pop('left', None)
3375             xkw.pop('right', None)
3376             xkw.pop('labelleft', None)
3377             xkw.pop('labelright', None)
3378             self.xaxis.set_tick_params(**xkw)
3379         if axis in ['y', 'both']:
3380             ykw = dict(kwargs)
3381             ykw.pop('top', None)
3382             ykw.pop('bottom', None)
3383             ykw.pop('labeltop', None)
3384             ykw.pop('labelbottom', None)
3385             self.yaxis.set_tick_params(**ykw)

</code><intended_behavior>Modify the `tick_params` method to include a `fontfamily` keyword argument. This argument should allow the user to specify the font family for the tick labels. When processing the `**kwargs` within `tick_params`, the method should apply the specified `fontfamily` to both the x-axis and y-axis tick labels, ensuring that if `fontfamily` is specified, it is respected and applied correctly to the ticks as specified by the `axis` argument. This enhancement must ensure backward compatibility, thus, if `fontfamily` is not specified, the default behavior (using the plot's or the system's default font family) remains unchanged.</intended_behavior>, <file>lib/matplotlib/axes/_base.py</file>
<class>_AxesBase</class>
<method>None</method>
<code>
548 class _AxesBase(martist.Artist):
549     name = "rectilinear"
550 
551     # axis names are the prefixes for the attributes that contain the
552     # respective axis; e.g. 'x' <-> self.xaxis, containing an XAxis.
553     # Note that PolarAxes uses these attributes as well, so that we have
554     # 'x' <-> self.xaxis, containing a ThetaAxis. In particular we do not
555     # have 'theta' in _axis_names.
556     # In practice, this is ('x', 'y') for all 2D Axes and ('x', 'y', 'z')
557     # for Axes3D.
558     _axis_names = ("x", "y")
559     _shared_axes = {name: cbook.Grouper() for name in _axis_names}
560     _twinned_axes = cbook.Grouper()
561 
562     _subclass_uses_cla = False
563 
564     @property
565     def _axis_map(self):
566         """A mapping of axis names, e.g. 'x', to `Axis` instances."""
567         return {name: getattr(self, f"{name}axis")
568                 for name in self._axis_names}
569 
570     def __str__(self):
571         return "{0}({1[0]:g},{1[1]:g};{1[2]:g}x{1[3]:g})".format(
572             type(self).__name__, self._position.bounds)
573 
574     def __init__(self, fig,
575                  *args,
576                  facecolor=None,  # defaults to rc axes.facecolor
577                  frameon=True,
578                  sharex=None,  # use Axes instance's xaxis info
579                  sharey=None,  # use Axes instance's yaxis info
580                  label='',
581                  xscale=None,
582                  yscale=None,
583                  box_aspect=None,
584                  **kwargs
585                  ):
586         """
587         Build an Axes in a figure.
588 
589         Parameters
590         ----------
591         fig : `~matplotlib.figure.Figure`
592             The Axes is built in the `.Figure` *fig*.
593 
594         *args
595             ``*args`` can be a single ``(left, bottom, width, height)``
596             rectangle or a single `.Bbox`.  This specifies the rectangle (in
597             figure coordinates) where the Axes is positioned.
598 
599             ``*args`` can also consist of three numbers or a single three-digit
600             number; in the latter case, the digits are considered as
601             independent numbers.  The numbers are interpreted as ``(nrows,
602             ncols, index)``: ``(nrows, ncols)`` specifies the size of an array
603             of subplots, and ``index`` is the 1-based index of the subplot
604             being created.  Finally, ``*args`` can also directly be a
605             `.SubplotSpec` instance.
606 
607         sharex, sharey : `~.axes.Axes`, optional
608             The x- or y-`~.matplotlib.axis` is shared with the x- or y-axis in
609             the input `~.axes.Axes`.
610 
611         frameon : bool, default: True
612             Whether the Axes frame is visible.
613 
614         box_aspect : float, optional
615             Set a fixed aspect for the Axes box, i.e. the ratio of height to
616             width. See `~.axes.Axes.set_box_aspect` for details.
617 
618         **kwargs
619             Other optional keyword arguments:
620 
621             %(Axes:kwdoc)s
622 
623         Returns
624         -------
625         `~.axes.Axes`
626             The new `~.axes.Axes` object.
627         """
628 
629         super().__init__()
630         if "rect" in kwargs:
631             if args:
632                 raise TypeError(
633                     "'rect' cannot be used together with positional arguments")
634             rect = kwargs.pop("rect")
635             _api.check_isinstance((mtransforms.Bbox, Iterable), rect=rect)
636             args = (rect,)
637         subplotspec = None
638         if len(args) == 1 and isinstance(args[0], mtransforms.Bbox):
639             self._position = args[0]
640         elif len(args) == 1 and np.iterable(args[0]):
641             self._position = mtransforms.Bbox.from_bounds(*args[0])
642         else:
643             self._position = self._originalPosition = mtransforms.Bbox.unit()
644             subplotspec = SubplotSpec._from_subplot_args(fig, args)
645         if self._position.width < 0 or self._position.height < 0:
646             raise ValueError('Width and height specified must be non-negative')
647         self._originalPosition = self._position.frozen()
648         self.axes = self
649         self._aspect = 'auto'
650         self._adjustable = 'box'
651         self._anchor = 'C'
652         self._stale_viewlims = {name: False for name in self._axis_names}
653         self._sharex = sharex
654         self._sharey = sharey
655         self.set_label(label)
656         self.set_figure(fig)
657         # The subplotspec needs to be set after the figure (so that
658         # figure-level subplotpars are taken into account), but the figure
659         # needs to be set after self._position is initialized.
660         if subplotspec:
661             self.set_subplotspec(subplotspec)
662         else:
663             self._subplotspec = None
664         self.set_box_aspect(box_aspect)
665         self._axes_locator = None  # Optionally set via update(kwargs).
666 
667         self._children = []
668 
669         # placeholder for any colorbars added that use this Axes.
670         # (see colorbar.py):
671         self._colorbars = []
672         self.spines = mspines.Spines.from_dict(self._gen_axes_spines())
673 
674         # this call may differ for non-sep axes, e.g., polar
675         self._init_axis()
676         if facecolor is None:
677             facecolor = mpl.rcParams['axes.facecolor']
678         self._facecolor = facecolor
679         self._frameon = frameon
680         self.set_axisbelow(mpl.rcParams['axes.axisbelow'])
681 
682         self._rasterization_zorder = None
683         self.clear()
684 
685         # funcs used to format x and y - fall back on major formatters
686         self.fmt_xdata = None
687         self.fmt_ydata = None
688 
689         self.set_navigate(True)
690         self.set_navigate_mode(None)
691 
692         if xscale:
693             self.set_xscale(xscale)
694         if yscale:
695             self.set_yscale(yscale)
696 
697         self._internal_update(kwargs)
698 
699         for name, axis in self._axis_map.items():
700             axis.callbacks._connect_picklable(
701                 'units', self._unit_change_handler(name))
702 
703         rcParams = mpl.rcParams
704         self.tick_params(
705             top=rcParams['xtick.top'] and rcParams['xtick.minor.top'],
706             bottom=rcParams['xtick.bottom'] and rcParams['xtick.minor.bottom'],
707             labeltop=(rcParams['xtick.labeltop'] and
708                       rcParams['xtick.minor.top']),
709             labelbottom=(rcParams['xtick.labelbottom'] and
710                          rcParams['xtick.minor.bottom']),
711             left=rcParams['ytick.left'] and rcParams['ytick.minor.left'],
712             right=rcParams['ytick.right'] and rcParams['ytick.minor.right'],
713             labelleft=(rcParams['ytick.labelleft'] and
714                        rcParams['ytick.minor.left']),
715             labelright=(rcParams['ytick.labelright'] and
716                         rcParams['ytick.minor.right']),
717             which='minor')
718 
719         self.tick_params(
720             top=rcParams['xtick.top'] and rcParams['xtick.major.top'],
721             bottom=rcParams['xtick.bottom'] and rcParams['xtick.major.bottom'],
722             labeltop=(rcParams['xtick.labeltop'] and
723                       rcParams['xtick.major.top']),
724             labelbottom=(rcParams['xtick.labelbottom'] and
725                          rcParams['xtick.major.bottom']),
726             left=rcParams['ytick.left'] and rcParams['ytick.major.left'],
727             right=rcParams['ytick.right'] and rcParams['ytick.major.right'],
728             labelleft=(rcParams['ytick.labelleft'] and
729                        rcParams['ytick.major.left']),
730             labelright=(rcParams['ytick.labelright'] and
731                         rcParams['ytick.major.right']),
732             which='major')
733 
734     def __init_subclass__(cls, **kwargs):
735         parent_uses_cla = super(cls, cls)._subclass_uses_cla
736         if 'cla' in cls.__dict__:
737             _api.warn_deprecated(
738                 '3.6',
739                 pending=True,
740                 message=f'Overriding `Axes.cla` in {cls.__qualname__} is '
741                 'pending deprecation in %(since)s and will be fully '
742                 'deprecated in favor of `Axes.clear` in the future. '
743                 'Please report '
744                 f'this to the {cls.__module__!r} author.')
745         cls._subclass_uses_cla = 'cla' in cls.__dict__ or parent_uses_cla
746         super().__init_subclass__(**kwargs)
747 
748     def __getstate__(self):
749         state = super().__getstate__()
750         # Prune the sharing & twinning info to only contain the current group.
751         state["_shared_axes"] = {
752             name: self._shared_axes[name].get_siblings(self)
753             for name in self._axis_names if self in self._shared_axes[name]}
754         state["_twinned_axes"] = (self._twinned_axes.get_siblings(self)
755                                   if self in self._twinned_axes else None)
756         return state
757 
758     def __setstate__(self, state):
759         # Merge the grouping info back into the global groupers.
760         shared_axes = state.pop("_shared_axes")
761         for name, shared_siblings in shared_axes.items():
762             self._shared_axes[name].join(*shared_siblings)
763         twinned_siblings = state.pop("_twinned_axes")
764         if twinned_siblings:
765             self._twinned_axes.join(*twinned_siblings)
766         self.__dict__ = state
767         self._stale = True
768 
769     def __repr__(self):
770         fields = []
771         if self.get_label():
772             fields += [f"label={self.get_label()!r}"]
773         if hasattr(self, "get_title"):
774             titles = {}
775             for k in ["left", "center", "right"]:
776                 title = self.get_title(loc=k)
777                 if title:
778                     titles[k] = title
779             if titles:
780                 fields += [f"title={titles}"]
781         for name, axis in self._axis_map.items():
782             if axis.get_label() and axis.get_label().get_text():
783                 fields += [f"{name}label={axis.get_label().get_text()!r}"]
784         return f"<{self.__class__.__name__}: " + ", ".join(fields) + ">"
785 
786     def get_subplotspec(self):
787         """Return the `.SubplotSpec` associated with the subplot, or None."""
788         return self._subplotspec
789 
790     def set_subplotspec(self, subplotspec):
791         """Set the `.SubplotSpec`. associated with the subplot."""
792         self._subplotspec = subplotspec
793         self._set_position(subplotspec.get_position(self.figure))
794 
795     def get_gridspec(self):
796         """Return the `.GridSpec` associated with the subplot, or None."""
797         return self._subplotspec.get_gridspec() if self._subplotspec else None
798 
799     def get_window_extent(self, renderer=None):
800         """
801         Return the Axes bounding box in display space.
802 
803         This bounding box does not include the spines, ticks, ticklabels,
804         or other labels.  For a bounding box including these elements use
805         `~matplotlib.axes.Axes.get_tightbbox`.
806 
807         See Also
808         --------
809         matplotlib.axes.Axes.get_tightbbox
810         matplotlib.axis.Axis.get_tightbbox
811         matplotlib.spines.Spine.get_window_extent
812         """
813         return self.bbox
814 
815     def _init_axis(self):
816         # This is moved out of __init__ because non-separable axes don't use it
817         self.xaxis = maxis.XAxis(self)
818         self.spines.bottom.register_axis(self.xaxis)
819         self.spines.top.register_axis(self.xaxis)
820         self.yaxis = maxis.YAxis(self)
821         self.spines.left.register_axis(self.yaxis)
822         self.spines.right.register_axis(self.yaxis)
823 
824     def set_figure(self, fig):
825         # docstring inherited
826         super().set_figure(fig)
827 
828         self.bbox = mtransforms.TransformedBbox(self._position,
829                                                 fig.transSubfigure)
830         # these will be updated later as data is added
831         self.dataLim = mtransforms.Bbox.null()
832         self._viewLim = mtransforms.Bbox.unit()
833         self.transScale = mtransforms.TransformWrapper(
834             mtransforms.IdentityTransform())
835 
836         self._set_lim_and_transforms()
837 
838     def _unstale_viewLim(self):
839         # We should arrange to store this information once per share-group
840         # instead of on every axis.
841         need_scale = {
842             name: any(ax._stale_viewlims[name]
843                       for ax in self._shared_axes[name].get_siblings(self))
844             for name in self._axis_names}
845         if any(need_scale.values()):
846             for name in need_scale:
847                 for ax in self._shared_axes[name].get_siblings(self):
848                     ax._stale_viewlims[name] = False
849             self.autoscale_view(**{f"scale{name}": scale
850                                    for name, scale in need_scale.items()})
851 
852     @property
853     def viewLim(self):
854         self._unstale_viewLim()
855         return self._viewLim
856 
857     def _request_autoscale_view(self, axis="all", tight=None):
858         """
859         Mark a single axis, or all of them, as stale wrt. autoscaling.
860 
861         No computation is performed until the next autoscaling; thus, separate
862         calls to control individual axises incur negligible performance cost.
863 
864         Parameters
865         ----------
866         axis : str, default: "all"
867             Either an element of ``self._axis_names``, or "all".
868         tight : bool or None, default: None
869         """
870         axis_names = _api.check_getitem(
871             {**{k: [k] for k in self._axis_names}, "all": self._axis_names},
872             axis=axis)
873         for name in axis_names:
874             self._stale_viewlims[name] = True
875         if tight is not None:
876             self._tight = tight
877 
878     def _set_lim_and_transforms(self):
879         """
880         Set the *_xaxis_transform*, *_yaxis_transform*, *transScale*,
881         *transData*, *transLimits* and *transAxes* transformations.
882 
883         .. note::
884 
885             This method is primarily used by rectilinear projections of the
886             `~matplotlib.axes.Axes` class, and is meant to be overridden by
887             new kinds of projection Axes that need different transformations
888             and limits. (See `~matplotlib.projections.polar.PolarAxes` for an
889             example.)
890         """
891         self.transAxes = mtransforms.BboxTransformTo(self.bbox)
892 
893         # Transforms the x and y axis separately by a scale factor.
894         # It is assumed that this part will have non-linear components
895         # (e.g., for a log scale).
896         self.transScale = mtransforms.TransformWrapper(
897             mtransforms.IdentityTransform())
898 
899         # An affine transformation on the data, generally to limit the
900         # range of the axes
901         self.transLimits = mtransforms.BboxTransformFrom(
902             mtransforms.TransformedBbox(self._viewLim, self.transScale))
903 
904         # The parentheses are important for efficiency here -- they
905         # group the last two (which are usually affines) separately
906         # from the first (which, with log-scaling can be non-affine).
907         self.transData = self.transScale + (self.transLimits + self.transAxes)
908 
909         self._xaxis_transform = mtransforms.blended_transform_factory(
910             self.transData, self.transAxes)
911         self._yaxis_transform = mtransforms.blended_transform_factory(
912             self.transAxes, self.transData)
913 
914     def get_xaxis_transform(self, which='grid'):
915         """
916         Get the transformation used for drawing x-axis labels, ticks
917         and gridlines.  The x-direction is in data coordinates and the
918         y-direction is in axis coordinates.
919 
920         .. note::
921 
922             This transformation is primarily used by the
923             `~matplotlib.axis.Axis` class, and is meant to be
924             overridden by new kinds of projections that may need to
925             place axis elements in different locations.
926 
927         Parameters
928         ----------
929         which : {'grid', 'tick1', 'tick2'}
930         """
931         if which == 'grid':
932             return self._xaxis_transform
933         elif which == 'tick1':
934             # for cartesian projection, this is bottom spine
935             return self.spines.bottom.get_spine_transform()
936         elif which == 'tick2':
937             # for cartesian projection, this is top spine
938             return self.spines.top.get_spine_transform()
939         else:
940             raise ValueError(f'unknown value for which: {which!r}')
941 
942     def get_xaxis_text1_transform(self, pad_points):
943         """
944         Returns
945         -------
946         transform : Transform
947             The transform used for drawing x-axis labels, which will add
948             *pad_points* of padding (in points) between the axis and the label.
949             The x-direction is in data coordinates and the y-direction is in
950             axis coordinates
951         valign : {'center', 'top', 'bottom', 'baseline', 'center_baseline'}
952             The text vertical alignment.
953         halign : {'center', 'left', 'right'}
954             The text horizontal alignment.
955 
956         Notes
957         -----
958         This transformation is primarily used by the `~matplotlib.axis.Axis`
959         class, and is meant to be overridden by new kinds of projections that
960         may need to place axis elements in different locations.
961         """
962         labels_align = mpl.rcParams["xtick.alignment"]
963         return (self.get_xaxis_transform(which='tick1') +
964                 mtransforms.ScaledTranslation(0, -1 * pad_points / 72,
965                                               self.figure.dpi_scale_trans),
966                 "top", labels_align)
967 
968     def get_xaxis_text2_transform(self, pad_points):
969         """
970         Returns
971         -------
972         transform : Transform
973             The transform used for drawing secondary x-axis labels, which will
974             add *pad_points* of padding (in points) between the axis and the
975             label.  The x-direction is in data coordinates and the y-direction
976             is in axis coordinates
977         valign : {'center', 'top', 'bottom', 'baseline', 'center_baseline'}
978             The text vertical alignment.
979         halign : {'center', 'left', 'right'}
980             The text horizontal alignment.
981 
982         Notes
983         -----
984         This transformation is primarily used by the `~matplotlib.axis.Axis`
985         class, and is meant to be overridden by new kinds of projections that
986         may need to place axis elements in different locations.
987         """
988         labels_align = mpl.rcParams["xtick.alignment"]
989         return (self.get_xaxis_transform(which='tick2') +
990                 mtransforms.ScaledTranslation(0, pad_points / 72,
991                                               self.figure.dpi_scale_trans),
992                 "bottom", labels_align)
993 
994     def get_yaxis_transform(self, which='grid'):
995         """
996         Get the transformation used for drawing y-axis labels, ticks
997         and gridlines.  The x-direction is in axis coordinates and the
998         y-direction is in data coordinates.
999 
1000         .. note::
1001 
1002             This transformation is primarily used by the
1003             `~matplotlib.axis.Axis` class, and is meant to be
1004             overridden by new kinds of projections that may need to
1005             place axis elements in different locations.
1006 
1007         Parameters
1008         ----------
1009         which : {'grid', 'tick1', 'tick2'}
1010         """
1011         if which == 'grid':
1012             return self._yaxis_transform
1013         elif which == 'tick1':
1014             # for cartesian projection, this is bottom spine
1015             return self.spines.left.get_spine_transform()
1016         elif which == 'tick2':
1017             # for cartesian projection, this is top spine
1018             return self.spines.right.get_spine_transform()
1019         else:
1020             raise ValueError(f'unknown value for which: {which!r}')
1021 
1022     def get_yaxis_text1_transform(self, pad_points):
1023         """
1024         Returns
1025         -------
1026         transform : Transform
1027             The transform used for drawing y-axis labels, which will add
1028             *pad_points* of padding (in points) between the axis and the label.
1029             The x-direction is in axis coordinates and the y-direction is in
1030             data coordinates
1031         valign : {'center', 'top', 'bottom', 'baseline', 'center_baseline'}
1032             The text vertical alignment.
1033         halign : {'center', 'left', 'right'}
1034             The text horizontal alignment.
1035 
1036         Notes
1037         -----
1038         This transformation is primarily used by the `~matplotlib.axis.Axis`
1039         class, and is meant to be overridden by new kinds of projections that
1040         may need to place axis elements in different locations.
1041         """
1042         labels_align = mpl.rcParams["ytick.alignment"]
1043         return (self.get_yaxis_transform(which='tick1') +
1044                 mtransforms.ScaledTranslation(-1 * pad_points / 72, 0,
1045                                               self.figure.dpi_scale_trans),
1046                 labels_align, "right")
1047 
1048     def get_yaxis_text2_transform(self, pad_points):
1049         """
1050         Returns
1051         -------
1052         transform : Transform
1053             The transform used for drawing secondart y-axis labels, which will
1054             add *pad_points* of padding (in points) between the axis and the
1055             label.  The x-direction is in axis coordinates and the y-direction
1056             is in data coordinates
1057         valign : {'center', 'top', 'bottom', 'baseline', 'center_baseline'}
1058             The text vertical alignment.
1059         halign : {'center', 'left', 'right'}
1060             The text horizontal alignment.
1061 
1062         Notes
1063         -----
1064         This transformation is primarily used by the `~matplotlib.axis.Axis`
1065         class, and is meant to be overridden by new kinds of projections that
1066         may need to place axis elements in different locations.
1067         """
1068         labels_align = mpl.rcParams["ytick.alignment"]
1069         return (self.get_yaxis_transform(which='tick2') +
1070                 mtransforms.ScaledTranslation(pad_points / 72, 0,
1071                                               self.figure.dpi_scale_trans),
1072                 labels_align, "left")
1073 
1074     def _update_transScale(self):
1075         self.transScale.set(
1076             mtransforms.blended_transform_factory(
1077                 self.xaxis.get_transform(), self.yaxis.get_transform()))
1078 
1079     def get_position(self, original=False):
1080         """
1081         Return the position of the Axes within the figure as a `.Bbox`.
1082 
1083         Parameters
1084         ----------
1085         original : bool
1086             If ``True``, return the original position. Otherwise, return the
1087             active position. For an explanation of the positions see
1088             `.set_position`.
1089 
1090         Returns
1091         -------
1092         `.Bbox`
1093 
1094         """
1095         if original:
1096             return self._originalPosition.frozen()
1097         else:
1098             locator = self.get_axes_locator()
1099             if not locator:
1100                 self.apply_aspect()
1101             return self._position.frozen()
1102 
1103     def set_position(self, pos, which='both'):
1104         """
1105         Set the Axes position.
1106 
1107         Axes have two position attributes. The 'original' position is the
1108         position allocated for the Axes. The 'active' position is the
1109         position the Axes is actually drawn at. These positions are usually
1110         the same unless a fixed aspect is set to the Axes. See
1111         `.Axes.set_aspect` for details.
1112 
1113         Parameters
1114         ----------
1115         pos : [left, bottom, width, height] or `~matplotlib.transforms.Bbox`
1116             The new position of the Axes in `.Figure` coordinates.
1117 
1118         which : {'both', 'active', 'original'}, default: 'both'
1119             Determines which position variables to change.
1120 
1121         See Also
1122         --------
1123         matplotlib.transforms.Bbox.from_bounds
1124         matplotlib.transforms.Bbox.from_extents
1125         """
1126         self._set_position(pos, which=which)
1127         # because this is being called externally to the library we
1128         # don't let it be in the layout.
1129         self.set_in_layout(False)
1130 
1131     def _set_position(self, pos, which='both'):
1132         """
1133         Private version of set_position.
1134 
1135         Call this internally to get the same functionality of `set_position`,
1136         but not to take the axis out of the constrained_layout hierarchy.
1137         """
1138         if not isinstance(pos, mtransforms.BboxBase):
1139             pos = mtransforms.Bbox.from_bounds(*pos)
1140         for ax in self._twinned_axes.get_siblings(self):
1141             if which in ('both', 'active'):
1142                 ax._position.set(pos)
1143             if which in ('both', 'original'):
1144                 ax._originalPosition.set(pos)
1145         self.stale = True
1146 
1147     def reset_position(self):
1148         """
1149         Reset the active position to the original position.
1150 
1151         This undoes changes to the active position (as defined in
1152         `.set_position`) which may have been performed to satisfy fixed-aspect
1153         constraints.
1154         """
1155         for ax in self._twinned_axes.get_siblings(self):
1156             pos = ax.get_position(original=True)
1157             ax.set_position(pos, which='active')
1158 
1159     def set_axes_locator(self, locator):
1160         """
1161         Set the Axes locator.
1162 
1163         Parameters
1164         ----------
1165         locator : Callable[[Axes, Renderer], Bbox]
1166         """
1167         self._axes_locator = locator
1168         self.stale = True
1169 
1170     def get_axes_locator(self):
1171         """
1172         Return the axes_locator.
1173         """
1174         return self._axes_locator
1175 
1176     def _set_artist_props(self, a):
1177         """Set the boilerplate props for artists added to Axes."""
1178         a.set_figure(self.figure)
1179         if not a.is_transform_set():
1180             a.set_transform(self.transData)
1181 
1182         a.axes = self
1183         if a.get_mouseover():
1184             self._mouseover_set.add(a)
1185 
1186     def _gen_axes_patch(self):
1187         """
1188         Returns
1189         -------
1190         Patch
1191             The patch used to draw the background of the Axes.  It is also used
1192             as the clipping path for any data elements on the Axes.
1193 
1194             In the standard Axes, this is a rectangle, but in other projections
1195             it may not be.
1196 
1197         Notes
1198         -----
1199         Intended to be overridden by new projection types.
1200         """
1201         return mpatches.Rectangle((0.0, 0.0), 1.0, 1.0)
1202 
1203     def _gen_axes_spines(self, locations=None, offset=0.0, units='inches'):
1204         """
1205         Returns
1206         -------
1207         dict
1208             Mapping of spine names to `.Line2D` or `.Patch` instances that are
1209             used to draw Axes spines.
1210 
1211             In the standard Axes, spines are single line segments, but in other
1212             projections they may not be.
1213 
1214         Notes
1215         -----
1216         Intended to be overridden by new projection types.
1217         """
1218         return {side: mspines.Spine.linear_spine(self, side)
1219                 for side in ['left', 'right', 'bottom', 'top']}
1220 
1221     def sharex(self, other):
1222         """
1223         Share the x-axis with *other*.
1224 
1225         This is equivalent to passing ``sharex=other`` when constructing the
1226         Axes, and cannot be used if the x-axis is already being shared with
1227         another Axes.
1228         """
1229         _api.check_isinstance(_AxesBase, other=other)
1230         if self._sharex is not None and other is not self._sharex:
1231             raise ValueError("x-axis is already shared")
1232         self._shared_axes["x"].join(self, other)
1233         self._sharex = other
1234         self.xaxis.major = other.xaxis.major  # Ticker instances holding
1235         self.xaxis.minor = other.xaxis.minor  # locator and formatter.
1236         x0, x1 = other.get_xlim()
1237         self.set_xlim(x0, x1, emit=False, auto=other.get_autoscalex_on())
1238         self.xaxis._scale = other.xaxis._scale
1239 
1240     def sharey(self, other):
1241         """
1242         Share the y-axis with *other*.
1243 
1244         This is equivalent to passing ``sharey=other`` when constructing the
1245         Axes, and cannot be used if the y-axis is already being shared with
1246         another Axes.
1247         """
1248         _api.check_isinstance(_AxesBase, other=other)
1249         if self._sharey is not None and other is not self._sharey:
1250             raise ValueError("y-axis is already shared")
1251         self._shared_axes["y"].join(self, other)
1252         self._sharey = other
1253         self.yaxis.major = other.yaxis.major  # Ticker instances holding
1254         self.yaxis.minor = other.yaxis.minor  # locator and formatter.
1255         y0, y1 = other.get_ylim()
1256         self.set_ylim(y0, y1, emit=False, auto=other.get_autoscaley_on())
1257         self.yaxis._scale = other.yaxis._scale
1258 
1259     def __clear(self):
1260         """Clear the Axes."""
1261         # The actual implementation of clear() as long as clear() has to be
1262         # an adapter delegating to the correct implementation.
1263         # The implementation can move back into clear() when the
1264         # deprecation on cla() subclassing expires.
1265 
1266         # stash the current visibility state
1267         if hasattr(self, 'patch'):
1268             patch_visible = self.patch.get_visible()
1269         else:
1270             patch_visible = True
1271 
1272         xaxis_visible = self.xaxis.get_visible()
1273         yaxis_visible = self.yaxis.get_visible()
1274 
1275         for axis in self._axis_map.values():
1276             axis.clear()  # Also resets the scale to linear.
1277         for spine in self.spines.values():
1278             spine.clear()
1279 
1280         self.ignore_existing_data_limits = True
1281         self.callbacks = cbook.CallbackRegistry(
1282             signals=["xlim_changed", "ylim_changed", "zlim_changed"])
1283 
1284         # update the minor locator for x and y axis based on rcParams
1285         if mpl.rcParams['xtick.minor.visible']:
1286             self.xaxis.set_minor_locator(mticker.AutoMinorLocator())
1287         if mpl.rcParams['ytick.minor.visible']:
1288             self.yaxis.set_minor_locator(mticker.AutoMinorLocator())
1289 
1290         self._xmargin = mpl.rcParams['axes.xmargin']
1291         self._ymargin = mpl.rcParams['axes.ymargin']
1292         self._tight = None
1293         self._use_sticky_edges = True
1294 
1295         self._get_lines = _process_plot_var_args(self)
1296         self._get_patches_for_fill = _process_plot_var_args(self, 'fill')
1297 
1298         self._gridOn = mpl.rcParams['axes.grid']
1299         old_children, self._children = self._children, []
1300         for chld in old_children:
1301             chld.axes = chld.figure = None
1302         self._mouseover_set = _OrderedSet()
1303         self.child_axes = []
1304         self._current_image = None  # strictly for pyplot via _sci, _gci
1305         self._projection_init = None  # strictly for pyplot.subplot
1306         self.legend_ = None
1307         self.containers = []
1308 
1309         self.grid(False)  # Disable grid on init to use rcParameter
1310         self.grid(self._gridOn, which=mpl.rcParams['axes.grid.which'],
1311                   axis=mpl.rcParams['axes.grid.axis'])
1312         props = font_manager.FontProperties(
1313             size=mpl.rcParams['axes.titlesize'],
1314             weight=mpl.rcParams['axes.titleweight'])
1315 
1316         y = mpl.rcParams['axes.titley']
1317         if y is None:
1318             y = 1.0
1319             self._autotitlepos = True
1320         else:
1321             self._autotitlepos = False
1322 
1323         self.title = mtext.Text(
1324             x=0.5, y=y, text='',
1325             fontproperties=props,
1326             verticalalignment='baseline',
1327             horizontalalignment='center',
1328             )
1329         self._left_title = mtext.Text(
1330             x=0.0, y=y, text='',
1331             fontproperties=props.copy(),
1332             verticalalignment='baseline',
1333             horizontalalignment='left', )
1334         self._right_title = mtext.Text(
1335             x=1.0, y=y, text='',
1336             fontproperties=props.copy(),
1337             verticalalignment='baseline',
1338             horizontalalignment='right',
1339             )
1340         title_offset_points = mpl.rcParams['axes.titlepad']
1341         # refactor this out so it can be called in ax.set_title if
1342         # pad argument used...
1343         self._set_title_offset_trans(title_offset_points)
1344 
1345         for _title in (self.title, self._left_title, self._right_title):
1346             self._set_artist_props(_title)
1347 
1348         # The patch draws the background of the Axes.  We want this to be below
1349         # the other artists.  We use the frame to draw the edges so we are
1350         # setting the edgecolor to None.
1351         self.patch = self._gen_axes_patch()
1352         self.patch.set_figure(self.figure)
1353         self.patch.set_facecolor(self._facecolor)
1354         self.patch.set_edgecolor('none')
1355         self.patch.set_linewidth(0)
1356         self.patch.set_transform(self.transAxes)
1357 
1358         self.set_axis_on()
1359 
1360         self.xaxis.set_clip_path(self.patch)
1361         self.yaxis.set_clip_path(self.patch)
1362 
1363         if self._sharex is not None:
1364             self.xaxis.set_visible(xaxis_visible)
1365             self.patch.set_visible(patch_visible)
1366         if self._sharey is not None:
1367             self.yaxis.set_visible(yaxis_visible)
1368             self.patch.set_visible(patch_visible)
1369 
1370         # This comes last, as the call to _set_lim may trigger an autoscale (in
1371         # case of shared axes), requiring children to be already set up.
1372         for name, axis in self._axis_map.items():
1373             share = getattr(self, f"_share{name}")
1374             if share is not None:
1375                 getattr(self, f"share{name}")(share)
1376             else:
1377                 axis._set_scale("linear")
1378                 axis._set_lim(0, 1, auto=True)
1379         self._update_transScale()
1380 
1381         self.stale = True
1382 
1383     def clear(self):
1384         """Clear the Axes."""
1385         # Act as an alias, or as the superclass implementation depending on the
1386         # subclass implementation.
1387         if self._subclass_uses_cla:
1388             self.cla()
1389         else:
1390             self.__clear()
1391 
1392     def cla(self):
1393         """Clear the Axes."""
1394         # Act as an alias, or as the superclass implementation depending on the
1395         # subclass implementation.
1396         if self._subclass_uses_cla:
1397             self.__clear()
1398         else:
1399             self.clear()
1400 
1401     class ArtistList(Sequence):
1402         """
1403         A sublist of Axes children based on their type.
1404 
1405         The type-specific children sublists were made immutable in Matplotlib
1406         3.7.  In the future these artist lists may be replaced by tuples. Use
1407         as if this is a tuple already.
1408         """
1409         def __init__(self, axes, prop_name,
1410                      valid_types=None, invalid_types=None):
1411             """
1412             Parameters
1413             ----------
1414             axes : `~matplotlib.axes.Axes`
1415                 The Axes from which this sublist will pull the children
1416                 Artists.
1417             prop_name : str
1418                 The property name used to access this sublist from the Axes;
1419                 used to generate deprecation warnings.
1420             valid_types : list of type, optional
1421                 A list of types that determine which children will be returned
1422                 by this sublist. If specified, then the Artists in the sublist
1423                 must be instances of any of these types. If unspecified, then
1424                 any type of Artist is valid (unless limited by
1425                 *invalid_types*.)
1426             invalid_types : tuple, optional
1427                 A list of types that determine which children will *not* be
1428                 returned by this sublist. If specified, then Artists in the
1429                 sublist will never be an instance of these types. Otherwise, no
1430                 types will be excluded.
1431             """
1432             self._axes = axes
1433             self._prop_name = prop_name
1434             self._type_check = lambda artist: (
1435                 (not valid_types or isinstance(artist, valid_types)) and
1436                 (not invalid_types or not isinstance(artist, invalid_types))
1437             )
1438 
1439         def __repr__(self):
1440             return f'<Axes.ArtistList of {len(self)} {self._prop_name}>'
1441 
1442         def __len__(self):
1443             return sum(self._type_check(artist)
1444                        for artist in self._axes._children)
1445 
1446         def __iter__(self):
1447             for artist in list(self._axes._children):
1448                 if self._type_check(artist):
1449                     yield artist
1450 
1451         def __getitem__(self, key):
1452             return [artist
1453                     for artist in self._axes._children
1454                     if self._type_check(artist)][key]
1455 
1456         def __add__(self, other):
1457             if isinstance(other, (list, _AxesBase.ArtistList)):
1458                 return [*self, *other]
1459             if isinstance(other, (tuple, _AxesBase.ArtistList)):
1460                 return (*self, *other)
1461             return NotImplemented
1462 
1463         def __radd__(self, other):
1464             if isinstance(other, list):
1465                 return other + list(self)
1466             if isinstance(other, tuple):
1467                 return other + tuple(self)
1468             return NotImplemented
1469 
1470     @property
1471     def artists(self):
1472         return self.ArtistList(self, 'artists', invalid_types=(
1473             mcoll.Collection, mimage.AxesImage, mlines.Line2D, mpatches.Patch,
1474             mtable.Table, mtext.Text))
1475 
1476     @property
1477     def collections(self):
1478         return self.ArtistList(self, 'collections',
1479                                valid_types=mcoll.Collection)
1480 
1481     @property
1482     def images(self):
1483         return self.ArtistList(self, 'images', valid_types=mimage.AxesImage)
1484 
1485     @property
1486     def lines(self):
1487         return self.ArtistList(self, 'lines', valid_types=mlines.Line2D)
1488 
1489     @property
1490     def patches(self):
1491         return self.ArtistList(self, 'patches', valid_types=mpatches.Patch)
1492 
1493     @property
1494     def tables(self):
1495         return self.ArtistList(self, 'tables', valid_types=mtable.Table)
1496 
1497     @property
1498     def texts(self):
1499         return self.ArtistList(self, 'texts', valid_types=mtext.Text)
1500 
1501     def get_facecolor(self):
1502         """Get the facecolor of the Axes."""
1503         return self.patch.get_facecolor()
1504 
1505     def set_facecolor(self, color):
1506         """
1507         Set the facecolor of the Axes.
1508 
1509         Parameters
1510         ----------
1511         color : color
1512         """
1513         self._facecolor = color
1514         self.stale = True
1515         return self.patch.set_facecolor(color)
1516 
1517     def _set_title_offset_trans(self, title_offset_points):
1518         """
1519         Set the offset for the title either from :rc:`axes.titlepad`
1520         or from set_title kwarg ``pad``.
1521         """
1522         self.titleOffsetTrans = mtransforms.ScaledTranslation(
1523                 0.0, title_offset_points / 72,
1524                 self.figure.dpi_scale_trans)
1525         for _title in (self.title, self._left_title, self._right_title):
1526             _title.set_transform(self.transAxes + self.titleOffsetTrans)
1527             _title.set_clip_box(None)
1528 
1529     def set_prop_cycle(self, *args, **kwargs):
1530         """
1531         Set the property cycle of the Axes.
1532 
1533         The property cycle controls the style properties such as color,
1534         marker and linestyle of future plot commands. The style properties
1535         of data already added to the Axes are not modified.
1536 
1537         Call signatures::
1538 
1539           set_prop_cycle(cycler)
1540           set_prop_cycle(label=values[, label2=values2[, ...]])
1541           set_prop_cycle(label, values)
1542 
1543         Form 1 sets given `~cycler.Cycler` object.
1544 
1545         Form 2 creates a `~cycler.Cycler` which cycles over one or more
1546         properties simultaneously and set it as the property cycle of the
1547         Axes. If multiple properties are given, their value lists must have
1548         the same length. This is just a shortcut for explicitly creating a
1549         cycler and passing it to the function, i.e. it's short for
1550         ``set_prop_cycle(cycler(label=values label2=values2, ...))``.
1551 
1552         Form 3 creates a `~cycler.Cycler` for a single property and set it
1553         as the property cycle of the Axes. This form exists for compatibility
1554         with the original `cycler.cycler` interface. Its use is discouraged
1555         in favor of the kwarg form, i.e. ``set_prop_cycle(label=values)``.
1556 
1557         Parameters
1558         ----------
1559         cycler : Cycler
1560             Set the given Cycler. *None* resets to the cycle defined by the
1561             current style.
1562 
1563         label : str
1564             The property key. Must be a valid `.Artist` property.
1565             For example, 'color' or 'linestyle'. Aliases are allowed,
1566             such as 'c' for 'color' and 'lw' for 'linewidth'.
1567 
1568         values : iterable
1569             Finite-length iterable of the property values. These values
1570             are validated and will raise a ValueError if invalid.
1571 
1572         See Also
1573         --------
1574         matplotlib.rcsetup.cycler
1575             Convenience function for creating validated cyclers for properties.
1576         cycler.cycler
1577             The original function for creating unvalidated cyclers.
1578 
1579         Examples
1580         --------
1581         Setting the property cycle for a single property:
1582 
1583         >>> ax.set_prop_cycle(color=['red', 'green', 'blue'])
1584 
1585         Setting the property cycle for simultaneously cycling over multiple
1586         properties (e.g. red circle, green plus, blue cross):
1587 
1588         >>> ax.set_prop_cycle(color=['red', 'green', 'blue'],
1589         ...                   marker=['o', '+', 'x'])
1590 
1591         """
1592         if args and kwargs:
1593             raise TypeError("Cannot supply both positional and keyword "
1594                             "arguments to this method.")
1595         # Can't do `args == (None,)` as that crashes cycler.
1596         if len(args) == 1 and args[0] is None:
1597             prop_cycle = None
1598         else:
1599             prop_cycle = cycler(*args, **kwargs)
1600         self._get_lines.set_prop_cycle(prop_cycle)
1601         self._get_patches_for_fill.set_prop_cycle(prop_cycle)
1602 
1603     def get_aspect(self):
1604         """
1605         Return the aspect ratio of the axes scaling.
1606 
1607         This is either "auto" or a float giving the ratio of y/x-scale.
1608         """
1609         return self._aspect
1610 
1611     def set_aspect(self, aspect, adjustable=None, anchor=None, share=False):
1612         """
1613         Set the aspect ratio of the axes scaling, i.e. y/x-scale.
1614 
1615         Parameters
1616         ----------
1617         aspect : {'auto', 'equal'} or float
1618             Possible values:
1619 
1620             - 'auto': fill the position rectangle with data.
1621             - 'equal': same as ``aspect=1``, i.e. same scaling for x and y.
1622             - *float*: The displayed size of 1 unit in y-data coordinates will
1623               be *aspect* times the displayed size of 1 unit in x-data
1624               coordinates; e.g. for ``aspect=2`` a square in data coordinates
1625               will be rendered with a height of twice its width.
1626 
1627         adjustable : None or {'box', 'datalim'}, optional
1628             If not ``None``, this defines which parameter will be adjusted to
1629             meet the required aspect. See `.set_adjustable` for further
1630             details.
1631 
1632         anchor : None or str or (float, float), optional
1633             If not ``None``, this defines where the Axes will be drawn if there
1634             is extra space due to aspect constraints. The most common way
1635             to specify the anchor are abbreviations of cardinal directions:
1636 
1637             =====   =====================
1638             value   description
1639             =====   =====================
1640             'C'     centered
1641             'SW'    lower left corner
1642             'S'     middle of bottom edge
1643             'SE'    lower right corner
1644             etc.
1645             =====   =====================
1646 
1647             See `~.Axes.set_anchor` for further details.
1648 
1649         share : bool, default: False
1650             If ``True``, apply the settings to all shared Axes.
1651 
1652         See Also
1653         --------
1654         matplotlib.axes.Axes.set_adjustable
1655             Set how the Axes adjusts to achieve the required aspect ratio.
1656         matplotlib.axes.Axes.set_anchor
1657             Set the position in case of extra space.
1658         """
1659         if cbook._str_equal(aspect, 'equal'):
1660             aspect = 1
1661         if not cbook._str_equal(aspect, 'auto'):
1662             aspect = float(aspect)  # raise ValueError if necessary
1663             if aspect <= 0 or not np.isfinite(aspect):
1664                 raise ValueError("aspect must be finite and positive ")
1665 
1666         if share:
1667             axes = {sibling for name in self._axis_names
1668                     for sibling in self._shared_axes[name].get_siblings(self)}
1669         else:
1670             axes = [self]
1671 
1672         for ax in axes:
1673             ax._aspect = aspect
1674 
1675         if adjustable is None:
1676             adjustable = self._adjustable
1677         self.set_adjustable(adjustable, share=share)  # Handle sharing.
1678 
1679         if anchor is not None:
1680             self.set_anchor(anchor, share=share)
1681         self.stale = True
1682 
1683     def get_adjustable(self):
1684         """
1685         Return whether the Axes will adjust its physical dimension ('box') or
1686         its data limits ('datalim') to achieve the desired aspect ratio.
1687 
1688         See Also
1689         --------
1690         matplotlib.axes.Axes.set_adjustable
1691             Set how the Axes adjusts to achieve the required aspect ratio.
1692         matplotlib.axes.Axes.set_aspect
1693             For a description of aspect handling.
1694         """
1695         return self._adjustable
1696 
1697     def set_adjustable(self, adjustable, share=False):
1698         """
1699         Set how the Axes adjusts to achieve the required aspect ratio.
1700 
1701         Parameters
1702         ----------
1703         adjustable : {'box', 'datalim'}
1704             If 'box', change the physical dimensions of the Axes.
1705             If 'datalim', change the ``x`` or ``y`` data limits.
1706 
1707         share : bool, default: False
1708             If ``True``, apply the settings to all shared Axes.
1709 
1710         See Also
1711         --------
1712         matplotlib.axes.Axes.set_aspect
1713             For a description of aspect handling.
1714 
1715         Notes
1716         -----
1717         Shared Axes (of which twinned Axes are a special case)
1718         impose restrictions on how aspect ratios can be imposed.
1719         For twinned Axes, use 'datalim'.  For Axes that share both
1720         x and y, use 'box'.  Otherwise, either 'datalim' or 'box'
1721         may be used.  These limitations are partly a requirement
1722         to avoid over-specification, and partly a result of the
1723         particular implementation we are currently using, in
1724         which the adjustments for aspect ratios are done sequentially
1725         and independently on each Axes as it is drawn.
1726         """
1727         _api.check_in_list(["box", "datalim"], adjustable=adjustable)
1728         if share:
1729             axs = {sibling for name in self._axis_names
1730                    for sibling in self._shared_axes[name].get_siblings(self)}
1731         else:
1732             axs = [self]
1733         if (adjustable == "datalim"
1734                 and any(getattr(ax.get_data_ratio, "__func__", None)
1735                         != _AxesBase.get_data_ratio
1736                         for ax in axs)):
1737             # Limits adjustment by apply_aspect assumes that the axes' aspect
1738             # ratio can be computed from the data limits and scales.
1739             raise ValueError("Cannot set Axes adjustable to 'datalim' for "
1740                              "Axes which override 'get_data_ratio'")
1741         for ax in axs:
1742             ax._adjustable = adjustable
1743         self.stale = True
1744 
1745     def get_box_aspect(self):
1746         """
1747         Return the Axes box aspect, i.e. the ratio of height to width.
1748 
1749         The box aspect is ``None`` (i.e. chosen depending on the available
1750         figure space) unless explicitly specified.
1751 
1752         See Also
1753         --------
1754         matplotlib.axes.Axes.set_box_aspect
1755             for a description of box aspect.
1756         matplotlib.axes.Axes.set_aspect
1757             for a description of aspect handling.
1758         """
1759         return self._box_aspect
1760 
1761     def set_box_aspect(self, aspect=None):
1762         """
1763         Set the Axes box aspect, i.e. the ratio of height to width.
1764 
1765         This defines the aspect of the Axes in figure space and is not to be
1766         confused with the data aspect (see `~.Axes.set_aspect`).
1767 
1768         Parameters
1769         ----------
1770         aspect : float or None
1771             Changes the physical dimensions of the Axes, such that the ratio
1772             of the Axes height to the Axes width in physical units is equal to
1773             *aspect*. Defining a box aspect will change the *adjustable*
1774             property to 'datalim' (see `~.Axes.set_adjustable`).
1775 
1776             *None* will disable a fixed box aspect so that height and width
1777             of the Axes are chosen independently.
1778 
1779         See Also
1780         --------
1781         matplotlib.axes.Axes.set_aspect
1782             for a description of aspect handling.
1783         """
1784         axs = {*self._twinned_axes.get_siblings(self),
1785                *self._twinned_axes.get_siblings(self)}
1786 
1787         if aspect is not None:
1788             aspect = float(aspect)
1789             # when box_aspect is set to other than ´None`,
1790             # adjustable must be "datalim"
1791             for ax in axs:
1792                 ax.set_adjustable("datalim")
1793 
1794         for ax in axs:
1795             ax._box_aspect = aspect
1796             ax.stale = True
1797 
1798     def get_anchor(self):
1799         """
1800         Get the anchor location.
1801 
1802         See Also
1803         --------
1804         matplotlib.axes.Axes.set_anchor
1805             for a description of the anchor.
1806         matplotlib.axes.Axes.set_aspect
1807             for a description of aspect handling.
1808         """
1809         return self._anchor
1810 
1811     def set_anchor(self, anchor, share=False):
1812         """
1813         Define the anchor location.
1814 
1815         The actual drawing area (active position) of the Axes may be smaller
1816         than the Bbox (original position) when a fixed aspect is required. The
1817         anchor defines where the drawing area will be located within the
1818         available space.
1819 
1820         Parameters
1821         ----------
1822         anchor : (float, float) or {'C', 'SW', 'S', 'SE', 'E', 'NE', ...}
1823             Either an (*x*, *y*) pair of relative coordinates (0 is left or
1824             bottom, 1 is right or top), 'C' (center), or a cardinal direction
1825             ('SW', southwest, is bottom left, etc.).  str inputs are shorthands
1826             for (*x*, *y*) coordinates, as shown in the following diagram::
1827 
1828                ┌─────────────────┬─────────────────┬─────────────────┐
1829                │ 'NW' (0.0, 1.0) │ 'N' (0.5, 1.0)  │ 'NE' (1.0, 1.0) │
1830                ├─────────────────┼─────────────────┼─────────────────┤
1831                │ 'W'  (0.0, 0.5) │ 'C' (0.5, 0.5)  │ 'E'  (1.0, 0.5) │
1832                ├─────────────────┼─────────────────┼─────────────────┤
1833                │ 'SW' (0.0, 0.0) │ 'S' (0.5, 0.0)  │ 'SE' (1.0, 0.0) │
1834                └─────────────────┴─────────────────┴─────────────────┘
1835 
1836         share : bool, default: False
1837             If ``True``, apply the settings to all shared Axes.
1838 
1839         See Also
1840         --------
1841         matplotlib.axes.Axes.set_aspect
1842             for a description of aspect handling.
1843         """
1844         if not (anchor in mtransforms.Bbox.coefs or len(anchor) == 2):
1845             raise ValueError('argument must be among %s' %
1846                              ', '.join(mtransforms.Bbox.coefs))
1847         if share:
1848             axes = {sibling for name in self._axis_names
1849                     for sibling in self._shared_axes[name].get_siblings(self)}
1850         else:
1851             axes = [self]
1852         for ax in axes:
1853             ax._anchor = anchor
1854 
1855         self.stale = True
1856 
1857     def get_data_ratio(self):
1858         """
1859         Return the aspect ratio of the scaled data.
1860 
1861         Notes
1862         -----
1863         This method is intended to be overridden by new projection types.
1864         """
1865         txmin, txmax = self.xaxis.get_transform().transform(self.get_xbound())
1866         tymin, tymax = self.yaxis.get_transform().transform(self.get_ybound())
1867         xsize = max(abs(txmax - txmin), 1e-30)
1868         ysize = max(abs(tymax - tymin), 1e-30)
1869         return ysize / xsize
1870 
1871     def apply_aspect(self, position=None):
1872         """
1873         Adjust the Axes for a specified data aspect ratio.
1874 
1875         Depending on `.get_adjustable` this will modify either the
1876         Axes box (position) or the view limits. In the former case,
1877         `~matplotlib.axes.Axes.get_anchor` will affect the position.
1878 
1879         Parameters
1880         ----------
1881         position : None or .Bbox
1882             If not ``None``, this defines the position of the
1883             Axes within the figure as a Bbox. See `~.Axes.get_position`
1884             for further details.
1885 
1886         Notes
1887         -----
1888         This is called automatically when each Axes is drawn.  You may need
1889         to call it yourself if you need to update the Axes position and/or
1890         view limits before the Figure is drawn.
1891 
1892         See Also
1893         --------
1894         matplotlib.axes.Axes.set_aspect
1895             For a description of aspect ratio handling.
1896         matplotlib.axes.Axes.set_adjustable
1897             Set how the Axes adjusts to achieve the required aspect ratio.
1898         matplotlib.axes.Axes.set_anchor
1899             Set the position in case of extra space.
1900         """
1901         if position is None:
1902             position = self.get_position(original=True)
1903 
1904         aspect = self.get_aspect()
1905 
1906         if aspect == 'auto' and self._box_aspect is None:
1907             self._set_position(position, which='active')
1908             return
1909 
1910         trans = self.get_figure().transSubfigure
1911         bb = mtransforms.Bbox.unit().transformed(trans)
1912         # this is the physical aspect of the panel (or figure):
1913         fig_aspect = bb.height / bb.width
1914 
1915         if self._adjustable == 'box':
1916             if self in self._twinned_axes:
1917                 raise RuntimeError("Adjustable 'box' is not allowed in a "
1918                                    "twinned Axes; use 'datalim' instead")
1919             box_aspect = aspect * self.get_data_ratio()
1920             pb = position.frozen()
1921             pb1 = pb.shrunk_to_aspect(box_aspect, pb, fig_aspect)
1922             self._set_position(pb1.anchored(self.get_anchor(), pb), 'active')
1923             return
1924 
1925         # The following is only seen if self._adjustable == 'datalim'
1926         if self._box_aspect is not None:
1927             pb = position.frozen()
1928             pb1 = pb.shrunk_to_aspect(self._box_aspect, pb, fig_aspect)
1929             self._set_position(pb1.anchored(self.get_anchor(), pb), 'active')
1930             if aspect == "auto":
1931                 return
1932 
1933         # reset active to original in case it had been changed by prior use
1934         # of 'box'
1935         if self._box_aspect is None:
1936             self._set_position(position, which='active')
1937         else:
1938             position = pb1.anchored(self.get_anchor(), pb)
1939 
1940         x_trf = self.xaxis.get_transform()
1941         y_trf = self.yaxis.get_transform()
1942         xmin, xmax = x_trf.transform(self.get_xbound())
1943         ymin, ymax = y_trf.transform(self.get_ybound())
1944         xsize = max(abs(xmax - xmin), 1e-30)
1945         ysize = max(abs(ymax - ymin), 1e-30)
1946 
1947         box_aspect = fig_aspect * (position.height / position.width)
1948         data_ratio = box_aspect / aspect
1949 
1950         y_expander = data_ratio * xsize / ysize - 1
1951         # If y_expander > 0, the dy/dx viewLim ratio needs to increase
1952         if abs(y_expander) < 0.005:
1953             return
1954 
1955         dL = self.dataLim
1956         x0, x1 = x_trf.transform(dL.intervalx)
1957         y0, y1 = y_trf.transform(dL.intervaly)
1958         xr = 1.05 * (x1 - x0)
1959         yr = 1.05 * (y1 - y0)
1960 
1961         xmarg = xsize - xr
1962         ymarg = ysize - yr
1963         Ysize = data_ratio * xsize
1964         Xsize = ysize / data_ratio
1965         Xmarg = Xsize - xr
1966         Ymarg = Ysize - yr
1967         # Setting these targets to, e.g., 0.05*xr does not seem to help.
1968         xm = 0
1969         ym = 0
1970 
1971         shared_x = self in self._shared_axes["x"]
1972         shared_y = self in self._shared_axes["y"]
1973 
1974         if shared_x and shared_y:
1975             raise RuntimeError("set_aspect(..., adjustable='datalim') or "
1976                                "axis('equal') are not allowed when both axes "
1977                                "are shared.  Try set_aspect(..., "
1978                                "adjustable='box').")
1979 
1980         # If y is shared, then we are only allowed to change x, etc.
1981         if shared_y:
1982             adjust_y = False
1983         else:
1984             if xmarg > xm and ymarg > ym:
1985                 adjy = ((Ymarg > 0 and y_expander < 0) or
1986                         (Xmarg < 0 and y_expander > 0))
1987             else:
1988                 adjy = y_expander > 0
1989             adjust_y = shared_x or adjy  # (Ymarg > xmarg)
1990 
1991         if adjust_y:
1992             yc = 0.5 * (ymin + ymax)
1993             y0 = yc - Ysize / 2.0
1994             y1 = yc + Ysize / 2.0
1995             self.set_ybound(y_trf.inverted().transform([y0, y1]))
1996         else:
1997             xc = 0.5 * (xmin + xmax)
1998             x0 = xc - Xsize / 2.0
1999             x1 = xc + Xsize / 2.0
2000             self.set_xbound(x_trf.inverted().transform([x0, x1]))
2001 
2002     def axis(self, arg=None, /, *, emit=True, **kwargs):
2003         """
2004         Convenience method to get or set some axis properties.
2005 
2006         Call signatures::
2007 
2008           xmin, xmax, ymin, ymax = axis()
2009           xmin, xmax, ymin, ymax = axis([xmin, xmax, ymin, ymax])
2010           xmin, xmax, ymin, ymax = axis(option)
2011           xmin, xmax, ymin, ymax = axis(**kwargs)
2012 
2013         Parameters
2014         ----------
2015         xmin, xmax, ymin, ymax : float, optional
2016             The axis limits to be set.  This can also be achieved using ::
2017 
2018                 ax.set(xlim=(xmin, xmax), ylim=(ymin, ymax))
2019 
2020         option : bool or str
2021             If a bool, turns axis lines and labels on or off. If a string,
2022             possible values are:
2023 
2024             ======== ==========================================================
2025             Value    Description
2026             ======== ==========================================================
2027             'on'     Turn on axis lines and labels. Same as ``True``.
2028             'off'    Turn off axis lines and labels. Same as ``False``.
2029             'equal'  Set equal scaling (i.e., make circles circular) by
2030                      changing axis limits. This is the same as
2031                      ``ax.set_aspect('equal', adjustable='datalim')``.
2032                      Explicit data limits may not be respected in this case.
2033             'scaled' Set equal scaling (i.e., make circles circular) by
2034                      changing dimensions of the plot box. This is the same as
2035                      ``ax.set_aspect('equal', adjustable='box', anchor='C')``.
2036                      Additionally, further autoscaling will be disabled.
2037             'tight'  Set limits just large enough to show all data, then
2038                      disable further autoscaling.
2039             'auto'   Automatic scaling (fill plot box with data).
2040             'image'  'scaled' with axis limits equal to data limits.
2041             'square' Square plot; similar to 'scaled', but initially forcing
2042                      ``xmax-xmin == ymax-ymin``.
2043             ======== ==========================================================
2044 
2045         emit : bool, default: True
2046             Whether observers are notified of the axis limit change.
2047             This option is passed on to `~.Axes.set_xlim` and
2048             `~.Axes.set_ylim`.
2049 
2050         Returns
2051         -------
2052         xmin, xmax, ymin, ymax : float
2053             The axis limits.
2054 
2055         See Also
2056         --------
2057         matplotlib.axes.Axes.set_xlim
2058         matplotlib.axes.Axes.set_ylim
2059         """
2060         if isinstance(arg, (str, bool)):
2061             if arg is True:
2062                 arg = 'on'
2063             if arg is False:
2064                 arg = 'off'
2065             arg = arg.lower()
2066             if arg == 'on':
2067                 self.set_axis_on()
2068             elif arg == 'off':
2069                 self.set_axis_off()
2070             elif arg in [
2071                     'equal', 'tight', 'scaled', 'auto', 'image', 'square']:
2072                 self.set_autoscale_on(True)
2073                 self.set_aspect('auto')
2074                 self.autoscale_view(tight=False)
2075                 if arg == 'equal':
2076                     self.set_aspect('equal', adjustable='datalim')
2077                 elif arg == 'scaled':
2078                     self.set_aspect('equal', adjustable='box', anchor='C')
2079                     self.set_autoscale_on(False)  # Req. by Mark Bakker
2080                 elif arg == 'tight':
2081                     self.autoscale_view(tight=True)
2082                     self.set_autoscale_on(False)
2083                 elif arg == 'image':
2084                     self.autoscale_view(tight=True)
2085                     self.set_autoscale_on(False)
2086                     self.set_aspect('equal', adjustable='box', anchor='C')
2087                 elif arg == 'square':
2088                     self.set_aspect('equal', adjustable='box', anchor='C')
2089                     self.set_autoscale_on(False)
2090                     xlim = self.get_xlim()
2091                     ylim = self.get_ylim()
2092                     edge_size = max(np.diff(xlim), np.diff(ylim))[0]
2093                     self.set_xlim([xlim[0], xlim[0] + edge_size],
2094                                   emit=emit, auto=False)
2095                     self.set_ylim([ylim[0], ylim[0] + edge_size],
2096                                   emit=emit, auto=False)
2097             else:
2098                 raise ValueError(f"Unrecognized string {arg!r} to axis; "
2099                                  "try 'on' or 'off'")
2100         else:
2101             if arg is not None:
2102                 try:
2103                     xmin, xmax, ymin, ymax = arg
2104                 except (TypeError, ValueError) as err:
2105                     raise TypeError('the first argument to axis() must be an '
2106                                     'iterable of the form '
2107                                     '[xmin, xmax, ymin, ymax]') from err
2108             else:
2109                 xmin = kwargs.pop('xmin', None)
2110                 xmax = kwargs.pop('xmax', None)
2111                 ymin = kwargs.pop('ymin', None)
2112                 ymax = kwargs.pop('ymax', None)
2113             xauto = (None  # Keep autoscale state as is.
2114                      if xmin is None and xmax is None
2115                      else False)  # Turn off autoscale.
2116             yauto = (None
2117                      if ymin is None and ymax is None
2118                      else False)
2119             self.set_xlim(xmin, xmax, emit=emit, auto=xauto)
2120             self.set_ylim(ymin, ymax, emit=emit, auto=yauto)
2121         if kwargs:
2122             raise _api.kwarg_error("axis", kwargs)
2123         return (*self.get_xlim(), *self.get_ylim())
2124 
2125     def get_legend(self):
2126         """Return the `.Legend` instance, or None if no legend is defined."""
2127         return self.legend_
2128 
2129     def get_images(self):
2130         r"""Return a list of `.AxesImage`\s contained by the Axes."""
2131         return cbook.silent_list('AxesImage', self.images)
2132 
2133     def get_lines(self):
2134         """Return a list of lines contained by the Axes."""
2135         return cbook.silent_list('Line2D', self.lines)
2136 
2137     def get_xaxis(self):
2138         """
2139         [*Discouraged*] Return the XAxis instance.
2140 
2141         .. admonition:: Discouraged
2142 
2143             The use of this function is discouraged. You should instead
2144             directly access the attribute ``ax.xaxis``.
2145         """
2146         return self.xaxis
2147 
2148     def get_yaxis(self):
2149         """
2150         [*Discouraged*] Return the YAxis instance.
2151 
2152         .. admonition:: Discouraged
2153 
2154             The use of this function is discouraged. You should instead
2155             directly access the attribute ``ax.yaxis``.
2156         """
2157         return self.yaxis
2158 
2159     get_xgridlines = _axis_method_wrapper("xaxis", "get_gridlines")
2160     get_xticklines = _axis_method_wrapper("xaxis", "get_ticklines")
2161     get_ygridlines = _axis_method_wrapper("yaxis", "get_gridlines")
2162     get_yticklines = _axis_method_wrapper("yaxis", "get_ticklines")
2163 
2164     # Adding and tracking artists
2165 
2166     def _sci(self, im):
2167         """
2168         Set the current image.
2169 
2170         This image will be the target of colormap functions like
2171         ``pyplot.viridis``, and other functions such as `~.pyplot.clim`.  The
2172         current image is an attribute of the current Axes.
2173         """
2174         _api.check_isinstance(
2175             (mpl.contour.ContourSet, mcoll.Collection, mimage.AxesImage),
2176             im=im)
2177         if isinstance(im, mpl.contour.ContourSet):
2178             if im.collections[0] not in self._children:
2179                 raise ValueError("ContourSet must be in current Axes")
2180         elif im not in self._children:
2181             raise ValueError("Argument must be an image, collection, or "
2182                              "ContourSet in this Axes")
2183         self._current_image = im
2184 
2185     def _gci(self):
2186         """Helper for `~matplotlib.pyplot.gci`; do not use elsewhere."""
2187         return self._current_image
2188 
2189     def has_data(self):
2190         """
2191         Return whether any artists have been added to the Axes.
2192 
2193         This should not be used to determine whether the *dataLim*
2194         need to be updated, and may not actually be useful for
2195         anything.
2196         """
2197         return any(isinstance(a, (mcoll.Collection, mimage.AxesImage,
2198                                   mlines.Line2D, mpatches.Patch))
2199                    for a in self._children)
2200 
2201     def add_artist(self, a):
2202         """
2203         Add an `.Artist` to the Axes; return the artist.
2204 
2205         Use `add_artist` only for artists for which there is no dedicated
2206         "add" method; and if necessary, use a method such as `update_datalim`
2207         to manually update the dataLim if the artist is to be included in
2208         autoscaling.
2209 
2210         If no ``transform`` has been specified when creating the artist (e.g.
2211         ``artist.get_transform() == None``) then the transform is set to
2212         ``ax.transData``.
2213         """
2214         a.axes = self
2215         self._children.append(a)
2216         a._remove_method = self._children.remove
2217         self._set_artist_props(a)
2218         if a.get_clip_path() is None:
2219             a.set_clip_path(self.patch)
2220         self.stale = True
2221         return a
2222 
2223     def add_child_axes(self, ax):
2224         """
2225         Add an `.AxesBase` to the Axes' children; return the child Axes.
2226 
2227         This is the lowlevel version.  See `.axes.Axes.inset_axes`.
2228         """
2229 
2230         # normally Axes have themselves as the Axes, but these need to have
2231         # their parent...
2232         # Need to bypass the getter...
2233         ax._axes = self
2234         ax.stale_callback = martist._stale_axes_callback
2235 
2236         self.child_axes.append(ax)
2237         ax._remove_method = self.child_axes.remove
2238         self.stale = True
2239         return ax
2240 
2241     def add_collection(self, collection, autolim=True):
2242         """
2243         Add a `.Collection` to the Axes; return the collection.
2244         """
2245         _api.check_isinstance(mcoll.Collection, collection=collection)
2246         label = collection.get_label()
2247         if not label:
2248             collection.set_label(f'_child{len(self._children)}')
2249         self._children.append(collection)
2250         collection._remove_method = self._children.remove
2251         self._set_artist_props(collection)
2252 
2253         if collection.get_clip_path() is None:
2254             collection.set_clip_path(self.patch)
2255 
2256         if autolim:
2257             # Make sure viewLim is not stale (mostly to match
2258             # pre-lazy-autoscale behavior, which is not really better).
2259             self._unstale_viewLim()
2260             datalim = collection.get_datalim(self.transData)
2261             points = datalim.get_points()
2262             if not np.isinf(datalim.minpos).all():
2263                 # By definition, if minpos (minimum positive value) is set
2264                 # (i.e., non-inf), then min(points) <= minpos <= max(points),
2265                 # and minpos would be superfluous. However, we add minpos to
2266                 # the call so that self.dataLim will update its own minpos.
2267                 # This ensures that log scales see the correct minimum.
2268                 points = np.concatenate([points, [datalim.minpos]])
2269             self.update_datalim(points)
2270 
2271         self.stale = True
2272         return collection
2273 
2274     def add_image(self, image):
2275         """
2276         Add an `.AxesImage` to the Axes; return the image.
2277         """
2278         _api.check_isinstance(mimage.AxesImage, image=image)
2279         self._set_artist_props(image)
2280         if not image.get_label():
2281             image.set_label(f'_child{len(self._children)}')
2282         self._children.append(image)
2283         image._remove_method = self._children.remove
2284         self.stale = True
2285         return image
2286 
2287     def _update_image_limits(self, image):
2288         xmin, xmax, ymin, ymax = image.get_extent()
2289         self.axes.update_datalim(((xmin, ymin), (xmax, ymax)))
2290 
2291     def add_line(self, line):
2292         """
2293         Add a `.Line2D` to the Axes; return the line.
2294         """
2295         _api.check_isinstance(mlines.Line2D, line=line)
2296         self._set_artist_props(line)
2297         if line.get_clip_path() is None:
2298             line.set_clip_path(self.patch)
2299 
2300         self._update_line_limits(line)
2301         if not line.get_label():
2302             line.set_label(f'_child{len(self._children)}')
2303         self._children.append(line)
2304         line._remove_method = self._children.remove
2305         self.stale = True
2306         return line
2307 
2308     def _add_text(self, txt):
2309         """
2310         Add a `.Text` to the Axes; return the text.
2311         """
2312         _api.check_isinstance(mtext.Text, txt=txt)
2313         self._set_artist_props(txt)
2314         self._children.append(txt)
2315         txt._remove_method = self._children.remove
2316         self.stale = True
2317         return txt
2318 
2319     def _update_line_limits(self, line):
2320         """
2321         Figures out the data limit of the given line, updating self.dataLim.
2322         """
2323         path = line.get_path()
2324         if path.vertices.size == 0:
2325             return
2326 
2327         line_trf = line.get_transform()
2328 
2329         if line_trf == self.transData:
2330             data_path = path
2331         elif any(line_trf.contains_branch_seperately(self.transData)):
2332             # Compute the transform from line coordinates to data coordinates.
2333             trf_to_data = line_trf - self.transData
2334             # If transData is affine we can use the cached non-affine component
2335             # of line's path (since the non-affine part of line_trf is
2336             # entirely encapsulated in trf_to_data).
2337             if self.transData.is_affine:
2338                 line_trans_path = line._get_transformed_path()
2339                 na_path, _ = line_trans_path.get_transformed_path_and_affine()
2340                 data_path = trf_to_data.transform_path_affine(na_path)
2341             else:
2342                 data_path = trf_to_data.transform_path(path)
2343         else:
2344             # For backwards compatibility we update the dataLim with the
2345             # coordinate range of the given path, even though the coordinate
2346             # systems are completely different. This may occur in situations
2347             # such as when ax.transAxes is passed through for absolute
2348             # positioning.
2349             data_path = path
2350 
2351         if not data_path.vertices.size:
2352             return
2353 
2354         updatex, updatey = line_trf.contains_branch_seperately(self.transData)
2355         if self.name != "rectilinear":
2356             # This block is mostly intended to handle axvline in polar plots,
2357             # for which updatey would otherwise be True.
2358             if updatex and line_trf == self.get_yaxis_transform():
2359                 updatex = False
2360             if updatey and line_trf == self.get_xaxis_transform():
2361                 updatey = False
2362         self.dataLim.update_from_path(data_path,
2363                                       self.ignore_existing_data_limits,
2364                                       updatex=updatex, updatey=updatey)
2365         self.ignore_existing_data_limits = False
2366 
2367     def add_patch(self, p):
2368         """
2369         Add a `.Patch` to the Axes; return the patch.
2370         """
2371         _api.check_isinstance(mpatches.Patch, p=p)
2372         self._set_artist_props(p)
2373         if p.get_clip_path() is None:
2374             p.set_clip_path(self.patch)
2375         self._update_patch_limits(p)
2376         self._children.append(p)
2377         p._remove_method = self._children.remove
2378         return p
2379 
2380     def _update_patch_limits(self, patch):
2381         """Update the data limits for the given patch."""
2382         # hist can add zero height Rectangles, which is useful to keep
2383         # the bins, counts and patches lined up, but it throws off log
2384         # scaling.  We'll ignore rects with zero height or width in
2385         # the auto-scaling
2386 
2387         # cannot check for '==0' since unitized data may not compare to zero
2388         # issue #2150 - we update the limits if patch has non zero width
2389         # or height.
2390         if (isinstance(patch, mpatches.Rectangle) and
2391                 ((not patch.get_width()) and (not patch.get_height()))):
2392             return
2393         p = patch.get_path()
2394         # Get all vertices on the path
2395         # Loop through each segment to get extrema for Bezier curve sections
2396         vertices = []
2397         for curve, code in p.iter_bezier(simplify=False):
2398             # Get distance along the curve of any extrema
2399             _, dzeros = curve.axis_aligned_extrema()
2400             # Calculate vertices of start, end and any extrema in between
2401             vertices.append(curve([0, *dzeros, 1]))
2402 
2403         if len(vertices):
2404             vertices = np.row_stack(vertices)
2405 
2406         patch_trf = patch.get_transform()
2407         updatex, updatey = patch_trf.contains_branch_seperately(self.transData)
2408         if not (updatex or updatey):
2409             return
2410         if self.name != "rectilinear":
2411             # As in _update_line_limits, but for axvspan.
2412             if updatex and patch_trf == self.get_yaxis_transform():
2413                 updatex = False
2414             if updatey and patch_trf == self.get_xaxis_transform():
2415                 updatey = False
2416         trf_to_data = patch_trf - self.transData
2417         xys = trf_to_data.transform(vertices)
2418         self.update_datalim(xys, updatex=updatex, updatey=updatey)
2419 
2420     def add_table(self, tab):
2421         """
2422         Add a `.Table` to the Axes; return the table.
2423         """
2424         _api.check_isinstance(mtable.Table, tab=tab)
2425         self._set_artist_props(tab)
2426         self._children.append(tab)
2427         if tab.get_clip_path() is None:
2428             tab.set_clip_path(self.patch)
2429         tab._remove_method = self._children.remove
2430         return tab
2431 
2432     def add_container(self, container):
2433         """
2434         Add a `.Container` to the Axes' containers; return the container.
2435         """
2436         label = container.get_label()
2437         if not label:
2438             container.set_label('_container%d' % len(self.containers))
2439         self.containers.append(container)
2440         container._remove_method = self.containers.remove
2441         return container
2442 
2443     def _unit_change_handler(self, axis_name, event=None):
2444         """
2445         Process axis units changes: requests updates to data and view limits.
2446         """
2447         if event is None:  # Allow connecting `self._unit_change_handler(name)`
2448             return functools.partial(
2449                 self._unit_change_handler, axis_name, event=object())
2450         _api.check_in_list(self._axis_map, axis_name=axis_name)
2451         for line in self.lines:
2452             line.recache_always()
2453         self.relim()
2454         self._request_autoscale_view(axis_name)
2455 
2456     def relim(self, visible_only=False):
2457         """
2458         Recompute the data limits based on current artists.
2459 
2460         At present, `.Collection` instances are not supported.
2461 
2462         Parameters
2463         ----------
2464         visible_only : bool, default: False
2465             Whether to exclude invisible artists.
2466         """
2467         # Collections are deliberately not supported (yet); see
2468         # the TODO note in artists.py.
2469         self.dataLim.ignore(True)
2470         self.dataLim.set_points(mtransforms.Bbox.null().get_points())
2471         self.ignore_existing_data_limits = True
2472 
2473         for artist in self._children:
2474             if not visible_only or artist.get_visible():
2475                 if isinstance(artist, mlines.Line2D):
2476                     self._update_line_limits(artist)
2477                 elif isinstance(artist, mpatches.Patch):
2478                     self._update_patch_limits(artist)
2479                 elif isinstance(artist, mimage.AxesImage):
2480                     self._update_image_limits(artist)
2481 
2482     def update_datalim(self, xys, updatex=True, updatey=True):
2483         """
2484         Extend the `~.Axes.dataLim` Bbox to include the given points.
2485 
2486         If no data is set currently, the Bbox will ignore its limits and set
2487         the bound to be the bounds of the xydata (*xys*). Otherwise, it will
2488         compute the bounds of the union of its current data and the data in
2489         *xys*.
2490 
2491         Parameters
2492         ----------
2493         xys : 2D array-like
2494             The points to include in the data limits Bbox. This can be either
2495             a list of (x, y) tuples or a (N, 2) array.
2496 
2497         updatex, updatey : bool, default: True
2498             Whether to update the x/y limits.
2499         """
2500         xys = np.asarray(xys)
2501         if not np.any(np.isfinite(xys)):
2502             return
2503         self.dataLim.update_from_data_xy(xys, self.ignore_existing_data_limits,
2504                                          updatex=updatex, updatey=updatey)
2505         self.ignore_existing_data_limits = False
2506 
2507     def _process_unit_info(self, datasets=None, kwargs=None, *, convert=True):
2508         """
2509         Set axis units based on *datasets* and *kwargs*, and optionally apply
2510         unit conversions to *datasets*.
2511 
2512         Parameters
2513         ----------
2514         datasets : list
2515             List of (axis_name, dataset) pairs (where the axis name is defined
2516             as in `._axis_map`).  Individual datasets can also be None
2517             (which gets passed through).
2518         kwargs : dict
2519             Other parameters from which unit info (i.e., the *xunits*,
2520             *yunits*, *zunits* (for 3D Axes), *runits* and *thetaunits* (for
2521             polar) entries) is popped, if present.  Note that this dict is
2522             mutated in-place!
2523         convert : bool, default: True
2524             Whether to return the original datasets or the converted ones.
2525 
2526         Returns
2527         -------
2528         list
2529             Either the original datasets if *convert* is False, or the
2530             converted ones if *convert* is True (the default).
2531         """
2532         # The API makes datasets a list of pairs rather than an axis_name to
2533         # dataset mapping because it is sometimes necessary to process multiple
2534         # datasets for a single axis, and concatenating them may be tricky
2535         # (e.g. if some are scalars, etc.).
2536         datasets = datasets or []
2537         kwargs = kwargs or {}
2538         axis_map = self._axis_map
2539         for axis_name, data in datasets:
2540             try:
2541                 axis = axis_map[axis_name]
2542             except KeyError:
2543                 raise ValueError(f"Invalid axis name: {axis_name!r}") from None
2544             # Update from data if axis is already set but no unit is set yet.
2545             if axis is not None and data is not None and not axis.have_units():
2546                 axis.update_units(data)
2547         for axis_name, axis in axis_map.items():
2548             # Return if no axis is set.
2549             if axis is None:
2550                 continue
2551             # Check for units in the kwargs, and if present update axis.
2552             units = kwargs.pop(f"{axis_name}units", axis.units)
2553             if self.name == "polar":
2554                 # Special case: polar supports "thetaunits"/"runits".
2555                 polar_units = {"x": "thetaunits", "y": "runits"}
2556                 units = kwargs.pop(polar_units[axis_name], units)
2557             if units != axis.units and units is not None:
2558                 axis.set_units(units)
2559                 # If the units being set imply a different converter,
2560                 # we need to update again.
2561                 for dataset_axis_name, data in datasets:
2562                     if dataset_axis_name == axis_name and data is not None:
2563                         axis.update_units(data)
2564         return [axis_map[axis_name].convert_units(data)
2565                 if convert and data is not None else data
2566                 for axis_name, data in datasets]
2567 
2568     def in_axes(self, mouseevent):
2569         """
2570         Return whether the given event (in display coords) is in the Axes.
2571         """
2572         return self.patch.contains(mouseevent)[0]
2573 
2574     get_autoscalex_on = _axis_method_wrapper("xaxis", "_get_autoscale_on")
2575     get_autoscaley_on = _axis_method_wrapper("yaxis", "_get_autoscale_on")
2576     set_autoscalex_on = _axis_method_wrapper("xaxis", "_set_autoscale_on")
2577     set_autoscaley_on = _axis_method_wrapper("yaxis", "_set_autoscale_on")
2578 
2579     def get_autoscale_on(self):
2580         """Return True if each axis is autoscaled, False otherwise."""
2581         return all(axis._get_autoscale_on()
2582                    for axis in self._axis_map.values())
2583 
2584     def set_autoscale_on(self, b):
2585         """
2586         Set whether autoscaling is applied to each axis on the next draw or
2587         call to `.Axes.autoscale_view`.
2588 
2589         Parameters
2590         ----------
2591         b : bool
2592         """
2593         for axis in self._axis_map.values():
2594             axis._set_autoscale_on(b)
2595 
2596     @property
2597     def use_sticky_edges(self):
2598         """
2599         When autoscaling, whether to obey all `Artist.sticky_edges`.
2600 
2601         Default is ``True``.
2602 
2603         Setting this to ``False`` ensures that the specified margins
2604         will be applied, even if the plot includes an image, for
2605         example, which would otherwise force a view limit to coincide
2606         with its data limit.
2607 
2608         The changing this property does not change the plot until
2609         `autoscale` or `autoscale_view` is called.
2610         """
2611         return self._use_sticky_edges
2612 
2613     @use_sticky_edges.setter
2614     def use_sticky_edges(self, b):
2615         self._use_sticky_edges = bool(b)
2616         # No effect until next autoscaling, which will mark the Axes as stale.
2617 
2618     def set_xmargin(self, m):
2619         """
2620         Set padding of X data limits prior to autoscaling.
2621 
2622         *m* times the data interval will be added to each end of that interval
2623         before it is used in autoscaling.  If *m* is negative, this will clip
2624         the data range instead of expanding it.
2625 
2626         For example, if your data is in the range [0, 2], a margin of 0.1 will
2627         result in a range [-0.2, 2.2]; a margin of -0.1 will result in a range
2628         of [0.2, 1.8].
2629 
2630         Parameters
2631         ----------
2632         m : float greater than -0.5
2633         """
2634         if m <= -0.5:
2635             raise ValueError("margin must be greater than -0.5")
2636         self._xmargin = m
2637         self._request_autoscale_view("x")
2638         self.stale = True
2639 
2640     def set_ymargin(self, m):
2641         """
2642         Set padding of Y data limits prior to autoscaling.
2643 
2644         *m* times the data interval will be added to each end of that interval
2645         before it is used in autoscaling.  If *m* is negative, this will clip
2646         the data range instead of expanding it.
2647 
2648         For example, if your data is in the range [0, 2], a margin of 0.1 will
2649         result in a range [-0.2, 2.2]; a margin of -0.1 will result in a range
2650         of [0.2, 1.8].
2651 
2652         Parameters
2653         ----------
2654         m : float greater than -0.5
2655         """
2656         if m <= -0.5:
2657             raise ValueError("margin must be greater than -0.5")
2658         self._ymargin = m
2659         self._request_autoscale_view("y")
2660         self.stale = True
2661 
2662     def margins(self, *margins, x=None, y=None, tight=True):
2663         """
2664         Set or retrieve autoscaling margins.
2665 
2666         The padding added to each limit of the Axes is the *margin*
2667         times the data interval. All input parameters must be floats
2668         within the range [0, 1]. Passing both positional and keyword
2669         arguments is invalid and will raise a TypeError. If no
2670         arguments (positional or otherwise) are provided, the current
2671         margins will remain in place and simply be returned.
2672 
2673         Specifying any margin changes only the autoscaling; for example,
2674         if *xmargin* is not None, then *xmargin* times the X data
2675         interval will be added to each end of that interval before
2676         it is used in autoscaling.
2677 
2678         Parameters
2679         ----------
2680         *margins : float, optional
2681             If a single positional argument is provided, it specifies
2682             both margins of the x-axis and y-axis limits. If two
2683             positional arguments are provided, they will be interpreted
2684             as *xmargin*, *ymargin*. If setting the margin on a single
2685             axis is desired, use the keyword arguments described below.
2686 
2687         x, y : float, optional
2688             Specific margin values for the x-axis and y-axis,
2689             respectively. These cannot be used with positional
2690             arguments, but can be used individually to alter on e.g.,
2691             only the y-axis.
2692 
2693         tight : bool or None, default: True
2694             The *tight* parameter is passed to `~.axes.Axes.autoscale_view`,
2695             which is executed after a margin is changed; the default
2696             here is *True*, on the assumption that when margins are
2697             specified, no additional padding to match tick marks is
2698             usually desired.  Setting *tight* to *None* preserves
2699             the previous setting.
2700 
2701         Returns
2702         -------
2703         xmargin, ymargin : float
2704 
2705         Notes
2706         -----
2707         If a previously used Axes method such as :meth:`pcolor` has set
2708         :attr:`use_sticky_edges` to `True`, only the limits not set by
2709         the "sticky artists" will be modified. To force all of the
2710         margins to be set, set :attr:`use_sticky_edges` to `False`
2711         before calling :meth:`margins`.
2712         """
2713 
2714         if margins and (x is not None or y is not None):
2715             raise TypeError('Cannot pass both positional and keyword '
2716                             'arguments for x and/or y.')
2717         elif len(margins) == 1:
2718             x = y = margins[0]
2719         elif len(margins) == 2:
2720             x, y = margins
2721         elif margins:
2722             raise TypeError('Must pass a single positional argument for all '
2723                             'margins, or one for each margin (x, y).')
2724 
2725         if x is None and y is None:
2726             if tight is not True:
2727                 _api.warn_external(f'ignoring tight={tight!r} in get mode')
2728             return self._xmargin, self._ymargin
2729 
2730         if tight is not None:
2731             self._tight = tight
2732         if x is not None:
2733             self.set_xmargin(x)
2734         if y is not None:
2735             self.set_ymargin(y)
2736 
2737     def set_rasterization_zorder(self, z):
2738         """
2739         Set the zorder threshold for rasterization for vector graphics output.
2740 
2741         All artists with a zorder below the given value will be rasterized if
2742         they support rasterization.
2743 
2744         This setting is ignored for pixel-based output.
2745 
2746         See also :doc:`/gallery/misc/rasterization_demo`.
2747 
2748         Parameters
2749         ----------
2750         z : float or None
2751             The zorder below which artists are rasterized.
2752             If ``None`` rasterization based on zorder is deactivated.
2753         """
2754         self._rasterization_zorder = z
2755         self.stale = True
2756 
2757     def get_rasterization_zorder(self):
2758         """Return the zorder value below which artists will be rasterized."""
2759         return self._rasterization_zorder
2760 
2761     def autoscale(self, enable=True, axis='both', tight=None):
2762         """
2763         Autoscale the axis view to the data (toggle).
2764 
2765         Convenience method for simple axis view autoscaling.
2766         It turns autoscaling on or off, and then,
2767         if autoscaling for either axis is on, it performs
2768         the autoscaling on the specified axis or Axes.
2769 
2770         Parameters
2771         ----------
2772         enable : bool or None, default: True
2773             True turns autoscaling on, False turns it off.
2774             None leaves the autoscaling state unchanged.
2775         axis : {'both', 'x', 'y'}, default: 'both'
2776             The axis on which to operate.  (For 3D Axes, *axis* can also be set
2777             to 'z', and 'both' refers to all three axes.)
2778         tight : bool or None, default: None
2779             If True, first set the margins to zero.  Then, this argument is
2780             forwarded to `~.axes.Axes.autoscale_view` (regardless of
2781             its value); see the description of its behavior there.
2782         """
2783         if enable is None:
2784             scalex = True
2785             scaley = True
2786         else:
2787             if axis in ['x', 'both']:
2788                 self.set_autoscalex_on(bool(enable))
2789                 scalex = self.get_autoscalex_on()
2790             else:
2791                 scalex = False
2792             if axis in ['y', 'both']:
2793                 self.set_autoscaley_on(bool(enable))
2794                 scaley = self.get_autoscaley_on()
2795             else:
2796                 scaley = False
2797         if tight and scalex:
2798             self._xmargin = 0
2799         if tight and scaley:
2800             self._ymargin = 0
2801         if scalex:
2802             self._request_autoscale_view("x", tight=tight)
2803         if scaley:
2804             self._request_autoscale_view("y", tight=tight)
2805 
2806     def autoscale_view(self, tight=None, scalex=True, scaley=True):
2807         """
2808         Autoscale the view limits using the data limits.
2809 
2810         Parameters
2811         ----------
2812         tight : bool or None
2813             If *True*, only expand the axis limits using the margins.  Note
2814             that unlike for `autoscale`, ``tight=True`` does *not* set the
2815             margins to zero.
2816 
2817             If *False* and :rc:`axes.autolimit_mode` is 'round_numbers', then
2818             after expansion by the margins, further expand the axis limits
2819             using the axis major locator.
2820 
2821             If None (the default), reuse the value set in the previous call to
2822             `autoscale_view` (the initial value is False, but the default style
2823             sets :rc:`axes.autolimit_mode` to 'data', in which case this
2824             behaves like True).
2825 
2826         scalex : bool, default: True
2827             Whether to autoscale the x-axis.
2828 
2829         scaley : bool, default: True
2830             Whether to autoscale the y-axis.
2831 
2832         Notes
2833         -----
2834         The autoscaling preserves any preexisting axis direction reversal.
2835 
2836         The data limits are not updated automatically when artist data are
2837         changed after the artist has been added to an Axes instance.  In that
2838         case, use :meth:`matplotlib.axes.Axes.relim` prior to calling
2839         autoscale_view.
2840 
2841         If the views of the Axes are fixed, e.g. via `set_xlim`, they will
2842         not be changed by autoscale_view().
2843         See :meth:`matplotlib.axes.Axes.autoscale` for an alternative.
2844         """
2845         if tight is not None:
2846             self._tight = bool(tight)
2847 
2848         x_stickies = y_stickies = np.array([])
2849         if self.use_sticky_edges:
2850             if self._xmargin and scalex and self.get_autoscalex_on():
2851                 x_stickies = np.sort(np.concatenate([
2852                     artist.sticky_edges.x
2853                     for ax in self._shared_axes["x"].get_siblings(self)
2854                     for artist in ax.get_children()]))
2855             if self._ymargin and scaley and self.get_autoscaley_on():
2856                 y_stickies = np.sort(np.concatenate([
2857                     artist.sticky_edges.y
2858                     for ax in self._shared_axes["y"].get_siblings(self)
2859                     for artist in ax.get_children()]))
2860         if self.get_xscale() == 'log':
2861             x_stickies = x_stickies[x_stickies > 0]
2862         if self.get_yscale() == 'log':
2863             y_stickies = y_stickies[y_stickies > 0]
2864 
2865         def handle_single_axis(
2866                 scale, shared_axes, name, axis, margin, stickies, set_bound):
2867 
2868             if not (scale and axis._get_autoscale_on()):
2869                 return  # nothing to do...
2870 
2871             shared = shared_axes.get_siblings(self)
2872             # Base autoscaling on finite data limits when there is at least one
2873             # finite data limit among all the shared_axes and intervals.
2874             values = [val for ax in shared
2875                       for val in getattr(ax.dataLim, f"interval{name}")
2876                       if np.isfinite(val)]
2877             if values:
2878                 x0, x1 = (min(values), max(values))
2879             elif getattr(self._viewLim, f"mutated{name}")():
2880                 # No data, but explicit viewLims already set:
2881                 # in mutatedx or mutatedy.
2882                 return
2883             else:
2884                 x0, x1 = (-np.inf, np.inf)
2885             # If x0 and x1 are nonfinite, get default limits from the locator.
2886             locator = axis.get_major_locator()
2887             x0, x1 = locator.nonsingular(x0, x1)
2888             # Find the minimum minpos for use in the margin calculation.
2889             minimum_minpos = min(
2890                 getattr(ax.dataLim, f"minpos{name}") for ax in shared)
2891 
2892             # Prevent margin addition from crossing a sticky value.  A small
2893             # tolerance must be added due to floating point issues with
2894             # streamplot; it is defined relative to x0, x1, x1-x0 but has
2895             # no absolute term (e.g. "+1e-8") to avoid issues when working with
2896             # datasets where all values are tiny (less than 1e-8).
2897             tol = 1e-5 * max(abs(x0), abs(x1), abs(x1 - x0))
2898             # Index of largest element < x0 + tol, if any.
2899             i0 = stickies.searchsorted(x0 + tol) - 1
2900             x0bound = stickies[i0] if i0 != -1 else None
2901             # Index of smallest element > x1 - tol, if any.
2902             i1 = stickies.searchsorted(x1 - tol)
2903             x1bound = stickies[i1] if i1 != len(stickies) else None
2904 
2905             # Add the margin in figure space and then transform back, to handle
2906             # non-linear scales.
2907             transform = axis.get_transform()
2908             inverse_trans = transform.inverted()
2909             x0, x1 = axis._scale.limit_range_for_scale(x0, x1, minimum_minpos)
2910             x0t, x1t = transform.transform([x0, x1])
2911             delta = (x1t - x0t) * margin
2912             if not np.isfinite(delta):
2913                 delta = 0  # If a bound isn't finite, set margin to zero.
2914             x0, x1 = inverse_trans.transform([x0t - delta, x1t + delta])
2915 
2916             # Apply sticky bounds.
2917             if x0bound is not None:
2918                 x0 = max(x0, x0bound)
2919             if x1bound is not None:
2920                 x1 = min(x1, x1bound)
2921 
2922             if not self._tight:
2923                 x0, x1 = locator.view_limits(x0, x1)
2924             set_bound(x0, x1)
2925             # End of definition of internal function 'handle_single_axis'.
2926 
2927         handle_single_axis(
2928             scalex, self._shared_axes["x"], 'x', self.xaxis, self._xmargin,
2929             x_stickies, self.set_xbound)
2930         handle_single_axis(
2931             scaley, self._shared_axes["y"], 'y', self.yaxis, self._ymargin,
2932             y_stickies, self.set_ybound)
2933 
2934     def _update_title_position(self, renderer):
2935         """
2936         Update the title position based on the bounding box enclosing
2937         all the ticklabels and x-axis spine and xlabel...
2938         """
2939         if self._autotitlepos is not None and not self._autotitlepos:
2940             _log.debug('title position was updated manually, not adjusting')
2941             return
2942 
2943         titles = (self.title, self._left_title, self._right_title)
2944 
2945         # Need to check all our twins too, and all the children as well.
2946         axs = self._twinned_axes.get_siblings(self) + self.child_axes
2947         for ax in self.child_axes:  # Child positions must be updated first.
2948             locator = ax.get_axes_locator()
2949             ax.apply_aspect(locator(self, renderer) if locator else None)
2950 
2951         for title in titles:
2952             x, _ = title.get_position()
2953             # need to start again in case of window resizing
2954             title.set_position((x, 1.0))
2955             top = -np.inf
2956             for ax in axs:
2957                 bb = None
2958                 if (ax.xaxis.get_ticks_position() in ['top', 'unknown']
2959                         or ax.xaxis.get_label_position() == 'top'):
2960                     bb = ax.xaxis.get_tightbbox(renderer)
2961                 if bb is None:
2962                     if 'outline' in ax.spines:
2963                         # Special case for colorbars:
2964                         bb = ax.spines['outline'].get_window_extent()
2965                     else:
2966                         bb = ax.get_window_extent(renderer)
2967                 top = max(top, bb.ymax)
2968                 if title.get_text():
2969                     ax.yaxis.get_tightbbox(renderer)  # update offsetText
2970                     if ax.yaxis.offsetText.get_text():
2971                         bb = ax.yaxis.offsetText.get_tightbbox(renderer)
2972                         if bb.intersection(title.get_tightbbox(renderer), bb):
2973                             top = bb.ymax
2974             if top < 0:
2975                 # the top of Axes is not even on the figure, so don't try and
2976                 # automatically place it.
2977                 _log.debug('top of Axes not in the figure, so title not moved')
2978                 return
2979             if title.get_window_extent(renderer).ymin < top:
2980                 _, y = self.transAxes.inverted().transform((0, top))
2981                 title.set_position((x, y))
2982                 # empirically, this doesn't always get the min to top,
2983                 # so we need to adjust again.
2984                 if title.get_window_extent(renderer).ymin < top:
2985                     _, y = self.transAxes.inverted().transform(
2986                         (0., 2 * top - title.get_window_extent(renderer).ymin))
2987                     title.set_position((x, y))
2988 
2989         ymax = max(title.get_position()[1] for title in titles)
2990         for title in titles:
2991             # now line up all the titles at the highest baseline.
2992             x, _ = title.get_position()
2993             title.set_position((x, ymax))
2994 
2995     # Drawing
2996     @martist.allow_rasterization
2997     def draw(self, renderer):
2998         # docstring inherited
2999         if renderer is None:
3000             raise RuntimeError('No renderer defined')
3001         if not self.get_visible():
3002             return
3003         self._unstale_viewLim()
3004 
3005         renderer.open_group('axes', gid=self.get_gid())
3006 
3007         # prevent triggering call backs during the draw process
3008         self._stale = True
3009 
3010         # loop over self and child Axes...
3011         locator = self.get_axes_locator()
3012         self.apply_aspect(locator(self, renderer) if locator else None)
3013 
3014         artists = self.get_children()
3015         artists.remove(self.patch)
3016 
3017         # the frame draws the edges around the Axes patch -- we
3018         # decouple these so the patch can be in the background and the
3019         # frame in the foreground. Do this before drawing the axis
3020         # objects so that the spine has the opportunity to update them.
3021         if not (self.axison and self._frameon):
3022             for spine in self.spines.values():
3023                 artists.remove(spine)
3024 
3025         self._update_title_position(renderer)
3026 
3027         if not self.axison:
3028             for _axis in self._axis_map.values():
3029                 artists.remove(_axis)
3030 
3031         if not self.figure.canvas.is_saving():
3032             artists = [
3033                 a for a in artists
3034                 if not a.get_animated() or isinstance(a, mimage.AxesImage)]
3035         artists = sorted(artists, key=attrgetter('zorder'))
3036 
3037         # rasterize artists with negative zorder
3038         # if the minimum zorder is negative, start rasterization
3039         rasterization_zorder = self._rasterization_zorder
3040 
3041         if (rasterization_zorder is not None and
3042                 artists and artists[0].zorder < rasterization_zorder):
3043             split_index = np.searchsorted(
3044                 [art.zorder for art in artists],
3045                 rasterization_zorder, side='right'
3046             )
3047             artists_rasterized = artists[:split_index]
3048             artists = artists[split_index:]
3049         else:
3050             artists_rasterized = []
3051 
3052         if self.axison and self._frameon:
3053             if artists_rasterized:
3054                 artists_rasterized = [self.patch] + artists_rasterized
3055             else:
3056                 artists = [self.patch] + artists
3057 
3058         if artists_rasterized:
3059             _draw_rasterized(self.figure, artists_rasterized, renderer)
3060 
3061         mimage._draw_list_compositing_images(
3062             renderer, self, artists, self.figure.suppressComposite)
3063 
3064         renderer.close_group('axes')
3065         self.stale = False
3066 
3067     def draw_artist(self, a):
3068         """
3069         Efficiently redraw a single artist.
3070         """
3071         a.draw(self.figure.canvas.get_renderer())
3072 
3073     def redraw_in_frame(self):
3074         """
3075         Efficiently redraw Axes data, but not axis ticks, labels, etc.
3076         """
3077         with ExitStack() as stack:
3078             for artist in [*self._axis_map.values(),
3079                            self.title, self._left_title, self._right_title]:
3080                 stack.enter_context(artist._cm_set(visible=False))
3081             self.draw(self.figure.canvas.get_renderer())
3082 
3083     # Axes rectangle characteristics
3084 
3085     def get_frame_on(self):
3086         """Get whether the Axes rectangle patch is drawn."""
3087         return self._frameon
3088 
3089     def set_frame_on(self, b):
3090         """
3091         Set whether the Axes rectangle patch is drawn.
3092 
3093         Parameters
3094         ----------
3095         b : bool
3096         """
3097         self._frameon = b
3098         self.stale = True
3099 
3100     def get_axisbelow(self):
3101         """
3102         Get whether axis ticks and gridlines are above or below most artists.
3103 
3104         Returns
3105         -------
3106         bool or 'line'
3107 
3108         See Also
3109         --------
3110         set_axisbelow
3111         """
3112         return self._axisbelow
3113 
3114     def set_axisbelow(self, b):
3115         """
3116         Set whether axis ticks and gridlines are above or below most artists.
3117 
3118         This controls the zorder of the ticks and gridlines. For more
3119         information on the zorder see :doc:`/gallery/misc/zorder_demo`.
3120 
3121         Parameters
3122         ----------
3123         b : bool or 'line'
3124             Possible values:
3125 
3126             - *True* (zorder = 0.5): Ticks and gridlines are below all Artists.
3127             - 'line' (zorder = 1.5): Ticks and gridlines are above patches
3128               (e.g. rectangles, with default zorder = 1) but still below lines
3129               and markers (with their default zorder = 2).
3130             - *False* (zorder = 2.5): Ticks and gridlines are above patches
3131               and lines / markers.
3132 
3133         See Also
3134         --------
3135         get_axisbelow
3136         """
3137         # Check that b is True, False or 'line'
3138         self._axisbelow = axisbelow = validate_axisbelow(b)
3139         zorder = {
3140             True: 0.5,
3141             'line': 1.5,
3142             False: 2.5,
3143         }[axisbelow]
3144         for axis in self._axis_map.values():
3145             axis.set_zorder(zorder)
3146         self.stale = True
3147 
3148     @_docstring.dedent_interpd
3149     def grid(self, visible=None, which='major', axis='both', **kwargs):
3150         """
3151         Configure the grid lines.
3152 
3153         Parameters
3154         ----------
3155         visible : bool or None, optional
3156             Whether to show the grid lines.  If any *kwargs* are supplied, it
3157             is assumed you want the grid on and *visible* will be set to True.
3158 
3159             If *visible* is *None* and there are no *kwargs*, this toggles the
3160             visibility of the lines.
3161 
3162         which : {'major', 'minor', 'both'}, optional
3163             The grid lines to apply the changes on.
3164 
3165         axis : {'both', 'x', 'y'}, optional
3166             The axis to apply the changes on.
3167 
3168         **kwargs : `.Line2D` properties
3169             Define the line properties of the grid, e.g.::
3170 
3171                 grid(color='r', linestyle='-', linewidth=2)
3172 
3173             Valid keyword arguments are:
3174 
3175             %(Line2D:kwdoc)s
3176 
3177         Notes
3178         -----
3179         The axis is drawn as a unit, so the effective zorder for drawing the
3180         grid is determined by the zorder of each axis, not by the zorder of the
3181         `.Line2D` objects comprising the grid.  Therefore, to set grid zorder,
3182         use `.set_axisbelow` or, for more control, call the
3183         `~.Artist.set_zorder` method of each axis.
3184         """
3185         _api.check_in_list(['x', 'y', 'both'], axis=axis)
3186         if axis in ['x', 'both']:
3187             self.xaxis.grid(visible, which=which, **kwargs)
3188         if axis in ['y', 'both']:
3189             self.yaxis.grid(visible, which=which, **kwargs)
3190 
3191     def ticklabel_format(self, *, axis='both', style='', scilimits=None,
3192                          useOffset=None, useLocale=None, useMathText=None):
3193         r"""
3194         Configure the `.ScalarFormatter` used by default for linear Axes.
3195 
3196         If a parameter is not set, the corresponding property of the formatter
3197         is left unchanged.
3198 
3199         Parameters
3200         ----------
3201         axis : {'x', 'y', 'both'}, default: 'both'
3202             The axis to configure.  Only major ticks are affected.
3203 
3204         style : {'sci', 'scientific', 'plain'}
3205             Whether to use scientific notation.
3206             The formatter default is to use scientific notation.
3207 
3208         scilimits : pair of ints (m, n)
3209             Scientific notation is used only for numbers outside the range
3210             10\ :sup:`m` to 10\ :sup:`n` (and only if the formatter is
3211             configured to use scientific notation at all).  Use (0, 0) to
3212             include all numbers.  Use (m, m) where m != 0 to fix the order of
3213             magnitude to 10\ :sup:`m`.
3214             The formatter default is :rc:`axes.formatter.limits`.
3215 
3216         useOffset : bool or float
3217             If True, the offset is calculated as needed.
3218             If False, no offset is used.
3219             If a numeric value, it sets the offset.
3220             The formatter default is :rc:`axes.formatter.useoffset`.
3221 
3222         useLocale : bool
3223             Whether to format the number using the current locale or using the
3224             C (English) locale.  This affects e.g. the decimal separator.  The
3225             formatter default is :rc:`axes.formatter.use_locale`.
3226 
3227         useMathText : bool
3228             Render the offset and scientific notation in mathtext.
3229             The formatter default is :rc:`axes.formatter.use_mathtext`.
3230 
3231         Raises
3232         ------
3233         AttributeError
3234             If the current formatter is not a `.ScalarFormatter`.
3235         """
3236         style = style.lower()
3237         axis = axis.lower()
3238         if scilimits is not None:
3239             try:
3240                 m, n = scilimits
3241                 m + n + 1  # check that both are numbers
3242             except (ValueError, TypeError) as err:
3243                 raise ValueError("scilimits must be a sequence of 2 integers"
3244                                  ) from err
3245         STYLES = {'sci': True, 'scientific': True, 'plain': False, '': None}
3246         is_sci_style = _api.check_getitem(STYLES, style=style)
3247         axis_map = {**{k: [v] for k, v in self._axis_map.items()},
3248                     'both': list(self._axis_map.values())}
3249         axises = _api.check_getitem(axis_map, axis=axis)
3250         try:
3251             for axis in axises:
3252                 if is_sci_style is not None:
3253                     axis.major.formatter.set_scientific(is_sci_style)
3254                 if scilimits is not None:
3255                     axis.major.formatter.set_powerlimits(scilimits)
3256                 if useOffset is not None:
3257                     axis.major.formatter.set_useOffset(useOffset)
3258                 if useLocale is not None:
3259                     axis.major.formatter.set_useLocale(useLocale)
3260                 if useMathText is not None:
3261                     axis.major.formatter.set_useMathText(useMathText)
3262         except AttributeError as err:
3263             raise AttributeError(
3264                 "This method only works with the ScalarFormatter") from err
3265 
3266     def locator_params(self, axis='both', tight=None, **kwargs):
3267         """
3268         Control behavior of major tick locators.
3269 
3270         Because the locator is involved in autoscaling, `~.Axes.autoscale_view`
3271         is called automatically after the parameters are changed.
3272 
3273         Parameters
3274         ----------
3275         axis : {'both', 'x', 'y'}, default: 'both'
3276             The axis on which to operate.  (For 3D Axes, *axis* can also be
3277             set to 'z', and 'both' refers to all three axes.)
3278         tight : bool or None, optional
3279             Parameter passed to `~.Axes.autoscale_view`.
3280             Default is None, for no change.
3281 
3282         Other Parameters
3283         ----------------
3284         **kwargs
3285             Remaining keyword arguments are passed to directly to the
3286             ``set_params()`` method of the locator. Supported keywords depend
3287             on the type of the locator. See for example
3288             `~.ticker.MaxNLocator.set_params` for the `.ticker.MaxNLocator`
3289             used by default for linear.
3290 
3291         Examples
3292         --------
3293         When plotting small subplots, one might want to reduce the maximum
3294         number of ticks and use tight bounds, for example::
3295 
3296             ax.locator_params(tight=True, nbins=4)
3297 
3298         """
3299         _api.check_in_list([*self._axis_names, "both"], axis=axis)
3300         for name in self._axis_names:
3301             if axis in [name, "both"]:
3302                 loc = self._axis_map[name].get_major_locator()
3303                 loc.set_params(**kwargs)
3304                 self._request_autoscale_view(name, tight=tight)
3305         self.stale = True
3306 
3307     def tick_params(self, axis='both', **kwargs):
3308         """
3309         Change the appearance of ticks, tick labels, and gridlines.
3310 
3311         Tick properties that are not explicitly set using the keyword
3312         arguments remain unchanged unless *reset* is True. For the current
3313         style settings, see `.Axis.get_tick_params`.
3314 
3315         Parameters
3316         ----------
3317         axis : {'x', 'y', 'both'}, default: 'both'
3318             The axis to which the parameters are applied.
3319         which : {'major', 'minor', 'both'}, default: 'major'
3320             The group of ticks to which the parameters are applied.
3321         reset : bool, default: False
3322             Whether to reset the ticks to defaults before updating them.
3323 
3324         Other Parameters
3325         ----------------
3326         direction : {'in', 'out', 'inout'}
3327             Puts ticks inside the Axes, outside the Axes, or both.
3328         length : float
3329             Tick length in points.
3330         width : float
3331             Tick width in points.
3332         color : color
3333             Tick color.
3334         pad : float
3335             Distance in points between tick and label.
3336         labelsize : float or str
3337             Tick label font size in points or as a string (e.g., 'large').
3338         labelcolor : color
3339             Tick label color.
3340         colors : color
3341             Tick color and label color.
3342         zorder : float
3343             Tick and label zorder.
3344         bottom, top, left, right : bool
3345             Whether to draw the respective ticks.
3346         labelbottom, labeltop, labelleft, labelright : bool
3347             Whether to draw the respective tick labels.
3348         labelrotation : float
3349             Tick label rotation
3350         grid_color : color
3351             Gridline color.
3352         grid_alpha : float
3353             Transparency of gridlines: 0 (transparent) to 1 (opaque).
3354         grid_linewidth : float
3355             Width of gridlines in points.
3356         grid_linestyle : str
3357             Any valid `.Line2D` line style spec.
3358 
3359         Examples
3360         --------
3361         ::
3362 
3363             ax.tick_params(direction='out', length=6, width=2, colors='r',
3364                            grid_color='r', grid_alpha=0.5)
3365 
3366         This will make all major ticks be red, pointing out of the box,
3367         and with dimensions 6 points by 2 points.  Tick labels will
3368         also be red.  Gridlines will be red and translucent.
3369 
3370         """
3371         _api.check_in_list(['x', 'y', 'both'], axis=axis)
3372         if axis in ['x', 'both']:
3373             xkw = dict(kwargs)
3374             xkw.pop('left', None)
3375             xkw.pop('right', None)
3376             xkw.pop('labelleft', None)
3377             xkw.pop('labelright', None)
3378             self.xaxis.set_tick_params(**xkw)
3379         if axis in ['y', 'both']:
3380             ykw = dict(kwargs)
3381             ykw.pop('top', None)
3382             ykw.pop('bottom', None)
3383             ykw.pop('labeltop', None)
3384             ykw.pop('labelbottom', None)
3385             self.yaxis.set_tick_params(**ykw)
3386 
3387     def set_axis_off(self):
3388         """
3389         Turn the x- and y-axis off.
3390 
3391         This affects the axis lines, ticks, ticklabels, grid and axis labels.
3392         """
3393         self.axison = False
3394         self.stale = True
3395 
3396     def set_axis_on(self):
3397         """
3398         Turn the x- and y-axis on.
3399 
3400         This affects the axis lines, ticks, ticklabels, grid and axis labels.
3401         """
3402         self.axison = True
3403         self.stale = True
3404 
3405     # data limits, ticks, tick labels, and formatting
3406 
3407     def get_xlabel(self):
3408         """
3409         Get the xlabel text string.
3410         """
3411         label = self.xaxis.get_label()
3412         return label.get_text()
3413 
3414     def set_xlabel(self, xlabel, fontdict=None, labelpad=None, *,
3415                    loc=None, **kwargs):
3416         """
3417         Set the label for the x-axis.
3418 
3419         Parameters
3420         ----------
3421         xlabel : str
3422             The label text.
3423 
3424         labelpad : float, default: :rc:`axes.labelpad`
3425             Spacing in points from the Axes bounding box including ticks
3426             and tick labels.  If None, the previous value is left as is.
3427 
3428         loc : {'left', 'center', 'right'}, default: :rc:`xaxis.labellocation`
3429             The label position. This is a high-level alternative for passing
3430             parameters *x* and *horizontalalignment*.
3431 
3432         Other Parameters
3433         ----------------
3434         **kwargs : `.Text` properties
3435             `.Text` properties control the appearance of the label.
3436 
3437         See Also
3438         --------
3439         text : Documents the properties supported by `.Text`.
3440         """
3441         if labelpad is not None:
3442             self.xaxis.labelpad = labelpad
3443         protected_kw = ['x', 'horizontalalignment', 'ha']
3444         if {*kwargs} & {*protected_kw}:
3445             if loc is not None:
3446                 raise TypeError(f"Specifying 'loc' is disallowed when any of "
3447                                 f"its corresponding low level keyword "
3448                                 f"arguments ({protected_kw}) are also "
3449                                 f"supplied")
3450 
3451         else:
3452             loc = (loc if loc is not None
3453                    else mpl.rcParams['xaxis.labellocation'])
3454             _api.check_in_list(('left', 'center', 'right'), loc=loc)
3455 
3456             x = {
3457                 'left': 0,
3458                 'center': 0.5,
3459                 'right': 1,
3460             }[loc]
3461             kwargs.update(x=x, horizontalalignment=loc)
3462 
3463         return self.xaxis.set_label_text(xlabel, fontdict, **kwargs)
3464 
3465     def invert_xaxis(self):
3466         """
3467         Invert the x-axis.
3468 
3469         See Also
3470         --------
3471         xaxis_inverted
3472         get_xlim, set_xlim
3473         get_xbound, set_xbound
3474         """
3475         self.xaxis.set_inverted(not self.xaxis.get_inverted())
3476 
3477     xaxis_inverted = _axis_method_wrapper("xaxis", "get_inverted")
3478 
3479     def get_xbound(self):
3480         """
3481         Return the lower and upper x-axis bounds, in increasing order.
3482 
3483         See Also
3484         --------
3485         set_xbound
3486         get_xlim, set_xlim
3487         invert_xaxis, xaxis_inverted
3488         """
3489         left, right = self.get_xlim()
3490         if left < right:
3491             return left, right
3492         else:
3493             return right, left
3494 
3495     def set_xbound(self, lower=None, upper=None):
3496         """
3497         Set the lower and upper numerical bounds of the x-axis.
3498 
3499         This method will honor axis inversion regardless of parameter order.
3500         It will not change the autoscaling setting (`.get_autoscalex_on()`).
3501 
3502         Parameters
3503         ----------
3504         lower, upper : float or None
3505             The lower and upper bounds. If *None*, the respective axis bound
3506             is not modified.
3507 
3508         See Also
3509         --------
3510         get_xbound
3511         get_xlim, set_xlim
3512         invert_xaxis, xaxis_inverted
3513         """
3514         if upper is None and np.iterable(lower):
3515             lower, upper = lower
3516 
3517         old_lower, old_upper = self.get_xbound()
3518         if lower is None:
3519             lower = old_lower
3520         if upper is None:
3521             upper = old_upper
3522 
3523         self.set_xlim(sorted((lower, upper),
3524                              reverse=bool(self.xaxis_inverted())),
3525                       auto=None)
3526 
3527     def get_xlim(self):
3528         """
3529         Return the x-axis view limits.
3530 
3531         Returns
3532         -------
3533         left, right : (float, float)
3534             The current x-axis limits in data coordinates.
3535 
3536         See Also
3537         --------
3538         .Axes.set_xlim
3539         set_xbound, get_xbound
3540         invert_xaxis, xaxis_inverted
3541 
3542         Notes
3543         -----
3544         The x-axis may be inverted, in which case the *left* value will
3545         be greater than the *right* value.
3546         """
3547         return tuple(self.viewLim.intervalx)
3548 
3549     def _validate_converted_limits(self, limit, convert):
3550         """
3551         Raise ValueError if converted limits are non-finite.
3552 
3553         Note that this function also accepts None as a limit argument.
3554 
3555         Returns
3556         -------
3557         The limit value after call to convert(), or None if limit is None.
3558         """
3559         if limit is not None:
3560             converted_limit = convert(limit)
3561             if (isinstance(converted_limit, Real)
3562                     and not np.isfinite(converted_limit)):
3563                 raise ValueError("Axis limits cannot be NaN or Inf")
3564             return converted_limit
3565 
3566     def set_xlim(self, left=None, right=None, *, emit=True, auto=False,
3567                  xmin=None, xmax=None):
3568         """
3569         Set the x-axis view limits.
3570 
3571         Parameters
3572         ----------
3573         left : float, optional
3574             The left xlim in data coordinates. Passing *None* leaves the
3575             limit unchanged.
3576 
3577             The left and right xlims may also be passed as the tuple
3578             (*left*, *right*) as the first positional argument (or as
3579             the *left* keyword argument).
3580 
3581             .. ACCEPTS: (bottom: float, top: float)
3582 
3583         right : float, optional
3584             The right xlim in data coordinates. Passing *None* leaves the
3585             limit unchanged.
3586 
3587         emit : bool, default: True
3588             Whether to notify observers of limit change.
3589 
3590         auto : bool or None, default: False
3591             Whether to turn on autoscaling of the x-axis. True turns on,
3592             False turns off, None leaves unchanged.
3593 
3594         xmin, xmax : float, optional
3595             They are equivalent to left and right respectively, and it is an
3596             error to pass both *xmin* and *left* or *xmax* and *right*.
3597 
3598         Returns
3599         -------
3600         left, right : (float, float)
3601             The new x-axis limits in data coordinates.
3602 
3603         See Also
3604         --------
3605         get_xlim
3606         set_xbound, get_xbound
3607         invert_xaxis, xaxis_inverted
3608 
3609         Notes
3610         -----
3611         The *left* value may be greater than the *right* value, in which
3612         case the x-axis values will decrease from left to right.
3613 
3614         Examples
3615         --------
3616         >>> set_xlim(left, right)
3617         >>> set_xlim((left, right))
3618         >>> left, right = set_xlim(left, right)
3619 
3620         One limit may be left unchanged.
3621 
3622         >>> set_xlim(right=right_lim)
3623 
3624         Limits may be passed in reverse order to flip the direction of
3625         the x-axis. For example, suppose *x* represents the number of
3626         years before present. The x-axis limits might be set like the
3627         following so 5000 years ago is on the left of the plot and the
3628         present is on the right.
3629 
3630         >>> set_xlim(5000, 0)
3631         """
3632         if right is None and np.iterable(left):
3633             left, right = left
3634         if xmin is not None:
3635             if left is not None:
3636                 raise TypeError("Cannot pass both 'left' and 'xmin'")
3637             left = xmin
3638         if xmax is not None:
3639             if right is not None:
3640                 raise TypeError("Cannot pass both 'right' and 'xmax'")
3641             right = xmax
3642         return self.xaxis._set_lim(left, right, emit=emit, auto=auto)
3643 
3644     get_xscale = _axis_method_wrapper("xaxis", "get_scale")
3645     set_xscale = _axis_method_wrapper("xaxis", "_set_axes_scale")
3646     get_xticks = _axis_method_wrapper("xaxis", "get_ticklocs")
3647     set_xticks = _axis_method_wrapper("xaxis", "set_ticks")
3648     get_xmajorticklabels = _axis_method_wrapper("xaxis", "get_majorticklabels")
3649     get_xminorticklabels = _axis_method_wrapper("xaxis", "get_minorticklabels")
3650     get_xticklabels = _axis_method_wrapper("xaxis", "get_ticklabels")
3651     set_xticklabels = _axis_method_wrapper(
3652         "xaxis", "set_ticklabels",
3653         doc_sub={"Axis.set_ticks": "Axes.set_xticks"})
3654 
3655     def get_ylabel(self):
3656         """
3657         Get the ylabel text string.
3658         """
3659         label = self.yaxis.get_label()
3660         return label.get_text()
3661 
3662     def set_ylabel(self, ylabel, fontdict=None, labelpad=None, *,
3663                    loc=None, **kwargs):
3664         """
3665         Set the label for the y-axis.
3666 
3667         Parameters
3668         ----------
3669         ylabel : str
3670             The label text.
3671 
3672         labelpad : float, default: :rc:`axes.labelpad`
3673             Spacing in points from the Axes bounding box including ticks
3674             and tick labels.  If None, the previous value is left as is.
3675 
3676         loc : {'bottom', 'center', 'top'}, default: :rc:`yaxis.labellocation`
3677             The label position. This is a high-level alternative for passing
3678             parameters *y* and *horizontalalignment*.
3679 
3680         Other Parameters
3681         ----------------
3682         **kwargs : `.Text` properties
3683             `.Text` properties control the appearance of the label.
3684 
3685         See Also
3686         --------
3687         text : Documents the properties supported by `.Text`.
3688         """
3689         if labelpad is not None:
3690             self.yaxis.labelpad = labelpad
3691         protected_kw = ['y', 'horizontalalignment', 'ha']
3692         if {*kwargs} & {*protected_kw}:
3693             if loc is not None:
3694                 raise TypeError(f"Specifying 'loc' is disallowed when any of "
3695                                 f"its corresponding low level keyword "
3696                                 f"arguments ({protected_kw}) are also "
3697                                 f"supplied")
3698 
3699         else:
3700             loc = (loc if loc is not None
3701                    else mpl.rcParams['yaxis.labellocation'])
3702             _api.check_in_list(('bottom', 'center', 'top'), loc=loc)
3703 
3704             y, ha = {
3705                 'bottom': (0, 'left'),
3706                 'center': (0.5, 'center'),
3707                 'top': (1, 'right')
3708             }[loc]
3709             kwargs.update(y=y, horizontalalignment=ha)
3710 
3711         return self.yaxis.set_label_text(ylabel, fontdict, **kwargs)
3712 
3713     def invert_yaxis(self):
3714         """
3715         Invert the y-axis.
3716 
3717         See Also
3718         --------
3719         yaxis_inverted
3720         get_ylim, set_ylim
3721         get_ybound, set_ybound
3722         """
3723         self.yaxis.set_inverted(not self.yaxis.get_inverted())
3724 
3725     yaxis_inverted = _axis_method_wrapper("yaxis", "get_inverted")
3726 
3727     def get_ybound(self):
3728         """
3729         Return the lower and upper y-axis bounds, in increasing order.
3730 
3731         See Also
3732         --------
3733         set_ybound
3734         get_ylim, set_ylim
3735         invert_yaxis, yaxis_inverted
3736         """
3737         bottom, top = self.get_ylim()
3738         if bottom < top:
3739             return bottom, top
3740         else:
3741             return top, bottom
3742 
3743     def set_ybound(self, lower=None, upper=None):
3744         """
3745         Set the lower and upper numerical bounds of the y-axis.
3746 
3747         This method will honor axis inversion regardless of parameter order.
3748         It will not change the autoscaling setting (`.get_autoscaley_on()`).
3749 
3750         Parameters
3751         ----------
3752         lower, upper : float or None
3753             The lower and upper bounds. If *None*, the respective axis bound
3754             is not modified.
3755 
3756         See Also
3757         --------
3758         get_ybound
3759         get_ylim, set_ylim
3760         invert_yaxis, yaxis_inverted
3761         """
3762         if upper is None and np.iterable(lower):
3763             lower, upper = lower
3764 
3765         old_lower, old_upper = self.get_ybound()
3766         if lower is None:
3767             lower = old_lower
3768         if upper is None:
3769             upper = old_upper
3770 
3771         self.set_ylim(sorted((lower, upper),
3772                              reverse=bool(self.yaxis_inverted())),
3773                       auto=None)
3774 
3775     def get_ylim(self):
3776         """
3777         Return the y-axis view limits.
3778 
3779         Returns
3780         -------
3781         bottom, top : (float, float)
3782             The current y-axis limits in data coordinates.
3783 
3784         See Also
3785         --------
3786         .Axes.set_ylim
3787         set_ybound, get_ybound
3788         invert_yaxis, yaxis_inverted
3789 
3790         Notes
3791         -----
3792         The y-axis may be inverted, in which case the *bottom* value
3793         will be greater than the *top* value.
3794         """
3795         return tuple(self.viewLim.intervaly)
3796 
3797     def set_ylim(self, bottom=None, top=None, *, emit=True, auto=False,
3798                  ymin=None, ymax=None):
3799         """
3800         Set the y-axis view limits.
3801 
3802         Parameters
3803         ----------
3804         bottom : float, optional
3805             The bottom ylim in data coordinates. Passing *None* leaves the
3806             limit unchanged.
3807 
3808             The bottom and top ylims may also be passed as the tuple
3809             (*bottom*, *top*) as the first positional argument (or as
3810             the *bottom* keyword argument).
3811 
3812             .. ACCEPTS: (bottom: float, top: float)
3813 
3814         top : float, optional
3815             The top ylim in data coordinates. Passing *None* leaves the
3816             limit unchanged.
3817 
3818         emit : bool, default: True
3819             Whether to notify observers of limit change.
3820 
3821         auto : bool or None, default: False
3822             Whether to turn on autoscaling of the y-axis. *True* turns on,
3823             *False* turns off, *None* leaves unchanged.
3824 
3825         ymin, ymax : float, optional
3826             They are equivalent to bottom and top respectively, and it is an
3827             error to pass both *ymin* and *bottom* or *ymax* and *top*.
3828 
3829         Returns
3830         -------
3831         bottom, top : (float, float)
3832             The new y-axis limits in data coordinates.
3833 
3834         See Also
3835         --------
3836         get_ylim
3837         set_ybound, get_ybound
3838         invert_yaxis, yaxis_inverted
3839 
3840         Notes
3841         -----
3842         The *bottom* value may be greater than the *top* value, in which
3843         case the y-axis values will decrease from *bottom* to *top*.
3844 
3845         Examples
3846         --------
3847         >>> set_ylim(bottom, top)
3848         >>> set_ylim((bottom, top))
3849         >>> bottom, top = set_ylim(bottom, top)
3850 
3851         One limit may be left unchanged.
3852 
3853         >>> set_ylim(top=top_lim)
3854 
3855         Limits may be passed in reverse order to flip the direction of
3856         the y-axis. For example, suppose ``y`` represents depth of the
3857         ocean in m. The y-axis limits might be set like the following
3858         so 5000 m depth is at the bottom of the plot and the surface,
3859         0 m, is at the top.
3860 
3861         >>> set_ylim(5000, 0)
3862         """
3863         if top is None and np.iterable(bottom):
3864             bottom, top = bottom
3865         if ymin is not None:
3866             if bottom is not None:
3867                 raise TypeError("Cannot pass both 'bottom' and 'ymin'")
3868             bottom = ymin
3869         if ymax is not None:
3870             if top is not None:
3871                 raise TypeError("Cannot pass both 'top' and 'ymax'")
3872             top = ymax
3873         return self.yaxis._set_lim(bottom, top, emit=emit, auto=auto)
3874 
3875     get_yscale = _axis_method_wrapper("yaxis", "get_scale")
3876     set_yscale = _axis_method_wrapper("yaxis", "_set_axes_scale")
3877     get_yticks = _axis_method_wrapper("yaxis", "get_ticklocs")
3878     set_yticks = _axis_method_wrapper("yaxis", "set_ticks")
3879     get_ymajorticklabels = _axis_method_wrapper("yaxis", "get_majorticklabels")
3880     get_yminorticklabels = _axis_method_wrapper("yaxis", "get_minorticklabels")
3881     get_yticklabels = _axis_method_wrapper("yaxis", "get_ticklabels")
3882     set_yticklabels = _axis_method_wrapper(
3883         "yaxis", "set_ticklabels",
3884         doc_sub={"Axis.set_ticks": "Axes.set_yticks"})
3885 
3886     xaxis_date = _axis_method_wrapper("xaxis", "axis_date")
3887     yaxis_date = _axis_method_wrapper("yaxis", "axis_date")
3888 
3889     def format_xdata(self, x):
3890         """
3891         Return *x* formatted as an x-value.
3892 
3893         This function will use the `.fmt_xdata` attribute if it is not None,
3894         else will fall back on the xaxis major formatter.
3895         """
3896         return (self.fmt_xdata if self.fmt_xdata is not None
3897                 else self.xaxis.get_major_formatter().format_data_short)(x)
3898 
3899     def format_ydata(self, y):
3900         """
3901         Return *y* formatted as a y-value.
3902 
3903         This function will use the `.fmt_ydata` attribute if it is not None,
3904         else will fall back on the yaxis major formatter.
3905         """
3906         return (self.fmt_ydata if self.fmt_ydata is not None
3907                 else self.yaxis.get_major_formatter().format_data_short)(y)
3908 
3909     def format_coord(self, x, y):
3910         """Return a format string formatting the *x*, *y* coordinates."""
3911         return "x={} y={}".format(
3912             "???" if x is None else self.format_xdata(x),
3913             "???" if y is None else self.format_ydata(y),
3914         )
3915 
3916     def minorticks_on(self):
3917         """
3918         Display minor ticks on the Axes.
3919 
3920         Displaying minor ticks may reduce performance; you may turn them off
3921         using `minorticks_off()` if drawing speed is a problem.
3922         """
3923         for ax in (self.xaxis, self.yaxis):
3924             scale = ax.get_scale()
3925             if scale == 'log':
3926                 s = ax._scale
3927                 ax.set_minor_locator(mticker.LogLocator(s.base, s.subs))
3928             elif scale == 'symlog':
3929                 s = ax._scale
3930                 ax.set_minor_locator(
3931                     mticker.SymmetricalLogLocator(s._transform, s.subs))
3932             else:
3933                 ax.set_minor_locator(mticker.AutoMinorLocator())
3934 
3935     def minorticks_off(self):
3936         """Remove minor ticks from the Axes."""
3937         self.xaxis.set_minor_locator(mticker.NullLocator())
3938         self.yaxis.set_minor_locator(mticker.NullLocator())
3939 
3940     # Interactive manipulation
3941 
3942     def can_zoom(self):
3943         """
3944         Return whether this Axes supports the zoom box button functionality.
3945         """
3946         return True
3947 
3948     def can_pan(self):
3949         """
3950         Return whether this Axes supports any pan/zoom button functionality.
3951         """
3952         return True
3953 
3954     def get_navigate(self):
3955         """
3956         Get whether the Axes responds to navigation commands.
3957         """
3958         return self._navigate
3959 
3960     def set_navigate(self, b):
3961         """
3962         Set whether the Axes responds to navigation toolbar commands.
3963 
3964         Parameters
3965         ----------
3966         b : bool
3967         """
3968         self._navigate = b
3969 
3970     def get_navigate_mode(self):
3971         """
3972         Get the navigation toolbar button status: 'PAN', 'ZOOM', or None.
3973         """
3974         return self._navigate_mode
3975 
3976     def set_navigate_mode(self, b):
3977         """
3978         Set the navigation toolbar button status.
3979 
3980         .. warning::
3981             This is not a user-API function.
3982 
3983         """
3984         self._navigate_mode = b
3985 
3986     def _get_view(self):
3987         """
3988         Save information required to reproduce the current view.
3989 
3990         This method is called before a view is changed, such as during a pan or zoom
3991         initiated by the user.  It returns an opaque object that describes the current
3992         view, in a format compatible with :meth:`_set_view`.
3993 
3994         The default implementation saves the view limits and autoscaling state.
3995         Subclasses may override this as needed, as long as :meth:`_set_view` is also
3996         adjusted accordingly.
3997         """
3998         return {
3999             "xlim": self.get_xlim(), "autoscalex_on": self.get_autoscalex_on(),
4000             "ylim": self.get_ylim(), "autoscaley_on": self.get_autoscaley_on(),
4001         }
4002 
4003     def _set_view(self, view):
4004         """
4005         Apply a previously saved view.
4006 
4007         This method is called when restoring a view (with the return value of
4008         :meth:`_get_view` as argument), such as with the navigation buttons.
4009 
4010         Subclasses that override :meth:`_get_view` also need to override this method
4011         accordingly.
4012         """
4013         self.set(**view)
4014 
4015     def _prepare_view_from_bbox(self, bbox, direction='in',
4016                                 mode=None, twinx=False, twiny=False):
4017         """
4018         Helper function to prepare the new bounds from a bbox.
4019 
4020         This helper function returns the new x and y bounds from the zoom
4021         bbox. This a convenience method to abstract the bbox logic
4022         out of the base setter.
4023         """
4024         if len(bbox) == 3:
4025             xp, yp, scl = bbox  # Zooming code
4026             if scl == 0:  # Should not happen
4027                 scl = 1.
4028             if scl > 1:
4029                 direction = 'in'
4030             else:
4031                 direction = 'out'
4032                 scl = 1/scl
4033             # get the limits of the axes
4034             (xmin, ymin), (xmax, ymax) = self.transData.transform(
4035                 np.transpose([self.get_xlim(), self.get_ylim()]))
4036             # set the range
4037             xwidth = xmax - xmin
4038             ywidth = ymax - ymin
4039             xcen = (xmax + xmin)*.5
4040             ycen = (ymax + ymin)*.5
4041             xzc = (xp*(scl - 1) + xcen)/scl
4042             yzc = (yp*(scl - 1) + ycen)/scl
4043             bbox = [xzc - xwidth/2./scl, yzc - ywidth/2./scl,
4044                     xzc + xwidth/2./scl, yzc + ywidth/2./scl]
4045         elif len(bbox) != 4:
4046             # should be len 3 or 4 but nothing else
4047             _api.warn_external(
4048                 "Warning in _set_view_from_bbox: bounding box is not a tuple "
4049                 "of length 3 or 4. Ignoring the view change.")
4050             return
4051 
4052         # Original limits.
4053         xmin0, xmax0 = self.get_xbound()
4054         ymin0, ymax0 = self.get_ybound()
4055         # The zoom box in screen coords.
4056         startx, starty, stopx, stopy = bbox
4057         # Convert to data coords.
4058         (startx, starty), (stopx, stopy) = self.transData.inverted().transform(
4059             [(startx, starty), (stopx, stopy)])
4060         # Clip to axes limits.
4061         xmin, xmax = np.clip(sorted([startx, stopx]), xmin0, xmax0)
4062         ymin, ymax = np.clip(sorted([starty, stopy]), ymin0, ymax0)
4063         # Don't double-zoom twinned axes or if zooming only the other axis.
4064         if twinx or mode == "y":
4065             xmin, xmax = xmin0, xmax0
4066         if twiny or mode == "x":
4067             ymin, ymax = ymin0, ymax0
4068 
4069         if direction == "in":
4070             new_xbound = xmin, xmax
4071             new_ybound = ymin, ymax
4072 
4073         elif direction == "out":
4074             x_trf = self.xaxis.get_transform()
4075             sxmin0, sxmax0, sxmin, sxmax = x_trf.transform(
4076                 [xmin0, xmax0, xmin, xmax])  # To screen space.
4077             factor = (sxmax0 - sxmin0) / (sxmax - sxmin)  # Unzoom factor.
4078             # Move original bounds away by
4079             # (factor) x (distance between unzoom box and Axes bbox).
4080             sxmin1 = sxmin0 - factor * (sxmin - sxmin0)
4081             sxmax1 = sxmax0 + factor * (sxmax0 - sxmax)
4082             # And back to data space.
4083             new_xbound = x_trf.inverted().transform([sxmin1, sxmax1])
4084 
4085             y_trf = self.yaxis.get_transform()
4086             symin0, symax0, symin, symax = y_trf.transform(
4087                 [ymin0, ymax0, ymin, ymax])
4088             factor = (symax0 - symin0) / (symax - symin)
4089             symin1 = symin0 - factor * (symin - symin0)
4090             symax1 = symax0 + factor * (symax0 - symax)
4091             new_ybound = y_trf.inverted().transform([symin1, symax1])
4092 
4093         return new_xbound, new_ybound
4094 
4095     def _set_view_from_bbox(self, bbox, direction='in',
4096                             mode=None, twinx=False, twiny=False):
4097         """
4098         Update view from a selection bbox.
4099 
4100         .. note::
4101 
4102             Intended to be overridden by new projection types, but if not, the
4103             default implementation sets the view limits to the bbox directly.
4104 
4105         Parameters
4106         ----------
4107         bbox : 4-tuple or 3 tuple
4108             * If bbox is a 4 tuple, it is the selected bounding box limits,
4109               in *display* coordinates.
4110             * If bbox is a 3 tuple, it is an (xp, yp, scl) triple, where
4111               (xp, yp) is the center of zooming and scl the scale factor to
4112               zoom by.
4113 
4114         direction : str
4115             The direction to apply the bounding box.
4116                 * `'in'` - The bounding box describes the view directly, i.e.,
4117                            it zooms in.
4118                 * `'out'` - The bounding box describes the size to make the
4119                             existing view, i.e., it zooms out.
4120 
4121         mode : str or None
4122             The selection mode, whether to apply the bounding box in only the
4123             `'x'` direction, `'y'` direction or both (`None`).
4124 
4125         twinx : bool
4126             Whether this axis is twinned in the *x*-direction.
4127 
4128         twiny : bool
4129             Whether this axis is twinned in the *y*-direction.
4130         """
4131         new_xbound, new_ybound = self._prepare_view_from_bbox(
4132             bbox, direction=direction, mode=mode, twinx=twinx, twiny=twiny)
4133         if not twinx and mode != "y":
4134             self.set_xbound(new_xbound)
4135             self.set_autoscalex_on(False)
4136         if not twiny and mode != "x":
4137             self.set_ybound(new_ybound)
4138             self.set_autoscaley_on(False)
4139 
4140     def start_pan(self, x, y, button):
4141         """
4142         Called when a pan operation has started.
4143 
4144         Parameters
4145         ----------
4146         x, y : float
4147             The mouse coordinates in display coords.
4148         button : `.MouseButton`
4149             The pressed mouse button.
4150 
4151         Notes
4152         -----
4153         This is intended to be overridden by new projection types.
4154         """
4155         self._pan_start = types.SimpleNamespace(
4156             lim=self.viewLim.frozen(),
4157             trans=self.transData.frozen(),
4158             trans_inverse=self.transData.inverted().frozen(),
4159             bbox=self.bbox.frozen(),
4160             x=x,
4161             y=y)
4162 
4163     def end_pan(self):
4164         """
4165         Called when a pan operation completes (when the mouse button is up.)
4166 
4167         Notes
4168         -----
4169         This is intended to be overridden by new projection types.
4170         """
4171         del self._pan_start
4172 
4173     def _get_pan_points(self, button, key, x, y):
4174         """
4175         Helper function to return the new points after a pan.
4176 
4177         This helper function returns the points on the axis after a pan has
4178         occurred. This is a convenience method to abstract the pan logic
4179         out of the base setter.
4180         """
4181         def format_deltas(key, dx, dy):
4182             if key == 'control':
4183                 if abs(dx) > abs(dy):
4184                     dy = dx
4185                 else:
4186                     dx = dy
4187             elif key == 'x':
4188                 dy = 0
4189             elif key == 'y':
4190                 dx = 0
4191             elif key == 'shift':
4192                 if 2 * abs(dx) < abs(dy):
4193                     dx = 0
4194                 elif 2 * abs(dy) < abs(dx):
4195                     dy = 0
4196                 elif abs(dx) > abs(dy):
4197                     dy = dy / abs(dy) * abs(dx)
4198                 else:
4199                     dx = dx / abs(dx) * abs(dy)
4200             return dx, dy
4201 
4202         p = self._pan_start
4203         dx = x - p.x
4204         dy = y - p.y
4205         if dx == dy == 0:
4206             return
4207         if button == 1:
4208             dx, dy = format_deltas(key, dx, dy)
4209             result = p.bbox.translated(-dx, -dy).transformed(p.trans_inverse)
4210         elif button == 3:
4211             try:
4212                 dx = -dx / self.bbox.width
4213                 dy = -dy / self.bbox.height
4214                 dx, dy = format_deltas(key, dx, dy)
4215                 if self.get_aspect() != 'auto':
4216                     dx = dy = 0.5 * (dx + dy)
4217                 alpha = np.power(10.0, (dx, dy))
4218                 start = np.array([p.x, p.y])
4219                 oldpoints = p.lim.transformed(p.trans)
4220                 newpoints = start + alpha * (oldpoints - start)
4221                 result = (mtransforms.Bbox(newpoints)
4222                           .transformed(p.trans_inverse))
4223             except OverflowError:
4224                 _api.warn_external('Overflow while panning')
4225                 return
4226         else:
4227             return
4228 
4229         valid = np.isfinite(result.transformed(p.trans))
4230         points = result.get_points().astype(object)
4231         # Just ignore invalid limits (typically, underflow in log-scale).
4232         points[~valid] = None
4233         return points
4234 
4235     def drag_pan(self, button, key, x, y):
4236         """
4237         Called when the mouse moves during a pan operation.
4238 
4239         Parameters
4240         ----------
4241         button : `.MouseButton`
4242             The pressed mouse button.
4243         key : str or None
4244             The pressed key, if any.
4245         x, y : float
4246             The mouse coordinates in display coords.
4247 
4248         Notes
4249         -----
4250         This is intended to be overridden by new projection types.
4251         """
4252         points = self._get_pan_points(button, key, x, y)
4253         if points is not None:
4254             self.set_xlim(points[:, 0])
4255             self.set_ylim(points[:, 1])
4256 
4257     def get_children(self):
4258         # docstring inherited.
4259         return [
4260             *self._children,
4261             *self.spines.values(),
4262             *self._axis_map.values(),
4263             self.title, self._left_title, self._right_title,
4264             *self.child_axes,
4265             *([self.legend_] if self.legend_ is not None else []),
4266             self.patch,
4267         ]
4268 
4269     def contains(self, mouseevent):
4270         # docstring inherited.
4271         return self.patch.contains(mouseevent)
4272 
4273     def contains_point(self, point):
4274         """
4275         Return whether *point* (pair of pixel coordinates) is inside the Axes
4276         patch.
4277         """
4278         return self.patch.contains_point(point, radius=1.0)
4279 
4280     def get_default_bbox_extra_artists(self):
4281         """
4282         Return a default list of artists that are used for the bounding box
4283         calculation.
4284 
4285         Artists are excluded either by not being visible or
4286         ``artist.set_in_layout(False)``.
4287         """
4288 
4289         artists = self.get_children()
4290 
4291         for axis in self._axis_map.values():
4292             # axis tight bboxes are calculated separately inside
4293             # Axes.get_tightbbox() using for_layout_only=True
4294             artists.remove(axis)
4295         if not (self.axison and self._frameon):
4296             # don't do bbox on spines if frame not on.
4297             for spine in self.spines.values():
4298                 artists.remove(spine)
4299 
4300         artists.remove(self.title)
4301         artists.remove(self._left_title)
4302         artists.remove(self._right_title)
4303 
4304         # always include types that do not internally implement clipping
4305         # to Axes. may have clip_on set to True and clip_box equivalent
4306         # to ax.bbox but then ignore these properties during draws.
4307         noclip = (_AxesBase, maxis.Axis,
4308                   offsetbox.AnnotationBbox, offsetbox.OffsetBox)
4309         return [a for a in artists if a.get_visible() and a.get_in_layout()
4310                 and (isinstance(a, noclip) or not a._fully_clipped_to_axes())]
4311 
4312     @_api.make_keyword_only("3.8", "call_axes_locator")
4313     def get_tightbbox(self, renderer=None, call_axes_locator=True,
4314                       bbox_extra_artists=None, *, for_layout_only=False):
4315         """
4316         Return the tight bounding box of the Axes, including axis and their
4317         decorators (xlabel, title, etc).
4318 
4319         Artists that have ``artist.set_in_layout(False)`` are not included
4320         in the bbox.
4321 
4322         Parameters
4323         ----------
4324         renderer : `.RendererBase` subclass
4325             renderer that will be used to draw the figures (i.e.
4326             ``fig.canvas.get_renderer()``)
4327 
4328         bbox_extra_artists : list of `.Artist` or ``None``
4329             List of artists to include in the tight bounding box.  If
4330             ``None`` (default), then all artist children of the Axes are
4331             included in the tight bounding box.
4332 
4333         call_axes_locator : bool, default: True
4334             If *call_axes_locator* is ``False``, it does not call the
4335             ``_axes_locator`` attribute, which is necessary to get the correct
4336             bounding box. ``call_axes_locator=False`` can be used if the
4337             caller is only interested in the relative size of the tightbbox
4338             compared to the Axes bbox.
4339 
4340         for_layout_only : default: False
4341             The bounding box will *not* include the x-extent of the title and
4342             the xlabel, or the y-extent of the ylabel.
4343 
4344         Returns
4345         -------
4346         `.BboxBase`
4347             Bounding box in figure pixel coordinates.
4348 
4349         See Also
4350         --------
4351         matplotlib.axes.Axes.get_window_extent
4352         matplotlib.axis.Axis.get_tightbbox
4353         matplotlib.spines.Spine.get_window_extent
4354         """
4355 
4356         bb = []
4357         if renderer is None:
4358             renderer = self.figure._get_renderer()
4359 
4360         if not self.get_visible():
4361             return None
4362 
4363         locator = self.get_axes_locator()
4364         self.apply_aspect(
4365             locator(self, renderer) if locator and call_axes_locator else None)
4366 
4367         for axis in self._axis_map.values():
4368             if self.axison and axis.get_visible():
4369                 ba = martist._get_tightbbox_for_layout_only(axis, renderer)
4370                 if ba:
4371                     bb.append(ba)
4372         self._update_title_position(renderer)
4373         axbbox = self.get_window_extent(renderer)
4374         bb.append(axbbox)
4375 
4376         for title in [self.title, self._left_title, self._right_title]:
4377             if title.get_visible():
4378                 bt = title.get_window_extent(renderer)
4379                 if for_layout_only and bt.width > 0:
4380                     # make the title bbox 1 pixel wide so its width
4381                     # is not accounted for in bbox calculations in
4382                     # tight/constrained_layout
4383                     bt.x0 = (bt.x0 + bt.x1) / 2 - 0.5
4384                     bt.x1 = bt.x0 + 1.0
4385                 bb.append(bt)
4386 
4387         bbox_artists = bbox_extra_artists
4388         if bbox_artists is None:
4389             bbox_artists = self.get_default_bbox_extra_artists()
4390 
4391         for a in bbox_artists:
4392             bbox = a.get_tightbbox(renderer)
4393             if (bbox is not None
4394                     and 0 < bbox.width < np.inf
4395                     and 0 < bbox.height < np.inf):
4396                 bb.append(bbox)
4397         return mtransforms.Bbox.union(
4398             [b for b in bb if b.width != 0 or b.height != 0])
4399 
4400     def _make_twin_axes(self, *args, **kwargs):
4401         """Make a twinx Axes of self. This is used for twinx and twiny."""
4402         if 'sharex' in kwargs and 'sharey' in kwargs:
4403             # The following line is added in v2.2 to avoid breaking Seaborn,
4404             # which currently uses this internal API.
4405             if kwargs["sharex"] is not self and kwargs["sharey"] is not self:
4406                 raise ValueError("Twinned Axes may share only one axis")
4407         ss = self.get_subplotspec()
4408         if ss:
4409             twin = self.figure.add_subplot(ss, *args, **kwargs)
4410         else:
4411             twin = self.figure.add_axes(
4412                 self.get_position(True), *args, **kwargs,
4413                 axes_locator=_TransformedBoundsLocator(
4414                     [0, 0, 1, 1], self.transAxes))
4415         self.set_adjustable('datalim')
4416         twin.set_adjustable('datalim')
4417         self._twinned_axes.join(self, twin)
4418         return twin
4419 
4420     def twinx(self):
4421         """
4422         Create a twin Axes sharing the xaxis.
4423 
4424         Create a new Axes with an invisible x-axis and an independent
4425         y-axis positioned opposite to the original one (i.e. at right). The
4426         x-axis autoscale setting will be inherited from the original
4427         Axes.  To ensure that the tick marks of both y-axes align, see
4428         `~matplotlib.ticker.LinearLocator`.
4429 
4430         Returns
4431         -------
4432         Axes
4433             The newly created Axes instance
4434 
4435         Notes
4436         -----
4437         For those who are 'picking' artists while using twinx, pick
4438         events are only called for the artists in the top-most Axes.
4439         """
4440         ax2 = self._make_twin_axes(sharex=self)
4441         ax2.yaxis.tick_right()
4442         ax2.yaxis.set_label_position('right')
4443         ax2.yaxis.set_offset_position('right')
4444         ax2.set_autoscalex_on(self.get_autoscalex_on())
4445         self.yaxis.tick_left()
4446         ax2.xaxis.set_visible(False)
4447         ax2.patch.set_visible(False)
4448         return ax2
4449 
4450     def twiny(self):
4451         """
4452         Create a twin Axes sharing the yaxis.
4453 
4454         Create a new Axes with an invisible y-axis and an independent
4455         x-axis positioned opposite to the original one (i.e. at top). The
4456         y-axis autoscale setting will be inherited from the original Axes.
4457         To ensure that the tick marks of both x-axes align, see
4458         `~matplotlib.ticker.LinearLocator`.
4459 
4460         Returns
4461         -------
4462         Axes
4463             The newly created Axes instance
4464 
4465         Notes
4466         -----
4467         For those who are 'picking' artists while using twiny, pick
4468         events are only called for the artists in the top-most Axes.
4469         """
4470         ax2 = self._make_twin_axes(sharey=self)
4471         ax2.xaxis.tick_top()
4472         ax2.xaxis.set_label_position('top')
4473         ax2.set_autoscaley_on(self.get_autoscaley_on())
4474         self.xaxis.tick_bottom()
4475         ax2.yaxis.set_visible(False)
4476         ax2.patch.set_visible(False)
4477         return ax2
4478 
4479     def get_shared_x_axes(self):
4480         """Return an immutable view on the shared x-axes Grouper."""
4481         return cbook.GrouperView(self._shared_axes["x"])
4482 
4483     def get_shared_y_axes(self):
4484         """Return an immutable view on the shared y-axes Grouper."""
4485         return cbook.GrouperView(self._shared_axes["y"])
4486 
4487     def label_outer(self):
4488         """
4489         Only show "outer" labels and tick labels.
4490 
4491         x-labels are only kept for subplots on the last row (or first row, if
4492         labels are on the top side); y-labels only for subplots on the first
4493         column (or last column, if labels are on the right side).
4494         """
4495         self._label_outer_xaxis(check_patch=False)
4496         self._label_outer_yaxis(check_patch=False)
4497 
4498     def _label_outer_xaxis(self, *, check_patch):
4499         # see documentation in label_outer.
4500         if check_patch and not isinstance(self.patch, mpl.patches.Rectangle):
4501             return
4502         ss = self.get_subplotspec()
4503         if not ss:
4504             return
4505         label_position = self.xaxis.get_label_position()
4506         if not ss.is_first_row():  # Remove top label/ticklabels/offsettext.
4507             if label_position == "top":
4508                 self.set_xlabel("")
4509             self.xaxis.set_tick_params(which="both", labeltop=False)
4510             if self.xaxis.offsetText.get_position()[1] == 1:
4511                 self.xaxis.offsetText.set_visible(False)
4512         if not ss.is_last_row():  # Remove bottom label/ticklabels/offsettext.
4513             if label_position == "bottom":
4514                 self.set_xlabel("")
4515             self.xaxis.set_tick_params(which="both", labelbottom=False)
4516             if self.xaxis.offsetText.get_position()[1] == 0:
4517                 self.xaxis.offsetText.set_visible(False)
4518 
4519     def _label_outer_yaxis(self, *, check_patch):
4520         # see documentation in label_outer.
4521         if check_patch and not isinstance(self.patch, mpl.patches.Rectangle):
4522             return
4523         ss = self.get_subplotspec()
4524         if not ss:
4525             return
4526         label_position = self.yaxis.get_label_position()
4527         if not ss.is_first_col():  # Remove left label/ticklabels/offsettext.
4528             if label_position == "left":
4529                 self.set_ylabel("")
4530             self.yaxis.set_tick_params(which="both", labelleft=False)
4531             if self.yaxis.offsetText.get_position()[0] == 0:
4532                 self.yaxis.offsetText.set_visible(False)
4533         if not ss.is_last_col():  # Remove right label/ticklabels/offsettext.
4534             if label_position == "right":
4535                 self.set_ylabel("")
4536             self.yaxis.set_tick_params(which="both", labelright=False)
4537             if self.yaxis.offsetText.get_position()[0] == 1:
4538                 self.yaxis.offsetText.set_visible(False)

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>, <file>lib/mpl_toolkits/mplot3d/axes3d.py</file>
<class>Axes3D</class>
<method>tick_params</method>
<code>
1346     def tick_params(self, axis='both', **kwargs):
1347         """
1348         Convenience method for changing the appearance of ticks and
1349         tick labels.
1350 
1351         See `.Axes.tick_params` for full documentation.  Because this function
1352         applies to 3D Axes, *axis* can also be set to 'z', and setting *axis*
1353         to 'both' autoscales all three axes.
1354 
1355         Also, because of how Axes3D objects are drawn very differently
1356         from regular 2D axes, some of these settings may have
1357         ambiguous meaning.  For simplicity, the 'z' axis will
1358         accept settings as if it was like the 'y' axis.
1359 
1360         .. note::
1361            Axes3D currently ignores some of these settings.
1362         """
1363         _api.check_in_list(['x', 'y', 'z', 'both'], axis=axis)
1364         if axis in ['x', 'y', 'both']:
1365             super().tick_params(axis, **kwargs)
1366         if axis in ['z', 'both']:
1367             zkw = dict(kwargs)
1368             zkw.pop('top', None)
1369             zkw.pop('bottom', None)
1370             zkw.pop('labeltop', None)
1371             zkw.pop('labelbottom', None)
1372             self.zaxis.set_tick_params(**zkw)

</code><intended_behavior>Update the `tick_params` method to accept and correctly apply a `fontfamily` keyword argument for the 'x', 'y', and crucially, the 'z' axis, considering the 3D context. As with the 2D scenario, ensure that specifying `fontfamily` changes the font family of the tick labels according to the user's input while keeping all other functionalities intact. Special attention should be paid to integrating this functionality within the 3D plotting constraints and ensuring compatibility with the generalized matplotlib styles and options framework. Furthermore, since the 3D method calls its 2D counterpart for the 'x' and 'y' axes, care must be taken to harmonize the handling of `fontfamily` between these implementations.</intended_behavior>, <file>lib/mpl_toolkits/mplot3d/axes3d.py</file>
<class>Axes3D</class>
<method>None</method>
<code>
45 class Axes3D(Axes):
46     """
47     3D Axes object.
48 
49     .. note::
50 
51         As a user, you do not instantiate Axes directly, but use Axes creation
52         methods instead; e.g. from `.pyplot` or `.Figure`:
53         `~.pyplot.subplots`, `~.pyplot.subplot_mosaic` or `.Figure.add_axes`.
54     """
55     name = '3d'
56 
57     _axis_names = ("x", "y", "z")
58     Axes._shared_axes["z"] = cbook.Grouper()
59 
60     vvec = _api.deprecate_privatize_attribute("3.7")
61     eye = _api.deprecate_privatize_attribute("3.7")
62     sx = _api.deprecate_privatize_attribute("3.7")
63     sy = _api.deprecate_privatize_attribute("3.7")
64 
65     def __init__(
66             self, fig, rect=None, *args,
67             elev=30, azim=-60, roll=0, sharez=None, proj_type='persp',
68             box_aspect=None, computed_zorder=True, focal_length=None,
69             **kwargs):
70         """
71         Parameters
72         ----------
73         fig : Figure
74             The parent figure.
75         rect : tuple (left, bottom, width, height), default: None.
76             The ``(left, bottom, width, height)`` axes position.
77         elev : float, default: 30
78             The elevation angle in degrees rotates the camera above and below
79             the x-y plane, with a positive angle corresponding to a location
80             above the plane.
81         azim : float, default: -60
82             The azimuthal angle in degrees rotates the camera about the z axis,
83             with a positive angle corresponding to a right-handed rotation. In
84             other words, a positive azimuth rotates the camera about the origin
85             from its location along the +x axis towards the +y axis.
86         roll : float, default: 0
87             The roll angle in degrees rotates the camera about the viewing
88             axis. A positive angle spins the camera clockwise, causing the
89             scene to rotate counter-clockwise.
90         sharez : Axes3D, optional
91             Other Axes to share z-limits with.
92         proj_type : {'persp', 'ortho'}
93             The projection type, default 'persp'.
94         box_aspect : 3-tuple of floats, default: None
95             Changes the physical dimensions of the Axes3D, such that the ratio
96             of the axis lengths in display units is x:y:z.
97             If None, defaults to 4:4:3
98         computed_zorder : bool, default: True
99             If True, the draw order is computed based on the average position
100             of the `.Artist`\\s along the view direction.
101             Set to False if you want to manually control the order in which
102             Artists are drawn on top of each other using their *zorder*
103             attribute. This can be used for fine-tuning if the automatic order
104             does not produce the desired result. Note however, that a manual
105             zorder will only be correct for a limited view angle. If the figure
106             is rotated by the user, it will look wrong from certain angles.
107         focal_length : float, default: None
108             For a projection type of 'persp', the focal length of the virtual
109             camera. Must be > 0. If None, defaults to 1.
110             For a projection type of 'ortho', must be set to either None
111             or infinity (numpy.inf). If None, defaults to infinity.
112             The focal length can be computed from a desired Field Of View via
113             the equation: focal_length = 1/tan(FOV/2)
114 
115         **kwargs
116             Other optional keyword arguments:
117 
118             %(Axes3D:kwdoc)s
119         """
120 
121         if rect is None:
122             rect = [0.0, 0.0, 1.0, 1.0]
123 
124         self.initial_azim = azim
125         self.initial_elev = elev
126         self.initial_roll = roll
127         self.set_proj_type(proj_type, focal_length)
128         self.computed_zorder = computed_zorder
129 
130         self.xy_viewLim = Bbox.unit()
131         self.zz_viewLim = Bbox.unit()
132         self.xy_dataLim = Bbox.unit()
133         # z-limits are encoded in the x-component of the Bbox, y is un-used
134         self.zz_dataLim = Bbox.unit()
135 
136         # inhibit autoscale_view until the axes are defined
137         # they can't be defined until Axes.__init__ has been called
138         self.view_init(self.initial_elev, self.initial_azim, self.initial_roll)
139 
140         self._sharez = sharez
141         if sharez is not None:
142             self._shared_axes["z"].join(self, sharez)
143             self._adjustable = 'datalim'
144 
145         if kwargs.pop('auto_add_to_figure', False):
146             raise AttributeError(
147                 'auto_add_to_figure is no longer supported for Axes3D. '
148                 'Use fig.add_axes(ax) instead.'
149             )
150 
151         super().__init__(
152             fig, rect, frameon=True, box_aspect=box_aspect, *args, **kwargs
153         )
154         # Disable drawing of axes by base class
155         super().set_axis_off()
156         # Enable drawing of axes by Axes3D class
157         self.set_axis_on()
158         self.M = None
159 
160         # func used to format z -- fall back on major formatters
161         self.fmt_zdata = None
162 
163         self.mouse_init()
164         self.figure.canvas.callbacks._connect_picklable(
165             'motion_notify_event', self._on_move)
166         self.figure.canvas.callbacks._connect_picklable(
167             'button_press_event', self._button_press)
168         self.figure.canvas.callbacks._connect_picklable(
169             'button_release_event', self._button_release)
170         self.set_top_view()
171 
172         self.patch.set_linewidth(0)
173         # Calculate the pseudo-data width and height
174         pseudo_bbox = self.transLimits.inverted().transform([(0, 0), (1, 1)])
175         self._pseudo_w, self._pseudo_h = pseudo_bbox[1] - pseudo_bbox[0]
176 
177         # mplot3d currently manages its own spines and needs these turned off
178         # for bounding box calculations
179         self.spines[:].set_visible(False)
180 
181     def set_axis_off(self):
182         self._axis3don = False
183         self.stale = True
184 
185     def set_axis_on(self):
186         self._axis3don = True
187         self.stale = True
188 
189     def convert_zunits(self, z):
190         """
191         For artists in an Axes, if the zaxis has units support,
192         convert *z* using zaxis unit type
193         """
194         return self.zaxis.convert_units(z)
195 
196     def set_top_view(self):
197         # this happens to be the right view for the viewing coordinates
198         # moved up and to the left slightly to fit labels and axes
199         xdwl = 0.95 / self._dist
200         xdw = 0.9 / self._dist
201         ydwl = 0.95 / self._dist
202         ydw = 0.9 / self._dist
203         # Set the viewing pane.
204         self.viewLim.intervalx = (-xdwl, xdw)
205         self.viewLim.intervaly = (-ydwl, ydw)
206         self.stale = True
207 
208     def _init_axis(self):
209         """Init 3D axes; overrides creation of regular X/Y axes."""
210         self.xaxis = axis3d.XAxis(self)
211         self.yaxis = axis3d.YAxis(self)
212         self.zaxis = axis3d.ZAxis(self)
213 
214     def get_zaxis(self):
215         """Return the ``ZAxis`` (`~.axis3d.Axis`) instance."""
216         return self.zaxis
217 
218     get_zgridlines = _axis_method_wrapper("zaxis", "get_gridlines")
219     get_zticklines = _axis_method_wrapper("zaxis", "get_ticklines")
220 
221     @_api.deprecated("3.7")
222     def unit_cube(self, vals=None):
223         return self._unit_cube(vals)
224 
225     def _unit_cube(self, vals=None):
226         minx, maxx, miny, maxy, minz, maxz = vals or self.get_w_lims()
227         return [(minx, miny, minz),
228                 (maxx, miny, minz),
229                 (maxx, maxy, minz),
230                 (minx, maxy, minz),
231                 (minx, miny, maxz),
232                 (maxx, miny, maxz),
233                 (maxx, maxy, maxz),
234                 (minx, maxy, maxz)]
235 
236     @_api.deprecated("3.7")
237     def tunit_cube(self, vals=None, M=None):
238         return self._tunit_cube(vals, M)
239 
240     def _tunit_cube(self, vals=None, M=None):
241         if M is None:
242             M = self.M
243         xyzs = self._unit_cube(vals)
244         tcube = proj3d._proj_points(xyzs, M)
245         return tcube
246 
247     @_api.deprecated("3.7")
248     def tunit_edges(self, vals=None, M=None):
249         return self._tunit_edges(vals, M)
250 
251     def _tunit_edges(self, vals=None, M=None):
252         tc = self._tunit_cube(vals, M)
253         edges = [(tc[0], tc[1]),
254                  (tc[1], tc[2]),
255                  (tc[2], tc[3]),
256                  (tc[3], tc[0]),
257 
258                  (tc[0], tc[4]),
259                  (tc[1], tc[5]),
260                  (tc[2], tc[6]),
261                  (tc[3], tc[7]),
262 
263                  (tc[4], tc[5]),
264                  (tc[5], tc[6]),
265                  (tc[6], tc[7]),
266                  (tc[7], tc[4])]
267         return edges
268 
269     def set_aspect(self, aspect, adjustable=None, anchor=None, share=False):
270         """
271         Set the aspect ratios.
272 
273         Parameters
274         ----------
275         aspect : {'auto', 'equal', 'equalxy', 'equalxz', 'equalyz'}
276             Possible values:
277 
278             =========   ==================================================
279             value       description
280             =========   ==================================================
281             'auto'      automatic; fill the position rectangle with data.
282             'equal'     adapt all the axes to have equal aspect ratios.
283             'equalxy'   adapt the x and y axes to have equal aspect ratios.
284             'equalxz'   adapt the x and z axes to have equal aspect ratios.
285             'equalyz'   adapt the y and z axes to have equal aspect ratios.
286             =========   ==================================================
287 
288         adjustable : None or {'box', 'datalim'}, optional
289             If not *None*, this defines which parameter will be adjusted to
290             meet the required aspect. See `.set_adjustable` for further
291             details.
292 
293         anchor : None or str or 2-tuple of float, optional
294             If not *None*, this defines where the Axes will be drawn if there
295             is extra space due to aspect constraints. The most common way to
296             specify the anchor are abbreviations of cardinal directions:
297 
298             =====   =====================
299             value   description
300             =====   =====================
301             'C'     centered
302             'SW'    lower left corner
303             'S'     middle of bottom edge
304             'SE'    lower right corner
305             etc.
306             =====   =====================
307 
308             See `~.Axes.set_anchor` for further details.
309 
310         share : bool, default: False
311             If ``True``, apply the settings to all shared Axes.
312 
313         See Also
314         --------
315         mpl_toolkits.mplot3d.axes3d.Axes3D.set_box_aspect
316         """
317         _api.check_in_list(('auto', 'equal', 'equalxy', 'equalyz', 'equalxz'),
318                            aspect=aspect)
319         super().set_aspect(
320             aspect='auto', adjustable=adjustable, anchor=anchor, share=share)
321         self._aspect = aspect
322 
323         if aspect in ('equal', 'equalxy', 'equalxz', 'equalyz'):
324             ax_indices = self._equal_aspect_axis_indices(aspect)
325 
326             view_intervals = np.array([self.xaxis.get_view_interval(),
327                                        self.yaxis.get_view_interval(),
328                                        self.zaxis.get_view_interval()])
329             ptp = np.ptp(view_intervals, axis=1)
330             if self._adjustable == 'datalim':
331                 mean = np.mean(view_intervals, axis=1)
332                 scale = max(ptp[ax_indices] / self._box_aspect[ax_indices])
333                 deltas = scale * self._box_aspect
334 
335                 for i, set_lim in enumerate((self.set_xlim3d,
336                                              self.set_ylim3d,
337                                              self.set_zlim3d)):
338                     if i in ax_indices:
339                         set_lim(mean[i] - deltas[i]/2., mean[i] + deltas[i]/2.)
340             else:  # 'box'
341                 # Change the box aspect such that the ratio of the length of
342                 # the unmodified axis to the length of the diagonal
343                 # perpendicular to it remains unchanged.
344                 box_aspect = np.array(self._box_aspect)
345                 box_aspect[ax_indices] = ptp[ax_indices]
346                 remaining_ax_indices = {0, 1, 2}.difference(ax_indices)
347                 if remaining_ax_indices:
348                     remaining = remaining_ax_indices.pop()
349                     old_diag = np.linalg.norm(self._box_aspect[ax_indices])
350                     new_diag = np.linalg.norm(box_aspect[ax_indices])
351                     box_aspect[remaining] *= new_diag / old_diag
352                 self.set_box_aspect(box_aspect)
353 
354     def _equal_aspect_axis_indices(self, aspect):
355         """
356         Get the indices for which of the x, y, z axes are constrained to have
357         equal aspect ratios.
358 
359         Parameters
360         ----------
361         aspect : {'auto', 'equal', 'equalxy', 'equalxz', 'equalyz'}
362             See descriptions in docstring for `.set_aspect()`.
363         """
364         ax_indices = []  # aspect == 'auto'
365         if aspect == 'equal':
366             ax_indices = [0, 1, 2]
367         elif aspect == 'equalxy':
368             ax_indices = [0, 1]
369         elif aspect == 'equalxz':
370             ax_indices = [0, 2]
371         elif aspect == 'equalyz':
372             ax_indices = [1, 2]
373         return ax_indices
374 
375     def set_box_aspect(self, aspect, *, zoom=1):
376         """
377         Set the Axes box aspect.
378 
379         The box aspect is the ratio of height to width in display
380         units for each face of the box when viewed perpendicular to
381         that face.  This is not to be confused with the data aspect (see
382         `~.Axes3D.set_aspect`). The default ratios are 4:4:3 (x:y:z).
383 
384         To simulate having equal aspect in data space, set the box
385         aspect to match your data range in each dimension.
386 
387         *zoom* controls the overall size of the Axes3D in the figure.
388 
389         Parameters
390         ----------
391         aspect : 3-tuple of floats or None
392             Changes the physical dimensions of the Axes3D, such that the ratio
393             of the axis lengths in display units is x:y:z.
394             If None, defaults to (4, 4, 3).
395 
396         zoom : float, default: 1
397             Control overall size of the Axes3D in the figure. Must be > 0.
398         """
399         if zoom <= 0:
400             raise ValueError(f'Argument zoom = {zoom} must be > 0')
401 
402         if aspect is None:
403             aspect = np.asarray((4, 4, 3), dtype=float)
404         else:
405             aspect = np.asarray(aspect, dtype=float)
406             _api.check_shape((3,), aspect=aspect)
407         # default scale tuned to match the mpl32 appearance.
408         aspect *= 1.8294640721620434 * zoom / np.linalg.norm(aspect)
409 
410         self._box_aspect = aspect
411         self.stale = True
412 
413     def apply_aspect(self, position=None):
414         if position is None:
415             position = self.get_position(original=True)
416 
417         # in the superclass, we would go through and actually deal with axis
418         # scales and box/datalim. Those are all irrelevant - all we need to do
419         # is make sure our coordinate system is square.
420         trans = self.get_figure().transSubfigure
421         bb = mtransforms.Bbox.unit().transformed(trans)
422         # this is the physical aspect of the panel (or figure):
423         fig_aspect = bb.height / bb.width
424 
425         box_aspect = 1
426         pb = position.frozen()
427         pb1 = pb.shrunk_to_aspect(box_aspect, pb, fig_aspect)
428         self._set_position(pb1.anchored(self.get_anchor(), pb), 'active')
429 
430     @martist.allow_rasterization
431     def draw(self, renderer):
432         if not self.get_visible():
433             return
434         self._unstale_viewLim()
435 
436         # draw the background patch
437         self.patch.draw(renderer)
438         self._frameon = False
439 
440         # first, set the aspect
441         # this is duplicated from `axes._base._AxesBase.draw`
442         # but must be called before any of the artist are drawn as
443         # it adjusts the view limits and the size of the bounding box
444         # of the Axes
445         locator = self.get_axes_locator()
446         self.apply_aspect(locator(self, renderer) if locator else None)
447 
448         # add the projection matrix to the renderer
449         self.M = self.get_proj()
450 
451         collections_and_patches = (
452             artist for artist in self._children
453             if isinstance(artist, (mcoll.Collection, mpatches.Patch))
454             and artist.get_visible())
455         if self.computed_zorder:
456             # Calculate projection of collections and patches and zorder
457             # them. Make sure they are drawn above the grids.
458             zorder_offset = max(axis.get_zorder()
459                                 for axis in self._axis_map.values()) + 1
460             collection_zorder = patch_zorder = zorder_offset
461 
462             for artist in sorted(collections_and_patches,
463                                  key=lambda artist: artist.do_3d_projection(),
464                                  reverse=True):
465                 if isinstance(artist, mcoll.Collection):
466                     artist.zorder = collection_zorder
467                     collection_zorder += 1
468                 elif isinstance(artist, mpatches.Patch):
469                     artist.zorder = patch_zorder
470                     patch_zorder += 1
471         else:
472             for artist in collections_and_patches:
473                 artist.do_3d_projection()
474 
475         if self._axis3don:
476             # Draw panes first
477             for axis in self._axis_map.values():
478                 axis.draw_pane(renderer)
479             # Then gridlines
480             for axis in self._axis_map.values():
481                 axis.draw_grid(renderer)
482             # Then axes, labels, text, and ticks
483             for axis in self._axis_map.values():
484                 axis.draw(renderer)
485 
486         # Then rest
487         super().draw(renderer)
488 
489     def get_axis_position(self):
490         vals = self.get_w_lims()
491         tc = self._tunit_cube(vals, self.M)
492         xhigh = tc[1][2] > tc[2][2]
493         yhigh = tc[3][2] > tc[2][2]
494         zhigh = tc[0][2] > tc[2][2]
495         return xhigh, yhigh, zhigh
496 
497     def update_datalim(self, xys, **kwargs):
498         """
499         Not implemented in `~mpl_toolkits.mplot3d.axes3d.Axes3D`.
500         """
501         pass
502 
503     get_autoscalez_on = _axis_method_wrapper("zaxis", "_get_autoscale_on")
504     set_autoscalez_on = _axis_method_wrapper("zaxis", "_set_autoscale_on")
505 
506     def set_zmargin(self, m):
507         """
508         Set padding of Z data limits prior to autoscaling.
509 
510         *m* times the data interval will be added to each end of that interval
511         before it is used in autoscaling.  If *m* is negative, this will clip
512         the data range instead of expanding it.
513 
514         For example, if your data is in the range [0, 2], a margin of 0.1 will
515         result in a range [-0.2, 2.2]; a margin of -0.1 will result in a range
516         of [0.2, 1.8].
517 
518         Parameters
519         ----------
520         m : float greater than -0.5
521         """
522         if m <= -0.5:
523             raise ValueError("margin must be greater than -0.5")
524         self._zmargin = m
525         self._request_autoscale_view("z")
526         self.stale = True
527 
528     def margins(self, *margins, x=None, y=None, z=None, tight=True):
529         """
530         Set or retrieve autoscaling margins.
531 
532         See `.Axes.margins` for full documentation.  Because this function
533         applies to 3D Axes, it also takes a *z* argument, and returns
534         ``(xmargin, ymargin, zmargin)``.
535         """
536         if margins and (x is not None or y is not None or z is not None):
537             raise TypeError('Cannot pass both positional and keyword '
538                             'arguments for x, y, and/or z.')
539         elif len(margins) == 1:
540             x = y = z = margins[0]
541         elif len(margins) == 3:
542             x, y, z = margins
543         elif margins:
544             raise TypeError('Must pass a single positional argument for all '
545                             'margins, or one for each margin (x, y, z).')
546 
547         if x is None and y is None and z is None:
548             if tight is not True:
549                 _api.warn_external(f'ignoring tight={tight!r} in get mode')
550             return self._xmargin, self._ymargin, self._zmargin
551 
552         if x is not None:
553             self.set_xmargin(x)
554         if y is not None:
555             self.set_ymargin(y)
556         if z is not None:
557             self.set_zmargin(z)
558 
559         self.autoscale_view(
560             tight=tight, scalex=(x is not None), scaley=(y is not None),
561             scalez=(z is not None)
562         )
563 
564     def autoscale(self, enable=True, axis='both', tight=None):
565         """
566         Convenience method for simple axis view autoscaling.
567 
568         See `.Axes.autoscale` for full documentation.  Because this function
569         applies to 3D Axes, *axis* can also be set to 'z', and setting *axis*
570         to 'both' autoscales all three axes.
571         """
572         if enable is None:
573             scalex = True
574             scaley = True
575             scalez = True
576         else:
577             if axis in ['x', 'both']:
578                 self.set_autoscalex_on(bool(enable))
579                 scalex = self.get_autoscalex_on()
580             else:
581                 scalex = False
582             if axis in ['y', 'both']:
583                 self.set_autoscaley_on(bool(enable))
584                 scaley = self.get_autoscaley_on()
585             else:
586                 scaley = False
587             if axis in ['z', 'both']:
588                 self.set_autoscalez_on(bool(enable))
589                 scalez = self.get_autoscalez_on()
590             else:
591                 scalez = False
592         if scalex:
593             self._request_autoscale_view("x", tight=tight)
594         if scaley:
595             self._request_autoscale_view("y", tight=tight)
596         if scalez:
597             self._request_autoscale_view("z", tight=tight)
598 
599     def auto_scale_xyz(self, X, Y, Z=None, had_data=None):
600         # This updates the bounding boxes as to keep a record as to what the
601         # minimum sized rectangular volume holds the data.
602         if np.shape(X) == np.shape(Y):
603             self.xy_dataLim.update_from_data_xy(
604                 np.column_stack([np.ravel(X), np.ravel(Y)]), not had_data)
605         else:
606             self.xy_dataLim.update_from_data_x(X, not had_data)
607             self.xy_dataLim.update_from_data_y(Y, not had_data)
608         if Z is not None:
609             self.zz_dataLim.update_from_data_x(Z, not had_data)
610         # Let autoscale_view figure out how to use this data.
611         self.autoscale_view()
612 
613     def autoscale_view(self, tight=None, scalex=True, scaley=True,
614                        scalez=True):
615         """
616         Autoscale the view limits using the data limits.
617 
618         See `.Axes.autoscale_view` for full documentation.  Because this
619         function applies to 3D Axes, it also takes a *scalez* argument.
620         """
621         # This method looks at the rectangular volume (see above)
622         # of data and decides how to scale the view portal to fit it.
623         if tight is None:
624             _tight = self._tight
625             if not _tight:
626                 # if image data only just use the datalim
627                 for artist in self._children:
628                     if isinstance(artist, mimage.AxesImage):
629                         _tight = True
630                     elif isinstance(artist, (mlines.Line2D, mpatches.Patch)):
631                         _tight = False
632                         break
633         else:
634             _tight = self._tight = bool(tight)
635 
636         if scalex and self.get_autoscalex_on():
637             x0, x1 = self.xy_dataLim.intervalx
638             xlocator = self.xaxis.get_major_locator()
639             x0, x1 = xlocator.nonsingular(x0, x1)
640             if self._xmargin > 0:
641                 delta = (x1 - x0) * self._xmargin
642                 x0 -= delta
643                 x1 += delta
644             if not _tight:
645                 x0, x1 = xlocator.view_limits(x0, x1)
646             self.set_xbound(x0, x1)
647 
648         if scaley and self.get_autoscaley_on():
649             y0, y1 = self.xy_dataLim.intervaly
650             ylocator = self.yaxis.get_major_locator()
651             y0, y1 = ylocator.nonsingular(y0, y1)
652             if self._ymargin > 0:
653                 delta = (y1 - y0) * self._ymargin
654                 y0 -= delta
655                 y1 += delta
656             if not _tight:
657                 y0, y1 = ylocator.view_limits(y0, y1)
658             self.set_ybound(y0, y1)
659 
660         if scalez and self.get_autoscalez_on():
661             z0, z1 = self.zz_dataLim.intervalx
662             zlocator = self.zaxis.get_major_locator()
663             z0, z1 = zlocator.nonsingular(z0, z1)
664             if self._zmargin > 0:
665                 delta = (z1 - z0) * self._zmargin
666                 z0 -= delta
667                 z1 += delta
668             if not _tight:
669                 z0, z1 = zlocator.view_limits(z0, z1)
670             self.set_zbound(z0, z1)
671 
672     def get_w_lims(self):
673         """Get 3D world limits."""
674         minx, maxx = self.get_xlim3d()
675         miny, maxy = self.get_ylim3d()
676         minz, maxz = self.get_zlim3d()
677         return minx, maxx, miny, maxy, minz, maxz
678 
679     # set_xlim, set_ylim are directly inherited from base Axes.
680     def set_zlim(self, bottom=None, top=None, *, emit=True, auto=False,
681                  zmin=None, zmax=None):
682         """
683         Set 3D z limits.
684 
685         See `.Axes.set_ylim` for full documentation
686         """
687         if top is None and np.iterable(bottom):
688             bottom, top = bottom
689         if zmin is not None:
690             if bottom is not None:
691                 raise TypeError("Cannot pass both 'bottom' and 'zmin'")
692             bottom = zmin
693         if zmax is not None:
694             if top is not None:
695                 raise TypeError("Cannot pass both 'top' and 'zmax'")
696             top = zmax
697         return self.zaxis._set_lim(bottom, top, emit=emit, auto=auto)
698 
699     set_xlim3d = maxes.Axes.set_xlim
700     set_ylim3d = maxes.Axes.set_ylim
701     set_zlim3d = set_zlim
702 
703     def get_xlim(self):
704         # docstring inherited
705         return tuple(self.xy_viewLim.intervalx)
706 
707     def get_ylim(self):
708         # docstring inherited
709         return tuple(self.xy_viewLim.intervaly)
710 
711     def get_zlim(self):
712         """Get 3D z limits."""
713         return tuple(self.zz_viewLim.intervalx)
714 
715     get_zscale = _axis_method_wrapper("zaxis", "get_scale")
716 
717     # Redefine all three methods to overwrite their docstrings.
718     set_xscale = _axis_method_wrapper("xaxis", "_set_axes_scale")
719     set_yscale = _axis_method_wrapper("yaxis", "_set_axes_scale")
720     set_zscale = _axis_method_wrapper("zaxis", "_set_axes_scale")
721     set_xscale.__doc__, set_yscale.__doc__, set_zscale.__doc__ = map(
722         """
723         Set the {}-axis scale.
724 
725         Parameters
726         ----------
727         value : {{"linear"}}
728             The axis scale type to apply.  3D axes currently only support
729             linear scales; other scales yield nonsensical results.
730 
731         **kwargs
732             Keyword arguments are nominally forwarded to the scale class, but
733             none of them is applicable for linear scales.
734         """.format,
735         ["x", "y", "z"])
736 
737     get_zticks = _axis_method_wrapper("zaxis", "get_ticklocs")
738     set_zticks = _axis_method_wrapper("zaxis", "set_ticks")
739     get_zmajorticklabels = _axis_method_wrapper("zaxis", "get_majorticklabels")
740     get_zminorticklabels = _axis_method_wrapper("zaxis", "get_minorticklabels")
741     get_zticklabels = _axis_method_wrapper("zaxis", "get_ticklabels")
742     set_zticklabels = _axis_method_wrapper(
743         "zaxis", "set_ticklabels",
744         doc_sub={"Axis.set_ticks": "Axes3D.set_zticks"})
745 
746     zaxis_date = _axis_method_wrapper("zaxis", "axis_date")
747     if zaxis_date.__doc__:
748         zaxis_date.__doc__ += textwrap.dedent("""
749 
750         Notes
751         -----
752         This function is merely provided for completeness, but 3D axes do not
753         support dates for ticks, and so this may not work as expected.
754         """)
755 
756     def clabel(self, *args, **kwargs):
757         """Currently not implemented for 3D axes, and returns *None*."""
758         return None
759 
760     def view_init(self, elev=None, azim=None, roll=None, vertical_axis="z"):
761         """
762         Set the elevation and azimuth of the axes in degrees (not radians).
763 
764         This can be used to rotate the axes programmatically.
765 
766         To look normal to the primary planes, the following elevation and
767         azimuth angles can be used. A roll angle of 0, 90, 180, or 270 deg
768         will rotate these views while keeping the axes at right angles.
769 
770         ==========   ====  ====
771         view plane   elev  azim
772         ==========   ====  ====
773         XY           90    -90
774         XZ           0     -90
775         YZ           0     0
776         -XY          -90   90
777         -XZ          0     90
778         -YZ          0     180
779         ==========   ====  ====
780 
781         Parameters
782         ----------
783         elev : float, default: None
784             The elevation angle in degrees rotates the camera above the plane
785             pierced by the vertical axis, with a positive angle corresponding
786             to a location above that plane. For example, with the default
787             vertical axis of 'z', the elevation defines the angle of the camera
788             location above the x-y plane.
789             If None, then the initial value as specified in the `Axes3D`
790             constructor is used.
791         azim : float, default: None
792             The azimuthal angle in degrees rotates the camera about the
793             vertical axis, with a positive angle corresponding to a
794             right-handed rotation. For example, with the default vertical axis
795             of 'z', a positive azimuth rotates the camera about the origin from
796             its location along the +x axis towards the +y axis.
797             If None, then the initial value as specified in the `Axes3D`
798             constructor is used.
799         roll : float, default: None
800             The roll angle in degrees rotates the camera about the viewing
801             axis. A positive angle spins the camera clockwise, causing the
802             scene to rotate counter-clockwise.
803             If None, then the initial value as specified in the `Axes3D`
804             constructor is used.
805         vertical_axis : {"z", "x", "y"}, default: "z"
806             The axis to align vertically. *azim* rotates about this axis.
807         """
808 
809         self._dist = 10  # The camera distance from origin. Behaves like zoom
810 
811         if elev is None:
812             self.elev = self.initial_elev
813         else:
814             self.elev = elev
815 
816         if azim is None:
817             self.azim = self.initial_azim
818         else:
819             self.azim = azim
820 
821         if roll is None:
822             self.roll = self.initial_roll
823         else:
824             self.roll = roll
825 
826         self._vertical_axis = _api.check_getitem(
827             dict(x=0, y=1, z=2), vertical_axis=vertical_axis
828         )
829 
830     def set_proj_type(self, proj_type, focal_length=None):
831         """
832         Set the projection type.
833 
834         Parameters
835         ----------
836         proj_type : {'persp', 'ortho'}
837             The projection type.
838         focal_length : float, default: None
839             For a projection type of 'persp', the focal length of the virtual
840             camera. Must be > 0. If None, defaults to 1.
841             The focal length can be computed from a desired Field Of View via
842             the equation: focal_length = 1/tan(FOV/2)
843         """
844         _api.check_in_list(['persp', 'ortho'], proj_type=proj_type)
845         if proj_type == 'persp':
846             if focal_length is None:
847                 focal_length = 1
848             elif focal_length <= 0:
849                 raise ValueError(f"focal_length = {focal_length} must be "
850                                  "greater than 0")
851             self._focal_length = focal_length
852         else:  # 'ortho':
853             if focal_length not in (None, np.inf):
854                 raise ValueError(f"focal_length = {focal_length} must be "
855                                  f"None for proj_type = {proj_type}")
856             self._focal_length = np.inf
857 
858     def _roll_to_vertical(self, arr):
859         """Roll arrays to match the different vertical axis."""
860         return np.roll(arr, self._vertical_axis - 2)
861 
862     def get_proj(self):
863         """Create the projection matrix from the current viewing position."""
864 
865         # Transform to uniform world coordinates 0-1, 0-1, 0-1
866         box_aspect = self._roll_to_vertical(self._box_aspect)
867         worldM = proj3d.world_transformation(
868             *self.get_xlim3d(),
869             *self.get_ylim3d(),
870             *self.get_zlim3d(),
871             pb_aspect=box_aspect,
872         )
873 
874         # Look into the middle of the world coordinates:
875         R = 0.5 * box_aspect
876 
877         # elev: elevation angle in the z plane.
878         # azim: azimuth angle in the xy plane.
879         # Coordinates for a point that rotates around the box of data.
880         # p0, p1 corresponds to rotating the box only around the vertical axis.
881         # p2 corresponds to rotating the box only around the horizontal axis.
882         elev_rad = np.deg2rad(self.elev)
883         azim_rad = np.deg2rad(self.azim)
884         p0 = np.cos(elev_rad) * np.cos(azim_rad)
885         p1 = np.cos(elev_rad) * np.sin(azim_rad)
886         p2 = np.sin(elev_rad)
887 
888         # When changing vertical axis the coordinates changes as well.
889         # Roll the values to get the same behaviour as the default:
890         ps = self._roll_to_vertical([p0, p1, p2])
891 
892         # The coordinates for the eye viewing point. The eye is looking
893         # towards the middle of the box of data from a distance:
894         eye = R + self._dist * ps
895 
896         # vvec, self._vvec and self._eye are unused, remove when deprecated
897         vvec = R - eye
898         self._eye = eye
899         self._vvec = vvec / np.linalg.norm(vvec)
900 
901         # Calculate the viewing axes for the eye position
902         u, v, w = self._calc_view_axes(eye)
903         self._view_u = u  # _view_u is towards the right of the screen
904         self._view_v = v  # _view_v is towards the top of the screen
905         self._view_w = w  # _view_w is out of the screen
906 
907         # Generate the view and projection transformation matrices
908         if self._focal_length == np.inf:
909             # Orthographic projection
910             viewM = proj3d._view_transformation_uvw(u, v, w, eye)
911             projM = proj3d._ortho_transformation(-self._dist, self._dist)
912         else:
913             # Perspective projection
914             # Scale the eye dist to compensate for the focal length zoom effect
915             eye_focal = R + self._dist * ps * self._focal_length
916             viewM = proj3d._view_transformation_uvw(u, v, w, eye_focal)
917             projM = proj3d._persp_transformation(-self._dist,
918                                                  self._dist,
919                                                  self._focal_length)
920 
921         # Combine all the transformation matrices to get the final projection
922         M0 = np.dot(viewM, worldM)
923         M = np.dot(projM, M0)
924         return M
925 
926     def mouse_init(self, rotate_btn=1, pan_btn=2, zoom_btn=3):
927         """
928         Set the mouse buttons for 3D rotation and zooming.
929 
930         Parameters
931         ----------
932         rotate_btn : int or list of int, default: 1
933             The mouse button or buttons to use for 3D rotation of the axes.
934         pan_btn : int or list of int, default: 2
935             The mouse button or buttons to use to pan the 3D axes.
936         zoom_btn : int or list of int, default: 3
937             The mouse button or buttons to use to zoom the 3D axes.
938         """
939         self.button_pressed = None
940         # coerce scalars into array-like, then convert into
941         # a regular list to avoid comparisons against None
942         # which breaks in recent versions of numpy.
943         self._rotate_btn = np.atleast_1d(rotate_btn).tolist()
944         self._pan_btn = np.atleast_1d(pan_btn).tolist()
945         self._zoom_btn = np.atleast_1d(zoom_btn).tolist()
946 
947     def disable_mouse_rotation(self):
948         """Disable mouse buttons for 3D rotation, panning, and zooming."""
949         self.mouse_init(rotate_btn=[], pan_btn=[], zoom_btn=[])
950 
951     def can_zoom(self):
952         # doc-string inherited
953         return True
954 
955     def can_pan(self):
956         # doc-string inherited
957         return True
958 
959     def sharez(self, other):
960         """
961         Share the z-axis with *other*.
962 
963         This is equivalent to passing ``sharez=other`` when constructing the
964         Axes, and cannot be used if the z-axis is already being shared with
965         another Axes.
966         """
967         _api.check_isinstance(maxes._base._AxesBase, other=other)
968         if self._sharez is not None and other is not self._sharez:
969             raise ValueError("z-axis is already shared")
970         self._shared_axes["z"].join(self, other)
971         self._sharez = other
972         self.zaxis.major = other.zaxis.major  # Ticker instances holding
973         self.zaxis.minor = other.zaxis.minor  # locator and formatter.
974         z0, z1 = other.get_zlim()
975         self.set_zlim(z0, z1, emit=False, auto=other.get_autoscalez_on())
976         self.zaxis._scale = other.zaxis._scale
977 
978     def clear(self):
979         # docstring inherited.
980         super().clear()
981         if self._focal_length == np.inf:
982             self._zmargin = mpl.rcParams['axes.zmargin']
983         else:
984             self._zmargin = 0.
985         self.grid(mpl.rcParams['axes3d.grid'])
986 
987     def _button_press(self, event):
988         if event.inaxes == self:
989             self.button_pressed = event.button
990             self._sx, self._sy = event.xdata, event.ydata
991             toolbar = self.figure.canvas.toolbar
992             if toolbar and toolbar._nav_stack() is None:
993                 toolbar.push_current()
994 
995     def _button_release(self, event):
996         self.button_pressed = None
997         toolbar = self.figure.canvas.toolbar
998         # backend_bases.release_zoom and backend_bases.release_pan call
999         # push_current, so check the navigation mode so we don't call it twice
1000         if toolbar and self.get_navigate_mode() is None:
1001             toolbar.push_current()
1002 
1003     def _get_view(self):
1004         # docstring inherited
1005         return {
1006             "xlim": self.get_xlim(), "autoscalex_on": self.get_autoscalex_on(),
1007             "ylim": self.get_ylim(), "autoscaley_on": self.get_autoscaley_on(),
1008             "zlim": self.get_zlim(), "autoscalez_on": self.get_autoscalez_on(),
1009         }, (self.elev, self.azim, self.roll)
1010 
1011     def _set_view(self, view):
1012         # docstring inherited
1013         props, (elev, azim, roll) = view
1014         self.set(**props)
1015         self.elev = elev
1016         self.azim = azim
1017         self.roll = roll
1018 
1019     def format_zdata(self, z):
1020         """
1021         Return *z* string formatted.  This function will use the
1022         :attr:`fmt_zdata` attribute if it is callable, else will fall
1023         back on the zaxis major formatter
1024         """
1025         try:
1026             return self.fmt_zdata(z)
1027         except (AttributeError, TypeError):
1028             func = self.zaxis.get_major_formatter().format_data_short
1029             val = func(z)
1030             return val
1031 
1032     def format_coord(self, xd, yd):
1033         """
1034         Given the 2D view coordinates attempt to guess a 3D coordinate.
1035         Looks for the nearest edge to the point and then assumes that
1036         the point is at the same z location as the nearest point on the edge.
1037         """
1038 
1039         if self.M is None:
1040             return ''
1041 
1042         if self.button_pressed in self._rotate_btn:
1043             # ignore xd and yd and display angles instead
1044             norm_elev = art3d._norm_angle(self.elev)
1045             norm_azim = art3d._norm_angle(self.azim)
1046             norm_roll = art3d._norm_angle(self.roll)
1047             return (f"elevation={norm_elev:.0f}\N{DEGREE SIGN}, "
1048                     f"azimuth={norm_azim:.0f}\N{DEGREE SIGN}, "
1049                     f"roll={norm_roll:.0f}\N{DEGREE SIGN}"
1050                     ).replace("-", "\N{MINUS SIGN}")
1051 
1052         # nearest edge
1053         p0, p1 = min(self._tunit_edges(),
1054                      key=lambda edge: proj3d._line2d_seg_dist(
1055                          (xd, yd), edge[0][:2], edge[1][:2]))
1056 
1057         # scale the z value to match
1058         x0, y0, z0 = p0
1059         x1, y1, z1 = p1
1060         d0 = np.hypot(x0-xd, y0-yd)
1061         d1 = np.hypot(x1-xd, y1-yd)
1062         dt = d0+d1
1063         z = d1/dt * z0 + d0/dt * z1
1064 
1065         x, y, z = proj3d.inv_transform(xd, yd, z, self.M)
1066 
1067         xs = self.format_xdata(x)
1068         ys = self.format_ydata(y)
1069         zs = self.format_zdata(z)
1070         return f'x={xs}, y={ys}, z={zs}'
1071 
1072     def _on_move(self, event):
1073         """
1074         Mouse moving.
1075 
1076         By default, button-1 rotates, button-2 pans, and button-3 zooms;
1077         these buttons can be modified via `mouse_init`.
1078         """
1079 
1080         if not self.button_pressed:
1081             return
1082 
1083         if self.get_navigate_mode() is not None:
1084             # we don't want to rotate if we are zooming/panning
1085             # from the toolbar
1086             return
1087 
1088         if self.M is None:
1089             return
1090 
1091         x, y = event.xdata, event.ydata
1092         # In case the mouse is out of bounds.
1093         if x is None or event.inaxes != self:
1094             return
1095 
1096         dx, dy = x - self._sx, y - self._sy
1097         w = self._pseudo_w
1098         h = self._pseudo_h
1099 
1100         # Rotation
1101         if self.button_pressed in self._rotate_btn:
1102             # rotate viewing point
1103             # get the x and y pixel coords
1104             if dx == 0 and dy == 0:
1105                 return
1106 
1107             roll = np.deg2rad(self.roll)
1108             delev = -(dy/h)*180*np.cos(roll) + (dx/w)*180*np.sin(roll)
1109             dazim = -(dy/h)*180*np.sin(roll) - (dx/w)*180*np.cos(roll)
1110             self.elev = self.elev + delev
1111             self.azim = self.azim + dazim
1112             self.stale = True
1113 
1114         elif self.button_pressed in self._pan_btn:
1115             # Start the pan event with pixel coordinates
1116             px, py = self.transData.transform([self._sx, self._sy])
1117             self.start_pan(px, py, 2)
1118             # pan view (takes pixel coordinate input)
1119             self.drag_pan(2, None, event.x, event.y)
1120             self.end_pan()
1121 
1122         # Zoom
1123         elif self.button_pressed in self._zoom_btn:
1124             # zoom view (dragging down zooms in)
1125             scale = h/(h - dy)
1126             self._scale_axis_limits(scale, scale, scale)
1127 
1128         # Store the event coordinates for the next time through.
1129         self._sx, self._sy = x, y
1130         # Always request a draw update at the end of interaction
1131         self.figure.canvas.draw_idle()
1132 
1133     def drag_pan(self, button, key, x, y):
1134         # docstring inherited
1135 
1136         # Get the coordinates from the move event
1137         p = self._pan_start
1138         (xdata, ydata), (xdata_start, ydata_start) = p.trans_inverse.transform(
1139             [(x, y), (p.x, p.y)])
1140         self._sx, self._sy = xdata, ydata
1141         # Calling start_pan() to set the x/y of this event as the starting
1142         # move location for the next event
1143         self.start_pan(x, y, button)
1144         du, dv = xdata - xdata_start, ydata - ydata_start
1145         dw = 0
1146         if key == 'x':
1147             dv = 0
1148         elif key == 'y':
1149             du = 0
1150         if du == 0 and dv == 0:
1151             return
1152 
1153         # Transform the pan from the view axes to the data axes
1154         R = np.array([self._view_u, self._view_v, self._view_w])
1155         R = -R / self._box_aspect * self._dist
1156         duvw_projected = R.T @ np.array([du, dv, dw])
1157 
1158         # Calculate pan distance
1159         minx, maxx, miny, maxy, minz, maxz = self.get_w_lims()
1160         dx = (maxx - minx) * duvw_projected[0]
1161         dy = (maxy - miny) * duvw_projected[1]
1162         dz = (maxz - minz) * duvw_projected[2]
1163 
1164         # Set the new axis limits
1165         self.set_xlim3d(minx + dx, maxx + dx)
1166         self.set_ylim3d(miny + dy, maxy + dy)
1167         self.set_zlim3d(minz + dz, maxz + dz)
1168 
1169     def _calc_view_axes(self, eye):
1170         """
1171         Get the unit vectors for the viewing axes in data coordinates.
1172         `u` is towards the right of the screen
1173         `v` is towards the top of the screen
1174         `w` is out of the screen
1175         """
1176         elev_rad = np.deg2rad(art3d._norm_angle(self.elev))
1177         roll_rad = np.deg2rad(art3d._norm_angle(self.roll))
1178 
1179         # Look into the middle of the world coordinates
1180         R = 0.5 * self._roll_to_vertical(self._box_aspect)
1181 
1182         # Define which axis should be vertical. A negative value
1183         # indicates the plot is upside down and therefore the values
1184         # have been reversed:
1185         V = np.zeros(3)
1186         V[self._vertical_axis] = -1 if abs(elev_rad) > np.pi/2 else 1
1187 
1188         u, v, w = proj3d._view_axes(eye, R, V, roll_rad)
1189         return u, v, w
1190 
1191     def _set_view_from_bbox(self, bbox, direction='in',
1192                             mode=None, twinx=False, twiny=False):
1193         """
1194         Zoom in or out of the bounding box.
1195 
1196         Will center the view in the center of the bounding box, and zoom by
1197         the ratio of the size of the bounding box to the size of the Axes3D.
1198         """
1199         (start_x, start_y, stop_x, stop_y) = bbox
1200         if mode == 'x':
1201             start_y = self.bbox.min[1]
1202             stop_y = self.bbox.max[1]
1203         elif mode == 'y':
1204             start_x = self.bbox.min[0]
1205             stop_x = self.bbox.max[0]
1206 
1207         # Clip to bounding box limits
1208         start_x, stop_x = np.clip(sorted([start_x, stop_x]),
1209                                   self.bbox.min[0], self.bbox.max[0])
1210         start_y, stop_y = np.clip(sorted([start_y, stop_y]),
1211                                   self.bbox.min[1], self.bbox.max[1])
1212 
1213         # Move the center of the view to the center of the bbox
1214         zoom_center_x = (start_x + stop_x)/2
1215         zoom_center_y = (start_y + stop_y)/2
1216 
1217         ax_center_x = (self.bbox.max[0] + self.bbox.min[0])/2
1218         ax_center_y = (self.bbox.max[1] + self.bbox.min[1])/2
1219 
1220         self.start_pan(zoom_center_x, zoom_center_y, 2)
1221         self.drag_pan(2, None, ax_center_x, ax_center_y)
1222         self.end_pan()
1223 
1224         # Calculate zoom level
1225         dx = abs(start_x - stop_x)
1226         dy = abs(start_y - stop_y)
1227         scale_u = dx / (self.bbox.max[0] - self.bbox.min[0])
1228         scale_v = dy / (self.bbox.max[1] - self.bbox.min[1])
1229 
1230         # Keep aspect ratios equal
1231         scale = max(scale_u, scale_v)
1232 
1233         # Zoom out
1234         if direction == 'out':
1235             scale = 1 / scale
1236 
1237         self._zoom_data_limits(scale, scale, scale)
1238 
1239     def _zoom_data_limits(self, scale_u, scale_v, scale_w):
1240         """
1241         Zoom in or out of a 3D plot.
1242 
1243         Will scale the data limits by the scale factors. These will be
1244         transformed to the x, y, z data axes based on the current view angles.
1245         A scale factor > 1 zooms out and a scale factor < 1 zooms in.
1246 
1247         For an axes that has had its aspect ratio set to 'equal', 'equalxy',
1248         'equalyz', or 'equalxz', the relevant axes are constrained to zoom
1249         equally.
1250 
1251         Parameters
1252         ----------
1253         scale_u : float
1254             Scale factor for the u view axis (view screen horizontal).
1255         scale_v : float
1256             Scale factor for the v view axis (view screen vertical).
1257         scale_w : float
1258             Scale factor for the w view axis (view screen depth).
1259         """
1260         scale = np.array([scale_u, scale_v, scale_w])
1261 
1262         # Only perform frame conversion if unequal scale factors
1263         if not np.allclose(scale, scale_u):
1264             # Convert the scale factors from the view frame to the data frame
1265             R = np.array([self._view_u, self._view_v, self._view_w])
1266             S = scale * np.eye(3)
1267             scale = np.linalg.norm(R.T @ S, axis=1)
1268 
1269             # Set the constrained scale factors to the factor closest to 1
1270             if self._aspect in ('equal', 'equalxy', 'equalxz', 'equalyz'):
1271                 ax_idxs = self._equal_aspect_axis_indices(self._aspect)
1272                 min_ax_idxs = np.argmin(np.abs(scale[ax_idxs] - 1))
1273                 scale[ax_idxs] = scale[ax_idxs][min_ax_idxs]
1274 
1275         self._scale_axis_limits(scale[0], scale[1], scale[2])
1276 
1277     def _scale_axis_limits(self, scale_x, scale_y, scale_z):
1278         """
1279         Keeping the center of the x, y, and z data axes fixed, scale their
1280         limits by scale factors. A scale factor > 1 zooms out and a scale
1281         factor < 1 zooms in.
1282 
1283         Parameters
1284         ----------
1285         scale_x : float
1286             Scale factor for the x data axis.
1287         scale_y : float
1288             Scale factor for the y data axis.
1289         scale_z : float
1290             Scale factor for the z data axis.
1291         """
1292         # Get the axis limits and centers
1293         minx, maxx, miny, maxy, minz, maxz = self.get_w_lims()
1294         cx = (maxx + minx)/2
1295         cy = (maxy + miny)/2
1296         cz = (maxz + minz)/2
1297 
1298         # Scale the data range
1299         dx = (maxx - minx)*scale_x
1300         dy = (maxy - miny)*scale_y
1301         dz = (maxz - minz)*scale_z
1302 
1303         # Set the scaled axis limits
1304         self.set_xlim3d(cx - dx/2, cx + dx/2)
1305         self.set_ylim3d(cy - dy/2, cy + dy/2)
1306         self.set_zlim3d(cz - dz/2, cz + dz/2)
1307 
1308     def set_zlabel(self, zlabel, fontdict=None, labelpad=None, **kwargs):
1309         """
1310         Set zlabel.  See doc for `.set_ylabel` for description.
1311         """
1312         if labelpad is not None:
1313             self.zaxis.labelpad = labelpad
1314         return self.zaxis.set_label_text(zlabel, fontdict, **kwargs)
1315 
1316     def get_zlabel(self):
1317         """
1318         Get the z-label text string.
1319         """
1320         label = self.zaxis.get_label()
1321         return label.get_text()
1322 
1323     # Axes rectangle characteristics
1324 
1325     # The frame_on methods are not available for 3D axes.
1326     # Python will raise a TypeError if they are called.
1327     get_frame_on = None
1328     set_frame_on = None
1329 
1330     def grid(self, visible=True, **kwargs):
1331         """
1332         Set / unset 3D grid.
1333 
1334         .. note::
1335 
1336             Currently, this function does not behave the same as
1337             `.axes.Axes.grid`, but it is intended to eventually support that
1338             behavior.
1339         """
1340         # TODO: Operate on each axes separately
1341         if len(kwargs):
1342             visible = True
1343         self._draw_grid = visible
1344         self.stale = True
1345 
1346     def tick_params(self, axis='both', **kwargs):
1347         """
1348         Convenience method for changing the appearance of ticks and
1349         tick labels.
1350 
1351         See `.Axes.tick_params` for full documentation.  Because this function
1352         applies to 3D Axes, *axis* can also be set to 'z', and setting *axis*
1353         to 'both' autoscales all three axes.
1354 
1355         Also, because of how Axes3D objects are drawn very differently
1356         from regular 2D axes, some of these settings may have
1357         ambiguous meaning.  For simplicity, the 'z' axis will
1358         accept settings as if it was like the 'y' axis.
1359 
1360         .. note::
1361            Axes3D currently ignores some of these settings.
1362         """
1363         _api.check_in_list(['x', 'y', 'z', 'both'], axis=axis)
1364         if axis in ['x', 'y', 'both']:
1365             super().tick_params(axis, **kwargs)
1366         if axis in ['z', 'both']:
1367             zkw = dict(kwargs)
1368             zkw.pop('top', None)
1369             zkw.pop('bottom', None)
1370             zkw.pop('labeltop', None)
1371             zkw.pop('labelbottom', None)
1372             self.zaxis.set_tick_params(**zkw)
1373 
1374     # data limits, ticks, tick labels, and formatting
1375 
1376     def invert_zaxis(self):
1377         """
1378         Invert the z-axis.
1379         """
1380         bottom, top = self.get_zlim()
1381         self.set_zlim(top, bottom, auto=None)
1382 
1383     zaxis_inverted = _axis_method_wrapper("zaxis", "get_inverted")
1384 
1385     def get_zbound(self):
1386         """
1387         Return the lower and upper z-axis bounds, in increasing order.
1388         """
1389         bottom, top = self.get_zlim()
1390         if bottom < top:
1391             return bottom, top
1392         else:
1393             return top, bottom
1394 
1395     def set_zbound(self, lower=None, upper=None):
1396         """
1397         Set the lower and upper numerical bounds of the z-axis.
1398 
1399         This method will honor axes inversion regardless of parameter order.
1400         It will not change the autoscaling setting (`.get_autoscalez_on()`).
1401         """
1402         if upper is None and np.iterable(lower):
1403             lower, upper = lower
1404 
1405         old_lower, old_upper = self.get_zbound()
1406         if lower is None:
1407             lower = old_lower
1408         if upper is None:
1409             upper = old_upper
1410 
1411         self.set_zlim(sorted((lower, upper),
1412                              reverse=bool(self.zaxis_inverted())),
1413                       auto=None)
1414 
1415     def text(self, x, y, z, s, zdir=None, **kwargs):
1416         """
1417         Add text to the plot.
1418 
1419         Keyword arguments will be passed on to `.Axes.text`, except for the
1420         *zdir* keyword, which sets the direction to be used as the z
1421         direction.
1422         """
1423         text = super().text(x, y, s, **kwargs)
1424         art3d.text_2d_to_3d(text, z, zdir)
1425         return text
1426 
1427     text3D = text
1428     text2D = Axes.text
1429 
1430     def plot(self, xs, ys, *args, zdir='z', **kwargs):
1431         """
1432         Plot 2D or 3D data.
1433 
1434         Parameters
1435         ----------
1436         xs : 1D array-like
1437             x coordinates of vertices.
1438         ys : 1D array-like
1439             y coordinates of vertices.
1440         zs : float or 1D array-like
1441             z coordinates of vertices; either one for all points or one for
1442             each point.
1443         zdir : {'x', 'y', 'z'}, default: 'z'
1444             When plotting 2D data, the direction to use as z.
1445         **kwargs
1446             Other arguments are forwarded to `matplotlib.axes.Axes.plot`.
1447         """
1448         had_data = self.has_data()
1449 
1450         # `zs` can be passed positionally or as keyword; checking whether
1451         # args[0] is a string matches the behavior of 2D `plot` (via
1452         # `_process_plot_var_args`).
1453         if args and not isinstance(args[0], str):
1454             zs, *args = args
1455             if 'zs' in kwargs:
1456                 raise TypeError("plot() for multiple values for argument 'z'")
1457         else:
1458             zs = kwargs.pop('zs', 0)
1459 
1460         # Match length
1461         zs = np.broadcast_to(zs, np.shape(xs))
1462 
1463         lines = super().plot(xs, ys, *args, **kwargs)
1464         for line in lines:
1465             art3d.line_2d_to_3d(line, zs=zs, zdir=zdir)
1466 
1467         xs, ys, zs = art3d.juggle_axes(xs, ys, zs, zdir)
1468         self.auto_scale_xyz(xs, ys, zs, had_data)
1469         return lines
1470 
1471     plot3D = plot
1472 
1473     def plot_surface(self, X, Y, Z, *, norm=None, vmin=None,
1474                      vmax=None, lightsource=None, **kwargs):
1475         """
1476         Create a surface plot.
1477 
1478         By default, it will be colored in shades of a solid color, but it also
1479         supports colormapping by supplying the *cmap* argument.
1480 
1481         .. note::
1482 
1483            The *rcount* and *ccount* kwargs, which both default to 50,
1484            determine the maximum number of samples used in each direction.  If
1485            the input data is larger, it will be downsampled (by slicing) to
1486            these numbers of points.
1487 
1488         .. note::
1489 
1490            To maximize rendering speed consider setting *rstride* and *cstride*
1491            to divisors of the number of rows minus 1 and columns minus 1
1492            respectively. For example, given 51 rows rstride can be any of the
1493            divisors of 50.
1494 
1495            Similarly, a setting of *rstride* and *cstride* equal to 1 (or
1496            *rcount* and *ccount* equal the number of rows and columns) can use
1497            the optimized path.
1498 
1499         Parameters
1500         ----------
1501         X, Y, Z : 2D arrays
1502             Data values.
1503 
1504         rcount, ccount : int
1505             Maximum number of samples used in each direction.  If the input
1506             data is larger, it will be downsampled (by slicing) to these
1507             numbers of points.  Defaults to 50.
1508 
1509         rstride, cstride : int
1510             Downsampling stride in each direction.  These arguments are
1511             mutually exclusive with *rcount* and *ccount*.  If only one of
1512             *rstride* or *cstride* is set, the other defaults to 10.
1513 
1514             'classic' mode uses a default of ``rstride = cstride = 10`` instead
1515             of the new default of ``rcount = ccount = 50``.
1516 
1517         color : color-like
1518             Color of the surface patches.
1519 
1520         cmap : Colormap
1521             Colormap of the surface patches.
1522 
1523         facecolors : array-like of colors.
1524             Colors of each individual patch.
1525 
1526         norm : Normalize
1527             Normalization for the colormap.
1528 
1529         vmin, vmax : float
1530             Bounds for the normalization.
1531 
1532         shade : bool, default: True
1533             Whether to shade the facecolors.  Shading is always disabled when
1534             *cmap* is specified.
1535 
1536         lightsource : `~matplotlib.colors.LightSource`
1537             The lightsource to use when *shade* is True.
1538 
1539         **kwargs
1540             Other keyword arguments are forwarded to `.Poly3DCollection`.
1541         """
1542 
1543         had_data = self.has_data()
1544 
1545         if Z.ndim != 2:
1546             raise ValueError("Argument Z must be 2-dimensional.")
1547 
1548         Z = cbook._to_unmasked_float_array(Z)
1549         X, Y, Z = np.broadcast_arrays(X, Y, Z)
1550         rows, cols = Z.shape
1551 
1552         has_stride = 'rstride' in kwargs or 'cstride' in kwargs
1553         has_count = 'rcount' in kwargs or 'ccount' in kwargs
1554 
1555         if has_stride and has_count:
1556             raise ValueError("Cannot specify both stride and count arguments")
1557 
1558         rstride = kwargs.pop('rstride', 10)
1559         cstride = kwargs.pop('cstride', 10)
1560         rcount = kwargs.pop('rcount', 50)
1561         ccount = kwargs.pop('ccount', 50)
1562 
1563         if mpl.rcParams['_internal.classic_mode']:
1564             # Strides have priority over counts in classic mode.
1565             # So, only compute strides from counts
1566             # if counts were explicitly given
1567             compute_strides = has_count
1568         else:
1569             # If the strides are provided then it has priority.
1570             # Otherwise, compute the strides from the counts.
1571             compute_strides = not has_stride
1572 
1573         if compute_strides:
1574             rstride = int(max(np.ceil(rows / rcount), 1))
1575             cstride = int(max(np.ceil(cols / ccount), 1))
1576 
1577         fcolors = kwargs.pop('facecolors', None)
1578 
1579         cmap = kwargs.get('cmap', None)
1580         shade = kwargs.pop('shade', cmap is None)
1581         if shade is None:
1582             raise ValueError("shade cannot be None.")
1583 
1584         colset = []  # the sampled facecolor
1585         if (rows - 1) % rstride == 0 and \
1586            (cols - 1) % cstride == 0 and \
1587            fcolors is None:
1588             polys = np.stack(
1589                 [cbook._array_patch_perimeters(a, rstride, cstride)
1590                  for a in (X, Y, Z)],
1591                 axis=-1)
1592         else:
1593             # evenly spaced, and including both endpoints
1594             row_inds = list(range(0, rows-1, rstride)) + [rows-1]
1595             col_inds = list(range(0, cols-1, cstride)) + [cols-1]
1596 
1597             polys = []
1598             for rs, rs_next in zip(row_inds[:-1], row_inds[1:]):
1599                 for cs, cs_next in zip(col_inds[:-1], col_inds[1:]):
1600                     ps = [
1601                         # +1 ensures we share edges between polygons
1602                         cbook._array_perimeter(a[rs:rs_next+1, cs:cs_next+1])
1603                         for a in (X, Y, Z)
1604                     ]
1605                     # ps = np.stack(ps, axis=-1)
1606                     ps = np.array(ps).T
1607                     polys.append(ps)
1608 
1609                     if fcolors is not None:
1610                         colset.append(fcolors[rs][cs])
1611 
1612         # In cases where there are NaNs in the data (possibly from masked
1613         # arrays), artifacts can be introduced. Here check whether NaNs exist
1614         # and remove the entries if so
1615         if not isinstance(polys, np.ndarray) or np.isnan(polys).any():
1616             new_polys = []
1617             new_colset = []
1618 
1619             # Depending on fcolors, colset is either an empty list or has as
1620             # many elements as polys. In the former case new_colset results in
1621             # a list with None entries, that is discarded later.
1622             for p, col in itertools.zip_longest(polys, colset):
1623                 new_poly = np.array(p)[~np.isnan(p).any(axis=1)]
1624                 if len(new_poly):
1625                     new_polys.append(new_poly)
1626                     new_colset.append(col)
1627 
1628             # Replace previous polys and, if fcolors is not None, colset
1629             polys = new_polys
1630             if fcolors is not None:
1631                 colset = new_colset
1632 
1633         # note that the striding causes some polygons to have more coordinates
1634         # than others
1635 
1636         if fcolors is not None:
1637             polyc = art3d.Poly3DCollection(
1638                 polys, edgecolors=colset, facecolors=colset, shade=shade,
1639                 lightsource=lightsource, **kwargs)
1640         elif cmap:
1641             polyc = art3d.Poly3DCollection(polys, **kwargs)
1642             # can't always vectorize, because polys might be jagged
1643             if isinstance(polys, np.ndarray):
1644                 avg_z = polys[..., 2].mean(axis=-1)
1645             else:
1646                 avg_z = np.array([ps[:, 2].mean() for ps in polys])
1647             polyc.set_array(avg_z)
1648             if vmin is not None or vmax is not None:
1649                 polyc.set_clim(vmin, vmax)
1650             if norm is not None:
1651                 polyc.set_norm(norm)
1652         else:
1653             color = kwargs.pop('color', None)
1654             if color is None:
1655                 color = self._get_lines.get_next_color()
1656             color = np.array(mcolors.to_rgba(color))
1657 
1658             polyc = art3d.Poly3DCollection(
1659                 polys, facecolors=color, shade=shade,
1660                 lightsource=lightsource, **kwargs)
1661 
1662         self.add_collection(polyc)
1663         self.auto_scale_xyz(X, Y, Z, had_data)
1664 
1665         return polyc
1666 
1667     def plot_wireframe(self, X, Y, Z, **kwargs):
1668         """
1669         Plot a 3D wireframe.
1670 
1671         .. note::
1672 
1673            The *rcount* and *ccount* kwargs, which both default to 50,
1674            determine the maximum number of samples used in each direction.  If
1675            the input data is larger, it will be downsampled (by slicing) to
1676            these numbers of points.
1677 
1678         Parameters
1679         ----------
1680         X, Y, Z : 2D arrays
1681             Data values.
1682 
1683         rcount, ccount : int
1684             Maximum number of samples used in each direction.  If the input
1685             data is larger, it will be downsampled (by slicing) to these
1686             numbers of points.  Setting a count to zero causes the data to be
1687             not sampled in the corresponding direction, producing a 3D line
1688             plot rather than a wireframe plot.  Defaults to 50.
1689 
1690         rstride, cstride : int
1691             Downsampling stride in each direction.  These arguments are
1692             mutually exclusive with *rcount* and *ccount*.  If only one of
1693             *rstride* or *cstride* is set, the other defaults to 1.  Setting a
1694             stride to zero causes the data to be not sampled in the
1695             corresponding direction, producing a 3D line plot rather than a
1696             wireframe plot.
1697 
1698             'classic' mode uses a default of ``rstride = cstride = 1`` instead
1699             of the new default of ``rcount = ccount = 50``.
1700 
1701         **kwargs
1702             Other keyword arguments are forwarded to `.Line3DCollection`.
1703         """
1704 
1705         had_data = self.has_data()
1706         if Z.ndim != 2:
1707             raise ValueError("Argument Z must be 2-dimensional.")
1708         # FIXME: Support masked arrays
1709         X, Y, Z = np.broadcast_arrays(X, Y, Z)
1710         rows, cols = Z.shape
1711 
1712         has_stride = 'rstride' in kwargs or 'cstride' in kwargs
1713         has_count = 'rcount' in kwargs or 'ccount' in kwargs
1714 
1715         if has_stride and has_count:
1716             raise ValueError("Cannot specify both stride and count arguments")
1717 
1718         rstride = kwargs.pop('rstride', 1)
1719         cstride = kwargs.pop('cstride', 1)
1720         rcount = kwargs.pop('rcount', 50)
1721         ccount = kwargs.pop('ccount', 50)
1722 
1723         if mpl.rcParams['_internal.classic_mode']:
1724             # Strides have priority over counts in classic mode.
1725             # So, only compute strides from counts
1726             # if counts were explicitly given
1727             if has_count:
1728                 rstride = int(max(np.ceil(rows / rcount), 1)) if rcount else 0
1729                 cstride = int(max(np.ceil(cols / ccount), 1)) if ccount else 0
1730         else:
1731             # If the strides are provided then it has priority.
1732             # Otherwise, compute the strides from the counts.
1733             if not has_stride:
1734                 rstride = int(max(np.ceil(rows / rcount), 1)) if rcount else 0
1735                 cstride = int(max(np.ceil(cols / ccount), 1)) if ccount else 0
1736 
1737         # We want two sets of lines, one running along the "rows" of
1738         # Z and another set of lines running along the "columns" of Z.
1739         # This transpose will make it easy to obtain the columns.
1740         tX, tY, tZ = np.transpose(X), np.transpose(Y), np.transpose(Z)
1741 
1742         if rstride:
1743             rii = list(range(0, rows, rstride))
1744             # Add the last index only if needed
1745             if rows > 0 and rii[-1] != (rows - 1):
1746                 rii += [rows-1]
1747         else:
1748             rii = []
1749         if cstride:
1750             cii = list(range(0, cols, cstride))
1751             # Add the last index only if needed
1752             if cols > 0 and cii[-1] != (cols - 1):
1753                 cii += [cols-1]
1754         else:
1755             cii = []
1756 
1757         if rstride == 0 and cstride == 0:
1758             raise ValueError("Either rstride or cstride must be non zero")
1759 
1760         # If the inputs were empty, then just
1761         # reset everything.
1762         if Z.size == 0:
1763             rii = []
1764             cii = []
1765 
1766         xlines = [X[i] for i in rii]
1767         ylines = [Y[i] for i in rii]
1768         zlines = [Z[i] for i in rii]
1769 
1770         txlines = [tX[i] for i in cii]
1771         tylines = [tY[i] for i in cii]
1772         tzlines = [tZ[i] for i in cii]
1773 
1774         lines = ([list(zip(xl, yl, zl))
1775                  for xl, yl, zl in zip(xlines, ylines, zlines)]
1776                  + [list(zip(xl, yl, zl))
1777                  for xl, yl, zl in zip(txlines, tylines, tzlines)])
1778 
1779         linec = art3d.Line3DCollection(lines, **kwargs)
1780         self.add_collection(linec)
1781         self.auto_scale_xyz(X, Y, Z, had_data)
1782 
1783         return linec
1784 
1785     def plot_trisurf(self, *args, color=None, norm=None, vmin=None, vmax=None,
1786                      lightsource=None, **kwargs):
1787         """
1788         Plot a triangulated surface.
1789 
1790         The (optional) triangulation can be specified in one of two ways;
1791         either::
1792 
1793           plot_trisurf(triangulation, ...)
1794 
1795         where triangulation is a `~matplotlib.tri.Triangulation` object, or::
1796 
1797           plot_trisurf(X, Y, ...)
1798           plot_trisurf(X, Y, triangles, ...)
1799           plot_trisurf(X, Y, triangles=triangles, ...)
1800 
1801         in which case a Triangulation object will be created.  See
1802         `.Triangulation` for an explanation of these possibilities.
1803 
1804         The remaining arguments are::
1805 
1806           plot_trisurf(..., Z)
1807 
1808         where *Z* is the array of values to contour, one per point
1809         in the triangulation.
1810 
1811         Parameters
1812         ----------
1813         X, Y, Z : array-like
1814             Data values as 1D arrays.
1815         color
1816             Color of the surface patches.
1817         cmap
1818             A colormap for the surface patches.
1819         norm : Normalize
1820             An instance of Normalize to map values to colors.
1821         vmin, vmax : float, default: None
1822             Minimum and maximum value to map.
1823         shade : bool, default: True
1824             Whether to shade the facecolors.  Shading is always disabled when
1825             *cmap* is specified.
1826         lightsource : `~matplotlib.colors.LightSource`
1827             The lightsource to use when *shade* is True.
1828         **kwargs
1829             All other keyword arguments are passed on to
1830             :class:`~mpl_toolkits.mplot3d.art3d.Poly3DCollection`
1831 
1832         Examples
1833         --------
1834         .. plot:: gallery/mplot3d/trisurf3d.py
1835         .. plot:: gallery/mplot3d/trisurf3d_2.py
1836         """
1837 
1838         had_data = self.has_data()
1839 
1840         # TODO: Support custom face colours
1841         if color is None:
1842             color = self._get_lines.get_next_color()
1843         color = np.array(mcolors.to_rgba(color))
1844 
1845         cmap = kwargs.get('cmap', None)
1846         shade = kwargs.pop('shade', cmap is None)
1847 
1848         tri, args, kwargs = \
1849             Triangulation.get_from_args_and_kwargs(*args, **kwargs)
1850         try:
1851             z = kwargs.pop('Z')
1852         except KeyError:
1853             # We do this so Z doesn't get passed as an arg to PolyCollection
1854             z, *args = args
1855         z = np.asarray(z)
1856 
1857         triangles = tri.get_masked_triangles()
1858         xt = tri.x[triangles]
1859         yt = tri.y[triangles]
1860         zt = z[triangles]
1861         verts = np.stack((xt, yt, zt), axis=-1)
1862 
1863         if cmap:
1864             polyc = art3d.Poly3DCollection(verts, *args, **kwargs)
1865             # average over the three points of each triangle
1866             avg_z = verts[:, :, 2].mean(axis=1)
1867             polyc.set_array(avg_z)
1868             if vmin is not None or vmax is not None:
1869                 polyc.set_clim(vmin, vmax)
1870             if norm is not None:
1871                 polyc.set_norm(norm)
1872         else:
1873             polyc = art3d.Poly3DCollection(
1874                 verts, *args, shade=shade, lightsource=lightsource,
1875                 facecolors=color, **kwargs)
1876 
1877         self.add_collection(polyc)
1878         self.auto_scale_xyz(tri.x, tri.y, z, had_data)
1879 
1880         return polyc
1881 
1882     def _3d_extend_contour(self, cset, stride=5):
1883         """
1884         Extend a contour in 3D by creating
1885         """
1886 
1887         levels = cset.levels
1888         colls = cset.collections
1889         dz = (levels[1] - levels[0]) / 2
1890 
1891         for z, linec in zip(levels, colls):
1892             paths = linec.get_paths()
1893             if not paths:
1894                 continue
1895             topverts = art3d._paths_to_3d_segments(paths, z - dz)
1896             botverts = art3d._paths_to_3d_segments(paths, z + dz)
1897 
1898             color = linec.get_edgecolor()[0]
1899 
1900             nsteps = round(len(topverts[0]) / stride)
1901             if nsteps <= 1:
1902                 if len(topverts[0]) > 1:
1903                     nsteps = 2
1904                 else:
1905                     continue
1906 
1907             polyverts = []
1908             stepsize = (len(topverts[0]) - 1) / (nsteps - 1)
1909             for i in range(round(nsteps) - 1):
1910                 i1 = round(i * stepsize)
1911                 i2 = round((i + 1) * stepsize)
1912                 polyverts.append([topverts[0][i1],
1913                                   topverts[0][i2],
1914                                   botverts[0][i2],
1915                                   botverts[0][i1]])
1916 
1917             # all polygons have 4 vertices, so vectorize
1918             polyverts = np.array(polyverts)
1919             polycol = art3d.Poly3DCollection(polyverts,
1920                                              facecolors=color,
1921                                              edgecolors=color,
1922                                              shade=True)
1923             polycol.set_sort_zpos(z)
1924             self.add_collection3d(polycol)
1925 
1926         for col in colls:
1927             col.remove()
1928 
1929     def add_contour_set(
1930             self, cset, extend3d=False, stride=5, zdir='z', offset=None):
1931         zdir = '-' + zdir
1932         if extend3d:
1933             self._3d_extend_contour(cset, stride)
1934         else:
1935             for z, linec in zip(cset.levels, cset.collections):
1936                 if offset is not None:
1937                     z = offset
1938                 art3d.line_collection_2d_to_3d(linec, z, zdir=zdir)
1939 
1940     def add_contourf_set(self, cset, zdir='z', offset=None):
1941         self._add_contourf_set(cset, zdir=zdir, offset=offset)
1942 
1943     def _add_contourf_set(self, cset, zdir='z', offset=None):
1944         """
1945         Returns
1946         -------
1947         levels : `numpy.ndarray`
1948             Levels at which the filled contours are added.
1949         """
1950         zdir = '-' + zdir
1951 
1952         midpoints = cset.levels[:-1] + np.diff(cset.levels) / 2
1953         # Linearly interpolate to get levels for any extensions
1954         if cset._extend_min:
1955             min_level = cset.levels[0] - np.diff(cset.levels[:2]) / 2
1956             midpoints = np.insert(midpoints, 0, min_level)
1957         if cset._extend_max:
1958             max_level = cset.levels[-1] + np.diff(cset.levels[-2:]) / 2
1959             midpoints = np.append(midpoints, max_level)
1960 
1961         for z, linec in zip(midpoints, cset.collections):
1962             if offset is not None:
1963                 z = offset
1964             art3d.poly_collection_2d_to_3d(linec, z, zdir=zdir)
1965             linec.set_sort_zpos(z)
1966         return midpoints
1967 
1968     @_preprocess_data()
1969     def contour(self, X, Y, Z, *args,
1970                 extend3d=False, stride=5, zdir='z', offset=None, **kwargs):
1971         """
1972         Create a 3D contour plot.
1973 
1974         Parameters
1975         ----------
1976         X, Y, Z : array-like,
1977             Input data. See `.Axes.contour` for supported data shapes.
1978         extend3d : bool, default: False
1979             Whether to extend contour in 3D.
1980         stride : int
1981             Step size for extending contour.
1982         zdir : {'x', 'y', 'z'}, default: 'z'
1983             The direction to use.
1984         offset : float, optional
1985             If specified, plot a projection of the contour lines at this
1986             position in a plane normal to *zdir*.
1987         data : indexable object, optional
1988             DATA_PARAMETER_PLACEHOLDER
1989 
1990         *args, **kwargs
1991             Other arguments are forwarded to `matplotlib.axes.Axes.contour`.
1992 
1993         Returns
1994         -------
1995         matplotlib.contour.QuadContourSet
1996         """
1997         had_data = self.has_data()
1998 
1999         jX, jY, jZ = art3d.rotate_axes(X, Y, Z, zdir)
2000         cset = super().contour(jX, jY, jZ, *args, **kwargs)
2001         self.add_contour_set(cset, extend3d, stride, zdir, offset)
2002 
2003         self.auto_scale_xyz(X, Y, Z, had_data)
2004         return cset
2005 
2006     contour3D = contour
2007 
2008     @_preprocess_data()
2009     def tricontour(self, *args,
2010                    extend3d=False, stride=5, zdir='z', offset=None, **kwargs):
2011         """
2012         Create a 3D contour plot.
2013 
2014         .. note::
2015             This method currently produces incorrect output due to a
2016             longstanding bug in 3D PolyCollection rendering.
2017 
2018         Parameters
2019         ----------
2020         X, Y, Z : array-like
2021             Input data. See `.Axes.tricontour` for supported data shapes.
2022         extend3d : bool, default: False
2023             Whether to extend contour in 3D.
2024         stride : int
2025             Step size for extending contour.
2026         zdir : {'x', 'y', 'z'}, default: 'z'
2027             The direction to use.
2028         offset : float, optional
2029             If specified, plot a projection of the contour lines at this
2030             position in a plane normal to *zdir*.
2031         data : indexable object, optional
2032             DATA_PARAMETER_PLACEHOLDER
2033         *args, **kwargs
2034             Other arguments are forwarded to `matplotlib.axes.Axes.tricontour`.
2035 
2036         Returns
2037         -------
2038         matplotlib.tri._tricontour.TriContourSet
2039         """
2040         had_data = self.has_data()
2041 
2042         tri, args, kwargs = Triangulation.get_from_args_and_kwargs(
2043                 *args, **kwargs)
2044         X = tri.x
2045         Y = tri.y
2046         if 'Z' in kwargs:
2047             Z = kwargs.pop('Z')
2048         else:
2049             # We do this so Z doesn't get passed as an arg to Axes.tricontour
2050             Z, *args = args
2051 
2052         jX, jY, jZ = art3d.rotate_axes(X, Y, Z, zdir)
2053         tri = Triangulation(jX, jY, tri.triangles, tri.mask)
2054 
2055         cset = super().tricontour(tri, jZ, *args, **kwargs)
2056         self.add_contour_set(cset, extend3d, stride, zdir, offset)
2057 
2058         self.auto_scale_xyz(X, Y, Z, had_data)
2059         return cset
2060 
2061     def _auto_scale_contourf(self, X, Y, Z, zdir, levels, had_data):
2062         # Autoscale in the zdir based on the levels added, which are
2063         # different from data range if any contour extensions are present
2064         dim_vals = {'x': X, 'y': Y, 'z': Z, zdir: levels}
2065         # Input data and levels have different sizes, but auto_scale_xyz
2066         # expected same-size input, so manually take min/max limits
2067         limits = [(np.nanmin(dim_vals[dim]), np.nanmax(dim_vals[dim]))
2068                   for dim in ['x', 'y', 'z']]
2069         self.auto_scale_xyz(*limits, had_data)
2070 
2071     @_preprocess_data()
2072     def contourf(self, X, Y, Z, *args, zdir='z', offset=None, **kwargs):
2073         """
2074         Create a 3D filled contour plot.
2075 
2076         Parameters
2077         ----------
2078         X, Y, Z : array-like
2079             Input data. See `.Axes.contourf` for supported data shapes.
2080         zdir : {'x', 'y', 'z'}, default: 'z'
2081             The direction to use.
2082         offset : float, optional
2083             If specified, plot a projection of the contour lines at this
2084             position in a plane normal to *zdir*.
2085         data : indexable object, optional
2086             DATA_PARAMETER_PLACEHOLDER
2087         *args, **kwargs
2088             Other arguments are forwarded to `matplotlib.axes.Axes.contourf`.
2089 
2090         Returns
2091         -------
2092         matplotlib.contour.QuadContourSet
2093         """
2094         had_data = self.has_data()
2095 
2096         jX, jY, jZ = art3d.rotate_axes(X, Y, Z, zdir)
2097         cset = super().contourf(jX, jY, jZ, *args, **kwargs)
2098         levels = self._add_contourf_set(cset, zdir, offset)
2099 
2100         self._auto_scale_contourf(X, Y, Z, zdir, levels, had_data)
2101         return cset
2102 
2103     contourf3D = contourf
2104 
2105     @_preprocess_data()
2106     def tricontourf(self, *args, zdir='z', offset=None, **kwargs):
2107         """
2108         Create a 3D filled contour plot.
2109 
2110         .. note::
2111             This method currently produces incorrect output due to a
2112             longstanding bug in 3D PolyCollection rendering.
2113 
2114         Parameters
2115         ----------
2116         X, Y, Z : array-like
2117             Input data. See `.Axes.tricontourf` for supported data shapes.
2118         zdir : {'x', 'y', 'z'}, default: 'z'
2119             The direction to use.
2120         offset : float, optional
2121             If specified, plot a projection of the contour lines at this
2122             position in a plane normal to zdir.
2123         data : indexable object, optional
2124             DATA_PARAMETER_PLACEHOLDER
2125         *args, **kwargs
2126             Other arguments are forwarded to
2127             `matplotlib.axes.Axes.tricontourf`.
2128 
2129         Returns
2130         -------
2131         matplotlib.tri._tricontour.TriContourSet
2132         """
2133         had_data = self.has_data()
2134 
2135         tri, args, kwargs = Triangulation.get_from_args_and_kwargs(
2136                 *args, **kwargs)
2137         X = tri.x
2138         Y = tri.y
2139         if 'Z' in kwargs:
2140             Z = kwargs.pop('Z')
2141         else:
2142             # We do this so Z doesn't get passed as an arg to Axes.tricontourf
2143             Z, *args = args
2144 
2145         jX, jY, jZ = art3d.rotate_axes(X, Y, Z, zdir)
2146         tri = Triangulation(jX, jY, tri.triangles, tri.mask)
2147 
2148         cset = super().tricontourf(tri, jZ, *args, **kwargs)
2149         levels = self._add_contourf_set(cset, zdir, offset)
2150 
2151         self._auto_scale_contourf(X, Y, Z, zdir, levels, had_data)
2152         return cset
2153 
2154     def add_collection3d(self, col, zs=0, zdir='z'):
2155         """
2156         Add a 3D collection object to the plot.
2157 
2158         2D collection types are converted to a 3D version by
2159         modifying the object and adding z coordinate information.
2160 
2161         Supported are:
2162 
2163         - PolyCollection
2164         - LineCollection
2165         - PatchCollection
2166         """
2167         zvals = np.atleast_1d(zs)
2168         zsortval = (np.min(zvals) if zvals.size
2169                     else 0)  # FIXME: arbitrary default
2170 
2171         # FIXME: use issubclass() (although, then a 3D collection
2172         #       object would also pass.)  Maybe have a collection3d
2173         #       abstract class to test for and exclude?
2174         if type(col) is mcoll.PolyCollection:
2175             art3d.poly_collection_2d_to_3d(col, zs=zs, zdir=zdir)
2176             col.set_sort_zpos(zsortval)
2177         elif type(col) is mcoll.LineCollection:
2178             art3d.line_collection_2d_to_3d(col, zs=zs, zdir=zdir)
2179             col.set_sort_zpos(zsortval)
2180         elif type(col) is mcoll.PatchCollection:
2181             art3d.patch_collection_2d_to_3d(col, zs=zs, zdir=zdir)
2182             col.set_sort_zpos(zsortval)
2183 
2184         collection = super().add_collection(col)
2185         return collection
2186 
2187     @_preprocess_data(replace_names=["xs", "ys", "zs", "s",
2188                                      "edgecolors", "c", "facecolor",
2189                                      "facecolors", "color"])
2190     def scatter(self, xs, ys, zs=0, zdir='z', s=20, c=None, depthshade=True,
2191                 *args, **kwargs):
2192         """
2193         Create a scatter plot.
2194 
2195         Parameters
2196         ----------
2197         xs, ys : array-like
2198             The data positions.
2199         zs : float or array-like, default: 0
2200             The z-positions. Either an array of the same length as *xs* and
2201             *ys* or a single value to place all points in the same plane.
2202         zdir : {'x', 'y', 'z', '-x', '-y', '-z'}, default: 'z'
2203             The axis direction for the *zs*. This is useful when plotting 2D
2204             data on a 3D Axes. The data must be passed as *xs*, *ys*. Setting
2205             *zdir* to 'y' then plots the data to the x-z-plane.
2206 
2207             See also :doc:`/gallery/mplot3d/2dcollections3d`.
2208 
2209         s : float or array-like, default: 20
2210             The marker size in points**2. Either an array of the same length
2211             as *xs* and *ys* or a single value to make all markers the same
2212             size.
2213         c : color, sequence, or sequence of colors, optional
2214             The marker color. Possible values:
2215 
2216             - A single color format string.
2217             - A sequence of colors of length n.
2218             - A sequence of n numbers to be mapped to colors using *cmap* and
2219               *norm*.
2220             - A 2D array in which the rows are RGB or RGBA.
2221 
2222             For more details see the *c* argument of `~.axes.Axes.scatter`.
2223         depthshade : bool, default: True
2224             Whether to shade the scatter markers to give the appearance of
2225             depth. Each call to ``scatter()`` will perform its depthshading
2226             independently.
2227         data : indexable object, optional
2228             DATA_PARAMETER_PLACEHOLDER
2229         **kwargs
2230             All other keyword arguments are passed on to `~.axes.Axes.scatter`.
2231 
2232         Returns
2233         -------
2234         paths : `~matplotlib.collections.PathCollection`
2235         """
2236 
2237         had_data = self.has_data()
2238         zs_orig = zs
2239 
2240         xs, ys, zs = np.broadcast_arrays(
2241             *[np.ravel(np.ma.filled(t, np.nan)) for t in [xs, ys, zs]])
2242         s = np.ma.ravel(s)  # This doesn't have to match x, y in size.
2243 
2244         xs, ys, zs, s, c = cbook.delete_masked_points(xs, ys, zs, s, c)
2245 
2246         # For xs and ys, 2D scatter() will do the copying.
2247         if np.may_share_memory(zs_orig, zs):  # Avoid unnecessary copies.
2248             zs = zs.copy()
2249 
2250         patches = super().scatter(xs, ys, s=s, c=c, *args, **kwargs)
2251         art3d.patch_collection_2d_to_3d(patches, zs=zs, zdir=zdir,
2252                                         depthshade=depthshade)
2253 
2254         if self._zmargin < 0.05 and xs.size > 0:
2255             self.set_zmargin(0.05)
2256 
2257         self.auto_scale_xyz(xs, ys, zs, had_data)
2258 
2259         return patches
2260 
2261     scatter3D = scatter
2262 
2263     @_preprocess_data()
2264     def bar(self, left, height, zs=0, zdir='z', *args, **kwargs):
2265         """
2266         Add 2D bar(s).
2267 
2268         Parameters
2269         ----------
2270         left : 1D array-like
2271             The x coordinates of the left sides of the bars.
2272         height : 1D array-like
2273             The height of the bars.
2274         zs : float or 1D array-like
2275             Z coordinate of bars; if a single value is specified, it will be
2276             used for all bars.
2277         zdir : {'x', 'y', 'z'}, default: 'z'
2278             When plotting 2D data, the direction to use as z ('x', 'y' or 'z').
2279         data : indexable object, optional
2280             DATA_PARAMETER_PLACEHOLDER
2281         **kwargs
2282             Other keyword arguments are forwarded to
2283             `matplotlib.axes.Axes.bar`.
2284 
2285         Returns
2286         -------
2287         mpl_toolkits.mplot3d.art3d.Patch3DCollection
2288         """
2289         had_data = self.has_data()
2290 
2291         patches = super().bar(left, height, *args, **kwargs)
2292 
2293         zs = np.broadcast_to(zs, len(left))
2294 
2295         verts = []
2296         verts_zs = []
2297         for p, z in zip(patches, zs):
2298             vs = art3d._get_patch_verts(p)
2299             verts += vs.tolist()
2300             verts_zs += [z] * len(vs)
2301             art3d.patch_2d_to_3d(p, z, zdir)
2302             if 'alpha' in kwargs:
2303                 p.set_alpha(kwargs['alpha'])
2304 
2305         if len(verts) > 0:
2306             # the following has to be skipped if verts is empty
2307             # NOTE: Bugs could still occur if len(verts) > 0,
2308             #       but the "2nd dimension" is empty.
2309             xs, ys = zip(*verts)
2310         else:
2311             xs, ys = [], []
2312 
2313         xs, ys, verts_zs = art3d.juggle_axes(xs, ys, verts_zs, zdir)
2314         self.auto_scale_xyz(xs, ys, verts_zs, had_data)
2315 
2316         return patches
2317 
2318     @_preprocess_data()
2319     def bar3d(self, x, y, z, dx, dy, dz, color=None,
2320               zsort='average', shade=True, lightsource=None, *args, **kwargs):
2321         """
2322         Generate a 3D barplot.
2323 
2324         This method creates three-dimensional barplot where the width,
2325         depth, height, and color of the bars can all be uniquely set.
2326 
2327         Parameters
2328         ----------
2329         x, y, z : array-like
2330             The coordinates of the anchor point of the bars.
2331 
2332         dx, dy, dz : float or array-like
2333             The width, depth, and height of the bars, respectively.
2334 
2335         color : sequence of colors, optional
2336             The color of the bars can be specified globally or
2337             individually. This parameter can be:
2338 
2339             - A single color, to color all bars the same color.
2340             - An array of colors of length N bars, to color each bar
2341               independently.
2342             - An array of colors of length 6, to color the faces of the
2343               bars similarly.
2344             - An array of colors of length 6 * N bars, to color each face
2345               independently.
2346 
2347             When coloring the faces of the boxes specifically, this is
2348             the order of the coloring:
2349 
2350             1. -Z (bottom of box)
2351             2. +Z (top of box)
2352             3. -Y
2353             4. +Y
2354             5. -X
2355             6. +X
2356 
2357         zsort : str, optional
2358             The z-axis sorting scheme passed onto `~.art3d.Poly3DCollection`
2359 
2360         shade : bool, default: True
2361             When true, this shades the dark sides of the bars (relative
2362             to the plot's source of light).
2363 
2364         lightsource : `~matplotlib.colors.LightSource`
2365             The lightsource to use when *shade* is True.
2366 
2367         data : indexable object, optional
2368             DATA_PARAMETER_PLACEHOLDER
2369 
2370         **kwargs
2371             Any additional keyword arguments are passed onto
2372             `~.art3d.Poly3DCollection`.
2373 
2374         Returns
2375         -------
2376         collection : `~.art3d.Poly3DCollection`
2377             A collection of three-dimensional polygons representing the bars.
2378         """
2379 
2380         had_data = self.has_data()
2381 
2382         x, y, z, dx, dy, dz = np.broadcast_arrays(
2383             np.atleast_1d(x), y, z, dx, dy, dz)
2384         minx = np.min(x)
2385         maxx = np.max(x + dx)
2386         miny = np.min(y)
2387         maxy = np.max(y + dy)
2388         minz = np.min(z)
2389         maxz = np.max(z + dz)
2390 
2391         # shape (6, 4, 3)
2392         # All faces are oriented facing outwards - when viewed from the
2393         # outside, their vertices are in a counterclockwise ordering.
2394         cuboid = np.array([
2395             # -z
2396             (
2397                 (0, 0, 0),
2398                 (0, 1, 0),
2399                 (1, 1, 0),
2400                 (1, 0, 0),
2401             ),
2402             # +z
2403             (
2404                 (0, 0, 1),
2405                 (1, 0, 1),
2406                 (1, 1, 1),
2407                 (0, 1, 1),
2408             ),
2409             # -y
2410             (
2411                 (0, 0, 0),
2412                 (1, 0, 0),
2413                 (1, 0, 1),
2414                 (0, 0, 1),
2415             ),
2416             # +y
2417             (
2418                 (0, 1, 0),
2419                 (0, 1, 1),
2420                 (1, 1, 1),
2421                 (1, 1, 0),
2422             ),
2423             # -x
2424             (
2425                 (0, 0, 0),
2426                 (0, 0, 1),
2427                 (0, 1, 1),
2428                 (0, 1, 0),
2429             ),
2430             # +x
2431             (
2432                 (1, 0, 0),
2433                 (1, 1, 0),
2434                 (1, 1, 1),
2435                 (1, 0, 1),
2436             ),
2437         ])
2438 
2439         # indexed by [bar, face, vertex, coord]
2440         polys = np.empty(x.shape + cuboid.shape)
2441 
2442         # handle each coordinate separately
2443         for i, p, dp in [(0, x, dx), (1, y, dy), (2, z, dz)]:
2444             p = p[..., np.newaxis, np.newaxis]
2445             dp = dp[..., np.newaxis, np.newaxis]
2446             polys[..., i] = p + dp * cuboid[..., i]
2447 
2448         # collapse the first two axes
2449         polys = polys.reshape((-1,) + polys.shape[2:])
2450 
2451         facecolors = []
2452         if color is None:
2453             color = [self._get_patches_for_fill.get_next_color()]
2454 
2455         color = list(mcolors.to_rgba_array(color))
2456 
2457         if len(color) == len(x):
2458             # bar colors specified, need to expand to number of faces
2459             for c in color:
2460                 facecolors.extend([c] * 6)
2461         else:
2462             # a single color specified, or face colors specified explicitly
2463             facecolors = color
2464             if len(facecolors) < len(x):
2465                 facecolors *= (6 * len(x))
2466 
2467         col = art3d.Poly3DCollection(polys,
2468                                      zsort=zsort,
2469                                      facecolors=facecolors,
2470                                      shade=shade,
2471                                      lightsource=lightsource,
2472                                      *args, **kwargs)
2473         self.add_collection(col)
2474 
2475         self.auto_scale_xyz((minx, maxx), (miny, maxy), (minz, maxz), had_data)
2476 
2477         return col
2478 
2479     def set_title(self, label, fontdict=None, loc='center', **kwargs):
2480         # docstring inherited
2481         ret = super().set_title(label, fontdict=fontdict, loc=loc, **kwargs)
2482         (x, y) = self.title.get_position()
2483         self.title.set_y(0.92 * y)
2484         return ret
2485 
2486     @_preprocess_data()
2487     def quiver(self, X, Y, Z, U, V, W, *,
2488                length=1, arrow_length_ratio=.3, pivot='tail', normalize=False,
2489                **kwargs):
2490         """
2491         Plot a 3D field of arrows.
2492 
2493         The arguments can be array-like or scalars, so long as they can be
2494         broadcast together. The arguments can also be masked arrays. If an
2495         element in any of argument is masked, then that corresponding quiver
2496         element will not be plotted.
2497 
2498         Parameters
2499         ----------
2500         X, Y, Z : array-like
2501             The x, y and z coordinates of the arrow locations (default is
2502             tail of arrow; see *pivot* kwarg).
2503 
2504         U, V, W : array-like
2505             The x, y and z components of the arrow vectors.
2506 
2507         length : float, default: 1
2508             The length of each quiver.
2509 
2510         arrow_length_ratio : float, default: 0.3
2511             The ratio of the arrow head with respect to the quiver.
2512 
2513         pivot : {'tail', 'middle', 'tip'}, default: 'tail'
2514             The part of the arrow that is at the grid point; the arrow
2515             rotates about this point, hence the name *pivot*.
2516 
2517         normalize : bool, default: False
2518             Whether all arrows are normalized to have the same length, or keep
2519             the lengths defined by *u*, *v*, and *w*.
2520 
2521         data : indexable object, optional
2522             DATA_PARAMETER_PLACEHOLDER
2523 
2524         **kwargs
2525             Any additional keyword arguments are delegated to
2526             :class:`.Line3DCollection`
2527         """
2528 
2529         def calc_arrows(UVW):
2530             # get unit direction vector perpendicular to (u, v, w)
2531             x = UVW[:, 0]
2532             y = UVW[:, 1]
2533             norm = np.linalg.norm(UVW[:, :2], axis=1)
2534             x_p = np.divide(y, norm, where=norm != 0, out=np.zeros_like(x))
2535             y_p = np.divide(-x,  norm, where=norm != 0, out=np.ones_like(x))
2536             # compute the two arrowhead direction unit vectors
2537             rangle = math.radians(15)
2538             c = math.cos(rangle)
2539             s = math.sin(rangle)
2540             # construct the rotation matrices of shape (3, 3, n)
2541             r13 = y_p * s
2542             r32 = x_p * s
2543             r12 = x_p * y_p * (1 - c)
2544             Rpos = np.array(
2545                 [[c + (x_p ** 2) * (1 - c), r12, r13],
2546                  [r12, c + (y_p ** 2) * (1 - c), -r32],
2547                  [-r13, r32, np.full_like(x_p, c)]])
2548             # opposite rotation negates all the sin terms
2549             Rneg = Rpos.copy()
2550             Rneg[[0, 1, 2, 2], [2, 2, 0, 1]] *= -1
2551             # Batch n (3, 3) x (3) matrix multiplications ((3, 3, n) x (n, 3)).
2552             Rpos_vecs = np.einsum("ij...,...j->...i", Rpos, UVW)
2553             Rneg_vecs = np.einsum("ij...,...j->...i", Rneg, UVW)
2554             # Stack into (n, 2, 3) result.
2555             return np.stack([Rpos_vecs, Rneg_vecs], axis=1)
2556 
2557         had_data = self.has_data()
2558 
2559         input_args = [X, Y, Z, U, V, W]
2560 
2561         # extract the masks, if any
2562         masks = [k.mask for k in input_args
2563                  if isinstance(k, np.ma.MaskedArray)]
2564         # broadcast to match the shape
2565         bcast = np.broadcast_arrays(*input_args, *masks)
2566         input_args = bcast[:6]
2567         masks = bcast[6:]
2568         if masks:
2569             # combine the masks into one
2570             mask = functools.reduce(np.logical_or, masks)
2571             # put mask on and compress
2572             input_args = [np.ma.array(k, mask=mask).compressed()
2573                           for k in input_args]
2574         else:
2575             input_args = [np.ravel(k) for k in input_args]
2576 
2577         if any(len(v) == 0 for v in input_args):
2578             # No quivers, so just make an empty collection and return early
2579             linec = art3d.Line3DCollection([], **kwargs)
2580             self.add_collection(linec)
2581             return linec
2582 
2583         shaft_dt = np.array([0., length], dtype=float)
2584         arrow_dt = shaft_dt * arrow_length_ratio
2585 
2586         _api.check_in_list(['tail', 'middle', 'tip'], pivot=pivot)
2587         if pivot == 'tail':
2588             shaft_dt -= length
2589         elif pivot == 'middle':
2590             shaft_dt -= length / 2
2591 
2592         XYZ = np.column_stack(input_args[:3])
2593         UVW = np.column_stack(input_args[3:]).astype(float)
2594 
2595         # Normalize rows of UVW
2596         norm = np.linalg.norm(UVW, axis=1)
2597 
2598         # If any row of UVW is all zeros, don't make a quiver for it
2599         mask = norm > 0
2600         XYZ = XYZ[mask]
2601         if normalize:
2602             UVW = UVW[mask] / norm[mask].reshape((-1, 1))
2603         else:
2604             UVW = UVW[mask]
2605 
2606         if len(XYZ) > 0:
2607             # compute the shaft lines all at once with an outer product
2608             shafts = (XYZ - np.multiply.outer(shaft_dt, UVW)).swapaxes(0, 1)
2609             # compute head direction vectors, n heads x 2 sides x 3 dimensions
2610             head_dirs = calc_arrows(UVW)
2611             # compute all head lines at once, starting from the shaft ends
2612             heads = shafts[:, :1] - np.multiply.outer(arrow_dt, head_dirs)
2613             # stack left and right head lines together
2614             heads = heads.reshape((len(arrow_dt), -1, 3))
2615             # transpose to get a list of lines
2616             heads = heads.swapaxes(0, 1)
2617 
2618             lines = [*shafts, *heads]
2619         else:
2620             lines = []
2621 
2622         linec = art3d.Line3DCollection(lines, **kwargs)
2623         self.add_collection(linec)
2624 
2625         self.auto_scale_xyz(XYZ[:, 0], XYZ[:, 1], XYZ[:, 2], had_data)
2626 
2627         return linec
2628 
2629     quiver3D = quiver
2630 
2631     def voxels(self, *args, facecolors=None, edgecolors=None, shade=True,
2632                lightsource=None, **kwargs):
2633         """
2634         ax.voxels([x, y, z,] /, filled, facecolors=None, edgecolors=None, \
2635 **kwargs)
2636 
2637         Plot a set of filled voxels
2638 
2639         All voxels are plotted as 1x1x1 cubes on the axis, with
2640         ``filled[0, 0, 0]`` placed with its lower corner at the origin.
2641         Occluded faces are not plotted.
2642 
2643         Parameters
2644         ----------
2645         filled : 3D np.array of bool
2646             A 3D array of values, with truthy values indicating which voxels
2647             to fill
2648 
2649         x, y, z : 3D np.array, optional
2650             The coordinates of the corners of the voxels. This should broadcast
2651             to a shape one larger in every dimension than the shape of
2652             *filled*.  These can be used to plot non-cubic voxels.
2653 
2654             If not specified, defaults to increasing integers along each axis,
2655             like those returned by :func:`~numpy.indices`.
2656             As indicated by the ``/`` in the function signature, these
2657             arguments can only be passed positionally.
2658 
2659         facecolors, edgecolors : array-like, optional
2660             The color to draw the faces and edges of the voxels. Can only be
2661             passed as keyword arguments.
2662             These parameters can be:
2663 
2664             - A single color value, to color all voxels the same color. This
2665               can be either a string, or a 1D RGB/RGBA array
2666             - ``None``, the default, to use a single color for the faces, and
2667               the style default for the edges.
2668             - A 3D `~numpy.ndarray` of color names, with each item the color
2669               for the corresponding voxel. The size must match the voxels.
2670             - A 4D `~numpy.ndarray` of RGB/RGBA data, with the components
2671               along the last axis.
2672 
2673         shade : bool, default: True
2674             Whether to shade the facecolors.
2675 
2676         lightsource : `~matplotlib.colors.LightSource`
2677             The lightsource to use when *shade* is True.
2678 
2679         **kwargs
2680             Additional keyword arguments to pass onto
2681             `~mpl_toolkits.mplot3d.art3d.Poly3DCollection`.
2682 
2683         Returns
2684         -------
2685         faces : dict
2686             A dictionary indexed by coordinate, where ``faces[i, j, k]`` is a
2687             `.Poly3DCollection` of the faces drawn for the voxel
2688             ``filled[i, j, k]``. If no faces were drawn for a given voxel,
2689             either because it was not asked to be drawn, or it is fully
2690             occluded, then ``(i, j, k) not in faces``.
2691 
2692         Examples
2693         --------
2694         .. plot:: gallery/mplot3d/voxels.py
2695         .. plot:: gallery/mplot3d/voxels_rgb.py
2696         .. plot:: gallery/mplot3d/voxels_torus.py
2697         .. plot:: gallery/mplot3d/voxels_numpy_logo.py
2698         """
2699 
2700         # work out which signature we should be using, and use it to parse
2701         # the arguments. Name must be voxels for the correct error message
2702         if len(args) >= 3:
2703             # underscores indicate position only
2704             def voxels(__x, __y, __z, filled, **kwargs):
2705                 return (__x, __y, __z), filled, kwargs
2706         else:
2707             def voxels(filled, **kwargs):
2708                 return None, filled, kwargs
2709 
2710         xyz, filled, kwargs = voxels(*args, **kwargs)
2711 
2712         # check dimensions
2713         if filled.ndim != 3:
2714             raise ValueError("Argument filled must be 3-dimensional")
2715         size = np.array(filled.shape, dtype=np.intp)
2716 
2717         # check xyz coordinates, which are one larger than the filled shape
2718         coord_shape = tuple(size + 1)
2719         if xyz is None:
2720             x, y, z = np.indices(coord_shape)
2721         else:
2722             x, y, z = (np.broadcast_to(c, coord_shape) for c in xyz)
2723 
2724         def _broadcast_color_arg(color, name):
2725             if np.ndim(color) in (0, 1):
2726                 # single color, like "red" or [1, 0, 0]
2727                 return np.broadcast_to(color, filled.shape + np.shape(color))
2728             elif np.ndim(color) in (3, 4):
2729                 # 3D array of strings, or 4D array with last axis rgb
2730                 if np.shape(color)[:3] != filled.shape:
2731                     raise ValueError(
2732                         f"When multidimensional, {name} must match the shape "
2733                         "of filled")
2734                 return color
2735             else:
2736                 raise ValueError(f"Invalid {name} argument")
2737 
2738         # broadcast and default on facecolors
2739         if facecolors is None:
2740             facecolors = self._get_patches_for_fill.get_next_color()
2741         facecolors = _broadcast_color_arg(facecolors, 'facecolors')
2742 
2743         # broadcast but no default on edgecolors
2744         edgecolors = _broadcast_color_arg(edgecolors, 'edgecolors')
2745 
2746         # scale to the full array, even if the data is only in the center
2747         self.auto_scale_xyz(x, y, z)
2748 
2749         # points lying on corners of a square
2750         square = np.array([
2751             [0, 0, 0],
2752             [1, 0, 0],
2753             [1, 1, 0],
2754             [0, 1, 0],
2755         ], dtype=np.intp)
2756 
2757         voxel_faces = defaultdict(list)
2758 
2759         def permutation_matrices(n):
2760             """Generate cyclic permutation matrices."""
2761             mat = np.eye(n, dtype=np.intp)
2762             for i in range(n):
2763                 yield mat
2764                 mat = np.roll(mat, 1, axis=0)
2765 
2766         # iterate over each of the YZ, ZX, and XY orientations, finding faces
2767         # to render
2768         for permute in permutation_matrices(3):
2769             # find the set of ranges to iterate over
2770             pc, qc, rc = permute.T.dot(size)
2771             pinds = np.arange(pc)
2772             qinds = np.arange(qc)
2773             rinds = np.arange(rc)
2774 
2775             square_rot_pos = square.dot(permute.T)
2776             square_rot_neg = square_rot_pos[::-1]
2777 
2778             # iterate within the current plane
2779             for p in pinds:
2780                 for q in qinds:
2781                     # iterate perpendicularly to the current plane, handling
2782                     # boundaries. We only draw faces between a voxel and an
2783                     # empty space, to avoid drawing internal faces.
2784 
2785                     # draw lower faces
2786                     p0 = permute.dot([p, q, 0])
2787                     i0 = tuple(p0)
2788                     if filled[i0]:
2789                         voxel_faces[i0].append(p0 + square_rot_neg)
2790 
2791                     # draw middle faces
2792                     for r1, r2 in zip(rinds[:-1], rinds[1:]):
2793                         p1 = permute.dot([p, q, r1])
2794                         p2 = permute.dot([p, q, r2])
2795 
2796                         i1 = tuple(p1)
2797                         i2 = tuple(p2)
2798 
2799                         if filled[i1] and not filled[i2]:
2800                             voxel_faces[i1].append(p2 + square_rot_pos)
2801                         elif not filled[i1] and filled[i2]:
2802                             voxel_faces[i2].append(p2 + square_rot_neg)
2803 
2804                     # draw upper faces
2805                     pk = permute.dot([p, q, rc-1])
2806                     pk2 = permute.dot([p, q, rc])
2807                     ik = tuple(pk)
2808                     if filled[ik]:
2809                         voxel_faces[ik].append(pk2 + square_rot_pos)
2810 
2811         # iterate over the faces, and generate a Poly3DCollection for each
2812         # voxel
2813         polygons = {}
2814         for coord, faces_inds in voxel_faces.items():
2815             # convert indices into 3D positions
2816             if xyz is None:
2817                 faces = faces_inds
2818             else:
2819                 faces = []
2820                 for face_inds in faces_inds:
2821                     ind = face_inds[:, 0], face_inds[:, 1], face_inds[:, 2]
2822                     face = np.empty(face_inds.shape)
2823                     face[:, 0] = x[ind]
2824                     face[:, 1] = y[ind]
2825                     face[:, 2] = z[ind]
2826                     faces.append(face)
2827 
2828             # shade the faces
2829             facecolor = facecolors[coord]
2830             edgecolor = edgecolors[coord]
2831 
2832             poly = art3d.Poly3DCollection(
2833                 faces, facecolors=facecolor, edgecolors=edgecolor,
2834                 shade=shade, lightsource=lightsource, **kwargs)
2835             self.add_collection3d(poly)
2836             polygons[coord] = poly
2837 
2838         return polygons
2839 
2840     @_preprocess_data(replace_names=["x", "y", "z", "xerr", "yerr", "zerr"])
2841     def errorbar(self, x, y, z, zerr=None, yerr=None, xerr=None, fmt='',
2842                  barsabove=False, errorevery=1, ecolor=None, elinewidth=None,
2843                  capsize=None, capthick=None, xlolims=False, xuplims=False,
2844                  ylolims=False, yuplims=False, zlolims=False, zuplims=False,
2845                  **kwargs):
2846         """
2847         Plot lines and/or markers with errorbars around them.
2848 
2849         *x*/*y*/*z* define the data locations, and *xerr*/*yerr*/*zerr* define
2850         the errorbar sizes. By default, this draws the data markers/lines as
2851         well the errorbars. Use fmt='none' to draw errorbars only.
2852 
2853         Parameters
2854         ----------
2855         x, y, z : float or array-like
2856             The data positions.
2857 
2858         xerr, yerr, zerr : float or array-like, shape (N,) or (2, N), optional
2859             The errorbar sizes:
2860 
2861             - scalar: Symmetric +/- values for all data points.
2862             - shape(N,): Symmetric +/-values for each data point.
2863             - shape(2, N): Separate - and + values for each bar. First row
2864               contains the lower errors, the second row contains the upper
2865               errors.
2866             - *None*: No errorbar.
2867 
2868             Note that all error arrays should have *positive* values.
2869 
2870         fmt : str, default: ''
2871             The format for the data points / data lines. See `.plot` for
2872             details.
2873 
2874             Use 'none' (case-insensitive) to plot errorbars without any data
2875             markers.
2876 
2877         ecolor : color, default: None
2878             The color of the errorbar lines.  If None, use the color of the
2879             line connecting the markers.
2880 
2881         elinewidth : float, default: None
2882             The linewidth of the errorbar lines. If None, the linewidth of
2883             the current style is used.
2884 
2885         capsize : float, default: :rc:`errorbar.capsize`
2886             The length of the error bar caps in points.
2887 
2888         capthick : float, default: None
2889             An alias to the keyword argument *markeredgewidth* (a.k.a. *mew*).
2890             This setting is a more sensible name for the property that
2891             controls the thickness of the error bar cap in points. For
2892             backwards compatibility, if *mew* or *markeredgewidth* are given,
2893             then they will over-ride *capthick*. This may change in future
2894             releases.
2895 
2896         barsabove : bool, default: False
2897             If True, will plot the errorbars above the plot
2898             symbols. Default is below.
2899 
2900         xlolims, ylolims, zlolims : bool, default: False
2901             These arguments can be used to indicate that a value gives only
2902             lower limits. In that case a caret symbol is used to indicate
2903             this. *lims*-arguments may be scalars, or array-likes of the same
2904             length as the errors. To use limits with inverted axes,
2905             `~.Axes.set_xlim` or `~.Axes.set_ylim` must be called before
2906             `errorbar`. Note the tricky parameter names: setting e.g.
2907             *ylolims* to True means that the y-value is a *lower* limit of the
2908             True value, so, only an *upward*-pointing arrow will be drawn!
2909 
2910         xuplims, yuplims, zuplims : bool, default: False
2911             Same as above, but for controlling the upper limits.
2912 
2913         errorevery : int or (int, int), default: 1
2914             draws error bars on a subset of the data. *errorevery* =N draws
2915             error bars on the points (x[::N], y[::N], z[::N]).
2916             *errorevery* =(start, N) draws error bars on the points
2917             (x[start::N], y[start::N], z[start::N]). e.g. *errorevery* =(6, 3)
2918             adds error bars to the data at (x[6], x[9], x[12], x[15], ...).
2919             Used to avoid overlapping error bars when two series share x-axis
2920             values.
2921 
2922         Returns
2923         -------
2924         errlines : list
2925             List of `~mpl_toolkits.mplot3d.art3d.Line3DCollection` instances
2926             each containing an errorbar line.
2927         caplines : list
2928             List of `~mpl_toolkits.mplot3d.art3d.Line3D` instances each
2929             containing a capline object.
2930         limmarks : list
2931             List of `~mpl_toolkits.mplot3d.art3d.Line3D` instances each
2932             containing a marker with an upper or lower limit.
2933 
2934         Other Parameters
2935         ----------------
2936         data : indexable object, optional
2937             DATA_PARAMETER_PLACEHOLDER
2938 
2939         **kwargs
2940             All other keyword arguments for styling errorbar lines are passed
2941             `~mpl_toolkits.mplot3d.art3d.Line3DCollection`.
2942 
2943         Examples
2944         --------
2945         .. plot:: gallery/mplot3d/errorbar3d.py
2946         """
2947         had_data = self.has_data()
2948 
2949         kwargs = cbook.normalize_kwargs(kwargs, mlines.Line2D)
2950         # Drop anything that comes in as None to use the default instead.
2951         kwargs = {k: v for k, v in kwargs.items() if v is not None}
2952         kwargs.setdefault('zorder', 2)
2953 
2954         self._process_unit_info([("x", x), ("y", y), ("z", z)], kwargs,
2955                                 convert=False)
2956 
2957         # make sure all the args are iterable; use lists not arrays to
2958         # preserve units
2959         x = x if np.iterable(x) else [x]
2960         y = y if np.iterable(y) else [y]
2961         z = z if np.iterable(z) else [z]
2962 
2963         if not len(x) == len(y) == len(z):
2964             raise ValueError("'x', 'y', and 'z' must have the same size")
2965 
2966         everymask = self._errorevery_to_mask(x, errorevery)
2967 
2968         label = kwargs.pop("label", None)
2969         kwargs['label'] = '_nolegend_'
2970 
2971         # Create the main line and determine overall kwargs for child artists.
2972         # We avoid calling self.plot() directly, or self._get_lines(), because
2973         # that would call self._process_unit_info again, and do other indirect
2974         # data processing.
2975         (data_line, base_style), = self._get_lines._plot_args(
2976             (x, y) if fmt == '' else (x, y, fmt), kwargs, return_kwargs=True)
2977         art3d.line_2d_to_3d(data_line, zs=z)
2978 
2979         # Do this after creating `data_line` to avoid modifying `base_style`.
2980         if barsabove:
2981             data_line.set_zorder(kwargs['zorder'] - .1)
2982         else:
2983             data_line.set_zorder(kwargs['zorder'] + .1)
2984 
2985         # Add line to plot, or throw it away and use it to determine kwargs.
2986         if fmt.lower() != 'none':
2987             self.add_line(data_line)
2988         else:
2989             data_line = None
2990             # Remove alpha=0 color that _process_plot_format returns.
2991             base_style.pop('color')
2992 
2993         if 'color' not in base_style:
2994             base_style['color'] = 'C0'
2995         if ecolor is None:
2996             ecolor = base_style['color']
2997 
2998         # Eject any line-specific information from format string, as it's not
2999         # needed for bars or caps.
3000         for key in ['marker', 'markersize', 'markerfacecolor',
3001                     'markeredgewidth', 'markeredgecolor', 'markevery',
3002                     'linestyle', 'fillstyle', 'drawstyle', 'dash_capstyle',
3003                     'dash_joinstyle', 'solid_capstyle', 'solid_joinstyle']:
3004             base_style.pop(key, None)
3005 
3006         # Make the style dict for the line collections (the bars).
3007         eb_lines_style = {**base_style, 'color': ecolor}
3008 
3009         if elinewidth:
3010             eb_lines_style['linewidth'] = elinewidth
3011         elif 'linewidth' in kwargs:
3012             eb_lines_style['linewidth'] = kwargs['linewidth']
3013 
3014         for key in ('transform', 'alpha', 'zorder', 'rasterized'):
3015             if key in kwargs:
3016                 eb_lines_style[key] = kwargs[key]
3017 
3018         # Make the style dict for caps (the "hats").
3019         eb_cap_style = {**base_style, 'linestyle': 'None'}
3020         if capsize is None:
3021             capsize = mpl.rcParams["errorbar.capsize"]
3022         if capsize > 0:
3023             eb_cap_style['markersize'] = 2. * capsize
3024         if capthick is not None:
3025             eb_cap_style['markeredgewidth'] = capthick
3026         eb_cap_style['color'] = ecolor
3027 
3028         def _apply_mask(arrays, mask):
3029             # Return, for each array in *arrays*, the elements for which *mask*
3030             # is True, without using fancy indexing.
3031             return [[*itertools.compress(array, mask)] for array in arrays]
3032 
3033         def _extract_errs(err, data, lomask, himask):
3034             # For separate +/- error values we need to unpack err
3035             if len(err.shape) == 2:
3036                 low_err, high_err = err
3037             else:
3038                 low_err, high_err = err, err
3039 
3040             lows = np.where(lomask | ~everymask, data, data - low_err)
3041             highs = np.where(himask | ~everymask, data, data + high_err)
3042 
3043             return lows, highs
3044 
3045         # collect drawn items while looping over the three coordinates
3046         errlines, caplines, limmarks = [], [], []
3047 
3048         # list of endpoint coordinates, used for auto-scaling
3049         coorderrs = []
3050 
3051         # define the markers used for errorbar caps and limits below
3052         # the dictionary key is mapped by the `i_xyz` helper dictionary
3053         capmarker = {0: '|', 1: '|', 2: '_'}
3054         i_xyz = {'x': 0, 'y': 1, 'z': 2}
3055 
3056         # Calculate marker size from points to quiver length. Because these are
3057         # not markers, and 3D Axes do not use the normal transform stack, this
3058         # is a bit involved. Since the quiver arrows will change size as the
3059         # scene is rotated, they are given a standard size based on viewing
3060         # them directly in planar form.
3061         quiversize = eb_cap_style.get('markersize',
3062                                       mpl.rcParams['lines.markersize']) ** 2
3063         quiversize *= self.figure.dpi / 72
3064         quiversize = self.transAxes.inverted().transform([
3065             (0, 0), (quiversize, quiversize)])
3066         quiversize = np.mean(np.diff(quiversize, axis=0))
3067         # quiversize is now in Axes coordinates, and to convert back to data
3068         # coordinates, we need to run it through the inverse 3D transform. For
3069         # consistency, this uses a fixed elevation, azimuth, and roll.
3070         with cbook._setattr_cm(self, elev=0, azim=0, roll=0):
3071             invM = np.linalg.inv(self.get_proj())
3072         # elev=azim=roll=0 produces the Y-Z plane, so quiversize in 2D 'x' is
3073         # 'y' in 3D, hence the 1 index.
3074         quiversize = np.dot(invM, [quiversize, 0, 0, 0])[1]
3075         # Quivers use a fixed 15-degree arrow head, so scale up the length so
3076         # that the size corresponds to the base. In other words, this constant
3077         # corresponds to the equation tan(15) = (base / 2) / (arrow length).
3078         quiversize *= 1.8660254037844388
3079         eb_quiver_style = {**eb_cap_style,
3080                            'length': quiversize, 'arrow_length_ratio': 1}
3081         eb_quiver_style.pop('markersize', None)
3082 
3083         # loop over x-, y-, and z-direction and draw relevant elements
3084         for zdir, data, err, lolims, uplims in zip(
3085                 ['x', 'y', 'z'], [x, y, z], [xerr, yerr, zerr],
3086                 [xlolims, ylolims, zlolims], [xuplims, yuplims, zuplims]):
3087 
3088             dir_vector = art3d.get_dir_vector(zdir)
3089             i_zdir = i_xyz[zdir]
3090 
3091             if err is None:
3092                 continue
3093 
3094             if not np.iterable(err):
3095                 err = [err] * len(data)
3096 
3097             err = np.atleast_1d(err)
3098 
3099             # arrays fine here, they are booleans and hence not units
3100             lolims = np.broadcast_to(lolims, len(data)).astype(bool)
3101             uplims = np.broadcast_to(uplims, len(data)).astype(bool)
3102 
3103             # a nested list structure that expands to (xl,xh),(yl,yh),(zl,zh),
3104             # where x/y/z and l/h correspond to dimensions and low/high
3105             # positions of errorbars in a dimension we're looping over
3106             coorderr = [
3107                 _extract_errs(err * dir_vector[i], coord, lolims, uplims)
3108                 for i, coord in enumerate([x, y, z])]
3109             (xl, xh), (yl, yh), (zl, zh) = coorderr
3110 
3111             # draws capmarkers - flat caps orthogonal to the error bars
3112             nolims = ~(lolims | uplims)
3113             if nolims.any() and capsize > 0:
3114                 lo_caps_xyz = _apply_mask([xl, yl, zl], nolims & everymask)
3115                 hi_caps_xyz = _apply_mask([xh, yh, zh], nolims & everymask)
3116 
3117                 # setting '_' for z-caps and '|' for x- and y-caps;
3118                 # these markers will rotate as the viewing angle changes
3119                 cap_lo = art3d.Line3D(*lo_caps_xyz, ls='',
3120                                       marker=capmarker[i_zdir],
3121                                       **eb_cap_style)
3122                 cap_hi = art3d.Line3D(*hi_caps_xyz, ls='',
3123                                       marker=capmarker[i_zdir],
3124                                       **eb_cap_style)
3125                 self.add_line(cap_lo)
3126                 self.add_line(cap_hi)
3127                 caplines.append(cap_lo)
3128                 caplines.append(cap_hi)
3129 
3130             if lolims.any():
3131                 xh0, yh0, zh0 = _apply_mask([xh, yh, zh], lolims & everymask)
3132                 self.quiver(xh0, yh0, zh0, *dir_vector, **eb_quiver_style)
3133             if uplims.any():
3134                 xl0, yl0, zl0 = _apply_mask([xl, yl, zl], uplims & everymask)
3135                 self.quiver(xl0, yl0, zl0, *-dir_vector, **eb_quiver_style)
3136 
3137             errline = art3d.Line3DCollection(np.array(coorderr).T,
3138                                              **eb_lines_style)
3139             self.add_collection(errline)
3140             errlines.append(errline)
3141             coorderrs.append(coorderr)
3142 
3143         coorderrs = np.array(coorderrs)
3144 
3145         def _digout_minmax(err_arr, coord_label):
3146             return (np.nanmin(err_arr[:, i_xyz[coord_label], :, :]),
3147                     np.nanmax(err_arr[:, i_xyz[coord_label], :, :]))
3148 
3149         minx, maxx = _digout_minmax(coorderrs, 'x')
3150         miny, maxy = _digout_minmax(coorderrs, 'y')
3151         minz, maxz = _digout_minmax(coorderrs, 'z')
3152         self.auto_scale_xyz((minx, maxx), (miny, maxy), (minz, maxz), had_data)
3153 
3154         # Adapting errorbar containers for 3d case, assuming z-axis points "up"
3155         errorbar_container = mcontainer.ErrorbarContainer(
3156             (data_line, tuple(caplines), tuple(errlines)),
3157             has_xerr=(xerr is not None or yerr is not None),
3158             has_yerr=(zerr is not None),
3159             label=label)
3160         self.containers.append(errorbar_container)
3161 
3162         return errlines, caplines, limmarks
3163 
3164     @_api.make_keyword_only("3.8", "call_axes_locator")
3165     def get_tightbbox(self, renderer=None, call_axes_locator=True,
3166                       bbox_extra_artists=None, *, for_layout_only=False):
3167         ret = super().get_tightbbox(renderer,
3168                                     call_axes_locator=call_axes_locator,
3169                                     bbox_extra_artists=bbox_extra_artists,
3170                                     for_layout_only=for_layout_only)
3171         batch = [ret]
3172         if self._axis3don:
3173             for axis in self._axis_map.values():
3174                 if axis.get_visible():
3175                     axis_bb = martist._get_tightbbox_for_layout_only(
3176                         axis, renderer)
3177                     if axis_bb:
3178                         batch.append(axis_bb)
3179         return mtransforms.Bbox.union(batch)
3180 
3181     @_preprocess_data()
3182     def stem(self, x, y, z, *, linefmt='C0-', markerfmt='C0o', basefmt='C3-',
3183              bottom=0, label=None, orientation='z'):
3184         """
3185         Create a 3D stem plot.
3186 
3187         A stem plot draws lines perpendicular to a baseline, and places markers
3188         at the heads. By default, the baseline is defined by *x* and *y*, and
3189         stems are drawn vertically from *bottom* to *z*.
3190 
3191         Parameters
3192         ----------
3193         x, y, z : array-like
3194             The positions of the heads of the stems. The stems are drawn along
3195             the *orientation*-direction from the baseline at *bottom* (in the
3196             *orientation*-coordinate) to the heads. By default, the *x* and *y*
3197             positions are used for the baseline and *z* for the head position,
3198             but this can be changed by *orientation*.
3199 
3200         linefmt : str, default: 'C0-'
3201             A string defining the properties of the vertical lines. Usually,
3202             this will be a color or a color and a linestyle:
3203 
3204             =========  =============
3205             Character  Line Style
3206             =========  =============
3207             ``'-'``    solid line
3208             ``'--'``   dashed line
3209             ``'-.'``   dash-dot line
3210             ``':'``    dotted line
3211             =========  =============
3212 
3213             Note: While it is technically possible to specify valid formats
3214             other than color or color and linestyle (e.g. 'rx' or '-.'), this
3215             is beyond the intention of the method and will most likely not
3216             result in a reasonable plot.
3217 
3218         markerfmt : str, default: 'C0o'
3219             A string defining the properties of the markers at the stem heads.
3220 
3221         basefmt : str, default: 'C3-'
3222             A format string defining the properties of the baseline.
3223 
3224         bottom : float, default: 0
3225             The position of the baseline, in *orientation*-coordinates.
3226 
3227         label : str, default: None
3228             The label to use for the stems in legends.
3229 
3230         orientation : {'x', 'y', 'z'}, default: 'z'
3231             The direction along which stems are drawn.
3232 
3233         data : indexable object, optional
3234             DATA_PARAMETER_PLACEHOLDER
3235 
3236         Returns
3237         -------
3238         `.StemContainer`
3239             The container may be treated like a tuple
3240             (*markerline*, *stemlines*, *baseline*)
3241 
3242         Examples
3243         --------
3244         .. plot:: gallery/mplot3d/stem3d_demo.py
3245         """
3246 
3247         from matplotlib.container import StemContainer
3248 
3249         had_data = self.has_data()
3250 
3251         _api.check_in_list(['x', 'y', 'z'], orientation=orientation)
3252 
3253         xlim = (np.min(x), np.max(x))
3254         ylim = (np.min(y), np.max(y))
3255         zlim = (np.min(z), np.max(z))
3256 
3257         # Determine the appropriate plane for the baseline and the direction of
3258         # stemlines based on the value of orientation.
3259         if orientation == 'x':
3260             basex, basexlim = y, ylim
3261             basey, baseylim = z, zlim
3262             lines = [[(bottom, thisy, thisz), (thisx, thisy, thisz)]
3263                      for thisx, thisy, thisz in zip(x, y, z)]
3264         elif orientation == 'y':
3265             basex, basexlim = x, xlim
3266             basey, baseylim = z, zlim
3267             lines = [[(thisx, bottom, thisz), (thisx, thisy, thisz)]
3268                      for thisx, thisy, thisz in zip(x, y, z)]
3269         else:
3270             basex, basexlim = x, xlim
3271             basey, baseylim = y, ylim
3272             lines = [[(thisx, thisy, bottom), (thisx, thisy, thisz)]
3273                      for thisx, thisy, thisz in zip(x, y, z)]
3274 
3275         # Determine style for stem lines.
3276         linestyle, linemarker, linecolor = _process_plot_format(linefmt)
3277         if linestyle is None:
3278             linestyle = mpl.rcParams['lines.linestyle']
3279 
3280         # Plot everything in required order.
3281         baseline, = self.plot(basex, basey, basefmt, zs=bottom,
3282                               zdir=orientation, label='_nolegend_')
3283         stemlines = art3d.Line3DCollection(
3284             lines, linestyles=linestyle, colors=linecolor, label='_nolegend_')
3285         self.add_collection(stemlines)
3286         markerline, = self.plot(x, y, z, markerfmt, label='_nolegend_')
3287 
3288         stem_container = StemContainer((markerline, stemlines, baseline),
3289                                        label=label)
3290         self.add_container(stem_container)
3291 
3292         jx, jy, jz = art3d.juggle_axes(basexlim, baseylim, [bottom, bottom],
3293                                        orientation)
3294         self.auto_scale_xyz([*jx, *xlim], [*jy, *ylim], [*jz, *zlim], had_data)
3295 
3296         return stem_container
3297 
3298     stem3D = stem

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>]
2025-10-18 14:27:39.137 | INFO     | Search completed. Bug locations: [<file>lib/matplotlib/axes/_base.py</file>
<class>_AxesBase</class>
<method>tick_params</method>
<code>
3307     def tick_params(self, axis='both', **kwargs):
3308         """
3309         Change the appearance of ticks, tick labels, and gridlines.
3310 
3311         Tick properties that are not explicitly set using the keyword
3312         arguments remain unchanged unless *reset* is True. For the current
3313         style settings, see `.Axis.get_tick_params`.
3314 
3315         Parameters
3316         ----------
3317         axis : {'x', 'y', 'both'}, default: 'both'
3318             The axis to which the parameters are applied.
3319         which : {'major', 'minor', 'both'}, default: 'major'
3320             The group of ticks to which the parameters are applied.
3321         reset : bool, default: False
3322             Whether to reset the ticks to defaults before updating them.
3323 
3324         Other Parameters
3325         ----------------
3326         direction : {'in', 'out', 'inout'}
3327             Puts ticks inside the Axes, outside the Axes, or both.
3328         length : float
3329             Tick length in points.
3330         width : float
3331             Tick width in points.
3332         color : color
3333             Tick color.
3334         pad : float
3335             Distance in points between tick and label.
3336         labelsize : float or str
3337             Tick label font size in points or as a string (e.g., 'large').
3338         labelcolor : color
3339             Tick label color.
3340         colors : color
3341             Tick color and label color.
3342         zorder : float
3343             Tick and label zorder.
3344         bottom, top, left, right : bool
3345             Whether to draw the respective ticks.
3346         labelbottom, labeltop, labelleft, labelright : bool
3347             Whether to draw the respective tick labels.
3348         labelrotation : float
3349             Tick label rotation
3350         grid_color : color
3351             Gridline color.
3352         grid_alpha : float
3353             Transparency of gridlines: 0 (transparent) to 1 (opaque).
3354         grid_linewidth : float
3355             Width of gridlines in points.
3356         grid_linestyle : str
3357             Any valid `.Line2D` line style spec.
3358 
3359         Examples
3360         --------
3361         ::
3362 
3363             ax.tick_params(direction='out', length=6, width=2, colors='r',
3364                            grid_color='r', grid_alpha=0.5)
3365 
3366         This will make all major ticks be red, pointing out of the box,
3367         and with dimensions 6 points by 2 points.  Tick labels will
3368         also be red.  Gridlines will be red and translucent.
3369 
3370         """
3371         _api.check_in_list(['x', 'y', 'both'], axis=axis)
3372         if axis in ['x', 'both']:
3373             xkw = dict(kwargs)
3374             xkw.pop('left', None)
3375             xkw.pop('right', None)
3376             xkw.pop('labelleft', None)
3377             xkw.pop('labelright', None)
3378             self.xaxis.set_tick_params(**xkw)
3379         if axis in ['y', 'both']:
3380             ykw = dict(kwargs)
3381             ykw.pop('top', None)
3382             ykw.pop('bottom', None)
3383             ykw.pop('labeltop', None)
3384             ykw.pop('labelbottom', None)
3385             self.yaxis.set_tick_params(**ykw)

</code><intended_behavior>Modify the `tick_params` method to include a `fontfamily` keyword argument. This argument should allow the user to specify the font family for the tick labels. When processing the `**kwargs` within `tick_params`, the method should apply the specified `fontfamily` to both the x-axis and y-axis tick labels, ensuring that if `fontfamily` is specified, it is respected and applied correctly to the ticks as specified by the `axis` argument. This enhancement must ensure backward compatibility, thus, if `fontfamily` is not specified, the default behavior (using the plot's or the system's default font family) remains unchanged.</intended_behavior>, <file>lib/matplotlib/axes/_base.py</file>
<class>_AxesBase</class>
<method>None</method>
<code>
548 class _AxesBase(martist.Artist):
549     name = "rectilinear"
550 
551     # axis names are the prefixes for the attributes that contain the
552     # respective axis; e.g. 'x' <-> self.xaxis, containing an XAxis.
553     # Note that PolarAxes uses these attributes as well, so that we have
554     # 'x' <-> self.xaxis, containing a ThetaAxis. In particular we do not
555     # have 'theta' in _axis_names.
556     # In practice, this is ('x', 'y') for all 2D Axes and ('x', 'y', 'z')
557     # for Axes3D.
558     _axis_names = ("x", "y")
559     _shared_axes = {name: cbook.Grouper() for name in _axis_names}
560     _twinned_axes = cbook.Grouper()
561 
562     _subclass_uses_cla = False
563 
564     @property
565     def _axis_map(self):
566         """A mapping of axis names, e.g. 'x', to `Axis` instances."""
567         return {name: getattr(self, f"{name}axis")
568                 for name in self._axis_names}
569 
570     def __str__(self):
571         return "{0}({1[0]:g},{1[1]:g};{1[2]:g}x{1[3]:g})".format(
572             type(self).__name__, self._position.bounds)
573 
574     def __init__(self, fig,
575                  *args,
576                  facecolor=None,  # defaults to rc axes.facecolor
577                  frameon=True,
578                  sharex=None,  # use Axes instance's xaxis info
579                  sharey=None,  # use Axes instance's yaxis info
580                  label='',
581                  xscale=None,
582                  yscale=None,
583                  box_aspect=None,
584                  **kwargs
585                  ):
586         """
587         Build an Axes in a figure.
588 
589         Parameters
590         ----------
591         fig : `~matplotlib.figure.Figure`
592             The Axes is built in the `.Figure` *fig*.
593 
594         *args
595             ``*args`` can be a single ``(left, bottom, width, height)``
596             rectangle or a single `.Bbox`.  This specifies the rectangle (in
597             figure coordinates) where the Axes is positioned.
598 
599             ``*args`` can also consist of three numbers or a single three-digit
600             number; in the latter case, the digits are considered as
601             independent numbers.  The numbers are interpreted as ``(nrows,
602             ncols, index)``: ``(nrows, ncols)`` specifies the size of an array
603             of subplots, and ``index`` is the 1-based index of the subplot
604             being created.  Finally, ``*args`` can also directly be a
605             `.SubplotSpec` instance.
606 
607         sharex, sharey : `~.axes.Axes`, optional
608             The x- or y-`~.matplotlib.axis` is shared with the x- or y-axis in
609             the input `~.axes.Axes`.
610 
611         frameon : bool, default: True
612             Whether the Axes frame is visible.
613 
614         box_aspect : float, optional
615             Set a fixed aspect for the Axes box, i.e. the ratio of height to
616             width. See `~.axes.Axes.set_box_aspect` for details.
617 
618         **kwargs
619             Other optional keyword arguments:
620 
621             %(Axes:kwdoc)s
622 
623         Returns
624         -------
625         `~.axes.Axes`
626             The new `~.axes.Axes` object.
627         """
628 
629         super().__init__()
630         if "rect" in kwargs:
631             if args:
632                 raise TypeError(
633                     "'rect' cannot be used together with positional arguments")
634             rect = kwargs.pop("rect")
635             _api.check_isinstance((mtransforms.Bbox, Iterable), rect=rect)
636             args = (rect,)
637         subplotspec = None
638         if len(args) == 1 and isinstance(args[0], mtransforms.Bbox):
639             self._position = args[0]
640         elif len(args) == 1 and np.iterable(args[0]):
641             self._position = mtransforms.Bbox.from_bounds(*args[0])
642         else:
643             self._position = self._originalPosition = mtransforms.Bbox.unit()
644             subplotspec = SubplotSpec._from_subplot_args(fig, args)
645         if self._position.width < 0 or self._position.height < 0:
646             raise ValueError('Width and height specified must be non-negative')
647         self._originalPosition = self._position.frozen()
648         self.axes = self
649         self._aspect = 'auto'
650         self._adjustable = 'box'
651         self._anchor = 'C'
652         self._stale_viewlims = {name: False for name in self._axis_names}
653         self._sharex = sharex
654         self._sharey = sharey
655         self.set_label(label)
656         self.set_figure(fig)
657         # The subplotspec needs to be set after the figure (so that
658         # figure-level subplotpars are taken into account), but the figure
659         # needs to be set after self._position is initialized.
660         if subplotspec:
661             self.set_subplotspec(subplotspec)
662         else:
663             self._subplotspec = None
664         self.set_box_aspect(box_aspect)
665         self._axes_locator = None  # Optionally set via update(kwargs).
666 
667         self._children = []
668 
669         # placeholder for any colorbars added that use this Axes.
670         # (see colorbar.py):
671         self._colorbars = []
672         self.spines = mspines.Spines.from_dict(self._gen_axes_spines())
673 
674         # this call may differ for non-sep axes, e.g., polar
675         self._init_axis()
676         if facecolor is None:
677             facecolor = mpl.rcParams['axes.facecolor']
678         self._facecolor = facecolor
679         self._frameon = frameon
680         self.set_axisbelow(mpl.rcParams['axes.axisbelow'])
681 
682         self._rasterization_zorder = None
683         self.clear()
684 
685         # funcs used to format x and y - fall back on major formatters
686         self.fmt_xdata = None
687         self.fmt_ydata = None
688 
689         self.set_navigate(True)
690         self.set_navigate_mode(None)
691 
692         if xscale:
693             self.set_xscale(xscale)
694         if yscale:
695             self.set_yscale(yscale)
696 
697         self._internal_update(kwargs)
698 
699         for name, axis in self._axis_map.items():
700             axis.callbacks._connect_picklable(
701                 'units', self._unit_change_handler(name))
702 
703         rcParams = mpl.rcParams
704         self.tick_params(
705             top=rcParams['xtick.top'] and rcParams['xtick.minor.top'],
706             bottom=rcParams['xtick.bottom'] and rcParams['xtick.minor.bottom'],
707             labeltop=(rcParams['xtick.labeltop'] and
708                       rcParams['xtick.minor.top']),
709             labelbottom=(rcParams['xtick.labelbottom'] and
710                          rcParams['xtick.minor.bottom']),
711             left=rcParams['ytick.left'] and rcParams['ytick.minor.left'],
712             right=rcParams['ytick.right'] and rcParams['ytick.minor.right'],
713             labelleft=(rcParams['ytick.labelleft'] and
714                        rcParams['ytick.minor.left']),
715             labelright=(rcParams['ytick.labelright'] and
716                         rcParams['ytick.minor.right']),
717             which='minor')
718 
719         self.tick_params(
720             top=rcParams['xtick.top'] and rcParams['xtick.major.top'],
721             bottom=rcParams['xtick.bottom'] and rcParams['xtick.major.bottom'],
722             labeltop=(rcParams['xtick.labeltop'] and
723                       rcParams['xtick.major.top']),
724             labelbottom=(rcParams['xtick.labelbottom'] and
725                          rcParams['xtick.major.bottom']),
726             left=rcParams['ytick.left'] and rcParams['ytick.major.left'],
727             right=rcParams['ytick.right'] and rcParams['ytick.major.right'],
728             labelleft=(rcParams['ytick.labelleft'] and
729                        rcParams['ytick.major.left']),
730             labelright=(rcParams['ytick.labelright'] and
731                         rcParams['ytick.major.right']),
732             which='major')
733 
734     def __init_subclass__(cls, **kwargs):
735         parent_uses_cla = super(cls, cls)._subclass_uses_cla
736         if 'cla' in cls.__dict__:
737             _api.warn_deprecated(
738                 '3.6',
739                 pending=True,
740                 message=f'Overriding `Axes.cla` in {cls.__qualname__} is '
741                 'pending deprecation in %(since)s and will be fully '
742                 'deprecated in favor of `Axes.clear` in the future. '
743                 'Please report '
744                 f'this to the {cls.__module__!r} author.')
745         cls._subclass_uses_cla = 'cla' in cls.__dict__ or parent_uses_cla
746         super().__init_subclass__(**kwargs)
747 
748     def __getstate__(self):
749         state = super().__getstate__()
750         # Prune the sharing & twinning info to only contain the current group.
751         state["_shared_axes"] = {
752             name: self._shared_axes[name].get_siblings(self)
753             for name in self._axis_names if self in self._shared_axes[name]}
754         state["_twinned_axes"] = (self._twinned_axes.get_siblings(self)
755                                   if self in self._twinned_axes else None)
756         return state
757 
758     def __setstate__(self, state):
759         # Merge the grouping info back into the global groupers.
760         shared_axes = state.pop("_shared_axes")
761         for name, shared_siblings in shared_axes.items():
762             self._shared_axes[name].join(*shared_siblings)
763         twinned_siblings = state.pop("_twinned_axes")
764         if twinned_siblings:
765             self._twinned_axes.join(*twinned_siblings)
766         self.__dict__ = state
767         self._stale = True
768 
769     def __repr__(self):
770         fields = []
771         if self.get_label():
772             fields += [f"label={self.get_label()!r}"]
773         if hasattr(self, "get_title"):
774             titles = {}
775             for k in ["left", "center", "right"]:
776                 title = self.get_title(loc=k)
777                 if title:
778                     titles[k] = title
779             if titles:
780                 fields += [f"title={titles}"]
781         for name, axis in self._axis_map.items():
782             if axis.get_label() and axis.get_label().get_text():
783                 fields += [f"{name}label={axis.get_label().get_text()!r}"]
784         return f"<{self.__class__.__name__}: " + ", ".join(fields) + ">"
785 
786     def get_subplotspec(self):
787         """Return the `.SubplotSpec` associated with the subplot, or None."""
788         return self._subplotspec
789 
790     def set_subplotspec(self, subplotspec):
791         """Set the `.SubplotSpec`. associated with the subplot."""
792         self._subplotspec = subplotspec
793         self._set_position(subplotspec.get_position(self.figure))
794 
795     def get_gridspec(self):
796         """Return the `.GridSpec` associated with the subplot, or None."""
797         return self._subplotspec.get_gridspec() if self._subplotspec else None
798 
799     def get_window_extent(self, renderer=None):
800         """
801         Return the Axes bounding box in display space.
802 
803         This bounding box does not include the spines, ticks, ticklabels,
804         or other labels.  For a bounding box including these elements use
805         `~matplotlib.axes.Axes.get_tightbbox`.
806 
807         See Also
808         --------
809         matplotlib.axes.Axes.get_tightbbox
810         matplotlib.axis.Axis.get_tightbbox
811         matplotlib.spines.Spine.get_window_extent
812         """
813         return self.bbox
814 
815     def _init_axis(self):
816         # This is moved out of __init__ because non-separable axes don't use it
817         self.xaxis = maxis.XAxis(self)
818         self.spines.bottom.register_axis(self.xaxis)
819         self.spines.top.register_axis(self.xaxis)
820         self.yaxis = maxis.YAxis(self)
821         self.spines.left.register_axis(self.yaxis)
822         self.spines.right.register_axis(self.yaxis)
823 
824     def set_figure(self, fig):
825         # docstring inherited
826         super().set_figure(fig)
827 
828         self.bbox = mtransforms.TransformedBbox(self._position,
829                                                 fig.transSubfigure)
830         # these will be updated later as data is added
831         self.dataLim = mtransforms.Bbox.null()
832         self._viewLim = mtransforms.Bbox.unit()
833         self.transScale = mtransforms.TransformWrapper(
834             mtransforms.IdentityTransform())
835 
836         self._set_lim_and_transforms()
837 
838     def _unstale_viewLim(self):
839         # We should arrange to store this information once per share-group
840         # instead of on every axis.
841         need_scale = {
842             name: any(ax._stale_viewlims[name]
843                       for ax in self._shared_axes[name].get_siblings(self))
844             for name in self._axis_names}
845         if any(need_scale.values()):
846             for name in need_scale:
847                 for ax in self._shared_axes[name].get_siblings(self):
848                     ax._stale_viewlims[name] = False
849             self.autoscale_view(**{f"scale{name}": scale
850                                    for name, scale in need_scale.items()})
851 
852     @property
853     def viewLim(self):
854         self._unstale_viewLim()
855         return self._viewLim
856 
857     def _request_autoscale_view(self, axis="all", tight=None):
858         """
859         Mark a single axis, or all of them, as stale wrt. autoscaling.
860 
861         No computation is performed until the next autoscaling; thus, separate
862         calls to control individual axises incur negligible performance cost.
863 
864         Parameters
865         ----------
866         axis : str, default: "all"
867             Either an element of ``self._axis_names``, or "all".
868         tight : bool or None, default: None
869         """
870         axis_names = _api.check_getitem(
871             {**{k: [k] for k in self._axis_names}, "all": self._axis_names},
872             axis=axis)
873         for name in axis_names:
874             self._stale_viewlims[name] = True
875         if tight is not None:
876             self._tight = tight
877 
878     def _set_lim_and_transforms(self):
879         """
880         Set the *_xaxis_transform*, *_yaxis_transform*, *transScale*,
881         *transData*, *transLimits* and *transAxes* transformations.
882 
883         .. note::
884 
885             This method is primarily used by rectilinear projections of the
886             `~matplotlib.axes.Axes` class, and is meant to be overridden by
887             new kinds of projection Axes that need different transformations
888             and limits. (See `~matplotlib.projections.polar.PolarAxes` for an
889             example.)
890         """
891         self.transAxes = mtransforms.BboxTransformTo(self.bbox)
892 
893         # Transforms the x and y axis separately by a scale factor.
894         # It is assumed that this part will have non-linear components
895         # (e.g., for a log scale).
896         self.transScale = mtransforms.TransformWrapper(
897             mtransforms.IdentityTransform())
898 
899         # An affine transformation on the data, generally to limit the
900         # range of the axes
901         self.transLimits = mtransforms.BboxTransformFrom(
902             mtransforms.TransformedBbox(self._viewLim, self.transScale))
903 
904         # The parentheses are important for efficiency here -- they
905         # group the last two (which are usually affines) separately
906         # from the first (which, with log-scaling can be non-affine).
907         self.transData = self.transScale + (self.transLimits + self.transAxes)
908 
909         self._xaxis_transform = mtransforms.blended_transform_factory(
910             self.transData, self.transAxes)
911         self._yaxis_transform = mtransforms.blended_transform_factory(
912             self.transAxes, self.transData)
913 
914     def get_xaxis_transform(self, which='grid'):
915         """
916         Get the transformation used for drawing x-axis labels, ticks
917         and gridlines.  The x-direction is in data coordinates and the
918         y-direction is in axis coordinates.
919 
920         .. note::
921 
922             This transformation is primarily used by the
923             `~matplotlib.axis.Axis` class, and is meant to be
924             overridden by new kinds of projections that may need to
925             place axis elements in different locations.
926 
927         Parameters
928         ----------
929         which : {'grid', 'tick1', 'tick2'}
930         """
931         if which == 'grid':
932             return self._xaxis_transform
933         elif which == 'tick1':
934             # for cartesian projection, this is bottom spine
935             return self.spines.bottom.get_spine_transform()
936         elif which == 'tick2':
937             # for cartesian projection, this is top spine
938             return self.spines.top.get_spine_transform()
939         else:
940             raise ValueError(f'unknown value for which: {which!r}')
941 
942     def get_xaxis_text1_transform(self, pad_points):
943         """
944         Returns
945         -------
946         transform : Transform
947             The transform used for drawing x-axis labels, which will add
948             *pad_points* of padding (in points) between the axis and the label.
949             The x-direction is in data coordinates and the y-direction is in
950             axis coordinates
951         valign : {'center', 'top', 'bottom', 'baseline', 'center_baseline'}
952             The text vertical alignment.
953         halign : {'center', 'left', 'right'}
954             The text horizontal alignment.
955 
956         Notes
957         -----
958         This transformation is primarily used by the `~matplotlib.axis.Axis`
959         class, and is meant to be overridden by new kinds of projections that
960         may need to place axis elements in different locations.
961         """
962         labels_align = mpl.rcParams["xtick.alignment"]
963         return (self.get_xaxis_transform(which='tick1') +
964                 mtransforms.ScaledTranslation(0, -1 * pad_points / 72,
965                                               self.figure.dpi_scale_trans),
966                 "top", labels_align)
967 
968     def get_xaxis_text2_transform(self, pad_points):
969         """
970         Returns
971         -------
972         transform : Transform
973             The transform used for drawing secondary x-axis labels, which will
974             add *pad_points* of padding (in points) between the axis and the
975             label.  The x-direction is in data coordinates and the y-direction
976             is in axis coordinates
977         valign : {'center', 'top', 'bottom', 'baseline', 'center_baseline'}
978             The text vertical alignment.
979         halign : {'center', 'left', 'right'}
980             The text horizontal alignment.
981 
982         Notes
983         -----
984         This transformation is primarily used by the `~matplotlib.axis.Axis`
985         class, and is meant to be overridden by new kinds of projections that
986         may need to place axis elements in different locations.
987         """
988         labels_align = mpl.rcParams["xtick.alignment"]
989         return (self.get_xaxis_transform(which='tick2') +
990                 mtransforms.ScaledTranslation(0, pad_points / 72,
991                                               self.figure.dpi_scale_trans),
992                 "bottom", labels_align)
993 
994     def get_yaxis_transform(self, which='grid'):
995         """
996         Get the transformation used for drawing y-axis labels, ticks
997         and gridlines.  The x-direction is in axis coordinates and the
998         y-direction is in data coordinates.
999 
1000         .. note::
1001 
1002             This transformation is primarily used by the
1003             `~matplotlib.axis.Axis` class, and is meant to be
1004             overridden by new kinds of projections that may need to
1005             place axis elements in different locations.
1006 
1007         Parameters
1008         ----------
1009         which : {'grid', 'tick1', 'tick2'}
1010         """
1011         if which == 'grid':
1012             return self._yaxis_transform
1013         elif which == 'tick1':
1014             # for cartesian projection, this is bottom spine
1015             return self.spines.left.get_spine_transform()
1016         elif which == 'tick2':
1017             # for cartesian projection, this is top spine
1018             return self.spines.right.get_spine_transform()
1019         else:
1020             raise ValueError(f'unknown value for which: {which!r}')
1021 
1022     def get_yaxis_text1_transform(self, pad_points):
1023         """
1024         Returns
1025         -------
1026         transform : Transform
1027             The transform used for drawing y-axis labels, which will add
1028             *pad_points* of padding (in points) between the axis and the label.
1029             The x-direction is in axis coordinates and the y-direction is in
1030             data coordinates
1031         valign : {'center', 'top', 'bottom', 'baseline', 'center_baseline'}
1032             The text vertical alignment.
1033         halign : {'center', 'left', 'right'}
1034             The text horizontal alignment.
1035 
1036         Notes
1037         -----
1038         This transformation is primarily used by the `~matplotlib.axis.Axis`
1039         class, and is meant to be overridden by new kinds of projections that
1040         may need to place axis elements in different locations.
1041         """
1042         labels_align = mpl.rcParams["ytick.alignment"]
1043         return (self.get_yaxis_transform(which='tick1') +
1044                 mtransforms.ScaledTranslation(-1 * pad_points / 72, 0,
1045                                               self.figure.dpi_scale_trans),
1046                 labels_align, "right")
1047 
1048     def get_yaxis_text2_transform(self, pad_points):
1049         """
1050         Returns
1051         -------
1052         transform : Transform
1053             The transform used for drawing secondart y-axis labels, which will
1054             add *pad_points* of padding (in points) between the axis and the
1055             label.  The x-direction is in axis coordinates and the y-direction
1056             is in data coordinates
1057         valign : {'center', 'top', 'bottom', 'baseline', 'center_baseline'}
1058             The text vertical alignment.
1059         halign : {'center', 'left', 'right'}
1060             The text horizontal alignment.
1061 
1062         Notes
1063         -----
1064         This transformation is primarily used by the `~matplotlib.axis.Axis`
1065         class, and is meant to be overridden by new kinds of projections that
1066         may need to place axis elements in different locations.
1067         """
1068         labels_align = mpl.rcParams["ytick.alignment"]
1069         return (self.get_yaxis_transform(which='tick2') +
1070                 mtransforms.ScaledTranslation(pad_points / 72, 0,
1071                                               self.figure.dpi_scale_trans),
1072                 labels_align, "left")
1073 
1074     def _update_transScale(self):
1075         self.transScale.set(
1076             mtransforms.blended_transform_factory(
1077                 self.xaxis.get_transform(), self.yaxis.get_transform()))
1078 
1079     def get_position(self, original=False):
1080         """
1081         Return the position of the Axes within the figure as a `.Bbox`.
1082 
1083         Parameters
1084         ----------
1085         original : bool
1086             If ``True``, return the original position. Otherwise, return the
1087             active position. For an explanation of the positions see
1088             `.set_position`.
1089 
1090         Returns
1091         -------
1092         `.Bbox`
1093 
1094         """
1095         if original:
1096             return self._originalPosition.frozen()
1097         else:
1098             locator = self.get_axes_locator()
1099             if not locator:
1100                 self.apply_aspect()
1101             return self._position.frozen()
1102 
1103     def set_position(self, pos, which='both'):
1104         """
1105         Set the Axes position.
1106 
1107         Axes have two position attributes. The 'original' position is the
1108         position allocated for the Axes. The 'active' position is the
1109         position the Axes is actually drawn at. These positions are usually
1110         the same unless a fixed aspect is set to the Axes. See
1111         `.Axes.set_aspect` for details.
1112 
1113         Parameters
1114         ----------
1115         pos : [left, bottom, width, height] or `~matplotlib.transforms.Bbox`
1116             The new position of the Axes in `.Figure` coordinates.
1117 
1118         which : {'both', 'active', 'original'}, default: 'both'
1119             Determines which position variables to change.
1120 
1121         See Also
1122         --------
1123         matplotlib.transforms.Bbox.from_bounds
1124         matplotlib.transforms.Bbox.from_extents
1125         """
1126         self._set_position(pos, which=which)
1127         # because this is being called externally to the library we
1128         # don't let it be in the layout.
1129         self.set_in_layout(False)
1130 
1131     def _set_position(self, pos, which='both'):
1132         """
1133         Private version of set_position.
1134 
1135         Call this internally to get the same functionality of `set_position`,
1136         but not to take the axis out of the constrained_layout hierarchy.
1137         """
1138         if not isinstance(pos, mtransforms.BboxBase):
1139             pos = mtransforms.Bbox.from_bounds(*pos)
1140         for ax in self._twinned_axes.get_siblings(self):
1141             if which in ('both', 'active'):
1142                 ax._position.set(pos)
1143             if which in ('both', 'original'):
1144                 ax._originalPosition.set(pos)
1145         self.stale = True
1146 
1147     def reset_position(self):
1148         """
1149         Reset the active position to the original position.
1150 
1151         This undoes changes to the active position (as defined in
1152         `.set_position`) which may have been performed to satisfy fixed-aspect
1153         constraints.
1154         """
1155         for ax in self._twinned_axes.get_siblings(self):
1156             pos = ax.get_position(original=True)
1157             ax.set_position(pos, which='active')
1158 
1159     def set_axes_locator(self, locator):
1160         """
1161         Set the Axes locator.
1162 
1163         Parameters
1164         ----------
1165         locator : Callable[[Axes, Renderer], Bbox]
1166         """
1167         self._axes_locator = locator
1168         self.stale = True
1169 
1170     def get_axes_locator(self):
1171         """
1172         Return the axes_locator.
1173         """
1174         return self._axes_locator
1175 
1176     def _set_artist_props(self, a):
1177         """Set the boilerplate props for artists added to Axes."""
1178         a.set_figure(self.figure)
1179         if not a.is_transform_set():
1180             a.set_transform(self.transData)
1181 
1182         a.axes = self
1183         if a.get_mouseover():
1184             self._mouseover_set.add(a)
1185 
1186     def _gen_axes_patch(self):
1187         """
1188         Returns
1189         -------
1190         Patch
1191             The patch used to draw the background of the Axes.  It is also used
1192             as the clipping path for any data elements on the Axes.
1193 
1194             In the standard Axes, this is a rectangle, but in other projections
1195             it may not be.
1196 
1197         Notes
1198         -----
1199         Intended to be overridden by new projection types.
1200         """
1201         return mpatches.Rectangle((0.0, 0.0), 1.0, 1.0)
1202 
1203     def _gen_axes_spines(self, locations=None, offset=0.0, units='inches'):
1204         """
1205         Returns
1206         -------
1207         dict
1208             Mapping of spine names to `.Line2D` or `.Patch` instances that are
1209             used to draw Axes spines.
1210 
1211             In the standard Axes, spines are single line segments, but in other
1212             projections they may not be.
1213 
1214         Notes
1215         -----
1216         Intended to be overridden by new projection types.
1217         """
1218         return {side: mspines.Spine.linear_spine(self, side)
1219                 for side in ['left', 'right', 'bottom', 'top']}
1220 
1221     def sharex(self, other):
1222         """
1223         Share the x-axis with *other*.
1224 
1225         This is equivalent to passing ``sharex=other`` when constructing the
1226         Axes, and cannot be used if the x-axis is already being shared with
1227         another Axes.
1228         """
1229         _api.check_isinstance(_AxesBase, other=other)
1230         if self._sharex is not None and other is not self._sharex:
1231             raise ValueError("x-axis is already shared")
1232         self._shared_axes["x"].join(self, other)
1233         self._sharex = other
1234         self.xaxis.major = other.xaxis.major  # Ticker instances holding
1235         self.xaxis.minor = other.xaxis.minor  # locator and formatter.
1236         x0, x1 = other.get_xlim()
1237         self.set_xlim(x0, x1, emit=False, auto=other.get_autoscalex_on())
1238         self.xaxis._scale = other.xaxis._scale
1239 
1240     def sharey(self, other):
1241         """
1242         Share the y-axis with *other*.
1243 
1244         This is equivalent to passing ``sharey=other`` when constructing the
1245         Axes, and cannot be used if the y-axis is already being shared with
1246         another Axes.
1247         """
1248         _api.check_isinstance(_AxesBase, other=other)
1249         if self._sharey is not None and other is not self._sharey:
1250             raise ValueError("y-axis is already shared")
1251         self._shared_axes["y"].join(self, other)
1252         self._sharey = other
1253         self.yaxis.major = other.yaxis.major  # Ticker instances holding
1254         self.yaxis.minor = other.yaxis.minor  # locator and formatter.
1255         y0, y1 = other.get_ylim()
1256         self.set_ylim(y0, y1, emit=False, auto=other.get_autoscaley_on())
1257         self.yaxis._scale = other.yaxis._scale
1258 
1259     def __clear(self):
1260         """Clear the Axes."""
1261         # The actual implementation of clear() as long as clear() has to be
1262         # an adapter delegating to the correct implementation.
1263         # The implementation can move back into clear() when the
1264         # deprecation on cla() subclassing expires.
1265 
1266         # stash the current visibility state
1267         if hasattr(self, 'patch'):
1268             patch_visible = self.patch.get_visible()
1269         else:
1270             patch_visible = True
1271 
1272         xaxis_visible = self.xaxis.get_visible()
1273         yaxis_visible = self.yaxis.get_visible()
1274 
1275         for axis in self._axis_map.values():
1276             axis.clear()  # Also resets the scale to linear.
1277         for spine in self.spines.values():
1278             spine.clear()
1279 
1280         self.ignore_existing_data_limits = True
1281         self.callbacks = cbook.CallbackRegistry(
1282             signals=["xlim_changed", "ylim_changed", "zlim_changed"])
1283 
1284         # update the minor locator for x and y axis based on rcParams
1285         if mpl.rcParams['xtick.minor.visible']:
1286             self.xaxis.set_minor_locator(mticker.AutoMinorLocator())
1287         if mpl.rcParams['ytick.minor.visible']:
1288             self.yaxis.set_minor_locator(mticker.AutoMinorLocator())
1289 
1290         self._xmargin = mpl.rcParams['axes.xmargin']
1291         self._ymargin = mpl.rcParams['axes.ymargin']
1292         self._tight = None
1293         self._use_sticky_edges = True
1294 
1295         self._get_lines = _process_plot_var_args(self)
1296         self._get_patches_for_fill = _process_plot_var_args(self, 'fill')
1297 
1298         self._gridOn = mpl.rcParams['axes.grid']
1299         old_children, self._children = self._children, []
1300         for chld in old_children:
1301             chld.axes = chld.figure = None
1302         self._mouseover_set = _OrderedSet()
1303         self.child_axes = []
1304         self._current_image = None  # strictly for pyplot via _sci, _gci
1305         self._projection_init = None  # strictly for pyplot.subplot
1306         self.legend_ = None
1307         self.containers = []
1308 
1309         self.grid(False)  # Disable grid on init to use rcParameter
1310         self.grid(self._gridOn, which=mpl.rcParams['axes.grid.which'],
1311                   axis=mpl.rcParams['axes.grid.axis'])
1312         props = font_manager.FontProperties(
1313             size=mpl.rcParams['axes.titlesize'],
1314             weight=mpl.rcParams['axes.titleweight'])
1315 
1316         y = mpl.rcParams['axes.titley']
1317         if y is None:
1318             y = 1.0
1319             self._autotitlepos = True
1320         else:
1321             self._autotitlepos = False
1322 
1323         self.title = mtext.Text(
1324             x=0.5, y=y, text='',
1325             fontproperties=props,
1326             verticalalignment='baseline',
1327             horizontalalignment='center',
1328             )
1329         self._left_title = mtext.Text(
1330             x=0.0, y=y, text='',
1331             fontproperties=props.copy(),
1332             verticalalignment='baseline',
1333             horizontalalignment='left', )
1334         self._right_title = mtext.Text(
1335             x=1.0, y=y, text='',
1336             fontproperties=props.copy(),
1337             verticalalignment='baseline',
1338             horizontalalignment='right',
1339             )
1340         title_offset_points = mpl.rcParams['axes.titlepad']
1341         # refactor this out so it can be called in ax.set_title if
1342         # pad argument used...
1343         self._set_title_offset_trans(title_offset_points)
1344 
1345         for _title in (self.title, self._left_title, self._right_title):
1346             self._set_artist_props(_title)
1347 
1348         # The patch draws the background of the Axes.  We want this to be below
1349         # the other artists.  We use the frame to draw the edges so we are
1350         # setting the edgecolor to None.
1351         self.patch = self._gen_axes_patch()
1352         self.patch.set_figure(self.figure)
1353         self.patch.set_facecolor(self._facecolor)
1354         self.patch.set_edgecolor('none')
1355         self.patch.set_linewidth(0)
1356         self.patch.set_transform(self.transAxes)
1357 
1358         self.set_axis_on()
1359 
1360         self.xaxis.set_clip_path(self.patch)
1361         self.yaxis.set_clip_path(self.patch)
1362 
1363         if self._sharex is not None:
1364             self.xaxis.set_visible(xaxis_visible)
1365             self.patch.set_visible(patch_visible)
1366         if self._sharey is not None:
1367             self.yaxis.set_visible(yaxis_visible)
1368             self.patch.set_visible(patch_visible)
1369 
1370         # This comes last, as the call to _set_lim may trigger an autoscale (in
1371         # case of shared axes), requiring children to be already set up.
1372         for name, axis in self._axis_map.items():
1373             share = getattr(self, f"_share{name}")
1374             if share is not None:
1375                 getattr(self, f"share{name}")(share)
1376             else:
1377                 axis._set_scale("linear")
1378                 axis._set_lim(0, 1, auto=True)
1379         self._update_transScale()
1380 
1381         self.stale = True
1382 
1383     def clear(self):
1384         """Clear the Axes."""
1385         # Act as an alias, or as the superclass implementation depending on the
1386         # subclass implementation.
1387         if self._subclass_uses_cla:
1388             self.cla()
1389         else:
1390             self.__clear()
1391 
1392     def cla(self):
1393         """Clear the Axes."""
1394         # Act as an alias, or as the superclass implementation depending on the
1395         # subclass implementation.
1396         if self._subclass_uses_cla:
1397             self.__clear()
1398         else:
1399             self.clear()
1400 
1401     class ArtistList(Sequence):
1402         """
1403         A sublist of Axes children based on their type.
1404 
1405         The type-specific children sublists were made immutable in Matplotlib
1406         3.7.  In the future these artist lists may be replaced by tuples. Use
1407         as if this is a tuple already.
1408         """
1409         def __init__(self, axes, prop_name,
1410                      valid_types=None, invalid_types=None):
1411             """
1412             Parameters
1413             ----------
1414             axes : `~matplotlib.axes.Axes`
1415                 The Axes from which this sublist will pull the children
1416                 Artists.
1417             prop_name : str
1418                 The property name used to access this sublist from the Axes;
1419                 used to generate deprecation warnings.
1420             valid_types : list of type, optional
1421                 A list of types that determine which children will be returned
1422                 by this sublist. If specified, then the Artists in the sublist
1423                 must be instances of any of these types. If unspecified, then
1424                 any type of Artist is valid (unless limited by
1425                 *invalid_types*.)
1426             invalid_types : tuple, optional
1427                 A list of types that determine which children will *not* be
1428                 returned by this sublist. If specified, then Artists in the
1429                 sublist will never be an instance of these types. Otherwise, no
1430                 types will be excluded.
1431             """
1432             self._axes = axes
1433             self._prop_name = prop_name
1434             self._type_check = lambda artist: (
1435                 (not valid_types or isinstance(artist, valid_types)) and
1436                 (not invalid_types or not isinstance(artist, invalid_types))
1437             )
1438 
1439         def __repr__(self):
1440             return f'<Axes.ArtistList of {len(self)} {self._prop_name}>'
1441 
1442         def __len__(self):
1443             return sum(self._type_check(artist)
1444                        for artist in self._axes._children)
1445 
1446         def __iter__(self):
1447             for artist in list(self._axes._children):
1448                 if self._type_check(artist):
1449                     yield artist
1450 
1451         def __getitem__(self, key):
1452             return [artist
1453                     for artist in self._axes._children
1454                     if self._type_check(artist)][key]
1455 
1456         def __add__(self, other):
1457             if isinstance(other, (list, _AxesBase.ArtistList)):
1458                 return [*self, *other]
1459             if isinstance(other, (tuple, _AxesBase.ArtistList)):
1460                 return (*self, *other)
1461             return NotImplemented
1462 
1463         def __radd__(self, other):
1464             if isinstance(other, list):
1465                 return other + list(self)
1466             if isinstance(other, tuple):
1467                 return other + tuple(self)
1468             return NotImplemented
1469 
1470     @property
1471     def artists(self):
1472         return self.ArtistList(self, 'artists', invalid_types=(
1473             mcoll.Collection, mimage.AxesImage, mlines.Line2D, mpatches.Patch,
1474             mtable.Table, mtext.Text))
1475 
1476     @property
1477     def collections(self):
1478         return self.ArtistList(self, 'collections',
1479                                valid_types=mcoll.Collection)
1480 
1481     @property
1482     def images(self):
1483         return self.ArtistList(self, 'images', valid_types=mimage.AxesImage)
1484 
1485     @property
1486     def lines(self):
1487         return self.ArtistList(self, 'lines', valid_types=mlines.Line2D)
1488 
1489     @property
1490     def patches(self):
1491         return self.ArtistList(self, 'patches', valid_types=mpatches.Patch)
1492 
1493     @property
1494     def tables(self):
1495         return self.ArtistList(self, 'tables', valid_types=mtable.Table)
1496 
1497     @property
1498     def texts(self):
1499         return self.ArtistList(self, 'texts', valid_types=mtext.Text)
1500 
1501     def get_facecolor(self):
1502         """Get the facecolor of the Axes."""
1503         return self.patch.get_facecolor()
1504 
1505     def set_facecolor(self, color):
1506         """
1507         Set the facecolor of the Axes.
1508 
1509         Parameters
1510         ----------
1511         color : color
1512         """
1513         self._facecolor = color
1514         self.stale = True
1515         return self.patch.set_facecolor(color)
1516 
1517     def _set_title_offset_trans(self, title_offset_points):
1518         """
1519         Set the offset for the title either from :rc:`axes.titlepad`
1520         or from set_title kwarg ``pad``.
1521         """
1522         self.titleOffsetTrans = mtransforms.ScaledTranslation(
1523                 0.0, title_offset_points / 72,
1524                 self.figure.dpi_scale_trans)
1525         for _title in (self.title, self._left_title, self._right_title):
1526             _title.set_transform(self.transAxes + self.titleOffsetTrans)
1527             _title.set_clip_box(None)
1528 
1529     def set_prop_cycle(self, *args, **kwargs):
1530         """
1531         Set the property cycle of the Axes.
1532 
1533         The property cycle controls the style properties such as color,
1534         marker and linestyle of future plot commands. The style properties
1535         of data already added to the Axes are not modified.
1536 
1537         Call signatures::
1538 
1539           set_prop_cycle(cycler)
1540           set_prop_cycle(label=values[, label2=values2[, ...]])
1541           set_prop_cycle(label, values)
1542 
1543         Form 1 sets given `~cycler.Cycler` object.
1544 
1545         Form 2 creates a `~cycler.Cycler` which cycles over one or more
1546         properties simultaneously and set it as the property cycle of the
1547         Axes. If multiple properties are given, their value lists must have
1548         the same length. This is just a shortcut for explicitly creating a
1549         cycler and passing it to the function, i.e. it's short for
1550         ``set_prop_cycle(cycler(label=values label2=values2, ...))``.
1551 
1552         Form 3 creates a `~cycler.Cycler` for a single property and set it
1553         as the property cycle of the Axes. This form exists for compatibility
1554         with the original `cycler.cycler` interface. Its use is discouraged
1555         in favor of the kwarg form, i.e. ``set_prop_cycle(label=values)``.
1556 
1557         Parameters
1558         ----------
1559         cycler : Cycler
1560             Set the given Cycler. *None* resets to the cycle defined by the
1561             current style.
1562 
1563         label : str
1564             The property key. Must be a valid `.Artist` property.
1565             For example, 'color' or 'linestyle'. Aliases are allowed,
1566             such as 'c' for 'color' and 'lw' for 'linewidth'.
1567 
1568         values : iterable
1569             Finite-length iterable of the property values. These values
1570             are validated and will raise a ValueError if invalid.
1571 
1572         See Also
1573         --------
1574         matplotlib.rcsetup.cycler
1575             Convenience function for creating validated cyclers for properties.
1576         cycler.cycler
1577             The original function for creating unvalidated cyclers.
1578 
1579         Examples
1580         --------
1581         Setting the property cycle for a single property:
1582 
1583         >>> ax.set_prop_cycle(color=['red', 'green', 'blue'])
1584 
1585         Setting the property cycle for simultaneously cycling over multiple
1586         properties (e.g. red circle, green plus, blue cross):
1587 
1588         >>> ax.set_prop_cycle(color=['red', 'green', 'blue'],
1589         ...                   marker=['o', '+', 'x'])
1590 
1591         """
1592         if args and kwargs:
1593             raise TypeError("Cannot supply both positional and keyword "
1594                             "arguments to this method.")
1595         # Can't do `args == (None,)` as that crashes cycler.
1596         if len(args) == 1 and args[0] is None:
1597             prop_cycle = None
1598         else:
1599             prop_cycle = cycler(*args, **kwargs)
1600         self._get_lines.set_prop_cycle(prop_cycle)
1601         self._get_patches_for_fill.set_prop_cycle(prop_cycle)
1602 
1603     def get_aspect(self):
1604         """
1605         Return the aspect ratio of the axes scaling.
1606 
1607         This is either "auto" or a float giving the ratio of y/x-scale.
1608         """
1609         return self._aspect
1610 
1611     def set_aspect(self, aspect, adjustable=None, anchor=None, share=False):
1612         """
1613         Set the aspect ratio of the axes scaling, i.e. y/x-scale.
1614 
1615         Parameters
1616         ----------
1617         aspect : {'auto', 'equal'} or float
1618             Possible values:
1619 
1620             - 'auto': fill the position rectangle with data.
1621             - 'equal': same as ``aspect=1``, i.e. same scaling for x and y.
1622             - *float*: The displayed size of 1 unit in y-data coordinates will
1623               be *aspect* times the displayed size of 1 unit in x-data
1624               coordinates; e.g. for ``aspect=2`` a square in data coordinates
1625               will be rendered with a height of twice its width.
1626 
1627         adjustable : None or {'box', 'datalim'}, optional
1628             If not ``None``, this defines which parameter will be adjusted to
1629             meet the required aspect. See `.set_adjustable` for further
1630             details.
1631 
1632         anchor : None or str or (float, float), optional
1633             If not ``None``, this defines where the Axes will be drawn if there
1634             is extra space due to aspect constraints. The most common way
1635             to specify the anchor are abbreviations of cardinal directions:
1636 
1637             =====   =====================
1638             value   description
1639             =====   =====================
1640             'C'     centered
1641             'SW'    lower left corner
1642             'S'     middle of bottom edge
1643             'SE'    lower right corner
1644             etc.
1645             =====   =====================
1646 
1647             See `~.Axes.set_anchor` for further details.
1648 
1649         share : bool, default: False
1650             If ``True``, apply the settings to all shared Axes.
1651 
1652         See Also
1653         --------
1654         matplotlib.axes.Axes.set_adjustable
1655             Set how the Axes adjusts to achieve the required aspect ratio.
1656         matplotlib.axes.Axes.set_anchor
1657             Set the position in case of extra space.
1658         """
1659         if cbook._str_equal(aspect, 'equal'):
1660             aspect = 1
1661         if not cbook._str_equal(aspect, 'auto'):
1662             aspect = float(aspect)  # raise ValueError if necessary
1663             if aspect <= 0 or not np.isfinite(aspect):
1664                 raise ValueError("aspect must be finite and positive ")
1665 
1666         if share:
1667             axes = {sibling for name in self._axis_names
1668                     for sibling in self._shared_axes[name].get_siblings(self)}
1669         else:
1670             axes = [self]
1671 
1672         for ax in axes:
1673             ax._aspect = aspect
1674 
1675         if adjustable is None:
1676             adjustable = self._adjustable
1677         self.set_adjustable(adjustable, share=share)  # Handle sharing.
1678 
1679         if anchor is not None:
1680             self.set_anchor(anchor, share=share)
1681         self.stale = True
1682 
1683     def get_adjustable(self):
1684         """
1685         Return whether the Axes will adjust its physical dimension ('box') or
1686         its data limits ('datalim') to achieve the desired aspect ratio.
1687 
1688         See Also
1689         --------
1690         matplotlib.axes.Axes.set_adjustable
1691             Set how the Axes adjusts to achieve the required aspect ratio.
1692         matplotlib.axes.Axes.set_aspect
1693             For a description of aspect handling.
1694         """
1695         return self._adjustable
1696 
1697     def set_adjustable(self, adjustable, share=False):
1698         """
1699         Set how the Axes adjusts to achieve the required aspect ratio.
1700 
1701         Parameters
1702         ----------
1703         adjustable : {'box', 'datalim'}
1704             If 'box', change the physical dimensions of the Axes.
1705             If 'datalim', change the ``x`` or ``y`` data limits.
1706 
1707         share : bool, default: False
1708             If ``True``, apply the settings to all shared Axes.
1709 
1710         See Also
1711         --------
1712         matplotlib.axes.Axes.set_aspect
1713             For a description of aspect handling.
1714 
1715         Notes
1716         -----
1717         Shared Axes (of which twinned Axes are a special case)
1718         impose restrictions on how aspect ratios can be imposed.
1719         For twinned Axes, use 'datalim'.  For Axes that share both
1720         x and y, use 'box'.  Otherwise, either 'datalim' or 'box'
1721         may be used.  These limitations are partly a requirement
1722         to avoid over-specification, and partly a result of the
1723         particular implementation we are currently using, in
1724         which the adjustments for aspect ratios are done sequentially
1725         and independently on each Axes as it is drawn.
1726         """
1727         _api.check_in_list(["box", "datalim"], adjustable=adjustable)
1728         if share:
1729             axs = {sibling for name in self._axis_names
1730                    for sibling in self._shared_axes[name].get_siblings(self)}
1731         else:
1732             axs = [self]
1733         if (adjustable == "datalim"
1734                 and any(getattr(ax.get_data_ratio, "__func__", None)
1735                         != _AxesBase.get_data_ratio
1736                         for ax in axs)):
1737             # Limits adjustment by apply_aspect assumes that the axes' aspect
1738             # ratio can be computed from the data limits and scales.
1739             raise ValueError("Cannot set Axes adjustable to 'datalim' for "
1740                              "Axes which override 'get_data_ratio'")
1741         for ax in axs:
1742             ax._adjustable = adjustable
1743         self.stale = True
1744 
1745     def get_box_aspect(self):
1746         """
1747         Return the Axes box aspect, i.e. the ratio of height to width.
1748 
1749         The box aspect is ``None`` (i.e. chosen depending on the available
1750         figure space) unless explicitly specified.
1751 
1752         See Also
1753         --------
1754         matplotlib.axes.Axes.set_box_aspect
1755             for a description of box aspect.
1756         matplotlib.axes.Axes.set_aspect
1757             for a description of aspect handling.
1758         """
1759         return self._box_aspect
1760 
1761     def set_box_aspect(self, aspect=None):
1762         """
1763         Set the Axes box aspect, i.e. the ratio of height to width.
1764 
1765         This defines the aspect of the Axes in figure space and is not to be
1766         confused with the data aspect (see `~.Axes.set_aspect`).
1767 
1768         Parameters
1769         ----------
1770         aspect : float or None
1771             Changes the physical dimensions of the Axes, such that the ratio
1772             of the Axes height to the Axes width in physical units is equal to
1773             *aspect*. Defining a box aspect will change the *adjustable*
1774             property to 'datalim' (see `~.Axes.set_adjustable`).
1775 
1776             *None* will disable a fixed box aspect so that height and width
1777             of the Axes are chosen independently.
1778 
1779         See Also
1780         --------
1781         matplotlib.axes.Axes.set_aspect
1782             for a description of aspect handling.
1783         """
1784         axs = {*self._twinned_axes.get_siblings(self),
1785                *self._twinned_axes.get_siblings(self)}
1786 
1787         if aspect is not None:
1788             aspect = float(aspect)
1789             # when box_aspect is set to other than ´None`,
1790             # adjustable must be "datalim"
1791             for ax in axs:
1792                 ax.set_adjustable("datalim")
1793 
1794         for ax in axs:
1795             ax._box_aspect = aspect
1796             ax.stale = True
1797 
1798     def get_anchor(self):
1799         """
1800         Get the anchor location.
1801 
1802         See Also
1803         --------
1804         matplotlib.axes.Axes.set_anchor
1805             for a description of the anchor.
1806         matplotlib.axes.Axes.set_aspect
1807             for a description of aspect handling.
1808         """
1809         return self._anchor
1810 
1811     def set_anchor(self, anchor, share=False):
1812         """
1813         Define the anchor location.
1814 
1815         The actual drawing area (active position) of the Axes may be smaller
1816         than the Bbox (original position) when a fixed aspect is required. The
1817         anchor defines where the drawing area will be located within the
1818         available space.
1819 
1820         Parameters
1821         ----------
1822         anchor : (float, float) or {'C', 'SW', 'S', 'SE', 'E', 'NE', ...}
1823             Either an (*x*, *y*) pair of relative coordinates (0 is left or
1824             bottom, 1 is right or top), 'C' (center), or a cardinal direction
1825             ('SW', southwest, is bottom left, etc.).  str inputs are shorthands
1826             for (*x*, *y*) coordinates, as shown in the following diagram::
1827 
1828                ┌─────────────────┬─────────────────┬─────────────────┐
1829                │ 'NW' (0.0, 1.0) │ 'N' (0.5, 1.0)  │ 'NE' (1.0, 1.0) │
1830                ├─────────────────┼─────────────────┼─────────────────┤
1831                │ 'W'  (0.0, 0.5) │ 'C' (0.5, 0.5)  │ 'E'  (1.0, 0.5) │
1832                ├─────────────────┼─────────────────┼─────────────────┤
1833                │ 'SW' (0.0, 0.0) │ 'S' (0.5, 0.0)  │ 'SE' (1.0, 0.0) │
1834                └─────────────────┴─────────────────┴─────────────────┘
1835 
1836         share : bool, default: False
1837             If ``True``, apply the settings to all shared Axes.
1838 
1839         See Also
1840         --------
1841         matplotlib.axes.Axes.set_aspect
1842             for a description of aspect handling.
1843         """
1844         if not (anchor in mtransforms.Bbox.coefs or len(anchor) == 2):
1845             raise ValueError('argument must be among %s' %
1846                              ', '.join(mtransforms.Bbox.coefs))
1847         if share:
1848             axes = {sibling for name in self._axis_names
1849                     for sibling in self._shared_axes[name].get_siblings(self)}
1850         else:
1851             axes = [self]
1852         for ax in axes:
1853             ax._anchor = anchor
1854 
1855         self.stale = True
1856 
1857     def get_data_ratio(self):
1858         """
1859         Return the aspect ratio of the scaled data.
1860 
1861         Notes
1862         -----
1863         This method is intended to be overridden by new projection types.
1864         """
1865         txmin, txmax = self.xaxis.get_transform().transform(self.get_xbound())
1866         tymin, tymax = self.yaxis.get_transform().transform(self.get_ybound())
1867         xsize = max(abs(txmax - txmin), 1e-30)
1868         ysize = max(abs(tymax - tymin), 1e-30)
1869         return ysize / xsize
1870 
1871     def apply_aspect(self, position=None):
1872         """
1873         Adjust the Axes for a specified data aspect ratio.
1874 
1875         Depending on `.get_adjustable` this will modify either the
1876         Axes box (position) or the view limits. In the former case,
1877         `~matplotlib.axes.Axes.get_anchor` will affect the position.
1878 
1879         Parameters
1880         ----------
1881         position : None or .Bbox
1882             If not ``None``, this defines the position of the
1883             Axes within the figure as a Bbox. See `~.Axes.get_position`
1884             for further details.
1885 
1886         Notes
1887         -----
1888         This is called automatically when each Axes is drawn.  You may need
1889         to call it yourself if you need to update the Axes position and/or
1890         view limits before the Figure is drawn.
1891 
1892         See Also
1893         --------
1894         matplotlib.axes.Axes.set_aspect
1895             For a description of aspect ratio handling.
1896         matplotlib.axes.Axes.set_adjustable
1897             Set how the Axes adjusts to achieve the required aspect ratio.
1898         matplotlib.axes.Axes.set_anchor
1899             Set the position in case of extra space.
1900         """
1901         if position is None:
1902             position = self.get_position(original=True)
1903 
1904         aspect = self.get_aspect()
1905 
1906         if aspect == 'auto' and self._box_aspect is None:
1907             self._set_position(position, which='active')
1908             return
1909 
1910         trans = self.get_figure().transSubfigure
1911         bb = mtransforms.Bbox.unit().transformed(trans)
1912         # this is the physical aspect of the panel (or figure):
1913         fig_aspect = bb.height / bb.width
1914 
1915         if self._adjustable == 'box':
1916             if self in self._twinned_axes:
1917                 raise RuntimeError("Adjustable 'box' is not allowed in a "
1918                                    "twinned Axes; use 'datalim' instead")
1919             box_aspect = aspect * self.get_data_ratio()
1920             pb = position.frozen()
1921             pb1 = pb.shrunk_to_aspect(box_aspect, pb, fig_aspect)
1922             self._set_position(pb1.anchored(self.get_anchor(), pb), 'active')
1923             return
1924 
1925         # The following is only seen if self._adjustable == 'datalim'
1926         if self._box_aspect is not None:
1927             pb = position.frozen()
1928             pb1 = pb.shrunk_to_aspect(self._box_aspect, pb, fig_aspect)
1929             self._set_position(pb1.anchored(self.get_anchor(), pb), 'active')
1930             if aspect == "auto":
1931                 return
1932 
1933         # reset active to original in case it had been changed by prior use
1934         # of 'box'
1935         if self._box_aspect is None:
1936             self._set_position(position, which='active')
1937         else:
1938             position = pb1.anchored(self.get_anchor(), pb)
1939 
1940         x_trf = self.xaxis.get_transform()
1941         y_trf = self.yaxis.get_transform()
1942         xmin, xmax = x_trf.transform(self.get_xbound())
1943         ymin, ymax = y_trf.transform(self.get_ybound())
1944         xsize = max(abs(xmax - xmin), 1e-30)
1945         ysize = max(abs(ymax - ymin), 1e-30)
1946 
1947         box_aspect = fig_aspect * (position.height / position.width)
1948         data_ratio = box_aspect / aspect
1949 
1950         y_expander = data_ratio * xsize / ysize - 1
1951         # If y_expander > 0, the dy/dx viewLim ratio needs to increase
1952         if abs(y_expander) < 0.005:
1953             return
1954 
1955         dL = self.dataLim
1956         x0, x1 = x_trf.transform(dL.intervalx)
1957         y0, y1 = y_trf.transform(dL.intervaly)
1958         xr = 1.05 * (x1 - x0)
1959         yr = 1.05 * (y1 - y0)
1960 
1961         xmarg = xsize - xr
1962         ymarg = ysize - yr
1963         Ysize = data_ratio * xsize
1964         Xsize = ysize / data_ratio
1965         Xmarg = Xsize - xr
1966         Ymarg = Ysize - yr
1967         # Setting these targets to, e.g., 0.05*xr does not seem to help.
1968         xm = 0
1969         ym = 0
1970 
1971         shared_x = self in self._shared_axes["x"]
1972         shared_y = self in self._shared_axes["y"]
1973 
1974         if shared_x and shared_y:
1975             raise RuntimeError("set_aspect(..., adjustable='datalim') or "
1976                                "axis('equal') are not allowed when both axes "
1977                                "are shared.  Try set_aspect(..., "
1978                                "adjustable='box').")
1979 
1980         # If y is shared, then we are only allowed to change x, etc.
1981         if shared_y:
1982             adjust_y = False
1983         else:
1984             if xmarg > xm and ymarg > ym:
1985                 adjy = ((Ymarg > 0 and y_expander < 0) or
1986                         (Xmarg < 0 and y_expander > 0))
1987             else:
1988                 adjy = y_expander > 0
1989             adjust_y = shared_x or adjy  # (Ymarg > xmarg)
1990 
1991         if adjust_y:
1992             yc = 0.5 * (ymin + ymax)
1993             y0 = yc - Ysize / 2.0
1994             y1 = yc + Ysize / 2.0
1995             self.set_ybound(y_trf.inverted().transform([y0, y1]))
1996         else:
1997             xc = 0.5 * (xmin + xmax)
1998             x0 = xc - Xsize / 2.0
1999             x1 = xc + Xsize / 2.0
2000             self.set_xbound(x_trf.inverted().transform([x0, x1]))
2001 
2002     def axis(self, arg=None, /, *, emit=True, **kwargs):
2003         """
2004         Convenience method to get or set some axis properties.
2005 
2006         Call signatures::
2007 
2008           xmin, xmax, ymin, ymax = axis()
2009           xmin, xmax, ymin, ymax = axis([xmin, xmax, ymin, ymax])
2010           xmin, xmax, ymin, ymax = axis(option)
2011           xmin, xmax, ymin, ymax = axis(**kwargs)
2012 
2013         Parameters
2014         ----------
2015         xmin, xmax, ymin, ymax : float, optional
2016             The axis limits to be set.  This can also be achieved using ::
2017 
2018                 ax.set(xlim=(xmin, xmax), ylim=(ymin, ymax))
2019 
2020         option : bool or str
2021             If a bool, turns axis lines and labels on or off. If a string,
2022             possible values are:
2023 
2024             ======== ==========================================================
2025             Value    Description
2026             ======== ==========================================================
2027             'on'     Turn on axis lines and labels. Same as ``True``.
2028             'off'    Turn off axis lines and labels. Same as ``False``.
2029             'equal'  Set equal scaling (i.e., make circles circular) by
2030                      changing axis limits. This is the same as
2031                      ``ax.set_aspect('equal', adjustable='datalim')``.
2032                      Explicit data limits may not be respected in this case.
2033             'scaled' Set equal scaling (i.e., make circles circular) by
2034                      changing dimensions of the plot box. This is the same as
2035                      ``ax.set_aspect('equal', adjustable='box', anchor='C')``.
2036                      Additionally, further autoscaling will be disabled.
2037             'tight'  Set limits just large enough to show all data, then
2038                      disable further autoscaling.
2039             'auto'   Automatic scaling (fill plot box with data).
2040             'image'  'scaled' with axis limits equal to data limits.
2041             'square' Square plot; similar to 'scaled', but initially forcing
2042                      ``xmax-xmin == ymax-ymin``.
2043             ======== ==========================================================
2044 
2045         emit : bool, default: True
2046             Whether observers are notified of the axis limit change.
2047             This option is passed on to `~.Axes.set_xlim` and
2048             `~.Axes.set_ylim`.
2049 
2050         Returns
2051         -------
2052         xmin, xmax, ymin, ymax : float
2053             The axis limits.
2054 
2055         See Also
2056         --------
2057         matplotlib.axes.Axes.set_xlim
2058         matplotlib.axes.Axes.set_ylim
2059         """
2060         if isinstance(arg, (str, bool)):
2061             if arg is True:
2062                 arg = 'on'
2063             if arg is False:
2064                 arg = 'off'
2065             arg = arg.lower()
2066             if arg == 'on':
2067                 self.set_axis_on()
2068             elif arg == 'off':
2069                 self.set_axis_off()
2070             elif arg in [
2071                     'equal', 'tight', 'scaled', 'auto', 'image', 'square']:
2072                 self.set_autoscale_on(True)
2073                 self.set_aspect('auto')
2074                 self.autoscale_view(tight=False)
2075                 if arg == 'equal':
2076                     self.set_aspect('equal', adjustable='datalim')
2077                 elif arg == 'scaled':
2078                     self.set_aspect('equal', adjustable='box', anchor='C')
2079                     self.set_autoscale_on(False)  # Req. by Mark Bakker
2080                 elif arg == 'tight':
2081                     self.autoscale_view(tight=True)
2082                     self.set_autoscale_on(False)
2083                 elif arg == 'image':
2084                     self.autoscale_view(tight=True)
2085                     self.set_autoscale_on(False)
2086                     self.set_aspect('equal', adjustable='box', anchor='C')
2087                 elif arg == 'square':
2088                     self.set_aspect('equal', adjustable='box', anchor='C')
2089                     self.set_autoscale_on(False)
2090                     xlim = self.get_xlim()
2091                     ylim = self.get_ylim()
2092                     edge_size = max(np.diff(xlim), np.diff(ylim))[0]
2093                     self.set_xlim([xlim[0], xlim[0] + edge_size],
2094                                   emit=emit, auto=False)
2095                     self.set_ylim([ylim[0], ylim[0] + edge_size],
2096                                   emit=emit, auto=False)
2097             else:
2098                 raise ValueError(f"Unrecognized string {arg!r} to axis; "
2099                                  "try 'on' or 'off'")
2100         else:
2101             if arg is not None:
2102                 try:
2103                     xmin, xmax, ymin, ymax = arg
2104                 except (TypeError, ValueError) as err:
2105                     raise TypeError('the first argument to axis() must be an '
2106                                     'iterable of the form '
2107                                     '[xmin, xmax, ymin, ymax]') from err
2108             else:
2109                 xmin = kwargs.pop('xmin', None)
2110                 xmax = kwargs.pop('xmax', None)
2111                 ymin = kwargs.pop('ymin', None)
2112                 ymax = kwargs.pop('ymax', None)
2113             xauto = (None  # Keep autoscale state as is.
2114                      if xmin is None and xmax is None
2115                      else False)  # Turn off autoscale.
2116             yauto = (None
2117                      if ymin is None and ymax is None
2118                      else False)
2119             self.set_xlim(xmin, xmax, emit=emit, auto=xauto)
2120             self.set_ylim(ymin, ymax, emit=emit, auto=yauto)
2121         if kwargs:
2122             raise _api.kwarg_error("axis", kwargs)
2123         return (*self.get_xlim(), *self.get_ylim())
2124 
2125     def get_legend(self):
2126         """Return the `.Legend` instance, or None if no legend is defined."""
2127         return self.legend_
2128 
2129     def get_images(self):
2130         r"""Return a list of `.AxesImage`\s contained by the Axes."""
2131         return cbook.silent_list('AxesImage', self.images)
2132 
2133     def get_lines(self):
2134         """Return a list of lines contained by the Axes."""
2135         return cbook.silent_list('Line2D', self.lines)
2136 
2137     def get_xaxis(self):
2138         """
2139         [*Discouraged*] Return the XAxis instance.
2140 
2141         .. admonition:: Discouraged
2142 
2143             The use of this function is discouraged. You should instead
2144             directly access the attribute ``ax.xaxis``.
2145         """
2146         return self.xaxis
2147 
2148     def get_yaxis(self):
2149         """
2150         [*Discouraged*] Return the YAxis instance.
2151 
2152         .. admonition:: Discouraged
2153 
2154             The use of this function is discouraged. You should instead
2155             directly access the attribute ``ax.yaxis``.
2156         """
2157         return self.yaxis
2158 
2159     get_xgridlines = _axis_method_wrapper("xaxis", "get_gridlines")
2160     get_xticklines = _axis_method_wrapper("xaxis", "get_ticklines")
2161     get_ygridlines = _axis_method_wrapper("yaxis", "get_gridlines")
2162     get_yticklines = _axis_method_wrapper("yaxis", "get_ticklines")
2163 
2164     # Adding and tracking artists
2165 
2166     def _sci(self, im):
2167         """
2168         Set the current image.
2169 
2170         This image will be the target of colormap functions like
2171         ``pyplot.viridis``, and other functions such as `~.pyplot.clim`.  The
2172         current image is an attribute of the current Axes.
2173         """
2174         _api.check_isinstance(
2175             (mpl.contour.ContourSet, mcoll.Collection, mimage.AxesImage),
2176             im=im)
2177         if isinstance(im, mpl.contour.ContourSet):
2178             if im.collections[0] not in self._children:
2179                 raise ValueError("ContourSet must be in current Axes")
2180         elif im not in self._children:
2181             raise ValueError("Argument must be an image, collection, or "
2182                              "ContourSet in this Axes")
2183         self._current_image = im
2184 
2185     def _gci(self):
2186         """Helper for `~matplotlib.pyplot.gci`; do not use elsewhere."""
2187         return self._current_image
2188 
2189     def has_data(self):
2190         """
2191         Return whether any artists have been added to the Axes.
2192 
2193         This should not be used to determine whether the *dataLim*
2194         need to be updated, and may not actually be useful for
2195         anything.
2196         """
2197         return any(isinstance(a, (mcoll.Collection, mimage.AxesImage,
2198                                   mlines.Line2D, mpatches.Patch))
2199                    for a in self._children)
2200 
2201     def add_artist(self, a):
2202         """
2203         Add an `.Artist` to the Axes; return the artist.
2204 
2205         Use `add_artist` only for artists for which there is no dedicated
2206         "add" method; and if necessary, use a method such as `update_datalim`
2207         to manually update the dataLim if the artist is to be included in
2208         autoscaling.
2209 
2210         If no ``transform`` has been specified when creating the artist (e.g.
2211         ``artist.get_transform() == None``) then the transform is set to
2212         ``ax.transData``.
2213         """
2214         a.axes = self
2215         self._children.append(a)
2216         a._remove_method = self._children.remove
2217         self._set_artist_props(a)
2218         if a.get_clip_path() is None:
2219             a.set_clip_path(self.patch)
2220         self.stale = True
2221         return a
2222 
2223     def add_child_axes(self, ax):
2224         """
2225         Add an `.AxesBase` to the Axes' children; return the child Axes.
2226 
2227         This is the lowlevel version.  See `.axes.Axes.inset_axes`.
2228         """
2229 
2230         # normally Axes have themselves as the Axes, but these need to have
2231         # their parent...
2232         # Need to bypass the getter...
2233         ax._axes = self
2234         ax.stale_callback = martist._stale_axes_callback
2235 
2236         self.child_axes.append(ax)
2237         ax._remove_method = self.child_axes.remove
2238         self.stale = True
2239         return ax
2240 
2241     def add_collection(self, collection, autolim=True):
2242         """
2243         Add a `.Collection` to the Axes; return the collection.
2244         """
2245         _api.check_isinstance(mcoll.Collection, collection=collection)
2246         label = collection.get_label()
2247         if not label:
2248             collection.set_label(f'_child{len(self._children)}')
2249         self._children.append(collection)
2250         collection._remove_method = self._children.remove
2251         self._set_artist_props(collection)
2252 
2253         if collection.get_clip_path() is None:
2254             collection.set_clip_path(self.patch)
2255 
2256         if autolim:
2257             # Make sure viewLim is not stale (mostly to match
2258             # pre-lazy-autoscale behavior, which is not really better).
2259             self._unstale_viewLim()
2260             datalim = collection.get_datalim(self.transData)
2261             points = datalim.get_points()
2262             if not np.isinf(datalim.minpos).all():
2263                 # By definition, if minpos (minimum positive value) is set
2264                 # (i.e., non-inf), then min(points) <= minpos <= max(points),
2265                 # and minpos would be superfluous. However, we add minpos to
2266                 # the call so that self.dataLim will update its own minpos.
2267                 # This ensures that log scales see the correct minimum.
2268                 points = np.concatenate([points, [datalim.minpos]])
2269             self.update_datalim(points)
2270 
2271         self.stale = True
2272         return collection
2273 
2274     def add_image(self, image):
2275         """
2276         Add an `.AxesImage` to the Axes; return the image.
2277         """
2278         _api.check_isinstance(mimage.AxesImage, image=image)
2279         self._set_artist_props(image)
2280         if not image.get_label():
2281             image.set_label(f'_child{len(self._children)}')
2282         self._children.append(image)
2283         image._remove_method = self._children.remove
2284         self.stale = True
2285         return image
2286 
2287     def _update_image_limits(self, image):
2288         xmin, xmax, ymin, ymax = image.get_extent()
2289         self.axes.update_datalim(((xmin, ymin), (xmax, ymax)))
2290 
2291     def add_line(self, line):
2292         """
2293         Add a `.Line2D` to the Axes; return the line.
2294         """
2295         _api.check_isinstance(mlines.Line2D, line=line)
2296         self._set_artist_props(line)
2297         if line.get_clip_path() is None:
2298             line.set_clip_path(self.patch)
2299 
2300         self._update_line_limits(line)
2301         if not line.get_label():
2302             line.set_label(f'_child{len(self._children)}')
2303         self._children.append(line)
2304         line._remove_method = self._children.remove
2305         self.stale = True
2306         return line
2307 
2308     def _add_text(self, txt):
2309         """
2310         Add a `.Text` to the Axes; return the text.
2311         """
2312         _api.check_isinstance(mtext.Text, txt=txt)
2313         self._set_artist_props(txt)
2314         self._children.append(txt)
2315         txt._remove_method = self._children.remove
2316         self.stale = True
2317         return txt
2318 
2319     def _update_line_limits(self, line):
2320         """
2321         Figures out the data limit of the given line, updating self.dataLim.
2322         """
2323         path = line.get_path()
2324         if path.vertices.size == 0:
2325             return
2326 
2327         line_trf = line.get_transform()
2328 
2329         if line_trf == self.transData:
2330             data_path = path
2331         elif any(line_trf.contains_branch_seperately(self.transData)):
2332             # Compute the transform from line coordinates to data coordinates.
2333             trf_to_data = line_trf - self.transData
2334             # If transData is affine we can use the cached non-affine component
2335             # of line's path (since the non-affine part of line_trf is
2336             # entirely encapsulated in trf_to_data).
2337             if self.transData.is_affine:
2338                 line_trans_path = line._get_transformed_path()
2339                 na_path, _ = line_trans_path.get_transformed_path_and_affine()
2340                 data_path = trf_to_data.transform_path_affine(na_path)
2341             else:
2342                 data_path = trf_to_data.transform_path(path)
2343         else:
2344             # For backwards compatibility we update the dataLim with the
2345             # coordinate range of the given path, even though the coordinate
2346             # systems are completely different. This may occur in situations
2347             # such as when ax.transAxes is passed through for absolute
2348             # positioning.
2349             data_path = path
2350 
2351         if not data_path.vertices.size:
2352             return
2353 
2354         updatex, updatey = line_trf.contains_branch_seperately(self.transData)
2355         if self.name != "rectilinear":
2356             # This block is mostly intended to handle axvline in polar plots,
2357             # for which updatey would otherwise be True.
2358             if updatex and line_trf == self.get_yaxis_transform():
2359                 updatex = False
2360             if updatey and line_trf == self.get_xaxis_transform():
2361                 updatey = False
2362         self.dataLim.update_from_path(data_path,
2363                                       self.ignore_existing_data_limits,
2364                                       updatex=updatex, updatey=updatey)
2365         self.ignore_existing_data_limits = False
2366 
2367     def add_patch(self, p):
2368         """
2369         Add a `.Patch` to the Axes; return the patch.
2370         """
2371         _api.check_isinstance(mpatches.Patch, p=p)
2372         self._set_artist_props(p)
2373         if p.get_clip_path() is None:
2374             p.set_clip_path(self.patch)
2375         self._update_patch_limits(p)
2376         self._children.append(p)
2377         p._remove_method = self._children.remove
2378         return p
2379 
2380     def _update_patch_limits(self, patch):
2381         """Update the data limits for the given patch."""
2382         # hist can add zero height Rectangles, which is useful to keep
2383         # the bins, counts and patches lined up, but it throws off log
2384         # scaling.  We'll ignore rects with zero height or width in
2385         # the auto-scaling
2386 
2387         # cannot check for '==0' since unitized data may not compare to zero
2388         # issue #2150 - we update the limits if patch has non zero width
2389         # or height.
2390         if (isinstance(patch, mpatches.Rectangle) and
2391                 ((not patch.get_width()) and (not patch.get_height()))):
2392             return
2393         p = patch.get_path()
2394         # Get all vertices on the path
2395         # Loop through each segment to get extrema for Bezier curve sections
2396         vertices = []
2397         for curve, code in p.iter_bezier(simplify=False):
2398             # Get distance along the curve of any extrema
2399             _, dzeros = curve.axis_aligned_extrema()
2400             # Calculate vertices of start, end and any extrema in between
2401             vertices.append(curve([0, *dzeros, 1]))
2402 
2403         if len(vertices):
2404             vertices = np.row_stack(vertices)
2405 
2406         patch_trf = patch.get_transform()
2407         updatex, updatey = patch_trf.contains_branch_seperately(self.transData)
2408         if not (updatex or updatey):
2409             return
2410         if self.name != "rectilinear":
2411             # As in _update_line_limits, but for axvspan.
2412             if updatex and patch_trf == self.get_yaxis_transform():
2413                 updatex = False
2414             if updatey and patch_trf == self.get_xaxis_transform():
2415                 updatey = False
2416         trf_to_data = patch_trf - self.transData
2417         xys = trf_to_data.transform(vertices)
2418         self.update_datalim(xys, updatex=updatex, updatey=updatey)
2419 
2420     def add_table(self, tab):
2421         """
2422         Add a `.Table` to the Axes; return the table.
2423         """
2424         _api.check_isinstance(mtable.Table, tab=tab)
2425         self._set_artist_props(tab)
2426         self._children.append(tab)
2427         if tab.get_clip_path() is None:
2428             tab.set_clip_path(self.patch)
2429         tab._remove_method = self._children.remove
2430         return tab
2431 
2432     def add_container(self, container):
2433         """
2434         Add a `.Container` to the Axes' containers; return the container.
2435         """
2436         label = container.get_label()
2437         if not label:
2438             container.set_label('_container%d' % len(self.containers))
2439         self.containers.append(container)
2440         container._remove_method = self.containers.remove
2441         return container
2442 
2443     def _unit_change_handler(self, axis_name, event=None):
2444         """
2445         Process axis units changes: requests updates to data and view limits.
2446         """
2447         if event is None:  # Allow connecting `self._unit_change_handler(name)`
2448             return functools.partial(
2449                 self._unit_change_handler, axis_name, event=object())
2450         _api.check_in_list(self._axis_map, axis_name=axis_name)
2451         for line in self.lines:
2452             line.recache_always()
2453         self.relim()
2454         self._request_autoscale_view(axis_name)
2455 
2456     def relim(self, visible_only=False):
2457         """
2458         Recompute the data limits based on current artists.
2459 
2460         At present, `.Collection` instances are not supported.
2461 
2462         Parameters
2463         ----------
2464         visible_only : bool, default: False
2465             Whether to exclude invisible artists.
2466         """
2467         # Collections are deliberately not supported (yet); see
2468         # the TODO note in artists.py.
2469         self.dataLim.ignore(True)
2470         self.dataLim.set_points(mtransforms.Bbox.null().get_points())
2471         self.ignore_existing_data_limits = True
2472 
2473         for artist in self._children:
2474             if not visible_only or artist.get_visible():
2475                 if isinstance(artist, mlines.Line2D):
2476                     self._update_line_limits(artist)
2477                 elif isinstance(artist, mpatches.Patch):
2478                     self._update_patch_limits(artist)
2479                 elif isinstance(artist, mimage.AxesImage):
2480                     self._update_image_limits(artist)
2481 
2482     def update_datalim(self, xys, updatex=True, updatey=True):
2483         """
2484         Extend the `~.Axes.dataLim` Bbox to include the given points.
2485 
2486         If no data is set currently, the Bbox will ignore its limits and set
2487         the bound to be the bounds of the xydata (*xys*). Otherwise, it will
2488         compute the bounds of the union of its current data and the data in
2489         *xys*.
2490 
2491         Parameters
2492         ----------
2493         xys : 2D array-like
2494             The points to include in the data limits Bbox. This can be either
2495             a list of (x, y) tuples or a (N, 2) array.
2496 
2497         updatex, updatey : bool, default: True
2498             Whether to update the x/y limits.
2499         """
2500         xys = np.asarray(xys)
2501         if not np.any(np.isfinite(xys)):
2502             return
2503         self.dataLim.update_from_data_xy(xys, self.ignore_existing_data_limits,
2504                                          updatex=updatex, updatey=updatey)
2505         self.ignore_existing_data_limits = False
2506 
2507     def _process_unit_info(self, datasets=None, kwargs=None, *, convert=True):
2508         """
2509         Set axis units based on *datasets* and *kwargs*, and optionally apply
2510         unit conversions to *datasets*.
2511 
2512         Parameters
2513         ----------
2514         datasets : list
2515             List of (axis_name, dataset) pairs (where the axis name is defined
2516             as in `._axis_map`).  Individual datasets can also be None
2517             (which gets passed through).
2518         kwargs : dict
2519             Other parameters from which unit info (i.e., the *xunits*,
2520             *yunits*, *zunits* (for 3D Axes), *runits* and *thetaunits* (for
2521             polar) entries) is popped, if present.  Note that this dict is
2522             mutated in-place!
2523         convert : bool, default: True
2524             Whether to return the original datasets or the converted ones.
2525 
2526         Returns
2527         -------
2528         list
2529             Either the original datasets if *convert* is False, or the
2530             converted ones if *convert* is True (the default).
2531         """
2532         # The API makes datasets a list of pairs rather than an axis_name to
2533         # dataset mapping because it is sometimes necessary to process multiple
2534         # datasets for a single axis, and concatenating them may be tricky
2535         # (e.g. if some are scalars, etc.).
2536         datasets = datasets or []
2537         kwargs = kwargs or {}
2538         axis_map = self._axis_map
2539         for axis_name, data in datasets:
2540             try:
2541                 axis = axis_map[axis_name]
2542             except KeyError:
2543                 raise ValueError(f"Invalid axis name: {axis_name!r}") from None
2544             # Update from data if axis is already set but no unit is set yet.
2545             if axis is not None and data is not None and not axis.have_units():
2546                 axis.update_units(data)
2547         for axis_name, axis in axis_map.items():
2548             # Return if no axis is set.
2549             if axis is None:
2550                 continue
2551             # Check for units in the kwargs, and if present update axis.
2552             units = kwargs.pop(f"{axis_name}units", axis.units)
2553             if self.name == "polar":
2554                 # Special case: polar supports "thetaunits"/"runits".
2555                 polar_units = {"x": "thetaunits", "y": "runits"}
2556                 units = kwargs.pop(polar_units[axis_name], units)
2557             if units != axis.units and units is not None:
2558                 axis.set_units(units)
2559                 # If the units being set imply a different converter,
2560                 # we need to update again.
2561                 for dataset_axis_name, data in datasets:
2562                     if dataset_axis_name == axis_name and data is not None:
2563                         axis.update_units(data)
2564         return [axis_map[axis_name].convert_units(data)
2565                 if convert and data is not None else data
2566                 for axis_name, data in datasets]
2567 
2568     def in_axes(self, mouseevent):
2569         """
2570         Return whether the given event (in display coords) is in the Axes.
2571         """
2572         return self.patch.contains(mouseevent)[0]
2573 
2574     get_autoscalex_on = _axis_method_wrapper("xaxis", "_get_autoscale_on")
2575     get_autoscaley_on = _axis_method_wrapper("yaxis", "_get_autoscale_on")
2576     set_autoscalex_on = _axis_method_wrapper("xaxis", "_set_autoscale_on")
2577     set_autoscaley_on = _axis_method_wrapper("yaxis", "_set_autoscale_on")
2578 
2579     def get_autoscale_on(self):
2580         """Return True if each axis is autoscaled, False otherwise."""
2581         return all(axis._get_autoscale_on()
2582                    for axis in self._axis_map.values())
2583 
2584     def set_autoscale_on(self, b):
2585         """
2586         Set whether autoscaling is applied to each axis on the next draw or
2587         call to `.Axes.autoscale_view`.
2588 
2589         Parameters
2590         ----------
2591         b : bool
2592         """
2593         for axis in self._axis_map.values():
2594             axis._set_autoscale_on(b)
2595 
2596     @property
2597     def use_sticky_edges(self):
2598         """
2599         When autoscaling, whether to obey all `Artist.sticky_edges`.
2600 
2601         Default is ``True``.
2602 
2603         Setting this to ``False`` ensures that the specified margins
2604         will be applied, even if the plot includes an image, for
2605         example, which would otherwise force a view limit to coincide
2606         with its data limit.
2607 
2608         The changing this property does not change the plot until
2609         `autoscale` or `autoscale_view` is called.
2610         """
2611         return self._use_sticky_edges
2612 
2613     @use_sticky_edges.setter
2614     def use_sticky_edges(self, b):
2615         self._use_sticky_edges = bool(b)
2616         # No effect until next autoscaling, which will mark the Axes as stale.
2617 
2618     def set_xmargin(self, m):
2619         """
2620         Set padding of X data limits prior to autoscaling.
2621 
2622         *m* times the data interval will be added to each end of that interval
2623         before it is used in autoscaling.  If *m* is negative, this will clip
2624         the data range instead of expanding it.
2625 
2626         For example, if your data is in the range [0, 2], a margin of 0.1 will
2627         result in a range [-0.2, 2.2]; a margin of -0.1 will result in a range
2628         of [0.2, 1.8].
2629 
2630         Parameters
2631         ----------
2632         m : float greater than -0.5
2633         """
2634         if m <= -0.5:
2635             raise ValueError("margin must be greater than -0.5")
2636         self._xmargin = m
2637         self._request_autoscale_view("x")
2638         self.stale = True
2639 
2640     def set_ymargin(self, m):
2641         """
2642         Set padding of Y data limits prior to autoscaling.
2643 
2644         *m* times the data interval will be added to each end of that interval
2645         before it is used in autoscaling.  If *m* is negative, this will clip
2646         the data range instead of expanding it.
2647 
2648         For example, if your data is in the range [0, 2], a margin of 0.1 will
2649         result in a range [-0.2, 2.2]; a margin of -0.1 will result in a range
2650         of [0.2, 1.8].
2651 
2652         Parameters
2653         ----------
2654         m : float greater than -0.5
2655         """
2656         if m <= -0.5:
2657             raise ValueError("margin must be greater than -0.5")
2658         self._ymargin = m
2659         self._request_autoscale_view("y")
2660         self.stale = True
2661 
2662     def margins(self, *margins, x=None, y=None, tight=True):
2663         """
2664         Set or retrieve autoscaling margins.
2665 
2666         The padding added to each limit of the Axes is the *margin*
2667         times the data interval. All input parameters must be floats
2668         within the range [0, 1]. Passing both positional and keyword
2669         arguments is invalid and will raise a TypeError. If no
2670         arguments (positional or otherwise) are provided, the current
2671         margins will remain in place and simply be returned.
2672 
2673         Specifying any margin changes only the autoscaling; for example,
2674         if *xmargin* is not None, then *xmargin* times the X data
2675         interval will be added to each end of that interval before
2676         it is used in autoscaling.
2677 
2678         Parameters
2679         ----------
2680         *margins : float, optional
2681             If a single positional argument is provided, it specifies
2682             both margins of the x-axis and y-axis limits. If two
2683             positional arguments are provided, they will be interpreted
2684             as *xmargin*, *ymargin*. If setting the margin on a single
2685             axis is desired, use the keyword arguments described below.
2686 
2687         x, y : float, optional
2688             Specific margin values for the x-axis and y-axis,
2689             respectively. These cannot be used with positional
2690             arguments, but can be used individually to alter on e.g.,
2691             only the y-axis.
2692 
2693         tight : bool or None, default: True
2694             The *tight* parameter is passed to `~.axes.Axes.autoscale_view`,
2695             which is executed after a margin is changed; the default
2696             here is *True*, on the assumption that when margins are
2697             specified, no additional padding to match tick marks is
2698             usually desired.  Setting *tight* to *None* preserves
2699             the previous setting.
2700 
2701         Returns
2702         -------
2703         xmargin, ymargin : float
2704 
2705         Notes
2706         -----
2707         If a previously used Axes method such as :meth:`pcolor` has set
2708         :attr:`use_sticky_edges` to `True`, only the limits not set by
2709         the "sticky artists" will be modified. To force all of the
2710         margins to be set, set :attr:`use_sticky_edges` to `False`
2711         before calling :meth:`margins`.
2712         """
2713 
2714         if margins and (x is not None or y is not None):
2715             raise TypeError('Cannot pass both positional and keyword '
2716                             'arguments for x and/or y.')
2717         elif len(margins) == 1:
2718             x = y = margins[0]
2719         elif len(margins) == 2:
2720             x, y = margins
2721         elif margins:
2722             raise TypeError('Must pass a single positional argument for all '
2723                             'margins, or one for each margin (x, y).')
2724 
2725         if x is None and y is None:
2726             if tight is not True:
2727                 _api.warn_external(f'ignoring tight={tight!r} in get mode')
2728             return self._xmargin, self._ymargin
2729 
2730         if tight is not None:
2731             self._tight = tight
2732         if x is not None:
2733             self.set_xmargin(x)
2734         if y is not None:
2735             self.set_ymargin(y)
2736 
2737     def set_rasterization_zorder(self, z):
2738         """
2739         Set the zorder threshold for rasterization for vector graphics output.
2740 
2741         All artists with a zorder below the given value will be rasterized if
2742         they support rasterization.
2743 
2744         This setting is ignored for pixel-based output.
2745 
2746         See also :doc:`/gallery/misc/rasterization_demo`.
2747 
2748         Parameters
2749         ----------
2750         z : float or None
2751             The zorder below which artists are rasterized.
2752             If ``None`` rasterization based on zorder is deactivated.
2753         """
2754         self._rasterization_zorder = z
2755         self.stale = True
2756 
2757     def get_rasterization_zorder(self):
2758         """Return the zorder value below which artists will be rasterized."""
2759         return self._rasterization_zorder
2760 
2761     def autoscale(self, enable=True, axis='both', tight=None):
2762         """
2763         Autoscale the axis view to the data (toggle).
2764 
2765         Convenience method for simple axis view autoscaling.
2766         It turns autoscaling on or off, and then,
2767         if autoscaling for either axis is on, it performs
2768         the autoscaling on the specified axis or Axes.
2769 
2770         Parameters
2771         ----------
2772         enable : bool or None, default: True
2773             True turns autoscaling on, False turns it off.
2774             None leaves the autoscaling state unchanged.
2775         axis : {'both', 'x', 'y'}, default: 'both'
2776             The axis on which to operate.  (For 3D Axes, *axis* can also be set
2777             to 'z', and 'both' refers to all three axes.)
2778         tight : bool or None, default: None
2779             If True, first set the margins to zero.  Then, this argument is
2780             forwarded to `~.axes.Axes.autoscale_view` (regardless of
2781             its value); see the description of its behavior there.
2782         """
2783         if enable is None:
2784             scalex = True
2785             scaley = True
2786         else:
2787             if axis in ['x', 'both']:
2788                 self.set_autoscalex_on(bool(enable))
2789                 scalex = self.get_autoscalex_on()
2790             else:
2791                 scalex = False
2792             if axis in ['y', 'both']:
2793                 self.set_autoscaley_on(bool(enable))
2794                 scaley = self.get_autoscaley_on()
2795             else:
2796                 scaley = False
2797         if tight and scalex:
2798             self._xmargin = 0
2799         if tight and scaley:
2800             self._ymargin = 0
2801         if scalex:
2802             self._request_autoscale_view("x", tight=tight)
2803         if scaley:
2804             self._request_autoscale_view("y", tight=tight)
2805 
2806     def autoscale_view(self, tight=None, scalex=True, scaley=True):
2807         """
2808         Autoscale the view limits using the data limits.
2809 
2810         Parameters
2811         ----------
2812         tight : bool or None
2813             If *True*, only expand the axis limits using the margins.  Note
2814             that unlike for `autoscale`, ``tight=True`` does *not* set the
2815             margins to zero.
2816 
2817             If *False* and :rc:`axes.autolimit_mode` is 'round_numbers', then
2818             after expansion by the margins, further expand the axis limits
2819             using the axis major locator.
2820 
2821             If None (the default), reuse the value set in the previous call to
2822             `autoscale_view` (the initial value is False, but the default style
2823             sets :rc:`axes.autolimit_mode` to 'data', in which case this
2824             behaves like True).
2825 
2826         scalex : bool, default: True
2827             Whether to autoscale the x-axis.
2828 
2829         scaley : bool, default: True
2830             Whether to autoscale the y-axis.
2831 
2832         Notes
2833         -----
2834         The autoscaling preserves any preexisting axis direction reversal.
2835 
2836         The data limits are not updated automatically when artist data are
2837         changed after the artist has been added to an Axes instance.  In that
2838         case, use :meth:`matplotlib.axes.Axes.relim` prior to calling
2839         autoscale_view.
2840 
2841         If the views of the Axes are fixed, e.g. via `set_xlim`, they will
2842         not be changed by autoscale_view().
2843         See :meth:`matplotlib.axes.Axes.autoscale` for an alternative.
2844         """
2845         if tight is not None:
2846             self._tight = bool(tight)
2847 
2848         x_stickies = y_stickies = np.array([])
2849         if self.use_sticky_edges:
2850             if self._xmargin and scalex and self.get_autoscalex_on():
2851                 x_stickies = np.sort(np.concatenate([
2852                     artist.sticky_edges.x
2853                     for ax in self._shared_axes["x"].get_siblings(self)
2854                     for artist in ax.get_children()]))
2855             if self._ymargin and scaley and self.get_autoscaley_on():
2856                 y_stickies = np.sort(np.concatenate([
2857                     artist.sticky_edges.y
2858                     for ax in self._shared_axes["y"].get_siblings(self)
2859                     for artist in ax.get_children()]))
2860         if self.get_xscale() == 'log':
2861             x_stickies = x_stickies[x_stickies > 0]
2862         if self.get_yscale() == 'log':
2863             y_stickies = y_stickies[y_stickies > 0]
2864 
2865         def handle_single_axis(
2866                 scale, shared_axes, name, axis, margin, stickies, set_bound):
2867 
2868             if not (scale and axis._get_autoscale_on()):
2869                 return  # nothing to do...
2870 
2871             shared = shared_axes.get_siblings(self)
2872             # Base autoscaling on finite data limits when there is at least one
2873             # finite data limit among all the shared_axes and intervals.
2874             values = [val for ax in shared
2875                       for val in getattr(ax.dataLim, f"interval{name}")
2876                       if np.isfinite(val)]
2877             if values:
2878                 x0, x1 = (min(values), max(values))
2879             elif getattr(self._viewLim, f"mutated{name}")():
2880                 # No data, but explicit viewLims already set:
2881                 # in mutatedx or mutatedy.
2882                 return
2883             else:
2884                 x0, x1 = (-np.inf, np.inf)
2885             # If x0 and x1 are nonfinite, get default limits from the locator.
2886             locator = axis.get_major_locator()
2887             x0, x1 = locator.nonsingular(x0, x1)
2888             # Find the minimum minpos for use in the margin calculation.
2889             minimum_minpos = min(
2890                 getattr(ax.dataLim, f"minpos{name}") for ax in shared)
2891 
2892             # Prevent margin addition from crossing a sticky value.  A small
2893             # tolerance must be added due to floating point issues with
2894             # streamplot; it is defined relative to x0, x1, x1-x0 but has
2895             # no absolute term (e.g. "+1e-8") to avoid issues when working with
2896             # datasets where all values are tiny (less than 1e-8).
2897             tol = 1e-5 * max(abs(x0), abs(x1), abs(x1 - x0))
2898             # Index of largest element < x0 + tol, if any.
2899             i0 = stickies.searchsorted(x0 + tol) - 1
2900             x0bound = stickies[i0] if i0 != -1 else None
2901             # Index of smallest element > x1 - tol, if any.
2902             i1 = stickies.searchsorted(x1 - tol)
2903             x1bound = stickies[i1] if i1 != len(stickies) else None
2904 
2905             # Add the margin in figure space and then transform back, to handle
2906             # non-linear scales.
2907             transform = axis.get_transform()
2908             inverse_trans = transform.inverted()
2909             x0, x1 = axis._scale.limit_range_for_scale(x0, x1, minimum_minpos)
2910             x0t, x1t = transform.transform([x0, x1])
2911             delta = (x1t - x0t) * margin
2912             if not np.isfinite(delta):
2913                 delta = 0  # If a bound isn't finite, set margin to zero.
2914             x0, x1 = inverse_trans.transform([x0t - delta, x1t + delta])
2915 
2916             # Apply sticky bounds.
2917             if x0bound is not None:
2918                 x0 = max(x0, x0bound)
2919             if x1bound is not None:
2920                 x1 = min(x1, x1bound)
2921 
2922             if not self._tight:
2923                 x0, x1 = locator.view_limits(x0, x1)
2924             set_bound(x0, x1)
2925             # End of definition of internal function 'handle_single_axis'.
2926 
2927         handle_single_axis(
2928             scalex, self._shared_axes["x"], 'x', self.xaxis, self._xmargin,
2929             x_stickies, self.set_xbound)
2930         handle_single_axis(
2931             scaley, self._shared_axes["y"], 'y', self.yaxis, self._ymargin,
2932             y_stickies, self.set_ybound)
2933 
2934     def _update_title_position(self, renderer):
2935         """
2936         Update the title position based on the bounding box enclosing
2937         all the ticklabels and x-axis spine and xlabel...
2938         """
2939         if self._autotitlepos is not None and not self._autotitlepos:
2940             _log.debug('title position was updated manually, not adjusting')
2941             return
2942 
2943         titles = (self.title, self._left_title, self._right_title)
2944 
2945         # Need to check all our twins too, and all the children as well.
2946         axs = self._twinned_axes.get_siblings(self) + self.child_axes
2947         for ax in self.child_axes:  # Child positions must be updated first.
2948             locator = ax.get_axes_locator()
2949             ax.apply_aspect(locator(self, renderer) if locator else None)
2950 
2951         for title in titles:
2952             x, _ = title.get_position()
2953             # need to start again in case of window resizing
2954             title.set_position((x, 1.0))
2955             top = -np.inf
2956             for ax in axs:
2957                 bb = None
2958                 if (ax.xaxis.get_ticks_position() in ['top', 'unknown']
2959                         or ax.xaxis.get_label_position() == 'top'):
2960                     bb = ax.xaxis.get_tightbbox(renderer)
2961                 if bb is None:
2962                     if 'outline' in ax.spines:
2963                         # Special case for colorbars:
2964                         bb = ax.spines['outline'].get_window_extent()
2965                     else:
2966                         bb = ax.get_window_extent(renderer)
2967                 top = max(top, bb.ymax)
2968                 if title.get_text():
2969                     ax.yaxis.get_tightbbox(renderer)  # update offsetText
2970                     if ax.yaxis.offsetText.get_text():
2971                         bb = ax.yaxis.offsetText.get_tightbbox(renderer)
2972                         if bb.intersection(title.get_tightbbox(renderer), bb):
2973                             top = bb.ymax
2974             if top < 0:
2975                 # the top of Axes is not even on the figure, so don't try and
2976                 # automatically place it.
2977                 _log.debug('top of Axes not in the figure, so title not moved')
2978                 return
2979             if title.get_window_extent(renderer).ymin < top:
2980                 _, y = self.transAxes.inverted().transform((0, top))
2981                 title.set_position((x, y))
2982                 # empirically, this doesn't always get the min to top,
2983                 # so we need to adjust again.
2984                 if title.get_window_extent(renderer).ymin < top:
2985                     _, y = self.transAxes.inverted().transform(
2986                         (0., 2 * top - title.get_window_extent(renderer).ymin))
2987                     title.set_position((x, y))
2988 
2989         ymax = max(title.get_position()[1] for title in titles)
2990         for title in titles:
2991             # now line up all the titles at the highest baseline.
2992             x, _ = title.get_position()
2993             title.set_position((x, ymax))
2994 
2995     # Drawing
2996     @martist.allow_rasterization
2997     def draw(self, renderer):
2998         # docstring inherited
2999         if renderer is None:
3000             raise RuntimeError('No renderer defined')
3001         if not self.get_visible():
3002             return
3003         self._unstale_viewLim()
3004 
3005         renderer.open_group('axes', gid=self.get_gid())
3006 
3007         # prevent triggering call backs during the draw process
3008         self._stale = True
3009 
3010         # loop over self and child Axes...
3011         locator = self.get_axes_locator()
3012         self.apply_aspect(locator(self, renderer) if locator else None)
3013 
3014         artists = self.get_children()
3015         artists.remove(self.patch)
3016 
3017         # the frame draws the edges around the Axes patch -- we
3018         # decouple these so the patch can be in the background and the
3019         # frame in the foreground. Do this before drawing the axis
3020         # objects so that the spine has the opportunity to update them.
3021         if not (self.axison and self._frameon):
3022             for spine in self.spines.values():
3023                 artists.remove(spine)
3024 
3025         self._update_title_position(renderer)
3026 
3027         if not self.axison:
3028             for _axis in self._axis_map.values():
3029                 artists.remove(_axis)
3030 
3031         if not self.figure.canvas.is_saving():
3032             artists = [
3033                 a for a in artists
3034                 if not a.get_animated() or isinstance(a, mimage.AxesImage)]
3035         artists = sorted(artists, key=attrgetter('zorder'))
3036 
3037         # rasterize artists with negative zorder
3038         # if the minimum zorder is negative, start rasterization
3039         rasterization_zorder = self._rasterization_zorder
3040 
3041         if (rasterization_zorder is not None and
3042                 artists and artists[0].zorder < rasterization_zorder):
3043             split_index = np.searchsorted(
3044                 [art.zorder for art in artists],
3045                 rasterization_zorder, side='right'
3046             )
3047             artists_rasterized = artists[:split_index]
3048             artists = artists[split_index:]
3049         else:
3050             artists_rasterized = []
3051 
3052         if self.axison and self._frameon:
3053             if artists_rasterized:
3054                 artists_rasterized = [self.patch] + artists_rasterized
3055             else:
3056                 artists = [self.patch] + artists
3057 
3058         if artists_rasterized:
3059             _draw_rasterized(self.figure, artists_rasterized, renderer)
3060 
3061         mimage._draw_list_compositing_images(
3062             renderer, self, artists, self.figure.suppressComposite)
3063 
3064         renderer.close_group('axes')
3065         self.stale = False
3066 
3067     def draw_artist(self, a):
3068         """
3069         Efficiently redraw a single artist.
3070         """
3071         a.draw(self.figure.canvas.get_renderer())
3072 
3073     def redraw_in_frame(self):
3074         """
3075         Efficiently redraw Axes data, but not axis ticks, labels, etc.
3076         """
3077         with ExitStack() as stack:
3078             for artist in [*self._axis_map.values(),
3079                            self.title, self._left_title, self._right_title]:
3080                 stack.enter_context(artist._cm_set(visible=False))
3081             self.draw(self.figure.canvas.get_renderer())
3082 
3083     # Axes rectangle characteristics
3084 
3085     def get_frame_on(self):
3086         """Get whether the Axes rectangle patch is drawn."""
3087         return self._frameon
3088 
3089     def set_frame_on(self, b):
3090         """
3091         Set whether the Axes rectangle patch is drawn.
3092 
3093         Parameters
3094         ----------
3095         b : bool
3096         """
3097         self._frameon = b
3098         self.stale = True
3099 
3100     def get_axisbelow(self):
3101         """
3102         Get whether axis ticks and gridlines are above or below most artists.
3103 
3104         Returns
3105         -------
3106         bool or 'line'
3107 
3108         See Also
3109         --------
3110         set_axisbelow
3111         """
3112         return self._axisbelow
3113 
3114     def set_axisbelow(self, b):
3115         """
3116         Set whether axis ticks and gridlines are above or below most artists.
3117 
3118         This controls the zorder of the ticks and gridlines. For more
3119         information on the zorder see :doc:`/gallery/misc/zorder_demo`.
3120 
3121         Parameters
3122         ----------
3123         b : bool or 'line'
3124             Possible values:
3125 
3126             - *True* (zorder = 0.5): Ticks and gridlines are below all Artists.
3127             - 'line' (zorder = 1.5): Ticks and gridlines are above patches
3128               (e.g. rectangles, with default zorder = 1) but still below lines
3129               and markers (with their default zorder = 2).
3130             - *False* (zorder = 2.5): Ticks and gridlines are above patches
3131               and lines / markers.
3132 
3133         See Also
3134         --------
3135         get_axisbelow
3136         """
3137         # Check that b is True, False or 'line'
3138         self._axisbelow = axisbelow = validate_axisbelow(b)
3139         zorder = {
3140             True: 0.5,
3141             'line': 1.5,
3142             False: 2.5,
3143         }[axisbelow]
3144         for axis in self._axis_map.values():
3145             axis.set_zorder(zorder)
3146         self.stale = True
3147 
3148     @_docstring.dedent_interpd
3149     def grid(self, visible=None, which='major', axis='both', **kwargs):
3150         """
3151         Configure the grid lines.
3152 
3153         Parameters
3154         ----------
3155         visible : bool or None, optional
3156             Whether to show the grid lines.  If any *kwargs* are supplied, it
3157             is assumed you want the grid on and *visible* will be set to True.
3158 
3159             If *visible* is *None* and there are no *kwargs*, this toggles the
3160             visibility of the lines.
3161 
3162         which : {'major', 'minor', 'both'}, optional
3163             The grid lines to apply the changes on.
3164 
3165         axis : {'both', 'x', 'y'}, optional
3166             The axis to apply the changes on.
3167 
3168         **kwargs : `.Line2D` properties
3169             Define the line properties of the grid, e.g.::
3170 
3171                 grid(color='r', linestyle='-', linewidth=2)
3172 
3173             Valid keyword arguments are:
3174 
3175             %(Line2D:kwdoc)s
3176 
3177         Notes
3178         -----
3179         The axis is drawn as a unit, so the effective zorder for drawing the
3180         grid is determined by the zorder of each axis, not by the zorder of the
3181         `.Line2D` objects comprising the grid.  Therefore, to set grid zorder,
3182         use `.set_axisbelow` or, for more control, call the
3183         `~.Artist.set_zorder` method of each axis.
3184         """
3185         _api.check_in_list(['x', 'y', 'both'], axis=axis)
3186         if axis in ['x', 'both']:
3187             self.xaxis.grid(visible, which=which, **kwargs)
3188         if axis in ['y', 'both']:
3189             self.yaxis.grid(visible, which=which, **kwargs)
3190 
3191     def ticklabel_format(self, *, axis='both', style='', scilimits=None,
3192                          useOffset=None, useLocale=None, useMathText=None):
3193         r"""
3194         Configure the `.ScalarFormatter` used by default for linear Axes.
3195 
3196         If a parameter is not set, the corresponding property of the formatter
3197         is left unchanged.
3198 
3199         Parameters
3200         ----------
3201         axis : {'x', 'y', 'both'}, default: 'both'
3202             The axis to configure.  Only major ticks are affected.
3203 
3204         style : {'sci', 'scientific', 'plain'}
3205             Whether to use scientific notation.
3206             The formatter default is to use scientific notation.
3207 
3208         scilimits : pair of ints (m, n)
3209             Scientific notation is used only for numbers outside the range
3210             10\ :sup:`m` to 10\ :sup:`n` (and only if the formatter is
3211             configured to use scientific notation at all).  Use (0, 0) to
3212             include all numbers.  Use (m, m) where m != 0 to fix the order of
3213             magnitude to 10\ :sup:`m`.
3214             The formatter default is :rc:`axes.formatter.limits`.
3215 
3216         useOffset : bool or float
3217             If True, the offset is calculated as needed.
3218             If False, no offset is used.
3219             If a numeric value, it sets the offset.
3220             The formatter default is :rc:`axes.formatter.useoffset`.
3221 
3222         useLocale : bool
3223             Whether to format the number using the current locale or using the
3224             C (English) locale.  This affects e.g. the decimal separator.  The
3225             formatter default is :rc:`axes.formatter.use_locale`.
3226 
3227         useMathText : bool
3228             Render the offset and scientific notation in mathtext.
3229             The formatter default is :rc:`axes.formatter.use_mathtext`.
3230 
3231         Raises
3232         ------
3233         AttributeError
3234             If the current formatter is not a `.ScalarFormatter`.
3235         """
3236         style = style.lower()
3237         axis = axis.lower()
3238         if scilimits is not None:
3239             try:
3240                 m, n = scilimits
3241                 m + n + 1  # check that both are numbers
3242             except (ValueError, TypeError) as err:
3243                 raise ValueError("scilimits must be a sequence of 2 integers"
3244                                  ) from err
3245         STYLES = {'sci': True, 'scientific': True, 'plain': False, '': None}
3246         is_sci_style = _api.check_getitem(STYLES, style=style)
3247         axis_map = {**{k: [v] for k, v in self._axis_map.items()},
3248                     'both': list(self._axis_map.values())}
3249         axises = _api.check_getitem(axis_map, axis=axis)
3250         try:
3251             for axis in axises:
3252                 if is_sci_style is not None:
3253                     axis.major.formatter.set_scientific(is_sci_style)
3254                 if scilimits is not None:
3255                     axis.major.formatter.set_powerlimits(scilimits)
3256                 if useOffset is not None:
3257                     axis.major.formatter.set_useOffset(useOffset)
3258                 if useLocale is not None:
3259                     axis.major.formatter.set_useLocale(useLocale)
3260                 if useMathText is not None:
3261                     axis.major.formatter.set_useMathText(useMathText)
3262         except AttributeError as err:
3263             raise AttributeError(
3264                 "This method only works with the ScalarFormatter") from err
3265 
3266     def locator_params(self, axis='both', tight=None, **kwargs):
3267         """
3268         Control behavior of major tick locators.
3269 
3270         Because the locator is involved in autoscaling, `~.Axes.autoscale_view`
3271         is called automatically after the parameters are changed.
3272 
3273         Parameters
3274         ----------
3275         axis : {'both', 'x', 'y'}, default: 'both'
3276             The axis on which to operate.  (For 3D Axes, *axis* can also be
3277             set to 'z', and 'both' refers to all three axes.)
3278         tight : bool or None, optional
3279             Parameter passed to `~.Axes.autoscale_view`.
3280             Default is None, for no change.
3281 
3282         Other Parameters
3283         ----------------
3284         **kwargs
3285             Remaining keyword arguments are passed to directly to the
3286             ``set_params()`` method of the locator. Supported keywords depend
3287             on the type of the locator. See for example
3288             `~.ticker.MaxNLocator.set_params` for the `.ticker.MaxNLocator`
3289             used by default for linear.
3290 
3291         Examples
3292         --------
3293         When plotting small subplots, one might want to reduce the maximum
3294         number of ticks and use tight bounds, for example::
3295 
3296             ax.locator_params(tight=True, nbins=4)
3297 
3298         """
3299         _api.check_in_list([*self._axis_names, "both"], axis=axis)
3300         for name in self._axis_names:
3301             if axis in [name, "both"]:
3302                 loc = self._axis_map[name].get_major_locator()
3303                 loc.set_params(**kwargs)
3304                 self._request_autoscale_view(name, tight=tight)
3305         self.stale = True
3306 
3307     def tick_params(self, axis='both', **kwargs):
3308         """
3309         Change the appearance of ticks, tick labels, and gridlines.
3310 
3311         Tick properties that are not explicitly set using the keyword
3312         arguments remain unchanged unless *reset* is True. For the current
3313         style settings, see `.Axis.get_tick_params`.
3314 
3315         Parameters
3316         ----------
3317         axis : {'x', 'y', 'both'}, default: 'both'
3318             The axis to which the parameters are applied.
3319         which : {'major', 'minor', 'both'}, default: 'major'
3320             The group of ticks to which the parameters are applied.
3321         reset : bool, default: False
3322             Whether to reset the ticks to defaults before updating them.
3323 
3324         Other Parameters
3325         ----------------
3326         direction : {'in', 'out', 'inout'}
3327             Puts ticks inside the Axes, outside the Axes, or both.
3328         length : float
3329             Tick length in points.
3330         width : float
3331             Tick width in points.
3332         color : color
3333             Tick color.
3334         pad : float
3335             Distance in points between tick and label.
3336         labelsize : float or str
3337             Tick label font size in points or as a string (e.g., 'large').
3338         labelcolor : color
3339             Tick label color.
3340         colors : color
3341             Tick color and label color.
3342         zorder : float
3343             Tick and label zorder.
3344         bottom, top, left, right : bool
3345             Whether to draw the respective ticks.
3346         labelbottom, labeltop, labelleft, labelright : bool
3347             Whether to draw the respective tick labels.
3348         labelrotation : float
3349             Tick label rotation
3350         grid_color : color
3351             Gridline color.
3352         grid_alpha : float
3353             Transparency of gridlines: 0 (transparent) to 1 (opaque).
3354         grid_linewidth : float
3355             Width of gridlines in points.
3356         grid_linestyle : str
3357             Any valid `.Line2D` line style spec.
3358 
3359         Examples
3360         --------
3361         ::
3362 
3363             ax.tick_params(direction='out', length=6, width=2, colors='r',
3364                            grid_color='r', grid_alpha=0.5)
3365 
3366         This will make all major ticks be red, pointing out of the box,
3367         and with dimensions 6 points by 2 points.  Tick labels will
3368         also be red.  Gridlines will be red and translucent.
3369 
3370         """
3371         _api.check_in_list(['x', 'y', 'both'], axis=axis)
3372         if axis in ['x', 'both']:
3373             xkw = dict(kwargs)
3374             xkw.pop('left', None)
3375             xkw.pop('right', None)
3376             xkw.pop('labelleft', None)
3377             xkw.pop('labelright', None)
3378             self.xaxis.set_tick_params(**xkw)
3379         if axis in ['y', 'both']:
3380             ykw = dict(kwargs)
3381             ykw.pop('top', None)
3382             ykw.pop('bottom', None)
3383             ykw.pop('labeltop', None)
3384             ykw.pop('labelbottom', None)
3385             self.yaxis.set_tick_params(**ykw)
3386 
3387     def set_axis_off(self):
3388         """
3389         Turn the x- and y-axis off.
3390 
3391         This affects the axis lines, ticks, ticklabels, grid and axis labels.
3392         """
3393         self.axison = False
3394         self.stale = True
3395 
3396     def set_axis_on(self):
3397         """
3398         Turn the x- and y-axis on.
3399 
3400         This affects the axis lines, ticks, ticklabels, grid and axis labels.
3401         """
3402         self.axison = True
3403         self.stale = True
3404 
3405     # data limits, ticks, tick labels, and formatting
3406 
3407     def get_xlabel(self):
3408         """
3409         Get the xlabel text string.
3410         """
3411         label = self.xaxis.get_label()
3412         return label.get_text()
3413 
3414     def set_xlabel(self, xlabel, fontdict=None, labelpad=None, *,
3415                    loc=None, **kwargs):
3416         """
3417         Set the label for the x-axis.
3418 
3419         Parameters
3420         ----------
3421         xlabel : str
3422             The label text.
3423 
3424         labelpad : float, default: :rc:`axes.labelpad`
3425             Spacing in points from the Axes bounding box including ticks
3426             and tick labels.  If None, the previous value is left as is.
3427 
3428         loc : {'left', 'center', 'right'}, default: :rc:`xaxis.labellocation`
3429             The label position. This is a high-level alternative for passing
3430             parameters *x* and *horizontalalignment*.
3431 
3432         Other Parameters
3433         ----------------
3434         **kwargs : `.Text` properties
3435             `.Text` properties control the appearance of the label.
3436 
3437         See Also
3438         --------
3439         text : Documents the properties supported by `.Text`.
3440         """
3441         if labelpad is not None:
3442             self.xaxis.labelpad = labelpad
3443         protected_kw = ['x', 'horizontalalignment', 'ha']
3444         if {*kwargs} & {*protected_kw}:
3445             if loc is not None:
3446                 raise TypeError(f"Specifying 'loc' is disallowed when any of "
3447                                 f"its corresponding low level keyword "
3448                                 f"arguments ({protected_kw}) are also "
3449                                 f"supplied")
3450 
3451         else:
3452             loc = (loc if loc is not None
3453                    else mpl.rcParams['xaxis.labellocation'])
3454             _api.check_in_list(('left', 'center', 'right'), loc=loc)
3455 
3456             x = {
3457                 'left': 0,
3458                 'center': 0.5,
3459                 'right': 1,
3460             }[loc]
3461             kwargs.update(x=x, horizontalalignment=loc)
3462 
3463         return self.xaxis.set_label_text(xlabel, fontdict, **kwargs)
3464 
3465     def invert_xaxis(self):
3466         """
3467         Invert the x-axis.
3468 
3469         See Also
3470         --------
3471         xaxis_inverted
3472         get_xlim, set_xlim
3473         get_xbound, set_xbound
3474         """
3475         self.xaxis.set_inverted(not self.xaxis.get_inverted())
3476 
3477     xaxis_inverted = _axis_method_wrapper("xaxis", "get_inverted")
3478 
3479     def get_xbound(self):
3480         """
3481         Return the lower and upper x-axis bounds, in increasing order.
3482 
3483         See Also
3484         --------
3485         set_xbound
3486         get_xlim, set_xlim
3487         invert_xaxis, xaxis_inverted
3488         """
3489         left, right = self.get_xlim()
3490         if left < right:
3491             return left, right
3492         else:
3493             return right, left
3494 
3495     def set_xbound(self, lower=None, upper=None):
3496         """
3497         Set the lower and upper numerical bounds of the x-axis.
3498 
3499         This method will honor axis inversion regardless of parameter order.
3500         It will not change the autoscaling setting (`.get_autoscalex_on()`).
3501 
3502         Parameters
3503         ----------
3504         lower, upper : float or None
3505             The lower and upper bounds. If *None*, the respective axis bound
3506             is not modified.
3507 
3508         See Also
3509         --------
3510         get_xbound
3511         get_xlim, set_xlim
3512         invert_xaxis, xaxis_inverted
3513         """
3514         if upper is None and np.iterable(lower):
3515             lower, upper = lower
3516 
3517         old_lower, old_upper = self.get_xbound()
3518         if lower is None:
3519             lower = old_lower
3520         if upper is None:
3521             upper = old_upper
3522 
3523         self.set_xlim(sorted((lower, upper),
3524                              reverse=bool(self.xaxis_inverted())),
3525                       auto=None)
3526 
3527     def get_xlim(self):
3528         """
3529         Return the x-axis view limits.
3530 
3531         Returns
3532         -------
3533         left, right : (float, float)
3534             The current x-axis limits in data coordinates.
3535 
3536         See Also
3537         --------
3538         .Axes.set_xlim
3539         set_xbound, get_xbound
3540         invert_xaxis, xaxis_inverted
3541 
3542         Notes
3543         -----
3544         The x-axis may be inverted, in which case the *left* value will
3545         be greater than the *right* value.
3546         """
3547         return tuple(self.viewLim.intervalx)
3548 
3549     def _validate_converted_limits(self, limit, convert):
3550         """
3551         Raise ValueError if converted limits are non-finite.
3552 
3553         Note that this function also accepts None as a limit argument.
3554 
3555         Returns
3556         -------
3557         The limit value after call to convert(), or None if limit is None.
3558         """
3559         if limit is not None:
3560             converted_limit = convert(limit)
3561             if (isinstance(converted_limit, Real)
3562                     and not np.isfinite(converted_limit)):
3563                 raise ValueError("Axis limits cannot be NaN or Inf")
3564             return converted_limit
3565 
3566     def set_xlim(self, left=None, right=None, *, emit=True, auto=False,
3567                  xmin=None, xmax=None):
3568         """
3569         Set the x-axis view limits.
3570 
3571         Parameters
3572         ----------
3573         left : float, optional
3574             The left xlim in data coordinates. Passing *None* leaves the
3575             limit unchanged.
3576 
3577             The left and right xlims may also be passed as the tuple
3578             (*left*, *right*) as the first positional argument (or as
3579             the *left* keyword argument).
3580 
3581             .. ACCEPTS: (bottom: float, top: float)
3582 
3583         right : float, optional
3584             The right xlim in data coordinates. Passing *None* leaves the
3585             limit unchanged.
3586 
3587         emit : bool, default: True
3588             Whether to notify observers of limit change.
3589 
3590         auto : bool or None, default: False
3591             Whether to turn on autoscaling of the x-axis. True turns on,
3592             False turns off, None leaves unchanged.
3593 
3594         xmin, xmax : float, optional
3595             They are equivalent to left and right respectively, and it is an
3596             error to pass both *xmin* and *left* or *xmax* and *right*.
3597 
3598         Returns
3599         -------
3600         left, right : (float, float)
3601             The new x-axis limits in data coordinates.
3602 
3603         See Also
3604         --------
3605         get_xlim
3606         set_xbound, get_xbound
3607         invert_xaxis, xaxis_inverted
3608 
3609         Notes
3610         -----
3611         The *left* value may be greater than the *right* value, in which
3612         case the x-axis values will decrease from left to right.
3613 
3614         Examples
3615         --------
3616         >>> set_xlim(left, right)
3617         >>> set_xlim((left, right))
3618         >>> left, right = set_xlim(left, right)
3619 
3620         One limit may be left unchanged.
3621 
3622         >>> set_xlim(right=right_lim)
3623 
3624         Limits may be passed in reverse order to flip the direction of
3625         the x-axis. For example, suppose *x* represents the number of
3626         years before present. The x-axis limits might be set like the
3627         following so 5000 years ago is on the left of the plot and the
3628         present is on the right.
3629 
3630         >>> set_xlim(5000, 0)
3631         """
3632         if right is None and np.iterable(left):
3633             left, right = left
3634         if xmin is not None:
3635             if left is not None:
3636                 raise TypeError("Cannot pass both 'left' and 'xmin'")
3637             left = xmin
3638         if xmax is not None:
3639             if right is not None:
3640                 raise TypeError("Cannot pass both 'right' and 'xmax'")
3641             right = xmax
3642         return self.xaxis._set_lim(left, right, emit=emit, auto=auto)
3643 
3644     get_xscale = _axis_method_wrapper("xaxis", "get_scale")
3645     set_xscale = _axis_method_wrapper("xaxis", "_set_axes_scale")
3646     get_xticks = _axis_method_wrapper("xaxis", "get_ticklocs")
3647     set_xticks = _axis_method_wrapper("xaxis", "set_ticks")
3648     get_xmajorticklabels = _axis_method_wrapper("xaxis", "get_majorticklabels")
3649     get_xminorticklabels = _axis_method_wrapper("xaxis", "get_minorticklabels")
3650     get_xticklabels = _axis_method_wrapper("xaxis", "get_ticklabels")
3651     set_xticklabels = _axis_method_wrapper(
3652         "xaxis", "set_ticklabels",
3653         doc_sub={"Axis.set_ticks": "Axes.set_xticks"})
3654 
3655     def get_ylabel(self):
3656         """
3657         Get the ylabel text string.
3658         """
3659         label = self.yaxis.get_label()
3660         return label.get_text()
3661 
3662     def set_ylabel(self, ylabel, fontdict=None, labelpad=None, *,
3663                    loc=None, **kwargs):
3664         """
3665         Set the label for the y-axis.
3666 
3667         Parameters
3668         ----------
3669         ylabel : str
3670             The label text.
3671 
3672         labelpad : float, default: :rc:`axes.labelpad`
3673             Spacing in points from the Axes bounding box including ticks
3674             and tick labels.  If None, the previous value is left as is.
3675 
3676         loc : {'bottom', 'center', 'top'}, default: :rc:`yaxis.labellocation`
3677             The label position. This is a high-level alternative for passing
3678             parameters *y* and *horizontalalignment*.
3679 
3680         Other Parameters
3681         ----------------
3682         **kwargs : `.Text` properties
3683             `.Text` properties control the appearance of the label.
3684 
3685         See Also
3686         --------
3687         text : Documents the properties supported by `.Text`.
3688         """
3689         if labelpad is not None:
3690             self.yaxis.labelpad = labelpad
3691         protected_kw = ['y', 'horizontalalignment', 'ha']
3692         if {*kwargs} & {*protected_kw}:
3693             if loc is not None:
3694                 raise TypeError(f"Specifying 'loc' is disallowed when any of "
3695                                 f"its corresponding low level keyword "
3696                                 f"arguments ({protected_kw}) are also "
3697                                 f"supplied")
3698 
3699         else:
3700             loc = (loc if loc is not None
3701                    else mpl.rcParams['yaxis.labellocation'])
3702             _api.check_in_list(('bottom', 'center', 'top'), loc=loc)
3703 
3704             y, ha = {
3705                 'bottom': (0, 'left'),
3706                 'center': (0.5, 'center'),
3707                 'top': (1, 'right')
3708             }[loc]
3709             kwargs.update(y=y, horizontalalignment=ha)
3710 
3711         return self.yaxis.set_label_text(ylabel, fontdict, **kwargs)
3712 
3713     def invert_yaxis(self):
3714         """
3715         Invert the y-axis.
3716 
3717         See Also
3718         --------
3719         yaxis_inverted
3720         get_ylim, set_ylim
3721         get_ybound, set_ybound
3722         """
3723         self.yaxis.set_inverted(not self.yaxis.get_inverted())
3724 
3725     yaxis_inverted = _axis_method_wrapper("yaxis", "get_inverted")
3726 
3727     def get_ybound(self):
3728         """
3729         Return the lower and upper y-axis bounds, in increasing order.
3730 
3731         See Also
3732         --------
3733         set_ybound
3734         get_ylim, set_ylim
3735         invert_yaxis, yaxis_inverted
3736         """
3737         bottom, top = self.get_ylim()
3738         if bottom < top:
3739             return bottom, top
3740         else:
3741             return top, bottom
3742 
3743     def set_ybound(self, lower=None, upper=None):
3744         """
3745         Set the lower and upper numerical bounds of the y-axis.
3746 
3747         This method will honor axis inversion regardless of parameter order.
3748         It will not change the autoscaling setting (`.get_autoscaley_on()`).
3749 
3750         Parameters
3751         ----------
3752         lower, upper : float or None
3753             The lower and upper bounds. If *None*, the respective axis bound
3754             is not modified.
3755 
3756         See Also
3757         --------
3758         get_ybound
3759         get_ylim, set_ylim
3760         invert_yaxis, yaxis_inverted
3761         """
3762         if upper is None and np.iterable(lower):
3763             lower, upper = lower
3764 
3765         old_lower, old_upper = self.get_ybound()
3766         if lower is None:
3767             lower = old_lower
3768         if upper is None:
3769             upper = old_upper
3770 
3771         self.set_ylim(sorted((lower, upper),
3772                              reverse=bool(self.yaxis_inverted())),
3773                       auto=None)
3774 
3775     def get_ylim(self):
3776         """
3777         Return the y-axis view limits.
3778 
3779         Returns
3780         -------
3781         bottom, top : (float, float)
3782             The current y-axis limits in data coordinates.
3783 
3784         See Also
3785         --------
3786         .Axes.set_ylim
3787         set_ybound, get_ybound
3788         invert_yaxis, yaxis_inverted
3789 
3790         Notes
3791         -----
3792         The y-axis may be inverted, in which case the *bottom* value
3793         will be greater than the *top* value.
3794         """
3795         return tuple(self.viewLim.intervaly)
3796 
3797     def set_ylim(self, bottom=None, top=None, *, emit=True, auto=False,
3798                  ymin=None, ymax=None):
3799         """
3800         Set the y-axis view limits.
3801 
3802         Parameters
3803         ----------
3804         bottom : float, optional
3805             The bottom ylim in data coordinates. Passing *None* leaves the
3806             limit unchanged.
3807 
3808             The bottom and top ylims may also be passed as the tuple
3809             (*bottom*, *top*) as the first positional argument (or as
3810             the *bottom* keyword argument).
3811 
3812             .. ACCEPTS: (bottom: float, top: float)
3813 
3814         top : float, optional
3815             The top ylim in data coordinates. Passing *None* leaves the
3816             limit unchanged.
3817 
3818         emit : bool, default: True
3819             Whether to notify observers of limit change.
3820 
3821         auto : bool or None, default: False
3822             Whether to turn on autoscaling of the y-axis. *True* turns on,
3823             *False* turns off, *None* leaves unchanged.
3824 
3825         ymin, ymax : float, optional
3826             They are equivalent to bottom and top respectively, and it is an
3827             error to pass both *ymin* and *bottom* or *ymax* and *top*.
3828 
3829         Returns
3830         -------
3831         bottom, top : (float, float)
3832             The new y-axis limits in data coordinates.
3833 
3834         See Also
3835         --------
3836         get_ylim
3837         set_ybound, get_ybound
3838         invert_yaxis, yaxis_inverted
3839 
3840         Notes
3841         -----
3842         The *bottom* value may be greater than the *top* value, in which
3843         case the y-axis values will decrease from *bottom* to *top*.
3844 
3845         Examples
3846         --------
3847         >>> set_ylim(bottom, top)
3848         >>> set_ylim((bottom, top))
3849         >>> bottom, top = set_ylim(bottom, top)
3850 
3851         One limit may be left unchanged.
3852 
3853         >>> set_ylim(top=top_lim)
3854 
3855         Limits may be passed in reverse order to flip the direction of
3856         the y-axis. For example, suppose ``y`` represents depth of the
3857         ocean in m. The y-axis limits might be set like the following
3858         so 5000 m depth is at the bottom of the plot and the surface,
3859         0 m, is at the top.
3860 
3861         >>> set_ylim(5000, 0)
3862         """
3863         if top is None and np.iterable(bottom):
3864             bottom, top = bottom
3865         if ymin is not None:
3866             if bottom is not None:
3867                 raise TypeError("Cannot pass both 'bottom' and 'ymin'")
3868             bottom = ymin
3869         if ymax is not None:
3870             if top is not None:
3871                 raise TypeError("Cannot pass both 'top' and 'ymax'")
3872             top = ymax
3873         return self.yaxis._set_lim(bottom, top, emit=emit, auto=auto)
3874 
3875     get_yscale = _axis_method_wrapper("yaxis", "get_scale")
3876     set_yscale = _axis_method_wrapper("yaxis", "_set_axes_scale")
3877     get_yticks = _axis_method_wrapper("yaxis", "get_ticklocs")
3878     set_yticks = _axis_method_wrapper("yaxis", "set_ticks")
3879     get_ymajorticklabels = _axis_method_wrapper("yaxis", "get_majorticklabels")
3880     get_yminorticklabels = _axis_method_wrapper("yaxis", "get_minorticklabels")
3881     get_yticklabels = _axis_method_wrapper("yaxis", "get_ticklabels")
3882     set_yticklabels = _axis_method_wrapper(
3883         "yaxis", "set_ticklabels",
3884         doc_sub={"Axis.set_ticks": "Axes.set_yticks"})
3885 
3886     xaxis_date = _axis_method_wrapper("xaxis", "axis_date")
3887     yaxis_date = _axis_method_wrapper("yaxis", "axis_date")
3888 
3889     def format_xdata(self, x):
3890         """
3891         Return *x* formatted as an x-value.
3892 
3893         This function will use the `.fmt_xdata` attribute if it is not None,
3894         else will fall back on the xaxis major formatter.
3895         """
3896         return (self.fmt_xdata if self.fmt_xdata is not None
3897                 else self.xaxis.get_major_formatter().format_data_short)(x)
3898 
3899     def format_ydata(self, y):
3900         """
3901         Return *y* formatted as a y-value.
3902 
3903         This function will use the `.fmt_ydata` attribute if it is not None,
3904         else will fall back on the yaxis major formatter.
3905         """
3906         return (self.fmt_ydata if self.fmt_ydata is not None
3907                 else self.yaxis.get_major_formatter().format_data_short)(y)
3908 
3909     def format_coord(self, x, y):
3910         """Return a format string formatting the *x*, *y* coordinates."""
3911         return "x={} y={}".format(
3912             "???" if x is None else self.format_xdata(x),
3913             "???" if y is None else self.format_ydata(y),
3914         )
3915 
3916     def minorticks_on(self):
3917         """
3918         Display minor ticks on the Axes.
3919 
3920         Displaying minor ticks may reduce performance; you may turn them off
3921         using `minorticks_off()` if drawing speed is a problem.
3922         """
3923         for ax in (self.xaxis, self.yaxis):
3924             scale = ax.get_scale()
3925             if scale == 'log':
3926                 s = ax._scale
3927                 ax.set_minor_locator(mticker.LogLocator(s.base, s.subs))
3928             elif scale == 'symlog':
3929                 s = ax._scale
3930                 ax.set_minor_locator(
3931                     mticker.SymmetricalLogLocator(s._transform, s.subs))
3932             else:
3933                 ax.set_minor_locator(mticker.AutoMinorLocator())
3934 
3935     def minorticks_off(self):
3936         """Remove minor ticks from the Axes."""
3937         self.xaxis.set_minor_locator(mticker.NullLocator())
3938         self.yaxis.set_minor_locator(mticker.NullLocator())
3939 
3940     # Interactive manipulation
3941 
3942     def can_zoom(self):
3943         """
3944         Return whether this Axes supports the zoom box button functionality.
3945         """
3946         return True
3947 
3948     def can_pan(self):
3949         """
3950         Return whether this Axes supports any pan/zoom button functionality.
3951         """
3952         return True
3953 
3954     def get_navigate(self):
3955         """
3956         Get whether the Axes responds to navigation commands.
3957         """
3958         return self._navigate
3959 
3960     def set_navigate(self, b):
3961         """
3962         Set whether the Axes responds to navigation toolbar commands.
3963 
3964         Parameters
3965         ----------
3966         b : bool
3967         """
3968         self._navigate = b
3969 
3970     def get_navigate_mode(self):
3971         """
3972         Get the navigation toolbar button status: 'PAN', 'ZOOM', or None.
3973         """
3974         return self._navigate_mode
3975 
3976     def set_navigate_mode(self, b):
3977         """
3978         Set the navigation toolbar button status.
3979 
3980         .. warning::
3981             This is not a user-API function.
3982 
3983         """
3984         self._navigate_mode = b
3985 
3986     def _get_view(self):
3987         """
3988         Save information required to reproduce the current view.
3989 
3990         This method is called before a view is changed, such as during a pan or zoom
3991         initiated by the user.  It returns an opaque object that describes the current
3992         view, in a format compatible with :meth:`_set_view`.
3993 
3994         The default implementation saves the view limits and autoscaling state.
3995         Subclasses may override this as needed, as long as :meth:`_set_view` is also
3996         adjusted accordingly.
3997         """
3998         return {
3999             "xlim": self.get_xlim(), "autoscalex_on": self.get_autoscalex_on(),
4000             "ylim": self.get_ylim(), "autoscaley_on": self.get_autoscaley_on(),
4001         }
4002 
4003     def _set_view(self, view):
4004         """
4005         Apply a previously saved view.
4006 
4007         This method is called when restoring a view (with the return value of
4008         :meth:`_get_view` as argument), such as with the navigation buttons.
4009 
4010         Subclasses that override :meth:`_get_view` also need to override this method
4011         accordingly.
4012         """
4013         self.set(**view)
4014 
4015     def _prepare_view_from_bbox(self, bbox, direction='in',
4016                                 mode=None, twinx=False, twiny=False):
4017         """
4018         Helper function to prepare the new bounds from a bbox.
4019 
4020         This helper function returns the new x and y bounds from the zoom
4021         bbox. This a convenience method to abstract the bbox logic
4022         out of the base setter.
4023         """
4024         if len(bbox) == 3:
4025             xp, yp, scl = bbox  # Zooming code
4026             if scl == 0:  # Should not happen
4027                 scl = 1.
4028             if scl > 1:
4029                 direction = 'in'
4030             else:
4031                 direction = 'out'
4032                 scl = 1/scl
4033             # get the limits of the axes
4034             (xmin, ymin), (xmax, ymax) = self.transData.transform(
4035                 np.transpose([self.get_xlim(), self.get_ylim()]))
4036             # set the range
4037             xwidth = xmax - xmin
4038             ywidth = ymax - ymin
4039             xcen = (xmax + xmin)*.5
4040             ycen = (ymax + ymin)*.5
4041             xzc = (xp*(scl - 1) + xcen)/scl
4042             yzc = (yp*(scl - 1) + ycen)/scl
4043             bbox = [xzc - xwidth/2./scl, yzc - ywidth/2./scl,
4044                     xzc + xwidth/2./scl, yzc + ywidth/2./scl]
4045         elif len(bbox) != 4:
4046             # should be len 3 or 4 but nothing else
4047             _api.warn_external(
4048                 "Warning in _set_view_from_bbox: bounding box is not a tuple "
4049                 "of length 3 or 4. Ignoring the view change.")
4050             return
4051 
4052         # Original limits.
4053         xmin0, xmax0 = self.get_xbound()
4054         ymin0, ymax0 = self.get_ybound()
4055         # The zoom box in screen coords.
4056         startx, starty, stopx, stopy = bbox
4057         # Convert to data coords.
4058         (startx, starty), (stopx, stopy) = self.transData.inverted().transform(
4059             [(startx, starty), (stopx, stopy)])
4060         # Clip to axes limits.
4061         xmin, xmax = np.clip(sorted([startx, stopx]), xmin0, xmax0)
4062         ymin, ymax = np.clip(sorted([starty, stopy]), ymin0, ymax0)
4063         # Don't double-zoom twinned axes or if zooming only the other axis.
4064         if twinx or mode == "y":
4065             xmin, xmax = xmin0, xmax0
4066         if twiny or mode == "x":
4067             ymin, ymax = ymin0, ymax0
4068 
4069         if direction == "in":
4070             new_xbound = xmin, xmax
4071             new_ybound = ymin, ymax
4072 
4073         elif direction == "out":
4074             x_trf = self.xaxis.get_transform()
4075             sxmin0, sxmax0, sxmin, sxmax = x_trf.transform(
4076                 [xmin0, xmax0, xmin, xmax])  # To screen space.
4077             factor = (sxmax0 - sxmin0) / (sxmax - sxmin)  # Unzoom factor.
4078             # Move original bounds away by
4079             # (factor) x (distance between unzoom box and Axes bbox).
4080             sxmin1 = sxmin0 - factor * (sxmin - sxmin0)
4081             sxmax1 = sxmax0 + factor * (sxmax0 - sxmax)
4082             # And back to data space.
4083             new_xbound = x_trf.inverted().transform([sxmin1, sxmax1])
4084 
4085             y_trf = self.yaxis.get_transform()
4086             symin0, symax0, symin, symax = y_trf.transform(
4087                 [ymin0, ymax0, ymin, ymax])
4088             factor = (symax0 - symin0) / (symax - symin)
4089             symin1 = symin0 - factor * (symin - symin0)
4090             symax1 = symax0 + factor * (symax0 - symax)
4091             new_ybound = y_trf.inverted().transform([symin1, symax1])
4092 
4093         return new_xbound, new_ybound
4094 
4095     def _set_view_from_bbox(self, bbox, direction='in',
4096                             mode=None, twinx=False, twiny=False):
4097         """
4098         Update view from a selection bbox.
4099 
4100         .. note::
4101 
4102             Intended to be overridden by new projection types, but if not, the
4103             default implementation sets the view limits to the bbox directly.
4104 
4105         Parameters
4106         ----------
4107         bbox : 4-tuple or 3 tuple
4108             * If bbox is a 4 tuple, it is the selected bounding box limits,
4109               in *display* coordinates.
4110             * If bbox is a 3 tuple, it is an (xp, yp, scl) triple, where
4111               (xp, yp) is the center of zooming and scl the scale factor to
4112               zoom by.
4113 
4114         direction : str
4115             The direction to apply the bounding box.
4116                 * `'in'` - The bounding box describes the view directly, i.e.,
4117                            it zooms in.
4118                 * `'out'` - The bounding box describes the size to make the
4119                             existing view, i.e., it zooms out.
4120 
4121         mode : str or None
4122             The selection mode, whether to apply the bounding box in only the
4123             `'x'` direction, `'y'` direction or both (`None`).
4124 
4125         twinx : bool
4126             Whether this axis is twinned in the *x*-direction.
4127 
4128         twiny : bool
4129             Whether this axis is twinned in the *y*-direction.
4130         """
4131         new_xbound, new_ybound = self._prepare_view_from_bbox(
4132             bbox, direction=direction, mode=mode, twinx=twinx, twiny=twiny)
4133         if not twinx and mode != "y":
4134             self.set_xbound(new_xbound)
4135             self.set_autoscalex_on(False)
4136         if not twiny and mode != "x":
4137             self.set_ybound(new_ybound)
4138             self.set_autoscaley_on(False)
4139 
4140     def start_pan(self, x, y, button):
4141         """
4142         Called when a pan operation has started.
4143 
4144         Parameters
4145         ----------
4146         x, y : float
4147             The mouse coordinates in display coords.
4148         button : `.MouseButton`
4149             The pressed mouse button.
4150 
4151         Notes
4152         -----
4153         This is intended to be overridden by new projection types.
4154         """
4155         self._pan_start = types.SimpleNamespace(
4156             lim=self.viewLim.frozen(),
4157             trans=self.transData.frozen(),
4158             trans_inverse=self.transData.inverted().frozen(),
4159             bbox=self.bbox.frozen(),
4160             x=x,
4161             y=y)
4162 
4163     def end_pan(self):
4164         """
4165         Called when a pan operation completes (when the mouse button is up.)
4166 
4167         Notes
4168         -----
4169         This is intended to be overridden by new projection types.
4170         """
4171         del self._pan_start
4172 
4173     def _get_pan_points(self, button, key, x, y):
4174         """
4175         Helper function to return the new points after a pan.
4176 
4177         This helper function returns the points on the axis after a pan has
4178         occurred. This is a convenience method to abstract the pan logic
4179         out of the base setter.
4180         """
4181         def format_deltas(key, dx, dy):
4182             if key == 'control':
4183                 if abs(dx) > abs(dy):
4184                     dy = dx
4185                 else:
4186                     dx = dy
4187             elif key == 'x':
4188                 dy = 0
4189             elif key == 'y':
4190                 dx = 0
4191             elif key == 'shift':
4192                 if 2 * abs(dx) < abs(dy):
4193                     dx = 0
4194                 elif 2 * abs(dy) < abs(dx):
4195                     dy = 0
4196                 elif abs(dx) > abs(dy):
4197                     dy = dy / abs(dy) * abs(dx)
4198                 else:
4199                     dx = dx / abs(dx) * abs(dy)
4200             return dx, dy
4201 
4202         p = self._pan_start
4203         dx = x - p.x
4204         dy = y - p.y
4205         if dx == dy == 0:
4206             return
4207         if button == 1:
4208             dx, dy = format_deltas(key, dx, dy)
4209             result = p.bbox.translated(-dx, -dy).transformed(p.trans_inverse)
4210         elif button == 3:
4211             try:
4212                 dx = -dx / self.bbox.width
4213                 dy = -dy / self.bbox.height
4214                 dx, dy = format_deltas(key, dx, dy)
4215                 if self.get_aspect() != 'auto':
4216                     dx = dy = 0.5 * (dx + dy)
4217                 alpha = np.power(10.0, (dx, dy))
4218                 start = np.array([p.x, p.y])
4219                 oldpoints = p.lim.transformed(p.trans)
4220                 newpoints = start + alpha * (oldpoints - start)
4221                 result = (mtransforms.Bbox(newpoints)
4222                           .transformed(p.trans_inverse))
4223             except OverflowError:
4224                 _api.warn_external('Overflow while panning')
4225                 return
4226         else:
4227             return
4228 
4229         valid = np.isfinite(result.transformed(p.trans))
4230         points = result.get_points().astype(object)
4231         # Just ignore invalid limits (typically, underflow in log-scale).
4232         points[~valid] = None
4233         return points
4234 
4235     def drag_pan(self, button, key, x, y):
4236         """
4237         Called when the mouse moves during a pan operation.
4238 
4239         Parameters
4240         ----------
4241         button : `.MouseButton`
4242             The pressed mouse button.
4243         key : str or None
4244             The pressed key, if any.
4245         x, y : float
4246             The mouse coordinates in display coords.
4247 
4248         Notes
4249         -----
4250         This is intended to be overridden by new projection types.
4251         """
4252         points = self._get_pan_points(button, key, x, y)
4253         if points is not None:
4254             self.set_xlim(points[:, 0])
4255             self.set_ylim(points[:, 1])
4256 
4257     def get_children(self):
4258         # docstring inherited.
4259         return [
4260             *self._children,
4261             *self.spines.values(),
4262             *self._axis_map.values(),
4263             self.title, self._left_title, self._right_title,
4264             *self.child_axes,
4265             *([self.legend_] if self.legend_ is not None else []),
4266             self.patch,
4267         ]
4268 
4269     def contains(self, mouseevent):
4270         # docstring inherited.
4271         return self.patch.contains(mouseevent)
4272 
4273     def contains_point(self, point):
4274         """
4275         Return whether *point* (pair of pixel coordinates) is inside the Axes
4276         patch.
4277         """
4278         return self.patch.contains_point(point, radius=1.0)
4279 
4280     def get_default_bbox_extra_artists(self):
4281         """
4282         Return a default list of artists that are used for the bounding box
4283         calculation.
4284 
4285         Artists are excluded either by not being visible or
4286         ``artist.set_in_layout(False)``.
4287         """
4288 
4289         artists = self.get_children()
4290 
4291         for axis in self._axis_map.values():
4292             # axis tight bboxes are calculated separately inside
4293             # Axes.get_tightbbox() using for_layout_only=True
4294             artists.remove(axis)
4295         if not (self.axison and self._frameon):
4296             # don't do bbox on spines if frame not on.
4297             for spine in self.spines.values():
4298                 artists.remove(spine)
4299 
4300         artists.remove(self.title)
4301         artists.remove(self._left_title)
4302         artists.remove(self._right_title)
4303 
4304         # always include types that do not internally implement clipping
4305         # to Axes. may have clip_on set to True and clip_box equivalent
4306         # to ax.bbox but then ignore these properties during draws.
4307         noclip = (_AxesBase, maxis.Axis,
4308                   offsetbox.AnnotationBbox, offsetbox.OffsetBox)
4309         return [a for a in artists if a.get_visible() and a.get_in_layout()
4310                 and (isinstance(a, noclip) or not a._fully_clipped_to_axes())]
4311 
4312     @_api.make_keyword_only("3.8", "call_axes_locator")
4313     def get_tightbbox(self, renderer=None, call_axes_locator=True,
4314                       bbox_extra_artists=None, *, for_layout_only=False):
4315         """
4316         Return the tight bounding box of the Axes, including axis and their
4317         decorators (xlabel, title, etc).
4318 
4319         Artists that have ``artist.set_in_layout(False)`` are not included
4320         in the bbox.
4321 
4322         Parameters
4323         ----------
4324         renderer : `.RendererBase` subclass
4325             renderer that will be used to draw the figures (i.e.
4326             ``fig.canvas.get_renderer()``)
4327 
4328         bbox_extra_artists : list of `.Artist` or ``None``
4329             List of artists to include in the tight bounding box.  If
4330             ``None`` (default), then all artist children of the Axes are
4331             included in the tight bounding box.
4332 
4333         call_axes_locator : bool, default: True
4334             If *call_axes_locator* is ``False``, it does not call the
4335             ``_axes_locator`` attribute, which is necessary to get the correct
4336             bounding box. ``call_axes_locator=False`` can be used if the
4337             caller is only interested in the relative size of the tightbbox
4338             compared to the Axes bbox.
4339 
4340         for_layout_only : default: False
4341             The bounding box will *not* include the x-extent of the title and
4342             the xlabel, or the y-extent of the ylabel.
4343 
4344         Returns
4345         -------
4346         `.BboxBase`
4347             Bounding box in figure pixel coordinates.
4348 
4349         See Also
4350         --------
4351         matplotlib.axes.Axes.get_window_extent
4352         matplotlib.axis.Axis.get_tightbbox
4353         matplotlib.spines.Spine.get_window_extent
4354         """
4355 
4356         bb = []
4357         if renderer is None:
4358             renderer = self.figure._get_renderer()
4359 
4360         if not self.get_visible():
4361             return None
4362 
4363         locator = self.get_axes_locator()
4364         self.apply_aspect(
4365             locator(self, renderer) if locator and call_axes_locator else None)
4366 
4367         for axis in self._axis_map.values():
4368             if self.axison and axis.get_visible():
4369                 ba = martist._get_tightbbox_for_layout_only(axis, renderer)
4370                 if ba:
4371                     bb.append(ba)
4372         self._update_title_position(renderer)
4373         axbbox = self.get_window_extent(renderer)
4374         bb.append(axbbox)
4375 
4376         for title in [self.title, self._left_title, self._right_title]:
4377             if title.get_visible():
4378                 bt = title.get_window_extent(renderer)
4379                 if for_layout_only and bt.width > 0:
4380                     # make the title bbox 1 pixel wide so its width
4381                     # is not accounted for in bbox calculations in
4382                     # tight/constrained_layout
4383                     bt.x0 = (bt.x0 + bt.x1) / 2 - 0.5
4384                     bt.x1 = bt.x0 + 1.0
4385                 bb.append(bt)
4386 
4387         bbox_artists = bbox_extra_artists
4388         if bbox_artists is None:
4389             bbox_artists = self.get_default_bbox_extra_artists()
4390 
4391         for a in bbox_artists:
4392             bbox = a.get_tightbbox(renderer)
4393             if (bbox is not None
4394                     and 0 < bbox.width < np.inf
4395                     and 0 < bbox.height < np.inf):
4396                 bb.append(bbox)
4397         return mtransforms.Bbox.union(
4398             [b for b in bb if b.width != 0 or b.height != 0])
4399 
4400     def _make_twin_axes(self, *args, **kwargs):
4401         """Make a twinx Axes of self. This is used for twinx and twiny."""
4402         if 'sharex' in kwargs and 'sharey' in kwargs:
4403             # The following line is added in v2.2 to avoid breaking Seaborn,
4404             # which currently uses this internal API.
4405             if kwargs["sharex"] is not self and kwargs["sharey"] is not self:
4406                 raise ValueError("Twinned Axes may share only one axis")
4407         ss = self.get_subplotspec()
4408         if ss:
4409             twin = self.figure.add_subplot(ss, *args, **kwargs)
4410         else:
4411             twin = self.figure.add_axes(
4412                 self.get_position(True), *args, **kwargs,
4413                 axes_locator=_TransformedBoundsLocator(
4414                     [0, 0, 1, 1], self.transAxes))
4415         self.set_adjustable('datalim')
4416         twin.set_adjustable('datalim')
4417         self._twinned_axes.join(self, twin)
4418         return twin
4419 
4420     def twinx(self):
4421         """
4422         Create a twin Axes sharing the xaxis.
4423 
4424         Create a new Axes with an invisible x-axis and an independent
4425         y-axis positioned opposite to the original one (i.e. at right). The
4426         x-axis autoscale setting will be inherited from the original
4427         Axes.  To ensure that the tick marks of both y-axes align, see
4428         `~matplotlib.ticker.LinearLocator`.
4429 
4430         Returns
4431         -------
4432         Axes
4433             The newly created Axes instance
4434 
4435         Notes
4436         -----
4437         For those who are 'picking' artists while using twinx, pick
4438         events are only called for the artists in the top-most Axes.
4439         """
4440         ax2 = self._make_twin_axes(sharex=self)
4441         ax2.yaxis.tick_right()
4442         ax2.yaxis.set_label_position('right')
4443         ax2.yaxis.set_offset_position('right')
4444         ax2.set_autoscalex_on(self.get_autoscalex_on())
4445         self.yaxis.tick_left()
4446         ax2.xaxis.set_visible(False)
4447         ax2.patch.set_visible(False)
4448         return ax2
4449 
4450     def twiny(self):
4451         """
4452         Create a twin Axes sharing the yaxis.
4453 
4454         Create a new Axes with an invisible y-axis and an independent
4455         x-axis positioned opposite to the original one (i.e. at top). The
4456         y-axis autoscale setting will be inherited from the original Axes.
4457         To ensure that the tick marks of both x-axes align, see
4458         `~matplotlib.ticker.LinearLocator`.
4459 
4460         Returns
4461         -------
4462         Axes
4463             The newly created Axes instance
4464 
4465         Notes
4466         -----
4467         For those who are 'picking' artists while using twiny, pick
4468         events are only called for the artists in the top-most Axes.
4469         """
4470         ax2 = self._make_twin_axes(sharey=self)
4471         ax2.xaxis.tick_top()
4472         ax2.xaxis.set_label_position('top')
4473         ax2.set_autoscaley_on(self.get_autoscaley_on())
4474         self.xaxis.tick_bottom()
4475         ax2.yaxis.set_visible(False)
4476         ax2.patch.set_visible(False)
4477         return ax2
4478 
4479     def get_shared_x_axes(self):
4480         """Return an immutable view on the shared x-axes Grouper."""
4481         return cbook.GrouperView(self._shared_axes["x"])
4482 
4483     def get_shared_y_axes(self):
4484         """Return an immutable view on the shared y-axes Grouper."""
4485         return cbook.GrouperView(self._shared_axes["y"])
4486 
4487     def label_outer(self):
4488         """
4489         Only show "outer" labels and tick labels.
4490 
4491         x-labels are only kept for subplots on the last row (or first row, if
4492         labels are on the top side); y-labels only for subplots on the first
4493         column (or last column, if labels are on the right side).
4494         """
4495         self._label_outer_xaxis(check_patch=False)
4496         self._label_outer_yaxis(check_patch=False)
4497 
4498     def _label_outer_xaxis(self, *, check_patch):
4499         # see documentation in label_outer.
4500         if check_patch and not isinstance(self.patch, mpl.patches.Rectangle):
4501             return
4502         ss = self.get_subplotspec()
4503         if not ss:
4504             return
4505         label_position = self.xaxis.get_label_position()
4506         if not ss.is_first_row():  # Remove top label/ticklabels/offsettext.
4507             if label_position == "top":
4508                 self.set_xlabel("")
4509             self.xaxis.set_tick_params(which="both", labeltop=False)
4510             if self.xaxis.offsetText.get_position()[1] == 1:
4511                 self.xaxis.offsetText.set_visible(False)
4512         if not ss.is_last_row():  # Remove bottom label/ticklabels/offsettext.
4513             if label_position == "bottom":
4514                 self.set_xlabel("")
4515             self.xaxis.set_tick_params(which="both", labelbottom=False)
4516             if self.xaxis.offsetText.get_position()[1] == 0:
4517                 self.xaxis.offsetText.set_visible(False)
4518 
4519     def _label_outer_yaxis(self, *, check_patch):
4520         # see documentation in label_outer.
4521         if check_patch and not isinstance(self.patch, mpl.patches.Rectangle):
4522             return
4523         ss = self.get_subplotspec()
4524         if not ss:
4525             return
4526         label_position = self.yaxis.get_label_position()
4527         if not ss.is_first_col():  # Remove left label/ticklabels/offsettext.
4528             if label_position == "left":
4529                 self.set_ylabel("")
4530             self.yaxis.set_tick_params(which="both", labelleft=False)
4531             if self.yaxis.offsetText.get_position()[0] == 0:
4532                 self.yaxis.offsetText.set_visible(False)
4533         if not ss.is_last_col():  # Remove right label/ticklabels/offsettext.
4534             if label_position == "right":
4535                 self.set_ylabel("")
4536             self.yaxis.set_tick_params(which="both", labelright=False)
4537             if self.yaxis.offsetText.get_position()[0] == 1:
4538                 self.yaxis.offsetText.set_visible(False)

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>, <file>lib/mpl_toolkits/mplot3d/axes3d.py</file>
<class>Axes3D</class>
<method>tick_params</method>
<code>
1346     def tick_params(self, axis='both', **kwargs):
1347         """
1348         Convenience method for changing the appearance of ticks and
1349         tick labels.
1350 
1351         See `.Axes.tick_params` for full documentation.  Because this function
1352         applies to 3D Axes, *axis* can also be set to 'z', and setting *axis*
1353         to 'both' autoscales all three axes.
1354 
1355         Also, because of how Axes3D objects are drawn very differently
1356         from regular 2D axes, some of these settings may have
1357         ambiguous meaning.  For simplicity, the 'z' axis will
1358         accept settings as if it was like the 'y' axis.
1359 
1360         .. note::
1361            Axes3D currently ignores some of these settings.
1362         """
1363         _api.check_in_list(['x', 'y', 'z', 'both'], axis=axis)
1364         if axis in ['x', 'y', 'both']:
1365             super().tick_params(axis, **kwargs)
1366         if axis in ['z', 'both']:
1367             zkw = dict(kwargs)
1368             zkw.pop('top', None)
1369             zkw.pop('bottom', None)
1370             zkw.pop('labeltop', None)
1371             zkw.pop('labelbottom', None)
1372             self.zaxis.set_tick_params(**zkw)

</code><intended_behavior>Update the `tick_params` method to accept and correctly apply a `fontfamily` keyword argument for the 'x', 'y', and crucially, the 'z' axis, considering the 3D context. As with the 2D scenario, ensure that specifying `fontfamily` changes the font family of the tick labels according to the user's input while keeping all other functionalities intact. Special attention should be paid to integrating this functionality within the 3D plotting constraints and ensuring compatibility with the generalized matplotlib styles and options framework. Furthermore, since the 3D method calls its 2D counterpart for the 'x' and 'y' axes, care must be taken to harmonize the handling of `fontfamily` between these implementations.</intended_behavior>, <file>lib/mpl_toolkits/mplot3d/axes3d.py</file>
<class>Axes3D</class>
<method>None</method>
<code>
45 class Axes3D(Axes):
46     """
47     3D Axes object.
48 
49     .. note::
50 
51         As a user, you do not instantiate Axes directly, but use Axes creation
52         methods instead; e.g. from `.pyplot` or `.Figure`:
53         `~.pyplot.subplots`, `~.pyplot.subplot_mosaic` or `.Figure.add_axes`.
54     """
55     name = '3d'
56 
57     _axis_names = ("x", "y", "z")
58     Axes._shared_axes["z"] = cbook.Grouper()
59 
60     vvec = _api.deprecate_privatize_attribute("3.7")
61     eye = _api.deprecate_privatize_attribute("3.7")
62     sx = _api.deprecate_privatize_attribute("3.7")
63     sy = _api.deprecate_privatize_attribute("3.7")
64 
65     def __init__(
66             self, fig, rect=None, *args,
67             elev=30, azim=-60, roll=0, sharez=None, proj_type='persp',
68             box_aspect=None, computed_zorder=True, focal_length=None,
69             **kwargs):
70         """
71         Parameters
72         ----------
73         fig : Figure
74             The parent figure.
75         rect : tuple (left, bottom, width, height), default: None.
76             The ``(left, bottom, width, height)`` axes position.
77         elev : float, default: 30
78             The elevation angle in degrees rotates the camera above and below
79             the x-y plane, with a positive angle corresponding to a location
80             above the plane.
81         azim : float, default: -60
82             The azimuthal angle in degrees rotates the camera about the z axis,
83             with a positive angle corresponding to a right-handed rotation. In
84             other words, a positive azimuth rotates the camera about the origin
85             from its location along the +x axis towards the +y axis.
86         roll : float, default: 0
87             The roll angle in degrees rotates the camera about the viewing
88             axis. A positive angle spins the camera clockwise, causing the
89             scene to rotate counter-clockwise.
90         sharez : Axes3D, optional
91             Other Axes to share z-limits with.
92         proj_type : {'persp', 'ortho'}
93             The projection type, default 'persp'.
94         box_aspect : 3-tuple of floats, default: None
95             Changes the physical dimensions of the Axes3D, such that the ratio
96             of the axis lengths in display units is x:y:z.
97             If None, defaults to 4:4:3
98         computed_zorder : bool, default: True
99             If True, the draw order is computed based on the average position
100             of the `.Artist`\\s along the view direction.
101             Set to False if you want to manually control the order in which
102             Artists are drawn on top of each other using their *zorder*
103             attribute. This can be used for fine-tuning if the automatic order
104             does not produce the desired result. Note however, that a manual
105             zorder will only be correct for a limited view angle. If the figure
106             is rotated by the user, it will look wrong from certain angles.
107         focal_length : float, default: None
108             For a projection type of 'persp', the focal length of the virtual
109             camera. Must be > 0. If None, defaults to 1.
110             For a projection type of 'ortho', must be set to either None
111             or infinity (numpy.inf). If None, defaults to infinity.
112             The focal length can be computed from a desired Field Of View via
113             the equation: focal_length = 1/tan(FOV/2)
114 
115         **kwargs
116             Other optional keyword arguments:
117 
118             %(Axes3D:kwdoc)s
119         """
120 
121         if rect is None:
122             rect = [0.0, 0.0, 1.0, 1.0]
123 
124         self.initial_azim = azim
125         self.initial_elev = elev
126         self.initial_roll = roll
127         self.set_proj_type(proj_type, focal_length)
128         self.computed_zorder = computed_zorder
129 
130         self.xy_viewLim = Bbox.unit()
131         self.zz_viewLim = Bbox.unit()
132         self.xy_dataLim = Bbox.unit()
133         # z-limits are encoded in the x-component of the Bbox, y is un-used
134         self.zz_dataLim = Bbox.unit()
135 
136         # inhibit autoscale_view until the axes are defined
137         # they can't be defined until Axes.__init__ has been called
138         self.view_init(self.initial_elev, self.initial_azim, self.initial_roll)
139 
140         self._sharez = sharez
141         if sharez is not None:
142             self._shared_axes["z"].join(self, sharez)
143             self._adjustable = 'datalim'
144 
145         if kwargs.pop('auto_add_to_figure', False):
146             raise AttributeError(
147                 'auto_add_to_figure is no longer supported for Axes3D. '
148                 'Use fig.add_axes(ax) instead.'
149             )
150 
151         super().__init__(
152             fig, rect, frameon=True, box_aspect=box_aspect, *args, **kwargs
153         )
154         # Disable drawing of axes by base class
155         super().set_axis_off()
156         # Enable drawing of axes by Axes3D class
157         self.set_axis_on()
158         self.M = None
159 
160         # func used to format z -- fall back on major formatters
161         self.fmt_zdata = None
162 
163         self.mouse_init()
164         self.figure.canvas.callbacks._connect_picklable(
165             'motion_notify_event', self._on_move)
166         self.figure.canvas.callbacks._connect_picklable(
167             'button_press_event', self._button_press)
168         self.figure.canvas.callbacks._connect_picklable(
169             'button_release_event', self._button_release)
170         self.set_top_view()
171 
172         self.patch.set_linewidth(0)
173         # Calculate the pseudo-data width and height
174         pseudo_bbox = self.transLimits.inverted().transform([(0, 0), (1, 1)])
175         self._pseudo_w, self._pseudo_h = pseudo_bbox[1] - pseudo_bbox[0]
176 
177         # mplot3d currently manages its own spines and needs these turned off
178         # for bounding box calculations
179         self.spines[:].set_visible(False)
180 
181     def set_axis_off(self):
182         self._axis3don = False
183         self.stale = True
184 
185     def set_axis_on(self):
186         self._axis3don = True
187         self.stale = True
188 
189     def convert_zunits(self, z):
190         """
191         For artists in an Axes, if the zaxis has units support,
192         convert *z* using zaxis unit type
193         """
194         return self.zaxis.convert_units(z)
195 
196     def set_top_view(self):
197         # this happens to be the right view for the viewing coordinates
198         # moved up and to the left slightly to fit labels and axes
199         xdwl = 0.95 / self._dist
200         xdw = 0.9 / self._dist
201         ydwl = 0.95 / self._dist
202         ydw = 0.9 / self._dist
203         # Set the viewing pane.
204         self.viewLim.intervalx = (-xdwl, xdw)
205         self.viewLim.intervaly = (-ydwl, ydw)
206         self.stale = True
207 
208     def _init_axis(self):
209         """Init 3D axes; overrides creation of regular X/Y axes."""
210         self.xaxis = axis3d.XAxis(self)
211         self.yaxis = axis3d.YAxis(self)
212         self.zaxis = axis3d.ZAxis(self)
213 
214     def get_zaxis(self):
215         """Return the ``ZAxis`` (`~.axis3d.Axis`) instance."""
216         return self.zaxis
217 
218     get_zgridlines = _axis_method_wrapper("zaxis", "get_gridlines")
219     get_zticklines = _axis_method_wrapper("zaxis", "get_ticklines")
220 
221     @_api.deprecated("3.7")
222     def unit_cube(self, vals=None):
223         return self._unit_cube(vals)
224 
225     def _unit_cube(self, vals=None):
226         minx, maxx, miny, maxy, minz, maxz = vals or self.get_w_lims()
227         return [(minx, miny, minz),
228                 (maxx, miny, minz),
229                 (maxx, maxy, minz),
230                 (minx, maxy, minz),
231                 (minx, miny, maxz),
232                 (maxx, miny, maxz),
233                 (maxx, maxy, maxz),
234                 (minx, maxy, maxz)]
235 
236     @_api.deprecated("3.7")
237     def tunit_cube(self, vals=None, M=None):
238         return self._tunit_cube(vals, M)
239 
240     def _tunit_cube(self, vals=None, M=None):
241         if M is None:
242             M = self.M
243         xyzs = self._unit_cube(vals)
244         tcube = proj3d._proj_points(xyzs, M)
245         return tcube
246 
247     @_api.deprecated("3.7")
248     def tunit_edges(self, vals=None, M=None):
249         return self._tunit_edges(vals, M)
250 
251     def _tunit_edges(self, vals=None, M=None):
252         tc = self._tunit_cube(vals, M)
253         edges = [(tc[0], tc[1]),
254                  (tc[1], tc[2]),
255                  (tc[2], tc[3]),
256                  (tc[3], tc[0]),
257 
258                  (tc[0], tc[4]),
259                  (tc[1], tc[5]),
260                  (tc[2], tc[6]),
261                  (tc[3], tc[7]),
262 
263                  (tc[4], tc[5]),
264                  (tc[5], tc[6]),
265                  (tc[6], tc[7]),
266                  (tc[7], tc[4])]
267         return edges
268 
269     def set_aspect(self, aspect, adjustable=None, anchor=None, share=False):
270         """
271         Set the aspect ratios.
272 
273         Parameters
274         ----------
275         aspect : {'auto', 'equal', 'equalxy', 'equalxz', 'equalyz'}
276             Possible values:
277 
278             =========   ==================================================
279             value       description
280             =========   ==================================================
281             'auto'      automatic; fill the position rectangle with data.
282             'equal'     adapt all the axes to have equal aspect ratios.
283             'equalxy'   adapt the x and y axes to have equal aspect ratios.
284             'equalxz'   adapt the x and z axes to have equal aspect ratios.
285             'equalyz'   adapt the y and z axes to have equal aspect ratios.
286             =========   ==================================================
287 
288         adjustable : None or {'box', 'datalim'}, optional
289             If not *None*, this defines which parameter will be adjusted to
290             meet the required aspect. See `.set_adjustable` for further
291             details.
292 
293         anchor : None or str or 2-tuple of float, optional
294             If not *None*, this defines where the Axes will be drawn if there
295             is extra space due to aspect constraints. The most common way to
296             specify the anchor are abbreviations of cardinal directions:
297 
298             =====   =====================
299             value   description
300             =====   =====================
301             'C'     centered
302             'SW'    lower left corner
303             'S'     middle of bottom edge
304             'SE'    lower right corner
305             etc.
306             =====   =====================
307 
308             See `~.Axes.set_anchor` for further details.
309 
310         share : bool, default: False
311             If ``True``, apply the settings to all shared Axes.
312 
313         See Also
314         --------
315         mpl_toolkits.mplot3d.axes3d.Axes3D.set_box_aspect
316         """
317         _api.check_in_list(('auto', 'equal', 'equalxy', 'equalyz', 'equalxz'),
318                            aspect=aspect)
319         super().set_aspect(
320             aspect='auto', adjustable=adjustable, anchor=anchor, share=share)
321         self._aspect = aspect
322 
323         if aspect in ('equal', 'equalxy', 'equalxz', 'equalyz'):
324             ax_indices = self._equal_aspect_axis_indices(aspect)
325 
326             view_intervals = np.array([self.xaxis.get_view_interval(),
327                                        self.yaxis.get_view_interval(),
328                                        self.zaxis.get_view_interval()])
329             ptp = np.ptp(view_intervals, axis=1)
330             if self._adjustable == 'datalim':
331                 mean = np.mean(view_intervals, axis=1)
332                 scale = max(ptp[ax_indices] / self._box_aspect[ax_indices])
333                 deltas = scale * self._box_aspect
334 
335                 for i, set_lim in enumerate((self.set_xlim3d,
336                                              self.set_ylim3d,
337                                              self.set_zlim3d)):
338                     if i in ax_indices:
339                         set_lim(mean[i] - deltas[i]/2., mean[i] + deltas[i]/2.)
340             else:  # 'box'
341                 # Change the box aspect such that the ratio of the length of
342                 # the unmodified axis to the length of the diagonal
343                 # perpendicular to it remains unchanged.
344                 box_aspect = np.array(self._box_aspect)
345                 box_aspect[ax_indices] = ptp[ax_indices]
346                 remaining_ax_indices = {0, 1, 2}.difference(ax_indices)
347                 if remaining_ax_indices:
348                     remaining = remaining_ax_indices.pop()
349                     old_diag = np.linalg.norm(self._box_aspect[ax_indices])
350                     new_diag = np.linalg.norm(box_aspect[ax_indices])
351                     box_aspect[remaining] *= new_diag / old_diag
352                 self.set_box_aspect(box_aspect)
353 
354     def _equal_aspect_axis_indices(self, aspect):
355         """
356         Get the indices for which of the x, y, z axes are constrained to have
357         equal aspect ratios.
358 
359         Parameters
360         ----------
361         aspect : {'auto', 'equal', 'equalxy', 'equalxz', 'equalyz'}
362             See descriptions in docstring for `.set_aspect()`.
363         """
364         ax_indices = []  # aspect == 'auto'
365         if aspect == 'equal':
366             ax_indices = [0, 1, 2]
367         elif aspect == 'equalxy':
368             ax_indices = [0, 1]
369         elif aspect == 'equalxz':
370             ax_indices = [0, 2]
371         elif aspect == 'equalyz':
372             ax_indices = [1, 2]
373         return ax_indices
374 
375     def set_box_aspect(self, aspect, *, zoom=1):
376         """
377         Set the Axes box aspect.
378 
379         The box aspect is the ratio of height to width in display
380         units for each face of the box when viewed perpendicular to
381         that face.  This is not to be confused with the data aspect (see
382         `~.Axes3D.set_aspect`). The default ratios are 4:4:3 (x:y:z).
383 
384         To simulate having equal aspect in data space, set the box
385         aspect to match your data range in each dimension.
386 
387         *zoom* controls the overall size of the Axes3D in the figure.
388 
389         Parameters
390         ----------
391         aspect : 3-tuple of floats or None
392             Changes the physical dimensions of the Axes3D, such that the ratio
393             of the axis lengths in display units is x:y:z.
394             If None, defaults to (4, 4, 3).
395 
396         zoom : float, default: 1
397             Control overall size of the Axes3D in the figure. Must be > 0.
398         """
399         if zoom <= 0:
400             raise ValueError(f'Argument zoom = {zoom} must be > 0')
401 
402         if aspect is None:
403             aspect = np.asarray((4, 4, 3), dtype=float)
404         else:
405             aspect = np.asarray(aspect, dtype=float)
406             _api.check_shape((3,), aspect=aspect)
407         # default scale tuned to match the mpl32 appearance.
408         aspect *= 1.8294640721620434 * zoom / np.linalg.norm(aspect)
409 
410         self._box_aspect = aspect
411         self.stale = True
412 
413     def apply_aspect(self, position=None):
414         if position is None:
415             position = self.get_position(original=True)
416 
417         # in the superclass, we would go through and actually deal with axis
418         # scales and box/datalim. Those are all irrelevant - all we need to do
419         # is make sure our coordinate system is square.
420         trans = self.get_figure().transSubfigure
421         bb = mtransforms.Bbox.unit().transformed(trans)
422         # this is the physical aspect of the panel (or figure):
423         fig_aspect = bb.height / bb.width
424 
425         box_aspect = 1
426         pb = position.frozen()
427         pb1 = pb.shrunk_to_aspect(box_aspect, pb, fig_aspect)
428         self._set_position(pb1.anchored(self.get_anchor(), pb), 'active')
429 
430     @martist.allow_rasterization
431     def draw(self, renderer):
432         if not self.get_visible():
433             return
434         self._unstale_viewLim()
435 
436         # draw the background patch
437         self.patch.draw(renderer)
438         self._frameon = False
439 
440         # first, set the aspect
441         # this is duplicated from `axes._base._AxesBase.draw`
442         # but must be called before any of the artist are drawn as
443         # it adjusts the view limits and the size of the bounding box
444         # of the Axes
445         locator = self.get_axes_locator()
446         self.apply_aspect(locator(self, renderer) if locator else None)
447 
448         # add the projection matrix to the renderer
449         self.M = self.get_proj()
450 
451         collections_and_patches = (
452             artist for artist in self._children
453             if isinstance(artist, (mcoll.Collection, mpatches.Patch))
454             and artist.get_visible())
455         if self.computed_zorder:
456             # Calculate projection of collections and patches and zorder
457             # them. Make sure they are drawn above the grids.
458             zorder_offset = max(axis.get_zorder()
459                                 for axis in self._axis_map.values()) + 1
460             collection_zorder = patch_zorder = zorder_offset
461 
462             for artist in sorted(collections_and_patches,
463                                  key=lambda artist: artist.do_3d_projection(),
464                                  reverse=True):
465                 if isinstance(artist, mcoll.Collection):
466                     artist.zorder = collection_zorder
467                     collection_zorder += 1
468                 elif isinstance(artist, mpatches.Patch):
469                     artist.zorder = patch_zorder
470                     patch_zorder += 1
471         else:
472             for artist in collections_and_patches:
473                 artist.do_3d_projection()
474 
475         if self._axis3don:
476             # Draw panes first
477             for axis in self._axis_map.values():
478                 axis.draw_pane(renderer)
479             # Then gridlines
480             for axis in self._axis_map.values():
481                 axis.draw_grid(renderer)
482             # Then axes, labels, text, and ticks
483             for axis in self._axis_map.values():
484                 axis.draw(renderer)
485 
486         # Then rest
487         super().draw(renderer)
488 
489     def get_axis_position(self):
490         vals = self.get_w_lims()
491         tc = self._tunit_cube(vals, self.M)
492         xhigh = tc[1][2] > tc[2][2]
493         yhigh = tc[3][2] > tc[2][2]
494         zhigh = tc[0][2] > tc[2][2]
495         return xhigh, yhigh, zhigh
496 
497     def update_datalim(self, xys, **kwargs):
498         """
499         Not implemented in `~mpl_toolkits.mplot3d.axes3d.Axes3D`.
500         """
501         pass
502 
503     get_autoscalez_on = _axis_method_wrapper("zaxis", "_get_autoscale_on")
504     set_autoscalez_on = _axis_method_wrapper("zaxis", "_set_autoscale_on")
505 
506     def set_zmargin(self, m):
507         """
508         Set padding of Z data limits prior to autoscaling.
509 
510         *m* times the data interval will be added to each end of that interval
511         before it is used in autoscaling.  If *m* is negative, this will clip
512         the data range instead of expanding it.
513 
514         For example, if your data is in the range [0, 2], a margin of 0.1 will
515         result in a range [-0.2, 2.2]; a margin of -0.1 will result in a range
516         of [0.2, 1.8].
517 
518         Parameters
519         ----------
520         m : float greater than -0.5
521         """
522         if m <= -0.5:
523             raise ValueError("margin must be greater than -0.5")
524         self._zmargin = m
525         self._request_autoscale_view("z")
526         self.stale = True
527 
528     def margins(self, *margins, x=None, y=None, z=None, tight=True):
529         """
530         Set or retrieve autoscaling margins.
531 
532         See `.Axes.margins` for full documentation.  Because this function
533         applies to 3D Axes, it also takes a *z* argument, and returns
534         ``(xmargin, ymargin, zmargin)``.
535         """
536         if margins and (x is not None or y is not None or z is not None):
537             raise TypeError('Cannot pass both positional and keyword '
538                             'arguments for x, y, and/or z.')
539         elif len(margins) == 1:
540             x = y = z = margins[0]
541         elif len(margins) == 3:
542             x, y, z = margins
543         elif margins:
544             raise TypeError('Must pass a single positional argument for all '
545                             'margins, or one for each margin (x, y, z).')
546 
547         if x is None and y is None and z is None:
548             if tight is not True:
549                 _api.warn_external(f'ignoring tight={tight!r} in get mode')
550             return self._xmargin, self._ymargin, self._zmargin
551 
552         if x is not None:
553             self.set_xmargin(x)
554         if y is not None:
555             self.set_ymargin(y)
556         if z is not None:
557             self.set_zmargin(z)
558 
559         self.autoscale_view(
560             tight=tight, scalex=(x is not None), scaley=(y is not None),
561             scalez=(z is not None)
562         )
563 
564     def autoscale(self, enable=True, axis='both', tight=None):
565         """
566         Convenience method for simple axis view autoscaling.
567 
568         See `.Axes.autoscale` for full documentation.  Because this function
569         applies to 3D Axes, *axis* can also be set to 'z', and setting *axis*
570         to 'both' autoscales all three axes.
571         """
572         if enable is None:
573             scalex = True
574             scaley = True
575             scalez = True
576         else:
577             if axis in ['x', 'both']:
578                 self.set_autoscalex_on(bool(enable))
579                 scalex = self.get_autoscalex_on()
580             else:
581                 scalex = False
582             if axis in ['y', 'both']:
583                 self.set_autoscaley_on(bool(enable))
584                 scaley = self.get_autoscaley_on()
585             else:
586                 scaley = False
587             if axis in ['z', 'both']:
588                 self.set_autoscalez_on(bool(enable))
589                 scalez = self.get_autoscalez_on()
590             else:
591                 scalez = False
592         if scalex:
593             self._request_autoscale_view("x", tight=tight)
594         if scaley:
595             self._request_autoscale_view("y", tight=tight)
596         if scalez:
597             self._request_autoscale_view("z", tight=tight)
598 
599     def auto_scale_xyz(self, X, Y, Z=None, had_data=None):
600         # This updates the bounding boxes as to keep a record as to what the
601         # minimum sized rectangular volume holds the data.
602         if np.shape(X) == np.shape(Y):
603             self.xy_dataLim.update_from_data_xy(
604                 np.column_stack([np.ravel(X), np.ravel(Y)]), not had_data)
605         else:
606             self.xy_dataLim.update_from_data_x(X, not had_data)
607             self.xy_dataLim.update_from_data_y(Y, not had_data)
608         if Z is not None:
609             self.zz_dataLim.update_from_data_x(Z, not had_data)
610         # Let autoscale_view figure out how to use this data.
611         self.autoscale_view()
612 
613     def autoscale_view(self, tight=None, scalex=True, scaley=True,
614                        scalez=True):
615         """
616         Autoscale the view limits using the data limits.
617 
618         See `.Axes.autoscale_view` for full documentation.  Because this
619         function applies to 3D Axes, it also takes a *scalez* argument.
620         """
621         # This method looks at the rectangular volume (see above)
622         # of data and decides how to scale the view portal to fit it.
623         if tight is None:
624             _tight = self._tight
625             if not _tight:
626                 # if image data only just use the datalim
627                 for artist in self._children:
628                     if isinstance(artist, mimage.AxesImage):
629                         _tight = True
630                     elif isinstance(artist, (mlines.Line2D, mpatches.Patch)):
631                         _tight = False
632                         break
633         else:
634             _tight = self._tight = bool(tight)
635 
636         if scalex and self.get_autoscalex_on():
637             x0, x1 = self.xy_dataLim.intervalx
638             xlocator = self.xaxis.get_major_locator()
639             x0, x1 = xlocator.nonsingular(x0, x1)
640             if self._xmargin > 0:
641                 delta = (x1 - x0) * self._xmargin
642                 x0 -= delta
643                 x1 += delta
644             if not _tight:
645                 x0, x1 = xlocator.view_limits(x0, x1)
646             self.set_xbound(x0, x1)
647 
648         if scaley and self.get_autoscaley_on():
649             y0, y1 = self.xy_dataLim.intervaly
650             ylocator = self.yaxis.get_major_locator()
651             y0, y1 = ylocator.nonsingular(y0, y1)
652             if self._ymargin > 0:
653                 delta = (y1 - y0) * self._ymargin
654                 y0 -= delta
655                 y1 += delta
656             if not _tight:
657                 y0, y1 = ylocator.view_limits(y0, y1)
658             self.set_ybound(y0, y1)
659 
660         if scalez and self.get_autoscalez_on():
661             z0, z1 = self.zz_dataLim.intervalx
662             zlocator = self.zaxis.get_major_locator()
663             z0, z1 = zlocator.nonsingular(z0, z1)
664             if self._zmargin > 0:
665                 delta = (z1 - z0) * self._zmargin
666                 z0 -= delta
667                 z1 += delta
668             if not _tight:
669                 z0, z1 = zlocator.view_limits(z0, z1)
670             self.set_zbound(z0, z1)
671 
672     def get_w_lims(self):
673         """Get 3D world limits."""
674         minx, maxx = self.get_xlim3d()
675         miny, maxy = self.get_ylim3d()
676         minz, maxz = self.get_zlim3d()
677         return minx, maxx, miny, maxy, minz, maxz
678 
679     # set_xlim, set_ylim are directly inherited from base Axes.
680     def set_zlim(self, bottom=None, top=None, *, emit=True, auto=False,
681                  zmin=None, zmax=None):
682         """
683         Set 3D z limits.
684 
685         See `.Axes.set_ylim` for full documentation
686         """
687         if top is None and np.iterable(bottom):
688             bottom, top = bottom
689         if zmin is not None:
690             if bottom is not None:
691                 raise TypeError("Cannot pass both 'bottom' and 'zmin'")
692             bottom = zmin
693         if zmax is not None:
694             if top is not None:
695                 raise TypeError("Cannot pass both 'top' and 'zmax'")
696             top = zmax
697         return self.zaxis._set_lim(bottom, top, emit=emit, auto=auto)
698 
699     set_xlim3d = maxes.Axes.set_xlim
700     set_ylim3d = maxes.Axes.set_ylim
701     set_zlim3d = set_zlim
702 
703     def get_xlim(self):
704         # docstring inherited
705         return tuple(self.xy_viewLim.intervalx)
706 
707     def get_ylim(self):
708         # docstring inherited
709         return tuple(self.xy_viewLim.intervaly)
710 
711     def get_zlim(self):
712         """Get 3D z limits."""
713         return tuple(self.zz_viewLim.intervalx)
714 
715     get_zscale = _axis_method_wrapper("zaxis", "get_scale")
716 
717     # Redefine all three methods to overwrite their docstrings.
718     set_xscale = _axis_method_wrapper("xaxis", "_set_axes_scale")
719     set_yscale = _axis_method_wrapper("yaxis", "_set_axes_scale")
720     set_zscale = _axis_method_wrapper("zaxis", "_set_axes_scale")
721     set_xscale.__doc__, set_yscale.__doc__, set_zscale.__doc__ = map(
722         """
723         Set the {}-axis scale.
724 
725         Parameters
726         ----------
727         value : {{"linear"}}
728             The axis scale type to apply.  3D axes currently only support
729             linear scales; other scales yield nonsensical results.
730 
731         **kwargs
732             Keyword arguments are nominally forwarded to the scale class, but
733             none of them is applicable for linear scales.
734         """.format,
735         ["x", "y", "z"])
736 
737     get_zticks = _axis_method_wrapper("zaxis", "get_ticklocs")
738     set_zticks = _axis_method_wrapper("zaxis", "set_ticks")
739     get_zmajorticklabels = _axis_method_wrapper("zaxis", "get_majorticklabels")
740     get_zminorticklabels = _axis_method_wrapper("zaxis", "get_minorticklabels")
741     get_zticklabels = _axis_method_wrapper("zaxis", "get_ticklabels")
742     set_zticklabels = _axis_method_wrapper(
743         "zaxis", "set_ticklabels",
744         doc_sub={"Axis.set_ticks": "Axes3D.set_zticks"})
745 
746     zaxis_date = _axis_method_wrapper("zaxis", "axis_date")
747     if zaxis_date.__doc__:
748         zaxis_date.__doc__ += textwrap.dedent("""
749 
750         Notes
751         -----
752         This function is merely provided for completeness, but 3D axes do not
753         support dates for ticks, and so this may not work as expected.
754         """)
755 
756     def clabel(self, *args, **kwargs):
757         """Currently not implemented for 3D axes, and returns *None*."""
758         return None
759 
760     def view_init(self, elev=None, azim=None, roll=None, vertical_axis="z"):
761         """
762         Set the elevation and azimuth of the axes in degrees (not radians).
763 
764         This can be used to rotate the axes programmatically.
765 
766         To look normal to the primary planes, the following elevation and
767         azimuth angles can be used. A roll angle of 0, 90, 180, or 270 deg
768         will rotate these views while keeping the axes at right angles.
769 
770         ==========   ====  ====
771         view plane   elev  azim
772         ==========   ====  ====
773         XY           90    -90
774         XZ           0     -90
775         YZ           0     0
776         -XY          -90   90
777         -XZ          0     90
778         -YZ          0     180
779         ==========   ====  ====
780 
781         Parameters
782         ----------
783         elev : float, default: None
784             The elevation angle in degrees rotates the camera above the plane
785             pierced by the vertical axis, with a positive angle corresponding
786             to a location above that plane. For example, with the default
787             vertical axis of 'z', the elevation defines the angle of the camera
788             location above the x-y plane.
789             If None, then the initial value as specified in the `Axes3D`
790             constructor is used.
791         azim : float, default: None
792             The azimuthal angle in degrees rotates the camera about the
793             vertical axis, with a positive angle corresponding to a
794             right-handed rotation. For example, with the default vertical axis
795             of 'z', a positive azimuth rotates the camera about the origin from
796             its location along the +x axis towards the +y axis.
797             If None, then the initial value as specified in the `Axes3D`
798             constructor is used.
799         roll : float, default: None
800             The roll angle in degrees rotates the camera about the viewing
801             axis. A positive angle spins the camera clockwise, causing the
802             scene to rotate counter-clockwise.
803             If None, then the initial value as specified in the `Axes3D`
804             constructor is used.
805         vertical_axis : {"z", "x", "y"}, default: "z"
806             The axis to align vertically. *azim* rotates about this axis.
807         """
808 
809         self._dist = 10  # The camera distance from origin. Behaves like zoom
810 
811         if elev is None:
812             self.elev = self.initial_elev
813         else:
814             self.elev = elev
815 
816         if azim is None:
817             self.azim = self.initial_azim
818         else:
819             self.azim = azim
820 
821         if roll is None:
822             self.roll = self.initial_roll
823         else:
824             self.roll = roll
825 
826         self._vertical_axis = _api.check_getitem(
827             dict(x=0, y=1, z=2), vertical_axis=vertical_axis
828         )
829 
830     def set_proj_type(self, proj_type, focal_length=None):
831         """
832         Set the projection type.
833 
834         Parameters
835         ----------
836         proj_type : {'persp', 'ortho'}
837             The projection type.
838         focal_length : float, default: None
839             For a projection type of 'persp', the focal length of the virtual
840             camera. Must be > 0. If None, defaults to 1.
841             The focal length can be computed from a desired Field Of View via
842             the equation: focal_length = 1/tan(FOV/2)
843         """
844         _api.check_in_list(['persp', 'ortho'], proj_type=proj_type)
845         if proj_type == 'persp':
846             if focal_length is None:
847                 focal_length = 1
848             elif focal_length <= 0:
849                 raise ValueError(f"focal_length = {focal_length} must be "
850                                  "greater than 0")
851             self._focal_length = focal_length
852         else:  # 'ortho':
853             if focal_length not in (None, np.inf):
854                 raise ValueError(f"focal_length = {focal_length} must be "
855                                  f"None for proj_type = {proj_type}")
856             self._focal_length = np.inf
857 
858     def _roll_to_vertical(self, arr):
859         """Roll arrays to match the different vertical axis."""
860         return np.roll(arr, self._vertical_axis - 2)
861 
862     def get_proj(self):
863         """Create the projection matrix from the current viewing position."""
864 
865         # Transform to uniform world coordinates 0-1, 0-1, 0-1
866         box_aspect = self._roll_to_vertical(self._box_aspect)
867         worldM = proj3d.world_transformation(
868             *self.get_xlim3d(),
869             *self.get_ylim3d(),
870             *self.get_zlim3d(),
871             pb_aspect=box_aspect,
872         )
873 
874         # Look into the middle of the world coordinates:
875         R = 0.5 * box_aspect
876 
877         # elev: elevation angle in the z plane.
878         # azim: azimuth angle in the xy plane.
879         # Coordinates for a point that rotates around the box of data.
880         # p0, p1 corresponds to rotating the box only around the vertical axis.
881         # p2 corresponds to rotating the box only around the horizontal axis.
882         elev_rad = np.deg2rad(self.elev)
883         azim_rad = np.deg2rad(self.azim)
884         p0 = np.cos(elev_rad) * np.cos(azim_rad)
885         p1 = np.cos(elev_rad) * np.sin(azim_rad)
886         p2 = np.sin(elev_rad)
887 
888         # When changing vertical axis the coordinates changes as well.
889         # Roll the values to get the same behaviour as the default:
890         ps = self._roll_to_vertical([p0, p1, p2])
891 
892         # The coordinates for the eye viewing point. The eye is looking
893         # towards the middle of the box of data from a distance:
894         eye = R + self._dist * ps
895 
896         # vvec, self._vvec and self._eye are unused, remove when deprecated
897         vvec = R - eye
898         self._eye = eye
899         self._vvec = vvec / np.linalg.norm(vvec)
900 
901         # Calculate the viewing axes for the eye position
902         u, v, w = self._calc_view_axes(eye)
903         self._view_u = u  # _view_u is towards the right of the screen
904         self._view_v = v  # _view_v is towards the top of the screen
905         self._view_w = w  # _view_w is out of the screen
906 
907         # Generate the view and projection transformation matrices
908         if self._focal_length == np.inf:
909             # Orthographic projection
910             viewM = proj3d._view_transformation_uvw(u, v, w, eye)
911             projM = proj3d._ortho_transformation(-self._dist, self._dist)
912         else:
913             # Perspective projection
914             # Scale the eye dist to compensate for the focal length zoom effect
915             eye_focal = R + self._dist * ps * self._focal_length
916             viewM = proj3d._view_transformation_uvw(u, v, w, eye_focal)
917             projM = proj3d._persp_transformation(-self._dist,
918                                                  self._dist,
919                                                  self._focal_length)
920 
921         # Combine all the transformation matrices to get the final projection
922         M0 = np.dot(viewM, worldM)
923         M = np.dot(projM, M0)
924         return M
925 
926     def mouse_init(self, rotate_btn=1, pan_btn=2, zoom_btn=3):
927         """
928         Set the mouse buttons for 3D rotation and zooming.
929 
930         Parameters
931         ----------
932         rotate_btn : int or list of int, default: 1
933             The mouse button or buttons to use for 3D rotation of the axes.
934         pan_btn : int or list of int, default: 2
935             The mouse button or buttons to use to pan the 3D axes.
936         zoom_btn : int or list of int, default: 3
937             The mouse button or buttons to use to zoom the 3D axes.
938         """
939         self.button_pressed = None
940         # coerce scalars into array-like, then convert into
941         # a regular list to avoid comparisons against None
942         # which breaks in recent versions of numpy.
943         self._rotate_btn = np.atleast_1d(rotate_btn).tolist()
944         self._pan_btn = np.atleast_1d(pan_btn).tolist()
945         self._zoom_btn = np.atleast_1d(zoom_btn).tolist()
946 
947     def disable_mouse_rotation(self):
948         """Disable mouse buttons for 3D rotation, panning, and zooming."""
949         self.mouse_init(rotate_btn=[], pan_btn=[], zoom_btn=[])
950 
951     def can_zoom(self):
952         # doc-string inherited
953         return True
954 
955     def can_pan(self):
956         # doc-string inherited
957         return True
958 
959     def sharez(self, other):
960         """
961         Share the z-axis with *other*.
962 
963         This is equivalent to passing ``sharez=other`` when constructing the
964         Axes, and cannot be used if the z-axis is already being shared with
965         another Axes.
966         """
967         _api.check_isinstance(maxes._base._AxesBase, other=other)
968         if self._sharez is not None and other is not self._sharez:
969             raise ValueError("z-axis is already shared")
970         self._shared_axes["z"].join(self, other)
971         self._sharez = other
972         self.zaxis.major = other.zaxis.major  # Ticker instances holding
973         self.zaxis.minor = other.zaxis.minor  # locator and formatter.
974         z0, z1 = other.get_zlim()
975         self.set_zlim(z0, z1, emit=False, auto=other.get_autoscalez_on())
976         self.zaxis._scale = other.zaxis._scale
977 
978     def clear(self):
979         # docstring inherited.
980         super().clear()
981         if self._focal_length == np.inf:
982             self._zmargin = mpl.rcParams['axes.zmargin']
983         else:
984             self._zmargin = 0.
985         self.grid(mpl.rcParams['axes3d.grid'])
986 
987     def _button_press(self, event):
988         if event.inaxes == self:
989             self.button_pressed = event.button
990             self._sx, self._sy = event.xdata, event.ydata
991             toolbar = self.figure.canvas.toolbar
992             if toolbar and toolbar._nav_stack() is None:
993                 toolbar.push_current()
994 
995     def _button_release(self, event):
996         self.button_pressed = None
997         toolbar = self.figure.canvas.toolbar
998         # backend_bases.release_zoom and backend_bases.release_pan call
999         # push_current, so check the navigation mode so we don't call it twice
1000         if toolbar and self.get_navigate_mode() is None:
1001             toolbar.push_current()
1002 
1003     def _get_view(self):
1004         # docstring inherited
1005         return {
1006             "xlim": self.get_xlim(), "autoscalex_on": self.get_autoscalex_on(),
1007             "ylim": self.get_ylim(), "autoscaley_on": self.get_autoscaley_on(),
1008             "zlim": self.get_zlim(), "autoscalez_on": self.get_autoscalez_on(),
1009         }, (self.elev, self.azim, self.roll)
1010 
1011     def _set_view(self, view):
1012         # docstring inherited
1013         props, (elev, azim, roll) = view
1014         self.set(**props)
1015         self.elev = elev
1016         self.azim = azim
1017         self.roll = roll
1018 
1019     def format_zdata(self, z):
1020         """
1021         Return *z* string formatted.  This function will use the
1022         :attr:`fmt_zdata` attribute if it is callable, else will fall
1023         back on the zaxis major formatter
1024         """
1025         try:
1026             return self.fmt_zdata(z)
1027         except (AttributeError, TypeError):
1028             func = self.zaxis.get_major_formatter().format_data_short
1029             val = func(z)
1030             return val
1031 
1032     def format_coord(self, xd, yd):
1033         """
1034         Given the 2D view coordinates attempt to guess a 3D coordinate.
1035         Looks for the nearest edge to the point and then assumes that
1036         the point is at the same z location as the nearest point on the edge.
1037         """
1038 
1039         if self.M is None:
1040             return ''
1041 
1042         if self.button_pressed in self._rotate_btn:
1043             # ignore xd and yd and display angles instead
1044             norm_elev = art3d._norm_angle(self.elev)
1045             norm_azim = art3d._norm_angle(self.azim)
1046             norm_roll = art3d._norm_angle(self.roll)
1047             return (f"elevation={norm_elev:.0f}\N{DEGREE SIGN}, "
1048                     f"azimuth={norm_azim:.0f}\N{DEGREE SIGN}, "
1049                     f"roll={norm_roll:.0f}\N{DEGREE SIGN}"
1050                     ).replace("-", "\N{MINUS SIGN}")
1051 
1052         # nearest edge
1053         p0, p1 = min(self._tunit_edges(),
1054                      key=lambda edge: proj3d._line2d_seg_dist(
1055                          (xd, yd), edge[0][:2], edge[1][:2]))
1056 
1057         # scale the z value to match
1058         x0, y0, z0 = p0
1059         x1, y1, z1 = p1
1060         d0 = np.hypot(x0-xd, y0-yd)
1061         d1 = np.hypot(x1-xd, y1-yd)
1062         dt = d0+d1
1063         z = d1/dt * z0 + d0/dt * z1
1064 
1065         x, y, z = proj3d.inv_transform(xd, yd, z, self.M)
1066 
1067         xs = self.format_xdata(x)
1068         ys = self.format_ydata(y)
1069         zs = self.format_zdata(z)
1070         return f'x={xs}, y={ys}, z={zs}'
1071 
1072     def _on_move(self, event):
1073         """
1074         Mouse moving.
1075 
1076         By default, button-1 rotates, button-2 pans, and button-3 zooms;
1077         these buttons can be modified via `mouse_init`.
1078         """
1079 
1080         if not self.button_pressed:
1081             return
1082 
1083         if self.get_navigate_mode() is not None:
1084             # we don't want to rotate if we are zooming/panning
1085             # from the toolbar
1086             return
1087 
1088         if self.M is None:
1089             return
1090 
1091         x, y = event.xdata, event.ydata
1092         # In case the mouse is out of bounds.
1093         if x is None or event.inaxes != self:
1094             return
1095 
1096         dx, dy = x - self._sx, y - self._sy
1097         w = self._pseudo_w
1098         h = self._pseudo_h
1099 
1100         # Rotation
1101         if self.button_pressed in self._rotate_btn:
1102             # rotate viewing point
1103             # get the x and y pixel coords
1104             if dx == 0 and dy == 0:
1105                 return
1106 
1107             roll = np.deg2rad(self.roll)
1108             delev = -(dy/h)*180*np.cos(roll) + (dx/w)*180*np.sin(roll)
1109             dazim = -(dy/h)*180*np.sin(roll) - (dx/w)*180*np.cos(roll)
1110             self.elev = self.elev + delev
1111             self.azim = self.azim + dazim
1112             self.stale = True
1113 
1114         elif self.button_pressed in self._pan_btn:
1115             # Start the pan event with pixel coordinates
1116             px, py = self.transData.transform([self._sx, self._sy])
1117             self.start_pan(px, py, 2)
1118             # pan view (takes pixel coordinate input)
1119             self.drag_pan(2, None, event.x, event.y)
1120             self.end_pan()
1121 
1122         # Zoom
1123         elif self.button_pressed in self._zoom_btn:
1124             # zoom view (dragging down zooms in)
1125             scale = h/(h - dy)
1126             self._scale_axis_limits(scale, scale, scale)
1127 
1128         # Store the event coordinates for the next time through.
1129         self._sx, self._sy = x, y
1130         # Always request a draw update at the end of interaction
1131         self.figure.canvas.draw_idle()
1132 
1133     def drag_pan(self, button, key, x, y):
1134         # docstring inherited
1135 
1136         # Get the coordinates from the move event
1137         p = self._pan_start
1138         (xdata, ydata), (xdata_start, ydata_start) = p.trans_inverse.transform(
1139             [(x, y), (p.x, p.y)])
1140         self._sx, self._sy = xdata, ydata
1141         # Calling start_pan() to set the x/y of this event as the starting
1142         # move location for the next event
1143         self.start_pan(x, y, button)
1144         du, dv = xdata - xdata_start, ydata - ydata_start
1145         dw = 0
1146         if key == 'x':
1147             dv = 0
1148         elif key == 'y':
1149             du = 0
1150         if du == 0 and dv == 0:
1151             return
1152 
1153         # Transform the pan from the view axes to the data axes
1154         R = np.array([self._view_u, self._view_v, self._view_w])
1155         R = -R / self._box_aspect * self._dist
1156         duvw_projected = R.T @ np.array([du, dv, dw])
1157 
1158         # Calculate pan distance
1159         minx, maxx, miny, maxy, minz, maxz = self.get_w_lims()
1160         dx = (maxx - minx) * duvw_projected[0]
1161         dy = (maxy - miny) * duvw_projected[1]
1162         dz = (maxz - minz) * duvw_projected[2]
1163 
1164         # Set the new axis limits
1165         self.set_xlim3d(minx + dx, maxx + dx)
1166         self.set_ylim3d(miny + dy, maxy + dy)
1167         self.set_zlim3d(minz + dz, maxz + dz)
1168 
1169     def _calc_view_axes(self, eye):
1170         """
1171         Get the unit vectors for the viewing axes in data coordinates.
1172         `u` is towards the right of the screen
1173         `v` is towards the top of the screen
1174         `w` is out of the screen
1175         """
1176         elev_rad = np.deg2rad(art3d._norm_angle(self.elev))
1177         roll_rad = np.deg2rad(art3d._norm_angle(self.roll))
1178 
1179         # Look into the middle of the world coordinates
1180         R = 0.5 * self._roll_to_vertical(self._box_aspect)
1181 
1182         # Define which axis should be vertical. A negative value
1183         # indicates the plot is upside down and therefore the values
1184         # have been reversed:
1185         V = np.zeros(3)
1186         V[self._vertical_axis] = -1 if abs(elev_rad) > np.pi/2 else 1
1187 
1188         u, v, w = proj3d._view_axes(eye, R, V, roll_rad)
1189         return u, v, w
1190 
1191     def _set_view_from_bbox(self, bbox, direction='in',
1192                             mode=None, twinx=False, twiny=False):
1193         """
1194         Zoom in or out of the bounding box.
1195 
1196         Will center the view in the center of the bounding box, and zoom by
1197         the ratio of the size of the bounding box to the size of the Axes3D.
1198         """
1199         (start_x, start_y, stop_x, stop_y) = bbox
1200         if mode == 'x':
1201             start_y = self.bbox.min[1]
1202             stop_y = self.bbox.max[1]
1203         elif mode == 'y':
1204             start_x = self.bbox.min[0]
1205             stop_x = self.bbox.max[0]
1206 
1207         # Clip to bounding box limits
1208         start_x, stop_x = np.clip(sorted([start_x, stop_x]),
1209                                   self.bbox.min[0], self.bbox.max[0])
1210         start_y, stop_y = np.clip(sorted([start_y, stop_y]),
1211                                   self.bbox.min[1], self.bbox.max[1])
1212 
1213         # Move the center of the view to the center of the bbox
1214         zoom_center_x = (start_x + stop_x)/2
1215         zoom_center_y = (start_y + stop_y)/2
1216 
1217         ax_center_x = (self.bbox.max[0] + self.bbox.min[0])/2
1218         ax_center_y = (self.bbox.max[1] + self.bbox.min[1])/2
1219 
1220         self.start_pan(zoom_center_x, zoom_center_y, 2)
1221         self.drag_pan(2, None, ax_center_x, ax_center_y)
1222         self.end_pan()
1223 
1224         # Calculate zoom level
1225         dx = abs(start_x - stop_x)
1226         dy = abs(start_y - stop_y)
1227         scale_u = dx / (self.bbox.max[0] - self.bbox.min[0])
1228         scale_v = dy / (self.bbox.max[1] - self.bbox.min[1])
1229 
1230         # Keep aspect ratios equal
1231         scale = max(scale_u, scale_v)
1232 
1233         # Zoom out
1234         if direction == 'out':
1235             scale = 1 / scale
1236 
1237         self._zoom_data_limits(scale, scale, scale)
1238 
1239     def _zoom_data_limits(self, scale_u, scale_v, scale_w):
1240         """
1241         Zoom in or out of a 3D plot.
1242 
1243         Will scale the data limits by the scale factors. These will be
1244         transformed to the x, y, z data axes based on the current view angles.
1245         A scale factor > 1 zooms out and a scale factor < 1 zooms in.
1246 
1247         For an axes that has had its aspect ratio set to 'equal', 'equalxy',
1248         'equalyz', or 'equalxz', the relevant axes are constrained to zoom
1249         equally.
1250 
1251         Parameters
1252         ----------
1253         scale_u : float
1254             Scale factor for the u view axis (view screen horizontal).
1255         scale_v : float
1256             Scale factor for the v view axis (view screen vertical).
1257         scale_w : float
1258             Scale factor for the w view axis (view screen depth).
1259         """
1260         scale = np.array([scale_u, scale_v, scale_w])
1261 
1262         # Only perform frame conversion if unequal scale factors
1263         if not np.allclose(scale, scale_u):
1264             # Convert the scale factors from the view frame to the data frame
1265             R = np.array([self._view_u, self._view_v, self._view_w])
1266             S = scale * np.eye(3)
1267             scale = np.linalg.norm(R.T @ S, axis=1)
1268 
1269             # Set the constrained scale factors to the factor closest to 1
1270             if self._aspect in ('equal', 'equalxy', 'equalxz', 'equalyz'):
1271                 ax_idxs = self._equal_aspect_axis_indices(self._aspect)
1272                 min_ax_idxs = np.argmin(np.abs(scale[ax_idxs] - 1))
1273                 scale[ax_idxs] = scale[ax_idxs][min_ax_idxs]
1274 
1275         self._scale_axis_limits(scale[0], scale[1], scale[2])
1276 
1277     def _scale_axis_limits(self, scale_x, scale_y, scale_z):
1278         """
1279         Keeping the center of the x, y, and z data axes fixed, scale their
1280         limits by scale factors. A scale factor > 1 zooms out and a scale
1281         factor < 1 zooms in.
1282 
1283         Parameters
1284         ----------
1285         scale_x : float
1286             Scale factor for the x data axis.
1287         scale_y : float
1288             Scale factor for the y data axis.
1289         scale_z : float
1290             Scale factor for the z data axis.
1291         """
1292         # Get the axis limits and centers
1293         minx, maxx, miny, maxy, minz, maxz = self.get_w_lims()
1294         cx = (maxx + minx)/2
1295         cy = (maxy + miny)/2
1296         cz = (maxz + minz)/2
1297 
1298         # Scale the data range
1299         dx = (maxx - minx)*scale_x
1300         dy = (maxy - miny)*scale_y
1301         dz = (maxz - minz)*scale_z
1302 
1303         # Set the scaled axis limits
1304         self.set_xlim3d(cx - dx/2, cx + dx/2)
1305         self.set_ylim3d(cy - dy/2, cy + dy/2)
1306         self.set_zlim3d(cz - dz/2, cz + dz/2)
1307 
1308     def set_zlabel(self, zlabel, fontdict=None, labelpad=None, **kwargs):
1309         """
1310         Set zlabel.  See doc for `.set_ylabel` for description.
1311         """
1312         if labelpad is not None:
1313             self.zaxis.labelpad = labelpad
1314         return self.zaxis.set_label_text(zlabel, fontdict, **kwargs)
1315 
1316     def get_zlabel(self):
1317         """
1318         Get the z-label text string.
1319         """
1320         label = self.zaxis.get_label()
1321         return label.get_text()
1322 
1323     # Axes rectangle characteristics
1324 
1325     # The frame_on methods are not available for 3D axes.
1326     # Python will raise a TypeError if they are called.
1327     get_frame_on = None
1328     set_frame_on = None
1329 
1330     def grid(self, visible=True, **kwargs):
1331         """
1332         Set / unset 3D grid.
1333 
1334         .. note::
1335 
1336             Currently, this function does not behave the same as
1337             `.axes.Axes.grid`, but it is intended to eventually support that
1338             behavior.
1339         """
1340         # TODO: Operate on each axes separately
1341         if len(kwargs):
1342             visible = True
1343         self._draw_grid = visible
1344         self.stale = True
1345 
1346     def tick_params(self, axis='both', **kwargs):
1347         """
1348         Convenience method for changing the appearance of ticks and
1349         tick labels.
1350 
1351         See `.Axes.tick_params` for full documentation.  Because this function
1352         applies to 3D Axes, *axis* can also be set to 'z', and setting *axis*
1353         to 'both' autoscales all three axes.
1354 
1355         Also, because of how Axes3D objects are drawn very differently
1356         from regular 2D axes, some of these settings may have
1357         ambiguous meaning.  For simplicity, the 'z' axis will
1358         accept settings as if it was like the 'y' axis.
1359 
1360         .. note::
1361            Axes3D currently ignores some of these settings.
1362         """
1363         _api.check_in_list(['x', 'y', 'z', 'both'], axis=axis)
1364         if axis in ['x', 'y', 'both']:
1365             super().tick_params(axis, **kwargs)
1366         if axis in ['z', 'both']:
1367             zkw = dict(kwargs)
1368             zkw.pop('top', None)
1369             zkw.pop('bottom', None)
1370             zkw.pop('labeltop', None)
1371             zkw.pop('labelbottom', None)
1372             self.zaxis.set_tick_params(**zkw)
1373 
1374     # data limits, ticks, tick labels, and formatting
1375 
1376     def invert_zaxis(self):
1377         """
1378         Invert the z-axis.
1379         """
1380         bottom, top = self.get_zlim()
1381         self.set_zlim(top, bottom, auto=None)
1382 
1383     zaxis_inverted = _axis_method_wrapper("zaxis", "get_inverted")
1384 
1385     def get_zbound(self):
1386         """
1387         Return the lower and upper z-axis bounds, in increasing order.
1388         """
1389         bottom, top = self.get_zlim()
1390         if bottom < top:
1391             return bottom, top
1392         else:
1393             return top, bottom
1394 
1395     def set_zbound(self, lower=None, upper=None):
1396         """
1397         Set the lower and upper numerical bounds of the z-axis.
1398 
1399         This method will honor axes inversion regardless of parameter order.
1400         It will not change the autoscaling setting (`.get_autoscalez_on()`).
1401         """
1402         if upper is None and np.iterable(lower):
1403             lower, upper = lower
1404 
1405         old_lower, old_upper = self.get_zbound()
1406         if lower is None:
1407             lower = old_lower
1408         if upper is None:
1409             upper = old_upper
1410 
1411         self.set_zlim(sorted((lower, upper),
1412                              reverse=bool(self.zaxis_inverted())),
1413                       auto=None)
1414 
1415     def text(self, x, y, z, s, zdir=None, **kwargs):
1416         """
1417         Add text to the plot.
1418 
1419         Keyword arguments will be passed on to `.Axes.text`, except for the
1420         *zdir* keyword, which sets the direction to be used as the z
1421         direction.
1422         """
1423         text = super().text(x, y, s, **kwargs)
1424         art3d.text_2d_to_3d(text, z, zdir)
1425         return text
1426 
1427     text3D = text
1428     text2D = Axes.text
1429 
1430     def plot(self, xs, ys, *args, zdir='z', **kwargs):
1431         """
1432         Plot 2D or 3D data.
1433 
1434         Parameters
1435         ----------
1436         xs : 1D array-like
1437             x coordinates of vertices.
1438         ys : 1D array-like
1439             y coordinates of vertices.
1440         zs : float or 1D array-like
1441             z coordinates of vertices; either one for all points or one for
1442             each point.
1443         zdir : {'x', 'y', 'z'}, default: 'z'
1444             When plotting 2D data, the direction to use as z.
1445         **kwargs
1446             Other arguments are forwarded to `matplotlib.axes.Axes.plot`.
1447         """
1448         had_data = self.has_data()
1449 
1450         # `zs` can be passed positionally or as keyword; checking whether
1451         # args[0] is a string matches the behavior of 2D `plot` (via
1452         # `_process_plot_var_args`).
1453         if args and not isinstance(args[0], str):
1454             zs, *args = args
1455             if 'zs' in kwargs:
1456                 raise TypeError("plot() for multiple values for argument 'z'")
1457         else:
1458             zs = kwargs.pop('zs', 0)
1459 
1460         # Match length
1461         zs = np.broadcast_to(zs, np.shape(xs))
1462 
1463         lines = super().plot(xs, ys, *args, **kwargs)
1464         for line in lines:
1465             art3d.line_2d_to_3d(line, zs=zs, zdir=zdir)
1466 
1467         xs, ys, zs = art3d.juggle_axes(xs, ys, zs, zdir)
1468         self.auto_scale_xyz(xs, ys, zs, had_data)
1469         return lines
1470 
1471     plot3D = plot
1472 
1473     def plot_surface(self, X, Y, Z, *, norm=None, vmin=None,
1474                      vmax=None, lightsource=None, **kwargs):
1475         """
1476         Create a surface plot.
1477 
1478         By default, it will be colored in shades of a solid color, but it also
1479         supports colormapping by supplying the *cmap* argument.
1480 
1481         .. note::
1482 
1483            The *rcount* and *ccount* kwargs, which both default to 50,
1484            determine the maximum number of samples used in each direction.  If
1485            the input data is larger, it will be downsampled (by slicing) to
1486            these numbers of points.
1487 
1488         .. note::
1489 
1490            To maximize rendering speed consider setting *rstride* and *cstride*
1491            to divisors of the number of rows minus 1 and columns minus 1
1492            respectively. For example, given 51 rows rstride can be any of the
1493            divisors of 50.
1494 
1495            Similarly, a setting of *rstride* and *cstride* equal to 1 (or
1496            *rcount* and *ccount* equal the number of rows and columns) can use
1497            the optimized path.
1498 
1499         Parameters
1500         ----------
1501         X, Y, Z : 2D arrays
1502             Data values.
1503 
1504         rcount, ccount : int
1505             Maximum number of samples used in each direction.  If the input
1506             data is larger, it will be downsampled (by slicing) to these
1507             numbers of points.  Defaults to 50.
1508 
1509         rstride, cstride : int
1510             Downsampling stride in each direction.  These arguments are
1511             mutually exclusive with *rcount* and *ccount*.  If only one of
1512             *rstride* or *cstride* is set, the other defaults to 10.
1513 
1514             'classic' mode uses a default of ``rstride = cstride = 10`` instead
1515             of the new default of ``rcount = ccount = 50``.
1516 
1517         color : color-like
1518             Color of the surface patches.
1519 
1520         cmap : Colormap
1521             Colormap of the surface patches.
1522 
1523         facecolors : array-like of colors.
1524             Colors of each individual patch.
1525 
1526         norm : Normalize
1527             Normalization for the colormap.
1528 
1529         vmin, vmax : float
1530             Bounds for the normalization.
1531 
1532         shade : bool, default: True
1533             Whether to shade the facecolors.  Shading is always disabled when
1534             *cmap* is specified.
1535 
1536         lightsource : `~matplotlib.colors.LightSource`
1537             The lightsource to use when *shade* is True.
1538 
1539         **kwargs
1540             Other keyword arguments are forwarded to `.Poly3DCollection`.
1541         """
1542 
1543         had_data = self.has_data()
1544 
1545         if Z.ndim != 2:
1546             raise ValueError("Argument Z must be 2-dimensional.")
1547 
1548         Z = cbook._to_unmasked_float_array(Z)
1549         X, Y, Z = np.broadcast_arrays(X, Y, Z)
1550         rows, cols = Z.shape
1551 
1552         has_stride = 'rstride' in kwargs or 'cstride' in kwargs
1553         has_count = 'rcount' in kwargs or 'ccount' in kwargs
1554 
1555         if has_stride and has_count:
1556             raise ValueError("Cannot specify both stride and count arguments")
1557 
1558         rstride = kwargs.pop('rstride', 10)
1559         cstride = kwargs.pop('cstride', 10)
1560         rcount = kwargs.pop('rcount', 50)
1561         ccount = kwargs.pop('ccount', 50)
1562 
1563         if mpl.rcParams['_internal.classic_mode']:
1564             # Strides have priority over counts in classic mode.
1565             # So, only compute strides from counts
1566             # if counts were explicitly given
1567             compute_strides = has_count
1568         else:
1569             # If the strides are provided then it has priority.
1570             # Otherwise, compute the strides from the counts.
1571             compute_strides = not has_stride
1572 
1573         if compute_strides:
1574             rstride = int(max(np.ceil(rows / rcount), 1))
1575             cstride = int(max(np.ceil(cols / ccount), 1))
1576 
1577         fcolors = kwargs.pop('facecolors', None)
1578 
1579         cmap = kwargs.get('cmap', None)
1580         shade = kwargs.pop('shade', cmap is None)
1581         if shade is None:
1582             raise ValueError("shade cannot be None.")
1583 
1584         colset = []  # the sampled facecolor
1585         if (rows - 1) % rstride == 0 and \
1586            (cols - 1) % cstride == 0 and \
1587            fcolors is None:
1588             polys = np.stack(
1589                 [cbook._array_patch_perimeters(a, rstride, cstride)
1590                  for a in (X, Y, Z)],
1591                 axis=-1)
1592         else:
1593             # evenly spaced, and including both endpoints
1594             row_inds = list(range(0, rows-1, rstride)) + [rows-1]
1595             col_inds = list(range(0, cols-1, cstride)) + [cols-1]
1596 
1597             polys = []
1598             for rs, rs_next in zip(row_inds[:-1], row_inds[1:]):
1599                 for cs, cs_next in zip(col_inds[:-1], col_inds[1:]):
1600                     ps = [
1601                         # +1 ensures we share edges between polygons
1602                         cbook._array_perimeter(a[rs:rs_next+1, cs:cs_next+1])
1603                         for a in (X, Y, Z)
1604                     ]
1605                     # ps = np.stack(ps, axis=-1)
1606                     ps = np.array(ps).T
1607                     polys.append(ps)
1608 
1609                     if fcolors is not None:
1610                         colset.append(fcolors[rs][cs])
1611 
1612         # In cases where there are NaNs in the data (possibly from masked
1613         # arrays), artifacts can be introduced. Here check whether NaNs exist
1614         # and remove the entries if so
1615         if not isinstance(polys, np.ndarray) or np.isnan(polys).any():
1616             new_polys = []
1617             new_colset = []
1618 
1619             # Depending on fcolors, colset is either an empty list or has as
1620             # many elements as polys. In the former case new_colset results in
1621             # a list with None entries, that is discarded later.
1622             for p, col in itertools.zip_longest(polys, colset):
1623                 new_poly = np.array(p)[~np.isnan(p).any(axis=1)]
1624                 if len(new_poly):
1625                     new_polys.append(new_poly)
1626                     new_colset.append(col)
1627 
1628             # Replace previous polys and, if fcolors is not None, colset
1629             polys = new_polys
1630             if fcolors is not None:
1631                 colset = new_colset
1632 
1633         # note that the striding causes some polygons to have more coordinates
1634         # than others
1635 
1636         if fcolors is not None:
1637             polyc = art3d.Poly3DCollection(
1638                 polys, edgecolors=colset, facecolors=colset, shade=shade,
1639                 lightsource=lightsource, **kwargs)
1640         elif cmap:
1641             polyc = art3d.Poly3DCollection(polys, **kwargs)
1642             # can't always vectorize, because polys might be jagged
1643             if isinstance(polys, np.ndarray):
1644                 avg_z = polys[..., 2].mean(axis=-1)
1645             else:
1646                 avg_z = np.array([ps[:, 2].mean() for ps in polys])
1647             polyc.set_array(avg_z)
1648             if vmin is not None or vmax is not None:
1649                 polyc.set_clim(vmin, vmax)
1650             if norm is not None:
1651                 polyc.set_norm(norm)
1652         else:
1653             color = kwargs.pop('color', None)
1654             if color is None:
1655                 color = self._get_lines.get_next_color()
1656             color = np.array(mcolors.to_rgba(color))
1657 
1658             polyc = art3d.Poly3DCollection(
1659                 polys, facecolors=color, shade=shade,
1660                 lightsource=lightsource, **kwargs)
1661 
1662         self.add_collection(polyc)
1663         self.auto_scale_xyz(X, Y, Z, had_data)
1664 
1665         return polyc
1666 
1667     def plot_wireframe(self, X, Y, Z, **kwargs):
1668         """
1669         Plot a 3D wireframe.
1670 
1671         .. note::
1672 
1673            The *rcount* and *ccount* kwargs, which both default to 50,
1674            determine the maximum number of samples used in each direction.  If
1675            the input data is larger, it will be downsampled (by slicing) to
1676            these numbers of points.
1677 
1678         Parameters
1679         ----------
1680         X, Y, Z : 2D arrays
1681             Data values.
1682 
1683         rcount, ccount : int
1684             Maximum number of samples used in each direction.  If the input
1685             data is larger, it will be downsampled (by slicing) to these
1686             numbers of points.  Setting a count to zero causes the data to be
1687             not sampled in the corresponding direction, producing a 3D line
1688             plot rather than a wireframe plot.  Defaults to 50.
1689 
1690         rstride, cstride : int
1691             Downsampling stride in each direction.  These arguments are
1692             mutually exclusive with *rcount* and *ccount*.  If only one of
1693             *rstride* or *cstride* is set, the other defaults to 1.  Setting a
1694             stride to zero causes the data to be not sampled in the
1695             corresponding direction, producing a 3D line plot rather than a
1696             wireframe plot.
1697 
1698             'classic' mode uses a default of ``rstride = cstride = 1`` instead
1699             of the new default of ``rcount = ccount = 50``.
1700 
1701         **kwargs
1702             Other keyword arguments are forwarded to `.Line3DCollection`.
1703         """
1704 
1705         had_data = self.has_data()
1706         if Z.ndim != 2:
1707             raise ValueError("Argument Z must be 2-dimensional.")
1708         # FIXME: Support masked arrays
1709         X, Y, Z = np.broadcast_arrays(X, Y, Z)
1710         rows, cols = Z.shape
1711 
1712         has_stride = 'rstride' in kwargs or 'cstride' in kwargs
1713         has_count = 'rcount' in kwargs or 'ccount' in kwargs
1714 
1715         if has_stride and has_count:
1716             raise ValueError("Cannot specify both stride and count arguments")
1717 
1718         rstride = kwargs.pop('rstride', 1)
1719         cstride = kwargs.pop('cstride', 1)
1720         rcount = kwargs.pop('rcount', 50)
1721         ccount = kwargs.pop('ccount', 50)
1722 
1723         if mpl.rcParams['_internal.classic_mode']:
1724             # Strides have priority over counts in classic mode.
1725             # So, only compute strides from counts
1726             # if counts were explicitly given
1727             if has_count:
1728                 rstride = int(max(np.ceil(rows / rcount), 1)) if rcount else 0
1729                 cstride = int(max(np.ceil(cols / ccount), 1)) if ccount else 0
1730         else:
1731             # If the strides are provided then it has priority.
1732             # Otherwise, compute the strides from the counts.
1733             if not has_stride:
1734                 rstride = int(max(np.ceil(rows / rcount), 1)) if rcount else 0
1735                 cstride = int(max(np.ceil(cols / ccount), 1)) if ccount else 0
1736 
1737         # We want two sets of lines, one running along the "rows" of
1738         # Z and another set of lines running along the "columns" of Z.
1739         # This transpose will make it easy to obtain the columns.
1740         tX, tY, tZ = np.transpose(X), np.transpose(Y), np.transpose(Z)
1741 
1742         if rstride:
1743             rii = list(range(0, rows, rstride))
1744             # Add the last index only if needed
1745             if rows > 0 and rii[-1] != (rows - 1):
1746                 rii += [rows-1]
1747         else:
1748             rii = []
1749         if cstride:
1750             cii = list(range(0, cols, cstride))
1751             # Add the last index only if needed
1752             if cols > 0 and cii[-1] != (cols - 1):
1753                 cii += [cols-1]
1754         else:
1755             cii = []
1756 
1757         if rstride == 0 and cstride == 0:
1758             raise ValueError("Either rstride or cstride must be non zero")
1759 
1760         # If the inputs were empty, then just
1761         # reset everything.
1762         if Z.size == 0:
1763             rii = []
1764             cii = []
1765 
1766         xlines = [X[i] for i in rii]
1767         ylines = [Y[i] for i in rii]
1768         zlines = [Z[i] for i in rii]
1769 
1770         txlines = [tX[i] for i in cii]
1771         tylines = [tY[i] for i in cii]
1772         tzlines = [tZ[i] for i in cii]
1773 
1774         lines = ([list(zip(xl, yl, zl))
1775                  for xl, yl, zl in zip(xlines, ylines, zlines)]
1776                  + [list(zip(xl, yl, zl))
1777                  for xl, yl, zl in zip(txlines, tylines, tzlines)])
1778 
1779         linec = art3d.Line3DCollection(lines, **kwargs)
1780         self.add_collection(linec)
1781         self.auto_scale_xyz(X, Y, Z, had_data)
1782 
1783         return linec
1784 
1785     def plot_trisurf(self, *args, color=None, norm=None, vmin=None, vmax=None,
1786                      lightsource=None, **kwargs):
1787         """
1788         Plot a triangulated surface.
1789 
1790         The (optional) triangulation can be specified in one of two ways;
1791         either::
1792 
1793           plot_trisurf(triangulation, ...)
1794 
1795         where triangulation is a `~matplotlib.tri.Triangulation` object, or::
1796 
1797           plot_trisurf(X, Y, ...)
1798           plot_trisurf(X, Y, triangles, ...)
1799           plot_trisurf(X, Y, triangles=triangles, ...)
1800 
1801         in which case a Triangulation object will be created.  See
1802         `.Triangulation` for an explanation of these possibilities.
1803 
1804         The remaining arguments are::
1805 
1806           plot_trisurf(..., Z)
1807 
1808         where *Z* is the array of values to contour, one per point
1809         in the triangulation.
1810 
1811         Parameters
1812         ----------
1813         X, Y, Z : array-like
1814             Data values as 1D arrays.
1815         color
1816             Color of the surface patches.
1817         cmap
1818             A colormap for the surface patches.
1819         norm : Normalize
1820             An instance of Normalize to map values to colors.
1821         vmin, vmax : float, default: None
1822             Minimum and maximum value to map.
1823         shade : bool, default: True
1824             Whether to shade the facecolors.  Shading is always disabled when
1825             *cmap* is specified.
1826         lightsource : `~matplotlib.colors.LightSource`
1827             The lightsource to use when *shade* is True.
1828         **kwargs
1829             All other keyword arguments are passed on to
1830             :class:`~mpl_toolkits.mplot3d.art3d.Poly3DCollection`
1831 
1832         Examples
1833         --------
1834         .. plot:: gallery/mplot3d/trisurf3d.py
1835         .. plot:: gallery/mplot3d/trisurf3d_2.py
1836         """
1837 
1838         had_data = self.has_data()
1839 
1840         # TODO: Support custom face colours
1841         if color is None:
1842             color = self._get_lines.get_next_color()
1843         color = np.array(mcolors.to_rgba(color))
1844 
1845         cmap = kwargs.get('cmap', None)
1846         shade = kwargs.pop('shade', cmap is None)
1847 
1848         tri, args, kwargs = \
1849             Triangulation.get_from_args_and_kwargs(*args, **kwargs)
1850         try:
1851             z = kwargs.pop('Z')
1852         except KeyError:
1853             # We do this so Z doesn't get passed as an arg to PolyCollection
1854             z, *args = args
1855         z = np.asarray(z)
1856 
1857         triangles = tri.get_masked_triangles()
1858         xt = tri.x[triangles]
1859         yt = tri.y[triangles]
1860         zt = z[triangles]
1861         verts = np.stack((xt, yt, zt), axis=-1)
1862 
1863         if cmap:
1864             polyc = art3d.Poly3DCollection(verts, *args, **kwargs)
1865             # average over the three points of each triangle
1866             avg_z = verts[:, :, 2].mean(axis=1)
1867             polyc.set_array(avg_z)
1868             if vmin is not None or vmax is not None:
1869                 polyc.set_clim(vmin, vmax)
1870             if norm is not None:
1871                 polyc.set_norm(norm)
1872         else:
1873             polyc = art3d.Poly3DCollection(
1874                 verts, *args, shade=shade, lightsource=lightsource,
1875                 facecolors=color, **kwargs)
1876 
1877         self.add_collection(polyc)
1878         self.auto_scale_xyz(tri.x, tri.y, z, had_data)
1879 
1880         return polyc
1881 
1882     def _3d_extend_contour(self, cset, stride=5):
1883         """
1884         Extend a contour in 3D by creating
1885         """
1886 
1887         levels = cset.levels
1888         colls = cset.collections
1889         dz = (levels[1] - levels[0]) / 2
1890 
1891         for z, linec in zip(levels, colls):
1892             paths = linec.get_paths()
1893             if not paths:
1894                 continue
1895             topverts = art3d._paths_to_3d_segments(paths, z - dz)
1896             botverts = art3d._paths_to_3d_segments(paths, z + dz)
1897 
1898             color = linec.get_edgecolor()[0]
1899 
1900             nsteps = round(len(topverts[0]) / stride)
1901             if nsteps <= 1:
1902                 if len(topverts[0]) > 1:
1903                     nsteps = 2
1904                 else:
1905                     continue
1906 
1907             polyverts = []
1908             stepsize = (len(topverts[0]) - 1) / (nsteps - 1)
1909             for i in range(round(nsteps) - 1):
1910                 i1 = round(i * stepsize)
1911                 i2 = round((i + 1) * stepsize)
1912                 polyverts.append([topverts[0][i1],
1913                                   topverts[0][i2],
1914                                   botverts[0][i2],
1915                                   botverts[0][i1]])
1916 
1917             # all polygons have 4 vertices, so vectorize
1918             polyverts = np.array(polyverts)
1919             polycol = art3d.Poly3DCollection(polyverts,
1920                                              facecolors=color,
1921                                              edgecolors=color,
1922                                              shade=True)
1923             polycol.set_sort_zpos(z)
1924             self.add_collection3d(polycol)
1925 
1926         for col in colls:
1927             col.remove()
1928 
1929     def add_contour_set(
1930             self, cset, extend3d=False, stride=5, zdir='z', offset=None):
1931         zdir = '-' + zdir
1932         if extend3d:
1933             self._3d_extend_contour(cset, stride)
1934         else:
1935             for z, linec in zip(cset.levels, cset.collections):
1936                 if offset is not None:
1937                     z = offset
1938                 art3d.line_collection_2d_to_3d(linec, z, zdir=zdir)
1939 
1940     def add_contourf_set(self, cset, zdir='z', offset=None):
1941         self._add_contourf_set(cset, zdir=zdir, offset=offset)
1942 
1943     def _add_contourf_set(self, cset, zdir='z', offset=None):
1944         """
1945         Returns
1946         -------
1947         levels : `numpy.ndarray`
1948             Levels at which the filled contours are added.
1949         """
1950         zdir = '-' + zdir
1951 
1952         midpoints = cset.levels[:-1] + np.diff(cset.levels) / 2
1953         # Linearly interpolate to get levels for any extensions
1954         if cset._extend_min:
1955             min_level = cset.levels[0] - np.diff(cset.levels[:2]) / 2
1956             midpoints = np.insert(midpoints, 0, min_level)
1957         if cset._extend_max:
1958             max_level = cset.levels[-1] + np.diff(cset.levels[-2:]) / 2
1959             midpoints = np.append(midpoints, max_level)
1960 
1961         for z, linec in zip(midpoints, cset.collections):
1962             if offset is not None:
1963                 z = offset
1964             art3d.poly_collection_2d_to_3d(linec, z, zdir=zdir)
1965             linec.set_sort_zpos(z)
1966         return midpoints
1967 
1968     @_preprocess_data()
1969     def contour(self, X, Y, Z, *args,
1970                 extend3d=False, stride=5, zdir='z', offset=None, **kwargs):
1971         """
1972         Create a 3D contour plot.
1973 
1974         Parameters
1975         ----------
1976         X, Y, Z : array-like,
1977             Input data. See `.Axes.contour` for supported data shapes.
1978         extend3d : bool, default: False
1979             Whether to extend contour in 3D.
1980         stride : int
1981             Step size for extending contour.
1982         zdir : {'x', 'y', 'z'}, default: 'z'
1983             The direction to use.
1984         offset : float, optional
1985             If specified, plot a projection of the contour lines at this
1986             position in a plane normal to *zdir*.
1987         data : indexable object, optional
1988             DATA_PARAMETER_PLACEHOLDER
1989 
1990         *args, **kwargs
1991             Other arguments are forwarded to `matplotlib.axes.Axes.contour`.
1992 
1993         Returns
1994         -------
1995         matplotlib.contour.QuadContourSet
1996         """
1997         had_data = self.has_data()
1998 
1999         jX, jY, jZ = art3d.rotate_axes(X, Y, Z, zdir)
2000         cset = super().contour(jX, jY, jZ, *args, **kwargs)
2001         self.add_contour_set(cset, extend3d, stride, zdir, offset)
2002 
2003         self.auto_scale_xyz(X, Y, Z, had_data)
2004         return cset
2005 
2006     contour3D = contour
2007 
2008     @_preprocess_data()
2009     def tricontour(self, *args,
2010                    extend3d=False, stride=5, zdir='z', offset=None, **kwargs):
2011         """
2012         Create a 3D contour plot.
2013 
2014         .. note::
2015             This method currently produces incorrect output due to a
2016             longstanding bug in 3D PolyCollection rendering.
2017 
2018         Parameters
2019         ----------
2020         X, Y, Z : array-like
2021             Input data. See `.Axes.tricontour` for supported data shapes.
2022         extend3d : bool, default: False
2023             Whether to extend contour in 3D.
2024         stride : int
2025             Step size for extending contour.
2026         zdir : {'x', 'y', 'z'}, default: 'z'
2027             The direction to use.
2028         offset : float, optional
2029             If specified, plot a projection of the contour lines at this
2030             position in a plane normal to *zdir*.
2031         data : indexable object, optional
2032             DATA_PARAMETER_PLACEHOLDER
2033         *args, **kwargs
2034             Other arguments are forwarded to `matplotlib.axes.Axes.tricontour`.
2035 
2036         Returns
2037         -------
2038         matplotlib.tri._tricontour.TriContourSet
2039         """
2040         had_data = self.has_data()
2041 
2042         tri, args, kwargs = Triangulation.get_from_args_and_kwargs(
2043                 *args, **kwargs)
2044         X = tri.x
2045         Y = tri.y
2046         if 'Z' in kwargs:
2047             Z = kwargs.pop('Z')
2048         else:
2049             # We do this so Z doesn't get passed as an arg to Axes.tricontour
2050             Z, *args = args
2051 
2052         jX, jY, jZ = art3d.rotate_axes(X, Y, Z, zdir)
2053         tri = Triangulation(jX, jY, tri.triangles, tri.mask)
2054 
2055         cset = super().tricontour(tri, jZ, *args, **kwargs)
2056         self.add_contour_set(cset, extend3d, stride, zdir, offset)
2057 
2058         self.auto_scale_xyz(X, Y, Z, had_data)
2059         return cset
2060 
2061     def _auto_scale_contourf(self, X, Y, Z, zdir, levels, had_data):
2062         # Autoscale in the zdir based on the levels added, which are
2063         # different from data range if any contour extensions are present
2064         dim_vals = {'x': X, 'y': Y, 'z': Z, zdir: levels}
2065         # Input data and levels have different sizes, but auto_scale_xyz
2066         # expected same-size input, so manually take min/max limits
2067         limits = [(np.nanmin(dim_vals[dim]), np.nanmax(dim_vals[dim]))
2068                   for dim in ['x', 'y', 'z']]
2069         self.auto_scale_xyz(*limits, had_data)
2070 
2071     @_preprocess_data()
2072     def contourf(self, X, Y, Z, *args, zdir='z', offset=None, **kwargs):
2073         """
2074         Create a 3D filled contour plot.
2075 
2076         Parameters
2077         ----------
2078         X, Y, Z : array-like
2079             Input data. See `.Axes.contourf` for supported data shapes.
2080         zdir : {'x', 'y', 'z'}, default: 'z'
2081             The direction to use.
2082         offset : float, optional
2083             If specified, plot a projection of the contour lines at this
2084             position in a plane normal to *zdir*.
2085         data : indexable object, optional
2086             DATA_PARAMETER_PLACEHOLDER
2087         *args, **kwargs
2088             Other arguments are forwarded to `matplotlib.axes.Axes.contourf`.
2089 
2090         Returns
2091         -------
2092         matplotlib.contour.QuadContourSet
2093         """
2094         had_data = self.has_data()
2095 
2096         jX, jY, jZ = art3d.rotate_axes(X, Y, Z, zdir)
2097         cset = super().contourf(jX, jY, jZ, *args, **kwargs)
2098         levels = self._add_contourf_set(cset, zdir, offset)
2099 
2100         self._auto_scale_contourf(X, Y, Z, zdir, levels, had_data)
2101         return cset
2102 
2103     contourf3D = contourf
2104 
2105     @_preprocess_data()
2106     def tricontourf(self, *args, zdir='z', offset=None, **kwargs):
2107         """
2108         Create a 3D filled contour plot.
2109 
2110         .. note::
2111             This method currently produces incorrect output due to a
2112             longstanding bug in 3D PolyCollection rendering.
2113 
2114         Parameters
2115         ----------
2116         X, Y, Z : array-like
2117             Input data. See `.Axes.tricontourf` for supported data shapes.
2118         zdir : {'x', 'y', 'z'}, default: 'z'
2119             The direction to use.
2120         offset : float, optional
2121             If specified, plot a projection of the contour lines at this
2122             position in a plane normal to zdir.
2123         data : indexable object, optional
2124             DATA_PARAMETER_PLACEHOLDER
2125         *args, **kwargs
2126             Other arguments are forwarded to
2127             `matplotlib.axes.Axes.tricontourf`.
2128 
2129         Returns
2130         -------
2131         matplotlib.tri._tricontour.TriContourSet
2132         """
2133         had_data = self.has_data()
2134 
2135         tri, args, kwargs = Triangulation.get_from_args_and_kwargs(
2136                 *args, **kwargs)
2137         X = tri.x
2138         Y = tri.y
2139         if 'Z' in kwargs:
2140             Z = kwargs.pop('Z')
2141         else:
2142             # We do this so Z doesn't get passed as an arg to Axes.tricontourf
2143             Z, *args = args
2144 
2145         jX, jY, jZ = art3d.rotate_axes(X, Y, Z, zdir)
2146         tri = Triangulation(jX, jY, tri.triangles, tri.mask)
2147 
2148         cset = super().tricontourf(tri, jZ, *args, **kwargs)
2149         levels = self._add_contourf_set(cset, zdir, offset)
2150 
2151         self._auto_scale_contourf(X, Y, Z, zdir, levels, had_data)
2152         return cset
2153 
2154     def add_collection3d(self, col, zs=0, zdir='z'):
2155         """
2156         Add a 3D collection object to the plot.
2157 
2158         2D collection types are converted to a 3D version by
2159         modifying the object and adding z coordinate information.
2160 
2161         Supported are:
2162 
2163         - PolyCollection
2164         - LineCollection
2165         - PatchCollection
2166         """
2167         zvals = np.atleast_1d(zs)
2168         zsortval = (np.min(zvals) if zvals.size
2169                     else 0)  # FIXME: arbitrary default
2170 
2171         # FIXME: use issubclass() (although, then a 3D collection
2172         #       object would also pass.)  Maybe have a collection3d
2173         #       abstract class to test for and exclude?
2174         if type(col) is mcoll.PolyCollection:
2175             art3d.poly_collection_2d_to_3d(col, zs=zs, zdir=zdir)
2176             col.set_sort_zpos(zsortval)
2177         elif type(col) is mcoll.LineCollection:
2178             art3d.line_collection_2d_to_3d(col, zs=zs, zdir=zdir)
2179             col.set_sort_zpos(zsortval)
2180         elif type(col) is mcoll.PatchCollection:
2181             art3d.patch_collection_2d_to_3d(col, zs=zs, zdir=zdir)
2182             col.set_sort_zpos(zsortval)
2183 
2184         collection = super().add_collection(col)
2185         return collection
2186 
2187     @_preprocess_data(replace_names=["xs", "ys", "zs", "s",
2188                                      "edgecolors", "c", "facecolor",
2189                                      "facecolors", "color"])
2190     def scatter(self, xs, ys, zs=0, zdir='z', s=20, c=None, depthshade=True,
2191                 *args, **kwargs):
2192         """
2193         Create a scatter plot.
2194 
2195         Parameters
2196         ----------
2197         xs, ys : array-like
2198             The data positions.
2199         zs : float or array-like, default: 0
2200             The z-positions. Either an array of the same length as *xs* and
2201             *ys* or a single value to place all points in the same plane.
2202         zdir : {'x', 'y', 'z', '-x', '-y', '-z'}, default: 'z'
2203             The axis direction for the *zs*. This is useful when plotting 2D
2204             data on a 3D Axes. The data must be passed as *xs*, *ys*. Setting
2205             *zdir* to 'y' then plots the data to the x-z-plane.
2206 
2207             See also :doc:`/gallery/mplot3d/2dcollections3d`.
2208 
2209         s : float or array-like, default: 20
2210             The marker size in points**2. Either an array of the same length
2211             as *xs* and *ys* or a single value to make all markers the same
2212             size.
2213         c : color, sequence, or sequence of colors, optional
2214             The marker color. Possible values:
2215 
2216             - A single color format string.
2217             - A sequence of colors of length n.
2218             - A sequence of n numbers to be mapped to colors using *cmap* and
2219               *norm*.
2220             - A 2D array in which the rows are RGB or RGBA.
2221 
2222             For more details see the *c* argument of `~.axes.Axes.scatter`.
2223         depthshade : bool, default: True
2224             Whether to shade the scatter markers to give the appearance of
2225             depth. Each call to ``scatter()`` will perform its depthshading
2226             independently.
2227         data : indexable object, optional
2228             DATA_PARAMETER_PLACEHOLDER
2229         **kwargs
2230             All other keyword arguments are passed on to `~.axes.Axes.scatter`.
2231 
2232         Returns
2233         -------
2234         paths : `~matplotlib.collections.PathCollection`
2235         """
2236 
2237         had_data = self.has_data()
2238         zs_orig = zs
2239 
2240         xs, ys, zs = np.broadcast_arrays(
2241             *[np.ravel(np.ma.filled(t, np.nan)) for t in [xs, ys, zs]])
2242         s = np.ma.ravel(s)  # This doesn't have to match x, y in size.
2243 
2244         xs, ys, zs, s, c = cbook.delete_masked_points(xs, ys, zs, s, c)
2245 
2246         # For xs and ys, 2D scatter() will do the copying.
2247         if np.may_share_memory(zs_orig, zs):  # Avoid unnecessary copies.
2248             zs = zs.copy()
2249 
2250         patches = super().scatter(xs, ys, s=s, c=c, *args, **kwargs)
2251         art3d.patch_collection_2d_to_3d(patches, zs=zs, zdir=zdir,
2252                                         depthshade=depthshade)
2253 
2254         if self._zmargin < 0.05 and xs.size > 0:
2255             self.set_zmargin(0.05)
2256 
2257         self.auto_scale_xyz(xs, ys, zs, had_data)
2258 
2259         return patches
2260 
2261     scatter3D = scatter
2262 
2263     @_preprocess_data()
2264     def bar(self, left, height, zs=0, zdir='z', *args, **kwargs):
2265         """
2266         Add 2D bar(s).
2267 
2268         Parameters
2269         ----------
2270         left : 1D array-like
2271             The x coordinates of the left sides of the bars.
2272         height : 1D array-like
2273             The height of the bars.
2274         zs : float or 1D array-like
2275             Z coordinate of bars; if a single value is specified, it will be
2276             used for all bars.
2277         zdir : {'x', 'y', 'z'}, default: 'z'
2278             When plotting 2D data, the direction to use as z ('x', 'y' or 'z').
2279         data : indexable object, optional
2280             DATA_PARAMETER_PLACEHOLDER
2281         **kwargs
2282             Other keyword arguments are forwarded to
2283             `matplotlib.axes.Axes.bar`.
2284 
2285         Returns
2286         -------
2287         mpl_toolkits.mplot3d.art3d.Patch3DCollection
2288         """
2289         had_data = self.has_data()
2290 
2291         patches = super().bar(left, height, *args, **kwargs)
2292 
2293         zs = np.broadcast_to(zs, len(left))
2294 
2295         verts = []
2296         verts_zs = []
2297         for p, z in zip(patches, zs):
2298             vs = art3d._get_patch_verts(p)
2299             verts += vs.tolist()
2300             verts_zs += [z] * len(vs)
2301             art3d.patch_2d_to_3d(p, z, zdir)
2302             if 'alpha' in kwargs:
2303                 p.set_alpha(kwargs['alpha'])
2304 
2305         if len(verts) > 0:
2306             # the following has to be skipped if verts is empty
2307             # NOTE: Bugs could still occur if len(verts) > 0,
2308             #       but the "2nd dimension" is empty.
2309             xs, ys = zip(*verts)
2310         else:
2311             xs, ys = [], []
2312 
2313         xs, ys, verts_zs = art3d.juggle_axes(xs, ys, verts_zs, zdir)
2314         self.auto_scale_xyz(xs, ys, verts_zs, had_data)
2315 
2316         return patches
2317 
2318     @_preprocess_data()
2319     def bar3d(self, x, y, z, dx, dy, dz, color=None,
2320               zsort='average', shade=True, lightsource=None, *args, **kwargs):
2321         """
2322         Generate a 3D barplot.
2323 
2324         This method creates three-dimensional barplot where the width,
2325         depth, height, and color of the bars can all be uniquely set.
2326 
2327         Parameters
2328         ----------
2329         x, y, z : array-like
2330             The coordinates of the anchor point of the bars.
2331 
2332         dx, dy, dz : float or array-like
2333             The width, depth, and height of the bars, respectively.
2334 
2335         color : sequence of colors, optional
2336             The color of the bars can be specified globally or
2337             individually. This parameter can be:
2338 
2339             - A single color, to color all bars the same color.
2340             - An array of colors of length N bars, to color each bar
2341               independently.
2342             - An array of colors of length 6, to color the faces of the
2343               bars similarly.
2344             - An array of colors of length 6 * N bars, to color each face
2345               independently.
2346 
2347             When coloring the faces of the boxes specifically, this is
2348             the order of the coloring:
2349 
2350             1. -Z (bottom of box)
2351             2. +Z (top of box)
2352             3. -Y
2353             4. +Y
2354             5. -X
2355             6. +X
2356 
2357         zsort : str, optional
2358             The z-axis sorting scheme passed onto `~.art3d.Poly3DCollection`
2359 
2360         shade : bool, default: True
2361             When true, this shades the dark sides of the bars (relative
2362             to the plot's source of light).
2363 
2364         lightsource : `~matplotlib.colors.LightSource`
2365             The lightsource to use when *shade* is True.
2366 
2367         data : indexable object, optional
2368             DATA_PARAMETER_PLACEHOLDER
2369 
2370         **kwargs
2371             Any additional keyword arguments are passed onto
2372             `~.art3d.Poly3DCollection`.
2373 
2374         Returns
2375         -------
2376         collection : `~.art3d.Poly3DCollection`
2377             A collection of three-dimensional polygons representing the bars.
2378         """
2379 
2380         had_data = self.has_data()
2381 
2382         x, y, z, dx, dy, dz = np.broadcast_arrays(
2383             np.atleast_1d(x), y, z, dx, dy, dz)
2384         minx = np.min(x)
2385         maxx = np.max(x + dx)
2386         miny = np.min(y)
2387         maxy = np.max(y + dy)
2388         minz = np.min(z)
2389         maxz = np.max(z + dz)
2390 
2391         # shape (6, 4, 3)
2392         # All faces are oriented facing outwards - when viewed from the
2393         # outside, their vertices are in a counterclockwise ordering.
2394         cuboid = np.array([
2395             # -z
2396             (
2397                 (0, 0, 0),
2398                 (0, 1, 0),
2399                 (1, 1, 0),
2400                 (1, 0, 0),
2401             ),
2402             # +z
2403             (
2404                 (0, 0, 1),
2405                 (1, 0, 1),
2406                 (1, 1, 1),
2407                 (0, 1, 1),
2408             ),
2409             # -y
2410             (
2411                 (0, 0, 0),
2412                 (1, 0, 0),
2413                 (1, 0, 1),
2414                 (0, 0, 1),
2415             ),
2416             # +y
2417             (
2418                 (0, 1, 0),
2419                 (0, 1, 1),
2420                 (1, 1, 1),
2421                 (1, 1, 0),
2422             ),
2423             # -x
2424             (
2425                 (0, 0, 0),
2426                 (0, 0, 1),
2427                 (0, 1, 1),
2428                 (0, 1, 0),
2429             ),
2430             # +x
2431             (
2432                 (1, 0, 0),
2433                 (1, 1, 0),
2434                 (1, 1, 1),
2435                 (1, 0, 1),
2436             ),
2437         ])
2438 
2439         # indexed by [bar, face, vertex, coord]
2440         polys = np.empty(x.shape + cuboid.shape)
2441 
2442         # handle each coordinate separately
2443         for i, p, dp in [(0, x, dx), (1, y, dy), (2, z, dz)]:
2444             p = p[..., np.newaxis, np.newaxis]
2445             dp = dp[..., np.newaxis, np.newaxis]
2446             polys[..., i] = p + dp * cuboid[..., i]
2447 
2448         # collapse the first two axes
2449         polys = polys.reshape((-1,) + polys.shape[2:])
2450 
2451         facecolors = []
2452         if color is None:
2453             color = [self._get_patches_for_fill.get_next_color()]
2454 
2455         color = list(mcolors.to_rgba_array(color))
2456 
2457         if len(color) == len(x):
2458             # bar colors specified, need to expand to number of faces
2459             for c in color:
2460                 facecolors.extend([c] * 6)
2461         else:
2462             # a single color specified, or face colors specified explicitly
2463             facecolors = color
2464             if len(facecolors) < len(x):
2465                 facecolors *= (6 * len(x))
2466 
2467         col = art3d.Poly3DCollection(polys,
2468                                      zsort=zsort,
2469                                      facecolors=facecolors,
2470                                      shade=shade,
2471                                      lightsource=lightsource,
2472                                      *args, **kwargs)
2473         self.add_collection(col)
2474 
2475         self.auto_scale_xyz((minx, maxx), (miny, maxy), (minz, maxz), had_data)
2476 
2477         return col
2478 
2479     def set_title(self, label, fontdict=None, loc='center', **kwargs):
2480         # docstring inherited
2481         ret = super().set_title(label, fontdict=fontdict, loc=loc, **kwargs)
2482         (x, y) = self.title.get_position()
2483         self.title.set_y(0.92 * y)
2484         return ret
2485 
2486     @_preprocess_data()
2487     def quiver(self, X, Y, Z, U, V, W, *,
2488                length=1, arrow_length_ratio=.3, pivot='tail', normalize=False,
2489                **kwargs):
2490         """
2491         Plot a 3D field of arrows.
2492 
2493         The arguments can be array-like or scalars, so long as they can be
2494         broadcast together. The arguments can also be masked arrays. If an
2495         element in any of argument is masked, then that corresponding quiver
2496         element will not be plotted.
2497 
2498         Parameters
2499         ----------
2500         X, Y, Z : array-like
2501             The x, y and z coordinates of the arrow locations (default is
2502             tail of arrow; see *pivot* kwarg).
2503 
2504         U, V, W : array-like
2505             The x, y and z components of the arrow vectors.
2506 
2507         length : float, default: 1
2508             The length of each quiver.
2509 
2510         arrow_length_ratio : float, default: 0.3
2511             The ratio of the arrow head with respect to the quiver.
2512 
2513         pivot : {'tail', 'middle', 'tip'}, default: 'tail'
2514             The part of the arrow that is at the grid point; the arrow
2515             rotates about this point, hence the name *pivot*.
2516 
2517         normalize : bool, default: False
2518             Whether all arrows are normalized to have the same length, or keep
2519             the lengths defined by *u*, *v*, and *w*.
2520 
2521         data : indexable object, optional
2522             DATA_PARAMETER_PLACEHOLDER
2523 
2524         **kwargs
2525             Any additional keyword arguments are delegated to
2526             :class:`.Line3DCollection`
2527         """
2528 
2529         def calc_arrows(UVW):
2530             # get unit direction vector perpendicular to (u, v, w)
2531             x = UVW[:, 0]
2532             y = UVW[:, 1]
2533             norm = np.linalg.norm(UVW[:, :2], axis=1)
2534             x_p = np.divide(y, norm, where=norm != 0, out=np.zeros_like(x))
2535             y_p = np.divide(-x,  norm, where=norm != 0, out=np.ones_like(x))
2536             # compute the two arrowhead direction unit vectors
2537             rangle = math.radians(15)
2538             c = math.cos(rangle)
2539             s = math.sin(rangle)
2540             # construct the rotation matrices of shape (3, 3, n)
2541             r13 = y_p * s
2542             r32 = x_p * s
2543             r12 = x_p * y_p * (1 - c)
2544             Rpos = np.array(
2545                 [[c + (x_p ** 2) * (1 - c), r12, r13],
2546                  [r12, c + (y_p ** 2) * (1 - c), -r32],
2547                  [-r13, r32, np.full_like(x_p, c)]])
2548             # opposite rotation negates all the sin terms
2549             Rneg = Rpos.copy()
2550             Rneg[[0, 1, 2, 2], [2, 2, 0, 1]] *= -1
2551             # Batch n (3, 3) x (3) matrix multiplications ((3, 3, n) x (n, 3)).
2552             Rpos_vecs = np.einsum("ij...,...j->...i", Rpos, UVW)
2553             Rneg_vecs = np.einsum("ij...,...j->...i", Rneg, UVW)
2554             # Stack into (n, 2, 3) result.
2555             return np.stack([Rpos_vecs, Rneg_vecs], axis=1)
2556 
2557         had_data = self.has_data()
2558 
2559         input_args = [X, Y, Z, U, V, W]
2560 
2561         # extract the masks, if any
2562         masks = [k.mask for k in input_args
2563                  if isinstance(k, np.ma.MaskedArray)]
2564         # broadcast to match the shape
2565         bcast = np.broadcast_arrays(*input_args, *masks)
2566         input_args = bcast[:6]
2567         masks = bcast[6:]
2568         if masks:
2569             # combine the masks into one
2570             mask = functools.reduce(np.logical_or, masks)
2571             # put mask on and compress
2572             input_args = [np.ma.array(k, mask=mask).compressed()
2573                           for k in input_args]
2574         else:
2575             input_args = [np.ravel(k) for k in input_args]
2576 
2577         if any(len(v) == 0 for v in input_args):
2578             # No quivers, so just make an empty collection and return early
2579             linec = art3d.Line3DCollection([], **kwargs)
2580             self.add_collection(linec)
2581             return linec
2582 
2583         shaft_dt = np.array([0., length], dtype=float)
2584         arrow_dt = shaft_dt * arrow_length_ratio
2585 
2586         _api.check_in_list(['tail', 'middle', 'tip'], pivot=pivot)
2587         if pivot == 'tail':
2588             shaft_dt -= length
2589         elif pivot == 'middle':
2590             shaft_dt -= length / 2
2591 
2592         XYZ = np.column_stack(input_args[:3])
2593         UVW = np.column_stack(input_args[3:]).astype(float)
2594 
2595         # Normalize rows of UVW
2596         norm = np.linalg.norm(UVW, axis=1)
2597 
2598         # If any row of UVW is all zeros, don't make a quiver for it
2599         mask = norm > 0
2600         XYZ = XYZ[mask]
2601         if normalize:
2602             UVW = UVW[mask] / norm[mask].reshape((-1, 1))
2603         else:
2604             UVW = UVW[mask]
2605 
2606         if len(XYZ) > 0:
2607             # compute the shaft lines all at once with an outer product
2608             shafts = (XYZ - np.multiply.outer(shaft_dt, UVW)).swapaxes(0, 1)
2609             # compute head direction vectors, n heads x 2 sides x 3 dimensions
2610             head_dirs = calc_arrows(UVW)
2611             # compute all head lines at once, starting from the shaft ends
2612             heads = shafts[:, :1] - np.multiply.outer(arrow_dt, head_dirs)
2613             # stack left and right head lines together
2614             heads = heads.reshape((len(arrow_dt), -1, 3))
2615             # transpose to get a list of lines
2616             heads = heads.swapaxes(0, 1)
2617 
2618             lines = [*shafts, *heads]
2619         else:
2620             lines = []
2621 
2622         linec = art3d.Line3DCollection(lines, **kwargs)
2623         self.add_collection(linec)
2624 
2625         self.auto_scale_xyz(XYZ[:, 0], XYZ[:, 1], XYZ[:, 2], had_data)
2626 
2627         return linec
2628 
2629     quiver3D = quiver
2630 
2631     def voxels(self, *args, facecolors=None, edgecolors=None, shade=True,
2632                lightsource=None, **kwargs):
2633         """
2634         ax.voxels([x, y, z,] /, filled, facecolors=None, edgecolors=None, \
2635 **kwargs)
2636 
2637         Plot a set of filled voxels
2638 
2639         All voxels are plotted as 1x1x1 cubes on the axis, with
2640         ``filled[0, 0, 0]`` placed with its lower corner at the origin.
2641         Occluded faces are not plotted.
2642 
2643         Parameters
2644         ----------
2645         filled : 3D np.array of bool
2646             A 3D array of values, with truthy values indicating which voxels
2647             to fill
2648 
2649         x, y, z : 3D np.array, optional
2650             The coordinates of the corners of the voxels. This should broadcast
2651             to a shape one larger in every dimension than the shape of
2652             *filled*.  These can be used to plot non-cubic voxels.
2653 
2654             If not specified, defaults to increasing integers along each axis,
2655             like those returned by :func:`~numpy.indices`.
2656             As indicated by the ``/`` in the function signature, these
2657             arguments can only be passed positionally.
2658 
2659         facecolors, edgecolors : array-like, optional
2660             The color to draw the faces and edges of the voxels. Can only be
2661             passed as keyword arguments.
2662             These parameters can be:
2663 
2664             - A single color value, to color all voxels the same color. This
2665               can be either a string, or a 1D RGB/RGBA array
2666             - ``None``, the default, to use a single color for the faces, and
2667               the style default for the edges.
2668             - A 3D `~numpy.ndarray` of color names, with each item the color
2669               for the corresponding voxel. The size must match the voxels.
2670             - A 4D `~numpy.ndarray` of RGB/RGBA data, with the components
2671               along the last axis.
2672 
2673         shade : bool, default: True
2674             Whether to shade the facecolors.
2675 
2676         lightsource : `~matplotlib.colors.LightSource`
2677             The lightsource to use when *shade* is True.
2678 
2679         **kwargs
2680             Additional keyword arguments to pass onto
2681             `~mpl_toolkits.mplot3d.art3d.Poly3DCollection`.
2682 
2683         Returns
2684         -------
2685         faces : dict
2686             A dictionary indexed by coordinate, where ``faces[i, j, k]`` is a
2687             `.Poly3DCollection` of the faces drawn for the voxel
2688             ``filled[i, j, k]``. If no faces were drawn for a given voxel,
2689             either because it was not asked to be drawn, or it is fully
2690             occluded, then ``(i, j, k) not in faces``.
2691 
2692         Examples
2693         --------
2694         .. plot:: gallery/mplot3d/voxels.py
2695         .. plot:: gallery/mplot3d/voxels_rgb.py
2696         .. plot:: gallery/mplot3d/voxels_torus.py
2697         .. plot:: gallery/mplot3d/voxels_numpy_logo.py
2698         """
2699 
2700         # work out which signature we should be using, and use it to parse
2701         # the arguments. Name must be voxels for the correct error message
2702         if len(args) >= 3:
2703             # underscores indicate position only
2704             def voxels(__x, __y, __z, filled, **kwargs):
2705                 return (__x, __y, __z), filled, kwargs
2706         else:
2707             def voxels(filled, **kwargs):
2708                 return None, filled, kwargs
2709 
2710         xyz, filled, kwargs = voxels(*args, **kwargs)
2711 
2712         # check dimensions
2713         if filled.ndim != 3:
2714             raise ValueError("Argument filled must be 3-dimensional")
2715         size = np.array(filled.shape, dtype=np.intp)
2716 
2717         # check xyz coordinates, which are one larger than the filled shape
2718         coord_shape = tuple(size + 1)
2719         if xyz is None:
2720             x, y, z = np.indices(coord_shape)
2721         else:
2722             x, y, z = (np.broadcast_to(c, coord_shape) for c in xyz)
2723 
2724         def _broadcast_color_arg(color, name):
2725             if np.ndim(color) in (0, 1):
2726                 # single color, like "red" or [1, 0, 0]
2727                 return np.broadcast_to(color, filled.shape + np.shape(color))
2728             elif np.ndim(color) in (3, 4):
2729                 # 3D array of strings, or 4D array with last axis rgb
2730                 if np.shape(color)[:3] != filled.shape:
2731                     raise ValueError(
2732                         f"When multidimensional, {name} must match the shape "
2733                         "of filled")
2734                 return color
2735             else:
2736                 raise ValueError(f"Invalid {name} argument")
2737 
2738         # broadcast and default on facecolors
2739         if facecolors is None:
2740             facecolors = self._get_patches_for_fill.get_next_color()
2741         facecolors = _broadcast_color_arg(facecolors, 'facecolors')
2742 
2743         # broadcast but no default on edgecolors
2744         edgecolors = _broadcast_color_arg(edgecolors, 'edgecolors')
2745 
2746         # scale to the full array, even if the data is only in the center
2747         self.auto_scale_xyz(x, y, z)
2748 
2749         # points lying on corners of a square
2750         square = np.array([
2751             [0, 0, 0],
2752             [1, 0, 0],
2753             [1, 1, 0],
2754             [0, 1, 0],
2755         ], dtype=np.intp)
2756 
2757         voxel_faces = defaultdict(list)
2758 
2759         def permutation_matrices(n):
2760             """Generate cyclic permutation matrices."""
2761             mat = np.eye(n, dtype=np.intp)
2762             for i in range(n):
2763                 yield mat
2764                 mat = np.roll(mat, 1, axis=0)
2765 
2766         # iterate over each of the YZ, ZX, and XY orientations, finding faces
2767         # to render
2768         for permute in permutation_matrices(3):
2769             # find the set of ranges to iterate over
2770             pc, qc, rc = permute.T.dot(size)
2771             pinds = np.arange(pc)
2772             qinds = np.arange(qc)
2773             rinds = np.arange(rc)
2774 
2775             square_rot_pos = square.dot(permute.T)
2776             square_rot_neg = square_rot_pos[::-1]
2777 
2778             # iterate within the current plane
2779             for p in pinds:
2780                 for q in qinds:
2781                     # iterate perpendicularly to the current plane, handling
2782                     # boundaries. We only draw faces between a voxel and an
2783                     # empty space, to avoid drawing internal faces.
2784 
2785                     # draw lower faces
2786                     p0 = permute.dot([p, q, 0])
2787                     i0 = tuple(p0)
2788                     if filled[i0]:
2789                         voxel_faces[i0].append(p0 + square_rot_neg)
2790 
2791                     # draw middle faces
2792                     for r1, r2 in zip(rinds[:-1], rinds[1:]):
2793                         p1 = permute.dot([p, q, r1])
2794                         p2 = permute.dot([p, q, r2])
2795 
2796                         i1 = tuple(p1)
2797                         i2 = tuple(p2)
2798 
2799                         if filled[i1] and not filled[i2]:
2800                             voxel_faces[i1].append(p2 + square_rot_pos)
2801                         elif not filled[i1] and filled[i2]:
2802                             voxel_faces[i2].append(p2 + square_rot_neg)
2803 
2804                     # draw upper faces
2805                     pk = permute.dot([p, q, rc-1])
2806                     pk2 = permute.dot([p, q, rc])
2807                     ik = tuple(pk)
2808                     if filled[ik]:
2809                         voxel_faces[ik].append(pk2 + square_rot_pos)
2810 
2811         # iterate over the faces, and generate a Poly3DCollection for each
2812         # voxel
2813         polygons = {}
2814         for coord, faces_inds in voxel_faces.items():
2815             # convert indices into 3D positions
2816             if xyz is None:
2817                 faces = faces_inds
2818             else:
2819                 faces = []
2820                 for face_inds in faces_inds:
2821                     ind = face_inds[:, 0], face_inds[:, 1], face_inds[:, 2]
2822                     face = np.empty(face_inds.shape)
2823                     face[:, 0] = x[ind]
2824                     face[:, 1] = y[ind]
2825                     face[:, 2] = z[ind]
2826                     faces.append(face)
2827 
2828             # shade the faces
2829             facecolor = facecolors[coord]
2830             edgecolor = edgecolors[coord]
2831 
2832             poly = art3d.Poly3DCollection(
2833                 faces, facecolors=facecolor, edgecolors=edgecolor,
2834                 shade=shade, lightsource=lightsource, **kwargs)
2835             self.add_collection3d(poly)
2836             polygons[coord] = poly
2837 
2838         return polygons
2839 
2840     @_preprocess_data(replace_names=["x", "y", "z", "xerr", "yerr", "zerr"])
2841     def errorbar(self, x, y, z, zerr=None, yerr=None, xerr=None, fmt='',
2842                  barsabove=False, errorevery=1, ecolor=None, elinewidth=None,
2843                  capsize=None, capthick=None, xlolims=False, xuplims=False,
2844                  ylolims=False, yuplims=False, zlolims=False, zuplims=False,
2845                  **kwargs):
2846         """
2847         Plot lines and/or markers with errorbars around them.
2848 
2849         *x*/*y*/*z* define the data locations, and *xerr*/*yerr*/*zerr* define
2850         the errorbar sizes. By default, this draws the data markers/lines as
2851         well the errorbars. Use fmt='none' to draw errorbars only.
2852 
2853         Parameters
2854         ----------
2855         x, y, z : float or array-like
2856             The data positions.
2857 
2858         xerr, yerr, zerr : float or array-like, shape (N,) or (2, N), optional
2859             The errorbar sizes:
2860 
2861             - scalar: Symmetric +/- values for all data points.
2862             - shape(N,): Symmetric +/-values for each data point.
2863             - shape(2, N): Separate - and + values for each bar. First row
2864               contains the lower errors, the second row contains the upper
2865               errors.
2866             - *None*: No errorbar.
2867 
2868             Note that all error arrays should have *positive* values.
2869 
2870         fmt : str, default: ''
2871             The format for the data points / data lines. See `.plot` for
2872             details.
2873 
2874             Use 'none' (case-insensitive) to plot errorbars without any data
2875             markers.
2876 
2877         ecolor : color, default: None
2878             The color of the errorbar lines.  If None, use the color of the
2879             line connecting the markers.
2880 
2881         elinewidth : float, default: None
2882             The linewidth of the errorbar lines. If None, the linewidth of
2883             the current style is used.
2884 
2885         capsize : float, default: :rc:`errorbar.capsize`
2886             The length of the error bar caps in points.
2887 
2888         capthick : float, default: None
2889             An alias to the keyword argument *markeredgewidth* (a.k.a. *mew*).
2890             This setting is a more sensible name for the property that
2891             controls the thickness of the error bar cap in points. For
2892             backwards compatibility, if *mew* or *markeredgewidth* are given,
2893             then they will over-ride *capthick*. This may change in future
2894             releases.
2895 
2896         barsabove : bool, default: False
2897             If True, will plot the errorbars above the plot
2898             symbols. Default is below.
2899 
2900         xlolims, ylolims, zlolims : bool, default: False
2901             These arguments can be used to indicate that a value gives only
2902             lower limits. In that case a caret symbol is used to indicate
2903             this. *lims*-arguments may be scalars, or array-likes of the same
2904             length as the errors. To use limits with inverted axes,
2905             `~.Axes.set_xlim` or `~.Axes.set_ylim` must be called before
2906             `errorbar`. Note the tricky parameter names: setting e.g.
2907             *ylolims* to True means that the y-value is a *lower* limit of the
2908             True value, so, only an *upward*-pointing arrow will be drawn!
2909 
2910         xuplims, yuplims, zuplims : bool, default: False
2911             Same as above, but for controlling the upper limits.
2912 
2913         errorevery : int or (int, int), default: 1
2914             draws error bars on a subset of the data. *errorevery* =N draws
2915             error bars on the points (x[::N], y[::N], z[::N]).
2916             *errorevery* =(start, N) draws error bars on the points
2917             (x[start::N], y[start::N], z[start::N]). e.g. *errorevery* =(6, 3)
2918             adds error bars to the data at (x[6], x[9], x[12], x[15], ...).
2919             Used to avoid overlapping error bars when two series share x-axis
2920             values.
2921 
2922         Returns
2923         -------
2924         errlines : list
2925             List of `~mpl_toolkits.mplot3d.art3d.Line3DCollection` instances
2926             each containing an errorbar line.
2927         caplines : list
2928             List of `~mpl_toolkits.mplot3d.art3d.Line3D` instances each
2929             containing a capline object.
2930         limmarks : list
2931             List of `~mpl_toolkits.mplot3d.art3d.Line3D` instances each
2932             containing a marker with an upper or lower limit.
2933 
2934         Other Parameters
2935         ----------------
2936         data : indexable object, optional
2937             DATA_PARAMETER_PLACEHOLDER
2938 
2939         **kwargs
2940             All other keyword arguments for styling errorbar lines are passed
2941             `~mpl_toolkits.mplot3d.art3d.Line3DCollection`.
2942 
2943         Examples
2944         --------
2945         .. plot:: gallery/mplot3d/errorbar3d.py
2946         """
2947         had_data = self.has_data()
2948 
2949         kwargs = cbook.normalize_kwargs(kwargs, mlines.Line2D)
2950         # Drop anything that comes in as None to use the default instead.
2951         kwargs = {k: v for k, v in kwargs.items() if v is not None}
2952         kwargs.setdefault('zorder', 2)
2953 
2954         self._process_unit_info([("x", x), ("y", y), ("z", z)], kwargs,
2955                                 convert=False)
2956 
2957         # make sure all the args are iterable; use lists not arrays to
2958         # preserve units
2959         x = x if np.iterable(x) else [x]
2960         y = y if np.iterable(y) else [y]
2961         z = z if np.iterable(z) else [z]
2962 
2963         if not len(x) == len(y) == len(z):
2964             raise ValueError("'x', 'y', and 'z' must have the same size")
2965 
2966         everymask = self._errorevery_to_mask(x, errorevery)
2967 
2968         label = kwargs.pop("label", None)
2969         kwargs['label'] = '_nolegend_'
2970 
2971         # Create the main line and determine overall kwargs for child artists.
2972         # We avoid calling self.plot() directly, or self._get_lines(), because
2973         # that would call self._process_unit_info again, and do other indirect
2974         # data processing.
2975         (data_line, base_style), = self._get_lines._plot_args(
2976             (x, y) if fmt == '' else (x, y, fmt), kwargs, return_kwargs=True)
2977         art3d.line_2d_to_3d(data_line, zs=z)
2978 
2979         # Do this after creating `data_line` to avoid modifying `base_style`.
2980         if barsabove:
2981             data_line.set_zorder(kwargs['zorder'] - .1)
2982         else:
2983             data_line.set_zorder(kwargs['zorder'] + .1)
2984 
2985         # Add line to plot, or throw it away and use it to determine kwargs.
2986         if fmt.lower() != 'none':
2987             self.add_line(data_line)
2988         else:
2989             data_line = None
2990             # Remove alpha=0 color that _process_plot_format returns.
2991             base_style.pop('color')
2992 
2993         if 'color' not in base_style:
2994             base_style['color'] = 'C0'
2995         if ecolor is None:
2996             ecolor = base_style['color']
2997 
2998         # Eject any line-specific information from format string, as it's not
2999         # needed for bars or caps.
3000         for key in ['marker', 'markersize', 'markerfacecolor',
3001                     'markeredgewidth', 'markeredgecolor', 'markevery',
3002                     'linestyle', 'fillstyle', 'drawstyle', 'dash_capstyle',
3003                     'dash_joinstyle', 'solid_capstyle', 'solid_joinstyle']:
3004             base_style.pop(key, None)
3005 
3006         # Make the style dict for the line collections (the bars).
3007         eb_lines_style = {**base_style, 'color': ecolor}
3008 
3009         if elinewidth:
3010             eb_lines_style['linewidth'] = elinewidth
3011         elif 'linewidth' in kwargs:
3012             eb_lines_style['linewidth'] = kwargs['linewidth']
3013 
3014         for key in ('transform', 'alpha', 'zorder', 'rasterized'):
3015             if key in kwargs:
3016                 eb_lines_style[key] = kwargs[key]
3017 
3018         # Make the style dict for caps (the "hats").
3019         eb_cap_style = {**base_style, 'linestyle': 'None'}
3020         if capsize is None:
3021             capsize = mpl.rcParams["errorbar.capsize"]
3022         if capsize > 0:
3023             eb_cap_style['markersize'] = 2. * capsize
3024         if capthick is not None:
3025             eb_cap_style['markeredgewidth'] = capthick
3026         eb_cap_style['color'] = ecolor
3027 
3028         def _apply_mask(arrays, mask):
3029             # Return, for each array in *arrays*, the elements for which *mask*
3030             # is True, without using fancy indexing.
3031             return [[*itertools.compress(array, mask)] for array in arrays]
3032 
3033         def _extract_errs(err, data, lomask, himask):
3034             # For separate +/- error values we need to unpack err
3035             if len(err.shape) == 2:
3036                 low_err, high_err = err
3037             else:
3038                 low_err, high_err = err, err
3039 
3040             lows = np.where(lomask | ~everymask, data, data - low_err)
3041             highs = np.where(himask | ~everymask, data, data + high_err)
3042 
3043             return lows, highs
3044 
3045         # collect drawn items while looping over the three coordinates
3046         errlines, caplines, limmarks = [], [], []
3047 
3048         # list of endpoint coordinates, used for auto-scaling
3049         coorderrs = []
3050 
3051         # define the markers used for errorbar caps and limits below
3052         # the dictionary key is mapped by the `i_xyz` helper dictionary
3053         capmarker = {0: '|', 1: '|', 2: '_'}
3054         i_xyz = {'x': 0, 'y': 1, 'z': 2}
3055 
3056         # Calculate marker size from points to quiver length. Because these are
3057         # not markers, and 3D Axes do not use the normal transform stack, this
3058         # is a bit involved. Since the quiver arrows will change size as the
3059         # scene is rotated, they are given a standard size based on viewing
3060         # them directly in planar form.
3061         quiversize = eb_cap_style.get('markersize',
3062                                       mpl.rcParams['lines.markersize']) ** 2
3063         quiversize *= self.figure.dpi / 72
3064         quiversize = self.transAxes.inverted().transform([
3065             (0, 0), (quiversize, quiversize)])
3066         quiversize = np.mean(np.diff(quiversize, axis=0))
3067         # quiversize is now in Axes coordinates, and to convert back to data
3068         # coordinates, we need to run it through the inverse 3D transform. For
3069         # consistency, this uses a fixed elevation, azimuth, and roll.
3070         with cbook._setattr_cm(self, elev=0, azim=0, roll=0):
3071             invM = np.linalg.inv(self.get_proj())
3072         # elev=azim=roll=0 produces the Y-Z plane, so quiversize in 2D 'x' is
3073         # 'y' in 3D, hence the 1 index.
3074         quiversize = np.dot(invM, [quiversize, 0, 0, 0])[1]
3075         # Quivers use a fixed 15-degree arrow head, so scale up the length so
3076         # that the size corresponds to the base. In other words, this constant
3077         # corresponds to the equation tan(15) = (base / 2) / (arrow length).
3078         quiversize *= 1.8660254037844388
3079         eb_quiver_style = {**eb_cap_style,
3080                            'length': quiversize, 'arrow_length_ratio': 1}
3081         eb_quiver_style.pop('markersize', None)
3082 
3083         # loop over x-, y-, and z-direction and draw relevant elements
3084         for zdir, data, err, lolims, uplims in zip(
3085                 ['x', 'y', 'z'], [x, y, z], [xerr, yerr, zerr],
3086                 [xlolims, ylolims, zlolims], [xuplims, yuplims, zuplims]):
3087 
3088             dir_vector = art3d.get_dir_vector(zdir)
3089             i_zdir = i_xyz[zdir]
3090 
3091             if err is None:
3092                 continue
3093 
3094             if not np.iterable(err):
3095                 err = [err] * len(data)
3096 
3097             err = np.atleast_1d(err)
3098 
3099             # arrays fine here, they are booleans and hence not units
3100             lolims = np.broadcast_to(lolims, len(data)).astype(bool)
3101             uplims = np.broadcast_to(uplims, len(data)).astype(bool)
3102 
3103             # a nested list structure that expands to (xl,xh),(yl,yh),(zl,zh),
3104             # where x/y/z and l/h correspond to dimensions and low/high
3105             # positions of errorbars in a dimension we're looping over
3106             coorderr = [
3107                 _extract_errs(err * dir_vector[i], coord, lolims, uplims)
3108                 for i, coord in enumerate([x, y, z])]
3109             (xl, xh), (yl, yh), (zl, zh) = coorderr
3110 
3111             # draws capmarkers - flat caps orthogonal to the error bars
3112             nolims = ~(lolims | uplims)
3113             if nolims.any() and capsize > 0:
3114                 lo_caps_xyz = _apply_mask([xl, yl, zl], nolims & everymask)
3115                 hi_caps_xyz = _apply_mask([xh, yh, zh], nolims & everymask)
3116 
3117                 # setting '_' for z-caps and '|' for x- and y-caps;
3118                 # these markers will rotate as the viewing angle changes
3119                 cap_lo = art3d.Line3D(*lo_caps_xyz, ls='',
3120                                       marker=capmarker[i_zdir],
3121                                       **eb_cap_style)
3122                 cap_hi = art3d.Line3D(*hi_caps_xyz, ls='',
3123                                       marker=capmarker[i_zdir],
3124                                       **eb_cap_style)
3125                 self.add_line(cap_lo)
3126                 self.add_line(cap_hi)
3127                 caplines.append(cap_lo)
3128                 caplines.append(cap_hi)
3129 
3130             if lolims.any():
3131                 xh0, yh0, zh0 = _apply_mask([xh, yh, zh], lolims & everymask)
3132                 self.quiver(xh0, yh0, zh0, *dir_vector, **eb_quiver_style)
3133             if uplims.any():
3134                 xl0, yl0, zl0 = _apply_mask([xl, yl, zl], uplims & everymask)
3135                 self.quiver(xl0, yl0, zl0, *-dir_vector, **eb_quiver_style)
3136 
3137             errline = art3d.Line3DCollection(np.array(coorderr).T,
3138                                              **eb_lines_style)
3139             self.add_collection(errline)
3140             errlines.append(errline)
3141             coorderrs.append(coorderr)
3142 
3143         coorderrs = np.array(coorderrs)
3144 
3145         def _digout_minmax(err_arr, coord_label):
3146             return (np.nanmin(err_arr[:, i_xyz[coord_label], :, :]),
3147                     np.nanmax(err_arr[:, i_xyz[coord_label], :, :]))
3148 
3149         minx, maxx = _digout_minmax(coorderrs, 'x')
3150         miny, maxy = _digout_minmax(coorderrs, 'y')
3151         minz, maxz = _digout_minmax(coorderrs, 'z')
3152         self.auto_scale_xyz((minx, maxx), (miny, maxy), (minz, maxz), had_data)
3153 
3154         # Adapting errorbar containers for 3d case, assuming z-axis points "up"
3155         errorbar_container = mcontainer.ErrorbarContainer(
3156             (data_line, tuple(caplines), tuple(errlines)),
3157             has_xerr=(xerr is not None or yerr is not None),
3158             has_yerr=(zerr is not None),
3159             label=label)
3160         self.containers.append(errorbar_container)
3161 
3162         return errlines, caplines, limmarks
3163 
3164     @_api.make_keyword_only("3.8", "call_axes_locator")
3165     def get_tightbbox(self, renderer=None, call_axes_locator=True,
3166                       bbox_extra_artists=None, *, for_layout_only=False):
3167         ret = super().get_tightbbox(renderer,
3168                                     call_axes_locator=call_axes_locator,
3169                                     bbox_extra_artists=bbox_extra_artists,
3170                                     for_layout_only=for_layout_only)
3171         batch = [ret]
3172         if self._axis3don:
3173             for axis in self._axis_map.values():
3174                 if axis.get_visible():
3175                     axis_bb = martist._get_tightbbox_for_layout_only(
3176                         axis, renderer)
3177                     if axis_bb:
3178                         batch.append(axis_bb)
3179         return mtransforms.Bbox.union(batch)
3180 
3181     @_preprocess_data()
3182     def stem(self, x, y, z, *, linefmt='C0-', markerfmt='C0o', basefmt='C3-',
3183              bottom=0, label=None, orientation='z'):
3184         """
3185         Create a 3D stem plot.
3186 
3187         A stem plot draws lines perpendicular to a baseline, and places markers
3188         at the heads. By default, the baseline is defined by *x* and *y*, and
3189         stems are drawn vertically from *bottom* to *z*.
3190 
3191         Parameters
3192         ----------
3193         x, y, z : array-like
3194             The positions of the heads of the stems. The stems are drawn along
3195             the *orientation*-direction from the baseline at *bottom* (in the
3196             *orientation*-coordinate) to the heads. By default, the *x* and *y*
3197             positions are used for the baseline and *z* for the head position,
3198             but this can be changed by *orientation*.
3199 
3200         linefmt : str, default: 'C0-'
3201             A string defining the properties of the vertical lines. Usually,
3202             this will be a color or a color and a linestyle:
3203 
3204             =========  =============
3205             Character  Line Style
3206             =========  =============
3207             ``'-'``    solid line
3208             ``'--'``   dashed line
3209             ``'-.'``   dash-dot line
3210             ``':'``    dotted line
3211             =========  =============
3212 
3213             Note: While it is technically possible to specify valid formats
3214             other than color or color and linestyle (e.g. 'rx' or '-.'), this
3215             is beyond the intention of the method and will most likely not
3216             result in a reasonable plot.
3217 
3218         markerfmt : str, default: 'C0o'
3219             A string defining the properties of the markers at the stem heads.
3220 
3221         basefmt : str, default: 'C3-'
3222             A format string defining the properties of the baseline.
3223 
3224         bottom : float, default: 0
3225             The position of the baseline, in *orientation*-coordinates.
3226 
3227         label : str, default: None
3228             The label to use for the stems in legends.
3229 
3230         orientation : {'x', 'y', 'z'}, default: 'z'
3231             The direction along which stems are drawn.
3232 
3233         data : indexable object, optional
3234             DATA_PARAMETER_PLACEHOLDER
3235 
3236         Returns
3237         -------
3238         `.StemContainer`
3239             The container may be treated like a tuple
3240             (*markerline*, *stemlines*, *baseline*)
3241 
3242         Examples
3243         --------
3244         .. plot:: gallery/mplot3d/stem3d_demo.py
3245         """
3246 
3247         from matplotlib.container import StemContainer
3248 
3249         had_data = self.has_data()
3250 
3251         _api.check_in_list(['x', 'y', 'z'], orientation=orientation)
3252 
3253         xlim = (np.min(x), np.max(x))
3254         ylim = (np.min(y), np.max(y))
3255         zlim = (np.min(z), np.max(z))
3256 
3257         # Determine the appropriate plane for the baseline and the direction of
3258         # stemlines based on the value of orientation.
3259         if orientation == 'x':
3260             basex, basexlim = y, ylim
3261             basey, baseylim = z, zlim
3262             lines = [[(bottom, thisy, thisz), (thisx, thisy, thisz)]
3263                      for thisx, thisy, thisz in zip(x, y, z)]
3264         elif orientation == 'y':
3265             basex, basexlim = x, xlim
3266             basey, baseylim = z, zlim
3267             lines = [[(thisx, bottom, thisz), (thisx, thisy, thisz)]
3268                      for thisx, thisy, thisz in zip(x, y, z)]
3269         else:
3270             basex, basexlim = x, xlim
3271             basey, baseylim = y, ylim
3272             lines = [[(thisx, thisy, bottom), (thisx, thisy, thisz)]
3273                      for thisx, thisy, thisz in zip(x, y, z)]
3274 
3275         # Determine style for stem lines.
3276         linestyle, linemarker, linecolor = _process_plot_format(linefmt)
3277         if linestyle is None:
3278             linestyle = mpl.rcParams['lines.linestyle']
3279 
3280         # Plot everything in required order.
3281         baseline, = self.plot(basex, basey, basefmt, zs=bottom,
3282                               zdir=orientation, label='_nolegend_')
3283         stemlines = art3d.Line3DCollection(
3284             lines, linestyles=linestyle, colors=linecolor, label='_nolegend_')
3285         self.add_collection(stemlines)
3286         markerline, = self.plot(x, y, z, markerfmt, label='_nolegend_')
3287 
3288         stem_container = StemContainer((markerline, stemlines, baseline),
3289                                        label=label)
3290         self.add_container(stem_container)
3291 
3292         jx, jy, jz = art3d.juggle_axes(basexlim, baseylim, [bottom, bottom],
3293                                        orientation)
3294         self.auto_scale_xyz([*jx, *xlim], [*jy, *ylim], [*jz, *zlim], had_data)
3295 
3296         return stem_container
3297 
3298     stem3D = stem

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>]
2025-10-18 14:27:39.138 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-18 14:27:39.138 | INFO     | Search-only: skipping patch selection
2025-10-18 14:27:39.269 | INFO     | Task matplotlib__matplotlib-25746 completed successfully.
2025-10-18 14:27:39.270 | INFO     | No patch generated. You can try running ACR again.
