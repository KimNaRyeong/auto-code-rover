[
    {
        "rel_file_path": "lib/matplotlib/axes/_base.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/matplotlib__matplotlib/setup_matplotlib__matplotlib__3.7/lib/matplotlib/axes/_base.py",
        "start": 3307,
        "end": 3385,
        "class_name": "_AxesBase",
        "method_name": "tick_params",
        "code": "3307     def tick_params(self, axis='both', **kwargs):\n3308         \"\"\"\n3309         Change the appearance of ticks, tick labels, and gridlines.\n3310 \n3311         Tick properties that are not explicitly set using the keyword\n3312         arguments remain unchanged unless *reset* is True. For the current\n3313         style settings, see `.Axis.get_tick_params`.\n3314 \n3315         Parameters\n3316         ----------\n3317         axis : {'x', 'y', 'both'}, default: 'both'\n3318             The axis to which the parameters are applied.\n3319         which : {'major', 'minor', 'both'}, default: 'major'\n3320             The group of ticks to which the parameters are applied.\n3321         reset : bool, default: False\n3322             Whether to reset the ticks to defaults before updating them.\n3323 \n3324         Other Parameters\n3325         ----------------\n3326         direction : {'in', 'out', 'inout'}\n3327             Puts ticks inside the Axes, outside the Axes, or both.\n3328         length : float\n3329             Tick length in points.\n3330         width : float\n3331             Tick width in points.\n3332         color : color\n3333             Tick color.\n3334         pad : float\n3335             Distance in points between tick and label.\n3336         labelsize : float or str\n3337             Tick label font size in points or as a string (e.g., 'large').\n3338         labelcolor : color\n3339             Tick label color.\n3340         colors : color\n3341             Tick color and label color.\n3342         zorder : float\n3343             Tick and label zorder.\n3344         bottom, top, left, right : bool\n3345             Whether to draw the respective ticks.\n3346         labelbottom, labeltop, labelleft, labelright : bool\n3347             Whether to draw the respective tick labels.\n3348         labelrotation : float\n3349             Tick label rotation\n3350         grid_color : color\n3351             Gridline color.\n3352         grid_alpha : float\n3353             Transparency of gridlines: 0 (transparent) to 1 (opaque).\n3354         grid_linewidth : float\n3355             Width of gridlines in points.\n3356         grid_linestyle : str\n3357             Any valid `.Line2D` line style spec.\n3358 \n3359         Examples\n3360         --------\n3361         ::\n3362 \n3363             ax.tick_params(direction='out', length=6, width=2, colors='r',\n3364                            grid_color='r', grid_alpha=0.5)\n3365 \n3366         This will make all major ticks be red, pointing out of the box,\n3367         and with dimensions 6 points by 2 points.  Tick labels will\n3368         also be red.  Gridlines will be red and translucent.\n3369 \n3370         \"\"\"\n3371         _api.check_in_list(['x', 'y', 'both'], axis=axis)\n3372         if axis in ['x', 'both']:\n3373             xkw = dict(kwargs)\n3374             xkw.pop('left', None)\n3375             xkw.pop('right', None)\n3376             xkw.pop('labelleft', None)\n3377             xkw.pop('labelright', None)\n3378             self.xaxis.set_tick_params(**xkw)\n3379         if axis in ['y', 'both']:\n3380             ykw = dict(kwargs)\n3381             ykw.pop('top', None)\n3382             ykw.pop('bottom', None)\n3383             ykw.pop('labeltop', None)\n3384             ykw.pop('labelbottom', None)\n3385             self.yaxis.set_tick_params(**ykw)\n",
        "intended_behavior": "Modify the `tick_params` method to include a `fontfamily` keyword argument. This argument should allow the user to specify the font family for the tick labels. When processing the `**kwargs` within `tick_params`, the method should apply the specified `fontfamily` to both the x-axis and y-axis tick labels, ensuring that if `fontfamily` is specified, it is respected and applied correctly to the ticks as specified by the `axis` argument. This enhancement must ensure backward compatibility, thus, if `fontfamily` is not specified, the default behavior (using the plot's or the system's default font family) remains unchanged."
    },
    {
        "rel_file_path": "lib/matplotlib/axes/_base.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/matplotlib__matplotlib/setup_matplotlib__matplotlib__3.7/lib/matplotlib/axes/_base.py",
        "start": 548,
        "end": 4538,
        "class_name": "_AxesBase",
        "method_name": null,
        "code": "548 class _AxesBase(martist.Artist):\n549     name = \"rectilinear\"\n550 \n551     # axis names are the prefixes for the attributes that contain the\n552     # respective axis; e.g. 'x' <-> self.xaxis, containing an XAxis.\n553     # Note that PolarAxes uses these attributes as well, so that we have\n554     # 'x' <-> self.xaxis, containing a ThetaAxis. In particular we do not\n555     # have 'theta' in _axis_names.\n556     # In practice, this is ('x', 'y') for all 2D Axes and ('x', 'y', 'z')\n557     # for Axes3D.\n558     _axis_names = (\"x\", \"y\")\n559     _shared_axes = {name: cbook.Grouper() for name in _axis_names}\n560     _twinned_axes = cbook.Grouper()\n561 \n562     _subclass_uses_cla = False\n563 \n564     @property\n565     def _axis_map(self):\n566         \"\"\"A mapping of axis names, e.g. 'x', to `Axis` instances.\"\"\"\n567         return {name: getattr(self, f\"{name}axis\")\n568                 for name in self._axis_names}\n569 \n570     def __str__(self):\n571         return \"{0}({1[0]:g},{1[1]:g};{1[2]:g}x{1[3]:g})\".format(\n572             type(self).__name__, self._position.bounds)\n573 \n574     def __init__(self, fig,\n575                  *args,\n576                  facecolor=None,  # defaults to rc axes.facecolor\n577                  frameon=True,\n578                  sharex=None,  # use Axes instance's xaxis info\n579                  sharey=None,  # use Axes instance's yaxis info\n580                  label='',\n581                  xscale=None,\n582                  yscale=None,\n583                  box_aspect=None,\n584                  **kwargs\n585                  ):\n586         \"\"\"\n587         Build an Axes in a figure.\n588 \n589         Parameters\n590         ----------\n591         fig : `~matplotlib.figure.Figure`\n592             The Axes is built in the `.Figure` *fig*.\n593 \n594         *args\n595             ``*args`` can be a single ``(left, bottom, width, height)``\n596             rectangle or a single `.Bbox`.  This specifies the rectangle (in\n597             figure coordinates) where the Axes is positioned.\n598 \n599             ``*args`` can also consist of three numbers or a single three-digit\n600             number; in the latter case, the digits are considered as\n601             independent numbers.  The numbers are interpreted as ``(nrows,\n602             ncols, index)``: ``(nrows, ncols)`` specifies the size of an array\n603             of subplots, and ``index`` is the 1-based index of the subplot\n604             being created.  Finally, ``*args`` can also directly be a\n605             `.SubplotSpec` instance.\n606 \n607         sharex, sharey : `~.axes.Axes`, optional\n608             The x- or y-`~.matplotlib.axis` is shared with the x- or y-axis in\n609             the input `~.axes.Axes`.\n610 \n611         frameon : bool, default: True\n612             Whether the Axes frame is visible.\n613 \n614         box_aspect : float, optional\n615             Set a fixed aspect for the Axes box, i.e. the ratio of height to\n616             width. See `~.axes.Axes.set_box_aspect` for details.\n617 \n618         **kwargs\n619             Other optional keyword arguments:\n620 \n621             %(Axes:kwdoc)s\n622 \n623         Returns\n624         -------\n625         `~.axes.Axes`\n626             The new `~.axes.Axes` object.\n627         \"\"\"\n628 \n629         super().__init__()\n630         if \"rect\" in kwargs:\n631             if args:\n632                 raise TypeError(\n633                     \"'rect' cannot be used together with positional arguments\")\n634             rect = kwargs.pop(\"rect\")\n635             _api.check_isinstance((mtransforms.Bbox, Iterable), rect=rect)\n636             args = (rect,)\n637         subplotspec = None\n638         if len(args) == 1 and isinstance(args[0], mtransforms.Bbox):\n639             self._position = args[0]\n640         elif len(args) == 1 and np.iterable(args[0]):\n641             self._position = mtransforms.Bbox.from_bounds(*args[0])\n642         else:\n643             self._position = self._originalPosition = mtransforms.Bbox.unit()\n644             subplotspec = SubplotSpec._from_subplot_args(fig, args)\n645         if self._position.width < 0 or self._position.height < 0:\n646             raise ValueError('Width and height specified must be non-negative')\n647         self._originalPosition = self._position.frozen()\n648         self.axes = self\n649         self._aspect = 'auto'\n650         self._adjustable = 'box'\n651         self._anchor = 'C'\n652         self._stale_viewlims = {name: False for name in self._axis_names}\n653         self._sharex = sharex\n654         self._sharey = sharey\n655         self.set_label(label)\n656         self.set_figure(fig)\n657         # The subplotspec needs to be set after the figure (so that\n658         # figure-level subplotpars are taken into account), but the figure\n659         # needs to be set after self._position is initialized.\n660         if subplotspec:\n661             self.set_subplotspec(subplotspec)\n662         else:\n663             self._subplotspec = None\n664         self.set_box_aspect(box_aspect)\n665         self._axes_locator = None  # Optionally set via update(kwargs).\n666 \n667         self._children = []\n668 \n669         # placeholder for any colorbars added that use this Axes.\n670         # (see colorbar.py):\n671         self._colorbars = []\n672         self.spines = mspines.Spines.from_dict(self._gen_axes_spines())\n673 \n674         # this call may differ for non-sep axes, e.g., polar\n675         self._init_axis()\n676         if facecolor is None:\n677             facecolor = mpl.rcParams['axes.facecolor']\n678         self._facecolor = facecolor\n679         self._frameon = frameon\n680         self.set_axisbelow(mpl.rcParams['axes.axisbelow'])\n681 \n682         self._rasterization_zorder = None\n683         self.clear()\n684 \n685         # funcs used to format x and y - fall back on major formatters\n686         self.fmt_xdata = None\n687         self.fmt_ydata = None\n688 \n689         self.set_navigate(True)\n690         self.set_navigate_mode(None)\n691 \n692         if xscale:\n693             self.set_xscale(xscale)\n694         if yscale:\n695             self.set_yscale(yscale)\n696 \n697         self._internal_update(kwargs)\n698 \n699         for name, axis in self._axis_map.items():\n700             axis.callbacks._connect_picklable(\n701                 'units', self._unit_change_handler(name))\n702 \n703         rcParams = mpl.rcParams\n704         self.tick_params(\n705             top=rcParams['xtick.top'] and rcParams['xtick.minor.top'],\n706             bottom=rcParams['xtick.bottom'] and rcParams['xtick.minor.bottom'],\n707             labeltop=(rcParams['xtick.labeltop'] and\n708                       rcParams['xtick.minor.top']),\n709             labelbottom=(rcParams['xtick.labelbottom'] and\n710                          rcParams['xtick.minor.bottom']),\n711             left=rcParams['ytick.left'] and rcParams['ytick.minor.left'],\n712             right=rcParams['ytick.right'] and rcParams['ytick.minor.right'],\n713             labelleft=(rcParams['ytick.labelleft'] and\n714                        rcParams['ytick.minor.left']),\n715             labelright=(rcParams['ytick.labelright'] and\n716                         rcParams['ytick.minor.right']),\n717             which='minor')\n718 \n719         self.tick_params(\n720             top=rcParams['xtick.top'] and rcParams['xtick.major.top'],\n721             bottom=rcParams['xtick.bottom'] and rcParams['xtick.major.bottom'],\n722             labeltop=(rcParams['xtick.labeltop'] and\n723                       rcParams['xtick.major.top']),\n724             labelbottom=(rcParams['xtick.labelbottom'] and\n725                          rcParams['xtick.major.bottom']),\n726             left=rcParams['ytick.left'] and rcParams['ytick.major.left'],\n727             right=rcParams['ytick.right'] and rcParams['ytick.major.right'],\n728             labelleft=(rcParams['ytick.labelleft'] and\n729                        rcParams['ytick.major.left']),\n730             labelright=(rcParams['ytick.labelright'] and\n731                         rcParams['ytick.major.right']),\n732             which='major')\n733 \n734     def __init_subclass__(cls, **kwargs):\n735         parent_uses_cla = super(cls, cls)._subclass_uses_cla\n736         if 'cla' in cls.__dict__:\n737             _api.warn_deprecated(\n738                 '3.6',\n739                 pending=True,\n740                 message=f'Overriding `Axes.cla` in {cls.__qualname__} is '\n741                 'pending deprecation in %(since)s and will be fully '\n742                 'deprecated in favor of `Axes.clear` in the future. '\n743                 'Please report '\n744                 f'this to the {cls.__module__!r} author.')\n745         cls._subclass_uses_cla = 'cla' in cls.__dict__ or parent_uses_cla\n746         super().__init_subclass__(**kwargs)\n747 \n748     def __getstate__(self):\n749         state = super().__getstate__()\n750         # Prune the sharing & twinning info to only contain the current group.\n751         state[\"_shared_axes\"] = {\n752             name: self._shared_axes[name].get_siblings(self)\n753             for name in self._axis_names if self in self._shared_axes[name]}\n754         state[\"_twinned_axes\"] = (self._twinned_axes.get_siblings(self)\n755                                   if self in self._twinned_axes else None)\n756         return state\n757 \n758     def __setstate__(self, state):\n759         # Merge the grouping info back into the global groupers.\n760         shared_axes = state.pop(\"_shared_axes\")\n761         for name, shared_siblings in shared_axes.items():\n762             self._shared_axes[name].join(*shared_siblings)\n763         twinned_siblings = state.pop(\"_twinned_axes\")\n764         if twinned_siblings:\n765             self._twinned_axes.join(*twinned_siblings)\n766         self.__dict__ = state\n767         self._stale = True\n768 \n769     def __repr__(self):\n770         fields = []\n771         if self.get_label():\n772             fields += [f\"label={self.get_label()!r}\"]\n773         if hasattr(self, \"get_title\"):\n774             titles = {}\n775             for k in [\"left\", \"center\", \"right\"]:\n776                 title = self.get_title(loc=k)\n777                 if title:\n778                     titles[k] = title\n779             if titles:\n780                 fields += [f\"title={titles}\"]\n781         for name, axis in self._axis_map.items():\n782             if axis.get_label() and axis.get_label().get_text():\n783                 fields += [f\"{name}label={axis.get_label().get_text()!r}\"]\n784         return f\"<{self.__class__.__name__}: \" + \", \".join(fields) + \">\"\n785 \n786     def get_subplotspec(self):\n787         \"\"\"Return the `.SubplotSpec` associated with the subplot, or None.\"\"\"\n788         return self._subplotspec\n789 \n790     def set_subplotspec(self, subplotspec):\n791         \"\"\"Set the `.SubplotSpec`. associated with the subplot.\"\"\"\n792         self._subplotspec = subplotspec\n793         self._set_position(subplotspec.get_position(self.figure))\n794 \n795     def get_gridspec(self):\n796         \"\"\"Return the `.GridSpec` associated with the subplot, or None.\"\"\"\n797         return self._subplotspec.get_gridspec() if self._subplotspec else None\n798 \n799     def get_window_extent(self, renderer=None):\n800         \"\"\"\n801         Return the Axes bounding box in display space.\n802 \n803         This bounding box does not include the spines, ticks, ticklabels,\n804         or other labels.  For a bounding box including these elements use\n805         `~matplotlib.axes.Axes.get_tightbbox`.\n806 \n807         See Also\n808         --------\n809         matplotlib.axes.Axes.get_tightbbox\n810         matplotlib.axis.Axis.get_tightbbox\n811         matplotlib.spines.Spine.get_window_extent\n812         \"\"\"\n813         return self.bbox\n814 \n815     def _init_axis(self):\n816         # This is moved out of __init__ because non-separable axes don't use it\n817         self.xaxis = maxis.XAxis(self)\n818         self.spines.bottom.register_axis(self.xaxis)\n819         self.spines.top.register_axis(self.xaxis)\n820         self.yaxis = maxis.YAxis(self)\n821         self.spines.left.register_axis(self.yaxis)\n822         self.spines.right.register_axis(self.yaxis)\n823 \n824     def set_figure(self, fig):\n825         # docstring inherited\n826         super().set_figure(fig)\n827 \n828         self.bbox = mtransforms.TransformedBbox(self._position,\n829                                                 fig.transSubfigure)\n830         # these will be updated later as data is added\n831         self.dataLim = mtransforms.Bbox.null()\n832         self._viewLim = mtransforms.Bbox.unit()\n833         self.transScale = mtransforms.TransformWrapper(\n834             mtransforms.IdentityTransform())\n835 \n836         self._set_lim_and_transforms()\n837 \n838     def _unstale_viewLim(self):\n839         # We should arrange to store this information once per share-group\n840         # instead of on every axis.\n841         need_scale = {\n842             name: any(ax._stale_viewlims[name]\n843                       for ax in self._shared_axes[name].get_siblings(self))\n844             for name in self._axis_names}\n845         if any(need_scale.values()):\n846             for name in need_scale:\n847                 for ax in self._shared_axes[name].get_siblings(self):\n848                     ax._stale_viewlims[name] = False\n849             self.autoscale_view(**{f\"scale{name}\": scale\n850                                    for name, scale in need_scale.items()})\n851 \n852     @property\n853     def viewLim(self):\n854         self._unstale_viewLim()\n855         return self._viewLim\n856 \n857     def _request_autoscale_view(self, axis=\"all\", tight=None):\n858         \"\"\"\n859         Mark a single axis, or all of them, as stale wrt. autoscaling.\n860 \n861         No computation is performed until the next autoscaling; thus, separate\n862         calls to control individual axises incur negligible performance cost.\n863 \n864         Parameters\n865         ----------\n866         axis : str, default: \"all\"\n867             Either an element of ``self._axis_names``, or \"all\".\n868         tight : bool or None, default: None\n869         \"\"\"\n870         axis_names = _api.check_getitem(\n871             {**{k: [k] for k in self._axis_names}, \"all\": self._axis_names},\n872             axis=axis)\n873         for name in axis_names:\n874             self._stale_viewlims[name] = True\n875         if tight is not None:\n876             self._tight = tight\n877 \n878     def _set_lim_and_transforms(self):\n879         \"\"\"\n880         Set the *_xaxis_transform*, *_yaxis_transform*, *transScale*,\n881         *transData*, *transLimits* and *transAxes* transformations.\n882 \n883         .. note::\n884 \n885             This method is primarily used by rectilinear projections of the\n886             `~matplotlib.axes.Axes` class, and is meant to be overridden by\n887             new kinds of projection Axes that need different transformations\n888             and limits. (See `~matplotlib.projections.polar.PolarAxes` for an\n889             example.)\n890         \"\"\"\n891         self.transAxes = mtransforms.BboxTransformTo(self.bbox)\n892 \n893         # Transforms the x and y axis separately by a scale factor.\n894         # It is assumed that this part will have non-linear components\n895         # (e.g., for a log scale).\n896         self.transScale = mtransforms.TransformWrapper(\n897             mtransforms.IdentityTransform())\n898 \n899         # An affine transformation on the data, generally to limit the\n900         # range of the axes\n901         self.transLimits = mtransforms.BboxTransformFrom(\n902             mtransforms.TransformedBbox(self._viewLim, self.transScale))\n903 \n904         # The parentheses are important for efficiency here -- they\n905         # group the last two (which are usually affines) separately\n906         # from the first (which, with log-scaling can be non-affine).\n907         self.transData = self.transScale + (self.transLimits + self.transAxes)\n908 \n909         self._xaxis_transform = mtransforms.blended_transform_factory(\n910             self.transData, self.transAxes)\n911         self._yaxis_transform = mtransforms.blended_transform_factory(\n912             self.transAxes, self.transData)\n913 \n914     def get_xaxis_transform(self, which='grid'):\n915         \"\"\"\n916         Get the transformation used for drawing x-axis labels, ticks\n917         and gridlines.  The x-direction is in data coordinates and the\n918         y-direction is in axis coordinates.\n919 \n920         .. note::\n921 \n922             This transformation is primarily used by the\n923             `~matplotlib.axis.Axis` class, and is meant to be\n924             overridden by new kinds of projections that may need to\n925             place axis elements in different locations.\n926 \n927         Parameters\n928         ----------\n929         which : {'grid', 'tick1', 'tick2'}\n930         \"\"\"\n931         if which == 'grid':\n932             return self._xaxis_transform\n933         elif which == 'tick1':\n934             # for cartesian projection, this is bottom spine\n935             return self.spines.bottom.get_spine_transform()\n936         elif which == 'tick2':\n937             # for cartesian projection, this is top spine\n938             return self.spines.top.get_spine_transform()\n939         else:\n940             raise ValueError(f'unknown value for which: {which!r}')\n941 \n942     def get_xaxis_text1_transform(self, pad_points):\n943         \"\"\"\n944         Returns\n945         -------\n946         transform : Transform\n947             The transform used for drawing x-axis labels, which will add\n948             *pad_points* of padding (in points) between the axis and the label.\n949             The x-direction is in data coordinates and the y-direction is in\n950             axis coordinates\n951         valign : {'center', 'top', 'bottom', 'baseline', 'center_baseline'}\n952             The text vertical alignment.\n953         halign : {'center', 'left', 'right'}\n954             The text horizontal alignment.\n955 \n956         Notes\n957         -----\n958         This transformation is primarily used by the `~matplotlib.axis.Axis`\n959         class, and is meant to be overridden by new kinds of projections that\n960         may need to place axis elements in different locations.\n961         \"\"\"\n962         labels_align = mpl.rcParams[\"xtick.alignment\"]\n963         return (self.get_xaxis_transform(which='tick1') +\n964                 mtransforms.ScaledTranslation(0, -1 * pad_points / 72,\n965                                               self.figure.dpi_scale_trans),\n966                 \"top\", labels_align)\n967 \n968     def get_xaxis_text2_transform(self, pad_points):\n969         \"\"\"\n970         Returns\n971         -------\n972         transform : Transform\n973             The transform used for drawing secondary x-axis labels, which will\n974             add *pad_points* of padding (in points) between the axis and the\n975             label.  The x-direction is in data coordinates and the y-direction\n976             is in axis coordinates\n977         valign : {'center', 'top', 'bottom', 'baseline', 'center_baseline'}\n978             The text vertical alignment.\n979         halign : {'center', 'left', 'right'}\n980             The text horizontal alignment.\n981 \n982         Notes\n983         -----\n984         This transformation is primarily used by the `~matplotlib.axis.Axis`\n985         class, and is meant to be overridden by new kinds of projections that\n986         may need to place axis elements in different locations.\n987         \"\"\"\n988         labels_align = mpl.rcParams[\"xtick.alignment\"]\n989         return (self.get_xaxis_transform(which='tick2') +\n990                 mtransforms.ScaledTranslation(0, pad_points / 72,\n991                                               self.figure.dpi_scale_trans),\n992                 \"bottom\", labels_align)\n993 \n994     def get_yaxis_transform(self, which='grid'):\n995         \"\"\"\n996         Get the transformation used for drawing y-axis labels, ticks\n997         and gridlines.  The x-direction is in axis coordinates and the\n998         y-direction is in data coordinates.\n999 \n1000         .. note::\n1001 \n1002             This transformation is primarily used by the\n1003             `~matplotlib.axis.Axis` class, and is meant to be\n1004             overridden by new kinds of projections that may need to\n1005             place axis elements in different locations.\n1006 \n1007         Parameters\n1008         ----------\n1009         which : {'grid', 'tick1', 'tick2'}\n1010         \"\"\"\n1011         if which == 'grid':\n1012             return self._yaxis_transform\n1013         elif which == 'tick1':\n1014             # for cartesian projection, this is bottom spine\n1015             return self.spines.left.get_spine_transform()\n1016         elif which == 'tick2':\n1017             # for cartesian projection, this is top spine\n1018             return self.spines.right.get_spine_transform()\n1019         else:\n1020             raise ValueError(f'unknown value for which: {which!r}')\n1021 \n1022     def get_yaxis_text1_transform(self, pad_points):\n1023         \"\"\"\n1024         Returns\n1025         -------\n1026         transform : Transform\n1027             The transform used for drawing y-axis labels, which will add\n1028             *pad_points* of padding (in points) between the axis and the label.\n1029             The x-direction is in axis coordinates and the y-direction is in\n1030             data coordinates\n1031         valign : {'center', 'top', 'bottom', 'baseline', 'center_baseline'}\n1032             The text vertical alignment.\n1033         halign : {'center', 'left', 'right'}\n1034             The text horizontal alignment.\n1035 \n1036         Notes\n1037         -----\n1038         This transformation is primarily used by the `~matplotlib.axis.Axis`\n1039         class, and is meant to be overridden by new kinds of projections that\n1040         may need to place axis elements in different locations.\n1041         \"\"\"\n1042         labels_align = mpl.rcParams[\"ytick.alignment\"]\n1043         return (self.get_yaxis_transform(which='tick1') +\n1044                 mtransforms.ScaledTranslation(-1 * pad_points / 72, 0,\n1045                                               self.figure.dpi_scale_trans),\n1046                 labels_align, \"right\")\n1047 \n1048     def get_yaxis_text2_transform(self, pad_points):\n1049         \"\"\"\n1050         Returns\n1051         -------\n1052         transform : Transform\n1053             The transform used for drawing secondart y-axis labels, which will\n1054             add *pad_points* of padding (in points) between the axis and the\n1055             label.  The x-direction is in axis coordinates and the y-direction\n1056             is in data coordinates\n1057         valign : {'center', 'top', 'bottom', 'baseline', 'center_baseline'}\n1058             The text vertical alignment.\n1059         halign : {'center', 'left', 'right'}\n1060             The text horizontal alignment.\n1061 \n1062         Notes\n1063         -----\n1064         This transformation is primarily used by the `~matplotlib.axis.Axis`\n1065         class, and is meant to be overridden by new kinds of projections that\n1066         may need to place axis elements in different locations.\n1067         \"\"\"\n1068         labels_align = mpl.rcParams[\"ytick.alignment\"]\n1069         return (self.get_yaxis_transform(which='tick2') +\n1070                 mtransforms.ScaledTranslation(pad_points / 72, 0,\n1071                                               self.figure.dpi_scale_trans),\n1072                 labels_align, \"left\")\n1073 \n1074     def _update_transScale(self):\n1075         self.transScale.set(\n1076             mtransforms.blended_transform_factory(\n1077                 self.xaxis.get_transform(), self.yaxis.get_transform()))\n1078 \n1079     def get_position(self, original=False):\n1080         \"\"\"\n1081         Return the position of the Axes within the figure as a `.Bbox`.\n1082 \n1083         Parameters\n1084         ----------\n1085         original : bool\n1086             If ``True``, return the original position. Otherwise, return the\n1087             active position. For an explanation of the positions see\n1088             `.set_position`.\n1089 \n1090         Returns\n1091         -------\n1092         `.Bbox`\n1093 \n1094         \"\"\"\n1095         if original:\n1096             return self._originalPosition.frozen()\n1097         else:\n1098             locator = self.get_axes_locator()\n1099             if not locator:\n1100                 self.apply_aspect()\n1101             return self._position.frozen()\n1102 \n1103     def set_position(self, pos, which='both'):\n1104         \"\"\"\n1105         Set the Axes position.\n1106 \n1107         Axes have two position attributes. The 'original' position is the\n1108         position allocated for the Axes. The 'active' position is the\n1109         position the Axes is actually drawn at. These positions are usually\n1110         the same unless a fixed aspect is set to the Axes. See\n1111         `.Axes.set_aspect` for details.\n1112 \n1113         Parameters\n1114         ----------\n1115         pos : [left, bottom, width, height] or `~matplotlib.transforms.Bbox`\n1116             The new position of the Axes in `.Figure` coordinates.\n1117 \n1118         which : {'both', 'active', 'original'}, default: 'both'\n1119             Determines which position variables to change.\n1120 \n1121         See Also\n1122         --------\n1123         matplotlib.transforms.Bbox.from_bounds\n1124         matplotlib.transforms.Bbox.from_extents\n1125         \"\"\"\n1126         self._set_position(pos, which=which)\n1127         # because this is being called externally to the library we\n1128         # don't let it be in the layout.\n1129         self.set_in_layout(False)\n1130 \n1131     def _set_position(self, pos, which='both'):\n1132         \"\"\"\n1133         Private version of set_position.\n1134 \n1135         Call this internally to get the same functionality of `set_position`,\n1136         but not to take the axis out of the constrained_layout hierarchy.\n1137         \"\"\"\n1138         if not isinstance(pos, mtransforms.BboxBase):\n1139             pos = mtransforms.Bbox.from_bounds(*pos)\n1140         for ax in self._twinned_axes.get_siblings(self):\n1141             if which in ('both', 'active'):\n1142                 ax._position.set(pos)\n1143             if which in ('both', 'original'):\n1144                 ax._originalPosition.set(pos)\n1145         self.stale = True\n1146 \n1147     def reset_position(self):\n1148         \"\"\"\n1149         Reset the active position to the original position.\n1150 \n1151         This undoes changes to the active position (as defined in\n1152         `.set_position`) which may have been performed to satisfy fixed-aspect\n1153         constraints.\n1154         \"\"\"\n1155         for ax in self._twinned_axes.get_siblings(self):\n1156             pos = ax.get_position(original=True)\n1157             ax.set_position(pos, which='active')\n1158 \n1159     def set_axes_locator(self, locator):\n1160         \"\"\"\n1161         Set the Axes locator.\n1162 \n1163         Parameters\n1164         ----------\n1165         locator : Callable[[Axes, Renderer], Bbox]\n1166         \"\"\"\n1167         self._axes_locator = locator\n1168         self.stale = True\n1169 \n1170     def get_axes_locator(self):\n1171         \"\"\"\n1172         Return the axes_locator.\n1173         \"\"\"\n1174         return self._axes_locator\n1175 \n1176     def _set_artist_props(self, a):\n1177         \"\"\"Set the boilerplate props for artists added to Axes.\"\"\"\n1178         a.set_figure(self.figure)\n1179         if not a.is_transform_set():\n1180             a.set_transform(self.transData)\n1181 \n1182         a.axes = self\n1183         if a.get_mouseover():\n1184             self._mouseover_set.add(a)\n1185 \n1186     def _gen_axes_patch(self):\n1187         \"\"\"\n1188         Returns\n1189         -------\n1190         Patch\n1191             The patch used to draw the background of the Axes.  It is also used\n1192             as the clipping path for any data elements on the Axes.\n1193 \n1194             In the standard Axes, this is a rectangle, but in other projections\n1195             it may not be.\n1196 \n1197         Notes\n1198         -----\n1199         Intended to be overridden by new projection types.\n1200         \"\"\"\n1201         return mpatches.Rectangle((0.0, 0.0), 1.0, 1.0)\n1202 \n1203     def _gen_axes_spines(self, locations=None, offset=0.0, units='inches'):\n1204         \"\"\"\n1205         Returns\n1206         -------\n1207         dict\n1208             Mapping of spine names to `.Line2D` or `.Patch` instances that are\n1209             used to draw Axes spines.\n1210 \n1211             In the standard Axes, spines are single line segments, but in other\n1212             projections they may not be.\n1213 \n1214         Notes\n1215         -----\n1216         Intended to be overridden by new projection types.\n1217         \"\"\"\n1218         return {side: mspines.Spine.linear_spine(self, side)\n1219                 for side in ['left', 'right', 'bottom', 'top']}\n1220 \n1221     def sharex(self, other):\n1222         \"\"\"\n1223         Share the x-axis with *other*.\n1224 \n1225         This is equivalent to passing ``sharex=other`` when constructing the\n1226         Axes, and cannot be used if the x-axis is already being shared with\n1227         another Axes.\n1228         \"\"\"\n1229         _api.check_isinstance(_AxesBase, other=other)\n1230         if self._sharex is not None and other is not self._sharex:\n1231             raise ValueError(\"x-axis is already shared\")\n1232         self._shared_axes[\"x\"].join(self, other)\n1233         self._sharex = other\n1234         self.xaxis.major = other.xaxis.major  # Ticker instances holding\n1235         self.xaxis.minor = other.xaxis.minor  # locator and formatter.\n1236         x0, x1 = other.get_xlim()\n1237         self.set_xlim(x0, x1, emit=False, auto=other.get_autoscalex_on())\n1238         self.xaxis._scale = other.xaxis._scale\n1239 \n1240     def sharey(self, other):\n1241         \"\"\"\n1242         Share the y-axis with *other*.\n1243 \n1244         This is equivalent to passing ``sharey=other`` when constructing the\n1245         Axes, and cannot be used if the y-axis is already being shared with\n1246         another Axes.\n1247         \"\"\"\n1248         _api.check_isinstance(_AxesBase, other=other)\n1249         if self._sharey is not None and other is not self._sharey:\n1250             raise ValueError(\"y-axis is already shared\")\n1251         self._shared_axes[\"y\"].join(self, other)\n1252         self._sharey = other\n1253         self.yaxis.major = other.yaxis.major  # Ticker instances holding\n1254         self.yaxis.minor = other.yaxis.minor  # locator and formatter.\n1255         y0, y1 = other.get_ylim()\n1256         self.set_ylim(y0, y1, emit=False, auto=other.get_autoscaley_on())\n1257         self.yaxis._scale = other.yaxis._scale\n1258 \n1259     def __clear(self):\n1260         \"\"\"Clear the Axes.\"\"\"\n1261         # The actual implementation of clear() as long as clear() has to be\n1262         # an adapter delegating to the correct implementation.\n1263         # The implementation can move back into clear() when the\n1264         # deprecation on cla() subclassing expires.\n1265 \n1266         # stash the current visibility state\n1267         if hasattr(self, 'patch'):\n1268             patch_visible = self.patch.get_visible()\n1269         else:\n1270             patch_visible = True\n1271 \n1272         xaxis_visible = self.xaxis.get_visible()\n1273         yaxis_visible = self.yaxis.get_visible()\n1274 \n1275         for axis in self._axis_map.values():\n1276             axis.clear()  # Also resets the scale to linear.\n1277         for spine in self.spines.values():\n1278             spine.clear()\n1279 \n1280         self.ignore_existing_data_limits = True\n1281         self.callbacks = cbook.CallbackRegistry(\n1282             signals=[\"xlim_changed\", \"ylim_changed\", \"zlim_changed\"])\n1283 \n1284         # update the minor locator for x and y axis based on rcParams\n1285         if mpl.rcParams['xtick.minor.visible']:\n1286             self.xaxis.set_minor_locator(mticker.AutoMinorLocator())\n1287         if mpl.rcParams['ytick.minor.visible']:\n1288             self.yaxis.set_minor_locator(mticker.AutoMinorLocator())\n1289 \n1290         self._xmargin = mpl.rcParams['axes.xmargin']\n1291         self._ymargin = mpl.rcParams['axes.ymargin']\n1292         self._tight = None\n1293         self._use_sticky_edges = True\n1294 \n1295         self._get_lines = _process_plot_var_args(self)\n1296         self._get_patches_for_fill = _process_plot_var_args(self, 'fill')\n1297 \n1298         self._gridOn = mpl.rcParams['axes.grid']\n1299         old_children, self._children = self._children, []\n1300         for chld in old_children:\n1301             chld.axes = chld.figure = None\n1302         self._mouseover_set = _OrderedSet()\n1303         self.child_axes = []\n1304         self._current_image = None  # strictly for pyplot via _sci, _gci\n1305         self._projection_init = None  # strictly for pyplot.subplot\n1306         self.legend_ = None\n1307         self.containers = []\n1308 \n1309         self.grid(False)  # Disable grid on init to use rcParameter\n1310         self.grid(self._gridOn, which=mpl.rcParams['axes.grid.which'],\n1311                   axis=mpl.rcParams['axes.grid.axis'])\n1312         props = font_manager.FontProperties(\n1313             size=mpl.rcParams['axes.titlesize'],\n1314             weight=mpl.rcParams['axes.titleweight'])\n1315 \n1316         y = mpl.rcParams['axes.titley']\n1317         if y is None:\n1318             y = 1.0\n1319             self._autotitlepos = True\n1320         else:\n1321             self._autotitlepos = False\n1322 \n1323         self.title = mtext.Text(\n1324             x=0.5, y=y, text='',\n1325             fontproperties=props,\n1326             verticalalignment='baseline',\n1327             horizontalalignment='center',\n1328             )\n1329         self._left_title = mtext.Text(\n1330             x=0.0, y=y, text='',\n1331             fontproperties=props.copy(),\n1332             verticalalignment='baseline',\n1333             horizontalalignment='left', )\n1334         self._right_title = mtext.Text(\n1335             x=1.0, y=y, text='',\n1336             fontproperties=props.copy(),\n1337             verticalalignment='baseline',\n1338             horizontalalignment='right',\n1339             )\n1340         title_offset_points = mpl.rcParams['axes.titlepad']\n1341         # refactor this out so it can be called in ax.set_title if\n1342         # pad argument used...\n1343         self._set_title_offset_trans(title_offset_points)\n1344 \n1345         for _title in (self.title, self._left_title, self._right_title):\n1346             self._set_artist_props(_title)\n1347 \n1348         # The patch draws the background of the Axes.  We want this to be below\n1349         # the other artists.  We use the frame to draw the edges so we are\n1350         # setting the edgecolor to None.\n1351         self.patch = self._gen_axes_patch()\n1352         self.patch.set_figure(self.figure)\n1353         self.patch.set_facecolor(self._facecolor)\n1354         self.patch.set_edgecolor('none')\n1355         self.patch.set_linewidth(0)\n1356         self.patch.set_transform(self.transAxes)\n1357 \n1358         self.set_axis_on()\n1359 \n1360         self.xaxis.set_clip_path(self.patch)\n1361         self.yaxis.set_clip_path(self.patch)\n1362 \n1363         if self._sharex is not None:\n1364             self.xaxis.set_visible(xaxis_visible)\n1365             self.patch.set_visible(patch_visible)\n1366         if self._sharey is not None:\n1367             self.yaxis.set_visible(yaxis_visible)\n1368             self.patch.set_visible(patch_visible)\n1369 \n1370         # This comes last, as the call to _set_lim may trigger an autoscale (in\n1371         # case of shared axes), requiring children to be already set up.\n1372         for name, axis in self._axis_map.items():\n1373             share = getattr(self, f\"_share{name}\")\n1374             if share is not None:\n1375                 getattr(self, f\"share{name}\")(share)\n1376             else:\n1377                 axis._set_scale(\"linear\")\n1378                 axis._set_lim(0, 1, auto=True)\n1379         self._update_transScale()\n1380 \n1381         self.stale = True\n1382 \n1383     def clear(self):\n1384         \"\"\"Clear the Axes.\"\"\"\n1385         # Act as an alias, or as the superclass implementation depending on the\n1386         # subclass implementation.\n1387         if self._subclass_uses_cla:\n1388             self.cla()\n1389         else:\n1390             self.__clear()\n1391 \n1392     def cla(self):\n1393         \"\"\"Clear the Axes.\"\"\"\n1394         # Act as an alias, or as the superclass implementation depending on the\n1395         # subclass implementation.\n1396         if self._subclass_uses_cla:\n1397             self.__clear()\n1398         else:\n1399             self.clear()\n1400 \n1401     class ArtistList(Sequence):\n1402         \"\"\"\n1403         A sublist of Axes children based on their type.\n1404 \n1405         The type-specific children sublists were made immutable in Matplotlib\n1406         3.7.  In the future these artist lists may be replaced by tuples. Use\n1407         as if this is a tuple already.\n1408         \"\"\"\n1409         def __init__(self, axes, prop_name,\n1410                      valid_types=None, invalid_types=None):\n1411             \"\"\"\n1412             Parameters\n1413             ----------\n1414             axes : `~matplotlib.axes.Axes`\n1415                 The Axes from which this sublist will pull the children\n1416                 Artists.\n1417             prop_name : str\n1418                 The property name used to access this sublist from the Axes;\n1419                 used to generate deprecation warnings.\n1420             valid_types : list of type, optional\n1421                 A list of types that determine which children will be returned\n1422                 by this sublist. If specified, then the Artists in the sublist\n1423                 must be instances of any of these types. If unspecified, then\n1424                 any type of Artist is valid (unless limited by\n1425                 *invalid_types*.)\n1426             invalid_types : tuple, optional\n1427                 A list of types that determine which children will *not* be\n1428                 returned by this sublist. If specified, then Artists in the\n1429                 sublist will never be an instance of these types. Otherwise, no\n1430                 types will be excluded.\n1431             \"\"\"\n1432             self._axes = axes\n1433             self._prop_name = prop_name\n1434             self._type_check = lambda artist: (\n1435                 (not valid_types or isinstance(artist, valid_types)) and\n1436                 (not invalid_types or not isinstance(artist, invalid_types))\n1437             )\n1438 \n1439         def __repr__(self):\n1440             return f'<Axes.ArtistList of {len(self)} {self._prop_name}>'\n1441 \n1442         def __len__(self):\n1443             return sum(self._type_check(artist)\n1444                        for artist in self._axes._children)\n1445 \n1446         def __iter__(self):\n1447             for artist in list(self._axes._children):\n1448                 if self._type_check(artist):\n1449                     yield artist\n1450 \n1451         def __getitem__(self, key):\n1452             return [artist\n1453                     for artist in self._axes._children\n1454                     if self._type_check(artist)][key]\n1455 \n1456         def __add__(self, other):\n1457             if isinstance(other, (list, _AxesBase.ArtistList)):\n1458                 return [*self, *other]\n1459             if isinstance(other, (tuple, _AxesBase.ArtistList)):\n1460                 return (*self, *other)\n1461             return NotImplemented\n1462 \n1463         def __radd__(self, other):\n1464             if isinstance(other, list):\n1465                 return other + list(self)\n1466             if isinstance(other, tuple):\n1467                 return other + tuple(self)\n1468             return NotImplemented\n1469 \n1470     @property\n1471     def artists(self):\n1472         return self.ArtistList(self, 'artists', invalid_types=(\n1473             mcoll.Collection, mimage.AxesImage, mlines.Line2D, mpatches.Patch,\n1474             mtable.Table, mtext.Text))\n1475 \n1476     @property\n1477     def collections(self):\n1478         return self.ArtistList(self, 'collections',\n1479                                valid_types=mcoll.Collection)\n1480 \n1481     @property\n1482     def images(self):\n1483         return self.ArtistList(self, 'images', valid_types=mimage.AxesImage)\n1484 \n1485     @property\n1486     def lines(self):\n1487         return self.ArtistList(self, 'lines', valid_types=mlines.Line2D)\n1488 \n1489     @property\n1490     def patches(self):\n1491         return self.ArtistList(self, 'patches', valid_types=mpatches.Patch)\n1492 \n1493     @property\n1494     def tables(self):\n1495         return self.ArtistList(self, 'tables', valid_types=mtable.Table)\n1496 \n1497     @property\n1498     def texts(self):\n1499         return self.ArtistList(self, 'texts', valid_types=mtext.Text)\n1500 \n1501     def get_facecolor(self):\n1502         \"\"\"Get the facecolor of the Axes.\"\"\"\n1503         return self.patch.get_facecolor()\n1504 \n1505     def set_facecolor(self, color):\n1506         \"\"\"\n1507         Set the facecolor of the Axes.\n1508 \n1509         Parameters\n1510         ----------\n1511         color : color\n1512         \"\"\"\n1513         self._facecolor = color\n1514         self.stale = True\n1515         return self.patch.set_facecolor(color)\n1516 \n1517     def _set_title_offset_trans(self, title_offset_points):\n1518         \"\"\"\n1519         Set the offset for the title either from :rc:`axes.titlepad`\n1520         or from set_title kwarg ``pad``.\n1521         \"\"\"\n1522         self.titleOffsetTrans = mtransforms.ScaledTranslation(\n1523                 0.0, title_offset_points / 72,\n1524                 self.figure.dpi_scale_trans)\n1525         for _title in (self.title, self._left_title, self._right_title):\n1526             _title.set_transform(self.transAxes + self.titleOffsetTrans)\n1527             _title.set_clip_box(None)\n1528 \n1529     def set_prop_cycle(self, *args, **kwargs):\n1530         \"\"\"\n1531         Set the property cycle of the Axes.\n1532 \n1533         The property cycle controls the style properties such as color,\n1534         marker and linestyle of future plot commands. The style properties\n1535         of data already added to the Axes are not modified.\n1536 \n1537         Call signatures::\n1538 \n1539           set_prop_cycle(cycler)\n1540           set_prop_cycle(label=values[, label2=values2[, ...]])\n1541           set_prop_cycle(label, values)\n1542 \n1543         Form 1 sets given `~cycler.Cycler` object.\n1544 \n1545         Form 2 creates a `~cycler.Cycler` which cycles over one or more\n1546         properties simultaneously and set it as the property cycle of the\n1547         Axes. If multiple properties are given, their value lists must have\n1548         the same length. This is just a shortcut for explicitly creating a\n1549         cycler and passing it to the function, i.e. it's short for\n1550         ``set_prop_cycle(cycler(label=values label2=values2, ...))``.\n1551 \n1552         Form 3 creates a `~cycler.Cycler` for a single property and set it\n1553         as the property cycle of the Axes. This form exists for compatibility\n1554         with the original `cycler.cycler` interface. Its use is discouraged\n1555         in favor of the kwarg form, i.e. ``set_prop_cycle(label=values)``.\n1556 \n1557         Parameters\n1558         ----------\n1559         cycler : Cycler\n1560             Set the given Cycler. *None* resets to the cycle defined by the\n1561             current style.\n1562 \n1563         label : str\n1564             The property key. Must be a valid `.Artist` property.\n1565             For example, 'color' or 'linestyle'. Aliases are allowed,\n1566             such as 'c' for 'color' and 'lw' for 'linewidth'.\n1567 \n1568         values : iterable\n1569             Finite-length iterable of the property values. These values\n1570             are validated and will raise a ValueError if invalid.\n1571 \n1572         See Also\n1573         --------\n1574         matplotlib.rcsetup.cycler\n1575             Convenience function for creating validated cyclers for properties.\n1576         cycler.cycler\n1577             The original function for creating unvalidated cyclers.\n1578 \n1579         Examples\n1580         --------\n1581         Setting the property cycle for a single property:\n1582 \n1583         >>> ax.set_prop_cycle(color=['red', 'green', 'blue'])\n1584 \n1585         Setting the property cycle for simultaneously cycling over multiple\n1586         properties (e.g. red circle, green plus, blue cross):\n1587 \n1588         >>> ax.set_prop_cycle(color=['red', 'green', 'blue'],\n1589         ...                   marker=['o', '+', 'x'])\n1590 \n1591         \"\"\"\n1592         if args and kwargs:\n1593             raise TypeError(\"Cannot supply both positional and keyword \"\n1594                             \"arguments to this method.\")\n1595         # Can't do `args == (None,)` as that crashes cycler.\n1596         if len(args) == 1 and args[0] is None:\n1597             prop_cycle = None\n1598         else:\n1599             prop_cycle = cycler(*args, **kwargs)\n1600         self._get_lines.set_prop_cycle(prop_cycle)\n1601         self._get_patches_for_fill.set_prop_cycle(prop_cycle)\n1602 \n1603     def get_aspect(self):\n1604         \"\"\"\n1605         Return the aspect ratio of the axes scaling.\n1606 \n1607         This is either \"auto\" or a float giving the ratio of y/x-scale.\n1608         \"\"\"\n1609         return self._aspect\n1610 \n1611     def set_aspect(self, aspect, adjustable=None, anchor=None, share=False):\n1612         \"\"\"\n1613         Set the aspect ratio of the axes scaling, i.e. y/x-scale.\n1614 \n1615         Parameters\n1616         ----------\n1617         aspect : {'auto', 'equal'} or float\n1618             Possible values:\n1619 \n1620             - 'auto': fill the position rectangle with data.\n1621             - 'equal': same as ``aspect=1``, i.e. same scaling for x and y.\n1622             - *float*: The displayed size of 1 unit in y-data coordinates will\n1623               be *aspect* times the displayed size of 1 unit in x-data\n1624               coordinates; e.g. for ``aspect=2`` a square in data coordinates\n1625               will be rendered with a height of twice its width.\n1626 \n1627         adjustable : None or {'box', 'datalim'}, optional\n1628             If not ``None``, this defines which parameter will be adjusted to\n1629             meet the required aspect. See `.set_adjustable` for further\n1630             details.\n1631 \n1632         anchor : None or str or (float, float), optional\n1633             If not ``None``, this defines where the Axes will be drawn if there\n1634             is extra space due to aspect constraints. The most common way\n1635             to specify the anchor are abbreviations of cardinal directions:\n1636 \n1637             =====   =====================\n1638             value   description\n1639             =====   =====================\n1640             'C'     centered\n1641             'SW'    lower left corner\n1642             'S'     middle of bottom edge\n1643             'SE'    lower right corner\n1644             etc.\n1645             =====   =====================\n1646 \n1647             See `~.Axes.set_anchor` for further details.\n1648 \n1649         share : bool, default: False\n1650             If ``True``, apply the settings to all shared Axes.\n1651 \n1652         See Also\n1653         --------\n1654         matplotlib.axes.Axes.set_adjustable\n1655             Set how the Axes adjusts to achieve the required aspect ratio.\n1656         matplotlib.axes.Axes.set_anchor\n1657             Set the position in case of extra space.\n1658         \"\"\"\n1659         if cbook._str_equal(aspect, 'equal'):\n1660             aspect = 1\n1661         if not cbook._str_equal(aspect, 'auto'):\n1662             aspect = float(aspect)  # raise ValueError if necessary\n1663             if aspect <= 0 or not np.isfinite(aspect):\n1664                 raise ValueError(\"aspect must be finite and positive \")\n1665 \n1666         if share:\n1667             axes = {sibling for name in self._axis_names\n1668                     for sibling in self._shared_axes[name].get_siblings(self)}\n1669         else:\n1670             axes = [self]\n1671 \n1672         for ax in axes:\n1673             ax._aspect = aspect\n1674 \n1675         if adjustable is None:\n1676             adjustable = self._adjustable\n1677         self.set_adjustable(adjustable, share=share)  # Handle sharing.\n1678 \n1679         if anchor is not None:\n1680             self.set_anchor(anchor, share=share)\n1681         self.stale = True\n1682 \n1683     def get_adjustable(self):\n1684         \"\"\"\n1685         Return whether the Axes will adjust its physical dimension ('box') or\n1686         its data limits ('datalim') to achieve the desired aspect ratio.\n1687 \n1688         See Also\n1689         --------\n1690         matplotlib.axes.Axes.set_adjustable\n1691             Set how the Axes adjusts to achieve the required aspect ratio.\n1692         matplotlib.axes.Axes.set_aspect\n1693             For a description of aspect handling.\n1694         \"\"\"\n1695         return self._adjustable\n1696 \n1697     def set_adjustable(self, adjustable, share=False):\n1698         \"\"\"\n1699         Set how the Axes adjusts to achieve the required aspect ratio.\n1700 \n1701         Parameters\n1702         ----------\n1703         adjustable : {'box', 'datalim'}\n1704             If 'box', change the physical dimensions of the Axes.\n1705             If 'datalim', change the ``x`` or ``y`` data limits.\n1706 \n1707         share : bool, default: False\n1708             If ``True``, apply the settings to all shared Axes.\n1709 \n1710         See Also\n1711         --------\n1712         matplotlib.axes.Axes.set_aspect\n1713             For a description of aspect handling.\n1714 \n1715         Notes\n1716         -----\n1717         Shared Axes (of which twinned Axes are a special case)\n1718         impose restrictions on how aspect ratios can be imposed.\n1719         For twinned Axes, use 'datalim'.  For Axes that share both\n1720         x and y, use 'box'.  Otherwise, either 'datalim' or 'box'\n1721         may be used.  These limitations are partly a requirement\n1722         to avoid over-specification, and partly a result of the\n1723         particular implementation we are currently using, in\n1724         which the adjustments for aspect ratios are done sequentially\n1725         and independently on each Axes as it is drawn.\n1726         \"\"\"\n1727         _api.check_in_list([\"box\", \"datalim\"], adjustable=adjustable)\n1728         if share:\n1729             axs = {sibling for name in self._axis_names\n1730                    for sibling in self._shared_axes[name].get_siblings(self)}\n1731         else:\n1732             axs = [self]\n1733         if (adjustable == \"datalim\"\n1734                 and any(getattr(ax.get_data_ratio, \"__func__\", None)\n1735                         != _AxesBase.get_data_ratio\n1736                         for ax in axs)):\n1737             # Limits adjustment by apply_aspect assumes that the axes' aspect\n1738             # ratio can be computed from the data limits and scales.\n1739             raise ValueError(\"Cannot set Axes adjustable to 'datalim' for \"\n1740                              \"Axes which override 'get_data_ratio'\")\n1741         for ax in axs:\n1742             ax._adjustable = adjustable\n1743         self.stale = True\n1744 \n1745     def get_box_aspect(self):\n1746         \"\"\"\n1747         Return the Axes box aspect, i.e. the ratio of height to width.\n1748 \n1749         The box aspect is ``None`` (i.e. chosen depending on the available\n1750         figure space) unless explicitly specified.\n1751 \n1752         See Also\n1753         --------\n1754         matplotlib.axes.Axes.set_box_aspect\n1755             for a description of box aspect.\n1756         matplotlib.axes.Axes.set_aspect\n1757             for a description of aspect handling.\n1758         \"\"\"\n1759         return self._box_aspect\n1760 \n1761     def set_box_aspect(self, aspect=None):\n1762         \"\"\"\n1763         Set the Axes box aspect, i.e. the ratio of height to width.\n1764 \n1765         This defines the aspect of the Axes in figure space and is not to be\n1766         confused with the data aspect (see `~.Axes.set_aspect`).\n1767 \n1768         Parameters\n1769         ----------\n1770         aspect : float or None\n1771             Changes the physical dimensions of the Axes, such that the ratio\n1772             of the Axes height to the Axes width in physical units is equal to\n1773             *aspect*. Defining a box aspect will change the *adjustable*\n1774             property to 'datalim' (see `~.Axes.set_adjustable`).\n1775 \n1776             *None* will disable a fixed box aspect so that height and width\n1777             of the Axes are chosen independently.\n1778 \n1779         See Also\n1780         --------\n1781         matplotlib.axes.Axes.set_aspect\n1782             for a description of aspect handling.\n1783         \"\"\"\n1784         axs = {*self._twinned_axes.get_siblings(self),\n1785                *self._twinned_axes.get_siblings(self)}\n1786 \n1787         if aspect is not None:\n1788             aspect = float(aspect)\n1789             # when box_aspect is set to other than \u00b4None`,\n1790             # adjustable must be \"datalim\"\n1791             for ax in axs:\n1792                 ax.set_adjustable(\"datalim\")\n1793 \n1794         for ax in axs:\n1795             ax._box_aspect = aspect\n1796             ax.stale = True\n1797 \n1798     def get_anchor(self):\n1799         \"\"\"\n1800         Get the anchor location.\n1801 \n1802         See Also\n1803         --------\n1804         matplotlib.axes.Axes.set_anchor\n1805             for a description of the anchor.\n1806         matplotlib.axes.Axes.set_aspect\n1807             for a description of aspect handling.\n1808         \"\"\"\n1809         return self._anchor\n1810 \n1811     def set_anchor(self, anchor, share=False):\n1812         \"\"\"\n1813         Define the anchor location.\n1814 \n1815         The actual drawing area (active position) of the Axes may be smaller\n1816         than the Bbox (original position) when a fixed aspect is required. The\n1817         anchor defines where the drawing area will be located within the\n1818         available space.\n1819 \n1820         Parameters\n1821         ----------\n1822         anchor : (float, float) or {'C', 'SW', 'S', 'SE', 'E', 'NE', ...}\n1823             Either an (*x*, *y*) pair of relative coordinates (0 is left or\n1824             bottom, 1 is right or top), 'C' (center), or a cardinal direction\n1825             ('SW', southwest, is bottom left, etc.).  str inputs are shorthands\n1826             for (*x*, *y*) coordinates, as shown in the following diagram::\n1827 \n1828                \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n1829                \u2502 'NW' (0.0, 1.0) \u2502 'N' (0.5, 1.0)  \u2502 'NE' (1.0, 1.0) \u2502\n1830                \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n1831                \u2502 'W'  (0.0, 0.5) \u2502 'C' (0.5, 0.5)  \u2502 'E'  (1.0, 0.5) \u2502\n1832                \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n1833                \u2502 'SW' (0.0, 0.0) \u2502 'S' (0.5, 0.0)  \u2502 'SE' (1.0, 0.0) \u2502\n1834                \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n1835 \n1836         share : bool, default: False\n1837             If ``True``, apply the settings to all shared Axes.\n1838 \n1839         See Also\n1840         --------\n1841         matplotlib.axes.Axes.set_aspect\n1842             for a description of aspect handling.\n1843         \"\"\"\n1844         if not (anchor in mtransforms.Bbox.coefs or len(anchor) == 2):\n1845             raise ValueError('argument must be among %s' %\n1846                              ', '.join(mtransforms.Bbox.coefs))\n1847         if share:\n1848             axes = {sibling for name in self._axis_names\n1849                     for sibling in self._shared_axes[name].get_siblings(self)}\n1850         else:\n1851             axes = [self]\n1852         for ax in axes:\n1853             ax._anchor = anchor\n1854 \n1855         self.stale = True\n1856 \n1857     def get_data_ratio(self):\n1858         \"\"\"\n1859         Return the aspect ratio of the scaled data.\n1860 \n1861         Notes\n1862         -----\n1863         This method is intended to be overridden by new projection types.\n1864         \"\"\"\n1865         txmin, txmax = self.xaxis.get_transform().transform(self.get_xbound())\n1866         tymin, tymax = self.yaxis.get_transform().transform(self.get_ybound())\n1867         xsize = max(abs(txmax - txmin), 1e-30)\n1868         ysize = max(abs(tymax - tymin), 1e-30)\n1869         return ysize / xsize\n1870 \n1871     def apply_aspect(self, position=None):\n1872         \"\"\"\n1873         Adjust the Axes for a specified data aspect ratio.\n1874 \n1875         Depending on `.get_adjustable` this will modify either the\n1876         Axes box (position) or the view limits. In the former case,\n1877         `~matplotlib.axes.Axes.get_anchor` will affect the position.\n1878 \n1879         Parameters\n1880         ----------\n1881         position : None or .Bbox\n1882             If not ``None``, this defines the position of the\n1883             Axes within the figure as a Bbox. See `~.Axes.get_position`\n1884             for further details.\n1885 \n1886         Notes\n1887         -----\n1888         This is called automatically when each Axes is drawn.  You may need\n1889         to call it yourself if you need to update the Axes position and/or\n1890         view limits before the Figure is drawn.\n1891 \n1892         See Also\n1893         --------\n1894         matplotlib.axes.Axes.set_aspect\n1895             For a description of aspect ratio handling.\n1896         matplotlib.axes.Axes.set_adjustable\n1897             Set how the Axes adjusts to achieve the required aspect ratio.\n1898         matplotlib.axes.Axes.set_anchor\n1899             Set the position in case of extra space.\n1900         \"\"\"\n1901         if position is None:\n1902             position = self.get_position(original=True)\n1903 \n1904         aspect = self.get_aspect()\n1905 \n1906         if aspect == 'auto' and self._box_aspect is None:\n1907             self._set_position(position, which='active')\n1908             return\n1909 \n1910         trans = self.get_figure().transSubfigure\n1911         bb = mtransforms.Bbox.unit().transformed(trans)\n1912         # this is the physical aspect of the panel (or figure):\n1913         fig_aspect = bb.height / bb.width\n1914 \n1915         if self._adjustable == 'box':\n1916             if self in self._twinned_axes:\n1917                 raise RuntimeError(\"Adjustable 'box' is not allowed in a \"\n1918                                    \"twinned Axes; use 'datalim' instead\")\n1919             box_aspect = aspect * self.get_data_ratio()\n1920             pb = position.frozen()\n1921             pb1 = pb.shrunk_to_aspect(box_aspect, pb, fig_aspect)\n1922             self._set_position(pb1.anchored(self.get_anchor(), pb), 'active')\n1923             return\n1924 \n1925         # The following is only seen if self._adjustable == 'datalim'\n1926         if self._box_aspect is not None:\n1927             pb = position.frozen()\n1928             pb1 = pb.shrunk_to_aspect(self._box_aspect, pb, fig_aspect)\n1929             self._set_position(pb1.anchored(self.get_anchor(), pb), 'active')\n1930             if aspect == \"auto\":\n1931                 return\n1932 \n1933         # reset active to original in case it had been changed by prior use\n1934         # of 'box'\n1935         if self._box_aspect is None:\n1936             self._set_position(position, which='active')\n1937         else:\n1938             position = pb1.anchored(self.get_anchor(), pb)\n1939 \n1940         x_trf = self.xaxis.get_transform()\n1941         y_trf = self.yaxis.get_transform()\n1942         xmin, xmax = x_trf.transform(self.get_xbound())\n1943         ymin, ymax = y_trf.transform(self.get_ybound())\n1944         xsize = max(abs(xmax - xmin), 1e-30)\n1945         ysize = max(abs(ymax - ymin), 1e-30)\n1946 \n1947         box_aspect = fig_aspect * (position.height / position.width)\n1948         data_ratio = box_aspect / aspect\n1949 \n1950         y_expander = data_ratio * xsize / ysize - 1\n1951         # If y_expander > 0, the dy/dx viewLim ratio needs to increase\n1952         if abs(y_expander) < 0.005:\n1953             return\n1954 \n1955         dL = self.dataLim\n1956         x0, x1 = x_trf.transform(dL.intervalx)\n1957         y0, y1 = y_trf.transform(dL.intervaly)\n1958         xr = 1.05 * (x1 - x0)\n1959         yr = 1.05 * (y1 - y0)\n1960 \n1961         xmarg = xsize - xr\n1962         ymarg = ysize - yr\n1963         Ysize = data_ratio * xsize\n1964         Xsize = ysize / data_ratio\n1965         Xmarg = Xsize - xr\n1966         Ymarg = Ysize - yr\n1967         # Setting these targets to, e.g., 0.05*xr does not seem to help.\n1968         xm = 0\n1969         ym = 0\n1970 \n1971         shared_x = self in self._shared_axes[\"x\"]\n1972         shared_y = self in self._shared_axes[\"y\"]\n1973 \n1974         if shared_x and shared_y:\n1975             raise RuntimeError(\"set_aspect(..., adjustable='datalim') or \"\n1976                                \"axis('equal') are not allowed when both axes \"\n1977                                \"are shared.  Try set_aspect(..., \"\n1978                                \"adjustable='box').\")\n1979 \n1980         # If y is shared, then we are only allowed to change x, etc.\n1981         if shared_y:\n1982             adjust_y = False\n1983         else:\n1984             if xmarg > xm and ymarg > ym:\n1985                 adjy = ((Ymarg > 0 and y_expander < 0) or\n1986                         (Xmarg < 0 and y_expander > 0))\n1987             else:\n1988                 adjy = y_expander > 0\n1989             adjust_y = shared_x or adjy  # (Ymarg > xmarg)\n1990 \n1991         if adjust_y:\n1992             yc = 0.5 * (ymin + ymax)\n1993             y0 = yc - Ysize / 2.0\n1994             y1 = yc + Ysize / 2.0\n1995             self.set_ybound(y_trf.inverted().transform([y0, y1]))\n1996         else:\n1997             xc = 0.5 * (xmin + xmax)\n1998             x0 = xc - Xsize / 2.0\n1999             x1 = xc + Xsize / 2.0\n2000             self.set_xbound(x_trf.inverted().transform([x0, x1]))\n2001 \n2002     def axis(self, arg=None, /, *, emit=True, **kwargs):\n2003         \"\"\"\n2004         Convenience method to get or set some axis properties.\n2005 \n2006         Call signatures::\n2007 \n2008           xmin, xmax, ymin, ymax = axis()\n2009           xmin, xmax, ymin, ymax = axis([xmin, xmax, ymin, ymax])\n2010           xmin, xmax, ymin, ymax = axis(option)\n2011           xmin, xmax, ymin, ymax = axis(**kwargs)\n2012 \n2013         Parameters\n2014         ----------\n2015         xmin, xmax, ymin, ymax : float, optional\n2016             The axis limits to be set.  This can also be achieved using ::\n2017 \n2018                 ax.set(xlim=(xmin, xmax), ylim=(ymin, ymax))\n2019 \n2020         option : bool or str\n2021             If a bool, turns axis lines and labels on or off. If a string,\n2022             possible values are:\n2023 \n2024             ======== ==========================================================\n2025             Value    Description\n2026             ======== ==========================================================\n2027             'on'     Turn on axis lines and labels. Same as ``True``.\n2028             'off'    Turn off axis lines and labels. Same as ``False``.\n2029             'equal'  Set equal scaling (i.e., make circles circular) by\n2030                      changing axis limits. This is the same as\n2031                      ``ax.set_aspect('equal', adjustable='datalim')``.\n2032                      Explicit data limits may not be respected in this case.\n2033             'scaled' Set equal scaling (i.e., make circles circular) by\n2034                      changing dimensions of the plot box. This is the same as\n2035                      ``ax.set_aspect('equal', adjustable='box', anchor='C')``.\n2036                      Additionally, further autoscaling will be disabled.\n2037             'tight'  Set limits just large enough to show all data, then\n2038                      disable further autoscaling.\n2039             'auto'   Automatic scaling (fill plot box with data).\n2040             'image'  'scaled' with axis limits equal to data limits.\n2041             'square' Square plot; similar to 'scaled', but initially forcing\n2042                      ``xmax-xmin == ymax-ymin``.\n2043             ======== ==========================================================\n2044 \n2045         emit : bool, default: True\n2046             Whether observers are notified of the axis limit change.\n2047             This option is passed on to `~.Axes.set_xlim` and\n2048             `~.Axes.set_ylim`.\n2049 \n2050         Returns\n2051         -------\n2052         xmin, xmax, ymin, ymax : float\n2053             The axis limits.\n2054 \n2055         See Also\n2056         --------\n2057         matplotlib.axes.Axes.set_xlim\n2058         matplotlib.axes.Axes.set_ylim\n2059         \"\"\"\n2060         if isinstance(arg, (str, bool)):\n2061             if arg is True:\n2062                 arg = 'on'\n2063             if arg is False:\n2064                 arg = 'off'\n2065             arg = arg.lower()\n2066             if arg == 'on':\n2067                 self.set_axis_on()\n2068             elif arg == 'off':\n2069                 self.set_axis_off()\n2070             elif arg in [\n2071                     'equal', 'tight', 'scaled', 'auto', 'image', 'square']:\n2072                 self.set_autoscale_on(True)\n2073                 self.set_aspect('auto')\n2074                 self.autoscale_view(tight=False)\n2075                 if arg == 'equal':\n2076                     self.set_aspect('equal', adjustable='datalim')\n2077                 elif arg == 'scaled':\n2078                     self.set_aspect('equal', adjustable='box', anchor='C')\n2079                     self.set_autoscale_on(False)  # Req. by Mark Bakker\n2080                 elif arg == 'tight':\n2081                     self.autoscale_view(tight=True)\n2082                     self.set_autoscale_on(False)\n2083                 elif arg == 'image':\n2084                     self.autoscale_view(tight=True)\n2085                     self.set_autoscale_on(False)\n2086                     self.set_aspect('equal', adjustable='box', anchor='C')\n2087                 elif arg == 'square':\n2088                     self.set_aspect('equal', adjustable='box', anchor='C')\n2089                     self.set_autoscale_on(False)\n2090                     xlim = self.get_xlim()\n2091                     ylim = self.get_ylim()\n2092                     edge_size = max(np.diff(xlim), np.diff(ylim))[0]\n2093                     self.set_xlim([xlim[0], xlim[0] + edge_size],\n2094                                   emit=emit, auto=False)\n2095                     self.set_ylim([ylim[0], ylim[0] + edge_size],\n2096                                   emit=emit, auto=False)\n2097             else:\n2098                 raise ValueError(f\"Unrecognized string {arg!r} to axis; \"\n2099                                  \"try 'on' or 'off'\")\n2100         else:\n2101             if arg is not None:\n2102                 try:\n2103                     xmin, xmax, ymin, ymax = arg\n2104                 except (TypeError, ValueError) as err:\n2105                     raise TypeError('the first argument to axis() must be an '\n2106                                     'iterable of the form '\n2107                                     '[xmin, xmax, ymin, ymax]') from err\n2108             else:\n2109                 xmin = kwargs.pop('xmin', None)\n2110                 xmax = kwargs.pop('xmax', None)\n2111                 ymin = kwargs.pop('ymin', None)\n2112                 ymax = kwargs.pop('ymax', None)\n2113             xauto = (None  # Keep autoscale state as is.\n2114                      if xmin is None and xmax is None\n2115                      else False)  # Turn off autoscale.\n2116             yauto = (None\n2117                      if ymin is None and ymax is None\n2118                      else False)\n2119             self.set_xlim(xmin, xmax, emit=emit, auto=xauto)\n2120             self.set_ylim(ymin, ymax, emit=emit, auto=yauto)\n2121         if kwargs:\n2122             raise _api.kwarg_error(\"axis\", kwargs)\n2123         return (*self.get_xlim(), *self.get_ylim())\n2124 \n2125     def get_legend(self):\n2126         \"\"\"Return the `.Legend` instance, or None if no legend is defined.\"\"\"\n2127         return self.legend_\n2128 \n2129     def get_images(self):\n2130         r\"\"\"Return a list of `.AxesImage`\\s contained by the Axes.\"\"\"\n2131         return cbook.silent_list('AxesImage', self.images)\n2132 \n2133     def get_lines(self):\n2134         \"\"\"Return a list of lines contained by the Axes.\"\"\"\n2135         return cbook.silent_list('Line2D', self.lines)\n2136 \n2137     def get_xaxis(self):\n2138         \"\"\"\n2139         [*Discouraged*] Return the XAxis instance.\n2140 \n2141         .. admonition:: Discouraged\n2142 \n2143             The use of this function is discouraged. You should instead\n2144             directly access the attribute ``ax.xaxis``.\n2145         \"\"\"\n2146         return self.xaxis\n2147 \n2148     def get_yaxis(self):\n2149         \"\"\"\n2150         [*Discouraged*] Return the YAxis instance.\n2151 \n2152         .. admonition:: Discouraged\n2153 \n2154             The use of this function is discouraged. You should instead\n2155             directly access the attribute ``ax.yaxis``.\n2156         \"\"\"\n2157         return self.yaxis\n2158 \n2159     get_xgridlines = _axis_method_wrapper(\"xaxis\", \"get_gridlines\")\n2160     get_xticklines = _axis_method_wrapper(\"xaxis\", \"get_ticklines\")\n2161     get_ygridlines = _axis_method_wrapper(\"yaxis\", \"get_gridlines\")\n2162     get_yticklines = _axis_method_wrapper(\"yaxis\", \"get_ticklines\")\n2163 \n2164     # Adding and tracking artists\n2165 \n2166     def _sci(self, im):\n2167         \"\"\"\n2168         Set the current image.\n2169 \n2170         This image will be the target of colormap functions like\n2171         ``pyplot.viridis``, and other functions such as `~.pyplot.clim`.  The\n2172         current image is an attribute of the current Axes.\n2173         \"\"\"\n2174         _api.check_isinstance(\n2175             (mpl.contour.ContourSet, mcoll.Collection, mimage.AxesImage),\n2176             im=im)\n2177         if isinstance(im, mpl.contour.ContourSet):\n2178             if im.collections[0] not in self._children:\n2179                 raise ValueError(\"ContourSet must be in current Axes\")\n2180         elif im not in self._children:\n2181             raise ValueError(\"Argument must be an image, collection, or \"\n2182                              \"ContourSet in this Axes\")\n2183         self._current_image = im\n2184 \n2185     def _gci(self):\n2186         \"\"\"Helper for `~matplotlib.pyplot.gci`; do not use elsewhere.\"\"\"\n2187         return self._current_image\n2188 \n2189     def has_data(self):\n2190         \"\"\"\n2191         Return whether any artists have been added to the Axes.\n2192 \n2193         This should not be used to determine whether the *dataLim*\n2194         need to be updated, and may not actually be useful for\n2195         anything.\n2196         \"\"\"\n2197         return any(isinstance(a, (mcoll.Collection, mimage.AxesImage,\n2198                                   mlines.Line2D, mpatches.Patch))\n2199                    for a in self._children)\n2200 \n2201     def add_artist(self, a):\n2202         \"\"\"\n2203         Add an `.Artist` to the Axes; return the artist.\n2204 \n2205         Use `add_artist` only for artists for which there is no dedicated\n2206         \"add\" method; and if necessary, use a method such as `update_datalim`\n2207         to manually update the dataLim if the artist is to be included in\n2208         autoscaling.\n2209 \n2210         If no ``transform`` has been specified when creating the artist (e.g.\n2211         ``artist.get_transform() == None``) then the transform is set to\n2212         ``ax.transData``.\n2213         \"\"\"\n2214         a.axes = self\n2215         self._children.append(a)\n2216         a._remove_method = self._children.remove\n2217         self._set_artist_props(a)\n2218         if a.get_clip_path() is None:\n2219             a.set_clip_path(self.patch)\n2220         self.stale = True\n2221         return a\n2222 \n2223     def add_child_axes(self, ax):\n2224         \"\"\"\n2225         Add an `.AxesBase` to the Axes' children; return the child Axes.\n2226 \n2227         This is the lowlevel version.  See `.axes.Axes.inset_axes`.\n2228         \"\"\"\n2229 \n2230         # normally Axes have themselves as the Axes, but these need to have\n2231         # their parent...\n2232         # Need to bypass the getter...\n2233         ax._axes = self\n2234         ax.stale_callback = martist._stale_axes_callback\n2235 \n2236         self.child_axes.append(ax)\n2237         ax._remove_method = self.child_axes.remove\n2238         self.stale = True\n2239         return ax\n2240 \n2241     def add_collection(self, collection, autolim=True):\n2242         \"\"\"\n2243         Add a `.Collection` to the Axes; return the collection.\n2244         \"\"\"\n2245         _api.check_isinstance(mcoll.Collection, collection=collection)\n2246         label = collection.get_label()\n2247         if not label:\n2248             collection.set_label(f'_child{len(self._children)}')\n2249         self._children.append(collection)\n2250         collection._remove_method = self._children.remove\n2251         self._set_artist_props(collection)\n2252 \n2253         if collection.get_clip_path() is None:\n2254             collection.set_clip_path(self.patch)\n2255 \n2256         if autolim:\n2257             # Make sure viewLim is not stale (mostly to match\n2258             # pre-lazy-autoscale behavior, which is not really better).\n2259             self._unstale_viewLim()\n2260             datalim = collection.get_datalim(self.transData)\n2261             points = datalim.get_points()\n2262             if not np.isinf(datalim.minpos).all():\n2263                 # By definition, if minpos (minimum positive value) is set\n2264                 # (i.e., non-inf), then min(points) <= minpos <= max(points),\n2265                 # and minpos would be superfluous. However, we add minpos to\n2266                 # the call so that self.dataLim will update its own minpos.\n2267                 # This ensures that log scales see the correct minimum.\n2268                 points = np.concatenate([points, [datalim.minpos]])\n2269             self.update_datalim(points)\n2270 \n2271         self.stale = True\n2272         return collection\n2273 \n2274     def add_image(self, image):\n2275         \"\"\"\n2276         Add an `.AxesImage` to the Axes; return the image.\n2277         \"\"\"\n2278         _api.check_isinstance(mimage.AxesImage, image=image)\n2279         self._set_artist_props(image)\n2280         if not image.get_label():\n2281             image.set_label(f'_child{len(self._children)}')\n2282         self._children.append(image)\n2283         image._remove_method = self._children.remove\n2284         self.stale = True\n2285         return image\n2286 \n2287     def _update_image_limits(self, image):\n2288         xmin, xmax, ymin, ymax = image.get_extent()\n2289         self.axes.update_datalim(((xmin, ymin), (xmax, ymax)))\n2290 \n2291     def add_line(self, line):\n2292         \"\"\"\n2293         Add a `.Line2D` to the Axes; return the line.\n2294         \"\"\"\n2295         _api.check_isinstance(mlines.Line2D, line=line)\n2296         self._set_artist_props(line)\n2297         if line.get_clip_path() is None:\n2298             line.set_clip_path(self.patch)\n2299 \n2300         self._update_line_limits(line)\n2301         if not line.get_label():\n2302             line.set_label(f'_child{len(self._children)}')\n2303         self._children.append(line)\n2304         line._remove_method = self._children.remove\n2305         self.stale = True\n2306         return line\n2307 \n2308     def _add_text(self, txt):\n2309         \"\"\"\n2310         Add a `.Text` to the Axes; return the text.\n2311         \"\"\"\n2312         _api.check_isinstance(mtext.Text, txt=txt)\n2313         self._set_artist_props(txt)\n2314         self._children.append(txt)\n2315         txt._remove_method = self._children.remove\n2316         self.stale = True\n2317         return txt\n2318 \n2319     def _update_line_limits(self, line):\n2320         \"\"\"\n2321         Figures out the data limit of the given line, updating self.dataLim.\n2322         \"\"\"\n2323         path = line.get_path()\n2324         if path.vertices.size == 0:\n2325             return\n2326 \n2327         line_trf = line.get_transform()\n2328 \n2329         if line_trf == self.transData:\n2330             data_path = path\n2331         elif any(line_trf.contains_branch_seperately(self.transData)):\n2332             # Compute the transform from line coordinates to data coordinates.\n2333             trf_to_data = line_trf - self.transData\n2334             # If transData is affine we can use the cached non-affine component\n2335             # of line's path (since the non-affine part of line_trf is\n2336             # entirely encapsulated in trf_to_data).\n2337             if self.transData.is_affine:\n2338                 line_trans_path = line._get_transformed_path()\n2339                 na_path, _ = line_trans_path.get_transformed_path_and_affine()\n2340                 data_path = trf_to_data.transform_path_affine(na_path)\n2341             else:\n2342                 data_path = trf_to_data.transform_path(path)\n2343         else:\n2344             # For backwards compatibility we update the dataLim with the\n2345             # coordinate range of the given path, even though the coordinate\n2346             # systems are completely different. This may occur in situations\n2347             # such as when ax.transAxes is passed through for absolute\n2348             # positioning.\n2349             data_path = path\n2350 \n2351         if not data_path.vertices.size:\n2352             return\n2353 \n2354         updatex, updatey = line_trf.contains_branch_seperately(self.transData)\n2355         if self.name != \"rectilinear\":\n2356             # This block is mostly intended to handle axvline in polar plots,\n2357             # for which updatey would otherwise be True.\n2358             if updatex and line_trf == self.get_yaxis_transform():\n2359                 updatex = False\n2360             if updatey and line_trf == self.get_xaxis_transform():\n2361                 updatey = False\n2362         self.dataLim.update_from_path(data_path,\n2363                                       self.ignore_existing_data_limits,\n2364                                       updatex=updatex, updatey=updatey)\n2365         self.ignore_existing_data_limits = False\n2366 \n2367     def add_patch(self, p):\n2368         \"\"\"\n2369         Add a `.Patch` to the Axes; return the patch.\n2370         \"\"\"\n2371         _api.check_isinstance(mpatches.Patch, p=p)\n2372         self._set_artist_props(p)\n2373         if p.get_clip_path() is None:\n2374             p.set_clip_path(self.patch)\n2375         self._update_patch_limits(p)\n2376         self._children.append(p)\n2377         p._remove_method = self._children.remove\n2378         return p\n2379 \n2380     def _update_patch_limits(self, patch):\n2381         \"\"\"Update the data limits for the given patch.\"\"\"\n2382         # hist can add zero height Rectangles, which is useful to keep\n2383         # the bins, counts and patches lined up, but it throws off log\n2384         # scaling.  We'll ignore rects with zero height or width in\n2385         # the auto-scaling\n2386 \n2387         # cannot check for '==0' since unitized data may not compare to zero\n2388         # issue #2150 - we update the limits if patch has non zero width\n2389         # or height.\n2390         if (isinstance(patch, mpatches.Rectangle) and\n2391                 ((not patch.get_width()) and (not patch.get_height()))):\n2392             return\n2393         p = patch.get_path()\n2394         # Get all vertices on the path\n2395         # Loop through each segment to get extrema for Bezier curve sections\n2396         vertices = []\n2397         for curve, code in p.iter_bezier(simplify=False):\n2398             # Get distance along the curve of any extrema\n2399             _, dzeros = curve.axis_aligned_extrema()\n2400             # Calculate vertices of start, end and any extrema in between\n2401             vertices.append(curve([0, *dzeros, 1]))\n2402 \n2403         if len(vertices):\n2404             vertices = np.row_stack(vertices)\n2405 \n2406         patch_trf = patch.get_transform()\n2407         updatex, updatey = patch_trf.contains_branch_seperately(self.transData)\n2408         if not (updatex or updatey):\n2409             return\n2410         if self.name != \"rectilinear\":\n2411             # As in _update_line_limits, but for axvspan.\n2412             if updatex and patch_trf == self.get_yaxis_transform():\n2413                 updatex = False\n2414             if updatey and patch_trf == self.get_xaxis_transform():\n2415                 updatey = False\n2416         trf_to_data = patch_trf - self.transData\n2417         xys = trf_to_data.transform(vertices)\n2418         self.update_datalim(xys, updatex=updatex, updatey=updatey)\n2419 \n2420     def add_table(self, tab):\n2421         \"\"\"\n2422         Add a `.Table` to the Axes; return the table.\n2423         \"\"\"\n2424         _api.check_isinstance(mtable.Table, tab=tab)\n2425         self._set_artist_props(tab)\n2426         self._children.append(tab)\n2427         if tab.get_clip_path() is None:\n2428             tab.set_clip_path(self.patch)\n2429         tab._remove_method = self._children.remove\n2430         return tab\n2431 \n2432     def add_container(self, container):\n2433         \"\"\"\n2434         Add a `.Container` to the Axes' containers; return the container.\n2435         \"\"\"\n2436         label = container.get_label()\n2437         if not label:\n2438             container.set_label('_container%d' % len(self.containers))\n2439         self.containers.append(container)\n2440         container._remove_method = self.containers.remove\n2441         return container\n2442 \n2443     def _unit_change_handler(self, axis_name, event=None):\n2444         \"\"\"\n2445         Process axis units changes: requests updates to data and view limits.\n2446         \"\"\"\n2447         if event is None:  # Allow connecting `self._unit_change_handler(name)`\n2448             return functools.partial(\n2449                 self._unit_change_handler, axis_name, event=object())\n2450         _api.check_in_list(self._axis_map, axis_name=axis_name)\n2451         for line in self.lines:\n2452             line.recache_always()\n2453         self.relim()\n2454         self._request_autoscale_view(axis_name)\n2455 \n2456     def relim(self, visible_only=False):\n2457         \"\"\"\n2458         Recompute the data limits based on current artists.\n2459 \n2460         At present, `.Collection` instances are not supported.\n2461 \n2462         Parameters\n2463         ----------\n2464         visible_only : bool, default: False\n2465             Whether to exclude invisible artists.\n2466         \"\"\"\n2467         # Collections are deliberately not supported (yet); see\n2468         # the TODO note in artists.py.\n2469         self.dataLim.ignore(True)\n2470         self.dataLim.set_points(mtransforms.Bbox.null().get_points())\n2471         self.ignore_existing_data_limits = True\n2472 \n2473         for artist in self._children:\n2474             if not visible_only or artist.get_visible():\n2475                 if isinstance(artist, mlines.Line2D):\n2476                     self._update_line_limits(artist)\n2477                 elif isinstance(artist, mpatches.Patch):\n2478                     self._update_patch_limits(artist)\n2479                 elif isinstance(artist, mimage.AxesImage):\n2480                     self._update_image_limits(artist)\n2481 \n2482     def update_datalim(self, xys, updatex=True, updatey=True):\n2483         \"\"\"\n2484         Extend the `~.Axes.dataLim` Bbox to include the given points.\n2485 \n2486         If no data is set currently, the Bbox will ignore its limits and set\n2487         the bound to be the bounds of the xydata (*xys*). Otherwise, it will\n2488         compute the bounds of the union of its current data and the data in\n2489         *xys*.\n2490 \n2491         Parameters\n2492         ----------\n2493         xys : 2D array-like\n2494             The points to include in the data limits Bbox. This can be either\n2495             a list of (x, y) tuples or a (N, 2) array.\n2496 \n2497         updatex, updatey : bool, default: True\n2498             Whether to update the x/y limits.\n2499         \"\"\"\n2500         xys = np.asarray(xys)\n2501         if not np.any(np.isfinite(xys)):\n2502             return\n2503         self.dataLim.update_from_data_xy(xys, self.ignore_existing_data_limits,\n2504                                          updatex=updatex, updatey=updatey)\n2505         self.ignore_existing_data_limits = False\n2506 \n2507     def _process_unit_info(self, datasets=None, kwargs=None, *, convert=True):\n2508         \"\"\"\n2509         Set axis units based on *datasets* and *kwargs*, and optionally apply\n2510         unit conversions to *datasets*.\n2511 \n2512         Parameters\n2513         ----------\n2514         datasets : list\n2515             List of (axis_name, dataset) pairs (where the axis name is defined\n2516             as in `._axis_map`).  Individual datasets can also be None\n2517             (which gets passed through).\n2518         kwargs : dict\n2519             Other parameters from which unit info (i.e., the *xunits*,\n2520             *yunits*, *zunits* (for 3D Axes), *runits* and *thetaunits* (for\n2521             polar) entries) is popped, if present.  Note that this dict is\n2522             mutated in-place!\n2523         convert : bool, default: True\n2524             Whether to return the original datasets or the converted ones.\n2525 \n2526         Returns\n2527         -------\n2528         list\n2529             Either the original datasets if *convert* is False, or the\n2530             converted ones if *convert* is True (the default).\n2531         \"\"\"\n2532         # The API makes datasets a list of pairs rather than an axis_name to\n2533         # dataset mapping because it is sometimes necessary to process multiple\n2534         # datasets for a single axis, and concatenating them may be tricky\n2535         # (e.g. if some are scalars, etc.).\n2536         datasets = datasets or []\n2537         kwargs = kwargs or {}\n2538         axis_map = self._axis_map\n2539         for axis_name, data in datasets:\n2540             try:\n2541                 axis = axis_map[axis_name]\n2542             except KeyError:\n2543                 raise ValueError(f\"Invalid axis name: {axis_name!r}\") from None\n2544             # Update from data if axis is already set but no unit is set yet.\n2545             if axis is not None and data is not None and not axis.have_units():\n2546                 axis.update_units(data)\n2547         for axis_name, axis in axis_map.items():\n2548             # Return if no axis is set.\n2549             if axis is None:\n2550                 continue\n2551             # Check for units in the kwargs, and if present update axis.\n2552             units = kwargs.pop(f\"{axis_name}units\", axis.units)\n2553             if self.name == \"polar\":\n2554                 # Special case: polar supports \"thetaunits\"/\"runits\".\n2555                 polar_units = {\"x\": \"thetaunits\", \"y\": \"runits\"}\n2556                 units = kwargs.pop(polar_units[axis_name], units)\n2557             if units != axis.units and units is not None:\n2558                 axis.set_units(units)\n2559                 # If the units being set imply a different converter,\n2560                 # we need to update again.\n2561                 for dataset_axis_name, data in datasets:\n2562                     if dataset_axis_name == axis_name and data is not None:\n2563                         axis.update_units(data)\n2564         return [axis_map[axis_name].convert_units(data)\n2565                 if convert and data is not None else data\n2566                 for axis_name, data in datasets]\n2567 \n2568     def in_axes(self, mouseevent):\n2569         \"\"\"\n2570         Return whether the given event (in display coords) is in the Axes.\n2571         \"\"\"\n2572         return self.patch.contains(mouseevent)[0]\n2573 \n2574     get_autoscalex_on = _axis_method_wrapper(\"xaxis\", \"_get_autoscale_on\")\n2575     get_autoscaley_on = _axis_method_wrapper(\"yaxis\", \"_get_autoscale_on\")\n2576     set_autoscalex_on = _axis_method_wrapper(\"xaxis\", \"_set_autoscale_on\")\n2577     set_autoscaley_on = _axis_method_wrapper(\"yaxis\", \"_set_autoscale_on\")\n2578 \n2579     def get_autoscale_on(self):\n2580         \"\"\"Return True if each axis is autoscaled, False otherwise.\"\"\"\n2581         return all(axis._get_autoscale_on()\n2582                    for axis in self._axis_map.values())\n2583 \n2584     def set_autoscale_on(self, b):\n2585         \"\"\"\n2586         Set whether autoscaling is applied to each axis on the next draw or\n2587         call to `.Axes.autoscale_view`.\n2588 \n2589         Parameters\n2590         ----------\n2591         b : bool\n2592         \"\"\"\n2593         for axis in self._axis_map.values():\n2594             axis._set_autoscale_on(b)\n2595 \n2596     @property\n2597     def use_sticky_edges(self):\n2598         \"\"\"\n2599         When autoscaling, whether to obey all `Artist.sticky_edges`.\n2600 \n2601         Default is ``True``.\n2602 \n2603         Setting this to ``False`` ensures that the specified margins\n2604         will be applied, even if the plot includes an image, for\n2605         example, which would otherwise force a view limit to coincide\n2606         with its data limit.\n2607 \n2608         The changing this property does not change the plot until\n2609         `autoscale` or `autoscale_view` is called.\n2610         \"\"\"\n2611         return self._use_sticky_edges\n2612 \n2613     @use_sticky_edges.setter\n2614     def use_sticky_edges(self, b):\n2615         self._use_sticky_edges = bool(b)\n2616         # No effect until next autoscaling, which will mark the Axes as stale.\n2617 \n2618     def set_xmargin(self, m):\n2619         \"\"\"\n2620         Set padding of X data limits prior to autoscaling.\n2621 \n2622         *m* times the data interval will be added to each end of that interval\n2623         before it is used in autoscaling.  If *m* is negative, this will clip\n2624         the data range instead of expanding it.\n2625 \n2626         For example, if your data is in the range [0, 2], a margin of 0.1 will\n2627         result in a range [-0.2, 2.2]; a margin of -0.1 will result in a range\n2628         of [0.2, 1.8].\n2629 \n2630         Parameters\n2631         ----------\n2632         m : float greater than -0.5\n2633         \"\"\"\n2634         if m <= -0.5:\n2635             raise ValueError(\"margin must be greater than -0.5\")\n2636         self._xmargin = m\n2637         self._request_autoscale_view(\"x\")\n2638         self.stale = True\n2639 \n2640     def set_ymargin(self, m):\n2641         \"\"\"\n2642         Set padding of Y data limits prior to autoscaling.\n2643 \n2644         *m* times the data interval will be added to each end of that interval\n2645         before it is used in autoscaling.  If *m* is negative, this will clip\n2646         the data range instead of expanding it.\n2647 \n2648         For example, if your data is in the range [0, 2], a margin of 0.1 will\n2649         result in a range [-0.2, 2.2]; a margin of -0.1 will result in a range\n2650         of [0.2, 1.8].\n2651 \n2652         Parameters\n2653         ----------\n2654         m : float greater than -0.5\n2655         \"\"\"\n2656         if m <= -0.5:\n2657             raise ValueError(\"margin must be greater than -0.5\")\n2658         self._ymargin = m\n2659         self._request_autoscale_view(\"y\")\n2660         self.stale = True\n2661 \n2662     def margins(self, *margins, x=None, y=None, tight=True):\n2663         \"\"\"\n2664         Set or retrieve autoscaling margins.\n2665 \n2666         The padding added to each limit of the Axes is the *margin*\n2667         times the data interval. All input parameters must be floats\n2668         within the range [0, 1]. Passing both positional and keyword\n2669         arguments is invalid and will raise a TypeError. If no\n2670         arguments (positional or otherwise) are provided, the current\n2671         margins will remain in place and simply be returned.\n2672 \n2673         Specifying any margin changes only the autoscaling; for example,\n2674         if *xmargin* is not None, then *xmargin* times the X data\n2675         interval will be added to each end of that interval before\n2676         it is used in autoscaling.\n2677 \n2678         Parameters\n2679         ----------\n2680         *margins : float, optional\n2681             If a single positional argument is provided, it specifies\n2682             both margins of the x-axis and y-axis limits. If two\n2683             positional arguments are provided, they will be interpreted\n2684             as *xmargin*, *ymargin*. If setting the margin on a single\n2685             axis is desired, use the keyword arguments described below.\n2686 \n2687         x, y : float, optional\n2688             Specific margin values for the x-axis and y-axis,\n2689             respectively. These cannot be used with positional\n2690             arguments, but can be used individually to alter on e.g.,\n2691             only the y-axis.\n2692 \n2693         tight : bool or None, default: True\n2694             The *tight* parameter is passed to `~.axes.Axes.autoscale_view`,\n2695             which is executed after a margin is changed; the default\n2696             here is *True*, on the assumption that when margins are\n2697             specified, no additional padding to match tick marks is\n2698             usually desired.  Setting *tight* to *None* preserves\n2699             the previous setting.\n2700 \n2701         Returns\n2702         -------\n2703         xmargin, ymargin : float\n2704 \n2705         Notes\n2706         -----\n2707         If a previously used Axes method such as :meth:`pcolor` has set\n2708         :attr:`use_sticky_edges` to `True`, only the limits not set by\n2709         the \"sticky artists\" will be modified. To force all of the\n2710         margins to be set, set :attr:`use_sticky_edges` to `False`\n2711         before calling :meth:`margins`.\n2712         \"\"\"\n2713 \n2714         if margins and (x is not None or y is not None):\n2715             raise TypeError('Cannot pass both positional and keyword '\n2716                             'arguments for x and/or y.')\n2717         elif len(margins) == 1:\n2718             x = y = margins[0]\n2719         elif len(margins) == 2:\n2720             x, y = margins\n2721         elif margins:\n2722             raise TypeError('Must pass a single positional argument for all '\n2723                             'margins, or one for each margin (x, y).')\n2724 \n2725         if x is None and y is None:\n2726             if tight is not True:\n2727                 _api.warn_external(f'ignoring tight={tight!r} in get mode')\n2728             return self._xmargin, self._ymargin\n2729 \n2730         if tight is not None:\n2731             self._tight = tight\n2732         if x is not None:\n2733             self.set_xmargin(x)\n2734         if y is not None:\n2735             self.set_ymargin(y)\n2736 \n2737     def set_rasterization_zorder(self, z):\n2738         \"\"\"\n2739         Set the zorder threshold for rasterization for vector graphics output.\n2740 \n2741         All artists with a zorder below the given value will be rasterized if\n2742         they support rasterization.\n2743 \n2744         This setting is ignored for pixel-based output.\n2745 \n2746         See also :doc:`/gallery/misc/rasterization_demo`.\n2747 \n2748         Parameters\n2749         ----------\n2750         z : float or None\n2751             The zorder below which artists are rasterized.\n2752             If ``None`` rasterization based on zorder is deactivated.\n2753         \"\"\"\n2754         self._rasterization_zorder = z\n2755         self.stale = True\n2756 \n2757     def get_rasterization_zorder(self):\n2758         \"\"\"Return the zorder value below which artists will be rasterized.\"\"\"\n2759         return self._rasterization_zorder\n2760 \n2761     def autoscale(self, enable=True, axis='both', tight=None):\n2762         \"\"\"\n2763         Autoscale the axis view to the data (toggle).\n2764 \n2765         Convenience method for simple axis view autoscaling.\n2766         It turns autoscaling on or off, and then,\n2767         if autoscaling for either axis is on, it performs\n2768         the autoscaling on the specified axis or Axes.\n2769 \n2770         Parameters\n2771         ----------\n2772         enable : bool or None, default: True\n2773             True turns autoscaling on, False turns it off.\n2774             None leaves the autoscaling state unchanged.\n2775         axis : {'both', 'x', 'y'}, default: 'both'\n2776             The axis on which to operate.  (For 3D Axes, *axis* can also be set\n2777             to 'z', and 'both' refers to all three axes.)\n2778         tight : bool or None, default: None\n2779             If True, first set the margins to zero.  Then, this argument is\n2780             forwarded to `~.axes.Axes.autoscale_view` (regardless of\n2781             its value); see the description of its behavior there.\n2782         \"\"\"\n2783         if enable is None:\n2784             scalex = True\n2785             scaley = True\n2786         else:\n2787             if axis in ['x', 'both']:\n2788                 self.set_autoscalex_on(bool(enable))\n2789                 scalex = self.get_autoscalex_on()\n2790             else:\n2791                 scalex = False\n2792             if axis in ['y', 'both']:\n2793                 self.set_autoscaley_on(bool(enable))\n2794                 scaley = self.get_autoscaley_on()\n2795             else:\n2796                 scaley = False\n2797         if tight and scalex:\n2798             self._xmargin = 0\n2799         if tight and scaley:\n2800             self._ymargin = 0\n2801         if scalex:\n2802             self._request_autoscale_view(\"x\", tight=tight)\n2803         if scaley:\n2804             self._request_autoscale_view(\"y\", tight=tight)\n2805 \n2806     def autoscale_view(self, tight=None, scalex=True, scaley=True):\n2807         \"\"\"\n2808         Autoscale the view limits using the data limits.\n2809 \n2810         Parameters\n2811         ----------\n2812         tight : bool or None\n2813             If *True*, only expand the axis limits using the margins.  Note\n2814             that unlike for `autoscale`, ``tight=True`` does *not* set the\n2815             margins to zero.\n2816 \n2817             If *False* and :rc:`axes.autolimit_mode` is 'round_numbers', then\n2818             after expansion by the margins, further expand the axis limits\n2819             using the axis major locator.\n2820 \n2821             If None (the default), reuse the value set in the previous call to\n2822             `autoscale_view` (the initial value is False, but the default style\n2823             sets :rc:`axes.autolimit_mode` to 'data', in which case this\n2824             behaves like True).\n2825 \n2826         scalex : bool, default: True\n2827             Whether to autoscale the x-axis.\n2828 \n2829         scaley : bool, default: True\n2830             Whether to autoscale the y-axis.\n2831 \n2832         Notes\n2833         -----\n2834         The autoscaling preserves any preexisting axis direction reversal.\n2835 \n2836         The data limits are not updated automatically when artist data are\n2837         changed after the artist has been added to an Axes instance.  In that\n2838         case, use :meth:`matplotlib.axes.Axes.relim` prior to calling\n2839         autoscale_view.\n2840 \n2841         If the views of the Axes are fixed, e.g. via `set_xlim`, they will\n2842         not be changed by autoscale_view().\n2843         See :meth:`matplotlib.axes.Axes.autoscale` for an alternative.\n2844         \"\"\"\n2845         if tight is not None:\n2846             self._tight = bool(tight)\n2847 \n2848         x_stickies = y_stickies = np.array([])\n2849         if self.use_sticky_edges:\n2850             if self._xmargin and scalex and self.get_autoscalex_on():\n2851                 x_stickies = np.sort(np.concatenate([\n2852                     artist.sticky_edges.x\n2853                     for ax in self._shared_axes[\"x\"].get_siblings(self)\n2854                     for artist in ax.get_children()]))\n2855             if self._ymargin and scaley and self.get_autoscaley_on():\n2856                 y_stickies = np.sort(np.concatenate([\n2857                     artist.sticky_edges.y\n2858                     for ax in self._shared_axes[\"y\"].get_siblings(self)\n2859                     for artist in ax.get_children()]))\n2860         if self.get_xscale() == 'log':\n2861             x_stickies = x_stickies[x_stickies > 0]\n2862         if self.get_yscale() == 'log':\n2863             y_stickies = y_stickies[y_stickies > 0]\n2864 \n2865         def handle_single_axis(\n2866                 scale, shared_axes, name, axis, margin, stickies, set_bound):\n2867 \n2868             if not (scale and axis._get_autoscale_on()):\n2869                 return  # nothing to do...\n2870 \n2871             shared = shared_axes.get_siblings(self)\n2872             # Base autoscaling on finite data limits when there is at least one\n2873             # finite data limit among all the shared_axes and intervals.\n2874             values = [val for ax in shared\n2875                       for val in getattr(ax.dataLim, f\"interval{name}\")\n2876                       if np.isfinite(val)]\n2877             if values:\n2878                 x0, x1 = (min(values), max(values))\n2879             elif getattr(self._viewLim, f\"mutated{name}\")():\n2880                 # No data, but explicit viewLims already set:\n2881                 # in mutatedx or mutatedy.\n2882                 return\n2883             else:\n2884                 x0, x1 = (-np.inf, np.inf)\n2885             # If x0 and x1 are nonfinite, get default limits from the locator.\n2886             locator = axis.get_major_locator()\n2887             x0, x1 = locator.nonsingular(x0, x1)\n2888             # Find the minimum minpos for use in the margin calculation.\n2889             minimum_minpos = min(\n2890                 getattr(ax.dataLim, f\"minpos{name}\") for ax in shared)\n2891 \n2892             # Prevent margin addition from crossing a sticky value.  A small\n2893             # tolerance must be added due to floating point issues with\n2894             # streamplot; it is defined relative to x0, x1, x1-x0 but has\n2895             # no absolute term (e.g. \"+1e-8\") to avoid issues when working with\n2896             # datasets where all values are tiny (less than 1e-8).\n2897             tol = 1e-5 * max(abs(x0), abs(x1), abs(x1 - x0))\n2898             # Index of largest element < x0 + tol, if any.\n2899             i0 = stickies.searchsorted(x0 + tol) - 1\n2900             x0bound = stickies[i0] if i0 != -1 else None\n2901             # Index of smallest element > x1 - tol, if any.\n2902             i1 = stickies.searchsorted(x1 - tol)\n2903             x1bound = stickies[i1] if i1 != len(stickies) else None\n2904 \n2905             # Add the margin in figure space and then transform back, to handle\n2906             # non-linear scales.\n2907             transform = axis.get_transform()\n2908             inverse_trans = transform.inverted()\n2909             x0, x1 = axis._scale.limit_range_for_scale(x0, x1, minimum_minpos)\n2910             x0t, x1t = transform.transform([x0, x1])\n2911             delta = (x1t - x0t) * margin\n2912             if not np.isfinite(delta):\n2913                 delta = 0  # If a bound isn't finite, set margin to zero.\n2914             x0, x1 = inverse_trans.transform([x0t - delta, x1t + delta])\n2915 \n2916             # Apply sticky bounds.\n2917             if x0bound is not None:\n2918                 x0 = max(x0, x0bound)\n2919             if x1bound is not None:\n2920                 x1 = min(x1, x1bound)\n2921 \n2922             if not self._tight:\n2923                 x0, x1 = locator.view_limits(x0, x1)\n2924             set_bound(x0, x1)\n2925             # End of definition of internal function 'handle_single_axis'.\n2926 \n2927         handle_single_axis(\n2928             scalex, self._shared_axes[\"x\"], 'x', self.xaxis, self._xmargin,\n2929             x_stickies, self.set_xbound)\n2930         handle_single_axis(\n2931             scaley, self._shared_axes[\"y\"], 'y', self.yaxis, self._ymargin,\n2932             y_stickies, self.set_ybound)\n2933 \n2934     def _update_title_position(self, renderer):\n2935         \"\"\"\n2936         Update the title position based on the bounding box enclosing\n2937         all the ticklabels and x-axis spine and xlabel...\n2938         \"\"\"\n2939         if self._autotitlepos is not None and not self._autotitlepos:\n2940             _log.debug('title position was updated manually, not adjusting')\n2941             return\n2942 \n2943         titles = (self.title, self._left_title, self._right_title)\n2944 \n2945         # Need to check all our twins too, and all the children as well.\n2946         axs = self._twinned_axes.get_siblings(self) + self.child_axes\n2947         for ax in self.child_axes:  # Child positions must be updated first.\n2948             locator = ax.get_axes_locator()\n2949             ax.apply_aspect(locator(self, renderer) if locator else None)\n2950 \n2951         for title in titles:\n2952             x, _ = title.get_position()\n2953             # need to start again in case of window resizing\n2954             title.set_position((x, 1.0))\n2955             top = -np.inf\n2956             for ax in axs:\n2957                 bb = None\n2958                 if (ax.xaxis.get_ticks_position() in ['top', 'unknown']\n2959                         or ax.xaxis.get_label_position() == 'top'):\n2960                     bb = ax.xaxis.get_tightbbox(renderer)\n2961                 if bb is None:\n2962                     if 'outline' in ax.spines:\n2963                         # Special case for colorbars:\n2964                         bb = ax.spines['outline'].get_window_extent()\n2965                     else:\n2966                         bb = ax.get_window_extent(renderer)\n2967                 top = max(top, bb.ymax)\n2968                 if title.get_text():\n2969                     ax.yaxis.get_tightbbox(renderer)  # update offsetText\n2970                     if ax.yaxis.offsetText.get_text():\n2971                         bb = ax.yaxis.offsetText.get_tightbbox(renderer)\n2972                         if bb.intersection(title.get_tightbbox(renderer), bb):\n2973                             top = bb.ymax\n2974             if top < 0:\n2975                 # the top of Axes is not even on the figure, so don't try and\n2976                 # automatically place it.\n2977                 _log.debug('top of Axes not in the figure, so title not moved')\n2978                 return\n2979             if title.get_window_extent(renderer).ymin < top:\n2980                 _, y = self.transAxes.inverted().transform((0, top))\n2981                 title.set_position((x, y))\n2982                 # empirically, this doesn't always get the min to top,\n2983                 # so we need to adjust again.\n2984                 if title.get_window_extent(renderer).ymin < top:\n2985                     _, y = self.transAxes.inverted().transform(\n2986                         (0., 2 * top - title.get_window_extent(renderer).ymin))\n2987                     title.set_position((x, y))\n2988 \n2989         ymax = max(title.get_position()[1] for title in titles)\n2990         for title in titles:\n2991             # now line up all the titles at the highest baseline.\n2992             x, _ = title.get_position()\n2993             title.set_position((x, ymax))\n2994 \n2995     # Drawing\n2996     @martist.allow_rasterization\n2997     def draw(self, renderer):\n2998         # docstring inherited\n2999         if renderer is None:\n3000             raise RuntimeError('No renderer defined')\n3001         if not self.get_visible():\n3002             return\n3003         self._unstale_viewLim()\n3004 \n3005         renderer.open_group('axes', gid=self.get_gid())\n3006 \n3007         # prevent triggering call backs during the draw process\n3008         self._stale = True\n3009 \n3010         # loop over self and child Axes...\n3011         locator = self.get_axes_locator()\n3012         self.apply_aspect(locator(self, renderer) if locator else None)\n3013 \n3014         artists = self.get_children()\n3015         artists.remove(self.patch)\n3016 \n3017         # the frame draws the edges around the Axes patch -- we\n3018         # decouple these so the patch can be in the background and the\n3019         # frame in the foreground. Do this before drawing the axis\n3020         # objects so that the spine has the opportunity to update them.\n3021         if not (self.axison and self._frameon):\n3022             for spine in self.spines.values():\n3023                 artists.remove(spine)\n3024 \n3025         self._update_title_position(renderer)\n3026 \n3027         if not self.axison:\n3028             for _axis in self._axis_map.values():\n3029                 artists.remove(_axis)\n3030 \n3031         if not self.figure.canvas.is_saving():\n3032             artists = [\n3033                 a for a in artists\n3034                 if not a.get_animated() or isinstance(a, mimage.AxesImage)]\n3035         artists = sorted(artists, key=attrgetter('zorder'))\n3036 \n3037         # rasterize artists with negative zorder\n3038         # if the minimum zorder is negative, start rasterization\n3039         rasterization_zorder = self._rasterization_zorder\n3040 \n3041         if (rasterization_zorder is not None and\n3042                 artists and artists[0].zorder < rasterization_zorder):\n3043             split_index = np.searchsorted(\n3044                 [art.zorder for art in artists],\n3045                 rasterization_zorder, side='right'\n3046             )\n3047             artists_rasterized = artists[:split_index]\n3048             artists = artists[split_index:]\n3049         else:\n3050             artists_rasterized = []\n3051 \n3052         if self.axison and self._frameon:\n3053             if artists_rasterized:\n3054                 artists_rasterized = [self.patch] + artists_rasterized\n3055             else:\n3056                 artists = [self.patch] + artists\n3057 \n3058         if artists_rasterized:\n3059             _draw_rasterized(self.figure, artists_rasterized, renderer)\n3060 \n3061         mimage._draw_list_compositing_images(\n3062             renderer, self, artists, self.figure.suppressComposite)\n3063 \n3064         renderer.close_group('axes')\n3065         self.stale = False\n3066 \n3067     def draw_artist(self, a):\n3068         \"\"\"\n3069         Efficiently redraw a single artist.\n3070         \"\"\"\n3071         a.draw(self.figure.canvas.get_renderer())\n3072 \n3073     def redraw_in_frame(self):\n3074         \"\"\"\n3075         Efficiently redraw Axes data, but not axis ticks, labels, etc.\n3076         \"\"\"\n3077         with ExitStack() as stack:\n3078             for artist in [*self._axis_map.values(),\n3079                            self.title, self._left_title, self._right_title]:\n3080                 stack.enter_context(artist._cm_set(visible=False))\n3081             self.draw(self.figure.canvas.get_renderer())\n3082 \n3083     # Axes rectangle characteristics\n3084 \n3085     def get_frame_on(self):\n3086         \"\"\"Get whether the Axes rectangle patch is drawn.\"\"\"\n3087         return self._frameon\n3088 \n3089     def set_frame_on(self, b):\n3090         \"\"\"\n3091         Set whether the Axes rectangle patch is drawn.\n3092 \n3093         Parameters\n3094         ----------\n3095         b : bool\n3096         \"\"\"\n3097         self._frameon = b\n3098         self.stale = True\n3099 \n3100     def get_axisbelow(self):\n3101         \"\"\"\n3102         Get whether axis ticks and gridlines are above or below most artists.\n3103 \n3104         Returns\n3105         -------\n3106         bool or 'line'\n3107 \n3108         See Also\n3109         --------\n3110         set_axisbelow\n3111         \"\"\"\n3112         return self._axisbelow\n3113 \n3114     def set_axisbelow(self, b):\n3115         \"\"\"\n3116         Set whether axis ticks and gridlines are above or below most artists.\n3117 \n3118         This controls the zorder of the ticks and gridlines. For more\n3119         information on the zorder see :doc:`/gallery/misc/zorder_demo`.\n3120 \n3121         Parameters\n3122         ----------\n3123         b : bool or 'line'\n3124             Possible values:\n3125 \n3126             - *True* (zorder = 0.5): Ticks and gridlines are below all Artists.\n3127             - 'line' (zorder = 1.5): Ticks and gridlines are above patches\n3128               (e.g. rectangles, with default zorder = 1) but still below lines\n3129               and markers (with their default zorder = 2).\n3130             - *False* (zorder = 2.5): Ticks and gridlines are above patches\n3131               and lines / markers.\n3132 \n3133         See Also\n3134         --------\n3135         get_axisbelow\n3136         \"\"\"\n3137         # Check that b is True, False or 'line'\n3138         self._axisbelow = axisbelow = validate_axisbelow(b)\n3139         zorder = {\n3140             True: 0.5,\n3141             'line': 1.5,\n3142             False: 2.5,\n3143         }[axisbelow]\n3144         for axis in self._axis_map.values():\n3145             axis.set_zorder(zorder)\n3146         self.stale = True\n3147 \n3148     @_docstring.dedent_interpd\n3149     def grid(self, visible=None, which='major', axis='both', **kwargs):\n3150         \"\"\"\n3151         Configure the grid lines.\n3152 \n3153         Parameters\n3154         ----------\n3155         visible : bool or None, optional\n3156             Whether to show the grid lines.  If any *kwargs* are supplied, it\n3157             is assumed you want the grid on and *visible* will be set to True.\n3158 \n3159             If *visible* is *None* and there are no *kwargs*, this toggles the\n3160             visibility of the lines.\n3161 \n3162         which : {'major', 'minor', 'both'}, optional\n3163             The grid lines to apply the changes on.\n3164 \n3165         axis : {'both', 'x', 'y'}, optional\n3166             The axis to apply the changes on.\n3167 \n3168         **kwargs : `.Line2D` properties\n3169             Define the line properties of the grid, e.g.::\n3170 \n3171                 grid(color='r', linestyle='-', linewidth=2)\n3172 \n3173             Valid keyword arguments are:\n3174 \n3175             %(Line2D:kwdoc)s\n3176 \n3177         Notes\n3178         -----\n3179         The axis is drawn as a unit, so the effective zorder for drawing the\n3180         grid is determined by the zorder of each axis, not by the zorder of the\n3181         `.Line2D` objects comprising the grid.  Therefore, to set grid zorder,\n3182         use `.set_axisbelow` or, for more control, call the\n3183         `~.Artist.set_zorder` method of each axis.\n3184         \"\"\"\n3185         _api.check_in_list(['x', 'y', 'both'], axis=axis)\n3186         if axis in ['x', 'both']:\n3187             self.xaxis.grid(visible, which=which, **kwargs)\n3188         if axis in ['y', 'both']:\n3189             self.yaxis.grid(visible, which=which, **kwargs)\n3190 \n3191     def ticklabel_format(self, *, axis='both', style='', scilimits=None,\n3192                          useOffset=None, useLocale=None, useMathText=None):\n3193         r\"\"\"\n3194         Configure the `.ScalarFormatter` used by default for linear Axes.\n3195 \n3196         If a parameter is not set, the corresponding property of the formatter\n3197         is left unchanged.\n3198 \n3199         Parameters\n3200         ----------\n3201         axis : {'x', 'y', 'both'}, default: 'both'\n3202             The axis to configure.  Only major ticks are affected.\n3203 \n3204         style : {'sci', 'scientific', 'plain'}\n3205             Whether to use scientific notation.\n3206             The formatter default is to use scientific notation.\n3207 \n3208         scilimits : pair of ints (m, n)\n3209             Scientific notation is used only for numbers outside the range\n3210             10\\ :sup:`m` to 10\\ :sup:`n` (and only if the formatter is\n3211             configured to use scientific notation at all).  Use (0, 0) to\n3212             include all numbers.  Use (m, m) where m != 0 to fix the order of\n3213             magnitude to 10\\ :sup:`m`.\n3214             The formatter default is :rc:`axes.formatter.limits`.\n3215 \n3216         useOffset : bool or float\n3217             If True, the offset is calculated as needed.\n3218             If False, no offset is used.\n3219             If a numeric value, it sets the offset.\n3220             The formatter default is :rc:`axes.formatter.useoffset`.\n3221 \n3222         useLocale : bool\n3223             Whether to format the number using the current locale or using the\n3224             C (English) locale.  This affects e.g. the decimal separator.  The\n3225             formatter default is :rc:`axes.formatter.use_locale`.\n3226 \n3227         useMathText : bool\n3228             Render the offset and scientific notation in mathtext.\n3229             The formatter default is :rc:`axes.formatter.use_mathtext`.\n3230 \n3231         Raises\n3232         ------\n3233         AttributeError\n3234             If the current formatter is not a `.ScalarFormatter`.\n3235         \"\"\"\n3236         style = style.lower()\n3237         axis = axis.lower()\n3238         if scilimits is not None:\n3239             try:\n3240                 m, n = scilimits\n3241                 m + n + 1  # check that both are numbers\n3242             except (ValueError, TypeError) as err:\n3243                 raise ValueError(\"scilimits must be a sequence of 2 integers\"\n3244                                  ) from err\n3245         STYLES = {'sci': True, 'scientific': True, 'plain': False, '': None}\n3246         is_sci_style = _api.check_getitem(STYLES, style=style)\n3247         axis_map = {**{k: [v] for k, v in self._axis_map.items()},\n3248                     'both': list(self._axis_map.values())}\n3249         axises = _api.check_getitem(axis_map, axis=axis)\n3250         try:\n3251             for axis in axises:\n3252                 if is_sci_style is not None:\n3253                     axis.major.formatter.set_scientific(is_sci_style)\n3254                 if scilimits is not None:\n3255                     axis.major.formatter.set_powerlimits(scilimits)\n3256                 if useOffset is not None:\n3257                     axis.major.formatter.set_useOffset(useOffset)\n3258                 if useLocale is not None:\n3259                     axis.major.formatter.set_useLocale(useLocale)\n3260                 if useMathText is not None:\n3261                     axis.major.formatter.set_useMathText(useMathText)\n3262         except AttributeError as err:\n3263             raise AttributeError(\n3264                 \"This method only works with the ScalarFormatter\") from err\n3265 \n3266     def locator_params(self, axis='both', tight=None, **kwargs):\n3267         \"\"\"\n3268         Control behavior of major tick locators.\n3269 \n3270         Because the locator is involved in autoscaling, `~.Axes.autoscale_view`\n3271         is called automatically after the parameters are changed.\n3272 \n3273         Parameters\n3274         ----------\n3275         axis : {'both', 'x', 'y'}, default: 'both'\n3276             The axis on which to operate.  (For 3D Axes, *axis* can also be\n3277             set to 'z', and 'both' refers to all three axes.)\n3278         tight : bool or None, optional\n3279             Parameter passed to `~.Axes.autoscale_view`.\n3280             Default is None, for no change.\n3281 \n3282         Other Parameters\n3283         ----------------\n3284         **kwargs\n3285             Remaining keyword arguments are passed to directly to the\n3286             ``set_params()`` method of the locator. Supported keywords depend\n3287             on the type of the locator. See for example\n3288             `~.ticker.MaxNLocator.set_params` for the `.ticker.MaxNLocator`\n3289             used by default for linear.\n3290 \n3291         Examples\n3292         --------\n3293         When plotting small subplots, one might want to reduce the maximum\n3294         number of ticks and use tight bounds, for example::\n3295 \n3296             ax.locator_params(tight=True, nbins=4)\n3297 \n3298         \"\"\"\n3299         _api.check_in_list([*self._axis_names, \"both\"], axis=axis)\n3300         for name in self._axis_names:\n3301             if axis in [name, \"both\"]:\n3302                 loc = self._axis_map[name].get_major_locator()\n3303                 loc.set_params(**kwargs)\n3304                 self._request_autoscale_view(name, tight=tight)\n3305         self.stale = True\n3306 \n3307     def tick_params(self, axis='both', **kwargs):\n3308         \"\"\"\n3309         Change the appearance of ticks, tick labels, and gridlines.\n3310 \n3311         Tick properties that are not explicitly set using the keyword\n3312         arguments remain unchanged unless *reset* is True. For the current\n3313         style settings, see `.Axis.get_tick_params`.\n3314 \n3315         Parameters\n3316         ----------\n3317         axis : {'x', 'y', 'both'}, default: 'both'\n3318             The axis to which the parameters are applied.\n3319         which : {'major', 'minor', 'both'}, default: 'major'\n3320             The group of ticks to which the parameters are applied.\n3321         reset : bool, default: False\n3322             Whether to reset the ticks to defaults before updating them.\n3323 \n3324         Other Parameters\n3325         ----------------\n3326         direction : {'in', 'out', 'inout'}\n3327             Puts ticks inside the Axes, outside the Axes, or both.\n3328         length : float\n3329             Tick length in points.\n3330         width : float\n3331             Tick width in points.\n3332         color : color\n3333             Tick color.\n3334         pad : float\n3335             Distance in points between tick and label.\n3336         labelsize : float or str\n3337             Tick label font size in points or as a string (e.g., 'large').\n3338         labelcolor : color\n3339             Tick label color.\n3340         colors : color\n3341             Tick color and label color.\n3342         zorder : float\n3343             Tick and label zorder.\n3344         bottom, top, left, right : bool\n3345             Whether to draw the respective ticks.\n3346         labelbottom, labeltop, labelleft, labelright : bool\n3347             Whether to draw the respective tick labels.\n3348         labelrotation : float\n3349             Tick label rotation\n3350         grid_color : color\n3351             Gridline color.\n3352         grid_alpha : float\n3353             Transparency of gridlines: 0 (transparent) to 1 (opaque).\n3354         grid_linewidth : float\n3355             Width of gridlines in points.\n3356         grid_linestyle : str\n3357             Any valid `.Line2D` line style spec.\n3358 \n3359         Examples\n3360         --------\n3361         ::\n3362 \n3363             ax.tick_params(direction='out', length=6, width=2, colors='r',\n3364                            grid_color='r', grid_alpha=0.5)\n3365 \n3366         This will make all major ticks be red, pointing out of the box,\n3367         and with dimensions 6 points by 2 points.  Tick labels will\n3368         also be red.  Gridlines will be red and translucent.\n3369 \n3370         \"\"\"\n3371         _api.check_in_list(['x', 'y', 'both'], axis=axis)\n3372         if axis in ['x', 'both']:\n3373             xkw = dict(kwargs)\n3374             xkw.pop('left', None)\n3375             xkw.pop('right', None)\n3376             xkw.pop('labelleft', None)\n3377             xkw.pop('labelright', None)\n3378             self.xaxis.set_tick_params(**xkw)\n3379         if axis in ['y', 'both']:\n3380             ykw = dict(kwargs)\n3381             ykw.pop('top', None)\n3382             ykw.pop('bottom', None)\n3383             ykw.pop('labeltop', None)\n3384             ykw.pop('labelbottom', None)\n3385             self.yaxis.set_tick_params(**ykw)\n3386 \n3387     def set_axis_off(self):\n3388         \"\"\"\n3389         Turn the x- and y-axis off.\n3390 \n3391         This affects the axis lines, ticks, ticklabels, grid and axis labels.\n3392         \"\"\"\n3393         self.axison = False\n3394         self.stale = True\n3395 \n3396     def set_axis_on(self):\n3397         \"\"\"\n3398         Turn the x- and y-axis on.\n3399 \n3400         This affects the axis lines, ticks, ticklabels, grid and axis labels.\n3401         \"\"\"\n3402         self.axison = True\n3403         self.stale = True\n3404 \n3405     # data limits, ticks, tick labels, and formatting\n3406 \n3407     def get_xlabel(self):\n3408         \"\"\"\n3409         Get the xlabel text string.\n3410         \"\"\"\n3411         label = self.xaxis.get_label()\n3412         return label.get_text()\n3413 \n3414     def set_xlabel(self, xlabel, fontdict=None, labelpad=None, *,\n3415                    loc=None, **kwargs):\n3416         \"\"\"\n3417         Set the label for the x-axis.\n3418 \n3419         Parameters\n3420         ----------\n3421         xlabel : str\n3422             The label text.\n3423 \n3424         labelpad : float, default: :rc:`axes.labelpad`\n3425             Spacing in points from the Axes bounding box including ticks\n3426             and tick labels.  If None, the previous value is left as is.\n3427 \n3428         loc : {'left', 'center', 'right'}, default: :rc:`xaxis.labellocation`\n3429             The label position. This is a high-level alternative for passing\n3430             parameters *x* and *horizontalalignment*.\n3431 \n3432         Other Parameters\n3433         ----------------\n3434         **kwargs : `.Text` properties\n3435             `.Text` properties control the appearance of the label.\n3436 \n3437         See Also\n3438         --------\n3439         text : Documents the properties supported by `.Text`.\n3440         \"\"\"\n3441         if labelpad is not None:\n3442             self.xaxis.labelpad = labelpad\n3443         protected_kw = ['x', 'horizontalalignment', 'ha']\n3444         if {*kwargs} & {*protected_kw}:\n3445             if loc is not None:\n3446                 raise TypeError(f\"Specifying 'loc' is disallowed when any of \"\n3447                                 f\"its corresponding low level keyword \"\n3448                                 f\"arguments ({protected_kw}) are also \"\n3449                                 f\"supplied\")\n3450 \n3451         else:\n3452             loc = (loc if loc is not None\n3453                    else mpl.rcParams['xaxis.labellocation'])\n3454             _api.check_in_list(('left', 'center', 'right'), loc=loc)\n3455 \n3456             x = {\n3457                 'left': 0,\n3458                 'center': 0.5,\n3459                 'right': 1,\n3460             }[loc]\n3461             kwargs.update(x=x, horizontalalignment=loc)\n3462 \n3463         return self.xaxis.set_label_text(xlabel, fontdict, **kwargs)\n3464 \n3465     def invert_xaxis(self):\n3466         \"\"\"\n3467         Invert the x-axis.\n3468 \n3469         See Also\n3470         --------\n3471         xaxis_inverted\n3472         get_xlim, set_xlim\n3473         get_xbound, set_xbound\n3474         \"\"\"\n3475         self.xaxis.set_inverted(not self.xaxis.get_inverted())\n3476 \n3477     xaxis_inverted = _axis_method_wrapper(\"xaxis\", \"get_inverted\")\n3478 \n3479     def get_xbound(self):\n3480         \"\"\"\n3481         Return the lower and upper x-axis bounds, in increasing order.\n3482 \n3483         See Also\n3484         --------\n3485         set_xbound\n3486         get_xlim, set_xlim\n3487         invert_xaxis, xaxis_inverted\n3488         \"\"\"\n3489         left, right = self.get_xlim()\n3490         if left < right:\n3491             return left, right\n3492         else:\n3493             return right, left\n3494 \n3495     def set_xbound(self, lower=None, upper=None):\n3496         \"\"\"\n3497         Set the lower and upper numerical bounds of the x-axis.\n3498 \n3499         This method will honor axis inversion regardless of parameter order.\n3500         It will not change the autoscaling setting (`.get_autoscalex_on()`).\n3501 \n3502         Parameters\n3503         ----------\n3504         lower, upper : float or None\n3505             The lower and upper bounds. If *None*, the respective axis bound\n3506             is not modified.\n3507 \n3508         See Also\n3509         --------\n3510         get_xbound\n3511         get_xlim, set_xlim\n3512         invert_xaxis, xaxis_inverted\n3513         \"\"\"\n3514         if upper is None and np.iterable(lower):\n3515             lower, upper = lower\n3516 \n3517         old_lower, old_upper = self.get_xbound()\n3518         if lower is None:\n3519             lower = old_lower\n3520         if upper is None:\n3521             upper = old_upper\n3522 \n3523         self.set_xlim(sorted((lower, upper),\n3524                              reverse=bool(self.xaxis_inverted())),\n3525                       auto=None)\n3526 \n3527     def get_xlim(self):\n3528         \"\"\"\n3529         Return the x-axis view limits.\n3530 \n3531         Returns\n3532         -------\n3533         left, right : (float, float)\n3534             The current x-axis limits in data coordinates.\n3535 \n3536         See Also\n3537         --------\n3538         .Axes.set_xlim\n3539         set_xbound, get_xbound\n3540         invert_xaxis, xaxis_inverted\n3541 \n3542         Notes\n3543         -----\n3544         The x-axis may be inverted, in which case the *left* value will\n3545         be greater than the *right* value.\n3546         \"\"\"\n3547         return tuple(self.viewLim.intervalx)\n3548 \n3549     def _validate_converted_limits(self, limit, convert):\n3550         \"\"\"\n3551         Raise ValueError if converted limits are non-finite.\n3552 \n3553         Note that this function also accepts None as a limit argument.\n3554 \n3555         Returns\n3556         -------\n3557         The limit value after call to convert(), or None if limit is None.\n3558         \"\"\"\n3559         if limit is not None:\n3560             converted_limit = convert(limit)\n3561             if (isinstance(converted_limit, Real)\n3562                     and not np.isfinite(converted_limit)):\n3563                 raise ValueError(\"Axis limits cannot be NaN or Inf\")\n3564             return converted_limit\n3565 \n3566     def set_xlim(self, left=None, right=None, *, emit=True, auto=False,\n3567                  xmin=None, xmax=None):\n3568         \"\"\"\n3569         Set the x-axis view limits.\n3570 \n3571         Parameters\n3572         ----------\n3573         left : float, optional\n3574             The left xlim in data coordinates. Passing *None* leaves the\n3575             limit unchanged.\n3576 \n3577             The left and right xlims may also be passed as the tuple\n3578             (*left*, *right*) as the first positional argument (or as\n3579             the *left* keyword argument).\n3580 \n3581             .. ACCEPTS: (bottom: float, top: float)\n3582 \n3583         right : float, optional\n3584             The right xlim in data coordinates. Passing *None* leaves the\n3585             limit unchanged.\n3586 \n3587         emit : bool, default: True\n3588             Whether to notify observers of limit change.\n3589 \n3590         auto : bool or None, default: False\n3591             Whether to turn on autoscaling of the x-axis. True turns on,\n3592             False turns off, None leaves unchanged.\n3593 \n3594         xmin, xmax : float, optional\n3595             They are equivalent to left and right respectively, and it is an\n3596             error to pass both *xmin* and *left* or *xmax* and *right*.\n3597 \n3598         Returns\n3599         -------\n3600         left, right : (float, float)\n3601             The new x-axis limits in data coordinates.\n3602 \n3603         See Also\n3604         --------\n3605         get_xlim\n3606         set_xbound, get_xbound\n3607         invert_xaxis, xaxis_inverted\n3608 \n3609         Notes\n3610         -----\n3611         The *left* value may be greater than the *right* value, in which\n3612         case the x-axis values will decrease from left to right.\n3613 \n3614         Examples\n3615         --------\n3616         >>> set_xlim(left, right)\n3617         >>> set_xlim((left, right))\n3618         >>> left, right = set_xlim(left, right)\n3619 \n3620         One limit may be left unchanged.\n3621 \n3622         >>> set_xlim(right=right_lim)\n3623 \n3624         Limits may be passed in reverse order to flip the direction of\n3625         the x-axis. For example, suppose *x* represents the number of\n3626         years before present. The x-axis limits might be set like the\n3627         following so 5000 years ago is on the left of the plot and the\n3628         present is on the right.\n3629 \n3630         >>> set_xlim(5000, 0)\n3631         \"\"\"\n3632         if right is None and np.iterable(left):\n3633             left, right = left\n3634         if xmin is not None:\n3635             if left is not None:\n3636                 raise TypeError(\"Cannot pass both 'left' and 'xmin'\")\n3637             left = xmin\n3638         if xmax is not None:\n3639             if right is not None:\n3640                 raise TypeError(\"Cannot pass both 'right' and 'xmax'\")\n3641             right = xmax\n3642         return self.xaxis._set_lim(left, right, emit=emit, auto=auto)\n3643 \n3644     get_xscale = _axis_method_wrapper(\"xaxis\", \"get_scale\")\n3645     set_xscale = _axis_method_wrapper(\"xaxis\", \"_set_axes_scale\")\n3646     get_xticks = _axis_method_wrapper(\"xaxis\", \"get_ticklocs\")\n3647     set_xticks = _axis_method_wrapper(\"xaxis\", \"set_ticks\")\n3648     get_xmajorticklabels = _axis_method_wrapper(\"xaxis\", \"get_majorticklabels\")\n3649     get_xminorticklabels = _axis_method_wrapper(\"xaxis\", \"get_minorticklabels\")\n3650     get_xticklabels = _axis_method_wrapper(\"xaxis\", \"get_ticklabels\")\n3651     set_xticklabels = _axis_method_wrapper(\n3652         \"xaxis\", \"set_ticklabels\",\n3653         doc_sub={\"Axis.set_ticks\": \"Axes.set_xticks\"})\n3654 \n3655     def get_ylabel(self):\n3656         \"\"\"\n3657         Get the ylabel text string.\n3658         \"\"\"\n3659         label = self.yaxis.get_label()\n3660         return label.get_text()\n3661 \n3662     def set_ylabel(self, ylabel, fontdict=None, labelpad=None, *,\n3663                    loc=None, **kwargs):\n3664         \"\"\"\n3665         Set the label for the y-axis.\n3666 \n3667         Parameters\n3668         ----------\n3669         ylabel : str\n3670             The label text.\n3671 \n3672         labelpad : float, default: :rc:`axes.labelpad`\n3673             Spacing in points from the Axes bounding box including ticks\n3674             and tick labels.  If None, the previous value is left as is.\n3675 \n3676         loc : {'bottom', 'center', 'top'}, default: :rc:`yaxis.labellocation`\n3677             The label position. This is a high-level alternative for passing\n3678             parameters *y* and *horizontalalignment*.\n3679 \n3680         Other Parameters\n3681         ----------------\n3682         **kwargs : `.Text` properties\n3683             `.Text` properties control the appearance of the label.\n3684 \n3685         See Also\n3686         --------\n3687         text : Documents the properties supported by `.Text`.\n3688         \"\"\"\n3689         if labelpad is not None:\n3690             self.yaxis.labelpad = labelpad\n3691         protected_kw = ['y', 'horizontalalignment', 'ha']\n3692         if {*kwargs} & {*protected_kw}:\n3693             if loc is not None:\n3694                 raise TypeError(f\"Specifying 'loc' is disallowed when any of \"\n3695                                 f\"its corresponding low level keyword \"\n3696                                 f\"arguments ({protected_kw}) are also \"\n3697                                 f\"supplied\")\n3698 \n3699         else:\n3700             loc = (loc if loc is not None\n3701                    else mpl.rcParams['yaxis.labellocation'])\n3702             _api.check_in_list(('bottom', 'center', 'top'), loc=loc)\n3703 \n3704             y, ha = {\n3705                 'bottom': (0, 'left'),\n3706                 'center': (0.5, 'center'),\n3707                 'top': (1, 'right')\n3708             }[loc]\n3709             kwargs.update(y=y, horizontalalignment=ha)\n3710 \n3711         return self.yaxis.set_label_text(ylabel, fontdict, **kwargs)\n3712 \n3713     def invert_yaxis(self):\n3714         \"\"\"\n3715         Invert the y-axis.\n3716 \n3717         See Also\n3718         --------\n3719         yaxis_inverted\n3720         get_ylim, set_ylim\n3721         get_ybound, set_ybound\n3722         \"\"\"\n3723         self.yaxis.set_inverted(not self.yaxis.get_inverted())\n3724 \n3725     yaxis_inverted = _axis_method_wrapper(\"yaxis\", \"get_inverted\")\n3726 \n3727     def get_ybound(self):\n3728         \"\"\"\n3729         Return the lower and upper y-axis bounds, in increasing order.\n3730 \n3731         See Also\n3732         --------\n3733         set_ybound\n3734         get_ylim, set_ylim\n3735         invert_yaxis, yaxis_inverted\n3736         \"\"\"\n3737         bottom, top = self.get_ylim()\n3738         if bottom < top:\n3739             return bottom, top\n3740         else:\n3741             return top, bottom\n3742 \n3743     def set_ybound(self, lower=None, upper=None):\n3744         \"\"\"\n3745         Set the lower and upper numerical bounds of the y-axis.\n3746 \n3747         This method will honor axis inversion regardless of parameter order.\n3748         It will not change the autoscaling setting (`.get_autoscaley_on()`).\n3749 \n3750         Parameters\n3751         ----------\n3752         lower, upper : float or None\n3753             The lower and upper bounds. If *None*, the respective axis bound\n3754             is not modified.\n3755 \n3756         See Also\n3757         --------\n3758         get_ybound\n3759         get_ylim, set_ylim\n3760         invert_yaxis, yaxis_inverted\n3761         \"\"\"\n3762         if upper is None and np.iterable(lower):\n3763             lower, upper = lower\n3764 \n3765         old_lower, old_upper = self.get_ybound()\n3766         if lower is None:\n3767             lower = old_lower\n3768         if upper is None:\n3769             upper = old_upper\n3770 \n3771         self.set_ylim(sorted((lower, upper),\n3772                              reverse=bool(self.yaxis_inverted())),\n3773                       auto=None)\n3774 \n3775     def get_ylim(self):\n3776         \"\"\"\n3777         Return the y-axis view limits.\n3778 \n3779         Returns\n3780         -------\n3781         bottom, top : (float, float)\n3782             The current y-axis limits in data coordinates.\n3783 \n3784         See Also\n3785         --------\n3786         .Axes.set_ylim\n3787         set_ybound, get_ybound\n3788         invert_yaxis, yaxis_inverted\n3789 \n3790         Notes\n3791         -----\n3792         The y-axis may be inverted, in which case the *bottom* value\n3793         will be greater than the *top* value.\n3794         \"\"\"\n3795         return tuple(self.viewLim.intervaly)\n3796 \n3797     def set_ylim(self, bottom=None, top=None, *, emit=True, auto=False,\n3798                  ymin=None, ymax=None):\n3799         \"\"\"\n3800         Set the y-axis view limits.\n3801 \n3802         Parameters\n3803         ----------\n3804         bottom : float, optional\n3805             The bottom ylim in data coordinates. Passing *None* leaves the\n3806             limit unchanged.\n3807 \n3808             The bottom and top ylims may also be passed as the tuple\n3809             (*bottom*, *top*) as the first positional argument (or as\n3810             the *bottom* keyword argument).\n3811 \n3812             .. ACCEPTS: (bottom: float, top: float)\n3813 \n3814         top : float, optional\n3815             The top ylim in data coordinates. Passing *None* leaves the\n3816             limit unchanged.\n3817 \n3818         emit : bool, default: True\n3819             Whether to notify observers of limit change.\n3820 \n3821         auto : bool or None, default: False\n3822             Whether to turn on autoscaling of the y-axis. *True* turns on,\n3823             *False* turns off, *None* leaves unchanged.\n3824 \n3825         ymin, ymax : float, optional\n3826             They are equivalent to bottom and top respectively, and it is an\n3827             error to pass both *ymin* and *bottom* or *ymax* and *top*.\n3828 \n3829         Returns\n3830         -------\n3831         bottom, top : (float, float)\n3832             The new y-axis limits in data coordinates.\n3833 \n3834         See Also\n3835         --------\n3836         get_ylim\n3837         set_ybound, get_ybound\n3838         invert_yaxis, yaxis_inverted\n3839 \n3840         Notes\n3841         -----\n3842         The *bottom* value may be greater than the *top* value, in which\n3843         case the y-axis values will decrease from *bottom* to *top*.\n3844 \n3845         Examples\n3846         --------\n3847         >>> set_ylim(bottom, top)\n3848         >>> set_ylim((bottom, top))\n3849         >>> bottom, top = set_ylim(bottom, top)\n3850 \n3851         One limit may be left unchanged.\n3852 \n3853         >>> set_ylim(top=top_lim)\n3854 \n3855         Limits may be passed in reverse order to flip the direction of\n3856         the y-axis. For example, suppose ``y`` represents depth of the\n3857         ocean in m. The y-axis limits might be set like the following\n3858         so 5000 m depth is at the bottom of the plot and the surface,\n3859         0 m, is at the top.\n3860 \n3861         >>> set_ylim(5000, 0)\n3862         \"\"\"\n3863         if top is None and np.iterable(bottom):\n3864             bottom, top = bottom\n3865         if ymin is not None:\n3866             if bottom is not None:\n3867                 raise TypeError(\"Cannot pass both 'bottom' and 'ymin'\")\n3868             bottom = ymin\n3869         if ymax is not None:\n3870             if top is not None:\n3871                 raise TypeError(\"Cannot pass both 'top' and 'ymax'\")\n3872             top = ymax\n3873         return self.yaxis._set_lim(bottom, top, emit=emit, auto=auto)\n3874 \n3875     get_yscale = _axis_method_wrapper(\"yaxis\", \"get_scale\")\n3876     set_yscale = _axis_method_wrapper(\"yaxis\", \"_set_axes_scale\")\n3877     get_yticks = _axis_method_wrapper(\"yaxis\", \"get_ticklocs\")\n3878     set_yticks = _axis_method_wrapper(\"yaxis\", \"set_ticks\")\n3879     get_ymajorticklabels = _axis_method_wrapper(\"yaxis\", \"get_majorticklabels\")\n3880     get_yminorticklabels = _axis_method_wrapper(\"yaxis\", \"get_minorticklabels\")\n3881     get_yticklabels = _axis_method_wrapper(\"yaxis\", \"get_ticklabels\")\n3882     set_yticklabels = _axis_method_wrapper(\n3883         \"yaxis\", \"set_ticklabels\",\n3884         doc_sub={\"Axis.set_ticks\": \"Axes.set_yticks\"})\n3885 \n3886     xaxis_date = _axis_method_wrapper(\"xaxis\", \"axis_date\")\n3887     yaxis_date = _axis_method_wrapper(\"yaxis\", \"axis_date\")\n3888 \n3889     def format_xdata(self, x):\n3890         \"\"\"\n3891         Return *x* formatted as an x-value.\n3892 \n3893         This function will use the `.fmt_xdata` attribute if it is not None,\n3894         else will fall back on the xaxis major formatter.\n3895         \"\"\"\n3896         return (self.fmt_xdata if self.fmt_xdata is not None\n3897                 else self.xaxis.get_major_formatter().format_data_short)(x)\n3898 \n3899     def format_ydata(self, y):\n3900         \"\"\"\n3901         Return *y* formatted as a y-value.\n3902 \n3903         This function will use the `.fmt_ydata` attribute if it is not None,\n3904         else will fall back on the yaxis major formatter.\n3905         \"\"\"\n3906         return (self.fmt_ydata if self.fmt_ydata is not None\n3907                 else self.yaxis.get_major_formatter().format_data_short)(y)\n3908 \n3909     def format_coord(self, x, y):\n3910         \"\"\"Return a format string formatting the *x*, *y* coordinates.\"\"\"\n3911         return \"x={} y={}\".format(\n3912             \"???\" if x is None else self.format_xdata(x),\n3913             \"???\" if y is None else self.format_ydata(y),\n3914         )\n3915 \n3916     def minorticks_on(self):\n3917         \"\"\"\n3918         Display minor ticks on the Axes.\n3919 \n3920         Displaying minor ticks may reduce performance; you may turn them off\n3921         using `minorticks_off()` if drawing speed is a problem.\n3922         \"\"\"\n3923         for ax in (self.xaxis, self.yaxis):\n3924             scale = ax.get_scale()\n3925             if scale == 'log':\n3926                 s = ax._scale\n3927                 ax.set_minor_locator(mticker.LogLocator(s.base, s.subs))\n3928             elif scale == 'symlog':\n3929                 s = ax._scale\n3930                 ax.set_minor_locator(\n3931                     mticker.SymmetricalLogLocator(s._transform, s.subs))\n3932             else:\n3933                 ax.set_minor_locator(mticker.AutoMinorLocator())\n3934 \n3935     def minorticks_off(self):\n3936         \"\"\"Remove minor ticks from the Axes.\"\"\"\n3937         self.xaxis.set_minor_locator(mticker.NullLocator())\n3938         self.yaxis.set_minor_locator(mticker.NullLocator())\n3939 \n3940     # Interactive manipulation\n3941 \n3942     def can_zoom(self):\n3943         \"\"\"\n3944         Return whether this Axes supports the zoom box button functionality.\n3945         \"\"\"\n3946         return True\n3947 \n3948     def can_pan(self):\n3949         \"\"\"\n3950         Return whether this Axes supports any pan/zoom button functionality.\n3951         \"\"\"\n3952         return True\n3953 \n3954     def get_navigate(self):\n3955         \"\"\"\n3956         Get whether the Axes responds to navigation commands.\n3957         \"\"\"\n3958         return self._navigate\n3959 \n3960     def set_navigate(self, b):\n3961         \"\"\"\n3962         Set whether the Axes responds to navigation toolbar commands.\n3963 \n3964         Parameters\n3965         ----------\n3966         b : bool\n3967         \"\"\"\n3968         self._navigate = b\n3969 \n3970     def get_navigate_mode(self):\n3971         \"\"\"\n3972         Get the navigation toolbar button status: 'PAN', 'ZOOM', or None.\n3973         \"\"\"\n3974         return self._navigate_mode\n3975 \n3976     def set_navigate_mode(self, b):\n3977         \"\"\"\n3978         Set the navigation toolbar button status.\n3979 \n3980         .. warning::\n3981             This is not a user-API function.\n3982 \n3983         \"\"\"\n3984         self._navigate_mode = b\n3985 \n3986     def _get_view(self):\n3987         \"\"\"\n3988         Save information required to reproduce the current view.\n3989 \n3990         This method is called before a view is changed, such as during a pan or zoom\n3991         initiated by the user.  It returns an opaque object that describes the current\n3992         view, in a format compatible with :meth:`_set_view`.\n3993 \n3994         The default implementation saves the view limits and autoscaling state.\n3995         Subclasses may override this as needed, as long as :meth:`_set_view` is also\n3996         adjusted accordingly.\n3997         \"\"\"\n3998         return {\n3999             \"xlim\": self.get_xlim(), \"autoscalex_on\": self.get_autoscalex_on(),\n4000             \"ylim\": self.get_ylim(), \"autoscaley_on\": self.get_autoscaley_on(),\n4001         }\n4002 \n4003     def _set_view(self, view):\n4004         \"\"\"\n4005         Apply a previously saved view.\n4006 \n4007         This method is called when restoring a view (with the return value of\n4008         :meth:`_get_view` as argument), such as with the navigation buttons.\n4009 \n4010         Subclasses that override :meth:`_get_view` also need to override this method\n4011         accordingly.\n4012         \"\"\"\n4013         self.set(**view)\n4014 \n4015     def _prepare_view_from_bbox(self, bbox, direction='in',\n4016                                 mode=None, twinx=False, twiny=False):\n4017         \"\"\"\n4018         Helper function to prepare the new bounds from a bbox.\n4019 \n4020         This helper function returns the new x and y bounds from the zoom\n4021         bbox. This a convenience method to abstract the bbox logic\n4022         out of the base setter.\n4023         \"\"\"\n4024         if len(bbox) == 3:\n4025             xp, yp, scl = bbox  # Zooming code\n4026             if scl == 0:  # Should not happen\n4027                 scl = 1.\n4028             if scl > 1:\n4029                 direction = 'in'\n4030             else:\n4031                 direction = 'out'\n4032                 scl = 1/scl\n4033             # get the limits of the axes\n4034             (xmin, ymin), (xmax, ymax) = self.transData.transform(\n4035                 np.transpose([self.get_xlim(), self.get_ylim()]))\n4036             # set the range\n4037             xwidth = xmax - xmin\n4038             ywidth = ymax - ymin\n4039             xcen = (xmax + xmin)*.5\n4040             ycen = (ymax + ymin)*.5\n4041             xzc = (xp*(scl - 1) + xcen)/scl\n4042             yzc = (yp*(scl - 1) + ycen)/scl\n4043             bbox = [xzc - xwidth/2./scl, yzc - ywidth/2./scl,\n4044                     xzc + xwidth/2./scl, yzc + ywidth/2./scl]\n4045         elif len(bbox) != 4:\n4046             # should be len 3 or 4 but nothing else\n4047             _api.warn_external(\n4048                 \"Warning in _set_view_from_bbox: bounding box is not a tuple \"\n4049                 \"of length 3 or 4. Ignoring the view change.\")\n4050             return\n4051 \n4052         # Original limits.\n4053         xmin0, xmax0 = self.get_xbound()\n4054         ymin0, ymax0 = self.get_ybound()\n4055         # The zoom box in screen coords.\n4056         startx, starty, stopx, stopy = bbox\n4057         # Convert to data coords.\n4058         (startx, starty), (stopx, stopy) = self.transData.inverted().transform(\n4059             [(startx, starty), (stopx, stopy)])\n4060         # Clip to axes limits.\n4061         xmin, xmax = np.clip(sorted([startx, stopx]), xmin0, xmax0)\n4062         ymin, ymax = np.clip(sorted([starty, stopy]), ymin0, ymax0)\n4063         # Don't double-zoom twinned axes or if zooming only the other axis.\n4064         if twinx or mode == \"y\":\n4065             xmin, xmax = xmin0, xmax0\n4066         if twiny or mode == \"x\":\n4067             ymin, ymax = ymin0, ymax0\n4068 \n4069         if direction == \"in\":\n4070             new_xbound = xmin, xmax\n4071             new_ybound = ymin, ymax\n4072 \n4073         elif direction == \"out\":\n4074             x_trf = self.xaxis.get_transform()\n4075             sxmin0, sxmax0, sxmin, sxmax = x_trf.transform(\n4076                 [xmin0, xmax0, xmin, xmax])  # To screen space.\n4077             factor = (sxmax0 - sxmin0) / (sxmax - sxmin)  # Unzoom factor.\n4078             # Move original bounds away by\n4079             # (factor) x (distance between unzoom box and Axes bbox).\n4080             sxmin1 = sxmin0 - factor * (sxmin - sxmin0)\n4081             sxmax1 = sxmax0 + factor * (sxmax0 - sxmax)\n4082             # And back to data space.\n4083             new_xbound = x_trf.inverted().transform([sxmin1, sxmax1])\n4084 \n4085             y_trf = self.yaxis.get_transform()\n4086             symin0, symax0, symin, symax = y_trf.transform(\n4087                 [ymin0, ymax0, ymin, ymax])\n4088             factor = (symax0 - symin0) / (symax - symin)\n4089             symin1 = symin0 - factor * (symin - symin0)\n4090             symax1 = symax0 + factor * (symax0 - symax)\n4091             new_ybound = y_trf.inverted().transform([symin1, symax1])\n4092 \n4093         return new_xbound, new_ybound\n4094 \n4095     def _set_view_from_bbox(self, bbox, direction='in',\n4096                             mode=None, twinx=False, twiny=False):\n4097         \"\"\"\n4098         Update view from a selection bbox.\n4099 \n4100         .. note::\n4101 \n4102             Intended to be overridden by new projection types, but if not, the\n4103             default implementation sets the view limits to the bbox directly.\n4104 \n4105         Parameters\n4106         ----------\n4107         bbox : 4-tuple or 3 tuple\n4108             * If bbox is a 4 tuple, it is the selected bounding box limits,\n4109               in *display* coordinates.\n4110             * If bbox is a 3 tuple, it is an (xp, yp, scl) triple, where\n4111               (xp, yp) is the center of zooming and scl the scale factor to\n4112               zoom by.\n4113 \n4114         direction : str\n4115             The direction to apply the bounding box.\n4116                 * `'in'` - The bounding box describes the view directly, i.e.,\n4117                            it zooms in.\n4118                 * `'out'` - The bounding box describes the size to make the\n4119                             existing view, i.e., it zooms out.\n4120 \n4121         mode : str or None\n4122             The selection mode, whether to apply the bounding box in only the\n4123             `'x'` direction, `'y'` direction or both (`None`).\n4124 \n4125         twinx : bool\n4126             Whether this axis is twinned in the *x*-direction.\n4127 \n4128         twiny : bool\n4129             Whether this axis is twinned in the *y*-direction.\n4130         \"\"\"\n4131         new_xbound, new_ybound = self._prepare_view_from_bbox(\n4132             bbox, direction=direction, mode=mode, twinx=twinx, twiny=twiny)\n4133         if not twinx and mode != \"y\":\n4134             self.set_xbound(new_xbound)\n4135             self.set_autoscalex_on(False)\n4136         if not twiny and mode != \"x\":\n4137             self.set_ybound(new_ybound)\n4138             self.set_autoscaley_on(False)\n4139 \n4140     def start_pan(self, x, y, button):\n4141         \"\"\"\n4142         Called when a pan operation has started.\n4143 \n4144         Parameters\n4145         ----------\n4146         x, y : float\n4147             The mouse coordinates in display coords.\n4148         button : `.MouseButton`\n4149             The pressed mouse button.\n4150 \n4151         Notes\n4152         -----\n4153         This is intended to be overridden by new projection types.\n4154         \"\"\"\n4155         self._pan_start = types.SimpleNamespace(\n4156             lim=self.viewLim.frozen(),\n4157             trans=self.transData.frozen(),\n4158             trans_inverse=self.transData.inverted().frozen(),\n4159             bbox=self.bbox.frozen(),\n4160             x=x,\n4161             y=y)\n4162 \n4163     def end_pan(self):\n4164         \"\"\"\n4165         Called when a pan operation completes (when the mouse button is up.)\n4166 \n4167         Notes\n4168         -----\n4169         This is intended to be overridden by new projection types.\n4170         \"\"\"\n4171         del self._pan_start\n4172 \n4173     def _get_pan_points(self, button, key, x, y):\n4174         \"\"\"\n4175         Helper function to return the new points after a pan.\n4176 \n4177         This helper function returns the points on the axis after a pan has\n4178         occurred. This is a convenience method to abstract the pan logic\n4179         out of the base setter.\n4180         \"\"\"\n4181         def format_deltas(key, dx, dy):\n4182             if key == 'control':\n4183                 if abs(dx) > abs(dy):\n4184                     dy = dx\n4185                 else:\n4186                     dx = dy\n4187             elif key == 'x':\n4188                 dy = 0\n4189             elif key == 'y':\n4190                 dx = 0\n4191             elif key == 'shift':\n4192                 if 2 * abs(dx) < abs(dy):\n4193                     dx = 0\n4194                 elif 2 * abs(dy) < abs(dx):\n4195                     dy = 0\n4196                 elif abs(dx) > abs(dy):\n4197                     dy = dy / abs(dy) * abs(dx)\n4198                 else:\n4199                     dx = dx / abs(dx) * abs(dy)\n4200             return dx, dy\n4201 \n4202         p = self._pan_start\n4203         dx = x - p.x\n4204         dy = y - p.y\n4205         if dx == dy == 0:\n4206             return\n4207         if button == 1:\n4208             dx, dy = format_deltas(key, dx, dy)\n4209             result = p.bbox.translated(-dx, -dy).transformed(p.trans_inverse)\n4210         elif button == 3:\n4211             try:\n4212                 dx = -dx / self.bbox.width\n4213                 dy = -dy / self.bbox.height\n4214                 dx, dy = format_deltas(key, dx, dy)\n4215                 if self.get_aspect() != 'auto':\n4216                     dx = dy = 0.5 * (dx + dy)\n4217                 alpha = np.power(10.0, (dx, dy))\n4218                 start = np.array([p.x, p.y])\n4219                 oldpoints = p.lim.transformed(p.trans)\n4220                 newpoints = start + alpha * (oldpoints - start)\n4221                 result = (mtransforms.Bbox(newpoints)\n4222                           .transformed(p.trans_inverse))\n4223             except OverflowError:\n4224                 _api.warn_external('Overflow while panning')\n4225                 return\n4226         else:\n4227             return\n4228 \n4229         valid = np.isfinite(result.transformed(p.trans))\n4230         points = result.get_points().astype(object)\n4231         # Just ignore invalid limits (typically, underflow in log-scale).\n4232         points[~valid] = None\n4233         return points\n4234 \n4235     def drag_pan(self, button, key, x, y):\n4236         \"\"\"\n4237         Called when the mouse moves during a pan operation.\n4238 \n4239         Parameters\n4240         ----------\n4241         button : `.MouseButton`\n4242             The pressed mouse button.\n4243         key : str or None\n4244             The pressed key, if any.\n4245         x, y : float\n4246             The mouse coordinates in display coords.\n4247 \n4248         Notes\n4249         -----\n4250         This is intended to be overridden by new projection types.\n4251         \"\"\"\n4252         points = self._get_pan_points(button, key, x, y)\n4253         if points is not None:\n4254             self.set_xlim(points[:, 0])\n4255             self.set_ylim(points[:, 1])\n4256 \n4257     def get_children(self):\n4258         # docstring inherited.\n4259         return [\n4260             *self._children,\n4261             *self.spines.values(),\n4262             *self._axis_map.values(),\n4263             self.title, self._left_title, self._right_title,\n4264             *self.child_axes,\n4265             *([self.legend_] if self.legend_ is not None else []),\n4266             self.patch,\n4267         ]\n4268 \n4269     def contains(self, mouseevent):\n4270         # docstring inherited.\n4271         return self.patch.contains(mouseevent)\n4272 \n4273     def contains_point(self, point):\n4274         \"\"\"\n4275         Return whether *point* (pair of pixel coordinates) is inside the Axes\n4276         patch.\n4277         \"\"\"\n4278         return self.patch.contains_point(point, radius=1.0)\n4279 \n4280     def get_default_bbox_extra_artists(self):\n4281         \"\"\"\n4282         Return a default list of artists that are used for the bounding box\n4283         calculation.\n4284 \n4285         Artists are excluded either by not being visible or\n4286         ``artist.set_in_layout(False)``.\n4287         \"\"\"\n4288 \n4289         artists = self.get_children()\n4290 \n4291         for axis in self._axis_map.values():\n4292             # axis tight bboxes are calculated separately inside\n4293             # Axes.get_tightbbox() using for_layout_only=True\n4294             artists.remove(axis)\n4295         if not (self.axison and self._frameon):\n4296             # don't do bbox on spines if frame not on.\n4297             for spine in self.spines.values():\n4298                 artists.remove(spine)\n4299 \n4300         artists.remove(self.title)\n4301         artists.remove(self._left_title)\n4302         artists.remove(self._right_title)\n4303 \n4304         # always include types that do not internally implement clipping\n4305         # to Axes. may have clip_on set to True and clip_box equivalent\n4306         # to ax.bbox but then ignore these properties during draws.\n4307         noclip = (_AxesBase, maxis.Axis,\n4308                   offsetbox.AnnotationBbox, offsetbox.OffsetBox)\n4309         return [a for a in artists if a.get_visible() and a.get_in_layout()\n4310                 and (isinstance(a, noclip) or not a._fully_clipped_to_axes())]\n4311 \n4312     @_api.make_keyword_only(\"3.8\", \"call_axes_locator\")\n4313     def get_tightbbox(self, renderer=None, call_axes_locator=True,\n4314                       bbox_extra_artists=None, *, for_layout_only=False):\n4315         \"\"\"\n4316         Return the tight bounding box of the Axes, including axis and their\n4317         decorators (xlabel, title, etc).\n4318 \n4319         Artists that have ``artist.set_in_layout(False)`` are not included\n4320         in the bbox.\n4321 \n4322         Parameters\n4323         ----------\n4324         renderer : `.RendererBase` subclass\n4325             renderer that will be used to draw the figures (i.e.\n4326             ``fig.canvas.get_renderer()``)\n4327 \n4328         bbox_extra_artists : list of `.Artist` or ``None``\n4329             List of artists to include in the tight bounding box.  If\n4330             ``None`` (default), then all artist children of the Axes are\n4331             included in the tight bounding box.\n4332 \n4333         call_axes_locator : bool, default: True\n4334             If *call_axes_locator* is ``False``, it does not call the\n4335             ``_axes_locator`` attribute, which is necessary to get the correct\n4336             bounding box. ``call_axes_locator=False`` can be used if the\n4337             caller is only interested in the relative size of the tightbbox\n4338             compared to the Axes bbox.\n4339 \n4340         for_layout_only : default: False\n4341             The bounding box will *not* include the x-extent of the title and\n4342             the xlabel, or the y-extent of the ylabel.\n4343 \n4344         Returns\n4345         -------\n4346         `.BboxBase`\n4347             Bounding box in figure pixel coordinates.\n4348 \n4349         See Also\n4350         --------\n4351         matplotlib.axes.Axes.get_window_extent\n4352         matplotlib.axis.Axis.get_tightbbox\n4353         matplotlib.spines.Spine.get_window_extent\n4354         \"\"\"\n4355 \n4356         bb = []\n4357         if renderer is None:\n4358             renderer = self.figure._get_renderer()\n4359 \n4360         if not self.get_visible():\n4361             return None\n4362 \n4363         locator = self.get_axes_locator()\n4364         self.apply_aspect(\n4365             locator(self, renderer) if locator and call_axes_locator else None)\n4366 \n4367         for axis in self._axis_map.values():\n4368             if self.axison and axis.get_visible():\n4369                 ba = martist._get_tightbbox_for_layout_only(axis, renderer)\n4370                 if ba:\n4371                     bb.append(ba)\n4372         self._update_title_position(renderer)\n4373         axbbox = self.get_window_extent(renderer)\n4374         bb.append(axbbox)\n4375 \n4376         for title in [self.title, self._left_title, self._right_title]:\n4377             if title.get_visible():\n4378                 bt = title.get_window_extent(renderer)\n4379                 if for_layout_only and bt.width > 0:\n4380                     # make the title bbox 1 pixel wide so its width\n4381                     # is not accounted for in bbox calculations in\n4382                     # tight/constrained_layout\n4383                     bt.x0 = (bt.x0 + bt.x1) / 2 - 0.5\n4384                     bt.x1 = bt.x0 + 1.0\n4385                 bb.append(bt)\n4386 \n4387         bbox_artists = bbox_extra_artists\n4388         if bbox_artists is None:\n4389             bbox_artists = self.get_default_bbox_extra_artists()\n4390 \n4391         for a in bbox_artists:\n4392             bbox = a.get_tightbbox(renderer)\n4393             if (bbox is not None\n4394                     and 0 < bbox.width < np.inf\n4395                     and 0 < bbox.height < np.inf):\n4396                 bb.append(bbox)\n4397         return mtransforms.Bbox.union(\n4398             [b for b in bb if b.width != 0 or b.height != 0])\n4399 \n4400     def _make_twin_axes(self, *args, **kwargs):\n4401         \"\"\"Make a twinx Axes of self. This is used for twinx and twiny.\"\"\"\n4402         if 'sharex' in kwargs and 'sharey' in kwargs:\n4403             # The following line is added in v2.2 to avoid breaking Seaborn,\n4404             # which currently uses this internal API.\n4405             if kwargs[\"sharex\"] is not self and kwargs[\"sharey\"] is not self:\n4406                 raise ValueError(\"Twinned Axes may share only one axis\")\n4407         ss = self.get_subplotspec()\n4408         if ss:\n4409             twin = self.figure.add_subplot(ss, *args, **kwargs)\n4410         else:\n4411             twin = self.figure.add_axes(\n4412                 self.get_position(True), *args, **kwargs,\n4413                 axes_locator=_TransformedBoundsLocator(\n4414                     [0, 0, 1, 1], self.transAxes))\n4415         self.set_adjustable('datalim')\n4416         twin.set_adjustable('datalim')\n4417         self._twinned_axes.join(self, twin)\n4418         return twin\n4419 \n4420     def twinx(self):\n4421         \"\"\"\n4422         Create a twin Axes sharing the xaxis.\n4423 \n4424         Create a new Axes with an invisible x-axis and an independent\n4425         y-axis positioned opposite to the original one (i.e. at right). The\n4426         x-axis autoscale setting will be inherited from the original\n4427         Axes.  To ensure that the tick marks of both y-axes align, see\n4428         `~matplotlib.ticker.LinearLocator`.\n4429 \n4430         Returns\n4431         -------\n4432         Axes\n4433             The newly created Axes instance\n4434 \n4435         Notes\n4436         -----\n4437         For those who are 'picking' artists while using twinx, pick\n4438         events are only called for the artists in the top-most Axes.\n4439         \"\"\"\n4440         ax2 = self._make_twin_axes(sharex=self)\n4441         ax2.yaxis.tick_right()\n4442         ax2.yaxis.set_label_position('right')\n4443         ax2.yaxis.set_offset_position('right')\n4444         ax2.set_autoscalex_on(self.get_autoscalex_on())\n4445         self.yaxis.tick_left()\n4446         ax2.xaxis.set_visible(False)\n4447         ax2.patch.set_visible(False)\n4448         return ax2\n4449 \n4450     def twiny(self):\n4451         \"\"\"\n4452         Create a twin Axes sharing the yaxis.\n4453 \n4454         Create a new Axes with an invisible y-axis and an independent\n4455         x-axis positioned opposite to the original one (i.e. at top). The\n4456         y-axis autoscale setting will be inherited from the original Axes.\n4457         To ensure that the tick marks of both x-axes align, see\n4458         `~matplotlib.ticker.LinearLocator`.\n4459 \n4460         Returns\n4461         -------\n4462         Axes\n4463             The newly created Axes instance\n4464 \n4465         Notes\n4466         -----\n4467         For those who are 'picking' artists while using twiny, pick\n4468         events are only called for the artists in the top-most Axes.\n4469         \"\"\"\n4470         ax2 = self._make_twin_axes(sharey=self)\n4471         ax2.xaxis.tick_top()\n4472         ax2.xaxis.set_label_position('top')\n4473         ax2.set_autoscaley_on(self.get_autoscaley_on())\n4474         self.xaxis.tick_bottom()\n4475         ax2.yaxis.set_visible(False)\n4476         ax2.patch.set_visible(False)\n4477         return ax2\n4478 \n4479     def get_shared_x_axes(self):\n4480         \"\"\"Return an immutable view on the shared x-axes Grouper.\"\"\"\n4481         return cbook.GrouperView(self._shared_axes[\"x\"])\n4482 \n4483     def get_shared_y_axes(self):\n4484         \"\"\"Return an immutable view on the shared y-axes Grouper.\"\"\"\n4485         return cbook.GrouperView(self._shared_axes[\"y\"])\n4486 \n4487     def label_outer(self):\n4488         \"\"\"\n4489         Only show \"outer\" labels and tick labels.\n4490 \n4491         x-labels are only kept for subplots on the last row (or first row, if\n4492         labels are on the top side); y-labels only for subplots on the first\n4493         column (or last column, if labels are on the right side).\n4494         \"\"\"\n4495         self._label_outer_xaxis(check_patch=False)\n4496         self._label_outer_yaxis(check_patch=False)\n4497 \n4498     def _label_outer_xaxis(self, *, check_patch):\n4499         # see documentation in label_outer.\n4500         if check_patch and not isinstance(self.patch, mpl.patches.Rectangle):\n4501             return\n4502         ss = self.get_subplotspec()\n4503         if not ss:\n4504             return\n4505         label_position = self.xaxis.get_label_position()\n4506         if not ss.is_first_row():  # Remove top label/ticklabels/offsettext.\n4507             if label_position == \"top\":\n4508                 self.set_xlabel(\"\")\n4509             self.xaxis.set_tick_params(which=\"both\", labeltop=False)\n4510             if self.xaxis.offsetText.get_position()[1] == 1:\n4511                 self.xaxis.offsetText.set_visible(False)\n4512         if not ss.is_last_row():  # Remove bottom label/ticklabels/offsettext.\n4513             if label_position == \"bottom\":\n4514                 self.set_xlabel(\"\")\n4515             self.xaxis.set_tick_params(which=\"both\", labelbottom=False)\n4516             if self.xaxis.offsetText.get_position()[1] == 0:\n4517                 self.xaxis.offsetText.set_visible(False)\n4518 \n4519     def _label_outer_yaxis(self, *, check_patch):\n4520         # see documentation in label_outer.\n4521         if check_patch and not isinstance(self.patch, mpl.patches.Rectangle):\n4522             return\n4523         ss = self.get_subplotspec()\n4524         if not ss:\n4525             return\n4526         label_position = self.yaxis.get_label_position()\n4527         if not ss.is_first_col():  # Remove left label/ticklabels/offsettext.\n4528             if label_position == \"left\":\n4529                 self.set_ylabel(\"\")\n4530             self.yaxis.set_tick_params(which=\"both\", labelleft=False)\n4531             if self.yaxis.offsetText.get_position()[0] == 0:\n4532                 self.yaxis.offsetText.set_visible(False)\n4533         if not ss.is_last_col():  # Remove right label/ticklabels/offsettext.\n4534             if label_position == \"right\":\n4535                 self.set_ylabel(\"\")\n4536             self.yaxis.set_tick_params(which=\"both\", labelright=False)\n4537             if self.yaxis.offsetText.get_position()[0] == 1:\n4538                 self.yaxis.offsetText.set_visible(False)\n",
        "intended_behavior": "This class provides additional context to the issue."
    },
    {
        "rel_file_path": "lib/mpl_toolkits/mplot3d/axes3d.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/matplotlib__matplotlib/setup_matplotlib__matplotlib__3.7/lib/mpl_toolkits/mplot3d/axes3d.py",
        "start": 1346,
        "end": 1372,
        "class_name": "Axes3D",
        "method_name": "tick_params",
        "code": "1346     def tick_params(self, axis='both', **kwargs):\n1347         \"\"\"\n1348         Convenience method for changing the appearance of ticks and\n1349         tick labels.\n1350 \n1351         See `.Axes.tick_params` for full documentation.  Because this function\n1352         applies to 3D Axes, *axis* can also be set to 'z', and setting *axis*\n1353         to 'both' autoscales all three axes.\n1354 \n1355         Also, because of how Axes3D objects are drawn very differently\n1356         from regular 2D axes, some of these settings may have\n1357         ambiguous meaning.  For simplicity, the 'z' axis will\n1358         accept settings as if it was like the 'y' axis.\n1359 \n1360         .. note::\n1361            Axes3D currently ignores some of these settings.\n1362         \"\"\"\n1363         _api.check_in_list(['x', 'y', 'z', 'both'], axis=axis)\n1364         if axis in ['x', 'y', 'both']:\n1365             super().tick_params(axis, **kwargs)\n1366         if axis in ['z', 'both']:\n1367             zkw = dict(kwargs)\n1368             zkw.pop('top', None)\n1369             zkw.pop('bottom', None)\n1370             zkw.pop('labeltop', None)\n1371             zkw.pop('labelbottom', None)\n1372             self.zaxis.set_tick_params(**zkw)\n",
        "intended_behavior": "Update the `tick_params` method to accept and correctly apply a `fontfamily` keyword argument for the 'x', 'y', and crucially, the 'z' axis, considering the 3D context. As with the 2D scenario, ensure that specifying `fontfamily` changes the font family of the tick labels according to the user's input while keeping all other functionalities intact. Special attention should be paid to integrating this functionality within the 3D plotting constraints and ensuring compatibility with the generalized matplotlib styles and options framework. Furthermore, since the 3D method calls its 2D counterpart for the 'x' and 'y' axes, care must be taken to harmonize the handling of `fontfamily` between these implementations."
    },
    {
        "rel_file_path": "lib/mpl_toolkits/mplot3d/axes3d.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/matplotlib__matplotlib/setup_matplotlib__matplotlib__3.7/lib/mpl_toolkits/mplot3d/axes3d.py",
        "start": 45,
        "end": 3298,
        "class_name": "Axes3D",
        "method_name": null,
        "code": "45 class Axes3D(Axes):\n46     \"\"\"\n47     3D Axes object.\n48 \n49     .. note::\n50 \n51         As a user, you do not instantiate Axes directly, but use Axes creation\n52         methods instead; e.g. from `.pyplot` or `.Figure`:\n53         `~.pyplot.subplots`, `~.pyplot.subplot_mosaic` or `.Figure.add_axes`.\n54     \"\"\"\n55     name = '3d'\n56 \n57     _axis_names = (\"x\", \"y\", \"z\")\n58     Axes._shared_axes[\"z\"] = cbook.Grouper()\n59 \n60     vvec = _api.deprecate_privatize_attribute(\"3.7\")\n61     eye = _api.deprecate_privatize_attribute(\"3.7\")\n62     sx = _api.deprecate_privatize_attribute(\"3.7\")\n63     sy = _api.deprecate_privatize_attribute(\"3.7\")\n64 \n65     def __init__(\n66             self, fig, rect=None, *args,\n67             elev=30, azim=-60, roll=0, sharez=None, proj_type='persp',\n68             box_aspect=None, computed_zorder=True, focal_length=None,\n69             **kwargs):\n70         \"\"\"\n71         Parameters\n72         ----------\n73         fig : Figure\n74             The parent figure.\n75         rect : tuple (left, bottom, width, height), default: None.\n76             The ``(left, bottom, width, height)`` axes position.\n77         elev : float, default: 30\n78             The elevation angle in degrees rotates the camera above and below\n79             the x-y plane, with a positive angle corresponding to a location\n80             above the plane.\n81         azim : float, default: -60\n82             The azimuthal angle in degrees rotates the camera about the z axis,\n83             with a positive angle corresponding to a right-handed rotation. In\n84             other words, a positive azimuth rotates the camera about the origin\n85             from its location along the +x axis towards the +y axis.\n86         roll : float, default: 0\n87             The roll angle in degrees rotates the camera about the viewing\n88             axis. A positive angle spins the camera clockwise, causing the\n89             scene to rotate counter-clockwise.\n90         sharez : Axes3D, optional\n91             Other Axes to share z-limits with.\n92         proj_type : {'persp', 'ortho'}\n93             The projection type, default 'persp'.\n94         box_aspect : 3-tuple of floats, default: None\n95             Changes the physical dimensions of the Axes3D, such that the ratio\n96             of the axis lengths in display units is x:y:z.\n97             If None, defaults to 4:4:3\n98         computed_zorder : bool, default: True\n99             If True, the draw order is computed based on the average position\n100             of the `.Artist`\\\\s along the view direction.\n101             Set to False if you want to manually control the order in which\n102             Artists are drawn on top of each other using their *zorder*\n103             attribute. This can be used for fine-tuning if the automatic order\n104             does not produce the desired result. Note however, that a manual\n105             zorder will only be correct for a limited view angle. If the figure\n106             is rotated by the user, it will look wrong from certain angles.\n107         focal_length : float, default: None\n108             For a projection type of 'persp', the focal length of the virtual\n109             camera. Must be > 0. If None, defaults to 1.\n110             For a projection type of 'ortho', must be set to either None\n111             or infinity (numpy.inf). If None, defaults to infinity.\n112             The focal length can be computed from a desired Field Of View via\n113             the equation: focal_length = 1/tan(FOV/2)\n114 \n115         **kwargs\n116             Other optional keyword arguments:\n117 \n118             %(Axes3D:kwdoc)s\n119         \"\"\"\n120 \n121         if rect is None:\n122             rect = [0.0, 0.0, 1.0, 1.0]\n123 \n124         self.initial_azim = azim\n125         self.initial_elev = elev\n126         self.initial_roll = roll\n127         self.set_proj_type(proj_type, focal_length)\n128         self.computed_zorder = computed_zorder\n129 \n130         self.xy_viewLim = Bbox.unit()\n131         self.zz_viewLim = Bbox.unit()\n132         self.xy_dataLim = Bbox.unit()\n133         # z-limits are encoded in the x-component of the Bbox, y is un-used\n134         self.zz_dataLim = Bbox.unit()\n135 \n136         # inhibit autoscale_view until the axes are defined\n137         # they can't be defined until Axes.__init__ has been called\n138         self.view_init(self.initial_elev, self.initial_azim, self.initial_roll)\n139 \n140         self._sharez = sharez\n141         if sharez is not None:\n142             self._shared_axes[\"z\"].join(self, sharez)\n143             self._adjustable = 'datalim'\n144 \n145         if kwargs.pop('auto_add_to_figure', False):\n146             raise AttributeError(\n147                 'auto_add_to_figure is no longer supported for Axes3D. '\n148                 'Use fig.add_axes(ax) instead.'\n149             )\n150 \n151         super().__init__(\n152             fig, rect, frameon=True, box_aspect=box_aspect, *args, **kwargs\n153         )\n154         # Disable drawing of axes by base class\n155         super().set_axis_off()\n156         # Enable drawing of axes by Axes3D class\n157         self.set_axis_on()\n158         self.M = None\n159 \n160         # func used to format z -- fall back on major formatters\n161         self.fmt_zdata = None\n162 \n163         self.mouse_init()\n164         self.figure.canvas.callbacks._connect_picklable(\n165             'motion_notify_event', self._on_move)\n166         self.figure.canvas.callbacks._connect_picklable(\n167             'button_press_event', self._button_press)\n168         self.figure.canvas.callbacks._connect_picklable(\n169             'button_release_event', self._button_release)\n170         self.set_top_view()\n171 \n172         self.patch.set_linewidth(0)\n173         # Calculate the pseudo-data width and height\n174         pseudo_bbox = self.transLimits.inverted().transform([(0, 0), (1, 1)])\n175         self._pseudo_w, self._pseudo_h = pseudo_bbox[1] - pseudo_bbox[0]\n176 \n177         # mplot3d currently manages its own spines and needs these turned off\n178         # for bounding box calculations\n179         self.spines[:].set_visible(False)\n180 \n181     def set_axis_off(self):\n182         self._axis3don = False\n183         self.stale = True\n184 \n185     def set_axis_on(self):\n186         self._axis3don = True\n187         self.stale = True\n188 \n189     def convert_zunits(self, z):\n190         \"\"\"\n191         For artists in an Axes, if the zaxis has units support,\n192         convert *z* using zaxis unit type\n193         \"\"\"\n194         return self.zaxis.convert_units(z)\n195 \n196     def set_top_view(self):\n197         # this happens to be the right view for the viewing coordinates\n198         # moved up and to the left slightly to fit labels and axes\n199         xdwl = 0.95 / self._dist\n200         xdw = 0.9 / self._dist\n201         ydwl = 0.95 / self._dist\n202         ydw = 0.9 / self._dist\n203         # Set the viewing pane.\n204         self.viewLim.intervalx = (-xdwl, xdw)\n205         self.viewLim.intervaly = (-ydwl, ydw)\n206         self.stale = True\n207 \n208     def _init_axis(self):\n209         \"\"\"Init 3D axes; overrides creation of regular X/Y axes.\"\"\"\n210         self.xaxis = axis3d.XAxis(self)\n211         self.yaxis = axis3d.YAxis(self)\n212         self.zaxis = axis3d.ZAxis(self)\n213 \n214     def get_zaxis(self):\n215         \"\"\"Return the ``ZAxis`` (`~.axis3d.Axis`) instance.\"\"\"\n216         return self.zaxis\n217 \n218     get_zgridlines = _axis_method_wrapper(\"zaxis\", \"get_gridlines\")\n219     get_zticklines = _axis_method_wrapper(\"zaxis\", \"get_ticklines\")\n220 \n221     @_api.deprecated(\"3.7\")\n222     def unit_cube(self, vals=None):\n223         return self._unit_cube(vals)\n224 \n225     def _unit_cube(self, vals=None):\n226         minx, maxx, miny, maxy, minz, maxz = vals or self.get_w_lims()\n227         return [(minx, miny, minz),\n228                 (maxx, miny, minz),\n229                 (maxx, maxy, minz),\n230                 (minx, maxy, minz),\n231                 (minx, miny, maxz),\n232                 (maxx, miny, maxz),\n233                 (maxx, maxy, maxz),\n234                 (minx, maxy, maxz)]\n235 \n236     @_api.deprecated(\"3.7\")\n237     def tunit_cube(self, vals=None, M=None):\n238         return self._tunit_cube(vals, M)\n239 \n240     def _tunit_cube(self, vals=None, M=None):\n241         if M is None:\n242             M = self.M\n243         xyzs = self._unit_cube(vals)\n244         tcube = proj3d._proj_points(xyzs, M)\n245         return tcube\n246 \n247     @_api.deprecated(\"3.7\")\n248     def tunit_edges(self, vals=None, M=None):\n249         return self._tunit_edges(vals, M)\n250 \n251     def _tunit_edges(self, vals=None, M=None):\n252         tc = self._tunit_cube(vals, M)\n253         edges = [(tc[0], tc[1]),\n254                  (tc[1], tc[2]),\n255                  (tc[2], tc[3]),\n256                  (tc[3], tc[0]),\n257 \n258                  (tc[0], tc[4]),\n259                  (tc[1], tc[5]),\n260                  (tc[2], tc[6]),\n261                  (tc[3], tc[7]),\n262 \n263                  (tc[4], tc[5]),\n264                  (tc[5], tc[6]),\n265                  (tc[6], tc[7]),\n266                  (tc[7], tc[4])]\n267         return edges\n268 \n269     def set_aspect(self, aspect, adjustable=None, anchor=None, share=False):\n270         \"\"\"\n271         Set the aspect ratios.\n272 \n273         Parameters\n274         ----------\n275         aspect : {'auto', 'equal', 'equalxy', 'equalxz', 'equalyz'}\n276             Possible values:\n277 \n278             =========   ==================================================\n279             value       description\n280             =========   ==================================================\n281             'auto'      automatic; fill the position rectangle with data.\n282             'equal'     adapt all the axes to have equal aspect ratios.\n283             'equalxy'   adapt the x and y axes to have equal aspect ratios.\n284             'equalxz'   adapt the x and z axes to have equal aspect ratios.\n285             'equalyz'   adapt the y and z axes to have equal aspect ratios.\n286             =========   ==================================================\n287 \n288         adjustable : None or {'box', 'datalim'}, optional\n289             If not *None*, this defines which parameter will be adjusted to\n290             meet the required aspect. See `.set_adjustable` for further\n291             details.\n292 \n293         anchor : None or str or 2-tuple of float, optional\n294             If not *None*, this defines where the Axes will be drawn if there\n295             is extra space due to aspect constraints. The most common way to\n296             specify the anchor are abbreviations of cardinal directions:\n297 \n298             =====   =====================\n299             value   description\n300             =====   =====================\n301             'C'     centered\n302             'SW'    lower left corner\n303             'S'     middle of bottom edge\n304             'SE'    lower right corner\n305             etc.\n306             =====   =====================\n307 \n308             See `~.Axes.set_anchor` for further details.\n309 \n310         share : bool, default: False\n311             If ``True``, apply the settings to all shared Axes.\n312 \n313         See Also\n314         --------\n315         mpl_toolkits.mplot3d.axes3d.Axes3D.set_box_aspect\n316         \"\"\"\n317         _api.check_in_list(('auto', 'equal', 'equalxy', 'equalyz', 'equalxz'),\n318                            aspect=aspect)\n319         super().set_aspect(\n320             aspect='auto', adjustable=adjustable, anchor=anchor, share=share)\n321         self._aspect = aspect\n322 \n323         if aspect in ('equal', 'equalxy', 'equalxz', 'equalyz'):\n324             ax_indices = self._equal_aspect_axis_indices(aspect)\n325 \n326             view_intervals = np.array([self.xaxis.get_view_interval(),\n327                                        self.yaxis.get_view_interval(),\n328                                        self.zaxis.get_view_interval()])\n329             ptp = np.ptp(view_intervals, axis=1)\n330             if self._adjustable == 'datalim':\n331                 mean = np.mean(view_intervals, axis=1)\n332                 scale = max(ptp[ax_indices] / self._box_aspect[ax_indices])\n333                 deltas = scale * self._box_aspect\n334 \n335                 for i, set_lim in enumerate((self.set_xlim3d,\n336                                              self.set_ylim3d,\n337                                              self.set_zlim3d)):\n338                     if i in ax_indices:\n339                         set_lim(mean[i] - deltas[i]/2., mean[i] + deltas[i]/2.)\n340             else:  # 'box'\n341                 # Change the box aspect such that the ratio of the length of\n342                 # the unmodified axis to the length of the diagonal\n343                 # perpendicular to it remains unchanged.\n344                 box_aspect = np.array(self._box_aspect)\n345                 box_aspect[ax_indices] = ptp[ax_indices]\n346                 remaining_ax_indices = {0, 1, 2}.difference(ax_indices)\n347                 if remaining_ax_indices:\n348                     remaining = remaining_ax_indices.pop()\n349                     old_diag = np.linalg.norm(self._box_aspect[ax_indices])\n350                     new_diag = np.linalg.norm(box_aspect[ax_indices])\n351                     box_aspect[remaining] *= new_diag / old_diag\n352                 self.set_box_aspect(box_aspect)\n353 \n354     def _equal_aspect_axis_indices(self, aspect):\n355         \"\"\"\n356         Get the indices for which of the x, y, z axes are constrained to have\n357         equal aspect ratios.\n358 \n359         Parameters\n360         ----------\n361         aspect : {'auto', 'equal', 'equalxy', 'equalxz', 'equalyz'}\n362             See descriptions in docstring for `.set_aspect()`.\n363         \"\"\"\n364         ax_indices = []  # aspect == 'auto'\n365         if aspect == 'equal':\n366             ax_indices = [0, 1, 2]\n367         elif aspect == 'equalxy':\n368             ax_indices = [0, 1]\n369         elif aspect == 'equalxz':\n370             ax_indices = [0, 2]\n371         elif aspect == 'equalyz':\n372             ax_indices = [1, 2]\n373         return ax_indices\n374 \n375     def set_box_aspect(self, aspect, *, zoom=1):\n376         \"\"\"\n377         Set the Axes box aspect.\n378 \n379         The box aspect is the ratio of height to width in display\n380         units for each face of the box when viewed perpendicular to\n381         that face.  This is not to be confused with the data aspect (see\n382         `~.Axes3D.set_aspect`). The default ratios are 4:4:3 (x:y:z).\n383 \n384         To simulate having equal aspect in data space, set the box\n385         aspect to match your data range in each dimension.\n386 \n387         *zoom* controls the overall size of the Axes3D in the figure.\n388 \n389         Parameters\n390         ----------\n391         aspect : 3-tuple of floats or None\n392             Changes the physical dimensions of the Axes3D, such that the ratio\n393             of the axis lengths in display units is x:y:z.\n394             If None, defaults to (4, 4, 3).\n395 \n396         zoom : float, default: 1\n397             Control overall size of the Axes3D in the figure. Must be > 0.\n398         \"\"\"\n399         if zoom <= 0:\n400             raise ValueError(f'Argument zoom = {zoom} must be > 0')\n401 \n402         if aspect is None:\n403             aspect = np.asarray((4, 4, 3), dtype=float)\n404         else:\n405             aspect = np.asarray(aspect, dtype=float)\n406             _api.check_shape((3,), aspect=aspect)\n407         # default scale tuned to match the mpl32 appearance.\n408         aspect *= 1.8294640721620434 * zoom / np.linalg.norm(aspect)\n409 \n410         self._box_aspect = aspect\n411         self.stale = True\n412 \n413     def apply_aspect(self, position=None):\n414         if position is None:\n415             position = self.get_position(original=True)\n416 \n417         # in the superclass, we would go through and actually deal with axis\n418         # scales and box/datalim. Those are all irrelevant - all we need to do\n419         # is make sure our coordinate system is square.\n420         trans = self.get_figure().transSubfigure\n421         bb = mtransforms.Bbox.unit().transformed(trans)\n422         # this is the physical aspect of the panel (or figure):\n423         fig_aspect = bb.height / bb.width\n424 \n425         box_aspect = 1\n426         pb = position.frozen()\n427         pb1 = pb.shrunk_to_aspect(box_aspect, pb, fig_aspect)\n428         self._set_position(pb1.anchored(self.get_anchor(), pb), 'active')\n429 \n430     @martist.allow_rasterization\n431     def draw(self, renderer):\n432         if not self.get_visible():\n433             return\n434         self._unstale_viewLim()\n435 \n436         # draw the background patch\n437         self.patch.draw(renderer)\n438         self._frameon = False\n439 \n440         # first, set the aspect\n441         # this is duplicated from `axes._base._AxesBase.draw`\n442         # but must be called before any of the artist are drawn as\n443         # it adjusts the view limits and the size of the bounding box\n444         # of the Axes\n445         locator = self.get_axes_locator()\n446         self.apply_aspect(locator(self, renderer) if locator else None)\n447 \n448         # add the projection matrix to the renderer\n449         self.M = self.get_proj()\n450 \n451         collections_and_patches = (\n452             artist for artist in self._children\n453             if isinstance(artist, (mcoll.Collection, mpatches.Patch))\n454             and artist.get_visible())\n455         if self.computed_zorder:\n456             # Calculate projection of collections and patches and zorder\n457             # them. Make sure they are drawn above the grids.\n458             zorder_offset = max(axis.get_zorder()\n459                                 for axis in self._axis_map.values()) + 1\n460             collection_zorder = patch_zorder = zorder_offset\n461 \n462             for artist in sorted(collections_and_patches,\n463                                  key=lambda artist: artist.do_3d_projection(),\n464                                  reverse=True):\n465                 if isinstance(artist, mcoll.Collection):\n466                     artist.zorder = collection_zorder\n467                     collection_zorder += 1\n468                 elif isinstance(artist, mpatches.Patch):\n469                     artist.zorder = patch_zorder\n470                     patch_zorder += 1\n471         else:\n472             for artist in collections_and_patches:\n473                 artist.do_3d_projection()\n474 \n475         if self._axis3don:\n476             # Draw panes first\n477             for axis in self._axis_map.values():\n478                 axis.draw_pane(renderer)\n479             # Then gridlines\n480             for axis in self._axis_map.values():\n481                 axis.draw_grid(renderer)\n482             # Then axes, labels, text, and ticks\n483             for axis in self._axis_map.values():\n484                 axis.draw(renderer)\n485 \n486         # Then rest\n487         super().draw(renderer)\n488 \n489     def get_axis_position(self):\n490         vals = self.get_w_lims()\n491         tc = self._tunit_cube(vals, self.M)\n492         xhigh = tc[1][2] > tc[2][2]\n493         yhigh = tc[3][2] > tc[2][2]\n494         zhigh = tc[0][2] > tc[2][2]\n495         return xhigh, yhigh, zhigh\n496 \n497     def update_datalim(self, xys, **kwargs):\n498         \"\"\"\n499         Not implemented in `~mpl_toolkits.mplot3d.axes3d.Axes3D`.\n500         \"\"\"\n501         pass\n502 \n503     get_autoscalez_on = _axis_method_wrapper(\"zaxis\", \"_get_autoscale_on\")\n504     set_autoscalez_on = _axis_method_wrapper(\"zaxis\", \"_set_autoscale_on\")\n505 \n506     def set_zmargin(self, m):\n507         \"\"\"\n508         Set padding of Z data limits prior to autoscaling.\n509 \n510         *m* times the data interval will be added to each end of that interval\n511         before it is used in autoscaling.  If *m* is negative, this will clip\n512         the data range instead of expanding it.\n513 \n514         For example, if your data is in the range [0, 2], a margin of 0.1 will\n515         result in a range [-0.2, 2.2]; a margin of -0.1 will result in a range\n516         of [0.2, 1.8].\n517 \n518         Parameters\n519         ----------\n520         m : float greater than -0.5\n521         \"\"\"\n522         if m <= -0.5:\n523             raise ValueError(\"margin must be greater than -0.5\")\n524         self._zmargin = m\n525         self._request_autoscale_view(\"z\")\n526         self.stale = True\n527 \n528     def margins(self, *margins, x=None, y=None, z=None, tight=True):\n529         \"\"\"\n530         Set or retrieve autoscaling margins.\n531 \n532         See `.Axes.margins` for full documentation.  Because this function\n533         applies to 3D Axes, it also takes a *z* argument, and returns\n534         ``(xmargin, ymargin, zmargin)``.\n535         \"\"\"\n536         if margins and (x is not None or y is not None or z is not None):\n537             raise TypeError('Cannot pass both positional and keyword '\n538                             'arguments for x, y, and/or z.')\n539         elif len(margins) == 1:\n540             x = y = z = margins[0]\n541         elif len(margins) == 3:\n542             x, y, z = margins\n543         elif margins:\n544             raise TypeError('Must pass a single positional argument for all '\n545                             'margins, or one for each margin (x, y, z).')\n546 \n547         if x is None and y is None and z is None:\n548             if tight is not True:\n549                 _api.warn_external(f'ignoring tight={tight!r} in get mode')\n550             return self._xmargin, self._ymargin, self._zmargin\n551 \n552         if x is not None:\n553             self.set_xmargin(x)\n554         if y is not None:\n555             self.set_ymargin(y)\n556         if z is not None:\n557             self.set_zmargin(z)\n558 \n559         self.autoscale_view(\n560             tight=tight, scalex=(x is not None), scaley=(y is not None),\n561             scalez=(z is not None)\n562         )\n563 \n564     def autoscale(self, enable=True, axis='both', tight=None):\n565         \"\"\"\n566         Convenience method for simple axis view autoscaling.\n567 \n568         See `.Axes.autoscale` for full documentation.  Because this function\n569         applies to 3D Axes, *axis* can also be set to 'z', and setting *axis*\n570         to 'both' autoscales all three axes.\n571         \"\"\"\n572         if enable is None:\n573             scalex = True\n574             scaley = True\n575             scalez = True\n576         else:\n577             if axis in ['x', 'both']:\n578                 self.set_autoscalex_on(bool(enable))\n579                 scalex = self.get_autoscalex_on()\n580             else:\n581                 scalex = False\n582             if axis in ['y', 'both']:\n583                 self.set_autoscaley_on(bool(enable))\n584                 scaley = self.get_autoscaley_on()\n585             else:\n586                 scaley = False\n587             if axis in ['z', 'both']:\n588                 self.set_autoscalez_on(bool(enable))\n589                 scalez = self.get_autoscalez_on()\n590             else:\n591                 scalez = False\n592         if scalex:\n593             self._request_autoscale_view(\"x\", tight=tight)\n594         if scaley:\n595             self._request_autoscale_view(\"y\", tight=tight)\n596         if scalez:\n597             self._request_autoscale_view(\"z\", tight=tight)\n598 \n599     def auto_scale_xyz(self, X, Y, Z=None, had_data=None):\n600         # This updates the bounding boxes as to keep a record as to what the\n601         # minimum sized rectangular volume holds the data.\n602         if np.shape(X) == np.shape(Y):\n603             self.xy_dataLim.update_from_data_xy(\n604                 np.column_stack([np.ravel(X), np.ravel(Y)]), not had_data)\n605         else:\n606             self.xy_dataLim.update_from_data_x(X, not had_data)\n607             self.xy_dataLim.update_from_data_y(Y, not had_data)\n608         if Z is not None:\n609             self.zz_dataLim.update_from_data_x(Z, not had_data)\n610         # Let autoscale_view figure out how to use this data.\n611         self.autoscale_view()\n612 \n613     def autoscale_view(self, tight=None, scalex=True, scaley=True,\n614                        scalez=True):\n615         \"\"\"\n616         Autoscale the view limits using the data limits.\n617 \n618         See `.Axes.autoscale_view` for full documentation.  Because this\n619         function applies to 3D Axes, it also takes a *scalez* argument.\n620         \"\"\"\n621         # This method looks at the rectangular volume (see above)\n622         # of data and decides how to scale the view portal to fit it.\n623         if tight is None:\n624             _tight = self._tight\n625             if not _tight:\n626                 # if image data only just use the datalim\n627                 for artist in self._children:\n628                     if isinstance(artist, mimage.AxesImage):\n629                         _tight = True\n630                     elif isinstance(artist, (mlines.Line2D, mpatches.Patch)):\n631                         _tight = False\n632                         break\n633         else:\n634             _tight = self._tight = bool(tight)\n635 \n636         if scalex and self.get_autoscalex_on():\n637             x0, x1 = self.xy_dataLim.intervalx\n638             xlocator = self.xaxis.get_major_locator()\n639             x0, x1 = xlocator.nonsingular(x0, x1)\n640             if self._xmargin > 0:\n641                 delta = (x1 - x0) * self._xmargin\n642                 x0 -= delta\n643                 x1 += delta\n644             if not _tight:\n645                 x0, x1 = xlocator.view_limits(x0, x1)\n646             self.set_xbound(x0, x1)\n647 \n648         if scaley and self.get_autoscaley_on():\n649             y0, y1 = self.xy_dataLim.intervaly\n650             ylocator = self.yaxis.get_major_locator()\n651             y0, y1 = ylocator.nonsingular(y0, y1)\n652             if self._ymargin > 0:\n653                 delta = (y1 - y0) * self._ymargin\n654                 y0 -= delta\n655                 y1 += delta\n656             if not _tight:\n657                 y0, y1 = ylocator.view_limits(y0, y1)\n658             self.set_ybound(y0, y1)\n659 \n660         if scalez and self.get_autoscalez_on():\n661             z0, z1 = self.zz_dataLim.intervalx\n662             zlocator = self.zaxis.get_major_locator()\n663             z0, z1 = zlocator.nonsingular(z0, z1)\n664             if self._zmargin > 0:\n665                 delta = (z1 - z0) * self._zmargin\n666                 z0 -= delta\n667                 z1 += delta\n668             if not _tight:\n669                 z0, z1 = zlocator.view_limits(z0, z1)\n670             self.set_zbound(z0, z1)\n671 \n672     def get_w_lims(self):\n673         \"\"\"Get 3D world limits.\"\"\"\n674         minx, maxx = self.get_xlim3d()\n675         miny, maxy = self.get_ylim3d()\n676         minz, maxz = self.get_zlim3d()\n677         return minx, maxx, miny, maxy, minz, maxz\n678 \n679     # set_xlim, set_ylim are directly inherited from base Axes.\n680     def set_zlim(self, bottom=None, top=None, *, emit=True, auto=False,\n681                  zmin=None, zmax=None):\n682         \"\"\"\n683         Set 3D z limits.\n684 \n685         See `.Axes.set_ylim` for full documentation\n686         \"\"\"\n687         if top is None and np.iterable(bottom):\n688             bottom, top = bottom\n689         if zmin is not None:\n690             if bottom is not None:\n691                 raise TypeError(\"Cannot pass both 'bottom' and 'zmin'\")\n692             bottom = zmin\n693         if zmax is not None:\n694             if top is not None:\n695                 raise TypeError(\"Cannot pass both 'top' and 'zmax'\")\n696             top = zmax\n697         return self.zaxis._set_lim(bottom, top, emit=emit, auto=auto)\n698 \n699     set_xlim3d = maxes.Axes.set_xlim\n700     set_ylim3d = maxes.Axes.set_ylim\n701     set_zlim3d = set_zlim\n702 \n703     def get_xlim(self):\n704         # docstring inherited\n705         return tuple(self.xy_viewLim.intervalx)\n706 \n707     def get_ylim(self):\n708         # docstring inherited\n709         return tuple(self.xy_viewLim.intervaly)\n710 \n711     def get_zlim(self):\n712         \"\"\"Get 3D z limits.\"\"\"\n713         return tuple(self.zz_viewLim.intervalx)\n714 \n715     get_zscale = _axis_method_wrapper(\"zaxis\", \"get_scale\")\n716 \n717     # Redefine all three methods to overwrite their docstrings.\n718     set_xscale = _axis_method_wrapper(\"xaxis\", \"_set_axes_scale\")\n719     set_yscale = _axis_method_wrapper(\"yaxis\", \"_set_axes_scale\")\n720     set_zscale = _axis_method_wrapper(\"zaxis\", \"_set_axes_scale\")\n721     set_xscale.__doc__, set_yscale.__doc__, set_zscale.__doc__ = map(\n722         \"\"\"\n723         Set the {}-axis scale.\n724 \n725         Parameters\n726         ----------\n727         value : {{\"linear\"}}\n728             The axis scale type to apply.  3D axes currently only support\n729             linear scales; other scales yield nonsensical results.\n730 \n731         **kwargs\n732             Keyword arguments are nominally forwarded to the scale class, but\n733             none of them is applicable for linear scales.\n734         \"\"\".format,\n735         [\"x\", \"y\", \"z\"])\n736 \n737     get_zticks = _axis_method_wrapper(\"zaxis\", \"get_ticklocs\")\n738     set_zticks = _axis_method_wrapper(\"zaxis\", \"set_ticks\")\n739     get_zmajorticklabels = _axis_method_wrapper(\"zaxis\", \"get_majorticklabels\")\n740     get_zminorticklabels = _axis_method_wrapper(\"zaxis\", \"get_minorticklabels\")\n741     get_zticklabels = _axis_method_wrapper(\"zaxis\", \"get_ticklabels\")\n742     set_zticklabels = _axis_method_wrapper(\n743         \"zaxis\", \"set_ticklabels\",\n744         doc_sub={\"Axis.set_ticks\": \"Axes3D.set_zticks\"})\n745 \n746     zaxis_date = _axis_method_wrapper(\"zaxis\", \"axis_date\")\n747     if zaxis_date.__doc__:\n748         zaxis_date.__doc__ += textwrap.dedent(\"\"\"\n749 \n750         Notes\n751         -----\n752         This function is merely provided for completeness, but 3D axes do not\n753         support dates for ticks, and so this may not work as expected.\n754         \"\"\")\n755 \n756     def clabel(self, *args, **kwargs):\n757         \"\"\"Currently not implemented for 3D axes, and returns *None*.\"\"\"\n758         return None\n759 \n760     def view_init(self, elev=None, azim=None, roll=None, vertical_axis=\"z\"):\n761         \"\"\"\n762         Set the elevation and azimuth of the axes in degrees (not radians).\n763 \n764         This can be used to rotate the axes programmatically.\n765 \n766         To look normal to the primary planes, the following elevation and\n767         azimuth angles can be used. A roll angle of 0, 90, 180, or 270 deg\n768         will rotate these views while keeping the axes at right angles.\n769 \n770         ==========   ====  ====\n771         view plane   elev  azim\n772         ==========   ====  ====\n773         XY           90    -90\n774         XZ           0     -90\n775         YZ           0     0\n776         -XY          -90   90\n777         -XZ          0     90\n778         -YZ          0     180\n779         ==========   ====  ====\n780 \n781         Parameters\n782         ----------\n783         elev : float, default: None\n784             The elevation angle in degrees rotates the camera above the plane\n785             pierced by the vertical axis, with a positive angle corresponding\n786             to a location above that plane. For example, with the default\n787             vertical axis of 'z', the elevation defines the angle of the camera\n788             location above the x-y plane.\n789             If None, then the initial value as specified in the `Axes3D`\n790             constructor is used.\n791         azim : float, default: None\n792             The azimuthal angle in degrees rotates the camera about the\n793             vertical axis, with a positive angle corresponding to a\n794             right-handed rotation. For example, with the default vertical axis\n795             of 'z', a positive azimuth rotates the camera about the origin from\n796             its location along the +x axis towards the +y axis.\n797             If None, then the initial value as specified in the `Axes3D`\n798             constructor is used.\n799         roll : float, default: None\n800             The roll angle in degrees rotates the camera about the viewing\n801             axis. A positive angle spins the camera clockwise, causing the\n802             scene to rotate counter-clockwise.\n803             If None, then the initial value as specified in the `Axes3D`\n804             constructor is used.\n805         vertical_axis : {\"z\", \"x\", \"y\"}, default: \"z\"\n806             The axis to align vertically. *azim* rotates about this axis.\n807         \"\"\"\n808 \n809         self._dist = 10  # The camera distance from origin. Behaves like zoom\n810 \n811         if elev is None:\n812             self.elev = self.initial_elev\n813         else:\n814             self.elev = elev\n815 \n816         if azim is None:\n817             self.azim = self.initial_azim\n818         else:\n819             self.azim = azim\n820 \n821         if roll is None:\n822             self.roll = self.initial_roll\n823         else:\n824             self.roll = roll\n825 \n826         self._vertical_axis = _api.check_getitem(\n827             dict(x=0, y=1, z=2), vertical_axis=vertical_axis\n828         )\n829 \n830     def set_proj_type(self, proj_type, focal_length=None):\n831         \"\"\"\n832         Set the projection type.\n833 \n834         Parameters\n835         ----------\n836         proj_type : {'persp', 'ortho'}\n837             The projection type.\n838         focal_length : float, default: None\n839             For a projection type of 'persp', the focal length of the virtual\n840             camera. Must be > 0. If None, defaults to 1.\n841             The focal length can be computed from a desired Field Of View via\n842             the equation: focal_length = 1/tan(FOV/2)\n843         \"\"\"\n844         _api.check_in_list(['persp', 'ortho'], proj_type=proj_type)\n845         if proj_type == 'persp':\n846             if focal_length is None:\n847                 focal_length = 1\n848             elif focal_length <= 0:\n849                 raise ValueError(f\"focal_length = {focal_length} must be \"\n850                                  \"greater than 0\")\n851             self._focal_length = focal_length\n852         else:  # 'ortho':\n853             if focal_length not in (None, np.inf):\n854                 raise ValueError(f\"focal_length = {focal_length} must be \"\n855                                  f\"None for proj_type = {proj_type}\")\n856             self._focal_length = np.inf\n857 \n858     def _roll_to_vertical(self, arr):\n859         \"\"\"Roll arrays to match the different vertical axis.\"\"\"\n860         return np.roll(arr, self._vertical_axis - 2)\n861 \n862     def get_proj(self):\n863         \"\"\"Create the projection matrix from the current viewing position.\"\"\"\n864 \n865         # Transform to uniform world coordinates 0-1, 0-1, 0-1\n866         box_aspect = self._roll_to_vertical(self._box_aspect)\n867         worldM = proj3d.world_transformation(\n868             *self.get_xlim3d(),\n869             *self.get_ylim3d(),\n870             *self.get_zlim3d(),\n871             pb_aspect=box_aspect,\n872         )\n873 \n874         # Look into the middle of the world coordinates:\n875         R = 0.5 * box_aspect\n876 \n877         # elev: elevation angle in the z plane.\n878         # azim: azimuth angle in the xy plane.\n879         # Coordinates for a point that rotates around the box of data.\n880         # p0, p1 corresponds to rotating the box only around the vertical axis.\n881         # p2 corresponds to rotating the box only around the horizontal axis.\n882         elev_rad = np.deg2rad(self.elev)\n883         azim_rad = np.deg2rad(self.azim)\n884         p0 = np.cos(elev_rad) * np.cos(azim_rad)\n885         p1 = np.cos(elev_rad) * np.sin(azim_rad)\n886         p2 = np.sin(elev_rad)\n887 \n888         # When changing vertical axis the coordinates changes as well.\n889         # Roll the values to get the same behaviour as the default:\n890         ps = self._roll_to_vertical([p0, p1, p2])\n891 \n892         # The coordinates for the eye viewing point. The eye is looking\n893         # towards the middle of the box of data from a distance:\n894         eye = R + self._dist * ps\n895 \n896         # vvec, self._vvec and self._eye are unused, remove when deprecated\n897         vvec = R - eye\n898         self._eye = eye\n899         self._vvec = vvec / np.linalg.norm(vvec)\n900 \n901         # Calculate the viewing axes for the eye position\n902         u, v, w = self._calc_view_axes(eye)\n903         self._view_u = u  # _view_u is towards the right of the screen\n904         self._view_v = v  # _view_v is towards the top of the screen\n905         self._view_w = w  # _view_w is out of the screen\n906 \n907         # Generate the view and projection transformation matrices\n908         if self._focal_length == np.inf:\n909             # Orthographic projection\n910             viewM = proj3d._view_transformation_uvw(u, v, w, eye)\n911             projM = proj3d._ortho_transformation(-self._dist, self._dist)\n912         else:\n913             # Perspective projection\n914             # Scale the eye dist to compensate for the focal length zoom effect\n915             eye_focal = R + self._dist * ps * self._focal_length\n916             viewM = proj3d._view_transformation_uvw(u, v, w, eye_focal)\n917             projM = proj3d._persp_transformation(-self._dist,\n918                                                  self._dist,\n919                                                  self._focal_length)\n920 \n921         # Combine all the transformation matrices to get the final projection\n922         M0 = np.dot(viewM, worldM)\n923         M = np.dot(projM, M0)\n924         return M\n925 \n926     def mouse_init(self, rotate_btn=1, pan_btn=2, zoom_btn=3):\n927         \"\"\"\n928         Set the mouse buttons for 3D rotation and zooming.\n929 \n930         Parameters\n931         ----------\n932         rotate_btn : int or list of int, default: 1\n933             The mouse button or buttons to use for 3D rotation of the axes.\n934         pan_btn : int or list of int, default: 2\n935             The mouse button or buttons to use to pan the 3D axes.\n936         zoom_btn : int or list of int, default: 3\n937             The mouse button or buttons to use to zoom the 3D axes.\n938         \"\"\"\n939         self.button_pressed = None\n940         # coerce scalars into array-like, then convert into\n941         # a regular list to avoid comparisons against None\n942         # which breaks in recent versions of numpy.\n943         self._rotate_btn = np.atleast_1d(rotate_btn).tolist()\n944         self._pan_btn = np.atleast_1d(pan_btn).tolist()\n945         self._zoom_btn = np.atleast_1d(zoom_btn).tolist()\n946 \n947     def disable_mouse_rotation(self):\n948         \"\"\"Disable mouse buttons for 3D rotation, panning, and zooming.\"\"\"\n949         self.mouse_init(rotate_btn=[], pan_btn=[], zoom_btn=[])\n950 \n951     def can_zoom(self):\n952         # doc-string inherited\n953         return True\n954 \n955     def can_pan(self):\n956         # doc-string inherited\n957         return True\n958 \n959     def sharez(self, other):\n960         \"\"\"\n961         Share the z-axis with *other*.\n962 \n963         This is equivalent to passing ``sharez=other`` when constructing the\n964         Axes, and cannot be used if the z-axis is already being shared with\n965         another Axes.\n966         \"\"\"\n967         _api.check_isinstance(maxes._base._AxesBase, other=other)\n968         if self._sharez is not None and other is not self._sharez:\n969             raise ValueError(\"z-axis is already shared\")\n970         self._shared_axes[\"z\"].join(self, other)\n971         self._sharez = other\n972         self.zaxis.major = other.zaxis.major  # Ticker instances holding\n973         self.zaxis.minor = other.zaxis.minor  # locator and formatter.\n974         z0, z1 = other.get_zlim()\n975         self.set_zlim(z0, z1, emit=False, auto=other.get_autoscalez_on())\n976         self.zaxis._scale = other.zaxis._scale\n977 \n978     def clear(self):\n979         # docstring inherited.\n980         super().clear()\n981         if self._focal_length == np.inf:\n982             self._zmargin = mpl.rcParams['axes.zmargin']\n983         else:\n984             self._zmargin = 0.\n985         self.grid(mpl.rcParams['axes3d.grid'])\n986 \n987     def _button_press(self, event):\n988         if event.inaxes == self:\n989             self.button_pressed = event.button\n990             self._sx, self._sy = event.xdata, event.ydata\n991             toolbar = self.figure.canvas.toolbar\n992             if toolbar and toolbar._nav_stack() is None:\n993                 toolbar.push_current()\n994 \n995     def _button_release(self, event):\n996         self.button_pressed = None\n997         toolbar = self.figure.canvas.toolbar\n998         # backend_bases.release_zoom and backend_bases.release_pan call\n999         # push_current, so check the navigation mode so we don't call it twice\n1000         if toolbar and self.get_navigate_mode() is None:\n1001             toolbar.push_current()\n1002 \n1003     def _get_view(self):\n1004         # docstring inherited\n1005         return {\n1006             \"xlim\": self.get_xlim(), \"autoscalex_on\": self.get_autoscalex_on(),\n1007             \"ylim\": self.get_ylim(), \"autoscaley_on\": self.get_autoscaley_on(),\n1008             \"zlim\": self.get_zlim(), \"autoscalez_on\": self.get_autoscalez_on(),\n1009         }, (self.elev, self.azim, self.roll)\n1010 \n1011     def _set_view(self, view):\n1012         # docstring inherited\n1013         props, (elev, azim, roll) = view\n1014         self.set(**props)\n1015         self.elev = elev\n1016         self.azim = azim\n1017         self.roll = roll\n1018 \n1019     def format_zdata(self, z):\n1020         \"\"\"\n1021         Return *z* string formatted.  This function will use the\n1022         :attr:`fmt_zdata` attribute if it is callable, else will fall\n1023         back on the zaxis major formatter\n1024         \"\"\"\n1025         try:\n1026             return self.fmt_zdata(z)\n1027         except (AttributeError, TypeError):\n1028             func = self.zaxis.get_major_formatter().format_data_short\n1029             val = func(z)\n1030             return val\n1031 \n1032     def format_coord(self, xd, yd):\n1033         \"\"\"\n1034         Given the 2D view coordinates attempt to guess a 3D coordinate.\n1035         Looks for the nearest edge to the point and then assumes that\n1036         the point is at the same z location as the nearest point on the edge.\n1037         \"\"\"\n1038 \n1039         if self.M is None:\n1040             return ''\n1041 \n1042         if self.button_pressed in self._rotate_btn:\n1043             # ignore xd and yd and display angles instead\n1044             norm_elev = art3d._norm_angle(self.elev)\n1045             norm_azim = art3d._norm_angle(self.azim)\n1046             norm_roll = art3d._norm_angle(self.roll)\n1047             return (f\"elevation={norm_elev:.0f}\\N{DEGREE SIGN}, \"\n1048                     f\"azimuth={norm_azim:.0f}\\N{DEGREE SIGN}, \"\n1049                     f\"roll={norm_roll:.0f}\\N{DEGREE SIGN}\"\n1050                     ).replace(\"-\", \"\\N{MINUS SIGN}\")\n1051 \n1052         # nearest edge\n1053         p0, p1 = min(self._tunit_edges(),\n1054                      key=lambda edge: proj3d._line2d_seg_dist(\n1055                          (xd, yd), edge[0][:2], edge[1][:2]))\n1056 \n1057         # scale the z value to match\n1058         x0, y0, z0 = p0\n1059         x1, y1, z1 = p1\n1060         d0 = np.hypot(x0-xd, y0-yd)\n1061         d1 = np.hypot(x1-xd, y1-yd)\n1062         dt = d0+d1\n1063         z = d1/dt * z0 + d0/dt * z1\n1064 \n1065         x, y, z = proj3d.inv_transform(xd, yd, z, self.M)\n1066 \n1067         xs = self.format_xdata(x)\n1068         ys = self.format_ydata(y)\n1069         zs = self.format_zdata(z)\n1070         return f'x={xs}, y={ys}, z={zs}'\n1071 \n1072     def _on_move(self, event):\n1073         \"\"\"\n1074         Mouse moving.\n1075 \n1076         By default, button-1 rotates, button-2 pans, and button-3 zooms;\n1077         these buttons can be modified via `mouse_init`.\n1078         \"\"\"\n1079 \n1080         if not self.button_pressed:\n1081             return\n1082 \n1083         if self.get_navigate_mode() is not None:\n1084             # we don't want to rotate if we are zooming/panning\n1085             # from the toolbar\n1086             return\n1087 \n1088         if self.M is None:\n1089             return\n1090 \n1091         x, y = event.xdata, event.ydata\n1092         # In case the mouse is out of bounds.\n1093         if x is None or event.inaxes != self:\n1094             return\n1095 \n1096         dx, dy = x - self._sx, y - self._sy\n1097         w = self._pseudo_w\n1098         h = self._pseudo_h\n1099 \n1100         # Rotation\n1101         if self.button_pressed in self._rotate_btn:\n1102             # rotate viewing point\n1103             # get the x and y pixel coords\n1104             if dx == 0 and dy == 0:\n1105                 return\n1106 \n1107             roll = np.deg2rad(self.roll)\n1108             delev = -(dy/h)*180*np.cos(roll) + (dx/w)*180*np.sin(roll)\n1109             dazim = -(dy/h)*180*np.sin(roll) - (dx/w)*180*np.cos(roll)\n1110             self.elev = self.elev + delev\n1111             self.azim = self.azim + dazim\n1112             self.stale = True\n1113 \n1114         elif self.button_pressed in self._pan_btn:\n1115             # Start the pan event with pixel coordinates\n1116             px, py = self.transData.transform([self._sx, self._sy])\n1117             self.start_pan(px, py, 2)\n1118             # pan view (takes pixel coordinate input)\n1119             self.drag_pan(2, None, event.x, event.y)\n1120             self.end_pan()\n1121 \n1122         # Zoom\n1123         elif self.button_pressed in self._zoom_btn:\n1124             # zoom view (dragging down zooms in)\n1125             scale = h/(h - dy)\n1126             self._scale_axis_limits(scale, scale, scale)\n1127 \n1128         # Store the event coordinates for the next time through.\n1129         self._sx, self._sy = x, y\n1130         # Always request a draw update at the end of interaction\n1131         self.figure.canvas.draw_idle()\n1132 \n1133     def drag_pan(self, button, key, x, y):\n1134         # docstring inherited\n1135 \n1136         # Get the coordinates from the move event\n1137         p = self._pan_start\n1138         (xdata, ydata), (xdata_start, ydata_start) = p.trans_inverse.transform(\n1139             [(x, y), (p.x, p.y)])\n1140         self._sx, self._sy = xdata, ydata\n1141         # Calling start_pan() to set the x/y of this event as the starting\n1142         # move location for the next event\n1143         self.start_pan(x, y, button)\n1144         du, dv = xdata - xdata_start, ydata - ydata_start\n1145         dw = 0\n1146         if key == 'x':\n1147             dv = 0\n1148         elif key == 'y':\n1149             du = 0\n1150         if du == 0 and dv == 0:\n1151             return\n1152 \n1153         # Transform the pan from the view axes to the data axes\n1154         R = np.array([self._view_u, self._view_v, self._view_w])\n1155         R = -R / self._box_aspect * self._dist\n1156         duvw_projected = R.T @ np.array([du, dv, dw])\n1157 \n1158         # Calculate pan distance\n1159         minx, maxx, miny, maxy, minz, maxz = self.get_w_lims()\n1160         dx = (maxx - minx) * duvw_projected[0]\n1161         dy = (maxy - miny) * duvw_projected[1]\n1162         dz = (maxz - minz) * duvw_projected[2]\n1163 \n1164         # Set the new axis limits\n1165         self.set_xlim3d(minx + dx, maxx + dx)\n1166         self.set_ylim3d(miny + dy, maxy + dy)\n1167         self.set_zlim3d(minz + dz, maxz + dz)\n1168 \n1169     def _calc_view_axes(self, eye):\n1170         \"\"\"\n1171         Get the unit vectors for the viewing axes in data coordinates.\n1172         `u` is towards the right of the screen\n1173         `v` is towards the top of the screen\n1174         `w` is out of the screen\n1175         \"\"\"\n1176         elev_rad = np.deg2rad(art3d._norm_angle(self.elev))\n1177         roll_rad = np.deg2rad(art3d._norm_angle(self.roll))\n1178 \n1179         # Look into the middle of the world coordinates\n1180         R = 0.5 * self._roll_to_vertical(self._box_aspect)\n1181 \n1182         # Define which axis should be vertical. A negative value\n1183         # indicates the plot is upside down and therefore the values\n1184         # have been reversed:\n1185         V = np.zeros(3)\n1186         V[self._vertical_axis] = -1 if abs(elev_rad) > np.pi/2 else 1\n1187 \n1188         u, v, w = proj3d._view_axes(eye, R, V, roll_rad)\n1189         return u, v, w\n1190 \n1191     def _set_view_from_bbox(self, bbox, direction='in',\n1192                             mode=None, twinx=False, twiny=False):\n1193         \"\"\"\n1194         Zoom in or out of the bounding box.\n1195 \n1196         Will center the view in the center of the bounding box, and zoom by\n1197         the ratio of the size of the bounding box to the size of the Axes3D.\n1198         \"\"\"\n1199         (start_x, start_y, stop_x, stop_y) = bbox\n1200         if mode == 'x':\n1201             start_y = self.bbox.min[1]\n1202             stop_y = self.bbox.max[1]\n1203         elif mode == 'y':\n1204             start_x = self.bbox.min[0]\n1205             stop_x = self.bbox.max[0]\n1206 \n1207         # Clip to bounding box limits\n1208         start_x, stop_x = np.clip(sorted([start_x, stop_x]),\n1209                                   self.bbox.min[0], self.bbox.max[0])\n1210         start_y, stop_y = np.clip(sorted([start_y, stop_y]),\n1211                                   self.bbox.min[1], self.bbox.max[1])\n1212 \n1213         # Move the center of the view to the center of the bbox\n1214         zoom_center_x = (start_x + stop_x)/2\n1215         zoom_center_y = (start_y + stop_y)/2\n1216 \n1217         ax_center_x = (self.bbox.max[0] + self.bbox.min[0])/2\n1218         ax_center_y = (self.bbox.max[1] + self.bbox.min[1])/2\n1219 \n1220         self.start_pan(zoom_center_x, zoom_center_y, 2)\n1221         self.drag_pan(2, None, ax_center_x, ax_center_y)\n1222         self.end_pan()\n1223 \n1224         # Calculate zoom level\n1225         dx = abs(start_x - stop_x)\n1226         dy = abs(start_y - stop_y)\n1227         scale_u = dx / (self.bbox.max[0] - self.bbox.min[0])\n1228         scale_v = dy / (self.bbox.max[1] - self.bbox.min[1])\n1229 \n1230         # Keep aspect ratios equal\n1231         scale = max(scale_u, scale_v)\n1232 \n1233         # Zoom out\n1234         if direction == 'out':\n1235             scale = 1 / scale\n1236 \n1237         self._zoom_data_limits(scale, scale, scale)\n1238 \n1239     def _zoom_data_limits(self, scale_u, scale_v, scale_w):\n1240         \"\"\"\n1241         Zoom in or out of a 3D plot.\n1242 \n1243         Will scale the data limits by the scale factors. These will be\n1244         transformed to the x, y, z data axes based on the current view angles.\n1245         A scale factor > 1 zooms out and a scale factor < 1 zooms in.\n1246 \n1247         For an axes that has had its aspect ratio set to 'equal', 'equalxy',\n1248         'equalyz', or 'equalxz', the relevant axes are constrained to zoom\n1249         equally.\n1250 \n1251         Parameters\n1252         ----------\n1253         scale_u : float\n1254             Scale factor for the u view axis (view screen horizontal).\n1255         scale_v : float\n1256             Scale factor for the v view axis (view screen vertical).\n1257         scale_w : float\n1258             Scale factor for the w view axis (view screen depth).\n1259         \"\"\"\n1260         scale = np.array([scale_u, scale_v, scale_w])\n1261 \n1262         # Only perform frame conversion if unequal scale factors\n1263         if not np.allclose(scale, scale_u):\n1264             # Convert the scale factors from the view frame to the data frame\n1265             R = np.array([self._view_u, self._view_v, self._view_w])\n1266             S = scale * np.eye(3)\n1267             scale = np.linalg.norm(R.T @ S, axis=1)\n1268 \n1269             # Set the constrained scale factors to the factor closest to 1\n1270             if self._aspect in ('equal', 'equalxy', 'equalxz', 'equalyz'):\n1271                 ax_idxs = self._equal_aspect_axis_indices(self._aspect)\n1272                 min_ax_idxs = np.argmin(np.abs(scale[ax_idxs] - 1))\n1273                 scale[ax_idxs] = scale[ax_idxs][min_ax_idxs]\n1274 \n1275         self._scale_axis_limits(scale[0], scale[1], scale[2])\n1276 \n1277     def _scale_axis_limits(self, scale_x, scale_y, scale_z):\n1278         \"\"\"\n1279         Keeping the center of the x, y, and z data axes fixed, scale their\n1280         limits by scale factors. A scale factor > 1 zooms out and a scale\n1281         factor < 1 zooms in.\n1282 \n1283         Parameters\n1284         ----------\n1285         scale_x : float\n1286             Scale factor for the x data axis.\n1287         scale_y : float\n1288             Scale factor for the y data axis.\n1289         scale_z : float\n1290             Scale factor for the z data axis.\n1291         \"\"\"\n1292         # Get the axis limits and centers\n1293         minx, maxx, miny, maxy, minz, maxz = self.get_w_lims()\n1294         cx = (maxx + minx)/2\n1295         cy = (maxy + miny)/2\n1296         cz = (maxz + minz)/2\n1297 \n1298         # Scale the data range\n1299         dx = (maxx - minx)*scale_x\n1300         dy = (maxy - miny)*scale_y\n1301         dz = (maxz - minz)*scale_z\n1302 \n1303         # Set the scaled axis limits\n1304         self.set_xlim3d(cx - dx/2, cx + dx/2)\n1305         self.set_ylim3d(cy - dy/2, cy + dy/2)\n1306         self.set_zlim3d(cz - dz/2, cz + dz/2)\n1307 \n1308     def set_zlabel(self, zlabel, fontdict=None, labelpad=None, **kwargs):\n1309         \"\"\"\n1310         Set zlabel.  See doc for `.set_ylabel` for description.\n1311         \"\"\"\n1312         if labelpad is not None:\n1313             self.zaxis.labelpad = labelpad\n1314         return self.zaxis.set_label_text(zlabel, fontdict, **kwargs)\n1315 \n1316     def get_zlabel(self):\n1317         \"\"\"\n1318         Get the z-label text string.\n1319         \"\"\"\n1320         label = self.zaxis.get_label()\n1321         return label.get_text()\n1322 \n1323     # Axes rectangle characteristics\n1324 \n1325     # The frame_on methods are not available for 3D axes.\n1326     # Python will raise a TypeError if they are called.\n1327     get_frame_on = None\n1328     set_frame_on = None\n1329 \n1330     def grid(self, visible=True, **kwargs):\n1331         \"\"\"\n1332         Set / unset 3D grid.\n1333 \n1334         .. note::\n1335 \n1336             Currently, this function does not behave the same as\n1337             `.axes.Axes.grid`, but it is intended to eventually support that\n1338             behavior.\n1339         \"\"\"\n1340         # TODO: Operate on each axes separately\n1341         if len(kwargs):\n1342             visible = True\n1343         self._draw_grid = visible\n1344         self.stale = True\n1345 \n1346     def tick_params(self, axis='both', **kwargs):\n1347         \"\"\"\n1348         Convenience method for changing the appearance of ticks and\n1349         tick labels.\n1350 \n1351         See `.Axes.tick_params` for full documentation.  Because this function\n1352         applies to 3D Axes, *axis* can also be set to 'z', and setting *axis*\n1353         to 'both' autoscales all three axes.\n1354 \n1355         Also, because of how Axes3D objects are drawn very differently\n1356         from regular 2D axes, some of these settings may have\n1357         ambiguous meaning.  For simplicity, the 'z' axis will\n1358         accept settings as if it was like the 'y' axis.\n1359 \n1360         .. note::\n1361            Axes3D currently ignores some of these settings.\n1362         \"\"\"\n1363         _api.check_in_list(['x', 'y', 'z', 'both'], axis=axis)\n1364         if axis in ['x', 'y', 'both']:\n1365             super().tick_params(axis, **kwargs)\n1366         if axis in ['z', 'both']:\n1367             zkw = dict(kwargs)\n1368             zkw.pop('top', None)\n1369             zkw.pop('bottom', None)\n1370             zkw.pop('labeltop', None)\n1371             zkw.pop('labelbottom', None)\n1372             self.zaxis.set_tick_params(**zkw)\n1373 \n1374     # data limits, ticks, tick labels, and formatting\n1375 \n1376     def invert_zaxis(self):\n1377         \"\"\"\n1378         Invert the z-axis.\n1379         \"\"\"\n1380         bottom, top = self.get_zlim()\n1381         self.set_zlim(top, bottom, auto=None)\n1382 \n1383     zaxis_inverted = _axis_method_wrapper(\"zaxis\", \"get_inverted\")\n1384 \n1385     def get_zbound(self):\n1386         \"\"\"\n1387         Return the lower and upper z-axis bounds, in increasing order.\n1388         \"\"\"\n1389         bottom, top = self.get_zlim()\n1390         if bottom < top:\n1391             return bottom, top\n1392         else:\n1393             return top, bottom\n1394 \n1395     def set_zbound(self, lower=None, upper=None):\n1396         \"\"\"\n1397         Set the lower and upper numerical bounds of the z-axis.\n1398 \n1399         This method will honor axes inversion regardless of parameter order.\n1400         It will not change the autoscaling setting (`.get_autoscalez_on()`).\n1401         \"\"\"\n1402         if upper is None and np.iterable(lower):\n1403             lower, upper = lower\n1404 \n1405         old_lower, old_upper = self.get_zbound()\n1406         if lower is None:\n1407             lower = old_lower\n1408         if upper is None:\n1409             upper = old_upper\n1410 \n1411         self.set_zlim(sorted((lower, upper),\n1412                              reverse=bool(self.zaxis_inverted())),\n1413                       auto=None)\n1414 \n1415     def text(self, x, y, z, s, zdir=None, **kwargs):\n1416         \"\"\"\n1417         Add text to the plot.\n1418 \n1419         Keyword arguments will be passed on to `.Axes.text`, except for the\n1420         *zdir* keyword, which sets the direction to be used as the z\n1421         direction.\n1422         \"\"\"\n1423         text = super().text(x, y, s, **kwargs)\n1424         art3d.text_2d_to_3d(text, z, zdir)\n1425         return text\n1426 \n1427     text3D = text\n1428     text2D = Axes.text\n1429 \n1430     def plot(self, xs, ys, *args, zdir='z', **kwargs):\n1431         \"\"\"\n1432         Plot 2D or 3D data.\n1433 \n1434         Parameters\n1435         ----------\n1436         xs : 1D array-like\n1437             x coordinates of vertices.\n1438         ys : 1D array-like\n1439             y coordinates of vertices.\n1440         zs : float or 1D array-like\n1441             z coordinates of vertices; either one for all points or one for\n1442             each point.\n1443         zdir : {'x', 'y', 'z'}, default: 'z'\n1444             When plotting 2D data, the direction to use as z.\n1445         **kwargs\n1446             Other arguments are forwarded to `matplotlib.axes.Axes.plot`.\n1447         \"\"\"\n1448         had_data = self.has_data()\n1449 \n1450         # `zs` can be passed positionally or as keyword; checking whether\n1451         # args[0] is a string matches the behavior of 2D `plot` (via\n1452         # `_process_plot_var_args`).\n1453         if args and not isinstance(args[0], str):\n1454             zs, *args = args\n1455             if 'zs' in kwargs:\n1456                 raise TypeError(\"plot() for multiple values for argument 'z'\")\n1457         else:\n1458             zs = kwargs.pop('zs', 0)\n1459 \n1460         # Match length\n1461         zs = np.broadcast_to(zs, np.shape(xs))\n1462 \n1463         lines = super().plot(xs, ys, *args, **kwargs)\n1464         for line in lines:\n1465             art3d.line_2d_to_3d(line, zs=zs, zdir=zdir)\n1466 \n1467         xs, ys, zs = art3d.juggle_axes(xs, ys, zs, zdir)\n1468         self.auto_scale_xyz(xs, ys, zs, had_data)\n1469         return lines\n1470 \n1471     plot3D = plot\n1472 \n1473     def plot_surface(self, X, Y, Z, *, norm=None, vmin=None,\n1474                      vmax=None, lightsource=None, **kwargs):\n1475         \"\"\"\n1476         Create a surface plot.\n1477 \n1478         By default, it will be colored in shades of a solid color, but it also\n1479         supports colormapping by supplying the *cmap* argument.\n1480 \n1481         .. note::\n1482 \n1483            The *rcount* and *ccount* kwargs, which both default to 50,\n1484            determine the maximum number of samples used in each direction.  If\n1485            the input data is larger, it will be downsampled (by slicing) to\n1486            these numbers of points.\n1487 \n1488         .. note::\n1489 \n1490            To maximize rendering speed consider setting *rstride* and *cstride*\n1491            to divisors of the number of rows minus 1 and columns minus 1\n1492            respectively. For example, given 51 rows rstride can be any of the\n1493            divisors of 50.\n1494 \n1495            Similarly, a setting of *rstride* and *cstride* equal to 1 (or\n1496            *rcount* and *ccount* equal the number of rows and columns) can use\n1497            the optimized path.\n1498 \n1499         Parameters\n1500         ----------\n1501         X, Y, Z : 2D arrays\n1502             Data values.\n1503 \n1504         rcount, ccount : int\n1505             Maximum number of samples used in each direction.  If the input\n1506             data is larger, it will be downsampled (by slicing) to these\n1507             numbers of points.  Defaults to 50.\n1508 \n1509         rstride, cstride : int\n1510             Downsampling stride in each direction.  These arguments are\n1511             mutually exclusive with *rcount* and *ccount*.  If only one of\n1512             *rstride* or *cstride* is set, the other defaults to 10.\n1513 \n1514             'classic' mode uses a default of ``rstride = cstride = 10`` instead\n1515             of the new default of ``rcount = ccount = 50``.\n1516 \n1517         color : color-like\n1518             Color of the surface patches.\n1519 \n1520         cmap : Colormap\n1521             Colormap of the surface patches.\n1522 \n1523         facecolors : array-like of colors.\n1524             Colors of each individual patch.\n1525 \n1526         norm : Normalize\n1527             Normalization for the colormap.\n1528 \n1529         vmin, vmax : float\n1530             Bounds for the normalization.\n1531 \n1532         shade : bool, default: True\n1533             Whether to shade the facecolors.  Shading is always disabled when\n1534             *cmap* is specified.\n1535 \n1536         lightsource : `~matplotlib.colors.LightSource`\n1537             The lightsource to use when *shade* is True.\n1538 \n1539         **kwargs\n1540             Other keyword arguments are forwarded to `.Poly3DCollection`.\n1541         \"\"\"\n1542 \n1543         had_data = self.has_data()\n1544 \n1545         if Z.ndim != 2:\n1546             raise ValueError(\"Argument Z must be 2-dimensional.\")\n1547 \n1548         Z = cbook._to_unmasked_float_array(Z)\n1549         X, Y, Z = np.broadcast_arrays(X, Y, Z)\n1550         rows, cols = Z.shape\n1551 \n1552         has_stride = 'rstride' in kwargs or 'cstride' in kwargs\n1553         has_count = 'rcount' in kwargs or 'ccount' in kwargs\n1554 \n1555         if has_stride and has_count:\n1556             raise ValueError(\"Cannot specify both stride and count arguments\")\n1557 \n1558         rstride = kwargs.pop('rstride', 10)\n1559         cstride = kwargs.pop('cstride', 10)\n1560         rcount = kwargs.pop('rcount', 50)\n1561         ccount = kwargs.pop('ccount', 50)\n1562 \n1563         if mpl.rcParams['_internal.classic_mode']:\n1564             # Strides have priority over counts in classic mode.\n1565             # So, only compute strides from counts\n1566             # if counts were explicitly given\n1567             compute_strides = has_count\n1568         else:\n1569             # If the strides are provided then it has priority.\n1570             # Otherwise, compute the strides from the counts.\n1571             compute_strides = not has_stride\n1572 \n1573         if compute_strides:\n1574             rstride = int(max(np.ceil(rows / rcount), 1))\n1575             cstride = int(max(np.ceil(cols / ccount), 1))\n1576 \n1577         fcolors = kwargs.pop('facecolors', None)\n1578 \n1579         cmap = kwargs.get('cmap', None)\n1580         shade = kwargs.pop('shade', cmap is None)\n1581         if shade is None:\n1582             raise ValueError(\"shade cannot be None.\")\n1583 \n1584         colset = []  # the sampled facecolor\n1585         if (rows - 1) % rstride == 0 and \\\n1586            (cols - 1) % cstride == 0 and \\\n1587            fcolors is None:\n1588             polys = np.stack(\n1589                 [cbook._array_patch_perimeters(a, rstride, cstride)\n1590                  for a in (X, Y, Z)],\n1591                 axis=-1)\n1592         else:\n1593             # evenly spaced, and including both endpoints\n1594             row_inds = list(range(0, rows-1, rstride)) + [rows-1]\n1595             col_inds = list(range(0, cols-1, cstride)) + [cols-1]\n1596 \n1597             polys = []\n1598             for rs, rs_next in zip(row_inds[:-1], row_inds[1:]):\n1599                 for cs, cs_next in zip(col_inds[:-1], col_inds[1:]):\n1600                     ps = [\n1601                         # +1 ensures we share edges between polygons\n1602                         cbook._array_perimeter(a[rs:rs_next+1, cs:cs_next+1])\n1603                         for a in (X, Y, Z)\n1604                     ]\n1605                     # ps = np.stack(ps, axis=-1)\n1606                     ps = np.array(ps).T\n1607                     polys.append(ps)\n1608 \n1609                     if fcolors is not None:\n1610                         colset.append(fcolors[rs][cs])\n1611 \n1612         # In cases where there are NaNs in the data (possibly from masked\n1613         # arrays), artifacts can be introduced. Here check whether NaNs exist\n1614         # and remove the entries if so\n1615         if not isinstance(polys, np.ndarray) or np.isnan(polys).any():\n1616             new_polys = []\n1617             new_colset = []\n1618 \n1619             # Depending on fcolors, colset is either an empty list or has as\n1620             # many elements as polys. In the former case new_colset results in\n1621             # a list with None entries, that is discarded later.\n1622             for p, col in itertools.zip_longest(polys, colset):\n1623                 new_poly = np.array(p)[~np.isnan(p).any(axis=1)]\n1624                 if len(new_poly):\n1625                     new_polys.append(new_poly)\n1626                     new_colset.append(col)\n1627 \n1628             # Replace previous polys and, if fcolors is not None, colset\n1629             polys = new_polys\n1630             if fcolors is not None:\n1631                 colset = new_colset\n1632 \n1633         # note that the striding causes some polygons to have more coordinates\n1634         # than others\n1635 \n1636         if fcolors is not None:\n1637             polyc = art3d.Poly3DCollection(\n1638                 polys, edgecolors=colset, facecolors=colset, shade=shade,\n1639                 lightsource=lightsource, **kwargs)\n1640         elif cmap:\n1641             polyc = art3d.Poly3DCollection(polys, **kwargs)\n1642             # can't always vectorize, because polys might be jagged\n1643             if isinstance(polys, np.ndarray):\n1644                 avg_z = polys[..., 2].mean(axis=-1)\n1645             else:\n1646                 avg_z = np.array([ps[:, 2].mean() for ps in polys])\n1647             polyc.set_array(avg_z)\n1648             if vmin is not None or vmax is not None:\n1649                 polyc.set_clim(vmin, vmax)\n1650             if norm is not None:\n1651                 polyc.set_norm(norm)\n1652         else:\n1653             color = kwargs.pop('color', None)\n1654             if color is None:\n1655                 color = self._get_lines.get_next_color()\n1656             color = np.array(mcolors.to_rgba(color))\n1657 \n1658             polyc = art3d.Poly3DCollection(\n1659                 polys, facecolors=color, shade=shade,\n1660                 lightsource=lightsource, **kwargs)\n1661 \n1662         self.add_collection(polyc)\n1663         self.auto_scale_xyz(X, Y, Z, had_data)\n1664 \n1665         return polyc\n1666 \n1667     def plot_wireframe(self, X, Y, Z, **kwargs):\n1668         \"\"\"\n1669         Plot a 3D wireframe.\n1670 \n1671         .. note::\n1672 \n1673            The *rcount* and *ccount* kwargs, which both default to 50,\n1674            determine the maximum number of samples used in each direction.  If\n1675            the input data is larger, it will be downsampled (by slicing) to\n1676            these numbers of points.\n1677 \n1678         Parameters\n1679         ----------\n1680         X, Y, Z : 2D arrays\n1681             Data values.\n1682 \n1683         rcount, ccount : int\n1684             Maximum number of samples used in each direction.  If the input\n1685             data is larger, it will be downsampled (by slicing) to these\n1686             numbers of points.  Setting a count to zero causes the data to be\n1687             not sampled in the corresponding direction, producing a 3D line\n1688             plot rather than a wireframe plot.  Defaults to 50.\n1689 \n1690         rstride, cstride : int\n1691             Downsampling stride in each direction.  These arguments are\n1692             mutually exclusive with *rcount* and *ccount*.  If only one of\n1693             *rstride* or *cstride* is set, the other defaults to 1.  Setting a\n1694             stride to zero causes the data to be not sampled in the\n1695             corresponding direction, producing a 3D line plot rather than a\n1696             wireframe plot.\n1697 \n1698             'classic' mode uses a default of ``rstride = cstride = 1`` instead\n1699             of the new default of ``rcount = ccount = 50``.\n1700 \n1701         **kwargs\n1702             Other keyword arguments are forwarded to `.Line3DCollection`.\n1703         \"\"\"\n1704 \n1705         had_data = self.has_data()\n1706         if Z.ndim != 2:\n1707             raise ValueError(\"Argument Z must be 2-dimensional.\")\n1708         # FIXME: Support masked arrays\n1709         X, Y, Z = np.broadcast_arrays(X, Y, Z)\n1710         rows, cols = Z.shape\n1711 \n1712         has_stride = 'rstride' in kwargs or 'cstride' in kwargs\n1713         has_count = 'rcount' in kwargs or 'ccount' in kwargs\n1714 \n1715         if has_stride and has_count:\n1716             raise ValueError(\"Cannot specify both stride and count arguments\")\n1717 \n1718         rstride = kwargs.pop('rstride', 1)\n1719         cstride = kwargs.pop('cstride', 1)\n1720         rcount = kwargs.pop('rcount', 50)\n1721         ccount = kwargs.pop('ccount', 50)\n1722 \n1723         if mpl.rcParams['_internal.classic_mode']:\n1724             # Strides have priority over counts in classic mode.\n1725             # So, only compute strides from counts\n1726             # if counts were explicitly given\n1727             if has_count:\n1728                 rstride = int(max(np.ceil(rows / rcount), 1)) if rcount else 0\n1729                 cstride = int(max(np.ceil(cols / ccount), 1)) if ccount else 0\n1730         else:\n1731             # If the strides are provided then it has priority.\n1732             # Otherwise, compute the strides from the counts.\n1733             if not has_stride:\n1734                 rstride = int(max(np.ceil(rows / rcount), 1)) if rcount else 0\n1735                 cstride = int(max(np.ceil(cols / ccount), 1)) if ccount else 0\n1736 \n1737         # We want two sets of lines, one running along the \"rows\" of\n1738         # Z and another set of lines running along the \"columns\" of Z.\n1739         # This transpose will make it easy to obtain the columns.\n1740         tX, tY, tZ = np.transpose(X), np.transpose(Y), np.transpose(Z)\n1741 \n1742         if rstride:\n1743             rii = list(range(0, rows, rstride))\n1744             # Add the last index only if needed\n1745             if rows > 0 and rii[-1] != (rows - 1):\n1746                 rii += [rows-1]\n1747         else:\n1748             rii = []\n1749         if cstride:\n1750             cii = list(range(0, cols, cstride))\n1751             # Add the last index only if needed\n1752             if cols > 0 and cii[-1] != (cols - 1):\n1753                 cii += [cols-1]\n1754         else:\n1755             cii = []\n1756 \n1757         if rstride == 0 and cstride == 0:\n1758             raise ValueError(\"Either rstride or cstride must be non zero\")\n1759 \n1760         # If the inputs were empty, then just\n1761         # reset everything.\n1762         if Z.size == 0:\n1763             rii = []\n1764             cii = []\n1765 \n1766         xlines = [X[i] for i in rii]\n1767         ylines = [Y[i] for i in rii]\n1768         zlines = [Z[i] for i in rii]\n1769 \n1770         txlines = [tX[i] for i in cii]\n1771         tylines = [tY[i] for i in cii]\n1772         tzlines = [tZ[i] for i in cii]\n1773 \n1774         lines = ([list(zip(xl, yl, zl))\n1775                  for xl, yl, zl in zip(xlines, ylines, zlines)]\n1776                  + [list(zip(xl, yl, zl))\n1777                  for xl, yl, zl in zip(txlines, tylines, tzlines)])\n1778 \n1779         linec = art3d.Line3DCollection(lines, **kwargs)\n1780         self.add_collection(linec)\n1781         self.auto_scale_xyz(X, Y, Z, had_data)\n1782 \n1783         return linec\n1784 \n1785     def plot_trisurf(self, *args, color=None, norm=None, vmin=None, vmax=None,\n1786                      lightsource=None, **kwargs):\n1787         \"\"\"\n1788         Plot a triangulated surface.\n1789 \n1790         The (optional) triangulation can be specified in one of two ways;\n1791         either::\n1792 \n1793           plot_trisurf(triangulation, ...)\n1794 \n1795         where triangulation is a `~matplotlib.tri.Triangulation` object, or::\n1796 \n1797           plot_trisurf(X, Y, ...)\n1798           plot_trisurf(X, Y, triangles, ...)\n1799           plot_trisurf(X, Y, triangles=triangles, ...)\n1800 \n1801         in which case a Triangulation object will be created.  See\n1802         `.Triangulation` for an explanation of these possibilities.\n1803 \n1804         The remaining arguments are::\n1805 \n1806           plot_trisurf(..., Z)\n1807 \n1808         where *Z* is the array of values to contour, one per point\n1809         in the triangulation.\n1810 \n1811         Parameters\n1812         ----------\n1813         X, Y, Z : array-like\n1814             Data values as 1D arrays.\n1815         color\n1816             Color of the surface patches.\n1817         cmap\n1818             A colormap for the surface patches.\n1819         norm : Normalize\n1820             An instance of Normalize to map values to colors.\n1821         vmin, vmax : float, default: None\n1822             Minimum and maximum value to map.\n1823         shade : bool, default: True\n1824             Whether to shade the facecolors.  Shading is always disabled when\n1825             *cmap* is specified.\n1826         lightsource : `~matplotlib.colors.LightSource`\n1827             The lightsource to use when *shade* is True.\n1828         **kwargs\n1829             All other keyword arguments are passed on to\n1830             :class:`~mpl_toolkits.mplot3d.art3d.Poly3DCollection`\n1831 \n1832         Examples\n1833         --------\n1834         .. plot:: gallery/mplot3d/trisurf3d.py\n1835         .. plot:: gallery/mplot3d/trisurf3d_2.py\n1836         \"\"\"\n1837 \n1838         had_data = self.has_data()\n1839 \n1840         # TODO: Support custom face colours\n1841         if color is None:\n1842             color = self._get_lines.get_next_color()\n1843         color = np.array(mcolors.to_rgba(color))\n1844 \n1845         cmap = kwargs.get('cmap', None)\n1846         shade = kwargs.pop('shade', cmap is None)\n1847 \n1848         tri, args, kwargs = \\\n1849             Triangulation.get_from_args_and_kwargs(*args, **kwargs)\n1850         try:\n1851             z = kwargs.pop('Z')\n1852         except KeyError:\n1853             # We do this so Z doesn't get passed as an arg to PolyCollection\n1854             z, *args = args\n1855         z = np.asarray(z)\n1856 \n1857         triangles = tri.get_masked_triangles()\n1858         xt = tri.x[triangles]\n1859         yt = tri.y[triangles]\n1860         zt = z[triangles]\n1861         verts = np.stack((xt, yt, zt), axis=-1)\n1862 \n1863         if cmap:\n1864             polyc = art3d.Poly3DCollection(verts, *args, **kwargs)\n1865             # average over the three points of each triangle\n1866             avg_z = verts[:, :, 2].mean(axis=1)\n1867             polyc.set_array(avg_z)\n1868             if vmin is not None or vmax is not None:\n1869                 polyc.set_clim(vmin, vmax)\n1870             if norm is not None:\n1871                 polyc.set_norm(norm)\n1872         else:\n1873             polyc = art3d.Poly3DCollection(\n1874                 verts, *args, shade=shade, lightsource=lightsource,\n1875                 facecolors=color, **kwargs)\n1876 \n1877         self.add_collection(polyc)\n1878         self.auto_scale_xyz(tri.x, tri.y, z, had_data)\n1879 \n1880         return polyc\n1881 \n1882     def _3d_extend_contour(self, cset, stride=5):\n1883         \"\"\"\n1884         Extend a contour in 3D by creating\n1885         \"\"\"\n1886 \n1887         levels = cset.levels\n1888         colls = cset.collections\n1889         dz = (levels[1] - levels[0]) / 2\n1890 \n1891         for z, linec in zip(levels, colls):\n1892             paths = linec.get_paths()\n1893             if not paths:\n1894                 continue\n1895             topverts = art3d._paths_to_3d_segments(paths, z - dz)\n1896             botverts = art3d._paths_to_3d_segments(paths, z + dz)\n1897 \n1898             color = linec.get_edgecolor()[0]\n1899 \n1900             nsteps = round(len(topverts[0]) / stride)\n1901             if nsteps <= 1:\n1902                 if len(topverts[0]) > 1:\n1903                     nsteps = 2\n1904                 else:\n1905                     continue\n1906 \n1907             polyverts = []\n1908             stepsize = (len(topverts[0]) - 1) / (nsteps - 1)\n1909             for i in range(round(nsteps) - 1):\n1910                 i1 = round(i * stepsize)\n1911                 i2 = round((i + 1) * stepsize)\n1912                 polyverts.append([topverts[0][i1],\n1913                                   topverts[0][i2],\n1914                                   botverts[0][i2],\n1915                                   botverts[0][i1]])\n1916 \n1917             # all polygons have 4 vertices, so vectorize\n1918             polyverts = np.array(polyverts)\n1919             polycol = art3d.Poly3DCollection(polyverts,\n1920                                              facecolors=color,\n1921                                              edgecolors=color,\n1922                                              shade=True)\n1923             polycol.set_sort_zpos(z)\n1924             self.add_collection3d(polycol)\n1925 \n1926         for col in colls:\n1927             col.remove()\n1928 \n1929     def add_contour_set(\n1930             self, cset, extend3d=False, stride=5, zdir='z', offset=None):\n1931         zdir = '-' + zdir\n1932         if extend3d:\n1933             self._3d_extend_contour(cset, stride)\n1934         else:\n1935             for z, linec in zip(cset.levels, cset.collections):\n1936                 if offset is not None:\n1937                     z = offset\n1938                 art3d.line_collection_2d_to_3d(linec, z, zdir=zdir)\n1939 \n1940     def add_contourf_set(self, cset, zdir='z', offset=None):\n1941         self._add_contourf_set(cset, zdir=zdir, offset=offset)\n1942 \n1943     def _add_contourf_set(self, cset, zdir='z', offset=None):\n1944         \"\"\"\n1945         Returns\n1946         -------\n1947         levels : `numpy.ndarray`\n1948             Levels at which the filled contours are added.\n1949         \"\"\"\n1950         zdir = '-' + zdir\n1951 \n1952         midpoints = cset.levels[:-1] + np.diff(cset.levels) / 2\n1953         # Linearly interpolate to get levels for any extensions\n1954         if cset._extend_min:\n1955             min_level = cset.levels[0] - np.diff(cset.levels[:2]) / 2\n1956             midpoints = np.insert(midpoints, 0, min_level)\n1957         if cset._extend_max:\n1958             max_level = cset.levels[-1] + np.diff(cset.levels[-2:]) / 2\n1959             midpoints = np.append(midpoints, max_level)\n1960 \n1961         for z, linec in zip(midpoints, cset.collections):\n1962             if offset is not None:\n1963                 z = offset\n1964             art3d.poly_collection_2d_to_3d(linec, z, zdir=zdir)\n1965             linec.set_sort_zpos(z)\n1966         return midpoints\n1967 \n1968     @_preprocess_data()\n1969     def contour(self, X, Y, Z, *args,\n1970                 extend3d=False, stride=5, zdir='z', offset=None, **kwargs):\n1971         \"\"\"\n1972         Create a 3D contour plot.\n1973 \n1974         Parameters\n1975         ----------\n1976         X, Y, Z : array-like,\n1977             Input data. See `.Axes.contour` for supported data shapes.\n1978         extend3d : bool, default: False\n1979             Whether to extend contour in 3D.\n1980         stride : int\n1981             Step size for extending contour.\n1982         zdir : {'x', 'y', 'z'}, default: 'z'\n1983             The direction to use.\n1984         offset : float, optional\n1985             If specified, plot a projection of the contour lines at this\n1986             position in a plane normal to *zdir*.\n1987         data : indexable object, optional\n1988             DATA_PARAMETER_PLACEHOLDER\n1989 \n1990         *args, **kwargs\n1991             Other arguments are forwarded to `matplotlib.axes.Axes.contour`.\n1992 \n1993         Returns\n1994         -------\n1995         matplotlib.contour.QuadContourSet\n1996         \"\"\"\n1997         had_data = self.has_data()\n1998 \n1999         jX, jY, jZ = art3d.rotate_axes(X, Y, Z, zdir)\n2000         cset = super().contour(jX, jY, jZ, *args, **kwargs)\n2001         self.add_contour_set(cset, extend3d, stride, zdir, offset)\n2002 \n2003         self.auto_scale_xyz(X, Y, Z, had_data)\n2004         return cset\n2005 \n2006     contour3D = contour\n2007 \n2008     @_preprocess_data()\n2009     def tricontour(self, *args,\n2010                    extend3d=False, stride=5, zdir='z', offset=None, **kwargs):\n2011         \"\"\"\n2012         Create a 3D contour plot.\n2013 \n2014         .. note::\n2015             This method currently produces incorrect output due to a\n2016             longstanding bug in 3D PolyCollection rendering.\n2017 \n2018         Parameters\n2019         ----------\n2020         X, Y, Z : array-like\n2021             Input data. See `.Axes.tricontour` for supported data shapes.\n2022         extend3d : bool, default: False\n2023             Whether to extend contour in 3D.\n2024         stride : int\n2025             Step size for extending contour.\n2026         zdir : {'x', 'y', 'z'}, default: 'z'\n2027             The direction to use.\n2028         offset : float, optional\n2029             If specified, plot a projection of the contour lines at this\n2030             position in a plane normal to *zdir*.\n2031         data : indexable object, optional\n2032             DATA_PARAMETER_PLACEHOLDER\n2033         *args, **kwargs\n2034             Other arguments are forwarded to `matplotlib.axes.Axes.tricontour`.\n2035 \n2036         Returns\n2037         -------\n2038         matplotlib.tri._tricontour.TriContourSet\n2039         \"\"\"\n2040         had_data = self.has_data()\n2041 \n2042         tri, args, kwargs = Triangulation.get_from_args_and_kwargs(\n2043                 *args, **kwargs)\n2044         X = tri.x\n2045         Y = tri.y\n2046         if 'Z' in kwargs:\n2047             Z = kwargs.pop('Z')\n2048         else:\n2049             # We do this so Z doesn't get passed as an arg to Axes.tricontour\n2050             Z, *args = args\n2051 \n2052         jX, jY, jZ = art3d.rotate_axes(X, Y, Z, zdir)\n2053         tri = Triangulation(jX, jY, tri.triangles, tri.mask)\n2054 \n2055         cset = super().tricontour(tri, jZ, *args, **kwargs)\n2056         self.add_contour_set(cset, extend3d, stride, zdir, offset)\n2057 \n2058         self.auto_scale_xyz(X, Y, Z, had_data)\n2059         return cset\n2060 \n2061     def _auto_scale_contourf(self, X, Y, Z, zdir, levels, had_data):\n2062         # Autoscale in the zdir based on the levels added, which are\n2063         # different from data range if any contour extensions are present\n2064         dim_vals = {'x': X, 'y': Y, 'z': Z, zdir: levels}\n2065         # Input data and levels have different sizes, but auto_scale_xyz\n2066         # expected same-size input, so manually take min/max limits\n2067         limits = [(np.nanmin(dim_vals[dim]), np.nanmax(dim_vals[dim]))\n2068                   for dim in ['x', 'y', 'z']]\n2069         self.auto_scale_xyz(*limits, had_data)\n2070 \n2071     @_preprocess_data()\n2072     def contourf(self, X, Y, Z, *args, zdir='z', offset=None, **kwargs):\n2073         \"\"\"\n2074         Create a 3D filled contour plot.\n2075 \n2076         Parameters\n2077         ----------\n2078         X, Y, Z : array-like\n2079             Input data. See `.Axes.contourf` for supported data shapes.\n2080         zdir : {'x', 'y', 'z'}, default: 'z'\n2081             The direction to use.\n2082         offset : float, optional\n2083             If specified, plot a projection of the contour lines at this\n2084             position in a plane normal to *zdir*.\n2085         data : indexable object, optional\n2086             DATA_PARAMETER_PLACEHOLDER\n2087         *args, **kwargs\n2088             Other arguments are forwarded to `matplotlib.axes.Axes.contourf`.\n2089 \n2090         Returns\n2091         -------\n2092         matplotlib.contour.QuadContourSet\n2093         \"\"\"\n2094         had_data = self.has_data()\n2095 \n2096         jX, jY, jZ = art3d.rotate_axes(X, Y, Z, zdir)\n2097         cset = super().contourf(jX, jY, jZ, *args, **kwargs)\n2098         levels = self._add_contourf_set(cset, zdir, offset)\n2099 \n2100         self._auto_scale_contourf(X, Y, Z, zdir, levels, had_data)\n2101         return cset\n2102 \n2103     contourf3D = contourf\n2104 \n2105     @_preprocess_data()\n2106     def tricontourf(self, *args, zdir='z', offset=None, **kwargs):\n2107         \"\"\"\n2108         Create a 3D filled contour plot.\n2109 \n2110         .. note::\n2111             This method currently produces incorrect output due to a\n2112             longstanding bug in 3D PolyCollection rendering.\n2113 \n2114         Parameters\n2115         ----------\n2116         X, Y, Z : array-like\n2117             Input data. See `.Axes.tricontourf` for supported data shapes.\n2118         zdir : {'x', 'y', 'z'}, default: 'z'\n2119             The direction to use.\n2120         offset : float, optional\n2121             If specified, plot a projection of the contour lines at this\n2122             position in a plane normal to zdir.\n2123         data : indexable object, optional\n2124             DATA_PARAMETER_PLACEHOLDER\n2125         *args, **kwargs\n2126             Other arguments are forwarded to\n2127             `matplotlib.axes.Axes.tricontourf`.\n2128 \n2129         Returns\n2130         -------\n2131         matplotlib.tri._tricontour.TriContourSet\n2132         \"\"\"\n2133         had_data = self.has_data()\n2134 \n2135         tri, args, kwargs = Triangulation.get_from_args_and_kwargs(\n2136                 *args, **kwargs)\n2137         X = tri.x\n2138         Y = tri.y\n2139         if 'Z' in kwargs:\n2140             Z = kwargs.pop('Z')\n2141         else:\n2142             # We do this so Z doesn't get passed as an arg to Axes.tricontourf\n2143             Z, *args = args\n2144 \n2145         jX, jY, jZ = art3d.rotate_axes(X, Y, Z, zdir)\n2146         tri = Triangulation(jX, jY, tri.triangles, tri.mask)\n2147 \n2148         cset = super().tricontourf(tri, jZ, *args, **kwargs)\n2149         levels = self._add_contourf_set(cset, zdir, offset)\n2150 \n2151         self._auto_scale_contourf(X, Y, Z, zdir, levels, had_data)\n2152         return cset\n2153 \n2154     def add_collection3d(self, col, zs=0, zdir='z'):\n2155         \"\"\"\n2156         Add a 3D collection object to the plot.\n2157 \n2158         2D collection types are converted to a 3D version by\n2159         modifying the object and adding z coordinate information.\n2160 \n2161         Supported are:\n2162 \n2163         - PolyCollection\n2164         - LineCollection\n2165         - PatchCollection\n2166         \"\"\"\n2167         zvals = np.atleast_1d(zs)\n2168         zsortval = (np.min(zvals) if zvals.size\n2169                     else 0)  # FIXME: arbitrary default\n2170 \n2171         # FIXME: use issubclass() (although, then a 3D collection\n2172         #       object would also pass.)  Maybe have a collection3d\n2173         #       abstract class to test for and exclude?\n2174         if type(col) is mcoll.PolyCollection:\n2175             art3d.poly_collection_2d_to_3d(col, zs=zs, zdir=zdir)\n2176             col.set_sort_zpos(zsortval)\n2177         elif type(col) is mcoll.LineCollection:\n2178             art3d.line_collection_2d_to_3d(col, zs=zs, zdir=zdir)\n2179             col.set_sort_zpos(zsortval)\n2180         elif type(col) is mcoll.PatchCollection:\n2181             art3d.patch_collection_2d_to_3d(col, zs=zs, zdir=zdir)\n2182             col.set_sort_zpos(zsortval)\n2183 \n2184         collection = super().add_collection(col)\n2185         return collection\n2186 \n2187     @_preprocess_data(replace_names=[\"xs\", \"ys\", \"zs\", \"s\",\n2188                                      \"edgecolors\", \"c\", \"facecolor\",\n2189                                      \"facecolors\", \"color\"])\n2190     def scatter(self, xs, ys, zs=0, zdir='z', s=20, c=None, depthshade=True,\n2191                 *args, **kwargs):\n2192         \"\"\"\n2193         Create a scatter plot.\n2194 \n2195         Parameters\n2196         ----------\n2197         xs, ys : array-like\n2198             The data positions.\n2199         zs : float or array-like, default: 0\n2200             The z-positions. Either an array of the same length as *xs* and\n2201             *ys* or a single value to place all points in the same plane.\n2202         zdir : {'x', 'y', 'z', '-x', '-y', '-z'}, default: 'z'\n2203             The axis direction for the *zs*. This is useful when plotting 2D\n2204             data on a 3D Axes. The data must be passed as *xs*, *ys*. Setting\n2205             *zdir* to 'y' then plots the data to the x-z-plane.\n2206 \n2207             See also :doc:`/gallery/mplot3d/2dcollections3d`.\n2208 \n2209         s : float or array-like, default: 20\n2210             The marker size in points**2. Either an array of the same length\n2211             as *xs* and *ys* or a single value to make all markers the same\n2212             size.\n2213         c : color, sequence, or sequence of colors, optional\n2214             The marker color. Possible values:\n2215 \n2216             - A single color format string.\n2217             - A sequence of colors of length n.\n2218             - A sequence of n numbers to be mapped to colors using *cmap* and\n2219               *norm*.\n2220             - A 2D array in which the rows are RGB or RGBA.\n2221 \n2222             For more details see the *c* argument of `~.axes.Axes.scatter`.\n2223         depthshade : bool, default: True\n2224             Whether to shade the scatter markers to give the appearance of\n2225             depth. Each call to ``scatter()`` will perform its depthshading\n2226             independently.\n2227         data : indexable object, optional\n2228             DATA_PARAMETER_PLACEHOLDER\n2229         **kwargs\n2230             All other keyword arguments are passed on to `~.axes.Axes.scatter`.\n2231 \n2232         Returns\n2233         -------\n2234         paths : `~matplotlib.collections.PathCollection`\n2235         \"\"\"\n2236 \n2237         had_data = self.has_data()\n2238         zs_orig = zs\n2239 \n2240         xs, ys, zs = np.broadcast_arrays(\n2241             *[np.ravel(np.ma.filled(t, np.nan)) for t in [xs, ys, zs]])\n2242         s = np.ma.ravel(s)  # This doesn't have to match x, y in size.\n2243 \n2244         xs, ys, zs, s, c = cbook.delete_masked_points(xs, ys, zs, s, c)\n2245 \n2246         # For xs and ys, 2D scatter() will do the copying.\n2247         if np.may_share_memory(zs_orig, zs):  # Avoid unnecessary copies.\n2248             zs = zs.copy()\n2249 \n2250         patches = super().scatter(xs, ys, s=s, c=c, *args, **kwargs)\n2251         art3d.patch_collection_2d_to_3d(patches, zs=zs, zdir=zdir,\n2252                                         depthshade=depthshade)\n2253 \n2254         if self._zmargin < 0.05 and xs.size > 0:\n2255             self.set_zmargin(0.05)\n2256 \n2257         self.auto_scale_xyz(xs, ys, zs, had_data)\n2258 \n2259         return patches\n2260 \n2261     scatter3D = scatter\n2262 \n2263     @_preprocess_data()\n2264     def bar(self, left, height, zs=0, zdir='z', *args, **kwargs):\n2265         \"\"\"\n2266         Add 2D bar(s).\n2267 \n2268         Parameters\n2269         ----------\n2270         left : 1D array-like\n2271             The x coordinates of the left sides of the bars.\n2272         height : 1D array-like\n2273             The height of the bars.\n2274         zs : float or 1D array-like\n2275             Z coordinate of bars; if a single value is specified, it will be\n2276             used for all bars.\n2277         zdir : {'x', 'y', 'z'}, default: 'z'\n2278             When plotting 2D data, the direction to use as z ('x', 'y' or 'z').\n2279         data : indexable object, optional\n2280             DATA_PARAMETER_PLACEHOLDER\n2281         **kwargs\n2282             Other keyword arguments are forwarded to\n2283             `matplotlib.axes.Axes.bar`.\n2284 \n2285         Returns\n2286         -------\n2287         mpl_toolkits.mplot3d.art3d.Patch3DCollection\n2288         \"\"\"\n2289         had_data = self.has_data()\n2290 \n2291         patches = super().bar(left, height, *args, **kwargs)\n2292 \n2293         zs = np.broadcast_to(zs, len(left))\n2294 \n2295         verts = []\n2296         verts_zs = []\n2297         for p, z in zip(patches, zs):\n2298             vs = art3d._get_patch_verts(p)\n2299             verts += vs.tolist()\n2300             verts_zs += [z] * len(vs)\n2301             art3d.patch_2d_to_3d(p, z, zdir)\n2302             if 'alpha' in kwargs:\n2303                 p.set_alpha(kwargs['alpha'])\n2304 \n2305         if len(verts) > 0:\n2306             # the following has to be skipped if verts is empty\n2307             # NOTE: Bugs could still occur if len(verts) > 0,\n2308             #       but the \"2nd dimension\" is empty.\n2309             xs, ys = zip(*verts)\n2310         else:\n2311             xs, ys = [], []\n2312 \n2313         xs, ys, verts_zs = art3d.juggle_axes(xs, ys, verts_zs, zdir)\n2314         self.auto_scale_xyz(xs, ys, verts_zs, had_data)\n2315 \n2316         return patches\n2317 \n2318     @_preprocess_data()\n2319     def bar3d(self, x, y, z, dx, dy, dz, color=None,\n2320               zsort='average', shade=True, lightsource=None, *args, **kwargs):\n2321         \"\"\"\n2322         Generate a 3D barplot.\n2323 \n2324         This method creates three-dimensional barplot where the width,\n2325         depth, height, and color of the bars can all be uniquely set.\n2326 \n2327         Parameters\n2328         ----------\n2329         x, y, z : array-like\n2330             The coordinates of the anchor point of the bars.\n2331 \n2332         dx, dy, dz : float or array-like\n2333             The width, depth, and height of the bars, respectively.\n2334 \n2335         color : sequence of colors, optional\n2336             The color of the bars can be specified globally or\n2337             individually. This parameter can be:\n2338 \n2339             - A single color, to color all bars the same color.\n2340             - An array of colors of length N bars, to color each bar\n2341               independently.\n2342             - An array of colors of length 6, to color the faces of the\n2343               bars similarly.\n2344             - An array of colors of length 6 * N bars, to color each face\n2345               independently.\n2346 \n2347             When coloring the faces of the boxes specifically, this is\n2348             the order of the coloring:\n2349 \n2350             1. -Z (bottom of box)\n2351             2. +Z (top of box)\n2352             3. -Y\n2353             4. +Y\n2354             5. -X\n2355             6. +X\n2356 \n2357         zsort : str, optional\n2358             The z-axis sorting scheme passed onto `~.art3d.Poly3DCollection`\n2359 \n2360         shade : bool, default: True\n2361             When true, this shades the dark sides of the bars (relative\n2362             to the plot's source of light).\n2363 \n2364         lightsource : `~matplotlib.colors.LightSource`\n2365             The lightsource to use when *shade* is True.\n2366 \n2367         data : indexable object, optional\n2368             DATA_PARAMETER_PLACEHOLDER\n2369 \n2370         **kwargs\n2371             Any additional keyword arguments are passed onto\n2372             `~.art3d.Poly3DCollection`.\n2373 \n2374         Returns\n2375         -------\n2376         collection : `~.art3d.Poly3DCollection`\n2377             A collection of three-dimensional polygons representing the bars.\n2378         \"\"\"\n2379 \n2380         had_data = self.has_data()\n2381 \n2382         x, y, z, dx, dy, dz = np.broadcast_arrays(\n2383             np.atleast_1d(x), y, z, dx, dy, dz)\n2384         minx = np.min(x)\n2385         maxx = np.max(x + dx)\n2386         miny = np.min(y)\n2387         maxy = np.max(y + dy)\n2388         minz = np.min(z)\n2389         maxz = np.max(z + dz)\n2390 \n2391         # shape (6, 4, 3)\n2392         # All faces are oriented facing outwards - when viewed from the\n2393         # outside, their vertices are in a counterclockwise ordering.\n2394         cuboid = np.array([\n2395             # -z\n2396             (\n2397                 (0, 0, 0),\n2398                 (0, 1, 0),\n2399                 (1, 1, 0),\n2400                 (1, 0, 0),\n2401             ),\n2402             # +z\n2403             (\n2404                 (0, 0, 1),\n2405                 (1, 0, 1),\n2406                 (1, 1, 1),\n2407                 (0, 1, 1),\n2408             ),\n2409             # -y\n2410             (\n2411                 (0, 0, 0),\n2412                 (1, 0, 0),\n2413                 (1, 0, 1),\n2414                 (0, 0, 1),\n2415             ),\n2416             # +y\n2417             (\n2418                 (0, 1, 0),\n2419                 (0, 1, 1),\n2420                 (1, 1, 1),\n2421                 (1, 1, 0),\n2422             ),\n2423             # -x\n2424             (\n2425                 (0, 0, 0),\n2426                 (0, 0, 1),\n2427                 (0, 1, 1),\n2428                 (0, 1, 0),\n2429             ),\n2430             # +x\n2431             (\n2432                 (1, 0, 0),\n2433                 (1, 1, 0),\n2434                 (1, 1, 1),\n2435                 (1, 0, 1),\n2436             ),\n2437         ])\n2438 \n2439         # indexed by [bar, face, vertex, coord]\n2440         polys = np.empty(x.shape + cuboid.shape)\n2441 \n2442         # handle each coordinate separately\n2443         for i, p, dp in [(0, x, dx), (1, y, dy), (2, z, dz)]:\n2444             p = p[..., np.newaxis, np.newaxis]\n2445             dp = dp[..., np.newaxis, np.newaxis]\n2446             polys[..., i] = p + dp * cuboid[..., i]\n2447 \n2448         # collapse the first two axes\n2449         polys = polys.reshape((-1,) + polys.shape[2:])\n2450 \n2451         facecolors = []\n2452         if color is None:\n2453             color = [self._get_patches_for_fill.get_next_color()]\n2454 \n2455         color = list(mcolors.to_rgba_array(color))\n2456 \n2457         if len(color) == len(x):\n2458             # bar colors specified, need to expand to number of faces\n2459             for c in color:\n2460                 facecolors.extend([c] * 6)\n2461         else:\n2462             # a single color specified, or face colors specified explicitly\n2463             facecolors = color\n2464             if len(facecolors) < len(x):\n2465                 facecolors *= (6 * len(x))\n2466 \n2467         col = art3d.Poly3DCollection(polys,\n2468                                      zsort=zsort,\n2469                                      facecolors=facecolors,\n2470                                      shade=shade,\n2471                                      lightsource=lightsource,\n2472                                      *args, **kwargs)\n2473         self.add_collection(col)\n2474 \n2475         self.auto_scale_xyz((minx, maxx), (miny, maxy), (minz, maxz), had_data)\n2476 \n2477         return col\n2478 \n2479     def set_title(self, label, fontdict=None, loc='center', **kwargs):\n2480         # docstring inherited\n2481         ret = super().set_title(label, fontdict=fontdict, loc=loc, **kwargs)\n2482         (x, y) = self.title.get_position()\n2483         self.title.set_y(0.92 * y)\n2484         return ret\n2485 \n2486     @_preprocess_data()\n2487     def quiver(self, X, Y, Z, U, V, W, *,\n2488                length=1, arrow_length_ratio=.3, pivot='tail', normalize=False,\n2489                **kwargs):\n2490         \"\"\"\n2491         Plot a 3D field of arrows.\n2492 \n2493         The arguments can be array-like or scalars, so long as they can be\n2494         broadcast together. The arguments can also be masked arrays. If an\n2495         element in any of argument is masked, then that corresponding quiver\n2496         element will not be plotted.\n2497 \n2498         Parameters\n2499         ----------\n2500         X, Y, Z : array-like\n2501             The x, y and z coordinates of the arrow locations (default is\n2502             tail of arrow; see *pivot* kwarg).\n2503 \n2504         U, V, W : array-like\n2505             The x, y and z components of the arrow vectors.\n2506 \n2507         length : float, default: 1\n2508             The length of each quiver.\n2509 \n2510         arrow_length_ratio : float, default: 0.3\n2511             The ratio of the arrow head with respect to the quiver.\n2512 \n2513         pivot : {'tail', 'middle', 'tip'}, default: 'tail'\n2514             The part of the arrow that is at the grid point; the arrow\n2515             rotates about this point, hence the name *pivot*.\n2516 \n2517         normalize : bool, default: False\n2518             Whether all arrows are normalized to have the same length, or keep\n2519             the lengths defined by *u*, *v*, and *w*.\n2520 \n2521         data : indexable object, optional\n2522             DATA_PARAMETER_PLACEHOLDER\n2523 \n2524         **kwargs\n2525             Any additional keyword arguments are delegated to\n2526             :class:`.Line3DCollection`\n2527         \"\"\"\n2528 \n2529         def calc_arrows(UVW):\n2530             # get unit direction vector perpendicular to (u, v, w)\n2531             x = UVW[:, 0]\n2532             y = UVW[:, 1]\n2533             norm = np.linalg.norm(UVW[:, :2], axis=1)\n2534             x_p = np.divide(y, norm, where=norm != 0, out=np.zeros_like(x))\n2535             y_p = np.divide(-x,  norm, where=norm != 0, out=np.ones_like(x))\n2536             # compute the two arrowhead direction unit vectors\n2537             rangle = math.radians(15)\n2538             c = math.cos(rangle)\n2539             s = math.sin(rangle)\n2540             # construct the rotation matrices of shape (3, 3, n)\n2541             r13 = y_p * s\n2542             r32 = x_p * s\n2543             r12 = x_p * y_p * (1 - c)\n2544             Rpos = np.array(\n2545                 [[c + (x_p ** 2) * (1 - c), r12, r13],\n2546                  [r12, c + (y_p ** 2) * (1 - c), -r32],\n2547                  [-r13, r32, np.full_like(x_p, c)]])\n2548             # opposite rotation negates all the sin terms\n2549             Rneg = Rpos.copy()\n2550             Rneg[[0, 1, 2, 2], [2, 2, 0, 1]] *= -1\n2551             # Batch n (3, 3) x (3) matrix multiplications ((3, 3, n) x (n, 3)).\n2552             Rpos_vecs = np.einsum(\"ij...,...j->...i\", Rpos, UVW)\n2553             Rneg_vecs = np.einsum(\"ij...,...j->...i\", Rneg, UVW)\n2554             # Stack into (n, 2, 3) result.\n2555             return np.stack([Rpos_vecs, Rneg_vecs], axis=1)\n2556 \n2557         had_data = self.has_data()\n2558 \n2559         input_args = [X, Y, Z, U, V, W]\n2560 \n2561         # extract the masks, if any\n2562         masks = [k.mask for k in input_args\n2563                  if isinstance(k, np.ma.MaskedArray)]\n2564         # broadcast to match the shape\n2565         bcast = np.broadcast_arrays(*input_args, *masks)\n2566         input_args = bcast[:6]\n2567         masks = bcast[6:]\n2568         if masks:\n2569             # combine the masks into one\n2570             mask = functools.reduce(np.logical_or, masks)\n2571             # put mask on and compress\n2572             input_args = [np.ma.array(k, mask=mask).compressed()\n2573                           for k in input_args]\n2574         else:\n2575             input_args = [np.ravel(k) for k in input_args]\n2576 \n2577         if any(len(v) == 0 for v in input_args):\n2578             # No quivers, so just make an empty collection and return early\n2579             linec = art3d.Line3DCollection([], **kwargs)\n2580             self.add_collection(linec)\n2581             return linec\n2582 \n2583         shaft_dt = np.array([0., length], dtype=float)\n2584         arrow_dt = shaft_dt * arrow_length_ratio\n2585 \n2586         _api.check_in_list(['tail', 'middle', 'tip'], pivot=pivot)\n2587         if pivot == 'tail':\n2588             shaft_dt -= length\n2589         elif pivot == 'middle':\n2590             shaft_dt -= length / 2\n2591 \n2592         XYZ = np.column_stack(input_args[:3])\n2593         UVW = np.column_stack(input_args[3:]).astype(float)\n2594 \n2595         # Normalize rows of UVW\n2596         norm = np.linalg.norm(UVW, axis=1)\n2597 \n2598         # If any row of UVW is all zeros, don't make a quiver for it\n2599         mask = norm > 0\n2600         XYZ = XYZ[mask]\n2601         if normalize:\n2602             UVW = UVW[mask] / norm[mask].reshape((-1, 1))\n2603         else:\n2604             UVW = UVW[mask]\n2605 \n2606         if len(XYZ) > 0:\n2607             # compute the shaft lines all at once with an outer product\n2608             shafts = (XYZ - np.multiply.outer(shaft_dt, UVW)).swapaxes(0, 1)\n2609             # compute head direction vectors, n heads x 2 sides x 3 dimensions\n2610             head_dirs = calc_arrows(UVW)\n2611             # compute all head lines at once, starting from the shaft ends\n2612             heads = shafts[:, :1] - np.multiply.outer(arrow_dt, head_dirs)\n2613             # stack left and right head lines together\n2614             heads = heads.reshape((len(arrow_dt), -1, 3))\n2615             # transpose to get a list of lines\n2616             heads = heads.swapaxes(0, 1)\n2617 \n2618             lines = [*shafts, *heads]\n2619         else:\n2620             lines = []\n2621 \n2622         linec = art3d.Line3DCollection(lines, **kwargs)\n2623         self.add_collection(linec)\n2624 \n2625         self.auto_scale_xyz(XYZ[:, 0], XYZ[:, 1], XYZ[:, 2], had_data)\n2626 \n2627         return linec\n2628 \n2629     quiver3D = quiver\n2630 \n2631     def voxels(self, *args, facecolors=None, edgecolors=None, shade=True,\n2632                lightsource=None, **kwargs):\n2633         \"\"\"\n2634         ax.voxels([x, y, z,] /, filled, facecolors=None, edgecolors=None, \\\n2635 **kwargs)\n2636 \n2637         Plot a set of filled voxels\n2638 \n2639         All voxels are plotted as 1x1x1 cubes on the axis, with\n2640         ``filled[0, 0, 0]`` placed with its lower corner at the origin.\n2641         Occluded faces are not plotted.\n2642 \n2643         Parameters\n2644         ----------\n2645         filled : 3D np.array of bool\n2646             A 3D array of values, with truthy values indicating which voxels\n2647             to fill\n2648 \n2649         x, y, z : 3D np.array, optional\n2650             The coordinates of the corners of the voxels. This should broadcast\n2651             to a shape one larger in every dimension than the shape of\n2652             *filled*.  These can be used to plot non-cubic voxels.\n2653 \n2654             If not specified, defaults to increasing integers along each axis,\n2655             like those returned by :func:`~numpy.indices`.\n2656             As indicated by the ``/`` in the function signature, these\n2657             arguments can only be passed positionally.\n2658 \n2659         facecolors, edgecolors : array-like, optional\n2660             The color to draw the faces and edges of the voxels. Can only be\n2661             passed as keyword arguments.\n2662             These parameters can be:\n2663 \n2664             - A single color value, to color all voxels the same color. This\n2665               can be either a string, or a 1D RGB/RGBA array\n2666             - ``None``, the default, to use a single color for the faces, and\n2667               the style default for the edges.\n2668             - A 3D `~numpy.ndarray` of color names, with each item the color\n2669               for the corresponding voxel. The size must match the voxels.\n2670             - A 4D `~numpy.ndarray` of RGB/RGBA data, with the components\n2671               along the last axis.\n2672 \n2673         shade : bool, default: True\n2674             Whether to shade the facecolors.\n2675 \n2676         lightsource : `~matplotlib.colors.LightSource`\n2677             The lightsource to use when *shade* is True.\n2678 \n2679         **kwargs\n2680             Additional keyword arguments to pass onto\n2681             `~mpl_toolkits.mplot3d.art3d.Poly3DCollection`.\n2682 \n2683         Returns\n2684         -------\n2685         faces : dict\n2686             A dictionary indexed by coordinate, where ``faces[i, j, k]`` is a\n2687             `.Poly3DCollection` of the faces drawn for the voxel\n2688             ``filled[i, j, k]``. If no faces were drawn for a given voxel,\n2689             either because it was not asked to be drawn, or it is fully\n2690             occluded, then ``(i, j, k) not in faces``.\n2691 \n2692         Examples\n2693         --------\n2694         .. plot:: gallery/mplot3d/voxels.py\n2695         .. plot:: gallery/mplot3d/voxels_rgb.py\n2696         .. plot:: gallery/mplot3d/voxels_torus.py\n2697         .. plot:: gallery/mplot3d/voxels_numpy_logo.py\n2698         \"\"\"\n2699 \n2700         # work out which signature we should be using, and use it to parse\n2701         # the arguments. Name must be voxels for the correct error message\n2702         if len(args) >= 3:\n2703             # underscores indicate position only\n2704             def voxels(__x, __y, __z, filled, **kwargs):\n2705                 return (__x, __y, __z), filled, kwargs\n2706         else:\n2707             def voxels(filled, **kwargs):\n2708                 return None, filled, kwargs\n2709 \n2710         xyz, filled, kwargs = voxels(*args, **kwargs)\n2711 \n2712         # check dimensions\n2713         if filled.ndim != 3:\n2714             raise ValueError(\"Argument filled must be 3-dimensional\")\n2715         size = np.array(filled.shape, dtype=np.intp)\n2716 \n2717         # check xyz coordinates, which are one larger than the filled shape\n2718         coord_shape = tuple(size + 1)\n2719         if xyz is None:\n2720             x, y, z = np.indices(coord_shape)\n2721         else:\n2722             x, y, z = (np.broadcast_to(c, coord_shape) for c in xyz)\n2723 \n2724         def _broadcast_color_arg(color, name):\n2725             if np.ndim(color) in (0, 1):\n2726                 # single color, like \"red\" or [1, 0, 0]\n2727                 return np.broadcast_to(color, filled.shape + np.shape(color))\n2728             elif np.ndim(color) in (3, 4):\n2729                 # 3D array of strings, or 4D array with last axis rgb\n2730                 if np.shape(color)[:3] != filled.shape:\n2731                     raise ValueError(\n2732                         f\"When multidimensional, {name} must match the shape \"\n2733                         \"of filled\")\n2734                 return color\n2735             else:\n2736                 raise ValueError(f\"Invalid {name} argument\")\n2737 \n2738         # broadcast and default on facecolors\n2739         if facecolors is None:\n2740             facecolors = self._get_patches_for_fill.get_next_color()\n2741         facecolors = _broadcast_color_arg(facecolors, 'facecolors')\n2742 \n2743         # broadcast but no default on edgecolors\n2744         edgecolors = _broadcast_color_arg(edgecolors, 'edgecolors')\n2745 \n2746         # scale to the full array, even if the data is only in the center\n2747         self.auto_scale_xyz(x, y, z)\n2748 \n2749         # points lying on corners of a square\n2750         square = np.array([\n2751             [0, 0, 0],\n2752             [1, 0, 0],\n2753             [1, 1, 0],\n2754             [0, 1, 0],\n2755         ], dtype=np.intp)\n2756 \n2757         voxel_faces = defaultdict(list)\n2758 \n2759         def permutation_matrices(n):\n2760             \"\"\"Generate cyclic permutation matrices.\"\"\"\n2761             mat = np.eye(n, dtype=np.intp)\n2762             for i in range(n):\n2763                 yield mat\n2764                 mat = np.roll(mat, 1, axis=0)\n2765 \n2766         # iterate over each of the YZ, ZX, and XY orientations, finding faces\n2767         # to render\n2768         for permute in permutation_matrices(3):\n2769             # find the set of ranges to iterate over\n2770             pc, qc, rc = permute.T.dot(size)\n2771             pinds = np.arange(pc)\n2772             qinds = np.arange(qc)\n2773             rinds = np.arange(rc)\n2774 \n2775             square_rot_pos = square.dot(permute.T)\n2776             square_rot_neg = square_rot_pos[::-1]\n2777 \n2778             # iterate within the current plane\n2779             for p in pinds:\n2780                 for q in qinds:\n2781                     # iterate perpendicularly to the current plane, handling\n2782                     # boundaries. We only draw faces between a voxel and an\n2783                     # empty space, to avoid drawing internal faces.\n2784 \n2785                     # draw lower faces\n2786                     p0 = permute.dot([p, q, 0])\n2787                     i0 = tuple(p0)\n2788                     if filled[i0]:\n2789                         voxel_faces[i0].append(p0 + square_rot_neg)\n2790 \n2791                     # draw middle faces\n2792                     for r1, r2 in zip(rinds[:-1], rinds[1:]):\n2793                         p1 = permute.dot([p, q, r1])\n2794                         p2 = permute.dot([p, q, r2])\n2795 \n2796                         i1 = tuple(p1)\n2797                         i2 = tuple(p2)\n2798 \n2799                         if filled[i1] and not filled[i2]:\n2800                             voxel_faces[i1].append(p2 + square_rot_pos)\n2801                         elif not filled[i1] and filled[i2]:\n2802                             voxel_faces[i2].append(p2 + square_rot_neg)\n2803 \n2804                     # draw upper faces\n2805                     pk = permute.dot([p, q, rc-1])\n2806                     pk2 = permute.dot([p, q, rc])\n2807                     ik = tuple(pk)\n2808                     if filled[ik]:\n2809                         voxel_faces[ik].append(pk2 + square_rot_pos)\n2810 \n2811         # iterate over the faces, and generate a Poly3DCollection for each\n2812         # voxel\n2813         polygons = {}\n2814         for coord, faces_inds in voxel_faces.items():\n2815             # convert indices into 3D positions\n2816             if xyz is None:\n2817                 faces = faces_inds\n2818             else:\n2819                 faces = []\n2820                 for face_inds in faces_inds:\n2821                     ind = face_inds[:, 0], face_inds[:, 1], face_inds[:, 2]\n2822                     face = np.empty(face_inds.shape)\n2823                     face[:, 0] = x[ind]\n2824                     face[:, 1] = y[ind]\n2825                     face[:, 2] = z[ind]\n2826                     faces.append(face)\n2827 \n2828             # shade the faces\n2829             facecolor = facecolors[coord]\n2830             edgecolor = edgecolors[coord]\n2831 \n2832             poly = art3d.Poly3DCollection(\n2833                 faces, facecolors=facecolor, edgecolors=edgecolor,\n2834                 shade=shade, lightsource=lightsource, **kwargs)\n2835             self.add_collection3d(poly)\n2836             polygons[coord] = poly\n2837 \n2838         return polygons\n2839 \n2840     @_preprocess_data(replace_names=[\"x\", \"y\", \"z\", \"xerr\", \"yerr\", \"zerr\"])\n2841     def errorbar(self, x, y, z, zerr=None, yerr=None, xerr=None, fmt='',\n2842                  barsabove=False, errorevery=1, ecolor=None, elinewidth=None,\n2843                  capsize=None, capthick=None, xlolims=False, xuplims=False,\n2844                  ylolims=False, yuplims=False, zlolims=False, zuplims=False,\n2845                  **kwargs):\n2846         \"\"\"\n2847         Plot lines and/or markers with errorbars around them.\n2848 \n2849         *x*/*y*/*z* define the data locations, and *xerr*/*yerr*/*zerr* define\n2850         the errorbar sizes. By default, this draws the data markers/lines as\n2851         well the errorbars. Use fmt='none' to draw errorbars only.\n2852 \n2853         Parameters\n2854         ----------\n2855         x, y, z : float or array-like\n2856             The data positions.\n2857 \n2858         xerr, yerr, zerr : float or array-like, shape (N,) or (2, N), optional\n2859             The errorbar sizes:\n2860 \n2861             - scalar: Symmetric +/- values for all data points.\n2862             - shape(N,): Symmetric +/-values for each data point.\n2863             - shape(2, N): Separate - and + values for each bar. First row\n2864               contains the lower errors, the second row contains the upper\n2865               errors.\n2866             - *None*: No errorbar.\n2867 \n2868             Note that all error arrays should have *positive* values.\n2869 \n2870         fmt : str, default: ''\n2871             The format for the data points / data lines. See `.plot` for\n2872             details.\n2873 \n2874             Use 'none' (case-insensitive) to plot errorbars without any data\n2875             markers.\n2876 \n2877         ecolor : color, default: None\n2878             The color of the errorbar lines.  If None, use the color of the\n2879             line connecting the markers.\n2880 \n2881         elinewidth : float, default: None\n2882             The linewidth of the errorbar lines. If None, the linewidth of\n2883             the current style is used.\n2884 \n2885         capsize : float, default: :rc:`errorbar.capsize`\n2886             The length of the error bar caps in points.\n2887 \n2888         capthick : float, default: None\n2889             An alias to the keyword argument *markeredgewidth* (a.k.a. *mew*).\n2890             This setting is a more sensible name for the property that\n2891             controls the thickness of the error bar cap in points. For\n2892             backwards compatibility, if *mew* or *markeredgewidth* are given,\n2893             then they will over-ride *capthick*. This may change in future\n2894             releases.\n2895 \n2896         barsabove : bool, default: False\n2897             If True, will plot the errorbars above the plot\n2898             symbols. Default is below.\n2899 \n2900         xlolims, ylolims, zlolims : bool, default: False\n2901             These arguments can be used to indicate that a value gives only\n2902             lower limits. In that case a caret symbol is used to indicate\n2903             this. *lims*-arguments may be scalars, or array-likes of the same\n2904             length as the errors. To use limits with inverted axes,\n2905             `~.Axes.set_xlim` or `~.Axes.set_ylim` must be called before\n2906             `errorbar`. Note the tricky parameter names: setting e.g.\n2907             *ylolims* to True means that the y-value is a *lower* limit of the\n2908             True value, so, only an *upward*-pointing arrow will be drawn!\n2909 \n2910         xuplims, yuplims, zuplims : bool, default: False\n2911             Same as above, but for controlling the upper limits.\n2912 \n2913         errorevery : int or (int, int), default: 1\n2914             draws error bars on a subset of the data. *errorevery* =N draws\n2915             error bars on the points (x[::N], y[::N], z[::N]).\n2916             *errorevery* =(start, N) draws error bars on the points\n2917             (x[start::N], y[start::N], z[start::N]). e.g. *errorevery* =(6, 3)\n2918             adds error bars to the data at (x[6], x[9], x[12], x[15], ...).\n2919             Used to avoid overlapping error bars when two series share x-axis\n2920             values.\n2921 \n2922         Returns\n2923         -------\n2924         errlines : list\n2925             List of `~mpl_toolkits.mplot3d.art3d.Line3DCollection` instances\n2926             each containing an errorbar line.\n2927         caplines : list\n2928             List of `~mpl_toolkits.mplot3d.art3d.Line3D` instances each\n2929             containing a capline object.\n2930         limmarks : list\n2931             List of `~mpl_toolkits.mplot3d.art3d.Line3D` instances each\n2932             containing a marker with an upper or lower limit.\n2933 \n2934         Other Parameters\n2935         ----------------\n2936         data : indexable object, optional\n2937             DATA_PARAMETER_PLACEHOLDER\n2938 \n2939         **kwargs\n2940             All other keyword arguments for styling errorbar lines are passed\n2941             `~mpl_toolkits.mplot3d.art3d.Line3DCollection`.\n2942 \n2943         Examples\n2944         --------\n2945         .. plot:: gallery/mplot3d/errorbar3d.py\n2946         \"\"\"\n2947         had_data = self.has_data()\n2948 \n2949         kwargs = cbook.normalize_kwargs(kwargs, mlines.Line2D)\n2950         # Drop anything that comes in as None to use the default instead.\n2951         kwargs = {k: v for k, v in kwargs.items() if v is not None}\n2952         kwargs.setdefault('zorder', 2)\n2953 \n2954         self._process_unit_info([(\"x\", x), (\"y\", y), (\"z\", z)], kwargs,\n2955                                 convert=False)\n2956 \n2957         # make sure all the args are iterable; use lists not arrays to\n2958         # preserve units\n2959         x = x if np.iterable(x) else [x]\n2960         y = y if np.iterable(y) else [y]\n2961         z = z if np.iterable(z) else [z]\n2962 \n2963         if not len(x) == len(y) == len(z):\n2964             raise ValueError(\"'x', 'y', and 'z' must have the same size\")\n2965 \n2966         everymask = self._errorevery_to_mask(x, errorevery)\n2967 \n2968         label = kwargs.pop(\"label\", None)\n2969         kwargs['label'] = '_nolegend_'\n2970 \n2971         # Create the main line and determine overall kwargs for child artists.\n2972         # We avoid calling self.plot() directly, or self._get_lines(), because\n2973         # that would call self._process_unit_info again, and do other indirect\n2974         # data processing.\n2975         (data_line, base_style), = self._get_lines._plot_args(\n2976             (x, y) if fmt == '' else (x, y, fmt), kwargs, return_kwargs=True)\n2977         art3d.line_2d_to_3d(data_line, zs=z)\n2978 \n2979         # Do this after creating `data_line` to avoid modifying `base_style`.\n2980         if barsabove:\n2981             data_line.set_zorder(kwargs['zorder'] - .1)\n2982         else:\n2983             data_line.set_zorder(kwargs['zorder'] + .1)\n2984 \n2985         # Add line to plot, or throw it away and use it to determine kwargs.\n2986         if fmt.lower() != 'none':\n2987             self.add_line(data_line)\n2988         else:\n2989             data_line = None\n2990             # Remove alpha=0 color that _process_plot_format returns.\n2991             base_style.pop('color')\n2992 \n2993         if 'color' not in base_style:\n2994             base_style['color'] = 'C0'\n2995         if ecolor is None:\n2996             ecolor = base_style['color']\n2997 \n2998         # Eject any line-specific information from format string, as it's not\n2999         # needed for bars or caps.\n3000         for key in ['marker', 'markersize', 'markerfacecolor',\n3001                     'markeredgewidth', 'markeredgecolor', 'markevery',\n3002                     'linestyle', 'fillstyle', 'drawstyle', 'dash_capstyle',\n3003                     'dash_joinstyle', 'solid_capstyle', 'solid_joinstyle']:\n3004             base_style.pop(key, None)\n3005 \n3006         # Make the style dict for the line collections (the bars).\n3007         eb_lines_style = {**base_style, 'color': ecolor}\n3008 \n3009         if elinewidth:\n3010             eb_lines_style['linewidth'] = elinewidth\n3011         elif 'linewidth' in kwargs:\n3012             eb_lines_style['linewidth'] = kwargs['linewidth']\n3013 \n3014         for key in ('transform', 'alpha', 'zorder', 'rasterized'):\n3015             if key in kwargs:\n3016                 eb_lines_style[key] = kwargs[key]\n3017 \n3018         # Make the style dict for caps (the \"hats\").\n3019         eb_cap_style = {**base_style, 'linestyle': 'None'}\n3020         if capsize is None:\n3021             capsize = mpl.rcParams[\"errorbar.capsize\"]\n3022         if capsize > 0:\n3023             eb_cap_style['markersize'] = 2. * capsize\n3024         if capthick is not None:\n3025             eb_cap_style['markeredgewidth'] = capthick\n3026         eb_cap_style['color'] = ecolor\n3027 \n3028         def _apply_mask(arrays, mask):\n3029             # Return, for each array in *arrays*, the elements for which *mask*\n3030             # is True, without using fancy indexing.\n3031             return [[*itertools.compress(array, mask)] for array in arrays]\n3032 \n3033         def _extract_errs(err, data, lomask, himask):\n3034             # For separate +/- error values we need to unpack err\n3035             if len(err.shape) == 2:\n3036                 low_err, high_err = err\n3037             else:\n3038                 low_err, high_err = err, err\n3039 \n3040             lows = np.where(lomask | ~everymask, data, data - low_err)\n3041             highs = np.where(himask | ~everymask, data, data + high_err)\n3042 \n3043             return lows, highs\n3044 \n3045         # collect drawn items while looping over the three coordinates\n3046         errlines, caplines, limmarks = [], [], []\n3047 \n3048         # list of endpoint coordinates, used for auto-scaling\n3049         coorderrs = []\n3050 \n3051         # define the markers used for errorbar caps and limits below\n3052         # the dictionary key is mapped by the `i_xyz` helper dictionary\n3053         capmarker = {0: '|', 1: '|', 2: '_'}\n3054         i_xyz = {'x': 0, 'y': 1, 'z': 2}\n3055 \n3056         # Calculate marker size from points to quiver length. Because these are\n3057         # not markers, and 3D Axes do not use the normal transform stack, this\n3058         # is a bit involved. Since the quiver arrows will change size as the\n3059         # scene is rotated, they are given a standard size based on viewing\n3060         # them directly in planar form.\n3061         quiversize = eb_cap_style.get('markersize',\n3062                                       mpl.rcParams['lines.markersize']) ** 2\n3063         quiversize *= self.figure.dpi / 72\n3064         quiversize = self.transAxes.inverted().transform([\n3065             (0, 0), (quiversize, quiversize)])\n3066         quiversize = np.mean(np.diff(quiversize, axis=0))\n3067         # quiversize is now in Axes coordinates, and to convert back to data\n3068         # coordinates, we need to run it through the inverse 3D transform. For\n3069         # consistency, this uses a fixed elevation, azimuth, and roll.\n3070         with cbook._setattr_cm(self, elev=0, azim=0, roll=0):\n3071             invM = np.linalg.inv(self.get_proj())\n3072         # elev=azim=roll=0 produces the Y-Z plane, so quiversize in 2D 'x' is\n3073         # 'y' in 3D, hence the 1 index.\n3074         quiversize = np.dot(invM, [quiversize, 0, 0, 0])[1]\n3075         # Quivers use a fixed 15-degree arrow head, so scale up the length so\n3076         # that the size corresponds to the base. In other words, this constant\n3077         # corresponds to the equation tan(15) = (base / 2) / (arrow length).\n3078         quiversize *= 1.8660254037844388\n3079         eb_quiver_style = {**eb_cap_style,\n3080                            'length': quiversize, 'arrow_length_ratio': 1}\n3081         eb_quiver_style.pop('markersize', None)\n3082 \n3083         # loop over x-, y-, and z-direction and draw relevant elements\n3084         for zdir, data, err, lolims, uplims in zip(\n3085                 ['x', 'y', 'z'], [x, y, z], [xerr, yerr, zerr],\n3086                 [xlolims, ylolims, zlolims], [xuplims, yuplims, zuplims]):\n3087 \n3088             dir_vector = art3d.get_dir_vector(zdir)\n3089             i_zdir = i_xyz[zdir]\n3090 \n3091             if err is None:\n3092                 continue\n3093 \n3094             if not np.iterable(err):\n3095                 err = [err] * len(data)\n3096 \n3097             err = np.atleast_1d(err)\n3098 \n3099             # arrays fine here, they are booleans and hence not units\n3100             lolims = np.broadcast_to(lolims, len(data)).astype(bool)\n3101             uplims = np.broadcast_to(uplims, len(data)).astype(bool)\n3102 \n3103             # a nested list structure that expands to (xl,xh),(yl,yh),(zl,zh),\n3104             # where x/y/z and l/h correspond to dimensions and low/high\n3105             # positions of errorbars in a dimension we're looping over\n3106             coorderr = [\n3107                 _extract_errs(err * dir_vector[i], coord, lolims, uplims)\n3108                 for i, coord in enumerate([x, y, z])]\n3109             (xl, xh), (yl, yh), (zl, zh) = coorderr\n3110 \n3111             # draws capmarkers - flat caps orthogonal to the error bars\n3112             nolims = ~(lolims | uplims)\n3113             if nolims.any() and capsize > 0:\n3114                 lo_caps_xyz = _apply_mask([xl, yl, zl], nolims & everymask)\n3115                 hi_caps_xyz = _apply_mask([xh, yh, zh], nolims & everymask)\n3116 \n3117                 # setting '_' for z-caps and '|' for x- and y-caps;\n3118                 # these markers will rotate as the viewing angle changes\n3119                 cap_lo = art3d.Line3D(*lo_caps_xyz, ls='',\n3120                                       marker=capmarker[i_zdir],\n3121                                       **eb_cap_style)\n3122                 cap_hi = art3d.Line3D(*hi_caps_xyz, ls='',\n3123                                       marker=capmarker[i_zdir],\n3124                                       **eb_cap_style)\n3125                 self.add_line(cap_lo)\n3126                 self.add_line(cap_hi)\n3127                 caplines.append(cap_lo)\n3128                 caplines.append(cap_hi)\n3129 \n3130             if lolims.any():\n3131                 xh0, yh0, zh0 = _apply_mask([xh, yh, zh], lolims & everymask)\n3132                 self.quiver(xh0, yh0, zh0, *dir_vector, **eb_quiver_style)\n3133             if uplims.any():\n3134                 xl0, yl0, zl0 = _apply_mask([xl, yl, zl], uplims & everymask)\n3135                 self.quiver(xl0, yl0, zl0, *-dir_vector, **eb_quiver_style)\n3136 \n3137             errline = art3d.Line3DCollection(np.array(coorderr).T,\n3138                                              **eb_lines_style)\n3139             self.add_collection(errline)\n3140             errlines.append(errline)\n3141             coorderrs.append(coorderr)\n3142 \n3143         coorderrs = np.array(coorderrs)\n3144 \n3145         def _digout_minmax(err_arr, coord_label):\n3146             return (np.nanmin(err_arr[:, i_xyz[coord_label], :, :]),\n3147                     np.nanmax(err_arr[:, i_xyz[coord_label], :, :]))\n3148 \n3149         minx, maxx = _digout_minmax(coorderrs, 'x')\n3150         miny, maxy = _digout_minmax(coorderrs, 'y')\n3151         minz, maxz = _digout_minmax(coorderrs, 'z')\n3152         self.auto_scale_xyz((minx, maxx), (miny, maxy), (minz, maxz), had_data)\n3153 \n3154         # Adapting errorbar containers for 3d case, assuming z-axis points \"up\"\n3155         errorbar_container = mcontainer.ErrorbarContainer(\n3156             (data_line, tuple(caplines), tuple(errlines)),\n3157             has_xerr=(xerr is not None or yerr is not None),\n3158             has_yerr=(zerr is not None),\n3159             label=label)\n3160         self.containers.append(errorbar_container)\n3161 \n3162         return errlines, caplines, limmarks\n3163 \n3164     @_api.make_keyword_only(\"3.8\", \"call_axes_locator\")\n3165     def get_tightbbox(self, renderer=None, call_axes_locator=True,\n3166                       bbox_extra_artists=None, *, for_layout_only=False):\n3167         ret = super().get_tightbbox(renderer,\n3168                                     call_axes_locator=call_axes_locator,\n3169                                     bbox_extra_artists=bbox_extra_artists,\n3170                                     for_layout_only=for_layout_only)\n3171         batch = [ret]\n3172         if self._axis3don:\n3173             for axis in self._axis_map.values():\n3174                 if axis.get_visible():\n3175                     axis_bb = martist._get_tightbbox_for_layout_only(\n3176                         axis, renderer)\n3177                     if axis_bb:\n3178                         batch.append(axis_bb)\n3179         return mtransforms.Bbox.union(batch)\n3180 \n3181     @_preprocess_data()\n3182     def stem(self, x, y, z, *, linefmt='C0-', markerfmt='C0o', basefmt='C3-',\n3183              bottom=0, label=None, orientation='z'):\n3184         \"\"\"\n3185         Create a 3D stem plot.\n3186 \n3187         A stem plot draws lines perpendicular to a baseline, and places markers\n3188         at the heads. By default, the baseline is defined by *x* and *y*, and\n3189         stems are drawn vertically from *bottom* to *z*.\n3190 \n3191         Parameters\n3192         ----------\n3193         x, y, z : array-like\n3194             The positions of the heads of the stems. The stems are drawn along\n3195             the *orientation*-direction from the baseline at *bottom* (in the\n3196             *orientation*-coordinate) to the heads. By default, the *x* and *y*\n3197             positions are used for the baseline and *z* for the head position,\n3198             but this can be changed by *orientation*.\n3199 \n3200         linefmt : str, default: 'C0-'\n3201             A string defining the properties of the vertical lines. Usually,\n3202             this will be a color or a color and a linestyle:\n3203 \n3204             =========  =============\n3205             Character  Line Style\n3206             =========  =============\n3207             ``'-'``    solid line\n3208             ``'--'``   dashed line\n3209             ``'-.'``   dash-dot line\n3210             ``':'``    dotted line\n3211             =========  =============\n3212 \n3213             Note: While it is technically possible to specify valid formats\n3214             other than color or color and linestyle (e.g. 'rx' or '-.'), this\n3215             is beyond the intention of the method and will most likely not\n3216             result in a reasonable plot.\n3217 \n3218         markerfmt : str, default: 'C0o'\n3219             A string defining the properties of the markers at the stem heads.\n3220 \n3221         basefmt : str, default: 'C3-'\n3222             A format string defining the properties of the baseline.\n3223 \n3224         bottom : float, default: 0\n3225             The position of the baseline, in *orientation*-coordinates.\n3226 \n3227         label : str, default: None\n3228             The label to use for the stems in legends.\n3229 \n3230         orientation : {'x', 'y', 'z'}, default: 'z'\n3231             The direction along which stems are drawn.\n3232 \n3233         data : indexable object, optional\n3234             DATA_PARAMETER_PLACEHOLDER\n3235 \n3236         Returns\n3237         -------\n3238         `.StemContainer`\n3239             The container may be treated like a tuple\n3240             (*markerline*, *stemlines*, *baseline*)\n3241 \n3242         Examples\n3243         --------\n3244         .. plot:: gallery/mplot3d/stem3d_demo.py\n3245         \"\"\"\n3246 \n3247         from matplotlib.container import StemContainer\n3248 \n3249         had_data = self.has_data()\n3250 \n3251         _api.check_in_list(['x', 'y', 'z'], orientation=orientation)\n3252 \n3253         xlim = (np.min(x), np.max(x))\n3254         ylim = (np.min(y), np.max(y))\n3255         zlim = (np.min(z), np.max(z))\n3256 \n3257         # Determine the appropriate plane for the baseline and the direction of\n3258         # stemlines based on the value of orientation.\n3259         if orientation == 'x':\n3260             basex, basexlim = y, ylim\n3261             basey, baseylim = z, zlim\n3262             lines = [[(bottom, thisy, thisz), (thisx, thisy, thisz)]\n3263                      for thisx, thisy, thisz in zip(x, y, z)]\n3264         elif orientation == 'y':\n3265             basex, basexlim = x, xlim\n3266             basey, baseylim = z, zlim\n3267             lines = [[(thisx, bottom, thisz), (thisx, thisy, thisz)]\n3268                      for thisx, thisy, thisz in zip(x, y, z)]\n3269         else:\n3270             basex, basexlim = x, xlim\n3271             basey, baseylim = y, ylim\n3272             lines = [[(thisx, thisy, bottom), (thisx, thisy, thisz)]\n3273                      for thisx, thisy, thisz in zip(x, y, z)]\n3274 \n3275         # Determine style for stem lines.\n3276         linestyle, linemarker, linecolor = _process_plot_format(linefmt)\n3277         if linestyle is None:\n3278             linestyle = mpl.rcParams['lines.linestyle']\n3279 \n3280         # Plot everything in required order.\n3281         baseline, = self.plot(basex, basey, basefmt, zs=bottom,\n3282                               zdir=orientation, label='_nolegend_')\n3283         stemlines = art3d.Line3DCollection(\n3284             lines, linestyles=linestyle, colors=linecolor, label='_nolegend_')\n3285         self.add_collection(stemlines)\n3286         markerline, = self.plot(x, y, z, markerfmt, label='_nolegend_')\n3287 \n3288         stem_container = StemContainer((markerline, stemlines, baseline),\n3289                                        label=label)\n3290         self.add_container(stem_container)\n3291 \n3292         jx, jy, jz = art3d.juggle_axes(basexlim, baseylim, [bottom, bottom],\n3293                                        orientation)\n3294         self.auto_scale_xyz([*jx, *xlim], [*jy, *ylim], [*jz, *zlim], had_data)\n3295 \n3296         return stem_container\n3297 \n3298     stem3D = stem\n",
        "intended_behavior": "This class provides additional context to the issue."
    }
]