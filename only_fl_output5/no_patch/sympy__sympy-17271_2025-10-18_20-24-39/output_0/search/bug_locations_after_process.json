[
    {
        "rel_file_path": "sympy/functions/elementary/integers.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sympy__sympy/setup_sympy__sympy__1.5/sympy/functions/elementary/integers.py",
        "start": 300,
        "end": 333,
        "class_name": "frac",
        "method_name": "eval",
        "code": "300     def eval(cls, arg):\n301         from sympy import AccumBounds, im\n302 \n303         def _eval(arg):\n304             if arg is S.Infinity or arg is S.NegativeInfinity:\n305                 return AccumBounds(0, 1)\n306             if arg.is_integer:\n307                 return S.Zero\n308             if arg.is_number:\n309                 if arg is S.NaN:\n310                     return S.NaN\n311                 elif arg is S.ComplexInfinity:\n312                     return None\n313                 else:\n314                     return arg - floor(arg)\n315             return cls(arg, evaluate=False)\n316 \n317         terms = Add.make_args(arg)\n318         real, imag = S.Zero, S.Zero\n319         for t in terms:\n320             # Two checks are needed for complex arguments\n321             # see issue-7649 for details\n322             if t.is_imaginary or (S.ImaginaryUnit*t).is_real:\n323                 i = im(t)\n324                 if not i.has(S.ImaginaryUnit):\n325                     imag += i\n326                 else:\n327                     real += t\n328             else:\n329                 real += t\n330 \n331         real = _eval(real)\n332         imag = _eval(imag)\n333         return real + S.ImaginaryUnit*imag\n",
        "intended_behavior": "The `eval` function within `frac` should be enhanced to handle cases where the argument (`arg`) is `zoo` (or leads to an indeterminate situation like `None + Zero`). The function should early check if the input is `zoo` or if during its processing, any component (real or imaginary) evaluates to `None` when encountering `zoo`. If `arg` is `zoo` or processing leads to an undefined state because of `zoo`, the function should either return a value that makes sense in the context of SymPy's handling of infinity (such as `NaN`, `0`, or `zoo` itself) or explicitly raise a meaningful exception. This behavior should be congruent with how undefined or infinite results are handled elsewhere in SymPy, particularly in functions that perform mathematical operations on complex numbers or infinity. This modification ensures `frac` gracefully handles all inputs, including `zoo`, maintaining the overall robustness and consistency of mathematical operations in SymPy."
    },
    {
        "rel_file_path": "sympy/functions/elementary/integers.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sympy__sympy/setup_sympy__sympy__1.5/sympy/functions/elementary/integers.py",
        "start": 250,
        "end": 345,
        "class_name": "frac",
        "method_name": null,
        "code": "250 class frac(Function):\n251     r\"\"\"Represents the fractional part of x\n252 \n253     For real numbers it is defined [1]_ as\n254 \n255     .. math::\n256         x - \\left\\lfloor{x}\\right\\rfloor\n257 \n258     Examples\n259     ========\n260 \n261     >>> from sympy import Symbol, frac, Rational, floor, ceiling, I\n262     >>> frac(Rational(4, 3))\n263     1/3\n264     >>> frac(-Rational(4, 3))\n265     2/3\n266 \n267     returns zero for integer arguments\n268 \n269     >>> n = Symbol('n', integer=True)\n270     >>> frac(n)\n271     0\n272 \n273     rewrite as floor\n274 \n275     >>> x = Symbol('x')\n276     >>> frac(x).rewrite(floor)\n277     x - floor(x)\n278 \n279     for complex arguments\n280 \n281     >>> r = Symbol('r', real=True)\n282     >>> t = Symbol('t', real=True)\n283     >>> frac(t + I*r)\n284     I*frac(r) + frac(t)\n285 \n286     See Also\n287     ========\n288 \n289     sympy.functions.elementary.integers.floor\n290     sympy.functions.elementary.integers.ceiling\n291 \n292     References\n293     ===========\n294 \n295     .. [1] https://en.wikipedia.org/wiki/Fractional_part\n296     .. [2] http://mathworld.wolfram.com/FractionalPart.html\n297 \n298     \"\"\"\n299     @classmethod\n300     def eval(cls, arg):\n301         from sympy import AccumBounds, im\n302 \n303         def _eval(arg):\n304             if arg is S.Infinity or arg is S.NegativeInfinity:\n305                 return AccumBounds(0, 1)\n306             if arg.is_integer:\n307                 return S.Zero\n308             if arg.is_number:\n309                 if arg is S.NaN:\n310                     return S.NaN\n311                 elif arg is S.ComplexInfinity:\n312                     return None\n313                 else:\n314                     return arg - floor(arg)\n315             return cls(arg, evaluate=False)\n316 \n317         terms = Add.make_args(arg)\n318         real, imag = S.Zero, S.Zero\n319         for t in terms:\n320             # Two checks are needed for complex arguments\n321             # see issue-7649 for details\n322             if t.is_imaginary or (S.ImaginaryUnit*t).is_real:\n323                 i = im(t)\n324                 if not i.has(S.ImaginaryUnit):\n325                     imag += i\n326                 else:\n327                     real += t\n328             else:\n329                 real += t\n330 \n331         real = _eval(real)\n332         imag = _eval(imag)\n333         return real + S.ImaginaryUnit*imag\n334 \n335     def _eval_rewrite_as_floor(self, arg, **kwargs):\n336         return arg - floor(arg)\n337 \n338     def _eval_rewrite_as_ceiling(self, arg, **kwargs):\n339         return arg + ceiling(-arg)\n340 \n341     def _eval_Eq(self, other):\n342         if isinstance(self, frac):\n343             if (self.rewrite(floor) == other) or \\\n344                     (self.rewrite(ceiling) == other):\n345                 return S.true\n",
        "intended_behavior": "This class provides additional context to the issue."
    }
]