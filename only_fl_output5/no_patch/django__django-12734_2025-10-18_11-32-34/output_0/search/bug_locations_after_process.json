[
    {
        "rel_file_path": "django/db/migrations/operations/models.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.1/django/db/migrations/operations/models.py",
        "start": 1,
        "end": 859,
        "class_name": null,
        "method_name": null,
        "code": "1 from django.db import models\n2 from django.db.migrations.operations.base import Operation\n3 from django.db.migrations.state import ModelState\n4 from django.db.models.options import normalize_together\n5 from django.utils.functional import cached_property\n6 \n7 from .fields import (\n8     AddField, AlterField, FieldOperation, RemoveField, RenameField,\n9 )\n10 from .utils import field_references, get_references, resolve_relation\n11 \n12 \n13 def _check_for_duplicates(arg_name, objs):\n14     used_vals = set()\n15     for val in objs:\n16         if val in used_vals:\n17             raise ValueError(\n18                 \"Found duplicate value %s in CreateModel %s argument.\" % (val, arg_name)\n19             )\n20         used_vals.add(val)\n21 \n22 \n23 class ModelOperation(Operation):\n24     def __init__(self, name):\n25         self.name = name\n26 \n27     @cached_property\n28     def name_lower(self):\n29         return self.name.lower()\n30 \n31     def references_model(self, name, app_label):\n32         return name.lower() == self.name_lower\n33 \n34     def reduce(self, operation, app_label):\n35         return (\n36             super().reduce(operation, app_label) or\n37             not operation.references_model(self.name, app_label)\n38         )\n39 \n40 \n41 class CreateModel(ModelOperation):\n42     \"\"\"Create a model's table.\"\"\"\n43 \n44     serialization_expand_args = ['fields', 'options', 'managers']\n45 \n46     def __init__(self, name, fields, options=None, bases=None, managers=None):\n47         self.fields = fields\n48         self.options = options or {}\n49         self.bases = bases or (models.Model,)\n50         self.managers = managers or []\n51         super().__init__(name)\n52         # Sanity-check that there are no duplicated field names, bases, or\n53         # manager names\n54         _check_for_duplicates('fields', (name for name, _ in self.fields))\n55         _check_for_duplicates('bases', (\n56             base._meta.label_lower if hasattr(base, '_meta') else\n57             base.lower() if isinstance(base, str) else base\n58             for base in self.bases\n59         ))\n60         _check_for_duplicates('managers', (name for name, _ in self.managers))\n61 \n62     def deconstruct(self):\n63         kwargs = {\n64             'name': self.name,\n65             'fields': self.fields,\n66         }\n67         if self.options:\n68             kwargs['options'] = self.options\n69         if self.bases and self.bases != (models.Model,):\n70             kwargs['bases'] = self.bases\n71         if self.managers and self.managers != [('objects', models.Manager())]:\n72             kwargs['managers'] = self.managers\n73         return (\n74             self.__class__.__qualname__,\n75             [],\n76             kwargs\n77         )\n78 \n79     def state_forwards(self, app_label, state):\n80         state.add_model(ModelState(\n81             app_label,\n82             self.name,\n83             list(self.fields),\n84             dict(self.options),\n85             tuple(self.bases),\n86             list(self.managers),\n87         ))\n88 \n89     def database_forwards(self, app_label, schema_editor, from_state, to_state):\n90         model = to_state.apps.get_model(app_label, self.name)\n91         if self.allow_migrate_model(schema_editor.connection.alias, model):\n92             schema_editor.create_model(model)\n93 \n94     def database_backwards(self, app_label, schema_editor, from_state, to_state):\n95         model = from_state.apps.get_model(app_label, self.name)\n96         if self.allow_migrate_model(schema_editor.connection.alias, model):\n97             schema_editor.delete_model(model)\n98 \n99     def describe(self):\n100         return \"Create %smodel %s\" % (\"proxy \" if self.options.get(\"proxy\", False) else \"\", self.name)\n101 \n102     def references_model(self, name, app_label):\n103         name_lower = name.lower()\n104         if name_lower == self.name_lower:\n105             return True\n106 \n107         # Check we didn't inherit from the model\n108         reference_model_tuple = (app_label, name_lower)\n109         for base in self.bases:\n110             if (base is not models.Model and isinstance(base, (models.base.ModelBase, str)) and\n111                     resolve_relation(base, app_label) == reference_model_tuple):\n112                 return True\n113 \n114         # Check we have no FKs/M2Ms with it\n115         for _name, field in self.fields:\n116             if field_references((app_label, self.name_lower), field, reference_model_tuple):\n117                 return True\n118         return False\n119 \n120     def reduce(self, operation, app_label):\n121         if (isinstance(operation, DeleteModel) and\n122                 self.name_lower == operation.name_lower and\n123                 not self.options.get(\"proxy\", False)):\n124             return []\n125         elif isinstance(operation, RenameModel) and self.name_lower == operation.old_name_lower:\n126             return [\n127                 CreateModel(\n128                     operation.new_name,\n129                     fields=self.fields,\n130                     options=self.options,\n131                     bases=self.bases,\n132                     managers=self.managers,\n133                 ),\n134             ]\n135         elif isinstance(operation, AlterModelOptions) and self.name_lower == operation.name_lower:\n136             return [\n137                 CreateModel(\n138                     self.name,\n139                     fields=self.fields,\n140                     options={**self.options, **operation.options},\n141                     bases=self.bases,\n142                     managers=self.managers,\n143                 ),\n144             ]\n145         elif isinstance(operation, AlterTogetherOptionOperation) and self.name_lower == operation.name_lower:\n146             return [\n147                 CreateModel(\n148                     self.name,\n149                     fields=self.fields,\n150                     options={**self.options, **{operation.option_name: operation.option_value}},\n151                     bases=self.bases,\n152                     managers=self.managers,\n153                 ),\n154             ]\n155         elif isinstance(operation, AlterOrderWithRespectTo) and self.name_lower == operation.name_lower:\n156             return [\n157                 CreateModel(\n158                     self.name,\n159                     fields=self.fields,\n160                     options={**self.options, 'order_with_respect_to': operation.order_with_respect_to},\n161                     bases=self.bases,\n162                     managers=self.managers,\n163                 ),\n164             ]\n165         elif isinstance(operation, FieldOperation) and self.name_lower == operation.model_name_lower:\n166             if isinstance(operation, AddField):\n167                 return [\n168                     CreateModel(\n169                         self.name,\n170                         fields=self.fields + [(operation.name, operation.field)],\n171                         options=self.options,\n172                         bases=self.bases,\n173                         managers=self.managers,\n174                     ),\n175                 ]\n176             elif isinstance(operation, AlterField):\n177                 return [\n178                     CreateModel(\n179                         self.name,\n180                         fields=[\n181                             (n, operation.field if n == operation.name else v)\n182                             for n, v in self.fields\n183                         ],\n184                         options=self.options,\n185                         bases=self.bases,\n186                         managers=self.managers,\n187                     ),\n188                 ]\n189             elif isinstance(operation, RemoveField):\n190                 options = self.options.copy()\n191                 for option_name in ('unique_together', 'index_together'):\n192                     option = options.pop(option_name, None)\n193                     if option:\n194                         option = set(filter(bool, (\n195                             tuple(f for f in fields if f != operation.name_lower) for fields in option\n196                         )))\n197                         if option:\n198                             options[option_name] = option\n199                 order_with_respect_to = options.get('order_with_respect_to')\n200                 if order_with_respect_to == operation.name_lower:\n201                     del options['order_with_respect_to']\n202                 return [\n203                     CreateModel(\n204                         self.name,\n205                         fields=[\n206                             (n, v)\n207                             for n, v in self.fields\n208                             if n.lower() != operation.name_lower\n209                         ],\n210                         options=options,\n211                         bases=self.bases,\n212                         managers=self.managers,\n213                     ),\n214                 ]\n215             elif isinstance(operation, RenameField):\n216                 options = self.options.copy()\n217                 for option_name in ('unique_together', 'index_together'):\n218                     option = options.get(option_name)\n219                     if option:\n220                         options[option_name] = {\n221                             tuple(operation.new_name if f == operation.old_name else f for f in fields)\n222                             for fields in option\n223                         }\n224                 order_with_respect_to = options.get('order_with_respect_to')\n225                 if order_with_respect_to == operation.old_name:\n226                     options['order_with_respect_to'] = operation.new_name\n227                 return [\n228                     CreateModel(\n229                         self.name,\n230                         fields=[\n231                             (operation.new_name if n == operation.old_name else n, v)\n232                             for n, v in self.fields\n233                         ],\n234                         options=options,\n235                         bases=self.bases,\n236                         managers=self.managers,\n237                     ),\n238                 ]\n239         return super().reduce(operation, app_label)\n240 \n241 \n242 class DeleteModel(ModelOperation):\n243     \"\"\"Drop a model's table.\"\"\"\n244 \n245     def deconstruct(self):\n246         kwargs = {\n247             'name': self.name,\n248         }\n249         return (\n250             self.__class__.__qualname__,\n251             [],\n252             kwargs\n253         )\n254 \n255     def state_forwards(self, app_label, state):\n256         state.remove_model(app_label, self.name_lower)\n257 \n258     def database_forwards(self, app_label, schema_editor, from_state, to_state):\n259         model = from_state.apps.get_model(app_label, self.name)\n260         if self.allow_migrate_model(schema_editor.connection.alias, model):\n261             schema_editor.delete_model(model)\n262 \n263     def database_backwards(self, app_label, schema_editor, from_state, to_state):\n264         model = to_state.apps.get_model(app_label, self.name)\n265         if self.allow_migrate_model(schema_editor.connection.alias, model):\n266             schema_editor.create_model(model)\n267 \n268     def references_model(self, name, app_label):\n269         # The deleted model could be referencing the specified model through\n270         # related fields.\n271         return True\n272 \n273     def describe(self):\n274         return \"Delete model %s\" % self.name\n275 \n276 \n277 class RenameModel(ModelOperation):\n278     \"\"\"Rename a model.\"\"\"\n279 \n280     def __init__(self, old_name, new_name):\n281         self.old_name = old_name\n282         self.new_name = new_name\n283         super().__init__(old_name)\n284 \n285     @cached_property\n286     def old_name_lower(self):\n287         return self.old_name.lower()\n288 \n289     @cached_property\n290     def new_name_lower(self):\n291         return self.new_name.lower()\n292 \n293     def deconstruct(self):\n294         kwargs = {\n295             'old_name': self.old_name,\n296             'new_name': self.new_name,\n297         }\n298         return (\n299             self.__class__.__qualname__,\n300             [],\n301             kwargs\n302         )\n303 \n304     def state_forwards(self, app_label, state):\n305         # Add a new model.\n306         renamed_model = state.models[app_label, self.old_name_lower].clone()\n307         renamed_model.name = self.new_name\n308         state.models[app_label, self.new_name_lower] = renamed_model\n309         # Repoint all fields pointing to the old model to the new one.\n310         old_model_tuple = (app_label, self.old_name_lower)\n311         new_remote_model = '%s.%s' % (app_label, self.new_name)\n312         to_reload = set()\n313         for model_state, index, name, field, reference in get_references(state, old_model_tuple):\n314             changed_field = None\n315             if reference.to:\n316                 changed_field = field.clone()\n317                 changed_field.remote_field.model = new_remote_model\n318             if reference.through:\n319                 if changed_field is None:\n320                     changed_field = field.clone()\n321                 changed_field.remote_field.through = new_remote_model\n322             if changed_field:\n323                 model_state.fields[index] = name, changed_field\n324                 to_reload.add((model_state.app_label, model_state.name_lower))\n325         # Reload models related to old model before removing the old model.\n326         state.reload_models(to_reload, delay=True)\n327         # Remove the old model.\n328         state.remove_model(app_label, self.old_name_lower)\n329         state.reload_model(app_label, self.new_name_lower, delay=True)\n330 \n331     def database_forwards(self, app_label, schema_editor, from_state, to_state):\n332         new_model = to_state.apps.get_model(app_label, self.new_name)\n333         if self.allow_migrate_model(schema_editor.connection.alias, new_model):\n334             old_model = from_state.apps.get_model(app_label, self.old_name)\n335             # Move the main table\n336             schema_editor.alter_db_table(\n337                 new_model,\n338                 old_model._meta.db_table,\n339                 new_model._meta.db_table,\n340             )\n341             # Alter the fields pointing to us\n342             for related_object in old_model._meta.related_objects:\n343                 if related_object.related_model == old_model:\n344                     model = new_model\n345                     related_key = (app_label, self.new_name_lower)\n346                 else:\n347                     model = related_object.related_model\n348                     related_key = (\n349                         related_object.related_model._meta.app_label,\n350                         related_object.related_model._meta.model_name,\n351                     )\n352                 to_field = to_state.apps.get_model(\n353                     *related_key\n354                 )._meta.get_field(related_object.field.name)\n355                 schema_editor.alter_field(\n356                     model,\n357                     related_object.field,\n358                     to_field,\n359                 )\n360             # Rename M2M fields whose name is based on this model's name.\n361             fields = zip(old_model._meta.local_many_to_many, new_model._meta.local_many_to_many)\n362             for (old_field, new_field) in fields:\n363                 # Skip self-referential fields as these are renamed above.\n364                 if new_field.model == new_field.related_model or not new_field.remote_field.through._meta.auto_created:\n365                     continue\n366                 # Rename the M2M table that's based on this model's name.\n367                 old_m2m_model = old_field.remote_field.through\n368                 new_m2m_model = new_field.remote_field.through\n369                 schema_editor.alter_db_table(\n370                     new_m2m_model,\n371                     old_m2m_model._meta.db_table,\n372                     new_m2m_model._meta.db_table,\n373                 )\n374                 # Rename the column in the M2M table that's based on this\n375                 # model's name.\n376                 schema_editor.alter_field(\n377                     new_m2m_model,\n378                     old_m2m_model._meta.get_field(old_model._meta.model_name),\n379                     new_m2m_model._meta.get_field(new_model._meta.model_name),\n380                 )\n381 \n382     def database_backwards(self, app_label, schema_editor, from_state, to_state):\n383         self.new_name_lower, self.old_name_lower = self.old_name_lower, self.new_name_lower\n384         self.new_name, self.old_name = self.old_name, self.new_name\n385 \n386         self.database_forwards(app_label, schema_editor, from_state, to_state)\n387 \n388         self.new_name_lower, self.old_name_lower = self.old_name_lower, self.new_name_lower\n389         self.new_name, self.old_name = self.old_name, self.new_name\n390 \n391     def references_model(self, name, app_label):\n392         return (\n393             name.lower() == self.old_name_lower or\n394             name.lower() == self.new_name_lower\n395         )\n396 \n397     def describe(self):\n398         return \"Rename model %s to %s\" % (self.old_name, self.new_name)\n399 \n400     def reduce(self, operation, app_label):\n401         if (isinstance(operation, RenameModel) and\n402                 self.new_name_lower == operation.old_name_lower):\n403             return [\n404                 RenameModel(\n405                     self.old_name,\n406                     operation.new_name,\n407                 ),\n408             ]\n409         # Skip `ModelOperation.reduce` as we want to run `references_model`\n410         # against self.new_name.\n411         return (\n412             super(ModelOperation, self).reduce(operation, app_label) or\n413             not operation.references_model(self.new_name, app_label)\n414         )\n415 \n416 \n417 class ModelOptionOperation(ModelOperation):\n418     def reduce(self, operation, app_label):\n419         if isinstance(operation, (self.__class__, DeleteModel)) and self.name_lower == operation.name_lower:\n420             return [operation]\n421         return super().reduce(operation, app_label)\n422 \n423 \n424 class AlterModelTable(ModelOptionOperation):\n425     \"\"\"Rename a model's table.\"\"\"\n426 \n427     def __init__(self, name, table):\n428         self.table = table\n429         super().__init__(name)\n430 \n431     def deconstruct(self):\n432         kwargs = {\n433             'name': self.name,\n434             'table': self.table,\n435         }\n436         return (\n437             self.__class__.__qualname__,\n438             [],\n439             kwargs\n440         )\n441 \n442     def state_forwards(self, app_label, state):\n443         state.models[app_label, self.name_lower].options[\"db_table\"] = self.table\n444         state.reload_model(app_label, self.name_lower, delay=True)\n445 \n446     def database_forwards(self, app_label, schema_editor, from_state, to_state):\n447         new_model = to_state.apps.get_model(app_label, self.name)\n448         if self.allow_migrate_model(schema_editor.connection.alias, new_model):\n449             old_model = from_state.apps.get_model(app_label, self.name)\n450             schema_editor.alter_db_table(\n451                 new_model,\n452                 old_model._meta.db_table,\n453                 new_model._meta.db_table,\n454             )\n455             # Rename M2M fields whose name is based on this model's db_table\n456             for (old_field, new_field) in zip(old_model._meta.local_many_to_many, new_model._meta.local_many_to_many):\n457                 if new_field.remote_field.through._meta.auto_created:\n458                     schema_editor.alter_db_table(\n459                         new_field.remote_field.through,\n460                         old_field.remote_field.through._meta.db_table,\n461                         new_field.remote_field.through._meta.db_table,\n462                     )\n463 \n464     def database_backwards(self, app_label, schema_editor, from_state, to_state):\n465         return self.database_forwards(app_label, schema_editor, from_state, to_state)\n466 \n467     def describe(self):\n468         return \"Rename table for %s to %s\" % (\n469             self.name,\n470             self.table if self.table is not None else \"(default)\"\n471         )\n472 \n473 \n474 class AlterTogetherOptionOperation(ModelOptionOperation):\n475     option_name = None\n476 \n477     def __init__(self, name, option_value):\n478         if option_value:\n479             option_value = set(normalize_together(option_value))\n480         setattr(self, self.option_name, option_value)\n481         super().__init__(name)\n482 \n483     @cached_property\n484     def option_value(self):\n485         return getattr(self, self.option_name)\n486 \n487     def deconstruct(self):\n488         kwargs = {\n489             'name': self.name,\n490             self.option_name: self.option_value,\n491         }\n492         return (\n493             self.__class__.__qualname__,\n494             [],\n495             kwargs\n496         )\n497 \n498     def state_forwards(self, app_label, state):\n499         model_state = state.models[app_label, self.name_lower]\n500         model_state.options[self.option_name] = self.option_value\n501         state.reload_model(app_label, self.name_lower, delay=True)\n502 \n503     def database_forwards(self, app_label, schema_editor, from_state, to_state):\n504         new_model = to_state.apps.get_model(app_label, self.name)\n505         if self.allow_migrate_model(schema_editor.connection.alias, new_model):\n506             old_model = from_state.apps.get_model(app_label, self.name)\n507             alter_together = getattr(schema_editor, 'alter_%s' % self.option_name)\n508             alter_together(\n509                 new_model,\n510                 getattr(old_model._meta, self.option_name, set()),\n511                 getattr(new_model._meta, self.option_name, set()),\n512             )\n513 \n514     def database_backwards(self, app_label, schema_editor, from_state, to_state):\n515         return self.database_forwards(app_label, schema_editor, from_state, to_state)\n516 \n517     def references_field(self, model_name, name, app_label):\n518         return (\n519             self.references_model(model_name, app_label) and\n520             (\n521                 not self.option_value or\n522                 any((name in fields) for fields in self.option_value)\n523             )\n524         )\n525 \n526     def describe(self):\n527         return \"Alter %s for %s (%s constraint(s))\" % (self.option_name, self.name, len(self.option_value or ''))\n528 \n529 \n530 class AlterUniqueTogether(AlterTogetherOptionOperation):\n531     \"\"\"\n532     Change the value of unique_together to the target one.\n533     Input value of unique_together must be a set of tuples.\n534     \"\"\"\n535     option_name = 'unique_together'\n536 \n537     def __init__(self, name, unique_together):\n538         super().__init__(name, unique_together)\n539 \n540 \n541 class AlterIndexTogether(AlterTogetherOptionOperation):\n542     \"\"\"\n543     Change the value of index_together to the target one.\n544     Input value of index_together must be a set of tuples.\n545     \"\"\"\n546     option_name = \"index_together\"\n547 \n548     def __init__(self, name, index_together):\n549         super().__init__(name, index_together)\n550 \n551 \n552 class AlterOrderWithRespectTo(ModelOptionOperation):\n553     \"\"\"Represent a change with the order_with_respect_to option.\"\"\"\n554 \n555     option_name = 'order_with_respect_to'\n556 \n557     def __init__(self, name, order_with_respect_to):\n558         self.order_with_respect_to = order_with_respect_to\n559         super().__init__(name)\n560 \n561     def deconstruct(self):\n562         kwargs = {\n563             'name': self.name,\n564             'order_with_respect_to': self.order_with_respect_to,\n565         }\n566         return (\n567             self.__class__.__qualname__,\n568             [],\n569             kwargs\n570         )\n571 \n572     def state_forwards(self, app_label, state):\n573         model_state = state.models[app_label, self.name_lower]\n574         model_state.options['order_with_respect_to'] = self.order_with_respect_to\n575         state.reload_model(app_label, self.name_lower, delay=True)\n576 \n577     def database_forwards(self, app_label, schema_editor, from_state, to_state):\n578         to_model = to_state.apps.get_model(app_label, self.name)\n579         if self.allow_migrate_model(schema_editor.connection.alias, to_model):\n580             from_model = from_state.apps.get_model(app_label, self.name)\n581             # Remove a field if we need to\n582             if from_model._meta.order_with_respect_to and not to_model._meta.order_with_respect_to:\n583                 schema_editor.remove_field(from_model, from_model._meta.get_field(\"_order\"))\n584             # Add a field if we need to (altering the column is untouched as\n585             # it's likely a rename)\n586             elif to_model._meta.order_with_respect_to and not from_model._meta.order_with_respect_to:\n587                 field = to_model._meta.get_field(\"_order\")\n588                 if not field.has_default():\n589                     field.default = 0\n590                 schema_editor.add_field(\n591                     from_model,\n592                     field,\n593                 )\n594 \n595     def database_backwards(self, app_label, schema_editor, from_state, to_state):\n596         self.database_forwards(app_label, schema_editor, from_state, to_state)\n597 \n598     def references_field(self, model_name, name, app_label):\n599         return (\n600             self.references_model(model_name, app_label) and\n601             (\n602                 self.order_with_respect_to is None or\n603                 name == self.order_with_respect_to\n604             )\n605         )\n606 \n607     def describe(self):\n608         return \"Set order_with_respect_to on %s to %s\" % (self.name, self.order_with_respect_to)\n609 \n610 \n611 class AlterModelOptions(ModelOptionOperation):\n612     \"\"\"\n613     Set new model options that don't directly affect the database schema\n614     (like verbose_name, permissions, ordering). Python code in migrations\n615     may still need them.\n616     \"\"\"\n617 \n618     # Model options we want to compare and preserve in an AlterModelOptions op\n619     ALTER_OPTION_KEYS = [\n620         \"base_manager_name\",\n621         \"default_manager_name\",\n622         \"default_related_name\",\n623         \"get_latest_by\",\n624         \"managed\",\n625         \"ordering\",\n626         \"permissions\",\n627         \"default_permissions\",\n628         \"select_on_save\",\n629         \"verbose_name\",\n630         \"verbose_name_plural\",\n631     ]\n632 \n633     def __init__(self, name, options):\n634         self.options = options\n635         super().__init__(name)\n636 \n637     def deconstruct(self):\n638         kwargs = {\n639             'name': self.name,\n640             'options': self.options,\n641         }\n642         return (\n643             self.__class__.__qualname__,\n644             [],\n645             kwargs\n646         )\n647 \n648     def state_forwards(self, app_label, state):\n649         model_state = state.models[app_label, self.name_lower]\n650         model_state.options = {**model_state.options, **self.options}\n651         for key in self.ALTER_OPTION_KEYS:\n652             if key not in self.options:\n653                 model_state.options.pop(key, False)\n654         state.reload_model(app_label, self.name_lower, delay=True)\n655 \n656     def database_forwards(self, app_label, schema_editor, from_state, to_state):\n657         pass\n658 \n659     def database_backwards(self, app_label, schema_editor, from_state, to_state):\n660         pass\n661 \n662     def describe(self):\n663         return \"Change Meta options on %s\" % self.name\n664 \n665 \n666 class AlterModelManagers(ModelOptionOperation):\n667     \"\"\"Alter the model's managers.\"\"\"\n668 \n669     serialization_expand_args = ['managers']\n670 \n671     def __init__(self, name, managers):\n672         self.managers = managers\n673         super().__init__(name)\n674 \n675     def deconstruct(self):\n676         return (\n677             self.__class__.__qualname__,\n678             [self.name, self.managers],\n679             {}\n680         )\n681 \n682     def state_forwards(self, app_label, state):\n683         model_state = state.models[app_label, self.name_lower]\n684         model_state.managers = list(self.managers)\n685         state.reload_model(app_label, self.name_lower, delay=True)\n686 \n687     def database_forwards(self, app_label, schema_editor, from_state, to_state):\n688         pass\n689 \n690     def database_backwards(self, app_label, schema_editor, from_state, to_state):\n691         pass\n692 \n693     def describe(self):\n694         return \"Change managers on %s\" % self.name\n695 \n696 \n697 class IndexOperation(Operation):\n698     option_name = 'indexes'\n699 \n700     @cached_property\n701     def model_name_lower(self):\n702         return self.model_name.lower()\n703 \n704 \n705 class AddIndex(IndexOperation):\n706     \"\"\"Add an index on a model.\"\"\"\n707 \n708     def __init__(self, model_name, index):\n709         self.model_name = model_name\n710         if not index.name:\n711             raise ValueError(\n712                 \"Indexes passed to AddIndex operations require a name \"\n713                 \"argument. %r doesn't have one.\" % index\n714             )\n715         self.index = index\n716 \n717     def state_forwards(self, app_label, state):\n718         model_state = state.models[app_label, self.model_name_lower]\n719         model_state.options[self.option_name] = [*model_state.options[self.option_name], self.index.clone()]\n720         state.reload_model(app_label, self.model_name_lower, delay=True)\n721 \n722     def database_forwards(self, app_label, schema_editor, from_state, to_state):\n723         model = to_state.apps.get_model(app_label, self.model_name)\n724         if self.allow_migrate_model(schema_editor.connection.alias, model):\n725             schema_editor.add_index(model, self.index)\n726 \n727     def database_backwards(self, app_label, schema_editor, from_state, to_state):\n728         model = from_state.apps.get_model(app_label, self.model_name)\n729         if self.allow_migrate_model(schema_editor.connection.alias, model):\n730             schema_editor.remove_index(model, self.index)\n731 \n732     def deconstruct(self):\n733         kwargs = {\n734             'model_name': self.model_name,\n735             'index': self.index,\n736         }\n737         return (\n738             self.__class__.__qualname__,\n739             [],\n740             kwargs,\n741         )\n742 \n743     def describe(self):\n744         return 'Create index %s on field(s) %s of model %s' % (\n745             self.index.name,\n746             ', '.join(self.index.fields),\n747             self.model_name,\n748         )\n749 \n750 \n751 class RemoveIndex(IndexOperation):\n752     \"\"\"Remove an index from a model.\"\"\"\n753 \n754     def __init__(self, model_name, name):\n755         self.model_name = model_name\n756         self.name = name\n757 \n758     def state_forwards(self, app_label, state):\n759         model_state = state.models[app_label, self.model_name_lower]\n760         indexes = model_state.options[self.option_name]\n761         model_state.options[self.option_name] = [idx for idx in indexes if idx.name != self.name]\n762         state.reload_model(app_label, self.model_name_lower, delay=True)\n763 \n764     def database_forwards(self, app_label, schema_editor, from_state, to_state):\n765         model = from_state.apps.get_model(app_label, self.model_name)\n766         if self.allow_migrate_model(schema_editor.connection.alias, model):\n767             from_model_state = from_state.models[app_label, self.model_name_lower]\n768             index = from_model_state.get_index_by_name(self.name)\n769             schema_editor.remove_index(model, index)\n770 \n771     def database_backwards(self, app_label, schema_editor, from_state, to_state):\n772         model = to_state.apps.get_model(app_label, self.model_name)\n773         if self.allow_migrate_model(schema_editor.connection.alias, model):\n774             to_model_state = to_state.models[app_label, self.model_name_lower]\n775             index = to_model_state.get_index_by_name(self.name)\n776             schema_editor.add_index(model, index)\n777 \n778     def deconstruct(self):\n779         kwargs = {\n780             'model_name': self.model_name,\n781             'name': self.name,\n782         }\n783         return (\n784             self.__class__.__qualname__,\n785             [],\n786             kwargs,\n787         )\n788 \n789     def describe(self):\n790         return 'Remove index %s from %s' % (self.name, self.model_name)\n791 \n792 \n793 class AddConstraint(IndexOperation):\n794     option_name = 'constraints'\n795 \n796     def __init__(self, model_name, constraint):\n797         self.model_name = model_name\n798         self.constraint = constraint\n799 \n800     def state_forwards(self, app_label, state):\n801         model_state = state.models[app_label, self.model_name_lower]\n802         model_state.options[self.option_name] = [*model_state.options[self.option_name], self.constraint]\n803         state.reload_model(app_label, self.model_name_lower, delay=True)\n804 \n805     def database_forwards(self, app_label, schema_editor, from_state, to_state):\n806         model = to_state.apps.get_model(app_label, self.model_name)\n807         if self.allow_migrate_model(schema_editor.connection.alias, model):\n808             schema_editor.add_constraint(model, self.constraint)\n809 \n810     def database_backwards(self, app_label, schema_editor, from_state, to_state):\n811         model = to_state.apps.get_model(app_label, self.model_name)\n812         if self.allow_migrate_model(schema_editor.connection.alias, model):\n813             schema_editor.remove_constraint(model, self.constraint)\n814 \n815     def deconstruct(self):\n816         return self.__class__.__name__, [], {\n817             'model_name': self.model_name,\n818             'constraint': self.constraint,\n819         }\n820 \n821     def describe(self):\n822         return 'Create constraint %s on model %s' % (self.constraint.name, self.model_name)\n823 \n824 \n825 class RemoveConstraint(IndexOperation):\n826     option_name = 'constraints'\n827 \n828     def __init__(self, model_name, name):\n829         self.model_name = model_name\n830         self.name = name\n831 \n832     def state_forwards(self, app_label, state):\n833         model_state = state.models[app_label, self.model_name_lower]\n834         constraints = model_state.options[self.option_name]\n835         model_state.options[self.option_name] = [c for c in constraints if c.name != self.name]\n836         state.reload_model(app_label, self.model_name_lower, delay=True)\n837 \n838     def database_forwards(self, app_label, schema_editor, from_state, to_state):\n839         model = to_state.apps.get_model(app_label, self.model_name)\n840         if self.allow_migrate_model(schema_editor.connection.alias, model):\n841             from_model_state = from_state.models[app_label, self.model_name_lower]\n842             constraint = from_model_state.get_constraint_by_name(self.name)\n843             schema_editor.remove_constraint(model, constraint)\n844 \n845     def database_backwards(self, app_label, schema_editor, from_state, to_state):\n846         model = to_state.apps.get_model(app_label, self.model_name)\n847         if self.allow_migrate_model(schema_editor.connection.alias, model):\n848             to_model_state = to_state.models[app_label, self.model_name_lower]\n849             constraint = to_model_state.get_constraint_by_name(self.name)\n850             schema_editor.add_constraint(model, constraint)\n851 \n852     def deconstruct(self):\n853         return self.__class__.__name__, [], {\n854             'model_name': self.model_name,\n855             'name': self.name,\n856         }\n857 \n858     def describe(self):\n859         return 'Remove constraint %s from model %s' % (self.name, self.model_name)\n",
        "intended_behavior": "The code should be enhanced to detect and apply schema changes not only to the fields of the models directly referenced in the AlterField operation but also to related fields in automatically generated intermediary tables. This would ensure that when a field like cve_id in the Vulnerability model changes its max_length, this change is also propagated to any corresponding fields in intermediary tables, such as those linking Vulnerability to AppVersion through a ManyToMany relation."
    }
]