2025-10-18 18:20:21.283 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-18 18:20:25.913 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=199, output_tokens=12, cost=0.002350
2025-10-18 18:20:25.915 | INFO     | Test agent decides that the issue statement does not contain reproduction steps; skipping reproducer tracing
2025-10-18 18:20:25.922 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 18:20:35.184 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=508, output_tokens=368, cost=0.016120
2025-10-18 18:20:35.193 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 18:20:38.279 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=722, output_tokens=87, cost=0.009830
2025-10-18 18:20:38.281 | DEBUG    | Extracted a valid json.
2025-10-18 18:20:38.281 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_method(\"handleIndexEntries\")",
        "search_method(\"categorizeEntries\")",
        "search_method(\"generateHtmlOutput\")",
        "search_code(\"Symbols in index\")",
        "search_code(\"_@_\")",
        "search_code(\"_£_\")",
        "search_code(\"_←_\")"
    ],
    "bug_locations": []
}
2025-10-18 18:20:38.321 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-18 18:20:38.322 | DEBUG    | <Agent search> Analyzing search results.
2025-10-18 18:20:50.157 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1139, output_tokens=536, cost=0.027470
2025-10-18 18:20:50.170 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 18:21:03.692 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1891, output_tokens=613, cost=0.037300
2025-10-18 18:21:03.703 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 18:21:12.549 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=967, output_tokens=347, cost=0.020080
2025-10-18 18:21:12.550 | DEBUG    | Extracted a valid json.
2025-10-18 18:21:12.550 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_method(\"generateIndex\")",
        "search_method(\"createHtmlSection\")",
        "search_code(\"special character\")",
        "search_code(\"createAnchor\")",
        "search_code(\"sortIndexEntries\")",
        "search_code(\"categorizeIndex\")",
        "search_class(\"IndexGenerator\")",
        "search_class(\"HtmlOutput\")"
    ],
    "bug_locations": [
        {
            "file": "index_generator.py",
            "class": "IndexGenerator",
            "method": "sortEntries",
            "intended_behavior": "This method would ideally be responsible for sorting index entries in a way that considers special characters (e.g., '@', '£', '←'). The intended behavior should be modified to ensure all symbol entries are categorized under a single \"Symbols\" section. This may involve adjusting the sorting logic to not only sort alphabetically but also group all special symbols together before or after alphabetical entries, based on project standards."
        },
        {
            "file": "html_output.py",
            "class": "HtmlOutput",
            "method": "generateSectionAnchors",
            "intended_behavior": "The method assumed to be responsible for generating HTML anchors for sections in the document should be adjusted to ensure uniqueness and correctness of anchor links, especially for sections that might traditionally have duplicates like \"Symbols.\" To resolve the issue, the code should ensure that each section, especially dynamically titled ones such as \"Symbols,\" has a unique anchor. If there is logic that hardcodes the assumption of only one \"Symbols\" section, it should be revised to accommodate or merge multiple such sections into one."
        }
    ]
}
2025-10-18 18:21:12.606 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-18 18:21:12.607 | DEBUG    | <Agent search> Analyzing search results.
2025-10-18 18:21:28.050 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2882, output_tokens=748, cost=0.051260
2025-10-18 18:21:28.064 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 18:21:34.305 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=3846, output_tokens=263, cost=0.046350
2025-10-18 18:21:34.310 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 18:21:36.719 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=617, output_tokens=56, cost=0.007850
2025-10-18 18:21:36.721 | INFO     | Refactored invocation argument parsing gives different result on 'get_code_around_line("utils/jssplitter_generator.py", 94, 10)': old result is ['utils/jssplitter_generator.py', '94', '10'], new result  is ['utils/jssplitter_generator.py', 94, 10]
2025-10-18 18:21:36.722 | DEBUG    | Extracted a valid json.
2025-10-18 18:21:36.722 | DEBUG    | Agent proxy return the following json: {
    "API_calls": ["get_code_around_line(\"utils/jssplitter_generator.py\", 94, 10)", "search_code(\"HTML output\")", "search_code(\"index\")", "search_code(\"symbols\")"],
    "bug_locations": []
}
2025-10-18 18:21:36.725 | INFO     | Refactored invocation argument parsing gives different result on 'get_code_around_line("utils/jssplitter_generator.py", 94, 10)': old result is ['utils/jssplitter_generator.py', '94', '10'], new result  is ['utils/jssplitter_generator.py', 94, 10]
2025-10-18 18:21:37.238 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-18 18:21:37.239 | DEBUG    | <Agent search> Analyzing search results.
2025-10-18 18:21:54.427 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=5847, output_tokens=769, cost=0.081540
2025-10-18 18:21:54.434 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 18:22:04.545 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=6832, output_tokens=414, cost=0.080740
2025-10-18 18:22:04.553 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 18:22:12.953 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=768, output_tokens=335, cost=0.017730
2025-10-18 18:22:12.954 | DEBUG    | Extracted a valid json.
2025-10-18 18:22:12.954 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "sphinx/environment/adapters/indexentries.py",
            "class": "",
            "method": "",
            "intended_behavior": "This file likely contains logic for sorting and categorizing index entries, which should be revised to aggregate entries containing special characters (@, £, ←) under a single “Symbols” category effectively. This will prevent the duplication of 'Symbols' sections in the HTML output. Specifically, any function within this file that handles the organization or categorization of symbols into sections should be updated to ensure all symbols are uniformly recognized and placed within the same category, regardless of their position in the Unicode table or their ASCII representation. This may involve enhancing the sorting logic to prioritize the grouping of all non-alphanumeric characters into a single index rather than segregating them based on their character value."
        },
        {
            "file": "sphinx/application.py",
            "class": "",
            "method": "",
            "intended_behavior": "In a file or class responsible for translating index entries into HTML elements, ensure that the logic recognizing and creating sections for 'Symbols' is capable of identifying and consolidating all symbol entries into one section. This might involve adjusting how sections are defined and anchored in the HTML document to prevent duplication. For instance, a method responsible for generating section headers or anchors for the HTML output needs validation to ensure that symbols are not creating additional unintended sections. This validation might include a pre-check on index categories to ensure uniqueness and consolidation of symbol entries, or a post-processing step to merge sections that are erroneously divided."
        }
    ]
}
2025-10-18 18:22:12.962 | DEBUG    | Bug location extracted successfully: [<file>sphinx/environment/adapters/indexentries.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2     sphinx.environment.adapters.indexentries
3     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
4 
5     Index entries adapters for sphinx.environment.
6 
7     :copyright: Copyright 2007-2020 by the Sphinx team, see AUTHORS.
8     :license: BSD, see LICENSE for details.
9 """
10 
11 import re
12 import unicodedata
13 from itertools import groupby
14 from typing import Any, Dict, Pattern, List, Tuple
15 from typing import cast
16 
17 from sphinx.builders import Builder
18 from sphinx.domains.index import IndexDomain
19 from sphinx.environment import BuildEnvironment
20 from sphinx.errors import NoUri
21 from sphinx.locale import _, __
22 from sphinx.util import split_into, logging
23 
24 
25 logger = logging.getLogger(__name__)
26 
27 
28 class IndexEntries:
29     def __init__(self, env: BuildEnvironment) -> None:
30         self.env = env
31 
32     def create_index(self, builder: Builder, group_entries: bool = True,
33                      _fixre: Pattern = re.compile(r'(.*) ([(][^()]*[)])')
34                      ) -> List[Tuple[str, List[Tuple[str, Any]]]]:
35         """Create the real index from the collected index entries."""
36         new = {}  # type: Dict[str, List]
37 
38         def add_entry(word: str, subword: str, main: str, link: bool = True,
39                       dic: Dict = new, key: str = None) -> None:
40             # Force the word to be unicode if it's a ASCII bytestring.
41             # This will solve problems with unicode normalization later.
42             # For instance the RFC role will add bytestrings at the moment
43             word = str(word)
44             entry = dic.get(word)
45             if not entry:
46                 dic[word] = entry = [[], {}, key]
47             if subword:
48                 add_entry(subword, '', main, link=link, dic=entry[1], key=key)
49             elif link:
50                 try:
51                     uri = builder.get_relative_uri('genindex', fn) + '#' + tid
52                 except NoUri:
53                     pass
54                 else:
55                     entry[0].append((main, uri))
56 
57         domain = cast(IndexDomain, self.env.get_domain('index'))
58         for fn, entries in domain.entries.items():
59             # new entry types must be listed in directives/other.py!
60             for type, value, tid, main, index_key in entries:
61                 try:
62                     if type == 'single':
63                         try:
64                             entry, subentry = split_into(2, 'single', value)
65                         except ValueError:
66                             entry, = split_into(1, 'single', value)
67                             subentry = ''
68                         add_entry(entry, subentry, main, key=index_key)
69                     elif type == 'pair':
70                         first, second = split_into(2, 'pair', value)
71                         add_entry(first, second, main, key=index_key)
72                         add_entry(second, first, main, key=index_key)
73                     elif type == 'triple':
74                         first, second, third = split_into(3, 'triple', value)
75                         add_entry(first, second + ' ' + third, main, key=index_key)
76                         add_entry(second, third + ', ' + first, main, key=index_key)
77                         add_entry(third, first + ' ' + second, main, key=index_key)
78                     elif type == 'see':
79                         first, second = split_into(2, 'see', value)
80                         add_entry(first, _('see %s') % second, None,
81                                   link=False, key=index_key)
82                     elif type == 'seealso':
83                         first, second = split_into(2, 'see', value)
84                         add_entry(first, _('see also %s') % second, None,
85                                   link=False, key=index_key)
86                     else:
87                         logger.warning(__('unknown index entry type %r'), type, location=fn)
88                 except ValueError as err:
89                     logger.warning(str(err), location=fn)
90 
91         # sort the index entries for same keyword.
92         def keyfunc0(entry: Tuple[str, str]) -> Tuple[bool, str]:
93             main, uri = entry
94             return (not main, uri)  # show main entries at first
95 
96         for indexentry in new.values():
97             indexentry[0].sort(key=keyfunc0)
98             for subentry in indexentry[1].values():
99                 subentry[0].sort(key=keyfunc0)  # type: ignore
100 
101         # sort the index entries; put all symbols at the front, even those
102         # following the letters in ASCII, this is where the chr(127) comes from
103         def keyfunc(entry: Tuple[str, List]) -> Tuple[str, str]:
104             key, (void, void, category_key) = entry
105             if category_key:
106                 # using specified category key to sort
107                 key = category_key
108             lckey = unicodedata.normalize('NFD', key.lower())
109             if lckey.startswith('\N{RIGHT-TO-LEFT MARK}'):
110                 lckey = lckey[1:]
111             if lckey[0:1].isalpha() or lckey.startswith('_'):
112                 lckey = chr(127) + lckey
113             # ensure a determinstic order *within* letters by also sorting on
114             # the entry itself
115             return (lckey, entry[0])
116         newlist = sorted(new.items(), key=keyfunc)
117 
118         if group_entries:
119             # fixup entries: transform
120             #   func() (in module foo)
121             #   func() (in module bar)
122             # into
123             #   func()
124             #     (in module foo)
125             #     (in module bar)
126             oldkey = ''
127             oldsubitems = None  # type: Dict[str, List]
128             i = 0
129             while i < len(newlist):
130                 key, (targets, subitems, _key) = newlist[i]
131                 # cannot move if it has subitems; structure gets too complex
132                 if not subitems:
133                     m = _fixre.match(key)
134                     if m:
135                         if oldkey == m.group(1):
136                             # prefixes match: add entry as subitem of the
137                             # previous entry
138                             oldsubitems.setdefault(m.group(2), [[], {}, _key])[0].\
139                                 extend(targets)
140                             del newlist[i]
141                             continue
142                         oldkey = m.group(1)
143                     else:
144                         oldkey = key
145                 oldsubitems = subitems
146                 i += 1
147 
148         # sort the sub-index entries
149         def keyfunc2(entry: Tuple[str, List]) -> str:
150             key = unicodedata.normalize('NFD', entry[0].lower())
151             if key.startswith('\N{RIGHT-TO-LEFT MARK}'):
152                 key = key[1:]
153             if key[0:1].isalpha() or key.startswith('_'):
154                 key = chr(127) + key
155             return key
156 
157         # group the entries by letter
158         def keyfunc3(item: Tuple[str, List]) -> str:
159             # hack: mutating the subitems dicts to a list in the keyfunc
160             k, v = item
161             v[1] = sorted(((si, se) for (si, (se, void, void)) in v[1].items()),
162                           key=keyfunc2)
163             if v[2] is None:
164                 # now calculate the key
165                 if k.startswith('\N{RIGHT-TO-LEFT MARK}'):
166                     k = k[1:]
167                 letter = unicodedata.normalize('NFD', k[0])[0].upper()
168                 if letter.isalpha() or letter == '_':
169                     return letter
170                 else:
171                     # get all other symbols under one heading
172                     return _('Symbols')
173             else:
174                 return v[2]
175         return [(key_, list(group))
176                 for (key_, group) in groupby(newlist, keyfunc3)]

</code><intended_behavior>This file likely contains logic for sorting and categorizing index entries, which should be revised to aggregate entries containing special characters (@, £, ←) under a single “Symbols” category effectively. This will prevent the duplication of 'Symbols' sections in the HTML output. Specifically, any function within this file that handles the organization or categorization of symbols into sections should be updated to ensure all symbols are uniformly recognized and placed within the same category, regardless of their position in the Unicode table or their ASCII representation. This may involve enhancing the sorting logic to prioritize the grouping of all non-alphanumeric characters into a single index rather than segregating them based on their character value.</intended_behavior>, <file>sphinx/application.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2     sphinx.application
3     ~~~~~~~~~~~~~~~~~~
4 
5     Sphinx application class and extensibility interface.
6 
7     Gracefully adapted from the TextPress system by Armin.
8 
9     :copyright: Copyright 2007-2020 by the Sphinx team, see AUTHORS.
10     :license: BSD, see LICENSE for details.
11 """
12 
13 import os
14 import pickle
15 import platform
16 import sys
17 import warnings
18 from collections import deque
19 from io import StringIO
20 from os import path
21 from typing import Any, Callable, Dict, IO, List, Tuple, Union
22 
23 from docutils import nodes
24 from docutils.nodes import Element, TextElement
25 from docutils.parsers.rst import Directive, roles
26 from docutils.transforms import Transform
27 from pygments.lexer import Lexer
28 
29 import sphinx
30 from sphinx import package_dir, locale
31 from sphinx.config import Config
32 from sphinx.deprecation import RemovedInSphinx40Warning
33 from sphinx.domains import Domain, Index
34 from sphinx.environment import BuildEnvironment
35 from sphinx.environment.collectors import EnvironmentCollector
36 from sphinx.errors import ApplicationError, ConfigError, VersionRequirementError
37 from sphinx.events import EventManager
38 from sphinx.extension import Extension
39 from sphinx.highlighting import lexer_classes, lexers
40 from sphinx.locale import __
41 from sphinx.project import Project
42 from sphinx.registry import SphinxComponentRegistry
43 from sphinx.roles import XRefRole
44 from sphinx.theming import Theme
45 from sphinx.util import docutils
46 from sphinx.util import logging
47 from sphinx.util import progress_message
48 from sphinx.util.build_phase import BuildPhase
49 from sphinx.util.console import bold  # type: ignore
50 from sphinx.util.i18n import CatalogRepository
51 from sphinx.util.logging import prefixed_warnings
52 from sphinx.util.osutil import abspath, ensuredir, relpath
53 from sphinx.util.tags import Tags
54 from sphinx.util.typing import RoleFunction, TitleGetter
55 
56 if False:
57     # For type annotation
58     from docutils.nodes import Node  # NOQA
59     from typing import Type  # for python3.5.1
60     from sphinx.builders import Builder
61 
62 
63 builtin_extensions = (
64     'sphinx.addnodes',
65     'sphinx.builders.changes',
66     'sphinx.builders.epub3',
67     'sphinx.builders.dirhtml',
68     'sphinx.builders.dummy',
69     'sphinx.builders.gettext',
70     'sphinx.builders.html',
71     'sphinx.builders.latex',
72     'sphinx.builders.linkcheck',
73     'sphinx.builders.manpage',
74     'sphinx.builders.singlehtml',
75     'sphinx.builders.texinfo',
76     'sphinx.builders.text',
77     'sphinx.builders.xml',
78     'sphinx.config',
79     'sphinx.domains.c',
80     'sphinx.domains.changeset',
81     'sphinx.domains.citation',
82     'sphinx.domains.cpp',
83     'sphinx.domains.index',
84     'sphinx.domains.javascript',
85     'sphinx.domains.math',
86     'sphinx.domains.python',
87     'sphinx.domains.rst',
88     'sphinx.domains.std',
89     'sphinx.directives',
90     'sphinx.directives.code',
91     'sphinx.directives.other',
92     'sphinx.directives.patches',
93     'sphinx.extension',
94     'sphinx.parsers',
95     'sphinx.registry',
96     'sphinx.roles',
97     'sphinx.transforms',
98     'sphinx.transforms.compact_bullet_list',
99     'sphinx.transforms.i18n',
100     'sphinx.transforms.references',
101     'sphinx.transforms.post_transforms',
102     'sphinx.transforms.post_transforms.code',
103     'sphinx.transforms.post_transforms.images',
104     'sphinx.util.compat',
105     'sphinx.versioning',
106     # collectors should be loaded by specific order
107     'sphinx.environment.collectors.dependencies',
108     'sphinx.environment.collectors.asset',
109     'sphinx.environment.collectors.metadata',
110     'sphinx.environment.collectors.title',
111     'sphinx.environment.collectors.toctree',
112     # 1st party extensions
113     'sphinxcontrib.applehelp',
114     'sphinxcontrib.devhelp',
115     'sphinxcontrib.htmlhelp',
116     'sphinxcontrib.serializinghtml',
117     'sphinxcontrib.qthelp',
118     # Strictly, alabaster theme is not a builtin extension,
119     # but it is loaded automatically to use it as default theme.
120     'alabaster',
121 )
122 
123 ENV_PICKLE_FILENAME = 'environment.pickle'
124 
125 logger = logging.getLogger(__name__)
126 
127 
128 class Sphinx:
129     """The main application class and extensibility interface.
130 
131     :ivar srcdir: Directory containing source.
132     :ivar confdir: Directory containing ``conf.py``.
133     :ivar doctreedir: Directory for storing pickled doctrees.
134     :ivar outdir: Directory for storing build documents.
135     """
136 
137     def __init__(self, srcdir: str, confdir: str, outdir: str, doctreedir: str,
138                  buildername: str, confoverrides: Dict = None,
139                  status: IO = sys.stdout, warning: IO = sys.stderr,
140                  freshenv: bool = False, warningiserror: bool = False, tags: List[str] = None,
141                  verbosity: int = 0, parallel: int = 0, keep_going: bool = False) -> None:
142         self.phase = BuildPhase.INITIALIZATION
143         self.verbosity = verbosity
144         self.extensions = {}                    # type: Dict[str, Extension]
145         self.builder = None                     # type: Builder
146         self.env = None                         # type: BuildEnvironment
147         self.project = None                     # type: Project
148         self.registry = SphinxComponentRegistry()
149         self.html_themes = {}                   # type: Dict[str, str]
150 
151         # validate provided directories
152         self.srcdir = abspath(srcdir)
153         self.outdir = abspath(outdir)
154         self.doctreedir = abspath(doctreedir)
155         self.confdir = confdir
156         if self.confdir:  # confdir is optional
157             self.confdir = abspath(self.confdir)
158             if not path.isfile(path.join(self.confdir, 'conf.py')):
159                 raise ApplicationError(__("config directory doesn't contain a "
160                                           "conf.py file (%s)") % confdir)
161 
162         if not path.isdir(self.srcdir):
163             raise ApplicationError(__('Cannot find source directory (%s)') %
164                                    self.srcdir)
165 
166         if path.exists(self.outdir) and not path.isdir(self.outdir):
167             raise ApplicationError(__('Output directory (%s) is not a directory') %
168                                    self.outdir)
169 
170         if self.srcdir == self.outdir:
171             raise ApplicationError(__('Source directory and destination '
172                                       'directory cannot be identical'))
173 
174         self.parallel = parallel
175 
176         if status is None:
177             self._status = StringIO()      # type: IO
178             self.quiet = True
179         else:
180             self._status = status
181             self.quiet = False
182 
183         if warning is None:
184             self._warning = StringIO()     # type: IO
185         else:
186             self._warning = warning
187         self._warncount = 0
188         self.keep_going = warningiserror and keep_going
189         if self.keep_going:
190             self.warningiserror = False
191         else:
192             self.warningiserror = warningiserror
193         logging.setup(self, self._status, self._warning)
194 
195         self.events = EventManager(self)
196 
197         # keep last few messages for traceback
198         # This will be filled by sphinx.util.logging.LastMessagesWriter
199         self.messagelog = deque(maxlen=10)  # type: deque
200 
201         # say hello to the world
202         logger.info(bold(__('Running Sphinx v%s') % sphinx.__display_version__))
203 
204         # notice for parallel build on macOS and py38+
205         if sys.version_info > (3, 8) and platform.system() == 'Darwin' and parallel > 1:
206             logger.info(bold(__("For security reason, parallel mode is disabled on macOS and "
207                                 "python3.8 and above. For more details, please read "
208                                 "https://github.com/sphinx-doc/sphinx/issues/6803")))
209 
210         # status code for command-line application
211         self.statuscode = 0
212 
213         # read config
214         self.tags = Tags(tags)
215         if self.confdir is None:
216             self.config = Config({}, confoverrides or {})
217         else:
218             self.config = Config.read(self.confdir, confoverrides or {}, self.tags)
219 
220         # initialize some limited config variables before initialize i18n and loading
221         # extensions
222         self.config.pre_init_values()
223 
224         # set up translation infrastructure
225         self._init_i18n()
226 
227         # check the Sphinx version if requested
228         if self.config.needs_sphinx and self.config.needs_sphinx > sphinx.__display_version__:
229             raise VersionRequirementError(
230                 __('This project needs at least Sphinx v%s and therefore cannot '
231                    'be built with this version.') % self.config.needs_sphinx)
232 
233         # set confdir to srcdir if -C given (!= no confdir); a few pieces
234         # of code expect a confdir to be set
235         if self.confdir is None:
236             self.confdir = self.srcdir
237 
238         # load all built-in extension modules
239         for extension in builtin_extensions:
240             self.setup_extension(extension)
241 
242         # load all user-given extension modules
243         for extension in self.config.extensions:
244             self.setup_extension(extension)
245 
246         # preload builder module (before init config values)
247         self.preload_builder(buildername)
248 
249         if not path.isdir(outdir):
250             with progress_message(__('making output directory')):
251                 ensuredir(outdir)
252 
253         # the config file itself can be an extension
254         if self.config.setup:
255             prefix = __('while setting up extension %s:') % "conf.py"
256             with prefixed_warnings(prefix):
257                 if callable(self.config.setup):
258                     self.config.setup(self)
259                 else:
260                     raise ConfigError(
261                         __("'setup' as currently defined in conf.py isn't a Python callable. "
262                            "Please modify its definition to make it a callable function. "
263                            "This is needed for conf.py to behave as a Sphinx extension.")
264                     )
265 
266         # now that we know all config values, collect them from conf.py
267         self.config.init_values()
268         self.events.emit('config-inited', self.config)
269 
270         # create the project
271         self.project = Project(self.srcdir, self.config.source_suffix)
272         # create the builder
273         self.builder = self.create_builder(buildername)
274         # set up the build environment
275         self._init_env(freshenv)
276         # set up the builder
277         self._init_builder()
278 
279     def _init_i18n(self) -> None:
280         """Load translated strings from the configured localedirs if enabled in
281         the configuration.
282         """
283         if self.config.language is None:
284             self.translator, has_translation = locale.init([], None)
285         else:
286             logger.info(bold(__('loading translations [%s]... ') % self.config.language),
287                         nonl=True)
288 
289             # compile mo files if sphinx.po file in user locale directories are updated
290             repo = CatalogRepository(self.srcdir, self.config.locale_dirs,
291                                      self.config.language, self.config.source_encoding)
292             for catalog in repo.catalogs:
293                 if catalog.domain == 'sphinx' and catalog.is_outdated():
294                     catalog.write_mo(self.config.language)
295 
296             locale_dirs = [None, path.join(package_dir, 'locale')] + list(repo.locale_dirs)
297             self.translator, has_translation = locale.init(locale_dirs, self.config.language)
298             if has_translation or self.config.language == 'en':
299                 # "en" never needs to be translated
300                 logger.info(__('done'))
301             else:
302                 logger.info(__('not available for built-in messages'))
303 
304     def _init_env(self, freshenv: bool) -> None:
305         filename = path.join(self.doctreedir, ENV_PICKLE_FILENAME)
306         if freshenv or not os.path.exists(filename):
307             self.env = BuildEnvironment()
308             self.env.setup(self)
309             self.env.find_files(self.config, self.builder)
310         else:
311             try:
312                 with progress_message(__('loading pickled environment')):
313                     with open(filename, 'rb') as f:
314                         self.env = pickle.load(f)
315                         self.env.setup(self)
316             except Exception as err:
317                 logger.info(__('failed: %s'), err)
318                 self._init_env(freshenv=True)
319 
320     def preload_builder(self, name: str) -> None:
321         self.registry.preload_builder(self, name)
322 
323     def create_builder(self, name: str) -> "Builder":
324         if name is None:
325             logger.info(__('No builder selected, using default: html'))
326             name = 'html'
327 
328         return self.registry.create_builder(self, name)
329 
330     def _init_builder(self) -> None:
331         self.builder.set_environment(self.env)
332         self.builder.init()
333         self.events.emit('builder-inited')
334 
335     # ---- main "build" method -------------------------------------------------
336 
337     def build(self, force_all: bool = False, filenames: List[str] = None) -> None:
338         self.phase = BuildPhase.READING
339         try:
340             if force_all:
341                 self.builder.compile_all_catalogs()
342                 self.builder.build_all()
343             elif filenames:
344                 self.builder.compile_specific_catalogs(filenames)
345                 self.builder.build_specific(filenames)
346             else:
347                 self.builder.compile_update_catalogs()
348                 self.builder.build_update()
349 
350             if self._warncount and self.keep_going:
351                 self.statuscode = 1
352 
353             status = (__('succeeded') if self.statuscode == 0
354                       else __('finished with problems'))
355             if self._warncount:
356                 if self.warningiserror:
357                     if self._warncount == 1:
358                         msg = __('build %s, %s warning (with warnings treated as errors).')
359                     else:
360                         msg = __('build %s, %s warnings (with warnings treated as errors).')
361                 else:
362                     if self._warncount == 1:
363                         msg = __('build %s, %s warning.')
364                     else:
365                         msg = __('build %s, %s warnings.')
366 
367                 logger.info(bold(msg % (status, self._warncount)))
368             else:
369                 logger.info(bold(__('build %s.') % status))
370 
371             if self.statuscode == 0 and self.builder.epilog:
372                 logger.info('')
373                 logger.info(self.builder.epilog % {
374                     'outdir': relpath(self.outdir),
375                     'project': self.config.project
376                 })
377         except Exception as err:
378             # delete the saved env to force a fresh build next time
379             envfile = path.join(self.doctreedir, ENV_PICKLE_FILENAME)
380             if path.isfile(envfile):
381                 os.unlink(envfile)
382             self.events.emit('build-finished', err)
383             raise
384         else:
385             self.events.emit('build-finished', None)
386         self.builder.cleanup()
387 
388     # ---- general extensibility interface -------------------------------------
389 
390     def setup_extension(self, extname: str) -> None:
391         """Import and setup a Sphinx extension module.
392 
393         Load the extension given by the module *name*.  Use this if your
394         extension needs the features provided by another extension.  No-op if
395         called twice.
396         """
397         logger.debug('[app] setting up extension: %r', extname)
398         self.registry.load_extension(self, extname)
399 
400     def require_sphinx(self, version: str) -> None:
401         """Check the Sphinx version if requested.
402 
403         Compare *version* (which must be a ``major.minor`` version string, e.g.
404         ``'1.1'``) with the version of the running Sphinx, and abort the build
405         when it is too old.
406 
407         .. versionadded:: 1.0
408         """
409         if version > sphinx.__display_version__[:3]:
410             raise VersionRequirementError(version)
411 
412     # event interface
413     def connect(self, event: str, callback: Callable, priority: int = 500) -> int:
414         """Register *callback* to be called when *event* is emitted.
415 
416         For details on available core events and the arguments of callback
417         functions, please see :ref:`events`.
418 
419         Registered callbacks will be invoked on event in the order of *priority* and
420         registration.  The priority is ascending order.
421 
422         The method returns a "listener ID" that can be used as an argument to
423         :meth:`disconnect`.
424 
425         .. versionchanged:: 3.0
426 
427            Support *priority*
428         """
429         listener_id = self.events.connect(event, callback, priority)
430         logger.debug('[app] connecting event %r (%d): %r [id=%s]',
431                      event, priority, callback, listener_id)
432         return listener_id
433 
434     def disconnect(self, listener_id: int) -> None:
435         """Unregister callback by *listener_id*."""
436         logger.debug('[app] disconnecting event: [id=%s]', listener_id)
437         self.events.disconnect(listener_id)
438 
439     def emit(self, event: str, *args: Any,
440              allowed_exceptions: Tuple["Type[Exception]", ...] = ()) -> List:
441         """Emit *event* and pass *arguments* to the callback functions.
442 
443         Return the return values of all callbacks as a list.  Do not emit core
444         Sphinx events in extensions!
445 
446         .. versionchanged:: 3.1
447 
448            Added *allowed_exceptions* to specify path-through exceptions
449         """
450         return self.events.emit(event, *args, allowed_exceptions=allowed_exceptions)
451 
452     def emit_firstresult(self, event: str, *args: Any,
453                          allowed_exceptions: Tuple["Type[Exception]", ...] = ()) -> Any:
454         """Emit *event* and pass *arguments* to the callback functions.
455 
456         Return the result of the first callback that doesn't return ``None``.
457 
458         .. versionadded:: 0.5
459         .. versionchanged:: 3.1
460 
461            Added *allowed_exceptions* to specify path-through exceptions
462         """
463         return self.events.emit_firstresult(event, *args,
464                                             allowed_exceptions=allowed_exceptions)
465 
466     # registering addon parts
467 
468     def add_builder(self, builder: "Type[Builder]", override: bool = False) -> None:
469         """Register a new builder.
470 
471         *builder* must be a class that inherits from
472         :class:`~sphinx.builders.Builder`.
473 
474         .. versionchanged:: 1.8
475            Add *override* keyword.
476         """
477         self.registry.add_builder(builder, override=override)
478 
479     # TODO(stephenfin): Describe 'types' parameter
480     def add_config_value(self, name: str, default: Any, rebuild: Union[bool, str],
481                          types: Any = ()) -> None:
482         """Register a configuration value.
483 
484         This is necessary for Sphinx to recognize new values and set default
485         values accordingly.  The *name* should be prefixed with the extension
486         name, to avoid clashes.  The *default* value can be any Python object.
487         The string value *rebuild* must be one of those values:
488 
489         * ``'env'`` if a change in the setting only takes effect when a
490           document is parsed -- this means that the whole environment must be
491           rebuilt.
492         * ``'html'`` if a change in the setting needs a full rebuild of HTML
493           documents.
494         * ``''`` if a change in the setting will not need any special rebuild.
495 
496         .. versionchanged:: 0.6
497            Changed *rebuild* from a simple boolean (equivalent to ``''`` or
498            ``'env'``) to a string.  However, booleans are still accepted and
499            converted internally.
500 
501         .. versionchanged:: 0.4
502            If the *default* value is a callable, it will be called with the
503            config object as its argument in order to get the default value.
504            This can be used to implement config values whose default depends on
505            other values.
506         """
507         logger.debug('[app] adding config value: %r',
508                      (name, default, rebuild) + ((types,) if types else ()))
509         if rebuild in (False, True):
510             rebuild = 'env' if rebuild else ''
511         self.config.add(name, default, rebuild, types)
512 
513     def add_event(self, name: str) -> None:
514         """Register an event called *name*.
515 
516         This is needed to be able to emit it.
517         """
518         logger.debug('[app] adding event: %r', name)
519         self.events.add(name)
520 
521     def set_translator(self, name: str, translator_class: "Type[nodes.NodeVisitor]",
522                        override: bool = False) -> None:
523         """Register or override a Docutils translator class.
524 
525         This is used to register a custom output translator or to replace a
526         builtin translator.  This allows extensions to use custom translator
527         and define custom nodes for the translator (see :meth:`add_node`).
528 
529         .. versionadded:: 1.3
530         .. versionchanged:: 1.8
531            Add *override* keyword.
532         """
533         self.registry.add_translator(name, translator_class, override=override)
534 
535     def add_node(self, node: "Type[Element]", override: bool = False,
536                  **kwargs: Tuple[Callable, Callable]) -> None:
537         """Register a Docutils node class.
538 
539         This is necessary for Docutils internals.  It may also be used in the
540         future to validate nodes in the parsed documents.
541 
542         Node visitor functions for the Sphinx HTML, LaTeX, text and manpage
543         writers can be given as keyword arguments: the keyword should be one or
544         more of ``'html'``, ``'latex'``, ``'text'``, ``'man'``, ``'texinfo'``
545         or any other supported translators, the value a 2-tuple of ``(visit,
546         depart)`` methods.  ``depart`` can be ``None`` if the ``visit``
547         function raises :exc:`docutils.nodes.SkipNode`.  Example:
548 
549         .. code-block:: python
550 
551            class math(docutils.nodes.Element): pass
552 
553            def visit_math_html(self, node):
554                self.body.append(self.starttag(node, 'math'))
555            def depart_math_html(self, node):
556                self.body.append('</math>')
557 
558            app.add_node(math, html=(visit_math_html, depart_math_html))
559 
560         Obviously, translators for which you don't specify visitor methods will
561         choke on the node when encountered in a document to translate.
562 
563         .. versionchanged:: 0.5
564            Added the support for keyword arguments giving visit functions.
565         """
566         logger.debug('[app] adding node: %r', (node, kwargs))
567         if not override and docutils.is_node_registered(node):
568             logger.warning(__('node class %r is already registered, '
569                               'its visitors will be overridden'),
570                            node.__name__, type='app', subtype='add_node')
571         docutils.register_node(node)
572         self.registry.add_translation_handlers(node, **kwargs)
573 
574     def add_enumerable_node(self, node: "Type[Element]", figtype: str,
575                             title_getter: TitleGetter = None, override: bool = False,
576                             **kwargs: Tuple[Callable, Callable]) -> None:
577         """Register a Docutils node class as a numfig target.
578 
579         Sphinx numbers the node automatically. And then the users can refer it
580         using :rst:role:`numref`.
581 
582         *figtype* is a type of enumerable nodes.  Each figtypes have individual
583         numbering sequences.  As a system figtypes, ``figure``, ``table`` and
584         ``code-block`` are defined.  It is able to add custom nodes to these
585         default figtypes.  It is also able to define new custom figtype if new
586         figtype is given.
587 
588         *title_getter* is a getter function to obtain the title of node.  It
589         takes an instance of the enumerable node, and it must return its title
590         as string.  The title is used to the default title of references for
591         :rst:role:`ref`.  By default, Sphinx searches
592         ``docutils.nodes.caption`` or ``docutils.nodes.title`` from the node as
593         a title.
594 
595         Other keyword arguments are used for node visitor functions. See the
596         :meth:`.Sphinx.add_node` for details.
597 
598         .. versionadded:: 1.4
599         """
600         self.registry.add_enumerable_node(node, figtype, title_getter, override=override)
601         self.add_node(node, override=override, **kwargs)
602 
603     def add_directive(self, name: str, cls: "Type[Directive]", override: bool = False) -> None:
604         """Register a Docutils directive.
605 
606         *name* must be the prospective directive name.  *cls* is a directive
607         class which inherits ``docutils.parsers.rst.Directive``.  For more
608         details, see `the Docutils docs
609         <http://docutils.sourceforge.net/docs/howto/rst-directives.html>`_ .
610 
611         For example, the (already existing) :rst:dir:`literalinclude` directive
612         would be added like this:
613 
614         .. code-block:: python
615 
616            from docutils.parsers.rst import Directive, directives
617 
618            class LiteralIncludeDirective(Directive):
619                has_content = True
620                required_arguments = 1
621                optional_arguments = 0
622                final_argument_whitespace = True
623                option_spec = {
624                    'class': directives.class_option,
625                    'name': directives.unchanged,
626                }
627 
628                def run(self):
629                    ...
630 
631            add_directive('literalinclude', LiteralIncludeDirective)
632 
633         .. versionchanged:: 0.6
634            Docutils 0.5-style directive classes are now supported.
635         .. deprecated:: 1.8
636            Docutils 0.4-style (function based) directives support is deprecated.
637         .. versionchanged:: 1.8
638            Add *override* keyword.
639         """
640         logger.debug('[app] adding directive: %r', (name, cls))
641         if not override and docutils.is_directive_registered(name):
642             logger.warning(__('directive %r is already registered, it will be overridden'),
643                            name, type='app', subtype='add_directive')
644 
645         docutils.register_directive(name, cls)
646 
647     def add_role(self, name: str, role: Any, override: bool = False) -> None:
648         """Register a Docutils role.
649 
650         *name* must be the role name that occurs in the source, *role* the role
651         function. Refer to the `Docutils documentation
652         <http://docutils.sourceforge.net/docs/howto/rst-roles.html>`_ for
653         more information.
654 
655         .. versionchanged:: 1.8
656            Add *override* keyword.
657         """
658         logger.debug('[app] adding role: %r', (name, role))
659         if not override and docutils.is_role_registered(name):
660             logger.warning(__('role %r is already registered, it will be overridden'),
661                            name, type='app', subtype='add_role')
662         docutils.register_role(name, role)
663 
664     def add_generic_role(self, name: str, nodeclass: Any, override: bool = False) -> None:
665         """Register a generic Docutils role.
666 
667         Register a Docutils role that does nothing but wrap its contents in the
668         node given by *nodeclass*.
669 
670         .. versionadded:: 0.6
671         .. versionchanged:: 1.8
672            Add *override* keyword.
673         """
674         # Don't use ``roles.register_generic_role`` because it uses
675         # ``register_canonical_role``.
676         logger.debug('[app] adding generic role: %r', (name, nodeclass))
677         if not override and docutils.is_role_registered(name):
678             logger.warning(__('role %r is already registered, it will be overridden'),
679                            name, type='app', subtype='add_generic_role')
680         role = roles.GenericRole(name, nodeclass)
681         docutils.register_role(name, role)
682 
683     def add_domain(self, domain: "Type[Domain]", override: bool = False) -> None:
684         """Register a domain.
685 
686         Make the given *domain* (which must be a class; more precisely, a
687         subclass of :class:`~sphinx.domains.Domain`) known to Sphinx.
688 
689         .. versionadded:: 1.0
690         .. versionchanged:: 1.8
691            Add *override* keyword.
692         """
693         self.registry.add_domain(domain, override=override)
694 
695     def add_directive_to_domain(self, domain: str, name: str,
696                                 cls: "Type[Directive]", override: bool = False) -> None:
697         """Register a Docutils directive in a domain.
698 
699         Like :meth:`add_directive`, but the directive is added to the domain
700         named *domain*.
701 
702         .. versionadded:: 1.0
703         .. versionchanged:: 1.8
704            Add *override* keyword.
705         """
706         self.registry.add_directive_to_domain(domain, name, cls, override=override)
707 
708     def add_role_to_domain(self, domain: str, name: str, role: Union[RoleFunction, XRefRole],
709                            override: bool = False) -> None:
710         """Register a Docutils role in a domain.
711 
712         Like :meth:`add_role`, but the role is added to the domain named
713         *domain*.
714 
715         .. versionadded:: 1.0
716         .. versionchanged:: 1.8
717            Add *override* keyword.
718         """
719         self.registry.add_role_to_domain(domain, name, role, override=override)
720 
721     def add_index_to_domain(self, domain: str, index: "Type[Index]", override: bool = False
722                             ) -> None:
723         """Register a custom index for a domain.
724 
725         Add a custom *index* class to the domain named *domain*.  *index* must
726         be a subclass of :class:`~sphinx.domains.Index`.
727 
728         .. versionadded:: 1.0
729         .. versionchanged:: 1.8
730            Add *override* keyword.
731         """
732         self.registry.add_index_to_domain(domain, index)
733 
734     def add_object_type(self, directivename: str, rolename: str, indextemplate: str = '',
735                         parse_node: Callable = None, ref_nodeclass: "Type[TextElement]" = None,
736                         objname: str = '', doc_field_types: List = [], override: bool = False
737                         ) -> None:
738         """Register a new object type.
739 
740         This method is a very convenient way to add a new :term:`object` type
741         that can be cross-referenced.  It will do this:
742 
743         - Create a new directive (called *directivename*) for documenting an
744           object.  It will automatically add index entries if *indextemplate*
745           is nonempty; if given, it must contain exactly one instance of
746           ``%s``.  See the example below for how the template will be
747           interpreted.
748         - Create a new role (called *rolename*) to cross-reference to these
749           object descriptions.
750         - If you provide *parse_node*, it must be a function that takes a
751           string and a docutils node, and it must populate the node with
752           children parsed from the string.  It must then return the name of the
753           item to be used in cross-referencing and index entries.  See the
754           :file:`conf.py` file in the source for this documentation for an
755           example.
756         - The *objname* (if not given, will default to *directivename*) names
757           the type of object.  It is used when listing objects, e.g. in search
758           results.
759 
760         For example, if you have this call in a custom Sphinx extension::
761 
762            app.add_object_type('directive', 'dir', 'pair: %s; directive')
763 
764         you can use this markup in your documents::
765 
766            .. rst:directive:: function
767 
768               Document a function.
769 
770            <...>
771 
772            See also the :rst:dir:`function` directive.
773 
774         For the directive, an index entry will be generated as if you had prepended ::
775 
776            .. index:: pair: function; directive
777 
778         The reference node will be of class ``literal`` (so it will be rendered
779         in a proportional font, as appropriate for code) unless you give the
780         *ref_nodeclass* argument, which must be a docutils node class.  Most
781         useful are ``docutils.nodes.emphasis`` or ``docutils.nodes.strong`` --
782         you can also use ``docutils.nodes.generated`` if you want no further
783         text decoration.  If the text should be treated as literal (e.g. no
784         smart quote replacement), but not have typewriter styling, use
785         ``sphinx.addnodes.literal_emphasis`` or
786         ``sphinx.addnodes.literal_strong``.
787 
788         For the role content, you have the same syntactical possibilities as
789         for standard Sphinx roles (see :ref:`xref-syntax`).
790 
791         .. versionchanged:: 1.8
792            Add *override* keyword.
793         """
794         self.registry.add_object_type(directivename, rolename, indextemplate, parse_node,
795                                       ref_nodeclass, objname, doc_field_types,
796                                       override=override)
797 
798     def add_crossref_type(self, directivename: str, rolename: str, indextemplate: str = '',
799                           ref_nodeclass: "Type[TextElement]" = None, objname: str = '',
800                           override: bool = False) -> None:
801         """Register a new crossref object type.
802 
803         This method is very similar to :meth:`add_object_type` except that the
804         directive it generates must be empty, and will produce no output.
805 
806         That means that you can add semantic targets to your sources, and refer
807         to them using custom roles instead of generic ones (like
808         :rst:role:`ref`).  Example call::
809 
810            app.add_crossref_type('topic', 'topic', 'single: %s',
811                                  docutils.nodes.emphasis)
812 
813         Example usage::
814 
815            .. topic:: application API
816 
817            The application API
818            -------------------
819 
820            Some random text here.
821 
822            See also :topic:`this section <application API>`.
823 
824         (Of course, the element following the ``topic`` directive needn't be a
825         section.)
826 
827         .. versionchanged:: 1.8
828            Add *override* keyword.
829         """
830         self.registry.add_crossref_type(directivename, rolename,
831                                         indextemplate, ref_nodeclass, objname,
832                                         override=override)
833 
834     def add_transform(self, transform: "Type[Transform]") -> None:
835         """Register a Docutils transform to be applied after parsing.
836 
837         Add the standard docutils :class:`Transform` subclass *transform* to
838         the list of transforms that are applied after Sphinx parses a reST
839         document.
840 
841         .. list-table:: priority range categories for Sphinx transforms
842            :widths: 20,80
843 
844            * - Priority
845              - Main purpose in Sphinx
846            * - 0-99
847              - Fix invalid nodes by docutils. Translate a doctree.
848            * - 100-299
849              - Preparation
850            * - 300-399
851              - early
852            * - 400-699
853              - main
854            * - 700-799
855              - Post processing. Deadline to modify text and referencing.
856            * - 800-899
857              - Collect referencing and referenced nodes. Domain processing.
858            * - 900-999
859              - Finalize and clean up.
860 
861         refs: `Transform Priority Range Categories`__
862 
863         __ http://docutils.sourceforge.net/docs/ref/transforms.html#transform-priority-range-categories
864         """  # NOQA
865         self.registry.add_transform(transform)
866 
867     def add_post_transform(self, transform: "Type[Transform]") -> None:
868         """Register a Docutils transform to be applied before writing.
869 
870         Add the standard docutils :class:`Transform` subclass *transform* to
871         the list of transforms that are applied before Sphinx writes a
872         document.
873         """
874         self.registry.add_post_transform(transform)
875 
876     def add_javascript(self, filename: str, **kwargs: str) -> None:
877         """An alias of :meth:`add_js_file`."""
878         warnings.warn('The app.add_javascript() is deprecated. '
879                       'Please use app.add_js_file() instead.',
880                       RemovedInSphinx40Warning, stacklevel=2)
881         self.add_js_file(filename, **kwargs)
882 
883     def add_js_file(self, filename: str, **kwargs: str) -> None:
884         """Register a JavaScript file to include in the HTML output.
885 
886         Add *filename* to the list of JavaScript files that the default HTML
887         template will include.  The filename must be relative to the HTML
888         static path , or a full URI with scheme.  If the keyword argument
889         ``body`` is given, its value will be added between the
890         ``<script>`` tags. Extra keyword arguments are included as
891         attributes of the ``<script>`` tag.
892 
893         Example::
894 
895             app.add_js_file('example.js')
896             # => <script src="_static/example.js"></script>
897 
898             app.add_js_file('example.js', async="async")
899             # => <script src="_static/example.js" async="async"></script>
900 
901             app.add_js_file(None, body="var myVariable = 'foo';")
902             # => <script>var myVariable = 'foo';</script>
903 
904         .. versionadded:: 0.5
905 
906         .. versionchanged:: 1.8
907            Renamed from ``app.add_javascript()``.
908            And it allows keyword arguments as attributes of script tag.
909         """
910         self.registry.add_js_file(filename, **kwargs)
911         if hasattr(self.builder, 'add_js_file'):
912             self.builder.add_js_file(filename, **kwargs)  # type: ignore
913 
914     def add_css_file(self, filename: str, **kwargs: str) -> None:
915         """Register a stylesheet to include in the HTML output.
916 
917         Add *filename* to the list of CSS files that the default HTML template
918         will include.  The filename must be relative to the HTML static path,
919         or a full URI with scheme.  The keyword arguments are also accepted for
920         attributes of ``<link>`` tag.
921 
922         Example::
923 
924             app.add_css_file('custom.css')
925             # => <link rel="stylesheet" href="_static/custom.css" type="text/css" />
926 
927             app.add_css_file('print.css', media='print')
928             # => <link rel="stylesheet" href="_static/print.css"
929             #          type="text/css" media="print" />
930 
931             app.add_css_file('fancy.css', rel='alternate stylesheet', title='fancy')
932             # => <link rel="alternate stylesheet" href="_static/fancy.css"
933             #          type="text/css" title="fancy" />
934 
935         .. versionadded:: 1.0
936 
937         .. versionchanged:: 1.6
938            Optional ``alternate`` and/or ``title`` attributes can be supplied
939            with the *alternate* (of boolean type) and *title* (a string)
940            arguments. The default is no title and *alternate* = ``False``. For
941            more information, refer to the `documentation
942            <https://mdn.io/Web/CSS/Alternative_style_sheets>`__.
943 
944         .. versionchanged:: 1.8
945            Renamed from ``app.add_stylesheet()``.
946            And it allows keyword arguments as attributes of link tag.
947         """
948         logger.debug('[app] adding stylesheet: %r', filename)
949         self.registry.add_css_files(filename, **kwargs)
950         if hasattr(self.builder, 'add_css_file'):
951             self.builder.add_css_file(filename, **kwargs)  # type: ignore
952 
953     def add_stylesheet(self, filename: str, alternate: bool = False, title: str = None
954                        ) -> None:
955         """An alias of :meth:`add_css_file`."""
956         warnings.warn('The app.add_stylesheet() is deprecated. '
957                       'Please use app.add_css_file() instead.',
958                       RemovedInSphinx40Warning, stacklevel=2)
959 
960         attributes = {}  # type: Dict[str, str]
961         if alternate:
962             attributes['rel'] = 'alternate stylesheet'
963         else:
964             attributes['rel'] = 'stylesheet'
965 
966         if title:
967             attributes['title'] = title
968 
969         self.add_css_file(filename, **attributes)
970 
971     def add_latex_package(self, packagename: str, options: str = None,
972                           after_hyperref: bool = False) -> None:
973         r"""Register a package to include in the LaTeX source code.
974 
975         Add *packagename* to the list of packages that LaTeX source code will
976         include.  If you provide *options*, it will be taken to `\usepackage`
977         declaration.  If you set *after_hyperref* truthy, the package will be
978         loaded after ``hyperref`` package.
979 
980         .. code-block:: python
981 
982            app.add_latex_package('mypackage')
983            # => \usepackage{mypackage}
984            app.add_latex_package('mypackage', 'foo,bar')
985            # => \usepackage[foo,bar]{mypackage}
986 
987         .. versionadded:: 1.3
988         .. versionadded:: 3.1
989 
990            *after_hyperref* option.
991         """
992         self.registry.add_latex_package(packagename, options, after_hyperref)
993 
994     def add_lexer(self, alias: str, lexer: Union[Lexer, "Type[Lexer]"]) -> None:
995         """Register a new lexer for source code.
996 
997         Use *lexer* to highlight code blocks with the given language *alias*.
998 
999         .. versionadded:: 0.6
1000         .. versionchanged:: 2.1
1001            Take a lexer class as an argument.  An instance of lexers are
1002            still supported until Sphinx-3.x.
1003         """
1004         logger.debug('[app] adding lexer: %r', (alias, lexer))
1005         if isinstance(lexer, Lexer):
1006             warnings.warn('app.add_lexer() API changed; '
1007                           'Please give lexer class instead instance',
1008                           RemovedInSphinx40Warning, stacklevel=2)
1009             lexers[alias] = lexer
1010         else:
1011             lexer_classes[alias] = lexer
1012 
1013     def add_autodocumenter(self, cls: Any, override: bool = False) -> None:
1014         """Register a new documenter class for the autodoc extension.
1015 
1016         Add *cls* as a new documenter class for the :mod:`sphinx.ext.autodoc`
1017         extension.  It must be a subclass of
1018         :class:`sphinx.ext.autodoc.Documenter`.  This allows to auto-document
1019         new types of objects.  See the source of the autodoc module for
1020         examples on how to subclass :class:`Documenter`.
1021 
1022         .. todo:: Add real docs for Documenter and subclassing
1023 
1024         .. versionadded:: 0.6
1025         .. versionchanged:: 2.2
1026            Add *override* keyword.
1027         """
1028         logger.debug('[app] adding autodocumenter: %r', cls)
1029         from sphinx.ext.autodoc.directive import AutodocDirective
1030         self.registry.add_documenter(cls.objtype, cls)
1031         self.add_directive('auto' + cls.objtype, AutodocDirective, override=override)
1032 
1033     def add_autodoc_attrgetter(self, typ: "Type", getter: Callable[[Any, str, Any], Any]
1034                                ) -> None:
1035         """Register a new ``getattr``-like function for the autodoc extension.
1036 
1037         Add *getter*, which must be a function with an interface compatible to
1038         the :func:`getattr` builtin, as the autodoc attribute getter for
1039         objects that are instances of *typ*.  All cases where autodoc needs to
1040         get an attribute of a type are then handled by this function instead of
1041         :func:`getattr`.
1042 
1043         .. versionadded:: 0.6
1044         """
1045         logger.debug('[app] adding autodoc attrgetter: %r', (typ, getter))
1046         self.registry.add_autodoc_attrgetter(typ, getter)
1047 
1048     def add_search_language(self, cls: Any) -> None:
1049         """Register a new language for the HTML search index.
1050 
1051         Add *cls*, which must be a subclass of
1052         :class:`sphinx.search.SearchLanguage`, as a support language for
1053         building the HTML full-text search index.  The class must have a *lang*
1054         attribute that indicates the language it should be used for.  See
1055         :confval:`html_search_language`.
1056 
1057         .. versionadded:: 1.1
1058         """
1059         logger.debug('[app] adding search language: %r', cls)
1060         from sphinx.search import languages, SearchLanguage
1061         assert issubclass(cls, SearchLanguage)
1062         languages[cls.lang] = cls
1063 
1064     def add_source_suffix(self, suffix: str, filetype: str, override: bool = False) -> None:
1065         """Register a suffix of source files.
1066 
1067         Same as :confval:`source_suffix`.  The users can override this
1068         using the setting.
1069 
1070         .. versionadded:: 1.8
1071         """
1072         self.registry.add_source_suffix(suffix, filetype, override=override)
1073 
1074     def add_source_parser(self, *args: Any, **kwargs: Any) -> None:
1075         """Register a parser class.
1076 
1077         .. versionadded:: 1.4
1078         .. versionchanged:: 1.8
1079            *suffix* argument is deprecated.  It only accepts *parser* argument.
1080            Use :meth:`add_source_suffix` API to register suffix instead.
1081         .. versionchanged:: 1.8
1082            Add *override* keyword.
1083         """
1084         self.registry.add_source_parser(*args, **kwargs)
1085 
1086     def add_env_collector(self, collector: "Type[EnvironmentCollector]") -> None:
1087         """Register an environment collector class.
1088 
1089         Refer to :ref:`collector-api`.
1090 
1091         .. versionadded:: 1.6
1092         """
1093         logger.debug('[app] adding environment collector: %r', collector)
1094         collector().enable(self)
1095 
1096     def add_html_theme(self, name: str, theme_path: str) -> None:
1097         """Register a HTML Theme.
1098 
1099         The *name* is a name of theme, and *path* is a full path to the theme
1100         (refs: :ref:`distribute-your-theme`).
1101 
1102         .. versionadded:: 1.6
1103         """
1104         logger.debug('[app] adding HTML theme: %r, %r', name, theme_path)
1105         self.html_themes[name] = theme_path
1106 
1107     def add_html_math_renderer(self, name: str,
1108                                inline_renderers: Tuple[Callable, Callable] = None,
1109                                block_renderers: Tuple[Callable, Callable] = None) -> None:
1110         """Register a math renderer for HTML.
1111 
1112         The *name* is a name of math renderer.  Both *inline_renderers* and
1113         *block_renderers* are used as visitor functions for the HTML writer:
1114         the former for inline math node (``nodes.math``), the latter for
1115         block math node (``nodes.math_block``).  Regarding visitor functions,
1116         see :meth:`add_node` for details.
1117 
1118         .. versionadded:: 1.8
1119 
1120         """
1121         self.registry.add_html_math_renderer(name, inline_renderers, block_renderers)
1122 
1123     def add_message_catalog(self, catalog: str, locale_dir: str) -> None:
1124         """Register a message catalog.
1125 
1126         The *catalog* is a name of catalog, and *locale_dir* is a base path
1127         of message catalog.  For more details, see
1128         :func:`sphinx.locale.get_translation()`.
1129 
1130         .. versionadded:: 1.8
1131         """
1132         locale.init([locale_dir], self.config.language, catalog)
1133         locale.init_console(locale_dir, catalog)
1134 
1135     # ---- other methods -------------------------------------------------
1136     def is_parallel_allowed(self, typ: str) -> bool:
1137         """Check parallel processing is allowed or not.
1138 
1139         ``typ`` is a type of processing; ``'read'`` or ``'write'``.
1140         """
1141         if typ == 'read':
1142             attrname = 'parallel_read_safe'
1143             message_not_declared = __("the %s extension does not declare if it "
1144                                       "is safe for parallel reading, assuming "
1145                                       "it isn't - please ask the extension author "
1146                                       "to check and make it explicit")
1147             message_not_safe = __("the %s extension is not safe for parallel reading")
1148         elif typ == 'write':
1149             attrname = 'parallel_write_safe'
1150             message_not_declared = __("the %s extension does not declare if it "
1151                                       "is safe for parallel writing, assuming "
1152                                       "it isn't - please ask the extension author "
1153                                       "to check and make it explicit")
1154             message_not_safe = __("the %s extension is not safe for parallel writing")
1155         else:
1156             raise ValueError('parallel type %s is not supported' % typ)
1157 
1158         for ext in self.extensions.values():
1159             allowed = getattr(ext, attrname, None)
1160             if allowed is None:
1161                 logger.warning(message_not_declared, ext.name)
1162                 logger.warning(__('doing serial %s'), typ)
1163                 return False
1164             elif not allowed:
1165                 logger.warning(message_not_safe, ext.name)
1166                 logger.warning(__('doing serial %s'), typ)
1167                 return False
1168 
1169         return True
1170 
1171 
1172 class TemplateBridge:
1173     """
1174     This class defines the interface for a "template bridge", that is, a class
1175     that renders templates given a template name and a context.
1176     """
1177 
1178     def init(self, builder: "Builder", theme: Theme = None, dirs: List[str] = None) -> None:
1179         """Called by the builder to initialize the template system.
1180 
1181         *builder* is the builder object; you'll probably want to look at the
1182         value of ``builder.config.templates_path``.
1183 
1184         *theme* is a :class:`sphinx.theming.Theme` object or None; in the latter
1185         case, *dirs* can be list of fixed directories to look for templates.
1186         """
1187         raise NotImplementedError('must be implemented in subclasses')
1188 
1189     def newest_template_mtime(self) -> float:
1190         """Called by the builder to determine if output files are outdated
1191         because of template changes.  Return the mtime of the newest template
1192         file that was changed.  The default implementation returns ``0``.
1193         """
1194         return 0
1195 
1196     def render(self, template: str, context: Dict) -> None:
1197         """Called by the builder to render a template given as a filename with
1198         a specified context (a Python dictionary).
1199         """
1200         raise NotImplementedError('must be implemented in subclasses')
1201 
1202     def render_string(self, template: str, context: Dict) -> str:
1203         """Called by the builder to render a template given as a string with a
1204         specified context (a Python dictionary).
1205         """
1206         raise NotImplementedError('must be implemented in subclasses')

</code><intended_behavior>In a file or class responsible for translating index entries into HTML elements, ensure that the logic recognizing and creating sections for 'Symbols' is capable of identifying and consolidating all symbol entries into one section. This might involve adjusting how sections are defined and anchored in the HTML document to prevent duplication. For instance, a method responsible for generating section headers or anchors for the HTML output needs validation to ensure that symbols are not creating additional unintended sections. This validation might include a pre-check on index categories to ensure uniqueness and consolidation of symbol entries, or a post-processing step to merge sections that are erroneously divided.</intended_behavior>]
2025-10-18 18:22:12.962 | INFO     | Search completed. Bug locations: [<file>sphinx/environment/adapters/indexentries.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2     sphinx.environment.adapters.indexentries
3     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
4 
5     Index entries adapters for sphinx.environment.
6 
7     :copyright: Copyright 2007-2020 by the Sphinx team, see AUTHORS.
8     :license: BSD, see LICENSE for details.
9 """
10 
11 import re
12 import unicodedata
13 from itertools import groupby
14 from typing import Any, Dict, Pattern, List, Tuple
15 from typing import cast
16 
17 from sphinx.builders import Builder
18 from sphinx.domains.index import IndexDomain
19 from sphinx.environment import BuildEnvironment
20 from sphinx.errors import NoUri
21 from sphinx.locale import _, __
22 from sphinx.util import split_into, logging
23 
24 
25 logger = logging.getLogger(__name__)
26 
27 
28 class IndexEntries:
29     def __init__(self, env: BuildEnvironment) -> None:
30         self.env = env
31 
32     def create_index(self, builder: Builder, group_entries: bool = True,
33                      _fixre: Pattern = re.compile(r'(.*) ([(][^()]*[)])')
34                      ) -> List[Tuple[str, List[Tuple[str, Any]]]]:
35         """Create the real index from the collected index entries."""
36         new = {}  # type: Dict[str, List]
37 
38         def add_entry(word: str, subword: str, main: str, link: bool = True,
39                       dic: Dict = new, key: str = None) -> None:
40             # Force the word to be unicode if it's a ASCII bytestring.
41             # This will solve problems with unicode normalization later.
42             # For instance the RFC role will add bytestrings at the moment
43             word = str(word)
44             entry = dic.get(word)
45             if not entry:
46                 dic[word] = entry = [[], {}, key]
47             if subword:
48                 add_entry(subword, '', main, link=link, dic=entry[1], key=key)
49             elif link:
50                 try:
51                     uri = builder.get_relative_uri('genindex', fn) + '#' + tid
52                 except NoUri:
53                     pass
54                 else:
55                     entry[0].append((main, uri))
56 
57         domain = cast(IndexDomain, self.env.get_domain('index'))
58         for fn, entries in domain.entries.items():
59             # new entry types must be listed in directives/other.py!
60             for type, value, tid, main, index_key in entries:
61                 try:
62                     if type == 'single':
63                         try:
64                             entry, subentry = split_into(2, 'single', value)
65                         except ValueError:
66                             entry, = split_into(1, 'single', value)
67                             subentry = ''
68                         add_entry(entry, subentry, main, key=index_key)
69                     elif type == 'pair':
70                         first, second = split_into(2, 'pair', value)
71                         add_entry(first, second, main, key=index_key)
72                         add_entry(second, first, main, key=index_key)
73                     elif type == 'triple':
74                         first, second, third = split_into(3, 'triple', value)
75                         add_entry(first, second + ' ' + third, main, key=index_key)
76                         add_entry(second, third + ', ' + first, main, key=index_key)
77                         add_entry(third, first + ' ' + second, main, key=index_key)
78                     elif type == 'see':
79                         first, second = split_into(2, 'see', value)
80                         add_entry(first, _('see %s') % second, None,
81                                   link=False, key=index_key)
82                     elif type == 'seealso':
83                         first, second = split_into(2, 'see', value)
84                         add_entry(first, _('see also %s') % second, None,
85                                   link=False, key=index_key)
86                     else:
87                         logger.warning(__('unknown index entry type %r'), type, location=fn)
88                 except ValueError as err:
89                     logger.warning(str(err), location=fn)
90 
91         # sort the index entries for same keyword.
92         def keyfunc0(entry: Tuple[str, str]) -> Tuple[bool, str]:
93             main, uri = entry
94             return (not main, uri)  # show main entries at first
95 
96         for indexentry in new.values():
97             indexentry[0].sort(key=keyfunc0)
98             for subentry in indexentry[1].values():
99                 subentry[0].sort(key=keyfunc0)  # type: ignore
100 
101         # sort the index entries; put all symbols at the front, even those
102         # following the letters in ASCII, this is where the chr(127) comes from
103         def keyfunc(entry: Tuple[str, List]) -> Tuple[str, str]:
104             key, (void, void, category_key) = entry
105             if category_key:
106                 # using specified category key to sort
107                 key = category_key
108             lckey = unicodedata.normalize('NFD', key.lower())
109             if lckey.startswith('\N{RIGHT-TO-LEFT MARK}'):
110                 lckey = lckey[1:]
111             if lckey[0:1].isalpha() or lckey.startswith('_'):
112                 lckey = chr(127) + lckey
113             # ensure a determinstic order *within* letters by also sorting on
114             # the entry itself
115             return (lckey, entry[0])
116         newlist = sorted(new.items(), key=keyfunc)
117 
118         if group_entries:
119             # fixup entries: transform
120             #   func() (in module foo)
121             #   func() (in module bar)
122             # into
123             #   func()
124             #     (in module foo)
125             #     (in module bar)
126             oldkey = ''
127             oldsubitems = None  # type: Dict[str, List]
128             i = 0
129             while i < len(newlist):
130                 key, (targets, subitems, _key) = newlist[i]
131                 # cannot move if it has subitems; structure gets too complex
132                 if not subitems:
133                     m = _fixre.match(key)
134                     if m:
135                         if oldkey == m.group(1):
136                             # prefixes match: add entry as subitem of the
137                             # previous entry
138                             oldsubitems.setdefault(m.group(2), [[], {}, _key])[0].\
139                                 extend(targets)
140                             del newlist[i]
141                             continue
142                         oldkey = m.group(1)
143                     else:
144                         oldkey = key
145                 oldsubitems = subitems
146                 i += 1
147 
148         # sort the sub-index entries
149         def keyfunc2(entry: Tuple[str, List]) -> str:
150             key = unicodedata.normalize('NFD', entry[0].lower())
151             if key.startswith('\N{RIGHT-TO-LEFT MARK}'):
152                 key = key[1:]
153             if key[0:1].isalpha() or key.startswith('_'):
154                 key = chr(127) + key
155             return key
156 
157         # group the entries by letter
158         def keyfunc3(item: Tuple[str, List]) -> str:
159             # hack: mutating the subitems dicts to a list in the keyfunc
160             k, v = item
161             v[1] = sorted(((si, se) for (si, (se, void, void)) in v[1].items()),
162                           key=keyfunc2)
163             if v[2] is None:
164                 # now calculate the key
165                 if k.startswith('\N{RIGHT-TO-LEFT MARK}'):
166                     k = k[1:]
167                 letter = unicodedata.normalize('NFD', k[0])[0].upper()
168                 if letter.isalpha() or letter == '_':
169                     return letter
170                 else:
171                     # get all other symbols under one heading
172                     return _('Symbols')
173             else:
174                 return v[2]
175         return [(key_, list(group))
176                 for (key_, group) in groupby(newlist, keyfunc3)]

</code><intended_behavior>This file likely contains logic for sorting and categorizing index entries, which should be revised to aggregate entries containing special characters (@, £, ←) under a single “Symbols” category effectively. This will prevent the duplication of 'Symbols' sections in the HTML output. Specifically, any function within this file that handles the organization or categorization of symbols into sections should be updated to ensure all symbols are uniformly recognized and placed within the same category, regardless of their position in the Unicode table or their ASCII representation. This may involve enhancing the sorting logic to prioritize the grouping of all non-alphanumeric characters into a single index rather than segregating them based on their character value.</intended_behavior>, <file>sphinx/application.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2     sphinx.application
3     ~~~~~~~~~~~~~~~~~~
4 
5     Sphinx application class and extensibility interface.
6 
7     Gracefully adapted from the TextPress system by Armin.
8 
9     :copyright: Copyright 2007-2020 by the Sphinx team, see AUTHORS.
10     :license: BSD, see LICENSE for details.
11 """
12 
13 import os
14 import pickle
15 import platform
16 import sys
17 import warnings
18 from collections import deque
19 from io import StringIO
20 from os import path
21 from typing import Any, Callable, Dict, IO, List, Tuple, Union
22 
23 from docutils import nodes
24 from docutils.nodes import Element, TextElement
25 from docutils.parsers.rst import Directive, roles
26 from docutils.transforms import Transform
27 from pygments.lexer import Lexer
28 
29 import sphinx
30 from sphinx import package_dir, locale
31 from sphinx.config import Config
32 from sphinx.deprecation import RemovedInSphinx40Warning
33 from sphinx.domains import Domain, Index
34 from sphinx.environment import BuildEnvironment
35 from sphinx.environment.collectors import EnvironmentCollector
36 from sphinx.errors import ApplicationError, ConfigError, VersionRequirementError
37 from sphinx.events import EventManager
38 from sphinx.extension import Extension
39 from sphinx.highlighting import lexer_classes, lexers
40 from sphinx.locale import __
41 from sphinx.project import Project
42 from sphinx.registry import SphinxComponentRegistry
43 from sphinx.roles import XRefRole
44 from sphinx.theming import Theme
45 from sphinx.util import docutils
46 from sphinx.util import logging
47 from sphinx.util import progress_message
48 from sphinx.util.build_phase import BuildPhase
49 from sphinx.util.console import bold  # type: ignore
50 from sphinx.util.i18n import CatalogRepository
51 from sphinx.util.logging import prefixed_warnings
52 from sphinx.util.osutil import abspath, ensuredir, relpath
53 from sphinx.util.tags import Tags
54 from sphinx.util.typing import RoleFunction, TitleGetter
55 
56 if False:
57     # For type annotation
58     from docutils.nodes import Node  # NOQA
59     from typing import Type  # for python3.5.1
60     from sphinx.builders import Builder
61 
62 
63 builtin_extensions = (
64     'sphinx.addnodes',
65     'sphinx.builders.changes',
66     'sphinx.builders.epub3',
67     'sphinx.builders.dirhtml',
68     'sphinx.builders.dummy',
69     'sphinx.builders.gettext',
70     'sphinx.builders.html',
71     'sphinx.builders.latex',
72     'sphinx.builders.linkcheck',
73     'sphinx.builders.manpage',
74     'sphinx.builders.singlehtml',
75     'sphinx.builders.texinfo',
76     'sphinx.builders.text',
77     'sphinx.builders.xml',
78     'sphinx.config',
79     'sphinx.domains.c',
80     'sphinx.domains.changeset',
81     'sphinx.domains.citation',
82     'sphinx.domains.cpp',
83     'sphinx.domains.index',
84     'sphinx.domains.javascript',
85     'sphinx.domains.math',
86     'sphinx.domains.python',
87     'sphinx.domains.rst',
88     'sphinx.domains.std',
89     'sphinx.directives',
90     'sphinx.directives.code',
91     'sphinx.directives.other',
92     'sphinx.directives.patches',
93     'sphinx.extension',
94     'sphinx.parsers',
95     'sphinx.registry',
96     'sphinx.roles',
97     'sphinx.transforms',
98     'sphinx.transforms.compact_bullet_list',
99     'sphinx.transforms.i18n',
100     'sphinx.transforms.references',
101     'sphinx.transforms.post_transforms',
102     'sphinx.transforms.post_transforms.code',
103     'sphinx.transforms.post_transforms.images',
104     'sphinx.util.compat',
105     'sphinx.versioning',
106     # collectors should be loaded by specific order
107     'sphinx.environment.collectors.dependencies',
108     'sphinx.environment.collectors.asset',
109     'sphinx.environment.collectors.metadata',
110     'sphinx.environment.collectors.title',
111     'sphinx.environment.collectors.toctree',
112     # 1st party extensions
113     'sphinxcontrib.applehelp',
114     'sphinxcontrib.devhelp',
115     'sphinxcontrib.htmlhelp',
116     'sphinxcontrib.serializinghtml',
117     'sphinxcontrib.qthelp',
118     # Strictly, alabaster theme is not a builtin extension,
119     # but it is loaded automatically to use it as default theme.
120     'alabaster',
121 )
122 
123 ENV_PICKLE_FILENAME = 'environment.pickle'
124 
125 logger = logging.getLogger(__name__)
126 
127 
128 class Sphinx:
129     """The main application class and extensibility interface.
130 
131     :ivar srcdir: Directory containing source.
132     :ivar confdir: Directory containing ``conf.py``.
133     :ivar doctreedir: Directory for storing pickled doctrees.
134     :ivar outdir: Directory for storing build documents.
135     """
136 
137     def __init__(self, srcdir: str, confdir: str, outdir: str, doctreedir: str,
138                  buildername: str, confoverrides: Dict = None,
139                  status: IO = sys.stdout, warning: IO = sys.stderr,
140                  freshenv: bool = False, warningiserror: bool = False, tags: List[str] = None,
141                  verbosity: int = 0, parallel: int = 0, keep_going: bool = False) -> None:
142         self.phase = BuildPhase.INITIALIZATION
143         self.verbosity = verbosity
144         self.extensions = {}                    # type: Dict[str, Extension]
145         self.builder = None                     # type: Builder
146         self.env = None                         # type: BuildEnvironment
147         self.project = None                     # type: Project
148         self.registry = SphinxComponentRegistry()
149         self.html_themes = {}                   # type: Dict[str, str]
150 
151         # validate provided directories
152         self.srcdir = abspath(srcdir)
153         self.outdir = abspath(outdir)
154         self.doctreedir = abspath(doctreedir)
155         self.confdir = confdir
156         if self.confdir:  # confdir is optional
157             self.confdir = abspath(self.confdir)
158             if not path.isfile(path.join(self.confdir, 'conf.py')):
159                 raise ApplicationError(__("config directory doesn't contain a "
160                                           "conf.py file (%s)") % confdir)
161 
162         if not path.isdir(self.srcdir):
163             raise ApplicationError(__('Cannot find source directory (%s)') %
164                                    self.srcdir)
165 
166         if path.exists(self.outdir) and not path.isdir(self.outdir):
167             raise ApplicationError(__('Output directory (%s) is not a directory') %
168                                    self.outdir)
169 
170         if self.srcdir == self.outdir:
171             raise ApplicationError(__('Source directory and destination '
172                                       'directory cannot be identical'))
173 
174         self.parallel = parallel
175 
176         if status is None:
177             self._status = StringIO()      # type: IO
178             self.quiet = True
179         else:
180             self._status = status
181             self.quiet = False
182 
183         if warning is None:
184             self._warning = StringIO()     # type: IO
185         else:
186             self._warning = warning
187         self._warncount = 0
188         self.keep_going = warningiserror and keep_going
189         if self.keep_going:
190             self.warningiserror = False
191         else:
192             self.warningiserror = warningiserror
193         logging.setup(self, self._status, self._warning)
194 
195         self.events = EventManager(self)
196 
197         # keep last few messages for traceback
198         # This will be filled by sphinx.util.logging.LastMessagesWriter
199         self.messagelog = deque(maxlen=10)  # type: deque
200 
201         # say hello to the world
202         logger.info(bold(__('Running Sphinx v%s') % sphinx.__display_version__))
203 
204         # notice for parallel build on macOS and py38+
205         if sys.version_info > (3, 8) and platform.system() == 'Darwin' and parallel > 1:
206             logger.info(bold(__("For security reason, parallel mode is disabled on macOS and "
207                                 "python3.8 and above. For more details, please read "
208                                 "https://github.com/sphinx-doc/sphinx/issues/6803")))
209 
210         # status code for command-line application
211         self.statuscode = 0
212 
213         # read config
214         self.tags = Tags(tags)
215         if self.confdir is None:
216             self.config = Config({}, confoverrides or {})
217         else:
218             self.config = Config.read(self.confdir, confoverrides or {}, self.tags)
219 
220         # initialize some limited config variables before initialize i18n and loading
221         # extensions
222         self.config.pre_init_values()
223 
224         # set up translation infrastructure
225         self._init_i18n()
226 
227         # check the Sphinx version if requested
228         if self.config.needs_sphinx and self.config.needs_sphinx > sphinx.__display_version__:
229             raise VersionRequirementError(
230                 __('This project needs at least Sphinx v%s and therefore cannot '
231                    'be built with this version.') % self.config.needs_sphinx)
232 
233         # set confdir to srcdir if -C given (!= no confdir); a few pieces
234         # of code expect a confdir to be set
235         if self.confdir is None:
236             self.confdir = self.srcdir
237 
238         # load all built-in extension modules
239         for extension in builtin_extensions:
240             self.setup_extension(extension)
241 
242         # load all user-given extension modules
243         for extension in self.config.extensions:
244             self.setup_extension(extension)
245 
246         # preload builder module (before init config values)
247         self.preload_builder(buildername)
248 
249         if not path.isdir(outdir):
250             with progress_message(__('making output directory')):
251                 ensuredir(outdir)
252 
253         # the config file itself can be an extension
254         if self.config.setup:
255             prefix = __('while setting up extension %s:') % "conf.py"
256             with prefixed_warnings(prefix):
257                 if callable(self.config.setup):
258                     self.config.setup(self)
259                 else:
260                     raise ConfigError(
261                         __("'setup' as currently defined in conf.py isn't a Python callable. "
262                            "Please modify its definition to make it a callable function. "
263                            "This is needed for conf.py to behave as a Sphinx extension.")
264                     )
265 
266         # now that we know all config values, collect them from conf.py
267         self.config.init_values()
268         self.events.emit('config-inited', self.config)
269 
270         # create the project
271         self.project = Project(self.srcdir, self.config.source_suffix)
272         # create the builder
273         self.builder = self.create_builder(buildername)
274         # set up the build environment
275         self._init_env(freshenv)
276         # set up the builder
277         self._init_builder()
278 
279     def _init_i18n(self) -> None:
280         """Load translated strings from the configured localedirs if enabled in
281         the configuration.
282         """
283         if self.config.language is None:
284             self.translator, has_translation = locale.init([], None)
285         else:
286             logger.info(bold(__('loading translations [%s]... ') % self.config.language),
287                         nonl=True)
288 
289             # compile mo files if sphinx.po file in user locale directories are updated
290             repo = CatalogRepository(self.srcdir, self.config.locale_dirs,
291                                      self.config.language, self.config.source_encoding)
292             for catalog in repo.catalogs:
293                 if catalog.domain == 'sphinx' and catalog.is_outdated():
294                     catalog.write_mo(self.config.language)
295 
296             locale_dirs = [None, path.join(package_dir, 'locale')] + list(repo.locale_dirs)
297             self.translator, has_translation = locale.init(locale_dirs, self.config.language)
298             if has_translation or self.config.language == 'en':
299                 # "en" never needs to be translated
300                 logger.info(__('done'))
301             else:
302                 logger.info(__('not available for built-in messages'))
303 
304     def _init_env(self, freshenv: bool) -> None:
305         filename = path.join(self.doctreedir, ENV_PICKLE_FILENAME)
306         if freshenv or not os.path.exists(filename):
307             self.env = BuildEnvironment()
308             self.env.setup(self)
309             self.env.find_files(self.config, self.builder)
310         else:
311             try:
312                 with progress_message(__('loading pickled environment')):
313                     with open(filename, 'rb') as f:
314                         self.env = pickle.load(f)
315                         self.env.setup(self)
316             except Exception as err:
317                 logger.info(__('failed: %s'), err)
318                 self._init_env(freshenv=True)
319 
320     def preload_builder(self, name: str) -> None:
321         self.registry.preload_builder(self, name)
322 
323     def create_builder(self, name: str) -> "Builder":
324         if name is None:
325             logger.info(__('No builder selected, using default: html'))
326             name = 'html'
327 
328         return self.registry.create_builder(self, name)
329 
330     def _init_builder(self) -> None:
331         self.builder.set_environment(self.env)
332         self.builder.init()
333         self.events.emit('builder-inited')
334 
335     # ---- main "build" method -------------------------------------------------
336 
337     def build(self, force_all: bool = False, filenames: List[str] = None) -> None:
338         self.phase = BuildPhase.READING
339         try:
340             if force_all:
341                 self.builder.compile_all_catalogs()
342                 self.builder.build_all()
343             elif filenames:
344                 self.builder.compile_specific_catalogs(filenames)
345                 self.builder.build_specific(filenames)
346             else:
347                 self.builder.compile_update_catalogs()
348                 self.builder.build_update()
349 
350             if self._warncount and self.keep_going:
351                 self.statuscode = 1
352 
353             status = (__('succeeded') if self.statuscode == 0
354                       else __('finished with problems'))
355             if self._warncount:
356                 if self.warningiserror:
357                     if self._warncount == 1:
358                         msg = __('build %s, %s warning (with warnings treated as errors).')
359                     else:
360                         msg = __('build %s, %s warnings (with warnings treated as errors).')
361                 else:
362                     if self._warncount == 1:
363                         msg = __('build %s, %s warning.')
364                     else:
365                         msg = __('build %s, %s warnings.')
366 
367                 logger.info(bold(msg % (status, self._warncount)))
368             else:
369                 logger.info(bold(__('build %s.') % status))
370 
371             if self.statuscode == 0 and self.builder.epilog:
372                 logger.info('')
373                 logger.info(self.builder.epilog % {
374                     'outdir': relpath(self.outdir),
375                     'project': self.config.project
376                 })
377         except Exception as err:
378             # delete the saved env to force a fresh build next time
379             envfile = path.join(self.doctreedir, ENV_PICKLE_FILENAME)
380             if path.isfile(envfile):
381                 os.unlink(envfile)
382             self.events.emit('build-finished', err)
383             raise
384         else:
385             self.events.emit('build-finished', None)
386         self.builder.cleanup()
387 
388     # ---- general extensibility interface -------------------------------------
389 
390     def setup_extension(self, extname: str) -> None:
391         """Import and setup a Sphinx extension module.
392 
393         Load the extension given by the module *name*.  Use this if your
394         extension needs the features provided by another extension.  No-op if
395         called twice.
396         """
397         logger.debug('[app] setting up extension: %r', extname)
398         self.registry.load_extension(self, extname)
399 
400     def require_sphinx(self, version: str) -> None:
401         """Check the Sphinx version if requested.
402 
403         Compare *version* (which must be a ``major.minor`` version string, e.g.
404         ``'1.1'``) with the version of the running Sphinx, and abort the build
405         when it is too old.
406 
407         .. versionadded:: 1.0
408         """
409         if version > sphinx.__display_version__[:3]:
410             raise VersionRequirementError(version)
411 
412     # event interface
413     def connect(self, event: str, callback: Callable, priority: int = 500) -> int:
414         """Register *callback* to be called when *event* is emitted.
415 
416         For details on available core events and the arguments of callback
417         functions, please see :ref:`events`.
418 
419         Registered callbacks will be invoked on event in the order of *priority* and
420         registration.  The priority is ascending order.
421 
422         The method returns a "listener ID" that can be used as an argument to
423         :meth:`disconnect`.
424 
425         .. versionchanged:: 3.0
426 
427            Support *priority*
428         """
429         listener_id = self.events.connect(event, callback, priority)
430         logger.debug('[app] connecting event %r (%d): %r [id=%s]',
431                      event, priority, callback, listener_id)
432         return listener_id
433 
434     def disconnect(self, listener_id: int) -> None:
435         """Unregister callback by *listener_id*."""
436         logger.debug('[app] disconnecting event: [id=%s]', listener_id)
437         self.events.disconnect(listener_id)
438 
439     def emit(self, event: str, *args: Any,
440              allowed_exceptions: Tuple["Type[Exception]", ...] = ()) -> List:
441         """Emit *event* and pass *arguments* to the callback functions.
442 
443         Return the return values of all callbacks as a list.  Do not emit core
444         Sphinx events in extensions!
445 
446         .. versionchanged:: 3.1
447 
448            Added *allowed_exceptions* to specify path-through exceptions
449         """
450         return self.events.emit(event, *args, allowed_exceptions=allowed_exceptions)
451 
452     def emit_firstresult(self, event: str, *args: Any,
453                          allowed_exceptions: Tuple["Type[Exception]", ...] = ()) -> Any:
454         """Emit *event* and pass *arguments* to the callback functions.
455 
456         Return the result of the first callback that doesn't return ``None``.
457 
458         .. versionadded:: 0.5
459         .. versionchanged:: 3.1
460 
461            Added *allowed_exceptions* to specify path-through exceptions
462         """
463         return self.events.emit_firstresult(event, *args,
464                                             allowed_exceptions=allowed_exceptions)
465 
466     # registering addon parts
467 
468     def add_builder(self, builder: "Type[Builder]", override: bool = False) -> None:
469         """Register a new builder.
470 
471         *builder* must be a class that inherits from
472         :class:`~sphinx.builders.Builder`.
473 
474         .. versionchanged:: 1.8
475            Add *override* keyword.
476         """
477         self.registry.add_builder(builder, override=override)
478 
479     # TODO(stephenfin): Describe 'types' parameter
480     def add_config_value(self, name: str, default: Any, rebuild: Union[bool, str],
481                          types: Any = ()) -> None:
482         """Register a configuration value.
483 
484         This is necessary for Sphinx to recognize new values and set default
485         values accordingly.  The *name* should be prefixed with the extension
486         name, to avoid clashes.  The *default* value can be any Python object.
487         The string value *rebuild* must be one of those values:
488 
489         * ``'env'`` if a change in the setting only takes effect when a
490           document is parsed -- this means that the whole environment must be
491           rebuilt.
492         * ``'html'`` if a change in the setting needs a full rebuild of HTML
493           documents.
494         * ``''`` if a change in the setting will not need any special rebuild.
495 
496         .. versionchanged:: 0.6
497            Changed *rebuild* from a simple boolean (equivalent to ``''`` or
498            ``'env'``) to a string.  However, booleans are still accepted and
499            converted internally.
500 
501         .. versionchanged:: 0.4
502            If the *default* value is a callable, it will be called with the
503            config object as its argument in order to get the default value.
504            This can be used to implement config values whose default depends on
505            other values.
506         """
507         logger.debug('[app] adding config value: %r',
508                      (name, default, rebuild) + ((types,) if types else ()))
509         if rebuild in (False, True):
510             rebuild = 'env' if rebuild else ''
511         self.config.add(name, default, rebuild, types)
512 
513     def add_event(self, name: str) -> None:
514         """Register an event called *name*.
515 
516         This is needed to be able to emit it.
517         """
518         logger.debug('[app] adding event: %r', name)
519         self.events.add(name)
520 
521     def set_translator(self, name: str, translator_class: "Type[nodes.NodeVisitor]",
522                        override: bool = False) -> None:
523         """Register or override a Docutils translator class.
524 
525         This is used to register a custom output translator or to replace a
526         builtin translator.  This allows extensions to use custom translator
527         and define custom nodes for the translator (see :meth:`add_node`).
528 
529         .. versionadded:: 1.3
530         .. versionchanged:: 1.8
531            Add *override* keyword.
532         """
533         self.registry.add_translator(name, translator_class, override=override)
534 
535     def add_node(self, node: "Type[Element]", override: bool = False,
536                  **kwargs: Tuple[Callable, Callable]) -> None:
537         """Register a Docutils node class.
538 
539         This is necessary for Docutils internals.  It may also be used in the
540         future to validate nodes in the parsed documents.
541 
542         Node visitor functions for the Sphinx HTML, LaTeX, text and manpage
543         writers can be given as keyword arguments: the keyword should be one or
544         more of ``'html'``, ``'latex'``, ``'text'``, ``'man'``, ``'texinfo'``
545         or any other supported translators, the value a 2-tuple of ``(visit,
546         depart)`` methods.  ``depart`` can be ``None`` if the ``visit``
547         function raises :exc:`docutils.nodes.SkipNode`.  Example:
548 
549         .. code-block:: python
550 
551            class math(docutils.nodes.Element): pass
552 
553            def visit_math_html(self, node):
554                self.body.append(self.starttag(node, 'math'))
555            def depart_math_html(self, node):
556                self.body.append('</math>')
557 
558            app.add_node(math, html=(visit_math_html, depart_math_html))
559 
560         Obviously, translators for which you don't specify visitor methods will
561         choke on the node when encountered in a document to translate.
562 
563         .. versionchanged:: 0.5
564            Added the support for keyword arguments giving visit functions.
565         """
566         logger.debug('[app] adding node: %r', (node, kwargs))
567         if not override and docutils.is_node_registered(node):
568             logger.warning(__('node class %r is already registered, '
569                               'its visitors will be overridden'),
570                            node.__name__, type='app', subtype='add_node')
571         docutils.register_node(node)
572         self.registry.add_translation_handlers(node, **kwargs)
573 
574     def add_enumerable_node(self, node: "Type[Element]", figtype: str,
575                             title_getter: TitleGetter = None, override: bool = False,
576                             **kwargs: Tuple[Callable, Callable]) -> None:
577         """Register a Docutils node class as a numfig target.
578 
579         Sphinx numbers the node automatically. And then the users can refer it
580         using :rst:role:`numref`.
581 
582         *figtype* is a type of enumerable nodes.  Each figtypes have individual
583         numbering sequences.  As a system figtypes, ``figure``, ``table`` and
584         ``code-block`` are defined.  It is able to add custom nodes to these
585         default figtypes.  It is also able to define new custom figtype if new
586         figtype is given.
587 
588         *title_getter* is a getter function to obtain the title of node.  It
589         takes an instance of the enumerable node, and it must return its title
590         as string.  The title is used to the default title of references for
591         :rst:role:`ref`.  By default, Sphinx searches
592         ``docutils.nodes.caption`` or ``docutils.nodes.title`` from the node as
593         a title.
594 
595         Other keyword arguments are used for node visitor functions. See the
596         :meth:`.Sphinx.add_node` for details.
597 
598         .. versionadded:: 1.4
599         """
600         self.registry.add_enumerable_node(node, figtype, title_getter, override=override)
601         self.add_node(node, override=override, **kwargs)
602 
603     def add_directive(self, name: str, cls: "Type[Directive]", override: bool = False) -> None:
604         """Register a Docutils directive.
605 
606         *name* must be the prospective directive name.  *cls* is a directive
607         class which inherits ``docutils.parsers.rst.Directive``.  For more
608         details, see `the Docutils docs
609         <http://docutils.sourceforge.net/docs/howto/rst-directives.html>`_ .
610 
611         For example, the (already existing) :rst:dir:`literalinclude` directive
612         would be added like this:
613 
614         .. code-block:: python
615 
616            from docutils.parsers.rst import Directive, directives
617 
618            class LiteralIncludeDirective(Directive):
619                has_content = True
620                required_arguments = 1
621                optional_arguments = 0
622                final_argument_whitespace = True
623                option_spec = {
624                    'class': directives.class_option,
625                    'name': directives.unchanged,
626                }
627 
628                def run(self):
629                    ...
630 
631            add_directive('literalinclude', LiteralIncludeDirective)
632 
633         .. versionchanged:: 0.6
634            Docutils 0.5-style directive classes are now supported.
635         .. deprecated:: 1.8
636            Docutils 0.4-style (function based) directives support is deprecated.
637         .. versionchanged:: 1.8
638            Add *override* keyword.
639         """
640         logger.debug('[app] adding directive: %r', (name, cls))
641         if not override and docutils.is_directive_registered(name):
642             logger.warning(__('directive %r is already registered, it will be overridden'),
643                            name, type='app', subtype='add_directive')
644 
645         docutils.register_directive(name, cls)
646 
647     def add_role(self, name: str, role: Any, override: bool = False) -> None:
648         """Register a Docutils role.
649 
650         *name* must be the role name that occurs in the source, *role* the role
651         function. Refer to the `Docutils documentation
652         <http://docutils.sourceforge.net/docs/howto/rst-roles.html>`_ for
653         more information.
654 
655         .. versionchanged:: 1.8
656            Add *override* keyword.
657         """
658         logger.debug('[app] adding role: %r', (name, role))
659         if not override and docutils.is_role_registered(name):
660             logger.warning(__('role %r is already registered, it will be overridden'),
661                            name, type='app', subtype='add_role')
662         docutils.register_role(name, role)
663 
664     def add_generic_role(self, name: str, nodeclass: Any, override: bool = False) -> None:
665         """Register a generic Docutils role.
666 
667         Register a Docutils role that does nothing but wrap its contents in the
668         node given by *nodeclass*.
669 
670         .. versionadded:: 0.6
671         .. versionchanged:: 1.8
672            Add *override* keyword.
673         """
674         # Don't use ``roles.register_generic_role`` because it uses
675         # ``register_canonical_role``.
676         logger.debug('[app] adding generic role: %r', (name, nodeclass))
677         if not override and docutils.is_role_registered(name):
678             logger.warning(__('role %r is already registered, it will be overridden'),
679                            name, type='app', subtype='add_generic_role')
680         role = roles.GenericRole(name, nodeclass)
681         docutils.register_role(name, role)
682 
683     def add_domain(self, domain: "Type[Domain]", override: bool = False) -> None:
684         """Register a domain.
685 
686         Make the given *domain* (which must be a class; more precisely, a
687         subclass of :class:`~sphinx.domains.Domain`) known to Sphinx.
688 
689         .. versionadded:: 1.0
690         .. versionchanged:: 1.8
691            Add *override* keyword.
692         """
693         self.registry.add_domain(domain, override=override)
694 
695     def add_directive_to_domain(self, domain: str, name: str,
696                                 cls: "Type[Directive]", override: bool = False) -> None:
697         """Register a Docutils directive in a domain.
698 
699         Like :meth:`add_directive`, but the directive is added to the domain
700         named *domain*.
701 
702         .. versionadded:: 1.0
703         .. versionchanged:: 1.8
704            Add *override* keyword.
705         """
706         self.registry.add_directive_to_domain(domain, name, cls, override=override)
707 
708     def add_role_to_domain(self, domain: str, name: str, role: Union[RoleFunction, XRefRole],
709                            override: bool = False) -> None:
710         """Register a Docutils role in a domain.
711 
712         Like :meth:`add_role`, but the role is added to the domain named
713         *domain*.
714 
715         .. versionadded:: 1.0
716         .. versionchanged:: 1.8
717            Add *override* keyword.
718         """
719         self.registry.add_role_to_domain(domain, name, role, override=override)
720 
721     def add_index_to_domain(self, domain: str, index: "Type[Index]", override: bool = False
722                             ) -> None:
723         """Register a custom index for a domain.
724 
725         Add a custom *index* class to the domain named *domain*.  *index* must
726         be a subclass of :class:`~sphinx.domains.Index`.
727 
728         .. versionadded:: 1.0
729         .. versionchanged:: 1.8
730            Add *override* keyword.
731         """
732         self.registry.add_index_to_domain(domain, index)
733 
734     def add_object_type(self, directivename: str, rolename: str, indextemplate: str = '',
735                         parse_node: Callable = None, ref_nodeclass: "Type[TextElement]" = None,
736                         objname: str = '', doc_field_types: List = [], override: bool = False
737                         ) -> None:
738         """Register a new object type.
739 
740         This method is a very convenient way to add a new :term:`object` type
741         that can be cross-referenced.  It will do this:
742 
743         - Create a new directive (called *directivename*) for documenting an
744           object.  It will automatically add index entries if *indextemplate*
745           is nonempty; if given, it must contain exactly one instance of
746           ``%s``.  See the example below for how the template will be
747           interpreted.
748         - Create a new role (called *rolename*) to cross-reference to these
749           object descriptions.
750         - If you provide *parse_node*, it must be a function that takes a
751           string and a docutils node, and it must populate the node with
752           children parsed from the string.  It must then return the name of the
753           item to be used in cross-referencing and index entries.  See the
754           :file:`conf.py` file in the source for this documentation for an
755           example.
756         - The *objname* (if not given, will default to *directivename*) names
757           the type of object.  It is used when listing objects, e.g. in search
758           results.
759 
760         For example, if you have this call in a custom Sphinx extension::
761 
762            app.add_object_type('directive', 'dir', 'pair: %s; directive')
763 
764         you can use this markup in your documents::
765 
766            .. rst:directive:: function
767 
768               Document a function.
769 
770            <...>
771 
772            See also the :rst:dir:`function` directive.
773 
774         For the directive, an index entry will be generated as if you had prepended ::
775 
776            .. index:: pair: function; directive
777 
778         The reference node will be of class ``literal`` (so it will be rendered
779         in a proportional font, as appropriate for code) unless you give the
780         *ref_nodeclass* argument, which must be a docutils node class.  Most
781         useful are ``docutils.nodes.emphasis`` or ``docutils.nodes.strong`` --
782         you can also use ``docutils.nodes.generated`` if you want no further
783         text decoration.  If the text should be treated as literal (e.g. no
784         smart quote replacement), but not have typewriter styling, use
785         ``sphinx.addnodes.literal_emphasis`` or
786         ``sphinx.addnodes.literal_strong``.
787 
788         For the role content, you have the same syntactical possibilities as
789         for standard Sphinx roles (see :ref:`xref-syntax`).
790 
791         .. versionchanged:: 1.8
792            Add *override* keyword.
793         """
794         self.registry.add_object_type(directivename, rolename, indextemplate, parse_node,
795                                       ref_nodeclass, objname, doc_field_types,
796                                       override=override)
797 
798     def add_crossref_type(self, directivename: str, rolename: str, indextemplate: str = '',
799                           ref_nodeclass: "Type[TextElement]" = None, objname: str = '',
800                           override: bool = False) -> None:
801         """Register a new crossref object type.
802 
803         This method is very similar to :meth:`add_object_type` except that the
804         directive it generates must be empty, and will produce no output.
805 
806         That means that you can add semantic targets to your sources, and refer
807         to them using custom roles instead of generic ones (like
808         :rst:role:`ref`).  Example call::
809 
810            app.add_crossref_type('topic', 'topic', 'single: %s',
811                                  docutils.nodes.emphasis)
812 
813         Example usage::
814 
815            .. topic:: application API
816 
817            The application API
818            -------------------
819 
820            Some random text here.
821 
822            See also :topic:`this section <application API>`.
823 
824         (Of course, the element following the ``topic`` directive needn't be a
825         section.)
826 
827         .. versionchanged:: 1.8
828            Add *override* keyword.
829         """
830         self.registry.add_crossref_type(directivename, rolename,
831                                         indextemplate, ref_nodeclass, objname,
832                                         override=override)
833 
834     def add_transform(self, transform: "Type[Transform]") -> None:
835         """Register a Docutils transform to be applied after parsing.
836 
837         Add the standard docutils :class:`Transform` subclass *transform* to
838         the list of transforms that are applied after Sphinx parses a reST
839         document.
840 
841         .. list-table:: priority range categories for Sphinx transforms
842            :widths: 20,80
843 
844            * - Priority
845              - Main purpose in Sphinx
846            * - 0-99
847              - Fix invalid nodes by docutils. Translate a doctree.
848            * - 100-299
849              - Preparation
850            * - 300-399
851              - early
852            * - 400-699
853              - main
854            * - 700-799
855              - Post processing. Deadline to modify text and referencing.
856            * - 800-899
857              - Collect referencing and referenced nodes. Domain processing.
858            * - 900-999
859              - Finalize and clean up.
860 
861         refs: `Transform Priority Range Categories`__
862 
863         __ http://docutils.sourceforge.net/docs/ref/transforms.html#transform-priority-range-categories
864         """  # NOQA
865         self.registry.add_transform(transform)
866 
867     def add_post_transform(self, transform: "Type[Transform]") -> None:
868         """Register a Docutils transform to be applied before writing.
869 
870         Add the standard docutils :class:`Transform` subclass *transform* to
871         the list of transforms that are applied before Sphinx writes a
872         document.
873         """
874         self.registry.add_post_transform(transform)
875 
876     def add_javascript(self, filename: str, **kwargs: str) -> None:
877         """An alias of :meth:`add_js_file`."""
878         warnings.warn('The app.add_javascript() is deprecated. '
879                       'Please use app.add_js_file() instead.',
880                       RemovedInSphinx40Warning, stacklevel=2)
881         self.add_js_file(filename, **kwargs)
882 
883     def add_js_file(self, filename: str, **kwargs: str) -> None:
884         """Register a JavaScript file to include in the HTML output.
885 
886         Add *filename* to the list of JavaScript files that the default HTML
887         template will include.  The filename must be relative to the HTML
888         static path , or a full URI with scheme.  If the keyword argument
889         ``body`` is given, its value will be added between the
890         ``<script>`` tags. Extra keyword arguments are included as
891         attributes of the ``<script>`` tag.
892 
893         Example::
894 
895             app.add_js_file('example.js')
896             # => <script src="_static/example.js"></script>
897 
898             app.add_js_file('example.js', async="async")
899             # => <script src="_static/example.js" async="async"></script>
900 
901             app.add_js_file(None, body="var myVariable = 'foo';")
902             # => <script>var myVariable = 'foo';</script>
903 
904         .. versionadded:: 0.5
905 
906         .. versionchanged:: 1.8
907            Renamed from ``app.add_javascript()``.
908            And it allows keyword arguments as attributes of script tag.
909         """
910         self.registry.add_js_file(filename, **kwargs)
911         if hasattr(self.builder, 'add_js_file'):
912             self.builder.add_js_file(filename, **kwargs)  # type: ignore
913 
914     def add_css_file(self, filename: str, **kwargs: str) -> None:
915         """Register a stylesheet to include in the HTML output.
916 
917         Add *filename* to the list of CSS files that the default HTML template
918         will include.  The filename must be relative to the HTML static path,
919         or a full URI with scheme.  The keyword arguments are also accepted for
920         attributes of ``<link>`` tag.
921 
922         Example::
923 
924             app.add_css_file('custom.css')
925             # => <link rel="stylesheet" href="_static/custom.css" type="text/css" />
926 
927             app.add_css_file('print.css', media='print')
928             # => <link rel="stylesheet" href="_static/print.css"
929             #          type="text/css" media="print" />
930 
931             app.add_css_file('fancy.css', rel='alternate stylesheet', title='fancy')
932             # => <link rel="alternate stylesheet" href="_static/fancy.css"
933             #          type="text/css" title="fancy" />
934 
935         .. versionadded:: 1.0
936 
937         .. versionchanged:: 1.6
938            Optional ``alternate`` and/or ``title`` attributes can be supplied
939            with the *alternate* (of boolean type) and *title* (a string)
940            arguments. The default is no title and *alternate* = ``False``. For
941            more information, refer to the `documentation
942            <https://mdn.io/Web/CSS/Alternative_style_sheets>`__.
943 
944         .. versionchanged:: 1.8
945            Renamed from ``app.add_stylesheet()``.
946            And it allows keyword arguments as attributes of link tag.
947         """
948         logger.debug('[app] adding stylesheet: %r', filename)
949         self.registry.add_css_files(filename, **kwargs)
950         if hasattr(self.builder, 'add_css_file'):
951             self.builder.add_css_file(filename, **kwargs)  # type: ignore
952 
953     def add_stylesheet(self, filename: str, alternate: bool = False, title: str = None
954                        ) -> None:
955         """An alias of :meth:`add_css_file`."""
956         warnings.warn('The app.add_stylesheet() is deprecated. '
957                       'Please use app.add_css_file() instead.',
958                       RemovedInSphinx40Warning, stacklevel=2)
959 
960         attributes = {}  # type: Dict[str, str]
961         if alternate:
962             attributes['rel'] = 'alternate stylesheet'
963         else:
964             attributes['rel'] = 'stylesheet'
965 
966         if title:
967             attributes['title'] = title
968 
969         self.add_css_file(filename, **attributes)
970 
971     def add_latex_package(self, packagename: str, options: str = None,
972                           after_hyperref: bool = False) -> None:
973         r"""Register a package to include in the LaTeX source code.
974 
975         Add *packagename* to the list of packages that LaTeX source code will
976         include.  If you provide *options*, it will be taken to `\usepackage`
977         declaration.  If you set *after_hyperref* truthy, the package will be
978         loaded after ``hyperref`` package.
979 
980         .. code-block:: python
981 
982            app.add_latex_package('mypackage')
983            # => \usepackage{mypackage}
984            app.add_latex_package('mypackage', 'foo,bar')
985            # => \usepackage[foo,bar]{mypackage}
986 
987         .. versionadded:: 1.3
988         .. versionadded:: 3.1
989 
990            *after_hyperref* option.
991         """
992         self.registry.add_latex_package(packagename, options, after_hyperref)
993 
994     def add_lexer(self, alias: str, lexer: Union[Lexer, "Type[Lexer]"]) -> None:
995         """Register a new lexer for source code.
996 
997         Use *lexer* to highlight code blocks with the given language *alias*.
998 
999         .. versionadded:: 0.6
1000         .. versionchanged:: 2.1
1001            Take a lexer class as an argument.  An instance of lexers are
1002            still supported until Sphinx-3.x.
1003         """
1004         logger.debug('[app] adding lexer: %r', (alias, lexer))
1005         if isinstance(lexer, Lexer):
1006             warnings.warn('app.add_lexer() API changed; '
1007                           'Please give lexer class instead instance',
1008                           RemovedInSphinx40Warning, stacklevel=2)
1009             lexers[alias] = lexer
1010         else:
1011             lexer_classes[alias] = lexer
1012 
1013     def add_autodocumenter(self, cls: Any, override: bool = False) -> None:
1014         """Register a new documenter class for the autodoc extension.
1015 
1016         Add *cls* as a new documenter class for the :mod:`sphinx.ext.autodoc`
1017         extension.  It must be a subclass of
1018         :class:`sphinx.ext.autodoc.Documenter`.  This allows to auto-document
1019         new types of objects.  See the source of the autodoc module for
1020         examples on how to subclass :class:`Documenter`.
1021 
1022         .. todo:: Add real docs for Documenter and subclassing
1023 
1024         .. versionadded:: 0.6
1025         .. versionchanged:: 2.2
1026            Add *override* keyword.
1027         """
1028         logger.debug('[app] adding autodocumenter: %r', cls)
1029         from sphinx.ext.autodoc.directive import AutodocDirective
1030         self.registry.add_documenter(cls.objtype, cls)
1031         self.add_directive('auto' + cls.objtype, AutodocDirective, override=override)
1032 
1033     def add_autodoc_attrgetter(self, typ: "Type", getter: Callable[[Any, str, Any], Any]
1034                                ) -> None:
1035         """Register a new ``getattr``-like function for the autodoc extension.
1036 
1037         Add *getter*, which must be a function with an interface compatible to
1038         the :func:`getattr` builtin, as the autodoc attribute getter for
1039         objects that are instances of *typ*.  All cases where autodoc needs to
1040         get an attribute of a type are then handled by this function instead of
1041         :func:`getattr`.
1042 
1043         .. versionadded:: 0.6
1044         """
1045         logger.debug('[app] adding autodoc attrgetter: %r', (typ, getter))
1046         self.registry.add_autodoc_attrgetter(typ, getter)
1047 
1048     def add_search_language(self, cls: Any) -> None:
1049         """Register a new language for the HTML search index.
1050 
1051         Add *cls*, which must be a subclass of
1052         :class:`sphinx.search.SearchLanguage`, as a support language for
1053         building the HTML full-text search index.  The class must have a *lang*
1054         attribute that indicates the language it should be used for.  See
1055         :confval:`html_search_language`.
1056 
1057         .. versionadded:: 1.1
1058         """
1059         logger.debug('[app] adding search language: %r', cls)
1060         from sphinx.search import languages, SearchLanguage
1061         assert issubclass(cls, SearchLanguage)
1062         languages[cls.lang] = cls
1063 
1064     def add_source_suffix(self, suffix: str, filetype: str, override: bool = False) -> None:
1065         """Register a suffix of source files.
1066 
1067         Same as :confval:`source_suffix`.  The users can override this
1068         using the setting.
1069 
1070         .. versionadded:: 1.8
1071         """
1072         self.registry.add_source_suffix(suffix, filetype, override=override)
1073 
1074     def add_source_parser(self, *args: Any, **kwargs: Any) -> None:
1075         """Register a parser class.
1076 
1077         .. versionadded:: 1.4
1078         .. versionchanged:: 1.8
1079            *suffix* argument is deprecated.  It only accepts *parser* argument.
1080            Use :meth:`add_source_suffix` API to register suffix instead.
1081         .. versionchanged:: 1.8
1082            Add *override* keyword.
1083         """
1084         self.registry.add_source_parser(*args, **kwargs)
1085 
1086     def add_env_collector(self, collector: "Type[EnvironmentCollector]") -> None:
1087         """Register an environment collector class.
1088 
1089         Refer to :ref:`collector-api`.
1090 
1091         .. versionadded:: 1.6
1092         """
1093         logger.debug('[app] adding environment collector: %r', collector)
1094         collector().enable(self)
1095 
1096     def add_html_theme(self, name: str, theme_path: str) -> None:
1097         """Register a HTML Theme.
1098 
1099         The *name* is a name of theme, and *path* is a full path to the theme
1100         (refs: :ref:`distribute-your-theme`).
1101 
1102         .. versionadded:: 1.6
1103         """
1104         logger.debug('[app] adding HTML theme: %r, %r', name, theme_path)
1105         self.html_themes[name] = theme_path
1106 
1107     def add_html_math_renderer(self, name: str,
1108                                inline_renderers: Tuple[Callable, Callable] = None,
1109                                block_renderers: Tuple[Callable, Callable] = None) -> None:
1110         """Register a math renderer for HTML.
1111 
1112         The *name* is a name of math renderer.  Both *inline_renderers* and
1113         *block_renderers* are used as visitor functions for the HTML writer:
1114         the former for inline math node (``nodes.math``), the latter for
1115         block math node (``nodes.math_block``).  Regarding visitor functions,
1116         see :meth:`add_node` for details.
1117 
1118         .. versionadded:: 1.8
1119 
1120         """
1121         self.registry.add_html_math_renderer(name, inline_renderers, block_renderers)
1122 
1123     def add_message_catalog(self, catalog: str, locale_dir: str) -> None:
1124         """Register a message catalog.
1125 
1126         The *catalog* is a name of catalog, and *locale_dir* is a base path
1127         of message catalog.  For more details, see
1128         :func:`sphinx.locale.get_translation()`.
1129 
1130         .. versionadded:: 1.8
1131         """
1132         locale.init([locale_dir], self.config.language, catalog)
1133         locale.init_console(locale_dir, catalog)
1134 
1135     # ---- other methods -------------------------------------------------
1136     def is_parallel_allowed(self, typ: str) -> bool:
1137         """Check parallel processing is allowed or not.
1138 
1139         ``typ`` is a type of processing; ``'read'`` or ``'write'``.
1140         """
1141         if typ == 'read':
1142             attrname = 'parallel_read_safe'
1143             message_not_declared = __("the %s extension does not declare if it "
1144                                       "is safe for parallel reading, assuming "
1145                                       "it isn't - please ask the extension author "
1146                                       "to check and make it explicit")
1147             message_not_safe = __("the %s extension is not safe for parallel reading")
1148         elif typ == 'write':
1149             attrname = 'parallel_write_safe'
1150             message_not_declared = __("the %s extension does not declare if it "
1151                                       "is safe for parallel writing, assuming "
1152                                       "it isn't - please ask the extension author "
1153                                       "to check and make it explicit")
1154             message_not_safe = __("the %s extension is not safe for parallel writing")
1155         else:
1156             raise ValueError('parallel type %s is not supported' % typ)
1157 
1158         for ext in self.extensions.values():
1159             allowed = getattr(ext, attrname, None)
1160             if allowed is None:
1161                 logger.warning(message_not_declared, ext.name)
1162                 logger.warning(__('doing serial %s'), typ)
1163                 return False
1164             elif not allowed:
1165                 logger.warning(message_not_safe, ext.name)
1166                 logger.warning(__('doing serial %s'), typ)
1167                 return False
1168 
1169         return True
1170 
1171 
1172 class TemplateBridge:
1173     """
1174     This class defines the interface for a "template bridge", that is, a class
1175     that renders templates given a template name and a context.
1176     """
1177 
1178     def init(self, builder: "Builder", theme: Theme = None, dirs: List[str] = None) -> None:
1179         """Called by the builder to initialize the template system.
1180 
1181         *builder* is the builder object; you'll probably want to look at the
1182         value of ``builder.config.templates_path``.
1183 
1184         *theme* is a :class:`sphinx.theming.Theme` object or None; in the latter
1185         case, *dirs* can be list of fixed directories to look for templates.
1186         """
1187         raise NotImplementedError('must be implemented in subclasses')
1188 
1189     def newest_template_mtime(self) -> float:
1190         """Called by the builder to determine if output files are outdated
1191         because of template changes.  Return the mtime of the newest template
1192         file that was changed.  The default implementation returns ``0``.
1193         """
1194         return 0
1195 
1196     def render(self, template: str, context: Dict) -> None:
1197         """Called by the builder to render a template given as a filename with
1198         a specified context (a Python dictionary).
1199         """
1200         raise NotImplementedError('must be implemented in subclasses')
1201 
1202     def render_string(self, template: str, context: Dict) -> str:
1203         """Called by the builder to render a template given as a string with a
1204         specified context (a Python dictionary).
1205         """
1206         raise NotImplementedError('must be implemented in subclasses')

</code><intended_behavior>In a file or class responsible for translating index entries into HTML elements, ensure that the logic recognizing and creating sections for 'Symbols' is capable of identifying and consolidating all symbol entries into one section. This might involve adjusting how sections are defined and anchored in the HTML document to prevent duplication. For instance, a method responsible for generating section headers or anchors for the HTML output needs validation to ensure that symbols are not creating additional unintended sections. This validation might include a pre-check on index categories to ensure uniqueness and consolidation of symbol entries, or a post-processing step to merge sections that are erroneously divided.</intended_behavior>]
2025-10-18 18:22:12.963 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-18 18:22:12.963 | INFO     | Search-only: skipping patch selection
2025-10-18 18:22:13.051 | INFO     | Task sphinx-doc__sphinx-7975 completed successfully.
2025-10-18 18:22:13.052 | INFO     | No patch generated. You can try running ACR again.
