[
    {
        "rel_file_path": "sphinx/environment/adapters/indexentries.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sphinx-doc__sphinx/setup_sphinx-doc__sphinx__3.2/sphinx/environment/adapters/indexentries.py",
        "start": 1,
        "end": 176,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\"\n2     sphinx.environment.adapters.indexentries\n3     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n4 \n5     Index entries adapters for sphinx.environment.\n6 \n7     :copyright: Copyright 2007-2020 by the Sphinx team, see AUTHORS.\n8     :license: BSD, see LICENSE for details.\n9 \"\"\"\n10 \n11 import re\n12 import unicodedata\n13 from itertools import groupby\n14 from typing import Any, Dict, Pattern, List, Tuple\n15 from typing import cast\n16 \n17 from sphinx.builders import Builder\n18 from sphinx.domains.index import IndexDomain\n19 from sphinx.environment import BuildEnvironment\n20 from sphinx.errors import NoUri\n21 from sphinx.locale import _, __\n22 from sphinx.util import split_into, logging\n23 \n24 \n25 logger = logging.getLogger(__name__)\n26 \n27 \n28 class IndexEntries:\n29     def __init__(self, env: BuildEnvironment) -> None:\n30         self.env = env\n31 \n32     def create_index(self, builder: Builder, group_entries: bool = True,\n33                      _fixre: Pattern = re.compile(r'(.*) ([(][^()]*[)])')\n34                      ) -> List[Tuple[str, List[Tuple[str, Any]]]]:\n35         \"\"\"Create the real index from the collected index entries.\"\"\"\n36         new = {}  # type: Dict[str, List]\n37 \n38         def add_entry(word: str, subword: str, main: str, link: bool = True,\n39                       dic: Dict = new, key: str = None) -> None:\n40             # Force the word to be unicode if it's a ASCII bytestring.\n41             # This will solve problems with unicode normalization later.\n42             # For instance the RFC role will add bytestrings at the moment\n43             word = str(word)\n44             entry = dic.get(word)\n45             if not entry:\n46                 dic[word] = entry = [[], {}, key]\n47             if subword:\n48                 add_entry(subword, '', main, link=link, dic=entry[1], key=key)\n49             elif link:\n50                 try:\n51                     uri = builder.get_relative_uri('genindex', fn) + '#' + tid\n52                 except NoUri:\n53                     pass\n54                 else:\n55                     entry[0].append((main, uri))\n56 \n57         domain = cast(IndexDomain, self.env.get_domain('index'))\n58         for fn, entries in domain.entries.items():\n59             # new entry types must be listed in directives/other.py!\n60             for type, value, tid, main, index_key in entries:\n61                 try:\n62                     if type == 'single':\n63                         try:\n64                             entry, subentry = split_into(2, 'single', value)\n65                         except ValueError:\n66                             entry, = split_into(1, 'single', value)\n67                             subentry = ''\n68                         add_entry(entry, subentry, main, key=index_key)\n69                     elif type == 'pair':\n70                         first, second = split_into(2, 'pair', value)\n71                         add_entry(first, second, main, key=index_key)\n72                         add_entry(second, first, main, key=index_key)\n73                     elif type == 'triple':\n74                         first, second, third = split_into(3, 'triple', value)\n75                         add_entry(first, second + ' ' + third, main, key=index_key)\n76                         add_entry(second, third + ', ' + first, main, key=index_key)\n77                         add_entry(third, first + ' ' + second, main, key=index_key)\n78                     elif type == 'see':\n79                         first, second = split_into(2, 'see', value)\n80                         add_entry(first, _('see %s') % second, None,\n81                                   link=False, key=index_key)\n82                     elif type == 'seealso':\n83                         first, second = split_into(2, 'see', value)\n84                         add_entry(first, _('see also %s') % second, None,\n85                                   link=False, key=index_key)\n86                     else:\n87                         logger.warning(__('unknown index entry type %r'), type, location=fn)\n88                 except ValueError as err:\n89                     logger.warning(str(err), location=fn)\n90 \n91         # sort the index entries for same keyword.\n92         def keyfunc0(entry: Tuple[str, str]) -> Tuple[bool, str]:\n93             main, uri = entry\n94             return (not main, uri)  # show main entries at first\n95 \n96         for indexentry in new.values():\n97             indexentry[0].sort(key=keyfunc0)\n98             for subentry in indexentry[1].values():\n99                 subentry[0].sort(key=keyfunc0)  # type: ignore\n100 \n101         # sort the index entries; put all symbols at the front, even those\n102         # following the letters in ASCII, this is where the chr(127) comes from\n103         def keyfunc(entry: Tuple[str, List]) -> Tuple[str, str]:\n104             key, (void, void, category_key) = entry\n105             if category_key:\n106                 # using specified category key to sort\n107                 key = category_key\n108             lckey = unicodedata.normalize('NFD', key.lower())\n109             if lckey.startswith('\\N{RIGHT-TO-LEFT MARK}'):\n110                 lckey = lckey[1:]\n111             if lckey[0:1].isalpha() or lckey.startswith('_'):\n112                 lckey = chr(127) + lckey\n113             # ensure a determinstic order *within* letters by also sorting on\n114             # the entry itself\n115             return (lckey, entry[0])\n116         newlist = sorted(new.items(), key=keyfunc)\n117 \n118         if group_entries:\n119             # fixup entries: transform\n120             #   func() (in module foo)\n121             #   func() (in module bar)\n122             # into\n123             #   func()\n124             #     (in module foo)\n125             #     (in module bar)\n126             oldkey = ''\n127             oldsubitems = None  # type: Dict[str, List]\n128             i = 0\n129             while i < len(newlist):\n130                 key, (targets, subitems, _key) = newlist[i]\n131                 # cannot move if it has subitems; structure gets too complex\n132                 if not subitems:\n133                     m = _fixre.match(key)\n134                     if m:\n135                         if oldkey == m.group(1):\n136                             # prefixes match: add entry as subitem of the\n137                             # previous entry\n138                             oldsubitems.setdefault(m.group(2), [[], {}, _key])[0].\\\n139                                 extend(targets)\n140                             del newlist[i]\n141                             continue\n142                         oldkey = m.group(1)\n143                     else:\n144                         oldkey = key\n145                 oldsubitems = subitems\n146                 i += 1\n147 \n148         # sort the sub-index entries\n149         def keyfunc2(entry: Tuple[str, List]) -> str:\n150             key = unicodedata.normalize('NFD', entry[0].lower())\n151             if key.startswith('\\N{RIGHT-TO-LEFT MARK}'):\n152                 key = key[1:]\n153             if key[0:1].isalpha() or key.startswith('_'):\n154                 key = chr(127) + key\n155             return key\n156 \n157         # group the entries by letter\n158         def keyfunc3(item: Tuple[str, List]) -> str:\n159             # hack: mutating the subitems dicts to a list in the keyfunc\n160             k, v = item\n161             v[1] = sorted(((si, se) for (si, (se, void, void)) in v[1].items()),\n162                           key=keyfunc2)\n163             if v[2] is None:\n164                 # now calculate the key\n165                 if k.startswith('\\N{RIGHT-TO-LEFT MARK}'):\n166                     k = k[1:]\n167                 letter = unicodedata.normalize('NFD', k[0])[0].upper()\n168                 if letter.isalpha() or letter == '_':\n169                     return letter\n170                 else:\n171                     # get all other symbols under one heading\n172                     return _('Symbols')\n173             else:\n174                 return v[2]\n175         return [(key_, list(group))\n176                 for (key_, group) in groupby(newlist, keyfunc3)]\n",
        "intended_behavior": "This file likely contains logic for sorting and categorizing index entries, which should be revised to aggregate entries containing special characters (@, \u00a3, \u2190) under a single \u201cSymbols\u201d category effectively. This will prevent the duplication of 'Symbols' sections in the HTML output. Specifically, any function within this file that handles the organization or categorization of symbols into sections should be updated to ensure all symbols are uniformly recognized and placed within the same category, regardless of their position in the Unicode table or their ASCII representation. This may involve enhancing the sorting logic to prioritize the grouping of all non-alphanumeric characters into a single index rather than segregating them based on their character value."
    },
    {
        "rel_file_path": "sphinx/application.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sphinx-doc__sphinx/setup_sphinx-doc__sphinx__3.2/sphinx/application.py",
        "start": 1,
        "end": 1206,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\"\n2     sphinx.application\n3     ~~~~~~~~~~~~~~~~~~\n4 \n5     Sphinx application class and extensibility interface.\n6 \n7     Gracefully adapted from the TextPress system by Armin.\n8 \n9     :copyright: Copyright 2007-2020 by the Sphinx team, see AUTHORS.\n10     :license: BSD, see LICENSE for details.\n11 \"\"\"\n12 \n13 import os\n14 import pickle\n15 import platform\n16 import sys\n17 import warnings\n18 from collections import deque\n19 from io import StringIO\n20 from os import path\n21 from typing import Any, Callable, Dict, IO, List, Tuple, Union\n22 \n23 from docutils import nodes\n24 from docutils.nodes import Element, TextElement\n25 from docutils.parsers.rst import Directive, roles\n26 from docutils.transforms import Transform\n27 from pygments.lexer import Lexer\n28 \n29 import sphinx\n30 from sphinx import package_dir, locale\n31 from sphinx.config import Config\n32 from sphinx.deprecation import RemovedInSphinx40Warning\n33 from sphinx.domains import Domain, Index\n34 from sphinx.environment import BuildEnvironment\n35 from sphinx.environment.collectors import EnvironmentCollector\n36 from sphinx.errors import ApplicationError, ConfigError, VersionRequirementError\n37 from sphinx.events import EventManager\n38 from sphinx.extension import Extension\n39 from sphinx.highlighting import lexer_classes, lexers\n40 from sphinx.locale import __\n41 from sphinx.project import Project\n42 from sphinx.registry import SphinxComponentRegistry\n43 from sphinx.roles import XRefRole\n44 from sphinx.theming import Theme\n45 from sphinx.util import docutils\n46 from sphinx.util import logging\n47 from sphinx.util import progress_message\n48 from sphinx.util.build_phase import BuildPhase\n49 from sphinx.util.console import bold  # type: ignore\n50 from sphinx.util.i18n import CatalogRepository\n51 from sphinx.util.logging import prefixed_warnings\n52 from sphinx.util.osutil import abspath, ensuredir, relpath\n53 from sphinx.util.tags import Tags\n54 from sphinx.util.typing import RoleFunction, TitleGetter\n55 \n56 if False:\n57     # For type annotation\n58     from docutils.nodes import Node  # NOQA\n59     from typing import Type  # for python3.5.1\n60     from sphinx.builders import Builder\n61 \n62 \n63 builtin_extensions = (\n64     'sphinx.addnodes',\n65     'sphinx.builders.changes',\n66     'sphinx.builders.epub3',\n67     'sphinx.builders.dirhtml',\n68     'sphinx.builders.dummy',\n69     'sphinx.builders.gettext',\n70     'sphinx.builders.html',\n71     'sphinx.builders.latex',\n72     'sphinx.builders.linkcheck',\n73     'sphinx.builders.manpage',\n74     'sphinx.builders.singlehtml',\n75     'sphinx.builders.texinfo',\n76     'sphinx.builders.text',\n77     'sphinx.builders.xml',\n78     'sphinx.config',\n79     'sphinx.domains.c',\n80     'sphinx.domains.changeset',\n81     'sphinx.domains.citation',\n82     'sphinx.domains.cpp',\n83     'sphinx.domains.index',\n84     'sphinx.domains.javascript',\n85     'sphinx.domains.math',\n86     'sphinx.domains.python',\n87     'sphinx.domains.rst',\n88     'sphinx.domains.std',\n89     'sphinx.directives',\n90     'sphinx.directives.code',\n91     'sphinx.directives.other',\n92     'sphinx.directives.patches',\n93     'sphinx.extension',\n94     'sphinx.parsers',\n95     'sphinx.registry',\n96     'sphinx.roles',\n97     'sphinx.transforms',\n98     'sphinx.transforms.compact_bullet_list',\n99     'sphinx.transforms.i18n',\n100     'sphinx.transforms.references',\n101     'sphinx.transforms.post_transforms',\n102     'sphinx.transforms.post_transforms.code',\n103     'sphinx.transforms.post_transforms.images',\n104     'sphinx.util.compat',\n105     'sphinx.versioning',\n106     # collectors should be loaded by specific order\n107     'sphinx.environment.collectors.dependencies',\n108     'sphinx.environment.collectors.asset',\n109     'sphinx.environment.collectors.metadata',\n110     'sphinx.environment.collectors.title',\n111     'sphinx.environment.collectors.toctree',\n112     # 1st party extensions\n113     'sphinxcontrib.applehelp',\n114     'sphinxcontrib.devhelp',\n115     'sphinxcontrib.htmlhelp',\n116     'sphinxcontrib.serializinghtml',\n117     'sphinxcontrib.qthelp',\n118     # Strictly, alabaster theme is not a builtin extension,\n119     # but it is loaded automatically to use it as default theme.\n120     'alabaster',\n121 )\n122 \n123 ENV_PICKLE_FILENAME = 'environment.pickle'\n124 \n125 logger = logging.getLogger(__name__)\n126 \n127 \n128 class Sphinx:\n129     \"\"\"The main application class and extensibility interface.\n130 \n131     :ivar srcdir: Directory containing source.\n132     :ivar confdir: Directory containing ``conf.py``.\n133     :ivar doctreedir: Directory for storing pickled doctrees.\n134     :ivar outdir: Directory for storing build documents.\n135     \"\"\"\n136 \n137     def __init__(self, srcdir: str, confdir: str, outdir: str, doctreedir: str,\n138                  buildername: str, confoverrides: Dict = None,\n139                  status: IO = sys.stdout, warning: IO = sys.stderr,\n140                  freshenv: bool = False, warningiserror: bool = False, tags: List[str] = None,\n141                  verbosity: int = 0, parallel: int = 0, keep_going: bool = False) -> None:\n142         self.phase = BuildPhase.INITIALIZATION\n143         self.verbosity = verbosity\n144         self.extensions = {}                    # type: Dict[str, Extension]\n145         self.builder = None                     # type: Builder\n146         self.env = None                         # type: BuildEnvironment\n147         self.project = None                     # type: Project\n148         self.registry = SphinxComponentRegistry()\n149         self.html_themes = {}                   # type: Dict[str, str]\n150 \n151         # validate provided directories\n152         self.srcdir = abspath(srcdir)\n153         self.outdir = abspath(outdir)\n154         self.doctreedir = abspath(doctreedir)\n155         self.confdir = confdir\n156         if self.confdir:  # confdir is optional\n157             self.confdir = abspath(self.confdir)\n158             if not path.isfile(path.join(self.confdir, 'conf.py')):\n159                 raise ApplicationError(__(\"config directory doesn't contain a \"\n160                                           \"conf.py file (%s)\") % confdir)\n161 \n162         if not path.isdir(self.srcdir):\n163             raise ApplicationError(__('Cannot find source directory (%s)') %\n164                                    self.srcdir)\n165 \n166         if path.exists(self.outdir) and not path.isdir(self.outdir):\n167             raise ApplicationError(__('Output directory (%s) is not a directory') %\n168                                    self.outdir)\n169 \n170         if self.srcdir == self.outdir:\n171             raise ApplicationError(__('Source directory and destination '\n172                                       'directory cannot be identical'))\n173 \n174         self.parallel = parallel\n175 \n176         if status is None:\n177             self._status = StringIO()      # type: IO\n178             self.quiet = True\n179         else:\n180             self._status = status\n181             self.quiet = False\n182 \n183         if warning is None:\n184             self._warning = StringIO()     # type: IO\n185         else:\n186             self._warning = warning\n187         self._warncount = 0\n188         self.keep_going = warningiserror and keep_going\n189         if self.keep_going:\n190             self.warningiserror = False\n191         else:\n192             self.warningiserror = warningiserror\n193         logging.setup(self, self._status, self._warning)\n194 \n195         self.events = EventManager(self)\n196 \n197         # keep last few messages for traceback\n198         # This will be filled by sphinx.util.logging.LastMessagesWriter\n199         self.messagelog = deque(maxlen=10)  # type: deque\n200 \n201         # say hello to the world\n202         logger.info(bold(__('Running Sphinx v%s') % sphinx.__display_version__))\n203 \n204         # notice for parallel build on macOS and py38+\n205         if sys.version_info > (3, 8) and platform.system() == 'Darwin' and parallel > 1:\n206             logger.info(bold(__(\"For security reason, parallel mode is disabled on macOS and \"\n207                                 \"python3.8 and above. For more details, please read \"\n208                                 \"https://github.com/sphinx-doc/sphinx/issues/6803\")))\n209 \n210         # status code for command-line application\n211         self.statuscode = 0\n212 \n213         # read config\n214         self.tags = Tags(tags)\n215         if self.confdir is None:\n216             self.config = Config({}, confoverrides or {})\n217         else:\n218             self.config = Config.read(self.confdir, confoverrides or {}, self.tags)\n219 \n220         # initialize some limited config variables before initialize i18n and loading\n221         # extensions\n222         self.config.pre_init_values()\n223 \n224         # set up translation infrastructure\n225         self._init_i18n()\n226 \n227         # check the Sphinx version if requested\n228         if self.config.needs_sphinx and self.config.needs_sphinx > sphinx.__display_version__:\n229             raise VersionRequirementError(\n230                 __('This project needs at least Sphinx v%s and therefore cannot '\n231                    'be built with this version.') % self.config.needs_sphinx)\n232 \n233         # set confdir to srcdir if -C given (!= no confdir); a few pieces\n234         # of code expect a confdir to be set\n235         if self.confdir is None:\n236             self.confdir = self.srcdir\n237 \n238         # load all built-in extension modules\n239         for extension in builtin_extensions:\n240             self.setup_extension(extension)\n241 \n242         # load all user-given extension modules\n243         for extension in self.config.extensions:\n244             self.setup_extension(extension)\n245 \n246         # preload builder module (before init config values)\n247         self.preload_builder(buildername)\n248 \n249         if not path.isdir(outdir):\n250             with progress_message(__('making output directory')):\n251                 ensuredir(outdir)\n252 \n253         # the config file itself can be an extension\n254         if self.config.setup:\n255             prefix = __('while setting up extension %s:') % \"conf.py\"\n256             with prefixed_warnings(prefix):\n257                 if callable(self.config.setup):\n258                     self.config.setup(self)\n259                 else:\n260                     raise ConfigError(\n261                         __(\"'setup' as currently defined in conf.py isn't a Python callable. \"\n262                            \"Please modify its definition to make it a callable function. \"\n263                            \"This is needed for conf.py to behave as a Sphinx extension.\")\n264                     )\n265 \n266         # now that we know all config values, collect them from conf.py\n267         self.config.init_values()\n268         self.events.emit('config-inited', self.config)\n269 \n270         # create the project\n271         self.project = Project(self.srcdir, self.config.source_suffix)\n272         # create the builder\n273         self.builder = self.create_builder(buildername)\n274         # set up the build environment\n275         self._init_env(freshenv)\n276         # set up the builder\n277         self._init_builder()\n278 \n279     def _init_i18n(self) -> None:\n280         \"\"\"Load translated strings from the configured localedirs if enabled in\n281         the configuration.\n282         \"\"\"\n283         if self.config.language is None:\n284             self.translator, has_translation = locale.init([], None)\n285         else:\n286             logger.info(bold(__('loading translations [%s]... ') % self.config.language),\n287                         nonl=True)\n288 \n289             # compile mo files if sphinx.po file in user locale directories are updated\n290             repo = CatalogRepository(self.srcdir, self.config.locale_dirs,\n291                                      self.config.language, self.config.source_encoding)\n292             for catalog in repo.catalogs:\n293                 if catalog.domain == 'sphinx' and catalog.is_outdated():\n294                     catalog.write_mo(self.config.language)\n295 \n296             locale_dirs = [None, path.join(package_dir, 'locale')] + list(repo.locale_dirs)\n297             self.translator, has_translation = locale.init(locale_dirs, self.config.language)\n298             if has_translation or self.config.language == 'en':\n299                 # \"en\" never needs to be translated\n300                 logger.info(__('done'))\n301             else:\n302                 logger.info(__('not available for built-in messages'))\n303 \n304     def _init_env(self, freshenv: bool) -> None:\n305         filename = path.join(self.doctreedir, ENV_PICKLE_FILENAME)\n306         if freshenv or not os.path.exists(filename):\n307             self.env = BuildEnvironment()\n308             self.env.setup(self)\n309             self.env.find_files(self.config, self.builder)\n310         else:\n311             try:\n312                 with progress_message(__('loading pickled environment')):\n313                     with open(filename, 'rb') as f:\n314                         self.env = pickle.load(f)\n315                         self.env.setup(self)\n316             except Exception as err:\n317                 logger.info(__('failed: %s'), err)\n318                 self._init_env(freshenv=True)\n319 \n320     def preload_builder(self, name: str) -> None:\n321         self.registry.preload_builder(self, name)\n322 \n323     def create_builder(self, name: str) -> \"Builder\":\n324         if name is None:\n325             logger.info(__('No builder selected, using default: html'))\n326             name = 'html'\n327 \n328         return self.registry.create_builder(self, name)\n329 \n330     def _init_builder(self) -> None:\n331         self.builder.set_environment(self.env)\n332         self.builder.init()\n333         self.events.emit('builder-inited')\n334 \n335     # ---- main \"build\" method -------------------------------------------------\n336 \n337     def build(self, force_all: bool = False, filenames: List[str] = None) -> None:\n338         self.phase = BuildPhase.READING\n339         try:\n340             if force_all:\n341                 self.builder.compile_all_catalogs()\n342                 self.builder.build_all()\n343             elif filenames:\n344                 self.builder.compile_specific_catalogs(filenames)\n345                 self.builder.build_specific(filenames)\n346             else:\n347                 self.builder.compile_update_catalogs()\n348                 self.builder.build_update()\n349 \n350             if self._warncount and self.keep_going:\n351                 self.statuscode = 1\n352 \n353             status = (__('succeeded') if self.statuscode == 0\n354                       else __('finished with problems'))\n355             if self._warncount:\n356                 if self.warningiserror:\n357                     if self._warncount == 1:\n358                         msg = __('build %s, %s warning (with warnings treated as errors).')\n359                     else:\n360                         msg = __('build %s, %s warnings (with warnings treated as errors).')\n361                 else:\n362                     if self._warncount == 1:\n363                         msg = __('build %s, %s warning.')\n364                     else:\n365                         msg = __('build %s, %s warnings.')\n366 \n367                 logger.info(bold(msg % (status, self._warncount)))\n368             else:\n369                 logger.info(bold(__('build %s.') % status))\n370 \n371             if self.statuscode == 0 and self.builder.epilog:\n372                 logger.info('')\n373                 logger.info(self.builder.epilog % {\n374                     'outdir': relpath(self.outdir),\n375                     'project': self.config.project\n376                 })\n377         except Exception as err:\n378             # delete the saved env to force a fresh build next time\n379             envfile = path.join(self.doctreedir, ENV_PICKLE_FILENAME)\n380             if path.isfile(envfile):\n381                 os.unlink(envfile)\n382             self.events.emit('build-finished', err)\n383             raise\n384         else:\n385             self.events.emit('build-finished', None)\n386         self.builder.cleanup()\n387 \n388     # ---- general extensibility interface -------------------------------------\n389 \n390     def setup_extension(self, extname: str) -> None:\n391         \"\"\"Import and setup a Sphinx extension module.\n392 \n393         Load the extension given by the module *name*.  Use this if your\n394         extension needs the features provided by another extension.  No-op if\n395         called twice.\n396         \"\"\"\n397         logger.debug('[app] setting up extension: %r', extname)\n398         self.registry.load_extension(self, extname)\n399 \n400     def require_sphinx(self, version: str) -> None:\n401         \"\"\"Check the Sphinx version if requested.\n402 \n403         Compare *version* (which must be a ``major.minor`` version string, e.g.\n404         ``'1.1'``) with the version of the running Sphinx, and abort the build\n405         when it is too old.\n406 \n407         .. versionadded:: 1.0\n408         \"\"\"\n409         if version > sphinx.__display_version__[:3]:\n410             raise VersionRequirementError(version)\n411 \n412     # event interface\n413     def connect(self, event: str, callback: Callable, priority: int = 500) -> int:\n414         \"\"\"Register *callback* to be called when *event* is emitted.\n415 \n416         For details on available core events and the arguments of callback\n417         functions, please see :ref:`events`.\n418 \n419         Registered callbacks will be invoked on event in the order of *priority* and\n420         registration.  The priority is ascending order.\n421 \n422         The method returns a \"listener ID\" that can be used as an argument to\n423         :meth:`disconnect`.\n424 \n425         .. versionchanged:: 3.0\n426 \n427            Support *priority*\n428         \"\"\"\n429         listener_id = self.events.connect(event, callback, priority)\n430         logger.debug('[app] connecting event %r (%d): %r [id=%s]',\n431                      event, priority, callback, listener_id)\n432         return listener_id\n433 \n434     def disconnect(self, listener_id: int) -> None:\n435         \"\"\"Unregister callback by *listener_id*.\"\"\"\n436         logger.debug('[app] disconnecting event: [id=%s]', listener_id)\n437         self.events.disconnect(listener_id)\n438 \n439     def emit(self, event: str, *args: Any,\n440              allowed_exceptions: Tuple[\"Type[Exception]\", ...] = ()) -> List:\n441         \"\"\"Emit *event* and pass *arguments* to the callback functions.\n442 \n443         Return the return values of all callbacks as a list.  Do not emit core\n444         Sphinx events in extensions!\n445 \n446         .. versionchanged:: 3.1\n447 \n448            Added *allowed_exceptions* to specify path-through exceptions\n449         \"\"\"\n450         return self.events.emit(event, *args, allowed_exceptions=allowed_exceptions)\n451 \n452     def emit_firstresult(self, event: str, *args: Any,\n453                          allowed_exceptions: Tuple[\"Type[Exception]\", ...] = ()) -> Any:\n454         \"\"\"Emit *event* and pass *arguments* to the callback functions.\n455 \n456         Return the result of the first callback that doesn't return ``None``.\n457 \n458         .. versionadded:: 0.5\n459         .. versionchanged:: 3.1\n460 \n461            Added *allowed_exceptions* to specify path-through exceptions\n462         \"\"\"\n463         return self.events.emit_firstresult(event, *args,\n464                                             allowed_exceptions=allowed_exceptions)\n465 \n466     # registering addon parts\n467 \n468     def add_builder(self, builder: \"Type[Builder]\", override: bool = False) -> None:\n469         \"\"\"Register a new builder.\n470 \n471         *builder* must be a class that inherits from\n472         :class:`~sphinx.builders.Builder`.\n473 \n474         .. versionchanged:: 1.8\n475            Add *override* keyword.\n476         \"\"\"\n477         self.registry.add_builder(builder, override=override)\n478 \n479     # TODO(stephenfin): Describe 'types' parameter\n480     def add_config_value(self, name: str, default: Any, rebuild: Union[bool, str],\n481                          types: Any = ()) -> None:\n482         \"\"\"Register a configuration value.\n483 \n484         This is necessary for Sphinx to recognize new values and set default\n485         values accordingly.  The *name* should be prefixed with the extension\n486         name, to avoid clashes.  The *default* value can be any Python object.\n487         The string value *rebuild* must be one of those values:\n488 \n489         * ``'env'`` if a change in the setting only takes effect when a\n490           document is parsed -- this means that the whole environment must be\n491           rebuilt.\n492         * ``'html'`` if a change in the setting needs a full rebuild of HTML\n493           documents.\n494         * ``''`` if a change in the setting will not need any special rebuild.\n495 \n496         .. versionchanged:: 0.6\n497            Changed *rebuild* from a simple boolean (equivalent to ``''`` or\n498            ``'env'``) to a string.  However, booleans are still accepted and\n499            converted internally.\n500 \n501         .. versionchanged:: 0.4\n502            If the *default* value is a callable, it will be called with the\n503            config object as its argument in order to get the default value.\n504            This can be used to implement config values whose default depends on\n505            other values.\n506         \"\"\"\n507         logger.debug('[app] adding config value: %r',\n508                      (name, default, rebuild) + ((types,) if types else ()))\n509         if rebuild in (False, True):\n510             rebuild = 'env' if rebuild else ''\n511         self.config.add(name, default, rebuild, types)\n512 \n513     def add_event(self, name: str) -> None:\n514         \"\"\"Register an event called *name*.\n515 \n516         This is needed to be able to emit it.\n517         \"\"\"\n518         logger.debug('[app] adding event: %r', name)\n519         self.events.add(name)\n520 \n521     def set_translator(self, name: str, translator_class: \"Type[nodes.NodeVisitor]\",\n522                        override: bool = False) -> None:\n523         \"\"\"Register or override a Docutils translator class.\n524 \n525         This is used to register a custom output translator or to replace a\n526         builtin translator.  This allows extensions to use custom translator\n527         and define custom nodes for the translator (see :meth:`add_node`).\n528 \n529         .. versionadded:: 1.3\n530         .. versionchanged:: 1.8\n531            Add *override* keyword.\n532         \"\"\"\n533         self.registry.add_translator(name, translator_class, override=override)\n534 \n535     def add_node(self, node: \"Type[Element]\", override: bool = False,\n536                  **kwargs: Tuple[Callable, Callable]) -> None:\n537         \"\"\"Register a Docutils node class.\n538 \n539         This is necessary for Docutils internals.  It may also be used in the\n540         future to validate nodes in the parsed documents.\n541 \n542         Node visitor functions for the Sphinx HTML, LaTeX, text and manpage\n543         writers can be given as keyword arguments: the keyword should be one or\n544         more of ``'html'``, ``'latex'``, ``'text'``, ``'man'``, ``'texinfo'``\n545         or any other supported translators, the value a 2-tuple of ``(visit,\n546         depart)`` methods.  ``depart`` can be ``None`` if the ``visit``\n547         function raises :exc:`docutils.nodes.SkipNode`.  Example:\n548 \n549         .. code-block:: python\n550 \n551            class math(docutils.nodes.Element): pass\n552 \n553            def visit_math_html(self, node):\n554                self.body.append(self.starttag(node, 'math'))\n555            def depart_math_html(self, node):\n556                self.body.append('</math>')\n557 \n558            app.add_node(math, html=(visit_math_html, depart_math_html))\n559 \n560         Obviously, translators for which you don't specify visitor methods will\n561         choke on the node when encountered in a document to translate.\n562 \n563         .. versionchanged:: 0.5\n564            Added the support for keyword arguments giving visit functions.\n565         \"\"\"\n566         logger.debug('[app] adding node: %r', (node, kwargs))\n567         if not override and docutils.is_node_registered(node):\n568             logger.warning(__('node class %r is already registered, '\n569                               'its visitors will be overridden'),\n570                            node.__name__, type='app', subtype='add_node')\n571         docutils.register_node(node)\n572         self.registry.add_translation_handlers(node, **kwargs)\n573 \n574     def add_enumerable_node(self, node: \"Type[Element]\", figtype: str,\n575                             title_getter: TitleGetter = None, override: bool = False,\n576                             **kwargs: Tuple[Callable, Callable]) -> None:\n577         \"\"\"Register a Docutils node class as a numfig target.\n578 \n579         Sphinx numbers the node automatically. And then the users can refer it\n580         using :rst:role:`numref`.\n581 \n582         *figtype* is a type of enumerable nodes.  Each figtypes have individual\n583         numbering sequences.  As a system figtypes, ``figure``, ``table`` and\n584         ``code-block`` are defined.  It is able to add custom nodes to these\n585         default figtypes.  It is also able to define new custom figtype if new\n586         figtype is given.\n587 \n588         *title_getter* is a getter function to obtain the title of node.  It\n589         takes an instance of the enumerable node, and it must return its title\n590         as string.  The title is used to the default title of references for\n591         :rst:role:`ref`.  By default, Sphinx searches\n592         ``docutils.nodes.caption`` or ``docutils.nodes.title`` from the node as\n593         a title.\n594 \n595         Other keyword arguments are used for node visitor functions. See the\n596         :meth:`.Sphinx.add_node` for details.\n597 \n598         .. versionadded:: 1.4\n599         \"\"\"\n600         self.registry.add_enumerable_node(node, figtype, title_getter, override=override)\n601         self.add_node(node, override=override, **kwargs)\n602 \n603     def add_directive(self, name: str, cls: \"Type[Directive]\", override: bool = False) -> None:\n604         \"\"\"Register a Docutils directive.\n605 \n606         *name* must be the prospective directive name.  *cls* is a directive\n607         class which inherits ``docutils.parsers.rst.Directive``.  For more\n608         details, see `the Docutils docs\n609         <http://docutils.sourceforge.net/docs/howto/rst-directives.html>`_ .\n610 \n611         For example, the (already existing) :rst:dir:`literalinclude` directive\n612         would be added like this:\n613 \n614         .. code-block:: python\n615 \n616            from docutils.parsers.rst import Directive, directives\n617 \n618            class LiteralIncludeDirective(Directive):\n619                has_content = True\n620                required_arguments = 1\n621                optional_arguments = 0\n622                final_argument_whitespace = True\n623                option_spec = {\n624                    'class': directives.class_option,\n625                    'name': directives.unchanged,\n626                }\n627 \n628                def run(self):\n629                    ...\n630 \n631            add_directive('literalinclude', LiteralIncludeDirective)\n632 \n633         .. versionchanged:: 0.6\n634            Docutils 0.5-style directive classes are now supported.\n635         .. deprecated:: 1.8\n636            Docutils 0.4-style (function based) directives support is deprecated.\n637         .. versionchanged:: 1.8\n638            Add *override* keyword.\n639         \"\"\"\n640         logger.debug('[app] adding directive: %r', (name, cls))\n641         if not override and docutils.is_directive_registered(name):\n642             logger.warning(__('directive %r is already registered, it will be overridden'),\n643                            name, type='app', subtype='add_directive')\n644 \n645         docutils.register_directive(name, cls)\n646 \n647     def add_role(self, name: str, role: Any, override: bool = False) -> None:\n648         \"\"\"Register a Docutils role.\n649 \n650         *name* must be the role name that occurs in the source, *role* the role\n651         function. Refer to the `Docutils documentation\n652         <http://docutils.sourceforge.net/docs/howto/rst-roles.html>`_ for\n653         more information.\n654 \n655         .. versionchanged:: 1.8\n656            Add *override* keyword.\n657         \"\"\"\n658         logger.debug('[app] adding role: %r', (name, role))\n659         if not override and docutils.is_role_registered(name):\n660             logger.warning(__('role %r is already registered, it will be overridden'),\n661                            name, type='app', subtype='add_role')\n662         docutils.register_role(name, role)\n663 \n664     def add_generic_role(self, name: str, nodeclass: Any, override: bool = False) -> None:\n665         \"\"\"Register a generic Docutils role.\n666 \n667         Register a Docutils role that does nothing but wrap its contents in the\n668         node given by *nodeclass*.\n669 \n670         .. versionadded:: 0.6\n671         .. versionchanged:: 1.8\n672            Add *override* keyword.\n673         \"\"\"\n674         # Don't use ``roles.register_generic_role`` because it uses\n675         # ``register_canonical_role``.\n676         logger.debug('[app] adding generic role: %r', (name, nodeclass))\n677         if not override and docutils.is_role_registered(name):\n678             logger.warning(__('role %r is already registered, it will be overridden'),\n679                            name, type='app', subtype='add_generic_role')\n680         role = roles.GenericRole(name, nodeclass)\n681         docutils.register_role(name, role)\n682 \n683     def add_domain(self, domain: \"Type[Domain]\", override: bool = False) -> None:\n684         \"\"\"Register a domain.\n685 \n686         Make the given *domain* (which must be a class; more precisely, a\n687         subclass of :class:`~sphinx.domains.Domain`) known to Sphinx.\n688 \n689         .. versionadded:: 1.0\n690         .. versionchanged:: 1.8\n691            Add *override* keyword.\n692         \"\"\"\n693         self.registry.add_domain(domain, override=override)\n694 \n695     def add_directive_to_domain(self, domain: str, name: str,\n696                                 cls: \"Type[Directive]\", override: bool = False) -> None:\n697         \"\"\"Register a Docutils directive in a domain.\n698 \n699         Like :meth:`add_directive`, but the directive is added to the domain\n700         named *domain*.\n701 \n702         .. versionadded:: 1.0\n703         .. versionchanged:: 1.8\n704            Add *override* keyword.\n705         \"\"\"\n706         self.registry.add_directive_to_domain(domain, name, cls, override=override)\n707 \n708     def add_role_to_domain(self, domain: str, name: str, role: Union[RoleFunction, XRefRole],\n709                            override: bool = False) -> None:\n710         \"\"\"Register a Docutils role in a domain.\n711 \n712         Like :meth:`add_role`, but the role is added to the domain named\n713         *domain*.\n714 \n715         .. versionadded:: 1.0\n716         .. versionchanged:: 1.8\n717            Add *override* keyword.\n718         \"\"\"\n719         self.registry.add_role_to_domain(domain, name, role, override=override)\n720 \n721     def add_index_to_domain(self, domain: str, index: \"Type[Index]\", override: bool = False\n722                             ) -> None:\n723         \"\"\"Register a custom index for a domain.\n724 \n725         Add a custom *index* class to the domain named *domain*.  *index* must\n726         be a subclass of :class:`~sphinx.domains.Index`.\n727 \n728         .. versionadded:: 1.0\n729         .. versionchanged:: 1.8\n730            Add *override* keyword.\n731         \"\"\"\n732         self.registry.add_index_to_domain(domain, index)\n733 \n734     def add_object_type(self, directivename: str, rolename: str, indextemplate: str = '',\n735                         parse_node: Callable = None, ref_nodeclass: \"Type[TextElement]\" = None,\n736                         objname: str = '', doc_field_types: List = [], override: bool = False\n737                         ) -> None:\n738         \"\"\"Register a new object type.\n739 \n740         This method is a very convenient way to add a new :term:`object` type\n741         that can be cross-referenced.  It will do this:\n742 \n743         - Create a new directive (called *directivename*) for documenting an\n744           object.  It will automatically add index entries if *indextemplate*\n745           is nonempty; if given, it must contain exactly one instance of\n746           ``%s``.  See the example below for how the template will be\n747           interpreted.\n748         - Create a new role (called *rolename*) to cross-reference to these\n749           object descriptions.\n750         - If you provide *parse_node*, it must be a function that takes a\n751           string and a docutils node, and it must populate the node with\n752           children parsed from the string.  It must then return the name of the\n753           item to be used in cross-referencing and index entries.  See the\n754           :file:`conf.py` file in the source for this documentation for an\n755           example.\n756         - The *objname* (if not given, will default to *directivename*) names\n757           the type of object.  It is used when listing objects, e.g. in search\n758           results.\n759 \n760         For example, if you have this call in a custom Sphinx extension::\n761 \n762            app.add_object_type('directive', 'dir', 'pair: %s; directive')\n763 \n764         you can use this markup in your documents::\n765 \n766            .. rst:directive:: function\n767 \n768               Document a function.\n769 \n770            <...>\n771 \n772            See also the :rst:dir:`function` directive.\n773 \n774         For the directive, an index entry will be generated as if you had prepended ::\n775 \n776            .. index:: pair: function; directive\n777 \n778         The reference node will be of class ``literal`` (so it will be rendered\n779         in a proportional font, as appropriate for code) unless you give the\n780         *ref_nodeclass* argument, which must be a docutils node class.  Most\n781         useful are ``docutils.nodes.emphasis`` or ``docutils.nodes.strong`` --\n782         you can also use ``docutils.nodes.generated`` if you want no further\n783         text decoration.  If the text should be treated as literal (e.g. no\n784         smart quote replacement), but not have typewriter styling, use\n785         ``sphinx.addnodes.literal_emphasis`` or\n786         ``sphinx.addnodes.literal_strong``.\n787 \n788         For the role content, you have the same syntactical possibilities as\n789         for standard Sphinx roles (see :ref:`xref-syntax`).\n790 \n791         .. versionchanged:: 1.8\n792            Add *override* keyword.\n793         \"\"\"\n794         self.registry.add_object_type(directivename, rolename, indextemplate, parse_node,\n795                                       ref_nodeclass, objname, doc_field_types,\n796                                       override=override)\n797 \n798     def add_crossref_type(self, directivename: str, rolename: str, indextemplate: str = '',\n799                           ref_nodeclass: \"Type[TextElement]\" = None, objname: str = '',\n800                           override: bool = False) -> None:\n801         \"\"\"Register a new crossref object type.\n802 \n803         This method is very similar to :meth:`add_object_type` except that the\n804         directive it generates must be empty, and will produce no output.\n805 \n806         That means that you can add semantic targets to your sources, and refer\n807         to them using custom roles instead of generic ones (like\n808         :rst:role:`ref`).  Example call::\n809 \n810            app.add_crossref_type('topic', 'topic', 'single: %s',\n811                                  docutils.nodes.emphasis)\n812 \n813         Example usage::\n814 \n815            .. topic:: application API\n816 \n817            The application API\n818            -------------------\n819 \n820            Some random text here.\n821 \n822            See also :topic:`this section <application API>`.\n823 \n824         (Of course, the element following the ``topic`` directive needn't be a\n825         section.)\n826 \n827         .. versionchanged:: 1.8\n828            Add *override* keyword.\n829         \"\"\"\n830         self.registry.add_crossref_type(directivename, rolename,\n831                                         indextemplate, ref_nodeclass, objname,\n832                                         override=override)\n833 \n834     def add_transform(self, transform: \"Type[Transform]\") -> None:\n835         \"\"\"Register a Docutils transform to be applied after parsing.\n836 \n837         Add the standard docutils :class:`Transform` subclass *transform* to\n838         the list of transforms that are applied after Sphinx parses a reST\n839         document.\n840 \n841         .. list-table:: priority range categories for Sphinx transforms\n842            :widths: 20,80\n843 \n844            * - Priority\n845              - Main purpose in Sphinx\n846            * - 0-99\n847              - Fix invalid nodes by docutils. Translate a doctree.\n848            * - 100-299\n849              - Preparation\n850            * - 300-399\n851              - early\n852            * - 400-699\n853              - main\n854            * - 700-799\n855              - Post processing. Deadline to modify text and referencing.\n856            * - 800-899\n857              - Collect referencing and referenced nodes. Domain processing.\n858            * - 900-999\n859              - Finalize and clean up.\n860 \n861         refs: `Transform Priority Range Categories`__\n862 \n863         __ http://docutils.sourceforge.net/docs/ref/transforms.html#transform-priority-range-categories\n864         \"\"\"  # NOQA\n865         self.registry.add_transform(transform)\n866 \n867     def add_post_transform(self, transform: \"Type[Transform]\") -> None:\n868         \"\"\"Register a Docutils transform to be applied before writing.\n869 \n870         Add the standard docutils :class:`Transform` subclass *transform* to\n871         the list of transforms that are applied before Sphinx writes a\n872         document.\n873         \"\"\"\n874         self.registry.add_post_transform(transform)\n875 \n876     def add_javascript(self, filename: str, **kwargs: str) -> None:\n877         \"\"\"An alias of :meth:`add_js_file`.\"\"\"\n878         warnings.warn('The app.add_javascript() is deprecated. '\n879                       'Please use app.add_js_file() instead.',\n880                       RemovedInSphinx40Warning, stacklevel=2)\n881         self.add_js_file(filename, **kwargs)\n882 \n883     def add_js_file(self, filename: str, **kwargs: str) -> None:\n884         \"\"\"Register a JavaScript file to include in the HTML output.\n885 \n886         Add *filename* to the list of JavaScript files that the default HTML\n887         template will include.  The filename must be relative to the HTML\n888         static path , or a full URI with scheme.  If the keyword argument\n889         ``body`` is given, its value will be added between the\n890         ``<script>`` tags. Extra keyword arguments are included as\n891         attributes of the ``<script>`` tag.\n892 \n893         Example::\n894 \n895             app.add_js_file('example.js')\n896             # => <script src=\"_static/example.js\"></script>\n897 \n898             app.add_js_file('example.js', async=\"async\")\n899             # => <script src=\"_static/example.js\" async=\"async\"></script>\n900 \n901             app.add_js_file(None, body=\"var myVariable = 'foo';\")\n902             # => <script>var myVariable = 'foo';</script>\n903 \n904         .. versionadded:: 0.5\n905 \n906         .. versionchanged:: 1.8\n907            Renamed from ``app.add_javascript()``.\n908            And it allows keyword arguments as attributes of script tag.\n909         \"\"\"\n910         self.registry.add_js_file(filename, **kwargs)\n911         if hasattr(self.builder, 'add_js_file'):\n912             self.builder.add_js_file(filename, **kwargs)  # type: ignore\n913 \n914     def add_css_file(self, filename: str, **kwargs: str) -> None:\n915         \"\"\"Register a stylesheet to include in the HTML output.\n916 \n917         Add *filename* to the list of CSS files that the default HTML template\n918         will include.  The filename must be relative to the HTML static path,\n919         or a full URI with scheme.  The keyword arguments are also accepted for\n920         attributes of ``<link>`` tag.\n921 \n922         Example::\n923 \n924             app.add_css_file('custom.css')\n925             # => <link rel=\"stylesheet\" href=\"_static/custom.css\" type=\"text/css\" />\n926 \n927             app.add_css_file('print.css', media='print')\n928             # => <link rel=\"stylesheet\" href=\"_static/print.css\"\n929             #          type=\"text/css\" media=\"print\" />\n930 \n931             app.add_css_file('fancy.css', rel='alternate stylesheet', title='fancy')\n932             # => <link rel=\"alternate stylesheet\" href=\"_static/fancy.css\"\n933             #          type=\"text/css\" title=\"fancy\" />\n934 \n935         .. versionadded:: 1.0\n936 \n937         .. versionchanged:: 1.6\n938            Optional ``alternate`` and/or ``title`` attributes can be supplied\n939            with the *alternate* (of boolean type) and *title* (a string)\n940            arguments. The default is no title and *alternate* = ``False``. For\n941            more information, refer to the `documentation\n942            <https://mdn.io/Web/CSS/Alternative_style_sheets>`__.\n943 \n944         .. versionchanged:: 1.8\n945            Renamed from ``app.add_stylesheet()``.\n946            And it allows keyword arguments as attributes of link tag.\n947         \"\"\"\n948         logger.debug('[app] adding stylesheet: %r', filename)\n949         self.registry.add_css_files(filename, **kwargs)\n950         if hasattr(self.builder, 'add_css_file'):\n951             self.builder.add_css_file(filename, **kwargs)  # type: ignore\n952 \n953     def add_stylesheet(self, filename: str, alternate: bool = False, title: str = None\n954                        ) -> None:\n955         \"\"\"An alias of :meth:`add_css_file`.\"\"\"\n956         warnings.warn('The app.add_stylesheet() is deprecated. '\n957                       'Please use app.add_css_file() instead.',\n958                       RemovedInSphinx40Warning, stacklevel=2)\n959 \n960         attributes = {}  # type: Dict[str, str]\n961         if alternate:\n962             attributes['rel'] = 'alternate stylesheet'\n963         else:\n964             attributes['rel'] = 'stylesheet'\n965 \n966         if title:\n967             attributes['title'] = title\n968 \n969         self.add_css_file(filename, **attributes)\n970 \n971     def add_latex_package(self, packagename: str, options: str = None,\n972                           after_hyperref: bool = False) -> None:\n973         r\"\"\"Register a package to include in the LaTeX source code.\n974 \n975         Add *packagename* to the list of packages that LaTeX source code will\n976         include.  If you provide *options*, it will be taken to `\\usepackage`\n977         declaration.  If you set *after_hyperref* truthy, the package will be\n978         loaded after ``hyperref`` package.\n979 \n980         .. code-block:: python\n981 \n982            app.add_latex_package('mypackage')\n983            # => \\usepackage{mypackage}\n984            app.add_latex_package('mypackage', 'foo,bar')\n985            # => \\usepackage[foo,bar]{mypackage}\n986 \n987         .. versionadded:: 1.3\n988         .. versionadded:: 3.1\n989 \n990            *after_hyperref* option.\n991         \"\"\"\n992         self.registry.add_latex_package(packagename, options, after_hyperref)\n993 \n994     def add_lexer(self, alias: str, lexer: Union[Lexer, \"Type[Lexer]\"]) -> None:\n995         \"\"\"Register a new lexer for source code.\n996 \n997         Use *lexer* to highlight code blocks with the given language *alias*.\n998 \n999         .. versionadded:: 0.6\n1000         .. versionchanged:: 2.1\n1001            Take a lexer class as an argument.  An instance of lexers are\n1002            still supported until Sphinx-3.x.\n1003         \"\"\"\n1004         logger.debug('[app] adding lexer: %r', (alias, lexer))\n1005         if isinstance(lexer, Lexer):\n1006             warnings.warn('app.add_lexer() API changed; '\n1007                           'Please give lexer class instead instance',\n1008                           RemovedInSphinx40Warning, stacklevel=2)\n1009             lexers[alias] = lexer\n1010         else:\n1011             lexer_classes[alias] = lexer\n1012 \n1013     def add_autodocumenter(self, cls: Any, override: bool = False) -> None:\n1014         \"\"\"Register a new documenter class for the autodoc extension.\n1015 \n1016         Add *cls* as a new documenter class for the :mod:`sphinx.ext.autodoc`\n1017         extension.  It must be a subclass of\n1018         :class:`sphinx.ext.autodoc.Documenter`.  This allows to auto-document\n1019         new types of objects.  See the source of the autodoc module for\n1020         examples on how to subclass :class:`Documenter`.\n1021 \n1022         .. todo:: Add real docs for Documenter and subclassing\n1023 \n1024         .. versionadded:: 0.6\n1025         .. versionchanged:: 2.2\n1026            Add *override* keyword.\n1027         \"\"\"\n1028         logger.debug('[app] adding autodocumenter: %r', cls)\n1029         from sphinx.ext.autodoc.directive import AutodocDirective\n1030         self.registry.add_documenter(cls.objtype, cls)\n1031         self.add_directive('auto' + cls.objtype, AutodocDirective, override=override)\n1032 \n1033     def add_autodoc_attrgetter(self, typ: \"Type\", getter: Callable[[Any, str, Any], Any]\n1034                                ) -> None:\n1035         \"\"\"Register a new ``getattr``-like function for the autodoc extension.\n1036 \n1037         Add *getter*, which must be a function with an interface compatible to\n1038         the :func:`getattr` builtin, as the autodoc attribute getter for\n1039         objects that are instances of *typ*.  All cases where autodoc needs to\n1040         get an attribute of a type are then handled by this function instead of\n1041         :func:`getattr`.\n1042 \n1043         .. versionadded:: 0.6\n1044         \"\"\"\n1045         logger.debug('[app] adding autodoc attrgetter: %r', (typ, getter))\n1046         self.registry.add_autodoc_attrgetter(typ, getter)\n1047 \n1048     def add_search_language(self, cls: Any) -> None:\n1049         \"\"\"Register a new language for the HTML search index.\n1050 \n1051         Add *cls*, which must be a subclass of\n1052         :class:`sphinx.search.SearchLanguage`, as a support language for\n1053         building the HTML full-text search index.  The class must have a *lang*\n1054         attribute that indicates the language it should be used for.  See\n1055         :confval:`html_search_language`.\n1056 \n1057         .. versionadded:: 1.1\n1058         \"\"\"\n1059         logger.debug('[app] adding search language: %r', cls)\n1060         from sphinx.search import languages, SearchLanguage\n1061         assert issubclass(cls, SearchLanguage)\n1062         languages[cls.lang] = cls\n1063 \n1064     def add_source_suffix(self, suffix: str, filetype: str, override: bool = False) -> None:\n1065         \"\"\"Register a suffix of source files.\n1066 \n1067         Same as :confval:`source_suffix`.  The users can override this\n1068         using the setting.\n1069 \n1070         .. versionadded:: 1.8\n1071         \"\"\"\n1072         self.registry.add_source_suffix(suffix, filetype, override=override)\n1073 \n1074     def add_source_parser(self, *args: Any, **kwargs: Any) -> None:\n1075         \"\"\"Register a parser class.\n1076 \n1077         .. versionadded:: 1.4\n1078         .. versionchanged:: 1.8\n1079            *suffix* argument is deprecated.  It only accepts *parser* argument.\n1080            Use :meth:`add_source_suffix` API to register suffix instead.\n1081         .. versionchanged:: 1.8\n1082            Add *override* keyword.\n1083         \"\"\"\n1084         self.registry.add_source_parser(*args, **kwargs)\n1085 \n1086     def add_env_collector(self, collector: \"Type[EnvironmentCollector]\") -> None:\n1087         \"\"\"Register an environment collector class.\n1088 \n1089         Refer to :ref:`collector-api`.\n1090 \n1091         .. versionadded:: 1.6\n1092         \"\"\"\n1093         logger.debug('[app] adding environment collector: %r', collector)\n1094         collector().enable(self)\n1095 \n1096     def add_html_theme(self, name: str, theme_path: str) -> None:\n1097         \"\"\"Register a HTML Theme.\n1098 \n1099         The *name* is a name of theme, and *path* is a full path to the theme\n1100         (refs: :ref:`distribute-your-theme`).\n1101 \n1102         .. versionadded:: 1.6\n1103         \"\"\"\n1104         logger.debug('[app] adding HTML theme: %r, %r', name, theme_path)\n1105         self.html_themes[name] = theme_path\n1106 \n1107     def add_html_math_renderer(self, name: str,\n1108                                inline_renderers: Tuple[Callable, Callable] = None,\n1109                                block_renderers: Tuple[Callable, Callable] = None) -> None:\n1110         \"\"\"Register a math renderer for HTML.\n1111 \n1112         The *name* is a name of math renderer.  Both *inline_renderers* and\n1113         *block_renderers* are used as visitor functions for the HTML writer:\n1114         the former for inline math node (``nodes.math``), the latter for\n1115         block math node (``nodes.math_block``).  Regarding visitor functions,\n1116         see :meth:`add_node` for details.\n1117 \n1118         .. versionadded:: 1.8\n1119 \n1120         \"\"\"\n1121         self.registry.add_html_math_renderer(name, inline_renderers, block_renderers)\n1122 \n1123     def add_message_catalog(self, catalog: str, locale_dir: str) -> None:\n1124         \"\"\"Register a message catalog.\n1125 \n1126         The *catalog* is a name of catalog, and *locale_dir* is a base path\n1127         of message catalog.  For more details, see\n1128         :func:`sphinx.locale.get_translation()`.\n1129 \n1130         .. versionadded:: 1.8\n1131         \"\"\"\n1132         locale.init([locale_dir], self.config.language, catalog)\n1133         locale.init_console(locale_dir, catalog)\n1134 \n1135     # ---- other methods -------------------------------------------------\n1136     def is_parallel_allowed(self, typ: str) -> bool:\n1137         \"\"\"Check parallel processing is allowed or not.\n1138 \n1139         ``typ`` is a type of processing; ``'read'`` or ``'write'``.\n1140         \"\"\"\n1141         if typ == 'read':\n1142             attrname = 'parallel_read_safe'\n1143             message_not_declared = __(\"the %s extension does not declare if it \"\n1144                                       \"is safe for parallel reading, assuming \"\n1145                                       \"it isn't - please ask the extension author \"\n1146                                       \"to check and make it explicit\")\n1147             message_not_safe = __(\"the %s extension is not safe for parallel reading\")\n1148         elif typ == 'write':\n1149             attrname = 'parallel_write_safe'\n1150             message_not_declared = __(\"the %s extension does not declare if it \"\n1151                                       \"is safe for parallel writing, assuming \"\n1152                                       \"it isn't - please ask the extension author \"\n1153                                       \"to check and make it explicit\")\n1154             message_not_safe = __(\"the %s extension is not safe for parallel writing\")\n1155         else:\n1156             raise ValueError('parallel type %s is not supported' % typ)\n1157 \n1158         for ext in self.extensions.values():\n1159             allowed = getattr(ext, attrname, None)\n1160             if allowed is None:\n1161                 logger.warning(message_not_declared, ext.name)\n1162                 logger.warning(__('doing serial %s'), typ)\n1163                 return False\n1164             elif not allowed:\n1165                 logger.warning(message_not_safe, ext.name)\n1166                 logger.warning(__('doing serial %s'), typ)\n1167                 return False\n1168 \n1169         return True\n1170 \n1171 \n1172 class TemplateBridge:\n1173     \"\"\"\n1174     This class defines the interface for a \"template bridge\", that is, a class\n1175     that renders templates given a template name and a context.\n1176     \"\"\"\n1177 \n1178     def init(self, builder: \"Builder\", theme: Theme = None, dirs: List[str] = None) -> None:\n1179         \"\"\"Called by the builder to initialize the template system.\n1180 \n1181         *builder* is the builder object; you'll probably want to look at the\n1182         value of ``builder.config.templates_path``.\n1183 \n1184         *theme* is a :class:`sphinx.theming.Theme` object or None; in the latter\n1185         case, *dirs* can be list of fixed directories to look for templates.\n1186         \"\"\"\n1187         raise NotImplementedError('must be implemented in subclasses')\n1188 \n1189     def newest_template_mtime(self) -> float:\n1190         \"\"\"Called by the builder to determine if output files are outdated\n1191         because of template changes.  Return the mtime of the newest template\n1192         file that was changed.  The default implementation returns ``0``.\n1193         \"\"\"\n1194         return 0\n1195 \n1196     def render(self, template: str, context: Dict) -> None:\n1197         \"\"\"Called by the builder to render a template given as a filename with\n1198         a specified context (a Python dictionary).\n1199         \"\"\"\n1200         raise NotImplementedError('must be implemented in subclasses')\n1201 \n1202     def render_string(self, template: str, context: Dict) -> str:\n1203         \"\"\"Called by the builder to render a template given as a string with a\n1204         specified context (a Python dictionary).\n1205         \"\"\"\n1206         raise NotImplementedError('must be implemented in subclasses')\n",
        "intended_behavior": "In a file or class responsible for translating index entries into HTML elements, ensure that the logic recognizing and creating sections for 'Symbols' is capable of identifying and consolidating all symbol entries into one section. This might involve adjusting how sections are defined and anchored in the HTML document to prevent duplication. For instance, a method responsible for generating section headers or anchors for the HTML output needs validation to ensure that symbols are not creating additional unintended sections. This validation might include a pre-check on index categories to ensure uniqueness and consolidation of symbol entries, or a post-processing step to merge sections that are erroneously divided."
    }
]