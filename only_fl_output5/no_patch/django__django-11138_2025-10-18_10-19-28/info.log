2025-10-18 10:19:28.344 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-18 10:19:30.906 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=976, output_tokens=12, cost=0.010120
2025-10-18 10:19:46.310 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1156, output_tokens=705, cost=0.032710
2025-10-18 10:19:47.492 | INFO     | registered non reproducing test 0
2025-10-18 10:20:07.163 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2636, output_tokens=801, cost=0.050390
2025-10-18 10:20:08.271 | INFO     | registered non reproducing test 1
2025-10-18 10:20:28.030 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2487, output_tokens=813, cost=0.049260
2025-10-18 10:20:29.134 | INFO     | registered non reproducing test 2
2025-10-18 10:20:29.134 | WARNING  | Failed to write a reproducer test; skipping reproducer tracing
2025-10-18 10:20:29.140 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 10:20:39.880 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1259, output_tokens=418, cost=0.025130
2025-10-18 10:20:39.888 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 10:20:42.863 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=772, output_tokens=60, cost=0.009520
2025-10-18 10:20:42.864 | INFO     | Refactored invocation argument parsing gives different result on 'get_code_around_line("django/db/backends/mysql/operations.py", 49, 10)': old result is ['django/db/backends/mysql/operations.py', '49', '10'], new result  is ['django/db/backends/mysql/operations.py', 49, 10]
2025-10-18 10:20:42.865 | DEBUG    | Extracted a valid json.
2025-10-18 10:20:42.865 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_code(\"CONVERT_TZ\")",
        "get_code_around_line(\"django/db/backends/mysql/operations.py\", 49, 10)",
        "search_method(\"convert_tz\")"
    ],
    "bug_locations": []
}
2025-10-18 10:20:42.895 | INFO     | Refactored invocation argument parsing gives different result on 'get_code_around_line("django/db/backends/mysql/operations.py", 49, 10)': old result is ['django/db/backends/mysql/operations.py', '49', '10'], new result  is ['django/db/backends/mysql/operations.py', 49, 10]
2025-10-18 10:20:42.909 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-18 10:20:42.909 | DEBUG    | <Agent search> Analyzing search results.
2025-10-18 10:21:01.306 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2305, output_tokens=893, cost=0.049840
2025-10-18 10:21:01.323 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 10:21:09.097 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=3414, output_tokens=264, cost=0.042060
2025-10-18 10:21:09.103 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 10:21:14.069 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=618, output_tokens=178, cost=0.011520
2025-10-18 10:21:14.070 | DEBUG    | Extracted a valid json.
2025-10-18 10:21:14.076 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations":[{"file": "django/db/backends/mysql/operations.py", "class": "DatabaseOperations", "method": "_convert_field_to_tz", "intended_behavior": "This method should be updated to consider when the database's `TIME_ZONE` setting matches Django's global `TIME_ZONE` setting. In such cases, the method should avoid using `CONVERT_TZ` for timezone conversion if the database and Django settings align, to prevent unnecessary conversions. Effectively, it should only apply `CONVERT_TZ` when the database's timezone differs from the Django application's timezone. This would involve first checking if `settings.TIME_ZONE` matches DATABASES['default']['TIME_ZONE'], and if so, bypassing the `CONVERT_TZ` operation or adjusting the parameters to reflect an intra-timezone conversion."}]
}
2025-10-18 10:21:14.085 | DEBUG    | Bug location extracted successfully: [<file>django/db/backends/oracle/operations.py</file>
<class>DatabaseOperations</class>
<method>_convert_field_to_tz</method>
<code>
97     def _convert_field_to_tz(self, field_name, tzname):
98         if not settings.USE_TZ:
99             return field_name
100         if not self._tzname_re.match(tzname):
101             raise ValueError("Invalid time zone name: %s" % tzname)
102         # Convert from UTC to local time, returning TIMESTAMP WITH TIME ZONE
103         # and cast it back to TIMESTAMP to strip the TIME ZONE details.
104         return "CAST((FROM_TZ(%s, '0:00') AT TIME ZONE '%s') AS TIMESTAMP)" % (field_name, tzname)

</code><intended_behavior>This method should be updated to consider when the database's `TIME_ZONE` setting matches Django's global `TIME_ZONE` setting. In such cases, the method should avoid using `CONVERT_TZ` for timezone conversion if the database and Django settings align, to prevent unnecessary conversions. Effectively, it should only apply `CONVERT_TZ` when the database's timezone differs from the Django application's timezone. This would involve first checking if `settings.TIME_ZONE` matches DATABASES['default']['TIME_ZONE'], and if so, bypassing the `CONVERT_TZ` operation or adjusting the parameters to reflect an intra-timezone conversion.</intended_behavior>, <file>django/db/backends/postgresql/operations.py</file>
<class>DatabaseOperations</class>
<method>_convert_field_to_tz</method>
<code>
43     def _convert_field_to_tz(self, field_name, tzname):
44         if settings.USE_TZ:
45             field_name = "%s AT TIME ZONE '%s'" % (field_name, tzname)
46         return field_name

</code><intended_behavior>This method should be updated to consider when the database's `TIME_ZONE` setting matches Django's global `TIME_ZONE` setting. In such cases, the method should avoid using `CONVERT_TZ` for timezone conversion if the database and Django settings align, to prevent unnecessary conversions. Effectively, it should only apply `CONVERT_TZ` when the database's timezone differs from the Django application's timezone. This would involve first checking if `settings.TIME_ZONE` matches DATABASES['default']['TIME_ZONE'], and if so, bypassing the `CONVERT_TZ` operation or adjusting the parameters to reflect an intra-timezone conversion.</intended_behavior>, <file>django/db/backends/mysql/operations.py</file>
<class>DatabaseOperations</class>
<method>_convert_field_to_tz</method>
<code>
71     def _convert_field_to_tz(self, field_name, tzname):
72         if settings.USE_TZ:
73             field_name = "CONVERT_TZ(%s, 'UTC', '%s')" % (field_name, tzname)
74         return field_name

</code><intended_behavior>This method should be updated to consider when the database's `TIME_ZONE` setting matches Django's global `TIME_ZONE` setting. In such cases, the method should avoid using `CONVERT_TZ` for timezone conversion if the database and Django settings align, to prevent unnecessary conversions. Effectively, it should only apply `CONVERT_TZ` when the database's timezone differs from the Django application's timezone. This would involve first checking if `settings.TIME_ZONE` matches DATABASES['default']['TIME_ZONE'], and if so, bypassing the `CONVERT_TZ` operation or adjusting the parameters to reflect an intra-timezone conversion.</intended_behavior>, <file>django/db/backends/oracle/operations.py</file>
<class>DatabaseOperations</class>
<method>None</method>
<code>
18 class DatabaseOperations(BaseDatabaseOperations):
19     # Oracle uses NUMBER(11) and NUMBER(19) for integer fields.
20     integer_field_ranges = {
21         'SmallIntegerField': (-99999999999, 99999999999),
22         'IntegerField': (-99999999999, 99999999999),
23         'BigIntegerField': (-9999999999999999999, 9999999999999999999),
24         'PositiveSmallIntegerField': (0, 99999999999),
25         'PositiveIntegerField': (0, 99999999999),
26     }
27     set_operators = {**BaseDatabaseOperations.set_operators, 'difference': 'MINUS'}
28 
29     # TODO: colorize this SQL code with style.SQL_KEYWORD(), etc.
30     _sequence_reset_sql = """
31 DECLARE
32     table_value integer;
33     seq_value integer;
34     seq_name user_tab_identity_cols.sequence_name%%TYPE;
35 BEGIN
36     BEGIN
37         SELECT sequence_name INTO seq_name FROM user_tab_identity_cols
38         WHERE  table_name = '%(table_name)s' AND
39                column_name = '%(column_name)s';
40         EXCEPTION WHEN NO_DATA_FOUND THEN
41             seq_name := '%(no_autofield_sequence_name)s';
42     END;
43 
44     SELECT NVL(MAX(%(column)s), 0) INTO table_value FROM %(table)s;
45     SELECT NVL(last_number - cache_size, 0) INTO seq_value FROM user_sequences
46            WHERE sequence_name = seq_name;
47     WHILE table_value > seq_value LOOP
48         EXECUTE IMMEDIATE 'SELECT "'||seq_name||'".nextval FROM DUAL'
49         INTO seq_value;
50     END LOOP;
51 END;
52 /"""
53 
54     # Oracle doesn't support string without precision; use the max string size.
55     cast_char_field_without_max_length = 'NVARCHAR2(2000)'
56     cast_data_types = {
57         'AutoField': 'NUMBER(11)',
58         'BigAutoField': 'NUMBER(19)',
59         'TextField': cast_char_field_without_max_length,
60     }
61 
62     def cache_key_culling_sql(self):
63         return 'SELECT cache_key FROM %s ORDER BY cache_key OFFSET %%s ROWS FETCH FIRST 1 ROWS ONLY'
64 
65     def date_extract_sql(self, lookup_type, field_name):
66         if lookup_type == 'week_day':
67             # TO_CHAR(field, 'D') returns an integer from 1-7, where 1=Sunday.
68             return "TO_CHAR(%s, 'D')" % field_name
69         elif lookup_type == 'week':
70             # IW = ISO week number
71             return "TO_CHAR(%s, 'IW')" % field_name
72         elif lookup_type == 'quarter':
73             return "TO_CHAR(%s, 'Q')" % field_name
74         elif lookup_type == 'iso_year':
75             return "TO_CHAR(%s, 'IYYY')" % field_name
76         else:
77             # https://docs.oracle.com/en/database/oracle/oracle-database/18/sqlrf/EXTRACT-datetime.html
78             return "EXTRACT(%s FROM %s)" % (lookup_type.upper(), field_name)
79 
80     def date_trunc_sql(self, lookup_type, field_name):
81         # https://docs.oracle.com/en/database/oracle/oracle-database/18/sqlrf/ROUND-and-TRUNC-Date-Functions.html
82         if lookup_type in ('year', 'month'):
83             return "TRUNC(%s, '%s')" % (field_name, lookup_type.upper())
84         elif lookup_type == 'quarter':
85             return "TRUNC(%s, 'Q')" % field_name
86         elif lookup_type == 'week':
87             return "TRUNC(%s, 'IW')" % field_name
88         else:
89             return "TRUNC(%s)" % field_name
90 
91     # Oracle crashes with "ORA-03113: end-of-file on communication channel"
92     # if the time zone name is passed in parameter. Use interpolation instead.
93     # https://groups.google.com/forum/#!msg/django-developers/zwQju7hbG78/9l934yelwfsJ
94     # This regexp matches all time zone names from the zoneinfo database.
95     _tzname_re = re.compile(r'^[\w/:+-]+$')
96 
97     def _convert_field_to_tz(self, field_name, tzname):
98         if not settings.USE_TZ:
99             return field_name
100         if not self._tzname_re.match(tzname):
101             raise ValueError("Invalid time zone name: %s" % tzname)
102         # Convert from UTC to local time, returning TIMESTAMP WITH TIME ZONE
103         # and cast it back to TIMESTAMP to strip the TIME ZONE details.
104         return "CAST((FROM_TZ(%s, '0:00') AT TIME ZONE '%s') AS TIMESTAMP)" % (field_name, tzname)
105 
106     def datetime_cast_date_sql(self, field_name, tzname):
107         field_name = self._convert_field_to_tz(field_name, tzname)
108         return 'TRUNC(%s)' % field_name
109 
110     def datetime_cast_time_sql(self, field_name, tzname):
111         # Since `TimeField` values are stored as TIMESTAMP where only the date
112         # part is ignored, convert the field to the specified timezone.
113         return self._convert_field_to_tz(field_name, tzname)
114 
115     def datetime_extract_sql(self, lookup_type, field_name, tzname):
116         field_name = self._convert_field_to_tz(field_name, tzname)
117         return self.date_extract_sql(lookup_type, field_name)
118 
119     def datetime_trunc_sql(self, lookup_type, field_name, tzname):
120         field_name = self._convert_field_to_tz(field_name, tzname)
121         # https://docs.oracle.com/en/database/oracle/oracle-database/18/sqlrf/ROUND-and-TRUNC-Date-Functions.html
122         if lookup_type in ('year', 'month'):
123             sql = "TRUNC(%s, '%s')" % (field_name, lookup_type.upper())
124         elif lookup_type == 'quarter':
125             sql = "TRUNC(%s, 'Q')" % field_name
126         elif lookup_type == 'week':
127             sql = "TRUNC(%s, 'IW')" % field_name
128         elif lookup_type == 'day':
129             sql = "TRUNC(%s)" % field_name
130         elif lookup_type == 'hour':
131             sql = "TRUNC(%s, 'HH24')" % field_name
132         elif lookup_type == 'minute':
133             sql = "TRUNC(%s, 'MI')" % field_name
134         else:
135             sql = "CAST(%s AS DATE)" % field_name  # Cast to DATE removes sub-second precision.
136         return sql
137 
138     def time_trunc_sql(self, lookup_type, field_name):
139         # The implementation is similar to `datetime_trunc_sql` as both
140         # `DateTimeField` and `TimeField` are stored as TIMESTAMP where
141         # the date part of the later is ignored.
142         if lookup_type == 'hour':
143             sql = "TRUNC(%s, 'HH24')" % field_name
144         elif lookup_type == 'minute':
145             sql = "TRUNC(%s, 'MI')" % field_name
146         elif lookup_type == 'second':
147             sql = "CAST(%s AS DATE)" % field_name  # Cast to DATE removes sub-second precision.
148         return sql
149 
150     def get_db_converters(self, expression):
151         converters = super().get_db_converters(expression)
152         internal_type = expression.output_field.get_internal_type()
153         if internal_type == 'TextField':
154             converters.append(self.convert_textfield_value)
155         elif internal_type == 'BinaryField':
156             converters.append(self.convert_binaryfield_value)
157         elif internal_type in ['BooleanField', 'NullBooleanField']:
158             converters.append(self.convert_booleanfield_value)
159         elif internal_type == 'DateTimeField':
160             if settings.USE_TZ:
161                 converters.append(self.convert_datetimefield_value)
162         elif internal_type == 'DateField':
163             converters.append(self.convert_datefield_value)
164         elif internal_type == 'TimeField':
165             converters.append(self.convert_timefield_value)
166         elif internal_type == 'UUIDField':
167             converters.append(self.convert_uuidfield_value)
168         # Oracle stores empty strings as null. If the field accepts the empty
169         # string, undo this to adhere to the Django convention of using
170         # the empty string instead of null.
171         if expression.field.empty_strings_allowed:
172             converters.append(
173                 self.convert_empty_bytes
174                 if internal_type == 'BinaryField' else
175                 self.convert_empty_string
176             )
177         return converters
178 
179     def convert_textfield_value(self, value, expression, connection):
180         if isinstance(value, Database.LOB):
181             value = value.read()
182         return value
183 
184     def convert_binaryfield_value(self, value, expression, connection):
185         if isinstance(value, Database.LOB):
186             value = force_bytes(value.read())
187         return value
188 
189     def convert_booleanfield_value(self, value, expression, connection):
190         if value in (0, 1):
191             value = bool(value)
192         return value
193 
194     # cx_Oracle always returns datetime.datetime objects for
195     # DATE and TIMESTAMP columns, but Django wants to see a
196     # python datetime.date, .time, or .datetime.
197 
198     def convert_datetimefield_value(self, value, expression, connection):
199         if value is not None:
200             value = timezone.make_aware(value, self.connection.timezone)
201         return value
202 
203     def convert_datefield_value(self, value, expression, connection):
204         if isinstance(value, Database.Timestamp):
205             value = value.date()
206         return value
207 
208     def convert_timefield_value(self, value, expression, connection):
209         if isinstance(value, Database.Timestamp):
210             value = value.time()
211         return value
212 
213     def convert_uuidfield_value(self, value, expression, connection):
214         if value is not None:
215             value = uuid.UUID(value)
216         return value
217 
218     @staticmethod
219     def convert_empty_string(value, expression, connection):
220         return '' if value is None else value
221 
222     @staticmethod
223     def convert_empty_bytes(value, expression, connection):
224         return b'' if value is None else value
225 
226     def deferrable_sql(self):
227         return " DEFERRABLE INITIALLY DEFERRED"
228 
229     def fetch_returned_insert_id(self, cursor):
230         value = cursor._insert_id_var.getvalue()
231         if value is None or value == []:
232             # cx_Oracle < 6.3 returns None, >= 6.3 returns empty list.
233             raise DatabaseError(
234                 'The database did not return a new row id. Probably "ORA-1403: '
235                 'no data found" was raised internally but was hidden by the '
236                 'Oracle OCI library (see https://code.djangoproject.com/ticket/28859).'
237             )
238         # cx_Oracle < 7 returns value, >= 7 returns list with single value.
239         return value[0] if isinstance(value, list) else value
240 
241     def field_cast_sql(self, db_type, internal_type):
242         if db_type and db_type.endswith('LOB'):
243             return "DBMS_LOB.SUBSTR(%s)"
244         else:
245             return "%s"
246 
247     def no_limit_value(self):
248         return None
249 
250     def limit_offset_sql(self, low_mark, high_mark):
251         fetch, offset = self._get_limit_offset_params(low_mark, high_mark)
252         return ' '.join(sql for sql in (
253             ('OFFSET %d ROWS' % offset) if offset else None,
254             ('FETCH FIRST %d ROWS ONLY' % fetch) if fetch else None,
255         ) if sql)
256 
257     def last_executed_query(self, cursor, sql, params):
258         # https://cx-oracle.readthedocs.io/en/latest/cursor.html#Cursor.statement
259         # The DB API definition does not define this attribute.
260         statement = cursor.statement
261         # Unlike Psycopg's `query` and MySQLdb`'s `_executed`, cx_Oracle's
262         # `statement` doesn't contain the query parameters. Substitute
263         # parameters manually.
264         if isinstance(params, (tuple, list)):
265             for i, param in enumerate(params):
266                 statement = statement.replace(':arg%d' % i, force_str(param, errors='replace'))
267         elif isinstance(params, dict):
268             for key, param in params.items():
269                 statement = statement.replace(':%s' % key, force_str(param, errors='replace'))
270         return statement
271 
272     def last_insert_id(self, cursor, table_name, pk_name):
273         sq_name = self._get_sequence_name(cursor, strip_quotes(table_name), pk_name)
274         cursor.execute('"%s".currval' % sq_name)
275         return cursor.fetchone()[0]
276 
277     def lookup_cast(self, lookup_type, internal_type=None):
278         if lookup_type in ('iexact', 'icontains', 'istartswith', 'iendswith'):
279             return "UPPER(%s)"
280         return "%s"
281 
282     def max_in_list_size(self):
283         return 1000
284 
285     def max_name_length(self):
286         return 30
287 
288     def pk_default_value(self):
289         return "NULL"
290 
291     def prep_for_iexact_query(self, x):
292         return x
293 
294     def process_clob(self, value):
295         if value is None:
296             return ''
297         return value.read()
298 
299     def quote_name(self, name):
300         # SQL92 requires delimited (quoted) names to be case-sensitive.  When
301         # not quoted, Oracle has case-insensitive behavior for identifiers, but
302         # always defaults to uppercase.
303         # We simplify things by making Oracle identifiers always uppercase.
304         if not name.startswith('"') and not name.endswith('"'):
305             name = '"%s"' % truncate_name(name.upper(), self.max_name_length())
306         # Oracle puts the query text into a (query % args) construct, so % signs
307         # in names need to be escaped. The '%%' will be collapsed back to '%' at
308         # that stage so we aren't really making the name longer here.
309         name = name.replace('%', '%%')
310         return name.upper()
311 
312     def random_function_sql(self):
313         return "DBMS_RANDOM.RANDOM"
314 
315     def regex_lookup(self, lookup_type):
316         if lookup_type == 'regex':
317             match_option = "'c'"
318         else:
319             match_option = "'i'"
320         return 'REGEXP_LIKE(%%s, %%s, %s)' % match_option
321 
322     def return_insert_id(self):
323         return "RETURNING %s INTO %%s", (InsertIdVar(),)
324 
325     def __foreign_key_constraints(self, table_name, recursive):
326         with self.connection.cursor() as cursor:
327             if recursive:
328                 cursor.execute("""
329                     SELECT
330                         user_tables.table_name, rcons.constraint_name
331                     FROM
332                         user_tables
333                     JOIN
334                         user_constraints cons
335                         ON (user_tables.table_name = cons.table_name AND cons.constraint_type = ANY('P', 'U'))
336                     LEFT JOIN
337                         user_constraints rcons
338                         ON (user_tables.table_name = rcons.table_name AND rcons.constraint_type = 'R')
339                     START WITH user_tables.table_name = UPPER(%s)
340                     CONNECT BY NOCYCLE PRIOR cons.constraint_name = rcons.r_constraint_name
341                     GROUP BY
342                         user_tables.table_name, rcons.constraint_name
343                     HAVING user_tables.table_name != UPPER(%s)
344                     ORDER BY MAX(level) DESC
345                 """, (table_name, table_name))
346             else:
347                 cursor.execute("""
348                     SELECT
349                         cons.table_name, cons.constraint_name
350                     FROM
351                         user_constraints cons
352                     WHERE
353                         cons.constraint_type = 'R'
354                         AND cons.table_name = UPPER(%s)
355                 """, (table_name,))
356             return cursor.fetchall()
357 
358     @cached_property
359     def _foreign_key_constraints(self):
360         # 512 is large enough to fit the ~330 tables (as of this writing) in
361         # Django's test suite.
362         return lru_cache(maxsize=512)(self.__foreign_key_constraints)
363 
364     def sql_flush(self, style, tables, sequences, allow_cascade=False):
365         if tables:
366             truncated_tables = {table.upper() for table in tables}
367             constraints = set()
368             # Oracle's TRUNCATE CASCADE only works with ON DELETE CASCADE
369             # foreign keys which Django doesn't define. Emulate the
370             # PostgreSQL behavior which truncates all dependent tables by
371             # manually retrieving all foreign key constraints and resolving
372             # dependencies.
373             for table in tables:
374                 for foreign_table, constraint in self._foreign_key_constraints(table, recursive=allow_cascade):
375                     if allow_cascade:
376                         truncated_tables.add(foreign_table)
377                     constraints.add((foreign_table, constraint))
378             sql = [
379                 "%s %s %s %s %s %s %s %s;" % (
380                     style.SQL_KEYWORD('ALTER'),
381                     style.SQL_KEYWORD('TABLE'),
382                     style.SQL_FIELD(self.quote_name(table)),
383                     style.SQL_KEYWORD('DISABLE'),
384                     style.SQL_KEYWORD('CONSTRAINT'),
385                     style.SQL_FIELD(self.quote_name(constraint)),
386                     style.SQL_KEYWORD('KEEP'),
387                     style.SQL_KEYWORD('INDEX'),
388                 ) for table, constraint in constraints
389             ] + [
390                 "%s %s %s;" % (
391                     style.SQL_KEYWORD('TRUNCATE'),
392                     style.SQL_KEYWORD('TABLE'),
393                     style.SQL_FIELD(self.quote_name(table)),
394                 ) for table in truncated_tables
395             ] + [
396                 "%s %s %s %s %s %s;" % (
397                     style.SQL_KEYWORD('ALTER'),
398                     style.SQL_KEYWORD('TABLE'),
399                     style.SQL_FIELD(self.quote_name(table)),
400                     style.SQL_KEYWORD('ENABLE'),
401                     style.SQL_KEYWORD('CONSTRAINT'),
402                     style.SQL_FIELD(self.quote_name(constraint)),
403                 ) for table, constraint in constraints
404             ]
405             # Since we've just deleted all the rows, running our sequence
406             # ALTER code will reset the sequence to 0.
407             sql.extend(self.sequence_reset_by_name_sql(style, sequences))
408             return sql
409         else:
410             return []
411 
412     def sequence_reset_by_name_sql(self, style, sequences):
413         sql = []
414         for sequence_info in sequences:
415             no_autofield_sequence_name = self._get_no_autofield_sequence_name(sequence_info['table'])
416             table = self.quote_name(sequence_info['table'])
417             column = self.quote_name(sequence_info['column'] or 'id')
418             query = self._sequence_reset_sql % {
419                 'no_autofield_sequence_name': no_autofield_sequence_name,
420                 'table': table,
421                 'column': column,
422                 'table_name': strip_quotes(table),
423                 'column_name': strip_quotes(column),
424             }
425             sql.append(query)
426         return sql
427 
428     def sequence_reset_sql(self, style, model_list):
429         from django.db import models
430         output = []
431         query = self._sequence_reset_sql
432         for model in model_list:
433             for f in model._meta.local_fields:
434                 if isinstance(f, models.AutoField):
435                     no_autofield_sequence_name = self._get_no_autofield_sequence_name(model._meta.db_table)
436                     table = self.quote_name(model._meta.db_table)
437                     column = self.quote_name(f.column)
438                     output.append(query % {
439                         'no_autofield_sequence_name': no_autofield_sequence_name,
440                         'table': table,
441                         'column': column,
442                         'table_name': strip_quotes(table),
443                         'column_name': strip_quotes(column),
444                     })
445                     # Only one AutoField is allowed per model, so don't
446                     # continue to loop
447                     break
448             for f in model._meta.many_to_many:
449                 if not f.remote_field.through:
450                     no_autofield_sequence_name = self._get_no_autofield_sequence_name(f.m2m_db_table())
451                     table = self.quote_name(f.m2m_db_table())
452                     column = self.quote_name('id')
453                     output.append(query % {
454                         'no_autofield_sequence_name': no_autofield_sequence_name,
455                         'table': table,
456                         'column': column,
457                         'table_name': strip_quotes(table),
458                         'column_name': 'ID',
459                     })
460         return output
461 
462     def start_transaction_sql(self):
463         return ''
464 
465     def tablespace_sql(self, tablespace, inline=False):
466         if inline:
467             return "USING INDEX TABLESPACE %s" % self.quote_name(tablespace)
468         else:
469             return "TABLESPACE %s" % self.quote_name(tablespace)
470 
471     def adapt_datefield_value(self, value):
472         """
473         Transform a date value to an object compatible with what is expected
474         by the backend driver for date columns.
475         The default implementation transforms the date to text, but that is not
476         necessary for Oracle.
477         """
478         return value
479 
480     def adapt_datetimefield_value(self, value):
481         """
482         Transform a datetime value to an object compatible with what is expected
483         by the backend driver for datetime columns.
484 
485         If naive datetime is passed assumes that is in UTC. Normally Django
486         models.DateTimeField makes sure that if USE_TZ is True passed datetime
487         is timezone aware.
488         """
489 
490         if value is None:
491             return None
492 
493         # Expression values are adapted by the database.
494         if hasattr(value, 'resolve_expression'):
495             return value
496 
497         # cx_Oracle doesn't support tz-aware datetimes
498         if timezone.is_aware(value):
499             if settings.USE_TZ:
500                 value = timezone.make_naive(value, self.connection.timezone)
501             else:
502                 raise ValueError("Oracle backend does not support timezone-aware datetimes when USE_TZ is False.")
503 
504         return Oracle_datetime.from_datetime(value)
505 
506     def adapt_timefield_value(self, value):
507         if value is None:
508             return None
509 
510         # Expression values are adapted by the database.
511         if hasattr(value, 'resolve_expression'):
512             return value
513 
514         if isinstance(value, str):
515             return datetime.datetime.strptime(value, '%H:%M:%S')
516 
517         # Oracle doesn't support tz-aware times
518         if timezone.is_aware(value):
519             raise ValueError("Oracle backend does not support timezone-aware times.")
520 
521         return Oracle_datetime(1900, 1, 1, value.hour, value.minute,
522                                value.second, value.microsecond)
523 
524     def combine_expression(self, connector, sub_expressions):
525         lhs, rhs = sub_expressions
526         if connector == '%%':
527             return 'MOD(%s)' % ','.join(sub_expressions)
528         elif connector == '&':
529             return 'BITAND(%s)' % ','.join(sub_expressions)
530         elif connector == '|':
531             return 'BITAND(-%(lhs)s-1,%(rhs)s)+%(lhs)s' % {'lhs': lhs, 'rhs': rhs}
532         elif connector == '<<':
533             return '(%(lhs)s * POWER(2, %(rhs)s))' % {'lhs': lhs, 'rhs': rhs}
534         elif connector == '>>':
535             return 'FLOOR(%(lhs)s / POWER(2, %(rhs)s))' % {'lhs': lhs, 'rhs': rhs}
536         elif connector == '^':
537             return 'POWER(%s)' % ','.join(sub_expressions)
538         return super().combine_expression(connector, sub_expressions)
539 
540     def _get_no_autofield_sequence_name(self, table):
541         """
542         Manually created sequence name to keep backward compatibility for
543         AutoFields that aren't Oracle identity columns.
544         """
545         name_length = self.max_name_length() - 3
546         return '%s_SQ' % truncate_name(strip_quotes(table), name_length).upper()
547 
548     def _get_sequence_name(self, cursor, table, pk_name):
549         cursor.execute("""
550             SELECT sequence_name
551             FROM user_tab_identity_cols
552             WHERE table_name = UPPER(%s)
553             AND column_name = UPPER(%s)""", [table, pk_name])
554         row = cursor.fetchone()
555         return self._get_no_autofield_sequence_name(table) if row is None else row[0]
556 
557     def bulk_insert_sql(self, fields, placeholder_rows):
558         query = []
559         for row in placeholder_rows:
560             select = []
561             for i, placeholder in enumerate(row):
562                 # A model without any fields has fields=[None].
563                 if fields[i]:
564                     internal_type = getattr(fields[i], 'target_field', fields[i]).get_internal_type()
565                     placeholder = BulkInsertMapper.types.get(internal_type, '%s') % placeholder
566                 # Add columns aliases to the first select to avoid "ORA-00918:
567                 # column ambiguously defined" when two or more columns in the
568                 # first select have the same value.
569                 if not query:
570                     placeholder = '%s col_%s' % (placeholder, i)
571                 select.append(placeholder)
572             query.append('SELECT %s FROM DUAL' % ', '.join(select))
573         # Bulk insert to tables with Oracle identity columns causes Oracle to
574         # add sequence.nextval to it. Sequence.nextval cannot be used with the
575         # UNION operator. To prevent incorrect SQL, move UNION to a subquery.
576         return 'SELECT * FROM (%s)' % ' UNION ALL '.join(query)
577 
578     def subtract_temporals(self, internal_type, lhs, rhs):
579         if internal_type == 'DateField':
580             lhs_sql, lhs_params = lhs
581             rhs_sql, rhs_params = rhs
582             return "NUMTODSINTERVAL(TO_NUMBER(%s - %s), 'DAY')" % (lhs_sql, rhs_sql), lhs_params + rhs_params
583         return super().subtract_temporals(internal_type, lhs, rhs)
584 
585     def bulk_batch_size(self, fields, objs):
586         """Oracle restricts the number of parameters in a query."""
587         if fields:
588             return self.connection.features.max_query_params // len(fields)
589         return len(objs)

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>, <file>django/db/backends/postgresql/operations.py</file>
<class>DatabaseOperations</class>
<method>None</method>
<code>
8 class DatabaseOperations(BaseDatabaseOperations):
9     cast_char_field_without_max_length = 'varchar'
10     explain_prefix = 'EXPLAIN'
11     cast_data_types = {
12         'AutoField': 'integer',
13         'BigAutoField': 'bigint',
14     }
15 
16     def unification_cast_sql(self, output_field):
17         internal_type = output_field.get_internal_type()
18         if internal_type in ("GenericIPAddressField", "IPAddressField", "TimeField", "UUIDField"):
19             # PostgreSQL will resolve a union as type 'text' if input types are
20             # 'unknown'.
21             # https://www.postgresql.org/docs/current/typeconv-union-case.html
22             # These fields cannot be implicitly cast back in the default
23             # PostgreSQL configuration so we need to explicitly cast them.
24             # We must also remove components of the type within brackets:
25             # varchar(255) -> varchar.
26             return 'CAST(%%s AS %s)' % output_field.db_type(self.connection).split('(')[0]
27         return '%s'
28 
29     def date_extract_sql(self, lookup_type, field_name):
30         # https://www.postgresql.org/docs/current/functions-datetime.html#FUNCTIONS-DATETIME-EXTRACT
31         if lookup_type == 'week_day':
32             # For consistency across backends, we return Sunday=1, Saturday=7.
33             return "EXTRACT('dow' FROM %s) + 1" % field_name
34         elif lookup_type == 'iso_year':
35             return "EXTRACT('isoyear' FROM %s)" % field_name
36         else:
37             return "EXTRACT('%s' FROM %s)" % (lookup_type, field_name)
38 
39     def date_trunc_sql(self, lookup_type, field_name):
40         # https://www.postgresql.org/docs/current/functions-datetime.html#FUNCTIONS-DATETIME-TRUNC
41         return "DATE_TRUNC('%s', %s)" % (lookup_type, field_name)
42 
43     def _convert_field_to_tz(self, field_name, tzname):
44         if settings.USE_TZ:
45             field_name = "%s AT TIME ZONE '%s'" % (field_name, tzname)
46         return field_name
47 
48     def datetime_cast_date_sql(self, field_name, tzname):
49         field_name = self._convert_field_to_tz(field_name, tzname)
50         return '(%s)::date' % field_name
51 
52     def datetime_cast_time_sql(self, field_name, tzname):
53         field_name = self._convert_field_to_tz(field_name, tzname)
54         return '(%s)::time' % field_name
55 
56     def datetime_extract_sql(self, lookup_type, field_name, tzname):
57         field_name = self._convert_field_to_tz(field_name, tzname)
58         return self.date_extract_sql(lookup_type, field_name)
59 
60     def datetime_trunc_sql(self, lookup_type, field_name, tzname):
61         field_name = self._convert_field_to_tz(field_name, tzname)
62         # https://www.postgresql.org/docs/current/functions-datetime.html#FUNCTIONS-DATETIME-TRUNC
63         return "DATE_TRUNC('%s', %s)" % (lookup_type, field_name)
64 
65     def time_trunc_sql(self, lookup_type, field_name):
66         return "DATE_TRUNC('%s', %s)::time" % (lookup_type, field_name)
67 
68     def deferrable_sql(self):
69         return " DEFERRABLE INITIALLY DEFERRED"
70 
71     def fetch_returned_insert_ids(self, cursor):
72         """
73         Given a cursor object that has just performed an INSERT...RETURNING
74         statement into a table that has an auto-incrementing ID, return the
75         list of newly created IDs.
76         """
77         return [item[0] for item in cursor.fetchall()]
78 
79     def lookup_cast(self, lookup_type, internal_type=None):
80         lookup = '%s'
81 
82         # Cast text lookups to text to allow things like filter(x__contains=4)
83         if lookup_type in ('iexact', 'contains', 'icontains', 'startswith',
84                            'istartswith', 'endswith', 'iendswith', 'regex', 'iregex'):
85             if internal_type in ('IPAddressField', 'GenericIPAddressField'):
86                 lookup = "HOST(%s)"
87             elif internal_type in ('CICharField', 'CIEmailField', 'CITextField'):
88                 lookup = '%s::citext'
89             else:
90                 lookup = "%s::text"
91 
92         # Use UPPER(x) for case-insensitive lookups; it's faster.
93         if lookup_type in ('iexact', 'icontains', 'istartswith', 'iendswith'):
94             lookup = 'UPPER(%s)' % lookup
95 
96         return lookup
97 
98     def no_limit_value(self):
99         return None
100 
101     def prepare_sql_script(self, sql):
102         return [sql]
103 
104     def quote_name(self, name):
105         if name.startswith('"') and name.endswith('"'):
106             return name  # Quoting once is enough.
107         return '"%s"' % name
108 
109     def set_time_zone_sql(self):
110         return "SET TIME ZONE %s"
111 
112     def sql_flush(self, style, tables, sequences, allow_cascade=False):
113         if tables:
114             # Perform a single SQL 'TRUNCATE x, y, z...;' statement.  It allows
115             # us to truncate tables referenced by a foreign key in any other
116             # table.
117             tables_sql = ', '.join(
118                 style.SQL_FIELD(self.quote_name(table)) for table in tables)
119             if allow_cascade:
120                 sql = ['%s %s %s;' % (
121                     style.SQL_KEYWORD('TRUNCATE'),
122                     tables_sql,
123                     style.SQL_KEYWORD('CASCADE'),
124                 )]
125             else:
126                 sql = ['%s %s;' % (
127                     style.SQL_KEYWORD('TRUNCATE'),
128                     tables_sql,
129                 )]
130             sql.extend(self.sequence_reset_by_name_sql(style, sequences))
131             return sql
132         else:
133             return []
134 
135     def sequence_reset_by_name_sql(self, style, sequences):
136         # 'ALTER SEQUENCE sequence_name RESTART WITH 1;'... style SQL statements
137         # to reset sequence indices
138         sql = []
139         for sequence_info in sequences:
140             table_name = sequence_info['table']
141             # 'id' will be the case if it's an m2m using an autogenerated
142             # intermediate table (see BaseDatabaseIntrospection.sequence_list).
143             column_name = sequence_info['column'] or 'id'
144             sql.append("%s setval(pg_get_serial_sequence('%s','%s'), 1, false);" % (
145                 style.SQL_KEYWORD('SELECT'),
146                 style.SQL_TABLE(self.quote_name(table_name)),
147                 style.SQL_FIELD(column_name),
148             ))
149         return sql
150 
151     def tablespace_sql(self, tablespace, inline=False):
152         if inline:
153             return "USING INDEX TABLESPACE %s" % self.quote_name(tablespace)
154         else:
155             return "TABLESPACE %s" % self.quote_name(tablespace)
156 
157     def sequence_reset_sql(self, style, model_list):
158         from django.db import models
159         output = []
160         qn = self.quote_name
161         for model in model_list:
162             # Use `coalesce` to set the sequence for each model to the max pk value if there are records,
163             # or 1 if there are none. Set the `is_called` property (the third argument to `setval`) to true
164             # if there are records (as the max pk value is already in use), otherwise set it to false.
165             # Use pg_get_serial_sequence to get the underlying sequence name from the table name
166             # and column name (available since PostgreSQL 8)
167 
168             for f in model._meta.local_fields:
169                 if isinstance(f, models.AutoField):
170                     output.append(
171                         "%s setval(pg_get_serial_sequence('%s','%s'), "
172                         "coalesce(max(%s), 1), max(%s) %s null) %s %s;" % (
173                             style.SQL_KEYWORD('SELECT'),
174                             style.SQL_TABLE(qn(model._meta.db_table)),
175                             style.SQL_FIELD(f.column),
176                             style.SQL_FIELD(qn(f.column)),
177                             style.SQL_FIELD(qn(f.column)),
178                             style.SQL_KEYWORD('IS NOT'),
179                             style.SQL_KEYWORD('FROM'),
180                             style.SQL_TABLE(qn(model._meta.db_table)),
181                         )
182                     )
183                     break  # Only one AutoField is allowed per model, so don't bother continuing.
184             for f in model._meta.many_to_many:
185                 if not f.remote_field.through:
186                     output.append(
187                         "%s setval(pg_get_serial_sequence('%s','%s'), "
188                         "coalesce(max(%s), 1), max(%s) %s null) %s %s;" % (
189                             style.SQL_KEYWORD('SELECT'),
190                             style.SQL_TABLE(qn(f.m2m_db_table())),
191                             style.SQL_FIELD('id'),
192                             style.SQL_FIELD(qn('id')),
193                             style.SQL_FIELD(qn('id')),
194                             style.SQL_KEYWORD('IS NOT'),
195                             style.SQL_KEYWORD('FROM'),
196                             style.SQL_TABLE(qn(f.m2m_db_table()))
197                         )
198                     )
199         return output
200 
201     def prep_for_iexact_query(self, x):
202         return x
203 
204     def max_name_length(self):
205         """
206         Return the maximum length of an identifier.
207 
208         The maximum length of an identifier is 63 by default, but can be
209         changed by recompiling PostgreSQL after editing the NAMEDATALEN
210         macro in src/include/pg_config_manual.h.
211 
212         This implementation returns 63, but can be overridden by a custom
213         database backend that inherits most of its behavior from this one.
214         """
215         return 63
216 
217     def distinct_sql(self, fields, params):
218         if fields:
219             params = [param for param_list in params for param in param_list]
220             return (['DISTINCT ON (%s)' % ', '.join(fields)], params)
221         else:
222             return ['DISTINCT'], []
223 
224     def last_executed_query(self, cursor, sql, params):
225         # http://initd.org/psycopg/docs/cursor.html#cursor.query
226         # The query attribute is a Psycopg extension to the DB API 2.0.
227         if cursor.query is not None:
228             return cursor.query.decode()
229         return None
230 
231     def return_insert_id(self):
232         return "RETURNING %s", ()
233 
234     def bulk_insert_sql(self, fields, placeholder_rows):
235         placeholder_rows_sql = (", ".join(row) for row in placeholder_rows)
236         values_sql = ", ".join("(%s)" % sql for sql in placeholder_rows_sql)
237         return "VALUES " + values_sql
238 
239     def adapt_datefield_value(self, value):
240         return value
241 
242     def adapt_datetimefield_value(self, value):
243         return value
244 
245     def adapt_timefield_value(self, value):
246         return value
247 
248     def adapt_ipaddressfield_value(self, value):
249         if value:
250             return Inet(value)
251         return None
252 
253     def subtract_temporals(self, internal_type, lhs, rhs):
254         if internal_type == 'DateField':
255             lhs_sql, lhs_params = lhs
256             rhs_sql, rhs_params = rhs
257             return "(interval '1 day' * (%s - %s))" % (lhs_sql, rhs_sql), lhs_params + rhs_params
258         return super().subtract_temporals(internal_type, lhs, rhs)
259 
260     def window_frame_range_start_end(self, start=None, end=None):
261         start_, end_ = super().window_frame_range_start_end(start, end)
262         if (start and start < 0) or (end and end > 0):
263             raise NotSupportedError(
264                 'PostgreSQL only supports UNBOUNDED together with PRECEDING '
265                 'and FOLLOWING.'
266             )
267         return start_, end_
268 
269     def explain_query_prefix(self, format=None, **options):
270         prefix = super().explain_query_prefix(format)
271         extra = {}
272         if format:
273             extra['FORMAT'] = format
274         if options:
275             extra.update({
276                 name.upper(): 'true' if value else 'false'
277                 for name, value in options.items()
278             })
279         if extra:
280             prefix += ' (%s)' % ', '.join('%s %s' % i for i in extra.items())
281         return prefix
282 
283     def ignore_conflicts_suffix_sql(self, ignore_conflicts=None):
284         return 'ON CONFLICT DO NOTHING' if ignore_conflicts else super().ignore_conflicts_suffix_sql(ignore_conflicts)

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>, <file>django/db/backends/mysql/operations.py</file>
<class>DatabaseOperations</class>
<method>None</method>
<code>
9 class DatabaseOperations(BaseDatabaseOperations):
10     compiler_module = "django.db.backends.mysql.compiler"
11 
12     # MySQL stores positive fields as UNSIGNED ints.
13     integer_field_ranges = {
14         **BaseDatabaseOperations.integer_field_ranges,
15         'PositiveSmallIntegerField': (0, 65535),
16         'PositiveIntegerField': (0, 4294967295),
17     }
18     cast_data_types = {
19         'AutoField': 'signed integer',
20         'BigAutoField': 'signed integer',
21         'CharField': 'char(%(max_length)s)',
22         'DecimalField': 'decimal(%(max_digits)s, %(decimal_places)s)',
23         'TextField': 'char',
24         'IntegerField': 'signed integer',
25         'BigIntegerField': 'signed integer',
26         'SmallIntegerField': 'signed integer',
27         'PositiveIntegerField': 'unsigned integer',
28         'PositiveSmallIntegerField': 'unsigned integer',
29     }
30     cast_char_field_without_max_length = 'char'
31     explain_prefix = 'EXPLAIN'
32 
33     def date_extract_sql(self, lookup_type, field_name):
34         # https://dev.mysql.com/doc/mysql/en/date-and-time-functions.html
35         if lookup_type == 'week_day':
36             # DAYOFWEEK() returns an integer, 1-7, Sunday=1.
37             # Note: WEEKDAY() returns 0-6, Monday=0.
38             return "DAYOFWEEK(%s)" % field_name
39         elif lookup_type == 'week':
40             # Override the value of default_week_format for consistency with
41             # other database backends.
42             # Mode 3: Monday, 1-53, with 4 or more days this year.
43             return "WEEK(%s, 3)" % field_name
44         elif lookup_type == 'iso_year':
45             # Get the year part from the YEARWEEK function, which returns a
46             # number as year * 100 + week.
47             return "TRUNCATE(YEARWEEK(%s, 3), -2) / 100" % field_name
48         else:
49             # EXTRACT returns 1-53 based on ISO-8601 for the week number.
50             return "EXTRACT(%s FROM %s)" % (lookup_type.upper(), field_name)
51 
52     def date_trunc_sql(self, lookup_type, field_name):
53         fields = {
54             'year': '%%Y-01-01',
55             'month': '%%Y-%%m-01',
56         }  # Use double percents to escape.
57         if lookup_type in fields:
58             format_str = fields[lookup_type]
59             return "CAST(DATE_FORMAT(%s, '%s') AS DATE)" % (field_name, format_str)
60         elif lookup_type == 'quarter':
61             return "MAKEDATE(YEAR(%s), 1) + INTERVAL QUARTER(%s) QUARTER - INTERVAL 1 QUARTER" % (
62                 field_name, field_name
63             )
64         elif lookup_type == 'week':
65             return "DATE_SUB(%s, INTERVAL WEEKDAY(%s) DAY)" % (
66                 field_name, field_name
67             )
68         else:
69             return "DATE(%s)" % (field_name)
70 
71     def _convert_field_to_tz(self, field_name, tzname):
72         if settings.USE_TZ:
73             field_name = "CONVERT_TZ(%s, 'UTC', '%s')" % (field_name, tzname)
74         return field_name
75 
76     def datetime_cast_date_sql(self, field_name, tzname):
77         field_name = self._convert_field_to_tz(field_name, tzname)
78         return "DATE(%s)" % field_name
79 
80     def datetime_cast_time_sql(self, field_name, tzname):
81         field_name = self._convert_field_to_tz(field_name, tzname)
82         return "TIME(%s)" % field_name
83 
84     def datetime_extract_sql(self, lookup_type, field_name, tzname):
85         field_name = self._convert_field_to_tz(field_name, tzname)
86         return self.date_extract_sql(lookup_type, field_name)
87 
88     def datetime_trunc_sql(self, lookup_type, field_name, tzname):
89         field_name = self._convert_field_to_tz(field_name, tzname)
90         fields = ['year', 'month', 'day', 'hour', 'minute', 'second']
91         format = ('%%Y-', '%%m', '-%%d', ' %%H:', '%%i', ':%%s')  # Use double percents to escape.
92         format_def = ('0000-', '01', '-01', ' 00:', '00', ':00')
93         if lookup_type == 'quarter':
94             return (
95                 "CAST(DATE_FORMAT(MAKEDATE(YEAR({field_name}), 1) + "
96                 "INTERVAL QUARTER({field_name}) QUARTER - " +
97                 "INTERVAL 1 QUARTER, '%%Y-%%m-01 00:00:00') AS DATETIME)"
98             ).format(field_name=field_name)
99         if lookup_type == 'week':
100             return (
101                 "CAST(DATE_FORMAT(DATE_SUB({field_name}, "
102                 "INTERVAL WEEKDAY({field_name}) DAY), "
103                 "'%%Y-%%m-%%d 00:00:00') AS DATETIME)"
104             ).format(field_name=field_name)
105         try:
106             i = fields.index(lookup_type) + 1
107         except ValueError:
108             sql = field_name
109         else:
110             format_str = ''.join(format[:i] + format_def[i:])
111             sql = "CAST(DATE_FORMAT(%s, '%s') AS DATETIME)" % (field_name, format_str)
112         return sql
113 
114     def time_trunc_sql(self, lookup_type, field_name):
115         fields = {
116             'hour': '%%H:00:00',
117             'minute': '%%H:%%i:00',
118             'second': '%%H:%%i:%%s',
119         }  # Use double percents to escape.
120         if lookup_type in fields:
121             format_str = fields[lookup_type]
122             return "CAST(DATE_FORMAT(%s, '%s') AS TIME)" % (field_name, format_str)
123         else:
124             return "TIME(%s)" % (field_name)
125 
126     def date_interval_sql(self, timedelta):
127         return 'INTERVAL %s MICROSECOND' % duration_microseconds(timedelta)
128 
129     def format_for_duration_arithmetic(self, sql):
130         return 'INTERVAL %s MICROSECOND' % sql
131 
132     def force_no_ordering(self):
133         """
134         "ORDER BY NULL" prevents MySQL from implicitly ordering by grouped
135         columns. If no ordering would otherwise be applied, we don't want any
136         implicit sorting going on.
137         """
138         return [(None, ("NULL", [], False))]
139 
140     def last_executed_query(self, cursor, sql, params):
141         # With MySQLdb, cursor objects have an (undocumented) "_executed"
142         # attribute where the exact query sent to the database is saved.
143         # See MySQLdb/cursors.py in the source distribution.
144         query = getattr(cursor, '_executed', None)
145         if query is not None:
146             query = query.decode(errors='replace')
147         return query
148 
149     def no_limit_value(self):
150         # 2**64 - 1, as recommended by the MySQL documentation
151         return 18446744073709551615
152 
153     def quote_name(self, name):
154         if name.startswith("`") and name.endswith("`"):
155             return name  # Quoting once is enough.
156         return "`%s`" % name
157 
158     def random_function_sql(self):
159         return 'RAND()'
160 
161     def sql_flush(self, style, tables, sequences, allow_cascade=False):
162         # NB: The generated SQL below is specific to MySQL
163         # 'TRUNCATE x;', 'TRUNCATE y;', 'TRUNCATE z;'... style SQL statements
164         # to clear all tables of all data
165         if tables:
166             sql = ['SET FOREIGN_KEY_CHECKS = 0;']
167             for table in tables:
168                 sql.append('%s %s;' % (
169                     style.SQL_KEYWORD('TRUNCATE'),
170                     style.SQL_FIELD(self.quote_name(table)),
171                 ))
172             sql.append('SET FOREIGN_KEY_CHECKS = 1;')
173             sql.extend(self.sequence_reset_by_name_sql(style, sequences))
174             return sql
175         else:
176             return []
177 
178     def validate_autopk_value(self, value):
179         # MySQLism: zero in AUTO_INCREMENT field does not work. Refs #17653.
180         if value == 0:
181             raise ValueError('The database backend does not accept 0 as a '
182                              'value for AutoField.')
183         return value
184 
185     def adapt_datetimefield_value(self, value):
186         if value is None:
187             return None
188 
189         # Expression values are adapted by the database.
190         if hasattr(value, 'resolve_expression'):
191             return value
192 
193         # MySQL doesn't support tz-aware datetimes
194         if timezone.is_aware(value):
195             if settings.USE_TZ:
196                 value = timezone.make_naive(value, self.connection.timezone)
197             else:
198                 raise ValueError("MySQL backend does not support timezone-aware datetimes when USE_TZ is False.")
199         return str(value)
200 
201     def adapt_timefield_value(self, value):
202         if value is None:
203             return None
204 
205         # Expression values are adapted by the database.
206         if hasattr(value, 'resolve_expression'):
207             return value
208 
209         # MySQL doesn't support tz-aware times
210         if timezone.is_aware(value):
211             raise ValueError("MySQL backend does not support timezone-aware times.")
212 
213         return str(value)
214 
215     def max_name_length(self):
216         return 64
217 
218     def bulk_insert_sql(self, fields, placeholder_rows):
219         placeholder_rows_sql = (", ".join(row) for row in placeholder_rows)
220         values_sql = ", ".join("(%s)" % sql for sql in placeholder_rows_sql)
221         return "VALUES " + values_sql
222 
223     def combine_expression(self, connector, sub_expressions):
224         if connector == '^':
225             return 'POW(%s)' % ','.join(sub_expressions)
226         # Convert the result to a signed integer since MySQL's binary operators
227         # return an unsigned integer.
228         elif connector in ('&', '|', '<<'):
229             return 'CONVERT(%s, SIGNED)' % connector.join(sub_expressions)
230         elif connector == '>>':
231             lhs, rhs = sub_expressions
232             return 'FLOOR(%(lhs)s / POW(2, %(rhs)s))' % {'lhs': lhs, 'rhs': rhs}
233         return super().combine_expression(connector, sub_expressions)
234 
235     def get_db_converters(self, expression):
236         converters = super().get_db_converters(expression)
237         internal_type = expression.output_field.get_internal_type()
238         if internal_type in ['BooleanField', 'NullBooleanField']:
239             converters.append(self.convert_booleanfield_value)
240         elif internal_type == 'DateTimeField':
241             if settings.USE_TZ:
242                 converters.append(self.convert_datetimefield_value)
243         elif internal_type == 'UUIDField':
244             converters.append(self.convert_uuidfield_value)
245         return converters
246 
247     def convert_booleanfield_value(self, value, expression, connection):
248         if value in (0, 1):
249             value = bool(value)
250         return value
251 
252     def convert_datetimefield_value(self, value, expression, connection):
253         if value is not None:
254             value = timezone.make_aware(value, self.connection.timezone)
255         return value
256 
257     def convert_uuidfield_value(self, value, expression, connection):
258         if value is not None:
259             value = uuid.UUID(value)
260         return value
261 
262     def binary_placeholder_sql(self, value):
263         return '_binary %s' if value is not None and not hasattr(value, 'as_sql') else '%s'
264 
265     def subtract_temporals(self, internal_type, lhs, rhs):
266         lhs_sql, lhs_params = lhs
267         rhs_sql, rhs_params = rhs
268         if internal_type == 'TimeField':
269             if self.connection.mysql_is_mariadb:
270                 # MariaDB includes the microsecond component in TIME_TO_SEC as
271                 # a decimal. MySQL returns an integer without microseconds.
272                 return 'CAST((TIME_TO_SEC(%(lhs)s) - TIME_TO_SEC(%(rhs)s)) * 1000000 AS SIGNED)' % {
273                     'lhs': lhs_sql, 'rhs': rhs_sql
274                 }, lhs_params + rhs_params
275             return (
276                 "((TIME_TO_SEC(%(lhs)s) * 1000000 + MICROSECOND(%(lhs)s)) -"
277                 " (TIME_TO_SEC(%(rhs)s) * 1000000 + MICROSECOND(%(rhs)s)))"
278             ) % {'lhs': lhs_sql, 'rhs': rhs_sql}, lhs_params * 2 + rhs_params * 2
279         else:
280             return "TIMESTAMPDIFF(MICROSECOND, %s, %s)" % (rhs_sql, lhs_sql), rhs_params + lhs_params
281 
282     def explain_query_prefix(self, format=None, **options):
283         # Alias MySQL's TRADITIONAL to TEXT for consistency with other backends.
284         if format and format.upper() == 'TEXT':
285             format = 'TRADITIONAL'
286         prefix = super().explain_query_prefix(format, **options)
287         if format:
288             prefix += ' FORMAT=%s' % format
289         if self.connection.features.needs_explain_extended and format is None:
290             # EXTENDED and FORMAT are mutually exclusive options.
291             prefix += ' EXTENDED'
292         return prefix
293 
294     def regex_lookup(self, lookup_type):
295         # REGEXP BINARY doesn't work correctly in MySQL 8+ and REGEXP_LIKE
296         # doesn't exist in MySQL 5.6 or in MariaDB.
297         if self.connection.mysql_version < (8, 0, 0) or self.connection.mysql_is_mariadb:
298             if lookup_type == 'regex':
299                 return '%s REGEXP BINARY %s'
300             return '%s REGEXP %s'
301 
302         match_option = 'c' if lookup_type == 'regex' else 'i'
303         return "REGEXP_LIKE(%%s, %%s, '%s')" % match_option
304 
305     def insert_statement(self, ignore_conflicts=False):
306         return 'INSERT IGNORE INTO' if ignore_conflicts else super().insert_statement(ignore_conflicts)

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>]
2025-10-18 10:21:14.085 | INFO     | Search completed. Bug locations: [<file>django/db/backends/oracle/operations.py</file>
<class>DatabaseOperations</class>
<method>_convert_field_to_tz</method>
<code>
97     def _convert_field_to_tz(self, field_name, tzname):
98         if not settings.USE_TZ:
99             return field_name
100         if not self._tzname_re.match(tzname):
101             raise ValueError("Invalid time zone name: %s" % tzname)
102         # Convert from UTC to local time, returning TIMESTAMP WITH TIME ZONE
103         # and cast it back to TIMESTAMP to strip the TIME ZONE details.
104         return "CAST((FROM_TZ(%s, '0:00') AT TIME ZONE '%s') AS TIMESTAMP)" % (field_name, tzname)

</code><intended_behavior>This method should be updated to consider when the database's `TIME_ZONE` setting matches Django's global `TIME_ZONE` setting. In such cases, the method should avoid using `CONVERT_TZ` for timezone conversion if the database and Django settings align, to prevent unnecessary conversions. Effectively, it should only apply `CONVERT_TZ` when the database's timezone differs from the Django application's timezone. This would involve first checking if `settings.TIME_ZONE` matches DATABASES['default']['TIME_ZONE'], and if so, bypassing the `CONVERT_TZ` operation or adjusting the parameters to reflect an intra-timezone conversion.</intended_behavior>, <file>django/db/backends/postgresql/operations.py</file>
<class>DatabaseOperations</class>
<method>_convert_field_to_tz</method>
<code>
43     def _convert_field_to_tz(self, field_name, tzname):
44         if settings.USE_TZ:
45             field_name = "%s AT TIME ZONE '%s'" % (field_name, tzname)
46         return field_name

</code><intended_behavior>This method should be updated to consider when the database's `TIME_ZONE` setting matches Django's global `TIME_ZONE` setting. In such cases, the method should avoid using `CONVERT_TZ` for timezone conversion if the database and Django settings align, to prevent unnecessary conversions. Effectively, it should only apply `CONVERT_TZ` when the database's timezone differs from the Django application's timezone. This would involve first checking if `settings.TIME_ZONE` matches DATABASES['default']['TIME_ZONE'], and if so, bypassing the `CONVERT_TZ` operation or adjusting the parameters to reflect an intra-timezone conversion.</intended_behavior>, <file>django/db/backends/mysql/operations.py</file>
<class>DatabaseOperations</class>
<method>_convert_field_to_tz</method>
<code>
71     def _convert_field_to_tz(self, field_name, tzname):
72         if settings.USE_TZ:
73             field_name = "CONVERT_TZ(%s, 'UTC', '%s')" % (field_name, tzname)
74         return field_name

</code><intended_behavior>This method should be updated to consider when the database's `TIME_ZONE` setting matches Django's global `TIME_ZONE` setting. In such cases, the method should avoid using `CONVERT_TZ` for timezone conversion if the database and Django settings align, to prevent unnecessary conversions. Effectively, it should only apply `CONVERT_TZ` when the database's timezone differs from the Django application's timezone. This would involve first checking if `settings.TIME_ZONE` matches DATABASES['default']['TIME_ZONE'], and if so, bypassing the `CONVERT_TZ` operation or adjusting the parameters to reflect an intra-timezone conversion.</intended_behavior>, <file>django/db/backends/oracle/operations.py</file>
<class>DatabaseOperations</class>
<method>None</method>
<code>
18 class DatabaseOperations(BaseDatabaseOperations):
19     # Oracle uses NUMBER(11) and NUMBER(19) for integer fields.
20     integer_field_ranges = {
21         'SmallIntegerField': (-99999999999, 99999999999),
22         'IntegerField': (-99999999999, 99999999999),
23         'BigIntegerField': (-9999999999999999999, 9999999999999999999),
24         'PositiveSmallIntegerField': (0, 99999999999),
25         'PositiveIntegerField': (0, 99999999999),
26     }
27     set_operators = {**BaseDatabaseOperations.set_operators, 'difference': 'MINUS'}
28 
29     # TODO: colorize this SQL code with style.SQL_KEYWORD(), etc.
30     _sequence_reset_sql = """
31 DECLARE
32     table_value integer;
33     seq_value integer;
34     seq_name user_tab_identity_cols.sequence_name%%TYPE;
35 BEGIN
36     BEGIN
37         SELECT sequence_name INTO seq_name FROM user_tab_identity_cols
38         WHERE  table_name = '%(table_name)s' AND
39                column_name = '%(column_name)s';
40         EXCEPTION WHEN NO_DATA_FOUND THEN
41             seq_name := '%(no_autofield_sequence_name)s';
42     END;
43 
44     SELECT NVL(MAX(%(column)s), 0) INTO table_value FROM %(table)s;
45     SELECT NVL(last_number - cache_size, 0) INTO seq_value FROM user_sequences
46            WHERE sequence_name = seq_name;
47     WHILE table_value > seq_value LOOP
48         EXECUTE IMMEDIATE 'SELECT "'||seq_name||'".nextval FROM DUAL'
49         INTO seq_value;
50     END LOOP;
51 END;
52 /"""
53 
54     # Oracle doesn't support string without precision; use the max string size.
55     cast_char_field_without_max_length = 'NVARCHAR2(2000)'
56     cast_data_types = {
57         'AutoField': 'NUMBER(11)',
58         'BigAutoField': 'NUMBER(19)',
59         'TextField': cast_char_field_without_max_length,
60     }
61 
62     def cache_key_culling_sql(self):
63         return 'SELECT cache_key FROM %s ORDER BY cache_key OFFSET %%s ROWS FETCH FIRST 1 ROWS ONLY'
64 
65     def date_extract_sql(self, lookup_type, field_name):
66         if lookup_type == 'week_day':
67             # TO_CHAR(field, 'D') returns an integer from 1-7, where 1=Sunday.
68             return "TO_CHAR(%s, 'D')" % field_name
69         elif lookup_type == 'week':
70             # IW = ISO week number
71             return "TO_CHAR(%s, 'IW')" % field_name
72         elif lookup_type == 'quarter':
73             return "TO_CHAR(%s, 'Q')" % field_name
74         elif lookup_type == 'iso_year':
75             return "TO_CHAR(%s, 'IYYY')" % field_name
76         else:
77             # https://docs.oracle.com/en/database/oracle/oracle-database/18/sqlrf/EXTRACT-datetime.html
78             return "EXTRACT(%s FROM %s)" % (lookup_type.upper(), field_name)
79 
80     def date_trunc_sql(self, lookup_type, field_name):
81         # https://docs.oracle.com/en/database/oracle/oracle-database/18/sqlrf/ROUND-and-TRUNC-Date-Functions.html
82         if lookup_type in ('year', 'month'):
83             return "TRUNC(%s, '%s')" % (field_name, lookup_type.upper())
84         elif lookup_type == 'quarter':
85             return "TRUNC(%s, 'Q')" % field_name
86         elif lookup_type == 'week':
87             return "TRUNC(%s, 'IW')" % field_name
88         else:
89             return "TRUNC(%s)" % field_name
90 
91     # Oracle crashes with "ORA-03113: end-of-file on communication channel"
92     # if the time zone name is passed in parameter. Use interpolation instead.
93     # https://groups.google.com/forum/#!msg/django-developers/zwQju7hbG78/9l934yelwfsJ
94     # This regexp matches all time zone names from the zoneinfo database.
95     _tzname_re = re.compile(r'^[\w/:+-]+$')
96 
97     def _convert_field_to_tz(self, field_name, tzname):
98         if not settings.USE_TZ:
99             return field_name
100         if not self._tzname_re.match(tzname):
101             raise ValueError("Invalid time zone name: %s" % tzname)
102         # Convert from UTC to local time, returning TIMESTAMP WITH TIME ZONE
103         # and cast it back to TIMESTAMP to strip the TIME ZONE details.
104         return "CAST((FROM_TZ(%s, '0:00') AT TIME ZONE '%s') AS TIMESTAMP)" % (field_name, tzname)
105 
106     def datetime_cast_date_sql(self, field_name, tzname):
107         field_name = self._convert_field_to_tz(field_name, tzname)
108         return 'TRUNC(%s)' % field_name
109 
110     def datetime_cast_time_sql(self, field_name, tzname):
111         # Since `TimeField` values are stored as TIMESTAMP where only the date
112         # part is ignored, convert the field to the specified timezone.
113         return self._convert_field_to_tz(field_name, tzname)
114 
115     def datetime_extract_sql(self, lookup_type, field_name, tzname):
116         field_name = self._convert_field_to_tz(field_name, tzname)
117         return self.date_extract_sql(lookup_type, field_name)
118 
119     def datetime_trunc_sql(self, lookup_type, field_name, tzname):
120         field_name = self._convert_field_to_tz(field_name, tzname)
121         # https://docs.oracle.com/en/database/oracle/oracle-database/18/sqlrf/ROUND-and-TRUNC-Date-Functions.html
122         if lookup_type in ('year', 'month'):
123             sql = "TRUNC(%s, '%s')" % (field_name, lookup_type.upper())
124         elif lookup_type == 'quarter':
125             sql = "TRUNC(%s, 'Q')" % field_name
126         elif lookup_type == 'week':
127             sql = "TRUNC(%s, 'IW')" % field_name
128         elif lookup_type == 'day':
129             sql = "TRUNC(%s)" % field_name
130         elif lookup_type == 'hour':
131             sql = "TRUNC(%s, 'HH24')" % field_name
132         elif lookup_type == 'minute':
133             sql = "TRUNC(%s, 'MI')" % field_name
134         else:
135             sql = "CAST(%s AS DATE)" % field_name  # Cast to DATE removes sub-second precision.
136         return sql
137 
138     def time_trunc_sql(self, lookup_type, field_name):
139         # The implementation is similar to `datetime_trunc_sql` as both
140         # `DateTimeField` and `TimeField` are stored as TIMESTAMP where
141         # the date part of the later is ignored.
142         if lookup_type == 'hour':
143             sql = "TRUNC(%s, 'HH24')" % field_name
144         elif lookup_type == 'minute':
145             sql = "TRUNC(%s, 'MI')" % field_name
146         elif lookup_type == 'second':
147             sql = "CAST(%s AS DATE)" % field_name  # Cast to DATE removes sub-second precision.
148         return sql
149 
150     def get_db_converters(self, expression):
151         converters = super().get_db_converters(expression)
152         internal_type = expression.output_field.get_internal_type()
153         if internal_type == 'TextField':
154             converters.append(self.convert_textfield_value)
155         elif internal_type == 'BinaryField':
156             converters.append(self.convert_binaryfield_value)
157         elif internal_type in ['BooleanField', 'NullBooleanField']:
158             converters.append(self.convert_booleanfield_value)
159         elif internal_type == 'DateTimeField':
160             if settings.USE_TZ:
161                 converters.append(self.convert_datetimefield_value)
162         elif internal_type == 'DateField':
163             converters.append(self.convert_datefield_value)
164         elif internal_type == 'TimeField':
165             converters.append(self.convert_timefield_value)
166         elif internal_type == 'UUIDField':
167             converters.append(self.convert_uuidfield_value)
168         # Oracle stores empty strings as null. If the field accepts the empty
169         # string, undo this to adhere to the Django convention of using
170         # the empty string instead of null.
171         if expression.field.empty_strings_allowed:
172             converters.append(
173                 self.convert_empty_bytes
174                 if internal_type == 'BinaryField' else
175                 self.convert_empty_string
176             )
177         return converters
178 
179     def convert_textfield_value(self, value, expression, connection):
180         if isinstance(value, Database.LOB):
181             value = value.read()
182         return value
183 
184     def convert_binaryfield_value(self, value, expression, connection):
185         if isinstance(value, Database.LOB):
186             value = force_bytes(value.read())
187         return value
188 
189     def convert_booleanfield_value(self, value, expression, connection):
190         if value in (0, 1):
191             value = bool(value)
192         return value
193 
194     # cx_Oracle always returns datetime.datetime objects for
195     # DATE and TIMESTAMP columns, but Django wants to see a
196     # python datetime.date, .time, or .datetime.
197 
198     def convert_datetimefield_value(self, value, expression, connection):
199         if value is not None:
200             value = timezone.make_aware(value, self.connection.timezone)
201         return value
202 
203     def convert_datefield_value(self, value, expression, connection):
204         if isinstance(value, Database.Timestamp):
205             value = value.date()
206         return value
207 
208     def convert_timefield_value(self, value, expression, connection):
209         if isinstance(value, Database.Timestamp):
210             value = value.time()
211         return value
212 
213     def convert_uuidfield_value(self, value, expression, connection):
214         if value is not None:
215             value = uuid.UUID(value)
216         return value
217 
218     @staticmethod
219     def convert_empty_string(value, expression, connection):
220         return '' if value is None else value
221 
222     @staticmethod
223     def convert_empty_bytes(value, expression, connection):
224         return b'' if value is None else value
225 
226     def deferrable_sql(self):
227         return " DEFERRABLE INITIALLY DEFERRED"
228 
229     def fetch_returned_insert_id(self, cursor):
230         value = cursor._insert_id_var.getvalue()
231         if value is None or value == []:
232             # cx_Oracle < 6.3 returns None, >= 6.3 returns empty list.
233             raise DatabaseError(
234                 'The database did not return a new row id. Probably "ORA-1403: '
235                 'no data found" was raised internally but was hidden by the '
236                 'Oracle OCI library (see https://code.djangoproject.com/ticket/28859).'
237             )
238         # cx_Oracle < 7 returns value, >= 7 returns list with single value.
239         return value[0] if isinstance(value, list) else value
240 
241     def field_cast_sql(self, db_type, internal_type):
242         if db_type and db_type.endswith('LOB'):
243             return "DBMS_LOB.SUBSTR(%s)"
244         else:
245             return "%s"
246 
247     def no_limit_value(self):
248         return None
249 
250     def limit_offset_sql(self, low_mark, high_mark):
251         fetch, offset = self._get_limit_offset_params(low_mark, high_mark)
252         return ' '.join(sql for sql in (
253             ('OFFSET %d ROWS' % offset) if offset else None,
254             ('FETCH FIRST %d ROWS ONLY' % fetch) if fetch else None,
255         ) if sql)
256 
257     def last_executed_query(self, cursor, sql, params):
258         # https://cx-oracle.readthedocs.io/en/latest/cursor.html#Cursor.statement
259         # The DB API definition does not define this attribute.
260         statement = cursor.statement
261         # Unlike Psycopg's `query` and MySQLdb`'s `_executed`, cx_Oracle's
262         # `statement` doesn't contain the query parameters. Substitute
263         # parameters manually.
264         if isinstance(params, (tuple, list)):
265             for i, param in enumerate(params):
266                 statement = statement.replace(':arg%d' % i, force_str(param, errors='replace'))
267         elif isinstance(params, dict):
268             for key, param in params.items():
269                 statement = statement.replace(':%s' % key, force_str(param, errors='replace'))
270         return statement
271 
272     def last_insert_id(self, cursor, table_name, pk_name):
273         sq_name = self._get_sequence_name(cursor, strip_quotes(table_name), pk_name)
274         cursor.execute('"%s".currval' % sq_name)
275         return cursor.fetchone()[0]
276 
277     def lookup_cast(self, lookup_type, internal_type=None):
278         if lookup_type in ('iexact', 'icontains', 'istartswith', 'iendswith'):
279             return "UPPER(%s)"
280         return "%s"
281 
282     def max_in_list_size(self):
283         return 1000
284 
285     def max_name_length(self):
286         return 30
287 
288     def pk_default_value(self):
289         return "NULL"
290 
291     def prep_for_iexact_query(self, x):
292         return x
293 
294     def process_clob(self, value):
295         if value is None:
296             return ''
297         return value.read()
298 
299     def quote_name(self, name):
300         # SQL92 requires delimited (quoted) names to be case-sensitive.  When
301         # not quoted, Oracle has case-insensitive behavior for identifiers, but
302         # always defaults to uppercase.
303         # We simplify things by making Oracle identifiers always uppercase.
304         if not name.startswith('"') and not name.endswith('"'):
305             name = '"%s"' % truncate_name(name.upper(), self.max_name_length())
306         # Oracle puts the query text into a (query % args) construct, so % signs
307         # in names need to be escaped. The '%%' will be collapsed back to '%' at
308         # that stage so we aren't really making the name longer here.
309         name = name.replace('%', '%%')
310         return name.upper()
311 
312     def random_function_sql(self):
313         return "DBMS_RANDOM.RANDOM"
314 
315     def regex_lookup(self, lookup_type):
316         if lookup_type == 'regex':
317             match_option = "'c'"
318         else:
319             match_option = "'i'"
320         return 'REGEXP_LIKE(%%s, %%s, %s)' % match_option
321 
322     def return_insert_id(self):
323         return "RETURNING %s INTO %%s", (InsertIdVar(),)
324 
325     def __foreign_key_constraints(self, table_name, recursive):
326         with self.connection.cursor() as cursor:
327             if recursive:
328                 cursor.execute("""
329                     SELECT
330                         user_tables.table_name, rcons.constraint_name
331                     FROM
332                         user_tables
333                     JOIN
334                         user_constraints cons
335                         ON (user_tables.table_name = cons.table_name AND cons.constraint_type = ANY('P', 'U'))
336                     LEFT JOIN
337                         user_constraints rcons
338                         ON (user_tables.table_name = rcons.table_name AND rcons.constraint_type = 'R')
339                     START WITH user_tables.table_name = UPPER(%s)
340                     CONNECT BY NOCYCLE PRIOR cons.constraint_name = rcons.r_constraint_name
341                     GROUP BY
342                         user_tables.table_name, rcons.constraint_name
343                     HAVING user_tables.table_name != UPPER(%s)
344                     ORDER BY MAX(level) DESC
345                 """, (table_name, table_name))
346             else:
347                 cursor.execute("""
348                     SELECT
349                         cons.table_name, cons.constraint_name
350                     FROM
351                         user_constraints cons
352                     WHERE
353                         cons.constraint_type = 'R'
354                         AND cons.table_name = UPPER(%s)
355                 """, (table_name,))
356             return cursor.fetchall()
357 
358     @cached_property
359     def _foreign_key_constraints(self):
360         # 512 is large enough to fit the ~330 tables (as of this writing) in
361         # Django's test suite.
362         return lru_cache(maxsize=512)(self.__foreign_key_constraints)
363 
364     def sql_flush(self, style, tables, sequences, allow_cascade=False):
365         if tables:
366             truncated_tables = {table.upper() for table in tables}
367             constraints = set()
368             # Oracle's TRUNCATE CASCADE only works with ON DELETE CASCADE
369             # foreign keys which Django doesn't define. Emulate the
370             # PostgreSQL behavior which truncates all dependent tables by
371             # manually retrieving all foreign key constraints and resolving
372             # dependencies.
373             for table in tables:
374                 for foreign_table, constraint in self._foreign_key_constraints(table, recursive=allow_cascade):
375                     if allow_cascade:
376                         truncated_tables.add(foreign_table)
377                     constraints.add((foreign_table, constraint))
378             sql = [
379                 "%s %s %s %s %s %s %s %s;" % (
380                     style.SQL_KEYWORD('ALTER'),
381                     style.SQL_KEYWORD('TABLE'),
382                     style.SQL_FIELD(self.quote_name(table)),
383                     style.SQL_KEYWORD('DISABLE'),
384                     style.SQL_KEYWORD('CONSTRAINT'),
385                     style.SQL_FIELD(self.quote_name(constraint)),
386                     style.SQL_KEYWORD('KEEP'),
387                     style.SQL_KEYWORD('INDEX'),
388                 ) for table, constraint in constraints
389             ] + [
390                 "%s %s %s;" % (
391                     style.SQL_KEYWORD('TRUNCATE'),
392                     style.SQL_KEYWORD('TABLE'),
393                     style.SQL_FIELD(self.quote_name(table)),
394                 ) for table in truncated_tables
395             ] + [
396                 "%s %s %s %s %s %s;" % (
397                     style.SQL_KEYWORD('ALTER'),
398                     style.SQL_KEYWORD('TABLE'),
399                     style.SQL_FIELD(self.quote_name(table)),
400                     style.SQL_KEYWORD('ENABLE'),
401                     style.SQL_KEYWORD('CONSTRAINT'),
402                     style.SQL_FIELD(self.quote_name(constraint)),
403                 ) for table, constraint in constraints
404             ]
405             # Since we've just deleted all the rows, running our sequence
406             # ALTER code will reset the sequence to 0.
407             sql.extend(self.sequence_reset_by_name_sql(style, sequences))
408             return sql
409         else:
410             return []
411 
412     def sequence_reset_by_name_sql(self, style, sequences):
413         sql = []
414         for sequence_info in sequences:
415             no_autofield_sequence_name = self._get_no_autofield_sequence_name(sequence_info['table'])
416             table = self.quote_name(sequence_info['table'])
417             column = self.quote_name(sequence_info['column'] or 'id')
418             query = self._sequence_reset_sql % {
419                 'no_autofield_sequence_name': no_autofield_sequence_name,
420                 'table': table,
421                 'column': column,
422                 'table_name': strip_quotes(table),
423                 'column_name': strip_quotes(column),
424             }
425             sql.append(query)
426         return sql
427 
428     def sequence_reset_sql(self, style, model_list):
429         from django.db import models
430         output = []
431         query = self._sequence_reset_sql
432         for model in model_list:
433             for f in model._meta.local_fields:
434                 if isinstance(f, models.AutoField):
435                     no_autofield_sequence_name = self._get_no_autofield_sequence_name(model._meta.db_table)
436                     table = self.quote_name(model._meta.db_table)
437                     column = self.quote_name(f.column)
438                     output.append(query % {
439                         'no_autofield_sequence_name': no_autofield_sequence_name,
440                         'table': table,
441                         'column': column,
442                         'table_name': strip_quotes(table),
443                         'column_name': strip_quotes(column),
444                     })
445                     # Only one AutoField is allowed per model, so don't
446                     # continue to loop
447                     break
448             for f in model._meta.many_to_many:
449                 if not f.remote_field.through:
450                     no_autofield_sequence_name = self._get_no_autofield_sequence_name(f.m2m_db_table())
451                     table = self.quote_name(f.m2m_db_table())
452                     column = self.quote_name('id')
453                     output.append(query % {
454                         'no_autofield_sequence_name': no_autofield_sequence_name,
455                         'table': table,
456                         'column': column,
457                         'table_name': strip_quotes(table),
458                         'column_name': 'ID',
459                     })
460         return output
461 
462     def start_transaction_sql(self):
463         return ''
464 
465     def tablespace_sql(self, tablespace, inline=False):
466         if inline:
467             return "USING INDEX TABLESPACE %s" % self.quote_name(tablespace)
468         else:
469             return "TABLESPACE %s" % self.quote_name(tablespace)
470 
471     def adapt_datefield_value(self, value):
472         """
473         Transform a date value to an object compatible with what is expected
474         by the backend driver for date columns.
475         The default implementation transforms the date to text, but that is not
476         necessary for Oracle.
477         """
478         return value
479 
480     def adapt_datetimefield_value(self, value):
481         """
482         Transform a datetime value to an object compatible with what is expected
483         by the backend driver for datetime columns.
484 
485         If naive datetime is passed assumes that is in UTC. Normally Django
486         models.DateTimeField makes sure that if USE_TZ is True passed datetime
487         is timezone aware.
488         """
489 
490         if value is None:
491             return None
492 
493         # Expression values are adapted by the database.
494         if hasattr(value, 'resolve_expression'):
495             return value
496 
497         # cx_Oracle doesn't support tz-aware datetimes
498         if timezone.is_aware(value):
499             if settings.USE_TZ:
500                 value = timezone.make_naive(value, self.connection.timezone)
501             else:
502                 raise ValueError("Oracle backend does not support timezone-aware datetimes when USE_TZ is False.")
503 
504         return Oracle_datetime.from_datetime(value)
505 
506     def adapt_timefield_value(self, value):
507         if value is None:
508             return None
509 
510         # Expression values are adapted by the database.
511         if hasattr(value, 'resolve_expression'):
512             return value
513 
514         if isinstance(value, str):
515             return datetime.datetime.strptime(value, '%H:%M:%S')
516 
517         # Oracle doesn't support tz-aware times
518         if timezone.is_aware(value):
519             raise ValueError("Oracle backend does not support timezone-aware times.")
520 
521         return Oracle_datetime(1900, 1, 1, value.hour, value.minute,
522                                value.second, value.microsecond)
523 
524     def combine_expression(self, connector, sub_expressions):
525         lhs, rhs = sub_expressions
526         if connector == '%%':
527             return 'MOD(%s)' % ','.join(sub_expressions)
528         elif connector == '&':
529             return 'BITAND(%s)' % ','.join(sub_expressions)
530         elif connector == '|':
531             return 'BITAND(-%(lhs)s-1,%(rhs)s)+%(lhs)s' % {'lhs': lhs, 'rhs': rhs}
532         elif connector == '<<':
533             return '(%(lhs)s * POWER(2, %(rhs)s))' % {'lhs': lhs, 'rhs': rhs}
534         elif connector == '>>':
535             return 'FLOOR(%(lhs)s / POWER(2, %(rhs)s))' % {'lhs': lhs, 'rhs': rhs}
536         elif connector == '^':
537             return 'POWER(%s)' % ','.join(sub_expressions)
538         return super().combine_expression(connector, sub_expressions)
539 
540     def _get_no_autofield_sequence_name(self, table):
541         """
542         Manually created sequence name to keep backward compatibility for
543         AutoFields that aren't Oracle identity columns.
544         """
545         name_length = self.max_name_length() - 3
546         return '%s_SQ' % truncate_name(strip_quotes(table), name_length).upper()
547 
548     def _get_sequence_name(self, cursor, table, pk_name):
549         cursor.execute("""
550             SELECT sequence_name
551             FROM user_tab_identity_cols
552             WHERE table_name = UPPER(%s)
553             AND column_name = UPPER(%s)""", [table, pk_name])
554         row = cursor.fetchone()
555         return self._get_no_autofield_sequence_name(table) if row is None else row[0]
556 
557     def bulk_insert_sql(self, fields, placeholder_rows):
558         query = []
559         for row in placeholder_rows:
560             select = []
561             for i, placeholder in enumerate(row):
562                 # A model without any fields has fields=[None].
563                 if fields[i]:
564                     internal_type = getattr(fields[i], 'target_field', fields[i]).get_internal_type()
565                     placeholder = BulkInsertMapper.types.get(internal_type, '%s') % placeholder
566                 # Add columns aliases to the first select to avoid "ORA-00918:
567                 # column ambiguously defined" when two or more columns in the
568                 # first select have the same value.
569                 if not query:
570                     placeholder = '%s col_%s' % (placeholder, i)
571                 select.append(placeholder)
572             query.append('SELECT %s FROM DUAL' % ', '.join(select))
573         # Bulk insert to tables with Oracle identity columns causes Oracle to
574         # add sequence.nextval to it. Sequence.nextval cannot be used with the
575         # UNION operator. To prevent incorrect SQL, move UNION to a subquery.
576         return 'SELECT * FROM (%s)' % ' UNION ALL '.join(query)
577 
578     def subtract_temporals(self, internal_type, lhs, rhs):
579         if internal_type == 'DateField':
580             lhs_sql, lhs_params = lhs
581             rhs_sql, rhs_params = rhs
582             return "NUMTODSINTERVAL(TO_NUMBER(%s - %s), 'DAY')" % (lhs_sql, rhs_sql), lhs_params + rhs_params
583         return super().subtract_temporals(internal_type, lhs, rhs)
584 
585     def bulk_batch_size(self, fields, objs):
586         """Oracle restricts the number of parameters in a query."""
587         if fields:
588             return self.connection.features.max_query_params // len(fields)
589         return len(objs)

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>, <file>django/db/backends/postgresql/operations.py</file>
<class>DatabaseOperations</class>
<method>None</method>
<code>
8 class DatabaseOperations(BaseDatabaseOperations):
9     cast_char_field_without_max_length = 'varchar'
10     explain_prefix = 'EXPLAIN'
11     cast_data_types = {
12         'AutoField': 'integer',
13         'BigAutoField': 'bigint',
14     }
15 
16     def unification_cast_sql(self, output_field):
17         internal_type = output_field.get_internal_type()
18         if internal_type in ("GenericIPAddressField", "IPAddressField", "TimeField", "UUIDField"):
19             # PostgreSQL will resolve a union as type 'text' if input types are
20             # 'unknown'.
21             # https://www.postgresql.org/docs/current/typeconv-union-case.html
22             # These fields cannot be implicitly cast back in the default
23             # PostgreSQL configuration so we need to explicitly cast them.
24             # We must also remove components of the type within brackets:
25             # varchar(255) -> varchar.
26             return 'CAST(%%s AS %s)' % output_field.db_type(self.connection).split('(')[0]
27         return '%s'
28 
29     def date_extract_sql(self, lookup_type, field_name):
30         # https://www.postgresql.org/docs/current/functions-datetime.html#FUNCTIONS-DATETIME-EXTRACT
31         if lookup_type == 'week_day':
32             # For consistency across backends, we return Sunday=1, Saturday=7.
33             return "EXTRACT('dow' FROM %s) + 1" % field_name
34         elif lookup_type == 'iso_year':
35             return "EXTRACT('isoyear' FROM %s)" % field_name
36         else:
37             return "EXTRACT('%s' FROM %s)" % (lookup_type, field_name)
38 
39     def date_trunc_sql(self, lookup_type, field_name):
40         # https://www.postgresql.org/docs/current/functions-datetime.html#FUNCTIONS-DATETIME-TRUNC
41         return "DATE_TRUNC('%s', %s)" % (lookup_type, field_name)
42 
43     def _convert_field_to_tz(self, field_name, tzname):
44         if settings.USE_TZ:
45             field_name = "%s AT TIME ZONE '%s'" % (field_name, tzname)
46         return field_name
47 
48     def datetime_cast_date_sql(self, field_name, tzname):
49         field_name = self._convert_field_to_tz(field_name, tzname)
50         return '(%s)::date' % field_name
51 
52     def datetime_cast_time_sql(self, field_name, tzname):
53         field_name = self._convert_field_to_tz(field_name, tzname)
54         return '(%s)::time' % field_name
55 
56     def datetime_extract_sql(self, lookup_type, field_name, tzname):
57         field_name = self._convert_field_to_tz(field_name, tzname)
58         return self.date_extract_sql(lookup_type, field_name)
59 
60     def datetime_trunc_sql(self, lookup_type, field_name, tzname):
61         field_name = self._convert_field_to_tz(field_name, tzname)
62         # https://www.postgresql.org/docs/current/functions-datetime.html#FUNCTIONS-DATETIME-TRUNC
63         return "DATE_TRUNC('%s', %s)" % (lookup_type, field_name)
64 
65     def time_trunc_sql(self, lookup_type, field_name):
66         return "DATE_TRUNC('%s', %s)::time" % (lookup_type, field_name)
67 
68     def deferrable_sql(self):
69         return " DEFERRABLE INITIALLY DEFERRED"
70 
71     def fetch_returned_insert_ids(self, cursor):
72         """
73         Given a cursor object that has just performed an INSERT...RETURNING
74         statement into a table that has an auto-incrementing ID, return the
75         list of newly created IDs.
76         """
77         return [item[0] for item in cursor.fetchall()]
78 
79     def lookup_cast(self, lookup_type, internal_type=None):
80         lookup = '%s'
81 
82         # Cast text lookups to text to allow things like filter(x__contains=4)
83         if lookup_type in ('iexact', 'contains', 'icontains', 'startswith',
84                            'istartswith', 'endswith', 'iendswith', 'regex', 'iregex'):
85             if internal_type in ('IPAddressField', 'GenericIPAddressField'):
86                 lookup = "HOST(%s)"
87             elif internal_type in ('CICharField', 'CIEmailField', 'CITextField'):
88                 lookup = '%s::citext'
89             else:
90                 lookup = "%s::text"
91 
92         # Use UPPER(x) for case-insensitive lookups; it's faster.
93         if lookup_type in ('iexact', 'icontains', 'istartswith', 'iendswith'):
94             lookup = 'UPPER(%s)' % lookup
95 
96         return lookup
97 
98     def no_limit_value(self):
99         return None
100 
101     def prepare_sql_script(self, sql):
102         return [sql]
103 
104     def quote_name(self, name):
105         if name.startswith('"') and name.endswith('"'):
106             return name  # Quoting once is enough.
107         return '"%s"' % name
108 
109     def set_time_zone_sql(self):
110         return "SET TIME ZONE %s"
111 
112     def sql_flush(self, style, tables, sequences, allow_cascade=False):
113         if tables:
114             # Perform a single SQL 'TRUNCATE x, y, z...;' statement.  It allows
115             # us to truncate tables referenced by a foreign key in any other
116             # table.
117             tables_sql = ', '.join(
118                 style.SQL_FIELD(self.quote_name(table)) for table in tables)
119             if allow_cascade:
120                 sql = ['%s %s %s;' % (
121                     style.SQL_KEYWORD('TRUNCATE'),
122                     tables_sql,
123                     style.SQL_KEYWORD('CASCADE'),
124                 )]
125             else:
126                 sql = ['%s %s;' % (
127                     style.SQL_KEYWORD('TRUNCATE'),
128                     tables_sql,
129                 )]
130             sql.extend(self.sequence_reset_by_name_sql(style, sequences))
131             return sql
132         else:
133             return []
134 
135     def sequence_reset_by_name_sql(self, style, sequences):
136         # 'ALTER SEQUENCE sequence_name RESTART WITH 1;'... style SQL statements
137         # to reset sequence indices
138         sql = []
139         for sequence_info in sequences:
140             table_name = sequence_info['table']
141             # 'id' will be the case if it's an m2m using an autogenerated
142             # intermediate table (see BaseDatabaseIntrospection.sequence_list).
143             column_name = sequence_info['column'] or 'id'
144             sql.append("%s setval(pg_get_serial_sequence('%s','%s'), 1, false);" % (
145                 style.SQL_KEYWORD('SELECT'),
146                 style.SQL_TABLE(self.quote_name(table_name)),
147                 style.SQL_FIELD(column_name),
148             ))
149         return sql
150 
151     def tablespace_sql(self, tablespace, inline=False):
152         if inline:
153             return "USING INDEX TABLESPACE %s" % self.quote_name(tablespace)
154         else:
155             return "TABLESPACE %s" % self.quote_name(tablespace)
156 
157     def sequence_reset_sql(self, style, model_list):
158         from django.db import models
159         output = []
160         qn = self.quote_name
161         for model in model_list:
162             # Use `coalesce` to set the sequence for each model to the max pk value if there are records,
163             # or 1 if there are none. Set the `is_called` property (the third argument to `setval`) to true
164             # if there are records (as the max pk value is already in use), otherwise set it to false.
165             # Use pg_get_serial_sequence to get the underlying sequence name from the table name
166             # and column name (available since PostgreSQL 8)
167 
168             for f in model._meta.local_fields:
169                 if isinstance(f, models.AutoField):
170                     output.append(
171                         "%s setval(pg_get_serial_sequence('%s','%s'), "
172                         "coalesce(max(%s), 1), max(%s) %s null) %s %s;" % (
173                             style.SQL_KEYWORD('SELECT'),
174                             style.SQL_TABLE(qn(model._meta.db_table)),
175                             style.SQL_FIELD(f.column),
176                             style.SQL_FIELD(qn(f.column)),
177                             style.SQL_FIELD(qn(f.column)),
178                             style.SQL_KEYWORD('IS NOT'),
179                             style.SQL_KEYWORD('FROM'),
180                             style.SQL_TABLE(qn(model._meta.db_table)),
181                         )
182                     )
183                     break  # Only one AutoField is allowed per model, so don't bother continuing.
184             for f in model._meta.many_to_many:
185                 if not f.remote_field.through:
186                     output.append(
187                         "%s setval(pg_get_serial_sequence('%s','%s'), "
188                         "coalesce(max(%s), 1), max(%s) %s null) %s %s;" % (
189                             style.SQL_KEYWORD('SELECT'),
190                             style.SQL_TABLE(qn(f.m2m_db_table())),
191                             style.SQL_FIELD('id'),
192                             style.SQL_FIELD(qn('id')),
193                             style.SQL_FIELD(qn('id')),
194                             style.SQL_KEYWORD('IS NOT'),
195                             style.SQL_KEYWORD('FROM'),
196                             style.SQL_TABLE(qn(f.m2m_db_table()))
197                         )
198                     )
199         return output
200 
201     def prep_for_iexact_query(self, x):
202         return x
203 
204     def max_name_length(self):
205         """
206         Return the maximum length of an identifier.
207 
208         The maximum length of an identifier is 63 by default, but can be
209         changed by recompiling PostgreSQL after editing the NAMEDATALEN
210         macro in src/include/pg_config_manual.h.
211 
212         This implementation returns 63, but can be overridden by a custom
213         database backend that inherits most of its behavior from this one.
214         """
215         return 63
216 
217     def distinct_sql(self, fields, params):
218         if fields:
219             params = [param for param_list in params for param in param_list]
220             return (['DISTINCT ON (%s)' % ', '.join(fields)], params)
221         else:
222             return ['DISTINCT'], []
223 
224     def last_executed_query(self, cursor, sql, params):
225         # http://initd.org/psycopg/docs/cursor.html#cursor.query
226         # The query attribute is a Psycopg extension to the DB API 2.0.
227         if cursor.query is not None:
228             return cursor.query.decode()
229         return None
230 
231     def return_insert_id(self):
232         return "RETURNING %s", ()
233 
234     def bulk_insert_sql(self, fields, placeholder_rows):
235         placeholder_rows_sql = (", ".join(row) for row in placeholder_rows)
236         values_sql = ", ".join("(%s)" % sql for sql in placeholder_rows_sql)
237         return "VALUES " + values_sql
238 
239     def adapt_datefield_value(self, value):
240         return value
241 
242     def adapt_datetimefield_value(self, value):
243         return value
244 
245     def adapt_timefield_value(self, value):
246         return value
247 
248     def adapt_ipaddressfield_value(self, value):
249         if value:
250             return Inet(value)
251         return None
252 
253     def subtract_temporals(self, internal_type, lhs, rhs):
254         if internal_type == 'DateField':
255             lhs_sql, lhs_params = lhs
256             rhs_sql, rhs_params = rhs
257             return "(interval '1 day' * (%s - %s))" % (lhs_sql, rhs_sql), lhs_params + rhs_params
258         return super().subtract_temporals(internal_type, lhs, rhs)
259 
260     def window_frame_range_start_end(self, start=None, end=None):
261         start_, end_ = super().window_frame_range_start_end(start, end)
262         if (start and start < 0) or (end and end > 0):
263             raise NotSupportedError(
264                 'PostgreSQL only supports UNBOUNDED together with PRECEDING '
265                 'and FOLLOWING.'
266             )
267         return start_, end_
268 
269     def explain_query_prefix(self, format=None, **options):
270         prefix = super().explain_query_prefix(format)
271         extra = {}
272         if format:
273             extra['FORMAT'] = format
274         if options:
275             extra.update({
276                 name.upper(): 'true' if value else 'false'
277                 for name, value in options.items()
278             })
279         if extra:
280             prefix += ' (%s)' % ', '.join('%s %s' % i for i in extra.items())
281         return prefix
282 
283     def ignore_conflicts_suffix_sql(self, ignore_conflicts=None):
284         return 'ON CONFLICT DO NOTHING' if ignore_conflicts else super().ignore_conflicts_suffix_sql(ignore_conflicts)

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>, <file>django/db/backends/mysql/operations.py</file>
<class>DatabaseOperations</class>
<method>None</method>
<code>
9 class DatabaseOperations(BaseDatabaseOperations):
10     compiler_module = "django.db.backends.mysql.compiler"
11 
12     # MySQL stores positive fields as UNSIGNED ints.
13     integer_field_ranges = {
14         **BaseDatabaseOperations.integer_field_ranges,
15         'PositiveSmallIntegerField': (0, 65535),
16         'PositiveIntegerField': (0, 4294967295),
17     }
18     cast_data_types = {
19         'AutoField': 'signed integer',
20         'BigAutoField': 'signed integer',
21         'CharField': 'char(%(max_length)s)',
22         'DecimalField': 'decimal(%(max_digits)s, %(decimal_places)s)',
23         'TextField': 'char',
24         'IntegerField': 'signed integer',
25         'BigIntegerField': 'signed integer',
26         'SmallIntegerField': 'signed integer',
27         'PositiveIntegerField': 'unsigned integer',
28         'PositiveSmallIntegerField': 'unsigned integer',
29     }
30     cast_char_field_without_max_length = 'char'
31     explain_prefix = 'EXPLAIN'
32 
33     def date_extract_sql(self, lookup_type, field_name):
34         # https://dev.mysql.com/doc/mysql/en/date-and-time-functions.html
35         if lookup_type == 'week_day':
36             # DAYOFWEEK() returns an integer, 1-7, Sunday=1.
37             # Note: WEEKDAY() returns 0-6, Monday=0.
38             return "DAYOFWEEK(%s)" % field_name
39         elif lookup_type == 'week':
40             # Override the value of default_week_format for consistency with
41             # other database backends.
42             # Mode 3: Monday, 1-53, with 4 or more days this year.
43             return "WEEK(%s, 3)" % field_name
44         elif lookup_type == 'iso_year':
45             # Get the year part from the YEARWEEK function, which returns a
46             # number as year * 100 + week.
47             return "TRUNCATE(YEARWEEK(%s, 3), -2) / 100" % field_name
48         else:
49             # EXTRACT returns 1-53 based on ISO-8601 for the week number.
50             return "EXTRACT(%s FROM %s)" % (lookup_type.upper(), field_name)
51 
52     def date_trunc_sql(self, lookup_type, field_name):
53         fields = {
54             'year': '%%Y-01-01',
55             'month': '%%Y-%%m-01',
56         }  # Use double percents to escape.
57         if lookup_type in fields:
58             format_str = fields[lookup_type]
59             return "CAST(DATE_FORMAT(%s, '%s') AS DATE)" % (field_name, format_str)
60         elif lookup_type == 'quarter':
61             return "MAKEDATE(YEAR(%s), 1) + INTERVAL QUARTER(%s) QUARTER - INTERVAL 1 QUARTER" % (
62                 field_name, field_name
63             )
64         elif lookup_type == 'week':
65             return "DATE_SUB(%s, INTERVAL WEEKDAY(%s) DAY)" % (
66                 field_name, field_name
67             )
68         else:
69             return "DATE(%s)" % (field_name)
70 
71     def _convert_field_to_tz(self, field_name, tzname):
72         if settings.USE_TZ:
73             field_name = "CONVERT_TZ(%s, 'UTC', '%s')" % (field_name, tzname)
74         return field_name
75 
76     def datetime_cast_date_sql(self, field_name, tzname):
77         field_name = self._convert_field_to_tz(field_name, tzname)
78         return "DATE(%s)" % field_name
79 
80     def datetime_cast_time_sql(self, field_name, tzname):
81         field_name = self._convert_field_to_tz(field_name, tzname)
82         return "TIME(%s)" % field_name
83 
84     def datetime_extract_sql(self, lookup_type, field_name, tzname):
85         field_name = self._convert_field_to_tz(field_name, tzname)
86         return self.date_extract_sql(lookup_type, field_name)
87 
88     def datetime_trunc_sql(self, lookup_type, field_name, tzname):
89         field_name = self._convert_field_to_tz(field_name, tzname)
90         fields = ['year', 'month', 'day', 'hour', 'minute', 'second']
91         format = ('%%Y-', '%%m', '-%%d', ' %%H:', '%%i', ':%%s')  # Use double percents to escape.
92         format_def = ('0000-', '01', '-01', ' 00:', '00', ':00')
93         if lookup_type == 'quarter':
94             return (
95                 "CAST(DATE_FORMAT(MAKEDATE(YEAR({field_name}), 1) + "
96                 "INTERVAL QUARTER({field_name}) QUARTER - " +
97                 "INTERVAL 1 QUARTER, '%%Y-%%m-01 00:00:00') AS DATETIME)"
98             ).format(field_name=field_name)
99         if lookup_type == 'week':
100             return (
101                 "CAST(DATE_FORMAT(DATE_SUB({field_name}, "
102                 "INTERVAL WEEKDAY({field_name}) DAY), "
103                 "'%%Y-%%m-%%d 00:00:00') AS DATETIME)"
104             ).format(field_name=field_name)
105         try:
106             i = fields.index(lookup_type) + 1
107         except ValueError:
108             sql = field_name
109         else:
110             format_str = ''.join(format[:i] + format_def[i:])
111             sql = "CAST(DATE_FORMAT(%s, '%s') AS DATETIME)" % (field_name, format_str)
112         return sql
113 
114     def time_trunc_sql(self, lookup_type, field_name):
115         fields = {
116             'hour': '%%H:00:00',
117             'minute': '%%H:%%i:00',
118             'second': '%%H:%%i:%%s',
119         }  # Use double percents to escape.
120         if lookup_type in fields:
121             format_str = fields[lookup_type]
122             return "CAST(DATE_FORMAT(%s, '%s') AS TIME)" % (field_name, format_str)
123         else:
124             return "TIME(%s)" % (field_name)
125 
126     def date_interval_sql(self, timedelta):
127         return 'INTERVAL %s MICROSECOND' % duration_microseconds(timedelta)
128 
129     def format_for_duration_arithmetic(self, sql):
130         return 'INTERVAL %s MICROSECOND' % sql
131 
132     def force_no_ordering(self):
133         """
134         "ORDER BY NULL" prevents MySQL from implicitly ordering by grouped
135         columns. If no ordering would otherwise be applied, we don't want any
136         implicit sorting going on.
137         """
138         return [(None, ("NULL", [], False))]
139 
140     def last_executed_query(self, cursor, sql, params):
141         # With MySQLdb, cursor objects have an (undocumented) "_executed"
142         # attribute where the exact query sent to the database is saved.
143         # See MySQLdb/cursors.py in the source distribution.
144         query = getattr(cursor, '_executed', None)
145         if query is not None:
146             query = query.decode(errors='replace')
147         return query
148 
149     def no_limit_value(self):
150         # 2**64 - 1, as recommended by the MySQL documentation
151         return 18446744073709551615
152 
153     def quote_name(self, name):
154         if name.startswith("`") and name.endswith("`"):
155             return name  # Quoting once is enough.
156         return "`%s`" % name
157 
158     def random_function_sql(self):
159         return 'RAND()'
160 
161     def sql_flush(self, style, tables, sequences, allow_cascade=False):
162         # NB: The generated SQL below is specific to MySQL
163         # 'TRUNCATE x;', 'TRUNCATE y;', 'TRUNCATE z;'... style SQL statements
164         # to clear all tables of all data
165         if tables:
166             sql = ['SET FOREIGN_KEY_CHECKS = 0;']
167             for table in tables:
168                 sql.append('%s %s;' % (
169                     style.SQL_KEYWORD('TRUNCATE'),
170                     style.SQL_FIELD(self.quote_name(table)),
171                 ))
172             sql.append('SET FOREIGN_KEY_CHECKS = 1;')
173             sql.extend(self.sequence_reset_by_name_sql(style, sequences))
174             return sql
175         else:
176             return []
177 
178     def validate_autopk_value(self, value):
179         # MySQLism: zero in AUTO_INCREMENT field does not work. Refs #17653.
180         if value == 0:
181             raise ValueError('The database backend does not accept 0 as a '
182                              'value for AutoField.')
183         return value
184 
185     def adapt_datetimefield_value(self, value):
186         if value is None:
187             return None
188 
189         # Expression values are adapted by the database.
190         if hasattr(value, 'resolve_expression'):
191             return value
192 
193         # MySQL doesn't support tz-aware datetimes
194         if timezone.is_aware(value):
195             if settings.USE_TZ:
196                 value = timezone.make_naive(value, self.connection.timezone)
197             else:
198                 raise ValueError("MySQL backend does not support timezone-aware datetimes when USE_TZ is False.")
199         return str(value)
200 
201     def adapt_timefield_value(self, value):
202         if value is None:
203             return None
204 
205         # Expression values are adapted by the database.
206         if hasattr(value, 'resolve_expression'):
207             return value
208 
209         # MySQL doesn't support tz-aware times
210         if timezone.is_aware(value):
211             raise ValueError("MySQL backend does not support timezone-aware times.")
212 
213         return str(value)
214 
215     def max_name_length(self):
216         return 64
217 
218     def bulk_insert_sql(self, fields, placeholder_rows):
219         placeholder_rows_sql = (", ".join(row) for row in placeholder_rows)
220         values_sql = ", ".join("(%s)" % sql for sql in placeholder_rows_sql)
221         return "VALUES " + values_sql
222 
223     def combine_expression(self, connector, sub_expressions):
224         if connector == '^':
225             return 'POW(%s)' % ','.join(sub_expressions)
226         # Convert the result to a signed integer since MySQL's binary operators
227         # return an unsigned integer.
228         elif connector in ('&', '|', '<<'):
229             return 'CONVERT(%s, SIGNED)' % connector.join(sub_expressions)
230         elif connector == '>>':
231             lhs, rhs = sub_expressions
232             return 'FLOOR(%(lhs)s / POW(2, %(rhs)s))' % {'lhs': lhs, 'rhs': rhs}
233         return super().combine_expression(connector, sub_expressions)
234 
235     def get_db_converters(self, expression):
236         converters = super().get_db_converters(expression)
237         internal_type = expression.output_field.get_internal_type()
238         if internal_type in ['BooleanField', 'NullBooleanField']:
239             converters.append(self.convert_booleanfield_value)
240         elif internal_type == 'DateTimeField':
241             if settings.USE_TZ:
242                 converters.append(self.convert_datetimefield_value)
243         elif internal_type == 'UUIDField':
244             converters.append(self.convert_uuidfield_value)
245         return converters
246 
247     def convert_booleanfield_value(self, value, expression, connection):
248         if value in (0, 1):
249             value = bool(value)
250         return value
251 
252     def convert_datetimefield_value(self, value, expression, connection):
253         if value is not None:
254             value = timezone.make_aware(value, self.connection.timezone)
255         return value
256 
257     def convert_uuidfield_value(self, value, expression, connection):
258         if value is not None:
259             value = uuid.UUID(value)
260         return value
261 
262     def binary_placeholder_sql(self, value):
263         return '_binary %s' if value is not None and not hasattr(value, 'as_sql') else '%s'
264 
265     def subtract_temporals(self, internal_type, lhs, rhs):
266         lhs_sql, lhs_params = lhs
267         rhs_sql, rhs_params = rhs
268         if internal_type == 'TimeField':
269             if self.connection.mysql_is_mariadb:
270                 # MariaDB includes the microsecond component in TIME_TO_SEC as
271                 # a decimal. MySQL returns an integer without microseconds.
272                 return 'CAST((TIME_TO_SEC(%(lhs)s) - TIME_TO_SEC(%(rhs)s)) * 1000000 AS SIGNED)' % {
273                     'lhs': lhs_sql, 'rhs': rhs_sql
274                 }, lhs_params + rhs_params
275             return (
276                 "((TIME_TO_SEC(%(lhs)s) * 1000000 + MICROSECOND(%(lhs)s)) -"
277                 " (TIME_TO_SEC(%(rhs)s) * 1000000 + MICROSECOND(%(rhs)s)))"
278             ) % {'lhs': lhs_sql, 'rhs': rhs_sql}, lhs_params * 2 + rhs_params * 2
279         else:
280             return "TIMESTAMPDIFF(MICROSECOND, %s, %s)" % (rhs_sql, lhs_sql), rhs_params + lhs_params
281 
282     def explain_query_prefix(self, format=None, **options):
283         # Alias MySQL's TRADITIONAL to TEXT for consistency with other backends.
284         if format and format.upper() == 'TEXT':
285             format = 'TRADITIONAL'
286         prefix = super().explain_query_prefix(format, **options)
287         if format:
288             prefix += ' FORMAT=%s' % format
289         if self.connection.features.needs_explain_extended and format is None:
290             # EXTENDED and FORMAT are mutually exclusive options.
291             prefix += ' EXTENDED'
292         return prefix
293 
294     def regex_lookup(self, lookup_type):
295         # REGEXP BINARY doesn't work correctly in MySQL 8+ and REGEXP_LIKE
296         # doesn't exist in MySQL 5.6 or in MariaDB.
297         if self.connection.mysql_version < (8, 0, 0) or self.connection.mysql_is_mariadb:
298             if lookup_type == 'regex':
299                 return '%s REGEXP BINARY %s'
300             return '%s REGEXP %s'
301 
302         match_option = 'c' if lookup_type == 'regex' else 'i'
303         return "REGEXP_LIKE(%%s, %%s, '%s')" % match_option
304 
305     def insert_statement(self, ignore_conflicts=False):
306         return 'INSERT IGNORE INTO' if ignore_conflicts else super().insert_statement(ignore_conflicts)

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>]
2025-10-18 10:21:14.086 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-18 10:21:14.086 | INFO     | Search-only: skipping patch selection
2025-10-18 10:21:14.261 | INFO     | Task django__django-11138 completed successfully.
2025-10-18 10:21:14.261 | INFO     | No patch generated. You can try running ACR again.
