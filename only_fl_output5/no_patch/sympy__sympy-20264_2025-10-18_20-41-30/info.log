2025-10-18 20:41:30.472 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-18 20:41:39.537 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2152, output_tokens=12, cost=0.021880
2025-10-18 20:41:49.615 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2332, output_tokens=446, cost=0.036700
2025-10-18 20:41:51.510 | INFO     | registered non reproducing test 0
2025-10-18 20:42:02.360 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=5983, output_tokens=473, cost=0.074020
2025-10-18 20:42:03.734 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 20:42:10.686 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2325, output_tokens=315, cost=0.032700
2025-10-18 20:42:10.693 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 20:42:13.797 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=669, output_tokens=70, cost=0.008790
2025-10-18 20:42:13.799 | DEBUG    | Extracted a valid json.
2025-10-18 20:42:13.799 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_method(\"latex\")",
        "search_class(\"LatexPrinter\")",
        "search_method_in_class(\"_print_Pow\", \"LatexPrinter\")",
        "search_method_in_class(\"_print_Mul\", \"LatexPrinter\")"
    ],
    "bug_locations": []
}
2025-10-18 20:42:13.932 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-18 20:42:13.933 | DEBUG    | <Agent search> Analyzing search results.
2025-10-18 20:42:31.133 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=11395, output_tokens=665, cost=0.133900
2025-10-18 20:42:31.147 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 20:42:41.279 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=12276, output_tokens=376, cost=0.134040
2025-10-18 20:42:41.288 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 20:42:48.921 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=730, output_tokens=343, cost=0.017590
2025-10-18 20:42:48.923 | DEBUG    | Extracted a valid json.
2025-10-18 20:42:48.923 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "sympy/printing/latex.py",
            "class": "LatexPrinter",
            "method": "_print_Pow",
            "intended_behavior": "The `_print_Pow` method should incorporate a condition or modification to correctly handle expressions in the form of `Pow(Rational(1, n), -1, evaluate=False)` for `n` as a positive integer (or its equivalent for negative integers but with n < -1). When encountering such expressions, rather than possibly falling into a recursive conversion process, it should directly convert them into a simple LaTeX fraction format, `\\frac{n}{1}` or its appropriate form based on the sign and magnitude of `n`. This adjustment should be made in a way that respects the evaluate flag being False, ensuring no unintended simplification occurs in non-target cases."
        },
        {
            "file": "sympy/printing/latex.py",
            "class": "LatexPrinter",
            "method": "_print_Mul",
            "intended_behavior": "The `_print_Mul` method may need adjustments to ensure that it can correctly handle and format the multiplication expressions especially arising from the conversion of `Pow` types that represent reciprocal or negative powers. Given the `RecursionError`, a potential solution involves implementing checks or mechanisms that prevent unnecessary or erroneous recursion when dealing with `Pow` expressions formatted by `_print_Pow`. Any fix here must seamlessly integrate with the handling of different types of multiplication expressions, maintaining the method's general utility while ensuring correct output for cases that previously led to errors."
        }
    ]
}
2025-10-18 20:42:48.940 | DEBUG    | Bug location extracted successfully: [<file>sympy/printing/latex.py</file>
<class>LatexPrinter</class>
<method>_print_Pow</method>
<code>
613     def _print_Pow(self, expr):
614         # Treat x**Rational(1,n) as special case
615         if expr.exp.is_Rational and abs(expr.exp.p) == 1 and expr.exp.q != 1 \
616                 and self._settings['root_notation']:
617             base = self._print(expr.base)
618             expq = expr.exp.q
619 
620             if expq == 2:
621                 tex = r"\sqrt{%s}" % base
622             elif self._settings['itex']:
623                 tex = r"\root{%d}{%s}" % (expq, base)
624             else:
625                 tex = r"\sqrt[%d]{%s}" % (expq, base)
626 
627             if expr.exp.is_negative:
628                 return r"\frac{1}{%s}" % tex
629             else:
630                 return tex
631         elif self._settings['fold_frac_powers'] \
632             and expr.exp.is_Rational \
633                 and expr.exp.q != 1:
634             base = self.parenthesize(expr.base, PRECEDENCE['Pow'])
635             p, q = expr.exp.p, expr.exp.q
636             # issue #12886: add parentheses for superscripts raised to powers
637             if expr.base.is_Symbol:
638                 base = self.parenthesize_super(base)
639             if expr.base.is_Function:
640                 return self._print(expr.base, exp="%s/%s" % (p, q))
641             return r"%s^{%s/%s}" % (base, p, q)
642         elif expr.exp.is_Rational and expr.exp.is_negative and \
643                 expr.base.is_commutative:
644             # special case for 1^(-x), issue 9216
645             if expr.base == 1:
646                 return r"%s^{%s}" % (expr.base, expr.exp)
647             # things like 1/x
648             return self._print_Mul(expr)
649         else:
650             if expr.base.is_Function:
651                 return self._print(expr.base, exp=self._print(expr.exp))
652             else:
653                 tex = r"%s^{%s}"
654                 return self._helper_print_standard_power(expr, tex)

</code><intended_behavior>The `_print_Pow` method should incorporate a condition or modification to correctly handle expressions in the form of `Pow(Rational(1, n), -1, evaluate=False)` for `n` as a positive integer (or its equivalent for negative integers but with n < -1). When encountering such expressions, rather than possibly falling into a recursive conversion process, it should directly convert them into a simple LaTeX fraction format, `\frac{n}{1}` or its appropriate form based on the sign and magnitude of `n`. This adjustment should be made in a way that respects the evaluate flag being False, ensuring no unintended simplification occurs in non-target cases.</intended_behavior>, <file>sympy/printing/latex.py</file>
<class>LatexPrinter</class>
<method>None</method>
<code>
137 class LatexPrinter(Printer):
138     printmethod = "_latex"
139 
140     _default_settings = {
141         "full_prec": False,
142         "fold_frac_powers": False,
143         "fold_func_brackets": False,
144         "fold_short_frac": None,
145         "inv_trig_style": "abbreviated",
146         "itex": False,
147         "ln_notation": False,
148         "long_frac_ratio": None,
149         "mat_delim": "[",
150         "mat_str": None,
151         "mode": "plain",
152         "mul_symbol": None,
153         "order": None,
154         "symbol_names": {},
155         "root_notation": True,
156         "mat_symbol_style": "plain",
157         "imaginary_unit": "i",
158         "gothic_re_im": False,
159         "decimal_separator": "period",
160         "perm_cyclic": True,
161         "parenthesize_super": True,
162         "min": None,
163         "max": None,
164     }  # type: Dict[str, Any]
165 
166     def __init__(self, settings=None):
167         Printer.__init__(self, settings)
168 
169         if 'mode' in self._settings:
170             valid_modes = ['inline', 'plain', 'equation',
171                            'equation*']
172             if self._settings['mode'] not in valid_modes:
173                 raise ValueError("'mode' must be one of 'inline', 'plain', "
174                                  "'equation' or 'equation*'")
175 
176         if self._settings['fold_short_frac'] is None and \
177                 self._settings['mode'] == 'inline':
178             self._settings['fold_short_frac'] = True
179 
180         mul_symbol_table = {
181             None: r" ",
182             "ldot": r" \,.\, ",
183             "dot": r" \cdot ",
184             "times": r" \times "
185         }
186         try:
187             self._settings['mul_symbol_latex'] = \
188                 mul_symbol_table[self._settings['mul_symbol']]
189         except KeyError:
190             self._settings['mul_symbol_latex'] = \
191                 self._settings['mul_symbol']
192         try:
193             self._settings['mul_symbol_latex_numbers'] = \
194                 mul_symbol_table[self._settings['mul_symbol'] or 'dot']
195         except KeyError:
196             if (self._settings['mul_symbol'].strip() in
197                     ['', ' ', '\\', '\\,', '\\:', '\\;', '\\quad']):
198                 self._settings['mul_symbol_latex_numbers'] = \
199                     mul_symbol_table['dot']
200             else:
201                 self._settings['mul_symbol_latex_numbers'] = \
202                     self._settings['mul_symbol']
203 
204         self._delim_dict = {'(': ')', '[': ']'}
205 
206         imaginary_unit_table = {
207             None: r"i",
208             "i": r"i",
209             "ri": r"\mathrm{i}",
210             "ti": r"\text{i}",
211             "j": r"j",
212             "rj": r"\mathrm{j}",
213             "tj": r"\text{j}",
214         }
215         try:
216             self._settings['imaginary_unit_latex'] = \
217                 imaginary_unit_table[self._settings['imaginary_unit']]
218         except KeyError:
219             self._settings['imaginary_unit_latex'] = \
220                 self._settings['imaginary_unit']
221 
222     def _add_parens(self, s):
223         return r"\left({}\right)".format(s)
224 
225     # TODO: merge this with the above, which requires a lot of test changes
226     def _add_parens_lspace(self, s):
227         return r"\left( {}\right)".format(s)
228 
229     def parenthesize(self, item, level, is_neg=False, strict=False):
230         prec_val = precedence_traditional(item)
231         if is_neg and strict:
232             return self._add_parens(self._print(item))
233 
234         if (prec_val < level) or ((not strict) and prec_val <= level):
235             return self._add_parens(self._print(item))
236         else:
237             return self._print(item)
238 
239     def parenthesize_super(self, s):
240         """
241         Protect superscripts in s
242 
243         If the parenthesize_super option is set, protect with parentheses, else
244         wrap in braces.
245         """
246         if "^" in s:
247             if self._settings['parenthesize_super']:
248                 return self._add_parens(s)
249             else:
250                 return "{{{}}}".format(s)
251         return s
252 
253     def doprint(self, expr):
254         tex = Printer.doprint(self, expr)
255 
256         if self._settings['mode'] == 'plain':
257             return tex
258         elif self._settings['mode'] == 'inline':
259             return r"$%s$" % tex
260         elif self._settings['itex']:
261             return r"$$%s$$" % tex
262         else:
263             env_str = self._settings['mode']
264             return r"\begin{%s}%s\end{%s}" % (env_str, tex, env_str)
265 
266     def _needs_brackets(self, expr):
267         """
268         Returns True if the expression needs to be wrapped in brackets when
269         printed, False otherwise. For example: a + b => True; a => False;
270         10 => False; -10 => True.
271         """
272         return not ((expr.is_Integer and expr.is_nonnegative)
273                     or (expr.is_Atom and (expr is not S.NegativeOne
274                                           and expr.is_Rational is False)))
275 
276     def _needs_function_brackets(self, expr):
277         """
278         Returns True if the expression needs to be wrapped in brackets when
279         passed as an argument to a function, False otherwise. This is a more
280         liberal version of _needs_brackets, in that many expressions which need
281         to be wrapped in brackets when added/subtracted/raised to a power do
282         not need them when passed to a function. Such an example is a*b.
283         """
284         if not self._needs_brackets(expr):
285             return False
286         else:
287             # Muls of the form a*b*c... can be folded
288             if expr.is_Mul and not self._mul_is_clean(expr):
289                 return True
290             # Pows which don't need brackets can be folded
291             elif expr.is_Pow and not self._pow_is_clean(expr):
292                 return True
293             # Add and Function always need brackets
294             elif expr.is_Add or expr.is_Function:
295                 return True
296             else:
297                 return False
298 
299     def _needs_mul_brackets(self, expr, first=False, last=False):
300         """
301         Returns True if the expression needs to be wrapped in brackets when
302         printed as part of a Mul, False otherwise. This is True for Add,
303         but also for some container objects that would not need brackets
304         when appearing last in a Mul, e.g. an Integral. ``last=True``
305         specifies that this expr is the last to appear in a Mul.
306         ``first=True`` specifies that this expr is the first to appear in
307         a Mul.
308         """
309         from sympy import Integral, Product, Sum
310 
311         if expr.is_Mul:
312             if not first and _coeff_isneg(expr):
313                 return True
314         elif precedence_traditional(expr) < PRECEDENCE["Mul"]:
315             return True
316         elif expr.is_Relational:
317             return True
318         if expr.is_Piecewise:
319             return True
320         if any([expr.has(x) for x in (Mod,)]):
321             return True
322         if (not last and
323                 any([expr.has(x) for x in (Integral, Product, Sum)])):
324             return True
325 
326         return False
327 
328     def _needs_add_brackets(self, expr):
329         """
330         Returns True if the expression needs to be wrapped in brackets when
331         printed as part of an Add, False otherwise.  This is False for most
332         things.
333         """
334         if expr.is_Relational:
335             return True
336         if any([expr.has(x) for x in (Mod,)]):
337             return True
338         if expr.is_Add:
339             return True
340         return False
341 
342     def _mul_is_clean(self, expr):
343         for arg in expr.args:
344             if arg.is_Function:
345                 return False
346         return True
347 
348     def _pow_is_clean(self, expr):
349         return not self._needs_brackets(expr.base)
350 
351     def _do_exponent(self, expr, exp):
352         if exp is not None:
353             return r"\left(%s\right)^{%s}" % (expr, exp)
354         else:
355             return expr
356 
357     def _print_Basic(self, expr):
358         ls = [self._print(o) for o in expr.args]
359         return self._deal_with_super_sub(expr.__class__.__name__) + \
360             r"\left(%s\right)" % ", ".join(ls)
361 
362     def _print_bool(self, e):
363         return r"\text{%s}" % e
364 
365     _print_BooleanTrue = _print_bool
366     _print_BooleanFalse = _print_bool
367 
368     def _print_NoneType(self, e):
369         return r"\text{%s}" % e
370 
371     def _print_Add(self, expr, order=None):
372         terms = self._as_ordered_terms(expr, order=order)
373 
374         tex = ""
375         for i, term in enumerate(terms):
376             if i == 0:
377                 pass
378             elif _coeff_isneg(term):
379                 tex += " - "
380                 term = -term
381             else:
382                 tex += " + "
383             term_tex = self._print(term)
384             if self._needs_add_brackets(term):
385                 term_tex = r"\left(%s\right)" % term_tex
386             tex += term_tex
387 
388         return tex
389 
390     def _print_Cycle(self, expr):
391         from sympy.combinatorics.permutations import Permutation
392         if expr.size == 0:
393             return r"\left( \right)"
394         expr = Permutation(expr)
395         expr_perm = expr.cyclic_form
396         siz = expr.size
397         if expr.array_form[-1] == siz - 1:
398             expr_perm = expr_perm + [[siz - 1]]
399         term_tex = ''
400         for i in expr_perm:
401             term_tex += str(i).replace(',', r"\;")
402         term_tex = term_tex.replace('[', r"\left( ")
403         term_tex = term_tex.replace(']', r"\right)")
404         return term_tex
405 
406     def _print_Permutation(self, expr):
407         from sympy.combinatorics.permutations import Permutation
408         from sympy.utilities.exceptions import SymPyDeprecationWarning
409 
410         perm_cyclic = Permutation.print_cyclic
411         if perm_cyclic is not None:
412             SymPyDeprecationWarning(
413                 feature="Permutation.print_cyclic = {}".format(perm_cyclic),
414                 useinstead="init_printing(perm_cyclic={})"
415                 .format(perm_cyclic),
416                 issue=15201,
417                 deprecated_since_version="1.6").warn()
418         else:
419             perm_cyclic = self._settings.get("perm_cyclic", True)
420 
421         if perm_cyclic:
422             return self._print_Cycle(expr)
423 
424         if expr.size == 0:
425             return r"\left( \right)"
426 
427         lower = [self._print(arg) for arg in expr.array_form]
428         upper = [self._print(arg) for arg in range(len(lower))]
429 
430         row1 = " & ".join(upper)
431         row2 = " & ".join(lower)
432         mat = r" \\ ".join((row1, row2))
433         return r"\begin{pmatrix} %s \end{pmatrix}" % mat
434 
435 
436     def _print_AppliedPermutation(self, expr):
437         perm, var = expr.args
438         return r"\sigma_{%s}(%s)" % (self._print(perm), self._print(var))
439 
440     def _print_Float(self, expr):
441         # Based off of that in StrPrinter
442         dps = prec_to_dps(expr._prec)
443         strip = False if self._settings['full_prec'] else True
444         low = self._settings["min"] if "min" in self._settings else None
445         high = self._settings["max"] if "max" in self._settings else None
446         str_real = mlib.to_str(expr._mpf_, dps, strip_zeros=strip, min_fixed=low, max_fixed=high)
447 
448         # Must always have a mul symbol (as 2.5 10^{20} just looks odd)
449         # thus we use the number separator
450         separator = self._settings['mul_symbol_latex_numbers']
451 
452         if 'e' in str_real:
453             (mant, exp) = str_real.split('e')
454 
455             if exp[0] == '+':
456                 exp = exp[1:]
457             if self._settings['decimal_separator'] == 'comma':
458                 mant = mant.replace('.','{,}')
459 
460             return r"%s%s10^{%s}" % (mant, separator, exp)
461         elif str_real == "+inf":
462             return r"\infty"
463         elif str_real == "-inf":
464             return r"- \infty"
465         else:
466             if self._settings['decimal_separator'] == 'comma':
467                 str_real = str_real.replace('.','{,}')
468             return str_real
469 
470     def _print_Cross(self, expr):
471         vec1 = expr._expr1
472         vec2 = expr._expr2
473         return r"%s \times %s" % (self.parenthesize(vec1, PRECEDENCE['Mul']),
474                                   self.parenthesize(vec2, PRECEDENCE['Mul']))
475 
476     def _print_Curl(self, expr):
477         vec = expr._expr
478         return r"\nabla\times %s" % self.parenthesize(vec, PRECEDENCE['Mul'])
479 
480     def _print_Divergence(self, expr):
481         vec = expr._expr
482         return r"\nabla\cdot %s" % self.parenthesize(vec, PRECEDENCE['Mul'])
483 
484     def _print_Dot(self, expr):
485         vec1 = expr._expr1
486         vec2 = expr._expr2
487         return r"%s \cdot %s" % (self.parenthesize(vec1, PRECEDENCE['Mul']),
488                                  self.parenthesize(vec2, PRECEDENCE['Mul']))
489 
490     def _print_Gradient(self, expr):
491         func = expr._expr
492         return r"\nabla %s" % self.parenthesize(func, PRECEDENCE['Mul'])
493 
494     def _print_Laplacian(self, expr):
495         func = expr._expr
496         return r"\triangle %s" % self.parenthesize(func, PRECEDENCE['Mul'])
497 
498     def _print_Mul(self, expr):
499         from sympy.core.power import Pow
500         from sympy.physics.units import Quantity
501         from sympy.simplify import fraction
502         separator = self._settings['mul_symbol_latex']
503         numbersep = self._settings['mul_symbol_latex_numbers']
504 
505         def convert(expr):
506             if not expr.is_Mul:
507                 return str(self._print(expr))
508             else:
509                 if self.order not in ('old', 'none'):
510                     args = expr.as_ordered_factors()
511                 else:
512                     args = list(expr.args)
513 
514                 # If quantities are present append them at the back
515                 args = sorted(args, key=lambda x: isinstance(x, Quantity) or
516                               (isinstance(x, Pow) and
517                                isinstance(x.base, Quantity)))
518 
519                 return convert_args(args)
520 
521         def convert_args(args):
522                 _tex = last_term_tex = ""
523 
524                 for i, term in enumerate(args):
525                     term_tex = self._print(term)
526 
527                     if self._needs_mul_brackets(term, first=(i == 0),
528                                                 last=(i == len(args) - 1)):
529                         term_tex = r"\left(%s\right)" % term_tex
530 
531                     if _between_two_numbers_p[0].search(last_term_tex) and \
532                             _between_two_numbers_p[1].match(term_tex):
533                         # between two numbers
534                         _tex += numbersep
535                     elif _tex:
536                         _tex += separator
537 
538                     _tex += term_tex
539                     last_term_tex = term_tex
540                 return _tex
541 
542         # Check for unevaluated Mul. In this case we need to make sure the
543         # identities are visible, multiple Rational factors are not combined
544         # etc so we display in a straight-forward form that fully preserves all
545         # args and their order.
546         # XXX: _print_Pow calls this routine with instances of Pow...
547         if isinstance(expr, Mul):
548             args = expr.args
549             if args[0] is S.One or any(isinstance(arg, Number) for arg in args[1:]):
550                 return convert_args(args)
551 
552         include_parens = False
553         if _coeff_isneg(expr):
554             expr = -expr
555             tex = "- "
556             if expr.is_Add:
557                 tex += "("
558                 include_parens = True
559         else:
560             tex = ""
561 
562         numer, denom = fraction(expr, exact=True)
563 
564         if denom is S.One and Pow(1, -1, evaluate=False) not in expr.args:
565             # use the original expression here, since fraction() may have
566             # altered it when producing numer and denom
567             tex += convert(expr)
568 
569         else:
570             snumer = convert(numer)
571             sdenom = convert(denom)
572             ldenom = len(sdenom.split())
573             ratio = self._settings['long_frac_ratio']
574             if self._settings['fold_short_frac'] and ldenom <= 2 and \
575                     "^" not in sdenom:
576                 # handle short fractions
577                 if self._needs_mul_brackets(numer, last=False):
578                     tex += r"\left(%s\right) / %s" % (snumer, sdenom)
579                 else:
580                     tex += r"%s / %s" % (snumer, sdenom)
581             elif ratio is not None and \
582                     len(snumer.split()) > ratio*ldenom:
583                 # handle long fractions
584                 if self._needs_mul_brackets(numer, last=True):
585                     tex += r"\frac{1}{%s}%s\left(%s\right)" \
586                         % (sdenom, separator, snumer)
587                 elif numer.is_Mul:
588                     # split a long numerator
589                     a = S.One
590                     b = S.One
591                     for x in numer.args:
592                         if self._needs_mul_brackets(x, last=False) or \
593                                 len(convert(a*x).split()) > ratio*ldenom or \
594                                 (b.is_commutative is x.is_commutative is False):
595                             b *= x
596                         else:
597                             a *= x
598                     if self._needs_mul_brackets(b, last=True):
599                         tex += r"\frac{%s}{%s}%s\left(%s\right)" \
600                             % (convert(a), sdenom, separator, convert(b))
601                     else:
602                         tex += r"\frac{%s}{%s}%s%s" \
603                             % (convert(a), sdenom, separator, convert(b))
604                 else:
605                     tex += r"\frac{1}{%s}%s%s" % (sdenom, separator, snumer)
606             else:
607                 tex += r"\frac{%s}{%s}" % (snumer, sdenom)
608 
609         if include_parens:
610             tex += ")"
611         return tex
612 
613     def _print_Pow(self, expr):
614         # Treat x**Rational(1,n) as special case
615         if expr.exp.is_Rational and abs(expr.exp.p) == 1 and expr.exp.q != 1 \
616                 and self._settings['root_notation']:
617             base = self._print(expr.base)
618             expq = expr.exp.q
619 
620             if expq == 2:
621                 tex = r"\sqrt{%s}" % base
622             elif self._settings['itex']:
623                 tex = r"\root{%d}{%s}" % (expq, base)
624             else:
625                 tex = r"\sqrt[%d]{%s}" % (expq, base)
626 
627             if expr.exp.is_negative:
628                 return r"\frac{1}{%s}" % tex
629             else:
630                 return tex
631         elif self._settings['fold_frac_powers'] \
632             and expr.exp.is_Rational \
633                 and expr.exp.q != 1:
634             base = self.parenthesize(expr.base, PRECEDENCE['Pow'])
635             p, q = expr.exp.p, expr.exp.q
636             # issue #12886: add parentheses for superscripts raised to powers
637             if expr.base.is_Symbol:
638                 base = self.parenthesize_super(base)
639             if expr.base.is_Function:
640                 return self._print(expr.base, exp="%s/%s" % (p, q))
641             return r"%s^{%s/%s}" % (base, p, q)
642         elif expr.exp.is_Rational and expr.exp.is_negative and \
643                 expr.base.is_commutative:
644             # special case for 1^(-x), issue 9216
645             if expr.base == 1:
646                 return r"%s^{%s}" % (expr.base, expr.exp)
647             # things like 1/x
648             return self._print_Mul(expr)
649         else:
650             if expr.base.is_Function:
651                 return self._print(expr.base, exp=self._print(expr.exp))
652             else:
653                 tex = r"%s^{%s}"
654                 return self._helper_print_standard_power(expr, tex)
655 
656     def _helper_print_standard_power(self, expr, template):
657         exp = self._print(expr.exp)
658         # issue #12886: add parentheses around superscripts raised
659         # to powers
660         base = self.parenthesize(expr.base, PRECEDENCE['Pow'])
661         if expr.base.is_Symbol:
662             base = self.parenthesize_super(base)
663         elif (isinstance(expr.base, Derivative)
664             and base.startswith(r'\left(')
665             and re.match(r'\\left\(\\d?d?dot', base)
666             and base.endswith(r'\right)')):
667             # don't use parentheses around dotted derivative
668             base = base[6: -7]  # remove outermost added parens
669         return template % (base, exp)
670 
671     def _print_UnevaluatedExpr(self, expr):
672         return self._print(expr.args[0])
673 
674     def _print_Sum(self, expr):
675         if len(expr.limits) == 1:
676             tex = r"\sum_{%s=%s}^{%s} " % \
677                 tuple([self._print(i) for i in expr.limits[0]])
678         else:
679             def _format_ineq(l):
680                 return r"%s \leq %s \leq %s" % \
681                     tuple([self._print(s) for s in (l[1], l[0], l[2])])
682 
683             tex = r"\sum_{\substack{%s}} " % \
684                 str.join('\\\\', [_format_ineq(l) for l in expr.limits])
685 
686         if isinstance(expr.function, Add):
687             tex += r"\left(%s\right)" % self._print(expr.function)
688         else:
689             tex += self._print(expr.function)
690 
691         return tex
692 
693     def _print_Product(self, expr):
694         if len(expr.limits) == 1:
695             tex = r"\prod_{%s=%s}^{%s} " % \
696                 tuple([self._print(i) for i in expr.limits[0]])
697         else:
698             def _format_ineq(l):
699                 return r"%s \leq %s \leq %s" % \
700                     tuple([self._print(s) for s in (l[1], l[0], l[2])])
701 
702             tex = r"\prod_{\substack{%s}} " % \
703                 str.join('\\\\', [_format_ineq(l) for l in expr.limits])
704 
705         if isinstance(expr.function, Add):
706             tex += r"\left(%s\right)" % self._print(expr.function)
707         else:
708             tex += self._print(expr.function)
709 
710         return tex
711 
712     def _print_BasisDependent(self, expr):
713         from sympy.vector import Vector
714 
715         o1 = []
716         if expr == expr.zero:
717             return expr.zero._latex_form
718         if isinstance(expr, Vector):
719             items = expr.separate().items()
720         else:
721             items = [(0, expr)]
722 
723         for system, vect in items:
724             inneritems = list(vect.components.items())
725             inneritems.sort(key=lambda x: x[0].__str__())
726             for k, v in inneritems:
727                 if v == 1:
728                     o1.append(' + ' + k._latex_form)
729                 elif v == -1:
730                     o1.append(' - ' + k._latex_form)
731                 else:
732                     arg_str = '(' + self._print(v) + ')'
733                     o1.append(' + ' + arg_str + k._latex_form)
734 
735         outstr = (''.join(o1))
736         if outstr[1] != '-':
737             outstr = outstr[3:]
738         else:
739             outstr = outstr[1:]
740         return outstr
741 
742     def _print_Indexed(self, expr):
743         tex_base = self._print(expr.base)
744         tex = '{'+tex_base+'}'+'_{%s}' % ','.join(
745             map(self._print, expr.indices))
746         return tex
747 
748     def _print_IndexedBase(self, expr):
749         return self._print(expr.label)
750 
751     def _print_Derivative(self, expr):
752         if requires_partial(expr.expr):
753             diff_symbol = r'\partial'
754         else:
755             diff_symbol = r'd'
756 
757         tex = ""
758         dim = 0
759         for x, num in reversed(expr.variable_count):
760             dim += num
761             if num == 1:
762                 tex += r"%s %s" % (diff_symbol, self._print(x))
763             else:
764                 tex += r"%s %s^{%s}" % (diff_symbol,
765                                         self.parenthesize_super(self._print(x)),
766                                         self._print(num))
767 
768         if dim == 1:
769             tex = r"\frac{%s}{%s}" % (diff_symbol, tex)
770         else:
771             tex = r"\frac{%s^{%s}}{%s}" % (diff_symbol, self._print(dim), tex)
772 
773         if any(_coeff_isneg(i) for i in expr.args):
774             return r"%s %s" % (tex, self.parenthesize(expr.expr,
775                                                   PRECEDENCE["Mul"],
776                                                   is_neg=True,
777                                                   strict=True))
778 
779         return r"%s %s" % (tex, self.parenthesize(expr.expr,
780                                                   PRECEDENCE["Mul"],
781                                                   is_neg=False,
782                                                   strict=True))
783 
784     def _print_Subs(self, subs):
785         expr, old, new = subs.args
786         latex_expr = self._print(expr)
787         latex_old = (self._print(e) for e in old)
788         latex_new = (self._print(e) for e in new)
789         latex_subs = r'\\ '.join(
790             e[0] + '=' + e[1] for e in zip(latex_old, latex_new))
791         return r'\left. %s \right|_{\substack{ %s }}' % (latex_expr,
792                                                          latex_subs)
793 
794     def _print_Integral(self, expr):
795         tex, symbols = "", []
796 
797         # Only up to \iiiint exists
798         if len(expr.limits) <= 4 and all(len(lim) == 1 for lim in expr.limits):
799             # Use len(expr.limits)-1 so that syntax highlighters don't think
800             # \" is an escaped quote
801             tex = r"\i" + "i"*(len(expr.limits) - 1) + "nt"
802             symbols = [r"\, d%s" % self._print(symbol[0])
803                        for symbol in expr.limits]
804 
805         else:
806             for lim in reversed(expr.limits):
807                 symbol = lim[0]
808                 tex += r"\int"
809 
810                 if len(lim) > 1:
811                     if self._settings['mode'] != 'inline' \
812                             and not self._settings['itex']:
813                         tex += r"\limits"
814 
815                     if len(lim) == 3:
816                         tex += "_{%s}^{%s}" % (self._print(lim[1]),
817                                                self._print(lim[2]))
818                     if len(lim) == 2:
819                         tex += "^{%s}" % (self._print(lim[1]))
820 
821                 symbols.insert(0, r"\, d%s" % self._print(symbol))
822 
823         return r"%s %s%s" % (tex, self.parenthesize(expr.function,
824                                                     PRECEDENCE["Mul"],
825                                                     is_neg=any(_coeff_isneg(i) for i in expr.args),
826                                                     strict=True),
827                              "".join(symbols))
828 
829     def _print_Limit(self, expr):
830         e, z, z0, dir = expr.args
831 
832         tex = r"\lim_{%s \to " % self._print(z)
833         if str(dir) == '+-' or z0 in (S.Infinity, S.NegativeInfinity):
834             tex += r"%s}" % self._print(z0)
835         else:
836             tex += r"%s^%s}" % (self._print(z0), self._print(dir))
837 
838         if isinstance(e, AssocOp):
839             return r"%s\left(%s\right)" % (tex, self._print(e))
840         else:
841             return r"%s %s" % (tex, self._print(e))
842 
843     def _hprint_Function(self, func):
844         r'''
845         Logic to decide how to render a function to latex
846           - if it is a recognized latex name, use the appropriate latex command
847           - if it is a single letter, just use that letter
848           - if it is a longer name, then put \operatorname{} around it and be
849             mindful of undercores in the name
850         '''
851         func = self._deal_with_super_sub(func)
852         if func in accepted_latex_functions:
853             name = r"\%s" % func
854         elif len(func) == 1 or func.startswith('\\'):
855             name = func
856         else:
857             name = r"\operatorname{%s}" % func
858         return name
859 
860     def _print_Function(self, expr, exp=None):
861         r'''
862         Render functions to LaTeX, handling functions that LaTeX knows about
863         e.g., sin, cos, ... by using the proper LaTeX command (\sin, \cos, ...).
864         For single-letter function names, render them as regular LaTeX math
865         symbols. For multi-letter function names that LaTeX does not know
866         about, (e.g., Li, sech) use \operatorname{} so that the function name
867         is rendered in Roman font and LaTeX handles spacing properly.
868 
869         expr is the expression involving the function
870         exp is an exponent
871         '''
872         func = expr.func.__name__
873         if hasattr(self, '_print_' + func) and \
874                 not isinstance(expr, AppliedUndef):
875             return getattr(self, '_print_' + func)(expr, exp)
876         else:
877             args = [str(self._print(arg)) for arg in expr.args]
878             # How inverse trig functions should be displayed, formats are:
879             # abbreviated: asin, full: arcsin, power: sin^-1
880             inv_trig_style = self._settings['inv_trig_style']
881             # If we are dealing with a power-style inverse trig function
882             inv_trig_power_case = False
883             # If it is applicable to fold the argument brackets
884             can_fold_brackets = self._settings['fold_func_brackets'] and \
885                 len(args) == 1 and \
886                 not self._needs_function_brackets(expr.args[0])
887 
888             inv_trig_table = [
889                 "asin", "acos", "atan",
890                 "acsc", "asec", "acot",
891                 "asinh", "acosh", "atanh",
892                 "acsch", "asech", "acoth",
893             ]
894 
895             # If the function is an inverse trig function, handle the style
896             if func in inv_trig_table:
897                 if inv_trig_style == "abbreviated":
898                     pass
899                 elif inv_trig_style == "full":
900                     func = "arc" + func[1:]
901                 elif inv_trig_style == "power":
902                     func = func[1:]
903                     inv_trig_power_case = True
904 
905                     # Can never fold brackets if we're raised to a power
906                     if exp is not None:
907                         can_fold_brackets = False
908 
909             if inv_trig_power_case:
910                 if func in accepted_latex_functions:
911                     name = r"\%s^{-1}" % func
912                 else:
913                     name = r"\operatorname{%s}^{-1}" % func
914             elif exp is not None:
915                 func_tex = self._hprint_Function(func)
916                 func_tex = self.parenthesize_super(func_tex)
917                 name = r'%s^{%s}' % (func_tex, exp)
918             else:
919                 name = self._hprint_Function(func)
920 
921             if can_fold_brackets:
922                 if func in accepted_latex_functions:
923                     # Wrap argument safely to avoid parse-time conflicts
924                     # with the function name itself
925                     name += r" {%s}"
926                 else:
927                     name += r"%s"
928             else:
929                 name += r"{\left(%s \right)}"
930 
931             if inv_trig_power_case and exp is not None:
932                 name += r"^{%s}" % exp
933 
934             return name % ",".join(args)
935 
936     def _print_UndefinedFunction(self, expr):
937         return self._hprint_Function(str(expr))
938 
939     def _print_ElementwiseApplyFunction(self, expr):
940         return r"{%s}_{\circ}\left({%s}\right)" % (
941             self._print(expr.function),
942             self._print(expr.expr),
943         )
944 
945     @property
946     def _special_function_classes(self):
947         from sympy.functions.special.tensor_functions import KroneckerDelta
948         from sympy.functions.special.gamma_functions import gamma, lowergamma
949         from sympy.functions.special.beta_functions import beta
950         from sympy.functions.special.delta_functions import DiracDelta
951         from sympy.functions.special.error_functions import Chi
952         return {KroneckerDelta: r'\delta',
953                 gamma:  r'\Gamma',
954                 lowergamma: r'\gamma',
955                 beta: r'\operatorname{B}',
956                 DiracDelta: r'\delta',
957                 Chi: r'\operatorname{Chi}'}
958 
959     def _print_FunctionClass(self, expr):
960         for cls in self._special_function_classes:
961             if issubclass(expr, cls) and expr.__name__ == cls.__name__:
962                 return self._special_function_classes[cls]
963         return self._hprint_Function(str(expr))
964 
965     def _print_Lambda(self, expr):
966         symbols, expr = expr.args
967 
968         if len(symbols) == 1:
969             symbols = self._print(symbols[0])
970         else:
971             symbols = self._print(tuple(symbols))
972 
973         tex = r"\left( %s \mapsto %s \right)" % (symbols, self._print(expr))
974 
975         return tex
976 
977     def _print_IdentityFunction(self, expr):
978         return r"\left( x \mapsto x \right)"
979 
980     def _hprint_variadic_function(self, expr, exp=None):
981         args = sorted(expr.args, key=default_sort_key)
982         texargs = [r"%s" % self._print(symbol) for symbol in args]
983         tex = r"\%s\left(%s\right)" % (str(expr.func).lower(),
984                                        ", ".join(texargs))
985         if exp is not None:
986             return r"%s^{%s}" % (tex, exp)
987         else:
988             return tex
989 
990     _print_Min = _print_Max = _hprint_variadic_function
991 
992     def _print_floor(self, expr, exp=None):
993         tex = r"\left\lfloor{%s}\right\rfloor" % self._print(expr.args[0])
994 
995         if exp is not None:
996             return r"%s^{%s}" % (tex, exp)
997         else:
998             return tex
999 
1000     def _print_ceiling(self, expr, exp=None):
1001         tex = r"\left\lceil{%s}\right\rceil" % self._print(expr.args[0])
1002 
1003         if exp is not None:
1004             return r"%s^{%s}" % (tex, exp)
1005         else:
1006             return tex
1007 
1008     def _print_log(self, expr, exp=None):
1009         if not self._settings["ln_notation"]:
1010             tex = r"\log{\left(%s \right)}" % self._print(expr.args[0])
1011         else:
1012             tex = r"\ln{\left(%s \right)}" % self._print(expr.args[0])
1013 
1014         if exp is not None:
1015             return r"%s^{%s}" % (tex, exp)
1016         else:
1017             return tex
1018 
1019     def _print_Abs(self, expr, exp=None):
1020         tex = r"\left|{%s}\right|" % self._print(expr.args[0])
1021 
1022         if exp is not None:
1023             return r"%s^{%s}" % (tex, exp)
1024         else:
1025             return tex
1026     _print_Determinant = _print_Abs
1027 
1028     def _print_re(self, expr, exp=None):
1029         if self._settings['gothic_re_im']:
1030             tex = r"\Re{%s}" % self.parenthesize(expr.args[0], PRECEDENCE['Atom'])
1031         else:
1032             tex = r"\operatorname{{re}}{{{}}}".format(self.parenthesize(expr.args[0], PRECEDENCE['Atom']))
1033 
1034         return self._do_exponent(tex, exp)
1035 
1036     def _print_im(self, expr, exp=None):
1037         if self._settings['gothic_re_im']:
1038             tex = r"\Im{%s}" % self.parenthesize(expr.args[0], PRECEDENCE['Atom'])
1039         else:
1040             tex = r"\operatorname{{im}}{{{}}}".format(self.parenthesize(expr.args[0], PRECEDENCE['Atom']))
1041 
1042         return self._do_exponent(tex, exp)
1043 
1044     def _print_Not(self, e):
1045         from sympy import Equivalent, Implies
1046         if isinstance(e.args[0], Equivalent):
1047             return self._print_Equivalent(e.args[0], r"\not\Leftrightarrow")
1048         if isinstance(e.args[0], Implies):
1049             return self._print_Implies(e.args[0], r"\not\Rightarrow")
1050         if (e.args[0].is_Boolean):
1051             return r"\neg \left(%s\right)" % self._print(e.args[0])
1052         else:
1053             return r"\neg %s" % self._print(e.args[0])
1054 
1055     def _print_LogOp(self, args, char):
1056         arg = args[0]
1057         if arg.is_Boolean and not arg.is_Not:
1058             tex = r"\left(%s\right)" % self._print(arg)
1059         else:
1060             tex = r"%s" % self._print(arg)
1061 
1062         for arg in args[1:]:
1063             if arg.is_Boolean and not arg.is_Not:
1064                 tex += r" %s \left(%s\right)" % (char, self._print(arg))
1065             else:
1066                 tex += r" %s %s" % (char, self._print(arg))
1067 
1068         return tex
1069 
1070     def _print_And(self, e):
1071         args = sorted(e.args, key=default_sort_key)
1072         return self._print_LogOp(args, r"\wedge")
1073 
1074     def _print_Or(self, e):
1075         args = sorted(e.args, key=default_sort_key)
1076         return self._print_LogOp(args, r"\vee")
1077 
1078     def _print_Xor(self, e):
1079         args = sorted(e.args, key=default_sort_key)
1080         return self._print_LogOp(args, r"\veebar")
1081 
1082     def _print_Implies(self, e, altchar=None):
1083         return self._print_LogOp(e.args, altchar or r"\Rightarrow")
1084 
1085     def _print_Equivalent(self, e, altchar=None):
1086         args = sorted(e.args, key=default_sort_key)
1087         return self._print_LogOp(args, altchar or r"\Leftrightarrow")
1088 
1089     def _print_conjugate(self, expr, exp=None):
1090         tex = r"\overline{%s}" % self._print(expr.args[0])
1091 
1092         if exp is not None:
1093             return r"%s^{%s}" % (tex, exp)
1094         else:
1095             return tex
1096 
1097     def _print_polar_lift(self, expr, exp=None):
1098         func = r"\operatorname{polar\_lift}"
1099         arg = r"{\left(%s \right)}" % self._print(expr.args[0])
1100 
1101         if exp is not None:
1102             return r"%s^{%s}%s" % (func, exp, arg)
1103         else:
1104             return r"%s%s" % (func, arg)
1105 
1106     def _print_ExpBase(self, expr, exp=None):
1107         # TODO should exp_polar be printed differently?
1108         #      what about exp_polar(0), exp_polar(1)?
1109         tex = r"e^{%s}" % self._print(expr.args[0])
1110         return self._do_exponent(tex, exp)
1111 
1112     def _print_elliptic_k(self, expr, exp=None):
1113         tex = r"\left(%s\right)" % self._print(expr.args[0])
1114         if exp is not None:
1115             return r"K^{%s}%s" % (exp, tex)
1116         else:
1117             return r"K%s" % tex
1118 
1119     def _print_elliptic_f(self, expr, exp=None):
1120         tex = r"\left(%s\middle| %s\right)" % \
1121             (self._print(expr.args[0]), self._print(expr.args[1]))
1122         if exp is not None:
1123             return r"F^{%s}%s" % (exp, tex)
1124         else:
1125             return r"F%s" % tex
1126 
1127     def _print_elliptic_e(self, expr, exp=None):
1128         if len(expr.args) == 2:
1129             tex = r"\left(%s\middle| %s\right)" % \
1130                 (self._print(expr.args[0]), self._print(expr.args[1]))
1131         else:
1132             tex = r"\left(%s\right)" % self._print(expr.args[0])
1133         if exp is not None:
1134             return r"E^{%s}%s" % (exp, tex)
1135         else:
1136             return r"E%s" % tex
1137 
1138     def _print_elliptic_pi(self, expr, exp=None):
1139         if len(expr.args) == 3:
1140             tex = r"\left(%s; %s\middle| %s\right)" % \
1141                 (self._print(expr.args[0]), self._print(expr.args[1]),
1142                  self._print(expr.args[2]))
1143         else:
1144             tex = r"\left(%s\middle| %s\right)" % \
1145                 (self._print(expr.args[0]), self._print(expr.args[1]))
1146         if exp is not None:
1147             return r"\Pi^{%s}%s" % (exp, tex)
1148         else:
1149             return r"\Pi%s" % tex
1150 
1151     def _print_beta(self, expr, exp=None):
1152         tex = r"\left(%s, %s\right)" % (self._print(expr.args[0]),
1153                                         self._print(expr.args[1]))
1154 
1155         if exp is not None:
1156             return r"\operatorname{B}^{%s}%s" % (exp, tex)
1157         else:
1158             return r"\operatorname{B}%s" % tex
1159 
1160     def _print_uppergamma(self, expr, exp=None):
1161         tex = r"\left(%s, %s\right)" % (self._print(expr.args[0]),
1162                                         self._print(expr.args[1]))
1163 
1164         if exp is not None:
1165             return r"\Gamma^{%s}%s" % (exp, tex)
1166         else:
1167             return r"\Gamma%s" % tex
1168 
1169     def _print_lowergamma(self, expr, exp=None):
1170         tex = r"\left(%s, %s\right)" % (self._print(expr.args[0]),
1171                                         self._print(expr.args[1]))
1172 
1173         if exp is not None:
1174             return r"\gamma^{%s}%s" % (exp, tex)
1175         else:
1176             return r"\gamma%s" % tex
1177 
1178     def _hprint_one_arg_func(self, expr, exp=None):
1179         tex = r"\left(%s\right)" % self._print(expr.args[0])
1180 
1181         if exp is not None:
1182             return r"%s^{%s}%s" % (self._print(expr.func), exp, tex)
1183         else:
1184             return r"%s%s" % (self._print(expr.func), tex)
1185 
1186     _print_gamma = _hprint_one_arg_func
1187 
1188     def _print_Chi(self, expr, exp=None):
1189         tex = r"\left(%s\right)" % self._print(expr.args[0])
1190 
1191         if exp is not None:
1192             return r"\operatorname{Chi}^{%s}%s" % (exp, tex)
1193         else:
1194             return r"\operatorname{Chi}%s" % tex
1195 
1196     def _print_expint(self, expr, exp=None):
1197         tex = r"\left(%s\right)" % self._print(expr.args[1])
1198         nu = self._print(expr.args[0])
1199 
1200         if exp is not None:
1201             return r"\operatorname{E}_{%s}^{%s}%s" % (nu, exp, tex)
1202         else:
1203             return r"\operatorname{E}_{%s}%s" % (nu, tex)
1204 
1205     def _print_fresnels(self, expr, exp=None):
1206         tex = r"\left(%s\right)" % self._print(expr.args[0])
1207 
1208         if exp is not None:
1209             return r"S^{%s}%s" % (exp, tex)
1210         else:
1211             return r"S%s" % tex
1212 
1213     def _print_fresnelc(self, expr, exp=None):
1214         tex = r"\left(%s\right)" % self._print(expr.args[0])
1215 
1216         if exp is not None:
1217             return r"C^{%s}%s" % (exp, tex)
1218         else:
1219             return r"C%s" % tex
1220 
1221     def _print_subfactorial(self, expr, exp=None):
1222         tex = r"!%s" % self.parenthesize(expr.args[0], PRECEDENCE["Func"])
1223 
1224         if exp is not None:
1225             return r"\left(%s\right)^{%s}" % (tex, exp)
1226         else:
1227             return tex
1228 
1229     def _print_factorial(self, expr, exp=None):
1230         tex = r"%s!" % self.parenthesize(expr.args[0], PRECEDENCE["Func"])
1231 
1232         if exp is not None:
1233             return r"%s^{%s}" % (tex, exp)
1234         else:
1235             return tex
1236 
1237     def _print_factorial2(self, expr, exp=None):
1238         tex = r"%s!!" % self.parenthesize(expr.args[0], PRECEDENCE["Func"])
1239 
1240         if exp is not None:
1241             return r"%s^{%s}" % (tex, exp)
1242         else:
1243             return tex
1244 
1245     def _print_binomial(self, expr, exp=None):
1246         tex = r"{\binom{%s}{%s}}" % (self._print(expr.args[0]),
1247                                      self._print(expr.args[1]))
1248 
1249         if exp is not None:
1250             return r"%s^{%s}" % (tex, exp)
1251         else:
1252             return tex
1253 
1254     def _print_RisingFactorial(self, expr, exp=None):
1255         n, k = expr.args
1256         base = r"%s" % self.parenthesize(n, PRECEDENCE['Func'])
1257 
1258         tex = r"{%s}^{\left(%s\right)}" % (base, self._print(k))
1259 
1260         return self._do_exponent(tex, exp)
1261 
1262     def _print_FallingFactorial(self, expr, exp=None):
1263         n, k = expr.args
1264         sub = r"%s" % self.parenthesize(k, PRECEDENCE['Func'])
1265 
1266         tex = r"{\left(%s\right)}_{%s}" % (self._print(n), sub)
1267 
1268         return self._do_exponent(tex, exp)
1269 
1270     def _hprint_BesselBase(self, expr, exp, sym):
1271         tex = r"%s" % (sym)
1272 
1273         need_exp = False
1274         if exp is not None:
1275             if tex.find('^') == -1:
1276                 tex = r"%s^{%s}" % (tex, exp)
1277             else:
1278                 need_exp = True
1279 
1280         tex = r"%s_{%s}\left(%s\right)" % (tex, self._print(expr.order),
1281                                            self._print(expr.argument))
1282 
1283         if need_exp:
1284             tex = self._do_exponent(tex, exp)
1285         return tex
1286 
1287     def _hprint_vec(self, vec):
1288         if not vec:
1289             return ""
1290         s = ""
1291         for i in vec[:-1]:
1292             s += "%s, " % self._print(i)
1293         s += self._print(vec[-1])
1294         return s
1295 
1296     def _print_besselj(self, expr, exp=None):
1297         return self._hprint_BesselBase(expr, exp, 'J')
1298 
1299     def _print_besseli(self, expr, exp=None):
1300         return self._hprint_BesselBase(expr, exp, 'I')
1301 
1302     def _print_besselk(self, expr, exp=None):
1303         return self._hprint_BesselBase(expr, exp, 'K')
1304 
1305     def _print_bessely(self, expr, exp=None):
1306         return self._hprint_BesselBase(expr, exp, 'Y')
1307 
1308     def _print_yn(self, expr, exp=None):
1309         return self._hprint_BesselBase(expr, exp, 'y')
1310 
1311     def _print_jn(self, expr, exp=None):
1312         return self._hprint_BesselBase(expr, exp, 'j')
1313 
1314     def _print_hankel1(self, expr, exp=None):
1315         return self._hprint_BesselBase(expr, exp, 'H^{(1)}')
1316 
1317     def _print_hankel2(self, expr, exp=None):
1318         return self._hprint_BesselBase(expr, exp, 'H^{(2)}')
1319 
1320     def _print_hn1(self, expr, exp=None):
1321         return self._hprint_BesselBase(expr, exp, 'h^{(1)}')
1322 
1323     def _print_hn2(self, expr, exp=None):
1324         return self._hprint_BesselBase(expr, exp, 'h^{(2)}')
1325 
1326     def _hprint_airy(self, expr, exp=None, notation=""):
1327         tex = r"\left(%s\right)" % self._print(expr.args[0])
1328 
1329         if exp is not None:
1330             return r"%s^{%s}%s" % (notation, exp, tex)
1331         else:
1332             return r"%s%s" % (notation, tex)
1333 
1334     def _hprint_airy_prime(self, expr, exp=None, notation=""):
1335         tex = r"\left(%s\right)" % self._print(expr.args[0])
1336 
1337         if exp is not None:
1338             return r"{%s^\prime}^{%s}%s" % (notation, exp, tex)
1339         else:
1340             return r"%s^\prime%s" % (notation, tex)
1341 
1342     def _print_airyai(self, expr, exp=None):
1343         return self._hprint_airy(expr, exp, 'Ai')
1344 
1345     def _print_airybi(self, expr, exp=None):
1346         return self._hprint_airy(expr, exp, 'Bi')
1347 
1348     def _print_airyaiprime(self, expr, exp=None):
1349         return self._hprint_airy_prime(expr, exp, 'Ai')
1350 
1351     def _print_airybiprime(self, expr, exp=None):
1352         return self._hprint_airy_prime(expr, exp, 'Bi')
1353 
1354     def _print_hyper(self, expr, exp=None):
1355         tex = r"{{}_{%s}F_{%s}\left(\begin{matrix} %s \\ %s \end{matrix}" \
1356               r"\middle| {%s} \right)}" % \
1357             (self._print(len(expr.ap)), self._print(len(expr.bq)),
1358               self._hprint_vec(expr.ap), self._hprint_vec(expr.bq),
1359               self._print(expr.argument))
1360 
1361         if exp is not None:
1362             tex = r"{%s}^{%s}" % (tex, exp)
1363         return tex
1364 
1365     def _print_meijerg(self, expr, exp=None):
1366         tex = r"{G_{%s, %s}^{%s, %s}\left(\begin{matrix} %s & %s \\" \
1367               r"%s & %s \end{matrix} \middle| {%s} \right)}" % \
1368             (self._print(len(expr.ap)), self._print(len(expr.bq)),
1369               self._print(len(expr.bm)), self._print(len(expr.an)),
1370               self._hprint_vec(expr.an), self._hprint_vec(expr.aother),
1371               self._hprint_vec(expr.bm), self._hprint_vec(expr.bother),
1372               self._print(expr.argument))
1373 
1374         if exp is not None:
1375             tex = r"{%s}^{%s}" % (tex, exp)
1376         return tex
1377 
1378     def _print_dirichlet_eta(self, expr, exp=None):
1379         tex = r"\left(%s\right)" % self._print(expr.args[0])
1380         if exp is not None:
1381             return r"\eta^{%s}%s" % (exp, tex)
1382         return r"\eta%s" % tex
1383 
1384     def _print_zeta(self, expr, exp=None):
1385         if len(expr.args) == 2:
1386             tex = r"\left(%s, %s\right)" % tuple(map(self._print, expr.args))
1387         else:
1388             tex = r"\left(%s\right)" % self._print(expr.args[0])
1389         if exp is not None:
1390             return r"\zeta^{%s}%s" % (exp, tex)
1391         return r"\zeta%s" % tex
1392 
1393     def _print_stieltjes(self, expr, exp=None):
1394         if len(expr.args) == 2:
1395             tex = r"_{%s}\left(%s\right)" % tuple(map(self._print, expr.args))
1396         else:
1397             tex = r"_{%s}" % self._print(expr.args[0])
1398         if exp is not None:
1399             return r"\gamma%s^{%s}" % (tex, exp)
1400         return r"\gamma%s" % tex
1401 
1402     def _print_lerchphi(self, expr, exp=None):
1403         tex = r"\left(%s, %s, %s\right)" % tuple(map(self._print, expr.args))
1404         if exp is None:
1405             return r"\Phi%s" % tex
1406         return r"\Phi^{%s}%s" % (exp, tex)
1407 
1408     def _print_polylog(self, expr, exp=None):
1409         s, z = map(self._print, expr.args)
1410         tex = r"\left(%s\right)" % z
1411         if exp is None:
1412             return r"\operatorname{Li}_{%s}%s" % (s, tex)
1413         return r"\operatorname{Li}_{%s}^{%s}%s" % (s, exp, tex)
1414 
1415     def _print_jacobi(self, expr, exp=None):
1416         n, a, b, x = map(self._print, expr.args)
1417         tex = r"P_{%s}^{\left(%s,%s\right)}\left(%s\right)" % (n, a, b, x)
1418         if exp is not None:
1419             tex = r"\left(" + tex + r"\right)^{%s}" % (exp)
1420         return tex
1421 
1422     def _print_gegenbauer(self, expr, exp=None):
1423         n, a, x = map(self._print, expr.args)
1424         tex = r"C_{%s}^{\left(%s\right)}\left(%s\right)" % (n, a, x)
1425         if exp is not None:
1426             tex = r"\left(" + tex + r"\right)^{%s}" % (exp)
1427         return tex
1428 
1429     def _print_chebyshevt(self, expr, exp=None):
1430         n, x = map(self._print, expr.args)
1431         tex = r"T_{%s}\left(%s\right)" % (n, x)
1432         if exp is not None:
1433             tex = r"\left(" + tex + r"\right)^{%s}" % (exp)
1434         return tex
1435 
1436     def _print_chebyshevu(self, expr, exp=None):
1437         n, x = map(self._print, expr.args)
1438         tex = r"U_{%s}\left(%s\right)" % (n, x)
1439         if exp is not None:
1440             tex = r"\left(" + tex + r"\right)^{%s}" % (exp)
1441         return tex
1442 
1443     def _print_legendre(self, expr, exp=None):
1444         n, x = map(self._print, expr.args)
1445         tex = r"P_{%s}\left(%s\right)" % (n, x)
1446         if exp is not None:
1447             tex = r"\left(" + tex + r"\right)^{%s}" % (exp)
1448         return tex
1449 
1450     def _print_assoc_legendre(self, expr, exp=None):
1451         n, a, x = map(self._print, expr.args)
1452         tex = r"P_{%s}^{\left(%s\right)}\left(%s\right)" % (n, a, x)
1453         if exp is not None:
1454             tex = r"\left(" + tex + r"\right)^{%s}" % (exp)
1455         return tex
1456 
1457     def _print_hermite(self, expr, exp=None):
1458         n, x = map(self._print, expr.args)
1459         tex = r"H_{%s}\left(%s\right)" % (n, x)
1460         if exp is not None:
1461             tex = r"\left(" + tex + r"\right)^{%s}" % (exp)
1462         return tex
1463 
1464     def _print_laguerre(self, expr, exp=None):
1465         n, x = map(self._print, expr.args)
1466         tex = r"L_{%s}\left(%s\right)" % (n, x)
1467         if exp is not None:
1468             tex = r"\left(" + tex + r"\right)^{%s}" % (exp)
1469         return tex
1470 
1471     def _print_assoc_laguerre(self, expr, exp=None):
1472         n, a, x = map(self._print, expr.args)
1473         tex = r"L_{%s}^{\left(%s\right)}\left(%s\right)" % (n, a, x)
1474         if exp is not None:
1475             tex = r"\left(" + tex + r"\right)^{%s}" % (exp)
1476         return tex
1477 
1478     def _print_Ynm(self, expr, exp=None):
1479         n, m, theta, phi = map(self._print, expr.args)
1480         tex = r"Y_{%s}^{%s}\left(%s,%s\right)" % (n, m, theta, phi)
1481         if exp is not None:
1482             tex = r"\left(" + tex + r"\right)^{%s}" % (exp)
1483         return tex
1484 
1485     def _print_Znm(self, expr, exp=None):
1486         n, m, theta, phi = map(self._print, expr.args)
1487         tex = r"Z_{%s}^{%s}\left(%s,%s\right)" % (n, m, theta, phi)
1488         if exp is not None:
1489             tex = r"\left(" + tex + r"\right)^{%s}" % (exp)
1490         return tex
1491 
1492     def __print_mathieu_functions(self, character, args, prime=False, exp=None):
1493         a, q, z = map(self._print, args)
1494         sup = r"^{\prime}" if prime else ""
1495         exp = "" if not exp else "^{%s}" % exp
1496         return r"%s%s\left(%s, %s, %s\right)%s" % (character, sup, a, q, z, exp)
1497 
1498     def _print_mathieuc(self, expr, exp=None):
1499         return self.__print_mathieu_functions("C", expr.args, exp=exp)
1500 
1501     def _print_mathieus(self, expr, exp=None):
1502         return self.__print_mathieu_functions("S", expr.args, exp=exp)
1503 
1504     def _print_mathieucprime(self, expr, exp=None):
1505         return self.__print_mathieu_functions("C", expr.args, prime=True, exp=exp)
1506 
1507     def _print_mathieusprime(self, expr, exp=None):
1508         return self.__print_mathieu_functions("S", expr.args, prime=True, exp=exp)
1509 
1510     def _print_Rational(self, expr):
1511         if expr.q != 1:
1512             sign = ""
1513             p = expr.p
1514             if expr.p < 0:
1515                 sign = "- "
1516                 p = -p
1517             if self._settings['fold_short_frac']:
1518                 return r"%s%d / %d" % (sign, p, expr.q)
1519             return r"%s\frac{%d}{%d}" % (sign, p, expr.q)
1520         else:
1521             return self._print(expr.p)
1522 
1523     def _print_Order(self, expr):
1524         s = self._print(expr.expr)
1525         if expr.point and any(p != S.Zero for p in expr.point) or \
1526            len(expr.variables) > 1:
1527             s += '; '
1528             if len(expr.variables) > 1:
1529                 s += self._print(expr.variables)
1530             elif expr.variables:
1531                 s += self._print(expr.variables[0])
1532             s += r'\rightarrow '
1533             if len(expr.point) > 1:
1534                 s += self._print(expr.point)
1535             else:
1536                 s += self._print(expr.point[0])
1537         return r"O\left(%s\right)" % s
1538 
1539     def _print_Symbol(self, expr, style='plain'):
1540         if expr in self._settings['symbol_names']:
1541             return self._settings['symbol_names'][expr]
1542 
1543         return self._deal_with_super_sub(expr.name, style=style)
1544 
1545     _print_RandomSymbol = _print_Symbol
1546 
1547     def _deal_with_super_sub(self, string, style='plain'):
1548         if '{' in string:
1549             name, supers, subs = string, [], []
1550         else:
1551             name, supers, subs = split_super_sub(string)
1552 
1553             name = translate(name)
1554             supers = [translate(sup) for sup in supers]
1555             subs = [translate(sub) for sub in subs]
1556 
1557         # apply the style only to the name
1558         if style == 'bold':
1559             name = "\\mathbf{{{}}}".format(name)
1560 
1561         # glue all items together:
1562         if supers:
1563             name += "^{%s}" % " ".join(supers)
1564         if subs:
1565             name += "_{%s}" % " ".join(subs)
1566 
1567         return name
1568 
1569     def _print_Relational(self, expr):
1570         if self._settings['itex']:
1571             gt = r"\gt"
1572             lt = r"\lt"
1573         else:
1574             gt = ">"
1575             lt = "<"
1576 
1577         charmap = {
1578             "==": "=",
1579             ">": gt,
1580             "<": lt,
1581             ">=": r"\geq",
1582             "<=": r"\leq",
1583             "!=": r"\neq",
1584         }
1585 
1586         return "%s %s %s" % (self._print(expr.lhs),
1587                              charmap[expr.rel_op], self._print(expr.rhs))
1588 
1589     def _print_Piecewise(self, expr):
1590         ecpairs = [r"%s & \text{for}\: %s" % (self._print(e), self._print(c))
1591                    for e, c in expr.args[:-1]]
1592         if expr.args[-1].cond == true:
1593             ecpairs.append(r"%s & \text{otherwise}" %
1594                            self._print(expr.args[-1].expr))
1595         else:
1596             ecpairs.append(r"%s & \text{for}\: %s" %
1597                            (self._print(expr.args[-1].expr),
1598                             self._print(expr.args[-1].cond)))
1599         tex = r"\begin{cases} %s \end{cases}"
1600         return tex % r" \\".join(ecpairs)
1601 
1602     def _print_MatrixBase(self, expr):
1603         lines = []
1604 
1605         for line in range(expr.rows):  # horrible, should be 'rows'
1606             lines.append(" & ".join([self._print(i) for i in expr[line, :]]))
1607 
1608         mat_str = self._settings['mat_str']
1609         if mat_str is None:
1610             if self._settings['mode'] == 'inline':
1611                 mat_str = 'smallmatrix'
1612             else:
1613                 if (expr.cols <= 10) is True:
1614                     mat_str = 'matrix'
1615                 else:
1616                     mat_str = 'array'
1617 
1618         out_str = r'\begin{%MATSTR%}%s\end{%MATSTR%}'
1619         out_str = out_str.replace('%MATSTR%', mat_str)
1620         if mat_str == 'array':
1621             out_str = out_str.replace('%s', '{' + 'c'*expr.cols + '}%s')
1622         if self._settings['mat_delim']:
1623             left_delim = self._settings['mat_delim']
1624             right_delim = self._delim_dict[left_delim]
1625             out_str = r'\left' + left_delim + out_str + \
1626                       r'\right' + right_delim
1627         return out_str % r"\\".join(lines)
1628 
1629     def _print_MatrixElement(self, expr):
1630         return self.parenthesize(expr.parent, PRECEDENCE["Atom"], strict=True)\
1631             + '_{%s, %s}' % (self._print(expr.i), self._print(expr.j))
1632 
1633     def _print_MatrixSlice(self, expr):
1634         def latexslice(x, dim):
1635             x = list(x)
1636             if x[2] == 1:
1637                 del x[2]
1638             if x[0] == 0:
1639                 x[0] = None
1640             if x[1] == dim:
1641                 x[1] = None
1642             return ':'.join(self._print(xi) if xi is not None else '' for xi in x)
1643         return (self.parenthesize(expr.parent, PRECEDENCE["Atom"], strict=True) + r'\left[' +
1644                 latexslice(expr.rowslice, expr.parent.rows) + ', ' +
1645                 latexslice(expr.colslice, expr.parent.cols) + r'\right]')
1646 
1647     def _print_BlockMatrix(self, expr):
1648         return self._print(expr.blocks)
1649 
1650     def _print_Transpose(self, expr):
1651         mat = expr.arg
1652         from sympy.matrices import MatrixSymbol
1653         if not isinstance(mat, MatrixSymbol):
1654             return r"\left(%s\right)^{T}" % self._print(mat)
1655         else:
1656             return "%s^{T}" % self.parenthesize(mat, precedence_traditional(expr), True)
1657 
1658     def _print_Trace(self, expr):
1659         mat = expr.arg
1660         return r"\operatorname{tr}\left(%s \right)" % self._print(mat)
1661 
1662     def _print_Adjoint(self, expr):
1663         mat = expr.arg
1664         from sympy.matrices import MatrixSymbol
1665         if not isinstance(mat, MatrixSymbol):
1666             return r"\left(%s\right)^{\dagger}" % self._print(mat)
1667         else:
1668             return r"%s^{\dagger}" % self._print(mat)
1669 
1670     def _print_MatMul(self, expr):
1671         from sympy import MatMul, Mul
1672 
1673         parens = lambda x: self.parenthesize(x, precedence_traditional(expr),
1674                                              False)
1675 
1676         args = expr.args
1677         if isinstance(args[0], Mul):
1678             args = args[0].as_ordered_factors() + list(args[1:])
1679         else:
1680             args = list(args)
1681 
1682         if isinstance(expr, MatMul) and _coeff_isneg(expr):
1683             if args[0] == -1:
1684                 args = args[1:]
1685             else:
1686                 args[0] = -args[0]
1687             return '- ' + ' '.join(map(parens, args))
1688         else:
1689             return ' '.join(map(parens, args))
1690 
1691     def _print_Mod(self, expr, exp=None):
1692         if exp is not None:
1693             return r'\left(%s\bmod{%s}\right)^{%s}' % \
1694                 (self.parenthesize(expr.args[0], PRECEDENCE['Mul'],
1695                                    strict=True), self._print(expr.args[1]),
1696                  exp)
1697         return r'%s\bmod{%s}' % (self.parenthesize(expr.args[0],
1698                                  PRECEDENCE['Mul'], strict=True),
1699                                  self._print(expr.args[1]))
1700 
1701     def _print_HadamardProduct(self, expr):
1702         args = expr.args
1703         prec = PRECEDENCE['Pow']
1704         parens = self.parenthesize
1705 
1706         return r' \circ '.join(
1707             map(lambda arg: parens(arg, prec, strict=True), args))
1708 
1709     def _print_HadamardPower(self, expr):
1710         if precedence_traditional(expr.exp) < PRECEDENCE["Mul"]:
1711             template = r"%s^{\circ \left({%s}\right)}"
1712         else:
1713             template = r"%s^{\circ {%s}}"
1714         return self._helper_print_standard_power(expr, template)
1715 
1716     def _print_KroneckerProduct(self, expr):
1717         args = expr.args
1718         prec = PRECEDENCE['Pow']
1719         parens = self.parenthesize
1720 
1721         return r' \otimes '.join(
1722             map(lambda arg: parens(arg, prec, strict=True), args))
1723 
1724     def _print_MatPow(self, expr):
1725         base, exp = expr.base, expr.exp
1726         from sympy.matrices import MatrixSymbol
1727         if not isinstance(base, MatrixSymbol):
1728             return "\\left(%s\\right)^{%s}" % (self._print(base),
1729                                               self._print(exp))
1730         else:
1731             return "%s^{%s}" % (self._print(base), self._print(exp))
1732 
1733     def _print_MatrixSymbol(self, expr):
1734         return self._print_Symbol(expr, style=self._settings[
1735             'mat_symbol_style'])
1736 
1737     def _print_ZeroMatrix(self, Z):
1738         return r"\mathbb{0}" if self._settings[
1739             'mat_symbol_style'] == 'plain' else r"\mathbf{0}"
1740 
1741     def _print_OneMatrix(self, O):
1742         return r"\mathbb{1}" if self._settings[
1743             'mat_symbol_style'] == 'plain' else r"\mathbf{1}"
1744 
1745     def _print_Identity(self, I):
1746         return r"\mathbb{I}" if self._settings[
1747             'mat_symbol_style'] == 'plain' else r"\mathbf{I}"
1748 
1749     def _print_PermutationMatrix(self, P):
1750         perm_str = self._print(P.args[0])
1751         return "P_{%s}" % perm_str
1752 
1753     def _print_NDimArray(self, expr):
1754 
1755         if expr.rank() == 0:
1756             return self._print(expr[()])
1757 
1758         mat_str = self._settings['mat_str']
1759         if mat_str is None:
1760             if self._settings['mode'] == 'inline':
1761                 mat_str = 'smallmatrix'
1762             else:
1763                 if (expr.rank() == 0) or (expr.shape[-1] <= 10):
1764                     mat_str = 'matrix'
1765                 else:
1766                     mat_str = 'array'
1767         block_str = r'\begin{%MATSTR%}%s\end{%MATSTR%}'
1768         block_str = block_str.replace('%MATSTR%', mat_str)
1769         if self._settings['mat_delim']:
1770             left_delim = self._settings['mat_delim']
1771             right_delim = self._delim_dict[left_delim]
1772             block_str = r'\left' + left_delim + block_str + \
1773                         r'\right' + right_delim
1774 
1775         if expr.rank() == 0:
1776             return block_str % ""
1777 
1778         level_str = [[]] + [[] for i in range(expr.rank())]
1779         shape_ranges = [list(range(i)) for i in expr.shape]
1780         for outer_i in itertools.product(*shape_ranges):
1781             level_str[-1].append(self._print(expr[outer_i]))
1782             even = True
1783             for back_outer_i in range(expr.rank()-1, -1, -1):
1784                 if len(level_str[back_outer_i+1]) < expr.shape[back_outer_i]:
1785                     break
1786                 if even:
1787                     level_str[back_outer_i].append(
1788                         r" & ".join(level_str[back_outer_i+1]))
1789                 else:
1790                     level_str[back_outer_i].append(
1791                         block_str % (r"\\".join(level_str[back_outer_i+1])))
1792                     if len(level_str[back_outer_i+1]) == 1:
1793                         level_str[back_outer_i][-1] = r"\left[" + \
1794                             level_str[back_outer_i][-1] + r"\right]"
1795                 even = not even
1796                 level_str[back_outer_i+1] = []
1797 
1798         out_str = level_str[0][0]
1799 
1800         if expr.rank() % 2 == 1:
1801             out_str = block_str % out_str
1802 
1803         return out_str
1804 
1805     def _printer_tensor_indices(self, name, indices, index_map={}):
1806         out_str = self._print(name)
1807         last_valence = None
1808         prev_map = None
1809         for index in indices:
1810             new_valence = index.is_up
1811             if ((index in index_map) or prev_map) and \
1812                     last_valence == new_valence:
1813                 out_str += ","
1814             if last_valence != new_valence:
1815                 if last_valence is not None:
1816                     out_str += "}"
1817                 if index.is_up:
1818                     out_str += "{}^{"
1819                 else:
1820                     out_str += "{}_{"
1821             out_str += self._print(index.args[0])
1822             if index in index_map:
1823                 out_str += "="
1824                 out_str += self._print(index_map[index])
1825                 prev_map = True
1826             else:
1827                 prev_map = False
1828             last_valence = new_valence
1829         if last_valence is not None:
1830             out_str += "}"
1831         return out_str
1832 
1833     def _print_Tensor(self, expr):
1834         name = expr.args[0].args[0]
1835         indices = expr.get_indices()
1836         return self._printer_tensor_indices(name, indices)
1837 
1838     def _print_TensorElement(self, expr):
1839         name = expr.expr.args[0].args[0]
1840         indices = expr.expr.get_indices()
1841         index_map = expr.index_map
1842         return self._printer_tensor_indices(name, indices, index_map)
1843 
1844     def _print_TensMul(self, expr):
1845         # prints expressions like "A(a)", "3*A(a)", "(1+x)*A(a)"
1846         sign, args = expr._get_args_for_traditional_printer()
1847         return sign + "".join(
1848             [self.parenthesize(arg, precedence(expr)) for arg in args]
1849         )
1850 
1851     def _print_TensAdd(self, expr):
1852         a = []
1853         args = expr.args
1854         for x in args:
1855             a.append(self.parenthesize(x, precedence(expr)))
1856         a.sort()
1857         s = ' + '.join(a)
1858         s = s.replace('+ -', '- ')
1859         return s
1860 
1861     def _print_TensorIndex(self, expr):
1862         return "{}%s{%s}" % (
1863             "^" if expr.is_up else "_",
1864             self._print(expr.args[0])
1865         )
1866 
1867     def _print_PartialDerivative(self, expr):
1868         if len(expr.variables) == 1:
1869             return r"\frac{\partial}{\partial {%s}}{%s}" % (
1870                 self._print(expr.variables[0]),
1871                 self.parenthesize(expr.expr, PRECEDENCE["Mul"], False)
1872             )
1873         else:
1874             return r"\frac{\partial^{%s}}{%s}{%s}" % (
1875                 len(expr.variables),
1876                 " ".join([r"\partial {%s}" % self._print(i) for i in expr.variables]),
1877                 self.parenthesize(expr.expr, PRECEDENCE["Mul"], False)
1878             )
1879 
1880     def _print_UniversalSet(self, expr):
1881         return r"\mathbb{U}"
1882 
1883     def _print_frac(self, expr, exp=None):
1884         if exp is None:
1885             return r"\operatorname{frac}{\left(%s\right)}" % self._print(expr.args[0])
1886         else:
1887             return r"\operatorname{frac}{\left(%s\right)}^{%s}" % (
1888                     self._print(expr.args[0]), exp)
1889 
1890     def _print_tuple(self, expr):
1891         if self._settings['decimal_separator'] == 'comma':
1892             sep = ";"
1893         elif self._settings['decimal_separator'] == 'period':
1894             sep = ","
1895         else:
1896             raise ValueError('Unknown Decimal Separator')
1897 
1898         if len(expr) == 1:
1899             # 1-tuple needs a trailing separator
1900             return self._add_parens_lspace(self._print(expr[0]) + sep)
1901         else:
1902             return self._add_parens_lspace(
1903                 (sep + r" \  ").join([self._print(i) for i in expr]))
1904 
1905     def _print_TensorProduct(self, expr):
1906         elements = [self._print(a) for a in expr.args]
1907         return r' \otimes '.join(elements)
1908 
1909     def _print_WedgeProduct(self, expr):
1910         elements = [self._print(a) for a in expr.args]
1911         return r' \wedge '.join(elements)
1912 
1913     def _print_Tuple(self, expr):
1914         return self._print_tuple(expr)
1915 
1916     def _print_list(self, expr):
1917         if self._settings['decimal_separator'] == 'comma':
1918             return r"\left[ %s\right]" % \
1919                 r"; \  ".join([self._print(i) for i in expr])
1920         elif self._settings['decimal_separator'] == 'period':
1921             return r"\left[ %s\right]" % \
1922                 r", \  ".join([self._print(i) for i in expr])
1923         else:
1924             raise ValueError('Unknown Decimal Separator')
1925 
1926 
1927     def _print_dict(self, d):
1928         keys = sorted(d.keys(), key=default_sort_key)
1929         items = []
1930 
1931         for key in keys:
1932             val = d[key]
1933             items.append("%s : %s" % (self._print(key), self._print(val)))
1934 
1935         return r"\left\{ %s\right\}" % r", \  ".join(items)
1936 
1937     def _print_Dict(self, expr):
1938         return self._print_dict(expr)
1939 
1940     def _print_DiracDelta(self, expr, exp=None):
1941         if len(expr.args) == 1 or expr.args[1] == 0:
1942             tex = r"\delta\left(%s\right)" % self._print(expr.args[0])
1943         else:
1944             tex = r"\delta^{\left( %s \right)}\left( %s \right)" % (
1945                 self._print(expr.args[1]), self._print(expr.args[0]))
1946         if exp:
1947             tex = r"\left(%s\right)^{%s}" % (tex, exp)
1948         return tex
1949 
1950     def _print_SingularityFunction(self, expr):
1951         shift = self._print(expr.args[0] - expr.args[1])
1952         power = self._print(expr.args[2])
1953         tex = r"{\left\langle %s \right\rangle}^{%s}" % (shift, power)
1954         return tex
1955 
1956     def _print_Heaviside(self, expr, exp=None):
1957         tex = r"\theta\left(%s\right)" % self._print(expr.args[0])
1958         if exp:
1959             tex = r"\left(%s\right)^{%s}" % (tex, exp)
1960         return tex
1961 
1962     def _print_KroneckerDelta(self, expr, exp=None):
1963         i = self._print(expr.args[0])
1964         j = self._print(expr.args[1])
1965         if expr.args[0].is_Atom and expr.args[1].is_Atom:
1966             tex = r'\delta_{%s %s}' % (i, j)
1967         else:
1968             tex = r'\delta_{%s, %s}' % (i, j)
1969         if exp is not None:
1970             tex = r'\left(%s\right)^{%s}' % (tex, exp)
1971         return tex
1972 
1973     def _print_LeviCivita(self, expr, exp=None):
1974         indices = map(self._print, expr.args)
1975         if all(x.is_Atom for x in expr.args):
1976             tex = r'\varepsilon_{%s}' % " ".join(indices)
1977         else:
1978             tex = r'\varepsilon_{%s}' % ", ".join(indices)
1979         if exp:
1980             tex = r'\left(%s\right)^{%s}' % (tex, exp)
1981         return tex
1982 
1983     def _print_RandomDomain(self, d):
1984         if hasattr(d, 'as_boolean'):
1985             return '\\text{Domain: }' + self._print(d.as_boolean())
1986         elif hasattr(d, 'set'):
1987             return ('\\text{Domain: }' + self._print(d.symbols) + '\\text{ in }' +
1988                     self._print(d.set))
1989         elif hasattr(d, 'symbols'):
1990             return '\\text{Domain on }' + self._print(d.symbols)
1991         else:
1992             return self._print(None)
1993 
1994     def _print_FiniteSet(self, s):
1995         items = sorted(s.args, key=default_sort_key)
1996         return self._print_set(items)
1997 
1998     def _print_set(self, s):
1999         items = sorted(s, key=default_sort_key)
2000         if self._settings['decimal_separator'] == 'comma':
2001             items = "; ".join(map(self._print, items))
2002         elif self._settings['decimal_separator'] == 'period':
2003             items = ", ".join(map(self._print, items))
2004         else:
2005             raise ValueError('Unknown Decimal Separator')
2006         return r"\left\{%s\right\}" % items
2007 
2008 
2009     _print_frozenset = _print_set
2010 
2011     def _print_Range(self, s):
2012         dots = object()
2013 
2014         if s.has(Symbol):
2015             return self._print_Basic(s)
2016 
2017         if s.start.is_infinite and s.stop.is_infinite:
2018             if s.step.is_positive:
2019                 printset = dots, -1, 0, 1, dots
2020             else:
2021                 printset = dots, 1, 0, -1, dots
2022         elif s.start.is_infinite:
2023             printset = dots, s[-1] - s.step, s[-1]
2024         elif s.stop.is_infinite:
2025             it = iter(s)
2026             printset = next(it), next(it), dots
2027         elif len(s) > 4:
2028             it = iter(s)
2029             printset = next(it), next(it), dots, s[-1]
2030         else:
2031             printset = tuple(s)
2032 
2033         return (r"\left\{" +
2034                 r", ".join(self._print(el) if el is not dots else r'\ldots' for el in printset) +
2035                 r"\right\}")
2036 
2037     def __print_number_polynomial(self, expr, letter, exp=None):
2038         if len(expr.args) == 2:
2039             if exp is not None:
2040                 return r"%s_{%s}^{%s}\left(%s\right)" % (letter,
2041                             self._print(expr.args[0]), exp,
2042                             self._print(expr.args[1]))
2043             return r"%s_{%s}\left(%s\right)" % (letter,
2044                         self._print(expr.args[0]), self._print(expr.args[1]))
2045 
2046         tex = r"%s_{%s}" % (letter, self._print(expr.args[0]))
2047         if exp is not None:
2048             tex = r"%s^{%s}" % (tex, exp)
2049         return tex
2050 
2051     def _print_bernoulli(self, expr, exp=None):
2052         return self.__print_number_polynomial(expr, "B", exp)
2053 
2054     def _print_bell(self, expr, exp=None):
2055         if len(expr.args) == 3:
2056             tex1 = r"B_{%s, %s}" % (self._print(expr.args[0]),
2057                                 self._print(expr.args[1]))
2058             tex2 = r"\left(%s\right)" % r", ".join(self._print(el) for
2059                                                el in expr.args[2])
2060             if exp is not None:
2061                 tex = r"%s^{%s}%s" % (tex1, exp, tex2)
2062             else:
2063                 tex = tex1 + tex2
2064             return tex
2065         return self.__print_number_polynomial(expr, "B", exp)
2066 
2067 
2068     def _print_fibonacci(self, expr, exp=None):
2069         return self.__print_number_polynomial(expr, "F", exp)
2070 
2071     def _print_lucas(self, expr, exp=None):
2072         tex = r"L_{%s}" % self._print(expr.args[0])
2073         if exp is not None:
2074             tex = r"%s^{%s}" % (tex, exp)
2075         return tex
2076 
2077     def _print_tribonacci(self, expr, exp=None):
2078         return self.__print_number_polynomial(expr, "T", exp)
2079 
2080     def _print_SeqFormula(self, s):
2081         dots = object()
2082         if len(s.start.free_symbols) > 0 or len(s.stop.free_symbols) > 0:
2083             return r"\left\{%s\right\}_{%s=%s}^{%s}" % (
2084                 self._print(s.formula),
2085                 self._print(s.variables[0]),
2086                 self._print(s.start),
2087                 self._print(s.stop)
2088             )
2089         if s.start is S.NegativeInfinity:
2090             stop = s.stop
2091             printset = (dots, s.coeff(stop - 3), s.coeff(stop - 2),
2092                         s.coeff(stop - 1), s.coeff(stop))
2093         elif s.stop is S.Infinity or s.length > 4:
2094             printset = s[:4]
2095             printset.append(dots)
2096         else:
2097             printset = tuple(s)
2098 
2099         return (r"\left[" +
2100                 r", ".join(self._print(el) if el is not dots else r'\ldots' for el in printset) +
2101                 r"\right]")
2102 
2103     _print_SeqPer = _print_SeqFormula
2104     _print_SeqAdd = _print_SeqFormula
2105     _print_SeqMul = _print_SeqFormula
2106 
2107     def _print_Interval(self, i):
2108         if i.start == i.end:
2109             return r"\left\{%s\right\}" % self._print(i.start)
2110 
2111         else:
2112             if i.left_open:
2113                 left = '('
2114             else:
2115                 left = '['
2116 
2117             if i.right_open:
2118                 right = ')'
2119             else:
2120                 right = ']'
2121 
2122             return r"\left%s%s, %s\right%s" % \
2123                    (left, self._print(i.start), self._print(i.end), right)
2124 
2125     def _print_AccumulationBounds(self, i):
2126         return r"\left\langle %s, %s\right\rangle" % \
2127                 (self._print(i.min), self._print(i.max))
2128 
2129     def _print_Union(self, u):
2130         prec = precedence_traditional(u)
2131         args_str = [self.parenthesize(i, prec) for i in u.args]
2132         return r" \cup ".join(args_str)
2133 
2134     def _print_Complement(self, u):
2135         prec = precedence_traditional(u)
2136         args_str = [self.parenthesize(i, prec) for i in u.args]
2137         return r" \setminus ".join(args_str)
2138 
2139     def _print_Intersection(self, u):
2140         prec = precedence_traditional(u)
2141         args_str = [self.parenthesize(i, prec) for i in u.args]
2142         return r" \cap ".join(args_str)
2143 
2144     def _print_SymmetricDifference(self, u):
2145         prec = precedence_traditional(u)
2146         args_str = [self.parenthesize(i, prec) for i in u.args]
2147         return r" \triangle ".join(args_str)
2148 
2149     def _print_ProductSet(self, p):
2150         prec = precedence_traditional(p)
2151         if len(p.sets) >= 1 and not has_variety(p.sets):
2152             return self.parenthesize(p.sets[0], prec) + "^{%d}" % len(p.sets)
2153         return r" \times ".join(
2154             self.parenthesize(set, prec) for set in p.sets)
2155 
2156     def _print_EmptySet(self, e):
2157         return r"\emptyset"
2158 
2159     def _print_Naturals(self, n):
2160         return r"\mathbb{N}"
2161 
2162     def _print_Naturals0(self, n):
2163         return r"\mathbb{N}_0"
2164 
2165     def _print_Integers(self, i):
2166         return r"\mathbb{Z}"
2167 
2168     def _print_Rationals(self, i):
2169         return r"\mathbb{Q}"
2170 
2171     def _print_Reals(self, i):
2172         return r"\mathbb{R}"
2173 
2174     def _print_Complexes(self, i):
2175         return r"\mathbb{C}"
2176 
2177     def _print_ImageSet(self, s):
2178         expr = s.lamda.expr
2179         sig = s.lamda.signature
2180         xys = ((self._print(x), self._print(y)) for x, y in zip(sig, s.base_sets))
2181         xinys = r" , ".join(r"%s \in %s" % xy for xy in xys)
2182         return r"\left\{%s\; |\; %s\right\}" % (self._print(expr), xinys)
2183 
2184     def _print_ConditionSet(self, s):
2185         vars_print = ', '.join([self._print(var) for var in Tuple(s.sym)])
2186         if s.base_set is S.UniversalSet:
2187             return r"\left\{%s \mid %s \right\}" % \
2188                 (vars_print, self._print(s.condition))
2189 
2190         return r"\left\{%s \mid %s \in %s \wedge %s \right\}" % (
2191             vars_print,
2192             vars_print,
2193             self._print(s.base_set),
2194             self._print(s.condition))
2195 
2196     def _print_ComplexRegion(self, s):
2197         vars_print = ', '.join([self._print(var) for var in s.variables])
2198         return r"\left\{%s\; |\; %s \in %s \right\}" % (
2199             self._print(s.expr),
2200             vars_print,
2201             self._print(s.sets))
2202 
2203     def _print_Contains(self, e):
2204         return r"%s \in %s" % tuple(self._print(a) for a in e.args)
2205 
2206     def _print_FourierSeries(self, s):
2207         return self._print_Add(s.truncate()) + r' + \ldots'
2208 
2209     def _print_FormalPowerSeries(self, s):
2210         return self._print_Add(s.infinite)
2211 
2212     def _print_FiniteField(self, expr):
2213         return r"\mathbb{F}_{%s}" % expr.mod
2214 
2215     def _print_IntegerRing(self, expr):
2216         return r"\mathbb{Z}"
2217 
2218     def _print_RationalField(self, expr):
2219         return r"\mathbb{Q}"
2220 
2221     def _print_RealField(self, expr):
2222         return r"\mathbb{R}"
2223 
2224     def _print_ComplexField(self, expr):
2225         return r"\mathbb{C}"
2226 
2227     def _print_PolynomialRing(self, expr):
2228         domain = self._print(expr.domain)
2229         symbols = ", ".join(map(self._print, expr.symbols))
2230         return r"%s\left[%s\right]" % (domain, symbols)
2231 
2232     def _print_FractionField(self, expr):
2233         domain = self._print(expr.domain)
2234         symbols = ", ".join(map(self._print, expr.symbols))
2235         return r"%s\left(%s\right)" % (domain, symbols)
2236 
2237     def _print_PolynomialRingBase(self, expr):
2238         domain = self._print(expr.domain)
2239         symbols = ", ".join(map(self._print, expr.symbols))
2240         inv = ""
2241         if not expr.is_Poly:
2242             inv = r"S_<^{-1}"
2243         return r"%s%s\left[%s\right]" % (inv, domain, symbols)
2244 
2245     def _print_Poly(self, poly):
2246         cls = poly.__class__.__name__
2247         terms = []
2248         for monom, coeff in poly.terms():
2249             s_monom = ''
2250             for i, exp in enumerate(monom):
2251                 if exp > 0:
2252                     if exp == 1:
2253                         s_monom += self._print(poly.gens[i])
2254                     else:
2255                         s_monom += self._print(pow(poly.gens[i], exp))
2256 
2257             if coeff.is_Add:
2258                 if s_monom:
2259                     s_coeff = r"\left(%s\right)" % self._print(coeff)
2260                 else:
2261                     s_coeff = self._print(coeff)
2262             else:
2263                 if s_monom:
2264                     if coeff is S.One:
2265                         terms.extend(['+', s_monom])
2266                         continue
2267 
2268                     if coeff is S.NegativeOne:
2269                         terms.extend(['-', s_monom])
2270                         continue
2271 
2272                 s_coeff = self._print(coeff)
2273 
2274             if not s_monom:
2275                 s_term = s_coeff
2276             else:
2277                 s_term = s_coeff + " " + s_monom
2278 
2279             if s_term.startswith('-'):
2280                 terms.extend(['-', s_term[1:]])
2281             else:
2282                 terms.extend(['+', s_term])
2283 
2284         if terms[0] in ['-', '+']:
2285             modifier = terms.pop(0)
2286 
2287             if modifier == '-':
2288                 terms[0] = '-' + terms[0]
2289 
2290         expr = ' '.join(terms)
2291         gens = list(map(self._print, poly.gens))
2292         domain = "domain=%s" % self._print(poly.get_domain())
2293 
2294         args = ", ".join([expr] + gens + [domain])
2295         if cls in accepted_latex_functions:
2296             tex = r"\%s {\left(%s \right)}" % (cls, args)
2297         else:
2298             tex = r"\operatorname{%s}{\left( %s \right)}" % (cls, args)
2299 
2300         return tex
2301 
2302     def _print_ComplexRootOf(self, root):
2303         cls = root.__class__.__name__
2304         if cls == "ComplexRootOf":
2305             cls = "CRootOf"
2306         expr = self._print(root.expr)
2307         index = root.index
2308         if cls in accepted_latex_functions:
2309             return r"\%s {\left(%s, %d\right)}" % (cls, expr, index)
2310         else:
2311             return r"\operatorname{%s} {\left(%s, %d\right)}" % (cls, expr,
2312                                                                  index)
2313 
2314     def _print_RootSum(self, expr):
2315         cls = expr.__class__.__name__
2316         args = [self._print(expr.expr)]
2317 
2318         if expr.fun is not S.IdentityFunction:
2319             args.append(self._print(expr.fun))
2320 
2321         if cls in accepted_latex_functions:
2322             return r"\%s {\left(%s\right)}" % (cls, ", ".join(args))
2323         else:
2324             return r"\operatorname{%s} {\left(%s\right)}" % (cls,
2325                                                              ", ".join(args))
2326 
2327     def _print_PolyElement(self, poly):
2328         mul_symbol = self._settings['mul_symbol_latex']
2329         return poly.str(self, PRECEDENCE, "{%s}^{%d}", mul_symbol)
2330 
2331     def _print_FracElement(self, frac):
2332         if frac.denom == 1:
2333             return self._print(frac.numer)
2334         else:
2335             numer = self._print(frac.numer)
2336             denom = self._print(frac.denom)
2337             return r"\frac{%s}{%s}" % (numer, denom)
2338 
2339     def _print_euler(self, expr, exp=None):
2340         m, x = (expr.args[0], None) if len(expr.args) == 1 else expr.args
2341         tex = r"E_{%s}" % self._print(m)
2342         if exp is not None:
2343             tex = r"%s^{%s}" % (tex, exp)
2344         if x is not None:
2345             tex = r"%s\left(%s\right)" % (tex, self._print(x))
2346         return tex
2347 
2348     def _print_catalan(self, expr, exp=None):
2349         tex = r"C_{%s}" % self._print(expr.args[0])
2350         if exp is not None:
2351             tex = r"%s^{%s}" % (tex, exp)
2352         return tex
2353 
2354     def _print_UnifiedTransform(self, expr, s, inverse=False):
2355         return r"\mathcal{{{}}}{}_{{{}}}\left[{}\right]\left({}\right)".format(s, '^{-1}' if inverse else '', self._print(expr.args[1]), self._print(expr.args[0]), self._print(expr.args[2]))
2356 
2357     def _print_MellinTransform(self, expr):
2358         return self._print_UnifiedTransform(expr, 'M')
2359 
2360     def _print_InverseMellinTransform(self, expr):
2361         return self._print_UnifiedTransform(expr, 'M', True)
2362 
2363     def _print_LaplaceTransform(self, expr):
2364         return self._print_UnifiedTransform(expr, 'L')
2365 
2366     def _print_InverseLaplaceTransform(self, expr):
2367         return self._print_UnifiedTransform(expr, 'L', True)
2368 
2369     def _print_FourierTransform(self, expr):
2370         return self._print_UnifiedTransform(expr, 'F')
2371 
2372     def _print_InverseFourierTransform(self, expr):
2373         return self._print_UnifiedTransform(expr, 'F', True)
2374 
2375     def _print_SineTransform(self, expr):
2376         return self._print_UnifiedTransform(expr, 'SIN')
2377 
2378     def _print_InverseSineTransform(self, expr):
2379         return self._print_UnifiedTransform(expr, 'SIN', True)
2380 
2381     def _print_CosineTransform(self, expr):
2382         return self._print_UnifiedTransform(expr, 'COS')
2383 
2384     def _print_InverseCosineTransform(self, expr):
2385         return self._print_UnifiedTransform(expr, 'COS', True)
2386 
2387     def _print_DMP(self, p):
2388         try:
2389             if p.ring is not None:
2390                 # TODO incorporate order
2391                 return self._print(p.ring.to_sympy(p))
2392         except SympifyError:
2393             pass
2394         return self._print(repr(p))
2395 
2396     def _print_DMF(self, p):
2397         return self._print_DMP(p)
2398 
2399     def _print_Object(self, object):
2400         return self._print(Symbol(object.name))
2401 
2402     def _print_LambertW(self, expr):
2403         if len(expr.args) == 1:
2404             return r"W\left(%s\right)" % self._print(expr.args[0])
2405         return r"W_{%s}\left(%s\right)" % \
2406             (self._print(expr.args[1]), self._print(expr.args[0]))
2407 
2408     def _print_Morphism(self, morphism):
2409         domain = self._print(morphism.domain)
2410         codomain = self._print(morphism.codomain)
2411         return "%s\\rightarrow %s" % (domain, codomain)
2412 
2413     def _print_TransferFunction(self, expr):
2414         from sympy.core import Mul, Pow
2415         num, den = expr.num, expr.den
2416         res = Mul(num, Pow(den, -1, evaluate=False), evaluate=False)
2417         return self._print_Mul(res)
2418 
2419     def _print_Series(self, expr):
2420         args = list(expr.args)
2421         parens = lambda x: self.parenthesize(x, precedence_traditional(expr),
2422                                              False)
2423         return ' '.join(map(parens, args))
2424 
2425     def _print_Parallel(self, expr):
2426         args = list(expr.args)
2427         parens = lambda x: self.parenthesize(x, precedence_traditional(expr),
2428                                              False)
2429         return ' '.join(map(parens, args))
2430 
2431     def _print_Feedback(self, expr):
2432         from sympy.physics.control import TransferFunction, Parallel, Series
2433 
2434         num, tf = expr.num, TransferFunction(1, 1, expr.num.var)
2435         num_arg_list = list(num.args) if isinstance(num, Series) else [num]
2436         den_arg_list = list(expr.den.args) if isinstance(expr.den, Series) else [expr.den]
2437 
2438         if isinstance(num, Series) and isinstance(expr.den, Series):
2439             den = Parallel(tf, Series(*num_arg_list, *den_arg_list))
2440         elif isinstance(num, Series) and isinstance(expr.den, TransferFunction):
2441             if expr.den == tf:
2442                 den = Parallel(tf, Series(*num_arg_list))
2443             else:
2444                 den = Parallel(tf, Series(*num_arg_list, expr.den))
2445         elif isinstance(num, TransferFunction) and isinstance(expr.den, Series):
2446             if num == tf:
2447                 den = Parallel(tf, Series(*den_arg_list))
2448             else:
2449                 den = Parallel(tf, Series(num, *den_arg_list))
2450         else:
2451             if num == tf:
2452                 den = Parallel(tf, *den_arg_list)
2453             elif expr.den == tf:
2454                 den = Parallel(tf, *num_arg_list)
2455             else:
2456                 den = Parallel(tf, Series(*num_arg_list, *den_arg_list))
2457 
2458         numer = self._print(num)
2459         denom = self._print(den)
2460         return r"\frac{%s}{%s}" % (numer, denom)
2461 
2462     def _print_NamedMorphism(self, morphism):
2463         pretty_name = self._print(Symbol(morphism.name))
2464         pretty_morphism = self._print_Morphism(morphism)
2465         return "%s:%s" % (pretty_name, pretty_morphism)
2466 
2467     def _print_IdentityMorphism(self, morphism):
2468         from sympy.categories import NamedMorphism
2469         return self._print_NamedMorphism(NamedMorphism(
2470             morphism.domain, morphism.codomain, "id"))
2471 
2472     def _print_CompositeMorphism(self, morphism):
2473         # All components of the morphism have names and it is thus
2474         # possible to build the name of the composite.
2475         component_names_list = [self._print(Symbol(component.name)) for
2476                                 component in morphism.components]
2477         component_names_list.reverse()
2478         component_names = "\\circ ".join(component_names_list) + ":"
2479 
2480         pretty_morphism = self._print_Morphism(morphism)
2481         return component_names + pretty_morphism
2482 
2483     def _print_Category(self, morphism):
2484         return r"\mathbf{{{}}}".format(self._print(Symbol(morphism.name)))
2485 
2486     def _print_Diagram(self, diagram):
2487         if not diagram.premises:
2488             # This is an empty diagram.
2489             return self._print(S.EmptySet)
2490 
2491         latex_result = self._print(diagram.premises)
2492         if diagram.conclusions:
2493             latex_result += "\\Longrightarrow %s" % \
2494                             self._print(diagram.conclusions)
2495 
2496         return latex_result
2497 
2498     def _print_DiagramGrid(self, grid):
2499         latex_result = "\\begin{array}{%s}\n" % ("c" * grid.width)
2500 
2501         for i in range(grid.height):
2502             for j in range(grid.width):
2503                 if grid[i, j]:
2504                     latex_result += latex(grid[i, j])
2505                 latex_result += " "
2506                 if j != grid.width - 1:
2507                     latex_result += "& "
2508 
2509             if i != grid.height - 1:
2510                 latex_result += "\\\\"
2511             latex_result += "\n"
2512 
2513         latex_result += "\\end{array}\n"
2514         return latex_result
2515 
2516     def _print_FreeModule(self, M):
2517         return '{{{}}}^{{{}}}'.format(self._print(M.ring), self._print(M.rank))
2518 
2519     def _print_FreeModuleElement(self, m):
2520         # Print as row vector for convenience, for now.
2521         return r"\left[ {} \right]".format(",".join(
2522             '{' + self._print(x) + '}' for x in m))
2523 
2524     def _print_SubModule(self, m):
2525         return r"\left\langle {} \right\rangle".format(",".join(
2526             '{' + self._print(x) + '}' for x in m.gens))
2527 
2528     def _print_ModuleImplementedIdeal(self, m):
2529         return r"\left\langle {} \right\rangle".format(",".join(
2530             '{' + self._print(x) + '}' for [x] in m._module.gens))
2531 
2532     def _print_Quaternion(self, expr):
2533         # TODO: This expression is potentially confusing,
2534         # shall we print it as `Quaternion( ... )`?
2535         s = [self.parenthesize(i, PRECEDENCE["Mul"], strict=True)
2536              for i in expr.args]
2537         a = [s[0]] + [i+" "+j for i, j in zip(s[1:], "ijk")]
2538         return " + ".join(a)
2539 
2540     def _print_QuotientRing(self, R):
2541         # TODO nicer fractions for few generators...
2542         return r"\frac{{{}}}{{{}}}".format(self._print(R.ring),
2543                  self._print(R.base_ideal))
2544 
2545     def _print_QuotientRingElement(self, x):
2546         return r"{{{}}} + {{{}}}".format(self._print(x.data),
2547                  self._print(x.ring.base_ideal))
2548 
2549     def _print_QuotientModuleElement(self, m):
2550         return r"{{{}}} + {{{}}}".format(self._print(m.data),
2551                  self._print(m.module.killed_module))
2552 
2553     def _print_QuotientModule(self, M):
2554         # TODO nicer fractions for few generators...
2555         return r"\frac{{{}}}{{{}}}".format(self._print(M.base),
2556                  self._print(M.killed_module))
2557 
2558     def _print_MatrixHomomorphism(self, h):
2559         return r"{{{}}} : {{{}}} \to {{{}}}".format(self._print(h._sympy_matrix()),
2560             self._print(h.domain), self._print(h.codomain))
2561 
2562     def _print_Manifold(self, manifold):
2563         string = manifold.name.name
2564         if '{' in string:
2565             name, supers, subs = string, [], []
2566         else:
2567             name, supers, subs = split_super_sub(string)
2568 
2569             name = translate(name)
2570             supers = [translate(sup) for sup in supers]
2571             subs = [translate(sub) for sub in subs]
2572 
2573         name = r'\text{%s}' % name
2574         if supers:
2575             name += "^{%s}" % " ".join(supers)
2576         if subs:
2577             name += "_{%s}" % " ".join(subs)
2578 
2579         return name
2580 
2581     def _print_Patch(self, patch):
2582         return r'\text{%s}_{%s}' % (self._print(patch.name), self._print(patch.manifold))
2583 
2584     def _print_CoordSystem(self, coordsys):
2585         return r'\text{%s}^{\text{%s}}_{%s}' % (
2586             self._print(coordsys.name), self._print(coordsys.patch.name), self._print(coordsys.manifold)
2587         )
2588 
2589     def _print_CovarDerivativeOp(self, cvd):
2590         return r'\mathbb{\nabla}_{%s}' % self._print(cvd._wrt)
2591 
2592     def _print_BaseScalarField(self, field):
2593         string = field._coord_sys.symbols[field._index].name
2594         return r'\mathbf{{{}}}'.format(self._print(Symbol(string)))
2595 
2596     def _print_BaseVectorField(self, field):
2597         string = field._coord_sys.symbols[field._index].name
2598         return r'\partial_{{{}}}'.format(self._print(Symbol(string)))
2599 
2600     def _print_Differential(self, diff):
2601         field = diff._form_field
2602         if hasattr(field, '_coord_sys'):
2603             string = field._coord_sys.symbols[field._index].name
2604             return r'\operatorname{{d}}{}'.format(self._print(Symbol(string)))
2605         else:
2606             string = self._print(field)
2607             return r'\operatorname{{d}}\left({}\right)'.format(string)
2608 
2609     def _print_Tr(self, p):
2610         # TODO: Handle indices
2611         contents = self._print(p.args[0])
2612         return r'\operatorname{{tr}}\left({}\right)'.format(contents)
2613 
2614     def _print_totient(self, expr, exp=None):
2615         if exp is not None:
2616             return r'\left(\phi\left(%s\right)\right)^{%s}' % \
2617                 (self._print(expr.args[0]), exp)
2618         return r'\phi\left(%s\right)' % self._print(expr.args[0])
2619 
2620     def _print_reduced_totient(self, expr, exp=None):
2621         if exp is not None:
2622             return r'\left(\lambda\left(%s\right)\right)^{%s}' % \
2623                 (self._print(expr.args[0]), exp)
2624         return r'\lambda\left(%s\right)' % self._print(expr.args[0])
2625 
2626     def _print_divisor_sigma(self, expr, exp=None):
2627         if len(expr.args) == 2:
2628             tex = r"_%s\left(%s\right)" % tuple(map(self._print,
2629                                                 (expr.args[1], expr.args[0])))
2630         else:
2631             tex = r"\left(%s\right)" % self._print(expr.args[0])
2632         if exp is not None:
2633             return r"\sigma^{%s}%s" % (exp, tex)
2634         return r"\sigma%s" % tex
2635 
2636     def _print_udivisor_sigma(self, expr, exp=None):
2637         if len(expr.args) == 2:
2638             tex = r"_%s\left(%s\right)" % tuple(map(self._print,
2639                                                 (expr.args[1], expr.args[0])))
2640         else:
2641             tex = r"\left(%s\right)" % self._print(expr.args[0])
2642         if exp is not None:
2643             return r"\sigma^*^{%s}%s" % (exp, tex)
2644         return r"\sigma^*%s" % tex
2645 
2646     def _print_primenu(self, expr, exp=None):
2647         if exp is not None:
2648             return r'\left(\nu\left(%s\right)\right)^{%s}' % \
2649                 (self._print(expr.args[0]), exp)
2650         return r'\nu\left(%s\right)' % self._print(expr.args[0])
2651 
2652     def _print_primeomega(self, expr, exp=None):
2653         if exp is not None:
2654             return r'\left(\Omega\left(%s\right)\right)^{%s}' % \
2655                 (self._print(expr.args[0]), exp)
2656         return r'\Omega\left(%s\right)' % self._print(expr.args[0])
2657 
2658     def _print_Str(self, s):
2659         return str(s.name)
2660 
2661     def _print_float(self, expr):
2662         return self._print(Float(expr))
2663 
2664     def _print_int(self, expr):
2665         return str(expr)
2666 
2667     def _print_mpz(self, expr):
2668         return str(expr)
2669 
2670     def _print_mpq(self, expr):
2671         return str(expr)
2672 
2673     def emptyPrinter(self, expr):
2674         # default to just printing as monospace, like would normally be shown
2675         s = super().emptyPrinter(expr)
2676 
2677         return r"\mathtt{\text{%s}}" % latex_escape(s)

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>, <file>sympy/printing/latex.py</file>
<class>LatexPrinter</class>
<method>_print_Mul</method>
<code>
498     def _print_Mul(self, expr):
499         from sympy.core.power import Pow
500         from sympy.physics.units import Quantity
501         from sympy.simplify import fraction
502         separator = self._settings['mul_symbol_latex']
503         numbersep = self._settings['mul_symbol_latex_numbers']
504 
505         def convert(expr):
506             if not expr.is_Mul:
507                 return str(self._print(expr))
508             else:
509                 if self.order not in ('old', 'none'):
510                     args = expr.as_ordered_factors()
511                 else:
512                     args = list(expr.args)
513 
514                 # If quantities are present append them at the back
515                 args = sorted(args, key=lambda x: isinstance(x, Quantity) or
516                               (isinstance(x, Pow) and
517                                isinstance(x.base, Quantity)))
518 
519                 return convert_args(args)
520 
521         def convert_args(args):
522                 _tex = last_term_tex = ""
523 
524                 for i, term in enumerate(args):
525                     term_tex = self._print(term)
526 
527                     if self._needs_mul_brackets(term, first=(i == 0),
528                                                 last=(i == len(args) - 1)):
529                         term_tex = r"\left(%s\right)" % term_tex
530 
531                     if _between_two_numbers_p[0].search(last_term_tex) and \
532                             _between_two_numbers_p[1].match(term_tex):
533                         # between two numbers
534                         _tex += numbersep
535                     elif _tex:
536                         _tex += separator
537 
538                     _tex += term_tex
539                     last_term_tex = term_tex
540                 return _tex
541 
542         # Check for unevaluated Mul. In this case we need to make sure the
543         # identities are visible, multiple Rational factors are not combined
544         # etc so we display in a straight-forward form that fully preserves all
545         # args and their order.
546         # XXX: _print_Pow calls this routine with instances of Pow...
547         if isinstance(expr, Mul):
548             args = expr.args
549             if args[0] is S.One or any(isinstance(arg, Number) for arg in args[1:]):
550                 return convert_args(args)
551 
552         include_parens = False
553         if _coeff_isneg(expr):
554             expr = -expr
555             tex = "- "
556             if expr.is_Add:
557                 tex += "("
558                 include_parens = True
559         else:
560             tex = ""
561 
562         numer, denom = fraction(expr, exact=True)
563 
564         if denom is S.One and Pow(1, -1, evaluate=False) not in expr.args:
565             # use the original expression here, since fraction() may have
566             # altered it when producing numer and denom
567             tex += convert(expr)
568 
569         else:
570             snumer = convert(numer)
571             sdenom = convert(denom)
572             ldenom = len(sdenom.split())
573             ratio = self._settings['long_frac_ratio']
574             if self._settings['fold_short_frac'] and ldenom <= 2 and \
575                     "^" not in sdenom:
576                 # handle short fractions
577                 if self._needs_mul_brackets(numer, last=False):
578                     tex += r"\left(%s\right) / %s" % (snumer, sdenom)
579                 else:
580                     tex += r"%s / %s" % (snumer, sdenom)
581             elif ratio is not None and \
582                     len(snumer.split()) > ratio*ldenom:
583                 # handle long fractions
584                 if self._needs_mul_brackets(numer, last=True):
585                     tex += r"\frac{1}{%s}%s\left(%s\right)" \
586                         % (sdenom, separator, snumer)
587                 elif numer.is_Mul:
588                     # split a long numerator
589                     a = S.One
590                     b = S.One
591                     for x in numer.args:
592                         if self._needs_mul_brackets(x, last=False) or \
593                                 len(convert(a*x).split()) > ratio*ldenom or \
594                                 (b.is_commutative is x.is_commutative is False):
595                             b *= x
596                         else:
597                             a *= x
598                     if self._needs_mul_brackets(b, last=True):
599                         tex += r"\frac{%s}{%s}%s\left(%s\right)" \
600                             % (convert(a), sdenom, separator, convert(b))
601                     else:
602                         tex += r"\frac{%s}{%s}%s%s" \
603                             % (convert(a), sdenom, separator, convert(b))
604                 else:
605                     tex += r"\frac{1}{%s}%s%s" % (sdenom, separator, snumer)
606             else:
607                 tex += r"\frac{%s}{%s}" % (snumer, sdenom)
608 
609         if include_parens:
610             tex += ")"
611         return tex

</code><intended_behavior>The `_print_Mul` method may need adjustments to ensure that it can correctly handle and format the multiplication expressions especially arising from the conversion of `Pow` types that represent reciprocal or negative powers. Given the `RecursionError`, a potential solution involves implementing checks or mechanisms that prevent unnecessary or erroneous recursion when dealing with `Pow` expressions formatted by `_print_Pow`. Any fix here must seamlessly integrate with the handling of different types of multiplication expressions, maintaining the method's general utility while ensuring correct output for cases that previously led to errors.</intended_behavior>, <file>sympy/printing/latex.py</file>
<class>LatexPrinter</class>
<method>None</method>
<code>
137 class LatexPrinter(Printer):
138     printmethod = "_latex"
139 
140     _default_settings = {
141         "full_prec": False,
142         "fold_frac_powers": False,
143         "fold_func_brackets": False,
144         "fold_short_frac": None,
145         "inv_trig_style": "abbreviated",
146         "itex": False,
147         "ln_notation": False,
148         "long_frac_ratio": None,
149         "mat_delim": "[",
150         "mat_str": None,
151         "mode": "plain",
152         "mul_symbol": None,
153         "order": None,
154         "symbol_names": {},
155         "root_notation": True,
156         "mat_symbol_style": "plain",
157         "imaginary_unit": "i",
158         "gothic_re_im": False,
159         "decimal_separator": "period",
160         "perm_cyclic": True,
161         "parenthesize_super": True,
162         "min": None,
163         "max": None,
164     }  # type: Dict[str, Any]
165 
166     def __init__(self, settings=None):
167         Printer.__init__(self, settings)
168 
169         if 'mode' in self._settings:
170             valid_modes = ['inline', 'plain', 'equation',
171                            'equation*']
172             if self._settings['mode'] not in valid_modes:
173                 raise ValueError("'mode' must be one of 'inline', 'plain', "
174                                  "'equation' or 'equation*'")
175 
176         if self._settings['fold_short_frac'] is None and \
177                 self._settings['mode'] == 'inline':
178             self._settings['fold_short_frac'] = True
179 
180         mul_symbol_table = {
181             None: r" ",
182             "ldot": r" \,.\, ",
183             "dot": r" \cdot ",
184             "times": r" \times "
185         }
186         try:
187             self._settings['mul_symbol_latex'] = \
188                 mul_symbol_table[self._settings['mul_symbol']]
189         except KeyError:
190             self._settings['mul_symbol_latex'] = \
191                 self._settings['mul_symbol']
192         try:
193             self._settings['mul_symbol_latex_numbers'] = \
194                 mul_symbol_table[self._settings['mul_symbol'] or 'dot']
195         except KeyError:
196             if (self._settings['mul_symbol'].strip() in
197                     ['', ' ', '\\', '\\,', '\\:', '\\;', '\\quad']):
198                 self._settings['mul_symbol_latex_numbers'] = \
199                     mul_symbol_table['dot']
200             else:
201                 self._settings['mul_symbol_latex_numbers'] = \
202                     self._settings['mul_symbol']
203 
204         self._delim_dict = {'(': ')', '[': ']'}
205 
206         imaginary_unit_table = {
207             None: r"i",
208             "i": r"i",
209             "ri": r"\mathrm{i}",
210             "ti": r"\text{i}",
211             "j": r"j",
212             "rj": r"\mathrm{j}",
213             "tj": r"\text{j}",
214         }
215         try:
216             self._settings['imaginary_unit_latex'] = \
217                 imaginary_unit_table[self._settings['imaginary_unit']]
218         except KeyError:
219             self._settings['imaginary_unit_latex'] = \
220                 self._settings['imaginary_unit']
221 
222     def _add_parens(self, s):
223         return r"\left({}\right)".format(s)
224 
225     # TODO: merge this with the above, which requires a lot of test changes
226     def _add_parens_lspace(self, s):
227         return r"\left( {}\right)".format(s)
228 
229     def parenthesize(self, item, level, is_neg=False, strict=False):
230         prec_val = precedence_traditional(item)
231         if is_neg and strict:
232             return self._add_parens(self._print(item))
233 
234         if (prec_val < level) or ((not strict) and prec_val <= level):
235             return self._add_parens(self._print(item))
236         else:
237             return self._print(item)
238 
239     def parenthesize_super(self, s):
240         """
241         Protect superscripts in s
242 
243         If the parenthesize_super option is set, protect with parentheses, else
244         wrap in braces.
245         """
246         if "^" in s:
247             if self._settings['parenthesize_super']:
248                 return self._add_parens(s)
249             else:
250                 return "{{{}}}".format(s)
251         return s
252 
253     def doprint(self, expr):
254         tex = Printer.doprint(self, expr)
255 
256         if self._settings['mode'] == 'plain':
257             return tex
258         elif self._settings['mode'] == 'inline':
259             return r"$%s$" % tex
260         elif self._settings['itex']:
261             return r"$$%s$$" % tex
262         else:
263             env_str = self._settings['mode']
264             return r"\begin{%s}%s\end{%s}" % (env_str, tex, env_str)
265 
266     def _needs_brackets(self, expr):
267         """
268         Returns True if the expression needs to be wrapped in brackets when
269         printed, False otherwise. For example: a + b => True; a => False;
270         10 => False; -10 => True.
271         """
272         return not ((expr.is_Integer and expr.is_nonnegative)
273                     or (expr.is_Atom and (expr is not S.NegativeOne
274                                           and expr.is_Rational is False)))
275 
276     def _needs_function_brackets(self, expr):
277         """
278         Returns True if the expression needs to be wrapped in brackets when
279         passed as an argument to a function, False otherwise. This is a more
280         liberal version of _needs_brackets, in that many expressions which need
281         to be wrapped in brackets when added/subtracted/raised to a power do
282         not need them when passed to a function. Such an example is a*b.
283         """
284         if not self._needs_brackets(expr):
285             return False
286         else:
287             # Muls of the form a*b*c... can be folded
288             if expr.is_Mul and not self._mul_is_clean(expr):
289                 return True
290             # Pows which don't need brackets can be folded
291             elif expr.is_Pow and not self._pow_is_clean(expr):
292                 return True
293             # Add and Function always need brackets
294             elif expr.is_Add or expr.is_Function:
295                 return True
296             else:
297                 return False
298 
299     def _needs_mul_brackets(self, expr, first=False, last=False):
300         """
301         Returns True if the expression needs to be wrapped in brackets when
302         printed as part of a Mul, False otherwise. This is True for Add,
303         but also for some container objects that would not need brackets
304         when appearing last in a Mul, e.g. an Integral. ``last=True``
305         specifies that this expr is the last to appear in a Mul.
306         ``first=True`` specifies that this expr is the first to appear in
307         a Mul.
308         """
309         from sympy import Integral, Product, Sum
310 
311         if expr.is_Mul:
312             if not first and _coeff_isneg(expr):
313                 return True
314         elif precedence_traditional(expr) < PRECEDENCE["Mul"]:
315             return True
316         elif expr.is_Relational:
317             return True
318         if expr.is_Piecewise:
319             return True
320         if any([expr.has(x) for x in (Mod,)]):
321             return True
322         if (not last and
323                 any([expr.has(x) for x in (Integral, Product, Sum)])):
324             return True
325 
326         return False
327 
328     def _needs_add_brackets(self, expr):
329         """
330         Returns True if the expression needs to be wrapped in brackets when
331         printed as part of an Add, False otherwise.  This is False for most
332         things.
333         """
334         if expr.is_Relational:
335             return True
336         if any([expr.has(x) for x in (Mod,)]):
337             return True
338         if expr.is_Add:
339             return True
340         return False
341 
342     def _mul_is_clean(self, expr):
343         for arg in expr.args:
344             if arg.is_Function:
345                 return False
346         return True
347 
348     def _pow_is_clean(self, expr):
349         return not self._needs_brackets(expr.base)
350 
351     def _do_exponent(self, expr, exp):
352         if exp is not None:
353             return r"\left(%s\right)^{%s}" % (expr, exp)
354         else:
355             return expr
356 
357     def _print_Basic(self, expr):
358         ls = [self._print(o) for o in expr.args]
359         return self._deal_with_super_sub(expr.__class__.__name__) + \
360             r"\left(%s\right)" % ", ".join(ls)
361 
362     def _print_bool(self, e):
363         return r"\text{%s}" % e
364 
365     _print_BooleanTrue = _print_bool
366     _print_BooleanFalse = _print_bool
367 
368     def _print_NoneType(self, e):
369         return r"\text{%s}" % e
370 
371     def _print_Add(self, expr, order=None):
372         terms = self._as_ordered_terms(expr, order=order)
373 
374         tex = ""
375         for i, term in enumerate(terms):
376             if i == 0:
377                 pass
378             elif _coeff_isneg(term):
379                 tex += " - "
380                 term = -term
381             else:
382                 tex += " + "
383             term_tex = self._print(term)
384             if self._needs_add_brackets(term):
385                 term_tex = r"\left(%s\right)" % term_tex
386             tex += term_tex
387 
388         return tex
389 
390     def _print_Cycle(self, expr):
391         from sympy.combinatorics.permutations import Permutation
392         if expr.size == 0:
393             return r"\left( \right)"
394         expr = Permutation(expr)
395         expr_perm = expr.cyclic_form
396         siz = expr.size
397         if expr.array_form[-1] == siz - 1:
398             expr_perm = expr_perm + [[siz - 1]]
399         term_tex = ''
400         for i in expr_perm:
401             term_tex += str(i).replace(',', r"\;")
402         term_tex = term_tex.replace('[', r"\left( ")
403         term_tex = term_tex.replace(']', r"\right)")
404         return term_tex
405 
406     def _print_Permutation(self, expr):
407         from sympy.combinatorics.permutations import Permutation
408         from sympy.utilities.exceptions import SymPyDeprecationWarning
409 
410         perm_cyclic = Permutation.print_cyclic
411         if perm_cyclic is not None:
412             SymPyDeprecationWarning(
413                 feature="Permutation.print_cyclic = {}".format(perm_cyclic),
414                 useinstead="init_printing(perm_cyclic={})"
415                 .format(perm_cyclic),
416                 issue=15201,
417                 deprecated_since_version="1.6").warn()
418         else:
419             perm_cyclic = self._settings.get("perm_cyclic", True)
420 
421         if perm_cyclic:
422             return self._print_Cycle(expr)
423 
424         if expr.size == 0:
425             return r"\left( \right)"
426 
427         lower = [self._print(arg) for arg in expr.array_form]
428         upper = [self._print(arg) for arg in range(len(lower))]
429 
430         row1 = " & ".join(upper)
431         row2 = " & ".join(lower)
432         mat = r" \\ ".join((row1, row2))
433         return r"\begin{pmatrix} %s \end{pmatrix}" % mat
434 
435 
436     def _print_AppliedPermutation(self, expr):
437         perm, var = expr.args
438         return r"\sigma_{%s}(%s)" % (self._print(perm), self._print(var))
439 
440     def _print_Float(self, expr):
441         # Based off of that in StrPrinter
442         dps = prec_to_dps(expr._prec)
443         strip = False if self._settings['full_prec'] else True
444         low = self._settings["min"] if "min" in self._settings else None
445         high = self._settings["max"] if "max" in self._settings else None
446         str_real = mlib.to_str(expr._mpf_, dps, strip_zeros=strip, min_fixed=low, max_fixed=high)
447 
448         # Must always have a mul symbol (as 2.5 10^{20} just looks odd)
449         # thus we use the number separator
450         separator = self._settings['mul_symbol_latex_numbers']
451 
452         if 'e' in str_real:
453             (mant, exp) = str_real.split('e')
454 
455             if exp[0] == '+':
456                 exp = exp[1:]
457             if self._settings['decimal_separator'] == 'comma':
458                 mant = mant.replace('.','{,}')
459 
460             return r"%s%s10^{%s}" % (mant, separator, exp)
461         elif str_real == "+inf":
462             return r"\infty"
463         elif str_real == "-inf":
464             return r"- \infty"
465         else:
466             if self._settings['decimal_separator'] == 'comma':
467                 str_real = str_real.replace('.','{,}')
468             return str_real
469 
470     def _print_Cross(self, expr):
471         vec1 = expr._expr1
472         vec2 = expr._expr2
473         return r"%s \times %s" % (self.parenthesize(vec1, PRECEDENCE['Mul']),
474                                   self.parenthesize(vec2, PRECEDENCE['Mul']))
475 
476     def _print_Curl(self, expr):
477         vec = expr._expr
478         return r"\nabla\times %s" % self.parenthesize(vec, PRECEDENCE['Mul'])
479 
480     def _print_Divergence(self, expr):
481         vec = expr._expr
482         return r"\nabla\cdot %s" % self.parenthesize(vec, PRECEDENCE['Mul'])
483 
484     def _print_Dot(self, expr):
485         vec1 = expr._expr1
486         vec2 = expr._expr2
487         return r"%s \cdot %s" % (self.parenthesize(vec1, PRECEDENCE['Mul']),
488                                  self.parenthesize(vec2, PRECEDENCE['Mul']))
489 
490     def _print_Gradient(self, expr):
491         func = expr._expr
492         return r"\nabla %s" % self.parenthesize(func, PRECEDENCE['Mul'])
493 
494     def _print_Laplacian(self, expr):
495         func = expr._expr
496         return r"\triangle %s" % self.parenthesize(func, PRECEDENCE['Mul'])
497 
498     def _print_Mul(self, expr):
499         from sympy.core.power import Pow
500         from sympy.physics.units import Quantity
501         from sympy.simplify import fraction
502         separator = self._settings['mul_symbol_latex']
503         numbersep = self._settings['mul_symbol_latex_numbers']
504 
505         def convert(expr):
506             if not expr.is_Mul:
507                 return str(self._print(expr))
508             else:
509                 if self.order not in ('old', 'none'):
510                     args = expr.as_ordered_factors()
511                 else:
512                     args = list(expr.args)
513 
514                 # If quantities are present append them at the back
515                 args = sorted(args, key=lambda x: isinstance(x, Quantity) or
516                               (isinstance(x, Pow) and
517                                isinstance(x.base, Quantity)))
518 
519                 return convert_args(args)
520 
521         def convert_args(args):
522                 _tex = last_term_tex = ""
523 
524                 for i, term in enumerate(args):
525                     term_tex = self._print(term)
526 
527                     if self._needs_mul_brackets(term, first=(i == 0),
528                                                 last=(i == len(args) - 1)):
529                         term_tex = r"\left(%s\right)" % term_tex
530 
531                     if _between_two_numbers_p[0].search(last_term_tex) and \
532                             _between_two_numbers_p[1].match(term_tex):
533                         # between two numbers
534                         _tex += numbersep
535                     elif _tex:
536                         _tex += separator
537 
538                     _tex += term_tex
539                     last_term_tex = term_tex
540                 return _tex
541 
542         # Check for unevaluated Mul. In this case we need to make sure the
543         # identities are visible, multiple Rational factors are not combined
544         # etc so we display in a straight-forward form that fully preserves all
545         # args and their order.
546         # XXX: _print_Pow calls this routine with instances of Pow...
547         if isinstance(expr, Mul):
548             args = expr.args
549             if args[0] is S.One or any(isinstance(arg, Number) for arg in args[1:]):
550                 return convert_args(args)
551 
552         include_parens = False
553         if _coeff_isneg(expr):
554             expr = -expr
555             tex = "- "
556             if expr.is_Add:
557                 tex += "("
558                 include_parens = True
559         else:
560             tex = ""
561 
562         numer, denom = fraction(expr, exact=True)
563 
564         if denom is S.One and Pow(1, -1, evaluate=False) not in expr.args:
565             # use the original expression here, since fraction() may have
566             # altered it when producing numer and denom
567             tex += convert(expr)
568 
569         else:
570             snumer = convert(numer)
571             sdenom = convert(denom)
572             ldenom = len(sdenom.split())
573             ratio = self._settings['long_frac_ratio']
574             if self._settings['fold_short_frac'] and ldenom <= 2 and \
575                     "^" not in sdenom:
576                 # handle short fractions
577                 if self._needs_mul_brackets(numer, last=False):
578                     tex += r"\left(%s\right) / %s" % (snumer, sdenom)
579                 else:
580                     tex += r"%s / %s" % (snumer, sdenom)
581             elif ratio is not None and \
582                     len(snumer.split()) > ratio*ldenom:
583                 # handle long fractions
584                 if self._needs_mul_brackets(numer, last=True):
585                     tex += r"\frac{1}{%s}%s\left(%s\right)" \
586                         % (sdenom, separator, snumer)
587                 elif numer.is_Mul:
588                     # split a long numerator
589                     a = S.One
590                     b = S.One
591                     for x in numer.args:
592                         if self._needs_mul_brackets(x, last=False) or \
593                                 len(convert(a*x).split()) > ratio*ldenom or \
594                                 (b.is_commutative is x.is_commutative is False):
595                             b *= x
596                         else:
597                             a *= x
598                     if self._needs_mul_brackets(b, last=True):
599                         tex += r"\frac{%s}{%s}%s\left(%s\right)" \
600                             % (convert(a), sdenom, separator, convert(b))
601                     else:
602                         tex += r"\frac{%s}{%s}%s%s" \
603                             % (convert(a), sdenom, separator, convert(b))
604                 else:
605                     tex += r"\frac{1}{%s}%s%s" % (sdenom, separator, snumer)
606             else:
607                 tex += r"\frac{%s}{%s}" % (snumer, sdenom)
608 
609         if include_parens:
610             tex += ")"
611         return tex
612 
613     def _print_Pow(self, expr):
614         # Treat x**Rational(1,n) as special case
615         if expr.exp.is_Rational and abs(expr.exp.p) == 1 and expr.exp.q != 1 \
616                 and self._settings['root_notation']:
617             base = self._print(expr.base)
618             expq = expr.exp.q
619 
620             if expq == 2:
621                 tex = r"\sqrt{%s}" % base
622             elif self._settings['itex']:
623                 tex = r"\root{%d}{%s}" % (expq, base)
624             else:
625                 tex = r"\sqrt[%d]{%s}" % (expq, base)
626 
627             if expr.exp.is_negative:
628                 return r"\frac{1}{%s}" % tex
629             else:
630                 return tex
631         elif self._settings['fold_frac_powers'] \
632             and expr.exp.is_Rational \
633                 and expr.exp.q != 1:
634             base = self.parenthesize(expr.base, PRECEDENCE['Pow'])
635             p, q = expr.exp.p, expr.exp.q
636             # issue #12886: add parentheses for superscripts raised to powers
637             if expr.base.is_Symbol:
638                 base = self.parenthesize_super(base)
639             if expr.base.is_Function:
640                 return self._print(expr.base, exp="%s/%s" % (p, q))
641             return r"%s^{%s/%s}" % (base, p, q)
642         elif expr.exp.is_Rational and expr.exp.is_negative and \
643                 expr.base.is_commutative:
644             # special case for 1^(-x), issue 9216
645             if expr.base == 1:
646                 return r"%s^{%s}" % (expr.base, expr.exp)
647             # things like 1/x
648             return self._print_Mul(expr)
649         else:
650             if expr.base.is_Function:
651                 return self._print(expr.base, exp=self._print(expr.exp))
652             else:
653                 tex = r"%s^{%s}"
654                 return self._helper_print_standard_power(expr, tex)
655 
656     def _helper_print_standard_power(self, expr, template):
657         exp = self._print(expr.exp)
658         # issue #12886: add parentheses around superscripts raised
659         # to powers
660         base = self.parenthesize(expr.base, PRECEDENCE['Pow'])
661         if expr.base.is_Symbol:
662             base = self.parenthesize_super(base)
663         elif (isinstance(expr.base, Derivative)
664             and base.startswith(r'\left(')
665             and re.match(r'\\left\(\\d?d?dot', base)
666             and base.endswith(r'\right)')):
667             # don't use parentheses around dotted derivative
668             base = base[6: -7]  # remove outermost added parens
669         return template % (base, exp)
670 
671     def _print_UnevaluatedExpr(self, expr):
672         return self._print(expr.args[0])
673 
674     def _print_Sum(self, expr):
675         if len(expr.limits) == 1:
676             tex = r"\sum_{%s=%s}^{%s} " % \
677                 tuple([self._print(i) for i in expr.limits[0]])
678         else:
679             def _format_ineq(l):
680                 return r"%s \leq %s \leq %s" % \
681                     tuple([self._print(s) for s in (l[1], l[0], l[2])])
682 
683             tex = r"\sum_{\substack{%s}} " % \
684                 str.join('\\\\', [_format_ineq(l) for l in expr.limits])
685 
686         if isinstance(expr.function, Add):
687             tex += r"\left(%s\right)" % self._print(expr.function)
688         else:
689             tex += self._print(expr.function)
690 
691         return tex
692 
693     def _print_Product(self, expr):
694         if len(expr.limits) == 1:
695             tex = r"\prod_{%s=%s}^{%s} " % \
696                 tuple([self._print(i) for i in expr.limits[0]])
697         else:
698             def _format_ineq(l):
699                 return r"%s \leq %s \leq %s" % \
700                     tuple([self._print(s) for s in (l[1], l[0], l[2])])
701 
702             tex = r"\prod_{\substack{%s}} " % \
703                 str.join('\\\\', [_format_ineq(l) for l in expr.limits])
704 
705         if isinstance(expr.function, Add):
706             tex += r"\left(%s\right)" % self._print(expr.function)
707         else:
708             tex += self._print(expr.function)
709 
710         return tex
711 
712     def _print_BasisDependent(self, expr):
713         from sympy.vector import Vector
714 
715         o1 = []
716         if expr == expr.zero:
717             return expr.zero._latex_form
718         if isinstance(expr, Vector):
719             items = expr.separate().items()
720         else:
721             items = [(0, expr)]
722 
723         for system, vect in items:
724             inneritems = list(vect.components.items())
725             inneritems.sort(key=lambda x: x[0].__str__())
726             for k, v in inneritems:
727                 if v == 1:
728                     o1.append(' + ' + k._latex_form)
729                 elif v == -1:
730                     o1.append(' - ' + k._latex_form)
731                 else:
732                     arg_str = '(' + self._print(v) + ')'
733                     o1.append(' + ' + arg_str + k._latex_form)
734 
735         outstr = (''.join(o1))
736         if outstr[1] != '-':
737             outstr = outstr[3:]
738         else:
739             outstr = outstr[1:]
740         return outstr
741 
742     def _print_Indexed(self, expr):
743         tex_base = self._print(expr.base)
744         tex = '{'+tex_base+'}'+'_{%s}' % ','.join(
745             map(self._print, expr.indices))
746         return tex
747 
748     def _print_IndexedBase(self, expr):
749         return self._print(expr.label)
750 
751     def _print_Derivative(self, expr):
752         if requires_partial(expr.expr):
753             diff_symbol = r'\partial'
754         else:
755             diff_symbol = r'd'
756 
757         tex = ""
758         dim = 0
759         for x, num in reversed(expr.variable_count):
760             dim += num
761             if num == 1:
762                 tex += r"%s %s" % (diff_symbol, self._print(x))
763             else:
764                 tex += r"%s %s^{%s}" % (diff_symbol,
765                                         self.parenthesize_super(self._print(x)),
766                                         self._print(num))
767 
768         if dim == 1:
769             tex = r"\frac{%s}{%s}" % (diff_symbol, tex)
770         else:
771             tex = r"\frac{%s^{%s}}{%s}" % (diff_symbol, self._print(dim), tex)
772 
773         if any(_coeff_isneg(i) for i in expr.args):
774             return r"%s %s" % (tex, self.parenthesize(expr.expr,
775                                                   PRECEDENCE["Mul"],
776                                                   is_neg=True,
777                                                   strict=True))
778 
779         return r"%s %s" % (tex, self.parenthesize(expr.expr,
780                                                   PRECEDENCE["Mul"],
781                                                   is_neg=False,
782                                                   strict=True))
783 
784     def _print_Subs(self, subs):
785         expr, old, new = subs.args
786         latex_expr = self._print(expr)
787         latex_old = (self._print(e) for e in old)
788         latex_new = (self._print(e) for e in new)
789         latex_subs = r'\\ '.join(
790             e[0] + '=' + e[1] for e in zip(latex_old, latex_new))
791         return r'\left. %s \right|_{\substack{ %s }}' % (latex_expr,
792                                                          latex_subs)
793 
794     def _print_Integral(self, expr):
795         tex, symbols = "", []
796 
797         # Only up to \iiiint exists
798         if len(expr.limits) <= 4 and all(len(lim) == 1 for lim in expr.limits):
799             # Use len(expr.limits)-1 so that syntax highlighters don't think
800             # \" is an escaped quote
801             tex = r"\i" + "i"*(len(expr.limits) - 1) + "nt"
802             symbols = [r"\, d%s" % self._print(symbol[0])
803                        for symbol in expr.limits]
804 
805         else:
806             for lim in reversed(expr.limits):
807                 symbol = lim[0]
808                 tex += r"\int"
809 
810                 if len(lim) > 1:
811                     if self._settings['mode'] != 'inline' \
812                             and not self._settings['itex']:
813                         tex += r"\limits"
814 
815                     if len(lim) == 3:
816                         tex += "_{%s}^{%s}" % (self._print(lim[1]),
817                                                self._print(lim[2]))
818                     if len(lim) == 2:
819                         tex += "^{%s}" % (self._print(lim[1]))
820 
821                 symbols.insert(0, r"\, d%s" % self._print(symbol))
822 
823         return r"%s %s%s" % (tex, self.parenthesize(expr.function,
824                                                     PRECEDENCE["Mul"],
825                                                     is_neg=any(_coeff_isneg(i) for i in expr.args),
826                                                     strict=True),
827                              "".join(symbols))
828 
829     def _print_Limit(self, expr):
830         e, z, z0, dir = expr.args
831 
832         tex = r"\lim_{%s \to " % self._print(z)
833         if str(dir) == '+-' or z0 in (S.Infinity, S.NegativeInfinity):
834             tex += r"%s}" % self._print(z0)
835         else:
836             tex += r"%s^%s}" % (self._print(z0), self._print(dir))
837 
838         if isinstance(e, AssocOp):
839             return r"%s\left(%s\right)" % (tex, self._print(e))
840         else:
841             return r"%s %s" % (tex, self._print(e))
842 
843     def _hprint_Function(self, func):
844         r'''
845         Logic to decide how to render a function to latex
846           - if it is a recognized latex name, use the appropriate latex command
847           - if it is a single letter, just use that letter
848           - if it is a longer name, then put \operatorname{} around it and be
849             mindful of undercores in the name
850         '''
851         func = self._deal_with_super_sub(func)
852         if func in accepted_latex_functions:
853             name = r"\%s" % func
854         elif len(func) == 1 or func.startswith('\\'):
855             name = func
856         else:
857             name = r"\operatorname{%s}" % func
858         return name
859 
860     def _print_Function(self, expr, exp=None):
861         r'''
862         Render functions to LaTeX, handling functions that LaTeX knows about
863         e.g., sin, cos, ... by using the proper LaTeX command (\sin, \cos, ...).
864         For single-letter function names, render them as regular LaTeX math
865         symbols. For multi-letter function names that LaTeX does not know
866         about, (e.g., Li, sech) use \operatorname{} so that the function name
867         is rendered in Roman font and LaTeX handles spacing properly.
868 
869         expr is the expression involving the function
870         exp is an exponent
871         '''
872         func = expr.func.__name__
873         if hasattr(self, '_print_' + func) and \
874                 not isinstance(expr, AppliedUndef):
875             return getattr(self, '_print_' + func)(expr, exp)
876         else:
877             args = [str(self._print(arg)) for arg in expr.args]
878             # How inverse trig functions should be displayed, formats are:
879             # abbreviated: asin, full: arcsin, power: sin^-1
880             inv_trig_style = self._settings['inv_trig_style']
881             # If we are dealing with a power-style inverse trig function
882             inv_trig_power_case = False
883             # If it is applicable to fold the argument brackets
884             can_fold_brackets = self._settings['fold_func_brackets'] and \
885                 len(args) == 1 and \
886                 not self._needs_function_brackets(expr.args[0])
887 
888             inv_trig_table = [
889                 "asin", "acos", "atan",
890                 "acsc", "asec", "acot",
891                 "asinh", "acosh", "atanh",
892                 "acsch", "asech", "acoth",
893             ]
894 
895             # If the function is an inverse trig function, handle the style
896             if func in inv_trig_table:
897                 if inv_trig_style == "abbreviated":
898                     pass
899                 elif inv_trig_style == "full":
900                     func = "arc" + func[1:]
901                 elif inv_trig_style == "power":
902                     func = func[1:]
903                     inv_trig_power_case = True
904 
905                     # Can never fold brackets if we're raised to a power
906                     if exp is not None:
907                         can_fold_brackets = False
908 
909             if inv_trig_power_case:
910                 if func in accepted_latex_functions:
911                     name = r"\%s^{-1}" % func
912                 else:
913                     name = r"\operatorname{%s}^{-1}" % func
914             elif exp is not None:
915                 func_tex = self._hprint_Function(func)
916                 func_tex = self.parenthesize_super(func_tex)
917                 name = r'%s^{%s}' % (func_tex, exp)
918             else:
919                 name = self._hprint_Function(func)
920 
921             if can_fold_brackets:
922                 if func in accepted_latex_functions:
923                     # Wrap argument safely to avoid parse-time conflicts
924                     # with the function name itself
925                     name += r" {%s}"
926                 else:
927                     name += r"%s"
928             else:
929                 name += r"{\left(%s \right)}"
930 
931             if inv_trig_power_case and exp is not None:
932                 name += r"^{%s}" % exp
933 
934             return name % ",".join(args)
935 
936     def _print_UndefinedFunction(self, expr):
937         return self._hprint_Function(str(expr))
938 
939     def _print_ElementwiseApplyFunction(self, expr):
940         return r"{%s}_{\circ}\left({%s}\right)" % (
941             self._print(expr.function),
942             self._print(expr.expr),
943         )
944 
945     @property
946     def _special_function_classes(self):
947         from sympy.functions.special.tensor_functions import KroneckerDelta
948         from sympy.functions.special.gamma_functions import gamma, lowergamma
949         from sympy.functions.special.beta_functions import beta
950         from sympy.functions.special.delta_functions import DiracDelta
951         from sympy.functions.special.error_functions import Chi
952         return {KroneckerDelta: r'\delta',
953                 gamma:  r'\Gamma',
954                 lowergamma: r'\gamma',
955                 beta: r'\operatorname{B}',
956                 DiracDelta: r'\delta',
957                 Chi: r'\operatorname{Chi}'}
958 
959     def _print_FunctionClass(self, expr):
960         for cls in self._special_function_classes:
961             if issubclass(expr, cls) and expr.__name__ == cls.__name__:
962                 return self._special_function_classes[cls]
963         return self._hprint_Function(str(expr))
964 
965     def _print_Lambda(self, expr):
966         symbols, expr = expr.args
967 
968         if len(symbols) == 1:
969             symbols = self._print(symbols[0])
970         else:
971             symbols = self._print(tuple(symbols))
972 
973         tex = r"\left( %s \mapsto %s \right)" % (symbols, self._print(expr))
974 
975         return tex
976 
977     def _print_IdentityFunction(self, expr):
978         return r"\left( x \mapsto x \right)"
979 
980     def _hprint_variadic_function(self, expr, exp=None):
981         args = sorted(expr.args, key=default_sort_key)
982         texargs = [r"%s" % self._print(symbol) for symbol in args]
983         tex = r"\%s\left(%s\right)" % (str(expr.func).lower(),
984                                        ", ".join(texargs))
985         if exp is not None:
986             return r"%s^{%s}" % (tex, exp)
987         else:
988             return tex
989 
990     _print_Min = _print_Max = _hprint_variadic_function
991 
992     def _print_floor(self, expr, exp=None):
993         tex = r"\left\lfloor{%s}\right\rfloor" % self._print(expr.args[0])
994 
995         if exp is not None:
996             return r"%s^{%s}" % (tex, exp)
997         else:
998             return tex
999 
1000     def _print_ceiling(self, expr, exp=None):
1001         tex = r"\left\lceil{%s}\right\rceil" % self._print(expr.args[0])
1002 
1003         if exp is not None:
1004             return r"%s^{%s}" % (tex, exp)
1005         else:
1006             return tex
1007 
1008     def _print_log(self, expr, exp=None):
1009         if not self._settings["ln_notation"]:
1010             tex = r"\log{\left(%s \right)}" % self._print(expr.args[0])
1011         else:
1012             tex = r"\ln{\left(%s \right)}" % self._print(expr.args[0])
1013 
1014         if exp is not None:
1015             return r"%s^{%s}" % (tex, exp)
1016         else:
1017             return tex
1018 
1019     def _print_Abs(self, expr, exp=None):
1020         tex = r"\left|{%s}\right|" % self._print(expr.args[0])
1021 
1022         if exp is not None:
1023             return r"%s^{%s}" % (tex, exp)
1024         else:
1025             return tex
1026     _print_Determinant = _print_Abs
1027 
1028     def _print_re(self, expr, exp=None):
1029         if self._settings['gothic_re_im']:
1030             tex = r"\Re{%s}" % self.parenthesize(expr.args[0], PRECEDENCE['Atom'])
1031         else:
1032             tex = r"\operatorname{{re}}{{{}}}".format(self.parenthesize(expr.args[0], PRECEDENCE['Atom']))
1033 
1034         return self._do_exponent(tex, exp)
1035 
1036     def _print_im(self, expr, exp=None):
1037         if self._settings['gothic_re_im']:
1038             tex = r"\Im{%s}" % self.parenthesize(expr.args[0], PRECEDENCE['Atom'])
1039         else:
1040             tex = r"\operatorname{{im}}{{{}}}".format(self.parenthesize(expr.args[0], PRECEDENCE['Atom']))
1041 
1042         return self._do_exponent(tex, exp)
1043 
1044     def _print_Not(self, e):
1045         from sympy import Equivalent, Implies
1046         if isinstance(e.args[0], Equivalent):
1047             return self._print_Equivalent(e.args[0], r"\not\Leftrightarrow")
1048         if isinstance(e.args[0], Implies):
1049             return self._print_Implies(e.args[0], r"\not\Rightarrow")
1050         if (e.args[0].is_Boolean):
1051             return r"\neg \left(%s\right)" % self._print(e.args[0])
1052         else:
1053             return r"\neg %s" % self._print(e.args[0])
1054 
1055     def _print_LogOp(self, args, char):
1056         arg = args[0]
1057         if arg.is_Boolean and not arg.is_Not:
1058             tex = r"\left(%s\right)" % self._print(arg)
1059         else:
1060             tex = r"%s" % self._print(arg)
1061 
1062         for arg in args[1:]:
1063             if arg.is_Boolean and not arg.is_Not:
1064                 tex += r" %s \left(%s\right)" % (char, self._print(arg))
1065             else:
1066                 tex += r" %s %s" % (char, self._print(arg))
1067 
1068         return tex
1069 
1070     def _print_And(self, e):
1071         args = sorted(e.args, key=default_sort_key)
1072         return self._print_LogOp(args, r"\wedge")
1073 
1074     def _print_Or(self, e):
1075         args = sorted(e.args, key=default_sort_key)
1076         return self._print_LogOp(args, r"\vee")
1077 
1078     def _print_Xor(self, e):
1079         args = sorted(e.args, key=default_sort_key)
1080         return self._print_LogOp(args, r"\veebar")
1081 
1082     def _print_Implies(self, e, altchar=None):
1083         return self._print_LogOp(e.args, altchar or r"\Rightarrow")
1084 
1085     def _print_Equivalent(self, e, altchar=None):
1086         args = sorted(e.args, key=default_sort_key)
1087         return self._print_LogOp(args, altchar or r"\Leftrightarrow")
1088 
1089     def _print_conjugate(self, expr, exp=None):
1090         tex = r"\overline{%s}" % self._print(expr.args[0])
1091 
1092         if exp is not None:
1093             return r"%s^{%s}" % (tex, exp)
1094         else:
1095             return tex
1096 
1097     def _print_polar_lift(self, expr, exp=None):
1098         func = r"\operatorname{polar\_lift}"
1099         arg = r"{\left(%s \right)}" % self._print(expr.args[0])
1100 
1101         if exp is not None:
1102             return r"%s^{%s}%s" % (func, exp, arg)
1103         else:
1104             return r"%s%s" % (func, arg)
1105 
1106     def _print_ExpBase(self, expr, exp=None):
1107         # TODO should exp_polar be printed differently?
1108         #      what about exp_polar(0), exp_polar(1)?
1109         tex = r"e^{%s}" % self._print(expr.args[0])
1110         return self._do_exponent(tex, exp)
1111 
1112     def _print_elliptic_k(self, expr, exp=None):
1113         tex = r"\left(%s\right)" % self._print(expr.args[0])
1114         if exp is not None:
1115             return r"K^{%s}%s" % (exp, tex)
1116         else:
1117             return r"K%s" % tex
1118 
1119     def _print_elliptic_f(self, expr, exp=None):
1120         tex = r"\left(%s\middle| %s\right)" % \
1121             (self._print(expr.args[0]), self._print(expr.args[1]))
1122         if exp is not None:
1123             return r"F^{%s}%s" % (exp, tex)
1124         else:
1125             return r"F%s" % tex
1126 
1127     def _print_elliptic_e(self, expr, exp=None):
1128         if len(expr.args) == 2:
1129             tex = r"\left(%s\middle| %s\right)" % \
1130                 (self._print(expr.args[0]), self._print(expr.args[1]))
1131         else:
1132             tex = r"\left(%s\right)" % self._print(expr.args[0])
1133         if exp is not None:
1134             return r"E^{%s}%s" % (exp, tex)
1135         else:
1136             return r"E%s" % tex
1137 
1138     def _print_elliptic_pi(self, expr, exp=None):
1139         if len(expr.args) == 3:
1140             tex = r"\left(%s; %s\middle| %s\right)" % \
1141                 (self._print(expr.args[0]), self._print(expr.args[1]),
1142                  self._print(expr.args[2]))
1143         else:
1144             tex = r"\left(%s\middle| %s\right)" % \
1145                 (self._print(expr.args[0]), self._print(expr.args[1]))
1146         if exp is not None:
1147             return r"\Pi^{%s}%s" % (exp, tex)
1148         else:
1149             return r"\Pi%s" % tex
1150 
1151     def _print_beta(self, expr, exp=None):
1152         tex = r"\left(%s, %s\right)" % (self._print(expr.args[0]),
1153                                         self._print(expr.args[1]))
1154 
1155         if exp is not None:
1156             return r"\operatorname{B}^{%s}%s" % (exp, tex)
1157         else:
1158             return r"\operatorname{B}%s" % tex
1159 
1160     def _print_uppergamma(self, expr, exp=None):
1161         tex = r"\left(%s, %s\right)" % (self._print(expr.args[0]),
1162                                         self._print(expr.args[1]))
1163 
1164         if exp is not None:
1165             return r"\Gamma^{%s}%s" % (exp, tex)
1166         else:
1167             return r"\Gamma%s" % tex
1168 
1169     def _print_lowergamma(self, expr, exp=None):
1170         tex = r"\left(%s, %s\right)" % (self._print(expr.args[0]),
1171                                         self._print(expr.args[1]))
1172 
1173         if exp is not None:
1174             return r"\gamma^{%s}%s" % (exp, tex)
1175         else:
1176             return r"\gamma%s" % tex
1177 
1178     def _hprint_one_arg_func(self, expr, exp=None):
1179         tex = r"\left(%s\right)" % self._print(expr.args[0])
1180 
1181         if exp is not None:
1182             return r"%s^{%s}%s" % (self._print(expr.func), exp, tex)
1183         else:
1184             return r"%s%s" % (self._print(expr.func), tex)
1185 
1186     _print_gamma = _hprint_one_arg_func
1187 
1188     def _print_Chi(self, expr, exp=None):
1189         tex = r"\left(%s\right)" % self._print(expr.args[0])
1190 
1191         if exp is not None:
1192             return r"\operatorname{Chi}^{%s}%s" % (exp, tex)
1193         else:
1194             return r"\operatorname{Chi}%s" % tex
1195 
1196     def _print_expint(self, expr, exp=None):
1197         tex = r"\left(%s\right)" % self._print(expr.args[1])
1198         nu = self._print(expr.args[0])
1199 
1200         if exp is not None:
1201             return r"\operatorname{E}_{%s}^{%s}%s" % (nu, exp, tex)
1202         else:
1203             return r"\operatorname{E}_{%s}%s" % (nu, tex)
1204 
1205     def _print_fresnels(self, expr, exp=None):
1206         tex = r"\left(%s\right)" % self._print(expr.args[0])
1207 
1208         if exp is not None:
1209             return r"S^{%s}%s" % (exp, tex)
1210         else:
1211             return r"S%s" % tex
1212 
1213     def _print_fresnelc(self, expr, exp=None):
1214         tex = r"\left(%s\right)" % self._print(expr.args[0])
1215 
1216         if exp is not None:
1217             return r"C^{%s}%s" % (exp, tex)
1218         else:
1219             return r"C%s" % tex
1220 
1221     def _print_subfactorial(self, expr, exp=None):
1222         tex = r"!%s" % self.parenthesize(expr.args[0], PRECEDENCE["Func"])
1223 
1224         if exp is not None:
1225             return r"\left(%s\right)^{%s}" % (tex, exp)
1226         else:
1227             return tex
1228 
1229     def _print_factorial(self, expr, exp=None):
1230         tex = r"%s!" % self.parenthesize(expr.args[0], PRECEDENCE["Func"])
1231 
1232         if exp is not None:
1233             return r"%s^{%s}" % (tex, exp)
1234         else:
1235             return tex
1236 
1237     def _print_factorial2(self, expr, exp=None):
1238         tex = r"%s!!" % self.parenthesize(expr.args[0], PRECEDENCE["Func"])
1239 
1240         if exp is not None:
1241             return r"%s^{%s}" % (tex, exp)
1242         else:
1243             return tex
1244 
1245     def _print_binomial(self, expr, exp=None):
1246         tex = r"{\binom{%s}{%s}}" % (self._print(expr.args[0]),
1247                                      self._print(expr.args[1]))
1248 
1249         if exp is not None:
1250             return r"%s^{%s}" % (tex, exp)
1251         else:
1252             return tex
1253 
1254     def _print_RisingFactorial(self, expr, exp=None):
1255         n, k = expr.args
1256         base = r"%s" % self.parenthesize(n, PRECEDENCE['Func'])
1257 
1258         tex = r"{%s}^{\left(%s\right)}" % (base, self._print(k))
1259 
1260         return self._do_exponent(tex, exp)
1261 
1262     def _print_FallingFactorial(self, expr, exp=None):
1263         n, k = expr.args
1264         sub = r"%s" % self.parenthesize(k, PRECEDENCE['Func'])
1265 
1266         tex = r"{\left(%s\right)}_{%s}" % (self._print(n), sub)
1267 
1268         return self._do_exponent(tex, exp)
1269 
1270     def _hprint_BesselBase(self, expr, exp, sym):
1271         tex = r"%s" % (sym)
1272 
1273         need_exp = False
1274         if exp is not None:
1275             if tex.find('^') == -1:
1276                 tex = r"%s^{%s}" % (tex, exp)
1277             else:
1278                 need_exp = True
1279 
1280         tex = r"%s_{%s}\left(%s\right)" % (tex, self._print(expr.order),
1281                                            self._print(expr.argument))
1282 
1283         if need_exp:
1284             tex = self._do_exponent(tex, exp)
1285         return tex
1286 
1287     def _hprint_vec(self, vec):
1288         if not vec:
1289             return ""
1290         s = ""
1291         for i in vec[:-1]:
1292             s += "%s, " % self._print(i)
1293         s += self._print(vec[-1])
1294         return s
1295 
1296     def _print_besselj(self, expr, exp=None):
1297         return self._hprint_BesselBase(expr, exp, 'J')
1298 
1299     def _print_besseli(self, expr, exp=None):
1300         return self._hprint_BesselBase(expr, exp, 'I')
1301 
1302     def _print_besselk(self, expr, exp=None):
1303         return self._hprint_BesselBase(expr, exp, 'K')
1304 
1305     def _print_bessely(self, expr, exp=None):
1306         return self._hprint_BesselBase(expr, exp, 'Y')
1307 
1308     def _print_yn(self, expr, exp=None):
1309         return self._hprint_BesselBase(expr, exp, 'y')
1310 
1311     def _print_jn(self, expr, exp=None):
1312         return self._hprint_BesselBase(expr, exp, 'j')
1313 
1314     def _print_hankel1(self, expr, exp=None):
1315         return self._hprint_BesselBase(expr, exp, 'H^{(1)}')
1316 
1317     def _print_hankel2(self, expr, exp=None):
1318         return self._hprint_BesselBase(expr, exp, 'H^{(2)}')
1319 
1320     def _print_hn1(self, expr, exp=None):
1321         return self._hprint_BesselBase(expr, exp, 'h^{(1)}')
1322 
1323     def _print_hn2(self, expr, exp=None):
1324         return self._hprint_BesselBase(expr, exp, 'h^{(2)}')
1325 
1326     def _hprint_airy(self, expr, exp=None, notation=""):
1327         tex = r"\left(%s\right)" % self._print(expr.args[0])
1328 
1329         if exp is not None:
1330             return r"%s^{%s}%s" % (notation, exp, tex)
1331         else:
1332             return r"%s%s" % (notation, tex)
1333 
1334     def _hprint_airy_prime(self, expr, exp=None, notation=""):
1335         tex = r"\left(%s\right)" % self._print(expr.args[0])
1336 
1337         if exp is not None:
1338             return r"{%s^\prime}^{%s}%s" % (notation, exp, tex)
1339         else:
1340             return r"%s^\prime%s" % (notation, tex)
1341 
1342     def _print_airyai(self, expr, exp=None):
1343         return self._hprint_airy(expr, exp, 'Ai')
1344 
1345     def _print_airybi(self, expr, exp=None):
1346         return self._hprint_airy(expr, exp, 'Bi')
1347 
1348     def _print_airyaiprime(self, expr, exp=None):
1349         return self._hprint_airy_prime(expr, exp, 'Ai')
1350 
1351     def _print_airybiprime(self, expr, exp=None):
1352         return self._hprint_airy_prime(expr, exp, 'Bi')
1353 
1354     def _print_hyper(self, expr, exp=None):
1355         tex = r"{{}_{%s}F_{%s}\left(\begin{matrix} %s \\ %s \end{matrix}" \
1356               r"\middle| {%s} \right)}" % \
1357             (self._print(len(expr.ap)), self._print(len(expr.bq)),
1358               self._hprint_vec(expr.ap), self._hprint_vec(expr.bq),
1359               self._print(expr.argument))
1360 
1361         if exp is not None:
1362             tex = r"{%s}^{%s}" % (tex, exp)
1363         return tex
1364 
1365     def _print_meijerg(self, expr, exp=None):
1366         tex = r"{G_{%s, %s}^{%s, %s}\left(\begin{matrix} %s & %s \\" \
1367               r"%s & %s \end{matrix} \middle| {%s} \right)}" % \
1368             (self._print(len(expr.ap)), self._print(len(expr.bq)),
1369               self._print(len(expr.bm)), self._print(len(expr.an)),
1370               self._hprint_vec(expr.an), self._hprint_vec(expr.aother),
1371               self._hprint_vec(expr.bm), self._hprint_vec(expr.bother),
1372               self._print(expr.argument))
1373 
1374         if exp is not None:
1375             tex = r"{%s}^{%s}" % (tex, exp)
1376         return tex
1377 
1378     def _print_dirichlet_eta(self, expr, exp=None):
1379         tex = r"\left(%s\right)" % self._print(expr.args[0])
1380         if exp is not None:
1381             return r"\eta^{%s}%s" % (exp, tex)
1382         return r"\eta%s" % tex
1383 
1384     def _print_zeta(self, expr, exp=None):
1385         if len(expr.args) == 2:
1386             tex = r"\left(%s, %s\right)" % tuple(map(self._print, expr.args))
1387         else:
1388             tex = r"\left(%s\right)" % self._print(expr.args[0])
1389         if exp is not None:
1390             return r"\zeta^{%s}%s" % (exp, tex)
1391         return r"\zeta%s" % tex
1392 
1393     def _print_stieltjes(self, expr, exp=None):
1394         if len(expr.args) == 2:
1395             tex = r"_{%s}\left(%s\right)" % tuple(map(self._print, expr.args))
1396         else:
1397             tex = r"_{%s}" % self._print(expr.args[0])
1398         if exp is not None:
1399             return r"\gamma%s^{%s}" % (tex, exp)
1400         return r"\gamma%s" % tex
1401 
1402     def _print_lerchphi(self, expr, exp=None):
1403         tex = r"\left(%s, %s, %s\right)" % tuple(map(self._print, expr.args))
1404         if exp is None:
1405             return r"\Phi%s" % tex
1406         return r"\Phi^{%s}%s" % (exp, tex)
1407 
1408     def _print_polylog(self, expr, exp=None):
1409         s, z = map(self._print, expr.args)
1410         tex = r"\left(%s\right)" % z
1411         if exp is None:
1412             return r"\operatorname{Li}_{%s}%s" % (s, tex)
1413         return r"\operatorname{Li}_{%s}^{%s}%s" % (s, exp, tex)
1414 
1415     def _print_jacobi(self, expr, exp=None):
1416         n, a, b, x = map(self._print, expr.args)
1417         tex = r"P_{%s}^{\left(%s,%s\right)}\left(%s\right)" % (n, a, b, x)
1418         if exp is not None:
1419             tex = r"\left(" + tex + r"\right)^{%s}" % (exp)
1420         return tex
1421 
1422     def _print_gegenbauer(self, expr, exp=None):
1423         n, a, x = map(self._print, expr.args)
1424         tex = r"C_{%s}^{\left(%s\right)}\left(%s\right)" % (n, a, x)
1425         if exp is not None:
1426             tex = r"\left(" + tex + r"\right)^{%s}" % (exp)
1427         return tex
1428 
1429     def _print_chebyshevt(self, expr, exp=None):
1430         n, x = map(self._print, expr.args)
1431         tex = r"T_{%s}\left(%s\right)" % (n, x)
1432         if exp is not None:
1433             tex = r"\left(" + tex + r"\right)^{%s}" % (exp)
1434         return tex
1435 
1436     def _print_chebyshevu(self, expr, exp=None):
1437         n, x = map(self._print, expr.args)
1438         tex = r"U_{%s}\left(%s\right)" % (n, x)
1439         if exp is not None:
1440             tex = r"\left(" + tex + r"\right)^{%s}" % (exp)
1441         return tex
1442 
1443     def _print_legendre(self, expr, exp=None):
1444         n, x = map(self._print, expr.args)
1445         tex = r"P_{%s}\left(%s\right)" % (n, x)
1446         if exp is not None:
1447             tex = r"\left(" + tex + r"\right)^{%s}" % (exp)
1448         return tex
1449 
1450     def _print_assoc_legendre(self, expr, exp=None):
1451         n, a, x = map(self._print, expr.args)
1452         tex = r"P_{%s}^{\left(%s\right)}\left(%s\right)" % (n, a, x)
1453         if exp is not None:
1454             tex = r"\left(" + tex + r"\right)^{%s}" % (exp)
1455         return tex
1456 
1457     def _print_hermite(self, expr, exp=None):
1458         n, x = map(self._print, expr.args)
1459         tex = r"H_{%s}\left(%s\right)" % (n, x)
1460         if exp is not None:
1461             tex = r"\left(" + tex + r"\right)^{%s}" % (exp)
1462         return tex
1463 
1464     def _print_laguerre(self, expr, exp=None):
1465         n, x = map(self._print, expr.args)
1466         tex = r"L_{%s}\left(%s\right)" % (n, x)
1467         if exp is not None:
1468             tex = r"\left(" + tex + r"\right)^{%s}" % (exp)
1469         return tex
1470 
1471     def _print_assoc_laguerre(self, expr, exp=None):
1472         n, a, x = map(self._print, expr.args)
1473         tex = r"L_{%s}^{\left(%s\right)}\left(%s\right)" % (n, a, x)
1474         if exp is not None:
1475             tex = r"\left(" + tex + r"\right)^{%s}" % (exp)
1476         return tex
1477 
1478     def _print_Ynm(self, expr, exp=None):
1479         n, m, theta, phi = map(self._print, expr.args)
1480         tex = r"Y_{%s}^{%s}\left(%s,%s\right)" % (n, m, theta, phi)
1481         if exp is not None:
1482             tex = r"\left(" + tex + r"\right)^{%s}" % (exp)
1483         return tex
1484 
1485     def _print_Znm(self, expr, exp=None):
1486         n, m, theta, phi = map(self._print, expr.args)
1487         tex = r"Z_{%s}^{%s}\left(%s,%s\right)" % (n, m, theta, phi)
1488         if exp is not None:
1489             tex = r"\left(" + tex + r"\right)^{%s}" % (exp)
1490         return tex
1491 
1492     def __print_mathieu_functions(self, character, args, prime=False, exp=None):
1493         a, q, z = map(self._print, args)
1494         sup = r"^{\prime}" if prime else ""
1495         exp = "" if not exp else "^{%s}" % exp
1496         return r"%s%s\left(%s, %s, %s\right)%s" % (character, sup, a, q, z, exp)
1497 
1498     def _print_mathieuc(self, expr, exp=None):
1499         return self.__print_mathieu_functions("C", expr.args, exp=exp)
1500 
1501     def _print_mathieus(self, expr, exp=None):
1502         return self.__print_mathieu_functions("S", expr.args, exp=exp)
1503 
1504     def _print_mathieucprime(self, expr, exp=None):
1505         return self.__print_mathieu_functions("C", expr.args, prime=True, exp=exp)
1506 
1507     def _print_mathieusprime(self, expr, exp=None):
1508         return self.__print_mathieu_functions("S", expr.args, prime=True, exp=exp)
1509 
1510     def _print_Rational(self, expr):
1511         if expr.q != 1:
1512             sign = ""
1513             p = expr.p
1514             if expr.p < 0:
1515                 sign = "- "
1516                 p = -p
1517             if self._settings['fold_short_frac']:
1518                 return r"%s%d / %d" % (sign, p, expr.q)
1519             return r"%s\frac{%d}{%d}" % (sign, p, expr.q)
1520         else:
1521             return self._print(expr.p)
1522 
1523     def _print_Order(self, expr):
1524         s = self._print(expr.expr)
1525         if expr.point and any(p != S.Zero for p in expr.point) or \
1526            len(expr.variables) > 1:
1527             s += '; '
1528             if len(expr.variables) > 1:
1529                 s += self._print(expr.variables)
1530             elif expr.variables:
1531                 s += self._print(expr.variables[0])
1532             s += r'\rightarrow '
1533             if len(expr.point) > 1:
1534                 s += self._print(expr.point)
1535             else:
1536                 s += self._print(expr.point[0])
1537         return r"O\left(%s\right)" % s
1538 
1539     def _print_Symbol(self, expr, style='plain'):
1540         if expr in self._settings['symbol_names']:
1541             return self._settings['symbol_names'][expr]
1542 
1543         return self._deal_with_super_sub(expr.name, style=style)
1544 
1545     _print_RandomSymbol = _print_Symbol
1546 
1547     def _deal_with_super_sub(self, string, style='plain'):
1548         if '{' in string:
1549             name, supers, subs = string, [], []
1550         else:
1551             name, supers, subs = split_super_sub(string)
1552 
1553             name = translate(name)
1554             supers = [translate(sup) for sup in supers]
1555             subs = [translate(sub) for sub in subs]
1556 
1557         # apply the style only to the name
1558         if style == 'bold':
1559             name = "\\mathbf{{{}}}".format(name)
1560 
1561         # glue all items together:
1562         if supers:
1563             name += "^{%s}" % " ".join(supers)
1564         if subs:
1565             name += "_{%s}" % " ".join(subs)
1566 
1567         return name
1568 
1569     def _print_Relational(self, expr):
1570         if self._settings['itex']:
1571             gt = r"\gt"
1572             lt = r"\lt"
1573         else:
1574             gt = ">"
1575             lt = "<"
1576 
1577         charmap = {
1578             "==": "=",
1579             ">": gt,
1580             "<": lt,
1581             ">=": r"\geq",
1582             "<=": r"\leq",
1583             "!=": r"\neq",
1584         }
1585 
1586         return "%s %s %s" % (self._print(expr.lhs),
1587                              charmap[expr.rel_op], self._print(expr.rhs))
1588 
1589     def _print_Piecewise(self, expr):
1590         ecpairs = [r"%s & \text{for}\: %s" % (self._print(e), self._print(c))
1591                    for e, c in expr.args[:-1]]
1592         if expr.args[-1].cond == true:
1593             ecpairs.append(r"%s & \text{otherwise}" %
1594                            self._print(expr.args[-1].expr))
1595         else:
1596             ecpairs.append(r"%s & \text{for}\: %s" %
1597                            (self._print(expr.args[-1].expr),
1598                             self._print(expr.args[-1].cond)))
1599         tex = r"\begin{cases} %s \end{cases}"
1600         return tex % r" \\".join(ecpairs)
1601 
1602     def _print_MatrixBase(self, expr):
1603         lines = []
1604 
1605         for line in range(expr.rows):  # horrible, should be 'rows'
1606             lines.append(" & ".join([self._print(i) for i in expr[line, :]]))
1607 
1608         mat_str = self._settings['mat_str']
1609         if mat_str is None:
1610             if self._settings['mode'] == 'inline':
1611                 mat_str = 'smallmatrix'
1612             else:
1613                 if (expr.cols <= 10) is True:
1614                     mat_str = 'matrix'
1615                 else:
1616                     mat_str = 'array'
1617 
1618         out_str = r'\begin{%MATSTR%}%s\end{%MATSTR%}'
1619         out_str = out_str.replace('%MATSTR%', mat_str)
1620         if mat_str == 'array':
1621             out_str = out_str.replace('%s', '{' + 'c'*expr.cols + '}%s')
1622         if self._settings['mat_delim']:
1623             left_delim = self._settings['mat_delim']
1624             right_delim = self._delim_dict[left_delim]
1625             out_str = r'\left' + left_delim + out_str + \
1626                       r'\right' + right_delim
1627         return out_str % r"\\".join(lines)
1628 
1629     def _print_MatrixElement(self, expr):
1630         return self.parenthesize(expr.parent, PRECEDENCE["Atom"], strict=True)\
1631             + '_{%s, %s}' % (self._print(expr.i), self._print(expr.j))
1632 
1633     def _print_MatrixSlice(self, expr):
1634         def latexslice(x, dim):
1635             x = list(x)
1636             if x[2] == 1:
1637                 del x[2]
1638             if x[0] == 0:
1639                 x[0] = None
1640             if x[1] == dim:
1641                 x[1] = None
1642             return ':'.join(self._print(xi) if xi is not None else '' for xi in x)
1643         return (self.parenthesize(expr.parent, PRECEDENCE["Atom"], strict=True) + r'\left[' +
1644                 latexslice(expr.rowslice, expr.parent.rows) + ', ' +
1645                 latexslice(expr.colslice, expr.parent.cols) + r'\right]')
1646 
1647     def _print_BlockMatrix(self, expr):
1648         return self._print(expr.blocks)
1649 
1650     def _print_Transpose(self, expr):
1651         mat = expr.arg
1652         from sympy.matrices import MatrixSymbol
1653         if not isinstance(mat, MatrixSymbol):
1654             return r"\left(%s\right)^{T}" % self._print(mat)
1655         else:
1656             return "%s^{T}" % self.parenthesize(mat, precedence_traditional(expr), True)
1657 
1658     def _print_Trace(self, expr):
1659         mat = expr.arg
1660         return r"\operatorname{tr}\left(%s \right)" % self._print(mat)
1661 
1662     def _print_Adjoint(self, expr):
1663         mat = expr.arg
1664         from sympy.matrices import MatrixSymbol
1665         if not isinstance(mat, MatrixSymbol):
1666             return r"\left(%s\right)^{\dagger}" % self._print(mat)
1667         else:
1668             return r"%s^{\dagger}" % self._print(mat)
1669 
1670     def _print_MatMul(self, expr):
1671         from sympy import MatMul, Mul
1672 
1673         parens = lambda x: self.parenthesize(x, precedence_traditional(expr),
1674                                              False)
1675 
1676         args = expr.args
1677         if isinstance(args[0], Mul):
1678             args = args[0].as_ordered_factors() + list(args[1:])
1679         else:
1680             args = list(args)
1681 
1682         if isinstance(expr, MatMul) and _coeff_isneg(expr):
1683             if args[0] == -1:
1684                 args = args[1:]
1685             else:
1686                 args[0] = -args[0]
1687             return '- ' + ' '.join(map(parens, args))
1688         else:
1689             return ' '.join(map(parens, args))
1690 
1691     def _print_Mod(self, expr, exp=None):
1692         if exp is not None:
1693             return r'\left(%s\bmod{%s}\right)^{%s}' % \
1694                 (self.parenthesize(expr.args[0], PRECEDENCE['Mul'],
1695                                    strict=True), self._print(expr.args[1]),
1696                  exp)
1697         return r'%s\bmod{%s}' % (self.parenthesize(expr.args[0],
1698                                  PRECEDENCE['Mul'], strict=True),
1699                                  self._print(expr.args[1]))
1700 
1701     def _print_HadamardProduct(self, expr):
1702         args = expr.args
1703         prec = PRECEDENCE['Pow']
1704         parens = self.parenthesize
1705 
1706         return r' \circ '.join(
1707             map(lambda arg: parens(arg, prec, strict=True), args))
1708 
1709     def _print_HadamardPower(self, expr):
1710         if precedence_traditional(expr.exp) < PRECEDENCE["Mul"]:
1711             template = r"%s^{\circ \left({%s}\right)}"
1712         else:
1713             template = r"%s^{\circ {%s}}"
1714         return self._helper_print_standard_power(expr, template)
1715 
1716     def _print_KroneckerProduct(self, expr):
1717         args = expr.args
1718         prec = PRECEDENCE['Pow']
1719         parens = self.parenthesize
1720 
1721         return r' \otimes '.join(
1722             map(lambda arg: parens(arg, prec, strict=True), args))
1723 
1724     def _print_MatPow(self, expr):
1725         base, exp = expr.base, expr.exp
1726         from sympy.matrices import MatrixSymbol
1727         if not isinstance(base, MatrixSymbol):
1728             return "\\left(%s\\right)^{%s}" % (self._print(base),
1729                                               self._print(exp))
1730         else:
1731             return "%s^{%s}" % (self._print(base), self._print(exp))
1732 
1733     def _print_MatrixSymbol(self, expr):
1734         return self._print_Symbol(expr, style=self._settings[
1735             'mat_symbol_style'])
1736 
1737     def _print_ZeroMatrix(self, Z):
1738         return r"\mathbb{0}" if self._settings[
1739             'mat_symbol_style'] == 'plain' else r"\mathbf{0}"
1740 
1741     def _print_OneMatrix(self, O):
1742         return r"\mathbb{1}" if self._settings[
1743             'mat_symbol_style'] == 'plain' else r"\mathbf{1}"
1744 
1745     def _print_Identity(self, I):
1746         return r"\mathbb{I}" if self._settings[
1747             'mat_symbol_style'] == 'plain' else r"\mathbf{I}"
1748 
1749     def _print_PermutationMatrix(self, P):
1750         perm_str = self._print(P.args[0])
1751         return "P_{%s}" % perm_str
1752 
1753     def _print_NDimArray(self, expr):
1754 
1755         if expr.rank() == 0:
1756             return self._print(expr[()])
1757 
1758         mat_str = self._settings['mat_str']
1759         if mat_str is None:
1760             if self._settings['mode'] == 'inline':
1761                 mat_str = 'smallmatrix'
1762             else:
1763                 if (expr.rank() == 0) or (expr.shape[-1] <= 10):
1764                     mat_str = 'matrix'
1765                 else:
1766                     mat_str = 'array'
1767         block_str = r'\begin{%MATSTR%}%s\end{%MATSTR%}'
1768         block_str = block_str.replace('%MATSTR%', mat_str)
1769         if self._settings['mat_delim']:
1770             left_delim = self._settings['mat_delim']
1771             right_delim = self._delim_dict[left_delim]
1772             block_str = r'\left' + left_delim + block_str + \
1773                         r'\right' + right_delim
1774 
1775         if expr.rank() == 0:
1776             return block_str % ""
1777 
1778         level_str = [[]] + [[] for i in range(expr.rank())]
1779         shape_ranges = [list(range(i)) for i in expr.shape]
1780         for outer_i in itertools.product(*shape_ranges):
1781             level_str[-1].append(self._print(expr[outer_i]))
1782             even = True
1783             for back_outer_i in range(expr.rank()-1, -1, -1):
1784                 if len(level_str[back_outer_i+1]) < expr.shape[back_outer_i]:
1785                     break
1786                 if even:
1787                     level_str[back_outer_i].append(
1788                         r" & ".join(level_str[back_outer_i+1]))
1789                 else:
1790                     level_str[back_outer_i].append(
1791                         block_str % (r"\\".join(level_str[back_outer_i+1])))
1792                     if len(level_str[back_outer_i+1]) == 1:
1793                         level_str[back_outer_i][-1] = r"\left[" + \
1794                             level_str[back_outer_i][-1] + r"\right]"
1795                 even = not even
1796                 level_str[back_outer_i+1] = []
1797 
1798         out_str = level_str[0][0]
1799 
1800         if expr.rank() % 2 == 1:
1801             out_str = block_str % out_str
1802 
1803         return out_str
1804 
1805     def _printer_tensor_indices(self, name, indices, index_map={}):
1806         out_str = self._print(name)
1807         last_valence = None
1808         prev_map = None
1809         for index in indices:
1810             new_valence = index.is_up
1811             if ((index in index_map) or prev_map) and \
1812                     last_valence == new_valence:
1813                 out_str += ","
1814             if last_valence != new_valence:
1815                 if last_valence is not None:
1816                     out_str += "}"
1817                 if index.is_up:
1818                     out_str += "{}^{"
1819                 else:
1820                     out_str += "{}_{"
1821             out_str += self._print(index.args[0])
1822             if index in index_map:
1823                 out_str += "="
1824                 out_str += self._print(index_map[index])
1825                 prev_map = True
1826             else:
1827                 prev_map = False
1828             last_valence = new_valence
1829         if last_valence is not None:
1830             out_str += "}"
1831         return out_str
1832 
1833     def _print_Tensor(self, expr):
1834         name = expr.args[0].args[0]
1835         indices = expr.get_indices()
1836         return self._printer_tensor_indices(name, indices)
1837 
1838     def _print_TensorElement(self, expr):
1839         name = expr.expr.args[0].args[0]
1840         indices = expr.expr.get_indices()
1841         index_map = expr.index_map
1842         return self._printer_tensor_indices(name, indices, index_map)
1843 
1844     def _print_TensMul(self, expr):
1845         # prints expressions like "A(a)", "3*A(a)", "(1+x)*A(a)"
1846         sign, args = expr._get_args_for_traditional_printer()
1847         return sign + "".join(
1848             [self.parenthesize(arg, precedence(expr)) for arg in args]
1849         )
1850 
1851     def _print_TensAdd(self, expr):
1852         a = []
1853         args = expr.args
1854         for x in args:
1855             a.append(self.parenthesize(x, precedence(expr)))
1856         a.sort()
1857         s = ' + '.join(a)
1858         s = s.replace('+ -', '- ')
1859         return s
1860 
1861     def _print_TensorIndex(self, expr):
1862         return "{}%s{%s}" % (
1863             "^" if expr.is_up else "_",
1864             self._print(expr.args[0])
1865         )
1866 
1867     def _print_PartialDerivative(self, expr):
1868         if len(expr.variables) == 1:
1869             return r"\frac{\partial}{\partial {%s}}{%s}" % (
1870                 self._print(expr.variables[0]),
1871                 self.parenthesize(expr.expr, PRECEDENCE["Mul"], False)
1872             )
1873         else:
1874             return r"\frac{\partial^{%s}}{%s}{%s}" % (
1875                 len(expr.variables),
1876                 " ".join([r"\partial {%s}" % self._print(i) for i in expr.variables]),
1877                 self.parenthesize(expr.expr, PRECEDENCE["Mul"], False)
1878             )
1879 
1880     def _print_UniversalSet(self, expr):
1881         return r"\mathbb{U}"
1882 
1883     def _print_frac(self, expr, exp=None):
1884         if exp is None:
1885             return r"\operatorname{frac}{\left(%s\right)}" % self._print(expr.args[0])
1886         else:
1887             return r"\operatorname{frac}{\left(%s\right)}^{%s}" % (
1888                     self._print(expr.args[0]), exp)
1889 
1890     def _print_tuple(self, expr):
1891         if self._settings['decimal_separator'] == 'comma':
1892             sep = ";"
1893         elif self._settings['decimal_separator'] == 'period':
1894             sep = ","
1895         else:
1896             raise ValueError('Unknown Decimal Separator')
1897 
1898         if len(expr) == 1:
1899             # 1-tuple needs a trailing separator
1900             return self._add_parens_lspace(self._print(expr[0]) + sep)
1901         else:
1902             return self._add_parens_lspace(
1903                 (sep + r" \  ").join([self._print(i) for i in expr]))
1904 
1905     def _print_TensorProduct(self, expr):
1906         elements = [self._print(a) for a in expr.args]
1907         return r' \otimes '.join(elements)
1908 
1909     def _print_WedgeProduct(self, expr):
1910         elements = [self._print(a) for a in expr.args]
1911         return r' \wedge '.join(elements)
1912 
1913     def _print_Tuple(self, expr):
1914         return self._print_tuple(expr)
1915 
1916     def _print_list(self, expr):
1917         if self._settings['decimal_separator'] == 'comma':
1918             return r"\left[ %s\right]" % \
1919                 r"; \  ".join([self._print(i) for i in expr])
1920         elif self._settings['decimal_separator'] == 'period':
1921             return r"\left[ %s\right]" % \
1922                 r", \  ".join([self._print(i) for i in expr])
1923         else:
1924             raise ValueError('Unknown Decimal Separator')
1925 
1926 
1927     def _print_dict(self, d):
1928         keys = sorted(d.keys(), key=default_sort_key)
1929         items = []
1930 
1931         for key in keys:
1932             val = d[key]
1933             items.append("%s : %s" % (self._print(key), self._print(val)))
1934 
1935         return r"\left\{ %s\right\}" % r", \  ".join(items)
1936 
1937     def _print_Dict(self, expr):
1938         return self._print_dict(expr)
1939 
1940     def _print_DiracDelta(self, expr, exp=None):
1941         if len(expr.args) == 1 or expr.args[1] == 0:
1942             tex = r"\delta\left(%s\right)" % self._print(expr.args[0])
1943         else:
1944             tex = r"\delta^{\left( %s \right)}\left( %s \right)" % (
1945                 self._print(expr.args[1]), self._print(expr.args[0]))
1946         if exp:
1947             tex = r"\left(%s\right)^{%s}" % (tex, exp)
1948         return tex
1949 
1950     def _print_SingularityFunction(self, expr):
1951         shift = self._print(expr.args[0] - expr.args[1])
1952         power = self._print(expr.args[2])
1953         tex = r"{\left\langle %s \right\rangle}^{%s}" % (shift, power)
1954         return tex
1955 
1956     def _print_Heaviside(self, expr, exp=None):
1957         tex = r"\theta\left(%s\right)" % self._print(expr.args[0])
1958         if exp:
1959             tex = r"\left(%s\right)^{%s}" % (tex, exp)
1960         return tex
1961 
1962     def _print_KroneckerDelta(self, expr, exp=None):
1963         i = self._print(expr.args[0])
1964         j = self._print(expr.args[1])
1965         if expr.args[0].is_Atom and expr.args[1].is_Atom:
1966             tex = r'\delta_{%s %s}' % (i, j)
1967         else:
1968             tex = r'\delta_{%s, %s}' % (i, j)
1969         if exp is not None:
1970             tex = r'\left(%s\right)^{%s}' % (tex, exp)
1971         return tex
1972 
1973     def _print_LeviCivita(self, expr, exp=None):
1974         indices = map(self._print, expr.args)
1975         if all(x.is_Atom for x in expr.args):
1976             tex = r'\varepsilon_{%s}' % " ".join(indices)
1977         else:
1978             tex = r'\varepsilon_{%s}' % ", ".join(indices)
1979         if exp:
1980             tex = r'\left(%s\right)^{%s}' % (tex, exp)
1981         return tex
1982 
1983     def _print_RandomDomain(self, d):
1984         if hasattr(d, 'as_boolean'):
1985             return '\\text{Domain: }' + self._print(d.as_boolean())
1986         elif hasattr(d, 'set'):
1987             return ('\\text{Domain: }' + self._print(d.symbols) + '\\text{ in }' +
1988                     self._print(d.set))
1989         elif hasattr(d, 'symbols'):
1990             return '\\text{Domain on }' + self._print(d.symbols)
1991         else:
1992             return self._print(None)
1993 
1994     def _print_FiniteSet(self, s):
1995         items = sorted(s.args, key=default_sort_key)
1996         return self._print_set(items)
1997 
1998     def _print_set(self, s):
1999         items = sorted(s, key=default_sort_key)
2000         if self._settings['decimal_separator'] == 'comma':
2001             items = "; ".join(map(self._print, items))
2002         elif self._settings['decimal_separator'] == 'period':
2003             items = ", ".join(map(self._print, items))
2004         else:
2005             raise ValueError('Unknown Decimal Separator')
2006         return r"\left\{%s\right\}" % items
2007 
2008 
2009     _print_frozenset = _print_set
2010 
2011     def _print_Range(self, s):
2012         dots = object()
2013 
2014         if s.has(Symbol):
2015             return self._print_Basic(s)
2016 
2017         if s.start.is_infinite and s.stop.is_infinite:
2018             if s.step.is_positive:
2019                 printset = dots, -1, 0, 1, dots
2020             else:
2021                 printset = dots, 1, 0, -1, dots
2022         elif s.start.is_infinite:
2023             printset = dots, s[-1] - s.step, s[-1]
2024         elif s.stop.is_infinite:
2025             it = iter(s)
2026             printset = next(it), next(it), dots
2027         elif len(s) > 4:
2028             it = iter(s)
2029             printset = next(it), next(it), dots, s[-1]
2030         else:
2031             printset = tuple(s)
2032 
2033         return (r"\left\{" +
2034                 r", ".join(self._print(el) if el is not dots else r'\ldots' for el in printset) +
2035                 r"\right\}")
2036 
2037     def __print_number_polynomial(self, expr, letter, exp=None):
2038         if len(expr.args) == 2:
2039             if exp is not None:
2040                 return r"%s_{%s}^{%s}\left(%s\right)" % (letter,
2041                             self._print(expr.args[0]), exp,
2042                             self._print(expr.args[1]))
2043             return r"%s_{%s}\left(%s\right)" % (letter,
2044                         self._print(expr.args[0]), self._print(expr.args[1]))
2045 
2046         tex = r"%s_{%s}" % (letter, self._print(expr.args[0]))
2047         if exp is not None:
2048             tex = r"%s^{%s}" % (tex, exp)
2049         return tex
2050 
2051     def _print_bernoulli(self, expr, exp=None):
2052         return self.__print_number_polynomial(expr, "B", exp)
2053 
2054     def _print_bell(self, expr, exp=None):
2055         if len(expr.args) == 3:
2056             tex1 = r"B_{%s, %s}" % (self._print(expr.args[0]),
2057                                 self._print(expr.args[1]))
2058             tex2 = r"\left(%s\right)" % r", ".join(self._print(el) for
2059                                                el in expr.args[2])
2060             if exp is not None:
2061                 tex = r"%s^{%s}%s" % (tex1, exp, tex2)
2062             else:
2063                 tex = tex1 + tex2
2064             return tex
2065         return self.__print_number_polynomial(expr, "B", exp)
2066 
2067 
2068     def _print_fibonacci(self, expr, exp=None):
2069         return self.__print_number_polynomial(expr, "F", exp)
2070 
2071     def _print_lucas(self, expr, exp=None):
2072         tex = r"L_{%s}" % self._print(expr.args[0])
2073         if exp is not None:
2074             tex = r"%s^{%s}" % (tex, exp)
2075         return tex
2076 
2077     def _print_tribonacci(self, expr, exp=None):
2078         return self.__print_number_polynomial(expr, "T", exp)
2079 
2080     def _print_SeqFormula(self, s):
2081         dots = object()
2082         if len(s.start.free_symbols) > 0 or len(s.stop.free_symbols) > 0:
2083             return r"\left\{%s\right\}_{%s=%s}^{%s}" % (
2084                 self._print(s.formula),
2085                 self._print(s.variables[0]),
2086                 self._print(s.start),
2087                 self._print(s.stop)
2088             )
2089         if s.start is S.NegativeInfinity:
2090             stop = s.stop
2091             printset = (dots, s.coeff(stop - 3), s.coeff(stop - 2),
2092                         s.coeff(stop - 1), s.coeff(stop))
2093         elif s.stop is S.Infinity or s.length > 4:
2094             printset = s[:4]
2095             printset.append(dots)
2096         else:
2097             printset = tuple(s)
2098 
2099         return (r"\left[" +
2100                 r", ".join(self._print(el) if el is not dots else r'\ldots' for el in printset) +
2101                 r"\right]")
2102 
2103     _print_SeqPer = _print_SeqFormula
2104     _print_SeqAdd = _print_SeqFormula
2105     _print_SeqMul = _print_SeqFormula
2106 
2107     def _print_Interval(self, i):
2108         if i.start == i.end:
2109             return r"\left\{%s\right\}" % self._print(i.start)
2110 
2111         else:
2112             if i.left_open:
2113                 left = '('
2114             else:
2115                 left = '['
2116 
2117             if i.right_open:
2118                 right = ')'
2119             else:
2120                 right = ']'
2121 
2122             return r"\left%s%s, %s\right%s" % \
2123                    (left, self._print(i.start), self._print(i.end), right)
2124 
2125     def _print_AccumulationBounds(self, i):
2126         return r"\left\langle %s, %s\right\rangle" % \
2127                 (self._print(i.min), self._print(i.max))
2128 
2129     def _print_Union(self, u):
2130         prec = precedence_traditional(u)
2131         args_str = [self.parenthesize(i, prec) for i in u.args]
2132         return r" \cup ".join(args_str)
2133 
2134     def _print_Complement(self, u):
2135         prec = precedence_traditional(u)
2136         args_str = [self.parenthesize(i, prec) for i in u.args]
2137         return r" \setminus ".join(args_str)
2138 
2139     def _print_Intersection(self, u):
2140         prec = precedence_traditional(u)
2141         args_str = [self.parenthesize(i, prec) for i in u.args]
2142         return r" \cap ".join(args_str)
2143 
2144     def _print_SymmetricDifference(self, u):
2145         prec = precedence_traditional(u)
2146         args_str = [self.parenthesize(i, prec) for i in u.args]
2147         return r" \triangle ".join(args_str)
2148 
2149     def _print_ProductSet(self, p):
2150         prec = precedence_traditional(p)
2151         if len(p.sets) >= 1 and not has_variety(p.sets):
2152             return self.parenthesize(p.sets[0], prec) + "^{%d}" % len(p.sets)
2153         return r" \times ".join(
2154             self.parenthesize(set, prec) for set in p.sets)
2155 
2156     def _print_EmptySet(self, e):
2157         return r"\emptyset"
2158 
2159     def _print_Naturals(self, n):
2160         return r"\mathbb{N}"
2161 
2162     def _print_Naturals0(self, n):
2163         return r"\mathbb{N}_0"
2164 
2165     def _print_Integers(self, i):
2166         return r"\mathbb{Z}"
2167 
2168     def _print_Rationals(self, i):
2169         return r"\mathbb{Q}"
2170 
2171     def _print_Reals(self, i):
2172         return r"\mathbb{R}"
2173 
2174     def _print_Complexes(self, i):
2175         return r"\mathbb{C}"
2176 
2177     def _print_ImageSet(self, s):
2178         expr = s.lamda.expr
2179         sig = s.lamda.signature
2180         xys = ((self._print(x), self._print(y)) for x, y in zip(sig, s.base_sets))
2181         xinys = r" , ".join(r"%s \in %s" % xy for xy in xys)
2182         return r"\left\{%s\; |\; %s\right\}" % (self._print(expr), xinys)
2183 
2184     def _print_ConditionSet(self, s):
2185         vars_print = ', '.join([self._print(var) for var in Tuple(s.sym)])
2186         if s.base_set is S.UniversalSet:
2187             return r"\left\{%s \mid %s \right\}" % \
2188                 (vars_print, self._print(s.condition))
2189 
2190         return r"\left\{%s \mid %s \in %s \wedge %s \right\}" % (
2191             vars_print,
2192             vars_print,
2193             self._print(s.base_set),
2194             self._print(s.condition))
2195 
2196     def _print_ComplexRegion(self, s):
2197         vars_print = ', '.join([self._print(var) for var in s.variables])
2198         return r"\left\{%s\; |\; %s \in %s \right\}" % (
2199             self._print(s.expr),
2200             vars_print,
2201             self._print(s.sets))
2202 
2203     def _print_Contains(self, e):
2204         return r"%s \in %s" % tuple(self._print(a) for a in e.args)
2205 
2206     def _print_FourierSeries(self, s):
2207         return self._print_Add(s.truncate()) + r' + \ldots'
2208 
2209     def _print_FormalPowerSeries(self, s):
2210         return self._print_Add(s.infinite)
2211 
2212     def _print_FiniteField(self, expr):
2213         return r"\mathbb{F}_{%s}" % expr.mod
2214 
2215     def _print_IntegerRing(self, expr):
2216         return r"\mathbb{Z}"
2217 
2218     def _print_RationalField(self, expr):
2219         return r"\mathbb{Q}"
2220 
2221     def _print_RealField(self, expr):
2222         return r"\mathbb{R}"
2223 
2224     def _print_ComplexField(self, expr):
2225         return r"\mathbb{C}"
2226 
2227     def _print_PolynomialRing(self, expr):
2228         domain = self._print(expr.domain)
2229         symbols = ", ".join(map(self._print, expr.symbols))
2230         return r"%s\left[%s\right]" % (domain, symbols)
2231 
2232     def _print_FractionField(self, expr):
2233         domain = self._print(expr.domain)
2234         symbols = ", ".join(map(self._print, expr.symbols))
2235         return r"%s\left(%s\right)" % (domain, symbols)
2236 
2237     def _print_PolynomialRingBase(self, expr):
2238         domain = self._print(expr.domain)
2239         symbols = ", ".join(map(self._print, expr.symbols))
2240         inv = ""
2241         if not expr.is_Poly:
2242             inv = r"S_<^{-1}"
2243         return r"%s%s\left[%s\right]" % (inv, domain, symbols)
2244 
2245     def _print_Poly(self, poly):
2246         cls = poly.__class__.__name__
2247         terms = []
2248         for monom, coeff in poly.terms():
2249             s_monom = ''
2250             for i, exp in enumerate(monom):
2251                 if exp > 0:
2252                     if exp == 1:
2253                         s_monom += self._print(poly.gens[i])
2254                     else:
2255                         s_monom += self._print(pow(poly.gens[i], exp))
2256 
2257             if coeff.is_Add:
2258                 if s_monom:
2259                     s_coeff = r"\left(%s\right)" % self._print(coeff)
2260                 else:
2261                     s_coeff = self._print(coeff)
2262             else:
2263                 if s_monom:
2264                     if coeff is S.One:
2265                         terms.extend(['+', s_monom])
2266                         continue
2267 
2268                     if coeff is S.NegativeOne:
2269                         terms.extend(['-', s_monom])
2270                         continue
2271 
2272                 s_coeff = self._print(coeff)
2273 
2274             if not s_monom:
2275                 s_term = s_coeff
2276             else:
2277                 s_term = s_coeff + " " + s_monom
2278 
2279             if s_term.startswith('-'):
2280                 terms.extend(['-', s_term[1:]])
2281             else:
2282                 terms.extend(['+', s_term])
2283 
2284         if terms[0] in ['-', '+']:
2285             modifier = terms.pop(0)
2286 
2287             if modifier == '-':
2288                 terms[0] = '-' + terms[0]
2289 
2290         expr = ' '.join(terms)
2291         gens = list(map(self._print, poly.gens))
2292         domain = "domain=%s" % self._print(poly.get_domain())
2293 
2294         args = ", ".join([expr] + gens + [domain])
2295         if cls in accepted_latex_functions:
2296             tex = r"\%s {\left(%s \right)}" % (cls, args)
2297         else:
2298             tex = r"\operatorname{%s}{\left( %s \right)}" % (cls, args)
2299 
2300         return tex
2301 
2302     def _print_ComplexRootOf(self, root):
2303         cls = root.__class__.__name__
2304         if cls == "ComplexRootOf":
2305             cls = "CRootOf"
2306         expr = self._print(root.expr)
2307         index = root.index
2308         if cls in accepted_latex_functions:
2309             return r"\%s {\left(%s, %d\right)}" % (cls, expr, index)
2310         else:
2311             return r"\operatorname{%s} {\left(%s, %d\right)}" % (cls, expr,
2312                                                                  index)
2313 
2314     def _print_RootSum(self, expr):
2315         cls = expr.__class__.__name__
2316         args = [self._print(expr.expr)]
2317 
2318         if expr.fun is not S.IdentityFunction:
2319             args.append(self._print(expr.fun))
2320 
2321         if cls in accepted_latex_functions:
2322             return r"\%s {\left(%s\right)}" % (cls, ", ".join(args))
2323         else:
2324             return r"\operatorname{%s} {\left(%s\right)}" % (cls,
2325                                                              ", ".join(args))
2326 
2327     def _print_PolyElement(self, poly):
2328         mul_symbol = self._settings['mul_symbol_latex']
2329         return poly.str(self, PRECEDENCE, "{%s}^{%d}", mul_symbol)
2330 
2331     def _print_FracElement(self, frac):
2332         if frac.denom == 1:
2333             return self._print(frac.numer)
2334         else:
2335             numer = self._print(frac.numer)
2336             denom = self._print(frac.denom)
2337             return r"\frac{%s}{%s}" % (numer, denom)
2338 
2339     def _print_euler(self, expr, exp=None):
2340         m, x = (expr.args[0], None) if len(expr.args) == 1 else expr.args
2341         tex = r"E_{%s}" % self._print(m)
2342         if exp is not None:
2343             tex = r"%s^{%s}" % (tex, exp)
2344         if x is not None:
2345             tex = r"%s\left(%s\right)" % (tex, self._print(x))
2346         return tex
2347 
2348     def _print_catalan(self, expr, exp=None):
2349         tex = r"C_{%s}" % self._print(expr.args[0])
2350         if exp is not None:
2351             tex = r"%s^{%s}" % (tex, exp)
2352         return tex
2353 
2354     def _print_UnifiedTransform(self, expr, s, inverse=False):
2355         return r"\mathcal{{{}}}{}_{{{}}}\left[{}\right]\left({}\right)".format(s, '^{-1}' if inverse else '', self._print(expr.args[1]), self._print(expr.args[0]), self._print(expr.args[2]))
2356 
2357     def _print_MellinTransform(self, expr):
2358         return self._print_UnifiedTransform(expr, 'M')
2359 
2360     def _print_InverseMellinTransform(self, expr):
2361         return self._print_UnifiedTransform(expr, 'M', True)
2362 
2363     def _print_LaplaceTransform(self, expr):
2364         return self._print_UnifiedTransform(expr, 'L')
2365 
2366     def _print_InverseLaplaceTransform(self, expr):
2367         return self._print_UnifiedTransform(expr, 'L', True)
2368 
2369     def _print_FourierTransform(self, expr):
2370         return self._print_UnifiedTransform(expr, 'F')
2371 
2372     def _print_InverseFourierTransform(self, expr):
2373         return self._print_UnifiedTransform(expr, 'F', True)
2374 
2375     def _print_SineTransform(self, expr):
2376         return self._print_UnifiedTransform(expr, 'SIN')
2377 
2378     def _print_InverseSineTransform(self, expr):
2379         return self._print_UnifiedTransform(expr, 'SIN', True)
2380 
2381     def _print_CosineTransform(self, expr):
2382         return self._print_UnifiedTransform(expr, 'COS')
2383 
2384     def _print_InverseCosineTransform(self, expr):
2385         return self._print_UnifiedTransform(expr, 'COS', True)
2386 
2387     def _print_DMP(self, p):
2388         try:
2389             if p.ring is not None:
2390                 # TODO incorporate order
2391                 return self._print(p.ring.to_sympy(p))
2392         except SympifyError:
2393             pass
2394         return self._print(repr(p))
2395 
2396     def _print_DMF(self, p):
2397         return self._print_DMP(p)
2398 
2399     def _print_Object(self, object):
2400         return self._print(Symbol(object.name))
2401 
2402     def _print_LambertW(self, expr):
2403         if len(expr.args) == 1:
2404             return r"W\left(%s\right)" % self._print(expr.args[0])
2405         return r"W_{%s}\left(%s\right)" % \
2406             (self._print(expr.args[1]), self._print(expr.args[0]))
2407 
2408     def _print_Morphism(self, morphism):
2409         domain = self._print(morphism.domain)
2410         codomain = self._print(morphism.codomain)
2411         return "%s\\rightarrow %s" % (domain, codomain)
2412 
2413     def _print_TransferFunction(self, expr):
2414         from sympy.core import Mul, Pow
2415         num, den = expr.num, expr.den
2416         res = Mul(num, Pow(den, -1, evaluate=False), evaluate=False)
2417         return self._print_Mul(res)
2418 
2419     def _print_Series(self, expr):
2420         args = list(expr.args)
2421         parens = lambda x: self.parenthesize(x, precedence_traditional(expr),
2422                                              False)
2423         return ' '.join(map(parens, args))
2424 
2425     def _print_Parallel(self, expr):
2426         args = list(expr.args)
2427         parens = lambda x: self.parenthesize(x, precedence_traditional(expr),
2428                                              False)
2429         return ' '.join(map(parens, args))
2430 
2431     def _print_Feedback(self, expr):
2432         from sympy.physics.control import TransferFunction, Parallel, Series
2433 
2434         num, tf = expr.num, TransferFunction(1, 1, expr.num.var)
2435         num_arg_list = list(num.args) if isinstance(num, Series) else [num]
2436         den_arg_list = list(expr.den.args) if isinstance(expr.den, Series) else [expr.den]
2437 
2438         if isinstance(num, Series) and isinstance(expr.den, Series):
2439             den = Parallel(tf, Series(*num_arg_list, *den_arg_list))
2440         elif isinstance(num, Series) and isinstance(expr.den, TransferFunction):
2441             if expr.den == tf:
2442                 den = Parallel(tf, Series(*num_arg_list))
2443             else:
2444                 den = Parallel(tf, Series(*num_arg_list, expr.den))
2445         elif isinstance(num, TransferFunction) and isinstance(expr.den, Series):
2446             if num == tf:
2447                 den = Parallel(tf, Series(*den_arg_list))
2448             else:
2449                 den = Parallel(tf, Series(num, *den_arg_list))
2450         else:
2451             if num == tf:
2452                 den = Parallel(tf, *den_arg_list)
2453             elif expr.den == tf:
2454                 den = Parallel(tf, *num_arg_list)
2455             else:
2456                 den = Parallel(tf, Series(*num_arg_list, *den_arg_list))
2457 
2458         numer = self._print(num)
2459         denom = self._print(den)
2460         return r"\frac{%s}{%s}" % (numer, denom)
2461 
2462     def _print_NamedMorphism(self, morphism):
2463         pretty_name = self._print(Symbol(morphism.name))
2464         pretty_morphism = self._print_Morphism(morphism)
2465         return "%s:%s" % (pretty_name, pretty_morphism)
2466 
2467     def _print_IdentityMorphism(self, morphism):
2468         from sympy.categories import NamedMorphism
2469         return self._print_NamedMorphism(NamedMorphism(
2470             morphism.domain, morphism.codomain, "id"))
2471 
2472     def _print_CompositeMorphism(self, morphism):
2473         # All components of the morphism have names and it is thus
2474         # possible to build the name of the composite.
2475         component_names_list = [self._print(Symbol(component.name)) for
2476                                 component in morphism.components]
2477         component_names_list.reverse()
2478         component_names = "\\circ ".join(component_names_list) + ":"
2479 
2480         pretty_morphism = self._print_Morphism(morphism)
2481         return component_names + pretty_morphism
2482 
2483     def _print_Category(self, morphism):
2484         return r"\mathbf{{{}}}".format(self._print(Symbol(morphism.name)))
2485 
2486     def _print_Diagram(self, diagram):
2487         if not diagram.premises:
2488             # This is an empty diagram.
2489             return self._print(S.EmptySet)
2490 
2491         latex_result = self._print(diagram.premises)
2492         if diagram.conclusions:
2493             latex_result += "\\Longrightarrow %s" % \
2494                             self._print(diagram.conclusions)
2495 
2496         return latex_result
2497 
2498     def _print_DiagramGrid(self, grid):
2499         latex_result = "\\begin{array}{%s}\n" % ("c" * grid.width)
2500 
2501         for i in range(grid.height):
2502             for j in range(grid.width):
2503                 if grid[i, j]:
2504                     latex_result += latex(grid[i, j])
2505                 latex_result += " "
2506                 if j != grid.width - 1:
2507                     latex_result += "& "
2508 
2509             if i != grid.height - 1:
2510                 latex_result += "\\\\"
2511             latex_result += "\n"
2512 
2513         latex_result += "\\end{array}\n"
2514         return latex_result
2515 
2516     def _print_FreeModule(self, M):
2517         return '{{{}}}^{{{}}}'.format(self._print(M.ring), self._print(M.rank))
2518 
2519     def _print_FreeModuleElement(self, m):
2520         # Print as row vector for convenience, for now.
2521         return r"\left[ {} \right]".format(",".join(
2522             '{' + self._print(x) + '}' for x in m))
2523 
2524     def _print_SubModule(self, m):
2525         return r"\left\langle {} \right\rangle".format(",".join(
2526             '{' + self._print(x) + '}' for x in m.gens))
2527 
2528     def _print_ModuleImplementedIdeal(self, m):
2529         return r"\left\langle {} \right\rangle".format(",".join(
2530             '{' + self._print(x) + '}' for [x] in m._module.gens))
2531 
2532     def _print_Quaternion(self, expr):
2533         # TODO: This expression is potentially confusing,
2534         # shall we print it as `Quaternion( ... )`?
2535         s = [self.parenthesize(i, PRECEDENCE["Mul"], strict=True)
2536              for i in expr.args]
2537         a = [s[0]] + [i+" "+j for i, j in zip(s[1:], "ijk")]
2538         return " + ".join(a)
2539 
2540     def _print_QuotientRing(self, R):
2541         # TODO nicer fractions for few generators...
2542         return r"\frac{{{}}}{{{}}}".format(self._print(R.ring),
2543                  self._print(R.base_ideal))
2544 
2545     def _print_QuotientRingElement(self, x):
2546         return r"{{{}}} + {{{}}}".format(self._print(x.data),
2547                  self._print(x.ring.base_ideal))
2548 
2549     def _print_QuotientModuleElement(self, m):
2550         return r"{{{}}} + {{{}}}".format(self._print(m.data),
2551                  self._print(m.module.killed_module))
2552 
2553     def _print_QuotientModule(self, M):
2554         # TODO nicer fractions for few generators...
2555         return r"\frac{{{}}}{{{}}}".format(self._print(M.base),
2556                  self._print(M.killed_module))
2557 
2558     def _print_MatrixHomomorphism(self, h):
2559         return r"{{{}}} : {{{}}} \to {{{}}}".format(self._print(h._sympy_matrix()),
2560             self._print(h.domain), self._print(h.codomain))
2561 
2562     def _print_Manifold(self, manifold):
2563         string = manifold.name.name
2564         if '{' in string:
2565             name, supers, subs = string, [], []
2566         else:
2567             name, supers, subs = split_super_sub(string)
2568 
2569             name = translate(name)
2570             supers = [translate(sup) for sup in supers]
2571             subs = [translate(sub) for sub in subs]
2572 
2573         name = r'\text{%s}' % name
2574         if supers:
2575             name += "^{%s}" % " ".join(supers)
2576         if subs:
2577             name += "_{%s}" % " ".join(subs)
2578 
2579         return name
2580 
2581     def _print_Patch(self, patch):
2582         return r'\text{%s}_{%s}' % (self._print(patch.name), self._print(patch.manifold))
2583 
2584     def _print_CoordSystem(self, coordsys):
2585         return r'\text{%s}^{\text{%s}}_{%s}' % (
2586             self._print(coordsys.name), self._print(coordsys.patch.name), self._print(coordsys.manifold)
2587         )
2588 
2589     def _print_CovarDerivativeOp(self, cvd):
2590         return r'\mathbb{\nabla}_{%s}' % self._print(cvd._wrt)
2591 
2592     def _print_BaseScalarField(self, field):
2593         string = field._coord_sys.symbols[field._index].name
2594         return r'\mathbf{{{}}}'.format(self._print(Symbol(string)))
2595 
2596     def _print_BaseVectorField(self, field):
2597         string = field._coord_sys.symbols[field._index].name
2598         return r'\partial_{{{}}}'.format(self._print(Symbol(string)))
2599 
2600     def _print_Differential(self, diff):
2601         field = diff._form_field
2602         if hasattr(field, '_coord_sys'):
2603             string = field._coord_sys.symbols[field._index].name
2604             return r'\operatorname{{d}}{}'.format(self._print(Symbol(string)))
2605         else:
2606             string = self._print(field)
2607             return r'\operatorname{{d}}\left({}\right)'.format(string)
2608 
2609     def _print_Tr(self, p):
2610         # TODO: Handle indices
2611         contents = self._print(p.args[0])
2612         return r'\operatorname{{tr}}\left({}\right)'.format(contents)
2613 
2614     def _print_totient(self, expr, exp=None):
2615         if exp is not None:
2616             return r'\left(\phi\left(%s\right)\right)^{%s}' % \
2617                 (self._print(expr.args[0]), exp)
2618         return r'\phi\left(%s\right)' % self._print(expr.args[0])
2619 
2620     def _print_reduced_totient(self, expr, exp=None):
2621         if exp is not None:
2622             return r'\left(\lambda\left(%s\right)\right)^{%s}' % \
2623                 (self._print(expr.args[0]), exp)
2624         return r'\lambda\left(%s\right)' % self._print(expr.args[0])
2625 
2626     def _print_divisor_sigma(self, expr, exp=None):
2627         if len(expr.args) == 2:
2628             tex = r"_%s\left(%s\right)" % tuple(map(self._print,
2629                                                 (expr.args[1], expr.args[0])))
2630         else:
2631             tex = r"\left(%s\right)" % self._print(expr.args[0])
2632         if exp is not None:
2633             return r"\sigma^{%s}%s" % (exp, tex)
2634         return r"\sigma%s" % tex
2635 
2636     def _print_udivisor_sigma(self, expr, exp=None):
2637         if len(expr.args) == 2:
2638             tex = r"_%s\left(%s\right)" % tuple(map(self._print,
2639                                                 (expr.args[1], expr.args[0])))
2640         else:
2641             tex = r"\left(%s\right)" % self._print(expr.args[0])
2642         if exp is not None:
2643             return r"\sigma^*^{%s}%s" % (exp, tex)
2644         return r"\sigma^*%s" % tex
2645 
2646     def _print_primenu(self, expr, exp=None):
2647         if exp is not None:
2648             return r'\left(\nu\left(%s\right)\right)^{%s}' % \
2649                 (self._print(expr.args[0]), exp)
2650         return r'\nu\left(%s\right)' % self._print(expr.args[0])
2651 
2652     def _print_primeomega(self, expr, exp=None):
2653         if exp is not None:
2654             return r'\left(\Omega\left(%s\right)\right)^{%s}' % \
2655                 (self._print(expr.args[0]), exp)
2656         return r'\Omega\left(%s\right)' % self._print(expr.args[0])
2657 
2658     def _print_Str(self, s):
2659         return str(s.name)
2660 
2661     def _print_float(self, expr):
2662         return self._print(Float(expr))
2663 
2664     def _print_int(self, expr):
2665         return str(expr)
2666 
2667     def _print_mpz(self, expr):
2668         return str(expr)
2669 
2670     def _print_mpq(self, expr):
2671         return str(expr)
2672 
2673     def emptyPrinter(self, expr):
2674         # default to just printing as monospace, like would normally be shown
2675         s = super().emptyPrinter(expr)
2676 
2677         return r"\mathtt{\text{%s}}" % latex_escape(s)

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>]
2025-10-18 20:42:48.940 | INFO     | Search completed. Bug locations: [<file>sympy/printing/latex.py</file>
<class>LatexPrinter</class>
<method>_print_Pow</method>
<code>
613     def _print_Pow(self, expr):
614         # Treat x**Rational(1,n) as special case
615         if expr.exp.is_Rational and abs(expr.exp.p) == 1 and expr.exp.q != 1 \
616                 and self._settings['root_notation']:
617             base = self._print(expr.base)
618             expq = expr.exp.q
619 
620             if expq == 2:
621                 tex = r"\sqrt{%s}" % base
622             elif self._settings['itex']:
623                 tex = r"\root{%d}{%s}" % (expq, base)
624             else:
625                 tex = r"\sqrt[%d]{%s}" % (expq, base)
626 
627             if expr.exp.is_negative:
628                 return r"\frac{1}{%s}" % tex
629             else:
630                 return tex
631         elif self._settings['fold_frac_powers'] \
632             and expr.exp.is_Rational \
633                 and expr.exp.q != 1:
634             base = self.parenthesize(expr.base, PRECEDENCE['Pow'])
635             p, q = expr.exp.p, expr.exp.q
636             # issue #12886: add parentheses for superscripts raised to powers
637             if expr.base.is_Symbol:
638                 base = self.parenthesize_super(base)
639             if expr.base.is_Function:
640                 return self._print(expr.base, exp="%s/%s" % (p, q))
641             return r"%s^{%s/%s}" % (base, p, q)
642         elif expr.exp.is_Rational and expr.exp.is_negative and \
643                 expr.base.is_commutative:
644             # special case for 1^(-x), issue 9216
645             if expr.base == 1:
646                 return r"%s^{%s}" % (expr.base, expr.exp)
647             # things like 1/x
648             return self._print_Mul(expr)
649         else:
650             if expr.base.is_Function:
651                 return self._print(expr.base, exp=self._print(expr.exp))
652             else:
653                 tex = r"%s^{%s}"
654                 return self._helper_print_standard_power(expr, tex)

</code><intended_behavior>The `_print_Pow` method should incorporate a condition or modification to correctly handle expressions in the form of `Pow(Rational(1, n), -1, evaluate=False)` for `n` as a positive integer (or its equivalent for negative integers but with n < -1). When encountering such expressions, rather than possibly falling into a recursive conversion process, it should directly convert them into a simple LaTeX fraction format, `\frac{n}{1}` or its appropriate form based on the sign and magnitude of `n`. This adjustment should be made in a way that respects the evaluate flag being False, ensuring no unintended simplification occurs in non-target cases.</intended_behavior>, <file>sympy/printing/latex.py</file>
<class>LatexPrinter</class>
<method>None</method>
<code>
137 class LatexPrinter(Printer):
138     printmethod = "_latex"
139 
140     _default_settings = {
141         "full_prec": False,
142         "fold_frac_powers": False,
143         "fold_func_brackets": False,
144         "fold_short_frac": None,
145         "inv_trig_style": "abbreviated",
146         "itex": False,
147         "ln_notation": False,
148         "long_frac_ratio": None,
149         "mat_delim": "[",
150         "mat_str": None,
151         "mode": "plain",
152         "mul_symbol": None,
153         "order": None,
154         "symbol_names": {},
155         "root_notation": True,
156         "mat_symbol_style": "plain",
157         "imaginary_unit": "i",
158         "gothic_re_im": False,
159         "decimal_separator": "period",
160         "perm_cyclic": True,
161         "parenthesize_super": True,
162         "min": None,
163         "max": None,
164     }  # type: Dict[str, Any]
165 
166     def __init__(self, settings=None):
167         Printer.__init__(self, settings)
168 
169         if 'mode' in self._settings:
170             valid_modes = ['inline', 'plain', 'equation',
171                            'equation*']
172             if self._settings['mode'] not in valid_modes:
173                 raise ValueError("'mode' must be one of 'inline', 'plain', "
174                                  "'equation' or 'equation*'")
175 
176         if self._settings['fold_short_frac'] is None and \
177                 self._settings['mode'] == 'inline':
178             self._settings['fold_short_frac'] = True
179 
180         mul_symbol_table = {
181             None: r" ",
182             "ldot": r" \,.\, ",
183             "dot": r" \cdot ",
184             "times": r" \times "
185         }
186         try:
187             self._settings['mul_symbol_latex'] = \
188                 mul_symbol_table[self._settings['mul_symbol']]
189         except KeyError:
190             self._settings['mul_symbol_latex'] = \
191                 self._settings['mul_symbol']
192         try:
193             self._settings['mul_symbol_latex_numbers'] = \
194                 mul_symbol_table[self._settings['mul_symbol'] or 'dot']
195         except KeyError:
196             if (self._settings['mul_symbol'].strip() in
197                     ['', ' ', '\\', '\\,', '\\:', '\\;', '\\quad']):
198                 self._settings['mul_symbol_latex_numbers'] = \
199                     mul_symbol_table['dot']
200             else:
201                 self._settings['mul_symbol_latex_numbers'] = \
202                     self._settings['mul_symbol']
203 
204         self._delim_dict = {'(': ')', '[': ']'}
205 
206         imaginary_unit_table = {
207             None: r"i",
208             "i": r"i",
209             "ri": r"\mathrm{i}",
210             "ti": r"\text{i}",
211             "j": r"j",
212             "rj": r"\mathrm{j}",
213             "tj": r"\text{j}",
214         }
215         try:
216             self._settings['imaginary_unit_latex'] = \
217                 imaginary_unit_table[self._settings['imaginary_unit']]
218         except KeyError:
219             self._settings['imaginary_unit_latex'] = \
220                 self._settings['imaginary_unit']
221 
222     def _add_parens(self, s):
223         return r"\left({}\right)".format(s)
224 
225     # TODO: merge this with the above, which requires a lot of test changes
226     def _add_parens_lspace(self, s):
227         return r"\left( {}\right)".format(s)
228 
229     def parenthesize(self, item, level, is_neg=False, strict=False):
230         prec_val = precedence_traditional(item)
231         if is_neg and strict:
232             return self._add_parens(self._print(item))
233 
234         if (prec_val < level) or ((not strict) and prec_val <= level):
235             return self._add_parens(self._print(item))
236         else:
237             return self._print(item)
238 
239     def parenthesize_super(self, s):
240         """
241         Protect superscripts in s
242 
243         If the parenthesize_super option is set, protect with parentheses, else
244         wrap in braces.
245         """
246         if "^" in s:
247             if self._settings['parenthesize_super']:
248                 return self._add_parens(s)
249             else:
250                 return "{{{}}}".format(s)
251         return s
252 
253     def doprint(self, expr):
254         tex = Printer.doprint(self, expr)
255 
256         if self._settings['mode'] == 'plain':
257             return tex
258         elif self._settings['mode'] == 'inline':
259             return r"$%s$" % tex
260         elif self._settings['itex']:
261             return r"$$%s$$" % tex
262         else:
263             env_str = self._settings['mode']
264             return r"\begin{%s}%s\end{%s}" % (env_str, tex, env_str)
265 
266     def _needs_brackets(self, expr):
267         """
268         Returns True if the expression needs to be wrapped in brackets when
269         printed, False otherwise. For example: a + b => True; a => False;
270         10 => False; -10 => True.
271         """
272         return not ((expr.is_Integer and expr.is_nonnegative)
273                     or (expr.is_Atom and (expr is not S.NegativeOne
274                                           and expr.is_Rational is False)))
275 
276     def _needs_function_brackets(self, expr):
277         """
278         Returns True if the expression needs to be wrapped in brackets when
279         passed as an argument to a function, False otherwise. This is a more
280         liberal version of _needs_brackets, in that many expressions which need
281         to be wrapped in brackets when added/subtracted/raised to a power do
282         not need them when passed to a function. Such an example is a*b.
283         """
284         if not self._needs_brackets(expr):
285             return False
286         else:
287             # Muls of the form a*b*c... can be folded
288             if expr.is_Mul and not self._mul_is_clean(expr):
289                 return True
290             # Pows which don't need brackets can be folded
291             elif expr.is_Pow and not self._pow_is_clean(expr):
292                 return True
293             # Add and Function always need brackets
294             elif expr.is_Add or expr.is_Function:
295                 return True
296             else:
297                 return False
298 
299     def _needs_mul_brackets(self, expr, first=False, last=False):
300         """
301         Returns True if the expression needs to be wrapped in brackets when
302         printed as part of a Mul, False otherwise. This is True for Add,
303         but also for some container objects that would not need brackets
304         when appearing last in a Mul, e.g. an Integral. ``last=True``
305         specifies that this expr is the last to appear in a Mul.
306         ``first=True`` specifies that this expr is the first to appear in
307         a Mul.
308         """
309         from sympy import Integral, Product, Sum
310 
311         if expr.is_Mul:
312             if not first and _coeff_isneg(expr):
313                 return True
314         elif precedence_traditional(expr) < PRECEDENCE["Mul"]:
315             return True
316         elif expr.is_Relational:
317             return True
318         if expr.is_Piecewise:
319             return True
320         if any([expr.has(x) for x in (Mod,)]):
321             return True
322         if (not last and
323                 any([expr.has(x) for x in (Integral, Product, Sum)])):
324             return True
325 
326         return False
327 
328     def _needs_add_brackets(self, expr):
329         """
330         Returns True if the expression needs to be wrapped in brackets when
331         printed as part of an Add, False otherwise.  This is False for most
332         things.
333         """
334         if expr.is_Relational:
335             return True
336         if any([expr.has(x) for x in (Mod,)]):
337             return True
338         if expr.is_Add:
339             return True
340         return False
341 
342     def _mul_is_clean(self, expr):
343         for arg in expr.args:
344             if arg.is_Function:
345                 return False
346         return True
347 
348     def _pow_is_clean(self, expr):
349         return not self._needs_brackets(expr.base)
350 
351     def _do_exponent(self, expr, exp):
352         if exp is not None:
353             return r"\left(%s\right)^{%s}" % (expr, exp)
354         else:
355             return expr
356 
357     def _print_Basic(self, expr):
358         ls = [self._print(o) for o in expr.args]
359         return self._deal_with_super_sub(expr.__class__.__name__) + \
360             r"\left(%s\right)" % ", ".join(ls)
361 
362     def _print_bool(self, e):
363         return r"\text{%s}" % e
364 
365     _print_BooleanTrue = _print_bool
366     _print_BooleanFalse = _print_bool
367 
368     def _print_NoneType(self, e):
369         return r"\text{%s}" % e
370 
371     def _print_Add(self, expr, order=None):
372         terms = self._as_ordered_terms(expr, order=order)
373 
374         tex = ""
375         for i, term in enumerate(terms):
376             if i == 0:
377                 pass
378             elif _coeff_isneg(term):
379                 tex += " - "
380                 term = -term
381             else:
382                 tex += " + "
383             term_tex = self._print(term)
384             if self._needs_add_brackets(term):
385                 term_tex = r"\left(%s\right)" % term_tex
386             tex += term_tex
387 
388         return tex
389 
390     def _print_Cycle(self, expr):
391         from sympy.combinatorics.permutations import Permutation
392         if expr.size == 0:
393             return r"\left( \right)"
394         expr = Permutation(expr)
395         expr_perm = expr.cyclic_form
396         siz = expr.size
397         if expr.array_form[-1] == siz - 1:
398             expr_perm = expr_perm + [[siz - 1]]
399         term_tex = ''
400         for i in expr_perm:
401             term_tex += str(i).replace(',', r"\;")
402         term_tex = term_tex.replace('[', r"\left( ")
403         term_tex = term_tex.replace(']', r"\right)")
404         return term_tex
405 
406     def _print_Permutation(self, expr):
407         from sympy.combinatorics.permutations import Permutation
408         from sympy.utilities.exceptions import SymPyDeprecationWarning
409 
410         perm_cyclic = Permutation.print_cyclic
411         if perm_cyclic is not None:
412             SymPyDeprecationWarning(
413                 feature="Permutation.print_cyclic = {}".format(perm_cyclic),
414                 useinstead="init_printing(perm_cyclic={})"
415                 .format(perm_cyclic),
416                 issue=15201,
417                 deprecated_since_version="1.6").warn()
418         else:
419             perm_cyclic = self._settings.get("perm_cyclic", True)
420 
421         if perm_cyclic:
422             return self._print_Cycle(expr)
423 
424         if expr.size == 0:
425             return r"\left( \right)"
426 
427         lower = [self._print(arg) for arg in expr.array_form]
428         upper = [self._print(arg) for arg in range(len(lower))]
429 
430         row1 = " & ".join(upper)
431         row2 = " & ".join(lower)
432         mat = r" \\ ".join((row1, row2))
433         return r"\begin{pmatrix} %s \end{pmatrix}" % mat
434 
435 
436     def _print_AppliedPermutation(self, expr):
437         perm, var = expr.args
438         return r"\sigma_{%s}(%s)" % (self._print(perm), self._print(var))
439 
440     def _print_Float(self, expr):
441         # Based off of that in StrPrinter
442         dps = prec_to_dps(expr._prec)
443         strip = False if self._settings['full_prec'] else True
444         low = self._settings["min"] if "min" in self._settings else None
445         high = self._settings["max"] if "max" in self._settings else None
446         str_real = mlib.to_str(expr._mpf_, dps, strip_zeros=strip, min_fixed=low, max_fixed=high)
447 
448         # Must always have a mul symbol (as 2.5 10^{20} just looks odd)
449         # thus we use the number separator
450         separator = self._settings['mul_symbol_latex_numbers']
451 
452         if 'e' in str_real:
453             (mant, exp) = str_real.split('e')
454 
455             if exp[0] == '+':
456                 exp = exp[1:]
457             if self._settings['decimal_separator'] == 'comma':
458                 mant = mant.replace('.','{,}')
459 
460             return r"%s%s10^{%s}" % (mant, separator, exp)
461         elif str_real == "+inf":
462             return r"\infty"
463         elif str_real == "-inf":
464             return r"- \infty"
465         else:
466             if self._settings['decimal_separator'] == 'comma':
467                 str_real = str_real.replace('.','{,}')
468             return str_real
469 
470     def _print_Cross(self, expr):
471         vec1 = expr._expr1
472         vec2 = expr._expr2
473         return r"%s \times %s" % (self.parenthesize(vec1, PRECEDENCE['Mul']),
474                                   self.parenthesize(vec2, PRECEDENCE['Mul']))
475 
476     def _print_Curl(self, expr):
477         vec = expr._expr
478         return r"\nabla\times %s" % self.parenthesize(vec, PRECEDENCE['Mul'])
479 
480     def _print_Divergence(self, expr):
481         vec = expr._expr
482         return r"\nabla\cdot %s" % self.parenthesize(vec, PRECEDENCE['Mul'])
483 
484     def _print_Dot(self, expr):
485         vec1 = expr._expr1
486         vec2 = expr._expr2
487         return r"%s \cdot %s" % (self.parenthesize(vec1, PRECEDENCE['Mul']),
488                                  self.parenthesize(vec2, PRECEDENCE['Mul']))
489 
490     def _print_Gradient(self, expr):
491         func = expr._expr
492         return r"\nabla %s" % self.parenthesize(func, PRECEDENCE['Mul'])
493 
494     def _print_Laplacian(self, expr):
495         func = expr._expr
496         return r"\triangle %s" % self.parenthesize(func, PRECEDENCE['Mul'])
497 
498     def _print_Mul(self, expr):
499         from sympy.core.power import Pow
500         from sympy.physics.units import Quantity
501         from sympy.simplify import fraction
502         separator = self._settings['mul_symbol_latex']
503         numbersep = self._settings['mul_symbol_latex_numbers']
504 
505         def convert(expr):
506             if not expr.is_Mul:
507                 return str(self._print(expr))
508             else:
509                 if self.order not in ('old', 'none'):
510                     args = expr.as_ordered_factors()
511                 else:
512                     args = list(expr.args)
513 
514                 # If quantities are present append them at the back
515                 args = sorted(args, key=lambda x: isinstance(x, Quantity) or
516                               (isinstance(x, Pow) and
517                                isinstance(x.base, Quantity)))
518 
519                 return convert_args(args)
520 
521         def convert_args(args):
522                 _tex = last_term_tex = ""
523 
524                 for i, term in enumerate(args):
525                     term_tex = self._print(term)
526 
527                     if self._needs_mul_brackets(term, first=(i == 0),
528                                                 last=(i == len(args) - 1)):
529                         term_tex = r"\left(%s\right)" % term_tex
530 
531                     if _between_two_numbers_p[0].search(last_term_tex) and \
532                             _between_two_numbers_p[1].match(term_tex):
533                         # between two numbers
534                         _tex += numbersep
535                     elif _tex:
536                         _tex += separator
537 
538                     _tex += term_tex
539                     last_term_tex = term_tex
540                 return _tex
541 
542         # Check for unevaluated Mul. In this case we need to make sure the
543         # identities are visible, multiple Rational factors are not combined
544         # etc so we display in a straight-forward form that fully preserves all
545         # args and their order.
546         # XXX: _print_Pow calls this routine with instances of Pow...
547         if isinstance(expr, Mul):
548             args = expr.args
549             if args[0] is S.One or any(isinstance(arg, Number) for arg in args[1:]):
550                 return convert_args(args)
551 
552         include_parens = False
553         if _coeff_isneg(expr):
554             expr = -expr
555             tex = "- "
556             if expr.is_Add:
557                 tex += "("
558                 include_parens = True
559         else:
560             tex = ""
561 
562         numer, denom = fraction(expr, exact=True)
563 
564         if denom is S.One and Pow(1, -1, evaluate=False) not in expr.args:
565             # use the original expression here, since fraction() may have
566             # altered it when producing numer and denom
567             tex += convert(expr)
568 
569         else:
570             snumer = convert(numer)
571             sdenom = convert(denom)
572             ldenom = len(sdenom.split())
573             ratio = self._settings['long_frac_ratio']
574             if self._settings['fold_short_frac'] and ldenom <= 2 and \
575                     "^" not in sdenom:
576                 # handle short fractions
577                 if self._needs_mul_brackets(numer, last=False):
578                     tex += r"\left(%s\right) / %s" % (snumer, sdenom)
579                 else:
580                     tex += r"%s / %s" % (snumer, sdenom)
581             elif ratio is not None and \
582                     len(snumer.split()) > ratio*ldenom:
583                 # handle long fractions
584                 if self._needs_mul_brackets(numer, last=True):
585                     tex += r"\frac{1}{%s}%s\left(%s\right)" \
586                         % (sdenom, separator, snumer)
587                 elif numer.is_Mul:
588                     # split a long numerator
589                     a = S.One
590                     b = S.One
591                     for x in numer.args:
592                         if self._needs_mul_brackets(x, last=False) or \
593                                 len(convert(a*x).split()) > ratio*ldenom or \
594                                 (b.is_commutative is x.is_commutative is False):
595                             b *= x
596                         else:
597                             a *= x
598                     if self._needs_mul_brackets(b, last=True):
599                         tex += r"\frac{%s}{%s}%s\left(%s\right)" \
600                             % (convert(a), sdenom, separator, convert(b))
601                     else:
602                         tex += r"\frac{%s}{%s}%s%s" \
603                             % (convert(a), sdenom, separator, convert(b))
604                 else:
605                     tex += r"\frac{1}{%s}%s%s" % (sdenom, separator, snumer)
606             else:
607                 tex += r"\frac{%s}{%s}" % (snumer, sdenom)
608 
609         if include_parens:
610             tex += ")"
611         return tex
612 
613     def _print_Pow(self, expr):
614         # Treat x**Rational(1,n) as special case
615         if expr.exp.is_Rational and abs(expr.exp.p) == 1 and expr.exp.q != 1 \
616                 and self._settings['root_notation']:
617             base = self._print(expr.base)
618             expq = expr.exp.q
619 
620             if expq == 2:
621                 tex = r"\sqrt{%s}" % base
622             elif self._settings['itex']:
623                 tex = r"\root{%d}{%s}" % (expq, base)
624             else:
625                 tex = r"\sqrt[%d]{%s}" % (expq, base)
626 
627             if expr.exp.is_negative:
628                 return r"\frac{1}{%s}" % tex
629             else:
630                 return tex
631         elif self._settings['fold_frac_powers'] \
632             and expr.exp.is_Rational \
633                 and expr.exp.q != 1:
634             base = self.parenthesize(expr.base, PRECEDENCE['Pow'])
635             p, q = expr.exp.p, expr.exp.q
636             # issue #12886: add parentheses for superscripts raised to powers
637             if expr.base.is_Symbol:
638                 base = self.parenthesize_super(base)
639             if expr.base.is_Function:
640                 return self._print(expr.base, exp="%s/%s" % (p, q))
641             return r"%s^{%s/%s}" % (base, p, q)
642         elif expr.exp.is_Rational and expr.exp.is_negative and \
643                 expr.base.is_commutative:
644             # special case for 1^(-x), issue 9216
645             if expr.base == 1:
646                 return r"%s^{%s}" % (expr.base, expr.exp)
647             # things like 1/x
648             return self._print_Mul(expr)
649         else:
650             if expr.base.is_Function:
651                 return self._print(expr.base, exp=self._print(expr.exp))
652             else:
653                 tex = r"%s^{%s}"
654                 return self._helper_print_standard_power(expr, tex)
655 
656     def _helper_print_standard_power(self, expr, template):
657         exp = self._print(expr.exp)
658         # issue #12886: add parentheses around superscripts raised
659         # to powers
660         base = self.parenthesize(expr.base, PRECEDENCE['Pow'])
661         if expr.base.is_Symbol:
662             base = self.parenthesize_super(base)
663         elif (isinstance(expr.base, Derivative)
664             and base.startswith(r'\left(')
665             and re.match(r'\\left\(\\d?d?dot', base)
666             and base.endswith(r'\right)')):
667             # don't use parentheses around dotted derivative
668             base = base[6: -7]  # remove outermost added parens
669         return template % (base, exp)
670 
671     def _print_UnevaluatedExpr(self, expr):
672         return self._print(expr.args[0])
673 
674     def _print_Sum(self, expr):
675         if len(expr.limits) == 1:
676             tex = r"\sum_{%s=%s}^{%s} " % \
677                 tuple([self._print(i) for i in expr.limits[0]])
678         else:
679             def _format_ineq(l):
680                 return r"%s \leq %s \leq %s" % \
681                     tuple([self._print(s) for s in (l[1], l[0], l[2])])
682 
683             tex = r"\sum_{\substack{%s}} " % \
684                 str.join('\\\\', [_format_ineq(l) for l in expr.limits])
685 
686         if isinstance(expr.function, Add):
687             tex += r"\left(%s\right)" % self._print(expr.function)
688         else:
689             tex += self._print(expr.function)
690 
691         return tex
692 
693     def _print_Product(self, expr):
694         if len(expr.limits) == 1:
695             tex = r"\prod_{%s=%s}^{%s} " % \
696                 tuple([self._print(i) for i in expr.limits[0]])
697         else:
698             def _format_ineq(l):
699                 return r"%s \leq %s \leq %s" % \
700                     tuple([self._print(s) for s in (l[1], l[0], l[2])])
701 
702             tex = r"\prod_{\substack{%s}} " % \
703                 str.join('\\\\', [_format_ineq(l) for l in expr.limits])
704 
705         if isinstance(expr.function, Add):
706             tex += r"\left(%s\right)" % self._print(expr.function)
707         else:
708             tex += self._print(expr.function)
709 
710         return tex
711 
712     def _print_BasisDependent(self, expr):
713         from sympy.vector import Vector
714 
715         o1 = []
716         if expr == expr.zero:
717             return expr.zero._latex_form
718         if isinstance(expr, Vector):
719             items = expr.separate().items()
720         else:
721             items = [(0, expr)]
722 
723         for system, vect in items:
724             inneritems = list(vect.components.items())
725             inneritems.sort(key=lambda x: x[0].__str__())
726             for k, v in inneritems:
727                 if v == 1:
728                     o1.append(' + ' + k._latex_form)
729                 elif v == -1:
730                     o1.append(' - ' + k._latex_form)
731                 else:
732                     arg_str = '(' + self._print(v) + ')'
733                     o1.append(' + ' + arg_str + k._latex_form)
734 
735         outstr = (''.join(o1))
736         if outstr[1] != '-':
737             outstr = outstr[3:]
738         else:
739             outstr = outstr[1:]
740         return outstr
741 
742     def _print_Indexed(self, expr):
743         tex_base = self._print(expr.base)
744         tex = '{'+tex_base+'}'+'_{%s}' % ','.join(
745             map(self._print, expr.indices))
746         return tex
747 
748     def _print_IndexedBase(self, expr):
749         return self._print(expr.label)
750 
751     def _print_Derivative(self, expr):
752         if requires_partial(expr.expr):
753             diff_symbol = r'\partial'
754         else:
755             diff_symbol = r'd'
756 
757         tex = ""
758         dim = 0
759         for x, num in reversed(expr.variable_count):
760             dim += num
761             if num == 1:
762                 tex += r"%s %s" % (diff_symbol, self._print(x))
763             else:
764                 tex += r"%s %s^{%s}" % (diff_symbol,
765                                         self.parenthesize_super(self._print(x)),
766                                         self._print(num))
767 
768         if dim == 1:
769             tex = r"\frac{%s}{%s}" % (diff_symbol, tex)
770         else:
771             tex = r"\frac{%s^{%s}}{%s}" % (diff_symbol, self._print(dim), tex)
772 
773         if any(_coeff_isneg(i) for i in expr.args):
774             return r"%s %s" % (tex, self.parenthesize(expr.expr,
775                                                   PRECEDENCE["Mul"],
776                                                   is_neg=True,
777                                                   strict=True))
778 
779         return r"%s %s" % (tex, self.parenthesize(expr.expr,
780                                                   PRECEDENCE["Mul"],
781                                                   is_neg=False,
782                                                   strict=True))
783 
784     def _print_Subs(self, subs):
785         expr, old, new = subs.args
786         latex_expr = self._print(expr)
787         latex_old = (self._print(e) for e in old)
788         latex_new = (self._print(e) for e in new)
789         latex_subs = r'\\ '.join(
790             e[0] + '=' + e[1] for e in zip(latex_old, latex_new))
791         return r'\left. %s \right|_{\substack{ %s }}' % (latex_expr,
792                                                          latex_subs)
793 
794     def _print_Integral(self, expr):
795         tex, symbols = "", []
796 
797         # Only up to \iiiint exists
798         if len(expr.limits) <= 4 and all(len(lim) == 1 for lim in expr.limits):
799             # Use len(expr.limits)-1 so that syntax highlighters don't think
800             # \" is an escaped quote
801             tex = r"\i" + "i"*(len(expr.limits) - 1) + "nt"
802             symbols = [r"\, d%s" % self._print(symbol[0])
803                        for symbol in expr.limits]
804 
805         else:
806             for lim in reversed(expr.limits):
807                 symbol = lim[0]
808                 tex += r"\int"
809 
810                 if len(lim) > 1:
811                     if self._settings['mode'] != 'inline' \
812                             and not self._settings['itex']:
813                         tex += r"\limits"
814 
815                     if len(lim) == 3:
816                         tex += "_{%s}^{%s}" % (self._print(lim[1]),
817                                                self._print(lim[2]))
818                     if len(lim) == 2:
819                         tex += "^{%s}" % (self._print(lim[1]))
820 
821                 symbols.insert(0, r"\, d%s" % self._print(symbol))
822 
823         return r"%s %s%s" % (tex, self.parenthesize(expr.function,
824                                                     PRECEDENCE["Mul"],
825                                                     is_neg=any(_coeff_isneg(i) for i in expr.args),
826                                                     strict=True),
827                              "".join(symbols))
828 
829     def _print_Limit(self, expr):
830         e, z, z0, dir = expr.args
831 
832         tex = r"\lim_{%s \to " % self._print(z)
833         if str(dir) == '+-' or z0 in (S.Infinity, S.NegativeInfinity):
834             tex += r"%s}" % self._print(z0)
835         else:
836             tex += r"%s^%s}" % (self._print(z0), self._print(dir))
837 
838         if isinstance(e, AssocOp):
839             return r"%s\left(%s\right)" % (tex, self._print(e))
840         else:
841             return r"%s %s" % (tex, self._print(e))
842 
843     def _hprint_Function(self, func):
844         r'''
845         Logic to decide how to render a function to latex
846           - if it is a recognized latex name, use the appropriate latex command
847           - if it is a single letter, just use that letter
848           - if it is a longer name, then put \operatorname{} around it and be
849             mindful of undercores in the name
850         '''
851         func = self._deal_with_super_sub(func)
852         if func in accepted_latex_functions:
853             name = r"\%s" % func
854         elif len(func) == 1 or func.startswith('\\'):
855             name = func
856         else:
857             name = r"\operatorname{%s}" % func
858         return name
859 
860     def _print_Function(self, expr, exp=None):
861         r'''
862         Render functions to LaTeX, handling functions that LaTeX knows about
863         e.g., sin, cos, ... by using the proper LaTeX command (\sin, \cos, ...).
864         For single-letter function names, render them as regular LaTeX math
865         symbols. For multi-letter function names that LaTeX does not know
866         about, (e.g., Li, sech) use \operatorname{} so that the function name
867         is rendered in Roman font and LaTeX handles spacing properly.
868 
869         expr is the expression involving the function
870         exp is an exponent
871         '''
872         func = expr.func.__name__
873         if hasattr(self, '_print_' + func) and \
874                 not isinstance(expr, AppliedUndef):
875             return getattr(self, '_print_' + func)(expr, exp)
876         else:
877             args = [str(self._print(arg)) for arg in expr.args]
878             # How inverse trig functions should be displayed, formats are:
879             # abbreviated: asin, full: arcsin, power: sin^-1
880             inv_trig_style = self._settings['inv_trig_style']
881             # If we are dealing with a power-style inverse trig function
882             inv_trig_power_case = False
883             # If it is applicable to fold the argument brackets
884             can_fold_brackets = self._settings['fold_func_brackets'] and \
885                 len(args) == 1 and \
886                 not self._needs_function_brackets(expr.args[0])
887 
888             inv_trig_table = [
889                 "asin", "acos", "atan",
890                 "acsc", "asec", "acot",
891                 "asinh", "acosh", "atanh",
892                 "acsch", "asech", "acoth",
893             ]
894 
895             # If the function is an inverse trig function, handle the style
896             if func in inv_trig_table:
897                 if inv_trig_style == "abbreviated":
898                     pass
899                 elif inv_trig_style == "full":
900                     func = "arc" + func[1:]
901                 elif inv_trig_style == "power":
902                     func = func[1:]
903                     inv_trig_power_case = True
904 
905                     # Can never fold brackets if we're raised to a power
906                     if exp is not None:
907                         can_fold_brackets = False
908 
909             if inv_trig_power_case:
910                 if func in accepted_latex_functions:
911                     name = r"\%s^{-1}" % func
912                 else:
913                     name = r"\operatorname{%s}^{-1}" % func
914             elif exp is not None:
915                 func_tex = self._hprint_Function(func)
916                 func_tex = self.parenthesize_super(func_tex)
917                 name = r'%s^{%s}' % (func_tex, exp)
918             else:
919                 name = self._hprint_Function(func)
920 
921             if can_fold_brackets:
922                 if func in accepted_latex_functions:
923                     # Wrap argument safely to avoid parse-time conflicts
924                     # with the function name itself
925                     name += r" {%s}"
926                 else:
927                     name += r"%s"
928             else:
929                 name += r"{\left(%s \right)}"
930 
931             if inv_trig_power_case and exp is not None:
932                 name += r"^{%s}" % exp
933 
934             return name % ",".join(args)
935 
936     def _print_UndefinedFunction(self, expr):
937         return self._hprint_Function(str(expr))
938 
939     def _print_ElementwiseApplyFunction(self, expr):
940         return r"{%s}_{\circ}\left({%s}\right)" % (
941             self._print(expr.function),
942             self._print(expr.expr),
943         )
944 
945     @property
946     def _special_function_classes(self):
947         from sympy.functions.special.tensor_functions import KroneckerDelta
948         from sympy.functions.special.gamma_functions import gamma, lowergamma
949         from sympy.functions.special.beta_functions import beta
950         from sympy.functions.special.delta_functions import DiracDelta
951         from sympy.functions.special.error_functions import Chi
952         return {KroneckerDelta: r'\delta',
953                 gamma:  r'\Gamma',
954                 lowergamma: r'\gamma',
955                 beta: r'\operatorname{B}',
956                 DiracDelta: r'\delta',
957                 Chi: r'\operatorname{Chi}'}
958 
959     def _print_FunctionClass(self, expr):
960         for cls in self._special_function_classes:
961             if issubclass(expr, cls) and expr.__name__ == cls.__name__:
962                 return self._special_function_classes[cls]
963         return self._hprint_Function(str(expr))
964 
965     def _print_Lambda(self, expr):
966         symbols, expr = expr.args
967 
968         if len(symbols) == 1:
969             symbols = self._print(symbols[0])
970         else:
971             symbols = self._print(tuple(symbols))
972 
973         tex = r"\left( %s \mapsto %s \right)" % (symbols, self._print(expr))
974 
975         return tex
976 
977     def _print_IdentityFunction(self, expr):
978         return r"\left( x \mapsto x \right)"
979 
980     def _hprint_variadic_function(self, expr, exp=None):
981         args = sorted(expr.args, key=default_sort_key)
982         texargs = [r"%s" % self._print(symbol) for symbol in args]
983         tex = r"\%s\left(%s\right)" % (str(expr.func).lower(),
984                                        ", ".join(texargs))
985         if exp is not None:
986             return r"%s^{%s}" % (tex, exp)
987         else:
988             return tex
989 
990     _print_Min = _print_Max = _hprint_variadic_function
991 
992     def _print_floor(self, expr, exp=None):
993         tex = r"\left\lfloor{%s}\right\rfloor" % self._print(expr.args[0])
994 
995         if exp is not None:
996             return r"%s^{%s}" % (tex, exp)
997         else:
998             return tex
999 
1000     def _print_ceiling(self, expr, exp=None):
1001         tex = r"\left\lceil{%s}\right\rceil" % self._print(expr.args[0])
1002 
1003         if exp is not None:
1004             return r"%s^{%s}" % (tex, exp)
1005         else:
1006             return tex
1007 
1008     def _print_log(self, expr, exp=None):
1009         if not self._settings["ln_notation"]:
1010             tex = r"\log{\left(%s \right)}" % self._print(expr.args[0])
1011         else:
1012             tex = r"\ln{\left(%s \right)}" % self._print(expr.args[0])
1013 
1014         if exp is not None:
1015             return r"%s^{%s}" % (tex, exp)
1016         else:
1017             return tex
1018 
1019     def _print_Abs(self, expr, exp=None):
1020         tex = r"\left|{%s}\right|" % self._print(expr.args[0])
1021 
1022         if exp is not None:
1023             return r"%s^{%s}" % (tex, exp)
1024         else:
1025             return tex
1026     _print_Determinant = _print_Abs
1027 
1028     def _print_re(self, expr, exp=None):
1029         if self._settings['gothic_re_im']:
1030             tex = r"\Re{%s}" % self.parenthesize(expr.args[0], PRECEDENCE['Atom'])
1031         else:
1032             tex = r"\operatorname{{re}}{{{}}}".format(self.parenthesize(expr.args[0], PRECEDENCE['Atom']))
1033 
1034         return self._do_exponent(tex, exp)
1035 
1036     def _print_im(self, expr, exp=None):
1037         if self._settings['gothic_re_im']:
1038             tex = r"\Im{%s}" % self.parenthesize(expr.args[0], PRECEDENCE['Atom'])
1039         else:
1040             tex = r"\operatorname{{im}}{{{}}}".format(self.parenthesize(expr.args[0], PRECEDENCE['Atom']))
1041 
1042         return self._do_exponent(tex, exp)
1043 
1044     def _print_Not(self, e):
1045         from sympy import Equivalent, Implies
1046         if isinstance(e.args[0], Equivalent):
1047             return self._print_Equivalent(e.args[0], r"\not\Leftrightarrow")
1048         if isinstance(e.args[0], Implies):
1049             return self._print_Implies(e.args[0], r"\not\Rightarrow")
1050         if (e.args[0].is_Boolean):
1051             return r"\neg \left(%s\right)" % self._print(e.args[0])
1052         else:
1053             return r"\neg %s" % self._print(e.args[0])
1054 
1055     def _print_LogOp(self, args, char):
1056         arg = args[0]
1057         if arg.is_Boolean and not arg.is_Not:
1058             tex = r"\left(%s\right)" % self._print(arg)
1059         else:
1060             tex = r"%s" % self._print(arg)
1061 
1062         for arg in args[1:]:
1063             if arg.is_Boolean and not arg.is_Not:
1064                 tex += r" %s \left(%s\right)" % (char, self._print(arg))
1065             else:
1066                 tex += r" %s %s" % (char, self._print(arg))
1067 
1068         return tex
1069 
1070     def _print_And(self, e):
1071         args = sorted(e.args, key=default_sort_key)
1072         return self._print_LogOp(args, r"\wedge")
1073 
1074     def _print_Or(self, e):
1075         args = sorted(e.args, key=default_sort_key)
1076         return self._print_LogOp(args, r"\vee")
1077 
1078     def _print_Xor(self, e):
1079         args = sorted(e.args, key=default_sort_key)
1080         return self._print_LogOp(args, r"\veebar")
1081 
1082     def _print_Implies(self, e, altchar=None):
1083         return self._print_LogOp(e.args, altchar or r"\Rightarrow")
1084 
1085     def _print_Equivalent(self, e, altchar=None):
1086         args = sorted(e.args, key=default_sort_key)
1087         return self._print_LogOp(args, altchar or r"\Leftrightarrow")
1088 
1089     def _print_conjugate(self, expr, exp=None):
1090         tex = r"\overline{%s}" % self._print(expr.args[0])
1091 
1092         if exp is not None:
1093             return r"%s^{%s}" % (tex, exp)
1094         else:
1095             return tex
1096 
1097     def _print_polar_lift(self, expr, exp=None):
1098         func = r"\operatorname{polar\_lift}"
1099         arg = r"{\left(%s \right)}" % self._print(expr.args[0])
1100 
1101         if exp is not None:
1102             return r"%s^{%s}%s" % (func, exp, arg)
1103         else:
1104             return r"%s%s" % (func, arg)
1105 
1106     def _print_ExpBase(self, expr, exp=None):
1107         # TODO should exp_polar be printed differently?
1108         #      what about exp_polar(0), exp_polar(1)?
1109         tex = r"e^{%s}" % self._print(expr.args[0])
1110         return self._do_exponent(tex, exp)
1111 
1112     def _print_elliptic_k(self, expr, exp=None):
1113         tex = r"\left(%s\right)" % self._print(expr.args[0])
1114         if exp is not None:
1115             return r"K^{%s}%s" % (exp, tex)
1116         else:
1117             return r"K%s" % tex
1118 
1119     def _print_elliptic_f(self, expr, exp=None):
1120         tex = r"\left(%s\middle| %s\right)" % \
1121             (self._print(expr.args[0]), self._print(expr.args[1]))
1122         if exp is not None:
1123             return r"F^{%s}%s" % (exp, tex)
1124         else:
1125             return r"F%s" % tex
1126 
1127     def _print_elliptic_e(self, expr, exp=None):
1128         if len(expr.args) == 2:
1129             tex = r"\left(%s\middle| %s\right)" % \
1130                 (self._print(expr.args[0]), self._print(expr.args[1]))
1131         else:
1132             tex = r"\left(%s\right)" % self._print(expr.args[0])
1133         if exp is not None:
1134             return r"E^{%s}%s" % (exp, tex)
1135         else:
1136             return r"E%s" % tex
1137 
1138     def _print_elliptic_pi(self, expr, exp=None):
1139         if len(expr.args) == 3:
1140             tex = r"\left(%s; %s\middle| %s\right)" % \
1141                 (self._print(expr.args[0]), self._print(expr.args[1]),
1142                  self._print(expr.args[2]))
1143         else:
1144             tex = r"\left(%s\middle| %s\right)" % \
1145                 (self._print(expr.args[0]), self._print(expr.args[1]))
1146         if exp is not None:
1147             return r"\Pi^{%s}%s" % (exp, tex)
1148         else:
1149             return r"\Pi%s" % tex
1150 
1151     def _print_beta(self, expr, exp=None):
1152         tex = r"\left(%s, %s\right)" % (self._print(expr.args[0]),
1153                                         self._print(expr.args[1]))
1154 
1155         if exp is not None:
1156             return r"\operatorname{B}^{%s}%s" % (exp, tex)
1157         else:
1158             return r"\operatorname{B}%s" % tex
1159 
1160     def _print_uppergamma(self, expr, exp=None):
1161         tex = r"\left(%s, %s\right)" % (self._print(expr.args[0]),
1162                                         self._print(expr.args[1]))
1163 
1164         if exp is not None:
1165             return r"\Gamma^{%s}%s" % (exp, tex)
1166         else:
1167             return r"\Gamma%s" % tex
1168 
1169     def _print_lowergamma(self, expr, exp=None):
1170         tex = r"\left(%s, %s\right)" % (self._print(expr.args[0]),
1171                                         self._print(expr.args[1]))
1172 
1173         if exp is not None:
1174             return r"\gamma^{%s}%s" % (exp, tex)
1175         else:
1176             return r"\gamma%s" % tex
1177 
1178     def _hprint_one_arg_func(self, expr, exp=None):
1179         tex = r"\left(%s\right)" % self._print(expr.args[0])
1180 
1181         if exp is not None:
1182             return r"%s^{%s}%s" % (self._print(expr.func), exp, tex)
1183         else:
1184             return r"%s%s" % (self._print(expr.func), tex)
1185 
1186     _print_gamma = _hprint_one_arg_func
1187 
1188     def _print_Chi(self, expr, exp=None):
1189         tex = r"\left(%s\right)" % self._print(expr.args[0])
1190 
1191         if exp is not None:
1192             return r"\operatorname{Chi}^{%s}%s" % (exp, tex)
1193         else:
1194             return r"\operatorname{Chi}%s" % tex
1195 
1196     def _print_expint(self, expr, exp=None):
1197         tex = r"\left(%s\right)" % self._print(expr.args[1])
1198         nu = self._print(expr.args[0])
1199 
1200         if exp is not None:
1201             return r"\operatorname{E}_{%s}^{%s}%s" % (nu, exp, tex)
1202         else:
1203             return r"\operatorname{E}_{%s}%s" % (nu, tex)
1204 
1205     def _print_fresnels(self, expr, exp=None):
1206         tex = r"\left(%s\right)" % self._print(expr.args[0])
1207 
1208         if exp is not None:
1209             return r"S^{%s}%s" % (exp, tex)
1210         else:
1211             return r"S%s" % tex
1212 
1213     def _print_fresnelc(self, expr, exp=None):
1214         tex = r"\left(%s\right)" % self._print(expr.args[0])
1215 
1216         if exp is not None:
1217             return r"C^{%s}%s" % (exp, tex)
1218         else:
1219             return r"C%s" % tex
1220 
1221     def _print_subfactorial(self, expr, exp=None):
1222         tex = r"!%s" % self.parenthesize(expr.args[0], PRECEDENCE["Func"])
1223 
1224         if exp is not None:
1225             return r"\left(%s\right)^{%s}" % (tex, exp)
1226         else:
1227             return tex
1228 
1229     def _print_factorial(self, expr, exp=None):
1230         tex = r"%s!" % self.parenthesize(expr.args[0], PRECEDENCE["Func"])
1231 
1232         if exp is not None:
1233             return r"%s^{%s}" % (tex, exp)
1234         else:
1235             return tex
1236 
1237     def _print_factorial2(self, expr, exp=None):
1238         tex = r"%s!!" % self.parenthesize(expr.args[0], PRECEDENCE["Func"])
1239 
1240         if exp is not None:
1241             return r"%s^{%s}" % (tex, exp)
1242         else:
1243             return tex
1244 
1245     def _print_binomial(self, expr, exp=None):
1246         tex = r"{\binom{%s}{%s}}" % (self._print(expr.args[0]),
1247                                      self._print(expr.args[1]))
1248 
1249         if exp is not None:
1250             return r"%s^{%s}" % (tex, exp)
1251         else:
1252             return tex
1253 
1254     def _print_RisingFactorial(self, expr, exp=None):
1255         n, k = expr.args
1256         base = r"%s" % self.parenthesize(n, PRECEDENCE['Func'])
1257 
1258         tex = r"{%s}^{\left(%s\right)}" % (base, self._print(k))
1259 
1260         return self._do_exponent(tex, exp)
1261 
1262     def _print_FallingFactorial(self, expr, exp=None):
1263         n, k = expr.args
1264         sub = r"%s" % self.parenthesize(k, PRECEDENCE['Func'])
1265 
1266         tex = r"{\left(%s\right)}_{%s}" % (self._print(n), sub)
1267 
1268         return self._do_exponent(tex, exp)
1269 
1270     def _hprint_BesselBase(self, expr, exp, sym):
1271         tex = r"%s" % (sym)
1272 
1273         need_exp = False
1274         if exp is not None:
1275             if tex.find('^') == -1:
1276                 tex = r"%s^{%s}" % (tex, exp)
1277             else:
1278                 need_exp = True
1279 
1280         tex = r"%s_{%s}\left(%s\right)" % (tex, self._print(expr.order),
1281                                            self._print(expr.argument))
1282 
1283         if need_exp:
1284             tex = self._do_exponent(tex, exp)
1285         return tex
1286 
1287     def _hprint_vec(self, vec):
1288         if not vec:
1289             return ""
1290         s = ""
1291         for i in vec[:-1]:
1292             s += "%s, " % self._print(i)
1293         s += self._print(vec[-1])
1294         return s
1295 
1296     def _print_besselj(self, expr, exp=None):
1297         return self._hprint_BesselBase(expr, exp, 'J')
1298 
1299     def _print_besseli(self, expr, exp=None):
1300         return self._hprint_BesselBase(expr, exp, 'I')
1301 
1302     def _print_besselk(self, expr, exp=None):
1303         return self._hprint_BesselBase(expr, exp, 'K')
1304 
1305     def _print_bessely(self, expr, exp=None):
1306         return self._hprint_BesselBase(expr, exp, 'Y')
1307 
1308     def _print_yn(self, expr, exp=None):
1309         return self._hprint_BesselBase(expr, exp, 'y')
1310 
1311     def _print_jn(self, expr, exp=None):
1312         return self._hprint_BesselBase(expr, exp, 'j')
1313 
1314     def _print_hankel1(self, expr, exp=None):
1315         return self._hprint_BesselBase(expr, exp, 'H^{(1)}')
1316 
1317     def _print_hankel2(self, expr, exp=None):
1318         return self._hprint_BesselBase(expr, exp, 'H^{(2)}')
1319 
1320     def _print_hn1(self, expr, exp=None):
1321         return self._hprint_BesselBase(expr, exp, 'h^{(1)}')
1322 
1323     def _print_hn2(self, expr, exp=None):
1324         return self._hprint_BesselBase(expr, exp, 'h^{(2)}')
1325 
1326     def _hprint_airy(self, expr, exp=None, notation=""):
1327         tex = r"\left(%s\right)" % self._print(expr.args[0])
1328 
1329         if exp is not None:
1330             return r"%s^{%s}%s" % (notation, exp, tex)
1331         else:
1332             return r"%s%s" % (notation, tex)
1333 
1334     def _hprint_airy_prime(self, expr, exp=None, notation=""):
1335         tex = r"\left(%s\right)" % self._print(expr.args[0])
1336 
1337         if exp is not None:
1338             return r"{%s^\prime}^{%s}%s" % (notation, exp, tex)
1339         else:
1340             return r"%s^\prime%s" % (notation, tex)
1341 
1342     def _print_airyai(self, expr, exp=None):
1343         return self._hprint_airy(expr, exp, 'Ai')
1344 
1345     def _print_airybi(self, expr, exp=None):
1346         return self._hprint_airy(expr, exp, 'Bi')
1347 
1348     def _print_airyaiprime(self, expr, exp=None):
1349         return self._hprint_airy_prime(expr, exp, 'Ai')
1350 
1351     def _print_airybiprime(self, expr, exp=None):
1352         return self._hprint_airy_prime(expr, exp, 'Bi')
1353 
1354     def _print_hyper(self, expr, exp=None):
1355         tex = r"{{}_{%s}F_{%s}\left(\begin{matrix} %s \\ %s \end{matrix}" \
1356               r"\middle| {%s} \right)}" % \
1357             (self._print(len(expr.ap)), self._print(len(expr.bq)),
1358               self._hprint_vec(expr.ap), self._hprint_vec(expr.bq),
1359               self._print(expr.argument))
1360 
1361         if exp is not None:
1362             tex = r"{%s}^{%s}" % (tex, exp)
1363         return tex
1364 
1365     def _print_meijerg(self, expr, exp=None):
1366         tex = r"{G_{%s, %s}^{%s, %s}\left(\begin{matrix} %s & %s \\" \
1367               r"%s & %s \end{matrix} \middle| {%s} \right)}" % \
1368             (self._print(len(expr.ap)), self._print(len(expr.bq)),
1369               self._print(len(expr.bm)), self._print(len(expr.an)),
1370               self._hprint_vec(expr.an), self._hprint_vec(expr.aother),
1371               self._hprint_vec(expr.bm), self._hprint_vec(expr.bother),
1372               self._print(expr.argument))
1373 
1374         if exp is not None:
1375             tex = r"{%s}^{%s}" % (tex, exp)
1376         return tex
1377 
1378     def _print_dirichlet_eta(self, expr, exp=None):
1379         tex = r"\left(%s\right)" % self._print(expr.args[0])
1380         if exp is not None:
1381             return r"\eta^{%s}%s" % (exp, tex)
1382         return r"\eta%s" % tex
1383 
1384     def _print_zeta(self, expr, exp=None):
1385         if len(expr.args) == 2:
1386             tex = r"\left(%s, %s\right)" % tuple(map(self._print, expr.args))
1387         else:
1388             tex = r"\left(%s\right)" % self._print(expr.args[0])
1389         if exp is not None:
1390             return r"\zeta^{%s}%s" % (exp, tex)
1391         return r"\zeta%s" % tex
1392 
1393     def _print_stieltjes(self, expr, exp=None):
1394         if len(expr.args) == 2:
1395             tex = r"_{%s}\left(%s\right)" % tuple(map(self._print, expr.args))
1396         else:
1397             tex = r"_{%s}" % self._print(expr.args[0])
1398         if exp is not None:
1399             return r"\gamma%s^{%s}" % (tex, exp)
1400         return r"\gamma%s" % tex
1401 
1402     def _print_lerchphi(self, expr, exp=None):
1403         tex = r"\left(%s, %s, %s\right)" % tuple(map(self._print, expr.args))
1404         if exp is None:
1405             return r"\Phi%s" % tex
1406         return r"\Phi^{%s}%s" % (exp, tex)
1407 
1408     def _print_polylog(self, expr, exp=None):
1409         s, z = map(self._print, expr.args)
1410         tex = r"\left(%s\right)" % z
1411         if exp is None:
1412             return r"\operatorname{Li}_{%s}%s" % (s, tex)
1413         return r"\operatorname{Li}_{%s}^{%s}%s" % (s, exp, tex)
1414 
1415     def _print_jacobi(self, expr, exp=None):
1416         n, a, b, x = map(self._print, expr.args)
1417         tex = r"P_{%s}^{\left(%s,%s\right)}\left(%s\right)" % (n, a, b, x)
1418         if exp is not None:
1419             tex = r"\left(" + tex + r"\right)^{%s}" % (exp)
1420         return tex
1421 
1422     def _print_gegenbauer(self, expr, exp=None):
1423         n, a, x = map(self._print, expr.args)
1424         tex = r"C_{%s}^{\left(%s\right)}\left(%s\right)" % (n, a, x)
1425         if exp is not None:
1426             tex = r"\left(" + tex + r"\right)^{%s}" % (exp)
1427         return tex
1428 
1429     def _print_chebyshevt(self, expr, exp=None):
1430         n, x = map(self._print, expr.args)
1431         tex = r"T_{%s}\left(%s\right)" % (n, x)
1432         if exp is not None:
1433             tex = r"\left(" + tex + r"\right)^{%s}" % (exp)
1434         return tex
1435 
1436     def _print_chebyshevu(self, expr, exp=None):
1437         n, x = map(self._print, expr.args)
1438         tex = r"U_{%s}\left(%s\right)" % (n, x)
1439         if exp is not None:
1440             tex = r"\left(" + tex + r"\right)^{%s}" % (exp)
1441         return tex
1442 
1443     def _print_legendre(self, expr, exp=None):
1444         n, x = map(self._print, expr.args)
1445         tex = r"P_{%s}\left(%s\right)" % (n, x)
1446         if exp is not None:
1447             tex = r"\left(" + tex + r"\right)^{%s}" % (exp)
1448         return tex
1449 
1450     def _print_assoc_legendre(self, expr, exp=None):
1451         n, a, x = map(self._print, expr.args)
1452         tex = r"P_{%s}^{\left(%s\right)}\left(%s\right)" % (n, a, x)
1453         if exp is not None:
1454             tex = r"\left(" + tex + r"\right)^{%s}" % (exp)
1455         return tex
1456 
1457     def _print_hermite(self, expr, exp=None):
1458         n, x = map(self._print, expr.args)
1459         tex = r"H_{%s}\left(%s\right)" % (n, x)
1460         if exp is not None:
1461             tex = r"\left(" + tex + r"\right)^{%s}" % (exp)
1462         return tex
1463 
1464     def _print_laguerre(self, expr, exp=None):
1465         n, x = map(self._print, expr.args)
1466         tex = r"L_{%s}\left(%s\right)" % (n, x)
1467         if exp is not None:
1468             tex = r"\left(" + tex + r"\right)^{%s}" % (exp)
1469         return tex
1470 
1471     def _print_assoc_laguerre(self, expr, exp=None):
1472         n, a, x = map(self._print, expr.args)
1473         tex = r"L_{%s}^{\left(%s\right)}\left(%s\right)" % (n, a, x)
1474         if exp is not None:
1475             tex = r"\left(" + tex + r"\right)^{%s}" % (exp)
1476         return tex
1477 
1478     def _print_Ynm(self, expr, exp=None):
1479         n, m, theta, phi = map(self._print, expr.args)
1480         tex = r"Y_{%s}^{%s}\left(%s,%s\right)" % (n, m, theta, phi)
1481         if exp is not None:
1482             tex = r"\left(" + tex + r"\right)^{%s}" % (exp)
1483         return tex
1484 
1485     def _print_Znm(self, expr, exp=None):
1486         n, m, theta, phi = map(self._print, expr.args)
1487         tex = r"Z_{%s}^{%s}\left(%s,%s\right)" % (n, m, theta, phi)
1488         if exp is not None:
1489             tex = r"\left(" + tex + r"\right)^{%s}" % (exp)
1490         return tex
1491 
1492     def __print_mathieu_functions(self, character, args, prime=False, exp=None):
1493         a, q, z = map(self._print, args)
1494         sup = r"^{\prime}" if prime else ""
1495         exp = "" if not exp else "^{%s}" % exp
1496         return r"%s%s\left(%s, %s, %s\right)%s" % (character, sup, a, q, z, exp)
1497 
1498     def _print_mathieuc(self, expr, exp=None):
1499         return self.__print_mathieu_functions("C", expr.args, exp=exp)
1500 
1501     def _print_mathieus(self, expr, exp=None):
1502         return self.__print_mathieu_functions("S", expr.args, exp=exp)
1503 
1504     def _print_mathieucprime(self, expr, exp=None):
1505         return self.__print_mathieu_functions("C", expr.args, prime=True, exp=exp)
1506 
1507     def _print_mathieusprime(self, expr, exp=None):
1508         return self.__print_mathieu_functions("S", expr.args, prime=True, exp=exp)
1509 
1510     def _print_Rational(self, expr):
1511         if expr.q != 1:
1512             sign = ""
1513             p = expr.p
1514             if expr.p < 0:
1515                 sign = "- "
1516                 p = -p
1517             if self._settings['fold_short_frac']:
1518                 return r"%s%d / %d" % (sign, p, expr.q)
1519             return r"%s\frac{%d}{%d}" % (sign, p, expr.q)
1520         else:
1521             return self._print(expr.p)
1522 
1523     def _print_Order(self, expr):
1524         s = self._print(expr.expr)
1525         if expr.point and any(p != S.Zero for p in expr.point) or \
1526            len(expr.variables) > 1:
1527             s += '; '
1528             if len(expr.variables) > 1:
1529                 s += self._print(expr.variables)
1530             elif expr.variables:
1531                 s += self._print(expr.variables[0])
1532             s += r'\rightarrow '
1533             if len(expr.point) > 1:
1534                 s += self._print(expr.point)
1535             else:
1536                 s += self._print(expr.point[0])
1537         return r"O\left(%s\right)" % s
1538 
1539     def _print_Symbol(self, expr, style='plain'):
1540         if expr in self._settings['symbol_names']:
1541             return self._settings['symbol_names'][expr]
1542 
1543         return self._deal_with_super_sub(expr.name, style=style)
1544 
1545     _print_RandomSymbol = _print_Symbol
1546 
1547     def _deal_with_super_sub(self, string, style='plain'):
1548         if '{' in string:
1549             name, supers, subs = string, [], []
1550         else:
1551             name, supers, subs = split_super_sub(string)
1552 
1553             name = translate(name)
1554             supers = [translate(sup) for sup in supers]
1555             subs = [translate(sub) for sub in subs]
1556 
1557         # apply the style only to the name
1558         if style == 'bold':
1559             name = "\\mathbf{{{}}}".format(name)
1560 
1561         # glue all items together:
1562         if supers:
1563             name += "^{%s}" % " ".join(supers)
1564         if subs:
1565             name += "_{%s}" % " ".join(subs)
1566 
1567         return name
1568 
1569     def _print_Relational(self, expr):
1570         if self._settings['itex']:
1571             gt = r"\gt"
1572             lt = r"\lt"
1573         else:
1574             gt = ">"
1575             lt = "<"
1576 
1577         charmap = {
1578             "==": "=",
1579             ">": gt,
1580             "<": lt,
1581             ">=": r"\geq",
1582             "<=": r"\leq",
1583             "!=": r"\neq",
1584         }
1585 
1586         return "%s %s %s" % (self._print(expr.lhs),
1587                              charmap[expr.rel_op], self._print(expr.rhs))
1588 
1589     def _print_Piecewise(self, expr):
1590         ecpairs = [r"%s & \text{for}\: %s" % (self._print(e), self._print(c))
1591                    for e, c in expr.args[:-1]]
1592         if expr.args[-1].cond == true:
1593             ecpairs.append(r"%s & \text{otherwise}" %
1594                            self._print(expr.args[-1].expr))
1595         else:
1596             ecpairs.append(r"%s & \text{for}\: %s" %
1597                            (self._print(expr.args[-1].expr),
1598                             self._print(expr.args[-1].cond)))
1599         tex = r"\begin{cases} %s \end{cases}"
1600         return tex % r" \\".join(ecpairs)
1601 
1602     def _print_MatrixBase(self, expr):
1603         lines = []
1604 
1605         for line in range(expr.rows):  # horrible, should be 'rows'
1606             lines.append(" & ".join([self._print(i) for i in expr[line, :]]))
1607 
1608         mat_str = self._settings['mat_str']
1609         if mat_str is None:
1610             if self._settings['mode'] == 'inline':
1611                 mat_str = 'smallmatrix'
1612             else:
1613                 if (expr.cols <= 10) is True:
1614                     mat_str = 'matrix'
1615                 else:
1616                     mat_str = 'array'
1617 
1618         out_str = r'\begin{%MATSTR%}%s\end{%MATSTR%}'
1619         out_str = out_str.replace('%MATSTR%', mat_str)
1620         if mat_str == 'array':
1621             out_str = out_str.replace('%s', '{' + 'c'*expr.cols + '}%s')
1622         if self._settings['mat_delim']:
1623             left_delim = self._settings['mat_delim']
1624             right_delim = self._delim_dict[left_delim]
1625             out_str = r'\left' + left_delim + out_str + \
1626                       r'\right' + right_delim
1627         return out_str % r"\\".join(lines)
1628 
1629     def _print_MatrixElement(self, expr):
1630         return self.parenthesize(expr.parent, PRECEDENCE["Atom"], strict=True)\
1631             + '_{%s, %s}' % (self._print(expr.i), self._print(expr.j))
1632 
1633     def _print_MatrixSlice(self, expr):
1634         def latexslice(x, dim):
1635             x = list(x)
1636             if x[2] == 1:
1637                 del x[2]
1638             if x[0] == 0:
1639                 x[0] = None
1640             if x[1] == dim:
1641                 x[1] = None
1642             return ':'.join(self._print(xi) if xi is not None else '' for xi in x)
1643         return (self.parenthesize(expr.parent, PRECEDENCE["Atom"], strict=True) + r'\left[' +
1644                 latexslice(expr.rowslice, expr.parent.rows) + ', ' +
1645                 latexslice(expr.colslice, expr.parent.cols) + r'\right]')
1646 
1647     def _print_BlockMatrix(self, expr):
1648         return self._print(expr.blocks)
1649 
1650     def _print_Transpose(self, expr):
1651         mat = expr.arg
1652         from sympy.matrices import MatrixSymbol
1653         if not isinstance(mat, MatrixSymbol):
1654             return r"\left(%s\right)^{T}" % self._print(mat)
1655         else:
1656             return "%s^{T}" % self.parenthesize(mat, precedence_traditional(expr), True)
1657 
1658     def _print_Trace(self, expr):
1659         mat = expr.arg
1660         return r"\operatorname{tr}\left(%s \right)" % self._print(mat)
1661 
1662     def _print_Adjoint(self, expr):
1663         mat = expr.arg
1664         from sympy.matrices import MatrixSymbol
1665         if not isinstance(mat, MatrixSymbol):
1666             return r"\left(%s\right)^{\dagger}" % self._print(mat)
1667         else:
1668             return r"%s^{\dagger}" % self._print(mat)
1669 
1670     def _print_MatMul(self, expr):
1671         from sympy import MatMul, Mul
1672 
1673         parens = lambda x: self.parenthesize(x, precedence_traditional(expr),
1674                                              False)
1675 
1676         args = expr.args
1677         if isinstance(args[0], Mul):
1678             args = args[0].as_ordered_factors() + list(args[1:])
1679         else:
1680             args = list(args)
1681 
1682         if isinstance(expr, MatMul) and _coeff_isneg(expr):
1683             if args[0] == -1:
1684                 args = args[1:]
1685             else:
1686                 args[0] = -args[0]
1687             return '- ' + ' '.join(map(parens, args))
1688         else:
1689             return ' '.join(map(parens, args))
1690 
1691     def _print_Mod(self, expr, exp=None):
1692         if exp is not None:
1693             return r'\left(%s\bmod{%s}\right)^{%s}' % \
1694                 (self.parenthesize(expr.args[0], PRECEDENCE['Mul'],
1695                                    strict=True), self._print(expr.args[1]),
1696                  exp)
1697         return r'%s\bmod{%s}' % (self.parenthesize(expr.args[0],
1698                                  PRECEDENCE['Mul'], strict=True),
1699                                  self._print(expr.args[1]))
1700 
1701     def _print_HadamardProduct(self, expr):
1702         args = expr.args
1703         prec = PRECEDENCE['Pow']
1704         parens = self.parenthesize
1705 
1706         return r' \circ '.join(
1707             map(lambda arg: parens(arg, prec, strict=True), args))
1708 
1709     def _print_HadamardPower(self, expr):
1710         if precedence_traditional(expr.exp) < PRECEDENCE["Mul"]:
1711             template = r"%s^{\circ \left({%s}\right)}"
1712         else:
1713             template = r"%s^{\circ {%s}}"
1714         return self._helper_print_standard_power(expr, template)
1715 
1716     def _print_KroneckerProduct(self, expr):
1717         args = expr.args
1718         prec = PRECEDENCE['Pow']
1719         parens = self.parenthesize
1720 
1721         return r' \otimes '.join(
1722             map(lambda arg: parens(arg, prec, strict=True), args))
1723 
1724     def _print_MatPow(self, expr):
1725         base, exp = expr.base, expr.exp
1726         from sympy.matrices import MatrixSymbol
1727         if not isinstance(base, MatrixSymbol):
1728             return "\\left(%s\\right)^{%s}" % (self._print(base),
1729                                               self._print(exp))
1730         else:
1731             return "%s^{%s}" % (self._print(base), self._print(exp))
1732 
1733     def _print_MatrixSymbol(self, expr):
1734         return self._print_Symbol(expr, style=self._settings[
1735             'mat_symbol_style'])
1736 
1737     def _print_ZeroMatrix(self, Z):
1738         return r"\mathbb{0}" if self._settings[
1739             'mat_symbol_style'] == 'plain' else r"\mathbf{0}"
1740 
1741     def _print_OneMatrix(self, O):
1742         return r"\mathbb{1}" if self._settings[
1743             'mat_symbol_style'] == 'plain' else r"\mathbf{1}"
1744 
1745     def _print_Identity(self, I):
1746         return r"\mathbb{I}" if self._settings[
1747             'mat_symbol_style'] == 'plain' else r"\mathbf{I}"
1748 
1749     def _print_PermutationMatrix(self, P):
1750         perm_str = self._print(P.args[0])
1751         return "P_{%s}" % perm_str
1752 
1753     def _print_NDimArray(self, expr):
1754 
1755         if expr.rank() == 0:
1756             return self._print(expr[()])
1757 
1758         mat_str = self._settings['mat_str']
1759         if mat_str is None:
1760             if self._settings['mode'] == 'inline':
1761                 mat_str = 'smallmatrix'
1762             else:
1763                 if (expr.rank() == 0) or (expr.shape[-1] <= 10):
1764                     mat_str = 'matrix'
1765                 else:
1766                     mat_str = 'array'
1767         block_str = r'\begin{%MATSTR%}%s\end{%MATSTR%}'
1768         block_str = block_str.replace('%MATSTR%', mat_str)
1769         if self._settings['mat_delim']:
1770             left_delim = self._settings['mat_delim']
1771             right_delim = self._delim_dict[left_delim]
1772             block_str = r'\left' + left_delim + block_str + \
1773                         r'\right' + right_delim
1774 
1775         if expr.rank() == 0:
1776             return block_str % ""
1777 
1778         level_str = [[]] + [[] for i in range(expr.rank())]
1779         shape_ranges = [list(range(i)) for i in expr.shape]
1780         for outer_i in itertools.product(*shape_ranges):
1781             level_str[-1].append(self._print(expr[outer_i]))
1782             even = True
1783             for back_outer_i in range(expr.rank()-1, -1, -1):
1784                 if len(level_str[back_outer_i+1]) < expr.shape[back_outer_i]:
1785                     break
1786                 if even:
1787                     level_str[back_outer_i].append(
1788                         r" & ".join(level_str[back_outer_i+1]))
1789                 else:
1790                     level_str[back_outer_i].append(
1791                         block_str % (r"\\".join(level_str[back_outer_i+1])))
1792                     if len(level_str[back_outer_i+1]) == 1:
1793                         level_str[back_outer_i][-1] = r"\left[" + \
1794                             level_str[back_outer_i][-1] + r"\right]"
1795                 even = not even
1796                 level_str[back_outer_i+1] = []
1797 
1798         out_str = level_str[0][0]
1799 
1800         if expr.rank() % 2 == 1:
1801             out_str = block_str % out_str
1802 
1803         return out_str
1804 
1805     def _printer_tensor_indices(self, name, indices, index_map={}):
1806         out_str = self._print(name)
1807         last_valence = None
1808         prev_map = None
1809         for index in indices:
1810             new_valence = index.is_up
1811             if ((index in index_map) or prev_map) and \
1812                     last_valence == new_valence:
1813                 out_str += ","
1814             if last_valence != new_valence:
1815                 if last_valence is not None:
1816                     out_str += "}"
1817                 if index.is_up:
1818                     out_str += "{}^{"
1819                 else:
1820                     out_str += "{}_{"
1821             out_str += self._print(index.args[0])
1822             if index in index_map:
1823                 out_str += "="
1824                 out_str += self._print(index_map[index])
1825                 prev_map = True
1826             else:
1827                 prev_map = False
1828             last_valence = new_valence
1829         if last_valence is not None:
1830             out_str += "}"
1831         return out_str
1832 
1833     def _print_Tensor(self, expr):
1834         name = expr.args[0].args[0]
1835         indices = expr.get_indices()
1836         return self._printer_tensor_indices(name, indices)
1837 
1838     def _print_TensorElement(self, expr):
1839         name = expr.expr.args[0].args[0]
1840         indices = expr.expr.get_indices()
1841         index_map = expr.index_map
1842         return self._printer_tensor_indices(name, indices, index_map)
1843 
1844     def _print_TensMul(self, expr):
1845         # prints expressions like "A(a)", "3*A(a)", "(1+x)*A(a)"
1846         sign, args = expr._get_args_for_traditional_printer()
1847         return sign + "".join(
1848             [self.parenthesize(arg, precedence(expr)) for arg in args]
1849         )
1850 
1851     def _print_TensAdd(self, expr):
1852         a = []
1853         args = expr.args
1854         for x in args:
1855             a.append(self.parenthesize(x, precedence(expr)))
1856         a.sort()
1857         s = ' + '.join(a)
1858         s = s.replace('+ -', '- ')
1859         return s
1860 
1861     def _print_TensorIndex(self, expr):
1862         return "{}%s{%s}" % (
1863             "^" if expr.is_up else "_",
1864             self._print(expr.args[0])
1865         )
1866 
1867     def _print_PartialDerivative(self, expr):
1868         if len(expr.variables) == 1:
1869             return r"\frac{\partial}{\partial {%s}}{%s}" % (
1870                 self._print(expr.variables[0]),
1871                 self.parenthesize(expr.expr, PRECEDENCE["Mul"], False)
1872             )
1873         else:
1874             return r"\frac{\partial^{%s}}{%s}{%s}" % (
1875                 len(expr.variables),
1876                 " ".join([r"\partial {%s}" % self._print(i) for i in expr.variables]),
1877                 self.parenthesize(expr.expr, PRECEDENCE["Mul"], False)
1878             )
1879 
1880     def _print_UniversalSet(self, expr):
1881         return r"\mathbb{U}"
1882 
1883     def _print_frac(self, expr, exp=None):
1884         if exp is None:
1885             return r"\operatorname{frac}{\left(%s\right)}" % self._print(expr.args[0])
1886         else:
1887             return r"\operatorname{frac}{\left(%s\right)}^{%s}" % (
1888                     self._print(expr.args[0]), exp)
1889 
1890     def _print_tuple(self, expr):
1891         if self._settings['decimal_separator'] == 'comma':
1892             sep = ";"
1893         elif self._settings['decimal_separator'] == 'period':
1894             sep = ","
1895         else:
1896             raise ValueError('Unknown Decimal Separator')
1897 
1898         if len(expr) == 1:
1899             # 1-tuple needs a trailing separator
1900             return self._add_parens_lspace(self._print(expr[0]) + sep)
1901         else:
1902             return self._add_parens_lspace(
1903                 (sep + r" \  ").join([self._print(i) for i in expr]))
1904 
1905     def _print_TensorProduct(self, expr):
1906         elements = [self._print(a) for a in expr.args]
1907         return r' \otimes '.join(elements)
1908 
1909     def _print_WedgeProduct(self, expr):
1910         elements = [self._print(a) for a in expr.args]
1911         return r' \wedge '.join(elements)
1912 
1913     def _print_Tuple(self, expr):
1914         return self._print_tuple(expr)
1915 
1916     def _print_list(self, expr):
1917         if self._settings['decimal_separator'] == 'comma':
1918             return r"\left[ %s\right]" % \
1919                 r"; \  ".join([self._print(i) for i in expr])
1920         elif self._settings['decimal_separator'] == 'period':
1921             return r"\left[ %s\right]" % \
1922                 r", \  ".join([self._print(i) for i in expr])
1923         else:
1924             raise ValueError('Unknown Decimal Separator')
1925 
1926 
1927     def _print_dict(self, d):
1928         keys = sorted(d.keys(), key=default_sort_key)
1929         items = []
1930 
1931         for key in keys:
1932             val = d[key]
1933             items.append("%s : %s" % (self._print(key), self._print(val)))
1934 
1935         return r"\left\{ %s\right\}" % r", \  ".join(items)
1936 
1937     def _print_Dict(self, expr):
1938         return self._print_dict(expr)
1939 
1940     def _print_DiracDelta(self, expr, exp=None):
1941         if len(expr.args) == 1 or expr.args[1] == 0:
1942             tex = r"\delta\left(%s\right)" % self._print(expr.args[0])
1943         else:
1944             tex = r"\delta^{\left( %s \right)}\left( %s \right)" % (
1945                 self._print(expr.args[1]), self._print(expr.args[0]))
1946         if exp:
1947             tex = r"\left(%s\right)^{%s}" % (tex, exp)
1948         return tex
1949 
1950     def _print_SingularityFunction(self, expr):
1951         shift = self._print(expr.args[0] - expr.args[1])
1952         power = self._print(expr.args[2])
1953         tex = r"{\left\langle %s \right\rangle}^{%s}" % (shift, power)
1954         return tex
1955 
1956     def _print_Heaviside(self, expr, exp=None):
1957         tex = r"\theta\left(%s\right)" % self._print(expr.args[0])
1958         if exp:
1959             tex = r"\left(%s\right)^{%s}" % (tex, exp)
1960         return tex
1961 
1962     def _print_KroneckerDelta(self, expr, exp=None):
1963         i = self._print(expr.args[0])
1964         j = self._print(expr.args[1])
1965         if expr.args[0].is_Atom and expr.args[1].is_Atom:
1966             tex = r'\delta_{%s %s}' % (i, j)
1967         else:
1968             tex = r'\delta_{%s, %s}' % (i, j)
1969         if exp is not None:
1970             tex = r'\left(%s\right)^{%s}' % (tex, exp)
1971         return tex
1972 
1973     def _print_LeviCivita(self, expr, exp=None):
1974         indices = map(self._print, expr.args)
1975         if all(x.is_Atom for x in expr.args):
1976             tex = r'\varepsilon_{%s}' % " ".join(indices)
1977         else:
1978             tex = r'\varepsilon_{%s}' % ", ".join(indices)
1979         if exp:
1980             tex = r'\left(%s\right)^{%s}' % (tex, exp)
1981         return tex
1982 
1983     def _print_RandomDomain(self, d):
1984         if hasattr(d, 'as_boolean'):
1985             return '\\text{Domain: }' + self._print(d.as_boolean())
1986         elif hasattr(d, 'set'):
1987             return ('\\text{Domain: }' + self._print(d.symbols) + '\\text{ in }' +
1988                     self._print(d.set))
1989         elif hasattr(d, 'symbols'):
1990             return '\\text{Domain on }' + self._print(d.symbols)
1991         else:
1992             return self._print(None)
1993 
1994     def _print_FiniteSet(self, s):
1995         items = sorted(s.args, key=default_sort_key)
1996         return self._print_set(items)
1997 
1998     def _print_set(self, s):
1999         items = sorted(s, key=default_sort_key)
2000         if self._settings['decimal_separator'] == 'comma':
2001             items = "; ".join(map(self._print, items))
2002         elif self._settings['decimal_separator'] == 'period':
2003             items = ", ".join(map(self._print, items))
2004         else:
2005             raise ValueError('Unknown Decimal Separator')
2006         return r"\left\{%s\right\}" % items
2007 
2008 
2009     _print_frozenset = _print_set
2010 
2011     def _print_Range(self, s):
2012         dots = object()
2013 
2014         if s.has(Symbol):
2015             return self._print_Basic(s)
2016 
2017         if s.start.is_infinite and s.stop.is_infinite:
2018             if s.step.is_positive:
2019                 printset = dots, -1, 0, 1, dots
2020             else:
2021                 printset = dots, 1, 0, -1, dots
2022         elif s.start.is_infinite:
2023             printset = dots, s[-1] - s.step, s[-1]
2024         elif s.stop.is_infinite:
2025             it = iter(s)
2026             printset = next(it), next(it), dots
2027         elif len(s) > 4:
2028             it = iter(s)
2029             printset = next(it), next(it), dots, s[-1]
2030         else:
2031             printset = tuple(s)
2032 
2033         return (r"\left\{" +
2034                 r", ".join(self._print(el) if el is not dots else r'\ldots' for el in printset) +
2035                 r"\right\}")
2036 
2037     def __print_number_polynomial(self, expr, letter, exp=None):
2038         if len(expr.args) == 2:
2039             if exp is not None:
2040                 return r"%s_{%s}^{%s}\left(%s\right)" % (letter,
2041                             self._print(expr.args[0]), exp,
2042                             self._print(expr.args[1]))
2043             return r"%s_{%s}\left(%s\right)" % (letter,
2044                         self._print(expr.args[0]), self._print(expr.args[1]))
2045 
2046         tex = r"%s_{%s}" % (letter, self._print(expr.args[0]))
2047         if exp is not None:
2048             tex = r"%s^{%s}" % (tex, exp)
2049         return tex
2050 
2051     def _print_bernoulli(self, expr, exp=None):
2052         return self.__print_number_polynomial(expr, "B", exp)
2053 
2054     def _print_bell(self, expr, exp=None):
2055         if len(expr.args) == 3:
2056             tex1 = r"B_{%s, %s}" % (self._print(expr.args[0]),
2057                                 self._print(expr.args[1]))
2058             tex2 = r"\left(%s\right)" % r", ".join(self._print(el) for
2059                                                el in expr.args[2])
2060             if exp is not None:
2061                 tex = r"%s^{%s}%s" % (tex1, exp, tex2)
2062             else:
2063                 tex = tex1 + tex2
2064             return tex
2065         return self.__print_number_polynomial(expr, "B", exp)
2066 
2067 
2068     def _print_fibonacci(self, expr, exp=None):
2069         return self.__print_number_polynomial(expr, "F", exp)
2070 
2071     def _print_lucas(self, expr, exp=None):
2072         tex = r"L_{%s}" % self._print(expr.args[0])
2073         if exp is not None:
2074             tex = r"%s^{%s}" % (tex, exp)
2075         return tex
2076 
2077     def _print_tribonacci(self, expr, exp=None):
2078         return self.__print_number_polynomial(expr, "T", exp)
2079 
2080     def _print_SeqFormula(self, s):
2081         dots = object()
2082         if len(s.start.free_symbols) > 0 or len(s.stop.free_symbols) > 0:
2083             return r"\left\{%s\right\}_{%s=%s}^{%s}" % (
2084                 self._print(s.formula),
2085                 self._print(s.variables[0]),
2086                 self._print(s.start),
2087                 self._print(s.stop)
2088             )
2089         if s.start is S.NegativeInfinity:
2090             stop = s.stop
2091             printset = (dots, s.coeff(stop - 3), s.coeff(stop - 2),
2092                         s.coeff(stop - 1), s.coeff(stop))
2093         elif s.stop is S.Infinity or s.length > 4:
2094             printset = s[:4]
2095             printset.append(dots)
2096         else:
2097             printset = tuple(s)
2098 
2099         return (r"\left[" +
2100                 r", ".join(self._print(el) if el is not dots else r'\ldots' for el in printset) +
2101                 r"\right]")
2102 
2103     _print_SeqPer = _print_SeqFormula
2104     _print_SeqAdd = _print_SeqFormula
2105     _print_SeqMul = _print_SeqFormula
2106 
2107     def _print_Interval(self, i):
2108         if i.start == i.end:
2109             return r"\left\{%s\right\}" % self._print(i.start)
2110 
2111         else:
2112             if i.left_open:
2113                 left = '('
2114             else:
2115                 left = '['
2116 
2117             if i.right_open:
2118                 right = ')'
2119             else:
2120                 right = ']'
2121 
2122             return r"\left%s%s, %s\right%s" % \
2123                    (left, self._print(i.start), self._print(i.end), right)
2124 
2125     def _print_AccumulationBounds(self, i):
2126         return r"\left\langle %s, %s\right\rangle" % \
2127                 (self._print(i.min), self._print(i.max))
2128 
2129     def _print_Union(self, u):
2130         prec = precedence_traditional(u)
2131         args_str = [self.parenthesize(i, prec) for i in u.args]
2132         return r" \cup ".join(args_str)
2133 
2134     def _print_Complement(self, u):
2135         prec = precedence_traditional(u)
2136         args_str = [self.parenthesize(i, prec) for i in u.args]
2137         return r" \setminus ".join(args_str)
2138 
2139     def _print_Intersection(self, u):
2140         prec = precedence_traditional(u)
2141         args_str = [self.parenthesize(i, prec) for i in u.args]
2142         return r" \cap ".join(args_str)
2143 
2144     def _print_SymmetricDifference(self, u):
2145         prec = precedence_traditional(u)
2146         args_str = [self.parenthesize(i, prec) for i in u.args]
2147         return r" \triangle ".join(args_str)
2148 
2149     def _print_ProductSet(self, p):
2150         prec = precedence_traditional(p)
2151         if len(p.sets) >= 1 and not has_variety(p.sets):
2152             return self.parenthesize(p.sets[0], prec) + "^{%d}" % len(p.sets)
2153         return r" \times ".join(
2154             self.parenthesize(set, prec) for set in p.sets)
2155 
2156     def _print_EmptySet(self, e):
2157         return r"\emptyset"
2158 
2159     def _print_Naturals(self, n):
2160         return r"\mathbb{N}"
2161 
2162     def _print_Naturals0(self, n):
2163         return r"\mathbb{N}_0"
2164 
2165     def _print_Integers(self, i):
2166         return r"\mathbb{Z}"
2167 
2168     def _print_Rationals(self, i):
2169         return r"\mathbb{Q}"
2170 
2171     def _print_Reals(self, i):
2172         return r"\mathbb{R}"
2173 
2174     def _print_Complexes(self, i):
2175         return r"\mathbb{C}"
2176 
2177     def _print_ImageSet(self, s):
2178         expr = s.lamda.expr
2179         sig = s.lamda.signature
2180         xys = ((self._print(x), self._print(y)) for x, y in zip(sig, s.base_sets))
2181         xinys = r" , ".join(r"%s \in %s" % xy for xy in xys)
2182         return r"\left\{%s\; |\; %s\right\}" % (self._print(expr), xinys)
2183 
2184     def _print_ConditionSet(self, s):
2185         vars_print = ', '.join([self._print(var) for var in Tuple(s.sym)])
2186         if s.base_set is S.UniversalSet:
2187             return r"\left\{%s \mid %s \right\}" % \
2188                 (vars_print, self._print(s.condition))
2189 
2190         return r"\left\{%s \mid %s \in %s \wedge %s \right\}" % (
2191             vars_print,
2192             vars_print,
2193             self._print(s.base_set),
2194             self._print(s.condition))
2195 
2196     def _print_ComplexRegion(self, s):
2197         vars_print = ', '.join([self._print(var) for var in s.variables])
2198         return r"\left\{%s\; |\; %s \in %s \right\}" % (
2199             self._print(s.expr),
2200             vars_print,
2201             self._print(s.sets))
2202 
2203     def _print_Contains(self, e):
2204         return r"%s \in %s" % tuple(self._print(a) for a in e.args)
2205 
2206     def _print_FourierSeries(self, s):
2207         return self._print_Add(s.truncate()) + r' + \ldots'
2208 
2209     def _print_FormalPowerSeries(self, s):
2210         return self._print_Add(s.infinite)
2211 
2212     def _print_FiniteField(self, expr):
2213         return r"\mathbb{F}_{%s}" % expr.mod
2214 
2215     def _print_IntegerRing(self, expr):
2216         return r"\mathbb{Z}"
2217 
2218     def _print_RationalField(self, expr):
2219         return r"\mathbb{Q}"
2220 
2221     def _print_RealField(self, expr):
2222         return r"\mathbb{R}"
2223 
2224     def _print_ComplexField(self, expr):
2225         return r"\mathbb{C}"
2226 
2227     def _print_PolynomialRing(self, expr):
2228         domain = self._print(expr.domain)
2229         symbols = ", ".join(map(self._print, expr.symbols))
2230         return r"%s\left[%s\right]" % (domain, symbols)
2231 
2232     def _print_FractionField(self, expr):
2233         domain = self._print(expr.domain)
2234         symbols = ", ".join(map(self._print, expr.symbols))
2235         return r"%s\left(%s\right)" % (domain, symbols)
2236 
2237     def _print_PolynomialRingBase(self, expr):
2238         domain = self._print(expr.domain)
2239         symbols = ", ".join(map(self._print, expr.symbols))
2240         inv = ""
2241         if not expr.is_Poly:
2242             inv = r"S_<^{-1}"
2243         return r"%s%s\left[%s\right]" % (inv, domain, symbols)
2244 
2245     def _print_Poly(self, poly):
2246         cls = poly.__class__.__name__
2247         terms = []
2248         for monom, coeff in poly.terms():
2249             s_monom = ''
2250             for i, exp in enumerate(monom):
2251                 if exp > 0:
2252                     if exp == 1:
2253                         s_monom += self._print(poly.gens[i])
2254                     else:
2255                         s_monom += self._print(pow(poly.gens[i], exp))
2256 
2257             if coeff.is_Add:
2258                 if s_monom:
2259                     s_coeff = r"\left(%s\right)" % self._print(coeff)
2260                 else:
2261                     s_coeff = self._print(coeff)
2262             else:
2263                 if s_monom:
2264                     if coeff is S.One:
2265                         terms.extend(['+', s_monom])
2266                         continue
2267 
2268                     if coeff is S.NegativeOne:
2269                         terms.extend(['-', s_monom])
2270                         continue
2271 
2272                 s_coeff = self._print(coeff)
2273 
2274             if not s_monom:
2275                 s_term = s_coeff
2276             else:
2277                 s_term = s_coeff + " " + s_monom
2278 
2279             if s_term.startswith('-'):
2280                 terms.extend(['-', s_term[1:]])
2281             else:
2282                 terms.extend(['+', s_term])
2283 
2284         if terms[0] in ['-', '+']:
2285             modifier = terms.pop(0)
2286 
2287             if modifier == '-':
2288                 terms[0] = '-' + terms[0]
2289 
2290         expr = ' '.join(terms)
2291         gens = list(map(self._print, poly.gens))
2292         domain = "domain=%s" % self._print(poly.get_domain())
2293 
2294         args = ", ".join([expr] + gens + [domain])
2295         if cls in accepted_latex_functions:
2296             tex = r"\%s {\left(%s \right)}" % (cls, args)
2297         else:
2298             tex = r"\operatorname{%s}{\left( %s \right)}" % (cls, args)
2299 
2300         return tex
2301 
2302     def _print_ComplexRootOf(self, root):
2303         cls = root.__class__.__name__
2304         if cls == "ComplexRootOf":
2305             cls = "CRootOf"
2306         expr = self._print(root.expr)
2307         index = root.index
2308         if cls in accepted_latex_functions:
2309             return r"\%s {\left(%s, %d\right)}" % (cls, expr, index)
2310         else:
2311             return r"\operatorname{%s} {\left(%s, %d\right)}" % (cls, expr,
2312                                                                  index)
2313 
2314     def _print_RootSum(self, expr):
2315         cls = expr.__class__.__name__
2316         args = [self._print(expr.expr)]
2317 
2318         if expr.fun is not S.IdentityFunction:
2319             args.append(self._print(expr.fun))
2320 
2321         if cls in accepted_latex_functions:
2322             return r"\%s {\left(%s\right)}" % (cls, ", ".join(args))
2323         else:
2324             return r"\operatorname{%s} {\left(%s\right)}" % (cls,
2325                                                              ", ".join(args))
2326 
2327     def _print_PolyElement(self, poly):
2328         mul_symbol = self._settings['mul_symbol_latex']
2329         return poly.str(self, PRECEDENCE, "{%s}^{%d}", mul_symbol)
2330 
2331     def _print_FracElement(self, frac):
2332         if frac.denom == 1:
2333             return self._print(frac.numer)
2334         else:
2335             numer = self._print(frac.numer)
2336             denom = self._print(frac.denom)
2337             return r"\frac{%s}{%s}" % (numer, denom)
2338 
2339     def _print_euler(self, expr, exp=None):
2340         m, x = (expr.args[0], None) if len(expr.args) == 1 else expr.args
2341         tex = r"E_{%s}" % self._print(m)
2342         if exp is not None:
2343             tex = r"%s^{%s}" % (tex, exp)
2344         if x is not None:
2345             tex = r"%s\left(%s\right)" % (tex, self._print(x))
2346         return tex
2347 
2348     def _print_catalan(self, expr, exp=None):
2349         tex = r"C_{%s}" % self._print(expr.args[0])
2350         if exp is not None:
2351             tex = r"%s^{%s}" % (tex, exp)
2352         return tex
2353 
2354     def _print_UnifiedTransform(self, expr, s, inverse=False):
2355         return r"\mathcal{{{}}}{}_{{{}}}\left[{}\right]\left({}\right)".format(s, '^{-1}' if inverse else '', self._print(expr.args[1]), self._print(expr.args[0]), self._print(expr.args[2]))
2356 
2357     def _print_MellinTransform(self, expr):
2358         return self._print_UnifiedTransform(expr, 'M')
2359 
2360     def _print_InverseMellinTransform(self, expr):
2361         return self._print_UnifiedTransform(expr, 'M', True)
2362 
2363     def _print_LaplaceTransform(self, expr):
2364         return self._print_UnifiedTransform(expr, 'L')
2365 
2366     def _print_InverseLaplaceTransform(self, expr):
2367         return self._print_UnifiedTransform(expr, 'L', True)
2368 
2369     def _print_FourierTransform(self, expr):
2370         return self._print_UnifiedTransform(expr, 'F')
2371 
2372     def _print_InverseFourierTransform(self, expr):
2373         return self._print_UnifiedTransform(expr, 'F', True)
2374 
2375     def _print_SineTransform(self, expr):
2376         return self._print_UnifiedTransform(expr, 'SIN')
2377 
2378     def _print_InverseSineTransform(self, expr):
2379         return self._print_UnifiedTransform(expr, 'SIN', True)
2380 
2381     def _print_CosineTransform(self, expr):
2382         return self._print_UnifiedTransform(expr, 'COS')
2383 
2384     def _print_InverseCosineTransform(self, expr):
2385         return self._print_UnifiedTransform(expr, 'COS', True)
2386 
2387     def _print_DMP(self, p):
2388         try:
2389             if p.ring is not None:
2390                 # TODO incorporate order
2391                 return self._print(p.ring.to_sympy(p))
2392         except SympifyError:
2393             pass
2394         return self._print(repr(p))
2395 
2396     def _print_DMF(self, p):
2397         return self._print_DMP(p)
2398 
2399     def _print_Object(self, object):
2400         return self._print(Symbol(object.name))
2401 
2402     def _print_LambertW(self, expr):
2403         if len(expr.args) == 1:
2404             return r"W\left(%s\right)" % self._print(expr.args[0])
2405         return r"W_{%s}\left(%s\right)" % \
2406             (self._print(expr.args[1]), self._print(expr.args[0]))
2407 
2408     def _print_Morphism(self, morphism):
2409         domain = self._print(morphism.domain)
2410         codomain = self._print(morphism.codomain)
2411         return "%s\\rightarrow %s" % (domain, codomain)
2412 
2413     def _print_TransferFunction(self, expr):
2414         from sympy.core import Mul, Pow
2415         num, den = expr.num, expr.den
2416         res = Mul(num, Pow(den, -1, evaluate=False), evaluate=False)
2417         return self._print_Mul(res)
2418 
2419     def _print_Series(self, expr):
2420         args = list(expr.args)
2421         parens = lambda x: self.parenthesize(x, precedence_traditional(expr),
2422                                              False)
2423         return ' '.join(map(parens, args))
2424 
2425     def _print_Parallel(self, expr):
2426         args = list(expr.args)
2427         parens = lambda x: self.parenthesize(x, precedence_traditional(expr),
2428                                              False)
2429         return ' '.join(map(parens, args))
2430 
2431     def _print_Feedback(self, expr):
2432         from sympy.physics.control import TransferFunction, Parallel, Series
2433 
2434         num, tf = expr.num, TransferFunction(1, 1, expr.num.var)
2435         num_arg_list = list(num.args) if isinstance(num, Series) else [num]
2436         den_arg_list = list(expr.den.args) if isinstance(expr.den, Series) else [expr.den]
2437 
2438         if isinstance(num, Series) and isinstance(expr.den, Series):
2439             den = Parallel(tf, Series(*num_arg_list, *den_arg_list))
2440         elif isinstance(num, Series) and isinstance(expr.den, TransferFunction):
2441             if expr.den == tf:
2442                 den = Parallel(tf, Series(*num_arg_list))
2443             else:
2444                 den = Parallel(tf, Series(*num_arg_list, expr.den))
2445         elif isinstance(num, TransferFunction) and isinstance(expr.den, Series):
2446             if num == tf:
2447                 den = Parallel(tf, Series(*den_arg_list))
2448             else:
2449                 den = Parallel(tf, Series(num, *den_arg_list))
2450         else:
2451             if num == tf:
2452                 den = Parallel(tf, *den_arg_list)
2453             elif expr.den == tf:
2454                 den = Parallel(tf, *num_arg_list)
2455             else:
2456                 den = Parallel(tf, Series(*num_arg_list, *den_arg_list))
2457 
2458         numer = self._print(num)
2459         denom = self._print(den)
2460         return r"\frac{%s}{%s}" % (numer, denom)
2461 
2462     def _print_NamedMorphism(self, morphism):
2463         pretty_name = self._print(Symbol(morphism.name))
2464         pretty_morphism = self._print_Morphism(morphism)
2465         return "%s:%s" % (pretty_name, pretty_morphism)
2466 
2467     def _print_IdentityMorphism(self, morphism):
2468         from sympy.categories import NamedMorphism
2469         return self._print_NamedMorphism(NamedMorphism(
2470             morphism.domain, morphism.codomain, "id"))
2471 
2472     def _print_CompositeMorphism(self, morphism):
2473         # All components of the morphism have names and it is thus
2474         # possible to build the name of the composite.
2475         component_names_list = [self._print(Symbol(component.name)) for
2476                                 component in morphism.components]
2477         component_names_list.reverse()
2478         component_names = "\\circ ".join(component_names_list) + ":"
2479 
2480         pretty_morphism = self._print_Morphism(morphism)
2481         return component_names + pretty_morphism
2482 
2483     def _print_Category(self, morphism):
2484         return r"\mathbf{{{}}}".format(self._print(Symbol(morphism.name)))
2485 
2486     def _print_Diagram(self, diagram):
2487         if not diagram.premises:
2488             # This is an empty diagram.
2489             return self._print(S.EmptySet)
2490 
2491         latex_result = self._print(diagram.premises)
2492         if diagram.conclusions:
2493             latex_result += "\\Longrightarrow %s" % \
2494                             self._print(diagram.conclusions)
2495 
2496         return latex_result
2497 
2498     def _print_DiagramGrid(self, grid):
2499         latex_result = "\\begin{array}{%s}\n" % ("c" * grid.width)
2500 
2501         for i in range(grid.height):
2502             for j in range(grid.width):
2503                 if grid[i, j]:
2504                     latex_result += latex(grid[i, j])
2505                 latex_result += " "
2506                 if j != grid.width - 1:
2507                     latex_result += "& "
2508 
2509             if i != grid.height - 1:
2510                 latex_result += "\\\\"
2511             latex_result += "\n"
2512 
2513         latex_result += "\\end{array}\n"
2514         return latex_result
2515 
2516     def _print_FreeModule(self, M):
2517         return '{{{}}}^{{{}}}'.format(self._print(M.ring), self._print(M.rank))
2518 
2519     def _print_FreeModuleElement(self, m):
2520         # Print as row vector for convenience, for now.
2521         return r"\left[ {} \right]".format(",".join(
2522             '{' + self._print(x) + '}' for x in m))
2523 
2524     def _print_SubModule(self, m):
2525         return r"\left\langle {} \right\rangle".format(",".join(
2526             '{' + self._print(x) + '}' for x in m.gens))
2527 
2528     def _print_ModuleImplementedIdeal(self, m):
2529         return r"\left\langle {} \right\rangle".format(",".join(
2530             '{' + self._print(x) + '}' for [x] in m._module.gens))
2531 
2532     def _print_Quaternion(self, expr):
2533         # TODO: This expression is potentially confusing,
2534         # shall we print it as `Quaternion( ... )`?
2535         s = [self.parenthesize(i, PRECEDENCE["Mul"], strict=True)
2536              for i in expr.args]
2537         a = [s[0]] + [i+" "+j for i, j in zip(s[1:], "ijk")]
2538         return " + ".join(a)
2539 
2540     def _print_QuotientRing(self, R):
2541         # TODO nicer fractions for few generators...
2542         return r"\frac{{{}}}{{{}}}".format(self._print(R.ring),
2543                  self._print(R.base_ideal))
2544 
2545     def _print_QuotientRingElement(self, x):
2546         return r"{{{}}} + {{{}}}".format(self._print(x.data),
2547                  self._print(x.ring.base_ideal))
2548 
2549     def _print_QuotientModuleElement(self, m):
2550         return r"{{{}}} + {{{}}}".format(self._print(m.data),
2551                  self._print(m.module.killed_module))
2552 
2553     def _print_QuotientModule(self, M):
2554         # TODO nicer fractions for few generators...
2555         return r"\frac{{{}}}{{{}}}".format(self._print(M.base),
2556                  self._print(M.killed_module))
2557 
2558     def _print_MatrixHomomorphism(self, h):
2559         return r"{{{}}} : {{{}}} \to {{{}}}".format(self._print(h._sympy_matrix()),
2560             self._print(h.domain), self._print(h.codomain))
2561 
2562     def _print_Manifold(self, manifold):
2563         string = manifold.name.name
2564         if '{' in string:
2565             name, supers, subs = string, [], []
2566         else:
2567             name, supers, subs = split_super_sub(string)
2568 
2569             name = translate(name)
2570             supers = [translate(sup) for sup in supers]
2571             subs = [translate(sub) for sub in subs]
2572 
2573         name = r'\text{%s}' % name
2574         if supers:
2575             name += "^{%s}" % " ".join(supers)
2576         if subs:
2577             name += "_{%s}" % " ".join(subs)
2578 
2579         return name
2580 
2581     def _print_Patch(self, patch):
2582         return r'\text{%s}_{%s}' % (self._print(patch.name), self._print(patch.manifold))
2583 
2584     def _print_CoordSystem(self, coordsys):
2585         return r'\text{%s}^{\text{%s}}_{%s}' % (
2586             self._print(coordsys.name), self._print(coordsys.patch.name), self._print(coordsys.manifold)
2587         )
2588 
2589     def _print_CovarDerivativeOp(self, cvd):
2590         return r'\mathbb{\nabla}_{%s}' % self._print(cvd._wrt)
2591 
2592     def _print_BaseScalarField(self, field):
2593         string = field._coord_sys.symbols[field._index].name
2594         return r'\mathbf{{{}}}'.format(self._print(Symbol(string)))
2595 
2596     def _print_BaseVectorField(self, field):
2597         string = field._coord_sys.symbols[field._index].name
2598         return r'\partial_{{{}}}'.format(self._print(Symbol(string)))
2599 
2600     def _print_Differential(self, diff):
2601         field = diff._form_field
2602         if hasattr(field, '_coord_sys'):
2603             string = field._coord_sys.symbols[field._index].name
2604             return r'\operatorname{{d}}{}'.format(self._print(Symbol(string)))
2605         else:
2606             string = self._print(field)
2607             return r'\operatorname{{d}}\left({}\right)'.format(string)
2608 
2609     def _print_Tr(self, p):
2610         # TODO: Handle indices
2611         contents = self._print(p.args[0])
2612         return r'\operatorname{{tr}}\left({}\right)'.format(contents)
2613 
2614     def _print_totient(self, expr, exp=None):
2615         if exp is not None:
2616             return r'\left(\phi\left(%s\right)\right)^{%s}' % \
2617                 (self._print(expr.args[0]), exp)
2618         return r'\phi\left(%s\right)' % self._print(expr.args[0])
2619 
2620     def _print_reduced_totient(self, expr, exp=None):
2621         if exp is not None:
2622             return r'\left(\lambda\left(%s\right)\right)^{%s}' % \
2623                 (self._print(expr.args[0]), exp)
2624         return r'\lambda\left(%s\right)' % self._print(expr.args[0])
2625 
2626     def _print_divisor_sigma(self, expr, exp=None):
2627         if len(expr.args) == 2:
2628             tex = r"_%s\left(%s\right)" % tuple(map(self._print,
2629                                                 (expr.args[1], expr.args[0])))
2630         else:
2631             tex = r"\left(%s\right)" % self._print(expr.args[0])
2632         if exp is not None:
2633             return r"\sigma^{%s}%s" % (exp, tex)
2634         return r"\sigma%s" % tex
2635 
2636     def _print_udivisor_sigma(self, expr, exp=None):
2637         if len(expr.args) == 2:
2638             tex = r"_%s\left(%s\right)" % tuple(map(self._print,
2639                                                 (expr.args[1], expr.args[0])))
2640         else:
2641             tex = r"\left(%s\right)" % self._print(expr.args[0])
2642         if exp is not None:
2643             return r"\sigma^*^{%s}%s" % (exp, tex)
2644         return r"\sigma^*%s" % tex
2645 
2646     def _print_primenu(self, expr, exp=None):
2647         if exp is not None:
2648             return r'\left(\nu\left(%s\right)\right)^{%s}' % \
2649                 (self._print(expr.args[0]), exp)
2650         return r'\nu\left(%s\right)' % self._print(expr.args[0])
2651 
2652     def _print_primeomega(self, expr, exp=None):
2653         if exp is not None:
2654             return r'\left(\Omega\left(%s\right)\right)^{%s}' % \
2655                 (self._print(expr.args[0]), exp)
2656         return r'\Omega\left(%s\right)' % self._print(expr.args[0])
2657 
2658     def _print_Str(self, s):
2659         return str(s.name)
2660 
2661     def _print_float(self, expr):
2662         return self._print(Float(expr))
2663 
2664     def _print_int(self, expr):
2665         return str(expr)
2666 
2667     def _print_mpz(self, expr):
2668         return str(expr)
2669 
2670     def _print_mpq(self, expr):
2671         return str(expr)
2672 
2673     def emptyPrinter(self, expr):
2674         # default to just printing as monospace, like would normally be shown
2675         s = super().emptyPrinter(expr)
2676 
2677         return r"\mathtt{\text{%s}}" % latex_escape(s)

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>, <file>sympy/printing/latex.py</file>
<class>LatexPrinter</class>
<method>_print_Mul</method>
<code>
498     def _print_Mul(self, expr):
499         from sympy.core.power import Pow
500         from sympy.physics.units import Quantity
501         from sympy.simplify import fraction
502         separator = self._settings['mul_symbol_latex']
503         numbersep = self._settings['mul_symbol_latex_numbers']
504 
505         def convert(expr):
506             if not expr.is_Mul:
507                 return str(self._print(expr))
508             else:
509                 if self.order not in ('old', 'none'):
510                     args = expr.as_ordered_factors()
511                 else:
512                     args = list(expr.args)
513 
514                 # If quantities are present append them at the back
515                 args = sorted(args, key=lambda x: isinstance(x, Quantity) or
516                               (isinstance(x, Pow) and
517                                isinstance(x.base, Quantity)))
518 
519                 return convert_args(args)
520 
521         def convert_args(args):
522                 _tex = last_term_tex = ""
523 
524                 for i, term in enumerate(args):
525                     term_tex = self._print(term)
526 
527                     if self._needs_mul_brackets(term, first=(i == 0),
528                                                 last=(i == len(args) - 1)):
529                         term_tex = r"\left(%s\right)" % term_tex
530 
531                     if _between_two_numbers_p[0].search(last_term_tex) and \
532                             _between_two_numbers_p[1].match(term_tex):
533                         # between two numbers
534                         _tex += numbersep
535                     elif _tex:
536                         _tex += separator
537 
538                     _tex += term_tex
539                     last_term_tex = term_tex
540                 return _tex
541 
542         # Check for unevaluated Mul. In this case we need to make sure the
543         # identities are visible, multiple Rational factors are not combined
544         # etc so we display in a straight-forward form that fully preserves all
545         # args and their order.
546         # XXX: _print_Pow calls this routine with instances of Pow...
547         if isinstance(expr, Mul):
548             args = expr.args
549             if args[0] is S.One or any(isinstance(arg, Number) for arg in args[1:]):
550                 return convert_args(args)
551 
552         include_parens = False
553         if _coeff_isneg(expr):
554             expr = -expr
555             tex = "- "
556             if expr.is_Add:
557                 tex += "("
558                 include_parens = True
559         else:
560             tex = ""
561 
562         numer, denom = fraction(expr, exact=True)
563 
564         if denom is S.One and Pow(1, -1, evaluate=False) not in expr.args:
565             # use the original expression here, since fraction() may have
566             # altered it when producing numer and denom
567             tex += convert(expr)
568 
569         else:
570             snumer = convert(numer)
571             sdenom = convert(denom)
572             ldenom = len(sdenom.split())
573             ratio = self._settings['long_frac_ratio']
574             if self._settings['fold_short_frac'] and ldenom <= 2 and \
575                     "^" not in sdenom:
576                 # handle short fractions
577                 if self._needs_mul_brackets(numer, last=False):
578                     tex += r"\left(%s\right) / %s" % (snumer, sdenom)
579                 else:
580                     tex += r"%s / %s" % (snumer, sdenom)
581             elif ratio is not None and \
582                     len(snumer.split()) > ratio*ldenom:
583                 # handle long fractions
584                 if self._needs_mul_brackets(numer, last=True):
585                     tex += r"\frac{1}{%s}%s\left(%s\right)" \
586                         % (sdenom, separator, snumer)
587                 elif numer.is_Mul:
588                     # split a long numerator
589                     a = S.One
590                     b = S.One
591                     for x in numer.args:
592                         if self._needs_mul_brackets(x, last=False) or \
593                                 len(convert(a*x).split()) > ratio*ldenom or \
594                                 (b.is_commutative is x.is_commutative is False):
595                             b *= x
596                         else:
597                             a *= x
598                     if self._needs_mul_brackets(b, last=True):
599                         tex += r"\frac{%s}{%s}%s\left(%s\right)" \
600                             % (convert(a), sdenom, separator, convert(b))
601                     else:
602                         tex += r"\frac{%s}{%s}%s%s" \
603                             % (convert(a), sdenom, separator, convert(b))
604                 else:
605                     tex += r"\frac{1}{%s}%s%s" % (sdenom, separator, snumer)
606             else:
607                 tex += r"\frac{%s}{%s}" % (snumer, sdenom)
608 
609         if include_parens:
610             tex += ")"
611         return tex

</code><intended_behavior>The `_print_Mul` method may need adjustments to ensure that it can correctly handle and format the multiplication expressions especially arising from the conversion of `Pow` types that represent reciprocal or negative powers. Given the `RecursionError`, a potential solution involves implementing checks or mechanisms that prevent unnecessary or erroneous recursion when dealing with `Pow` expressions formatted by `_print_Pow`. Any fix here must seamlessly integrate with the handling of different types of multiplication expressions, maintaining the method's general utility while ensuring correct output for cases that previously led to errors.</intended_behavior>, <file>sympy/printing/latex.py</file>
<class>LatexPrinter</class>
<method>None</method>
<code>
137 class LatexPrinter(Printer):
138     printmethod = "_latex"
139 
140     _default_settings = {
141         "full_prec": False,
142         "fold_frac_powers": False,
143         "fold_func_brackets": False,
144         "fold_short_frac": None,
145         "inv_trig_style": "abbreviated",
146         "itex": False,
147         "ln_notation": False,
148         "long_frac_ratio": None,
149         "mat_delim": "[",
150         "mat_str": None,
151         "mode": "plain",
152         "mul_symbol": None,
153         "order": None,
154         "symbol_names": {},
155         "root_notation": True,
156         "mat_symbol_style": "plain",
157         "imaginary_unit": "i",
158         "gothic_re_im": False,
159         "decimal_separator": "period",
160         "perm_cyclic": True,
161         "parenthesize_super": True,
162         "min": None,
163         "max": None,
164     }  # type: Dict[str, Any]
165 
166     def __init__(self, settings=None):
167         Printer.__init__(self, settings)
168 
169         if 'mode' in self._settings:
170             valid_modes = ['inline', 'plain', 'equation',
171                            'equation*']
172             if self._settings['mode'] not in valid_modes:
173                 raise ValueError("'mode' must be one of 'inline', 'plain', "
174                                  "'equation' or 'equation*'")
175 
176         if self._settings['fold_short_frac'] is None and \
177                 self._settings['mode'] == 'inline':
178             self._settings['fold_short_frac'] = True
179 
180         mul_symbol_table = {
181             None: r" ",
182             "ldot": r" \,.\, ",
183             "dot": r" \cdot ",
184             "times": r" \times "
185         }
186         try:
187             self._settings['mul_symbol_latex'] = \
188                 mul_symbol_table[self._settings['mul_symbol']]
189         except KeyError:
190             self._settings['mul_symbol_latex'] = \
191                 self._settings['mul_symbol']
192         try:
193             self._settings['mul_symbol_latex_numbers'] = \
194                 mul_symbol_table[self._settings['mul_symbol'] or 'dot']
195         except KeyError:
196             if (self._settings['mul_symbol'].strip() in
197                     ['', ' ', '\\', '\\,', '\\:', '\\;', '\\quad']):
198                 self._settings['mul_symbol_latex_numbers'] = \
199                     mul_symbol_table['dot']
200             else:
201                 self._settings['mul_symbol_latex_numbers'] = \
202                     self._settings['mul_symbol']
203 
204         self._delim_dict = {'(': ')', '[': ']'}
205 
206         imaginary_unit_table = {
207             None: r"i",
208             "i": r"i",
209             "ri": r"\mathrm{i}",
210             "ti": r"\text{i}",
211             "j": r"j",
212             "rj": r"\mathrm{j}",
213             "tj": r"\text{j}",
214         }
215         try:
216             self._settings['imaginary_unit_latex'] = \
217                 imaginary_unit_table[self._settings['imaginary_unit']]
218         except KeyError:
219             self._settings['imaginary_unit_latex'] = \
220                 self._settings['imaginary_unit']
221 
222     def _add_parens(self, s):
223         return r"\left({}\right)".format(s)
224 
225     # TODO: merge this with the above, which requires a lot of test changes
226     def _add_parens_lspace(self, s):
227         return r"\left( {}\right)".format(s)
228 
229     def parenthesize(self, item, level, is_neg=False, strict=False):
230         prec_val = precedence_traditional(item)
231         if is_neg and strict:
232             return self._add_parens(self._print(item))
233 
234         if (prec_val < level) or ((not strict) and prec_val <= level):
235             return self._add_parens(self._print(item))
236         else:
237             return self._print(item)
238 
239     def parenthesize_super(self, s):
240         """
241         Protect superscripts in s
242 
243         If the parenthesize_super option is set, protect with parentheses, else
244         wrap in braces.
245         """
246         if "^" in s:
247             if self._settings['parenthesize_super']:
248                 return self._add_parens(s)
249             else:
250                 return "{{{}}}".format(s)
251         return s
252 
253     def doprint(self, expr):
254         tex = Printer.doprint(self, expr)
255 
256         if self._settings['mode'] == 'plain':
257             return tex
258         elif self._settings['mode'] == 'inline':
259             return r"$%s$" % tex
260         elif self._settings['itex']:
261             return r"$$%s$$" % tex
262         else:
263             env_str = self._settings['mode']
264             return r"\begin{%s}%s\end{%s}" % (env_str, tex, env_str)
265 
266     def _needs_brackets(self, expr):
267         """
268         Returns True if the expression needs to be wrapped in brackets when
269         printed, False otherwise. For example: a + b => True; a => False;
270         10 => False; -10 => True.
271         """
272         return not ((expr.is_Integer and expr.is_nonnegative)
273                     or (expr.is_Atom and (expr is not S.NegativeOne
274                                           and expr.is_Rational is False)))
275 
276     def _needs_function_brackets(self, expr):
277         """
278         Returns True if the expression needs to be wrapped in brackets when
279         passed as an argument to a function, False otherwise. This is a more
280         liberal version of _needs_brackets, in that many expressions which need
281         to be wrapped in brackets when added/subtracted/raised to a power do
282         not need them when passed to a function. Such an example is a*b.
283         """
284         if not self._needs_brackets(expr):
285             return False
286         else:
287             # Muls of the form a*b*c... can be folded
288             if expr.is_Mul and not self._mul_is_clean(expr):
289                 return True
290             # Pows which don't need brackets can be folded
291             elif expr.is_Pow and not self._pow_is_clean(expr):
292                 return True
293             # Add and Function always need brackets
294             elif expr.is_Add or expr.is_Function:
295                 return True
296             else:
297                 return False
298 
299     def _needs_mul_brackets(self, expr, first=False, last=False):
300         """
301         Returns True if the expression needs to be wrapped in brackets when
302         printed as part of a Mul, False otherwise. This is True for Add,
303         but also for some container objects that would not need brackets
304         when appearing last in a Mul, e.g. an Integral. ``last=True``
305         specifies that this expr is the last to appear in a Mul.
306         ``first=True`` specifies that this expr is the first to appear in
307         a Mul.
308         """
309         from sympy import Integral, Product, Sum
310 
311         if expr.is_Mul:
312             if not first and _coeff_isneg(expr):
313                 return True
314         elif precedence_traditional(expr) < PRECEDENCE["Mul"]:
315             return True
316         elif expr.is_Relational:
317             return True
318         if expr.is_Piecewise:
319             return True
320         if any([expr.has(x) for x in (Mod,)]):
321             return True
322         if (not last and
323                 any([expr.has(x) for x in (Integral, Product, Sum)])):
324             return True
325 
326         return False
327 
328     def _needs_add_brackets(self, expr):
329         """
330         Returns True if the expression needs to be wrapped in brackets when
331         printed as part of an Add, False otherwise.  This is False for most
332         things.
333         """
334         if expr.is_Relational:
335             return True
336         if any([expr.has(x) for x in (Mod,)]):
337             return True
338         if expr.is_Add:
339             return True
340         return False
341 
342     def _mul_is_clean(self, expr):
343         for arg in expr.args:
344             if arg.is_Function:
345                 return False
346         return True
347 
348     def _pow_is_clean(self, expr):
349         return not self._needs_brackets(expr.base)
350 
351     def _do_exponent(self, expr, exp):
352         if exp is not None:
353             return r"\left(%s\right)^{%s}" % (expr, exp)
354         else:
355             return expr
356 
357     def _print_Basic(self, expr):
358         ls = [self._print(o) for o in expr.args]
359         return self._deal_with_super_sub(expr.__class__.__name__) + \
360             r"\left(%s\right)" % ", ".join(ls)
361 
362     def _print_bool(self, e):
363         return r"\text{%s}" % e
364 
365     _print_BooleanTrue = _print_bool
366     _print_BooleanFalse = _print_bool
367 
368     def _print_NoneType(self, e):
369         return r"\text{%s}" % e
370 
371     def _print_Add(self, expr, order=None):
372         terms = self._as_ordered_terms(expr, order=order)
373 
374         tex = ""
375         for i, term in enumerate(terms):
376             if i == 0:
377                 pass
378             elif _coeff_isneg(term):
379                 tex += " - "
380                 term = -term
381             else:
382                 tex += " + "
383             term_tex = self._print(term)
384             if self._needs_add_brackets(term):
385                 term_tex = r"\left(%s\right)" % term_tex
386             tex += term_tex
387 
388         return tex
389 
390     def _print_Cycle(self, expr):
391         from sympy.combinatorics.permutations import Permutation
392         if expr.size == 0:
393             return r"\left( \right)"
394         expr = Permutation(expr)
395         expr_perm = expr.cyclic_form
396         siz = expr.size
397         if expr.array_form[-1] == siz - 1:
398             expr_perm = expr_perm + [[siz - 1]]
399         term_tex = ''
400         for i in expr_perm:
401             term_tex += str(i).replace(',', r"\;")
402         term_tex = term_tex.replace('[', r"\left( ")
403         term_tex = term_tex.replace(']', r"\right)")
404         return term_tex
405 
406     def _print_Permutation(self, expr):
407         from sympy.combinatorics.permutations import Permutation
408         from sympy.utilities.exceptions import SymPyDeprecationWarning
409 
410         perm_cyclic = Permutation.print_cyclic
411         if perm_cyclic is not None:
412             SymPyDeprecationWarning(
413                 feature="Permutation.print_cyclic = {}".format(perm_cyclic),
414                 useinstead="init_printing(perm_cyclic={})"
415                 .format(perm_cyclic),
416                 issue=15201,
417                 deprecated_since_version="1.6").warn()
418         else:
419             perm_cyclic = self._settings.get("perm_cyclic", True)
420 
421         if perm_cyclic:
422             return self._print_Cycle(expr)
423 
424         if expr.size == 0:
425             return r"\left( \right)"
426 
427         lower = [self._print(arg) for arg in expr.array_form]
428         upper = [self._print(arg) for arg in range(len(lower))]
429 
430         row1 = " & ".join(upper)
431         row2 = " & ".join(lower)
432         mat = r" \\ ".join((row1, row2))
433         return r"\begin{pmatrix} %s \end{pmatrix}" % mat
434 
435 
436     def _print_AppliedPermutation(self, expr):
437         perm, var = expr.args
438         return r"\sigma_{%s}(%s)" % (self._print(perm), self._print(var))
439 
440     def _print_Float(self, expr):
441         # Based off of that in StrPrinter
442         dps = prec_to_dps(expr._prec)
443         strip = False if self._settings['full_prec'] else True
444         low = self._settings["min"] if "min" in self._settings else None
445         high = self._settings["max"] if "max" in self._settings else None
446         str_real = mlib.to_str(expr._mpf_, dps, strip_zeros=strip, min_fixed=low, max_fixed=high)
447 
448         # Must always have a mul symbol (as 2.5 10^{20} just looks odd)
449         # thus we use the number separator
450         separator = self._settings['mul_symbol_latex_numbers']
451 
452         if 'e' in str_real:
453             (mant, exp) = str_real.split('e')
454 
455             if exp[0] == '+':
456                 exp = exp[1:]
457             if self._settings['decimal_separator'] == 'comma':
458                 mant = mant.replace('.','{,}')
459 
460             return r"%s%s10^{%s}" % (mant, separator, exp)
461         elif str_real == "+inf":
462             return r"\infty"
463         elif str_real == "-inf":
464             return r"- \infty"
465         else:
466             if self._settings['decimal_separator'] == 'comma':
467                 str_real = str_real.replace('.','{,}')
468             return str_real
469 
470     def _print_Cross(self, expr):
471         vec1 = expr._expr1
472         vec2 = expr._expr2
473         return r"%s \times %s" % (self.parenthesize(vec1, PRECEDENCE['Mul']),
474                                   self.parenthesize(vec2, PRECEDENCE['Mul']))
475 
476     def _print_Curl(self, expr):
477         vec = expr._expr
478         return r"\nabla\times %s" % self.parenthesize(vec, PRECEDENCE['Mul'])
479 
480     def _print_Divergence(self, expr):
481         vec = expr._expr
482         return r"\nabla\cdot %s" % self.parenthesize(vec, PRECEDENCE['Mul'])
483 
484     def _print_Dot(self, expr):
485         vec1 = expr._expr1
486         vec2 = expr._expr2
487         return r"%s \cdot %s" % (self.parenthesize(vec1, PRECEDENCE['Mul']),
488                                  self.parenthesize(vec2, PRECEDENCE['Mul']))
489 
490     def _print_Gradient(self, expr):
491         func = expr._expr
492         return r"\nabla %s" % self.parenthesize(func, PRECEDENCE['Mul'])
493 
494     def _print_Laplacian(self, expr):
495         func = expr._expr
496         return r"\triangle %s" % self.parenthesize(func, PRECEDENCE['Mul'])
497 
498     def _print_Mul(self, expr):
499         from sympy.core.power import Pow
500         from sympy.physics.units import Quantity
501         from sympy.simplify import fraction
502         separator = self._settings['mul_symbol_latex']
503         numbersep = self._settings['mul_symbol_latex_numbers']
504 
505         def convert(expr):
506             if not expr.is_Mul:
507                 return str(self._print(expr))
508             else:
509                 if self.order not in ('old', 'none'):
510                     args = expr.as_ordered_factors()
511                 else:
512                     args = list(expr.args)
513 
514                 # If quantities are present append them at the back
515                 args = sorted(args, key=lambda x: isinstance(x, Quantity) or
516                               (isinstance(x, Pow) and
517                                isinstance(x.base, Quantity)))
518 
519                 return convert_args(args)
520 
521         def convert_args(args):
522                 _tex = last_term_tex = ""
523 
524                 for i, term in enumerate(args):
525                     term_tex = self._print(term)
526 
527                     if self._needs_mul_brackets(term, first=(i == 0),
528                                                 last=(i == len(args) - 1)):
529                         term_tex = r"\left(%s\right)" % term_tex
530 
531                     if _between_two_numbers_p[0].search(last_term_tex) and \
532                             _between_two_numbers_p[1].match(term_tex):
533                         # between two numbers
534                         _tex += numbersep
535                     elif _tex:
536                         _tex += separator
537 
538                     _tex += term_tex
539                     last_term_tex = term_tex
540                 return _tex
541 
542         # Check for unevaluated Mul. In this case we need to make sure the
543         # identities are visible, multiple Rational factors are not combined
544         # etc so we display in a straight-forward form that fully preserves all
545         # args and their order.
546         # XXX: _print_Pow calls this routine with instances of Pow...
547         if isinstance(expr, Mul):
548             args = expr.args
549             if args[0] is S.One or any(isinstance(arg, Number) for arg in args[1:]):
550                 return convert_args(args)
551 
552         include_parens = False
553         if _coeff_isneg(expr):
554             expr = -expr
555             tex = "- "
556             if expr.is_Add:
557                 tex += "("
558                 include_parens = True
559         else:
560             tex = ""
561 
562         numer, denom = fraction(expr, exact=True)
563 
564         if denom is S.One and Pow(1, -1, evaluate=False) not in expr.args:
565             # use the original expression here, since fraction() may have
566             # altered it when producing numer and denom
567             tex += convert(expr)
568 
569         else:
570             snumer = convert(numer)
571             sdenom = convert(denom)
572             ldenom = len(sdenom.split())
573             ratio = self._settings['long_frac_ratio']
574             if self._settings['fold_short_frac'] and ldenom <= 2 and \
575                     "^" not in sdenom:
576                 # handle short fractions
577                 if self._needs_mul_brackets(numer, last=False):
578                     tex += r"\left(%s\right) / %s" % (snumer, sdenom)
579                 else:
580                     tex += r"%s / %s" % (snumer, sdenom)
581             elif ratio is not None and \
582                     len(snumer.split()) > ratio*ldenom:
583                 # handle long fractions
584                 if self._needs_mul_brackets(numer, last=True):
585                     tex += r"\frac{1}{%s}%s\left(%s\right)" \
586                         % (sdenom, separator, snumer)
587                 elif numer.is_Mul:
588                     # split a long numerator
589                     a = S.One
590                     b = S.One
591                     for x in numer.args:
592                         if self._needs_mul_brackets(x, last=False) or \
593                                 len(convert(a*x).split()) > ratio*ldenom or \
594                                 (b.is_commutative is x.is_commutative is False):
595                             b *= x
596                         else:
597                             a *= x
598                     if self._needs_mul_brackets(b, last=True):
599                         tex += r"\frac{%s}{%s}%s\left(%s\right)" \
600                             % (convert(a), sdenom, separator, convert(b))
601                     else:
602                         tex += r"\frac{%s}{%s}%s%s" \
603                             % (convert(a), sdenom, separator, convert(b))
604                 else:
605                     tex += r"\frac{1}{%s}%s%s" % (sdenom, separator, snumer)
606             else:
607                 tex += r"\frac{%s}{%s}" % (snumer, sdenom)
608 
609         if include_parens:
610             tex += ")"
611         return tex
612 
613     def _print_Pow(self, expr):
614         # Treat x**Rational(1,n) as special case
615         if expr.exp.is_Rational and abs(expr.exp.p) == 1 and expr.exp.q != 1 \
616                 and self._settings['root_notation']:
617             base = self._print(expr.base)
618             expq = expr.exp.q
619 
620             if expq == 2:
621                 tex = r"\sqrt{%s}" % base
622             elif self._settings['itex']:
623                 tex = r"\root{%d}{%s}" % (expq, base)
624             else:
625                 tex = r"\sqrt[%d]{%s}" % (expq, base)
626 
627             if expr.exp.is_negative:
628                 return r"\frac{1}{%s}" % tex
629             else:
630                 return tex
631         elif self._settings['fold_frac_powers'] \
632             and expr.exp.is_Rational \
633                 and expr.exp.q != 1:
634             base = self.parenthesize(expr.base, PRECEDENCE['Pow'])
635             p, q = expr.exp.p, expr.exp.q
636             # issue #12886: add parentheses for superscripts raised to powers
637             if expr.base.is_Symbol:
638                 base = self.parenthesize_super(base)
639             if expr.base.is_Function:
640                 return self._print(expr.base, exp="%s/%s" % (p, q))
641             return r"%s^{%s/%s}" % (base, p, q)
642         elif expr.exp.is_Rational and expr.exp.is_negative and \
643                 expr.base.is_commutative:
644             # special case for 1^(-x), issue 9216
645             if expr.base == 1:
646                 return r"%s^{%s}" % (expr.base, expr.exp)
647             # things like 1/x
648             return self._print_Mul(expr)
649         else:
650             if expr.base.is_Function:
651                 return self._print(expr.base, exp=self._print(expr.exp))
652             else:
653                 tex = r"%s^{%s}"
654                 return self._helper_print_standard_power(expr, tex)
655 
656     def _helper_print_standard_power(self, expr, template):
657         exp = self._print(expr.exp)
658         # issue #12886: add parentheses around superscripts raised
659         # to powers
660         base = self.parenthesize(expr.base, PRECEDENCE['Pow'])
661         if expr.base.is_Symbol:
662             base = self.parenthesize_super(base)
663         elif (isinstance(expr.base, Derivative)
664             and base.startswith(r'\left(')
665             and re.match(r'\\left\(\\d?d?dot', base)
666             and base.endswith(r'\right)')):
667             # don't use parentheses around dotted derivative
668             base = base[6: -7]  # remove outermost added parens
669         return template % (base, exp)
670 
671     def _print_UnevaluatedExpr(self, expr):
672         return self._print(expr.args[0])
673 
674     def _print_Sum(self, expr):
675         if len(expr.limits) == 1:
676             tex = r"\sum_{%s=%s}^{%s} " % \
677                 tuple([self._print(i) for i in expr.limits[0]])
678         else:
679             def _format_ineq(l):
680                 return r"%s \leq %s \leq %s" % \
681                     tuple([self._print(s) for s in (l[1], l[0], l[2])])
682 
683             tex = r"\sum_{\substack{%s}} " % \
684                 str.join('\\\\', [_format_ineq(l) for l in expr.limits])
685 
686         if isinstance(expr.function, Add):
687             tex += r"\left(%s\right)" % self._print(expr.function)
688         else:
689             tex += self._print(expr.function)
690 
691         return tex
692 
693     def _print_Product(self, expr):
694         if len(expr.limits) == 1:
695             tex = r"\prod_{%s=%s}^{%s} " % \
696                 tuple([self._print(i) for i in expr.limits[0]])
697         else:
698             def _format_ineq(l):
699                 return r"%s \leq %s \leq %s" % \
700                     tuple([self._print(s) for s in (l[1], l[0], l[2])])
701 
702             tex = r"\prod_{\substack{%s}} " % \
703                 str.join('\\\\', [_format_ineq(l) for l in expr.limits])
704 
705         if isinstance(expr.function, Add):
706             tex += r"\left(%s\right)" % self._print(expr.function)
707         else:
708             tex += self._print(expr.function)
709 
710         return tex
711 
712     def _print_BasisDependent(self, expr):
713         from sympy.vector import Vector
714 
715         o1 = []
716         if expr == expr.zero:
717             return expr.zero._latex_form
718         if isinstance(expr, Vector):
719             items = expr.separate().items()
720         else:
721             items = [(0, expr)]
722 
723         for system, vect in items:
724             inneritems = list(vect.components.items())
725             inneritems.sort(key=lambda x: x[0].__str__())
726             for k, v in inneritems:
727                 if v == 1:
728                     o1.append(' + ' + k._latex_form)
729                 elif v == -1:
730                     o1.append(' - ' + k._latex_form)
731                 else:
732                     arg_str = '(' + self._print(v) + ')'
733                     o1.append(' + ' + arg_str + k._latex_form)
734 
735         outstr = (''.join(o1))
736         if outstr[1] != '-':
737             outstr = outstr[3:]
738         else:
739             outstr = outstr[1:]
740         return outstr
741 
742     def _print_Indexed(self, expr):
743         tex_base = self._print(expr.base)
744         tex = '{'+tex_base+'}'+'_{%s}' % ','.join(
745             map(self._print, expr.indices))
746         return tex
747 
748     def _print_IndexedBase(self, expr):
749         return self._print(expr.label)
750 
751     def _print_Derivative(self, expr):
752         if requires_partial(expr.expr):
753             diff_symbol = r'\partial'
754         else:
755             diff_symbol = r'd'
756 
757         tex = ""
758         dim = 0
759         for x, num in reversed(expr.variable_count):
760             dim += num
761             if num == 1:
762                 tex += r"%s %s" % (diff_symbol, self._print(x))
763             else:
764                 tex += r"%s %s^{%s}" % (diff_symbol,
765                                         self.parenthesize_super(self._print(x)),
766                                         self._print(num))
767 
768         if dim == 1:
769             tex = r"\frac{%s}{%s}" % (diff_symbol, tex)
770         else:
771             tex = r"\frac{%s^{%s}}{%s}" % (diff_symbol, self._print(dim), tex)
772 
773         if any(_coeff_isneg(i) for i in expr.args):
774             return r"%s %s" % (tex, self.parenthesize(expr.expr,
775                                                   PRECEDENCE["Mul"],
776                                                   is_neg=True,
777                                                   strict=True))
778 
779         return r"%s %s" % (tex, self.parenthesize(expr.expr,
780                                                   PRECEDENCE["Mul"],
781                                                   is_neg=False,
782                                                   strict=True))
783 
784     def _print_Subs(self, subs):
785         expr, old, new = subs.args
786         latex_expr = self._print(expr)
787         latex_old = (self._print(e) for e in old)
788         latex_new = (self._print(e) for e in new)
789         latex_subs = r'\\ '.join(
790             e[0] + '=' + e[1] for e in zip(latex_old, latex_new))
791         return r'\left. %s \right|_{\substack{ %s }}' % (latex_expr,
792                                                          latex_subs)
793 
794     def _print_Integral(self, expr):
795         tex, symbols = "", []
796 
797         # Only up to \iiiint exists
798         if len(expr.limits) <= 4 and all(len(lim) == 1 for lim in expr.limits):
799             # Use len(expr.limits)-1 so that syntax highlighters don't think
800             # \" is an escaped quote
801             tex = r"\i" + "i"*(len(expr.limits) - 1) + "nt"
802             symbols = [r"\, d%s" % self._print(symbol[0])
803                        for symbol in expr.limits]
804 
805         else:
806             for lim in reversed(expr.limits):
807                 symbol = lim[0]
808                 tex += r"\int"
809 
810                 if len(lim) > 1:
811                     if self._settings['mode'] != 'inline' \
812                             and not self._settings['itex']:
813                         tex += r"\limits"
814 
815                     if len(lim) == 3:
816                         tex += "_{%s}^{%s}" % (self._print(lim[1]),
817                                                self._print(lim[2]))
818                     if len(lim) == 2:
819                         tex += "^{%s}" % (self._print(lim[1]))
820 
821                 symbols.insert(0, r"\, d%s" % self._print(symbol))
822 
823         return r"%s %s%s" % (tex, self.parenthesize(expr.function,
824                                                     PRECEDENCE["Mul"],
825                                                     is_neg=any(_coeff_isneg(i) for i in expr.args),
826                                                     strict=True),
827                              "".join(symbols))
828 
829     def _print_Limit(self, expr):
830         e, z, z0, dir = expr.args
831 
832         tex = r"\lim_{%s \to " % self._print(z)
833         if str(dir) == '+-' or z0 in (S.Infinity, S.NegativeInfinity):
834             tex += r"%s}" % self._print(z0)
835         else:
836             tex += r"%s^%s}" % (self._print(z0), self._print(dir))
837 
838         if isinstance(e, AssocOp):
839             return r"%s\left(%s\right)" % (tex, self._print(e))
840         else:
841             return r"%s %s" % (tex, self._print(e))
842 
843     def _hprint_Function(self, func):
844         r'''
845         Logic to decide how to render a function to latex
846           - if it is a recognized latex name, use the appropriate latex command
847           - if it is a single letter, just use that letter
848           - if it is a longer name, then put \operatorname{} around it and be
849             mindful of undercores in the name
850         '''
851         func = self._deal_with_super_sub(func)
852         if func in accepted_latex_functions:
853             name = r"\%s" % func
854         elif len(func) == 1 or func.startswith('\\'):
855             name = func
856         else:
857             name = r"\operatorname{%s}" % func
858         return name
859 
860     def _print_Function(self, expr, exp=None):
861         r'''
862         Render functions to LaTeX, handling functions that LaTeX knows about
863         e.g., sin, cos, ... by using the proper LaTeX command (\sin, \cos, ...).
864         For single-letter function names, render them as regular LaTeX math
865         symbols. For multi-letter function names that LaTeX does not know
866         about, (e.g., Li, sech) use \operatorname{} so that the function name
867         is rendered in Roman font and LaTeX handles spacing properly.
868 
869         expr is the expression involving the function
870         exp is an exponent
871         '''
872         func = expr.func.__name__
873         if hasattr(self, '_print_' + func) and \
874                 not isinstance(expr, AppliedUndef):
875             return getattr(self, '_print_' + func)(expr, exp)
876         else:
877             args = [str(self._print(arg)) for arg in expr.args]
878             # How inverse trig functions should be displayed, formats are:
879             # abbreviated: asin, full: arcsin, power: sin^-1
880             inv_trig_style = self._settings['inv_trig_style']
881             # If we are dealing with a power-style inverse trig function
882             inv_trig_power_case = False
883             # If it is applicable to fold the argument brackets
884             can_fold_brackets = self._settings['fold_func_brackets'] and \
885                 len(args) == 1 and \
886                 not self._needs_function_brackets(expr.args[0])
887 
888             inv_trig_table = [
889                 "asin", "acos", "atan",
890                 "acsc", "asec", "acot",
891                 "asinh", "acosh", "atanh",
892                 "acsch", "asech", "acoth",
893             ]
894 
895             # If the function is an inverse trig function, handle the style
896             if func in inv_trig_table:
897                 if inv_trig_style == "abbreviated":
898                     pass
899                 elif inv_trig_style == "full":
900                     func = "arc" + func[1:]
901                 elif inv_trig_style == "power":
902                     func = func[1:]
903                     inv_trig_power_case = True
904 
905                     # Can never fold brackets if we're raised to a power
906                     if exp is not None:
907                         can_fold_brackets = False
908 
909             if inv_trig_power_case:
910                 if func in accepted_latex_functions:
911                     name = r"\%s^{-1}" % func
912                 else:
913                     name = r"\operatorname{%s}^{-1}" % func
914             elif exp is not None:
915                 func_tex = self._hprint_Function(func)
916                 func_tex = self.parenthesize_super(func_tex)
917                 name = r'%s^{%s}' % (func_tex, exp)
918             else:
919                 name = self._hprint_Function(func)
920 
921             if can_fold_brackets:
922                 if func in accepted_latex_functions:
923                     # Wrap argument safely to avoid parse-time conflicts
924                     # with the function name itself
925                     name += r" {%s}"
926                 else:
927                     name += r"%s"
928             else:
929                 name += r"{\left(%s \right)}"
930 
931             if inv_trig_power_case and exp is not None:
932                 name += r"^{%s}" % exp
933 
934             return name % ",".join(args)
935 
936     def _print_UndefinedFunction(self, expr):
937         return self._hprint_Function(str(expr))
938 
939     def _print_ElementwiseApplyFunction(self, expr):
940         return r"{%s}_{\circ}\left({%s}\right)" % (
941             self._print(expr.function),
942             self._print(expr.expr),
943         )
944 
945     @property
946     def _special_function_classes(self):
947         from sympy.functions.special.tensor_functions import KroneckerDelta
948         from sympy.functions.special.gamma_functions import gamma, lowergamma
949         from sympy.functions.special.beta_functions import beta
950         from sympy.functions.special.delta_functions import DiracDelta
951         from sympy.functions.special.error_functions import Chi
952         return {KroneckerDelta: r'\delta',
953                 gamma:  r'\Gamma',
954                 lowergamma: r'\gamma',
955                 beta: r'\operatorname{B}',
956                 DiracDelta: r'\delta',
957                 Chi: r'\operatorname{Chi}'}
958 
959     def _print_FunctionClass(self, expr):
960         for cls in self._special_function_classes:
961             if issubclass(expr, cls) and expr.__name__ == cls.__name__:
962                 return self._special_function_classes[cls]
963         return self._hprint_Function(str(expr))
964 
965     def _print_Lambda(self, expr):
966         symbols, expr = expr.args
967 
968         if len(symbols) == 1:
969             symbols = self._print(symbols[0])
970         else:
971             symbols = self._print(tuple(symbols))
972 
973         tex = r"\left( %s \mapsto %s \right)" % (symbols, self._print(expr))
974 
975         return tex
976 
977     def _print_IdentityFunction(self, expr):
978         return r"\left( x \mapsto x \right)"
979 
980     def _hprint_variadic_function(self, expr, exp=None):
981         args = sorted(expr.args, key=default_sort_key)
982         texargs = [r"%s" % self._print(symbol) for symbol in args]
983         tex = r"\%s\left(%s\right)" % (str(expr.func).lower(),
984                                        ", ".join(texargs))
985         if exp is not None:
986             return r"%s^{%s}" % (tex, exp)
987         else:
988             return tex
989 
990     _print_Min = _print_Max = _hprint_variadic_function
991 
992     def _print_floor(self, expr, exp=None):
993         tex = r"\left\lfloor{%s}\right\rfloor" % self._print(expr.args[0])
994 
995         if exp is not None:
996             return r"%s^{%s}" % (tex, exp)
997         else:
998             return tex
999 
1000     def _print_ceiling(self, expr, exp=None):
1001         tex = r"\left\lceil{%s}\right\rceil" % self._print(expr.args[0])
1002 
1003         if exp is not None:
1004             return r"%s^{%s}" % (tex, exp)
1005         else:
1006             return tex
1007 
1008     def _print_log(self, expr, exp=None):
1009         if not self._settings["ln_notation"]:
1010             tex = r"\log{\left(%s \right)}" % self._print(expr.args[0])
1011         else:
1012             tex = r"\ln{\left(%s \right)}" % self._print(expr.args[0])
1013 
1014         if exp is not None:
1015             return r"%s^{%s}" % (tex, exp)
1016         else:
1017             return tex
1018 
1019     def _print_Abs(self, expr, exp=None):
1020         tex = r"\left|{%s}\right|" % self._print(expr.args[0])
1021 
1022         if exp is not None:
1023             return r"%s^{%s}" % (tex, exp)
1024         else:
1025             return tex
1026     _print_Determinant = _print_Abs
1027 
1028     def _print_re(self, expr, exp=None):
1029         if self._settings['gothic_re_im']:
1030             tex = r"\Re{%s}" % self.parenthesize(expr.args[0], PRECEDENCE['Atom'])
1031         else:
1032             tex = r"\operatorname{{re}}{{{}}}".format(self.parenthesize(expr.args[0], PRECEDENCE['Atom']))
1033 
1034         return self._do_exponent(tex, exp)
1035 
1036     def _print_im(self, expr, exp=None):
1037         if self._settings['gothic_re_im']:
1038             tex = r"\Im{%s}" % self.parenthesize(expr.args[0], PRECEDENCE['Atom'])
1039         else:
1040             tex = r"\operatorname{{im}}{{{}}}".format(self.parenthesize(expr.args[0], PRECEDENCE['Atom']))
1041 
1042         return self._do_exponent(tex, exp)
1043 
1044     def _print_Not(self, e):
1045         from sympy import Equivalent, Implies
1046         if isinstance(e.args[0], Equivalent):
1047             return self._print_Equivalent(e.args[0], r"\not\Leftrightarrow")
1048         if isinstance(e.args[0], Implies):
1049             return self._print_Implies(e.args[0], r"\not\Rightarrow")
1050         if (e.args[0].is_Boolean):
1051             return r"\neg \left(%s\right)" % self._print(e.args[0])
1052         else:
1053             return r"\neg %s" % self._print(e.args[0])
1054 
1055     def _print_LogOp(self, args, char):
1056         arg = args[0]
1057         if arg.is_Boolean and not arg.is_Not:
1058             tex = r"\left(%s\right)" % self._print(arg)
1059         else:
1060             tex = r"%s" % self._print(arg)
1061 
1062         for arg in args[1:]:
1063             if arg.is_Boolean and not arg.is_Not:
1064                 tex += r" %s \left(%s\right)" % (char, self._print(arg))
1065             else:
1066                 tex += r" %s %s" % (char, self._print(arg))
1067 
1068         return tex
1069 
1070     def _print_And(self, e):
1071         args = sorted(e.args, key=default_sort_key)
1072         return self._print_LogOp(args, r"\wedge")
1073 
1074     def _print_Or(self, e):
1075         args = sorted(e.args, key=default_sort_key)
1076         return self._print_LogOp(args, r"\vee")
1077 
1078     def _print_Xor(self, e):
1079         args = sorted(e.args, key=default_sort_key)
1080         return self._print_LogOp(args, r"\veebar")
1081 
1082     def _print_Implies(self, e, altchar=None):
1083         return self._print_LogOp(e.args, altchar or r"\Rightarrow")
1084 
1085     def _print_Equivalent(self, e, altchar=None):
1086         args = sorted(e.args, key=default_sort_key)
1087         return self._print_LogOp(args, altchar or r"\Leftrightarrow")
1088 
1089     def _print_conjugate(self, expr, exp=None):
1090         tex = r"\overline{%s}" % self._print(expr.args[0])
1091 
1092         if exp is not None:
1093             return r"%s^{%s}" % (tex, exp)
1094         else:
1095             return tex
1096 
1097     def _print_polar_lift(self, expr, exp=None):
1098         func = r"\operatorname{polar\_lift}"
1099         arg = r"{\left(%s \right)}" % self._print(expr.args[0])
1100 
1101         if exp is not None:
1102             return r"%s^{%s}%s" % (func, exp, arg)
1103         else:
1104             return r"%s%s" % (func, arg)
1105 
1106     def _print_ExpBase(self, expr, exp=None):
1107         # TODO should exp_polar be printed differently?
1108         #      what about exp_polar(0), exp_polar(1)?
1109         tex = r"e^{%s}" % self._print(expr.args[0])
1110         return self._do_exponent(tex, exp)
1111 
1112     def _print_elliptic_k(self, expr, exp=None):
1113         tex = r"\left(%s\right)" % self._print(expr.args[0])
1114         if exp is not None:
1115             return r"K^{%s}%s" % (exp, tex)
1116         else:
1117             return r"K%s" % tex
1118 
1119     def _print_elliptic_f(self, expr, exp=None):
1120         tex = r"\left(%s\middle| %s\right)" % \
1121             (self._print(expr.args[0]), self._print(expr.args[1]))
1122         if exp is not None:
1123             return r"F^{%s}%s" % (exp, tex)
1124         else:
1125             return r"F%s" % tex
1126 
1127     def _print_elliptic_e(self, expr, exp=None):
1128         if len(expr.args) == 2:
1129             tex = r"\left(%s\middle| %s\right)" % \
1130                 (self._print(expr.args[0]), self._print(expr.args[1]))
1131         else:
1132             tex = r"\left(%s\right)" % self._print(expr.args[0])
1133         if exp is not None:
1134             return r"E^{%s}%s" % (exp, tex)
1135         else:
1136             return r"E%s" % tex
1137 
1138     def _print_elliptic_pi(self, expr, exp=None):
1139         if len(expr.args) == 3:
1140             tex = r"\left(%s; %s\middle| %s\right)" % \
1141                 (self._print(expr.args[0]), self._print(expr.args[1]),
1142                  self._print(expr.args[2]))
1143         else:
1144             tex = r"\left(%s\middle| %s\right)" % \
1145                 (self._print(expr.args[0]), self._print(expr.args[1]))
1146         if exp is not None:
1147             return r"\Pi^{%s}%s" % (exp, tex)
1148         else:
1149             return r"\Pi%s" % tex
1150 
1151     def _print_beta(self, expr, exp=None):
1152         tex = r"\left(%s, %s\right)" % (self._print(expr.args[0]),
1153                                         self._print(expr.args[1]))
1154 
1155         if exp is not None:
1156             return r"\operatorname{B}^{%s}%s" % (exp, tex)
1157         else:
1158             return r"\operatorname{B}%s" % tex
1159 
1160     def _print_uppergamma(self, expr, exp=None):
1161         tex = r"\left(%s, %s\right)" % (self._print(expr.args[0]),
1162                                         self._print(expr.args[1]))
1163 
1164         if exp is not None:
1165             return r"\Gamma^{%s}%s" % (exp, tex)
1166         else:
1167             return r"\Gamma%s" % tex
1168 
1169     def _print_lowergamma(self, expr, exp=None):
1170         tex = r"\left(%s, %s\right)" % (self._print(expr.args[0]),
1171                                         self._print(expr.args[1]))
1172 
1173         if exp is not None:
1174             return r"\gamma^{%s}%s" % (exp, tex)
1175         else:
1176             return r"\gamma%s" % tex
1177 
1178     def _hprint_one_arg_func(self, expr, exp=None):
1179         tex = r"\left(%s\right)" % self._print(expr.args[0])
1180 
1181         if exp is not None:
1182             return r"%s^{%s}%s" % (self._print(expr.func), exp, tex)
1183         else:
1184             return r"%s%s" % (self._print(expr.func), tex)
1185 
1186     _print_gamma = _hprint_one_arg_func
1187 
1188     def _print_Chi(self, expr, exp=None):
1189         tex = r"\left(%s\right)" % self._print(expr.args[0])
1190 
1191         if exp is not None:
1192             return r"\operatorname{Chi}^{%s}%s" % (exp, tex)
1193         else:
1194             return r"\operatorname{Chi}%s" % tex
1195 
1196     def _print_expint(self, expr, exp=None):
1197         tex = r"\left(%s\right)" % self._print(expr.args[1])
1198         nu = self._print(expr.args[0])
1199 
1200         if exp is not None:
1201             return r"\operatorname{E}_{%s}^{%s}%s" % (nu, exp, tex)
1202         else:
1203             return r"\operatorname{E}_{%s}%s" % (nu, tex)
1204 
1205     def _print_fresnels(self, expr, exp=None):
1206         tex = r"\left(%s\right)" % self._print(expr.args[0])
1207 
1208         if exp is not None:
1209             return r"S^{%s}%s" % (exp, tex)
1210         else:
1211             return r"S%s" % tex
1212 
1213     def _print_fresnelc(self, expr, exp=None):
1214         tex = r"\left(%s\right)" % self._print(expr.args[0])
1215 
1216         if exp is not None:
1217             return r"C^{%s}%s" % (exp, tex)
1218         else:
1219             return r"C%s" % tex
1220 
1221     def _print_subfactorial(self, expr, exp=None):
1222         tex = r"!%s" % self.parenthesize(expr.args[0], PRECEDENCE["Func"])
1223 
1224         if exp is not None:
1225             return r"\left(%s\right)^{%s}" % (tex, exp)
1226         else:
1227             return tex
1228 
1229     def _print_factorial(self, expr, exp=None):
1230         tex = r"%s!" % self.parenthesize(expr.args[0], PRECEDENCE["Func"])
1231 
1232         if exp is not None:
1233             return r"%s^{%s}" % (tex, exp)
1234         else:
1235             return tex
1236 
1237     def _print_factorial2(self, expr, exp=None):
1238         tex = r"%s!!" % self.parenthesize(expr.args[0], PRECEDENCE["Func"])
1239 
1240         if exp is not None:
1241             return r"%s^{%s}" % (tex, exp)
1242         else:
1243             return tex
1244 
1245     def _print_binomial(self, expr, exp=None):
1246         tex = r"{\binom{%s}{%s}}" % (self._print(expr.args[0]),
1247                                      self._print(expr.args[1]))
1248 
1249         if exp is not None:
1250             return r"%s^{%s}" % (tex, exp)
1251         else:
1252             return tex
1253 
1254     def _print_RisingFactorial(self, expr, exp=None):
1255         n, k = expr.args
1256         base = r"%s" % self.parenthesize(n, PRECEDENCE['Func'])
1257 
1258         tex = r"{%s}^{\left(%s\right)}" % (base, self._print(k))
1259 
1260         return self._do_exponent(tex, exp)
1261 
1262     def _print_FallingFactorial(self, expr, exp=None):
1263         n, k = expr.args
1264         sub = r"%s" % self.parenthesize(k, PRECEDENCE['Func'])
1265 
1266         tex = r"{\left(%s\right)}_{%s}" % (self._print(n), sub)
1267 
1268         return self._do_exponent(tex, exp)
1269 
1270     def _hprint_BesselBase(self, expr, exp, sym):
1271         tex = r"%s" % (sym)
1272 
1273         need_exp = False
1274         if exp is not None:
1275             if tex.find('^') == -1:
1276                 tex = r"%s^{%s}" % (tex, exp)
1277             else:
1278                 need_exp = True
1279 
1280         tex = r"%s_{%s}\left(%s\right)" % (tex, self._print(expr.order),
1281                                            self._print(expr.argument))
1282 
1283         if need_exp:
1284             tex = self._do_exponent(tex, exp)
1285         return tex
1286 
1287     def _hprint_vec(self, vec):
1288         if not vec:
1289             return ""
1290         s = ""
1291         for i in vec[:-1]:
1292             s += "%s, " % self._print(i)
1293         s += self._print(vec[-1])
1294         return s
1295 
1296     def _print_besselj(self, expr, exp=None):
1297         return self._hprint_BesselBase(expr, exp, 'J')
1298 
1299     def _print_besseli(self, expr, exp=None):
1300         return self._hprint_BesselBase(expr, exp, 'I')
1301 
1302     def _print_besselk(self, expr, exp=None):
1303         return self._hprint_BesselBase(expr, exp, 'K')
1304 
1305     def _print_bessely(self, expr, exp=None):
1306         return self._hprint_BesselBase(expr, exp, 'Y')
1307 
1308     def _print_yn(self, expr, exp=None):
1309         return self._hprint_BesselBase(expr, exp, 'y')
1310 
1311     def _print_jn(self, expr, exp=None):
1312         return self._hprint_BesselBase(expr, exp, 'j')
1313 
1314     def _print_hankel1(self, expr, exp=None):
1315         return self._hprint_BesselBase(expr, exp, 'H^{(1)}')
1316 
1317     def _print_hankel2(self, expr, exp=None):
1318         return self._hprint_BesselBase(expr, exp, 'H^{(2)}')
1319 
1320     def _print_hn1(self, expr, exp=None):
1321         return self._hprint_BesselBase(expr, exp, 'h^{(1)}')
1322 
1323     def _print_hn2(self, expr, exp=None):
1324         return self._hprint_BesselBase(expr, exp, 'h^{(2)}')
1325 
1326     def _hprint_airy(self, expr, exp=None, notation=""):
1327         tex = r"\left(%s\right)" % self._print(expr.args[0])
1328 
1329         if exp is not None:
1330             return r"%s^{%s}%s" % (notation, exp, tex)
1331         else:
1332             return r"%s%s" % (notation, tex)
1333 
1334     def _hprint_airy_prime(self, expr, exp=None, notation=""):
1335         tex = r"\left(%s\right)" % self._print(expr.args[0])
1336 
1337         if exp is not None:
1338             return r"{%s^\prime}^{%s}%s" % (notation, exp, tex)
1339         else:
1340             return r"%s^\prime%s" % (notation, tex)
1341 
1342     def _print_airyai(self, expr, exp=None):
1343         return self._hprint_airy(expr, exp, 'Ai')
1344 
1345     def _print_airybi(self, expr, exp=None):
1346         return self._hprint_airy(expr, exp, 'Bi')
1347 
1348     def _print_airyaiprime(self, expr, exp=None):
1349         return self._hprint_airy_prime(expr, exp, 'Ai')
1350 
1351     def _print_airybiprime(self, expr, exp=None):
1352         return self._hprint_airy_prime(expr, exp, 'Bi')
1353 
1354     def _print_hyper(self, expr, exp=None):
1355         tex = r"{{}_{%s}F_{%s}\left(\begin{matrix} %s \\ %s \end{matrix}" \
1356               r"\middle| {%s} \right)}" % \
1357             (self._print(len(expr.ap)), self._print(len(expr.bq)),
1358               self._hprint_vec(expr.ap), self._hprint_vec(expr.bq),
1359               self._print(expr.argument))
1360 
1361         if exp is not None:
1362             tex = r"{%s}^{%s}" % (tex, exp)
1363         return tex
1364 
1365     def _print_meijerg(self, expr, exp=None):
1366         tex = r"{G_{%s, %s}^{%s, %s}\left(\begin{matrix} %s & %s \\" \
1367               r"%s & %s \end{matrix} \middle| {%s} \right)}" % \
1368             (self._print(len(expr.ap)), self._print(len(expr.bq)),
1369               self._print(len(expr.bm)), self._print(len(expr.an)),
1370               self._hprint_vec(expr.an), self._hprint_vec(expr.aother),
1371               self._hprint_vec(expr.bm), self._hprint_vec(expr.bother),
1372               self._print(expr.argument))
1373 
1374         if exp is not None:
1375             tex = r"{%s}^{%s}" % (tex, exp)
1376         return tex
1377 
1378     def _print_dirichlet_eta(self, expr, exp=None):
1379         tex = r"\left(%s\right)" % self._print(expr.args[0])
1380         if exp is not None:
1381             return r"\eta^{%s}%s" % (exp, tex)
1382         return r"\eta%s" % tex
1383 
1384     def _print_zeta(self, expr, exp=None):
1385         if len(expr.args) == 2:
1386             tex = r"\left(%s, %s\right)" % tuple(map(self._print, expr.args))
1387         else:
1388             tex = r"\left(%s\right)" % self._print(expr.args[0])
1389         if exp is not None:
1390             return r"\zeta^{%s}%s" % (exp, tex)
1391         return r"\zeta%s" % tex
1392 
1393     def _print_stieltjes(self, expr, exp=None):
1394         if len(expr.args) == 2:
1395             tex = r"_{%s}\left(%s\right)" % tuple(map(self._print, expr.args))
1396         else:
1397             tex = r"_{%s}" % self._print(expr.args[0])
1398         if exp is not None:
1399             return r"\gamma%s^{%s}" % (tex, exp)
1400         return r"\gamma%s" % tex
1401 
1402     def _print_lerchphi(self, expr, exp=None):
1403         tex = r"\left(%s, %s, %s\right)" % tuple(map(self._print, expr.args))
1404         if exp is None:
1405             return r"\Phi%s" % tex
1406         return r"\Phi^{%s}%s" % (exp, tex)
1407 
1408     def _print_polylog(self, expr, exp=None):
1409         s, z = map(self._print, expr.args)
1410         tex = r"\left(%s\right)" % z
1411         if exp is None:
1412             return r"\operatorname{Li}_{%s}%s" % (s, tex)
1413         return r"\operatorname{Li}_{%s}^{%s}%s" % (s, exp, tex)
1414 
1415     def _print_jacobi(self, expr, exp=None):
1416         n, a, b, x = map(self._print, expr.args)
1417         tex = r"P_{%s}^{\left(%s,%s\right)}\left(%s\right)" % (n, a, b, x)
1418         if exp is not None:
1419             tex = r"\left(" + tex + r"\right)^{%s}" % (exp)
1420         return tex
1421 
1422     def _print_gegenbauer(self, expr, exp=None):
1423         n, a, x = map(self._print, expr.args)
1424         tex = r"C_{%s}^{\left(%s\right)}\left(%s\right)" % (n, a, x)
1425         if exp is not None:
1426             tex = r"\left(" + tex + r"\right)^{%s}" % (exp)
1427         return tex
1428 
1429     def _print_chebyshevt(self, expr, exp=None):
1430         n, x = map(self._print, expr.args)
1431         tex = r"T_{%s}\left(%s\right)" % (n, x)
1432         if exp is not None:
1433             tex = r"\left(" + tex + r"\right)^{%s}" % (exp)
1434         return tex
1435 
1436     def _print_chebyshevu(self, expr, exp=None):
1437         n, x = map(self._print, expr.args)
1438         tex = r"U_{%s}\left(%s\right)" % (n, x)
1439         if exp is not None:
1440             tex = r"\left(" + tex + r"\right)^{%s}" % (exp)
1441         return tex
1442 
1443     def _print_legendre(self, expr, exp=None):
1444         n, x = map(self._print, expr.args)
1445         tex = r"P_{%s}\left(%s\right)" % (n, x)
1446         if exp is not None:
1447             tex = r"\left(" + tex + r"\right)^{%s}" % (exp)
1448         return tex
1449 
1450     def _print_assoc_legendre(self, expr, exp=None):
1451         n, a, x = map(self._print, expr.args)
1452         tex = r"P_{%s}^{\left(%s\right)}\left(%s\right)" % (n, a, x)
1453         if exp is not None:
1454             tex = r"\left(" + tex + r"\right)^{%s}" % (exp)
1455         return tex
1456 
1457     def _print_hermite(self, expr, exp=None):
1458         n, x = map(self._print, expr.args)
1459         tex = r"H_{%s}\left(%s\right)" % (n, x)
1460         if exp is not None:
1461             tex = r"\left(" + tex + r"\right)^{%s}" % (exp)
1462         return tex
1463 
1464     def _print_laguerre(self, expr, exp=None):
1465         n, x = map(self._print, expr.args)
1466         tex = r"L_{%s}\left(%s\right)" % (n, x)
1467         if exp is not None:
1468             tex = r"\left(" + tex + r"\right)^{%s}" % (exp)
1469         return tex
1470 
1471     def _print_assoc_laguerre(self, expr, exp=None):
1472         n, a, x = map(self._print, expr.args)
1473         tex = r"L_{%s}^{\left(%s\right)}\left(%s\right)" % (n, a, x)
1474         if exp is not None:
1475             tex = r"\left(" + tex + r"\right)^{%s}" % (exp)
1476         return tex
1477 
1478     def _print_Ynm(self, expr, exp=None):
1479         n, m, theta, phi = map(self._print, expr.args)
1480         tex = r"Y_{%s}^{%s}\left(%s,%s\right)" % (n, m, theta, phi)
1481         if exp is not None:
1482             tex = r"\left(" + tex + r"\right)^{%s}" % (exp)
1483         return tex
1484 
1485     def _print_Znm(self, expr, exp=None):
1486         n, m, theta, phi = map(self._print, expr.args)
1487         tex = r"Z_{%s}^{%s}\left(%s,%s\right)" % (n, m, theta, phi)
1488         if exp is not None:
1489             tex = r"\left(" + tex + r"\right)^{%s}" % (exp)
1490         return tex
1491 
1492     def __print_mathieu_functions(self, character, args, prime=False, exp=None):
1493         a, q, z = map(self._print, args)
1494         sup = r"^{\prime}" if prime else ""
1495         exp = "" if not exp else "^{%s}" % exp
1496         return r"%s%s\left(%s, %s, %s\right)%s" % (character, sup, a, q, z, exp)
1497 
1498     def _print_mathieuc(self, expr, exp=None):
1499         return self.__print_mathieu_functions("C", expr.args, exp=exp)
1500 
1501     def _print_mathieus(self, expr, exp=None):
1502         return self.__print_mathieu_functions("S", expr.args, exp=exp)
1503 
1504     def _print_mathieucprime(self, expr, exp=None):
1505         return self.__print_mathieu_functions("C", expr.args, prime=True, exp=exp)
1506 
1507     def _print_mathieusprime(self, expr, exp=None):
1508         return self.__print_mathieu_functions("S", expr.args, prime=True, exp=exp)
1509 
1510     def _print_Rational(self, expr):
1511         if expr.q != 1:
1512             sign = ""
1513             p = expr.p
1514             if expr.p < 0:
1515                 sign = "- "
1516                 p = -p
1517             if self._settings['fold_short_frac']:
1518                 return r"%s%d / %d" % (sign, p, expr.q)
1519             return r"%s\frac{%d}{%d}" % (sign, p, expr.q)
1520         else:
1521             return self._print(expr.p)
1522 
1523     def _print_Order(self, expr):
1524         s = self._print(expr.expr)
1525         if expr.point and any(p != S.Zero for p in expr.point) or \
1526            len(expr.variables) > 1:
1527             s += '; '
1528             if len(expr.variables) > 1:
1529                 s += self._print(expr.variables)
1530             elif expr.variables:
1531                 s += self._print(expr.variables[0])
1532             s += r'\rightarrow '
1533             if len(expr.point) > 1:
1534                 s += self._print(expr.point)
1535             else:
1536                 s += self._print(expr.point[0])
1537         return r"O\left(%s\right)" % s
1538 
1539     def _print_Symbol(self, expr, style='plain'):
1540         if expr in self._settings['symbol_names']:
1541             return self._settings['symbol_names'][expr]
1542 
1543         return self._deal_with_super_sub(expr.name, style=style)
1544 
1545     _print_RandomSymbol = _print_Symbol
1546 
1547     def _deal_with_super_sub(self, string, style='plain'):
1548         if '{' in string:
1549             name, supers, subs = string, [], []
1550         else:
1551             name, supers, subs = split_super_sub(string)
1552 
1553             name = translate(name)
1554             supers = [translate(sup) for sup in supers]
1555             subs = [translate(sub) for sub in subs]
1556 
1557         # apply the style only to the name
1558         if style == 'bold':
1559             name = "\\mathbf{{{}}}".format(name)
1560 
1561         # glue all items together:
1562         if supers:
1563             name += "^{%s}" % " ".join(supers)
1564         if subs:
1565             name += "_{%s}" % " ".join(subs)
1566 
1567         return name
1568 
1569     def _print_Relational(self, expr):
1570         if self._settings['itex']:
1571             gt = r"\gt"
1572             lt = r"\lt"
1573         else:
1574             gt = ">"
1575             lt = "<"
1576 
1577         charmap = {
1578             "==": "=",
1579             ">": gt,
1580             "<": lt,
1581             ">=": r"\geq",
1582             "<=": r"\leq",
1583             "!=": r"\neq",
1584         }
1585 
1586         return "%s %s %s" % (self._print(expr.lhs),
1587                              charmap[expr.rel_op], self._print(expr.rhs))
1588 
1589     def _print_Piecewise(self, expr):
1590         ecpairs = [r"%s & \text{for}\: %s" % (self._print(e), self._print(c))
1591                    for e, c in expr.args[:-1]]
1592         if expr.args[-1].cond == true:
1593             ecpairs.append(r"%s & \text{otherwise}" %
1594                            self._print(expr.args[-1].expr))
1595         else:
1596             ecpairs.append(r"%s & \text{for}\: %s" %
1597                            (self._print(expr.args[-1].expr),
1598                             self._print(expr.args[-1].cond)))
1599         tex = r"\begin{cases} %s \end{cases}"
1600         return tex % r" \\".join(ecpairs)
1601 
1602     def _print_MatrixBase(self, expr):
1603         lines = []
1604 
1605         for line in range(expr.rows):  # horrible, should be 'rows'
1606             lines.append(" & ".join([self._print(i) for i in expr[line, :]]))
1607 
1608         mat_str = self._settings['mat_str']
1609         if mat_str is None:
1610             if self._settings['mode'] == 'inline':
1611                 mat_str = 'smallmatrix'
1612             else:
1613                 if (expr.cols <= 10) is True:
1614                     mat_str = 'matrix'
1615                 else:
1616                     mat_str = 'array'
1617 
1618         out_str = r'\begin{%MATSTR%}%s\end{%MATSTR%}'
1619         out_str = out_str.replace('%MATSTR%', mat_str)
1620         if mat_str == 'array':
1621             out_str = out_str.replace('%s', '{' + 'c'*expr.cols + '}%s')
1622         if self._settings['mat_delim']:
1623             left_delim = self._settings['mat_delim']
1624             right_delim = self._delim_dict[left_delim]
1625             out_str = r'\left' + left_delim + out_str + \
1626                       r'\right' + right_delim
1627         return out_str % r"\\".join(lines)
1628 
1629     def _print_MatrixElement(self, expr):
1630         return self.parenthesize(expr.parent, PRECEDENCE["Atom"], strict=True)\
1631             + '_{%s, %s}' % (self._print(expr.i), self._print(expr.j))
1632 
1633     def _print_MatrixSlice(self, expr):
1634         def latexslice(x, dim):
1635             x = list(x)
1636             if x[2] == 1:
1637                 del x[2]
1638             if x[0] == 0:
1639                 x[0] = None
1640             if x[1] == dim:
1641                 x[1] = None
1642             return ':'.join(self._print(xi) if xi is not None else '' for xi in x)
1643         return (self.parenthesize(expr.parent, PRECEDENCE["Atom"], strict=True) + r'\left[' +
1644                 latexslice(expr.rowslice, expr.parent.rows) + ', ' +
1645                 latexslice(expr.colslice, expr.parent.cols) + r'\right]')
1646 
1647     def _print_BlockMatrix(self, expr):
1648         return self._print(expr.blocks)
1649 
1650     def _print_Transpose(self, expr):
1651         mat = expr.arg
1652         from sympy.matrices import MatrixSymbol
1653         if not isinstance(mat, MatrixSymbol):
1654             return r"\left(%s\right)^{T}" % self._print(mat)
1655         else:
1656             return "%s^{T}" % self.parenthesize(mat, precedence_traditional(expr), True)
1657 
1658     def _print_Trace(self, expr):
1659         mat = expr.arg
1660         return r"\operatorname{tr}\left(%s \right)" % self._print(mat)
1661 
1662     def _print_Adjoint(self, expr):
1663         mat = expr.arg
1664         from sympy.matrices import MatrixSymbol
1665         if not isinstance(mat, MatrixSymbol):
1666             return r"\left(%s\right)^{\dagger}" % self._print(mat)
1667         else:
1668             return r"%s^{\dagger}" % self._print(mat)
1669 
1670     def _print_MatMul(self, expr):
1671         from sympy import MatMul, Mul
1672 
1673         parens = lambda x: self.parenthesize(x, precedence_traditional(expr),
1674                                              False)
1675 
1676         args = expr.args
1677         if isinstance(args[0], Mul):
1678             args = args[0].as_ordered_factors() + list(args[1:])
1679         else:
1680             args = list(args)
1681 
1682         if isinstance(expr, MatMul) and _coeff_isneg(expr):
1683             if args[0] == -1:
1684                 args = args[1:]
1685             else:
1686                 args[0] = -args[0]
1687             return '- ' + ' '.join(map(parens, args))
1688         else:
1689             return ' '.join(map(parens, args))
1690 
1691     def _print_Mod(self, expr, exp=None):
1692         if exp is not None:
1693             return r'\left(%s\bmod{%s}\right)^{%s}' % \
1694                 (self.parenthesize(expr.args[0], PRECEDENCE['Mul'],
1695                                    strict=True), self._print(expr.args[1]),
1696                  exp)
1697         return r'%s\bmod{%s}' % (self.parenthesize(expr.args[0],
1698                                  PRECEDENCE['Mul'], strict=True),
1699                                  self._print(expr.args[1]))
1700 
1701     def _print_HadamardProduct(self, expr):
1702         args = expr.args
1703         prec = PRECEDENCE['Pow']
1704         parens = self.parenthesize
1705 
1706         return r' \circ '.join(
1707             map(lambda arg: parens(arg, prec, strict=True), args))
1708 
1709     def _print_HadamardPower(self, expr):
1710         if precedence_traditional(expr.exp) < PRECEDENCE["Mul"]:
1711             template = r"%s^{\circ \left({%s}\right)}"
1712         else:
1713             template = r"%s^{\circ {%s}}"
1714         return self._helper_print_standard_power(expr, template)
1715 
1716     def _print_KroneckerProduct(self, expr):
1717         args = expr.args
1718         prec = PRECEDENCE['Pow']
1719         parens = self.parenthesize
1720 
1721         return r' \otimes '.join(
1722             map(lambda arg: parens(arg, prec, strict=True), args))
1723 
1724     def _print_MatPow(self, expr):
1725         base, exp = expr.base, expr.exp
1726         from sympy.matrices import MatrixSymbol
1727         if not isinstance(base, MatrixSymbol):
1728             return "\\left(%s\\right)^{%s}" % (self._print(base),
1729                                               self._print(exp))
1730         else:
1731             return "%s^{%s}" % (self._print(base), self._print(exp))
1732 
1733     def _print_MatrixSymbol(self, expr):
1734         return self._print_Symbol(expr, style=self._settings[
1735             'mat_symbol_style'])
1736 
1737     def _print_ZeroMatrix(self, Z):
1738         return r"\mathbb{0}" if self._settings[
1739             'mat_symbol_style'] == 'plain' else r"\mathbf{0}"
1740 
1741     def _print_OneMatrix(self, O):
1742         return r"\mathbb{1}" if self._settings[
1743             'mat_symbol_style'] == 'plain' else r"\mathbf{1}"
1744 
1745     def _print_Identity(self, I):
1746         return r"\mathbb{I}" if self._settings[
1747             'mat_symbol_style'] == 'plain' else r"\mathbf{I}"
1748 
1749     def _print_PermutationMatrix(self, P):
1750         perm_str = self._print(P.args[0])
1751         return "P_{%s}" % perm_str
1752 
1753     def _print_NDimArray(self, expr):
1754 
1755         if expr.rank() == 0:
1756             return self._print(expr[()])
1757 
1758         mat_str = self._settings['mat_str']
1759         if mat_str is None:
1760             if self._settings['mode'] == 'inline':
1761                 mat_str = 'smallmatrix'
1762             else:
1763                 if (expr.rank() == 0) or (expr.shape[-1] <= 10):
1764                     mat_str = 'matrix'
1765                 else:
1766                     mat_str = 'array'
1767         block_str = r'\begin{%MATSTR%}%s\end{%MATSTR%}'
1768         block_str = block_str.replace('%MATSTR%', mat_str)
1769         if self._settings['mat_delim']:
1770             left_delim = self._settings['mat_delim']
1771             right_delim = self._delim_dict[left_delim]
1772             block_str = r'\left' + left_delim + block_str + \
1773                         r'\right' + right_delim
1774 
1775         if expr.rank() == 0:
1776             return block_str % ""
1777 
1778         level_str = [[]] + [[] for i in range(expr.rank())]
1779         shape_ranges = [list(range(i)) for i in expr.shape]
1780         for outer_i in itertools.product(*shape_ranges):
1781             level_str[-1].append(self._print(expr[outer_i]))
1782             even = True
1783             for back_outer_i in range(expr.rank()-1, -1, -1):
1784                 if len(level_str[back_outer_i+1]) < expr.shape[back_outer_i]:
1785                     break
1786                 if even:
1787                     level_str[back_outer_i].append(
1788                         r" & ".join(level_str[back_outer_i+1]))
1789                 else:
1790                     level_str[back_outer_i].append(
1791                         block_str % (r"\\".join(level_str[back_outer_i+1])))
1792                     if len(level_str[back_outer_i+1]) == 1:
1793                         level_str[back_outer_i][-1] = r"\left[" + \
1794                             level_str[back_outer_i][-1] + r"\right]"
1795                 even = not even
1796                 level_str[back_outer_i+1] = []
1797 
1798         out_str = level_str[0][0]
1799 
1800         if expr.rank() % 2 == 1:
1801             out_str = block_str % out_str
1802 
1803         return out_str
1804 
1805     def _printer_tensor_indices(self, name, indices, index_map={}):
1806         out_str = self._print(name)
1807         last_valence = None
1808         prev_map = None
1809         for index in indices:
1810             new_valence = index.is_up
1811             if ((index in index_map) or prev_map) and \
1812                     last_valence == new_valence:
1813                 out_str += ","
1814             if last_valence != new_valence:
1815                 if last_valence is not None:
1816                     out_str += "}"
1817                 if index.is_up:
1818                     out_str += "{}^{"
1819                 else:
1820                     out_str += "{}_{"
1821             out_str += self._print(index.args[0])
1822             if index in index_map:
1823                 out_str += "="
1824                 out_str += self._print(index_map[index])
1825                 prev_map = True
1826             else:
1827                 prev_map = False
1828             last_valence = new_valence
1829         if last_valence is not None:
1830             out_str += "}"
1831         return out_str
1832 
1833     def _print_Tensor(self, expr):
1834         name = expr.args[0].args[0]
1835         indices = expr.get_indices()
1836         return self._printer_tensor_indices(name, indices)
1837 
1838     def _print_TensorElement(self, expr):
1839         name = expr.expr.args[0].args[0]
1840         indices = expr.expr.get_indices()
1841         index_map = expr.index_map
1842         return self._printer_tensor_indices(name, indices, index_map)
1843 
1844     def _print_TensMul(self, expr):
1845         # prints expressions like "A(a)", "3*A(a)", "(1+x)*A(a)"
1846         sign, args = expr._get_args_for_traditional_printer()
1847         return sign + "".join(
1848             [self.parenthesize(arg, precedence(expr)) for arg in args]
1849         )
1850 
1851     def _print_TensAdd(self, expr):
1852         a = []
1853         args = expr.args
1854         for x in args:
1855             a.append(self.parenthesize(x, precedence(expr)))
1856         a.sort()
1857         s = ' + '.join(a)
1858         s = s.replace('+ -', '- ')
1859         return s
1860 
1861     def _print_TensorIndex(self, expr):
1862         return "{}%s{%s}" % (
1863             "^" if expr.is_up else "_",
1864             self._print(expr.args[0])
1865         )
1866 
1867     def _print_PartialDerivative(self, expr):
1868         if len(expr.variables) == 1:
1869             return r"\frac{\partial}{\partial {%s}}{%s}" % (
1870                 self._print(expr.variables[0]),
1871                 self.parenthesize(expr.expr, PRECEDENCE["Mul"], False)
1872             )
1873         else:
1874             return r"\frac{\partial^{%s}}{%s}{%s}" % (
1875                 len(expr.variables),
1876                 " ".join([r"\partial {%s}" % self._print(i) for i in expr.variables]),
1877                 self.parenthesize(expr.expr, PRECEDENCE["Mul"], False)
1878             )
1879 
1880     def _print_UniversalSet(self, expr):
1881         return r"\mathbb{U}"
1882 
1883     def _print_frac(self, expr, exp=None):
1884         if exp is None:
1885             return r"\operatorname{frac}{\left(%s\right)}" % self._print(expr.args[0])
1886         else:
1887             return r"\operatorname{frac}{\left(%s\right)}^{%s}" % (
1888                     self._print(expr.args[0]), exp)
1889 
1890     def _print_tuple(self, expr):
1891         if self._settings['decimal_separator'] == 'comma':
1892             sep = ";"
1893         elif self._settings['decimal_separator'] == 'period':
1894             sep = ","
1895         else:
1896             raise ValueError('Unknown Decimal Separator')
1897 
1898         if len(expr) == 1:
1899             # 1-tuple needs a trailing separator
1900             return self._add_parens_lspace(self._print(expr[0]) + sep)
1901         else:
1902             return self._add_parens_lspace(
1903                 (sep + r" \  ").join([self._print(i) for i in expr]))
1904 
1905     def _print_TensorProduct(self, expr):
1906         elements = [self._print(a) for a in expr.args]
1907         return r' \otimes '.join(elements)
1908 
1909     def _print_WedgeProduct(self, expr):
1910         elements = [self._print(a) for a in expr.args]
1911         return r' \wedge '.join(elements)
1912 
1913     def _print_Tuple(self, expr):
1914         return self._print_tuple(expr)
1915 
1916     def _print_list(self, expr):
1917         if self._settings['decimal_separator'] == 'comma':
1918             return r"\left[ %s\right]" % \
1919                 r"; \  ".join([self._print(i) for i in expr])
1920         elif self._settings['decimal_separator'] == 'period':
1921             return r"\left[ %s\right]" % \
1922                 r", \  ".join([self._print(i) for i in expr])
1923         else:
1924             raise ValueError('Unknown Decimal Separator')
1925 
1926 
1927     def _print_dict(self, d):
1928         keys = sorted(d.keys(), key=default_sort_key)
1929         items = []
1930 
1931         for key in keys:
1932             val = d[key]
1933             items.append("%s : %s" % (self._print(key), self._print(val)))
1934 
1935         return r"\left\{ %s\right\}" % r", \  ".join(items)
1936 
1937     def _print_Dict(self, expr):
1938         return self._print_dict(expr)
1939 
1940     def _print_DiracDelta(self, expr, exp=None):
1941         if len(expr.args) == 1 or expr.args[1] == 0:
1942             tex = r"\delta\left(%s\right)" % self._print(expr.args[0])
1943         else:
1944             tex = r"\delta^{\left( %s \right)}\left( %s \right)" % (
1945                 self._print(expr.args[1]), self._print(expr.args[0]))
1946         if exp:
1947             tex = r"\left(%s\right)^{%s}" % (tex, exp)
1948         return tex
1949 
1950     def _print_SingularityFunction(self, expr):
1951         shift = self._print(expr.args[0] - expr.args[1])
1952         power = self._print(expr.args[2])
1953         tex = r"{\left\langle %s \right\rangle}^{%s}" % (shift, power)
1954         return tex
1955 
1956     def _print_Heaviside(self, expr, exp=None):
1957         tex = r"\theta\left(%s\right)" % self._print(expr.args[0])
1958         if exp:
1959             tex = r"\left(%s\right)^{%s}" % (tex, exp)
1960         return tex
1961 
1962     def _print_KroneckerDelta(self, expr, exp=None):
1963         i = self._print(expr.args[0])
1964         j = self._print(expr.args[1])
1965         if expr.args[0].is_Atom and expr.args[1].is_Atom:
1966             tex = r'\delta_{%s %s}' % (i, j)
1967         else:
1968             tex = r'\delta_{%s, %s}' % (i, j)
1969         if exp is not None:
1970             tex = r'\left(%s\right)^{%s}' % (tex, exp)
1971         return tex
1972 
1973     def _print_LeviCivita(self, expr, exp=None):
1974         indices = map(self._print, expr.args)
1975         if all(x.is_Atom for x in expr.args):
1976             tex = r'\varepsilon_{%s}' % " ".join(indices)
1977         else:
1978             tex = r'\varepsilon_{%s}' % ", ".join(indices)
1979         if exp:
1980             tex = r'\left(%s\right)^{%s}' % (tex, exp)
1981         return tex
1982 
1983     def _print_RandomDomain(self, d):
1984         if hasattr(d, 'as_boolean'):
1985             return '\\text{Domain: }' + self._print(d.as_boolean())
1986         elif hasattr(d, 'set'):
1987             return ('\\text{Domain: }' + self._print(d.symbols) + '\\text{ in }' +
1988                     self._print(d.set))
1989         elif hasattr(d, 'symbols'):
1990             return '\\text{Domain on }' + self._print(d.symbols)
1991         else:
1992             return self._print(None)
1993 
1994     def _print_FiniteSet(self, s):
1995         items = sorted(s.args, key=default_sort_key)
1996         return self._print_set(items)
1997 
1998     def _print_set(self, s):
1999         items = sorted(s, key=default_sort_key)
2000         if self._settings['decimal_separator'] == 'comma':
2001             items = "; ".join(map(self._print, items))
2002         elif self._settings['decimal_separator'] == 'period':
2003             items = ", ".join(map(self._print, items))
2004         else:
2005             raise ValueError('Unknown Decimal Separator')
2006         return r"\left\{%s\right\}" % items
2007 
2008 
2009     _print_frozenset = _print_set
2010 
2011     def _print_Range(self, s):
2012         dots = object()
2013 
2014         if s.has(Symbol):
2015             return self._print_Basic(s)
2016 
2017         if s.start.is_infinite and s.stop.is_infinite:
2018             if s.step.is_positive:
2019                 printset = dots, -1, 0, 1, dots
2020             else:
2021                 printset = dots, 1, 0, -1, dots
2022         elif s.start.is_infinite:
2023             printset = dots, s[-1] - s.step, s[-1]
2024         elif s.stop.is_infinite:
2025             it = iter(s)
2026             printset = next(it), next(it), dots
2027         elif len(s) > 4:
2028             it = iter(s)
2029             printset = next(it), next(it), dots, s[-1]
2030         else:
2031             printset = tuple(s)
2032 
2033         return (r"\left\{" +
2034                 r", ".join(self._print(el) if el is not dots else r'\ldots' for el in printset) +
2035                 r"\right\}")
2036 
2037     def __print_number_polynomial(self, expr, letter, exp=None):
2038         if len(expr.args) == 2:
2039             if exp is not None:
2040                 return r"%s_{%s}^{%s}\left(%s\right)" % (letter,
2041                             self._print(expr.args[0]), exp,
2042                             self._print(expr.args[1]))
2043             return r"%s_{%s}\left(%s\right)" % (letter,
2044                         self._print(expr.args[0]), self._print(expr.args[1]))
2045 
2046         tex = r"%s_{%s}" % (letter, self._print(expr.args[0]))
2047         if exp is not None:
2048             tex = r"%s^{%s}" % (tex, exp)
2049         return tex
2050 
2051     def _print_bernoulli(self, expr, exp=None):
2052         return self.__print_number_polynomial(expr, "B", exp)
2053 
2054     def _print_bell(self, expr, exp=None):
2055         if len(expr.args) == 3:
2056             tex1 = r"B_{%s, %s}" % (self._print(expr.args[0]),
2057                                 self._print(expr.args[1]))
2058             tex2 = r"\left(%s\right)" % r", ".join(self._print(el) for
2059                                                el in expr.args[2])
2060             if exp is not None:
2061                 tex = r"%s^{%s}%s" % (tex1, exp, tex2)
2062             else:
2063                 tex = tex1 + tex2
2064             return tex
2065         return self.__print_number_polynomial(expr, "B", exp)
2066 
2067 
2068     def _print_fibonacci(self, expr, exp=None):
2069         return self.__print_number_polynomial(expr, "F", exp)
2070 
2071     def _print_lucas(self, expr, exp=None):
2072         tex = r"L_{%s}" % self._print(expr.args[0])
2073         if exp is not None:
2074             tex = r"%s^{%s}" % (tex, exp)
2075         return tex
2076 
2077     def _print_tribonacci(self, expr, exp=None):
2078         return self.__print_number_polynomial(expr, "T", exp)
2079 
2080     def _print_SeqFormula(self, s):
2081         dots = object()
2082         if len(s.start.free_symbols) > 0 or len(s.stop.free_symbols) > 0:
2083             return r"\left\{%s\right\}_{%s=%s}^{%s}" % (
2084                 self._print(s.formula),
2085                 self._print(s.variables[0]),
2086                 self._print(s.start),
2087                 self._print(s.stop)
2088             )
2089         if s.start is S.NegativeInfinity:
2090             stop = s.stop
2091             printset = (dots, s.coeff(stop - 3), s.coeff(stop - 2),
2092                         s.coeff(stop - 1), s.coeff(stop))
2093         elif s.stop is S.Infinity or s.length > 4:
2094             printset = s[:4]
2095             printset.append(dots)
2096         else:
2097             printset = tuple(s)
2098 
2099         return (r"\left[" +
2100                 r", ".join(self._print(el) if el is not dots else r'\ldots' for el in printset) +
2101                 r"\right]")
2102 
2103     _print_SeqPer = _print_SeqFormula
2104     _print_SeqAdd = _print_SeqFormula
2105     _print_SeqMul = _print_SeqFormula
2106 
2107     def _print_Interval(self, i):
2108         if i.start == i.end:
2109             return r"\left\{%s\right\}" % self._print(i.start)
2110 
2111         else:
2112             if i.left_open:
2113                 left = '('
2114             else:
2115                 left = '['
2116 
2117             if i.right_open:
2118                 right = ')'
2119             else:
2120                 right = ']'
2121 
2122             return r"\left%s%s, %s\right%s" % \
2123                    (left, self._print(i.start), self._print(i.end), right)
2124 
2125     def _print_AccumulationBounds(self, i):
2126         return r"\left\langle %s, %s\right\rangle" % \
2127                 (self._print(i.min), self._print(i.max))
2128 
2129     def _print_Union(self, u):
2130         prec = precedence_traditional(u)
2131         args_str = [self.parenthesize(i, prec) for i in u.args]
2132         return r" \cup ".join(args_str)
2133 
2134     def _print_Complement(self, u):
2135         prec = precedence_traditional(u)
2136         args_str = [self.parenthesize(i, prec) for i in u.args]
2137         return r" \setminus ".join(args_str)
2138 
2139     def _print_Intersection(self, u):
2140         prec = precedence_traditional(u)
2141         args_str = [self.parenthesize(i, prec) for i in u.args]
2142         return r" \cap ".join(args_str)
2143 
2144     def _print_SymmetricDifference(self, u):
2145         prec = precedence_traditional(u)
2146         args_str = [self.parenthesize(i, prec) for i in u.args]
2147         return r" \triangle ".join(args_str)
2148 
2149     def _print_ProductSet(self, p):
2150         prec = precedence_traditional(p)
2151         if len(p.sets) >= 1 and not has_variety(p.sets):
2152             return self.parenthesize(p.sets[0], prec) + "^{%d}" % len(p.sets)
2153         return r" \times ".join(
2154             self.parenthesize(set, prec) for set in p.sets)
2155 
2156     def _print_EmptySet(self, e):
2157         return r"\emptyset"
2158 
2159     def _print_Naturals(self, n):
2160         return r"\mathbb{N}"
2161 
2162     def _print_Naturals0(self, n):
2163         return r"\mathbb{N}_0"
2164 
2165     def _print_Integers(self, i):
2166         return r"\mathbb{Z}"
2167 
2168     def _print_Rationals(self, i):
2169         return r"\mathbb{Q}"
2170 
2171     def _print_Reals(self, i):
2172         return r"\mathbb{R}"
2173 
2174     def _print_Complexes(self, i):
2175         return r"\mathbb{C}"
2176 
2177     def _print_ImageSet(self, s):
2178         expr = s.lamda.expr
2179         sig = s.lamda.signature
2180         xys = ((self._print(x), self._print(y)) for x, y in zip(sig, s.base_sets))
2181         xinys = r" , ".join(r"%s \in %s" % xy for xy in xys)
2182         return r"\left\{%s\; |\; %s\right\}" % (self._print(expr), xinys)
2183 
2184     def _print_ConditionSet(self, s):
2185         vars_print = ', '.join([self._print(var) for var in Tuple(s.sym)])
2186         if s.base_set is S.UniversalSet:
2187             return r"\left\{%s \mid %s \right\}" % \
2188                 (vars_print, self._print(s.condition))
2189 
2190         return r"\left\{%s \mid %s \in %s \wedge %s \right\}" % (
2191             vars_print,
2192             vars_print,
2193             self._print(s.base_set),
2194             self._print(s.condition))
2195 
2196     def _print_ComplexRegion(self, s):
2197         vars_print = ', '.join([self._print(var) for var in s.variables])
2198         return r"\left\{%s\; |\; %s \in %s \right\}" % (
2199             self._print(s.expr),
2200             vars_print,
2201             self._print(s.sets))
2202 
2203     def _print_Contains(self, e):
2204         return r"%s \in %s" % tuple(self._print(a) for a in e.args)
2205 
2206     def _print_FourierSeries(self, s):
2207         return self._print_Add(s.truncate()) + r' + \ldots'
2208 
2209     def _print_FormalPowerSeries(self, s):
2210         return self._print_Add(s.infinite)
2211 
2212     def _print_FiniteField(self, expr):
2213         return r"\mathbb{F}_{%s}" % expr.mod
2214 
2215     def _print_IntegerRing(self, expr):
2216         return r"\mathbb{Z}"
2217 
2218     def _print_RationalField(self, expr):
2219         return r"\mathbb{Q}"
2220 
2221     def _print_RealField(self, expr):
2222         return r"\mathbb{R}"
2223 
2224     def _print_ComplexField(self, expr):
2225         return r"\mathbb{C}"
2226 
2227     def _print_PolynomialRing(self, expr):
2228         domain = self._print(expr.domain)
2229         symbols = ", ".join(map(self._print, expr.symbols))
2230         return r"%s\left[%s\right]" % (domain, symbols)
2231 
2232     def _print_FractionField(self, expr):
2233         domain = self._print(expr.domain)
2234         symbols = ", ".join(map(self._print, expr.symbols))
2235         return r"%s\left(%s\right)" % (domain, symbols)
2236 
2237     def _print_PolynomialRingBase(self, expr):
2238         domain = self._print(expr.domain)
2239         symbols = ", ".join(map(self._print, expr.symbols))
2240         inv = ""
2241         if not expr.is_Poly:
2242             inv = r"S_<^{-1}"
2243         return r"%s%s\left[%s\right]" % (inv, domain, symbols)
2244 
2245     def _print_Poly(self, poly):
2246         cls = poly.__class__.__name__
2247         terms = []
2248         for monom, coeff in poly.terms():
2249             s_monom = ''
2250             for i, exp in enumerate(monom):
2251                 if exp > 0:
2252                     if exp == 1:
2253                         s_monom += self._print(poly.gens[i])
2254                     else:
2255                         s_monom += self._print(pow(poly.gens[i], exp))
2256 
2257             if coeff.is_Add:
2258                 if s_monom:
2259                     s_coeff = r"\left(%s\right)" % self._print(coeff)
2260                 else:
2261                     s_coeff = self._print(coeff)
2262             else:
2263                 if s_monom:
2264                     if coeff is S.One:
2265                         terms.extend(['+', s_monom])
2266                         continue
2267 
2268                     if coeff is S.NegativeOne:
2269                         terms.extend(['-', s_monom])
2270                         continue
2271 
2272                 s_coeff = self._print(coeff)
2273 
2274             if not s_monom:
2275                 s_term = s_coeff
2276             else:
2277                 s_term = s_coeff + " " + s_monom
2278 
2279             if s_term.startswith('-'):
2280                 terms.extend(['-', s_term[1:]])
2281             else:
2282                 terms.extend(['+', s_term])
2283 
2284         if terms[0] in ['-', '+']:
2285             modifier = terms.pop(0)
2286 
2287             if modifier == '-':
2288                 terms[0] = '-' + terms[0]
2289 
2290         expr = ' '.join(terms)
2291         gens = list(map(self._print, poly.gens))
2292         domain = "domain=%s" % self._print(poly.get_domain())
2293 
2294         args = ", ".join([expr] + gens + [domain])
2295         if cls in accepted_latex_functions:
2296             tex = r"\%s {\left(%s \right)}" % (cls, args)
2297         else:
2298             tex = r"\operatorname{%s}{\left( %s \right)}" % (cls, args)
2299 
2300         return tex
2301 
2302     def _print_ComplexRootOf(self, root):
2303         cls = root.__class__.__name__
2304         if cls == "ComplexRootOf":
2305             cls = "CRootOf"
2306         expr = self._print(root.expr)
2307         index = root.index
2308         if cls in accepted_latex_functions:
2309             return r"\%s {\left(%s, %d\right)}" % (cls, expr, index)
2310         else:
2311             return r"\operatorname{%s} {\left(%s, %d\right)}" % (cls, expr,
2312                                                                  index)
2313 
2314     def _print_RootSum(self, expr):
2315         cls = expr.__class__.__name__
2316         args = [self._print(expr.expr)]
2317 
2318         if expr.fun is not S.IdentityFunction:
2319             args.append(self._print(expr.fun))
2320 
2321         if cls in accepted_latex_functions:
2322             return r"\%s {\left(%s\right)}" % (cls, ", ".join(args))
2323         else:
2324             return r"\operatorname{%s} {\left(%s\right)}" % (cls,
2325                                                              ", ".join(args))
2326 
2327     def _print_PolyElement(self, poly):
2328         mul_symbol = self._settings['mul_symbol_latex']
2329         return poly.str(self, PRECEDENCE, "{%s}^{%d}", mul_symbol)
2330 
2331     def _print_FracElement(self, frac):
2332         if frac.denom == 1:
2333             return self._print(frac.numer)
2334         else:
2335             numer = self._print(frac.numer)
2336             denom = self._print(frac.denom)
2337             return r"\frac{%s}{%s}" % (numer, denom)
2338 
2339     def _print_euler(self, expr, exp=None):
2340         m, x = (expr.args[0], None) if len(expr.args) == 1 else expr.args
2341         tex = r"E_{%s}" % self._print(m)
2342         if exp is not None:
2343             tex = r"%s^{%s}" % (tex, exp)
2344         if x is not None:
2345             tex = r"%s\left(%s\right)" % (tex, self._print(x))
2346         return tex
2347 
2348     def _print_catalan(self, expr, exp=None):
2349         tex = r"C_{%s}" % self._print(expr.args[0])
2350         if exp is not None:
2351             tex = r"%s^{%s}" % (tex, exp)
2352         return tex
2353 
2354     def _print_UnifiedTransform(self, expr, s, inverse=False):
2355         return r"\mathcal{{{}}}{}_{{{}}}\left[{}\right]\left({}\right)".format(s, '^{-1}' if inverse else '', self._print(expr.args[1]), self._print(expr.args[0]), self._print(expr.args[2]))
2356 
2357     def _print_MellinTransform(self, expr):
2358         return self._print_UnifiedTransform(expr, 'M')
2359 
2360     def _print_InverseMellinTransform(self, expr):
2361         return self._print_UnifiedTransform(expr, 'M', True)
2362 
2363     def _print_LaplaceTransform(self, expr):
2364         return self._print_UnifiedTransform(expr, 'L')
2365 
2366     def _print_InverseLaplaceTransform(self, expr):
2367         return self._print_UnifiedTransform(expr, 'L', True)
2368 
2369     def _print_FourierTransform(self, expr):
2370         return self._print_UnifiedTransform(expr, 'F')
2371 
2372     def _print_InverseFourierTransform(self, expr):
2373         return self._print_UnifiedTransform(expr, 'F', True)
2374 
2375     def _print_SineTransform(self, expr):
2376         return self._print_UnifiedTransform(expr, 'SIN')
2377 
2378     def _print_InverseSineTransform(self, expr):
2379         return self._print_UnifiedTransform(expr, 'SIN', True)
2380 
2381     def _print_CosineTransform(self, expr):
2382         return self._print_UnifiedTransform(expr, 'COS')
2383 
2384     def _print_InverseCosineTransform(self, expr):
2385         return self._print_UnifiedTransform(expr, 'COS', True)
2386 
2387     def _print_DMP(self, p):
2388         try:
2389             if p.ring is not None:
2390                 # TODO incorporate order
2391                 return self._print(p.ring.to_sympy(p))
2392         except SympifyError:
2393             pass
2394         return self._print(repr(p))
2395 
2396     def _print_DMF(self, p):
2397         return self._print_DMP(p)
2398 
2399     def _print_Object(self, object):
2400         return self._print(Symbol(object.name))
2401 
2402     def _print_LambertW(self, expr):
2403         if len(expr.args) == 1:
2404             return r"W\left(%s\right)" % self._print(expr.args[0])
2405         return r"W_{%s}\left(%s\right)" % \
2406             (self._print(expr.args[1]), self._print(expr.args[0]))
2407 
2408     def _print_Morphism(self, morphism):
2409         domain = self._print(morphism.domain)
2410         codomain = self._print(morphism.codomain)
2411         return "%s\\rightarrow %s" % (domain, codomain)
2412 
2413     def _print_TransferFunction(self, expr):
2414         from sympy.core import Mul, Pow
2415         num, den = expr.num, expr.den
2416         res = Mul(num, Pow(den, -1, evaluate=False), evaluate=False)
2417         return self._print_Mul(res)
2418 
2419     def _print_Series(self, expr):
2420         args = list(expr.args)
2421         parens = lambda x: self.parenthesize(x, precedence_traditional(expr),
2422                                              False)
2423         return ' '.join(map(parens, args))
2424 
2425     def _print_Parallel(self, expr):
2426         args = list(expr.args)
2427         parens = lambda x: self.parenthesize(x, precedence_traditional(expr),
2428                                              False)
2429         return ' '.join(map(parens, args))
2430 
2431     def _print_Feedback(self, expr):
2432         from sympy.physics.control import TransferFunction, Parallel, Series
2433 
2434         num, tf = expr.num, TransferFunction(1, 1, expr.num.var)
2435         num_arg_list = list(num.args) if isinstance(num, Series) else [num]
2436         den_arg_list = list(expr.den.args) if isinstance(expr.den, Series) else [expr.den]
2437 
2438         if isinstance(num, Series) and isinstance(expr.den, Series):
2439             den = Parallel(tf, Series(*num_arg_list, *den_arg_list))
2440         elif isinstance(num, Series) and isinstance(expr.den, TransferFunction):
2441             if expr.den == tf:
2442                 den = Parallel(tf, Series(*num_arg_list))
2443             else:
2444                 den = Parallel(tf, Series(*num_arg_list, expr.den))
2445         elif isinstance(num, TransferFunction) and isinstance(expr.den, Series):
2446             if num == tf:
2447                 den = Parallel(tf, Series(*den_arg_list))
2448             else:
2449                 den = Parallel(tf, Series(num, *den_arg_list))
2450         else:
2451             if num == tf:
2452                 den = Parallel(tf, *den_arg_list)
2453             elif expr.den == tf:
2454                 den = Parallel(tf, *num_arg_list)
2455             else:
2456                 den = Parallel(tf, Series(*num_arg_list, *den_arg_list))
2457 
2458         numer = self._print(num)
2459         denom = self._print(den)
2460         return r"\frac{%s}{%s}" % (numer, denom)
2461 
2462     def _print_NamedMorphism(self, morphism):
2463         pretty_name = self._print(Symbol(morphism.name))
2464         pretty_morphism = self._print_Morphism(morphism)
2465         return "%s:%s" % (pretty_name, pretty_morphism)
2466 
2467     def _print_IdentityMorphism(self, morphism):
2468         from sympy.categories import NamedMorphism
2469         return self._print_NamedMorphism(NamedMorphism(
2470             morphism.domain, morphism.codomain, "id"))
2471 
2472     def _print_CompositeMorphism(self, morphism):
2473         # All components of the morphism have names and it is thus
2474         # possible to build the name of the composite.
2475         component_names_list = [self._print(Symbol(component.name)) for
2476                                 component in morphism.components]
2477         component_names_list.reverse()
2478         component_names = "\\circ ".join(component_names_list) + ":"
2479 
2480         pretty_morphism = self._print_Morphism(morphism)
2481         return component_names + pretty_morphism
2482 
2483     def _print_Category(self, morphism):
2484         return r"\mathbf{{{}}}".format(self._print(Symbol(morphism.name)))
2485 
2486     def _print_Diagram(self, diagram):
2487         if not diagram.premises:
2488             # This is an empty diagram.
2489             return self._print(S.EmptySet)
2490 
2491         latex_result = self._print(diagram.premises)
2492         if diagram.conclusions:
2493             latex_result += "\\Longrightarrow %s" % \
2494                             self._print(diagram.conclusions)
2495 
2496         return latex_result
2497 
2498     def _print_DiagramGrid(self, grid):
2499         latex_result = "\\begin{array}{%s}\n" % ("c" * grid.width)
2500 
2501         for i in range(grid.height):
2502             for j in range(grid.width):
2503                 if grid[i, j]:
2504                     latex_result += latex(grid[i, j])
2505                 latex_result += " "
2506                 if j != grid.width - 1:
2507                     latex_result += "& "
2508 
2509             if i != grid.height - 1:
2510                 latex_result += "\\\\"
2511             latex_result += "\n"
2512 
2513         latex_result += "\\end{array}\n"
2514         return latex_result
2515 
2516     def _print_FreeModule(self, M):
2517         return '{{{}}}^{{{}}}'.format(self._print(M.ring), self._print(M.rank))
2518 
2519     def _print_FreeModuleElement(self, m):
2520         # Print as row vector for convenience, for now.
2521         return r"\left[ {} \right]".format(",".join(
2522             '{' + self._print(x) + '}' for x in m))
2523 
2524     def _print_SubModule(self, m):
2525         return r"\left\langle {} \right\rangle".format(",".join(
2526             '{' + self._print(x) + '}' for x in m.gens))
2527 
2528     def _print_ModuleImplementedIdeal(self, m):
2529         return r"\left\langle {} \right\rangle".format(",".join(
2530             '{' + self._print(x) + '}' for [x] in m._module.gens))
2531 
2532     def _print_Quaternion(self, expr):
2533         # TODO: This expression is potentially confusing,
2534         # shall we print it as `Quaternion( ... )`?
2535         s = [self.parenthesize(i, PRECEDENCE["Mul"], strict=True)
2536              for i in expr.args]
2537         a = [s[0]] + [i+" "+j for i, j in zip(s[1:], "ijk")]
2538         return " + ".join(a)
2539 
2540     def _print_QuotientRing(self, R):
2541         # TODO nicer fractions for few generators...
2542         return r"\frac{{{}}}{{{}}}".format(self._print(R.ring),
2543                  self._print(R.base_ideal))
2544 
2545     def _print_QuotientRingElement(self, x):
2546         return r"{{{}}} + {{{}}}".format(self._print(x.data),
2547                  self._print(x.ring.base_ideal))
2548 
2549     def _print_QuotientModuleElement(self, m):
2550         return r"{{{}}} + {{{}}}".format(self._print(m.data),
2551                  self._print(m.module.killed_module))
2552 
2553     def _print_QuotientModule(self, M):
2554         # TODO nicer fractions for few generators...
2555         return r"\frac{{{}}}{{{}}}".format(self._print(M.base),
2556                  self._print(M.killed_module))
2557 
2558     def _print_MatrixHomomorphism(self, h):
2559         return r"{{{}}} : {{{}}} \to {{{}}}".format(self._print(h._sympy_matrix()),
2560             self._print(h.domain), self._print(h.codomain))
2561 
2562     def _print_Manifold(self, manifold):
2563         string = manifold.name.name
2564         if '{' in string:
2565             name, supers, subs = string, [], []
2566         else:
2567             name, supers, subs = split_super_sub(string)
2568 
2569             name = translate(name)
2570             supers = [translate(sup) for sup in supers]
2571             subs = [translate(sub) for sub in subs]
2572 
2573         name = r'\text{%s}' % name
2574         if supers:
2575             name += "^{%s}" % " ".join(supers)
2576         if subs:
2577             name += "_{%s}" % " ".join(subs)
2578 
2579         return name
2580 
2581     def _print_Patch(self, patch):
2582         return r'\text{%s}_{%s}' % (self._print(patch.name), self._print(patch.manifold))
2583 
2584     def _print_CoordSystem(self, coordsys):
2585         return r'\text{%s}^{\text{%s}}_{%s}' % (
2586             self._print(coordsys.name), self._print(coordsys.patch.name), self._print(coordsys.manifold)
2587         )
2588 
2589     def _print_CovarDerivativeOp(self, cvd):
2590         return r'\mathbb{\nabla}_{%s}' % self._print(cvd._wrt)
2591 
2592     def _print_BaseScalarField(self, field):
2593         string = field._coord_sys.symbols[field._index].name
2594         return r'\mathbf{{{}}}'.format(self._print(Symbol(string)))
2595 
2596     def _print_BaseVectorField(self, field):
2597         string = field._coord_sys.symbols[field._index].name
2598         return r'\partial_{{{}}}'.format(self._print(Symbol(string)))
2599 
2600     def _print_Differential(self, diff):
2601         field = diff._form_field
2602         if hasattr(field, '_coord_sys'):
2603             string = field._coord_sys.symbols[field._index].name
2604             return r'\operatorname{{d}}{}'.format(self._print(Symbol(string)))
2605         else:
2606             string = self._print(field)
2607             return r'\operatorname{{d}}\left({}\right)'.format(string)
2608 
2609     def _print_Tr(self, p):
2610         # TODO: Handle indices
2611         contents = self._print(p.args[0])
2612         return r'\operatorname{{tr}}\left({}\right)'.format(contents)
2613 
2614     def _print_totient(self, expr, exp=None):
2615         if exp is not None:
2616             return r'\left(\phi\left(%s\right)\right)^{%s}' % \
2617                 (self._print(expr.args[0]), exp)
2618         return r'\phi\left(%s\right)' % self._print(expr.args[0])
2619 
2620     def _print_reduced_totient(self, expr, exp=None):
2621         if exp is not None:
2622             return r'\left(\lambda\left(%s\right)\right)^{%s}' % \
2623                 (self._print(expr.args[0]), exp)
2624         return r'\lambda\left(%s\right)' % self._print(expr.args[0])
2625 
2626     def _print_divisor_sigma(self, expr, exp=None):
2627         if len(expr.args) == 2:
2628             tex = r"_%s\left(%s\right)" % tuple(map(self._print,
2629                                                 (expr.args[1], expr.args[0])))
2630         else:
2631             tex = r"\left(%s\right)" % self._print(expr.args[0])
2632         if exp is not None:
2633             return r"\sigma^{%s}%s" % (exp, tex)
2634         return r"\sigma%s" % tex
2635 
2636     def _print_udivisor_sigma(self, expr, exp=None):
2637         if len(expr.args) == 2:
2638             tex = r"_%s\left(%s\right)" % tuple(map(self._print,
2639                                                 (expr.args[1], expr.args[0])))
2640         else:
2641             tex = r"\left(%s\right)" % self._print(expr.args[0])
2642         if exp is not None:
2643             return r"\sigma^*^{%s}%s" % (exp, tex)
2644         return r"\sigma^*%s" % tex
2645 
2646     def _print_primenu(self, expr, exp=None):
2647         if exp is not None:
2648             return r'\left(\nu\left(%s\right)\right)^{%s}' % \
2649                 (self._print(expr.args[0]), exp)
2650         return r'\nu\left(%s\right)' % self._print(expr.args[0])
2651 
2652     def _print_primeomega(self, expr, exp=None):
2653         if exp is not None:
2654             return r'\left(\Omega\left(%s\right)\right)^{%s}' % \
2655                 (self._print(expr.args[0]), exp)
2656         return r'\Omega\left(%s\right)' % self._print(expr.args[0])
2657 
2658     def _print_Str(self, s):
2659         return str(s.name)
2660 
2661     def _print_float(self, expr):
2662         return self._print(Float(expr))
2663 
2664     def _print_int(self, expr):
2665         return str(expr)
2666 
2667     def _print_mpz(self, expr):
2668         return str(expr)
2669 
2670     def _print_mpq(self, expr):
2671         return str(expr)
2672 
2673     def emptyPrinter(self, expr):
2674         # default to just printing as monospace, like would normally be shown
2675         s = super().emptyPrinter(expr)
2676 
2677         return r"\mathtt{\text{%s}}" % latex_escape(s)

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>]
2025-10-18 20:42:48.941 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-18 20:42:48.941 | INFO     | Search-only: skipping patch selection
2025-10-18 20:42:49.097 | INFO     | Task sympy__sympy-20264 completed successfully.
2025-10-18 20:42:49.098 | INFO     | No patch generated. You can try running ACR again.
