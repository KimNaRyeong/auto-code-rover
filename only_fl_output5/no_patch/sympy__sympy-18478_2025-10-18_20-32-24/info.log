2025-10-18 20:32:24.766 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-18 20:32:35.279 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=129, output_tokens=13, cost=0.001680
2025-10-18 20:32:47.801 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=309, output_tokens=455, cost=0.016740
2025-10-18 20:32:49.620 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 20:32:55.725 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=438, output_tokens=279, cost=0.012750
2025-10-18 20:32:55.733 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 20:32:58.565 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=633, output_tokens=58, cost=0.008070
2025-10-18 20:32:58.566 | DEBUG    | Extracted a valid json.
2025-10-18 20:32:58.567 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_method(\"subs\")",
        "search_method_in_class(\"exp\", \"Function\")",
        "search_method_in_class(\"cos\", \"Function\")",
        "search_code(\"oo\")"
    ],
    "bug_locations": []
}
2025-10-18 20:33:29.518 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-18 20:33:29.519 | DEBUG    | <Agent search> Analyzing search results.
2025-10-18 20:33:50.775 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=11135, output_tokens=756, cost=0.134030
2025-10-18 20:33:50.782 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 20:34:00.207 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=12107, output_tokens=370, cost=0.132170
2025-10-18 20:34:00.212 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 20:34:05.879 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=724, output_tokens=208, cost=0.013480
2025-10-18 20:34:05.880 | DEBUG    | Extracted a valid json.
2025-10-18 20:34:05.886 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations": [
        {
            "file": "sympy/core/basic.py",
            "class": "",
            "method": "subs",
            "intended_behavior": "This code should ensure that expressions like `exp(x)` and `cos(x)` substituted with `oo` evaluate to infinity or the appropriate mathematical limit without reverting to `AccumBounds` unless absolutely mathematically necessary. The method should distinguish between cases where a function grows without bound vs. oscillates as `x` approaches infinity."
        },
        {
            "file": "sympy/calculus/util.py",
            "class": "",
            "method": "",
            "intended_behavior": "This code should ensure that any utility functions or mechanisms responsible for evaluating limits or behavior at infinity (`oo`) correctly interpret mathematical functions' growth, direction, or oscillation as they approach infinity, specifically accounting for exponential growth in a manner distinct from bounded oscillations or other behaviors."
        }
    ]
}
2025-10-18 20:34:05.897 | DEBUG    | Bug location extracted successfully: [<file>sympy/core/basic.py</file>
<class>None</class>
<method>subs</method>
<code>
778     def subs(self, *args, **kwargs):
779         """
780         Substitutes old for new in an expression after sympifying args.
781 
782         `args` is either:
783           - two arguments, e.g. foo.subs(old, new)
784           - one iterable argument, e.g. foo.subs(iterable). The iterable may be
785              o an iterable container with (old, new) pairs. In this case the
786                replacements are processed in the order given with successive
787                patterns possibly affecting replacements already made.
788              o a dict or set whose key/value items correspond to old/new pairs.
789                In this case the old/new pairs will be sorted by op count and in
790                case of a tie, by number of args and the default_sort_key. The
791                resulting sorted list is then processed as an iterable container
792                (see previous).
793 
794         If the keyword ``simultaneous`` is True, the subexpressions will not be
795         evaluated until all the substitutions have been made.
796 
797         Examples
798         ========
799 
800         >>> from sympy import pi, exp, limit, oo
801         >>> from sympy.abc import x, y
802         >>> (1 + x*y).subs(x, pi)
803         pi*y + 1
804         >>> (1 + x*y).subs({x:pi, y:2})
805         1 + 2*pi
806         >>> (1 + x*y).subs([(x, pi), (y, 2)])
807         1 + 2*pi
808         >>> reps = [(y, x**2), (x, 2)]
809         >>> (x + y).subs(reps)
810         6
811         >>> (x + y).subs(reversed(reps))
812         x**2 + 2
813 
814         >>> (x**2 + x**4).subs(x**2, y)
815         y**2 + y
816 
817         To replace only the x**2 but not the x**4, use xreplace:
818 
819         >>> (x**2 + x**4).xreplace({x**2: y})
820         x**4 + y
821 
822         To delay evaluation until all substitutions have been made,
823         set the keyword ``simultaneous`` to True:
824 
825         >>> (x/y).subs([(x, 0), (y, 0)])
826         0
827         >>> (x/y).subs([(x, 0), (y, 0)], simultaneous=True)
828         nan
829 
830         This has the added feature of not allowing subsequent substitutions
831         to affect those already made:
832 
833         >>> ((x + y)/y).subs({x + y: y, y: x + y})
834         1
835         >>> ((x + y)/y).subs({x + y: y, y: x + y}, simultaneous=True)
836         y/(x + y)
837 
838         In order to obtain a canonical result, unordered iterables are
839         sorted by count_op length, number of arguments and by the
840         default_sort_key to break any ties. All other iterables are left
841         unsorted.
842 
843         >>> from sympy import sqrt, sin, cos
844         >>> from sympy.abc import a, b, c, d, e
845 
846         >>> A = (sqrt(sin(2*x)), a)
847         >>> B = (sin(2*x), b)
848         >>> C = (cos(2*x), c)
849         >>> D = (x, d)
850         >>> E = (exp(x), e)
851 
852         >>> expr = sqrt(sin(2*x))*sin(exp(x)*x)*cos(2*x) + sin(2*x)
853 
854         >>> expr.subs(dict([A, B, C, D, E]))
855         a*c*sin(d*e) + b
856 
857         The resulting expression represents a literal replacement of the
858         old arguments with the new arguments. This may not reflect the
859         limiting behavior of the expression:
860 
861         >>> (x**3 - 3*x).subs({x: oo})
862         nan
863 
864         >>> limit(x**3 - 3*x, x, oo)
865         oo
866 
867         If the substitution will be followed by numerical
868         evaluation, it is better to pass the substitution to
869         evalf as
870 
871         >>> (1/x).evalf(subs={x: 3.0}, n=21)
872         0.333333333333333333333
873 
874         rather than
875 
876         >>> (1/x).subs({x: 3.0}).evalf(21)
877         0.333333333333333314830
878 
879         as the former will ensure that the desired level of precision is
880         obtained.
881 
882         See Also
883         ========
884         replace: replacement capable of doing wildcard-like matching,
885                  parsing of match, and conditional replacements
886         xreplace: exact node replacement in expr tree; also capable of
887                   using matching rules
888         sympy.core.evalf.EvalfMixin.evalf: calculates the given formula to a desired level of precision
889 
890         """
891         from sympy.core.containers import Dict
892         from sympy.utilities import default_sort_key
893         from sympy import Dummy, Symbol
894 
895         unordered = False
896         if len(args) == 1:
897             sequence = args[0]
898             if isinstance(sequence, set):
899                 unordered = True
900             elif isinstance(sequence, (Dict, Mapping)):
901                 unordered = True
902                 sequence = sequence.items()
903             elif not iterable(sequence):
904                 from sympy.utilities.misc import filldedent
905                 raise ValueError(filldedent("""
906                    When a single argument is passed to subs
907                    it should be a dictionary of old: new pairs or an iterable
908                    of (old, new) tuples."""))
909         elif len(args) == 2:
910             sequence = [args]
911         else:
912             raise ValueError("subs accepts either 1 or 2 arguments")
913 
914         sequence = list(sequence)
915         for i, s in enumerate(sequence):
916             if isinstance(s[0], str):
917                 # when old is a string we prefer Symbol
918                 s = Symbol(s[0]), s[1]
919             try:
920                 s = [sympify(_, strict=not isinstance(_, str))
921                      for _ in s]
922             except SympifyError:
923                 # if it can't be sympified, skip it
924                 sequence[i] = None
925                 continue
926             # skip if there is no change
927             sequence[i] = None if _aresame(*s) else tuple(s)
928         sequence = list(filter(None, sequence))
929 
930         if unordered:
931             sequence = dict(sequence)
932             if not all(k.is_Atom for k in sequence):
933                 d = {}
934                 for o, n in sequence.items():
935                     try:
936                         ops = o.count_ops(), len(o.args)
937                     except TypeError:
938                         ops = (0, 0)
939                     d.setdefault(ops, []).append((o, n))
940                 newseq = []
941                 for k in sorted(d.keys(), reverse=True):
942                     newseq.extend(
943                         sorted([v[0] for v in d[k]], key=default_sort_key))
944                 sequence = [(k, sequence[k]) for k in newseq]
945                 del newseq, d
946             else:
947                 sequence = sorted([(k, v) for (k, v) in sequence.items()],
948                                   key=default_sort_key)
949 
950         if kwargs.pop('simultaneous', False):  # XXX should this be the default for dict subs?
951             reps = {}
952             rv = self
953             kwargs['hack2'] = True
954             m = Dummy('subs_m')
955             for old, new in sequence:
956                 com = new.is_commutative
957                 if com is None:
958                     com = True
959                 d = Dummy('subs_d', commutative=com)
960                 # using d*m so Subs will be used on dummy variables
961                 # in things like Derivative(f(x, y), x) in which x
962                 # is both free and bound
963                 rv = rv._subs(old, d*m, **kwargs)
964                 if not isinstance(rv, Basic):
965                     break
966                 reps[d] = new
967             reps[m] = S.One  # get rid of m
968             return rv.xreplace(reps)
969         else:
970             rv = self
971             for old, new in sequence:
972                 rv = rv._subs(old, new, **kwargs)
973                 if not isinstance(rv, Basic):
974                     break
975             return rv

</code><intended_behavior>This code should ensure that expressions like `exp(x)` and `cos(x)` substituted with `oo` evaluate to infinity or the appropriate mathematical limit without reverting to `AccumBounds` unless absolutely mathematically necessary. The method should distinguish between cases where a function grows without bound vs. oscillates as `x` approaches infinity.</intended_behavior>, <file>sympy/core/basic.py</file>
<class>Basic</class>
<method>subs</method>
<code>
778     def subs(self, *args, **kwargs):
779         """
780         Substitutes old for new in an expression after sympifying args.
781 
782         `args` is either:
783           - two arguments, e.g. foo.subs(old, new)
784           - one iterable argument, e.g. foo.subs(iterable). The iterable may be
785              o an iterable container with (old, new) pairs. In this case the
786                replacements are processed in the order given with successive
787                patterns possibly affecting replacements already made.
788              o a dict or set whose key/value items correspond to old/new pairs.
789                In this case the old/new pairs will be sorted by op count and in
790                case of a tie, by number of args and the default_sort_key. The
791                resulting sorted list is then processed as an iterable container
792                (see previous).
793 
794         If the keyword ``simultaneous`` is True, the subexpressions will not be
795         evaluated until all the substitutions have been made.
796 
797         Examples
798         ========
799 
800         >>> from sympy import pi, exp, limit, oo
801         >>> from sympy.abc import x, y
802         >>> (1 + x*y).subs(x, pi)
803         pi*y + 1
804         >>> (1 + x*y).subs({x:pi, y:2})
805         1 + 2*pi
806         >>> (1 + x*y).subs([(x, pi), (y, 2)])
807         1 + 2*pi
808         >>> reps = [(y, x**2), (x, 2)]
809         >>> (x + y).subs(reps)
810         6
811         >>> (x + y).subs(reversed(reps))
812         x**2 + 2
813 
814         >>> (x**2 + x**4).subs(x**2, y)
815         y**2 + y
816 
817         To replace only the x**2 but not the x**4, use xreplace:
818 
819         >>> (x**2 + x**4).xreplace({x**2: y})
820         x**4 + y
821 
822         To delay evaluation until all substitutions have been made,
823         set the keyword ``simultaneous`` to True:
824 
825         >>> (x/y).subs([(x, 0), (y, 0)])
826         0
827         >>> (x/y).subs([(x, 0), (y, 0)], simultaneous=True)
828         nan
829 
830         This has the added feature of not allowing subsequent substitutions
831         to affect those already made:
832 
833         >>> ((x + y)/y).subs({x + y: y, y: x + y})
834         1
835         >>> ((x + y)/y).subs({x + y: y, y: x + y}, simultaneous=True)
836         y/(x + y)
837 
838         In order to obtain a canonical result, unordered iterables are
839         sorted by count_op length, number of arguments and by the
840         default_sort_key to break any ties. All other iterables are left
841         unsorted.
842 
843         >>> from sympy import sqrt, sin, cos
844         >>> from sympy.abc import a, b, c, d, e
845 
846         >>> A = (sqrt(sin(2*x)), a)
847         >>> B = (sin(2*x), b)
848         >>> C = (cos(2*x), c)
849         >>> D = (x, d)
850         >>> E = (exp(x), e)
851 
852         >>> expr = sqrt(sin(2*x))*sin(exp(x)*x)*cos(2*x) + sin(2*x)
853 
854         >>> expr.subs(dict([A, B, C, D, E]))
855         a*c*sin(d*e) + b
856 
857         The resulting expression represents a literal replacement of the
858         old arguments with the new arguments. This may not reflect the
859         limiting behavior of the expression:
860 
861         >>> (x**3 - 3*x).subs({x: oo})
862         nan
863 
864         >>> limit(x**3 - 3*x, x, oo)
865         oo
866 
867         If the substitution will be followed by numerical
868         evaluation, it is better to pass the substitution to
869         evalf as
870 
871         >>> (1/x).evalf(subs={x: 3.0}, n=21)
872         0.333333333333333333333
873 
874         rather than
875 
876         >>> (1/x).subs({x: 3.0}).evalf(21)
877         0.333333333333333314830
878 
879         as the former will ensure that the desired level of precision is
880         obtained.
881 
882         See Also
883         ========
884         replace: replacement capable of doing wildcard-like matching,
885                  parsing of match, and conditional replacements
886         xreplace: exact node replacement in expr tree; also capable of
887                   using matching rules
888         sympy.core.evalf.EvalfMixin.evalf: calculates the given formula to a desired level of precision
889 
890         """
891         from sympy.core.containers import Dict
892         from sympy.utilities import default_sort_key
893         from sympy import Dummy, Symbol
894 
895         unordered = False
896         if len(args) == 1:
897             sequence = args[0]
898             if isinstance(sequence, set):
899                 unordered = True
900             elif isinstance(sequence, (Dict, Mapping)):
901                 unordered = True
902                 sequence = sequence.items()
903             elif not iterable(sequence):
904                 from sympy.utilities.misc import filldedent
905                 raise ValueError(filldedent("""
906                    When a single argument is passed to subs
907                    it should be a dictionary of old: new pairs or an iterable
908                    of (old, new) tuples."""))
909         elif len(args) == 2:
910             sequence = [args]
911         else:
912             raise ValueError("subs accepts either 1 or 2 arguments")
913 
914         sequence = list(sequence)
915         for i, s in enumerate(sequence):
916             if isinstance(s[0], str):
917                 # when old is a string we prefer Symbol
918                 s = Symbol(s[0]), s[1]
919             try:
920                 s = [sympify(_, strict=not isinstance(_, str))
921                      for _ in s]
922             except SympifyError:
923                 # if it can't be sympified, skip it
924                 sequence[i] = None
925                 continue
926             # skip if there is no change
927             sequence[i] = None if _aresame(*s) else tuple(s)
928         sequence = list(filter(None, sequence))
929 
930         if unordered:
931             sequence = dict(sequence)
932             if not all(k.is_Atom for k in sequence):
933                 d = {}
934                 for o, n in sequence.items():
935                     try:
936                         ops = o.count_ops(), len(o.args)
937                     except TypeError:
938                         ops = (0, 0)
939                     d.setdefault(ops, []).append((o, n))
940                 newseq = []
941                 for k in sorted(d.keys(), reverse=True):
942                     newseq.extend(
943                         sorted([v[0] for v in d[k]], key=default_sort_key))
944                 sequence = [(k, sequence[k]) for k in newseq]
945                 del newseq, d
946             else:
947                 sequence = sorted([(k, v) for (k, v) in sequence.items()],
948                                   key=default_sort_key)
949 
950         if kwargs.pop('simultaneous', False):  # XXX should this be the default for dict subs?
951             reps = {}
952             rv = self
953             kwargs['hack2'] = True
954             m = Dummy('subs_m')
955             for old, new in sequence:
956                 com = new.is_commutative
957                 if com is None:
958                     com = True
959                 d = Dummy('subs_d', commutative=com)
960                 # using d*m so Subs will be used on dummy variables
961                 # in things like Derivative(f(x, y), x) in which x
962                 # is both free and bound
963                 rv = rv._subs(old, d*m, **kwargs)
964                 if not isinstance(rv, Basic):
965                     break
966                 reps[d] = new
967             reps[m] = S.One  # get rid of m
968             return rv.xreplace(reps)
969         else:
970             rv = self
971             for old, new in sequence:
972                 rv = rv._subs(old, new, **kwargs)
973                 if not isinstance(rv, Basic):
974                     break
975             return rv

</code><intended_behavior>This code should ensure that expressions like `exp(x)` and `cos(x)` substituted with `oo` evaluate to infinity or the appropriate mathematical limit without reverting to `AccumBounds` unless absolutely mathematically necessary. The method should distinguish between cases where a function grows without bound vs. oscillates as `x` approaches infinity.</intended_behavior>, <file>sympy/calculus/util.py</file>
<class>None</class>
<method>None</method>
<code>
1 from sympy import Order, S, log, limit, lcm_list, Abs, im, re, Dummy
2 from sympy.core import Add, Mul, Pow
3 from sympy.core.basic import Basic
4 from sympy.core.compatibility import iterable
5 from sympy.core.expr import AtomicExpr, Expr
6 from sympy.core.numbers import _sympifyit, oo
7 from sympy.core.sympify import _sympify
8 from sympy.functions.elementary.miscellaneous import Min, Max
9 from sympy.logic.boolalg import And
10 from sympy.polys.rationaltools import together
11 from sympy.sets.sets import (Interval, Intersection, FiniteSet, Union,
12                              Complement, EmptySet)
13 from sympy.sets.fancysets import ImageSet
14 from sympy.simplify.radsimp import denom
15 from sympy.solvers.inequalities import solve_univariate_inequality
16 from sympy.utilities import filldedent
17 
18 def continuous_domain(f, symbol, domain):
19     """
20     Returns the intervals in the given domain for which the function
21     is continuous.
22     This method is limited by the ability to determine the various
23     singularities and discontinuities of the given function.
24 
25     Parameters
26     ==========
27 
28     f : Expr
29         The concerned function.
30     symbol : Symbol
31         The variable for which the intervals are to be determined.
32     domain : Interval
33         The domain over which the continuity of the symbol has to be checked.
34 
35     Examples
36     ========
37 
38     >>> from sympy import Symbol, S, tan, log, pi, sqrt
39     >>> from sympy.sets import Interval
40     >>> from sympy.calculus.util import continuous_domain
41     >>> x = Symbol('x')
42     >>> continuous_domain(1/x, x, S.Reals)
43     Union(Interval.open(-oo, 0), Interval.open(0, oo))
44     >>> continuous_domain(tan(x), x, Interval(0, pi))
45     Union(Interval.Ropen(0, pi/2), Interval.Lopen(pi/2, pi))
46     >>> continuous_domain(sqrt(x - 2), x, Interval(-5, 5))
47     Interval(2, 5)
48     >>> continuous_domain(log(2*x - 1), x, S.Reals)
49     Interval.open(1/2, oo)
50 
51     Returns
52     =======
53 
54     Interval
55         Union of all intervals where the function is continuous.
56 
57     Raises
58     ======
59 
60     NotImplementedError
61         If the method to determine continuity of such a function
62         has not yet been developed.
63 
64     """
65     from sympy.solvers.inequalities import solve_univariate_inequality
66     from sympy.solvers.solveset import solveset, _has_rational_power
67 
68     if domain.is_subset(S.Reals):
69         constrained_interval = domain
70         for atom in f.atoms(Pow):
71             predicate, denomin = _has_rational_power(atom, symbol)
72             if predicate and denomin == 2:
73                 constraint = solve_univariate_inequality(atom.base >= 0,
74                                                          symbol).as_set()
75                 constrained_interval = Intersection(constraint,
76                                                     constrained_interval)
77 
78         for atom in f.atoms(log):
79             constraint = solve_univariate_inequality(atom.args[0] > 0,
80                                                      symbol).as_set()
81             constrained_interval = Intersection(constraint,
82                                                 constrained_interval)
83 
84         domain = constrained_interval
85 
86     try:
87         if f.has(Abs):
88             sings = solveset(1/f, symbol, domain) + \
89                 solveset(denom(together(f)), symbol, domain)
90         else:
91             for atom in f.atoms(Pow):
92                 predicate, denomin = _has_rational_power(atom, symbol)
93                 if predicate and denomin == 2:
94                     sings = solveset(1/f, symbol, domain) +\
95                         solveset(denom(together(f)), symbol, domain)
96                     break
97             else:
98                 sings = Intersection(solveset(1/f, symbol), domain) + \
99                     solveset(denom(together(f)), symbol, domain)
100 
101     except NotImplementedError:
102         raise NotImplementedError("Methods for determining the continuous domains"
103                                   " of this function have not been developed.")
104 
105     return domain - sings
106 
107 
108 def function_range(f, symbol, domain):
109     """
110     Finds the range of a function in a given domain.
111     This method is limited by the ability to determine the singularities and
112     determine limits.
113 
114     Parameters
115     ==========
116 
117     f : Expr
118         The concerned function.
119     symbol : Symbol
120         The variable for which the range of function is to be determined.
121     domain : Interval
122         The domain under which the range of the function has to be found.
123 
124     Examples
125     ========
126 
127     >>> from sympy import Symbol, S, exp, log, pi, sqrt, sin, tan
128     >>> from sympy.sets import Interval
129     >>> from sympy.calculus.util import function_range
130     >>> x = Symbol('x')
131     >>> function_range(sin(x), x, Interval(0, 2*pi))
132     Interval(-1, 1)
133     >>> function_range(tan(x), x, Interval(-pi/2, pi/2))
134     Interval(-oo, oo)
135     >>> function_range(1/x, x, S.Reals)
136     Union(Interval.open(-oo, 0), Interval.open(0, oo))
137     >>> function_range(exp(x), x, S.Reals)
138     Interval.open(0, oo)
139     >>> function_range(log(x), x, S.Reals)
140     Interval(-oo, oo)
141     >>> function_range(sqrt(x), x , Interval(-5, 9))
142     Interval(0, 3)
143 
144     Returns
145     =======
146 
147     Interval
148         Union of all ranges for all intervals under domain where function is
149         continuous.
150 
151     Raises
152     ======
153 
154     NotImplementedError
155         If any of the intervals, in the given domain, for which function
156         is continuous are not finite or real,
157         OR if the critical points of the function on the domain can't be found.
158     """
159     from sympy.solvers.solveset import solveset
160 
161     if isinstance(domain, EmptySet):
162         return S.EmptySet
163 
164     period = periodicity(f, symbol)
165     if period == S.Zero:
166         # the expression is constant wrt symbol
167         return FiniteSet(f.expand())
168 
169     if period is not None:
170         if isinstance(domain, Interval):
171             if (domain.inf - domain.sup).is_infinite:
172                 domain = Interval(0, period)
173         elif isinstance(domain, Union):
174             for sub_dom in domain.args:
175                 if isinstance(sub_dom, Interval) and \
176                 ((sub_dom.inf - sub_dom.sup).is_infinite):
177                     domain = Interval(0, period)
178 
179     intervals = continuous_domain(f, symbol, domain)
180     range_int = S.EmptySet
181     if isinstance(intervals,(Interval, FiniteSet)):
182         interval_iter = (intervals,)
183 
184     elif isinstance(intervals, Union):
185         interval_iter = intervals.args
186 
187     else:
188             raise NotImplementedError(filldedent('''
189                 Unable to find range for the given domain.
190                 '''))
191 
192     for interval in interval_iter:
193         if isinstance(interval, FiniteSet):
194             for singleton in interval:
195                 if singleton in domain:
196                     range_int += FiniteSet(f.subs(symbol, singleton))
197         elif isinstance(interval, Interval):
198             vals = S.EmptySet
199             critical_points = S.EmptySet
200             critical_values = S.EmptySet
201             bounds = ((interval.left_open, interval.inf, '+'),
202                    (interval.right_open, interval.sup, '-'))
203 
204             for is_open, limit_point, direction in bounds:
205                 if is_open:
206                     critical_values += FiniteSet(limit(f, symbol, limit_point, direction))
207                     vals += critical_values
208 
209                 else:
210                     vals += FiniteSet(f.subs(symbol, limit_point))
211 
212             solution = solveset(f.diff(symbol), symbol, interval)
213 
214             if not iterable(solution):
215                 raise NotImplementedError(
216                         'Unable to find critical points for {}'.format(f))
217             if isinstance(solution, ImageSet):
218                 raise NotImplementedError(
219                         'Infinite number of critical points for {}'.format(f))
220 
221             critical_points += solution
222 
223             for critical_point in critical_points:
224                 vals += FiniteSet(f.subs(symbol, critical_point))
225 
226             left_open, right_open = False, False
227 
228             if critical_values is not S.EmptySet:
229                 if critical_values.inf == vals.inf:
230                     left_open = True
231 
232                 if critical_values.sup == vals.sup:
233                     right_open = True
234 
235             range_int += Interval(vals.inf, vals.sup, left_open, right_open)
236         else:
237             raise NotImplementedError(filldedent('''
238                 Unable to find range for the given domain.
239                 '''))
240 
241     return range_int
242 
243 
244 def not_empty_in(finset_intersection, *syms):
245     """
246     Finds the domain of the functions in `finite_set` in which the
247     `finite_set` is not-empty
248 
249     Parameters
250     ==========
251 
252     finset_intersection : The unevaluated intersection of FiniteSet containing
253                         real-valued functions with Union of Sets
254     syms : Tuple of symbols
255             Symbol for which domain is to be found
256 
257     Raises
258     ======
259 
260     NotImplementedError
261         The algorithms to find the non-emptiness of the given FiniteSet are
262         not yet implemented.
263     ValueError
264         The input is not valid.
265     RuntimeError
266         It is a bug, please report it to the github issue tracker
267         (https://github.com/sympy/sympy/issues).
268 
269     Examples
270     ========
271 
272     >>> from sympy import FiniteSet, Interval, not_empty_in, oo
273     >>> from sympy.abc import x
274     >>> not_empty_in(FiniteSet(x/2).intersect(Interval(0, 1)), x)
275     Interval(0, 2)
276     >>> not_empty_in(FiniteSet(x, x**2).intersect(Interval(1, 2)), x)
277     Union(Interval(1, 2), Interval(-sqrt(2), -1))
278     >>> not_empty_in(FiniteSet(x**2/(x + 2)).intersect(Interval(1, oo)), x)
279     Union(Interval.Lopen(-2, -1), Interval(2, oo))
280     """
281 
282     # TODO: handle piecewise defined functions
283     # TODO: handle transcendental functions
284     # TODO: handle multivariate functions
285     if len(syms) == 0:
286         raise ValueError("One or more symbols must be given in syms.")
287 
288     if finset_intersection is S.EmptySet:
289         return S.EmptySet
290 
291     if isinstance(finset_intersection, Union):
292         elm_in_sets = finset_intersection.args[0]
293         return Union(not_empty_in(finset_intersection.args[1], *syms),
294                      elm_in_sets)
295 
296     if isinstance(finset_intersection, FiniteSet):
297         finite_set = finset_intersection
298         _sets = S.Reals
299     else:
300         finite_set = finset_intersection.args[1]
301         _sets = finset_intersection.args[0]
302 
303     if not isinstance(finite_set, FiniteSet):
304         raise ValueError('A FiniteSet must be given, not %s: %s' %
305                          (type(finite_set), finite_set))
306 
307     if len(syms) == 1:
308         symb = syms[0]
309     else:
310         raise NotImplementedError('more than one variables %s not handled' %
311                                   (syms,))
312 
313     def elm_domain(expr, intrvl):
314         """ Finds the domain of an expression in any given interval """
315         from sympy.solvers.solveset import solveset
316 
317         _start = intrvl.start
318         _end = intrvl.end
319         _singularities = solveset(expr.as_numer_denom()[1], symb,
320                                   domain=S.Reals)
321 
322         if intrvl.right_open:
323             if _end is S.Infinity:
324                 _domain1 = S.Reals
325             else:
326                 _domain1 = solveset(expr < _end, symb, domain=S.Reals)
327         else:
328             _domain1 = solveset(expr <= _end, symb, domain=S.Reals)
329 
330         if intrvl.left_open:
331             if _start is S.NegativeInfinity:
332                 _domain2 = S.Reals
333             else:
334                 _domain2 = solveset(expr > _start, symb, domain=S.Reals)
335         else:
336             _domain2 = solveset(expr >= _start, symb, domain=S.Reals)
337 
338         # domain in the interval
339         expr_with_sing = Intersection(_domain1, _domain2)
340         expr_domain = Complement(expr_with_sing, _singularities)
341         return expr_domain
342 
343     if isinstance(_sets, Interval):
344         return Union(*[elm_domain(element, _sets) for element in finite_set])
345 
346     if isinstance(_sets, Union):
347         _domain = S.EmptySet
348         for intrvl in _sets.args:
349             _domain_element = Union(*[elm_domain(element, intrvl)
350                                       for element in finite_set])
351             _domain = Union(_domain, _domain_element)
352         return _domain
353 
354 
355 def periodicity(f, symbol, check=False):
356     """
357     Tests the given function for periodicity in the given symbol.
358 
359     Parameters
360     ==========
361 
362     f : Expr.
363         The concerned function.
364     symbol : Symbol
365         The variable for which the period is to be determined.
366     check : Boolean, optional
367         The flag to verify whether the value being returned is a period or not.
368 
369     Returns
370     =======
371 
372     period
373         The period of the function is returned.
374         `None` is returned when the function is aperiodic or has a complex period.
375         The value of `0` is returned as the period of a constant function.
376 
377     Raises
378     ======
379 
380     NotImplementedError
381         The value of the period computed cannot be verified.
382 
383 
384     Notes
385     =====
386 
387     Currently, we do not support functions with a complex period.
388     The period of functions having complex periodic values such
389     as `exp`, `sinh` is evaluated to `None`.
390 
391     The value returned might not be the "fundamental" period of the given
392     function i.e. it may not be the smallest periodic value of the function.
393 
394     The verification of the period through the `check` flag is not reliable
395     due to internal simplification of the given expression. Hence, it is set
396     to `False` by default.
397 
398     Examples
399     ========
400     >>> from sympy import Symbol, sin, cos, tan, exp
401     >>> from sympy.calculus.util import periodicity
402     >>> x = Symbol('x')
403     >>> f = sin(x) + sin(2*x) + sin(3*x)
404     >>> periodicity(f, x)
405     2*pi
406     >>> periodicity(sin(x)*cos(x), x)
407     pi
408     >>> periodicity(exp(tan(2*x) - 1), x)
409     pi/2
410     >>> periodicity(sin(4*x)**cos(2*x), x)
411     pi
412     >>> periodicity(exp(x), x)
413     """
414     from sympy.core.mod import Mod
415     from sympy.core.relational import Relational
416     from sympy.functions.elementary.exponential import exp
417     from sympy.functions.elementary.complexes import Abs
418     from sympy.functions.elementary.trigonometric import (
419         TrigonometricFunction, sin, cos, csc, sec)
420     from sympy.simplify.simplify import simplify
421     from sympy.solvers.decompogen import decompogen
422     from sympy.polys.polytools import degree
423 
424     temp = Dummy('x', real=True)
425     f = f.subs(symbol, temp)
426     symbol = temp
427 
428     def _check(orig_f, period):
429         '''Return the checked period or raise an error.'''
430         new_f = orig_f.subs(symbol, symbol + period)
431         if new_f.equals(orig_f):
432             return period
433         else:
434             raise NotImplementedError(filldedent('''
435                 The period of the given function cannot be verified.
436                 When `%s` was replaced with `%s + %s` in `%s`, the result
437                 was `%s` which was not recognized as being the same as
438                 the original function.
439                 So either the period was wrong or the two forms were
440                 not recognized as being equal.
441                 Set check=False to obtain the value.''' %
442                 (symbol, symbol, period, orig_f, new_f)))
443 
444     orig_f = f
445     period = None
446 
447     if isinstance(f, Relational):
448         f = f.lhs - f.rhs
449 
450     f = simplify(f)
451 
452     if symbol not in f.free_symbols:
453         return S.Zero
454 
455     if isinstance(f, TrigonometricFunction):
456         try:
457             period = f.period(symbol)
458         except NotImplementedError:
459             pass
460 
461     if isinstance(f, Abs):
462         arg = f.args[0]
463         if isinstance(arg, (sec, csc, cos)):
464             # all but tan and cot might have a
465             # a period that is half as large
466             # so recast as sin
467             arg = sin(arg.args[0])
468         period = periodicity(arg, symbol)
469         if period is not None and isinstance(arg, sin):
470             # the argument of Abs was a trigonometric other than
471             # cot or tan; test to see if the half-period
472             # is valid. Abs(arg) has behaviour equivalent to
473             # orig_f, so use that for test:
474             orig_f = Abs(arg)
475             try:
476                 return _check(orig_f, period/2)
477             except NotImplementedError as err:
478                 if check:
479                     raise NotImplementedError(err)
480             # else let new orig_f and period be
481             # checked below
482 
483     if isinstance(f, exp):
484         if im(f) != 0:
485             period_real = periodicity(re(f), symbol)
486             period_imag = periodicity(im(f), symbol)
487             if period_real is not None and period_imag is not None:
488                 period = lcim([period_real, period_imag])
489 
490     if f.is_Pow:
491         base, expo = f.args
492         base_has_sym = base.has(symbol)
493         expo_has_sym = expo.has(symbol)
494 
495         if base_has_sym and not expo_has_sym:
496             period = periodicity(base, symbol)
497 
498         elif expo_has_sym and not base_has_sym:
499             period = periodicity(expo, symbol)
500 
501         else:
502             period = _periodicity(f.args, symbol)
503 
504     elif f.is_Mul:
505         coeff, g = f.as_independent(symbol, as_Add=False)
506         if isinstance(g, TrigonometricFunction) or coeff is not S.One:
507             period = periodicity(g, symbol)
508 
509         else:
510             period = _periodicity(g.args, symbol)
511 
512     elif f.is_Add:
513         k, g = f.as_independent(symbol)
514         if k is not S.Zero:
515             return periodicity(g, symbol)
516 
517         period = _periodicity(g.args, symbol)
518 
519     elif isinstance(f, Mod):
520         a, n = f.args
521 
522         if a == symbol:
523             period = n
524         elif isinstance(a, TrigonometricFunction):
525             period = periodicity(a, symbol)
526         #check if 'f' is linear in 'symbol'
527         elif (a.is_polynomial(symbol) and degree(a, symbol) == 1 and
528             symbol not in n.free_symbols):
529                 period = Abs(n / a.diff(symbol))
530 
531     elif period is None:
532         from sympy.solvers.decompogen import compogen
533         g_s = decompogen(f, symbol)
534         num_of_gs = len(g_s)
535         if num_of_gs > 1:
536             for index, g in enumerate(reversed(g_s)):
537                 start_index = num_of_gs - 1 - index
538                 g = compogen(g_s[start_index:], symbol)
539                 if g != orig_f and g != f: # Fix for issue 12620
540                     period = periodicity(g, symbol)
541                     if period is not None:
542                         break
543 
544     if period is not None:
545         if check:
546             return _check(orig_f, period)
547         return period
548 
549     return None
550 
551 
552 def _periodicity(args, symbol):
553     """
554     Helper for `periodicity` to find the period of a list of simpler
555     functions.
556     It uses the `lcim` method to find the least common period of
557     all the functions.
558 
559     Parameters
560     ==========
561 
562     args : Tuple of Symbol
563         All the symbols present in a function.
564 
565     symbol : Symbol
566         The symbol over which the function is to be evaluated.
567 
568     Returns
569     =======
570 
571     period
572         The least common period of the function for all the symbols
573         of the function.
574         None if for at least one of the symbols the function is aperiodic
575 
576     """
577     periods = []
578     for f in args:
579         period = periodicity(f, symbol)
580         if period is None:
581             return None
582 
583         if period is not S.Zero:
584             periods.append(period)
585 
586     if len(periods) > 1:
587         return lcim(periods)
588 
589     if periods:
590         return periods[0]
591 
592 
593 def lcim(numbers):
594     """Returns the least common integral multiple of a list of numbers.
595 
596     The numbers can be rational or irrational or a mixture of both.
597     `None` is returned for incommensurable numbers.
598 
599     Parameters
600     ==========
601 
602     numbers : list
603         Numbers (rational and/or irrational) for which lcim is to be found.
604 
605     Returns
606     =======
607 
608     number
609         lcim if it exists, otherwise `None` for incommensurable numbers.
610 
611     Examples
612     ========
613 
614     >>> from sympy import S, pi
615     >>> from sympy.calculus.util import lcim
616     >>> lcim([S(1)/2, S(3)/4, S(5)/6])
617     15/2
618     >>> lcim([2*pi, 3*pi, pi, pi/2])
619     6*pi
620     >>> lcim([S(1), 2*pi])
621     """
622     result = None
623     if all(num.is_irrational for num in numbers):
624         factorized_nums = list(map(lambda num: num.factor(), numbers))
625         factors_num = list(
626             map(lambda num: num.as_coeff_Mul(),
627                 factorized_nums))
628         term = factors_num[0][1]
629         if all(factor == term for coeff, factor in factors_num):
630             common_term = term
631             coeffs = [coeff for coeff, factor in factors_num]
632             result = lcm_list(coeffs) * common_term
633 
634     elif all(num.is_rational for num in numbers):
635         result = lcm_list(numbers)
636 
637     else:
638         pass
639 
640     return result
641 
642 def is_convex(f, *syms, **kwargs):
643     """Determines the  convexity of the function passed in the argument.
644 
645     Parameters
646     ==========
647 
648     f : Expr
649         The concerned function.
650     syms : Tuple of symbols
651         The variables with respect to which the convexity is to be determined.
652     domain : Interval, optional
653         The domain over which the convexity of the function has to be checked.
654         If unspecified, S.Reals will be the default domain.
655 
656     Returns
657     =======
658 
659     Boolean
660         The method returns `True` if the function is convex otherwise it
661         returns `False`.
662 
663     Raises
664     ======
665 
666     NotImplementedError
667         The check for the convexity of multivariate functions is not implemented yet.
668 
669     Notes
670     =====
671 
672     To determine concavity of a function pass `-f` as the concerned function.
673     To determine logarithmic convexity of a function pass log(f) as
674     concerned function.
675     To determine logartihmic concavity of a function pass -log(f) as
676     concerned function.
677 
678     Currently, convexity check of multivariate functions is not handled.
679 
680     Examples
681     ========
682 
683     >>> from sympy import symbols, exp, oo, Interval
684     >>> from sympy.calculus.util import is_convex
685     >>> x = symbols('x')
686     >>> is_convex(exp(x), x)
687     True
688     >>> is_convex(x**3, x, domain = Interval(-1, oo))
689     False
690 
691     References
692     ==========
693 
694     .. [1] https://en.wikipedia.org/wiki/Convex_function
695     .. [2] http://www.ifp.illinois.edu/~angelia/L3_convfunc.pdf
696     .. [3] https://en.wikipedia.org/wiki/Logarithmically_convex_function
697     .. [4] https://en.wikipedia.org/wiki/Logarithmically_concave_function
698     .. [5] https://en.wikipedia.org/wiki/Concave_function
699 
700     """
701 
702     if len(syms) > 1:
703         raise NotImplementedError(
704             "The check for the convexity of multivariate functions is not implemented yet.")
705 
706     f = _sympify(f)
707     domain = kwargs.get('domain', S.Reals)
708     var = syms[0]
709     condition = f.diff(var, 2) < 0
710     if solve_univariate_inequality(condition, var, False, domain):
711         return False
712     return True
713 
714 
715 def stationary_points(f, symbol, domain=S.Reals):
716     """
717     Returns the stationary points of a function (where derivative of the
718     function is 0) in the given domain.
719 
720     Parameters
721     ==========
722 
723     f : Expr
724         The concerned function.
725     symbol : Symbol
726         The variable for which the stationary points are to be determined.
727     domain : Interval
728         The domain over which the stationary points have to be checked.
729         If unspecified, S.Reals will be the default domain.
730 
731     Examples
732     ========
733 
734     >>> from sympy import Symbol, S, sin, log, pi, pprint, stationary_points
735     >>> from sympy.sets import Interval
736     >>> x = Symbol('x')
737 
738     >>> stationary_points(1/x, x, S.Reals)
739     EmptySet
740 
741     >>> pprint(stationary_points(sin(x), x), use_unicode=False)
742               pi                              3*pi
743     {2*n*pi + -- | n in Integers} U {2*n*pi + ---- | n in Integers}
744               2                                2
745 
746     >>> stationary_points(sin(x),x, Interval(0, 4*pi))
747     FiniteSet(pi/2, 3*pi/2, 5*pi/2, 7*pi/2)
748 
749     """
750     from sympy import solveset, diff
751 
752     if isinstance(domain, EmptySet):
753         return S.EmptySet
754 
755     domain = continuous_domain(f, symbol, domain)
756     set = solveset(diff(f, symbol), symbol, domain)
757 
758     return set
759 
760 
761 def maximum(f, symbol, domain=S.Reals):
762     """
763     Returns the maximum value of a function in the given domain.
764 
765     Parameters
766     ==========
767 
768     f : Expr
769         The concerned function.
770     symbol : Symbol
771         The variable for maximum value needs to be determined.
772     domain : Interval
773         The domain over which the maximum have to be checked.
774         If unspecified, then Global maximum is returned.
775 
776     Examples
777     ========
778 
779     >>> from sympy import Symbol, S, sin, cos, pi, maximum
780     >>> from sympy.sets import Interval
781     >>> x = Symbol('x')
782 
783     >>> f = -x**2 + 2*x + 5
784     >>> maximum(f, x, S.Reals)
785     6
786 
787     >>> maximum(sin(x), x, Interval(-pi, pi/4))
788     sqrt(2)/2
789 
790     >>> maximum(sin(x)*cos(x), x)
791     1/2
792 
793     """
794     from sympy import Symbol
795 
796     if isinstance(symbol, Symbol):
797         if isinstance(domain, EmptySet):
798             raise ValueError("Maximum value not defined for empty domain.")
799 
800         return function_range(f, symbol, domain).sup
801     else:
802         raise ValueError("%s is not a valid symbol." % symbol)
803 
804 
805 def minimum(f, symbol, domain=S.Reals):
806     """
807     Returns the minimum value of a function in the given domain.
808 
809     Parameters
810     ==========
811 
812     f : Expr
813         The concerned function.
814     symbol : Symbol
815         The variable for minimum value needs to be determined.
816     domain : Interval
817         The domain over which the minimum have to be checked.
818         If unspecified, then Global minimum is returned.
819 
820     Examples
821     ========
822 
823     >>> from sympy import Symbol, S, sin, cos, minimum
824     >>> from sympy.sets import Interval
825     >>> x = Symbol('x')
826 
827     >>> f = x**2 + 2*x + 5
828     >>> minimum(f, x, S.Reals)
829     4
830 
831     >>> minimum(sin(x), x, Interval(2, 3))
832     sin(3)
833 
834     >>> minimum(sin(x)*cos(x), x)
835     -1/2
836 
837     """
838     from sympy import Symbol
839 
840     if isinstance(symbol, Symbol):
841         if isinstance(domain, EmptySet):
842             raise ValueError("Minimum value not defined for empty domain.")
843 
844         return function_range(f, symbol, domain).inf
845     else:
846         raise ValueError("%s is not a valid symbol." % symbol)
847 
848 
849 class AccumulationBounds(AtomicExpr):
850     r"""
851     # Note AccumulationBounds has an alias: AccumBounds
852 
853     AccumulationBounds represent an interval `[a, b]`, which is always closed
854     at the ends. Here `a` and `b` can be any value from extended real numbers.
855 
856     The intended meaning of AccummulationBounds is to give an approximate
857     location of the accumulation points of a real function at a limit point.
858 
859     Let `a` and `b` be reals such that a <= b.
860 
861     `\left\langle a, b\right\rangle = \{x \in \mathbb{R} \mid a \le x \le b\}`
862 
863     `\left\langle -\infty, b\right\rangle = \{x \in \mathbb{R} \mid x \le b\} \cup \{-\infty, \infty\}`
864 
865     `\left\langle a, \infty \right\rangle = \{x \in \mathbb{R} \mid a \le x\} \cup \{-\infty, \infty\}`
866 
867     `\left\langle -\infty, \infty \right\rangle = \mathbb{R} \cup \{-\infty, \infty\}`
868 
869     `oo` and `-oo` are added to the second and third definition respectively,
870     since if either `-oo` or `oo` is an argument, then the other one should
871     be included (though not as an end point). This is forced, since we have,
872     for example, `1/AccumBounds(0, 1) = AccumBounds(1, oo)`, and the limit at
873     `0` is not one-sided. As x tends to `0-`, then `1/x -> -oo`, so `-oo`
874     should be interpreted as belonging to `AccumBounds(1, oo)` though it need
875     not appear explicitly.
876 
877     In many cases it suffices to know that the limit set is bounded.
878     However, in some other cases more exact information could be useful.
879     For example, all accumulation values of cos(x) + 1 are non-negative.
880     (AccumBounds(-1, 1) + 1 = AccumBounds(0, 2))
881 
882     A AccumulationBounds object is defined to be real AccumulationBounds,
883     if its end points are finite reals.
884 
885     Let `X`, `Y` be real AccumulationBounds, then their sum, difference,
886     product are defined to be the following sets:
887 
888     `X + Y = \{ x+y \mid x \in X \cap y \in Y\}`
889 
890     `X - Y = \{ x-y \mid x \in X \cap y \in Y\}`
891 
892     `X * Y = \{ x*y \mid x \in X \cap y \in Y\}`
893 
894     There is, however, no consensus on Interval division.
895 
896     `X / Y = \{ z \mid \exists x \in X, y \in Y \mid y \neq 0, z = x/y\}`
897 
898     Note: According to this definition the quotient of two AccumulationBounds
899     may not be a AccumulationBounds object but rather a union of
900     AccumulationBounds.
901 
902     Note
903     ====
904 
905     The main focus in the interval arithmetic is on the simplest way to
906     calculate upper and lower endpoints for the range of values of a
907     function in one or more variables. These barriers are not necessarily
908     the supremum or infimum, since the precise calculation of those values
909     can be difficult or impossible.
910 
911     Examples
912     ========
913 
914     >>> from sympy import AccumBounds, sin, exp, log, pi, E, S, oo
915     >>> from sympy.abc import x
916 
917     >>> AccumBounds(0, 1) + AccumBounds(1, 2)
918     AccumBounds(1, 3)
919 
920     >>> AccumBounds(0, 1) - AccumBounds(0, 2)
921     AccumBounds(-2, 1)
922 
923     >>> AccumBounds(-2, 3)*AccumBounds(-1, 1)
924     AccumBounds(-3, 3)
925 
926     >>> AccumBounds(1, 2)*AccumBounds(3, 5)
927     AccumBounds(3, 10)
928 
929     The exponentiation of AccumulationBounds is defined
930     as follows:
931 
932     If 0 does not belong to `X` or `n > 0` then
933 
934     `X^n = \{ x^n \mid x \in X\}`
935 
936     otherwise
937 
938     `X^n = \{ x^n \mid x \neq 0, x \in X\} \cup \{-\infty, \infty\}`
939 
940     Here for fractional `n`, the part of `X` resulting in a complex
941     AccumulationBounds object is neglected.
942 
943     >>> AccumBounds(-1, 4)**(S(1)/2)
944     AccumBounds(0, 2)
945 
946     >>> AccumBounds(1, 2)**2
947     AccumBounds(1, 4)
948 
949     >>> AccumBounds(-1, oo)**(-1)
950     AccumBounds(-oo, oo)
951 
952     Note: `<a, b>^2` is not same as `<a, b>*<a, b>`
953 
954     >>> AccumBounds(-1, 1)**2
955     AccumBounds(0, 1)
956 
957     >>> AccumBounds(1, 3) < 4
958     True
959 
960     >>> AccumBounds(1, 3) < -1
961     False
962 
963     Some elementary functions can also take AccumulationBounds as input.
964     A function `f` evaluated for some real AccumulationBounds `<a, b>`
965     is defined as `f(\left\langle a, b\right\rangle) = \{ f(x) \mid a \le x \le b \}`
966 
967     >>> sin(AccumBounds(pi/6, pi/3))
968     AccumBounds(1/2, sqrt(3)/2)
969 
970     >>> exp(AccumBounds(0, 1))
971     AccumBounds(1, E)
972 
973     >>> log(AccumBounds(1, E))
974     AccumBounds(0, 1)
975 
976     Some symbol in an expression can be substituted for a AccumulationBounds
977     object. But it doesn't necessarily evaluate the AccumulationBounds for
978     that expression.
979 
980     Same expression can be evaluated to different values depending upon
981     the form it is used for substitution. For example:
982 
983     >>> (x**2 + 2*x + 1).subs(x, AccumBounds(-1, 1))
984     AccumBounds(-1, 4)
985 
986     >>> ((x + 1)**2).subs(x, AccumBounds(-1, 1))
987     AccumBounds(0, 4)
988 
989     References
990     ==========
991 
992     .. [1] https://en.wikipedia.org/wiki/Interval_arithmetic
993 
994     .. [2] http://fab.cba.mit.edu/classes/S62.12/docs/Hickey_interval.pdf
995 
996     Notes
997     =====
998 
999     Do not use ``AccumulationBounds`` for floating point interval arithmetic
1000     calculations, use ``mpmath.iv`` instead.
1001     """
1002 
1003     is_extended_real = True
1004 
1005     def __new__(cls, min, max):
1006 
1007         min = _sympify(min)
1008         max = _sympify(max)
1009 
1010         # Only allow real intervals (use symbols with 'is_extended_real=True').
1011         if not min.is_extended_real or not max.is_extended_real:
1012             raise ValueError("Only real AccumulationBounds are supported")
1013 
1014         # Make sure that the created AccumBounds object will be valid.
1015         if max.is_comparable and min.is_comparable:
1016             if max < min:
1017                 raise ValueError(
1018                     "Lower limit should be smaller than upper limit")
1019 
1020         if max == min:
1021             return max
1022 
1023         return Basic.__new__(cls, min, max)
1024 
1025     # setting the operation priority
1026     _op_priority = 11.0
1027 
1028     def _eval_is_real(self):
1029         if self.min.is_real and self.max.is_real:
1030             return True
1031 
1032     @property
1033     def min(self):
1034         """
1035         Returns the minimum possible value attained by AccumulationBounds
1036         object.
1037 
1038         Examples
1039         ========
1040 
1041         >>> from sympy import AccumBounds
1042         >>> AccumBounds(1, 3).min
1043         1
1044 
1045         """
1046         return self.args[0]
1047 
1048     @property
1049     def max(self):
1050         """
1051         Returns the maximum possible value attained by AccumulationBounds
1052         object.
1053 
1054         Examples
1055         ========
1056 
1057         >>> from sympy import AccumBounds
1058         >>> AccumBounds(1, 3).max
1059         3
1060 
1061         """
1062         return self.args[1]
1063 
1064     @property
1065     def delta(self):
1066         """
1067         Returns the difference of maximum possible value attained by
1068         AccumulationBounds object and minimum possible value attained
1069         by AccumulationBounds object.
1070 
1071         Examples
1072         ========
1073 
1074         >>> from sympy import AccumBounds
1075         >>> AccumBounds(1, 3).delta
1076         2
1077 
1078         """
1079         return self.max - self.min
1080 
1081     @property
1082     def mid(self):
1083         """
1084         Returns the mean of maximum possible value attained by
1085         AccumulationBounds object and minimum possible value
1086         attained by AccumulationBounds object.
1087 
1088         Examples
1089         ========
1090 
1091         >>> from sympy import AccumBounds
1092         >>> AccumBounds(1, 3).mid
1093         2
1094 
1095         """
1096         return (self.min + self.max) / 2
1097 
1098     @_sympifyit('other', NotImplemented)
1099     def _eval_power(self, other):
1100         return self.__pow__(other)
1101 
1102     @_sympifyit('other', NotImplemented)
1103     def __add__(self, other):
1104         if isinstance(other, Expr):
1105             if isinstance(other, AccumBounds):
1106                 return AccumBounds(
1107                     Add(self.min, other.min),
1108                     Add(self.max, other.max))
1109             if other is S.Infinity and self.min is S.NegativeInfinity or \
1110                     other is S.NegativeInfinity and self.max is S.Infinity:
1111                 return AccumBounds(-oo, oo)
1112             elif other.is_extended_real:
1113                 return AccumBounds(Add(self.min, other), Add(self.max, other))
1114             return Add(self, other, evaluate=False)
1115         return NotImplemented
1116 
1117     __radd__ = __add__
1118 
1119     def __neg__(self):
1120         return AccumBounds(-self.max, -self.min)
1121 
1122     @_sympifyit('other', NotImplemented)
1123     def __sub__(self, other):
1124         if isinstance(other, Expr):
1125             if isinstance(other, AccumBounds):
1126                 return AccumBounds(
1127                     Add(self.min, -other.max),
1128                     Add(self.max, -other.min))
1129             if other is S.NegativeInfinity and self.min is S.NegativeInfinity or \
1130                     other is S.Infinity and self.max is S.Infinity:
1131                 return AccumBounds(-oo, oo)
1132             elif other.is_extended_real:
1133                 return AccumBounds(
1134                     Add(self.min, -other),
1135                     Add(self.max, -other))
1136             return Add(self, -other, evaluate=False)
1137         return NotImplemented
1138 
1139     @_sympifyit('other', NotImplemented)
1140     def __rsub__(self, other):
1141         return self.__neg__() + other
1142 
1143     @_sympifyit('other', NotImplemented)
1144     def __mul__(self, other):
1145         if isinstance(other, Expr):
1146             if isinstance(other, AccumBounds):
1147                 return AccumBounds(Min(Mul(self.min, other.min),
1148                                        Mul(self.min, other.max),
1149                                        Mul(self.max, other.min),
1150                                        Mul(self.max, other.max)),
1151                                    Max(Mul(self.min, other.min),
1152                                        Mul(self.min, other.max),
1153                                        Mul(self.max, other.min),
1154                                        Mul(self.max, other.max)))
1155             if other is S.Infinity:
1156                 if self.min.is_zero:
1157                     return AccumBounds(0, oo)
1158                 if self.max.is_zero:
1159                     return AccumBounds(-oo, 0)
1160             if other is S.NegativeInfinity:
1161                 if self.min.is_zero:
1162                     return AccumBounds(-oo, 0)
1163                 if self.max.is_zero:
1164                     return AccumBounds(0, oo)
1165             if other.is_extended_real:
1166                 if other.is_zero:
1167                     if self == AccumBounds(-oo, oo):
1168                         return AccumBounds(-oo, oo)
1169                     if self.max is S.Infinity:
1170                         return AccumBounds(0, oo)
1171                     if self.min is S.NegativeInfinity:
1172                         return AccumBounds(-oo, 0)
1173                     return S.Zero
1174                 if other.is_extended_positive:
1175                     return AccumBounds(
1176                         Mul(self.min, other),
1177                         Mul(self.max, other))
1178                 elif other.is_extended_negative:
1179                     return AccumBounds(
1180                         Mul(self.max, other),
1181                         Mul(self.min, other))
1182             if isinstance(other, Order):
1183                 return other
1184             return Mul(self, other, evaluate=False)
1185         return NotImplemented
1186 
1187     __rmul__ = __mul__
1188 
1189     @_sympifyit('other', NotImplemented)
1190     def __div__(self, other):
1191         if isinstance(other, Expr):
1192             if isinstance(other, AccumBounds):
1193                 if S.Zero not in other:
1194                     return self * AccumBounds(1/other.max, 1/other.min)
1195 
1196                 if S.Zero in self and S.Zero in other:
1197                     if self.min.is_zero and other.min.is_zero:
1198                         return AccumBounds(0, oo)
1199                     if self.max.is_zero and other.min.is_zero:
1200                         return AccumBounds(-oo, 0)
1201                     return AccumBounds(-oo, oo)
1202 
1203                 if self.max.is_extended_negative:
1204                     if other.min.is_extended_negative:
1205                         if other.max.is_zero:
1206                             return AccumBounds(self.max / other.min, oo)
1207                         if other.max.is_extended_positive:
1208                             # the actual answer is a Union of AccumBounds,
1209                             # Union(AccumBounds(-oo, self.max/other.max),
1210                             #       AccumBounds(self.max/other.min, oo))
1211                             return AccumBounds(-oo, oo)
1212 
1213                     if other.min.is_zero and other.max.is_extended_positive:
1214                         return AccumBounds(-oo, self.max / other.max)
1215 
1216                 if self.min.is_extended_positive:
1217                     if other.min.is_extended_negative:
1218                         if other.max.is_zero:
1219                             return AccumBounds(-oo, self.min / other.min)
1220                         if other.max.is_extended_positive:
1221                             # the actual answer is a Union of AccumBounds,
1222                             # Union(AccumBounds(-oo, self.min/other.min),
1223                             #       AccumBounds(self.min/other.max, oo))
1224                             return AccumBounds(-oo, oo)
1225 
1226                     if other.min.is_zero and other.max.is_extended_positive:
1227                         return AccumBounds(self.min / other.max, oo)
1228 
1229             elif other.is_extended_real:
1230                 if other is S.Infinity or other is S.NegativeInfinity:
1231                     if self == AccumBounds(-oo, oo):
1232                         return AccumBounds(-oo, oo)
1233                     if self.max is S.Infinity:
1234                         return AccumBounds(Min(0, other), Max(0, other))
1235                     if self.min is S.NegativeInfinity:
1236                         return AccumBounds(Min(0, -other), Max(0, -other))
1237                 if other.is_extended_positive:
1238                     return AccumBounds(self.min / other, self.max / other)
1239                 elif other.is_extended_negative:
1240                     return AccumBounds(self.max / other, self.min / other)
1241             return Mul(self, 1 / other, evaluate=False)
1242 
1243         return NotImplemented
1244 
1245     __truediv__ = __div__
1246 
1247     @_sympifyit('other', NotImplemented)
1248     def __rdiv__(self, other):
1249         if isinstance(other, Expr):
1250             if other.is_extended_real:
1251                 if other.is_zero:
1252                     return S.Zero
1253                 if S.Zero in self:
1254                     if self.min.is_zero:
1255                         if other.is_extended_positive:
1256                             return AccumBounds(Mul(other, 1 / self.max), oo)
1257                         if other.is_extended_negative:
1258                             return AccumBounds(-oo, Mul(other, 1 / self.max))
1259                     if self.max.is_zero:
1260                         if other.is_extended_positive:
1261                             return AccumBounds(-oo, Mul(other, 1 / self.min))
1262                         if other.is_extended_negative:
1263                             return AccumBounds(Mul(other, 1 / self.min), oo)
1264                     return AccumBounds(-oo, oo)
1265                 else:
1266                     return AccumBounds(Min(other / self.min, other / self.max),
1267                                        Max(other / self.min, other / self.max))
1268             return Mul(other, 1 / self, evaluate=False)
1269         else:
1270             return NotImplemented
1271 
1272     __rtruediv__ = __rdiv__
1273 
1274     @_sympifyit('other', NotImplemented)
1275     def __pow__(self, other):
1276         from sympy.functions.elementary.miscellaneous import real_root
1277         if isinstance(other, Expr):
1278             if other is S.Infinity:
1279                 if self.min.is_extended_nonnegative:
1280                     if self.max < 1:
1281                         return S.Zero
1282                     if self.min > 1:
1283                         return S.Infinity
1284                     return AccumBounds(0, oo)
1285                 elif self.max.is_extended_negative:
1286                     if self.min > -1:
1287                         return S.Zero
1288                     if self.max < -1:
1289                         return FiniteSet(-oo, oo)
1290                     return AccumBounds(-oo, oo)
1291                 else:
1292                     if self.min > -1:
1293                         if self.max < 1:
1294                             return S.Zero
1295                         return AccumBounds(0, oo)
1296                     return AccumBounds(-oo, oo)
1297 
1298             if other is S.NegativeInfinity:
1299                 return (1 / self)**oo
1300 
1301             if other.is_extended_real and other.is_number:
1302                 if other.is_zero:
1303                     return S.One
1304 
1305                 if other.is_Integer:
1306                     if self.min.is_extended_positive:
1307                         return AccumBounds(
1308                             Min(self.min ** other, self.max ** other),
1309                             Max(self.min ** other, self.max ** other))
1310                     elif self.max.is_extended_negative:
1311                         return AccumBounds(
1312                             Min(self.max ** other, self.min ** other),
1313                             Max(self.max ** other, self.min ** other))
1314 
1315                     if other % 2 == 0:
1316                         if other.is_extended_negative:
1317                             if self.min.is_zero:
1318                                 return AccumBounds(self.max**other, oo)
1319                             if self.max.is_zero:
1320                                 return AccumBounds(self.min**other, oo)
1321                             return AccumBounds(0, oo)
1322                         return AccumBounds(
1323                             S.Zero, Max(self.min**other, self.max**other))
1324                     else:
1325                         if other.is_extended_negative:
1326                             if self.min.is_zero:
1327                                 return AccumBounds(self.max**other, oo)
1328                             if self.max.is_zero:
1329                                 return AccumBounds(-oo, self.min**other)
1330                             return AccumBounds(-oo, oo)
1331                         return AccumBounds(self.min**other, self.max**other)
1332 
1333                 num, den = other.as_numer_denom()
1334                 if num == S.One:
1335                     if den % 2 == 0:
1336                         if S.Zero in self:
1337                             if self.min.is_extended_negative:
1338                                 return AccumBounds(0, real_root(self.max, den))
1339                     return AccumBounds(real_root(self.min, den),
1340                                        real_root(self.max, den))
1341                 if den!=1:
1342                     num_pow = self**num
1343                     return num_pow**(1 / den)
1344             return AccumBounds(-oo, oo)
1345 
1346         return NotImplemented
1347 
1348     def __abs__(self):
1349         if self.max.is_extended_negative:
1350             return self.__neg__()
1351         elif self.min.is_extended_negative:
1352             return AccumBounds(S.Zero, Max(abs(self.min), self.max))
1353         else:
1354             return self
1355 
1356     def __lt__(self, other):
1357         """
1358         Returns True if range of values attained by `self` AccumulationBounds
1359         object is less than the range of values attained by `other`, where
1360         other may be any value of type AccumulationBounds object or extended
1361         real number value, False if `other` satisfies the same property, else
1362         an unevaluated Relational
1363 
1364         Examples
1365         ========
1366 
1367         >>> from sympy import AccumBounds, oo
1368         >>> AccumBounds(1, 3) < AccumBounds(4, oo)
1369         True
1370         >>> AccumBounds(1, 4) < AccumBounds(3, 4)
1371         AccumBounds(1, 4) < AccumBounds(3, 4)
1372         >>> AccumBounds(1, oo) < -1
1373         False
1374 
1375         """
1376         other = _sympify(other)
1377         if isinstance(other, AccumBounds):
1378             if self.max < other.min:
1379                 return True
1380             if self.min >= other.max:
1381                 return False
1382         elif not other.is_extended_real:
1383             raise TypeError(
1384                 "Invalid comparison of %s %s" %
1385                 (type(other), other))
1386         elif other.is_comparable:
1387             if self.max < other:
1388                 return True
1389             if self.min >= other:
1390                 return False
1391         return super(AccumulationBounds, self).__lt__(other)
1392 
1393     def __le__(self, other):
1394         """
1395         Returns True if range of values attained by `self` AccumulationBounds
1396         object is less than or equal to the range of values attained by
1397         `other`, where other may be any value of type AccumulationBounds
1398         object or extended real number value, False if `other`
1399         satisfies the same property, else an unevaluated Relational.
1400 
1401         Examples
1402         ========
1403 
1404         >>> from sympy import AccumBounds, oo
1405         >>> AccumBounds(1, 3) <= AccumBounds(4, oo)
1406         True
1407         >>> AccumBounds(1, 4) <= AccumBounds(3, 4)
1408         AccumBounds(1, 4) <= AccumBounds(3, 4)
1409         >>> AccumBounds(1, 3) <= 0
1410         False
1411 
1412         """
1413         other = _sympify(other)
1414         if isinstance(other, AccumBounds):
1415             if self.max <= other.min:
1416                 return True
1417             if self.min > other.max:
1418                 return False
1419         elif not other.is_extended_real:
1420             raise TypeError(
1421                 "Invalid comparison of %s %s" %
1422                 (type(other), other))
1423         elif other.is_comparable:
1424             if self.max <= other:
1425                 return True
1426             if self.min > other:
1427                 return False
1428         return super(AccumulationBounds, self).__le__(other)
1429 
1430     def __gt__(self, other):
1431         """
1432         Returns True if range of values attained by `self` AccumulationBounds
1433         object is greater than the range of values attained by `other`,
1434         where other may be any value of type AccumulationBounds object or
1435         extended real number value, False if `other` satisfies
1436         the same property, else an unevaluated Relational.
1437 
1438         Examples
1439         ========
1440 
1441         >>> from sympy import AccumBounds, oo
1442         >>> AccumBounds(1, 3) > AccumBounds(4, oo)
1443         False
1444         >>> AccumBounds(1, 4) > AccumBounds(3, 4)
1445         AccumBounds(1, 4) > AccumBounds(3, 4)
1446         >>> AccumBounds(1, oo) > -1
1447         True
1448 
1449         """
1450         other = _sympify(other)
1451         if isinstance(other, AccumBounds):
1452             if self.min > other.max:
1453                 return True
1454             if self.max <= other.min:
1455                 return False
1456         elif not other.is_extended_real:
1457             raise TypeError(
1458                 "Invalid comparison of %s %s" %
1459                 (type(other), other))
1460         elif other.is_comparable:
1461             if self.min > other:
1462                 return True
1463             if self.max <= other:
1464                 return False
1465         return super(AccumulationBounds, self).__gt__(other)
1466 
1467     def __ge__(self, other):
1468         """
1469         Returns True if range of values attained by `self` AccumulationBounds
1470         object is less that the range of values attained by `other`, where
1471         other may be any value of type AccumulationBounds object or extended
1472         real number value, False if `other` satisfies the same
1473         property, else an unevaluated Relational.
1474 
1475         Examples
1476         ========
1477 
1478         >>> from sympy import AccumBounds, oo
1479         >>> AccumBounds(1, 3) >= AccumBounds(4, oo)
1480         False
1481         >>> AccumBounds(1, 4) >= AccumBounds(3, 4)
1482         AccumBounds(1, 4) >= AccumBounds(3, 4)
1483         >>> AccumBounds(1, oo) >= 1
1484         True
1485 
1486         """
1487         other = _sympify(other)
1488         if isinstance(other, AccumBounds):
1489             if self.min >= other.max:
1490                 return True
1491             if self.max < other.min:
1492                 return False
1493         elif not other.is_extended_real:
1494             raise TypeError(
1495                 "Invalid comparison of %s %s" %
1496                 (type(other), other))
1497         elif other.is_comparable:
1498             if self.min >= other:
1499                 return True
1500             if self.max < other:
1501                 return False
1502         return super(AccumulationBounds, self).__ge__(other)
1503 
1504     def __contains__(self, other):
1505         """
1506         Returns True if other is contained in self, where other
1507         belongs to extended real numbers, False if not contained,
1508         otherwise TypeError is raised.
1509 
1510         Examples
1511         ========
1512 
1513         >>> from sympy import AccumBounds, oo
1514         >>> 1 in AccumBounds(-1, 3)
1515         True
1516 
1517         -oo and oo go together as limits (in AccumulationBounds).
1518 
1519         >>> -oo in AccumBounds(1, oo)
1520         True
1521 
1522         >>> oo in AccumBounds(-oo, 0)
1523         True
1524 
1525         """
1526         other = _sympify(other)
1527 
1528         if other is S.Infinity or other is S.NegativeInfinity:
1529             if self.min is S.NegativeInfinity or self.max is S.Infinity:
1530                 return True
1531             return False
1532 
1533         rv = And(self.min <= other, self.max >= other)
1534         if rv not in (True, False):
1535             raise TypeError("input failed to evaluate")
1536         return rv
1537 
1538     def intersection(self, other):
1539         """
1540         Returns the intersection of 'self' and 'other'.
1541         Here other can be an instance of FiniteSet or AccumulationBounds.
1542 
1543         Examples
1544         ========
1545 
1546         >>> from sympy import AccumBounds, FiniteSet
1547         >>> AccumBounds(1, 3).intersection(AccumBounds(2, 4))
1548         AccumBounds(2, 3)
1549 
1550         >>> AccumBounds(1, 3).intersection(AccumBounds(4, 6))
1551         EmptySet
1552 
1553         >>> AccumBounds(1, 4).intersection(FiniteSet(1, 2, 5))
1554         FiniteSet(1, 2)
1555 
1556         """
1557         if not isinstance(other, (AccumBounds, FiniteSet)):
1558             raise TypeError(
1559                 "Input must be AccumulationBounds or FiniteSet object")
1560 
1561         if isinstance(other, FiniteSet):
1562             fin_set = S.EmptySet
1563             for i in other:
1564                 if i in self:
1565                     fin_set = fin_set + FiniteSet(i)
1566             return fin_set
1567 
1568         if self.max < other.min or self.min > other.max:
1569             return S.EmptySet
1570 
1571         if self.min <= other.min:
1572             if self.max <= other.max:
1573                 return AccumBounds(other.min, self.max)
1574             if self.max > other.max:
1575                 return other
1576 
1577         if other.min <= self.min:
1578             if other.max < self.max:
1579                 return AccumBounds(self.min, other.max)
1580             if other.max > self.max:
1581                 return self
1582 
1583     def union(self, other):
1584         # TODO : Devise a better method for Union of AccumBounds
1585         # this method is not actually correct and
1586         # can be made better
1587         if not isinstance(other, AccumBounds):
1588             raise TypeError(
1589                 "Input must be AccumulationBounds or FiniteSet object")
1590 
1591         if self.min <= other.min and self.max >= other.min:
1592             return AccumBounds(self.min, Max(self.max, other.max))
1593 
1594         if other.min <= self.min and other.max >= self.min:
1595             return AccumBounds(other.min, Max(self.max, other.max))
1596 
1597 
1598 # setting an alias for AccumulationBounds
1599 AccumBounds = AccumulationBounds

</code><intended_behavior>This code should ensure that any utility functions or mechanisms responsible for evaluating limits or behavior at infinity (`oo`) correctly interpret mathematical functions' growth, direction, or oscillation as they approach infinity, specifically accounting for exponential growth in a manner distinct from bounded oscillations or other behaviors.</intended_behavior>]
2025-10-18 20:34:05.897 | INFO     | Search completed. Bug locations: [<file>sympy/core/basic.py</file>
<class>None</class>
<method>subs</method>
<code>
778     def subs(self, *args, **kwargs):
779         """
780         Substitutes old for new in an expression after sympifying args.
781 
782         `args` is either:
783           - two arguments, e.g. foo.subs(old, new)
784           - one iterable argument, e.g. foo.subs(iterable). The iterable may be
785              o an iterable container with (old, new) pairs. In this case the
786                replacements are processed in the order given with successive
787                patterns possibly affecting replacements already made.
788              o a dict or set whose key/value items correspond to old/new pairs.
789                In this case the old/new pairs will be sorted by op count and in
790                case of a tie, by number of args and the default_sort_key. The
791                resulting sorted list is then processed as an iterable container
792                (see previous).
793 
794         If the keyword ``simultaneous`` is True, the subexpressions will not be
795         evaluated until all the substitutions have been made.
796 
797         Examples
798         ========
799 
800         >>> from sympy import pi, exp, limit, oo
801         >>> from sympy.abc import x, y
802         >>> (1 + x*y).subs(x, pi)
803         pi*y + 1
804         >>> (1 + x*y).subs({x:pi, y:2})
805         1 + 2*pi
806         >>> (1 + x*y).subs([(x, pi), (y, 2)])
807         1 + 2*pi
808         >>> reps = [(y, x**2), (x, 2)]
809         >>> (x + y).subs(reps)
810         6
811         >>> (x + y).subs(reversed(reps))
812         x**2 + 2
813 
814         >>> (x**2 + x**4).subs(x**2, y)
815         y**2 + y
816 
817         To replace only the x**2 but not the x**4, use xreplace:
818 
819         >>> (x**2 + x**4).xreplace({x**2: y})
820         x**4 + y
821 
822         To delay evaluation until all substitutions have been made,
823         set the keyword ``simultaneous`` to True:
824 
825         >>> (x/y).subs([(x, 0), (y, 0)])
826         0
827         >>> (x/y).subs([(x, 0), (y, 0)], simultaneous=True)
828         nan
829 
830         This has the added feature of not allowing subsequent substitutions
831         to affect those already made:
832 
833         >>> ((x + y)/y).subs({x + y: y, y: x + y})
834         1
835         >>> ((x + y)/y).subs({x + y: y, y: x + y}, simultaneous=True)
836         y/(x + y)
837 
838         In order to obtain a canonical result, unordered iterables are
839         sorted by count_op length, number of arguments and by the
840         default_sort_key to break any ties. All other iterables are left
841         unsorted.
842 
843         >>> from sympy import sqrt, sin, cos
844         >>> from sympy.abc import a, b, c, d, e
845 
846         >>> A = (sqrt(sin(2*x)), a)
847         >>> B = (sin(2*x), b)
848         >>> C = (cos(2*x), c)
849         >>> D = (x, d)
850         >>> E = (exp(x), e)
851 
852         >>> expr = sqrt(sin(2*x))*sin(exp(x)*x)*cos(2*x) + sin(2*x)
853 
854         >>> expr.subs(dict([A, B, C, D, E]))
855         a*c*sin(d*e) + b
856 
857         The resulting expression represents a literal replacement of the
858         old arguments with the new arguments. This may not reflect the
859         limiting behavior of the expression:
860 
861         >>> (x**3 - 3*x).subs({x: oo})
862         nan
863 
864         >>> limit(x**3 - 3*x, x, oo)
865         oo
866 
867         If the substitution will be followed by numerical
868         evaluation, it is better to pass the substitution to
869         evalf as
870 
871         >>> (1/x).evalf(subs={x: 3.0}, n=21)
872         0.333333333333333333333
873 
874         rather than
875 
876         >>> (1/x).subs({x: 3.0}).evalf(21)
877         0.333333333333333314830
878 
879         as the former will ensure that the desired level of precision is
880         obtained.
881 
882         See Also
883         ========
884         replace: replacement capable of doing wildcard-like matching,
885                  parsing of match, and conditional replacements
886         xreplace: exact node replacement in expr tree; also capable of
887                   using matching rules
888         sympy.core.evalf.EvalfMixin.evalf: calculates the given formula to a desired level of precision
889 
890         """
891         from sympy.core.containers import Dict
892         from sympy.utilities import default_sort_key
893         from sympy import Dummy, Symbol
894 
895         unordered = False
896         if len(args) == 1:
897             sequence = args[0]
898             if isinstance(sequence, set):
899                 unordered = True
900             elif isinstance(sequence, (Dict, Mapping)):
901                 unordered = True
902                 sequence = sequence.items()
903             elif not iterable(sequence):
904                 from sympy.utilities.misc import filldedent
905                 raise ValueError(filldedent("""
906                    When a single argument is passed to subs
907                    it should be a dictionary of old: new pairs or an iterable
908                    of (old, new) tuples."""))
909         elif len(args) == 2:
910             sequence = [args]
911         else:
912             raise ValueError("subs accepts either 1 or 2 arguments")
913 
914         sequence = list(sequence)
915         for i, s in enumerate(sequence):
916             if isinstance(s[0], str):
917                 # when old is a string we prefer Symbol
918                 s = Symbol(s[0]), s[1]
919             try:
920                 s = [sympify(_, strict=not isinstance(_, str))
921                      for _ in s]
922             except SympifyError:
923                 # if it can't be sympified, skip it
924                 sequence[i] = None
925                 continue
926             # skip if there is no change
927             sequence[i] = None if _aresame(*s) else tuple(s)
928         sequence = list(filter(None, sequence))
929 
930         if unordered:
931             sequence = dict(sequence)
932             if not all(k.is_Atom for k in sequence):
933                 d = {}
934                 for o, n in sequence.items():
935                     try:
936                         ops = o.count_ops(), len(o.args)
937                     except TypeError:
938                         ops = (0, 0)
939                     d.setdefault(ops, []).append((o, n))
940                 newseq = []
941                 for k in sorted(d.keys(), reverse=True):
942                     newseq.extend(
943                         sorted([v[0] for v in d[k]], key=default_sort_key))
944                 sequence = [(k, sequence[k]) for k in newseq]
945                 del newseq, d
946             else:
947                 sequence = sorted([(k, v) for (k, v) in sequence.items()],
948                                   key=default_sort_key)
949 
950         if kwargs.pop('simultaneous', False):  # XXX should this be the default for dict subs?
951             reps = {}
952             rv = self
953             kwargs['hack2'] = True
954             m = Dummy('subs_m')
955             for old, new in sequence:
956                 com = new.is_commutative
957                 if com is None:
958                     com = True
959                 d = Dummy('subs_d', commutative=com)
960                 # using d*m so Subs will be used on dummy variables
961                 # in things like Derivative(f(x, y), x) in which x
962                 # is both free and bound
963                 rv = rv._subs(old, d*m, **kwargs)
964                 if not isinstance(rv, Basic):
965                     break
966                 reps[d] = new
967             reps[m] = S.One  # get rid of m
968             return rv.xreplace(reps)
969         else:
970             rv = self
971             for old, new in sequence:
972                 rv = rv._subs(old, new, **kwargs)
973                 if not isinstance(rv, Basic):
974                     break
975             return rv

</code><intended_behavior>This code should ensure that expressions like `exp(x)` and `cos(x)` substituted with `oo` evaluate to infinity or the appropriate mathematical limit without reverting to `AccumBounds` unless absolutely mathematically necessary. The method should distinguish between cases where a function grows without bound vs. oscillates as `x` approaches infinity.</intended_behavior>, <file>sympy/core/basic.py</file>
<class>Basic</class>
<method>subs</method>
<code>
778     def subs(self, *args, **kwargs):
779         """
780         Substitutes old for new in an expression after sympifying args.
781 
782         `args` is either:
783           - two arguments, e.g. foo.subs(old, new)
784           - one iterable argument, e.g. foo.subs(iterable). The iterable may be
785              o an iterable container with (old, new) pairs. In this case the
786                replacements are processed in the order given with successive
787                patterns possibly affecting replacements already made.
788              o a dict or set whose key/value items correspond to old/new pairs.
789                In this case the old/new pairs will be sorted by op count and in
790                case of a tie, by number of args and the default_sort_key. The
791                resulting sorted list is then processed as an iterable container
792                (see previous).
793 
794         If the keyword ``simultaneous`` is True, the subexpressions will not be
795         evaluated until all the substitutions have been made.
796 
797         Examples
798         ========
799 
800         >>> from sympy import pi, exp, limit, oo
801         >>> from sympy.abc import x, y
802         >>> (1 + x*y).subs(x, pi)
803         pi*y + 1
804         >>> (1 + x*y).subs({x:pi, y:2})
805         1 + 2*pi
806         >>> (1 + x*y).subs([(x, pi), (y, 2)])
807         1 + 2*pi
808         >>> reps = [(y, x**2), (x, 2)]
809         >>> (x + y).subs(reps)
810         6
811         >>> (x + y).subs(reversed(reps))
812         x**2 + 2
813 
814         >>> (x**2 + x**4).subs(x**2, y)
815         y**2 + y
816 
817         To replace only the x**2 but not the x**4, use xreplace:
818 
819         >>> (x**2 + x**4).xreplace({x**2: y})
820         x**4 + y
821 
822         To delay evaluation until all substitutions have been made,
823         set the keyword ``simultaneous`` to True:
824 
825         >>> (x/y).subs([(x, 0), (y, 0)])
826         0
827         >>> (x/y).subs([(x, 0), (y, 0)], simultaneous=True)
828         nan
829 
830         This has the added feature of not allowing subsequent substitutions
831         to affect those already made:
832 
833         >>> ((x + y)/y).subs({x + y: y, y: x + y})
834         1
835         >>> ((x + y)/y).subs({x + y: y, y: x + y}, simultaneous=True)
836         y/(x + y)
837 
838         In order to obtain a canonical result, unordered iterables are
839         sorted by count_op length, number of arguments and by the
840         default_sort_key to break any ties. All other iterables are left
841         unsorted.
842 
843         >>> from sympy import sqrt, sin, cos
844         >>> from sympy.abc import a, b, c, d, e
845 
846         >>> A = (sqrt(sin(2*x)), a)
847         >>> B = (sin(2*x), b)
848         >>> C = (cos(2*x), c)
849         >>> D = (x, d)
850         >>> E = (exp(x), e)
851 
852         >>> expr = sqrt(sin(2*x))*sin(exp(x)*x)*cos(2*x) + sin(2*x)
853 
854         >>> expr.subs(dict([A, B, C, D, E]))
855         a*c*sin(d*e) + b
856 
857         The resulting expression represents a literal replacement of the
858         old arguments with the new arguments. This may not reflect the
859         limiting behavior of the expression:
860 
861         >>> (x**3 - 3*x).subs({x: oo})
862         nan
863 
864         >>> limit(x**3 - 3*x, x, oo)
865         oo
866 
867         If the substitution will be followed by numerical
868         evaluation, it is better to pass the substitution to
869         evalf as
870 
871         >>> (1/x).evalf(subs={x: 3.0}, n=21)
872         0.333333333333333333333
873 
874         rather than
875 
876         >>> (1/x).subs({x: 3.0}).evalf(21)
877         0.333333333333333314830
878 
879         as the former will ensure that the desired level of precision is
880         obtained.
881 
882         See Also
883         ========
884         replace: replacement capable of doing wildcard-like matching,
885                  parsing of match, and conditional replacements
886         xreplace: exact node replacement in expr tree; also capable of
887                   using matching rules
888         sympy.core.evalf.EvalfMixin.evalf: calculates the given formula to a desired level of precision
889 
890         """
891         from sympy.core.containers import Dict
892         from sympy.utilities import default_sort_key
893         from sympy import Dummy, Symbol
894 
895         unordered = False
896         if len(args) == 1:
897             sequence = args[0]
898             if isinstance(sequence, set):
899                 unordered = True
900             elif isinstance(sequence, (Dict, Mapping)):
901                 unordered = True
902                 sequence = sequence.items()
903             elif not iterable(sequence):
904                 from sympy.utilities.misc import filldedent
905                 raise ValueError(filldedent("""
906                    When a single argument is passed to subs
907                    it should be a dictionary of old: new pairs or an iterable
908                    of (old, new) tuples."""))
909         elif len(args) == 2:
910             sequence = [args]
911         else:
912             raise ValueError("subs accepts either 1 or 2 arguments")
913 
914         sequence = list(sequence)
915         for i, s in enumerate(sequence):
916             if isinstance(s[0], str):
917                 # when old is a string we prefer Symbol
918                 s = Symbol(s[0]), s[1]
919             try:
920                 s = [sympify(_, strict=not isinstance(_, str))
921                      for _ in s]
922             except SympifyError:
923                 # if it can't be sympified, skip it
924                 sequence[i] = None
925                 continue
926             # skip if there is no change
927             sequence[i] = None if _aresame(*s) else tuple(s)
928         sequence = list(filter(None, sequence))
929 
930         if unordered:
931             sequence = dict(sequence)
932             if not all(k.is_Atom for k in sequence):
933                 d = {}
934                 for o, n in sequence.items():
935                     try:
936                         ops = o.count_ops(), len(o.args)
937                     except TypeError:
938                         ops = (0, 0)
939                     d.setdefault(ops, []).append((o, n))
940                 newseq = []
941                 for k in sorted(d.keys(), reverse=True):
942                     newseq.extend(
943                         sorted([v[0] for v in d[k]], key=default_sort_key))
944                 sequence = [(k, sequence[k]) for k in newseq]
945                 del newseq, d
946             else:
947                 sequence = sorted([(k, v) for (k, v) in sequence.items()],
948                                   key=default_sort_key)
949 
950         if kwargs.pop('simultaneous', False):  # XXX should this be the default for dict subs?
951             reps = {}
952             rv = self
953             kwargs['hack2'] = True
954             m = Dummy('subs_m')
955             for old, new in sequence:
956                 com = new.is_commutative
957                 if com is None:
958                     com = True
959                 d = Dummy('subs_d', commutative=com)
960                 # using d*m so Subs will be used on dummy variables
961                 # in things like Derivative(f(x, y), x) in which x
962                 # is both free and bound
963                 rv = rv._subs(old, d*m, **kwargs)
964                 if not isinstance(rv, Basic):
965                     break
966                 reps[d] = new
967             reps[m] = S.One  # get rid of m
968             return rv.xreplace(reps)
969         else:
970             rv = self
971             for old, new in sequence:
972                 rv = rv._subs(old, new, **kwargs)
973                 if not isinstance(rv, Basic):
974                     break
975             return rv

</code><intended_behavior>This code should ensure that expressions like `exp(x)` and `cos(x)` substituted with `oo` evaluate to infinity or the appropriate mathematical limit without reverting to `AccumBounds` unless absolutely mathematically necessary. The method should distinguish between cases where a function grows without bound vs. oscillates as `x` approaches infinity.</intended_behavior>, <file>sympy/calculus/util.py</file>
<class>None</class>
<method>None</method>
<code>
1 from sympy import Order, S, log, limit, lcm_list, Abs, im, re, Dummy
2 from sympy.core import Add, Mul, Pow
3 from sympy.core.basic import Basic
4 from sympy.core.compatibility import iterable
5 from sympy.core.expr import AtomicExpr, Expr
6 from sympy.core.numbers import _sympifyit, oo
7 from sympy.core.sympify import _sympify
8 from sympy.functions.elementary.miscellaneous import Min, Max
9 from sympy.logic.boolalg import And
10 from sympy.polys.rationaltools import together
11 from sympy.sets.sets import (Interval, Intersection, FiniteSet, Union,
12                              Complement, EmptySet)
13 from sympy.sets.fancysets import ImageSet
14 from sympy.simplify.radsimp import denom
15 from sympy.solvers.inequalities import solve_univariate_inequality
16 from sympy.utilities import filldedent
17 
18 def continuous_domain(f, symbol, domain):
19     """
20     Returns the intervals in the given domain for which the function
21     is continuous.
22     This method is limited by the ability to determine the various
23     singularities and discontinuities of the given function.
24 
25     Parameters
26     ==========
27 
28     f : Expr
29         The concerned function.
30     symbol : Symbol
31         The variable for which the intervals are to be determined.
32     domain : Interval
33         The domain over which the continuity of the symbol has to be checked.
34 
35     Examples
36     ========
37 
38     >>> from sympy import Symbol, S, tan, log, pi, sqrt
39     >>> from sympy.sets import Interval
40     >>> from sympy.calculus.util import continuous_domain
41     >>> x = Symbol('x')
42     >>> continuous_domain(1/x, x, S.Reals)
43     Union(Interval.open(-oo, 0), Interval.open(0, oo))
44     >>> continuous_domain(tan(x), x, Interval(0, pi))
45     Union(Interval.Ropen(0, pi/2), Interval.Lopen(pi/2, pi))
46     >>> continuous_domain(sqrt(x - 2), x, Interval(-5, 5))
47     Interval(2, 5)
48     >>> continuous_domain(log(2*x - 1), x, S.Reals)
49     Interval.open(1/2, oo)
50 
51     Returns
52     =======
53 
54     Interval
55         Union of all intervals where the function is continuous.
56 
57     Raises
58     ======
59 
60     NotImplementedError
61         If the method to determine continuity of such a function
62         has not yet been developed.
63 
64     """
65     from sympy.solvers.inequalities import solve_univariate_inequality
66     from sympy.solvers.solveset import solveset, _has_rational_power
67 
68     if domain.is_subset(S.Reals):
69         constrained_interval = domain
70         for atom in f.atoms(Pow):
71             predicate, denomin = _has_rational_power(atom, symbol)
72             if predicate and denomin == 2:
73                 constraint = solve_univariate_inequality(atom.base >= 0,
74                                                          symbol).as_set()
75                 constrained_interval = Intersection(constraint,
76                                                     constrained_interval)
77 
78         for atom in f.atoms(log):
79             constraint = solve_univariate_inequality(atom.args[0] > 0,
80                                                      symbol).as_set()
81             constrained_interval = Intersection(constraint,
82                                                 constrained_interval)
83 
84         domain = constrained_interval
85 
86     try:
87         if f.has(Abs):
88             sings = solveset(1/f, symbol, domain) + \
89                 solveset(denom(together(f)), symbol, domain)
90         else:
91             for atom in f.atoms(Pow):
92                 predicate, denomin = _has_rational_power(atom, symbol)
93                 if predicate and denomin == 2:
94                     sings = solveset(1/f, symbol, domain) +\
95                         solveset(denom(together(f)), symbol, domain)
96                     break
97             else:
98                 sings = Intersection(solveset(1/f, symbol), domain) + \
99                     solveset(denom(together(f)), symbol, domain)
100 
101     except NotImplementedError:
102         raise NotImplementedError("Methods for determining the continuous domains"
103                                   " of this function have not been developed.")
104 
105     return domain - sings
106 
107 
108 def function_range(f, symbol, domain):
109     """
110     Finds the range of a function in a given domain.
111     This method is limited by the ability to determine the singularities and
112     determine limits.
113 
114     Parameters
115     ==========
116 
117     f : Expr
118         The concerned function.
119     symbol : Symbol
120         The variable for which the range of function is to be determined.
121     domain : Interval
122         The domain under which the range of the function has to be found.
123 
124     Examples
125     ========
126 
127     >>> from sympy import Symbol, S, exp, log, pi, sqrt, sin, tan
128     >>> from sympy.sets import Interval
129     >>> from sympy.calculus.util import function_range
130     >>> x = Symbol('x')
131     >>> function_range(sin(x), x, Interval(0, 2*pi))
132     Interval(-1, 1)
133     >>> function_range(tan(x), x, Interval(-pi/2, pi/2))
134     Interval(-oo, oo)
135     >>> function_range(1/x, x, S.Reals)
136     Union(Interval.open(-oo, 0), Interval.open(0, oo))
137     >>> function_range(exp(x), x, S.Reals)
138     Interval.open(0, oo)
139     >>> function_range(log(x), x, S.Reals)
140     Interval(-oo, oo)
141     >>> function_range(sqrt(x), x , Interval(-5, 9))
142     Interval(0, 3)
143 
144     Returns
145     =======
146 
147     Interval
148         Union of all ranges for all intervals under domain where function is
149         continuous.
150 
151     Raises
152     ======
153 
154     NotImplementedError
155         If any of the intervals, in the given domain, for which function
156         is continuous are not finite or real,
157         OR if the critical points of the function on the domain can't be found.
158     """
159     from sympy.solvers.solveset import solveset
160 
161     if isinstance(domain, EmptySet):
162         return S.EmptySet
163 
164     period = periodicity(f, symbol)
165     if period == S.Zero:
166         # the expression is constant wrt symbol
167         return FiniteSet(f.expand())
168 
169     if period is not None:
170         if isinstance(domain, Interval):
171             if (domain.inf - domain.sup).is_infinite:
172                 domain = Interval(0, period)
173         elif isinstance(domain, Union):
174             for sub_dom in domain.args:
175                 if isinstance(sub_dom, Interval) and \
176                 ((sub_dom.inf - sub_dom.sup).is_infinite):
177                     domain = Interval(0, period)
178 
179     intervals = continuous_domain(f, symbol, domain)
180     range_int = S.EmptySet
181     if isinstance(intervals,(Interval, FiniteSet)):
182         interval_iter = (intervals,)
183 
184     elif isinstance(intervals, Union):
185         interval_iter = intervals.args
186 
187     else:
188             raise NotImplementedError(filldedent('''
189                 Unable to find range for the given domain.
190                 '''))
191 
192     for interval in interval_iter:
193         if isinstance(interval, FiniteSet):
194             for singleton in interval:
195                 if singleton in domain:
196                     range_int += FiniteSet(f.subs(symbol, singleton))
197         elif isinstance(interval, Interval):
198             vals = S.EmptySet
199             critical_points = S.EmptySet
200             critical_values = S.EmptySet
201             bounds = ((interval.left_open, interval.inf, '+'),
202                    (interval.right_open, interval.sup, '-'))
203 
204             for is_open, limit_point, direction in bounds:
205                 if is_open:
206                     critical_values += FiniteSet(limit(f, symbol, limit_point, direction))
207                     vals += critical_values
208 
209                 else:
210                     vals += FiniteSet(f.subs(symbol, limit_point))
211 
212             solution = solveset(f.diff(symbol), symbol, interval)
213 
214             if not iterable(solution):
215                 raise NotImplementedError(
216                         'Unable to find critical points for {}'.format(f))
217             if isinstance(solution, ImageSet):
218                 raise NotImplementedError(
219                         'Infinite number of critical points for {}'.format(f))
220 
221             critical_points += solution
222 
223             for critical_point in critical_points:
224                 vals += FiniteSet(f.subs(symbol, critical_point))
225 
226             left_open, right_open = False, False
227 
228             if critical_values is not S.EmptySet:
229                 if critical_values.inf == vals.inf:
230                     left_open = True
231 
232                 if critical_values.sup == vals.sup:
233                     right_open = True
234 
235             range_int += Interval(vals.inf, vals.sup, left_open, right_open)
236         else:
237             raise NotImplementedError(filldedent('''
238                 Unable to find range for the given domain.
239                 '''))
240 
241     return range_int
242 
243 
244 def not_empty_in(finset_intersection, *syms):
245     """
246     Finds the domain of the functions in `finite_set` in which the
247     `finite_set` is not-empty
248 
249     Parameters
250     ==========
251 
252     finset_intersection : The unevaluated intersection of FiniteSet containing
253                         real-valued functions with Union of Sets
254     syms : Tuple of symbols
255             Symbol for which domain is to be found
256 
257     Raises
258     ======
259 
260     NotImplementedError
261         The algorithms to find the non-emptiness of the given FiniteSet are
262         not yet implemented.
263     ValueError
264         The input is not valid.
265     RuntimeError
266         It is a bug, please report it to the github issue tracker
267         (https://github.com/sympy/sympy/issues).
268 
269     Examples
270     ========
271 
272     >>> from sympy import FiniteSet, Interval, not_empty_in, oo
273     >>> from sympy.abc import x
274     >>> not_empty_in(FiniteSet(x/2).intersect(Interval(0, 1)), x)
275     Interval(0, 2)
276     >>> not_empty_in(FiniteSet(x, x**2).intersect(Interval(1, 2)), x)
277     Union(Interval(1, 2), Interval(-sqrt(2), -1))
278     >>> not_empty_in(FiniteSet(x**2/(x + 2)).intersect(Interval(1, oo)), x)
279     Union(Interval.Lopen(-2, -1), Interval(2, oo))
280     """
281 
282     # TODO: handle piecewise defined functions
283     # TODO: handle transcendental functions
284     # TODO: handle multivariate functions
285     if len(syms) == 0:
286         raise ValueError("One or more symbols must be given in syms.")
287 
288     if finset_intersection is S.EmptySet:
289         return S.EmptySet
290 
291     if isinstance(finset_intersection, Union):
292         elm_in_sets = finset_intersection.args[0]
293         return Union(not_empty_in(finset_intersection.args[1], *syms),
294                      elm_in_sets)
295 
296     if isinstance(finset_intersection, FiniteSet):
297         finite_set = finset_intersection
298         _sets = S.Reals
299     else:
300         finite_set = finset_intersection.args[1]
301         _sets = finset_intersection.args[0]
302 
303     if not isinstance(finite_set, FiniteSet):
304         raise ValueError('A FiniteSet must be given, not %s: %s' %
305                          (type(finite_set), finite_set))
306 
307     if len(syms) == 1:
308         symb = syms[0]
309     else:
310         raise NotImplementedError('more than one variables %s not handled' %
311                                   (syms,))
312 
313     def elm_domain(expr, intrvl):
314         """ Finds the domain of an expression in any given interval """
315         from sympy.solvers.solveset import solveset
316 
317         _start = intrvl.start
318         _end = intrvl.end
319         _singularities = solveset(expr.as_numer_denom()[1], symb,
320                                   domain=S.Reals)
321 
322         if intrvl.right_open:
323             if _end is S.Infinity:
324                 _domain1 = S.Reals
325             else:
326                 _domain1 = solveset(expr < _end, symb, domain=S.Reals)
327         else:
328             _domain1 = solveset(expr <= _end, symb, domain=S.Reals)
329 
330         if intrvl.left_open:
331             if _start is S.NegativeInfinity:
332                 _domain2 = S.Reals
333             else:
334                 _domain2 = solveset(expr > _start, symb, domain=S.Reals)
335         else:
336             _domain2 = solveset(expr >= _start, symb, domain=S.Reals)
337 
338         # domain in the interval
339         expr_with_sing = Intersection(_domain1, _domain2)
340         expr_domain = Complement(expr_with_sing, _singularities)
341         return expr_domain
342 
343     if isinstance(_sets, Interval):
344         return Union(*[elm_domain(element, _sets) for element in finite_set])
345 
346     if isinstance(_sets, Union):
347         _domain = S.EmptySet
348         for intrvl in _sets.args:
349             _domain_element = Union(*[elm_domain(element, intrvl)
350                                       for element in finite_set])
351             _domain = Union(_domain, _domain_element)
352         return _domain
353 
354 
355 def periodicity(f, symbol, check=False):
356     """
357     Tests the given function for periodicity in the given symbol.
358 
359     Parameters
360     ==========
361 
362     f : Expr.
363         The concerned function.
364     symbol : Symbol
365         The variable for which the period is to be determined.
366     check : Boolean, optional
367         The flag to verify whether the value being returned is a period or not.
368 
369     Returns
370     =======
371 
372     period
373         The period of the function is returned.
374         `None` is returned when the function is aperiodic or has a complex period.
375         The value of `0` is returned as the period of a constant function.
376 
377     Raises
378     ======
379 
380     NotImplementedError
381         The value of the period computed cannot be verified.
382 
383 
384     Notes
385     =====
386 
387     Currently, we do not support functions with a complex period.
388     The period of functions having complex periodic values such
389     as `exp`, `sinh` is evaluated to `None`.
390 
391     The value returned might not be the "fundamental" period of the given
392     function i.e. it may not be the smallest periodic value of the function.
393 
394     The verification of the period through the `check` flag is not reliable
395     due to internal simplification of the given expression. Hence, it is set
396     to `False` by default.
397 
398     Examples
399     ========
400     >>> from sympy import Symbol, sin, cos, tan, exp
401     >>> from sympy.calculus.util import periodicity
402     >>> x = Symbol('x')
403     >>> f = sin(x) + sin(2*x) + sin(3*x)
404     >>> periodicity(f, x)
405     2*pi
406     >>> periodicity(sin(x)*cos(x), x)
407     pi
408     >>> periodicity(exp(tan(2*x) - 1), x)
409     pi/2
410     >>> periodicity(sin(4*x)**cos(2*x), x)
411     pi
412     >>> periodicity(exp(x), x)
413     """
414     from sympy.core.mod import Mod
415     from sympy.core.relational import Relational
416     from sympy.functions.elementary.exponential import exp
417     from sympy.functions.elementary.complexes import Abs
418     from sympy.functions.elementary.trigonometric import (
419         TrigonometricFunction, sin, cos, csc, sec)
420     from sympy.simplify.simplify import simplify
421     from sympy.solvers.decompogen import decompogen
422     from sympy.polys.polytools import degree
423 
424     temp = Dummy('x', real=True)
425     f = f.subs(symbol, temp)
426     symbol = temp
427 
428     def _check(orig_f, period):
429         '''Return the checked period or raise an error.'''
430         new_f = orig_f.subs(symbol, symbol + period)
431         if new_f.equals(orig_f):
432             return period
433         else:
434             raise NotImplementedError(filldedent('''
435                 The period of the given function cannot be verified.
436                 When `%s` was replaced with `%s + %s` in `%s`, the result
437                 was `%s` which was not recognized as being the same as
438                 the original function.
439                 So either the period was wrong or the two forms were
440                 not recognized as being equal.
441                 Set check=False to obtain the value.''' %
442                 (symbol, symbol, period, orig_f, new_f)))
443 
444     orig_f = f
445     period = None
446 
447     if isinstance(f, Relational):
448         f = f.lhs - f.rhs
449 
450     f = simplify(f)
451 
452     if symbol not in f.free_symbols:
453         return S.Zero
454 
455     if isinstance(f, TrigonometricFunction):
456         try:
457             period = f.period(symbol)
458         except NotImplementedError:
459             pass
460 
461     if isinstance(f, Abs):
462         arg = f.args[0]
463         if isinstance(arg, (sec, csc, cos)):
464             # all but tan and cot might have a
465             # a period that is half as large
466             # so recast as sin
467             arg = sin(arg.args[0])
468         period = periodicity(arg, symbol)
469         if period is not None and isinstance(arg, sin):
470             # the argument of Abs was a trigonometric other than
471             # cot or tan; test to see if the half-period
472             # is valid. Abs(arg) has behaviour equivalent to
473             # orig_f, so use that for test:
474             orig_f = Abs(arg)
475             try:
476                 return _check(orig_f, period/2)
477             except NotImplementedError as err:
478                 if check:
479                     raise NotImplementedError(err)
480             # else let new orig_f and period be
481             # checked below
482 
483     if isinstance(f, exp):
484         if im(f) != 0:
485             period_real = periodicity(re(f), symbol)
486             period_imag = periodicity(im(f), symbol)
487             if period_real is not None and period_imag is not None:
488                 period = lcim([period_real, period_imag])
489 
490     if f.is_Pow:
491         base, expo = f.args
492         base_has_sym = base.has(symbol)
493         expo_has_sym = expo.has(symbol)
494 
495         if base_has_sym and not expo_has_sym:
496             period = periodicity(base, symbol)
497 
498         elif expo_has_sym and not base_has_sym:
499             period = periodicity(expo, symbol)
500 
501         else:
502             period = _periodicity(f.args, symbol)
503 
504     elif f.is_Mul:
505         coeff, g = f.as_independent(symbol, as_Add=False)
506         if isinstance(g, TrigonometricFunction) or coeff is not S.One:
507             period = periodicity(g, symbol)
508 
509         else:
510             period = _periodicity(g.args, symbol)
511 
512     elif f.is_Add:
513         k, g = f.as_independent(symbol)
514         if k is not S.Zero:
515             return periodicity(g, symbol)
516 
517         period = _periodicity(g.args, symbol)
518 
519     elif isinstance(f, Mod):
520         a, n = f.args
521 
522         if a == symbol:
523             period = n
524         elif isinstance(a, TrigonometricFunction):
525             period = periodicity(a, symbol)
526         #check if 'f' is linear in 'symbol'
527         elif (a.is_polynomial(symbol) and degree(a, symbol) == 1 and
528             symbol not in n.free_symbols):
529                 period = Abs(n / a.diff(symbol))
530 
531     elif period is None:
532         from sympy.solvers.decompogen import compogen
533         g_s = decompogen(f, symbol)
534         num_of_gs = len(g_s)
535         if num_of_gs > 1:
536             for index, g in enumerate(reversed(g_s)):
537                 start_index = num_of_gs - 1 - index
538                 g = compogen(g_s[start_index:], symbol)
539                 if g != orig_f and g != f: # Fix for issue 12620
540                     period = periodicity(g, symbol)
541                     if period is not None:
542                         break
543 
544     if period is not None:
545         if check:
546             return _check(orig_f, period)
547         return period
548 
549     return None
550 
551 
552 def _periodicity(args, symbol):
553     """
554     Helper for `periodicity` to find the period of a list of simpler
555     functions.
556     It uses the `lcim` method to find the least common period of
557     all the functions.
558 
559     Parameters
560     ==========
561 
562     args : Tuple of Symbol
563         All the symbols present in a function.
564 
565     symbol : Symbol
566         The symbol over which the function is to be evaluated.
567 
568     Returns
569     =======
570 
571     period
572         The least common period of the function for all the symbols
573         of the function.
574         None if for at least one of the symbols the function is aperiodic
575 
576     """
577     periods = []
578     for f in args:
579         period = periodicity(f, symbol)
580         if period is None:
581             return None
582 
583         if period is not S.Zero:
584             periods.append(period)
585 
586     if len(periods) > 1:
587         return lcim(periods)
588 
589     if periods:
590         return periods[0]
591 
592 
593 def lcim(numbers):
594     """Returns the least common integral multiple of a list of numbers.
595 
596     The numbers can be rational or irrational or a mixture of both.
597     `None` is returned for incommensurable numbers.
598 
599     Parameters
600     ==========
601 
602     numbers : list
603         Numbers (rational and/or irrational) for which lcim is to be found.
604 
605     Returns
606     =======
607 
608     number
609         lcim if it exists, otherwise `None` for incommensurable numbers.
610 
611     Examples
612     ========
613 
614     >>> from sympy import S, pi
615     >>> from sympy.calculus.util import lcim
616     >>> lcim([S(1)/2, S(3)/4, S(5)/6])
617     15/2
618     >>> lcim([2*pi, 3*pi, pi, pi/2])
619     6*pi
620     >>> lcim([S(1), 2*pi])
621     """
622     result = None
623     if all(num.is_irrational for num in numbers):
624         factorized_nums = list(map(lambda num: num.factor(), numbers))
625         factors_num = list(
626             map(lambda num: num.as_coeff_Mul(),
627                 factorized_nums))
628         term = factors_num[0][1]
629         if all(factor == term for coeff, factor in factors_num):
630             common_term = term
631             coeffs = [coeff for coeff, factor in factors_num]
632             result = lcm_list(coeffs) * common_term
633 
634     elif all(num.is_rational for num in numbers):
635         result = lcm_list(numbers)
636 
637     else:
638         pass
639 
640     return result
641 
642 def is_convex(f, *syms, **kwargs):
643     """Determines the  convexity of the function passed in the argument.
644 
645     Parameters
646     ==========
647 
648     f : Expr
649         The concerned function.
650     syms : Tuple of symbols
651         The variables with respect to which the convexity is to be determined.
652     domain : Interval, optional
653         The domain over which the convexity of the function has to be checked.
654         If unspecified, S.Reals will be the default domain.
655 
656     Returns
657     =======
658 
659     Boolean
660         The method returns `True` if the function is convex otherwise it
661         returns `False`.
662 
663     Raises
664     ======
665 
666     NotImplementedError
667         The check for the convexity of multivariate functions is not implemented yet.
668 
669     Notes
670     =====
671 
672     To determine concavity of a function pass `-f` as the concerned function.
673     To determine logarithmic convexity of a function pass log(f) as
674     concerned function.
675     To determine logartihmic concavity of a function pass -log(f) as
676     concerned function.
677 
678     Currently, convexity check of multivariate functions is not handled.
679 
680     Examples
681     ========
682 
683     >>> from sympy import symbols, exp, oo, Interval
684     >>> from sympy.calculus.util import is_convex
685     >>> x = symbols('x')
686     >>> is_convex(exp(x), x)
687     True
688     >>> is_convex(x**3, x, domain = Interval(-1, oo))
689     False
690 
691     References
692     ==========
693 
694     .. [1] https://en.wikipedia.org/wiki/Convex_function
695     .. [2] http://www.ifp.illinois.edu/~angelia/L3_convfunc.pdf
696     .. [3] https://en.wikipedia.org/wiki/Logarithmically_convex_function
697     .. [4] https://en.wikipedia.org/wiki/Logarithmically_concave_function
698     .. [5] https://en.wikipedia.org/wiki/Concave_function
699 
700     """
701 
702     if len(syms) > 1:
703         raise NotImplementedError(
704             "The check for the convexity of multivariate functions is not implemented yet.")
705 
706     f = _sympify(f)
707     domain = kwargs.get('domain', S.Reals)
708     var = syms[0]
709     condition = f.diff(var, 2) < 0
710     if solve_univariate_inequality(condition, var, False, domain):
711         return False
712     return True
713 
714 
715 def stationary_points(f, symbol, domain=S.Reals):
716     """
717     Returns the stationary points of a function (where derivative of the
718     function is 0) in the given domain.
719 
720     Parameters
721     ==========
722 
723     f : Expr
724         The concerned function.
725     symbol : Symbol
726         The variable for which the stationary points are to be determined.
727     domain : Interval
728         The domain over which the stationary points have to be checked.
729         If unspecified, S.Reals will be the default domain.
730 
731     Examples
732     ========
733 
734     >>> from sympy import Symbol, S, sin, log, pi, pprint, stationary_points
735     >>> from sympy.sets import Interval
736     >>> x = Symbol('x')
737 
738     >>> stationary_points(1/x, x, S.Reals)
739     EmptySet
740 
741     >>> pprint(stationary_points(sin(x), x), use_unicode=False)
742               pi                              3*pi
743     {2*n*pi + -- | n in Integers} U {2*n*pi + ---- | n in Integers}
744               2                                2
745 
746     >>> stationary_points(sin(x),x, Interval(0, 4*pi))
747     FiniteSet(pi/2, 3*pi/2, 5*pi/2, 7*pi/2)
748 
749     """
750     from sympy import solveset, diff
751 
752     if isinstance(domain, EmptySet):
753         return S.EmptySet
754 
755     domain = continuous_domain(f, symbol, domain)
756     set = solveset(diff(f, symbol), symbol, domain)
757 
758     return set
759 
760 
761 def maximum(f, symbol, domain=S.Reals):
762     """
763     Returns the maximum value of a function in the given domain.
764 
765     Parameters
766     ==========
767 
768     f : Expr
769         The concerned function.
770     symbol : Symbol
771         The variable for maximum value needs to be determined.
772     domain : Interval
773         The domain over which the maximum have to be checked.
774         If unspecified, then Global maximum is returned.
775 
776     Examples
777     ========
778 
779     >>> from sympy import Symbol, S, sin, cos, pi, maximum
780     >>> from sympy.sets import Interval
781     >>> x = Symbol('x')
782 
783     >>> f = -x**2 + 2*x + 5
784     >>> maximum(f, x, S.Reals)
785     6
786 
787     >>> maximum(sin(x), x, Interval(-pi, pi/4))
788     sqrt(2)/2
789 
790     >>> maximum(sin(x)*cos(x), x)
791     1/2
792 
793     """
794     from sympy import Symbol
795 
796     if isinstance(symbol, Symbol):
797         if isinstance(domain, EmptySet):
798             raise ValueError("Maximum value not defined for empty domain.")
799 
800         return function_range(f, symbol, domain).sup
801     else:
802         raise ValueError("%s is not a valid symbol." % symbol)
803 
804 
805 def minimum(f, symbol, domain=S.Reals):
806     """
807     Returns the minimum value of a function in the given domain.
808 
809     Parameters
810     ==========
811 
812     f : Expr
813         The concerned function.
814     symbol : Symbol
815         The variable for minimum value needs to be determined.
816     domain : Interval
817         The domain over which the minimum have to be checked.
818         If unspecified, then Global minimum is returned.
819 
820     Examples
821     ========
822 
823     >>> from sympy import Symbol, S, sin, cos, minimum
824     >>> from sympy.sets import Interval
825     >>> x = Symbol('x')
826 
827     >>> f = x**2 + 2*x + 5
828     >>> minimum(f, x, S.Reals)
829     4
830 
831     >>> minimum(sin(x), x, Interval(2, 3))
832     sin(3)
833 
834     >>> minimum(sin(x)*cos(x), x)
835     -1/2
836 
837     """
838     from sympy import Symbol
839 
840     if isinstance(symbol, Symbol):
841         if isinstance(domain, EmptySet):
842             raise ValueError("Minimum value not defined for empty domain.")
843 
844         return function_range(f, symbol, domain).inf
845     else:
846         raise ValueError("%s is not a valid symbol." % symbol)
847 
848 
849 class AccumulationBounds(AtomicExpr):
850     r"""
851     # Note AccumulationBounds has an alias: AccumBounds
852 
853     AccumulationBounds represent an interval `[a, b]`, which is always closed
854     at the ends. Here `a` and `b` can be any value from extended real numbers.
855 
856     The intended meaning of AccummulationBounds is to give an approximate
857     location of the accumulation points of a real function at a limit point.
858 
859     Let `a` and `b` be reals such that a <= b.
860 
861     `\left\langle a, b\right\rangle = \{x \in \mathbb{R} \mid a \le x \le b\}`
862 
863     `\left\langle -\infty, b\right\rangle = \{x \in \mathbb{R} \mid x \le b\} \cup \{-\infty, \infty\}`
864 
865     `\left\langle a, \infty \right\rangle = \{x \in \mathbb{R} \mid a \le x\} \cup \{-\infty, \infty\}`
866 
867     `\left\langle -\infty, \infty \right\rangle = \mathbb{R} \cup \{-\infty, \infty\}`
868 
869     `oo` and `-oo` are added to the second and third definition respectively,
870     since if either `-oo` or `oo` is an argument, then the other one should
871     be included (though not as an end point). This is forced, since we have,
872     for example, `1/AccumBounds(0, 1) = AccumBounds(1, oo)`, and the limit at
873     `0` is not one-sided. As x tends to `0-`, then `1/x -> -oo`, so `-oo`
874     should be interpreted as belonging to `AccumBounds(1, oo)` though it need
875     not appear explicitly.
876 
877     In many cases it suffices to know that the limit set is bounded.
878     However, in some other cases more exact information could be useful.
879     For example, all accumulation values of cos(x) + 1 are non-negative.
880     (AccumBounds(-1, 1) + 1 = AccumBounds(0, 2))
881 
882     A AccumulationBounds object is defined to be real AccumulationBounds,
883     if its end points are finite reals.
884 
885     Let `X`, `Y` be real AccumulationBounds, then their sum, difference,
886     product are defined to be the following sets:
887 
888     `X + Y = \{ x+y \mid x \in X \cap y \in Y\}`
889 
890     `X - Y = \{ x-y \mid x \in X \cap y \in Y\}`
891 
892     `X * Y = \{ x*y \mid x \in X \cap y \in Y\}`
893 
894     There is, however, no consensus on Interval division.
895 
896     `X / Y = \{ z \mid \exists x \in X, y \in Y \mid y \neq 0, z = x/y\}`
897 
898     Note: According to this definition the quotient of two AccumulationBounds
899     may not be a AccumulationBounds object but rather a union of
900     AccumulationBounds.
901 
902     Note
903     ====
904 
905     The main focus in the interval arithmetic is on the simplest way to
906     calculate upper and lower endpoints for the range of values of a
907     function in one or more variables. These barriers are not necessarily
908     the supremum or infimum, since the precise calculation of those values
909     can be difficult or impossible.
910 
911     Examples
912     ========
913 
914     >>> from sympy import AccumBounds, sin, exp, log, pi, E, S, oo
915     >>> from sympy.abc import x
916 
917     >>> AccumBounds(0, 1) + AccumBounds(1, 2)
918     AccumBounds(1, 3)
919 
920     >>> AccumBounds(0, 1) - AccumBounds(0, 2)
921     AccumBounds(-2, 1)
922 
923     >>> AccumBounds(-2, 3)*AccumBounds(-1, 1)
924     AccumBounds(-3, 3)
925 
926     >>> AccumBounds(1, 2)*AccumBounds(3, 5)
927     AccumBounds(3, 10)
928 
929     The exponentiation of AccumulationBounds is defined
930     as follows:
931 
932     If 0 does not belong to `X` or `n > 0` then
933 
934     `X^n = \{ x^n \mid x \in X\}`
935 
936     otherwise
937 
938     `X^n = \{ x^n \mid x \neq 0, x \in X\} \cup \{-\infty, \infty\}`
939 
940     Here for fractional `n`, the part of `X` resulting in a complex
941     AccumulationBounds object is neglected.
942 
943     >>> AccumBounds(-1, 4)**(S(1)/2)
944     AccumBounds(0, 2)
945 
946     >>> AccumBounds(1, 2)**2
947     AccumBounds(1, 4)
948 
949     >>> AccumBounds(-1, oo)**(-1)
950     AccumBounds(-oo, oo)
951 
952     Note: `<a, b>^2` is not same as `<a, b>*<a, b>`
953 
954     >>> AccumBounds(-1, 1)**2
955     AccumBounds(0, 1)
956 
957     >>> AccumBounds(1, 3) < 4
958     True
959 
960     >>> AccumBounds(1, 3) < -1
961     False
962 
963     Some elementary functions can also take AccumulationBounds as input.
964     A function `f` evaluated for some real AccumulationBounds `<a, b>`
965     is defined as `f(\left\langle a, b\right\rangle) = \{ f(x) \mid a \le x \le b \}`
966 
967     >>> sin(AccumBounds(pi/6, pi/3))
968     AccumBounds(1/2, sqrt(3)/2)
969 
970     >>> exp(AccumBounds(0, 1))
971     AccumBounds(1, E)
972 
973     >>> log(AccumBounds(1, E))
974     AccumBounds(0, 1)
975 
976     Some symbol in an expression can be substituted for a AccumulationBounds
977     object. But it doesn't necessarily evaluate the AccumulationBounds for
978     that expression.
979 
980     Same expression can be evaluated to different values depending upon
981     the form it is used for substitution. For example:
982 
983     >>> (x**2 + 2*x + 1).subs(x, AccumBounds(-1, 1))
984     AccumBounds(-1, 4)
985 
986     >>> ((x + 1)**2).subs(x, AccumBounds(-1, 1))
987     AccumBounds(0, 4)
988 
989     References
990     ==========
991 
992     .. [1] https://en.wikipedia.org/wiki/Interval_arithmetic
993 
994     .. [2] http://fab.cba.mit.edu/classes/S62.12/docs/Hickey_interval.pdf
995 
996     Notes
997     =====
998 
999     Do not use ``AccumulationBounds`` for floating point interval arithmetic
1000     calculations, use ``mpmath.iv`` instead.
1001     """
1002 
1003     is_extended_real = True
1004 
1005     def __new__(cls, min, max):
1006 
1007         min = _sympify(min)
1008         max = _sympify(max)
1009 
1010         # Only allow real intervals (use symbols with 'is_extended_real=True').
1011         if not min.is_extended_real or not max.is_extended_real:
1012             raise ValueError("Only real AccumulationBounds are supported")
1013 
1014         # Make sure that the created AccumBounds object will be valid.
1015         if max.is_comparable and min.is_comparable:
1016             if max < min:
1017                 raise ValueError(
1018                     "Lower limit should be smaller than upper limit")
1019 
1020         if max == min:
1021             return max
1022 
1023         return Basic.__new__(cls, min, max)
1024 
1025     # setting the operation priority
1026     _op_priority = 11.0
1027 
1028     def _eval_is_real(self):
1029         if self.min.is_real and self.max.is_real:
1030             return True
1031 
1032     @property
1033     def min(self):
1034         """
1035         Returns the minimum possible value attained by AccumulationBounds
1036         object.
1037 
1038         Examples
1039         ========
1040 
1041         >>> from sympy import AccumBounds
1042         >>> AccumBounds(1, 3).min
1043         1
1044 
1045         """
1046         return self.args[0]
1047 
1048     @property
1049     def max(self):
1050         """
1051         Returns the maximum possible value attained by AccumulationBounds
1052         object.
1053 
1054         Examples
1055         ========
1056 
1057         >>> from sympy import AccumBounds
1058         >>> AccumBounds(1, 3).max
1059         3
1060 
1061         """
1062         return self.args[1]
1063 
1064     @property
1065     def delta(self):
1066         """
1067         Returns the difference of maximum possible value attained by
1068         AccumulationBounds object and minimum possible value attained
1069         by AccumulationBounds object.
1070 
1071         Examples
1072         ========
1073 
1074         >>> from sympy import AccumBounds
1075         >>> AccumBounds(1, 3).delta
1076         2
1077 
1078         """
1079         return self.max - self.min
1080 
1081     @property
1082     def mid(self):
1083         """
1084         Returns the mean of maximum possible value attained by
1085         AccumulationBounds object and minimum possible value
1086         attained by AccumulationBounds object.
1087 
1088         Examples
1089         ========
1090 
1091         >>> from sympy import AccumBounds
1092         >>> AccumBounds(1, 3).mid
1093         2
1094 
1095         """
1096         return (self.min + self.max) / 2
1097 
1098     @_sympifyit('other', NotImplemented)
1099     def _eval_power(self, other):
1100         return self.__pow__(other)
1101 
1102     @_sympifyit('other', NotImplemented)
1103     def __add__(self, other):
1104         if isinstance(other, Expr):
1105             if isinstance(other, AccumBounds):
1106                 return AccumBounds(
1107                     Add(self.min, other.min),
1108                     Add(self.max, other.max))
1109             if other is S.Infinity and self.min is S.NegativeInfinity or \
1110                     other is S.NegativeInfinity and self.max is S.Infinity:
1111                 return AccumBounds(-oo, oo)
1112             elif other.is_extended_real:
1113                 return AccumBounds(Add(self.min, other), Add(self.max, other))
1114             return Add(self, other, evaluate=False)
1115         return NotImplemented
1116 
1117     __radd__ = __add__
1118 
1119     def __neg__(self):
1120         return AccumBounds(-self.max, -self.min)
1121 
1122     @_sympifyit('other', NotImplemented)
1123     def __sub__(self, other):
1124         if isinstance(other, Expr):
1125             if isinstance(other, AccumBounds):
1126                 return AccumBounds(
1127                     Add(self.min, -other.max),
1128                     Add(self.max, -other.min))
1129             if other is S.NegativeInfinity and self.min is S.NegativeInfinity or \
1130                     other is S.Infinity and self.max is S.Infinity:
1131                 return AccumBounds(-oo, oo)
1132             elif other.is_extended_real:
1133                 return AccumBounds(
1134                     Add(self.min, -other),
1135                     Add(self.max, -other))
1136             return Add(self, -other, evaluate=False)
1137         return NotImplemented
1138 
1139     @_sympifyit('other', NotImplemented)
1140     def __rsub__(self, other):
1141         return self.__neg__() + other
1142 
1143     @_sympifyit('other', NotImplemented)
1144     def __mul__(self, other):
1145         if isinstance(other, Expr):
1146             if isinstance(other, AccumBounds):
1147                 return AccumBounds(Min(Mul(self.min, other.min),
1148                                        Mul(self.min, other.max),
1149                                        Mul(self.max, other.min),
1150                                        Mul(self.max, other.max)),
1151                                    Max(Mul(self.min, other.min),
1152                                        Mul(self.min, other.max),
1153                                        Mul(self.max, other.min),
1154                                        Mul(self.max, other.max)))
1155             if other is S.Infinity:
1156                 if self.min.is_zero:
1157                     return AccumBounds(0, oo)
1158                 if self.max.is_zero:
1159                     return AccumBounds(-oo, 0)
1160             if other is S.NegativeInfinity:
1161                 if self.min.is_zero:
1162                     return AccumBounds(-oo, 0)
1163                 if self.max.is_zero:
1164                     return AccumBounds(0, oo)
1165             if other.is_extended_real:
1166                 if other.is_zero:
1167                     if self == AccumBounds(-oo, oo):
1168                         return AccumBounds(-oo, oo)
1169                     if self.max is S.Infinity:
1170                         return AccumBounds(0, oo)
1171                     if self.min is S.NegativeInfinity:
1172                         return AccumBounds(-oo, 0)
1173                     return S.Zero
1174                 if other.is_extended_positive:
1175                     return AccumBounds(
1176                         Mul(self.min, other),
1177                         Mul(self.max, other))
1178                 elif other.is_extended_negative:
1179                     return AccumBounds(
1180                         Mul(self.max, other),
1181                         Mul(self.min, other))
1182             if isinstance(other, Order):
1183                 return other
1184             return Mul(self, other, evaluate=False)
1185         return NotImplemented
1186 
1187     __rmul__ = __mul__
1188 
1189     @_sympifyit('other', NotImplemented)
1190     def __div__(self, other):
1191         if isinstance(other, Expr):
1192             if isinstance(other, AccumBounds):
1193                 if S.Zero not in other:
1194                     return self * AccumBounds(1/other.max, 1/other.min)
1195 
1196                 if S.Zero in self and S.Zero in other:
1197                     if self.min.is_zero and other.min.is_zero:
1198                         return AccumBounds(0, oo)
1199                     if self.max.is_zero and other.min.is_zero:
1200                         return AccumBounds(-oo, 0)
1201                     return AccumBounds(-oo, oo)
1202 
1203                 if self.max.is_extended_negative:
1204                     if other.min.is_extended_negative:
1205                         if other.max.is_zero:
1206                             return AccumBounds(self.max / other.min, oo)
1207                         if other.max.is_extended_positive:
1208                             # the actual answer is a Union of AccumBounds,
1209                             # Union(AccumBounds(-oo, self.max/other.max),
1210                             #       AccumBounds(self.max/other.min, oo))
1211                             return AccumBounds(-oo, oo)
1212 
1213                     if other.min.is_zero and other.max.is_extended_positive:
1214                         return AccumBounds(-oo, self.max / other.max)
1215 
1216                 if self.min.is_extended_positive:
1217                     if other.min.is_extended_negative:
1218                         if other.max.is_zero:
1219                             return AccumBounds(-oo, self.min / other.min)
1220                         if other.max.is_extended_positive:
1221                             # the actual answer is a Union of AccumBounds,
1222                             # Union(AccumBounds(-oo, self.min/other.min),
1223                             #       AccumBounds(self.min/other.max, oo))
1224                             return AccumBounds(-oo, oo)
1225 
1226                     if other.min.is_zero and other.max.is_extended_positive:
1227                         return AccumBounds(self.min / other.max, oo)
1228 
1229             elif other.is_extended_real:
1230                 if other is S.Infinity or other is S.NegativeInfinity:
1231                     if self == AccumBounds(-oo, oo):
1232                         return AccumBounds(-oo, oo)
1233                     if self.max is S.Infinity:
1234                         return AccumBounds(Min(0, other), Max(0, other))
1235                     if self.min is S.NegativeInfinity:
1236                         return AccumBounds(Min(0, -other), Max(0, -other))
1237                 if other.is_extended_positive:
1238                     return AccumBounds(self.min / other, self.max / other)
1239                 elif other.is_extended_negative:
1240                     return AccumBounds(self.max / other, self.min / other)
1241             return Mul(self, 1 / other, evaluate=False)
1242 
1243         return NotImplemented
1244 
1245     __truediv__ = __div__
1246 
1247     @_sympifyit('other', NotImplemented)
1248     def __rdiv__(self, other):
1249         if isinstance(other, Expr):
1250             if other.is_extended_real:
1251                 if other.is_zero:
1252                     return S.Zero
1253                 if S.Zero in self:
1254                     if self.min.is_zero:
1255                         if other.is_extended_positive:
1256                             return AccumBounds(Mul(other, 1 / self.max), oo)
1257                         if other.is_extended_negative:
1258                             return AccumBounds(-oo, Mul(other, 1 / self.max))
1259                     if self.max.is_zero:
1260                         if other.is_extended_positive:
1261                             return AccumBounds(-oo, Mul(other, 1 / self.min))
1262                         if other.is_extended_negative:
1263                             return AccumBounds(Mul(other, 1 / self.min), oo)
1264                     return AccumBounds(-oo, oo)
1265                 else:
1266                     return AccumBounds(Min(other / self.min, other / self.max),
1267                                        Max(other / self.min, other / self.max))
1268             return Mul(other, 1 / self, evaluate=False)
1269         else:
1270             return NotImplemented
1271 
1272     __rtruediv__ = __rdiv__
1273 
1274     @_sympifyit('other', NotImplemented)
1275     def __pow__(self, other):
1276         from sympy.functions.elementary.miscellaneous import real_root
1277         if isinstance(other, Expr):
1278             if other is S.Infinity:
1279                 if self.min.is_extended_nonnegative:
1280                     if self.max < 1:
1281                         return S.Zero
1282                     if self.min > 1:
1283                         return S.Infinity
1284                     return AccumBounds(0, oo)
1285                 elif self.max.is_extended_negative:
1286                     if self.min > -1:
1287                         return S.Zero
1288                     if self.max < -1:
1289                         return FiniteSet(-oo, oo)
1290                     return AccumBounds(-oo, oo)
1291                 else:
1292                     if self.min > -1:
1293                         if self.max < 1:
1294                             return S.Zero
1295                         return AccumBounds(0, oo)
1296                     return AccumBounds(-oo, oo)
1297 
1298             if other is S.NegativeInfinity:
1299                 return (1 / self)**oo
1300 
1301             if other.is_extended_real and other.is_number:
1302                 if other.is_zero:
1303                     return S.One
1304 
1305                 if other.is_Integer:
1306                     if self.min.is_extended_positive:
1307                         return AccumBounds(
1308                             Min(self.min ** other, self.max ** other),
1309                             Max(self.min ** other, self.max ** other))
1310                     elif self.max.is_extended_negative:
1311                         return AccumBounds(
1312                             Min(self.max ** other, self.min ** other),
1313                             Max(self.max ** other, self.min ** other))
1314 
1315                     if other % 2 == 0:
1316                         if other.is_extended_negative:
1317                             if self.min.is_zero:
1318                                 return AccumBounds(self.max**other, oo)
1319                             if self.max.is_zero:
1320                                 return AccumBounds(self.min**other, oo)
1321                             return AccumBounds(0, oo)
1322                         return AccumBounds(
1323                             S.Zero, Max(self.min**other, self.max**other))
1324                     else:
1325                         if other.is_extended_negative:
1326                             if self.min.is_zero:
1327                                 return AccumBounds(self.max**other, oo)
1328                             if self.max.is_zero:
1329                                 return AccumBounds(-oo, self.min**other)
1330                             return AccumBounds(-oo, oo)
1331                         return AccumBounds(self.min**other, self.max**other)
1332 
1333                 num, den = other.as_numer_denom()
1334                 if num == S.One:
1335                     if den % 2 == 0:
1336                         if S.Zero in self:
1337                             if self.min.is_extended_negative:
1338                                 return AccumBounds(0, real_root(self.max, den))
1339                     return AccumBounds(real_root(self.min, den),
1340                                        real_root(self.max, den))
1341                 if den!=1:
1342                     num_pow = self**num
1343                     return num_pow**(1 / den)
1344             return AccumBounds(-oo, oo)
1345 
1346         return NotImplemented
1347 
1348     def __abs__(self):
1349         if self.max.is_extended_negative:
1350             return self.__neg__()
1351         elif self.min.is_extended_negative:
1352             return AccumBounds(S.Zero, Max(abs(self.min), self.max))
1353         else:
1354             return self
1355 
1356     def __lt__(self, other):
1357         """
1358         Returns True if range of values attained by `self` AccumulationBounds
1359         object is less than the range of values attained by `other`, where
1360         other may be any value of type AccumulationBounds object or extended
1361         real number value, False if `other` satisfies the same property, else
1362         an unevaluated Relational
1363 
1364         Examples
1365         ========
1366 
1367         >>> from sympy import AccumBounds, oo
1368         >>> AccumBounds(1, 3) < AccumBounds(4, oo)
1369         True
1370         >>> AccumBounds(1, 4) < AccumBounds(3, 4)
1371         AccumBounds(1, 4) < AccumBounds(3, 4)
1372         >>> AccumBounds(1, oo) < -1
1373         False
1374 
1375         """
1376         other = _sympify(other)
1377         if isinstance(other, AccumBounds):
1378             if self.max < other.min:
1379                 return True
1380             if self.min >= other.max:
1381                 return False
1382         elif not other.is_extended_real:
1383             raise TypeError(
1384                 "Invalid comparison of %s %s" %
1385                 (type(other), other))
1386         elif other.is_comparable:
1387             if self.max < other:
1388                 return True
1389             if self.min >= other:
1390                 return False
1391         return super(AccumulationBounds, self).__lt__(other)
1392 
1393     def __le__(self, other):
1394         """
1395         Returns True if range of values attained by `self` AccumulationBounds
1396         object is less than or equal to the range of values attained by
1397         `other`, where other may be any value of type AccumulationBounds
1398         object or extended real number value, False if `other`
1399         satisfies the same property, else an unevaluated Relational.
1400 
1401         Examples
1402         ========
1403 
1404         >>> from sympy import AccumBounds, oo
1405         >>> AccumBounds(1, 3) <= AccumBounds(4, oo)
1406         True
1407         >>> AccumBounds(1, 4) <= AccumBounds(3, 4)
1408         AccumBounds(1, 4) <= AccumBounds(3, 4)
1409         >>> AccumBounds(1, 3) <= 0
1410         False
1411 
1412         """
1413         other = _sympify(other)
1414         if isinstance(other, AccumBounds):
1415             if self.max <= other.min:
1416                 return True
1417             if self.min > other.max:
1418                 return False
1419         elif not other.is_extended_real:
1420             raise TypeError(
1421                 "Invalid comparison of %s %s" %
1422                 (type(other), other))
1423         elif other.is_comparable:
1424             if self.max <= other:
1425                 return True
1426             if self.min > other:
1427                 return False
1428         return super(AccumulationBounds, self).__le__(other)
1429 
1430     def __gt__(self, other):
1431         """
1432         Returns True if range of values attained by `self` AccumulationBounds
1433         object is greater than the range of values attained by `other`,
1434         where other may be any value of type AccumulationBounds object or
1435         extended real number value, False if `other` satisfies
1436         the same property, else an unevaluated Relational.
1437 
1438         Examples
1439         ========
1440 
1441         >>> from sympy import AccumBounds, oo
1442         >>> AccumBounds(1, 3) > AccumBounds(4, oo)
1443         False
1444         >>> AccumBounds(1, 4) > AccumBounds(3, 4)
1445         AccumBounds(1, 4) > AccumBounds(3, 4)
1446         >>> AccumBounds(1, oo) > -1
1447         True
1448 
1449         """
1450         other = _sympify(other)
1451         if isinstance(other, AccumBounds):
1452             if self.min > other.max:
1453                 return True
1454             if self.max <= other.min:
1455                 return False
1456         elif not other.is_extended_real:
1457             raise TypeError(
1458                 "Invalid comparison of %s %s" %
1459                 (type(other), other))
1460         elif other.is_comparable:
1461             if self.min > other:
1462                 return True
1463             if self.max <= other:
1464                 return False
1465         return super(AccumulationBounds, self).__gt__(other)
1466 
1467     def __ge__(self, other):
1468         """
1469         Returns True if range of values attained by `self` AccumulationBounds
1470         object is less that the range of values attained by `other`, where
1471         other may be any value of type AccumulationBounds object or extended
1472         real number value, False if `other` satisfies the same
1473         property, else an unevaluated Relational.
1474 
1475         Examples
1476         ========
1477 
1478         >>> from sympy import AccumBounds, oo
1479         >>> AccumBounds(1, 3) >= AccumBounds(4, oo)
1480         False
1481         >>> AccumBounds(1, 4) >= AccumBounds(3, 4)
1482         AccumBounds(1, 4) >= AccumBounds(3, 4)
1483         >>> AccumBounds(1, oo) >= 1
1484         True
1485 
1486         """
1487         other = _sympify(other)
1488         if isinstance(other, AccumBounds):
1489             if self.min >= other.max:
1490                 return True
1491             if self.max < other.min:
1492                 return False
1493         elif not other.is_extended_real:
1494             raise TypeError(
1495                 "Invalid comparison of %s %s" %
1496                 (type(other), other))
1497         elif other.is_comparable:
1498             if self.min >= other:
1499                 return True
1500             if self.max < other:
1501                 return False
1502         return super(AccumulationBounds, self).__ge__(other)
1503 
1504     def __contains__(self, other):
1505         """
1506         Returns True if other is contained in self, where other
1507         belongs to extended real numbers, False if not contained,
1508         otherwise TypeError is raised.
1509 
1510         Examples
1511         ========
1512 
1513         >>> from sympy import AccumBounds, oo
1514         >>> 1 in AccumBounds(-1, 3)
1515         True
1516 
1517         -oo and oo go together as limits (in AccumulationBounds).
1518 
1519         >>> -oo in AccumBounds(1, oo)
1520         True
1521 
1522         >>> oo in AccumBounds(-oo, 0)
1523         True
1524 
1525         """
1526         other = _sympify(other)
1527 
1528         if other is S.Infinity or other is S.NegativeInfinity:
1529             if self.min is S.NegativeInfinity or self.max is S.Infinity:
1530                 return True
1531             return False
1532 
1533         rv = And(self.min <= other, self.max >= other)
1534         if rv not in (True, False):
1535             raise TypeError("input failed to evaluate")
1536         return rv
1537 
1538     def intersection(self, other):
1539         """
1540         Returns the intersection of 'self' and 'other'.
1541         Here other can be an instance of FiniteSet or AccumulationBounds.
1542 
1543         Examples
1544         ========
1545 
1546         >>> from sympy import AccumBounds, FiniteSet
1547         >>> AccumBounds(1, 3).intersection(AccumBounds(2, 4))
1548         AccumBounds(2, 3)
1549 
1550         >>> AccumBounds(1, 3).intersection(AccumBounds(4, 6))
1551         EmptySet
1552 
1553         >>> AccumBounds(1, 4).intersection(FiniteSet(1, 2, 5))
1554         FiniteSet(1, 2)
1555 
1556         """
1557         if not isinstance(other, (AccumBounds, FiniteSet)):
1558             raise TypeError(
1559                 "Input must be AccumulationBounds or FiniteSet object")
1560 
1561         if isinstance(other, FiniteSet):
1562             fin_set = S.EmptySet
1563             for i in other:
1564                 if i in self:
1565                     fin_set = fin_set + FiniteSet(i)
1566             return fin_set
1567 
1568         if self.max < other.min or self.min > other.max:
1569             return S.EmptySet
1570 
1571         if self.min <= other.min:
1572             if self.max <= other.max:
1573                 return AccumBounds(other.min, self.max)
1574             if self.max > other.max:
1575                 return other
1576 
1577         if other.min <= self.min:
1578             if other.max < self.max:
1579                 return AccumBounds(self.min, other.max)
1580             if other.max > self.max:
1581                 return self
1582 
1583     def union(self, other):
1584         # TODO : Devise a better method for Union of AccumBounds
1585         # this method is not actually correct and
1586         # can be made better
1587         if not isinstance(other, AccumBounds):
1588             raise TypeError(
1589                 "Input must be AccumulationBounds or FiniteSet object")
1590 
1591         if self.min <= other.min and self.max >= other.min:
1592             return AccumBounds(self.min, Max(self.max, other.max))
1593 
1594         if other.min <= self.min and other.max >= self.min:
1595             return AccumBounds(other.min, Max(self.max, other.max))
1596 
1597 
1598 # setting an alias for AccumulationBounds
1599 AccumBounds = AccumulationBounds

</code><intended_behavior>This code should ensure that any utility functions or mechanisms responsible for evaluating limits or behavior at infinity (`oo`) correctly interpret mathematical functions' growth, direction, or oscillation as they approach infinity, specifically accounting for exponential growth in a manner distinct from bounded oscillations or other behaviors.</intended_behavior>]
2025-10-18 20:34:05.898 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-18 20:34:05.898 | INFO     | Search-only: skipping patch selection
2025-10-18 20:34:05.974 | INFO     | Task sympy__sympy-18478 completed successfully.
2025-10-18 20:34:05.975 | INFO     | No patch generated. You can try running ACR again.
