[
    {
        "rel_file_path": "sympy/core/basic.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sympy__sympy/setup_sympy__sympy__1.6/sympy/core/basic.py",
        "start": 778,
        "end": 975,
        "class_name": null,
        "method_name": "subs",
        "code": "778     def subs(self, *args, **kwargs):\n779         \"\"\"\n780         Substitutes old for new in an expression after sympifying args.\n781 \n782         `args` is either:\n783           - two arguments, e.g. foo.subs(old, new)\n784           - one iterable argument, e.g. foo.subs(iterable). The iterable may be\n785              o an iterable container with (old, new) pairs. In this case the\n786                replacements are processed in the order given with successive\n787                patterns possibly affecting replacements already made.\n788              o a dict or set whose key/value items correspond to old/new pairs.\n789                In this case the old/new pairs will be sorted by op count and in\n790                case of a tie, by number of args and the default_sort_key. The\n791                resulting sorted list is then processed as an iterable container\n792                (see previous).\n793 \n794         If the keyword ``simultaneous`` is True, the subexpressions will not be\n795         evaluated until all the substitutions have been made.\n796 \n797         Examples\n798         ========\n799 \n800         >>> from sympy import pi, exp, limit, oo\n801         >>> from sympy.abc import x, y\n802         >>> (1 + x*y).subs(x, pi)\n803         pi*y + 1\n804         >>> (1 + x*y).subs({x:pi, y:2})\n805         1 + 2*pi\n806         >>> (1 + x*y).subs([(x, pi), (y, 2)])\n807         1 + 2*pi\n808         >>> reps = [(y, x**2), (x, 2)]\n809         >>> (x + y).subs(reps)\n810         6\n811         >>> (x + y).subs(reversed(reps))\n812         x**2 + 2\n813 \n814         >>> (x**2 + x**4).subs(x**2, y)\n815         y**2 + y\n816 \n817         To replace only the x**2 but not the x**4, use xreplace:\n818 \n819         >>> (x**2 + x**4).xreplace({x**2: y})\n820         x**4 + y\n821 \n822         To delay evaluation until all substitutions have been made,\n823         set the keyword ``simultaneous`` to True:\n824 \n825         >>> (x/y).subs([(x, 0), (y, 0)])\n826         0\n827         >>> (x/y).subs([(x, 0), (y, 0)], simultaneous=True)\n828         nan\n829 \n830         This has the added feature of not allowing subsequent substitutions\n831         to affect those already made:\n832 \n833         >>> ((x + y)/y).subs({x + y: y, y: x + y})\n834         1\n835         >>> ((x + y)/y).subs({x + y: y, y: x + y}, simultaneous=True)\n836         y/(x + y)\n837 \n838         In order to obtain a canonical result, unordered iterables are\n839         sorted by count_op length, number of arguments and by the\n840         default_sort_key to break any ties. All other iterables are left\n841         unsorted.\n842 \n843         >>> from sympy import sqrt, sin, cos\n844         >>> from sympy.abc import a, b, c, d, e\n845 \n846         >>> A = (sqrt(sin(2*x)), a)\n847         >>> B = (sin(2*x), b)\n848         >>> C = (cos(2*x), c)\n849         >>> D = (x, d)\n850         >>> E = (exp(x), e)\n851 \n852         >>> expr = sqrt(sin(2*x))*sin(exp(x)*x)*cos(2*x) + sin(2*x)\n853 \n854         >>> expr.subs(dict([A, B, C, D, E]))\n855         a*c*sin(d*e) + b\n856 \n857         The resulting expression represents a literal replacement of the\n858         old arguments with the new arguments. This may not reflect the\n859         limiting behavior of the expression:\n860 \n861         >>> (x**3 - 3*x).subs({x: oo})\n862         nan\n863 \n864         >>> limit(x**3 - 3*x, x, oo)\n865         oo\n866 \n867         If the substitution will be followed by numerical\n868         evaluation, it is better to pass the substitution to\n869         evalf as\n870 \n871         >>> (1/x).evalf(subs={x: 3.0}, n=21)\n872         0.333333333333333333333\n873 \n874         rather than\n875 \n876         >>> (1/x).subs({x: 3.0}).evalf(21)\n877         0.333333333333333314830\n878 \n879         as the former will ensure that the desired level of precision is\n880         obtained.\n881 \n882         See Also\n883         ========\n884         replace: replacement capable of doing wildcard-like matching,\n885                  parsing of match, and conditional replacements\n886         xreplace: exact node replacement in expr tree; also capable of\n887                   using matching rules\n888         sympy.core.evalf.EvalfMixin.evalf: calculates the given formula to a desired level of precision\n889 \n890         \"\"\"\n891         from sympy.core.containers import Dict\n892         from sympy.utilities import default_sort_key\n893         from sympy import Dummy, Symbol\n894 \n895         unordered = False\n896         if len(args) == 1:\n897             sequence = args[0]\n898             if isinstance(sequence, set):\n899                 unordered = True\n900             elif isinstance(sequence, (Dict, Mapping)):\n901                 unordered = True\n902                 sequence = sequence.items()\n903             elif not iterable(sequence):\n904                 from sympy.utilities.misc import filldedent\n905                 raise ValueError(filldedent(\"\"\"\n906                    When a single argument is passed to subs\n907                    it should be a dictionary of old: new pairs or an iterable\n908                    of (old, new) tuples.\"\"\"))\n909         elif len(args) == 2:\n910             sequence = [args]\n911         else:\n912             raise ValueError(\"subs accepts either 1 or 2 arguments\")\n913 \n914         sequence = list(sequence)\n915         for i, s in enumerate(sequence):\n916             if isinstance(s[0], str):\n917                 # when old is a string we prefer Symbol\n918                 s = Symbol(s[0]), s[1]\n919             try:\n920                 s = [sympify(_, strict=not isinstance(_, str))\n921                      for _ in s]\n922             except SympifyError:\n923                 # if it can't be sympified, skip it\n924                 sequence[i] = None\n925                 continue\n926             # skip if there is no change\n927             sequence[i] = None if _aresame(*s) else tuple(s)\n928         sequence = list(filter(None, sequence))\n929 \n930         if unordered:\n931             sequence = dict(sequence)\n932             if not all(k.is_Atom for k in sequence):\n933                 d = {}\n934                 for o, n in sequence.items():\n935                     try:\n936                         ops = o.count_ops(), len(o.args)\n937                     except TypeError:\n938                         ops = (0, 0)\n939                     d.setdefault(ops, []).append((o, n))\n940                 newseq = []\n941                 for k in sorted(d.keys(), reverse=True):\n942                     newseq.extend(\n943                         sorted([v[0] for v in d[k]], key=default_sort_key))\n944                 sequence = [(k, sequence[k]) for k in newseq]\n945                 del newseq, d\n946             else:\n947                 sequence = sorted([(k, v) for (k, v) in sequence.items()],\n948                                   key=default_sort_key)\n949 \n950         if kwargs.pop('simultaneous', False):  # XXX should this be the default for dict subs?\n951             reps = {}\n952             rv = self\n953             kwargs['hack2'] = True\n954             m = Dummy('subs_m')\n955             for old, new in sequence:\n956                 com = new.is_commutative\n957                 if com is None:\n958                     com = True\n959                 d = Dummy('subs_d', commutative=com)\n960                 # using d*m so Subs will be used on dummy variables\n961                 # in things like Derivative(f(x, y), x) in which x\n962                 # is both free and bound\n963                 rv = rv._subs(old, d*m, **kwargs)\n964                 if not isinstance(rv, Basic):\n965                     break\n966                 reps[d] = new\n967             reps[m] = S.One  # get rid of m\n968             return rv.xreplace(reps)\n969         else:\n970             rv = self\n971             for old, new in sequence:\n972                 rv = rv._subs(old, new, **kwargs)\n973                 if not isinstance(rv, Basic):\n974                     break\n975             return rv\n",
        "intended_behavior": "This code should ensure that expressions like `exp(x)` and `cos(x)` substituted with `oo` evaluate to infinity or the appropriate mathematical limit without reverting to `AccumBounds` unless absolutely mathematically necessary. The method should distinguish between cases where a function grows without bound vs. oscillates as `x` approaches infinity."
    },
    {
        "rel_file_path": "sympy/core/basic.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sympy__sympy/setup_sympy__sympy__1.6/sympy/core/basic.py",
        "start": 778,
        "end": 975,
        "class_name": "Basic",
        "method_name": "subs",
        "code": "778     def subs(self, *args, **kwargs):\n779         \"\"\"\n780         Substitutes old for new in an expression after sympifying args.\n781 \n782         `args` is either:\n783           - two arguments, e.g. foo.subs(old, new)\n784           - one iterable argument, e.g. foo.subs(iterable). The iterable may be\n785              o an iterable container with (old, new) pairs. In this case the\n786                replacements are processed in the order given with successive\n787                patterns possibly affecting replacements already made.\n788              o a dict or set whose key/value items correspond to old/new pairs.\n789                In this case the old/new pairs will be sorted by op count and in\n790                case of a tie, by number of args and the default_sort_key. The\n791                resulting sorted list is then processed as an iterable container\n792                (see previous).\n793 \n794         If the keyword ``simultaneous`` is True, the subexpressions will not be\n795         evaluated until all the substitutions have been made.\n796 \n797         Examples\n798         ========\n799 \n800         >>> from sympy import pi, exp, limit, oo\n801         >>> from sympy.abc import x, y\n802         >>> (1 + x*y).subs(x, pi)\n803         pi*y + 1\n804         >>> (1 + x*y).subs({x:pi, y:2})\n805         1 + 2*pi\n806         >>> (1 + x*y).subs([(x, pi), (y, 2)])\n807         1 + 2*pi\n808         >>> reps = [(y, x**2), (x, 2)]\n809         >>> (x + y).subs(reps)\n810         6\n811         >>> (x + y).subs(reversed(reps))\n812         x**2 + 2\n813 \n814         >>> (x**2 + x**4).subs(x**2, y)\n815         y**2 + y\n816 \n817         To replace only the x**2 but not the x**4, use xreplace:\n818 \n819         >>> (x**2 + x**4).xreplace({x**2: y})\n820         x**4 + y\n821 \n822         To delay evaluation until all substitutions have been made,\n823         set the keyword ``simultaneous`` to True:\n824 \n825         >>> (x/y).subs([(x, 0), (y, 0)])\n826         0\n827         >>> (x/y).subs([(x, 0), (y, 0)], simultaneous=True)\n828         nan\n829 \n830         This has the added feature of not allowing subsequent substitutions\n831         to affect those already made:\n832 \n833         >>> ((x + y)/y).subs({x + y: y, y: x + y})\n834         1\n835         >>> ((x + y)/y).subs({x + y: y, y: x + y}, simultaneous=True)\n836         y/(x + y)\n837 \n838         In order to obtain a canonical result, unordered iterables are\n839         sorted by count_op length, number of arguments and by the\n840         default_sort_key to break any ties. All other iterables are left\n841         unsorted.\n842 \n843         >>> from sympy import sqrt, sin, cos\n844         >>> from sympy.abc import a, b, c, d, e\n845 \n846         >>> A = (sqrt(sin(2*x)), a)\n847         >>> B = (sin(2*x), b)\n848         >>> C = (cos(2*x), c)\n849         >>> D = (x, d)\n850         >>> E = (exp(x), e)\n851 \n852         >>> expr = sqrt(sin(2*x))*sin(exp(x)*x)*cos(2*x) + sin(2*x)\n853 \n854         >>> expr.subs(dict([A, B, C, D, E]))\n855         a*c*sin(d*e) + b\n856 \n857         The resulting expression represents a literal replacement of the\n858         old arguments with the new arguments. This may not reflect the\n859         limiting behavior of the expression:\n860 \n861         >>> (x**3 - 3*x).subs({x: oo})\n862         nan\n863 \n864         >>> limit(x**3 - 3*x, x, oo)\n865         oo\n866 \n867         If the substitution will be followed by numerical\n868         evaluation, it is better to pass the substitution to\n869         evalf as\n870 \n871         >>> (1/x).evalf(subs={x: 3.0}, n=21)\n872         0.333333333333333333333\n873 \n874         rather than\n875 \n876         >>> (1/x).subs({x: 3.0}).evalf(21)\n877         0.333333333333333314830\n878 \n879         as the former will ensure that the desired level of precision is\n880         obtained.\n881 \n882         See Also\n883         ========\n884         replace: replacement capable of doing wildcard-like matching,\n885                  parsing of match, and conditional replacements\n886         xreplace: exact node replacement in expr tree; also capable of\n887                   using matching rules\n888         sympy.core.evalf.EvalfMixin.evalf: calculates the given formula to a desired level of precision\n889 \n890         \"\"\"\n891         from sympy.core.containers import Dict\n892         from sympy.utilities import default_sort_key\n893         from sympy import Dummy, Symbol\n894 \n895         unordered = False\n896         if len(args) == 1:\n897             sequence = args[0]\n898             if isinstance(sequence, set):\n899                 unordered = True\n900             elif isinstance(sequence, (Dict, Mapping)):\n901                 unordered = True\n902                 sequence = sequence.items()\n903             elif not iterable(sequence):\n904                 from sympy.utilities.misc import filldedent\n905                 raise ValueError(filldedent(\"\"\"\n906                    When a single argument is passed to subs\n907                    it should be a dictionary of old: new pairs or an iterable\n908                    of (old, new) tuples.\"\"\"))\n909         elif len(args) == 2:\n910             sequence = [args]\n911         else:\n912             raise ValueError(\"subs accepts either 1 or 2 arguments\")\n913 \n914         sequence = list(sequence)\n915         for i, s in enumerate(sequence):\n916             if isinstance(s[0], str):\n917                 # when old is a string we prefer Symbol\n918                 s = Symbol(s[0]), s[1]\n919             try:\n920                 s = [sympify(_, strict=not isinstance(_, str))\n921                      for _ in s]\n922             except SympifyError:\n923                 # if it can't be sympified, skip it\n924                 sequence[i] = None\n925                 continue\n926             # skip if there is no change\n927             sequence[i] = None if _aresame(*s) else tuple(s)\n928         sequence = list(filter(None, sequence))\n929 \n930         if unordered:\n931             sequence = dict(sequence)\n932             if not all(k.is_Atom for k in sequence):\n933                 d = {}\n934                 for o, n in sequence.items():\n935                     try:\n936                         ops = o.count_ops(), len(o.args)\n937                     except TypeError:\n938                         ops = (0, 0)\n939                     d.setdefault(ops, []).append((o, n))\n940                 newseq = []\n941                 for k in sorted(d.keys(), reverse=True):\n942                     newseq.extend(\n943                         sorted([v[0] for v in d[k]], key=default_sort_key))\n944                 sequence = [(k, sequence[k]) for k in newseq]\n945                 del newseq, d\n946             else:\n947                 sequence = sorted([(k, v) for (k, v) in sequence.items()],\n948                                   key=default_sort_key)\n949 \n950         if kwargs.pop('simultaneous', False):  # XXX should this be the default for dict subs?\n951             reps = {}\n952             rv = self\n953             kwargs['hack2'] = True\n954             m = Dummy('subs_m')\n955             for old, new in sequence:\n956                 com = new.is_commutative\n957                 if com is None:\n958                     com = True\n959                 d = Dummy('subs_d', commutative=com)\n960                 # using d*m so Subs will be used on dummy variables\n961                 # in things like Derivative(f(x, y), x) in which x\n962                 # is both free and bound\n963                 rv = rv._subs(old, d*m, **kwargs)\n964                 if not isinstance(rv, Basic):\n965                     break\n966                 reps[d] = new\n967             reps[m] = S.One  # get rid of m\n968             return rv.xreplace(reps)\n969         else:\n970             rv = self\n971             for old, new in sequence:\n972                 rv = rv._subs(old, new, **kwargs)\n973                 if not isinstance(rv, Basic):\n974                     break\n975             return rv\n",
        "intended_behavior": "This code should ensure that expressions like `exp(x)` and `cos(x)` substituted with `oo` evaluate to infinity or the appropriate mathematical limit without reverting to `AccumBounds` unless absolutely mathematically necessary. The method should distinguish between cases where a function grows without bound vs. oscillates as `x` approaches infinity."
    },
    {
        "rel_file_path": "sympy/calculus/util.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sympy__sympy/setup_sympy__sympy__1.6/sympy/calculus/util.py",
        "start": 1,
        "end": 1599,
        "class_name": null,
        "method_name": null,
        "code": "1 from sympy import Order, S, log, limit, lcm_list, Abs, im, re, Dummy\n2 from sympy.core import Add, Mul, Pow\n3 from sympy.core.basic import Basic\n4 from sympy.core.compatibility import iterable\n5 from sympy.core.expr import AtomicExpr, Expr\n6 from sympy.core.numbers import _sympifyit, oo\n7 from sympy.core.sympify import _sympify\n8 from sympy.functions.elementary.miscellaneous import Min, Max\n9 from sympy.logic.boolalg import And\n10 from sympy.polys.rationaltools import together\n11 from sympy.sets.sets import (Interval, Intersection, FiniteSet, Union,\n12                              Complement, EmptySet)\n13 from sympy.sets.fancysets import ImageSet\n14 from sympy.simplify.radsimp import denom\n15 from sympy.solvers.inequalities import solve_univariate_inequality\n16 from sympy.utilities import filldedent\n17 \n18 def continuous_domain(f, symbol, domain):\n19     \"\"\"\n20     Returns the intervals in the given domain for which the function\n21     is continuous.\n22     This method is limited by the ability to determine the various\n23     singularities and discontinuities of the given function.\n24 \n25     Parameters\n26     ==========\n27 \n28     f : Expr\n29         The concerned function.\n30     symbol : Symbol\n31         The variable for which the intervals are to be determined.\n32     domain : Interval\n33         The domain over which the continuity of the symbol has to be checked.\n34 \n35     Examples\n36     ========\n37 \n38     >>> from sympy import Symbol, S, tan, log, pi, sqrt\n39     >>> from sympy.sets import Interval\n40     >>> from sympy.calculus.util import continuous_domain\n41     >>> x = Symbol('x')\n42     >>> continuous_domain(1/x, x, S.Reals)\n43     Union(Interval.open(-oo, 0), Interval.open(0, oo))\n44     >>> continuous_domain(tan(x), x, Interval(0, pi))\n45     Union(Interval.Ropen(0, pi/2), Interval.Lopen(pi/2, pi))\n46     >>> continuous_domain(sqrt(x - 2), x, Interval(-5, 5))\n47     Interval(2, 5)\n48     >>> continuous_domain(log(2*x - 1), x, S.Reals)\n49     Interval.open(1/2, oo)\n50 \n51     Returns\n52     =======\n53 \n54     Interval\n55         Union of all intervals where the function is continuous.\n56 \n57     Raises\n58     ======\n59 \n60     NotImplementedError\n61         If the method to determine continuity of such a function\n62         has not yet been developed.\n63 \n64     \"\"\"\n65     from sympy.solvers.inequalities import solve_univariate_inequality\n66     from sympy.solvers.solveset import solveset, _has_rational_power\n67 \n68     if domain.is_subset(S.Reals):\n69         constrained_interval = domain\n70         for atom in f.atoms(Pow):\n71             predicate, denomin = _has_rational_power(atom, symbol)\n72             if predicate and denomin == 2:\n73                 constraint = solve_univariate_inequality(atom.base >= 0,\n74                                                          symbol).as_set()\n75                 constrained_interval = Intersection(constraint,\n76                                                     constrained_interval)\n77 \n78         for atom in f.atoms(log):\n79             constraint = solve_univariate_inequality(atom.args[0] > 0,\n80                                                      symbol).as_set()\n81             constrained_interval = Intersection(constraint,\n82                                                 constrained_interval)\n83 \n84         domain = constrained_interval\n85 \n86     try:\n87         if f.has(Abs):\n88             sings = solveset(1/f, symbol, domain) + \\\n89                 solveset(denom(together(f)), symbol, domain)\n90         else:\n91             for atom in f.atoms(Pow):\n92                 predicate, denomin = _has_rational_power(atom, symbol)\n93                 if predicate and denomin == 2:\n94                     sings = solveset(1/f, symbol, domain) +\\\n95                         solveset(denom(together(f)), symbol, domain)\n96                     break\n97             else:\n98                 sings = Intersection(solveset(1/f, symbol), domain) + \\\n99                     solveset(denom(together(f)), symbol, domain)\n100 \n101     except NotImplementedError:\n102         raise NotImplementedError(\"Methods for determining the continuous domains\"\n103                                   \" of this function have not been developed.\")\n104 \n105     return domain - sings\n106 \n107 \n108 def function_range(f, symbol, domain):\n109     \"\"\"\n110     Finds the range of a function in a given domain.\n111     This method is limited by the ability to determine the singularities and\n112     determine limits.\n113 \n114     Parameters\n115     ==========\n116 \n117     f : Expr\n118         The concerned function.\n119     symbol : Symbol\n120         The variable for which the range of function is to be determined.\n121     domain : Interval\n122         The domain under which the range of the function has to be found.\n123 \n124     Examples\n125     ========\n126 \n127     >>> from sympy import Symbol, S, exp, log, pi, sqrt, sin, tan\n128     >>> from sympy.sets import Interval\n129     >>> from sympy.calculus.util import function_range\n130     >>> x = Symbol('x')\n131     >>> function_range(sin(x), x, Interval(0, 2*pi))\n132     Interval(-1, 1)\n133     >>> function_range(tan(x), x, Interval(-pi/2, pi/2))\n134     Interval(-oo, oo)\n135     >>> function_range(1/x, x, S.Reals)\n136     Union(Interval.open(-oo, 0), Interval.open(0, oo))\n137     >>> function_range(exp(x), x, S.Reals)\n138     Interval.open(0, oo)\n139     >>> function_range(log(x), x, S.Reals)\n140     Interval(-oo, oo)\n141     >>> function_range(sqrt(x), x , Interval(-5, 9))\n142     Interval(0, 3)\n143 \n144     Returns\n145     =======\n146 \n147     Interval\n148         Union of all ranges for all intervals under domain where function is\n149         continuous.\n150 \n151     Raises\n152     ======\n153 \n154     NotImplementedError\n155         If any of the intervals, in the given domain, for which function\n156         is continuous are not finite or real,\n157         OR if the critical points of the function on the domain can't be found.\n158     \"\"\"\n159     from sympy.solvers.solveset import solveset\n160 \n161     if isinstance(domain, EmptySet):\n162         return S.EmptySet\n163 \n164     period = periodicity(f, symbol)\n165     if period == S.Zero:\n166         # the expression is constant wrt symbol\n167         return FiniteSet(f.expand())\n168 \n169     if period is not None:\n170         if isinstance(domain, Interval):\n171             if (domain.inf - domain.sup).is_infinite:\n172                 domain = Interval(0, period)\n173         elif isinstance(domain, Union):\n174             for sub_dom in domain.args:\n175                 if isinstance(sub_dom, Interval) and \\\n176                 ((sub_dom.inf - sub_dom.sup).is_infinite):\n177                     domain = Interval(0, period)\n178 \n179     intervals = continuous_domain(f, symbol, domain)\n180     range_int = S.EmptySet\n181     if isinstance(intervals,(Interval, FiniteSet)):\n182         interval_iter = (intervals,)\n183 \n184     elif isinstance(intervals, Union):\n185         interval_iter = intervals.args\n186 \n187     else:\n188             raise NotImplementedError(filldedent('''\n189                 Unable to find range for the given domain.\n190                 '''))\n191 \n192     for interval in interval_iter:\n193         if isinstance(interval, FiniteSet):\n194             for singleton in interval:\n195                 if singleton in domain:\n196                     range_int += FiniteSet(f.subs(symbol, singleton))\n197         elif isinstance(interval, Interval):\n198             vals = S.EmptySet\n199             critical_points = S.EmptySet\n200             critical_values = S.EmptySet\n201             bounds = ((interval.left_open, interval.inf, '+'),\n202                    (interval.right_open, interval.sup, '-'))\n203 \n204             for is_open, limit_point, direction in bounds:\n205                 if is_open:\n206                     critical_values += FiniteSet(limit(f, symbol, limit_point, direction))\n207                     vals += critical_values\n208 \n209                 else:\n210                     vals += FiniteSet(f.subs(symbol, limit_point))\n211 \n212             solution = solveset(f.diff(symbol), symbol, interval)\n213 \n214             if not iterable(solution):\n215                 raise NotImplementedError(\n216                         'Unable to find critical points for {}'.format(f))\n217             if isinstance(solution, ImageSet):\n218                 raise NotImplementedError(\n219                         'Infinite number of critical points for {}'.format(f))\n220 \n221             critical_points += solution\n222 \n223             for critical_point in critical_points:\n224                 vals += FiniteSet(f.subs(symbol, critical_point))\n225 \n226             left_open, right_open = False, False\n227 \n228             if critical_values is not S.EmptySet:\n229                 if critical_values.inf == vals.inf:\n230                     left_open = True\n231 \n232                 if critical_values.sup == vals.sup:\n233                     right_open = True\n234 \n235             range_int += Interval(vals.inf, vals.sup, left_open, right_open)\n236         else:\n237             raise NotImplementedError(filldedent('''\n238                 Unable to find range for the given domain.\n239                 '''))\n240 \n241     return range_int\n242 \n243 \n244 def not_empty_in(finset_intersection, *syms):\n245     \"\"\"\n246     Finds the domain of the functions in `finite_set` in which the\n247     `finite_set` is not-empty\n248 \n249     Parameters\n250     ==========\n251 \n252     finset_intersection : The unevaluated intersection of FiniteSet containing\n253                         real-valued functions with Union of Sets\n254     syms : Tuple of symbols\n255             Symbol for which domain is to be found\n256 \n257     Raises\n258     ======\n259 \n260     NotImplementedError\n261         The algorithms to find the non-emptiness of the given FiniteSet are\n262         not yet implemented.\n263     ValueError\n264         The input is not valid.\n265     RuntimeError\n266         It is a bug, please report it to the github issue tracker\n267         (https://github.com/sympy/sympy/issues).\n268 \n269     Examples\n270     ========\n271 \n272     >>> from sympy import FiniteSet, Interval, not_empty_in, oo\n273     >>> from sympy.abc import x\n274     >>> not_empty_in(FiniteSet(x/2).intersect(Interval(0, 1)), x)\n275     Interval(0, 2)\n276     >>> not_empty_in(FiniteSet(x, x**2).intersect(Interval(1, 2)), x)\n277     Union(Interval(1, 2), Interval(-sqrt(2), -1))\n278     >>> not_empty_in(FiniteSet(x**2/(x + 2)).intersect(Interval(1, oo)), x)\n279     Union(Interval.Lopen(-2, -1), Interval(2, oo))\n280     \"\"\"\n281 \n282     # TODO: handle piecewise defined functions\n283     # TODO: handle transcendental functions\n284     # TODO: handle multivariate functions\n285     if len(syms) == 0:\n286         raise ValueError(\"One or more symbols must be given in syms.\")\n287 \n288     if finset_intersection is S.EmptySet:\n289         return S.EmptySet\n290 \n291     if isinstance(finset_intersection, Union):\n292         elm_in_sets = finset_intersection.args[0]\n293         return Union(not_empty_in(finset_intersection.args[1], *syms),\n294                      elm_in_sets)\n295 \n296     if isinstance(finset_intersection, FiniteSet):\n297         finite_set = finset_intersection\n298         _sets = S.Reals\n299     else:\n300         finite_set = finset_intersection.args[1]\n301         _sets = finset_intersection.args[0]\n302 \n303     if not isinstance(finite_set, FiniteSet):\n304         raise ValueError('A FiniteSet must be given, not %s: %s' %\n305                          (type(finite_set), finite_set))\n306 \n307     if len(syms) == 1:\n308         symb = syms[0]\n309     else:\n310         raise NotImplementedError('more than one variables %s not handled' %\n311                                   (syms,))\n312 \n313     def elm_domain(expr, intrvl):\n314         \"\"\" Finds the domain of an expression in any given interval \"\"\"\n315         from sympy.solvers.solveset import solveset\n316 \n317         _start = intrvl.start\n318         _end = intrvl.end\n319         _singularities = solveset(expr.as_numer_denom()[1], symb,\n320                                   domain=S.Reals)\n321 \n322         if intrvl.right_open:\n323             if _end is S.Infinity:\n324                 _domain1 = S.Reals\n325             else:\n326                 _domain1 = solveset(expr < _end, symb, domain=S.Reals)\n327         else:\n328             _domain1 = solveset(expr <= _end, symb, domain=S.Reals)\n329 \n330         if intrvl.left_open:\n331             if _start is S.NegativeInfinity:\n332                 _domain2 = S.Reals\n333             else:\n334                 _domain2 = solveset(expr > _start, symb, domain=S.Reals)\n335         else:\n336             _domain2 = solveset(expr >= _start, symb, domain=S.Reals)\n337 \n338         # domain in the interval\n339         expr_with_sing = Intersection(_domain1, _domain2)\n340         expr_domain = Complement(expr_with_sing, _singularities)\n341         return expr_domain\n342 \n343     if isinstance(_sets, Interval):\n344         return Union(*[elm_domain(element, _sets) for element in finite_set])\n345 \n346     if isinstance(_sets, Union):\n347         _domain = S.EmptySet\n348         for intrvl in _sets.args:\n349             _domain_element = Union(*[elm_domain(element, intrvl)\n350                                       for element in finite_set])\n351             _domain = Union(_domain, _domain_element)\n352         return _domain\n353 \n354 \n355 def periodicity(f, symbol, check=False):\n356     \"\"\"\n357     Tests the given function for periodicity in the given symbol.\n358 \n359     Parameters\n360     ==========\n361 \n362     f : Expr.\n363         The concerned function.\n364     symbol : Symbol\n365         The variable for which the period is to be determined.\n366     check : Boolean, optional\n367         The flag to verify whether the value being returned is a period or not.\n368 \n369     Returns\n370     =======\n371 \n372     period\n373         The period of the function is returned.\n374         `None` is returned when the function is aperiodic or has a complex period.\n375         The value of `0` is returned as the period of a constant function.\n376 \n377     Raises\n378     ======\n379 \n380     NotImplementedError\n381         The value of the period computed cannot be verified.\n382 \n383 \n384     Notes\n385     =====\n386 \n387     Currently, we do not support functions with a complex period.\n388     The period of functions having complex periodic values such\n389     as `exp`, `sinh` is evaluated to `None`.\n390 \n391     The value returned might not be the \"fundamental\" period of the given\n392     function i.e. it may not be the smallest periodic value of the function.\n393 \n394     The verification of the period through the `check` flag is not reliable\n395     due to internal simplification of the given expression. Hence, it is set\n396     to `False` by default.\n397 \n398     Examples\n399     ========\n400     >>> from sympy import Symbol, sin, cos, tan, exp\n401     >>> from sympy.calculus.util import periodicity\n402     >>> x = Symbol('x')\n403     >>> f = sin(x) + sin(2*x) + sin(3*x)\n404     >>> periodicity(f, x)\n405     2*pi\n406     >>> periodicity(sin(x)*cos(x), x)\n407     pi\n408     >>> periodicity(exp(tan(2*x) - 1), x)\n409     pi/2\n410     >>> periodicity(sin(4*x)**cos(2*x), x)\n411     pi\n412     >>> periodicity(exp(x), x)\n413     \"\"\"\n414     from sympy.core.mod import Mod\n415     from sympy.core.relational import Relational\n416     from sympy.functions.elementary.exponential import exp\n417     from sympy.functions.elementary.complexes import Abs\n418     from sympy.functions.elementary.trigonometric import (\n419         TrigonometricFunction, sin, cos, csc, sec)\n420     from sympy.simplify.simplify import simplify\n421     from sympy.solvers.decompogen import decompogen\n422     from sympy.polys.polytools import degree\n423 \n424     temp = Dummy('x', real=True)\n425     f = f.subs(symbol, temp)\n426     symbol = temp\n427 \n428     def _check(orig_f, period):\n429         '''Return the checked period or raise an error.'''\n430         new_f = orig_f.subs(symbol, symbol + period)\n431         if new_f.equals(orig_f):\n432             return period\n433         else:\n434             raise NotImplementedError(filldedent('''\n435                 The period of the given function cannot be verified.\n436                 When `%s` was replaced with `%s + %s` in `%s`, the result\n437                 was `%s` which was not recognized as being the same as\n438                 the original function.\n439                 So either the period was wrong or the two forms were\n440                 not recognized as being equal.\n441                 Set check=False to obtain the value.''' %\n442                 (symbol, symbol, period, orig_f, new_f)))\n443 \n444     orig_f = f\n445     period = None\n446 \n447     if isinstance(f, Relational):\n448         f = f.lhs - f.rhs\n449 \n450     f = simplify(f)\n451 \n452     if symbol not in f.free_symbols:\n453         return S.Zero\n454 \n455     if isinstance(f, TrigonometricFunction):\n456         try:\n457             period = f.period(symbol)\n458         except NotImplementedError:\n459             pass\n460 \n461     if isinstance(f, Abs):\n462         arg = f.args[0]\n463         if isinstance(arg, (sec, csc, cos)):\n464             # all but tan and cot might have a\n465             # a period that is half as large\n466             # so recast as sin\n467             arg = sin(arg.args[0])\n468         period = periodicity(arg, symbol)\n469         if period is not None and isinstance(arg, sin):\n470             # the argument of Abs was a trigonometric other than\n471             # cot or tan; test to see if the half-period\n472             # is valid. Abs(arg) has behaviour equivalent to\n473             # orig_f, so use that for test:\n474             orig_f = Abs(arg)\n475             try:\n476                 return _check(orig_f, period/2)\n477             except NotImplementedError as err:\n478                 if check:\n479                     raise NotImplementedError(err)\n480             # else let new orig_f and period be\n481             # checked below\n482 \n483     if isinstance(f, exp):\n484         if im(f) != 0:\n485             period_real = periodicity(re(f), symbol)\n486             period_imag = periodicity(im(f), symbol)\n487             if period_real is not None and period_imag is not None:\n488                 period = lcim([period_real, period_imag])\n489 \n490     if f.is_Pow:\n491         base, expo = f.args\n492         base_has_sym = base.has(symbol)\n493         expo_has_sym = expo.has(symbol)\n494 \n495         if base_has_sym and not expo_has_sym:\n496             period = periodicity(base, symbol)\n497 \n498         elif expo_has_sym and not base_has_sym:\n499             period = periodicity(expo, symbol)\n500 \n501         else:\n502             period = _periodicity(f.args, symbol)\n503 \n504     elif f.is_Mul:\n505         coeff, g = f.as_independent(symbol, as_Add=False)\n506         if isinstance(g, TrigonometricFunction) or coeff is not S.One:\n507             period = periodicity(g, symbol)\n508 \n509         else:\n510             period = _periodicity(g.args, symbol)\n511 \n512     elif f.is_Add:\n513         k, g = f.as_independent(symbol)\n514         if k is not S.Zero:\n515             return periodicity(g, symbol)\n516 \n517         period = _periodicity(g.args, symbol)\n518 \n519     elif isinstance(f, Mod):\n520         a, n = f.args\n521 \n522         if a == symbol:\n523             period = n\n524         elif isinstance(a, TrigonometricFunction):\n525             period = periodicity(a, symbol)\n526         #check if 'f' is linear in 'symbol'\n527         elif (a.is_polynomial(symbol) and degree(a, symbol) == 1 and\n528             symbol not in n.free_symbols):\n529                 period = Abs(n / a.diff(symbol))\n530 \n531     elif period is None:\n532         from sympy.solvers.decompogen import compogen\n533         g_s = decompogen(f, symbol)\n534         num_of_gs = len(g_s)\n535         if num_of_gs > 1:\n536             for index, g in enumerate(reversed(g_s)):\n537                 start_index = num_of_gs - 1 - index\n538                 g = compogen(g_s[start_index:], symbol)\n539                 if g != orig_f and g != f: # Fix for issue 12620\n540                     period = periodicity(g, symbol)\n541                     if period is not None:\n542                         break\n543 \n544     if period is not None:\n545         if check:\n546             return _check(orig_f, period)\n547         return period\n548 \n549     return None\n550 \n551 \n552 def _periodicity(args, symbol):\n553     \"\"\"\n554     Helper for `periodicity` to find the period of a list of simpler\n555     functions.\n556     It uses the `lcim` method to find the least common period of\n557     all the functions.\n558 \n559     Parameters\n560     ==========\n561 \n562     args : Tuple of Symbol\n563         All the symbols present in a function.\n564 \n565     symbol : Symbol\n566         The symbol over which the function is to be evaluated.\n567 \n568     Returns\n569     =======\n570 \n571     period\n572         The least common period of the function for all the symbols\n573         of the function.\n574         None if for at least one of the symbols the function is aperiodic\n575 \n576     \"\"\"\n577     periods = []\n578     for f in args:\n579         period = periodicity(f, symbol)\n580         if period is None:\n581             return None\n582 \n583         if period is not S.Zero:\n584             periods.append(period)\n585 \n586     if len(periods) > 1:\n587         return lcim(periods)\n588 \n589     if periods:\n590         return periods[0]\n591 \n592 \n593 def lcim(numbers):\n594     \"\"\"Returns the least common integral multiple of a list of numbers.\n595 \n596     The numbers can be rational or irrational or a mixture of both.\n597     `None` is returned for incommensurable numbers.\n598 \n599     Parameters\n600     ==========\n601 \n602     numbers : list\n603         Numbers (rational and/or irrational) for which lcim is to be found.\n604 \n605     Returns\n606     =======\n607 \n608     number\n609         lcim if it exists, otherwise `None` for incommensurable numbers.\n610 \n611     Examples\n612     ========\n613 \n614     >>> from sympy import S, pi\n615     >>> from sympy.calculus.util import lcim\n616     >>> lcim([S(1)/2, S(3)/4, S(5)/6])\n617     15/2\n618     >>> lcim([2*pi, 3*pi, pi, pi/2])\n619     6*pi\n620     >>> lcim([S(1), 2*pi])\n621     \"\"\"\n622     result = None\n623     if all(num.is_irrational for num in numbers):\n624         factorized_nums = list(map(lambda num: num.factor(), numbers))\n625         factors_num = list(\n626             map(lambda num: num.as_coeff_Mul(),\n627                 factorized_nums))\n628         term = factors_num[0][1]\n629         if all(factor == term for coeff, factor in factors_num):\n630             common_term = term\n631             coeffs = [coeff for coeff, factor in factors_num]\n632             result = lcm_list(coeffs) * common_term\n633 \n634     elif all(num.is_rational for num in numbers):\n635         result = lcm_list(numbers)\n636 \n637     else:\n638         pass\n639 \n640     return result\n641 \n642 def is_convex(f, *syms, **kwargs):\n643     \"\"\"Determines the  convexity of the function passed in the argument.\n644 \n645     Parameters\n646     ==========\n647 \n648     f : Expr\n649         The concerned function.\n650     syms : Tuple of symbols\n651         The variables with respect to which the convexity is to be determined.\n652     domain : Interval, optional\n653         The domain over which the convexity of the function has to be checked.\n654         If unspecified, S.Reals will be the default domain.\n655 \n656     Returns\n657     =======\n658 \n659     Boolean\n660         The method returns `True` if the function is convex otherwise it\n661         returns `False`.\n662 \n663     Raises\n664     ======\n665 \n666     NotImplementedError\n667         The check for the convexity of multivariate functions is not implemented yet.\n668 \n669     Notes\n670     =====\n671 \n672     To determine concavity of a function pass `-f` as the concerned function.\n673     To determine logarithmic convexity of a function pass log(f) as\n674     concerned function.\n675     To determine logartihmic concavity of a function pass -log(f) as\n676     concerned function.\n677 \n678     Currently, convexity check of multivariate functions is not handled.\n679 \n680     Examples\n681     ========\n682 \n683     >>> from sympy import symbols, exp, oo, Interval\n684     >>> from sympy.calculus.util import is_convex\n685     >>> x = symbols('x')\n686     >>> is_convex(exp(x), x)\n687     True\n688     >>> is_convex(x**3, x, domain = Interval(-1, oo))\n689     False\n690 \n691     References\n692     ==========\n693 \n694     .. [1] https://en.wikipedia.org/wiki/Convex_function\n695     .. [2] http://www.ifp.illinois.edu/~angelia/L3_convfunc.pdf\n696     .. [3] https://en.wikipedia.org/wiki/Logarithmically_convex_function\n697     .. [4] https://en.wikipedia.org/wiki/Logarithmically_concave_function\n698     .. [5] https://en.wikipedia.org/wiki/Concave_function\n699 \n700     \"\"\"\n701 \n702     if len(syms) > 1:\n703         raise NotImplementedError(\n704             \"The check for the convexity of multivariate functions is not implemented yet.\")\n705 \n706     f = _sympify(f)\n707     domain = kwargs.get('domain', S.Reals)\n708     var = syms[0]\n709     condition = f.diff(var, 2) < 0\n710     if solve_univariate_inequality(condition, var, False, domain):\n711         return False\n712     return True\n713 \n714 \n715 def stationary_points(f, symbol, domain=S.Reals):\n716     \"\"\"\n717     Returns the stationary points of a function (where derivative of the\n718     function is 0) in the given domain.\n719 \n720     Parameters\n721     ==========\n722 \n723     f : Expr\n724         The concerned function.\n725     symbol : Symbol\n726         The variable for which the stationary points are to be determined.\n727     domain : Interval\n728         The domain over which the stationary points have to be checked.\n729         If unspecified, S.Reals will be the default domain.\n730 \n731     Examples\n732     ========\n733 \n734     >>> from sympy import Symbol, S, sin, log, pi, pprint, stationary_points\n735     >>> from sympy.sets import Interval\n736     >>> x = Symbol('x')\n737 \n738     >>> stationary_points(1/x, x, S.Reals)\n739     EmptySet\n740 \n741     >>> pprint(stationary_points(sin(x), x), use_unicode=False)\n742               pi                              3*pi\n743     {2*n*pi + -- | n in Integers} U {2*n*pi + ---- | n in Integers}\n744               2                                2\n745 \n746     >>> stationary_points(sin(x),x, Interval(0, 4*pi))\n747     FiniteSet(pi/2, 3*pi/2, 5*pi/2, 7*pi/2)\n748 \n749     \"\"\"\n750     from sympy import solveset, diff\n751 \n752     if isinstance(domain, EmptySet):\n753         return S.EmptySet\n754 \n755     domain = continuous_domain(f, symbol, domain)\n756     set = solveset(diff(f, symbol), symbol, domain)\n757 \n758     return set\n759 \n760 \n761 def maximum(f, symbol, domain=S.Reals):\n762     \"\"\"\n763     Returns the maximum value of a function in the given domain.\n764 \n765     Parameters\n766     ==========\n767 \n768     f : Expr\n769         The concerned function.\n770     symbol : Symbol\n771         The variable for maximum value needs to be determined.\n772     domain : Interval\n773         The domain over which the maximum have to be checked.\n774         If unspecified, then Global maximum is returned.\n775 \n776     Examples\n777     ========\n778 \n779     >>> from sympy import Symbol, S, sin, cos, pi, maximum\n780     >>> from sympy.sets import Interval\n781     >>> x = Symbol('x')\n782 \n783     >>> f = -x**2 + 2*x + 5\n784     >>> maximum(f, x, S.Reals)\n785     6\n786 \n787     >>> maximum(sin(x), x, Interval(-pi, pi/4))\n788     sqrt(2)/2\n789 \n790     >>> maximum(sin(x)*cos(x), x)\n791     1/2\n792 \n793     \"\"\"\n794     from sympy import Symbol\n795 \n796     if isinstance(symbol, Symbol):\n797         if isinstance(domain, EmptySet):\n798             raise ValueError(\"Maximum value not defined for empty domain.\")\n799 \n800         return function_range(f, symbol, domain).sup\n801     else:\n802         raise ValueError(\"%s is not a valid symbol.\" % symbol)\n803 \n804 \n805 def minimum(f, symbol, domain=S.Reals):\n806     \"\"\"\n807     Returns the minimum value of a function in the given domain.\n808 \n809     Parameters\n810     ==========\n811 \n812     f : Expr\n813         The concerned function.\n814     symbol : Symbol\n815         The variable for minimum value needs to be determined.\n816     domain : Interval\n817         The domain over which the minimum have to be checked.\n818         If unspecified, then Global minimum is returned.\n819 \n820     Examples\n821     ========\n822 \n823     >>> from sympy import Symbol, S, sin, cos, minimum\n824     >>> from sympy.sets import Interval\n825     >>> x = Symbol('x')\n826 \n827     >>> f = x**2 + 2*x + 5\n828     >>> minimum(f, x, S.Reals)\n829     4\n830 \n831     >>> minimum(sin(x), x, Interval(2, 3))\n832     sin(3)\n833 \n834     >>> minimum(sin(x)*cos(x), x)\n835     -1/2\n836 \n837     \"\"\"\n838     from sympy import Symbol\n839 \n840     if isinstance(symbol, Symbol):\n841         if isinstance(domain, EmptySet):\n842             raise ValueError(\"Minimum value not defined for empty domain.\")\n843 \n844         return function_range(f, symbol, domain).inf\n845     else:\n846         raise ValueError(\"%s is not a valid symbol.\" % symbol)\n847 \n848 \n849 class AccumulationBounds(AtomicExpr):\n850     r\"\"\"\n851     # Note AccumulationBounds has an alias: AccumBounds\n852 \n853     AccumulationBounds represent an interval `[a, b]`, which is always closed\n854     at the ends. Here `a` and `b` can be any value from extended real numbers.\n855 \n856     The intended meaning of AccummulationBounds is to give an approximate\n857     location of the accumulation points of a real function at a limit point.\n858 \n859     Let `a` and `b` be reals such that a <= b.\n860 \n861     `\\left\\langle a, b\\right\\rangle = \\{x \\in \\mathbb{R} \\mid a \\le x \\le b\\}`\n862 \n863     `\\left\\langle -\\infty, b\\right\\rangle = \\{x \\in \\mathbb{R} \\mid x \\le b\\} \\cup \\{-\\infty, \\infty\\}`\n864 \n865     `\\left\\langle a, \\infty \\right\\rangle = \\{x \\in \\mathbb{R} \\mid a \\le x\\} \\cup \\{-\\infty, \\infty\\}`\n866 \n867     `\\left\\langle -\\infty, \\infty \\right\\rangle = \\mathbb{R} \\cup \\{-\\infty, \\infty\\}`\n868 \n869     `oo` and `-oo` are added to the second and third definition respectively,\n870     since if either `-oo` or `oo` is an argument, then the other one should\n871     be included (though not as an end point). This is forced, since we have,\n872     for example, `1/AccumBounds(0, 1) = AccumBounds(1, oo)`, and the limit at\n873     `0` is not one-sided. As x tends to `0-`, then `1/x -> -oo`, so `-oo`\n874     should be interpreted as belonging to `AccumBounds(1, oo)` though it need\n875     not appear explicitly.\n876 \n877     In many cases it suffices to know that the limit set is bounded.\n878     However, in some other cases more exact information could be useful.\n879     For example, all accumulation values of cos(x) + 1 are non-negative.\n880     (AccumBounds(-1, 1) + 1 = AccumBounds(0, 2))\n881 \n882     A AccumulationBounds object is defined to be real AccumulationBounds,\n883     if its end points are finite reals.\n884 \n885     Let `X`, `Y` be real AccumulationBounds, then their sum, difference,\n886     product are defined to be the following sets:\n887 \n888     `X + Y = \\{ x+y \\mid x \\in X \\cap y \\in Y\\}`\n889 \n890     `X - Y = \\{ x-y \\mid x \\in X \\cap y \\in Y\\}`\n891 \n892     `X * Y = \\{ x*y \\mid x \\in X \\cap y \\in Y\\}`\n893 \n894     There is, however, no consensus on Interval division.\n895 \n896     `X / Y = \\{ z \\mid \\exists x \\in X, y \\in Y \\mid y \\neq 0, z = x/y\\}`\n897 \n898     Note: According to this definition the quotient of two AccumulationBounds\n899     may not be a AccumulationBounds object but rather a union of\n900     AccumulationBounds.\n901 \n902     Note\n903     ====\n904 \n905     The main focus in the interval arithmetic is on the simplest way to\n906     calculate upper and lower endpoints for the range of values of a\n907     function in one or more variables. These barriers are not necessarily\n908     the supremum or infimum, since the precise calculation of those values\n909     can be difficult or impossible.\n910 \n911     Examples\n912     ========\n913 \n914     >>> from sympy import AccumBounds, sin, exp, log, pi, E, S, oo\n915     >>> from sympy.abc import x\n916 \n917     >>> AccumBounds(0, 1) + AccumBounds(1, 2)\n918     AccumBounds(1, 3)\n919 \n920     >>> AccumBounds(0, 1) - AccumBounds(0, 2)\n921     AccumBounds(-2, 1)\n922 \n923     >>> AccumBounds(-2, 3)*AccumBounds(-1, 1)\n924     AccumBounds(-3, 3)\n925 \n926     >>> AccumBounds(1, 2)*AccumBounds(3, 5)\n927     AccumBounds(3, 10)\n928 \n929     The exponentiation of AccumulationBounds is defined\n930     as follows:\n931 \n932     If 0 does not belong to `X` or `n > 0` then\n933 \n934     `X^n = \\{ x^n \\mid x \\in X\\}`\n935 \n936     otherwise\n937 \n938     `X^n = \\{ x^n \\mid x \\neq 0, x \\in X\\} \\cup \\{-\\infty, \\infty\\}`\n939 \n940     Here for fractional `n`, the part of `X` resulting in a complex\n941     AccumulationBounds object is neglected.\n942 \n943     >>> AccumBounds(-1, 4)**(S(1)/2)\n944     AccumBounds(0, 2)\n945 \n946     >>> AccumBounds(1, 2)**2\n947     AccumBounds(1, 4)\n948 \n949     >>> AccumBounds(-1, oo)**(-1)\n950     AccumBounds(-oo, oo)\n951 \n952     Note: `<a, b>^2` is not same as `<a, b>*<a, b>`\n953 \n954     >>> AccumBounds(-1, 1)**2\n955     AccumBounds(0, 1)\n956 \n957     >>> AccumBounds(1, 3) < 4\n958     True\n959 \n960     >>> AccumBounds(1, 3) < -1\n961     False\n962 \n963     Some elementary functions can also take AccumulationBounds as input.\n964     A function `f` evaluated for some real AccumulationBounds `<a, b>`\n965     is defined as `f(\\left\\langle a, b\\right\\rangle) = \\{ f(x) \\mid a \\le x \\le b \\}`\n966 \n967     >>> sin(AccumBounds(pi/6, pi/3))\n968     AccumBounds(1/2, sqrt(3)/2)\n969 \n970     >>> exp(AccumBounds(0, 1))\n971     AccumBounds(1, E)\n972 \n973     >>> log(AccumBounds(1, E))\n974     AccumBounds(0, 1)\n975 \n976     Some symbol in an expression can be substituted for a AccumulationBounds\n977     object. But it doesn't necessarily evaluate the AccumulationBounds for\n978     that expression.\n979 \n980     Same expression can be evaluated to different values depending upon\n981     the form it is used for substitution. For example:\n982 \n983     >>> (x**2 + 2*x + 1).subs(x, AccumBounds(-1, 1))\n984     AccumBounds(-1, 4)\n985 \n986     >>> ((x + 1)**2).subs(x, AccumBounds(-1, 1))\n987     AccumBounds(0, 4)\n988 \n989     References\n990     ==========\n991 \n992     .. [1] https://en.wikipedia.org/wiki/Interval_arithmetic\n993 \n994     .. [2] http://fab.cba.mit.edu/classes/S62.12/docs/Hickey_interval.pdf\n995 \n996     Notes\n997     =====\n998 \n999     Do not use ``AccumulationBounds`` for floating point interval arithmetic\n1000     calculations, use ``mpmath.iv`` instead.\n1001     \"\"\"\n1002 \n1003     is_extended_real = True\n1004 \n1005     def __new__(cls, min, max):\n1006 \n1007         min = _sympify(min)\n1008         max = _sympify(max)\n1009 \n1010         # Only allow real intervals (use symbols with 'is_extended_real=True').\n1011         if not min.is_extended_real or not max.is_extended_real:\n1012             raise ValueError(\"Only real AccumulationBounds are supported\")\n1013 \n1014         # Make sure that the created AccumBounds object will be valid.\n1015         if max.is_comparable and min.is_comparable:\n1016             if max < min:\n1017                 raise ValueError(\n1018                     \"Lower limit should be smaller than upper limit\")\n1019 \n1020         if max == min:\n1021             return max\n1022 \n1023         return Basic.__new__(cls, min, max)\n1024 \n1025     # setting the operation priority\n1026     _op_priority = 11.0\n1027 \n1028     def _eval_is_real(self):\n1029         if self.min.is_real and self.max.is_real:\n1030             return True\n1031 \n1032     @property\n1033     def min(self):\n1034         \"\"\"\n1035         Returns the minimum possible value attained by AccumulationBounds\n1036         object.\n1037 \n1038         Examples\n1039         ========\n1040 \n1041         >>> from sympy import AccumBounds\n1042         >>> AccumBounds(1, 3).min\n1043         1\n1044 \n1045         \"\"\"\n1046         return self.args[0]\n1047 \n1048     @property\n1049     def max(self):\n1050         \"\"\"\n1051         Returns the maximum possible value attained by AccumulationBounds\n1052         object.\n1053 \n1054         Examples\n1055         ========\n1056 \n1057         >>> from sympy import AccumBounds\n1058         >>> AccumBounds(1, 3).max\n1059         3\n1060 \n1061         \"\"\"\n1062         return self.args[1]\n1063 \n1064     @property\n1065     def delta(self):\n1066         \"\"\"\n1067         Returns the difference of maximum possible value attained by\n1068         AccumulationBounds object and minimum possible value attained\n1069         by AccumulationBounds object.\n1070 \n1071         Examples\n1072         ========\n1073 \n1074         >>> from sympy import AccumBounds\n1075         >>> AccumBounds(1, 3).delta\n1076         2\n1077 \n1078         \"\"\"\n1079         return self.max - self.min\n1080 \n1081     @property\n1082     def mid(self):\n1083         \"\"\"\n1084         Returns the mean of maximum possible value attained by\n1085         AccumulationBounds object and minimum possible value\n1086         attained by AccumulationBounds object.\n1087 \n1088         Examples\n1089         ========\n1090 \n1091         >>> from sympy import AccumBounds\n1092         >>> AccumBounds(1, 3).mid\n1093         2\n1094 \n1095         \"\"\"\n1096         return (self.min + self.max) / 2\n1097 \n1098     @_sympifyit('other', NotImplemented)\n1099     def _eval_power(self, other):\n1100         return self.__pow__(other)\n1101 \n1102     @_sympifyit('other', NotImplemented)\n1103     def __add__(self, other):\n1104         if isinstance(other, Expr):\n1105             if isinstance(other, AccumBounds):\n1106                 return AccumBounds(\n1107                     Add(self.min, other.min),\n1108                     Add(self.max, other.max))\n1109             if other is S.Infinity and self.min is S.NegativeInfinity or \\\n1110                     other is S.NegativeInfinity and self.max is S.Infinity:\n1111                 return AccumBounds(-oo, oo)\n1112             elif other.is_extended_real:\n1113                 return AccumBounds(Add(self.min, other), Add(self.max, other))\n1114             return Add(self, other, evaluate=False)\n1115         return NotImplemented\n1116 \n1117     __radd__ = __add__\n1118 \n1119     def __neg__(self):\n1120         return AccumBounds(-self.max, -self.min)\n1121 \n1122     @_sympifyit('other', NotImplemented)\n1123     def __sub__(self, other):\n1124         if isinstance(other, Expr):\n1125             if isinstance(other, AccumBounds):\n1126                 return AccumBounds(\n1127                     Add(self.min, -other.max),\n1128                     Add(self.max, -other.min))\n1129             if other is S.NegativeInfinity and self.min is S.NegativeInfinity or \\\n1130                     other is S.Infinity and self.max is S.Infinity:\n1131                 return AccumBounds(-oo, oo)\n1132             elif other.is_extended_real:\n1133                 return AccumBounds(\n1134                     Add(self.min, -other),\n1135                     Add(self.max, -other))\n1136             return Add(self, -other, evaluate=False)\n1137         return NotImplemented\n1138 \n1139     @_sympifyit('other', NotImplemented)\n1140     def __rsub__(self, other):\n1141         return self.__neg__() + other\n1142 \n1143     @_sympifyit('other', NotImplemented)\n1144     def __mul__(self, other):\n1145         if isinstance(other, Expr):\n1146             if isinstance(other, AccumBounds):\n1147                 return AccumBounds(Min(Mul(self.min, other.min),\n1148                                        Mul(self.min, other.max),\n1149                                        Mul(self.max, other.min),\n1150                                        Mul(self.max, other.max)),\n1151                                    Max(Mul(self.min, other.min),\n1152                                        Mul(self.min, other.max),\n1153                                        Mul(self.max, other.min),\n1154                                        Mul(self.max, other.max)))\n1155             if other is S.Infinity:\n1156                 if self.min.is_zero:\n1157                     return AccumBounds(0, oo)\n1158                 if self.max.is_zero:\n1159                     return AccumBounds(-oo, 0)\n1160             if other is S.NegativeInfinity:\n1161                 if self.min.is_zero:\n1162                     return AccumBounds(-oo, 0)\n1163                 if self.max.is_zero:\n1164                     return AccumBounds(0, oo)\n1165             if other.is_extended_real:\n1166                 if other.is_zero:\n1167                     if self == AccumBounds(-oo, oo):\n1168                         return AccumBounds(-oo, oo)\n1169                     if self.max is S.Infinity:\n1170                         return AccumBounds(0, oo)\n1171                     if self.min is S.NegativeInfinity:\n1172                         return AccumBounds(-oo, 0)\n1173                     return S.Zero\n1174                 if other.is_extended_positive:\n1175                     return AccumBounds(\n1176                         Mul(self.min, other),\n1177                         Mul(self.max, other))\n1178                 elif other.is_extended_negative:\n1179                     return AccumBounds(\n1180                         Mul(self.max, other),\n1181                         Mul(self.min, other))\n1182             if isinstance(other, Order):\n1183                 return other\n1184             return Mul(self, other, evaluate=False)\n1185         return NotImplemented\n1186 \n1187     __rmul__ = __mul__\n1188 \n1189     @_sympifyit('other', NotImplemented)\n1190     def __div__(self, other):\n1191         if isinstance(other, Expr):\n1192             if isinstance(other, AccumBounds):\n1193                 if S.Zero not in other:\n1194                     return self * AccumBounds(1/other.max, 1/other.min)\n1195 \n1196                 if S.Zero in self and S.Zero in other:\n1197                     if self.min.is_zero and other.min.is_zero:\n1198                         return AccumBounds(0, oo)\n1199                     if self.max.is_zero and other.min.is_zero:\n1200                         return AccumBounds(-oo, 0)\n1201                     return AccumBounds(-oo, oo)\n1202 \n1203                 if self.max.is_extended_negative:\n1204                     if other.min.is_extended_negative:\n1205                         if other.max.is_zero:\n1206                             return AccumBounds(self.max / other.min, oo)\n1207                         if other.max.is_extended_positive:\n1208                             # the actual answer is a Union of AccumBounds,\n1209                             # Union(AccumBounds(-oo, self.max/other.max),\n1210                             #       AccumBounds(self.max/other.min, oo))\n1211                             return AccumBounds(-oo, oo)\n1212 \n1213                     if other.min.is_zero and other.max.is_extended_positive:\n1214                         return AccumBounds(-oo, self.max / other.max)\n1215 \n1216                 if self.min.is_extended_positive:\n1217                     if other.min.is_extended_negative:\n1218                         if other.max.is_zero:\n1219                             return AccumBounds(-oo, self.min / other.min)\n1220                         if other.max.is_extended_positive:\n1221                             # the actual answer is a Union of AccumBounds,\n1222                             # Union(AccumBounds(-oo, self.min/other.min),\n1223                             #       AccumBounds(self.min/other.max, oo))\n1224                             return AccumBounds(-oo, oo)\n1225 \n1226                     if other.min.is_zero and other.max.is_extended_positive:\n1227                         return AccumBounds(self.min / other.max, oo)\n1228 \n1229             elif other.is_extended_real:\n1230                 if other is S.Infinity or other is S.NegativeInfinity:\n1231                     if self == AccumBounds(-oo, oo):\n1232                         return AccumBounds(-oo, oo)\n1233                     if self.max is S.Infinity:\n1234                         return AccumBounds(Min(0, other), Max(0, other))\n1235                     if self.min is S.NegativeInfinity:\n1236                         return AccumBounds(Min(0, -other), Max(0, -other))\n1237                 if other.is_extended_positive:\n1238                     return AccumBounds(self.min / other, self.max / other)\n1239                 elif other.is_extended_negative:\n1240                     return AccumBounds(self.max / other, self.min / other)\n1241             return Mul(self, 1 / other, evaluate=False)\n1242 \n1243         return NotImplemented\n1244 \n1245     __truediv__ = __div__\n1246 \n1247     @_sympifyit('other', NotImplemented)\n1248     def __rdiv__(self, other):\n1249         if isinstance(other, Expr):\n1250             if other.is_extended_real:\n1251                 if other.is_zero:\n1252                     return S.Zero\n1253                 if S.Zero in self:\n1254                     if self.min.is_zero:\n1255                         if other.is_extended_positive:\n1256                             return AccumBounds(Mul(other, 1 / self.max), oo)\n1257                         if other.is_extended_negative:\n1258                             return AccumBounds(-oo, Mul(other, 1 / self.max))\n1259                     if self.max.is_zero:\n1260                         if other.is_extended_positive:\n1261                             return AccumBounds(-oo, Mul(other, 1 / self.min))\n1262                         if other.is_extended_negative:\n1263                             return AccumBounds(Mul(other, 1 / self.min), oo)\n1264                     return AccumBounds(-oo, oo)\n1265                 else:\n1266                     return AccumBounds(Min(other / self.min, other / self.max),\n1267                                        Max(other / self.min, other / self.max))\n1268             return Mul(other, 1 / self, evaluate=False)\n1269         else:\n1270             return NotImplemented\n1271 \n1272     __rtruediv__ = __rdiv__\n1273 \n1274     @_sympifyit('other', NotImplemented)\n1275     def __pow__(self, other):\n1276         from sympy.functions.elementary.miscellaneous import real_root\n1277         if isinstance(other, Expr):\n1278             if other is S.Infinity:\n1279                 if self.min.is_extended_nonnegative:\n1280                     if self.max < 1:\n1281                         return S.Zero\n1282                     if self.min > 1:\n1283                         return S.Infinity\n1284                     return AccumBounds(0, oo)\n1285                 elif self.max.is_extended_negative:\n1286                     if self.min > -1:\n1287                         return S.Zero\n1288                     if self.max < -1:\n1289                         return FiniteSet(-oo, oo)\n1290                     return AccumBounds(-oo, oo)\n1291                 else:\n1292                     if self.min > -1:\n1293                         if self.max < 1:\n1294                             return S.Zero\n1295                         return AccumBounds(0, oo)\n1296                     return AccumBounds(-oo, oo)\n1297 \n1298             if other is S.NegativeInfinity:\n1299                 return (1 / self)**oo\n1300 \n1301             if other.is_extended_real and other.is_number:\n1302                 if other.is_zero:\n1303                     return S.One\n1304 \n1305                 if other.is_Integer:\n1306                     if self.min.is_extended_positive:\n1307                         return AccumBounds(\n1308                             Min(self.min ** other, self.max ** other),\n1309                             Max(self.min ** other, self.max ** other))\n1310                     elif self.max.is_extended_negative:\n1311                         return AccumBounds(\n1312                             Min(self.max ** other, self.min ** other),\n1313                             Max(self.max ** other, self.min ** other))\n1314 \n1315                     if other % 2 == 0:\n1316                         if other.is_extended_negative:\n1317                             if self.min.is_zero:\n1318                                 return AccumBounds(self.max**other, oo)\n1319                             if self.max.is_zero:\n1320                                 return AccumBounds(self.min**other, oo)\n1321                             return AccumBounds(0, oo)\n1322                         return AccumBounds(\n1323                             S.Zero, Max(self.min**other, self.max**other))\n1324                     else:\n1325                         if other.is_extended_negative:\n1326                             if self.min.is_zero:\n1327                                 return AccumBounds(self.max**other, oo)\n1328                             if self.max.is_zero:\n1329                                 return AccumBounds(-oo, self.min**other)\n1330                             return AccumBounds(-oo, oo)\n1331                         return AccumBounds(self.min**other, self.max**other)\n1332 \n1333                 num, den = other.as_numer_denom()\n1334                 if num == S.One:\n1335                     if den % 2 == 0:\n1336                         if S.Zero in self:\n1337                             if self.min.is_extended_negative:\n1338                                 return AccumBounds(0, real_root(self.max, den))\n1339                     return AccumBounds(real_root(self.min, den),\n1340                                        real_root(self.max, den))\n1341                 if den!=1:\n1342                     num_pow = self**num\n1343                     return num_pow**(1 / den)\n1344             return AccumBounds(-oo, oo)\n1345 \n1346         return NotImplemented\n1347 \n1348     def __abs__(self):\n1349         if self.max.is_extended_negative:\n1350             return self.__neg__()\n1351         elif self.min.is_extended_negative:\n1352             return AccumBounds(S.Zero, Max(abs(self.min), self.max))\n1353         else:\n1354             return self\n1355 \n1356     def __lt__(self, other):\n1357         \"\"\"\n1358         Returns True if range of values attained by `self` AccumulationBounds\n1359         object is less than the range of values attained by `other`, where\n1360         other may be any value of type AccumulationBounds object or extended\n1361         real number value, False if `other` satisfies the same property, else\n1362         an unevaluated Relational\n1363 \n1364         Examples\n1365         ========\n1366 \n1367         >>> from sympy import AccumBounds, oo\n1368         >>> AccumBounds(1, 3) < AccumBounds(4, oo)\n1369         True\n1370         >>> AccumBounds(1, 4) < AccumBounds(3, 4)\n1371         AccumBounds(1, 4) < AccumBounds(3, 4)\n1372         >>> AccumBounds(1, oo) < -1\n1373         False\n1374 \n1375         \"\"\"\n1376         other = _sympify(other)\n1377         if isinstance(other, AccumBounds):\n1378             if self.max < other.min:\n1379                 return True\n1380             if self.min >= other.max:\n1381                 return False\n1382         elif not other.is_extended_real:\n1383             raise TypeError(\n1384                 \"Invalid comparison of %s %s\" %\n1385                 (type(other), other))\n1386         elif other.is_comparable:\n1387             if self.max < other:\n1388                 return True\n1389             if self.min >= other:\n1390                 return False\n1391         return super(AccumulationBounds, self).__lt__(other)\n1392 \n1393     def __le__(self, other):\n1394         \"\"\"\n1395         Returns True if range of values attained by `self` AccumulationBounds\n1396         object is less than or equal to the range of values attained by\n1397         `other`, where other may be any value of type AccumulationBounds\n1398         object or extended real number value, False if `other`\n1399         satisfies the same property, else an unevaluated Relational.\n1400 \n1401         Examples\n1402         ========\n1403 \n1404         >>> from sympy import AccumBounds, oo\n1405         >>> AccumBounds(1, 3) <= AccumBounds(4, oo)\n1406         True\n1407         >>> AccumBounds(1, 4) <= AccumBounds(3, 4)\n1408         AccumBounds(1, 4) <= AccumBounds(3, 4)\n1409         >>> AccumBounds(1, 3) <= 0\n1410         False\n1411 \n1412         \"\"\"\n1413         other = _sympify(other)\n1414         if isinstance(other, AccumBounds):\n1415             if self.max <= other.min:\n1416                 return True\n1417             if self.min > other.max:\n1418                 return False\n1419         elif not other.is_extended_real:\n1420             raise TypeError(\n1421                 \"Invalid comparison of %s %s\" %\n1422                 (type(other), other))\n1423         elif other.is_comparable:\n1424             if self.max <= other:\n1425                 return True\n1426             if self.min > other:\n1427                 return False\n1428         return super(AccumulationBounds, self).__le__(other)\n1429 \n1430     def __gt__(self, other):\n1431         \"\"\"\n1432         Returns True if range of values attained by `self` AccumulationBounds\n1433         object is greater than the range of values attained by `other`,\n1434         where other may be any value of type AccumulationBounds object or\n1435         extended real number value, False if `other` satisfies\n1436         the same property, else an unevaluated Relational.\n1437 \n1438         Examples\n1439         ========\n1440 \n1441         >>> from sympy import AccumBounds, oo\n1442         >>> AccumBounds(1, 3) > AccumBounds(4, oo)\n1443         False\n1444         >>> AccumBounds(1, 4) > AccumBounds(3, 4)\n1445         AccumBounds(1, 4) > AccumBounds(3, 4)\n1446         >>> AccumBounds(1, oo) > -1\n1447         True\n1448 \n1449         \"\"\"\n1450         other = _sympify(other)\n1451         if isinstance(other, AccumBounds):\n1452             if self.min > other.max:\n1453                 return True\n1454             if self.max <= other.min:\n1455                 return False\n1456         elif not other.is_extended_real:\n1457             raise TypeError(\n1458                 \"Invalid comparison of %s %s\" %\n1459                 (type(other), other))\n1460         elif other.is_comparable:\n1461             if self.min > other:\n1462                 return True\n1463             if self.max <= other:\n1464                 return False\n1465         return super(AccumulationBounds, self).__gt__(other)\n1466 \n1467     def __ge__(self, other):\n1468         \"\"\"\n1469         Returns True if range of values attained by `self` AccumulationBounds\n1470         object is less that the range of values attained by `other`, where\n1471         other may be any value of type AccumulationBounds object or extended\n1472         real number value, False if `other` satisfies the same\n1473         property, else an unevaluated Relational.\n1474 \n1475         Examples\n1476         ========\n1477 \n1478         >>> from sympy import AccumBounds, oo\n1479         >>> AccumBounds(1, 3) >= AccumBounds(4, oo)\n1480         False\n1481         >>> AccumBounds(1, 4) >= AccumBounds(3, 4)\n1482         AccumBounds(1, 4) >= AccumBounds(3, 4)\n1483         >>> AccumBounds(1, oo) >= 1\n1484         True\n1485 \n1486         \"\"\"\n1487         other = _sympify(other)\n1488         if isinstance(other, AccumBounds):\n1489             if self.min >= other.max:\n1490                 return True\n1491             if self.max < other.min:\n1492                 return False\n1493         elif not other.is_extended_real:\n1494             raise TypeError(\n1495                 \"Invalid comparison of %s %s\" %\n1496                 (type(other), other))\n1497         elif other.is_comparable:\n1498             if self.min >= other:\n1499                 return True\n1500             if self.max < other:\n1501                 return False\n1502         return super(AccumulationBounds, self).__ge__(other)\n1503 \n1504     def __contains__(self, other):\n1505         \"\"\"\n1506         Returns True if other is contained in self, where other\n1507         belongs to extended real numbers, False if not contained,\n1508         otherwise TypeError is raised.\n1509 \n1510         Examples\n1511         ========\n1512 \n1513         >>> from sympy import AccumBounds, oo\n1514         >>> 1 in AccumBounds(-1, 3)\n1515         True\n1516 \n1517         -oo and oo go together as limits (in AccumulationBounds).\n1518 \n1519         >>> -oo in AccumBounds(1, oo)\n1520         True\n1521 \n1522         >>> oo in AccumBounds(-oo, 0)\n1523         True\n1524 \n1525         \"\"\"\n1526         other = _sympify(other)\n1527 \n1528         if other is S.Infinity or other is S.NegativeInfinity:\n1529             if self.min is S.NegativeInfinity or self.max is S.Infinity:\n1530                 return True\n1531             return False\n1532 \n1533         rv = And(self.min <= other, self.max >= other)\n1534         if rv not in (True, False):\n1535             raise TypeError(\"input failed to evaluate\")\n1536         return rv\n1537 \n1538     def intersection(self, other):\n1539         \"\"\"\n1540         Returns the intersection of 'self' and 'other'.\n1541         Here other can be an instance of FiniteSet or AccumulationBounds.\n1542 \n1543         Examples\n1544         ========\n1545 \n1546         >>> from sympy import AccumBounds, FiniteSet\n1547         >>> AccumBounds(1, 3).intersection(AccumBounds(2, 4))\n1548         AccumBounds(2, 3)\n1549 \n1550         >>> AccumBounds(1, 3).intersection(AccumBounds(4, 6))\n1551         EmptySet\n1552 \n1553         >>> AccumBounds(1, 4).intersection(FiniteSet(1, 2, 5))\n1554         FiniteSet(1, 2)\n1555 \n1556         \"\"\"\n1557         if not isinstance(other, (AccumBounds, FiniteSet)):\n1558             raise TypeError(\n1559                 \"Input must be AccumulationBounds or FiniteSet object\")\n1560 \n1561         if isinstance(other, FiniteSet):\n1562             fin_set = S.EmptySet\n1563             for i in other:\n1564                 if i in self:\n1565                     fin_set = fin_set + FiniteSet(i)\n1566             return fin_set\n1567 \n1568         if self.max < other.min or self.min > other.max:\n1569             return S.EmptySet\n1570 \n1571         if self.min <= other.min:\n1572             if self.max <= other.max:\n1573                 return AccumBounds(other.min, self.max)\n1574             if self.max > other.max:\n1575                 return other\n1576 \n1577         if other.min <= self.min:\n1578             if other.max < self.max:\n1579                 return AccumBounds(self.min, other.max)\n1580             if other.max > self.max:\n1581                 return self\n1582 \n1583     def union(self, other):\n1584         # TODO : Devise a better method for Union of AccumBounds\n1585         # this method is not actually correct and\n1586         # can be made better\n1587         if not isinstance(other, AccumBounds):\n1588             raise TypeError(\n1589                 \"Input must be AccumulationBounds or FiniteSet object\")\n1590 \n1591         if self.min <= other.min and self.max >= other.min:\n1592             return AccumBounds(self.min, Max(self.max, other.max))\n1593 \n1594         if other.min <= self.min and other.max >= self.min:\n1595             return AccumBounds(other.min, Max(self.max, other.max))\n1596 \n1597 \n1598 # setting an alias for AccumulationBounds\n1599 AccumBounds = AccumulationBounds\n",
        "intended_behavior": "This code should ensure that any utility functions or mechanisms responsible for evaluating limits or behavior at infinity (`oo`) correctly interpret mathematical functions' growth, direction, or oscillation as they approach infinity, specifically accounting for exponential growth in a manner distinct from bounded oscillations or other behaviors."
    }
]