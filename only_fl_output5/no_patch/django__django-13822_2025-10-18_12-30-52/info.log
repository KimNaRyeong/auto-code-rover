2025-10-18 12:30:52.365 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-18 12:30:57.141 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=236, output_tokens=12, cost=0.002720
2025-10-18 12:31:19.698 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=416, output_tokens=927, cost=0.031970
2025-10-18 12:31:20.897 | INFO     | registered non reproducing test 0
2025-10-18 12:31:40.435 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2000, output_tokens=806, cost=0.044180
2025-10-18 12:31:41.542 | INFO     | registered non reproducing test 1
2025-10-18 12:31:59.169 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1996, output_tokens=740, cost=0.042160
2025-10-18 12:32:00.276 | INFO     | registered non reproducing test 2
2025-10-18 12:32:00.276 | WARNING  | Failed to write a reproducer test; skipping reproducer tracing
2025-10-18 12:32:00.282 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 12:32:08.996 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=541, output_tokens=301, cost=0.014440
2025-10-18 12:32:09.002 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 12:32:14.863 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=655, output_tokens=47, cost=0.007960
2025-10-18 12:32:14.864 | DEBUG    | Extracted a valid json.
2025-10-18 12:32:14.864 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_code(\"ManyToManyField\")",
        "search_code(\"related_name='+'\")",
        "search_code(\"class Meta:\")"
    ],
    "bug_locations": []
}
2025-10-18 12:32:15.020 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-18 12:32:15.020 | DEBUG    | <Agent search> Analyzing search results.
2025-10-18 12:32:33.876 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1751, output_tokens=843, cost=0.042800
2025-10-18 12:32:33.883 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 12:32:41.469 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2810, output_tokens=331, cost=0.038030
2025-10-18 12:32:41.475 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 12:32:46.548 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=685, output_tokens=160, cost=0.011650
2025-10-18 12:32:46.549 | DEBUG    | Extracted a valid json.
2025-10-18 12:32:46.555 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations":[
        {
            "file": "django/db/migrations/state.py", 
            "class": "", 
            "method": "", 
            "intended_behavior": "Adjust the state management logic to correctly differentiate between identical model names in different apps, ensuring that migrations involving these models do not raise fields.E305 errors."
        },
        {
            "file": "django/db/models/fields/related.py", 
            "class": "", 
            "method": "", 
            "intended_behavior": "Ensure that the usage of 'related_name='+' does not lead to conflicts during migration generation, effectively isolating the many-to-many relationships as per the design goal of using 'related_name='+'."
        }
    ]
}
2025-10-18 12:32:46.563 | DEBUG    | Bug location extracted successfully: [<file>django/db/migrations/state.py</file>
<class>None</class>
<method>None</method>
<code>
1 import copy
2 from contextlib import contextmanager
3 
4 from django.apps import AppConfig
5 from django.apps.registry import Apps, apps as global_apps
6 from django.conf import settings
7 from django.db import models
8 from django.db.models.fields.related import RECURSIVE_RELATIONSHIP_CONSTANT
9 from django.db.models.options import DEFAULT_NAMES, normalize_together
10 from django.db.models.utils import make_model_tuple
11 from django.utils.functional import cached_property
12 from django.utils.module_loading import import_string
13 from django.utils.version import get_docs_version
14 
15 from .exceptions import InvalidBasesError
16 
17 
18 def _get_app_label_and_model_name(model, app_label=''):
19     if isinstance(model, str):
20         split = model.split('.', 1)
21         return tuple(split) if len(split) == 2 else (app_label, split[0])
22     else:
23         return model._meta.app_label, model._meta.model_name
24 
25 
26 def _get_related_models(m):
27     """Return all models that have a direct relationship to the given model."""
28     related_models = [
29         subclass for subclass in m.__subclasses__()
30         if issubclass(subclass, models.Model)
31     ]
32     related_fields_models = set()
33     for f in m._meta.get_fields(include_parents=True, include_hidden=True):
34         if f.is_relation and f.related_model is not None and not isinstance(f.related_model, str):
35             related_fields_models.add(f.model)
36             related_models.append(f.related_model)
37     # Reverse accessors of foreign keys to proxy models are attached to their
38     # concrete proxied model.
39     opts = m._meta
40     if opts.proxy and m in related_fields_models:
41         related_models.append(opts.concrete_model)
42     return related_models
43 
44 
45 def get_related_models_tuples(model):
46     """
47     Return a list of typical (app_label, model_name) tuples for all related
48     models for the given model.
49     """
50     return {
51         (rel_mod._meta.app_label, rel_mod._meta.model_name)
52         for rel_mod in _get_related_models(model)
53     }
54 
55 
56 def get_related_models_recursive(model):
57     """
58     Return all models that have a direct or indirect relationship
59     to the given model.
60 
61     Relationships are either defined by explicit relational fields, like
62     ForeignKey, ManyToManyField or OneToOneField, or by inheriting from another
63     model (a superclass is related to its subclasses, but not vice versa). Note,
64     however, that a model inheriting from a concrete model is also related to
65     its superclass through the implicit *_ptr OneToOneField on the subclass.
66     """
67     seen = set()
68     queue = _get_related_models(model)
69     for rel_mod in queue:
70         rel_app_label, rel_model_name = rel_mod._meta.app_label, rel_mod._meta.model_name
71         if (rel_app_label, rel_model_name) in seen:
72             continue
73         seen.add((rel_app_label, rel_model_name))
74         queue.extend(_get_related_models(rel_mod))
75     return seen - {(model._meta.app_label, model._meta.model_name)}
76 
77 
78 class ProjectState:
79     """
80     Represent the entire project's overall state. This is the item that is
81     passed around - do it here rather than at the app level so that cross-app
82     FKs/etc. resolve properly.
83     """
84 
85     def __init__(self, models=None, real_apps=None):
86         self.models = models or {}
87         # Apps to include from main registry, usually unmigrated ones
88         self.real_apps = real_apps or []
89         self.is_delayed = False
90 
91     def add_model(self, model_state):
92         app_label, model_name = model_state.app_label, model_state.name_lower
93         self.models[(app_label, model_name)] = model_state
94         if 'apps' in self.__dict__:  # hasattr would cache the property
95             self.reload_model(app_label, model_name)
96 
97     def remove_model(self, app_label, model_name):
98         del self.models[app_label, model_name]
99         if 'apps' in self.__dict__:  # hasattr would cache the property
100             self.apps.unregister_model(app_label, model_name)
101             # Need to do this explicitly since unregister_model() doesn't clear
102             # the cache automatically (#24513)
103             self.apps.clear_cache()
104 
105     def _find_reload_model(self, app_label, model_name, delay=False):
106         if delay:
107             self.is_delayed = True
108 
109         related_models = set()
110 
111         try:
112             old_model = self.apps.get_model(app_label, model_name)
113         except LookupError:
114             pass
115         else:
116             # Get all relations to and from the old model before reloading,
117             # as _meta.apps may change
118             if delay:
119                 related_models = get_related_models_tuples(old_model)
120             else:
121                 related_models = get_related_models_recursive(old_model)
122 
123         # Get all outgoing references from the model to be rendered
124         model_state = self.models[(app_label, model_name)]
125         # Directly related models are the models pointed to by ForeignKeys,
126         # OneToOneFields, and ManyToManyFields.
127         direct_related_models = set()
128         for field in model_state.fields.values():
129             if field.is_relation:
130                 if field.remote_field.model == RECURSIVE_RELATIONSHIP_CONSTANT:
131                     continue
132                 rel_app_label, rel_model_name = _get_app_label_and_model_name(field.related_model, app_label)
133                 direct_related_models.add((rel_app_label, rel_model_name.lower()))
134 
135         # For all direct related models recursively get all related models.
136         related_models.update(direct_related_models)
137         for rel_app_label, rel_model_name in direct_related_models:
138             try:
139                 rel_model = self.apps.get_model(rel_app_label, rel_model_name)
140             except LookupError:
141                 pass
142             else:
143                 if delay:
144                     related_models.update(get_related_models_tuples(rel_model))
145                 else:
146                     related_models.update(get_related_models_recursive(rel_model))
147 
148         # Include the model itself
149         related_models.add((app_label, model_name))
150 
151         return related_models
152 
153     def reload_model(self, app_label, model_name, delay=False):
154         if 'apps' in self.__dict__:  # hasattr would cache the property
155             related_models = self._find_reload_model(app_label, model_name, delay)
156             self._reload(related_models)
157 
158     def reload_models(self, models, delay=True):
159         if 'apps' in self.__dict__:  # hasattr would cache the property
160             related_models = set()
161             for app_label, model_name in models:
162                 related_models.update(self._find_reload_model(app_label, model_name, delay))
163             self._reload(related_models)
164 
165     def _reload(self, related_models):
166         # Unregister all related models
167         with self.apps.bulk_update():
168             for rel_app_label, rel_model_name in related_models:
169                 self.apps.unregister_model(rel_app_label, rel_model_name)
170 
171         states_to_be_rendered = []
172         # Gather all models states of those models that will be rerendered.
173         # This includes:
174         # 1. All related models of unmigrated apps
175         for model_state in self.apps.real_models:
176             if (model_state.app_label, model_state.name_lower) in related_models:
177                 states_to_be_rendered.append(model_state)
178 
179         # 2. All related models of migrated apps
180         for rel_app_label, rel_model_name in related_models:
181             try:
182                 model_state = self.models[rel_app_label, rel_model_name]
183             except KeyError:
184                 pass
185             else:
186                 states_to_be_rendered.append(model_state)
187 
188         # Render all models
189         self.apps.render_multiple(states_to_be_rendered)
190 
191     def clone(self):
192         """Return an exact copy of this ProjectState."""
193         new_state = ProjectState(
194             models={k: v.clone() for k, v in self.models.items()},
195             real_apps=self.real_apps,
196         )
197         if 'apps' in self.__dict__:
198             new_state.apps = self.apps.clone()
199         new_state.is_delayed = self.is_delayed
200         return new_state
201 
202     def clear_delayed_apps_cache(self):
203         if self.is_delayed and 'apps' in self.__dict__:
204             del self.__dict__['apps']
205 
206     @cached_property
207     def apps(self):
208         return StateApps(self.real_apps, self.models)
209 
210     @property
211     def concrete_apps(self):
212         self.apps = StateApps(self.real_apps, self.models, ignore_swappable=True)
213         return self.apps
214 
215     @classmethod
216     def from_apps(cls, apps):
217         """Take an Apps and return a ProjectState matching it."""
218         app_models = {}
219         for model in apps.get_models(include_swapped=True):
220             model_state = ModelState.from_model(model)
221             app_models[(model_state.app_label, model_state.name_lower)] = model_state
222         return cls(app_models)
223 
224     def __eq__(self, other):
225         return self.models == other.models and set(self.real_apps) == set(other.real_apps)
226 
227 
228 class AppConfigStub(AppConfig):
229     """Stub of an AppConfig. Only provides a label and a dict of models."""
230     def __init__(self, label):
231         self.apps = None
232         self.models = {}
233         # App-label and app-name are not the same thing, so technically passing
234         # in the label here is wrong. In practice, migrations don't care about
235         # the app name, but we need something unique, and the label works fine.
236         self.label = label
237         self.name = label
238 
239     def import_models(self):
240         self.models = self.apps.all_models[self.label]
241 
242 
243 class StateApps(Apps):
244     """
245     Subclass of the global Apps registry class to better handle dynamic model
246     additions and removals.
247     """
248     def __init__(self, real_apps, models, ignore_swappable=False):
249         # Any apps in self.real_apps should have all their models included
250         # in the render. We don't use the original model instances as there
251         # are some variables that refer to the Apps object.
252         # FKs/M2Ms from real apps are also not included as they just
253         # mess things up with partial states (due to lack of dependencies)
254         self.real_models = []
255         for app_label in real_apps:
256             app = global_apps.get_app_config(app_label)
257             for model in app.get_models():
258                 self.real_models.append(ModelState.from_model(model, exclude_rels=True))
259         # Populate the app registry with a stub for each application.
260         app_labels = {model_state.app_label for model_state in models.values()}
261         app_configs = [AppConfigStub(label) for label in sorted([*real_apps, *app_labels])]
262         super().__init__(app_configs)
263 
264         # These locks get in the way of copying as implemented in clone(),
265         # which is called whenever Django duplicates a StateApps before
266         # updating it.
267         self._lock = None
268         self.ready_event = None
269 
270         self.render_multiple([*models.values(), *self.real_models])
271 
272         # There shouldn't be any operations pending at this point.
273         from django.core.checks.model_checks import _check_lazy_references
274         ignore = {make_model_tuple(settings.AUTH_USER_MODEL)} if ignore_swappable else set()
275         errors = _check_lazy_references(self, ignore=ignore)
276         if errors:
277             raise ValueError("\n".join(error.msg for error in errors))
278 
279     @contextmanager
280     def bulk_update(self):
281         # Avoid clearing each model's cache for each change. Instead, clear
282         # all caches when we're finished updating the model instances.
283         ready = self.ready
284         self.ready = False
285         try:
286             yield
287         finally:
288             self.ready = ready
289             self.clear_cache()
290 
291     def render_multiple(self, model_states):
292         # We keep trying to render the models in a loop, ignoring invalid
293         # base errors, until the size of the unrendered models doesn't
294         # decrease by at least one, meaning there's a base dependency loop/
295         # missing base.
296         if not model_states:
297             return
298         # Prevent that all model caches are expired for each render.
299         with self.bulk_update():
300             unrendered_models = model_states
301             while unrendered_models:
302                 new_unrendered_models = []
303                 for model in unrendered_models:
304                     try:
305                         model.render(self)
306                     except InvalidBasesError:
307                         new_unrendered_models.append(model)
308                 if len(new_unrendered_models) == len(unrendered_models):
309                     raise InvalidBasesError(
310                         "Cannot resolve bases for %r\nThis can happen if you are inheriting models from an "
311                         "app with migrations (e.g. contrib.auth)\n in an app with no migrations; see "
312                         "https://docs.djangoproject.com/en/%s/topics/migrations/#dependencies "
313                         "for more" % (new_unrendered_models, get_docs_version())
314                     )
315                 unrendered_models = new_unrendered_models
316 
317     def clone(self):
318         """Return a clone of this registry."""
319         clone = StateApps([], {})
320         clone.all_models = copy.deepcopy(self.all_models)
321         clone.app_configs = copy.deepcopy(self.app_configs)
322         # Set the pointer to the correct app registry.
323         for app_config in clone.app_configs.values():
324             app_config.apps = clone
325         # No need to actually clone them, they'll never change
326         clone.real_models = self.real_models
327         return clone
328 
329     def register_model(self, app_label, model):
330         self.all_models[app_label][model._meta.model_name] = model
331         if app_label not in self.app_configs:
332             self.app_configs[app_label] = AppConfigStub(app_label)
333             self.app_configs[app_label].apps = self
334         self.app_configs[app_label].models[model._meta.model_name] = model
335         self.do_pending_operations(model)
336         self.clear_cache()
337 
338     def unregister_model(self, app_label, model_name):
339         try:
340             del self.all_models[app_label][model_name]
341             del self.app_configs[app_label].models[model_name]
342         except KeyError:
343             pass
344 
345 
346 class ModelState:
347     """
348     Represent a Django Model. Don't use the actual Model class as it's not
349     designed to have its options changed - instead, mutate this one and then
350     render it into a Model as required.
351 
352     Note that while you are allowed to mutate .fields, you are not allowed
353     to mutate the Field instances inside there themselves - you must instead
354     assign new ones, as these are not detached during a clone.
355     """
356 
357     def __init__(self, app_label, name, fields, options=None, bases=None, managers=None):
358         self.app_label = app_label
359         self.name = name
360         self.fields = dict(fields)
361         self.options = options or {}
362         self.options.setdefault('indexes', [])
363         self.options.setdefault('constraints', [])
364         self.bases = bases or (models.Model,)
365         self.managers = managers or []
366         for name, field in self.fields.items():
367             # Sanity-check that fields are NOT already bound to a model.
368             if hasattr(field, 'model'):
369                 raise ValueError(
370                     'ModelState.fields cannot be bound to a model - "%s" is.' % name
371                 )
372             # Sanity-check that relation fields are NOT referring to a model class.
373             if field.is_relation and hasattr(field.related_model, '_meta'):
374                 raise ValueError(
375                     'ModelState.fields cannot refer to a model class - "%s.to" does. '
376                     'Use a string reference instead.' % name
377                 )
378             if field.many_to_many and hasattr(field.remote_field.through, '_meta'):
379                 raise ValueError(
380                     'ModelState.fields cannot refer to a model class - "%s.through" does. '
381                     'Use a string reference instead.' % name
382                 )
383         # Sanity-check that indexes have their name set.
384         for index in self.options['indexes']:
385             if not index.name:
386                 raise ValueError(
387                     "Indexes passed to ModelState require a name attribute. "
388                     "%r doesn't have one." % index
389                 )
390 
391     @cached_property
392     def name_lower(self):
393         return self.name.lower()
394 
395     @classmethod
396     def from_model(cls, model, exclude_rels=False):
397         """Given a model, return a ModelState representing it."""
398         # Deconstruct the fields
399         fields = []
400         for field in model._meta.local_fields:
401             if getattr(field, "remote_field", None) and exclude_rels:
402                 continue
403             if isinstance(field, models.OrderWrt):
404                 continue
405             name = field.name
406             try:
407                 fields.append((name, field.clone()))
408             except TypeError as e:
409                 raise TypeError("Couldn't reconstruct field %s on %s: %s" % (
410                     name,
411                     model._meta.label,
412                     e,
413                 ))
414         if not exclude_rels:
415             for field in model._meta.local_many_to_many:
416                 name = field.name
417                 try:
418                     fields.append((name, field.clone()))
419                 except TypeError as e:
420                     raise TypeError("Couldn't reconstruct m2m field %s on %s: %s" % (
421                         name,
422                         model._meta.object_name,
423                         e,
424                     ))
425         # Extract the options
426         options = {}
427         for name in DEFAULT_NAMES:
428             # Ignore some special options
429             if name in ["apps", "app_label"]:
430                 continue
431             elif name in model._meta.original_attrs:
432                 if name == "unique_together":
433                     ut = model._meta.original_attrs["unique_together"]
434                     options[name] = set(normalize_together(ut))
435                 elif name == "index_together":
436                     it = model._meta.original_attrs["index_together"]
437                     options[name] = set(normalize_together(it))
438                 elif name == "indexes":
439                     indexes = [idx.clone() for idx in model._meta.indexes]
440                     for index in indexes:
441                         if not index.name:
442                             index.set_name_with_model(model)
443                     options['indexes'] = indexes
444                 elif name == 'constraints':
445                     options['constraints'] = [con.clone() for con in model._meta.constraints]
446                 else:
447                     options[name] = model._meta.original_attrs[name]
448         # If we're ignoring relationships, remove all field-listing model
449         # options (that option basically just means "make a stub model")
450         if exclude_rels:
451             for key in ["unique_together", "index_together", "order_with_respect_to"]:
452                 if key in options:
453                     del options[key]
454         # Private fields are ignored, so remove options that refer to them.
455         elif options.get('order_with_respect_to') in {field.name for field in model._meta.private_fields}:
456             del options['order_with_respect_to']
457 
458         def flatten_bases(model):
459             bases = []
460             for base in model.__bases__:
461                 if hasattr(base, "_meta") and base._meta.abstract:
462                     bases.extend(flatten_bases(base))
463                 else:
464                     bases.append(base)
465             return bases
466 
467         # We can't rely on __mro__ directly because we only want to flatten
468         # abstract models and not the whole tree. However by recursing on
469         # __bases__ we may end up with duplicates and ordering issues, we
470         # therefore discard any duplicates and reorder the bases according
471         # to their index in the MRO.
472         flattened_bases = sorted(set(flatten_bases(model)), key=lambda x: model.__mro__.index(x))
473 
474         # Make our record
475         bases = tuple(
476             (
477                 base._meta.label_lower
478                 if hasattr(base, "_meta") else
479                 base
480             )
481             for base in flattened_bases
482         )
483         # Ensure at least one base inherits from models.Model
484         if not any((isinstance(base, str) or issubclass(base, models.Model)) for base in bases):
485             bases = (models.Model,)
486 
487         managers = []
488         manager_names = set()
489         default_manager_shim = None
490         for manager in model._meta.managers:
491             if manager.name in manager_names:
492                 # Skip overridden managers.
493                 continue
494             elif manager.use_in_migrations:
495                 # Copy managers usable in migrations.
496                 new_manager = copy.copy(manager)
497                 new_manager._set_creation_counter()
498             elif manager is model._base_manager or manager is model._default_manager:
499                 # Shim custom managers used as default and base managers.
500                 new_manager = models.Manager()
501                 new_manager.model = manager.model
502                 new_manager.name = manager.name
503                 if manager is model._default_manager:
504                     default_manager_shim = new_manager
505             else:
506                 continue
507             manager_names.add(manager.name)
508             managers.append((manager.name, new_manager))
509 
510         # Ignore a shimmed default manager called objects if it's the only one.
511         if managers == [('objects', default_manager_shim)]:
512             managers = []
513 
514         # Construct the new ModelState
515         return cls(
516             model._meta.app_label,
517             model._meta.object_name,
518             fields,
519             options,
520             bases,
521             managers,
522         )
523 
524     def construct_managers(self):
525         """Deep-clone the managers using deconstruction."""
526         # Sort all managers by their creation counter
527         sorted_managers = sorted(self.managers, key=lambda v: v[1].creation_counter)
528         for mgr_name, manager in sorted_managers:
529             as_manager, manager_path, qs_path, args, kwargs = manager.deconstruct()
530             if as_manager:
531                 qs_class = import_string(qs_path)
532                 yield mgr_name, qs_class.as_manager()
533             else:
534                 manager_class = import_string(manager_path)
535                 yield mgr_name, manager_class(*args, **kwargs)
536 
537     def clone(self):
538         """Return an exact copy of this ModelState."""
539         return self.__class__(
540             app_label=self.app_label,
541             name=self.name,
542             fields=dict(self.fields),
543             # Since options are shallow-copied here, operations such as
544             # AddIndex must replace their option (e.g 'indexes') rather
545             # than mutating it.
546             options=dict(self.options),
547             bases=self.bases,
548             managers=list(self.managers),
549         )
550 
551     def render(self, apps):
552         """Create a Model object from our current state into the given apps."""
553         # First, make a Meta object
554         meta_contents = {'app_label': self.app_label, 'apps': apps, **self.options}
555         meta = type("Meta", (), meta_contents)
556         # Then, work out our bases
557         try:
558             bases = tuple(
559                 (apps.get_model(base) if isinstance(base, str) else base)
560                 for base in self.bases
561             )
562         except LookupError:
563             raise InvalidBasesError("Cannot resolve one or more bases from %r" % (self.bases,))
564         # Clone fields for the body, add other bits.
565         body = {name: field.clone() for name, field in self.fields.items()}
566         body['Meta'] = meta
567         body['__module__'] = "__fake__"
568 
569         # Restore managers
570         body.update(self.construct_managers())
571         # Then, make a Model object (apps.register_model is called in __new__)
572         return type(self.name, bases, body)
573 
574     def get_index_by_name(self, name):
575         for index in self.options['indexes']:
576             if index.name == name:
577                 return index
578         raise ValueError("No index named %s on model %s" % (name, self.name))
579 
580     def get_constraint_by_name(self, name):
581         for constraint in self.options['constraints']:
582             if constraint.name == name:
583                 return constraint
584         raise ValueError('No constraint named %s on model %s' % (name, self.name))
585 
586     def __repr__(self):
587         return "<%s: '%s.%s'>" % (self.__class__.__name__, self.app_label, self.name)
588 
589     def __eq__(self, other):
590         return (
591             (self.app_label == other.app_label) and
592             (self.name == other.name) and
593             (len(self.fields) == len(other.fields)) and
594             all(
595                 k1 == k2 and f1.deconstruct()[1:] == f2.deconstruct()[1:]
596                 for (k1, f1), (k2, f2) in zip(
597                     sorted(self.fields.items()),
598                     sorted(other.fields.items()),
599                 )
600             ) and
601             (self.options == other.options) and
602             (self.bases == other.bases) and
603             (self.managers == other.managers)
604         )

</code><intended_behavior>Adjust the state management logic to correctly differentiate between identical model names in different apps, ensuring that migrations involving these models do not raise fields.E305 errors.</intended_behavior>, <file>django/db/models/fields/related.py</file>
<class>None</class>
<method>None</method>
<code>
1 import functools
2 import inspect
3 from functools import partial
4 
5 from django import forms
6 from django.apps import apps
7 from django.conf import SettingsReference, settings
8 from django.core import checks, exceptions
9 from django.db import connection, router
10 from django.db.backends import utils
11 from django.db.models import Q
12 from django.db.models.constants import LOOKUP_SEP
13 from django.db.models.deletion import CASCADE, SET_DEFAULT, SET_NULL
14 from django.db.models.query_utils import PathInfo
15 from django.db.models.utils import make_model_tuple
16 from django.utils.functional import cached_property
17 from django.utils.translation import gettext_lazy as _
18 
19 from . import Field
20 from .mixins import FieldCacheMixin
21 from .related_descriptors import (
22     ForeignKeyDeferredAttribute, ForwardManyToOneDescriptor,
23     ForwardOneToOneDescriptor, ManyToManyDescriptor,
24     ReverseManyToOneDescriptor, ReverseOneToOneDescriptor,
25 )
26 from .related_lookups import (
27     RelatedExact, RelatedGreaterThan, RelatedGreaterThanOrEqual, RelatedIn,
28     RelatedIsNull, RelatedLessThan, RelatedLessThanOrEqual,
29 )
30 from .reverse_related import (
31     ForeignObjectRel, ManyToManyRel, ManyToOneRel, OneToOneRel,
32 )
33 
34 RECURSIVE_RELATIONSHIP_CONSTANT = 'self'
35 
36 
37 def resolve_relation(scope_model, relation):
38     """
39     Transform relation into a model or fully-qualified model string of the form
40     "app_label.ModelName", relative to scope_model.
41 
42     The relation argument can be:
43       * RECURSIVE_RELATIONSHIP_CONSTANT, i.e. the string "self", in which case
44         the model argument will be returned.
45       * A bare model name without an app_label, in which case scope_model's
46         app_label will be prepended.
47       * An "app_label.ModelName" string.
48       * A model class, which will be returned unchanged.
49     """
50     # Check for recursive relations
51     if relation == RECURSIVE_RELATIONSHIP_CONSTANT:
52         relation = scope_model
53 
54     # Look for an "app.Model" relation
55     if isinstance(relation, str):
56         if "." not in relation:
57             relation = "%s.%s" % (scope_model._meta.app_label, relation)
58 
59     return relation
60 
61 
62 def lazy_related_operation(function, model, *related_models, **kwargs):
63     """
64     Schedule `function` to be called once `model` and all `related_models`
65     have been imported and registered with the app registry. `function` will
66     be called with the newly-loaded model classes as its positional arguments,
67     plus any optional keyword arguments.
68 
69     The `model` argument must be a model class. Each subsequent positional
70     argument is another model, or a reference to another model - see
71     `resolve_relation()` for the various forms these may take. Any relative
72     references will be resolved relative to `model`.
73 
74     This is a convenience wrapper for `Apps.lazy_model_operation` - the app
75     registry model used is the one found in `model._meta.apps`.
76     """
77     models = [model] + [resolve_relation(model, rel) for rel in related_models]
78     model_keys = (make_model_tuple(m) for m in models)
79     apps = model._meta.apps
80     return apps.lazy_model_operation(partial(function, **kwargs), *model_keys)
81 
82 
83 class RelatedField(FieldCacheMixin, Field):
84     """Base class that all relational fields inherit from."""
85 
86     # Field flags
87     one_to_many = False
88     one_to_one = False
89     many_to_many = False
90     many_to_one = False
91 
92     @cached_property
93     def related_model(self):
94         # Can't cache this property until all the models are loaded.
95         apps.check_models_ready()
96         return self.remote_field.model
97 
98     def check(self, **kwargs):
99         return [
100             *super().check(**kwargs),
101             *self._check_related_name_is_valid(),
102             *self._check_related_query_name_is_valid(),
103             *self._check_relation_model_exists(),
104             *self._check_referencing_to_swapped_model(),
105             *self._check_clashes(),
106         ]
107 
108     def _check_related_name_is_valid(self):
109         import keyword
110         related_name = self.remote_field.related_name
111         if related_name is None:
112             return []
113         is_valid_id = not keyword.iskeyword(related_name) and related_name.isidentifier()
114         if not (is_valid_id or related_name.endswith('+')):
115             return [
116                 checks.Error(
117                     "The name '%s' is invalid related_name for field %s.%s" %
118                     (self.remote_field.related_name, self.model._meta.object_name,
119                      self.name),
120                     hint="Related name must be a valid Python identifier or end with a '+'",
121                     obj=self,
122                     id='fields.E306',
123                 )
124             ]
125         return []
126 
127     def _check_related_query_name_is_valid(self):
128         if self.remote_field.is_hidden():
129             return []
130         rel_query_name = self.related_query_name()
131         errors = []
132         if rel_query_name.endswith('_'):
133             errors.append(
134                 checks.Error(
135                     "Reverse query name '%s' must not end with an underscore."
136                     % rel_query_name,
137                     hint=("Add or change a related_name or related_query_name "
138                           "argument for this field."),
139                     obj=self,
140                     id='fields.E308',
141                 )
142             )
143         if LOOKUP_SEP in rel_query_name:
144             errors.append(
145                 checks.Error(
146                     "Reverse query name '%s' must not contain '%s'."
147                     % (rel_query_name, LOOKUP_SEP),
148                     hint=("Add or change a related_name or related_query_name "
149                           "argument for this field."),
150                     obj=self,
151                     id='fields.E309',
152                 )
153             )
154         return errors
155 
156     def _check_relation_model_exists(self):
157         rel_is_missing = self.remote_field.model not in self.opts.apps.get_models()
158         rel_is_string = isinstance(self.remote_field.model, str)
159         model_name = self.remote_field.model if rel_is_string else self.remote_field.model._meta.object_name
160         if rel_is_missing and (rel_is_string or not self.remote_field.model._meta.swapped):
161             return [
162                 checks.Error(
163                     "Field defines a relation with model '%s', which is either "
164                     "not installed, or is abstract." % model_name,
165                     obj=self,
166                     id='fields.E300',
167                 )
168             ]
169         return []
170 
171     def _check_referencing_to_swapped_model(self):
172         if (self.remote_field.model not in self.opts.apps.get_models() and
173                 not isinstance(self.remote_field.model, str) and
174                 self.remote_field.model._meta.swapped):
175             return [
176                 checks.Error(
177                     "Field defines a relation with the model '%s', which has "
178                     "been swapped out." % self.remote_field.model._meta.label,
179                     hint="Update the relation to point at 'settings.%s'." % self.remote_field.model._meta.swappable,
180                     obj=self,
181                     id='fields.E301',
182                 )
183             ]
184         return []
185 
186     def _check_clashes(self):
187         """Check accessor and reverse query name clashes."""
188         from django.db.models.base import ModelBase
189 
190         errors = []
191         opts = self.model._meta
192 
193         # `f.remote_field.model` may be a string instead of a model. Skip if model name is
194         # not resolved.
195         if not isinstance(self.remote_field.model, ModelBase):
196             return []
197 
198         # Consider that we are checking field `Model.foreign` and the models
199         # are:
200         #
201         #     class Target(models.Model):
202         #         model = models.IntegerField()
203         #         model_set = models.IntegerField()
204         #
205         #     class Model(models.Model):
206         #         foreign = models.ForeignKey(Target)
207         #         m2m = models.ManyToManyField(Target)
208 
209         # rel_opts.object_name == "Target"
210         rel_opts = self.remote_field.model._meta
211         # If the field doesn't install a backward relation on the target model
212         # (so `is_hidden` returns True), then there are no clashes to check
213         # and we can skip these fields.
214         rel_is_hidden = self.remote_field.is_hidden()
215         rel_name = self.remote_field.get_accessor_name()  # i. e. "model_set"
216         rel_query_name = self.related_query_name()  # i. e. "model"
217         # i.e. "app_label.Model.field".
218         field_name = '%s.%s' % (opts.label, self.name)
219 
220         # Check clashes between accessor or reverse query name of `field`
221         # and any other field name -- i.e. accessor for Model.foreign is
222         # model_set and it clashes with Target.model_set.
223         potential_clashes = rel_opts.fields + rel_opts.many_to_many
224         for clash_field in potential_clashes:
225             # i.e. "app_label.Target.model_set".
226             clash_name = '%s.%s' % (rel_opts.label, clash_field.name)
227             if not rel_is_hidden and clash_field.name == rel_name:
228                 errors.append(
229                     checks.Error(
230                         "Reverse accessor for '%s' clashes with field name '%s'." % (field_name, clash_name),
231                         hint=("Rename field '%s', or add/change a related_name "
232                               "argument to the definition for field '%s'.") % (clash_name, field_name),
233                         obj=self,
234                         id='fields.E302',
235                     )
236                 )
237 
238             if clash_field.name == rel_query_name:
239                 errors.append(
240                     checks.Error(
241                         "Reverse query name for '%s' clashes with field name '%s'." % (field_name, clash_name),
242                         hint=("Rename field '%s', or add/change a related_name "
243                               "argument to the definition for field '%s'.") % (clash_name, field_name),
244                         obj=self,
245                         id='fields.E303',
246                     )
247                 )
248 
249         # Check clashes between accessors/reverse query names of `field` and
250         # any other field accessor -- i. e. Model.foreign accessor clashes with
251         # Model.m2m accessor.
252         potential_clashes = (r for r in rel_opts.related_objects if r.field is not self)
253         for clash_field in potential_clashes:
254             # i.e. "app_label.Model.m2m".
255             clash_name = '%s.%s' % (
256                 clash_field.related_model._meta.label,
257                 clash_field.field.name,
258             )
259             if not rel_is_hidden and clash_field.get_accessor_name() == rel_name:
260                 errors.append(
261                     checks.Error(
262                         "Reverse accessor for '%s' clashes with reverse accessor for '%s'." % (field_name, clash_name),
263                         hint=("Add or change a related_name argument "
264                               "to the definition for '%s' or '%s'.") % (field_name, clash_name),
265                         obj=self,
266                         id='fields.E304',
267                     )
268                 )
269 
270             if clash_field.get_accessor_name() == rel_query_name:
271                 errors.append(
272                     checks.Error(
273                         "Reverse query name for '%s' clashes with reverse query name for '%s'."
274                         % (field_name, clash_name),
275                         hint=("Add or change a related_name argument "
276                               "to the definition for '%s' or '%s'.") % (field_name, clash_name),
277                         obj=self,
278                         id='fields.E305',
279                     )
280                 )
281 
282         return errors
283 
284     def db_type(self, connection):
285         # By default related field will not have a column as it relates to
286         # columns from another table.
287         return None
288 
289     def contribute_to_class(self, cls, name, private_only=False, **kwargs):
290 
291         super().contribute_to_class(cls, name, private_only=private_only, **kwargs)
292 
293         self.opts = cls._meta
294 
295         if not cls._meta.abstract:
296             if self.remote_field.related_name:
297                 related_name = self.remote_field.related_name
298             else:
299                 related_name = self.opts.default_related_name
300             if related_name:
301                 related_name = related_name % {
302                     'class': cls.__name__.lower(),
303                     'model_name': cls._meta.model_name.lower(),
304                     'app_label': cls._meta.app_label.lower()
305                 }
306                 self.remote_field.related_name = related_name
307 
308             if self.remote_field.related_query_name:
309                 related_query_name = self.remote_field.related_query_name % {
310                     'class': cls.__name__.lower(),
311                     'app_label': cls._meta.app_label.lower(),
312                 }
313                 self.remote_field.related_query_name = related_query_name
314 
315             def resolve_related_class(model, related, field):
316                 field.remote_field.model = related
317                 field.do_related_class(related, model)
318             lazy_related_operation(resolve_related_class, cls, self.remote_field.model, field=self)
319 
320     def deconstruct(self):
321         name, path, args, kwargs = super().deconstruct()
322         if self.remote_field.limit_choices_to:
323             kwargs['limit_choices_to'] = self.remote_field.limit_choices_to
324         if self.remote_field.related_name is not None:
325             kwargs['related_name'] = self.remote_field.related_name
326         if self.remote_field.related_query_name is not None:
327             kwargs['related_query_name'] = self.remote_field.related_query_name
328         return name, path, args, kwargs
329 
330     def get_forward_related_filter(self, obj):
331         """
332         Return the keyword arguments that when supplied to
333         self.model.object.filter(), would select all instances related through
334         this field to the remote obj. This is used to build the querysets
335         returned by related descriptors. obj is an instance of
336         self.related_field.model.
337         """
338         return {
339             '%s__%s' % (self.name, rh_field.name): getattr(obj, rh_field.attname)
340             for _, rh_field in self.related_fields
341         }
342 
343     def get_reverse_related_filter(self, obj):
344         """
345         Complement to get_forward_related_filter(). Return the keyword
346         arguments that when passed to self.related_field.model.object.filter()
347         select all instances of self.related_field.model related through
348         this field to obj. obj is an instance of self.model.
349         """
350         base_filter = {
351             rh_field.attname: getattr(obj, lh_field.attname)
352             for lh_field, rh_field in self.related_fields
353         }
354         descriptor_filter = self.get_extra_descriptor_filter(obj)
355         base_q = Q(**base_filter)
356         if isinstance(descriptor_filter, dict):
357             return base_q & Q(**descriptor_filter)
358         elif descriptor_filter:
359             return base_q & descriptor_filter
360         return base_q
361 
362     @property
363     def swappable_setting(self):
364         """
365         Get the setting that this is powered from for swapping, or None
366         if it's not swapped in / marked with swappable=False.
367         """
368         if self.swappable:
369             # Work out string form of "to"
370             if isinstance(self.remote_field.model, str):
371                 to_string = self.remote_field.model
372             else:
373                 to_string = self.remote_field.model._meta.label
374             return apps.get_swappable_settings_name(to_string)
375         return None
376 
377     def set_attributes_from_rel(self):
378         self.name = (
379             self.name or
380             (self.remote_field.model._meta.model_name + '_' + self.remote_field.model._meta.pk.name)
381         )
382         if self.verbose_name is None:
383             self.verbose_name = self.remote_field.model._meta.verbose_name
384         self.remote_field.set_field_name()
385 
386     def do_related_class(self, other, cls):
387         self.set_attributes_from_rel()
388         self.contribute_to_related_class(other, self.remote_field)
389 
390     def get_limit_choices_to(self):
391         """
392         Return ``limit_choices_to`` for this model field.
393 
394         If it is a callable, it will be invoked and the result will be
395         returned.
396         """
397         if callable(self.remote_field.limit_choices_to):
398             return self.remote_field.limit_choices_to()
399         return self.remote_field.limit_choices_to
400 
401     def formfield(self, **kwargs):
402         """
403         Pass ``limit_choices_to`` to the field being constructed.
404 
405         Only passes it if there is a type that supports related fields.
406         This is a similar strategy used to pass the ``queryset`` to the field
407         being constructed.
408         """
409         defaults = {}
410         if hasattr(self.remote_field, 'get_related_field'):
411             # If this is a callable, do not invoke it here. Just pass
412             # it in the defaults for when the form class will later be
413             # instantiated.
414             limit_choices_to = self.remote_field.limit_choices_to
415             defaults.update({
416                 'limit_choices_to': limit_choices_to,
417             })
418         defaults.update(kwargs)
419         return super().formfield(**defaults)
420 
421     def related_query_name(self):
422         """
423         Define the name that can be used to identify this related object in a
424         table-spanning query.
425         """
426         return self.remote_field.related_query_name or self.remote_field.related_name or self.opts.model_name
427 
428     @property
429     def target_field(self):
430         """
431         When filtering against this relation, return the field on the remote
432         model against which the filtering should happen.
433         """
434         target_fields = self.get_path_info()[-1].target_fields
435         if len(target_fields) > 1:
436             raise exceptions.FieldError(
437                 "The relation has multiple target fields, but only single target field was asked for")
438         return target_fields[0]
439 
440     def get_cache_name(self):
441         return self.name
442 
443 
444 class ForeignObject(RelatedField):
445     """
446     Abstraction of the ForeignKey relation to support multi-column relations.
447     """
448 
449     # Field flags
450     many_to_many = False
451     many_to_one = True
452     one_to_many = False
453     one_to_one = False
454 
455     requires_unique_target = True
456     related_accessor_class = ReverseManyToOneDescriptor
457     forward_related_accessor_class = ForwardManyToOneDescriptor
458     rel_class = ForeignObjectRel
459 
460     def __init__(self, to, on_delete, from_fields, to_fields, rel=None, related_name=None,
461                  related_query_name=None, limit_choices_to=None, parent_link=False,
462                  swappable=True, **kwargs):
463 
464         if rel is None:
465             rel = self.rel_class(
466                 self, to,
467                 related_name=related_name,
468                 related_query_name=related_query_name,
469                 limit_choices_to=limit_choices_to,
470                 parent_link=parent_link,
471                 on_delete=on_delete,
472             )
473 
474         super().__init__(rel=rel, **kwargs)
475 
476         self.from_fields = from_fields
477         self.to_fields = to_fields
478         self.swappable = swappable
479 
480     def check(self, **kwargs):
481         return [
482             *super().check(**kwargs),
483             *self._check_to_fields_exist(),
484             *self._check_unique_target(),
485         ]
486 
487     def _check_to_fields_exist(self):
488         # Skip nonexistent models.
489         if isinstance(self.remote_field.model, str):
490             return []
491 
492         errors = []
493         for to_field in self.to_fields:
494             if to_field:
495                 try:
496                     self.remote_field.model._meta.get_field(to_field)
497                 except exceptions.FieldDoesNotExist:
498                     errors.append(
499                         checks.Error(
500                             "The to_field '%s' doesn't exist on the related "
501                             "model '%s'."
502                             % (to_field, self.remote_field.model._meta.label),
503                             obj=self,
504                             id='fields.E312',
505                         )
506                     )
507         return errors
508 
509     def _check_unique_target(self):
510         rel_is_string = isinstance(self.remote_field.model, str)
511         if rel_is_string or not self.requires_unique_target:
512             return []
513 
514         try:
515             self.foreign_related_fields
516         except exceptions.FieldDoesNotExist:
517             return []
518 
519         if not self.foreign_related_fields:
520             return []
521 
522         unique_foreign_fields = {
523             frozenset([f.name])
524             for f in self.remote_field.model._meta.get_fields()
525             if getattr(f, 'unique', False)
526         }
527         unique_foreign_fields.update({
528             frozenset(ut)
529             for ut in self.remote_field.model._meta.unique_together
530         })
531         unique_foreign_fields.update({
532             frozenset(uc.fields)
533             for uc in self.remote_field.model._meta.total_unique_constraints
534         })
535         foreign_fields = {f.name for f in self.foreign_related_fields}
536         has_unique_constraint = any(u <= foreign_fields for u in unique_foreign_fields)
537 
538         if not has_unique_constraint and len(self.foreign_related_fields) > 1:
539             field_combination = ', '.join(
540                 "'%s'" % rel_field.name for rel_field in self.foreign_related_fields
541             )
542             model_name = self.remote_field.model.__name__
543             return [
544                 checks.Error(
545                     "No subset of the fields %s on model '%s' is unique."
546                     % (field_combination, model_name),
547                     hint=(
548                         'Mark a single field as unique=True or add a set of '
549                         'fields to a unique constraint (via unique_together '
550                         'or a UniqueConstraint (without condition) in the '
551                         'model Meta.constraints).'
552                     ),
553                     obj=self,
554                     id='fields.E310',
555                 )
556             ]
557         elif not has_unique_constraint:
558             field_name = self.foreign_related_fields[0].name
559             model_name = self.remote_field.model.__name__
560             return [
561                 checks.Error(
562                     "'%s.%s' must be unique because it is referenced by "
563                     "a foreign key." % (model_name, field_name),
564                     hint=(
565                         'Add unique=True to this field or add a '
566                         'UniqueConstraint (without condition) in the model '
567                         'Meta.constraints.'
568                     ),
569                     obj=self,
570                     id='fields.E311',
571                 )
572             ]
573         else:
574             return []
575 
576     def deconstruct(self):
577         name, path, args, kwargs = super().deconstruct()
578         kwargs['on_delete'] = self.remote_field.on_delete
579         kwargs['from_fields'] = self.from_fields
580         kwargs['to_fields'] = self.to_fields
581 
582         if self.remote_field.parent_link:
583             kwargs['parent_link'] = self.remote_field.parent_link
584         if isinstance(self.remote_field.model, str):
585             if '.' in self.remote_field.model:
586                 app_label, model_name = self.remote_field.model.split('.')
587                 kwargs['to'] = '%s.%s' % (app_label, model_name.lower())
588             else:
589                 kwargs['to'] = self.remote_field.model.lower()
590         else:
591             kwargs['to'] = self.remote_field.model._meta.label_lower
592         # If swappable is True, then see if we're actually pointing to the target
593         # of a swap.
594         swappable_setting = self.swappable_setting
595         if swappable_setting is not None:
596             # If it's already a settings reference, error
597             if hasattr(kwargs['to'], "setting_name"):
598                 if kwargs['to'].setting_name != swappable_setting:
599                     raise ValueError(
600                         "Cannot deconstruct a ForeignKey pointing to a model "
601                         "that is swapped in place of more than one model (%s and %s)"
602                         % (kwargs['to'].setting_name, swappable_setting)
603                     )
604             # Set it
605             kwargs['to'] = SettingsReference(
606                 kwargs['to'],
607                 swappable_setting,
608             )
609         return name, path, args, kwargs
610 
611     def resolve_related_fields(self):
612         if not self.from_fields or len(self.from_fields) != len(self.to_fields):
613             raise ValueError('Foreign Object from and to fields must be the same non-zero length')
614         if isinstance(self.remote_field.model, str):
615             raise ValueError('Related model %r cannot be resolved' % self.remote_field.model)
616         related_fields = []
617         for index in range(len(self.from_fields)):
618             from_field_name = self.from_fields[index]
619             to_field_name = self.to_fields[index]
620             from_field = (
621                 self
622                 if from_field_name == RECURSIVE_RELATIONSHIP_CONSTANT
623                 else self.opts.get_field(from_field_name)
624             )
625             to_field = (self.remote_field.model._meta.pk if to_field_name is None
626                         else self.remote_field.model._meta.get_field(to_field_name))
627             related_fields.append((from_field, to_field))
628         return related_fields
629 
630     @cached_property
631     def related_fields(self):
632         return self.resolve_related_fields()
633 
634     @cached_property
635     def reverse_related_fields(self):
636         return [(rhs_field, lhs_field) for lhs_field, rhs_field in self.related_fields]
637 
638     @cached_property
639     def local_related_fields(self):
640         return tuple(lhs_field for lhs_field, rhs_field in self.related_fields)
641 
642     @cached_property
643     def foreign_related_fields(self):
644         return tuple(rhs_field for lhs_field, rhs_field in self.related_fields if rhs_field)
645 
646     def get_local_related_value(self, instance):
647         return self.get_instance_value_for_fields(instance, self.local_related_fields)
648 
649     def get_foreign_related_value(self, instance):
650         return self.get_instance_value_for_fields(instance, self.foreign_related_fields)
651 
652     @staticmethod
653     def get_instance_value_for_fields(instance, fields):
654         ret = []
655         opts = instance._meta
656         for field in fields:
657             # Gotcha: in some cases (like fixture loading) a model can have
658             # different values in parent_ptr_id and parent's id. So, use
659             # instance.pk (that is, parent_ptr_id) when asked for instance.id.
660             if field.primary_key:
661                 possible_parent_link = opts.get_ancestor_link(field.model)
662                 if (not possible_parent_link or
663                         possible_parent_link.primary_key or
664                         possible_parent_link.model._meta.abstract):
665                     ret.append(instance.pk)
666                     continue
667             ret.append(getattr(instance, field.attname))
668         return tuple(ret)
669 
670     def get_attname_column(self):
671         attname, column = super().get_attname_column()
672         return attname, None
673 
674     def get_joining_columns(self, reverse_join=False):
675         source = self.reverse_related_fields if reverse_join else self.related_fields
676         return tuple((lhs_field.column, rhs_field.column) for lhs_field, rhs_field in source)
677 
678     def get_reverse_joining_columns(self):
679         return self.get_joining_columns(reverse_join=True)
680 
681     def get_extra_descriptor_filter(self, instance):
682         """
683         Return an extra filter condition for related object fetching when
684         user does 'instance.fieldname', that is the extra filter is used in
685         the descriptor of the field.
686 
687         The filter should be either a dict usable in .filter(**kwargs) call or
688         a Q-object. The condition will be ANDed together with the relation's
689         joining columns.
690 
691         A parallel method is get_extra_restriction() which is used in
692         JOIN and subquery conditions.
693         """
694         return {}
695 
696     def get_extra_restriction(self, where_class, alias, related_alias):
697         """
698         Return a pair condition used for joining and subquery pushdown. The
699         condition is something that responds to as_sql(compiler, connection)
700         method.
701 
702         Note that currently referring both the 'alias' and 'related_alias'
703         will not work in some conditions, like subquery pushdown.
704 
705         A parallel method is get_extra_descriptor_filter() which is used in
706         instance.fieldname related object fetching.
707         """
708         return None
709 
710     def get_path_info(self, filtered_relation=None):
711         """Get path from this field to the related model."""
712         opts = self.remote_field.model._meta
713         from_opts = self.model._meta
714         return [PathInfo(
715             from_opts=from_opts,
716             to_opts=opts,
717             target_fields=self.foreign_related_fields,
718             join_field=self,
719             m2m=False,
720             direct=True,
721             filtered_relation=filtered_relation,
722         )]
723 
724     def get_reverse_path_info(self, filtered_relation=None):
725         """Get path from the related model to this field's model."""
726         opts = self.model._meta
727         from_opts = self.remote_field.model._meta
728         return [PathInfo(
729             from_opts=from_opts,
730             to_opts=opts,
731             target_fields=(opts.pk,),
732             join_field=self.remote_field,
733             m2m=not self.unique,
734             direct=False,
735             filtered_relation=filtered_relation,
736         )]
737 
738     @classmethod
739     @functools.lru_cache(maxsize=None)
740     def get_lookups(cls):
741         bases = inspect.getmro(cls)
742         bases = bases[:bases.index(ForeignObject) + 1]
743         class_lookups = [parent.__dict__.get('class_lookups', {}) for parent in bases]
744         return cls.merge_dicts(class_lookups)
745 
746     def contribute_to_class(self, cls, name, private_only=False, **kwargs):
747         super().contribute_to_class(cls, name, private_only=private_only, **kwargs)
748         setattr(cls, self.name, self.forward_related_accessor_class(self))
749 
750     def contribute_to_related_class(self, cls, related):
751         # Internal FK's - i.e., those with a related name ending with '+' -
752         # and swapped models don't get a related descriptor.
753         if not self.remote_field.is_hidden() and not related.related_model._meta.swapped:
754             setattr(cls._meta.concrete_model, related.get_accessor_name(), self.related_accessor_class(related))
755             # While 'limit_choices_to' might be a callable, simply pass
756             # it along for later - this is too early because it's still
757             # model load time.
758             if self.remote_field.limit_choices_to:
759                 cls._meta.related_fkey_lookups.append(self.remote_field.limit_choices_to)
760 
761 
762 ForeignObject.register_lookup(RelatedIn)
763 ForeignObject.register_lookup(RelatedExact)
764 ForeignObject.register_lookup(RelatedLessThan)
765 ForeignObject.register_lookup(RelatedGreaterThan)
766 ForeignObject.register_lookup(RelatedGreaterThanOrEqual)
767 ForeignObject.register_lookup(RelatedLessThanOrEqual)
768 ForeignObject.register_lookup(RelatedIsNull)
769 
770 
771 class ForeignKey(ForeignObject):
772     """
773     Provide a many-to-one relation by adding a column to the local model
774     to hold the remote value.
775 
776     By default ForeignKey will target the pk of the remote model but this
777     behavior can be changed by using the ``to_field`` argument.
778     """
779     descriptor_class = ForeignKeyDeferredAttribute
780     # Field flags
781     many_to_many = False
782     many_to_one = True
783     one_to_many = False
784     one_to_one = False
785 
786     rel_class = ManyToOneRel
787 
788     empty_strings_allowed = False
789     default_error_messages = {
790         'invalid': _('%(model)s instance with %(field)s %(value)r does not exist.')
791     }
792     description = _("Foreign Key (type determined by related field)")
793 
794     def __init__(self, to, on_delete, related_name=None, related_query_name=None,
795                  limit_choices_to=None, parent_link=False, to_field=None,
796                  db_constraint=True, **kwargs):
797         try:
798             to._meta.model_name
799         except AttributeError:
800             assert isinstance(to, str), (
801                 "%s(%r) is invalid. First parameter to ForeignKey must be "
802                 "either a model, a model name, or the string %r" % (
803                     self.__class__.__name__, to,
804                     RECURSIVE_RELATIONSHIP_CONSTANT,
805                 )
806             )
807         else:
808             # For backwards compatibility purposes, we need to *try* and set
809             # the to_field during FK construction. It won't be guaranteed to
810             # be correct until contribute_to_class is called. Refs #12190.
811             to_field = to_field or (to._meta.pk and to._meta.pk.name)
812         if not callable(on_delete):
813             raise TypeError('on_delete must be callable.')
814 
815         kwargs['rel'] = self.rel_class(
816             self, to, to_field,
817             related_name=related_name,
818             related_query_name=related_query_name,
819             limit_choices_to=limit_choices_to,
820             parent_link=parent_link,
821             on_delete=on_delete,
822         )
823         kwargs.setdefault('db_index', True)
824 
825         super().__init__(
826             to,
827             on_delete,
828             from_fields=[RECURSIVE_RELATIONSHIP_CONSTANT],
829             to_fields=[to_field],
830             **kwargs,
831         )
832         self.db_constraint = db_constraint
833 
834     def check(self, **kwargs):
835         return [
836             *super().check(**kwargs),
837             *self._check_on_delete(),
838             *self._check_unique(),
839         ]
840 
841     def _check_on_delete(self):
842         on_delete = getattr(self.remote_field, 'on_delete', None)
843         if on_delete == SET_NULL and not self.null:
844             return [
845                 checks.Error(
846                     'Field specifies on_delete=SET_NULL, but cannot be null.',
847                     hint='Set null=True argument on the field, or change the on_delete rule.',
848                     obj=self,
849                     id='fields.E320',
850                 )
851             ]
852         elif on_delete == SET_DEFAULT and not self.has_default():
853             return [
854                 checks.Error(
855                     'Field specifies on_delete=SET_DEFAULT, but has no default value.',
856                     hint='Set a default value, or change the on_delete rule.',
857                     obj=self,
858                     id='fields.E321',
859                 )
860             ]
861         else:
862             return []
863 
864     def _check_unique(self, **kwargs):
865         return [
866             checks.Warning(
867                 'Setting unique=True on a ForeignKey has the same effect as using a OneToOneField.',
868                 hint='ForeignKey(unique=True) is usually better served by a OneToOneField.',
869                 obj=self,
870                 id='fields.W342',
871             )
872         ] if self.unique else []
873 
874     def deconstruct(self):
875         name, path, args, kwargs = super().deconstruct()
876         del kwargs['to_fields']
877         del kwargs['from_fields']
878         # Handle the simpler arguments
879         if self.db_index:
880             del kwargs['db_index']
881         else:
882             kwargs['db_index'] = False
883         if self.db_constraint is not True:
884             kwargs['db_constraint'] = self.db_constraint
885         # Rel needs more work.
886         to_meta = getattr(self.remote_field.model, "_meta", None)
887         if self.remote_field.field_name and (
888                 not to_meta or (to_meta.pk and self.remote_field.field_name != to_meta.pk.name)):
889             kwargs['to_field'] = self.remote_field.field_name
890         return name, path, args, kwargs
891 
892     def to_python(self, value):
893         return self.target_field.to_python(value)
894 
895     @property
896     def target_field(self):
897         return self.foreign_related_fields[0]
898 
899     def get_reverse_path_info(self, filtered_relation=None):
900         """Get path from the related model to this field's model."""
901         opts = self.model._meta
902         from_opts = self.remote_field.model._meta
903         return [PathInfo(
904             from_opts=from_opts,
905             to_opts=opts,
906             target_fields=(opts.pk,),
907             join_field=self.remote_field,
908             m2m=not self.unique,
909             direct=False,
910             filtered_relation=filtered_relation,
911         )]
912 
913     def validate(self, value, model_instance):
914         if self.remote_field.parent_link:
915             return
916         super().validate(value, model_instance)
917         if value is None:
918             return
919 
920         using = router.db_for_read(self.remote_field.model, instance=model_instance)
921         qs = self.remote_field.model._base_manager.using(using).filter(
922             **{self.remote_field.field_name: value}
923         )
924         qs = qs.complex_filter(self.get_limit_choices_to())
925         if not qs.exists():
926             raise exceptions.ValidationError(
927                 self.error_messages['invalid'],
928                 code='invalid',
929                 params={
930                     'model': self.remote_field.model._meta.verbose_name, 'pk': value,
931                     'field': self.remote_field.field_name, 'value': value,
932                 },  # 'pk' is included for backwards compatibility
933             )
934 
935     def resolve_related_fields(self):
936         related_fields = super().resolve_related_fields()
937         for from_field, to_field in related_fields:
938             if to_field and to_field.model != self.remote_field.model._meta.concrete_model:
939                 raise exceptions.FieldError(
940                     "'%s.%s' refers to field '%s' which is not local to model "
941                     "'%s'." % (
942                         self.model._meta.label,
943                         self.name,
944                         to_field.name,
945                         self.remote_field.model._meta.concrete_model._meta.label,
946                     )
947                 )
948         return related_fields
949 
950     def get_attname(self):
951         return '%s_id' % self.name
952 
953     def get_attname_column(self):
954         attname = self.get_attname()
955         column = self.db_column or attname
956         return attname, column
957 
958     def get_default(self):
959         """Return the to_field if the default value is an object."""
960         field_default = super().get_default()
961         if isinstance(field_default, self.remote_field.model):
962             return getattr(field_default, self.target_field.attname)
963         return field_default
964 
965     def get_db_prep_save(self, value, connection):
966         if value is None or (value == '' and
967                              (not self.target_field.empty_strings_allowed or
968                               connection.features.interprets_empty_strings_as_nulls)):
969             return None
970         else:
971             return self.target_field.get_db_prep_save(value, connection=connection)
972 
973     def get_db_prep_value(self, value, connection, prepared=False):
974         return self.target_field.get_db_prep_value(value, connection, prepared)
975 
976     def get_prep_value(self, value):
977         return self.target_field.get_prep_value(value)
978 
979     def contribute_to_related_class(self, cls, related):
980         super().contribute_to_related_class(cls, related)
981         if self.remote_field.field_name is None:
982             self.remote_field.field_name = cls._meta.pk.name
983 
984     def formfield(self, *, using=None, **kwargs):
985         if isinstance(self.remote_field.model, str):
986             raise ValueError("Cannot create form field for %r yet, because "
987                              "its related model %r has not been loaded yet" %
988                              (self.name, self.remote_field.model))
989         return super().formfield(**{
990             'form_class': forms.ModelChoiceField,
991             'queryset': self.remote_field.model._default_manager.using(using),
992             'to_field_name': self.remote_field.field_name,
993             **kwargs,
994             'blank': self.blank,
995         })
996 
997     def db_check(self, connection):
998         return []
999 
1000     def db_type(self, connection):
1001         return self.target_field.rel_db_type(connection=connection)
1002 
1003     def db_parameters(self, connection):
1004         return {"type": self.db_type(connection), "check": self.db_check(connection)}
1005 
1006     def convert_empty_strings(self, value, expression, connection):
1007         if (not value) and isinstance(value, str):
1008             return None
1009         return value
1010 
1011     def get_db_converters(self, connection):
1012         converters = super().get_db_converters(connection)
1013         if connection.features.interprets_empty_strings_as_nulls:
1014             converters += [self.convert_empty_strings]
1015         return converters
1016 
1017     def get_col(self, alias, output_field=None):
1018         if output_field is None:
1019             output_field = self.target_field
1020             while isinstance(output_field, ForeignKey):
1021                 output_field = output_field.target_field
1022                 if output_field is self:
1023                     raise ValueError('Cannot resolve output_field.')
1024         return super().get_col(alias, output_field)
1025 
1026 
1027 class OneToOneField(ForeignKey):
1028     """
1029     A OneToOneField is essentially the same as a ForeignKey, with the exception
1030     that it always carries a "unique" constraint with it and the reverse
1031     relation always returns the object pointed to (since there will only ever
1032     be one), rather than returning a list.
1033     """
1034 
1035     # Field flags
1036     many_to_many = False
1037     many_to_one = False
1038     one_to_many = False
1039     one_to_one = True
1040 
1041     related_accessor_class = ReverseOneToOneDescriptor
1042     forward_related_accessor_class = ForwardOneToOneDescriptor
1043     rel_class = OneToOneRel
1044 
1045     description = _("One-to-one relationship")
1046 
1047     def __init__(self, to, on_delete, to_field=None, **kwargs):
1048         kwargs['unique'] = True
1049         super().__init__(to, on_delete, to_field=to_field, **kwargs)
1050 
1051     def deconstruct(self):
1052         name, path, args, kwargs = super().deconstruct()
1053         if "unique" in kwargs:
1054             del kwargs['unique']
1055         return name, path, args, kwargs
1056 
1057     def formfield(self, **kwargs):
1058         if self.remote_field.parent_link:
1059             return None
1060         return super().formfield(**kwargs)
1061 
1062     def save_form_data(self, instance, data):
1063         if isinstance(data, self.remote_field.model):
1064             setattr(instance, self.name, data)
1065         else:
1066             setattr(instance, self.attname, data)
1067             # Remote field object must be cleared otherwise Model.save()
1068             # will reassign attname using the related object pk.
1069             if data is None:
1070                 setattr(instance, self.name, data)
1071 
1072     def _check_unique(self, **kwargs):
1073         # Override ForeignKey since check isn't applicable here.
1074         return []
1075 
1076 
1077 def create_many_to_many_intermediary_model(field, klass):
1078     from django.db import models
1079 
1080     def set_managed(model, related, through):
1081         through._meta.managed = model._meta.managed or related._meta.managed
1082 
1083     to_model = resolve_relation(klass, field.remote_field.model)
1084     name = '%s_%s' % (klass._meta.object_name, field.name)
1085     lazy_related_operation(set_managed, klass, to_model, name)
1086 
1087     to = make_model_tuple(to_model)[1]
1088     from_ = klass._meta.model_name
1089     if to == from_:
1090         to = 'to_%s' % to
1091         from_ = 'from_%s' % from_
1092 
1093     meta = type('Meta', (), {
1094         'db_table': field._get_m2m_db_table(klass._meta),
1095         'auto_created': klass,
1096         'app_label': klass._meta.app_label,
1097         'db_tablespace': klass._meta.db_tablespace,
1098         'unique_together': (from_, to),
1099         'verbose_name': _('%(from)s-%(to)s relationship') % {'from': from_, 'to': to},
1100         'verbose_name_plural': _('%(from)s-%(to)s relationships') % {'from': from_, 'to': to},
1101         'apps': field.model._meta.apps,
1102     })
1103     # Construct and return the new class.
1104     return type(name, (models.Model,), {
1105         'Meta': meta,
1106         '__module__': klass.__module__,
1107         from_: models.ForeignKey(
1108             klass,
1109             related_name='%s+' % name,
1110             db_tablespace=field.db_tablespace,
1111             db_constraint=field.remote_field.db_constraint,
1112             on_delete=CASCADE,
1113         ),
1114         to: models.ForeignKey(
1115             to_model,
1116             related_name='%s+' % name,
1117             db_tablespace=field.db_tablespace,
1118             db_constraint=field.remote_field.db_constraint,
1119             on_delete=CASCADE,
1120         )
1121     })
1122 
1123 
1124 class ManyToManyField(RelatedField):
1125     """
1126     Provide a many-to-many relation by using an intermediary model that
1127     holds two ForeignKey fields pointed at the two sides of the relation.
1128 
1129     Unless a ``through`` model was provided, ManyToManyField will use the
1130     create_many_to_many_intermediary_model factory to automatically generate
1131     the intermediary model.
1132     """
1133 
1134     # Field flags
1135     many_to_many = True
1136     many_to_one = False
1137     one_to_many = False
1138     one_to_one = False
1139 
1140     rel_class = ManyToManyRel
1141 
1142     description = _("Many-to-many relationship")
1143 
1144     def __init__(self, to, related_name=None, related_query_name=None,
1145                  limit_choices_to=None, symmetrical=None, through=None,
1146                  through_fields=None, db_constraint=True, db_table=None,
1147                  swappable=True, **kwargs):
1148         try:
1149             to._meta
1150         except AttributeError:
1151             assert isinstance(to, str), (
1152                 "%s(%r) is invalid. First parameter to ManyToManyField must be "
1153                 "either a model, a model name, or the string %r" %
1154                 (self.__class__.__name__, to, RECURSIVE_RELATIONSHIP_CONSTANT)
1155             )
1156 
1157         if symmetrical is None:
1158             symmetrical = (to == RECURSIVE_RELATIONSHIP_CONSTANT)
1159 
1160         if through is not None:
1161             assert db_table is None, (
1162                 "Cannot specify a db_table if an intermediary model is used."
1163             )
1164 
1165         kwargs['rel'] = self.rel_class(
1166             self, to,
1167             related_name=related_name,
1168             related_query_name=related_query_name,
1169             limit_choices_to=limit_choices_to,
1170             symmetrical=symmetrical,
1171             through=through,
1172             through_fields=through_fields,
1173             db_constraint=db_constraint,
1174         )
1175         self.has_null_arg = 'null' in kwargs
1176 
1177         super().__init__(**kwargs)
1178 
1179         self.db_table = db_table
1180         self.swappable = swappable
1181 
1182     def check(self, **kwargs):
1183         return [
1184             *super().check(**kwargs),
1185             *self._check_unique(**kwargs),
1186             *self._check_relationship_model(**kwargs),
1187             *self._check_ignored_options(**kwargs),
1188             *self._check_table_uniqueness(**kwargs),
1189         ]
1190 
1191     def _check_unique(self, **kwargs):
1192         if self.unique:
1193             return [
1194                 checks.Error(
1195                     'ManyToManyFields cannot be unique.',
1196                     obj=self,
1197                     id='fields.E330',
1198                 )
1199             ]
1200         return []
1201 
1202     def _check_ignored_options(self, **kwargs):
1203         warnings = []
1204 
1205         if self.has_null_arg:
1206             warnings.append(
1207                 checks.Warning(
1208                     'null has no effect on ManyToManyField.',
1209                     obj=self,
1210                     id='fields.W340',
1211                 )
1212             )
1213 
1214         if self._validators:
1215             warnings.append(
1216                 checks.Warning(
1217                     'ManyToManyField does not support validators.',
1218                     obj=self,
1219                     id='fields.W341',
1220                 )
1221             )
1222         if (self.remote_field.limit_choices_to and self.remote_field.through and
1223                 not self.remote_field.through._meta.auto_created):
1224             warnings.append(
1225                 checks.Warning(
1226                     'limit_choices_to has no effect on ManyToManyField '
1227                     'with a through model.',
1228                     obj=self,
1229                     id='fields.W343',
1230                 )
1231             )
1232 
1233         return warnings
1234 
1235     def _check_relationship_model(self, from_model=None, **kwargs):
1236         if hasattr(self.remote_field.through, '_meta'):
1237             qualified_model_name = "%s.%s" % (
1238                 self.remote_field.through._meta.app_label, self.remote_field.through.__name__)
1239         else:
1240             qualified_model_name = self.remote_field.through
1241 
1242         errors = []
1243 
1244         if self.remote_field.through not in self.opts.apps.get_models(include_auto_created=True):
1245             # The relationship model is not installed.
1246             errors.append(
1247                 checks.Error(
1248                     "Field specifies a many-to-many relation through model "
1249                     "'%s', which has not been installed." % qualified_model_name,
1250                     obj=self,
1251                     id='fields.E331',
1252                 )
1253             )
1254 
1255         else:
1256             assert from_model is not None, (
1257                 "ManyToManyField with intermediate "
1258                 "tables cannot be checked if you don't pass the model "
1259                 "where the field is attached to."
1260             )
1261             # Set some useful local variables
1262             to_model = resolve_relation(from_model, self.remote_field.model)
1263             from_model_name = from_model._meta.object_name
1264             if isinstance(to_model, str):
1265                 to_model_name = to_model
1266             else:
1267                 to_model_name = to_model._meta.object_name
1268             relationship_model_name = self.remote_field.through._meta.object_name
1269             self_referential = from_model == to_model
1270             # Count foreign keys in intermediate model
1271             if self_referential:
1272                 seen_self = sum(
1273                     from_model == getattr(field.remote_field, 'model', None)
1274                     for field in self.remote_field.through._meta.fields
1275                 )
1276 
1277                 if seen_self > 2 and not self.remote_field.through_fields:
1278                     errors.append(
1279                         checks.Error(
1280                             "The model is used as an intermediate model by "
1281                             "'%s', but it has more than two foreign keys "
1282                             "to '%s', which is ambiguous. You must specify "
1283                             "which two foreign keys Django should use via the "
1284                             "through_fields keyword argument." % (self, from_model_name),
1285                             hint="Use through_fields to specify which two foreign keys Django should use.",
1286                             obj=self.remote_field.through,
1287                             id='fields.E333',
1288                         )
1289                     )
1290 
1291             else:
1292                 # Count foreign keys in relationship model
1293                 seen_from = sum(
1294                     from_model == getattr(field.remote_field, 'model', None)
1295                     for field in self.remote_field.through._meta.fields
1296                 )
1297                 seen_to = sum(
1298                     to_model == getattr(field.remote_field, 'model', None)
1299                     for field in self.remote_field.through._meta.fields
1300                 )
1301 
1302                 if seen_from > 1 and not self.remote_field.through_fields:
1303                     errors.append(
1304                         checks.Error(
1305                             ("The model is used as an intermediate model by "
1306                              "'%s', but it has more than one foreign key "
1307                              "from '%s', which is ambiguous. You must specify "
1308                              "which foreign key Django should use via the "
1309                              "through_fields keyword argument.") % (self, from_model_name),
1310                             hint=(
1311                                 'If you want to create a recursive relationship, '
1312                                 'use ManyToManyField("%s", through="%s").'
1313                             ) % (
1314                                 RECURSIVE_RELATIONSHIP_CONSTANT,
1315                                 relationship_model_name,
1316                             ),
1317                             obj=self,
1318                             id='fields.E334',
1319                         )
1320                     )
1321 
1322                 if seen_to > 1 and not self.remote_field.through_fields:
1323                     errors.append(
1324                         checks.Error(
1325                             "The model is used as an intermediate model by "
1326                             "'%s', but it has more than one foreign key "
1327                             "to '%s', which is ambiguous. You must specify "
1328                             "which foreign key Django should use via the "
1329                             "through_fields keyword argument." % (self, to_model_name),
1330                             hint=(
1331                                 'If you want to create a recursive relationship, '
1332                                 'use ManyToManyField("%s", through="%s").'
1333                             ) % (
1334                                 RECURSIVE_RELATIONSHIP_CONSTANT,
1335                                 relationship_model_name,
1336                             ),
1337                             obj=self,
1338                             id='fields.E335',
1339                         )
1340                     )
1341 
1342                 if seen_from == 0 or seen_to == 0:
1343                     errors.append(
1344                         checks.Error(
1345                             "The model is used as an intermediate model by "
1346                             "'%s', but it does not have a foreign key to '%s' or '%s'." % (
1347                                 self, from_model_name, to_model_name
1348                             ),
1349                             obj=self.remote_field.through,
1350                             id='fields.E336',
1351                         )
1352                     )
1353 
1354         # Validate `through_fields`.
1355         if self.remote_field.through_fields is not None:
1356             # Validate that we're given an iterable of at least two items
1357             # and that none of them is "falsy".
1358             if not (len(self.remote_field.through_fields) >= 2 and
1359                     self.remote_field.through_fields[0] and self.remote_field.through_fields[1]):
1360                 errors.append(
1361                     checks.Error(
1362                         "Field specifies 'through_fields' but does not provide "
1363                         "the names of the two link fields that should be used "
1364                         "for the relation through model '%s'." % qualified_model_name,
1365                         hint="Make sure you specify 'through_fields' as through_fields=('field1', 'field2')",
1366                         obj=self,
1367                         id='fields.E337',
1368                     )
1369                 )
1370 
1371             # Validate the given through fields -- they should be actual
1372             # fields on the through model, and also be foreign keys to the
1373             # expected models.
1374             else:
1375                 assert from_model is not None, (
1376                     "ManyToManyField with intermediate "
1377                     "tables cannot be checked if you don't pass the model "
1378                     "where the field is attached to."
1379                 )
1380 
1381                 source, through, target = from_model, self.remote_field.through, self.remote_field.model
1382                 source_field_name, target_field_name = self.remote_field.through_fields[:2]
1383 
1384                 for field_name, related_model in ((source_field_name, source),
1385                                                   (target_field_name, target)):
1386 
1387                     possible_field_names = []
1388                     for f in through._meta.fields:
1389                         if hasattr(f, 'remote_field') and getattr(f.remote_field, 'model', None) == related_model:
1390                             possible_field_names.append(f.name)
1391                     if possible_field_names:
1392                         hint = "Did you mean one of the following foreign keys to '%s': %s?" % (
1393                             related_model._meta.object_name,
1394                             ', '.join(possible_field_names),
1395                         )
1396                     else:
1397                         hint = None
1398 
1399                     try:
1400                         field = through._meta.get_field(field_name)
1401                     except exceptions.FieldDoesNotExist:
1402                         errors.append(
1403                             checks.Error(
1404                                 "The intermediary model '%s' has no field '%s'."
1405                                 % (qualified_model_name, field_name),
1406                                 hint=hint,
1407                                 obj=self,
1408                                 id='fields.E338',
1409                             )
1410                         )
1411                     else:
1412                         if not (hasattr(field, 'remote_field') and
1413                                 getattr(field.remote_field, 'model', None) == related_model):
1414                             errors.append(
1415                                 checks.Error(
1416                                     "'%s.%s' is not a foreign key to '%s'." % (
1417                                         through._meta.object_name, field_name,
1418                                         related_model._meta.object_name,
1419                                     ),
1420                                     hint=hint,
1421                                     obj=self,
1422                                     id='fields.E339',
1423                                 )
1424                             )
1425 
1426         return errors
1427 
1428     def _check_table_uniqueness(self, **kwargs):
1429         if isinstance(self.remote_field.through, str) or not self.remote_field.through._meta.managed:
1430             return []
1431         registered_tables = {
1432             model._meta.db_table: model
1433             for model in self.opts.apps.get_models(include_auto_created=True)
1434             if model != self.remote_field.through and model._meta.managed
1435         }
1436         m2m_db_table = self.m2m_db_table()
1437         model = registered_tables.get(m2m_db_table)
1438         # The second condition allows multiple m2m relations on a model if
1439         # some point to a through model that proxies another through model.
1440         if model and model._meta.concrete_model != self.remote_field.through._meta.concrete_model:
1441             if model._meta.auto_created:
1442                 def _get_field_name(model):
1443                     for field in model._meta.auto_created._meta.many_to_many:
1444                         if field.remote_field.through is model:
1445                             return field.name
1446                 opts = model._meta.auto_created._meta
1447                 clashing_obj = '%s.%s' % (opts.label, _get_field_name(model))
1448             else:
1449                 clashing_obj = model._meta.label
1450             if settings.DATABASE_ROUTERS:
1451                 error_class, error_id = checks.Warning, 'fields.W344'
1452                 error_hint = (
1453                     'You have configured settings.DATABASE_ROUTERS. Verify '
1454                     'that the table of %r is correctly routed to a separate '
1455                     'database.' % clashing_obj
1456                 )
1457             else:
1458                 error_class, error_id = checks.Error, 'fields.E340'
1459                 error_hint = None
1460             return [
1461                 error_class(
1462                     "The field's intermediary table '%s' clashes with the "
1463                     "table name of '%s'." % (m2m_db_table, clashing_obj),
1464                     obj=self,
1465                     hint=error_hint,
1466                     id=error_id,
1467                 )
1468             ]
1469         return []
1470 
1471     def deconstruct(self):
1472         name, path, args, kwargs = super().deconstruct()
1473         # Handle the simpler arguments.
1474         if self.db_table is not None:
1475             kwargs['db_table'] = self.db_table
1476         if self.remote_field.db_constraint is not True:
1477             kwargs['db_constraint'] = self.remote_field.db_constraint
1478         # Rel needs more work.
1479         if isinstance(self.remote_field.model, str):
1480             kwargs['to'] = self.remote_field.model
1481         else:
1482             kwargs['to'] = self.remote_field.model._meta.label
1483         if getattr(self.remote_field, 'through', None) is not None:
1484             if isinstance(self.remote_field.through, str):
1485                 kwargs['through'] = self.remote_field.through
1486             elif not self.remote_field.through._meta.auto_created:
1487                 kwargs['through'] = self.remote_field.through._meta.label
1488         # If swappable is True, then see if we're actually pointing to the target
1489         # of a swap.
1490         swappable_setting = self.swappable_setting
1491         if swappable_setting is not None:
1492             # If it's already a settings reference, error.
1493             if hasattr(kwargs['to'], "setting_name"):
1494                 if kwargs['to'].setting_name != swappable_setting:
1495                     raise ValueError(
1496                         "Cannot deconstruct a ManyToManyField pointing to a "
1497                         "model that is swapped in place of more than one model "
1498                         "(%s and %s)" % (kwargs['to'].setting_name, swappable_setting)
1499                     )
1500 
1501             kwargs['to'] = SettingsReference(
1502                 kwargs['to'],
1503                 swappable_setting,
1504             )
1505         return name, path, args, kwargs
1506 
1507     def _get_path_info(self, direct=False, filtered_relation=None):
1508         """Called by both direct and indirect m2m traversal."""
1509         int_model = self.remote_field.through
1510         linkfield1 = int_model._meta.get_field(self.m2m_field_name())
1511         linkfield2 = int_model._meta.get_field(self.m2m_reverse_field_name())
1512         if direct:
1513             join1infos = linkfield1.get_reverse_path_info()
1514             join2infos = linkfield2.get_path_info(filtered_relation)
1515         else:
1516             join1infos = linkfield2.get_reverse_path_info()
1517             join2infos = linkfield1.get_path_info(filtered_relation)
1518 
1519         # Get join infos between the last model of join 1 and the first model
1520         # of join 2. Assume the only reason these may differ is due to model
1521         # inheritance.
1522         join1_final = join1infos[-1].to_opts
1523         join2_initial = join2infos[0].from_opts
1524         if join1_final is join2_initial:
1525             intermediate_infos = []
1526         elif issubclass(join1_final.model, join2_initial.model):
1527             intermediate_infos = join1_final.get_path_to_parent(join2_initial.model)
1528         else:
1529             intermediate_infos = join2_initial.get_path_from_parent(join1_final.model)
1530 
1531         return [*join1infos, *intermediate_infos, *join2infos]
1532 
1533     def get_path_info(self, filtered_relation=None):
1534         return self._get_path_info(direct=True, filtered_relation=filtered_relation)
1535 
1536     def get_reverse_path_info(self, filtered_relation=None):
1537         return self._get_path_info(direct=False, filtered_relation=filtered_relation)
1538 
1539     def _get_m2m_db_table(self, opts):
1540         """
1541         Function that can be curried to provide the m2m table name for this
1542         relation.
1543         """
1544         if self.remote_field.through is not None:
1545             return self.remote_field.through._meta.db_table
1546         elif self.db_table:
1547             return self.db_table
1548         else:
1549             m2m_table_name = '%s_%s' % (utils.strip_quotes(opts.db_table), self.name)
1550             return utils.truncate_name(m2m_table_name, connection.ops.max_name_length())
1551 
1552     def _get_m2m_attr(self, related, attr):
1553         """
1554         Function that can be curried to provide the source accessor or DB
1555         column name for the m2m table.
1556         """
1557         cache_attr = '_m2m_%s_cache' % attr
1558         if hasattr(self, cache_attr):
1559             return getattr(self, cache_attr)
1560         if self.remote_field.through_fields is not None:
1561             link_field_name = self.remote_field.through_fields[0]
1562         else:
1563             link_field_name = None
1564         for f in self.remote_field.through._meta.fields:
1565             if (f.is_relation and f.remote_field.model == related.related_model and
1566                     (link_field_name is None or link_field_name == f.name)):
1567                 setattr(self, cache_attr, getattr(f, attr))
1568                 return getattr(self, cache_attr)
1569 
1570     def _get_m2m_reverse_attr(self, related, attr):
1571         """
1572         Function that can be curried to provide the related accessor or DB
1573         column name for the m2m table.
1574         """
1575         cache_attr = '_m2m_reverse_%s_cache' % attr
1576         if hasattr(self, cache_attr):
1577             return getattr(self, cache_attr)
1578         found = False
1579         if self.remote_field.through_fields is not None:
1580             link_field_name = self.remote_field.through_fields[1]
1581         else:
1582             link_field_name = None
1583         for f in self.remote_field.through._meta.fields:
1584             if f.is_relation and f.remote_field.model == related.model:
1585                 if link_field_name is None and related.related_model == related.model:
1586                     # If this is an m2m-intermediate to self,
1587                     # the first foreign key you find will be
1588                     # the source column. Keep searching for
1589                     # the second foreign key.
1590                     if found:
1591                         setattr(self, cache_attr, getattr(f, attr))
1592                         break
1593                     else:
1594                         found = True
1595                 elif link_field_name is None or link_field_name == f.name:
1596                     setattr(self, cache_attr, getattr(f, attr))
1597                     break
1598         return getattr(self, cache_attr)
1599 
1600     def contribute_to_class(self, cls, name, **kwargs):
1601         # To support multiple relations to self, it's useful to have a non-None
1602         # related name on symmetrical relations for internal reasons. The
1603         # concept doesn't make a lot of sense externally ("you want me to
1604         # specify *what* on my non-reversible relation?!"), so we set it up
1605         # automatically. The funky name reduces the chance of an accidental
1606         # clash.
1607         if self.remote_field.symmetrical and (
1608             self.remote_field.model == RECURSIVE_RELATIONSHIP_CONSTANT or
1609             self.remote_field.model == cls._meta.object_name
1610         ):
1611             self.remote_field.related_name = "%s_rel_+" % name
1612         elif self.remote_field.is_hidden():
1613             # If the backwards relation is disabled, replace the original
1614             # related_name with one generated from the m2m field name. Django
1615             # still uses backwards relations internally and we need to avoid
1616             # clashes between multiple m2m fields with related_name == '+'.
1617             self.remote_field.related_name = "_%s_%s_+" % (cls.__name__.lower(), name)
1618 
1619         super().contribute_to_class(cls, name, **kwargs)
1620 
1621         # The intermediate m2m model is not auto created if:
1622         #  1) There is a manually specified intermediate, or
1623         #  2) The class owning the m2m field is abstract.
1624         #  3) The class owning the m2m field has been swapped out.
1625         if not cls._meta.abstract:
1626             if self.remote_field.through:
1627                 def resolve_through_model(_, model, field):
1628                     field.remote_field.through = model
1629                 lazy_related_operation(resolve_through_model, cls, self.remote_field.through, field=self)
1630             elif not cls._meta.swapped:
1631                 self.remote_field.through = create_many_to_many_intermediary_model(self, cls)
1632 
1633         # Add the descriptor for the m2m relation.
1634         setattr(cls, self.name, ManyToManyDescriptor(self.remote_field, reverse=False))
1635 
1636         # Set up the accessor for the m2m table name for the relation.
1637         self.m2m_db_table = partial(self._get_m2m_db_table, cls._meta)
1638 
1639     def contribute_to_related_class(self, cls, related):
1640         # Internal M2Ms (i.e., those with a related name ending with '+')
1641         # and swapped models don't get a related descriptor.
1642         if not self.remote_field.is_hidden() and not related.related_model._meta.swapped:
1643             setattr(cls, related.get_accessor_name(), ManyToManyDescriptor(self.remote_field, reverse=True))
1644 
1645         # Set up the accessors for the column names on the m2m table.
1646         self.m2m_column_name = partial(self._get_m2m_attr, related, 'column')
1647         self.m2m_reverse_name = partial(self._get_m2m_reverse_attr, related, 'column')
1648 
1649         self.m2m_field_name = partial(self._get_m2m_attr, related, 'name')
1650         self.m2m_reverse_field_name = partial(self._get_m2m_reverse_attr, related, 'name')
1651 
1652         get_m2m_rel = partial(self._get_m2m_attr, related, 'remote_field')
1653         self.m2m_target_field_name = lambda: get_m2m_rel().field_name
1654         get_m2m_reverse_rel = partial(self._get_m2m_reverse_attr, related, 'remote_field')
1655         self.m2m_reverse_target_field_name = lambda: get_m2m_reverse_rel().field_name
1656 
1657     def set_attributes_from_rel(self):
1658         pass
1659 
1660     def value_from_object(self, obj):
1661         return [] if obj.pk is None else list(getattr(obj, self.attname).all())
1662 
1663     def save_form_data(self, instance, data):
1664         getattr(instance, self.attname).set(data)
1665 
1666     def formfield(self, *, using=None, **kwargs):
1667         defaults = {
1668             'form_class': forms.ModelMultipleChoiceField,
1669             'queryset': self.remote_field.model._default_manager.using(using),
1670             **kwargs,
1671         }
1672         # If initial is passed in, it's a list of related objects, but the
1673         # MultipleChoiceField takes a list of IDs.
1674         if defaults.get('initial') is not None:
1675             initial = defaults['initial']
1676             if callable(initial):
1677                 initial = initial()
1678             defaults['initial'] = [i.pk for i in initial]
1679         return super().formfield(**defaults)
1680 
1681     def db_check(self, connection):
1682         return None
1683 
1684     def db_type(self, connection):
1685         # A ManyToManyField is not represented by a single column,
1686         # so return None.
1687         return None
1688 
1689     def db_parameters(self, connection):
1690         return {"type": None, "check": None}

</code><intended_behavior>Ensure that the usage of 'related_name='+' does not lead to conflicts during migration generation, effectively isolating the many-to-many relationships as per the design goal of using 'related_name='+'.</intended_behavior>]
2025-10-18 12:32:46.564 | INFO     | Search completed. Bug locations: [<file>django/db/migrations/state.py</file>
<class>None</class>
<method>None</method>
<code>
1 import copy
2 from contextlib import contextmanager
3 
4 from django.apps import AppConfig
5 from django.apps.registry import Apps, apps as global_apps
6 from django.conf import settings
7 from django.db import models
8 from django.db.models.fields.related import RECURSIVE_RELATIONSHIP_CONSTANT
9 from django.db.models.options import DEFAULT_NAMES, normalize_together
10 from django.db.models.utils import make_model_tuple
11 from django.utils.functional import cached_property
12 from django.utils.module_loading import import_string
13 from django.utils.version import get_docs_version
14 
15 from .exceptions import InvalidBasesError
16 
17 
18 def _get_app_label_and_model_name(model, app_label=''):
19     if isinstance(model, str):
20         split = model.split('.', 1)
21         return tuple(split) if len(split) == 2 else (app_label, split[0])
22     else:
23         return model._meta.app_label, model._meta.model_name
24 
25 
26 def _get_related_models(m):
27     """Return all models that have a direct relationship to the given model."""
28     related_models = [
29         subclass for subclass in m.__subclasses__()
30         if issubclass(subclass, models.Model)
31     ]
32     related_fields_models = set()
33     for f in m._meta.get_fields(include_parents=True, include_hidden=True):
34         if f.is_relation and f.related_model is not None and not isinstance(f.related_model, str):
35             related_fields_models.add(f.model)
36             related_models.append(f.related_model)
37     # Reverse accessors of foreign keys to proxy models are attached to their
38     # concrete proxied model.
39     opts = m._meta
40     if opts.proxy and m in related_fields_models:
41         related_models.append(opts.concrete_model)
42     return related_models
43 
44 
45 def get_related_models_tuples(model):
46     """
47     Return a list of typical (app_label, model_name) tuples for all related
48     models for the given model.
49     """
50     return {
51         (rel_mod._meta.app_label, rel_mod._meta.model_name)
52         for rel_mod in _get_related_models(model)
53     }
54 
55 
56 def get_related_models_recursive(model):
57     """
58     Return all models that have a direct or indirect relationship
59     to the given model.
60 
61     Relationships are either defined by explicit relational fields, like
62     ForeignKey, ManyToManyField or OneToOneField, or by inheriting from another
63     model (a superclass is related to its subclasses, but not vice versa). Note,
64     however, that a model inheriting from a concrete model is also related to
65     its superclass through the implicit *_ptr OneToOneField on the subclass.
66     """
67     seen = set()
68     queue = _get_related_models(model)
69     for rel_mod in queue:
70         rel_app_label, rel_model_name = rel_mod._meta.app_label, rel_mod._meta.model_name
71         if (rel_app_label, rel_model_name) in seen:
72             continue
73         seen.add((rel_app_label, rel_model_name))
74         queue.extend(_get_related_models(rel_mod))
75     return seen - {(model._meta.app_label, model._meta.model_name)}
76 
77 
78 class ProjectState:
79     """
80     Represent the entire project's overall state. This is the item that is
81     passed around - do it here rather than at the app level so that cross-app
82     FKs/etc. resolve properly.
83     """
84 
85     def __init__(self, models=None, real_apps=None):
86         self.models = models or {}
87         # Apps to include from main registry, usually unmigrated ones
88         self.real_apps = real_apps or []
89         self.is_delayed = False
90 
91     def add_model(self, model_state):
92         app_label, model_name = model_state.app_label, model_state.name_lower
93         self.models[(app_label, model_name)] = model_state
94         if 'apps' in self.__dict__:  # hasattr would cache the property
95             self.reload_model(app_label, model_name)
96 
97     def remove_model(self, app_label, model_name):
98         del self.models[app_label, model_name]
99         if 'apps' in self.__dict__:  # hasattr would cache the property
100             self.apps.unregister_model(app_label, model_name)
101             # Need to do this explicitly since unregister_model() doesn't clear
102             # the cache automatically (#24513)
103             self.apps.clear_cache()
104 
105     def _find_reload_model(self, app_label, model_name, delay=False):
106         if delay:
107             self.is_delayed = True
108 
109         related_models = set()
110 
111         try:
112             old_model = self.apps.get_model(app_label, model_name)
113         except LookupError:
114             pass
115         else:
116             # Get all relations to and from the old model before reloading,
117             # as _meta.apps may change
118             if delay:
119                 related_models = get_related_models_tuples(old_model)
120             else:
121                 related_models = get_related_models_recursive(old_model)
122 
123         # Get all outgoing references from the model to be rendered
124         model_state = self.models[(app_label, model_name)]
125         # Directly related models are the models pointed to by ForeignKeys,
126         # OneToOneFields, and ManyToManyFields.
127         direct_related_models = set()
128         for field in model_state.fields.values():
129             if field.is_relation:
130                 if field.remote_field.model == RECURSIVE_RELATIONSHIP_CONSTANT:
131                     continue
132                 rel_app_label, rel_model_name = _get_app_label_and_model_name(field.related_model, app_label)
133                 direct_related_models.add((rel_app_label, rel_model_name.lower()))
134 
135         # For all direct related models recursively get all related models.
136         related_models.update(direct_related_models)
137         for rel_app_label, rel_model_name in direct_related_models:
138             try:
139                 rel_model = self.apps.get_model(rel_app_label, rel_model_name)
140             except LookupError:
141                 pass
142             else:
143                 if delay:
144                     related_models.update(get_related_models_tuples(rel_model))
145                 else:
146                     related_models.update(get_related_models_recursive(rel_model))
147 
148         # Include the model itself
149         related_models.add((app_label, model_name))
150 
151         return related_models
152 
153     def reload_model(self, app_label, model_name, delay=False):
154         if 'apps' in self.__dict__:  # hasattr would cache the property
155             related_models = self._find_reload_model(app_label, model_name, delay)
156             self._reload(related_models)
157 
158     def reload_models(self, models, delay=True):
159         if 'apps' in self.__dict__:  # hasattr would cache the property
160             related_models = set()
161             for app_label, model_name in models:
162                 related_models.update(self._find_reload_model(app_label, model_name, delay))
163             self._reload(related_models)
164 
165     def _reload(self, related_models):
166         # Unregister all related models
167         with self.apps.bulk_update():
168             for rel_app_label, rel_model_name in related_models:
169                 self.apps.unregister_model(rel_app_label, rel_model_name)
170 
171         states_to_be_rendered = []
172         # Gather all models states of those models that will be rerendered.
173         # This includes:
174         # 1. All related models of unmigrated apps
175         for model_state in self.apps.real_models:
176             if (model_state.app_label, model_state.name_lower) in related_models:
177                 states_to_be_rendered.append(model_state)
178 
179         # 2. All related models of migrated apps
180         for rel_app_label, rel_model_name in related_models:
181             try:
182                 model_state = self.models[rel_app_label, rel_model_name]
183             except KeyError:
184                 pass
185             else:
186                 states_to_be_rendered.append(model_state)
187 
188         # Render all models
189         self.apps.render_multiple(states_to_be_rendered)
190 
191     def clone(self):
192         """Return an exact copy of this ProjectState."""
193         new_state = ProjectState(
194             models={k: v.clone() for k, v in self.models.items()},
195             real_apps=self.real_apps,
196         )
197         if 'apps' in self.__dict__:
198             new_state.apps = self.apps.clone()
199         new_state.is_delayed = self.is_delayed
200         return new_state
201 
202     def clear_delayed_apps_cache(self):
203         if self.is_delayed and 'apps' in self.__dict__:
204             del self.__dict__['apps']
205 
206     @cached_property
207     def apps(self):
208         return StateApps(self.real_apps, self.models)
209 
210     @property
211     def concrete_apps(self):
212         self.apps = StateApps(self.real_apps, self.models, ignore_swappable=True)
213         return self.apps
214 
215     @classmethod
216     def from_apps(cls, apps):
217         """Take an Apps and return a ProjectState matching it."""
218         app_models = {}
219         for model in apps.get_models(include_swapped=True):
220             model_state = ModelState.from_model(model)
221             app_models[(model_state.app_label, model_state.name_lower)] = model_state
222         return cls(app_models)
223 
224     def __eq__(self, other):
225         return self.models == other.models and set(self.real_apps) == set(other.real_apps)
226 
227 
228 class AppConfigStub(AppConfig):
229     """Stub of an AppConfig. Only provides a label and a dict of models."""
230     def __init__(self, label):
231         self.apps = None
232         self.models = {}
233         # App-label and app-name are not the same thing, so technically passing
234         # in the label here is wrong. In practice, migrations don't care about
235         # the app name, but we need something unique, and the label works fine.
236         self.label = label
237         self.name = label
238 
239     def import_models(self):
240         self.models = self.apps.all_models[self.label]
241 
242 
243 class StateApps(Apps):
244     """
245     Subclass of the global Apps registry class to better handle dynamic model
246     additions and removals.
247     """
248     def __init__(self, real_apps, models, ignore_swappable=False):
249         # Any apps in self.real_apps should have all their models included
250         # in the render. We don't use the original model instances as there
251         # are some variables that refer to the Apps object.
252         # FKs/M2Ms from real apps are also not included as they just
253         # mess things up with partial states (due to lack of dependencies)
254         self.real_models = []
255         for app_label in real_apps:
256             app = global_apps.get_app_config(app_label)
257             for model in app.get_models():
258                 self.real_models.append(ModelState.from_model(model, exclude_rels=True))
259         # Populate the app registry with a stub for each application.
260         app_labels = {model_state.app_label for model_state in models.values()}
261         app_configs = [AppConfigStub(label) for label in sorted([*real_apps, *app_labels])]
262         super().__init__(app_configs)
263 
264         # These locks get in the way of copying as implemented in clone(),
265         # which is called whenever Django duplicates a StateApps before
266         # updating it.
267         self._lock = None
268         self.ready_event = None
269 
270         self.render_multiple([*models.values(), *self.real_models])
271 
272         # There shouldn't be any operations pending at this point.
273         from django.core.checks.model_checks import _check_lazy_references
274         ignore = {make_model_tuple(settings.AUTH_USER_MODEL)} if ignore_swappable else set()
275         errors = _check_lazy_references(self, ignore=ignore)
276         if errors:
277             raise ValueError("\n".join(error.msg for error in errors))
278 
279     @contextmanager
280     def bulk_update(self):
281         # Avoid clearing each model's cache for each change. Instead, clear
282         # all caches when we're finished updating the model instances.
283         ready = self.ready
284         self.ready = False
285         try:
286             yield
287         finally:
288             self.ready = ready
289             self.clear_cache()
290 
291     def render_multiple(self, model_states):
292         # We keep trying to render the models in a loop, ignoring invalid
293         # base errors, until the size of the unrendered models doesn't
294         # decrease by at least one, meaning there's a base dependency loop/
295         # missing base.
296         if not model_states:
297             return
298         # Prevent that all model caches are expired for each render.
299         with self.bulk_update():
300             unrendered_models = model_states
301             while unrendered_models:
302                 new_unrendered_models = []
303                 for model in unrendered_models:
304                     try:
305                         model.render(self)
306                     except InvalidBasesError:
307                         new_unrendered_models.append(model)
308                 if len(new_unrendered_models) == len(unrendered_models):
309                     raise InvalidBasesError(
310                         "Cannot resolve bases for %r\nThis can happen if you are inheriting models from an "
311                         "app with migrations (e.g. contrib.auth)\n in an app with no migrations; see "
312                         "https://docs.djangoproject.com/en/%s/topics/migrations/#dependencies "
313                         "for more" % (new_unrendered_models, get_docs_version())
314                     )
315                 unrendered_models = new_unrendered_models
316 
317     def clone(self):
318         """Return a clone of this registry."""
319         clone = StateApps([], {})
320         clone.all_models = copy.deepcopy(self.all_models)
321         clone.app_configs = copy.deepcopy(self.app_configs)
322         # Set the pointer to the correct app registry.
323         for app_config in clone.app_configs.values():
324             app_config.apps = clone
325         # No need to actually clone them, they'll never change
326         clone.real_models = self.real_models
327         return clone
328 
329     def register_model(self, app_label, model):
330         self.all_models[app_label][model._meta.model_name] = model
331         if app_label not in self.app_configs:
332             self.app_configs[app_label] = AppConfigStub(app_label)
333             self.app_configs[app_label].apps = self
334         self.app_configs[app_label].models[model._meta.model_name] = model
335         self.do_pending_operations(model)
336         self.clear_cache()
337 
338     def unregister_model(self, app_label, model_name):
339         try:
340             del self.all_models[app_label][model_name]
341             del self.app_configs[app_label].models[model_name]
342         except KeyError:
343             pass
344 
345 
346 class ModelState:
347     """
348     Represent a Django Model. Don't use the actual Model class as it's not
349     designed to have its options changed - instead, mutate this one and then
350     render it into a Model as required.
351 
352     Note that while you are allowed to mutate .fields, you are not allowed
353     to mutate the Field instances inside there themselves - you must instead
354     assign new ones, as these are not detached during a clone.
355     """
356 
357     def __init__(self, app_label, name, fields, options=None, bases=None, managers=None):
358         self.app_label = app_label
359         self.name = name
360         self.fields = dict(fields)
361         self.options = options or {}
362         self.options.setdefault('indexes', [])
363         self.options.setdefault('constraints', [])
364         self.bases = bases or (models.Model,)
365         self.managers = managers or []
366         for name, field in self.fields.items():
367             # Sanity-check that fields are NOT already bound to a model.
368             if hasattr(field, 'model'):
369                 raise ValueError(
370                     'ModelState.fields cannot be bound to a model - "%s" is.' % name
371                 )
372             # Sanity-check that relation fields are NOT referring to a model class.
373             if field.is_relation and hasattr(field.related_model, '_meta'):
374                 raise ValueError(
375                     'ModelState.fields cannot refer to a model class - "%s.to" does. '
376                     'Use a string reference instead.' % name
377                 )
378             if field.many_to_many and hasattr(field.remote_field.through, '_meta'):
379                 raise ValueError(
380                     'ModelState.fields cannot refer to a model class - "%s.through" does. '
381                     'Use a string reference instead.' % name
382                 )
383         # Sanity-check that indexes have their name set.
384         for index in self.options['indexes']:
385             if not index.name:
386                 raise ValueError(
387                     "Indexes passed to ModelState require a name attribute. "
388                     "%r doesn't have one." % index
389                 )
390 
391     @cached_property
392     def name_lower(self):
393         return self.name.lower()
394 
395     @classmethod
396     def from_model(cls, model, exclude_rels=False):
397         """Given a model, return a ModelState representing it."""
398         # Deconstruct the fields
399         fields = []
400         for field in model._meta.local_fields:
401             if getattr(field, "remote_field", None) and exclude_rels:
402                 continue
403             if isinstance(field, models.OrderWrt):
404                 continue
405             name = field.name
406             try:
407                 fields.append((name, field.clone()))
408             except TypeError as e:
409                 raise TypeError("Couldn't reconstruct field %s on %s: %s" % (
410                     name,
411                     model._meta.label,
412                     e,
413                 ))
414         if not exclude_rels:
415             for field in model._meta.local_many_to_many:
416                 name = field.name
417                 try:
418                     fields.append((name, field.clone()))
419                 except TypeError as e:
420                     raise TypeError("Couldn't reconstruct m2m field %s on %s: %s" % (
421                         name,
422                         model._meta.object_name,
423                         e,
424                     ))
425         # Extract the options
426         options = {}
427         for name in DEFAULT_NAMES:
428             # Ignore some special options
429             if name in ["apps", "app_label"]:
430                 continue
431             elif name in model._meta.original_attrs:
432                 if name == "unique_together":
433                     ut = model._meta.original_attrs["unique_together"]
434                     options[name] = set(normalize_together(ut))
435                 elif name == "index_together":
436                     it = model._meta.original_attrs["index_together"]
437                     options[name] = set(normalize_together(it))
438                 elif name == "indexes":
439                     indexes = [idx.clone() for idx in model._meta.indexes]
440                     for index in indexes:
441                         if not index.name:
442                             index.set_name_with_model(model)
443                     options['indexes'] = indexes
444                 elif name == 'constraints':
445                     options['constraints'] = [con.clone() for con in model._meta.constraints]
446                 else:
447                     options[name] = model._meta.original_attrs[name]
448         # If we're ignoring relationships, remove all field-listing model
449         # options (that option basically just means "make a stub model")
450         if exclude_rels:
451             for key in ["unique_together", "index_together", "order_with_respect_to"]:
452                 if key in options:
453                     del options[key]
454         # Private fields are ignored, so remove options that refer to them.
455         elif options.get('order_with_respect_to') in {field.name for field in model._meta.private_fields}:
456             del options['order_with_respect_to']
457 
458         def flatten_bases(model):
459             bases = []
460             for base in model.__bases__:
461                 if hasattr(base, "_meta") and base._meta.abstract:
462                     bases.extend(flatten_bases(base))
463                 else:
464                     bases.append(base)
465             return bases
466 
467         # We can't rely on __mro__ directly because we only want to flatten
468         # abstract models and not the whole tree. However by recursing on
469         # __bases__ we may end up with duplicates and ordering issues, we
470         # therefore discard any duplicates and reorder the bases according
471         # to their index in the MRO.
472         flattened_bases = sorted(set(flatten_bases(model)), key=lambda x: model.__mro__.index(x))
473 
474         # Make our record
475         bases = tuple(
476             (
477                 base._meta.label_lower
478                 if hasattr(base, "_meta") else
479                 base
480             )
481             for base in flattened_bases
482         )
483         # Ensure at least one base inherits from models.Model
484         if not any((isinstance(base, str) or issubclass(base, models.Model)) for base in bases):
485             bases = (models.Model,)
486 
487         managers = []
488         manager_names = set()
489         default_manager_shim = None
490         for manager in model._meta.managers:
491             if manager.name in manager_names:
492                 # Skip overridden managers.
493                 continue
494             elif manager.use_in_migrations:
495                 # Copy managers usable in migrations.
496                 new_manager = copy.copy(manager)
497                 new_manager._set_creation_counter()
498             elif manager is model._base_manager or manager is model._default_manager:
499                 # Shim custom managers used as default and base managers.
500                 new_manager = models.Manager()
501                 new_manager.model = manager.model
502                 new_manager.name = manager.name
503                 if manager is model._default_manager:
504                     default_manager_shim = new_manager
505             else:
506                 continue
507             manager_names.add(manager.name)
508             managers.append((manager.name, new_manager))
509 
510         # Ignore a shimmed default manager called objects if it's the only one.
511         if managers == [('objects', default_manager_shim)]:
512             managers = []
513 
514         # Construct the new ModelState
515         return cls(
516             model._meta.app_label,
517             model._meta.object_name,
518             fields,
519             options,
520             bases,
521             managers,
522         )
523 
524     def construct_managers(self):
525         """Deep-clone the managers using deconstruction."""
526         # Sort all managers by their creation counter
527         sorted_managers = sorted(self.managers, key=lambda v: v[1].creation_counter)
528         for mgr_name, manager in sorted_managers:
529             as_manager, manager_path, qs_path, args, kwargs = manager.deconstruct()
530             if as_manager:
531                 qs_class = import_string(qs_path)
532                 yield mgr_name, qs_class.as_manager()
533             else:
534                 manager_class = import_string(manager_path)
535                 yield mgr_name, manager_class(*args, **kwargs)
536 
537     def clone(self):
538         """Return an exact copy of this ModelState."""
539         return self.__class__(
540             app_label=self.app_label,
541             name=self.name,
542             fields=dict(self.fields),
543             # Since options are shallow-copied here, operations such as
544             # AddIndex must replace their option (e.g 'indexes') rather
545             # than mutating it.
546             options=dict(self.options),
547             bases=self.bases,
548             managers=list(self.managers),
549         )
550 
551     def render(self, apps):
552         """Create a Model object from our current state into the given apps."""
553         # First, make a Meta object
554         meta_contents = {'app_label': self.app_label, 'apps': apps, **self.options}
555         meta = type("Meta", (), meta_contents)
556         # Then, work out our bases
557         try:
558             bases = tuple(
559                 (apps.get_model(base) if isinstance(base, str) else base)
560                 for base in self.bases
561             )
562         except LookupError:
563             raise InvalidBasesError("Cannot resolve one or more bases from %r" % (self.bases,))
564         # Clone fields for the body, add other bits.
565         body = {name: field.clone() for name, field in self.fields.items()}
566         body['Meta'] = meta
567         body['__module__'] = "__fake__"
568 
569         # Restore managers
570         body.update(self.construct_managers())
571         # Then, make a Model object (apps.register_model is called in __new__)
572         return type(self.name, bases, body)
573 
574     def get_index_by_name(self, name):
575         for index in self.options['indexes']:
576             if index.name == name:
577                 return index
578         raise ValueError("No index named %s on model %s" % (name, self.name))
579 
580     def get_constraint_by_name(self, name):
581         for constraint in self.options['constraints']:
582             if constraint.name == name:
583                 return constraint
584         raise ValueError('No constraint named %s on model %s' % (name, self.name))
585 
586     def __repr__(self):
587         return "<%s: '%s.%s'>" % (self.__class__.__name__, self.app_label, self.name)
588 
589     def __eq__(self, other):
590         return (
591             (self.app_label == other.app_label) and
592             (self.name == other.name) and
593             (len(self.fields) == len(other.fields)) and
594             all(
595                 k1 == k2 and f1.deconstruct()[1:] == f2.deconstruct()[1:]
596                 for (k1, f1), (k2, f2) in zip(
597                     sorted(self.fields.items()),
598                     sorted(other.fields.items()),
599                 )
600             ) and
601             (self.options == other.options) and
602             (self.bases == other.bases) and
603             (self.managers == other.managers)
604         )

</code><intended_behavior>Adjust the state management logic to correctly differentiate between identical model names in different apps, ensuring that migrations involving these models do not raise fields.E305 errors.</intended_behavior>, <file>django/db/models/fields/related.py</file>
<class>None</class>
<method>None</method>
<code>
1 import functools
2 import inspect
3 from functools import partial
4 
5 from django import forms
6 from django.apps import apps
7 from django.conf import SettingsReference, settings
8 from django.core import checks, exceptions
9 from django.db import connection, router
10 from django.db.backends import utils
11 from django.db.models import Q
12 from django.db.models.constants import LOOKUP_SEP
13 from django.db.models.deletion import CASCADE, SET_DEFAULT, SET_NULL
14 from django.db.models.query_utils import PathInfo
15 from django.db.models.utils import make_model_tuple
16 from django.utils.functional import cached_property
17 from django.utils.translation import gettext_lazy as _
18 
19 from . import Field
20 from .mixins import FieldCacheMixin
21 from .related_descriptors import (
22     ForeignKeyDeferredAttribute, ForwardManyToOneDescriptor,
23     ForwardOneToOneDescriptor, ManyToManyDescriptor,
24     ReverseManyToOneDescriptor, ReverseOneToOneDescriptor,
25 )
26 from .related_lookups import (
27     RelatedExact, RelatedGreaterThan, RelatedGreaterThanOrEqual, RelatedIn,
28     RelatedIsNull, RelatedLessThan, RelatedLessThanOrEqual,
29 )
30 from .reverse_related import (
31     ForeignObjectRel, ManyToManyRel, ManyToOneRel, OneToOneRel,
32 )
33 
34 RECURSIVE_RELATIONSHIP_CONSTANT = 'self'
35 
36 
37 def resolve_relation(scope_model, relation):
38     """
39     Transform relation into a model or fully-qualified model string of the form
40     "app_label.ModelName", relative to scope_model.
41 
42     The relation argument can be:
43       * RECURSIVE_RELATIONSHIP_CONSTANT, i.e. the string "self", in which case
44         the model argument will be returned.
45       * A bare model name without an app_label, in which case scope_model's
46         app_label will be prepended.
47       * An "app_label.ModelName" string.
48       * A model class, which will be returned unchanged.
49     """
50     # Check for recursive relations
51     if relation == RECURSIVE_RELATIONSHIP_CONSTANT:
52         relation = scope_model
53 
54     # Look for an "app.Model" relation
55     if isinstance(relation, str):
56         if "." not in relation:
57             relation = "%s.%s" % (scope_model._meta.app_label, relation)
58 
59     return relation
60 
61 
62 def lazy_related_operation(function, model, *related_models, **kwargs):
63     """
64     Schedule `function` to be called once `model` and all `related_models`
65     have been imported and registered with the app registry. `function` will
66     be called with the newly-loaded model classes as its positional arguments,
67     plus any optional keyword arguments.
68 
69     The `model` argument must be a model class. Each subsequent positional
70     argument is another model, or a reference to another model - see
71     `resolve_relation()` for the various forms these may take. Any relative
72     references will be resolved relative to `model`.
73 
74     This is a convenience wrapper for `Apps.lazy_model_operation` - the app
75     registry model used is the one found in `model._meta.apps`.
76     """
77     models = [model] + [resolve_relation(model, rel) for rel in related_models]
78     model_keys = (make_model_tuple(m) for m in models)
79     apps = model._meta.apps
80     return apps.lazy_model_operation(partial(function, **kwargs), *model_keys)
81 
82 
83 class RelatedField(FieldCacheMixin, Field):
84     """Base class that all relational fields inherit from."""
85 
86     # Field flags
87     one_to_many = False
88     one_to_one = False
89     many_to_many = False
90     many_to_one = False
91 
92     @cached_property
93     def related_model(self):
94         # Can't cache this property until all the models are loaded.
95         apps.check_models_ready()
96         return self.remote_field.model
97 
98     def check(self, **kwargs):
99         return [
100             *super().check(**kwargs),
101             *self._check_related_name_is_valid(),
102             *self._check_related_query_name_is_valid(),
103             *self._check_relation_model_exists(),
104             *self._check_referencing_to_swapped_model(),
105             *self._check_clashes(),
106         ]
107 
108     def _check_related_name_is_valid(self):
109         import keyword
110         related_name = self.remote_field.related_name
111         if related_name is None:
112             return []
113         is_valid_id = not keyword.iskeyword(related_name) and related_name.isidentifier()
114         if not (is_valid_id or related_name.endswith('+')):
115             return [
116                 checks.Error(
117                     "The name '%s' is invalid related_name for field %s.%s" %
118                     (self.remote_field.related_name, self.model._meta.object_name,
119                      self.name),
120                     hint="Related name must be a valid Python identifier or end with a '+'",
121                     obj=self,
122                     id='fields.E306',
123                 )
124             ]
125         return []
126 
127     def _check_related_query_name_is_valid(self):
128         if self.remote_field.is_hidden():
129             return []
130         rel_query_name = self.related_query_name()
131         errors = []
132         if rel_query_name.endswith('_'):
133             errors.append(
134                 checks.Error(
135                     "Reverse query name '%s' must not end with an underscore."
136                     % rel_query_name,
137                     hint=("Add or change a related_name or related_query_name "
138                           "argument for this field."),
139                     obj=self,
140                     id='fields.E308',
141                 )
142             )
143         if LOOKUP_SEP in rel_query_name:
144             errors.append(
145                 checks.Error(
146                     "Reverse query name '%s' must not contain '%s'."
147                     % (rel_query_name, LOOKUP_SEP),
148                     hint=("Add or change a related_name or related_query_name "
149                           "argument for this field."),
150                     obj=self,
151                     id='fields.E309',
152                 )
153             )
154         return errors
155 
156     def _check_relation_model_exists(self):
157         rel_is_missing = self.remote_field.model not in self.opts.apps.get_models()
158         rel_is_string = isinstance(self.remote_field.model, str)
159         model_name = self.remote_field.model if rel_is_string else self.remote_field.model._meta.object_name
160         if rel_is_missing and (rel_is_string or not self.remote_field.model._meta.swapped):
161             return [
162                 checks.Error(
163                     "Field defines a relation with model '%s', which is either "
164                     "not installed, or is abstract." % model_name,
165                     obj=self,
166                     id='fields.E300',
167                 )
168             ]
169         return []
170 
171     def _check_referencing_to_swapped_model(self):
172         if (self.remote_field.model not in self.opts.apps.get_models() and
173                 not isinstance(self.remote_field.model, str) and
174                 self.remote_field.model._meta.swapped):
175             return [
176                 checks.Error(
177                     "Field defines a relation with the model '%s', which has "
178                     "been swapped out." % self.remote_field.model._meta.label,
179                     hint="Update the relation to point at 'settings.%s'." % self.remote_field.model._meta.swappable,
180                     obj=self,
181                     id='fields.E301',
182                 )
183             ]
184         return []
185 
186     def _check_clashes(self):
187         """Check accessor and reverse query name clashes."""
188         from django.db.models.base import ModelBase
189 
190         errors = []
191         opts = self.model._meta
192 
193         # `f.remote_field.model` may be a string instead of a model. Skip if model name is
194         # not resolved.
195         if not isinstance(self.remote_field.model, ModelBase):
196             return []
197 
198         # Consider that we are checking field `Model.foreign` and the models
199         # are:
200         #
201         #     class Target(models.Model):
202         #         model = models.IntegerField()
203         #         model_set = models.IntegerField()
204         #
205         #     class Model(models.Model):
206         #         foreign = models.ForeignKey(Target)
207         #         m2m = models.ManyToManyField(Target)
208 
209         # rel_opts.object_name == "Target"
210         rel_opts = self.remote_field.model._meta
211         # If the field doesn't install a backward relation on the target model
212         # (so `is_hidden` returns True), then there are no clashes to check
213         # and we can skip these fields.
214         rel_is_hidden = self.remote_field.is_hidden()
215         rel_name = self.remote_field.get_accessor_name()  # i. e. "model_set"
216         rel_query_name = self.related_query_name()  # i. e. "model"
217         # i.e. "app_label.Model.field".
218         field_name = '%s.%s' % (opts.label, self.name)
219 
220         # Check clashes between accessor or reverse query name of `field`
221         # and any other field name -- i.e. accessor for Model.foreign is
222         # model_set and it clashes with Target.model_set.
223         potential_clashes = rel_opts.fields + rel_opts.many_to_many
224         for clash_field in potential_clashes:
225             # i.e. "app_label.Target.model_set".
226             clash_name = '%s.%s' % (rel_opts.label, clash_field.name)
227             if not rel_is_hidden and clash_field.name == rel_name:
228                 errors.append(
229                     checks.Error(
230                         "Reverse accessor for '%s' clashes with field name '%s'." % (field_name, clash_name),
231                         hint=("Rename field '%s', or add/change a related_name "
232                               "argument to the definition for field '%s'.") % (clash_name, field_name),
233                         obj=self,
234                         id='fields.E302',
235                     )
236                 )
237 
238             if clash_field.name == rel_query_name:
239                 errors.append(
240                     checks.Error(
241                         "Reverse query name for '%s' clashes with field name '%s'." % (field_name, clash_name),
242                         hint=("Rename field '%s', or add/change a related_name "
243                               "argument to the definition for field '%s'.") % (clash_name, field_name),
244                         obj=self,
245                         id='fields.E303',
246                     )
247                 )
248 
249         # Check clashes between accessors/reverse query names of `field` and
250         # any other field accessor -- i. e. Model.foreign accessor clashes with
251         # Model.m2m accessor.
252         potential_clashes = (r for r in rel_opts.related_objects if r.field is not self)
253         for clash_field in potential_clashes:
254             # i.e. "app_label.Model.m2m".
255             clash_name = '%s.%s' % (
256                 clash_field.related_model._meta.label,
257                 clash_field.field.name,
258             )
259             if not rel_is_hidden and clash_field.get_accessor_name() == rel_name:
260                 errors.append(
261                     checks.Error(
262                         "Reverse accessor for '%s' clashes with reverse accessor for '%s'." % (field_name, clash_name),
263                         hint=("Add or change a related_name argument "
264                               "to the definition for '%s' or '%s'.") % (field_name, clash_name),
265                         obj=self,
266                         id='fields.E304',
267                     )
268                 )
269 
270             if clash_field.get_accessor_name() == rel_query_name:
271                 errors.append(
272                     checks.Error(
273                         "Reverse query name for '%s' clashes with reverse query name for '%s'."
274                         % (field_name, clash_name),
275                         hint=("Add or change a related_name argument "
276                               "to the definition for '%s' or '%s'.") % (field_name, clash_name),
277                         obj=self,
278                         id='fields.E305',
279                     )
280                 )
281 
282         return errors
283 
284     def db_type(self, connection):
285         # By default related field will not have a column as it relates to
286         # columns from another table.
287         return None
288 
289     def contribute_to_class(self, cls, name, private_only=False, **kwargs):
290 
291         super().contribute_to_class(cls, name, private_only=private_only, **kwargs)
292 
293         self.opts = cls._meta
294 
295         if not cls._meta.abstract:
296             if self.remote_field.related_name:
297                 related_name = self.remote_field.related_name
298             else:
299                 related_name = self.opts.default_related_name
300             if related_name:
301                 related_name = related_name % {
302                     'class': cls.__name__.lower(),
303                     'model_name': cls._meta.model_name.lower(),
304                     'app_label': cls._meta.app_label.lower()
305                 }
306                 self.remote_field.related_name = related_name
307 
308             if self.remote_field.related_query_name:
309                 related_query_name = self.remote_field.related_query_name % {
310                     'class': cls.__name__.lower(),
311                     'app_label': cls._meta.app_label.lower(),
312                 }
313                 self.remote_field.related_query_name = related_query_name
314 
315             def resolve_related_class(model, related, field):
316                 field.remote_field.model = related
317                 field.do_related_class(related, model)
318             lazy_related_operation(resolve_related_class, cls, self.remote_field.model, field=self)
319 
320     def deconstruct(self):
321         name, path, args, kwargs = super().deconstruct()
322         if self.remote_field.limit_choices_to:
323             kwargs['limit_choices_to'] = self.remote_field.limit_choices_to
324         if self.remote_field.related_name is not None:
325             kwargs['related_name'] = self.remote_field.related_name
326         if self.remote_field.related_query_name is not None:
327             kwargs['related_query_name'] = self.remote_field.related_query_name
328         return name, path, args, kwargs
329 
330     def get_forward_related_filter(self, obj):
331         """
332         Return the keyword arguments that when supplied to
333         self.model.object.filter(), would select all instances related through
334         this field to the remote obj. This is used to build the querysets
335         returned by related descriptors. obj is an instance of
336         self.related_field.model.
337         """
338         return {
339             '%s__%s' % (self.name, rh_field.name): getattr(obj, rh_field.attname)
340             for _, rh_field in self.related_fields
341         }
342 
343     def get_reverse_related_filter(self, obj):
344         """
345         Complement to get_forward_related_filter(). Return the keyword
346         arguments that when passed to self.related_field.model.object.filter()
347         select all instances of self.related_field.model related through
348         this field to obj. obj is an instance of self.model.
349         """
350         base_filter = {
351             rh_field.attname: getattr(obj, lh_field.attname)
352             for lh_field, rh_field in self.related_fields
353         }
354         descriptor_filter = self.get_extra_descriptor_filter(obj)
355         base_q = Q(**base_filter)
356         if isinstance(descriptor_filter, dict):
357             return base_q & Q(**descriptor_filter)
358         elif descriptor_filter:
359             return base_q & descriptor_filter
360         return base_q
361 
362     @property
363     def swappable_setting(self):
364         """
365         Get the setting that this is powered from for swapping, or None
366         if it's not swapped in / marked with swappable=False.
367         """
368         if self.swappable:
369             # Work out string form of "to"
370             if isinstance(self.remote_field.model, str):
371                 to_string = self.remote_field.model
372             else:
373                 to_string = self.remote_field.model._meta.label
374             return apps.get_swappable_settings_name(to_string)
375         return None
376 
377     def set_attributes_from_rel(self):
378         self.name = (
379             self.name or
380             (self.remote_field.model._meta.model_name + '_' + self.remote_field.model._meta.pk.name)
381         )
382         if self.verbose_name is None:
383             self.verbose_name = self.remote_field.model._meta.verbose_name
384         self.remote_field.set_field_name()
385 
386     def do_related_class(self, other, cls):
387         self.set_attributes_from_rel()
388         self.contribute_to_related_class(other, self.remote_field)
389 
390     def get_limit_choices_to(self):
391         """
392         Return ``limit_choices_to`` for this model field.
393 
394         If it is a callable, it will be invoked and the result will be
395         returned.
396         """
397         if callable(self.remote_field.limit_choices_to):
398             return self.remote_field.limit_choices_to()
399         return self.remote_field.limit_choices_to
400 
401     def formfield(self, **kwargs):
402         """
403         Pass ``limit_choices_to`` to the field being constructed.
404 
405         Only passes it if there is a type that supports related fields.
406         This is a similar strategy used to pass the ``queryset`` to the field
407         being constructed.
408         """
409         defaults = {}
410         if hasattr(self.remote_field, 'get_related_field'):
411             # If this is a callable, do not invoke it here. Just pass
412             # it in the defaults for when the form class will later be
413             # instantiated.
414             limit_choices_to = self.remote_field.limit_choices_to
415             defaults.update({
416                 'limit_choices_to': limit_choices_to,
417             })
418         defaults.update(kwargs)
419         return super().formfield(**defaults)
420 
421     def related_query_name(self):
422         """
423         Define the name that can be used to identify this related object in a
424         table-spanning query.
425         """
426         return self.remote_field.related_query_name or self.remote_field.related_name or self.opts.model_name
427 
428     @property
429     def target_field(self):
430         """
431         When filtering against this relation, return the field on the remote
432         model against which the filtering should happen.
433         """
434         target_fields = self.get_path_info()[-1].target_fields
435         if len(target_fields) > 1:
436             raise exceptions.FieldError(
437                 "The relation has multiple target fields, but only single target field was asked for")
438         return target_fields[0]
439 
440     def get_cache_name(self):
441         return self.name
442 
443 
444 class ForeignObject(RelatedField):
445     """
446     Abstraction of the ForeignKey relation to support multi-column relations.
447     """
448 
449     # Field flags
450     many_to_many = False
451     many_to_one = True
452     one_to_many = False
453     one_to_one = False
454 
455     requires_unique_target = True
456     related_accessor_class = ReverseManyToOneDescriptor
457     forward_related_accessor_class = ForwardManyToOneDescriptor
458     rel_class = ForeignObjectRel
459 
460     def __init__(self, to, on_delete, from_fields, to_fields, rel=None, related_name=None,
461                  related_query_name=None, limit_choices_to=None, parent_link=False,
462                  swappable=True, **kwargs):
463 
464         if rel is None:
465             rel = self.rel_class(
466                 self, to,
467                 related_name=related_name,
468                 related_query_name=related_query_name,
469                 limit_choices_to=limit_choices_to,
470                 parent_link=parent_link,
471                 on_delete=on_delete,
472             )
473 
474         super().__init__(rel=rel, **kwargs)
475 
476         self.from_fields = from_fields
477         self.to_fields = to_fields
478         self.swappable = swappable
479 
480     def check(self, **kwargs):
481         return [
482             *super().check(**kwargs),
483             *self._check_to_fields_exist(),
484             *self._check_unique_target(),
485         ]
486 
487     def _check_to_fields_exist(self):
488         # Skip nonexistent models.
489         if isinstance(self.remote_field.model, str):
490             return []
491 
492         errors = []
493         for to_field in self.to_fields:
494             if to_field:
495                 try:
496                     self.remote_field.model._meta.get_field(to_field)
497                 except exceptions.FieldDoesNotExist:
498                     errors.append(
499                         checks.Error(
500                             "The to_field '%s' doesn't exist on the related "
501                             "model '%s'."
502                             % (to_field, self.remote_field.model._meta.label),
503                             obj=self,
504                             id='fields.E312',
505                         )
506                     )
507         return errors
508 
509     def _check_unique_target(self):
510         rel_is_string = isinstance(self.remote_field.model, str)
511         if rel_is_string or not self.requires_unique_target:
512             return []
513 
514         try:
515             self.foreign_related_fields
516         except exceptions.FieldDoesNotExist:
517             return []
518 
519         if not self.foreign_related_fields:
520             return []
521 
522         unique_foreign_fields = {
523             frozenset([f.name])
524             for f in self.remote_field.model._meta.get_fields()
525             if getattr(f, 'unique', False)
526         }
527         unique_foreign_fields.update({
528             frozenset(ut)
529             for ut in self.remote_field.model._meta.unique_together
530         })
531         unique_foreign_fields.update({
532             frozenset(uc.fields)
533             for uc in self.remote_field.model._meta.total_unique_constraints
534         })
535         foreign_fields = {f.name for f in self.foreign_related_fields}
536         has_unique_constraint = any(u <= foreign_fields for u in unique_foreign_fields)
537 
538         if not has_unique_constraint and len(self.foreign_related_fields) > 1:
539             field_combination = ', '.join(
540                 "'%s'" % rel_field.name for rel_field in self.foreign_related_fields
541             )
542             model_name = self.remote_field.model.__name__
543             return [
544                 checks.Error(
545                     "No subset of the fields %s on model '%s' is unique."
546                     % (field_combination, model_name),
547                     hint=(
548                         'Mark a single field as unique=True or add a set of '
549                         'fields to a unique constraint (via unique_together '
550                         'or a UniqueConstraint (without condition) in the '
551                         'model Meta.constraints).'
552                     ),
553                     obj=self,
554                     id='fields.E310',
555                 )
556             ]
557         elif not has_unique_constraint:
558             field_name = self.foreign_related_fields[0].name
559             model_name = self.remote_field.model.__name__
560             return [
561                 checks.Error(
562                     "'%s.%s' must be unique because it is referenced by "
563                     "a foreign key." % (model_name, field_name),
564                     hint=(
565                         'Add unique=True to this field or add a '
566                         'UniqueConstraint (without condition) in the model '
567                         'Meta.constraints.'
568                     ),
569                     obj=self,
570                     id='fields.E311',
571                 )
572             ]
573         else:
574             return []
575 
576     def deconstruct(self):
577         name, path, args, kwargs = super().deconstruct()
578         kwargs['on_delete'] = self.remote_field.on_delete
579         kwargs['from_fields'] = self.from_fields
580         kwargs['to_fields'] = self.to_fields
581 
582         if self.remote_field.parent_link:
583             kwargs['parent_link'] = self.remote_field.parent_link
584         if isinstance(self.remote_field.model, str):
585             if '.' in self.remote_field.model:
586                 app_label, model_name = self.remote_field.model.split('.')
587                 kwargs['to'] = '%s.%s' % (app_label, model_name.lower())
588             else:
589                 kwargs['to'] = self.remote_field.model.lower()
590         else:
591             kwargs['to'] = self.remote_field.model._meta.label_lower
592         # If swappable is True, then see if we're actually pointing to the target
593         # of a swap.
594         swappable_setting = self.swappable_setting
595         if swappable_setting is not None:
596             # If it's already a settings reference, error
597             if hasattr(kwargs['to'], "setting_name"):
598                 if kwargs['to'].setting_name != swappable_setting:
599                     raise ValueError(
600                         "Cannot deconstruct a ForeignKey pointing to a model "
601                         "that is swapped in place of more than one model (%s and %s)"
602                         % (kwargs['to'].setting_name, swappable_setting)
603                     )
604             # Set it
605             kwargs['to'] = SettingsReference(
606                 kwargs['to'],
607                 swappable_setting,
608             )
609         return name, path, args, kwargs
610 
611     def resolve_related_fields(self):
612         if not self.from_fields or len(self.from_fields) != len(self.to_fields):
613             raise ValueError('Foreign Object from and to fields must be the same non-zero length')
614         if isinstance(self.remote_field.model, str):
615             raise ValueError('Related model %r cannot be resolved' % self.remote_field.model)
616         related_fields = []
617         for index in range(len(self.from_fields)):
618             from_field_name = self.from_fields[index]
619             to_field_name = self.to_fields[index]
620             from_field = (
621                 self
622                 if from_field_name == RECURSIVE_RELATIONSHIP_CONSTANT
623                 else self.opts.get_field(from_field_name)
624             )
625             to_field = (self.remote_field.model._meta.pk if to_field_name is None
626                         else self.remote_field.model._meta.get_field(to_field_name))
627             related_fields.append((from_field, to_field))
628         return related_fields
629 
630     @cached_property
631     def related_fields(self):
632         return self.resolve_related_fields()
633 
634     @cached_property
635     def reverse_related_fields(self):
636         return [(rhs_field, lhs_field) for lhs_field, rhs_field in self.related_fields]
637 
638     @cached_property
639     def local_related_fields(self):
640         return tuple(lhs_field for lhs_field, rhs_field in self.related_fields)
641 
642     @cached_property
643     def foreign_related_fields(self):
644         return tuple(rhs_field for lhs_field, rhs_field in self.related_fields if rhs_field)
645 
646     def get_local_related_value(self, instance):
647         return self.get_instance_value_for_fields(instance, self.local_related_fields)
648 
649     def get_foreign_related_value(self, instance):
650         return self.get_instance_value_for_fields(instance, self.foreign_related_fields)
651 
652     @staticmethod
653     def get_instance_value_for_fields(instance, fields):
654         ret = []
655         opts = instance._meta
656         for field in fields:
657             # Gotcha: in some cases (like fixture loading) a model can have
658             # different values in parent_ptr_id and parent's id. So, use
659             # instance.pk (that is, parent_ptr_id) when asked for instance.id.
660             if field.primary_key:
661                 possible_parent_link = opts.get_ancestor_link(field.model)
662                 if (not possible_parent_link or
663                         possible_parent_link.primary_key or
664                         possible_parent_link.model._meta.abstract):
665                     ret.append(instance.pk)
666                     continue
667             ret.append(getattr(instance, field.attname))
668         return tuple(ret)
669 
670     def get_attname_column(self):
671         attname, column = super().get_attname_column()
672         return attname, None
673 
674     def get_joining_columns(self, reverse_join=False):
675         source = self.reverse_related_fields if reverse_join else self.related_fields
676         return tuple((lhs_field.column, rhs_field.column) for lhs_field, rhs_field in source)
677 
678     def get_reverse_joining_columns(self):
679         return self.get_joining_columns(reverse_join=True)
680 
681     def get_extra_descriptor_filter(self, instance):
682         """
683         Return an extra filter condition for related object fetching when
684         user does 'instance.fieldname', that is the extra filter is used in
685         the descriptor of the field.
686 
687         The filter should be either a dict usable in .filter(**kwargs) call or
688         a Q-object. The condition will be ANDed together with the relation's
689         joining columns.
690 
691         A parallel method is get_extra_restriction() which is used in
692         JOIN and subquery conditions.
693         """
694         return {}
695 
696     def get_extra_restriction(self, where_class, alias, related_alias):
697         """
698         Return a pair condition used for joining and subquery pushdown. The
699         condition is something that responds to as_sql(compiler, connection)
700         method.
701 
702         Note that currently referring both the 'alias' and 'related_alias'
703         will not work in some conditions, like subquery pushdown.
704 
705         A parallel method is get_extra_descriptor_filter() which is used in
706         instance.fieldname related object fetching.
707         """
708         return None
709 
710     def get_path_info(self, filtered_relation=None):
711         """Get path from this field to the related model."""
712         opts = self.remote_field.model._meta
713         from_opts = self.model._meta
714         return [PathInfo(
715             from_opts=from_opts,
716             to_opts=opts,
717             target_fields=self.foreign_related_fields,
718             join_field=self,
719             m2m=False,
720             direct=True,
721             filtered_relation=filtered_relation,
722         )]
723 
724     def get_reverse_path_info(self, filtered_relation=None):
725         """Get path from the related model to this field's model."""
726         opts = self.model._meta
727         from_opts = self.remote_field.model._meta
728         return [PathInfo(
729             from_opts=from_opts,
730             to_opts=opts,
731             target_fields=(opts.pk,),
732             join_field=self.remote_field,
733             m2m=not self.unique,
734             direct=False,
735             filtered_relation=filtered_relation,
736         )]
737 
738     @classmethod
739     @functools.lru_cache(maxsize=None)
740     def get_lookups(cls):
741         bases = inspect.getmro(cls)
742         bases = bases[:bases.index(ForeignObject) + 1]
743         class_lookups = [parent.__dict__.get('class_lookups', {}) for parent in bases]
744         return cls.merge_dicts(class_lookups)
745 
746     def contribute_to_class(self, cls, name, private_only=False, **kwargs):
747         super().contribute_to_class(cls, name, private_only=private_only, **kwargs)
748         setattr(cls, self.name, self.forward_related_accessor_class(self))
749 
750     def contribute_to_related_class(self, cls, related):
751         # Internal FK's - i.e., those with a related name ending with '+' -
752         # and swapped models don't get a related descriptor.
753         if not self.remote_field.is_hidden() and not related.related_model._meta.swapped:
754             setattr(cls._meta.concrete_model, related.get_accessor_name(), self.related_accessor_class(related))
755             # While 'limit_choices_to' might be a callable, simply pass
756             # it along for later - this is too early because it's still
757             # model load time.
758             if self.remote_field.limit_choices_to:
759                 cls._meta.related_fkey_lookups.append(self.remote_field.limit_choices_to)
760 
761 
762 ForeignObject.register_lookup(RelatedIn)
763 ForeignObject.register_lookup(RelatedExact)
764 ForeignObject.register_lookup(RelatedLessThan)
765 ForeignObject.register_lookup(RelatedGreaterThan)
766 ForeignObject.register_lookup(RelatedGreaterThanOrEqual)
767 ForeignObject.register_lookup(RelatedLessThanOrEqual)
768 ForeignObject.register_lookup(RelatedIsNull)
769 
770 
771 class ForeignKey(ForeignObject):
772     """
773     Provide a many-to-one relation by adding a column to the local model
774     to hold the remote value.
775 
776     By default ForeignKey will target the pk of the remote model but this
777     behavior can be changed by using the ``to_field`` argument.
778     """
779     descriptor_class = ForeignKeyDeferredAttribute
780     # Field flags
781     many_to_many = False
782     many_to_one = True
783     one_to_many = False
784     one_to_one = False
785 
786     rel_class = ManyToOneRel
787 
788     empty_strings_allowed = False
789     default_error_messages = {
790         'invalid': _('%(model)s instance with %(field)s %(value)r does not exist.')
791     }
792     description = _("Foreign Key (type determined by related field)")
793 
794     def __init__(self, to, on_delete, related_name=None, related_query_name=None,
795                  limit_choices_to=None, parent_link=False, to_field=None,
796                  db_constraint=True, **kwargs):
797         try:
798             to._meta.model_name
799         except AttributeError:
800             assert isinstance(to, str), (
801                 "%s(%r) is invalid. First parameter to ForeignKey must be "
802                 "either a model, a model name, or the string %r" % (
803                     self.__class__.__name__, to,
804                     RECURSIVE_RELATIONSHIP_CONSTANT,
805                 )
806             )
807         else:
808             # For backwards compatibility purposes, we need to *try* and set
809             # the to_field during FK construction. It won't be guaranteed to
810             # be correct until contribute_to_class is called. Refs #12190.
811             to_field = to_field or (to._meta.pk and to._meta.pk.name)
812         if not callable(on_delete):
813             raise TypeError('on_delete must be callable.')
814 
815         kwargs['rel'] = self.rel_class(
816             self, to, to_field,
817             related_name=related_name,
818             related_query_name=related_query_name,
819             limit_choices_to=limit_choices_to,
820             parent_link=parent_link,
821             on_delete=on_delete,
822         )
823         kwargs.setdefault('db_index', True)
824 
825         super().__init__(
826             to,
827             on_delete,
828             from_fields=[RECURSIVE_RELATIONSHIP_CONSTANT],
829             to_fields=[to_field],
830             **kwargs,
831         )
832         self.db_constraint = db_constraint
833 
834     def check(self, **kwargs):
835         return [
836             *super().check(**kwargs),
837             *self._check_on_delete(),
838             *self._check_unique(),
839         ]
840 
841     def _check_on_delete(self):
842         on_delete = getattr(self.remote_field, 'on_delete', None)
843         if on_delete == SET_NULL and not self.null:
844             return [
845                 checks.Error(
846                     'Field specifies on_delete=SET_NULL, but cannot be null.',
847                     hint='Set null=True argument on the field, or change the on_delete rule.',
848                     obj=self,
849                     id='fields.E320',
850                 )
851             ]
852         elif on_delete == SET_DEFAULT and not self.has_default():
853             return [
854                 checks.Error(
855                     'Field specifies on_delete=SET_DEFAULT, but has no default value.',
856                     hint='Set a default value, or change the on_delete rule.',
857                     obj=self,
858                     id='fields.E321',
859                 )
860             ]
861         else:
862             return []
863 
864     def _check_unique(self, **kwargs):
865         return [
866             checks.Warning(
867                 'Setting unique=True on a ForeignKey has the same effect as using a OneToOneField.',
868                 hint='ForeignKey(unique=True) is usually better served by a OneToOneField.',
869                 obj=self,
870                 id='fields.W342',
871             )
872         ] if self.unique else []
873 
874     def deconstruct(self):
875         name, path, args, kwargs = super().deconstruct()
876         del kwargs['to_fields']
877         del kwargs['from_fields']
878         # Handle the simpler arguments
879         if self.db_index:
880             del kwargs['db_index']
881         else:
882             kwargs['db_index'] = False
883         if self.db_constraint is not True:
884             kwargs['db_constraint'] = self.db_constraint
885         # Rel needs more work.
886         to_meta = getattr(self.remote_field.model, "_meta", None)
887         if self.remote_field.field_name and (
888                 not to_meta or (to_meta.pk and self.remote_field.field_name != to_meta.pk.name)):
889             kwargs['to_field'] = self.remote_field.field_name
890         return name, path, args, kwargs
891 
892     def to_python(self, value):
893         return self.target_field.to_python(value)
894 
895     @property
896     def target_field(self):
897         return self.foreign_related_fields[0]
898 
899     def get_reverse_path_info(self, filtered_relation=None):
900         """Get path from the related model to this field's model."""
901         opts = self.model._meta
902         from_opts = self.remote_field.model._meta
903         return [PathInfo(
904             from_opts=from_opts,
905             to_opts=opts,
906             target_fields=(opts.pk,),
907             join_field=self.remote_field,
908             m2m=not self.unique,
909             direct=False,
910             filtered_relation=filtered_relation,
911         )]
912 
913     def validate(self, value, model_instance):
914         if self.remote_field.parent_link:
915             return
916         super().validate(value, model_instance)
917         if value is None:
918             return
919 
920         using = router.db_for_read(self.remote_field.model, instance=model_instance)
921         qs = self.remote_field.model._base_manager.using(using).filter(
922             **{self.remote_field.field_name: value}
923         )
924         qs = qs.complex_filter(self.get_limit_choices_to())
925         if not qs.exists():
926             raise exceptions.ValidationError(
927                 self.error_messages['invalid'],
928                 code='invalid',
929                 params={
930                     'model': self.remote_field.model._meta.verbose_name, 'pk': value,
931                     'field': self.remote_field.field_name, 'value': value,
932                 },  # 'pk' is included for backwards compatibility
933             )
934 
935     def resolve_related_fields(self):
936         related_fields = super().resolve_related_fields()
937         for from_field, to_field in related_fields:
938             if to_field and to_field.model != self.remote_field.model._meta.concrete_model:
939                 raise exceptions.FieldError(
940                     "'%s.%s' refers to field '%s' which is not local to model "
941                     "'%s'." % (
942                         self.model._meta.label,
943                         self.name,
944                         to_field.name,
945                         self.remote_field.model._meta.concrete_model._meta.label,
946                     )
947                 )
948         return related_fields
949 
950     def get_attname(self):
951         return '%s_id' % self.name
952 
953     def get_attname_column(self):
954         attname = self.get_attname()
955         column = self.db_column or attname
956         return attname, column
957 
958     def get_default(self):
959         """Return the to_field if the default value is an object."""
960         field_default = super().get_default()
961         if isinstance(field_default, self.remote_field.model):
962             return getattr(field_default, self.target_field.attname)
963         return field_default
964 
965     def get_db_prep_save(self, value, connection):
966         if value is None or (value == '' and
967                              (not self.target_field.empty_strings_allowed or
968                               connection.features.interprets_empty_strings_as_nulls)):
969             return None
970         else:
971             return self.target_field.get_db_prep_save(value, connection=connection)
972 
973     def get_db_prep_value(self, value, connection, prepared=False):
974         return self.target_field.get_db_prep_value(value, connection, prepared)
975 
976     def get_prep_value(self, value):
977         return self.target_field.get_prep_value(value)
978 
979     def contribute_to_related_class(self, cls, related):
980         super().contribute_to_related_class(cls, related)
981         if self.remote_field.field_name is None:
982             self.remote_field.field_name = cls._meta.pk.name
983 
984     def formfield(self, *, using=None, **kwargs):
985         if isinstance(self.remote_field.model, str):
986             raise ValueError("Cannot create form field for %r yet, because "
987                              "its related model %r has not been loaded yet" %
988                              (self.name, self.remote_field.model))
989         return super().formfield(**{
990             'form_class': forms.ModelChoiceField,
991             'queryset': self.remote_field.model._default_manager.using(using),
992             'to_field_name': self.remote_field.field_name,
993             **kwargs,
994             'blank': self.blank,
995         })
996 
997     def db_check(self, connection):
998         return []
999 
1000     def db_type(self, connection):
1001         return self.target_field.rel_db_type(connection=connection)
1002 
1003     def db_parameters(self, connection):
1004         return {"type": self.db_type(connection), "check": self.db_check(connection)}
1005 
1006     def convert_empty_strings(self, value, expression, connection):
1007         if (not value) and isinstance(value, str):
1008             return None
1009         return value
1010 
1011     def get_db_converters(self, connection):
1012         converters = super().get_db_converters(connection)
1013         if connection.features.interprets_empty_strings_as_nulls:
1014             converters += [self.convert_empty_strings]
1015         return converters
1016 
1017     def get_col(self, alias, output_field=None):
1018         if output_field is None:
1019             output_field = self.target_field
1020             while isinstance(output_field, ForeignKey):
1021                 output_field = output_field.target_field
1022                 if output_field is self:
1023                     raise ValueError('Cannot resolve output_field.')
1024         return super().get_col(alias, output_field)
1025 
1026 
1027 class OneToOneField(ForeignKey):
1028     """
1029     A OneToOneField is essentially the same as a ForeignKey, with the exception
1030     that it always carries a "unique" constraint with it and the reverse
1031     relation always returns the object pointed to (since there will only ever
1032     be one), rather than returning a list.
1033     """
1034 
1035     # Field flags
1036     many_to_many = False
1037     many_to_one = False
1038     one_to_many = False
1039     one_to_one = True
1040 
1041     related_accessor_class = ReverseOneToOneDescriptor
1042     forward_related_accessor_class = ForwardOneToOneDescriptor
1043     rel_class = OneToOneRel
1044 
1045     description = _("One-to-one relationship")
1046 
1047     def __init__(self, to, on_delete, to_field=None, **kwargs):
1048         kwargs['unique'] = True
1049         super().__init__(to, on_delete, to_field=to_field, **kwargs)
1050 
1051     def deconstruct(self):
1052         name, path, args, kwargs = super().deconstruct()
1053         if "unique" in kwargs:
1054             del kwargs['unique']
1055         return name, path, args, kwargs
1056 
1057     def formfield(self, **kwargs):
1058         if self.remote_field.parent_link:
1059             return None
1060         return super().formfield(**kwargs)
1061 
1062     def save_form_data(self, instance, data):
1063         if isinstance(data, self.remote_field.model):
1064             setattr(instance, self.name, data)
1065         else:
1066             setattr(instance, self.attname, data)
1067             # Remote field object must be cleared otherwise Model.save()
1068             # will reassign attname using the related object pk.
1069             if data is None:
1070                 setattr(instance, self.name, data)
1071 
1072     def _check_unique(self, **kwargs):
1073         # Override ForeignKey since check isn't applicable here.
1074         return []
1075 
1076 
1077 def create_many_to_many_intermediary_model(field, klass):
1078     from django.db import models
1079 
1080     def set_managed(model, related, through):
1081         through._meta.managed = model._meta.managed or related._meta.managed
1082 
1083     to_model = resolve_relation(klass, field.remote_field.model)
1084     name = '%s_%s' % (klass._meta.object_name, field.name)
1085     lazy_related_operation(set_managed, klass, to_model, name)
1086 
1087     to = make_model_tuple(to_model)[1]
1088     from_ = klass._meta.model_name
1089     if to == from_:
1090         to = 'to_%s' % to
1091         from_ = 'from_%s' % from_
1092 
1093     meta = type('Meta', (), {
1094         'db_table': field._get_m2m_db_table(klass._meta),
1095         'auto_created': klass,
1096         'app_label': klass._meta.app_label,
1097         'db_tablespace': klass._meta.db_tablespace,
1098         'unique_together': (from_, to),
1099         'verbose_name': _('%(from)s-%(to)s relationship') % {'from': from_, 'to': to},
1100         'verbose_name_plural': _('%(from)s-%(to)s relationships') % {'from': from_, 'to': to},
1101         'apps': field.model._meta.apps,
1102     })
1103     # Construct and return the new class.
1104     return type(name, (models.Model,), {
1105         'Meta': meta,
1106         '__module__': klass.__module__,
1107         from_: models.ForeignKey(
1108             klass,
1109             related_name='%s+' % name,
1110             db_tablespace=field.db_tablespace,
1111             db_constraint=field.remote_field.db_constraint,
1112             on_delete=CASCADE,
1113         ),
1114         to: models.ForeignKey(
1115             to_model,
1116             related_name='%s+' % name,
1117             db_tablespace=field.db_tablespace,
1118             db_constraint=field.remote_field.db_constraint,
1119             on_delete=CASCADE,
1120         )
1121     })
1122 
1123 
1124 class ManyToManyField(RelatedField):
1125     """
1126     Provide a many-to-many relation by using an intermediary model that
1127     holds two ForeignKey fields pointed at the two sides of the relation.
1128 
1129     Unless a ``through`` model was provided, ManyToManyField will use the
1130     create_many_to_many_intermediary_model factory to automatically generate
1131     the intermediary model.
1132     """
1133 
1134     # Field flags
1135     many_to_many = True
1136     many_to_one = False
1137     one_to_many = False
1138     one_to_one = False
1139 
1140     rel_class = ManyToManyRel
1141 
1142     description = _("Many-to-many relationship")
1143 
1144     def __init__(self, to, related_name=None, related_query_name=None,
1145                  limit_choices_to=None, symmetrical=None, through=None,
1146                  through_fields=None, db_constraint=True, db_table=None,
1147                  swappable=True, **kwargs):
1148         try:
1149             to._meta
1150         except AttributeError:
1151             assert isinstance(to, str), (
1152                 "%s(%r) is invalid. First parameter to ManyToManyField must be "
1153                 "either a model, a model name, or the string %r" %
1154                 (self.__class__.__name__, to, RECURSIVE_RELATIONSHIP_CONSTANT)
1155             )
1156 
1157         if symmetrical is None:
1158             symmetrical = (to == RECURSIVE_RELATIONSHIP_CONSTANT)
1159 
1160         if through is not None:
1161             assert db_table is None, (
1162                 "Cannot specify a db_table if an intermediary model is used."
1163             )
1164 
1165         kwargs['rel'] = self.rel_class(
1166             self, to,
1167             related_name=related_name,
1168             related_query_name=related_query_name,
1169             limit_choices_to=limit_choices_to,
1170             symmetrical=symmetrical,
1171             through=through,
1172             through_fields=through_fields,
1173             db_constraint=db_constraint,
1174         )
1175         self.has_null_arg = 'null' in kwargs
1176 
1177         super().__init__(**kwargs)
1178 
1179         self.db_table = db_table
1180         self.swappable = swappable
1181 
1182     def check(self, **kwargs):
1183         return [
1184             *super().check(**kwargs),
1185             *self._check_unique(**kwargs),
1186             *self._check_relationship_model(**kwargs),
1187             *self._check_ignored_options(**kwargs),
1188             *self._check_table_uniqueness(**kwargs),
1189         ]
1190 
1191     def _check_unique(self, **kwargs):
1192         if self.unique:
1193             return [
1194                 checks.Error(
1195                     'ManyToManyFields cannot be unique.',
1196                     obj=self,
1197                     id='fields.E330',
1198                 )
1199             ]
1200         return []
1201 
1202     def _check_ignored_options(self, **kwargs):
1203         warnings = []
1204 
1205         if self.has_null_arg:
1206             warnings.append(
1207                 checks.Warning(
1208                     'null has no effect on ManyToManyField.',
1209                     obj=self,
1210                     id='fields.W340',
1211                 )
1212             )
1213 
1214         if self._validators:
1215             warnings.append(
1216                 checks.Warning(
1217                     'ManyToManyField does not support validators.',
1218                     obj=self,
1219                     id='fields.W341',
1220                 )
1221             )
1222         if (self.remote_field.limit_choices_to and self.remote_field.through and
1223                 not self.remote_field.through._meta.auto_created):
1224             warnings.append(
1225                 checks.Warning(
1226                     'limit_choices_to has no effect on ManyToManyField '
1227                     'with a through model.',
1228                     obj=self,
1229                     id='fields.W343',
1230                 )
1231             )
1232 
1233         return warnings
1234 
1235     def _check_relationship_model(self, from_model=None, **kwargs):
1236         if hasattr(self.remote_field.through, '_meta'):
1237             qualified_model_name = "%s.%s" % (
1238                 self.remote_field.through._meta.app_label, self.remote_field.through.__name__)
1239         else:
1240             qualified_model_name = self.remote_field.through
1241 
1242         errors = []
1243 
1244         if self.remote_field.through not in self.opts.apps.get_models(include_auto_created=True):
1245             # The relationship model is not installed.
1246             errors.append(
1247                 checks.Error(
1248                     "Field specifies a many-to-many relation through model "
1249                     "'%s', which has not been installed." % qualified_model_name,
1250                     obj=self,
1251                     id='fields.E331',
1252                 )
1253             )
1254 
1255         else:
1256             assert from_model is not None, (
1257                 "ManyToManyField with intermediate "
1258                 "tables cannot be checked if you don't pass the model "
1259                 "where the field is attached to."
1260             )
1261             # Set some useful local variables
1262             to_model = resolve_relation(from_model, self.remote_field.model)
1263             from_model_name = from_model._meta.object_name
1264             if isinstance(to_model, str):
1265                 to_model_name = to_model
1266             else:
1267                 to_model_name = to_model._meta.object_name
1268             relationship_model_name = self.remote_field.through._meta.object_name
1269             self_referential = from_model == to_model
1270             # Count foreign keys in intermediate model
1271             if self_referential:
1272                 seen_self = sum(
1273                     from_model == getattr(field.remote_field, 'model', None)
1274                     for field in self.remote_field.through._meta.fields
1275                 )
1276 
1277                 if seen_self > 2 and not self.remote_field.through_fields:
1278                     errors.append(
1279                         checks.Error(
1280                             "The model is used as an intermediate model by "
1281                             "'%s', but it has more than two foreign keys "
1282                             "to '%s', which is ambiguous. You must specify "
1283                             "which two foreign keys Django should use via the "
1284                             "through_fields keyword argument." % (self, from_model_name),
1285                             hint="Use through_fields to specify which two foreign keys Django should use.",
1286                             obj=self.remote_field.through,
1287                             id='fields.E333',
1288                         )
1289                     )
1290 
1291             else:
1292                 # Count foreign keys in relationship model
1293                 seen_from = sum(
1294                     from_model == getattr(field.remote_field, 'model', None)
1295                     for field in self.remote_field.through._meta.fields
1296                 )
1297                 seen_to = sum(
1298                     to_model == getattr(field.remote_field, 'model', None)
1299                     for field in self.remote_field.through._meta.fields
1300                 )
1301 
1302                 if seen_from > 1 and not self.remote_field.through_fields:
1303                     errors.append(
1304                         checks.Error(
1305                             ("The model is used as an intermediate model by "
1306                              "'%s', but it has more than one foreign key "
1307                              "from '%s', which is ambiguous. You must specify "
1308                              "which foreign key Django should use via the "
1309                              "through_fields keyword argument.") % (self, from_model_name),
1310                             hint=(
1311                                 'If you want to create a recursive relationship, '
1312                                 'use ManyToManyField("%s", through="%s").'
1313                             ) % (
1314                                 RECURSIVE_RELATIONSHIP_CONSTANT,
1315                                 relationship_model_name,
1316                             ),
1317                             obj=self,
1318                             id='fields.E334',
1319                         )
1320                     )
1321 
1322                 if seen_to > 1 and not self.remote_field.through_fields:
1323                     errors.append(
1324                         checks.Error(
1325                             "The model is used as an intermediate model by "
1326                             "'%s', but it has more than one foreign key "
1327                             "to '%s', which is ambiguous. You must specify "
1328                             "which foreign key Django should use via the "
1329                             "through_fields keyword argument." % (self, to_model_name),
1330                             hint=(
1331                                 'If you want to create a recursive relationship, '
1332                                 'use ManyToManyField("%s", through="%s").'
1333                             ) % (
1334                                 RECURSIVE_RELATIONSHIP_CONSTANT,
1335                                 relationship_model_name,
1336                             ),
1337                             obj=self,
1338                             id='fields.E335',
1339                         )
1340                     )
1341 
1342                 if seen_from == 0 or seen_to == 0:
1343                     errors.append(
1344                         checks.Error(
1345                             "The model is used as an intermediate model by "
1346                             "'%s', but it does not have a foreign key to '%s' or '%s'." % (
1347                                 self, from_model_name, to_model_name
1348                             ),
1349                             obj=self.remote_field.through,
1350                             id='fields.E336',
1351                         )
1352                     )
1353 
1354         # Validate `through_fields`.
1355         if self.remote_field.through_fields is not None:
1356             # Validate that we're given an iterable of at least two items
1357             # and that none of them is "falsy".
1358             if not (len(self.remote_field.through_fields) >= 2 and
1359                     self.remote_field.through_fields[0] and self.remote_field.through_fields[1]):
1360                 errors.append(
1361                     checks.Error(
1362                         "Field specifies 'through_fields' but does not provide "
1363                         "the names of the two link fields that should be used "
1364                         "for the relation through model '%s'." % qualified_model_name,
1365                         hint="Make sure you specify 'through_fields' as through_fields=('field1', 'field2')",
1366                         obj=self,
1367                         id='fields.E337',
1368                     )
1369                 )
1370 
1371             # Validate the given through fields -- they should be actual
1372             # fields on the through model, and also be foreign keys to the
1373             # expected models.
1374             else:
1375                 assert from_model is not None, (
1376                     "ManyToManyField with intermediate "
1377                     "tables cannot be checked if you don't pass the model "
1378                     "where the field is attached to."
1379                 )
1380 
1381                 source, through, target = from_model, self.remote_field.through, self.remote_field.model
1382                 source_field_name, target_field_name = self.remote_field.through_fields[:2]
1383 
1384                 for field_name, related_model in ((source_field_name, source),
1385                                                   (target_field_name, target)):
1386 
1387                     possible_field_names = []
1388                     for f in through._meta.fields:
1389                         if hasattr(f, 'remote_field') and getattr(f.remote_field, 'model', None) == related_model:
1390                             possible_field_names.append(f.name)
1391                     if possible_field_names:
1392                         hint = "Did you mean one of the following foreign keys to '%s': %s?" % (
1393                             related_model._meta.object_name,
1394                             ', '.join(possible_field_names),
1395                         )
1396                     else:
1397                         hint = None
1398 
1399                     try:
1400                         field = through._meta.get_field(field_name)
1401                     except exceptions.FieldDoesNotExist:
1402                         errors.append(
1403                             checks.Error(
1404                                 "The intermediary model '%s' has no field '%s'."
1405                                 % (qualified_model_name, field_name),
1406                                 hint=hint,
1407                                 obj=self,
1408                                 id='fields.E338',
1409                             )
1410                         )
1411                     else:
1412                         if not (hasattr(field, 'remote_field') and
1413                                 getattr(field.remote_field, 'model', None) == related_model):
1414                             errors.append(
1415                                 checks.Error(
1416                                     "'%s.%s' is not a foreign key to '%s'." % (
1417                                         through._meta.object_name, field_name,
1418                                         related_model._meta.object_name,
1419                                     ),
1420                                     hint=hint,
1421                                     obj=self,
1422                                     id='fields.E339',
1423                                 )
1424                             )
1425 
1426         return errors
1427 
1428     def _check_table_uniqueness(self, **kwargs):
1429         if isinstance(self.remote_field.through, str) or not self.remote_field.through._meta.managed:
1430             return []
1431         registered_tables = {
1432             model._meta.db_table: model
1433             for model in self.opts.apps.get_models(include_auto_created=True)
1434             if model != self.remote_field.through and model._meta.managed
1435         }
1436         m2m_db_table = self.m2m_db_table()
1437         model = registered_tables.get(m2m_db_table)
1438         # The second condition allows multiple m2m relations on a model if
1439         # some point to a through model that proxies another through model.
1440         if model and model._meta.concrete_model != self.remote_field.through._meta.concrete_model:
1441             if model._meta.auto_created:
1442                 def _get_field_name(model):
1443                     for field in model._meta.auto_created._meta.many_to_many:
1444                         if field.remote_field.through is model:
1445                             return field.name
1446                 opts = model._meta.auto_created._meta
1447                 clashing_obj = '%s.%s' % (opts.label, _get_field_name(model))
1448             else:
1449                 clashing_obj = model._meta.label
1450             if settings.DATABASE_ROUTERS:
1451                 error_class, error_id = checks.Warning, 'fields.W344'
1452                 error_hint = (
1453                     'You have configured settings.DATABASE_ROUTERS. Verify '
1454                     'that the table of %r is correctly routed to a separate '
1455                     'database.' % clashing_obj
1456                 )
1457             else:
1458                 error_class, error_id = checks.Error, 'fields.E340'
1459                 error_hint = None
1460             return [
1461                 error_class(
1462                     "The field's intermediary table '%s' clashes with the "
1463                     "table name of '%s'." % (m2m_db_table, clashing_obj),
1464                     obj=self,
1465                     hint=error_hint,
1466                     id=error_id,
1467                 )
1468             ]
1469         return []
1470 
1471     def deconstruct(self):
1472         name, path, args, kwargs = super().deconstruct()
1473         # Handle the simpler arguments.
1474         if self.db_table is not None:
1475             kwargs['db_table'] = self.db_table
1476         if self.remote_field.db_constraint is not True:
1477             kwargs['db_constraint'] = self.remote_field.db_constraint
1478         # Rel needs more work.
1479         if isinstance(self.remote_field.model, str):
1480             kwargs['to'] = self.remote_field.model
1481         else:
1482             kwargs['to'] = self.remote_field.model._meta.label
1483         if getattr(self.remote_field, 'through', None) is not None:
1484             if isinstance(self.remote_field.through, str):
1485                 kwargs['through'] = self.remote_field.through
1486             elif not self.remote_field.through._meta.auto_created:
1487                 kwargs['through'] = self.remote_field.through._meta.label
1488         # If swappable is True, then see if we're actually pointing to the target
1489         # of a swap.
1490         swappable_setting = self.swappable_setting
1491         if swappable_setting is not None:
1492             # If it's already a settings reference, error.
1493             if hasattr(kwargs['to'], "setting_name"):
1494                 if kwargs['to'].setting_name != swappable_setting:
1495                     raise ValueError(
1496                         "Cannot deconstruct a ManyToManyField pointing to a "
1497                         "model that is swapped in place of more than one model "
1498                         "(%s and %s)" % (kwargs['to'].setting_name, swappable_setting)
1499                     )
1500 
1501             kwargs['to'] = SettingsReference(
1502                 kwargs['to'],
1503                 swappable_setting,
1504             )
1505         return name, path, args, kwargs
1506 
1507     def _get_path_info(self, direct=False, filtered_relation=None):
1508         """Called by both direct and indirect m2m traversal."""
1509         int_model = self.remote_field.through
1510         linkfield1 = int_model._meta.get_field(self.m2m_field_name())
1511         linkfield2 = int_model._meta.get_field(self.m2m_reverse_field_name())
1512         if direct:
1513             join1infos = linkfield1.get_reverse_path_info()
1514             join2infos = linkfield2.get_path_info(filtered_relation)
1515         else:
1516             join1infos = linkfield2.get_reverse_path_info()
1517             join2infos = linkfield1.get_path_info(filtered_relation)
1518 
1519         # Get join infos between the last model of join 1 and the first model
1520         # of join 2. Assume the only reason these may differ is due to model
1521         # inheritance.
1522         join1_final = join1infos[-1].to_opts
1523         join2_initial = join2infos[0].from_opts
1524         if join1_final is join2_initial:
1525             intermediate_infos = []
1526         elif issubclass(join1_final.model, join2_initial.model):
1527             intermediate_infos = join1_final.get_path_to_parent(join2_initial.model)
1528         else:
1529             intermediate_infos = join2_initial.get_path_from_parent(join1_final.model)
1530 
1531         return [*join1infos, *intermediate_infos, *join2infos]
1532 
1533     def get_path_info(self, filtered_relation=None):
1534         return self._get_path_info(direct=True, filtered_relation=filtered_relation)
1535 
1536     def get_reverse_path_info(self, filtered_relation=None):
1537         return self._get_path_info(direct=False, filtered_relation=filtered_relation)
1538 
1539     def _get_m2m_db_table(self, opts):
1540         """
1541         Function that can be curried to provide the m2m table name for this
1542         relation.
1543         """
1544         if self.remote_field.through is not None:
1545             return self.remote_field.through._meta.db_table
1546         elif self.db_table:
1547             return self.db_table
1548         else:
1549             m2m_table_name = '%s_%s' % (utils.strip_quotes(opts.db_table), self.name)
1550             return utils.truncate_name(m2m_table_name, connection.ops.max_name_length())
1551 
1552     def _get_m2m_attr(self, related, attr):
1553         """
1554         Function that can be curried to provide the source accessor or DB
1555         column name for the m2m table.
1556         """
1557         cache_attr = '_m2m_%s_cache' % attr
1558         if hasattr(self, cache_attr):
1559             return getattr(self, cache_attr)
1560         if self.remote_field.through_fields is not None:
1561             link_field_name = self.remote_field.through_fields[0]
1562         else:
1563             link_field_name = None
1564         for f in self.remote_field.through._meta.fields:
1565             if (f.is_relation and f.remote_field.model == related.related_model and
1566                     (link_field_name is None or link_field_name == f.name)):
1567                 setattr(self, cache_attr, getattr(f, attr))
1568                 return getattr(self, cache_attr)
1569 
1570     def _get_m2m_reverse_attr(self, related, attr):
1571         """
1572         Function that can be curried to provide the related accessor or DB
1573         column name for the m2m table.
1574         """
1575         cache_attr = '_m2m_reverse_%s_cache' % attr
1576         if hasattr(self, cache_attr):
1577             return getattr(self, cache_attr)
1578         found = False
1579         if self.remote_field.through_fields is not None:
1580             link_field_name = self.remote_field.through_fields[1]
1581         else:
1582             link_field_name = None
1583         for f in self.remote_field.through._meta.fields:
1584             if f.is_relation and f.remote_field.model == related.model:
1585                 if link_field_name is None and related.related_model == related.model:
1586                     # If this is an m2m-intermediate to self,
1587                     # the first foreign key you find will be
1588                     # the source column. Keep searching for
1589                     # the second foreign key.
1590                     if found:
1591                         setattr(self, cache_attr, getattr(f, attr))
1592                         break
1593                     else:
1594                         found = True
1595                 elif link_field_name is None or link_field_name == f.name:
1596                     setattr(self, cache_attr, getattr(f, attr))
1597                     break
1598         return getattr(self, cache_attr)
1599 
1600     def contribute_to_class(self, cls, name, **kwargs):
1601         # To support multiple relations to self, it's useful to have a non-None
1602         # related name on symmetrical relations for internal reasons. The
1603         # concept doesn't make a lot of sense externally ("you want me to
1604         # specify *what* on my non-reversible relation?!"), so we set it up
1605         # automatically. The funky name reduces the chance of an accidental
1606         # clash.
1607         if self.remote_field.symmetrical and (
1608             self.remote_field.model == RECURSIVE_RELATIONSHIP_CONSTANT or
1609             self.remote_field.model == cls._meta.object_name
1610         ):
1611             self.remote_field.related_name = "%s_rel_+" % name
1612         elif self.remote_field.is_hidden():
1613             # If the backwards relation is disabled, replace the original
1614             # related_name with one generated from the m2m field name. Django
1615             # still uses backwards relations internally and we need to avoid
1616             # clashes between multiple m2m fields with related_name == '+'.
1617             self.remote_field.related_name = "_%s_%s_+" % (cls.__name__.lower(), name)
1618 
1619         super().contribute_to_class(cls, name, **kwargs)
1620 
1621         # The intermediate m2m model is not auto created if:
1622         #  1) There is a manually specified intermediate, or
1623         #  2) The class owning the m2m field is abstract.
1624         #  3) The class owning the m2m field has been swapped out.
1625         if not cls._meta.abstract:
1626             if self.remote_field.through:
1627                 def resolve_through_model(_, model, field):
1628                     field.remote_field.through = model
1629                 lazy_related_operation(resolve_through_model, cls, self.remote_field.through, field=self)
1630             elif not cls._meta.swapped:
1631                 self.remote_field.through = create_many_to_many_intermediary_model(self, cls)
1632 
1633         # Add the descriptor for the m2m relation.
1634         setattr(cls, self.name, ManyToManyDescriptor(self.remote_field, reverse=False))
1635 
1636         # Set up the accessor for the m2m table name for the relation.
1637         self.m2m_db_table = partial(self._get_m2m_db_table, cls._meta)
1638 
1639     def contribute_to_related_class(self, cls, related):
1640         # Internal M2Ms (i.e., those with a related name ending with '+')
1641         # and swapped models don't get a related descriptor.
1642         if not self.remote_field.is_hidden() and not related.related_model._meta.swapped:
1643             setattr(cls, related.get_accessor_name(), ManyToManyDescriptor(self.remote_field, reverse=True))
1644 
1645         # Set up the accessors for the column names on the m2m table.
1646         self.m2m_column_name = partial(self._get_m2m_attr, related, 'column')
1647         self.m2m_reverse_name = partial(self._get_m2m_reverse_attr, related, 'column')
1648 
1649         self.m2m_field_name = partial(self._get_m2m_attr, related, 'name')
1650         self.m2m_reverse_field_name = partial(self._get_m2m_reverse_attr, related, 'name')
1651 
1652         get_m2m_rel = partial(self._get_m2m_attr, related, 'remote_field')
1653         self.m2m_target_field_name = lambda: get_m2m_rel().field_name
1654         get_m2m_reverse_rel = partial(self._get_m2m_reverse_attr, related, 'remote_field')
1655         self.m2m_reverse_target_field_name = lambda: get_m2m_reverse_rel().field_name
1656 
1657     def set_attributes_from_rel(self):
1658         pass
1659 
1660     def value_from_object(self, obj):
1661         return [] if obj.pk is None else list(getattr(obj, self.attname).all())
1662 
1663     def save_form_data(self, instance, data):
1664         getattr(instance, self.attname).set(data)
1665 
1666     def formfield(self, *, using=None, **kwargs):
1667         defaults = {
1668             'form_class': forms.ModelMultipleChoiceField,
1669             'queryset': self.remote_field.model._default_manager.using(using),
1670             **kwargs,
1671         }
1672         # If initial is passed in, it's a list of related objects, but the
1673         # MultipleChoiceField takes a list of IDs.
1674         if defaults.get('initial') is not None:
1675             initial = defaults['initial']
1676             if callable(initial):
1677                 initial = initial()
1678             defaults['initial'] = [i.pk for i in initial]
1679         return super().formfield(**defaults)
1680 
1681     def db_check(self, connection):
1682         return None
1683 
1684     def db_type(self, connection):
1685         # A ManyToManyField is not represented by a single column,
1686         # so return None.
1687         return None
1688 
1689     def db_parameters(self, connection):
1690         return {"type": None, "check": None}

</code><intended_behavior>Ensure that the usage of 'related_name='+' does not lead to conflicts during migration generation, effectively isolating the many-to-many relationships as per the design goal of using 'related_name='+'.</intended_behavior>]
2025-10-18 12:32:46.564 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-18 12:32:46.564 | INFO     | Search-only: skipping patch selection
2025-10-18 12:32:46.698 | INFO     | Task django__django-13822 completed successfully.
2025-10-18 12:32:46.699 | INFO     | No patch generated. You can try running ACR again.
