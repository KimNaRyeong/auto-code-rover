[
    {
        "rel_file_path": "django/db/migrations/state.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.2/django/db/migrations/state.py",
        "start": 1,
        "end": 604,
        "class_name": null,
        "method_name": null,
        "code": "1 import copy\n2 from contextlib import contextmanager\n3 \n4 from django.apps import AppConfig\n5 from django.apps.registry import Apps, apps as global_apps\n6 from django.conf import settings\n7 from django.db import models\n8 from django.db.models.fields.related import RECURSIVE_RELATIONSHIP_CONSTANT\n9 from django.db.models.options import DEFAULT_NAMES, normalize_together\n10 from django.db.models.utils import make_model_tuple\n11 from django.utils.functional import cached_property\n12 from django.utils.module_loading import import_string\n13 from django.utils.version import get_docs_version\n14 \n15 from .exceptions import InvalidBasesError\n16 \n17 \n18 def _get_app_label_and_model_name(model, app_label=''):\n19     if isinstance(model, str):\n20         split = model.split('.', 1)\n21         return tuple(split) if len(split) == 2 else (app_label, split[0])\n22     else:\n23         return model._meta.app_label, model._meta.model_name\n24 \n25 \n26 def _get_related_models(m):\n27     \"\"\"Return all models that have a direct relationship to the given model.\"\"\"\n28     related_models = [\n29         subclass for subclass in m.__subclasses__()\n30         if issubclass(subclass, models.Model)\n31     ]\n32     related_fields_models = set()\n33     for f in m._meta.get_fields(include_parents=True, include_hidden=True):\n34         if f.is_relation and f.related_model is not None and not isinstance(f.related_model, str):\n35             related_fields_models.add(f.model)\n36             related_models.append(f.related_model)\n37     # Reverse accessors of foreign keys to proxy models are attached to their\n38     # concrete proxied model.\n39     opts = m._meta\n40     if opts.proxy and m in related_fields_models:\n41         related_models.append(opts.concrete_model)\n42     return related_models\n43 \n44 \n45 def get_related_models_tuples(model):\n46     \"\"\"\n47     Return a list of typical (app_label, model_name) tuples for all related\n48     models for the given model.\n49     \"\"\"\n50     return {\n51         (rel_mod._meta.app_label, rel_mod._meta.model_name)\n52         for rel_mod in _get_related_models(model)\n53     }\n54 \n55 \n56 def get_related_models_recursive(model):\n57     \"\"\"\n58     Return all models that have a direct or indirect relationship\n59     to the given model.\n60 \n61     Relationships are either defined by explicit relational fields, like\n62     ForeignKey, ManyToManyField or OneToOneField, or by inheriting from another\n63     model (a superclass is related to its subclasses, but not vice versa). Note,\n64     however, that a model inheriting from a concrete model is also related to\n65     its superclass through the implicit *_ptr OneToOneField on the subclass.\n66     \"\"\"\n67     seen = set()\n68     queue = _get_related_models(model)\n69     for rel_mod in queue:\n70         rel_app_label, rel_model_name = rel_mod._meta.app_label, rel_mod._meta.model_name\n71         if (rel_app_label, rel_model_name) in seen:\n72             continue\n73         seen.add((rel_app_label, rel_model_name))\n74         queue.extend(_get_related_models(rel_mod))\n75     return seen - {(model._meta.app_label, model._meta.model_name)}\n76 \n77 \n78 class ProjectState:\n79     \"\"\"\n80     Represent the entire project's overall state. This is the item that is\n81     passed around - do it here rather than at the app level so that cross-app\n82     FKs/etc. resolve properly.\n83     \"\"\"\n84 \n85     def __init__(self, models=None, real_apps=None):\n86         self.models = models or {}\n87         # Apps to include from main registry, usually unmigrated ones\n88         self.real_apps = real_apps or []\n89         self.is_delayed = False\n90 \n91     def add_model(self, model_state):\n92         app_label, model_name = model_state.app_label, model_state.name_lower\n93         self.models[(app_label, model_name)] = model_state\n94         if 'apps' in self.__dict__:  # hasattr would cache the property\n95             self.reload_model(app_label, model_name)\n96 \n97     def remove_model(self, app_label, model_name):\n98         del self.models[app_label, model_name]\n99         if 'apps' in self.__dict__:  # hasattr would cache the property\n100             self.apps.unregister_model(app_label, model_name)\n101             # Need to do this explicitly since unregister_model() doesn't clear\n102             # the cache automatically (#24513)\n103             self.apps.clear_cache()\n104 \n105     def _find_reload_model(self, app_label, model_name, delay=False):\n106         if delay:\n107             self.is_delayed = True\n108 \n109         related_models = set()\n110 \n111         try:\n112             old_model = self.apps.get_model(app_label, model_name)\n113         except LookupError:\n114             pass\n115         else:\n116             # Get all relations to and from the old model before reloading,\n117             # as _meta.apps may change\n118             if delay:\n119                 related_models = get_related_models_tuples(old_model)\n120             else:\n121                 related_models = get_related_models_recursive(old_model)\n122 \n123         # Get all outgoing references from the model to be rendered\n124         model_state = self.models[(app_label, model_name)]\n125         # Directly related models are the models pointed to by ForeignKeys,\n126         # OneToOneFields, and ManyToManyFields.\n127         direct_related_models = set()\n128         for field in model_state.fields.values():\n129             if field.is_relation:\n130                 if field.remote_field.model == RECURSIVE_RELATIONSHIP_CONSTANT:\n131                     continue\n132                 rel_app_label, rel_model_name = _get_app_label_and_model_name(field.related_model, app_label)\n133                 direct_related_models.add((rel_app_label, rel_model_name.lower()))\n134 \n135         # For all direct related models recursively get all related models.\n136         related_models.update(direct_related_models)\n137         for rel_app_label, rel_model_name in direct_related_models:\n138             try:\n139                 rel_model = self.apps.get_model(rel_app_label, rel_model_name)\n140             except LookupError:\n141                 pass\n142             else:\n143                 if delay:\n144                     related_models.update(get_related_models_tuples(rel_model))\n145                 else:\n146                     related_models.update(get_related_models_recursive(rel_model))\n147 \n148         # Include the model itself\n149         related_models.add((app_label, model_name))\n150 \n151         return related_models\n152 \n153     def reload_model(self, app_label, model_name, delay=False):\n154         if 'apps' in self.__dict__:  # hasattr would cache the property\n155             related_models = self._find_reload_model(app_label, model_name, delay)\n156             self._reload(related_models)\n157 \n158     def reload_models(self, models, delay=True):\n159         if 'apps' in self.__dict__:  # hasattr would cache the property\n160             related_models = set()\n161             for app_label, model_name in models:\n162                 related_models.update(self._find_reload_model(app_label, model_name, delay))\n163             self._reload(related_models)\n164 \n165     def _reload(self, related_models):\n166         # Unregister all related models\n167         with self.apps.bulk_update():\n168             for rel_app_label, rel_model_name in related_models:\n169                 self.apps.unregister_model(rel_app_label, rel_model_name)\n170 \n171         states_to_be_rendered = []\n172         # Gather all models states of those models that will be rerendered.\n173         # This includes:\n174         # 1. All related models of unmigrated apps\n175         for model_state in self.apps.real_models:\n176             if (model_state.app_label, model_state.name_lower) in related_models:\n177                 states_to_be_rendered.append(model_state)\n178 \n179         # 2. All related models of migrated apps\n180         for rel_app_label, rel_model_name in related_models:\n181             try:\n182                 model_state = self.models[rel_app_label, rel_model_name]\n183             except KeyError:\n184                 pass\n185             else:\n186                 states_to_be_rendered.append(model_state)\n187 \n188         # Render all models\n189         self.apps.render_multiple(states_to_be_rendered)\n190 \n191     def clone(self):\n192         \"\"\"Return an exact copy of this ProjectState.\"\"\"\n193         new_state = ProjectState(\n194             models={k: v.clone() for k, v in self.models.items()},\n195             real_apps=self.real_apps,\n196         )\n197         if 'apps' in self.__dict__:\n198             new_state.apps = self.apps.clone()\n199         new_state.is_delayed = self.is_delayed\n200         return new_state\n201 \n202     def clear_delayed_apps_cache(self):\n203         if self.is_delayed and 'apps' in self.__dict__:\n204             del self.__dict__['apps']\n205 \n206     @cached_property\n207     def apps(self):\n208         return StateApps(self.real_apps, self.models)\n209 \n210     @property\n211     def concrete_apps(self):\n212         self.apps = StateApps(self.real_apps, self.models, ignore_swappable=True)\n213         return self.apps\n214 \n215     @classmethod\n216     def from_apps(cls, apps):\n217         \"\"\"Take an Apps and return a ProjectState matching it.\"\"\"\n218         app_models = {}\n219         for model in apps.get_models(include_swapped=True):\n220             model_state = ModelState.from_model(model)\n221             app_models[(model_state.app_label, model_state.name_lower)] = model_state\n222         return cls(app_models)\n223 \n224     def __eq__(self, other):\n225         return self.models == other.models and set(self.real_apps) == set(other.real_apps)\n226 \n227 \n228 class AppConfigStub(AppConfig):\n229     \"\"\"Stub of an AppConfig. Only provides a label and a dict of models.\"\"\"\n230     def __init__(self, label):\n231         self.apps = None\n232         self.models = {}\n233         # App-label and app-name are not the same thing, so technically passing\n234         # in the label here is wrong. In practice, migrations don't care about\n235         # the app name, but we need something unique, and the label works fine.\n236         self.label = label\n237         self.name = label\n238 \n239     def import_models(self):\n240         self.models = self.apps.all_models[self.label]\n241 \n242 \n243 class StateApps(Apps):\n244     \"\"\"\n245     Subclass of the global Apps registry class to better handle dynamic model\n246     additions and removals.\n247     \"\"\"\n248     def __init__(self, real_apps, models, ignore_swappable=False):\n249         # Any apps in self.real_apps should have all their models included\n250         # in the render. We don't use the original model instances as there\n251         # are some variables that refer to the Apps object.\n252         # FKs/M2Ms from real apps are also not included as they just\n253         # mess things up with partial states (due to lack of dependencies)\n254         self.real_models = []\n255         for app_label in real_apps:\n256             app = global_apps.get_app_config(app_label)\n257             for model in app.get_models():\n258                 self.real_models.append(ModelState.from_model(model, exclude_rels=True))\n259         # Populate the app registry with a stub for each application.\n260         app_labels = {model_state.app_label for model_state in models.values()}\n261         app_configs = [AppConfigStub(label) for label in sorted([*real_apps, *app_labels])]\n262         super().__init__(app_configs)\n263 \n264         # These locks get in the way of copying as implemented in clone(),\n265         # which is called whenever Django duplicates a StateApps before\n266         # updating it.\n267         self._lock = None\n268         self.ready_event = None\n269 \n270         self.render_multiple([*models.values(), *self.real_models])\n271 \n272         # There shouldn't be any operations pending at this point.\n273         from django.core.checks.model_checks import _check_lazy_references\n274         ignore = {make_model_tuple(settings.AUTH_USER_MODEL)} if ignore_swappable else set()\n275         errors = _check_lazy_references(self, ignore=ignore)\n276         if errors:\n277             raise ValueError(\"\\n\".join(error.msg for error in errors))\n278 \n279     @contextmanager\n280     def bulk_update(self):\n281         # Avoid clearing each model's cache for each change. Instead, clear\n282         # all caches when we're finished updating the model instances.\n283         ready = self.ready\n284         self.ready = False\n285         try:\n286             yield\n287         finally:\n288             self.ready = ready\n289             self.clear_cache()\n290 \n291     def render_multiple(self, model_states):\n292         # We keep trying to render the models in a loop, ignoring invalid\n293         # base errors, until the size of the unrendered models doesn't\n294         # decrease by at least one, meaning there's a base dependency loop/\n295         # missing base.\n296         if not model_states:\n297             return\n298         # Prevent that all model caches are expired for each render.\n299         with self.bulk_update():\n300             unrendered_models = model_states\n301             while unrendered_models:\n302                 new_unrendered_models = []\n303                 for model in unrendered_models:\n304                     try:\n305                         model.render(self)\n306                     except InvalidBasesError:\n307                         new_unrendered_models.append(model)\n308                 if len(new_unrendered_models) == len(unrendered_models):\n309                     raise InvalidBasesError(\n310                         \"Cannot resolve bases for %r\\nThis can happen if you are inheriting models from an \"\n311                         \"app with migrations (e.g. contrib.auth)\\n in an app with no migrations; see \"\n312                         \"https://docs.djangoproject.com/en/%s/topics/migrations/#dependencies \"\n313                         \"for more\" % (new_unrendered_models, get_docs_version())\n314                     )\n315                 unrendered_models = new_unrendered_models\n316 \n317     def clone(self):\n318         \"\"\"Return a clone of this registry.\"\"\"\n319         clone = StateApps([], {})\n320         clone.all_models = copy.deepcopy(self.all_models)\n321         clone.app_configs = copy.deepcopy(self.app_configs)\n322         # Set the pointer to the correct app registry.\n323         for app_config in clone.app_configs.values():\n324             app_config.apps = clone\n325         # No need to actually clone them, they'll never change\n326         clone.real_models = self.real_models\n327         return clone\n328 \n329     def register_model(self, app_label, model):\n330         self.all_models[app_label][model._meta.model_name] = model\n331         if app_label not in self.app_configs:\n332             self.app_configs[app_label] = AppConfigStub(app_label)\n333             self.app_configs[app_label].apps = self\n334         self.app_configs[app_label].models[model._meta.model_name] = model\n335         self.do_pending_operations(model)\n336         self.clear_cache()\n337 \n338     def unregister_model(self, app_label, model_name):\n339         try:\n340             del self.all_models[app_label][model_name]\n341             del self.app_configs[app_label].models[model_name]\n342         except KeyError:\n343             pass\n344 \n345 \n346 class ModelState:\n347     \"\"\"\n348     Represent a Django Model. Don't use the actual Model class as it's not\n349     designed to have its options changed - instead, mutate this one and then\n350     render it into a Model as required.\n351 \n352     Note that while you are allowed to mutate .fields, you are not allowed\n353     to mutate the Field instances inside there themselves - you must instead\n354     assign new ones, as these are not detached during a clone.\n355     \"\"\"\n356 \n357     def __init__(self, app_label, name, fields, options=None, bases=None, managers=None):\n358         self.app_label = app_label\n359         self.name = name\n360         self.fields = dict(fields)\n361         self.options = options or {}\n362         self.options.setdefault('indexes', [])\n363         self.options.setdefault('constraints', [])\n364         self.bases = bases or (models.Model,)\n365         self.managers = managers or []\n366         for name, field in self.fields.items():\n367             # Sanity-check that fields are NOT already bound to a model.\n368             if hasattr(field, 'model'):\n369                 raise ValueError(\n370                     'ModelState.fields cannot be bound to a model - \"%s\" is.' % name\n371                 )\n372             # Sanity-check that relation fields are NOT referring to a model class.\n373             if field.is_relation and hasattr(field.related_model, '_meta'):\n374                 raise ValueError(\n375                     'ModelState.fields cannot refer to a model class - \"%s.to\" does. '\n376                     'Use a string reference instead.' % name\n377                 )\n378             if field.many_to_many and hasattr(field.remote_field.through, '_meta'):\n379                 raise ValueError(\n380                     'ModelState.fields cannot refer to a model class - \"%s.through\" does. '\n381                     'Use a string reference instead.' % name\n382                 )\n383         # Sanity-check that indexes have their name set.\n384         for index in self.options['indexes']:\n385             if not index.name:\n386                 raise ValueError(\n387                     \"Indexes passed to ModelState require a name attribute. \"\n388                     \"%r doesn't have one.\" % index\n389                 )\n390 \n391     @cached_property\n392     def name_lower(self):\n393         return self.name.lower()\n394 \n395     @classmethod\n396     def from_model(cls, model, exclude_rels=False):\n397         \"\"\"Given a model, return a ModelState representing it.\"\"\"\n398         # Deconstruct the fields\n399         fields = []\n400         for field in model._meta.local_fields:\n401             if getattr(field, \"remote_field\", None) and exclude_rels:\n402                 continue\n403             if isinstance(field, models.OrderWrt):\n404                 continue\n405             name = field.name\n406             try:\n407                 fields.append((name, field.clone()))\n408             except TypeError as e:\n409                 raise TypeError(\"Couldn't reconstruct field %s on %s: %s\" % (\n410                     name,\n411                     model._meta.label,\n412                     e,\n413                 ))\n414         if not exclude_rels:\n415             for field in model._meta.local_many_to_many:\n416                 name = field.name\n417                 try:\n418                     fields.append((name, field.clone()))\n419                 except TypeError as e:\n420                     raise TypeError(\"Couldn't reconstruct m2m field %s on %s: %s\" % (\n421                         name,\n422                         model._meta.object_name,\n423                         e,\n424                     ))\n425         # Extract the options\n426         options = {}\n427         for name in DEFAULT_NAMES:\n428             # Ignore some special options\n429             if name in [\"apps\", \"app_label\"]:\n430                 continue\n431             elif name in model._meta.original_attrs:\n432                 if name == \"unique_together\":\n433                     ut = model._meta.original_attrs[\"unique_together\"]\n434                     options[name] = set(normalize_together(ut))\n435                 elif name == \"index_together\":\n436                     it = model._meta.original_attrs[\"index_together\"]\n437                     options[name] = set(normalize_together(it))\n438                 elif name == \"indexes\":\n439                     indexes = [idx.clone() for idx in model._meta.indexes]\n440                     for index in indexes:\n441                         if not index.name:\n442                             index.set_name_with_model(model)\n443                     options['indexes'] = indexes\n444                 elif name == 'constraints':\n445                     options['constraints'] = [con.clone() for con in model._meta.constraints]\n446                 else:\n447                     options[name] = model._meta.original_attrs[name]\n448         # If we're ignoring relationships, remove all field-listing model\n449         # options (that option basically just means \"make a stub model\")\n450         if exclude_rels:\n451             for key in [\"unique_together\", \"index_together\", \"order_with_respect_to\"]:\n452                 if key in options:\n453                     del options[key]\n454         # Private fields are ignored, so remove options that refer to them.\n455         elif options.get('order_with_respect_to') in {field.name for field in model._meta.private_fields}:\n456             del options['order_with_respect_to']\n457 \n458         def flatten_bases(model):\n459             bases = []\n460             for base in model.__bases__:\n461                 if hasattr(base, \"_meta\") and base._meta.abstract:\n462                     bases.extend(flatten_bases(base))\n463                 else:\n464                     bases.append(base)\n465             return bases\n466 \n467         # We can't rely on __mro__ directly because we only want to flatten\n468         # abstract models and not the whole tree. However by recursing on\n469         # __bases__ we may end up with duplicates and ordering issues, we\n470         # therefore discard any duplicates and reorder the bases according\n471         # to their index in the MRO.\n472         flattened_bases = sorted(set(flatten_bases(model)), key=lambda x: model.__mro__.index(x))\n473 \n474         # Make our record\n475         bases = tuple(\n476             (\n477                 base._meta.label_lower\n478                 if hasattr(base, \"_meta\") else\n479                 base\n480             )\n481             for base in flattened_bases\n482         )\n483         # Ensure at least one base inherits from models.Model\n484         if not any((isinstance(base, str) or issubclass(base, models.Model)) for base in bases):\n485             bases = (models.Model,)\n486 \n487         managers = []\n488         manager_names = set()\n489         default_manager_shim = None\n490         for manager in model._meta.managers:\n491             if manager.name in manager_names:\n492                 # Skip overridden managers.\n493                 continue\n494             elif manager.use_in_migrations:\n495                 # Copy managers usable in migrations.\n496                 new_manager = copy.copy(manager)\n497                 new_manager._set_creation_counter()\n498             elif manager is model._base_manager or manager is model._default_manager:\n499                 # Shim custom managers used as default and base managers.\n500                 new_manager = models.Manager()\n501                 new_manager.model = manager.model\n502                 new_manager.name = manager.name\n503                 if manager is model._default_manager:\n504                     default_manager_shim = new_manager\n505             else:\n506                 continue\n507             manager_names.add(manager.name)\n508             managers.append((manager.name, new_manager))\n509 \n510         # Ignore a shimmed default manager called objects if it's the only one.\n511         if managers == [('objects', default_manager_shim)]:\n512             managers = []\n513 \n514         # Construct the new ModelState\n515         return cls(\n516             model._meta.app_label,\n517             model._meta.object_name,\n518             fields,\n519             options,\n520             bases,\n521             managers,\n522         )\n523 \n524     def construct_managers(self):\n525         \"\"\"Deep-clone the managers using deconstruction.\"\"\"\n526         # Sort all managers by their creation counter\n527         sorted_managers = sorted(self.managers, key=lambda v: v[1].creation_counter)\n528         for mgr_name, manager in sorted_managers:\n529             as_manager, manager_path, qs_path, args, kwargs = manager.deconstruct()\n530             if as_manager:\n531                 qs_class = import_string(qs_path)\n532                 yield mgr_name, qs_class.as_manager()\n533             else:\n534                 manager_class = import_string(manager_path)\n535                 yield mgr_name, manager_class(*args, **kwargs)\n536 \n537     def clone(self):\n538         \"\"\"Return an exact copy of this ModelState.\"\"\"\n539         return self.__class__(\n540             app_label=self.app_label,\n541             name=self.name,\n542             fields=dict(self.fields),\n543             # Since options are shallow-copied here, operations such as\n544             # AddIndex must replace their option (e.g 'indexes') rather\n545             # than mutating it.\n546             options=dict(self.options),\n547             bases=self.bases,\n548             managers=list(self.managers),\n549         )\n550 \n551     def render(self, apps):\n552         \"\"\"Create a Model object from our current state into the given apps.\"\"\"\n553         # First, make a Meta object\n554         meta_contents = {'app_label': self.app_label, 'apps': apps, **self.options}\n555         meta = type(\"Meta\", (), meta_contents)\n556         # Then, work out our bases\n557         try:\n558             bases = tuple(\n559                 (apps.get_model(base) if isinstance(base, str) else base)\n560                 for base in self.bases\n561             )\n562         except LookupError:\n563             raise InvalidBasesError(\"Cannot resolve one or more bases from %r\" % (self.bases,))\n564         # Clone fields for the body, add other bits.\n565         body = {name: field.clone() for name, field in self.fields.items()}\n566         body['Meta'] = meta\n567         body['__module__'] = \"__fake__\"\n568 \n569         # Restore managers\n570         body.update(self.construct_managers())\n571         # Then, make a Model object (apps.register_model is called in __new__)\n572         return type(self.name, bases, body)\n573 \n574     def get_index_by_name(self, name):\n575         for index in self.options['indexes']:\n576             if index.name == name:\n577                 return index\n578         raise ValueError(\"No index named %s on model %s\" % (name, self.name))\n579 \n580     def get_constraint_by_name(self, name):\n581         for constraint in self.options['constraints']:\n582             if constraint.name == name:\n583                 return constraint\n584         raise ValueError('No constraint named %s on model %s' % (name, self.name))\n585 \n586     def __repr__(self):\n587         return \"<%s: '%s.%s'>\" % (self.__class__.__name__, self.app_label, self.name)\n588 \n589     def __eq__(self, other):\n590         return (\n591             (self.app_label == other.app_label) and\n592             (self.name == other.name) and\n593             (len(self.fields) == len(other.fields)) and\n594             all(\n595                 k1 == k2 and f1.deconstruct()[1:] == f2.deconstruct()[1:]\n596                 for (k1, f1), (k2, f2) in zip(\n597                     sorted(self.fields.items()),\n598                     sorted(other.fields.items()),\n599                 )\n600             ) and\n601             (self.options == other.options) and\n602             (self.bases == other.bases) and\n603             (self.managers == other.managers)\n604         )\n",
        "intended_behavior": "Adjust the state management logic to correctly differentiate between identical model names in different apps, ensuring that migrations involving these models do not raise fields.E305 errors."
    },
    {
        "rel_file_path": "django/db/models/fields/related.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.2/django/db/models/fields/related.py",
        "start": 1,
        "end": 1690,
        "class_name": null,
        "method_name": null,
        "code": "1 import functools\n2 import inspect\n3 from functools import partial\n4 \n5 from django import forms\n6 from django.apps import apps\n7 from django.conf import SettingsReference, settings\n8 from django.core import checks, exceptions\n9 from django.db import connection, router\n10 from django.db.backends import utils\n11 from django.db.models import Q\n12 from django.db.models.constants import LOOKUP_SEP\n13 from django.db.models.deletion import CASCADE, SET_DEFAULT, SET_NULL\n14 from django.db.models.query_utils import PathInfo\n15 from django.db.models.utils import make_model_tuple\n16 from django.utils.functional import cached_property\n17 from django.utils.translation import gettext_lazy as _\n18 \n19 from . import Field\n20 from .mixins import FieldCacheMixin\n21 from .related_descriptors import (\n22     ForeignKeyDeferredAttribute, ForwardManyToOneDescriptor,\n23     ForwardOneToOneDescriptor, ManyToManyDescriptor,\n24     ReverseManyToOneDescriptor, ReverseOneToOneDescriptor,\n25 )\n26 from .related_lookups import (\n27     RelatedExact, RelatedGreaterThan, RelatedGreaterThanOrEqual, RelatedIn,\n28     RelatedIsNull, RelatedLessThan, RelatedLessThanOrEqual,\n29 )\n30 from .reverse_related import (\n31     ForeignObjectRel, ManyToManyRel, ManyToOneRel, OneToOneRel,\n32 )\n33 \n34 RECURSIVE_RELATIONSHIP_CONSTANT = 'self'\n35 \n36 \n37 def resolve_relation(scope_model, relation):\n38     \"\"\"\n39     Transform relation into a model or fully-qualified model string of the form\n40     \"app_label.ModelName\", relative to scope_model.\n41 \n42     The relation argument can be:\n43       * RECURSIVE_RELATIONSHIP_CONSTANT, i.e. the string \"self\", in which case\n44         the model argument will be returned.\n45       * A bare model name without an app_label, in which case scope_model's\n46         app_label will be prepended.\n47       * An \"app_label.ModelName\" string.\n48       * A model class, which will be returned unchanged.\n49     \"\"\"\n50     # Check for recursive relations\n51     if relation == RECURSIVE_RELATIONSHIP_CONSTANT:\n52         relation = scope_model\n53 \n54     # Look for an \"app.Model\" relation\n55     if isinstance(relation, str):\n56         if \".\" not in relation:\n57             relation = \"%s.%s\" % (scope_model._meta.app_label, relation)\n58 \n59     return relation\n60 \n61 \n62 def lazy_related_operation(function, model, *related_models, **kwargs):\n63     \"\"\"\n64     Schedule `function` to be called once `model` and all `related_models`\n65     have been imported and registered with the app registry. `function` will\n66     be called with the newly-loaded model classes as its positional arguments,\n67     plus any optional keyword arguments.\n68 \n69     The `model` argument must be a model class. Each subsequent positional\n70     argument is another model, or a reference to another model - see\n71     `resolve_relation()` for the various forms these may take. Any relative\n72     references will be resolved relative to `model`.\n73 \n74     This is a convenience wrapper for `Apps.lazy_model_operation` - the app\n75     registry model used is the one found in `model._meta.apps`.\n76     \"\"\"\n77     models = [model] + [resolve_relation(model, rel) for rel in related_models]\n78     model_keys = (make_model_tuple(m) for m in models)\n79     apps = model._meta.apps\n80     return apps.lazy_model_operation(partial(function, **kwargs), *model_keys)\n81 \n82 \n83 class RelatedField(FieldCacheMixin, Field):\n84     \"\"\"Base class that all relational fields inherit from.\"\"\"\n85 \n86     # Field flags\n87     one_to_many = False\n88     one_to_one = False\n89     many_to_many = False\n90     many_to_one = False\n91 \n92     @cached_property\n93     def related_model(self):\n94         # Can't cache this property until all the models are loaded.\n95         apps.check_models_ready()\n96         return self.remote_field.model\n97 \n98     def check(self, **kwargs):\n99         return [\n100             *super().check(**kwargs),\n101             *self._check_related_name_is_valid(),\n102             *self._check_related_query_name_is_valid(),\n103             *self._check_relation_model_exists(),\n104             *self._check_referencing_to_swapped_model(),\n105             *self._check_clashes(),\n106         ]\n107 \n108     def _check_related_name_is_valid(self):\n109         import keyword\n110         related_name = self.remote_field.related_name\n111         if related_name is None:\n112             return []\n113         is_valid_id = not keyword.iskeyword(related_name) and related_name.isidentifier()\n114         if not (is_valid_id or related_name.endswith('+')):\n115             return [\n116                 checks.Error(\n117                     \"The name '%s' is invalid related_name for field %s.%s\" %\n118                     (self.remote_field.related_name, self.model._meta.object_name,\n119                      self.name),\n120                     hint=\"Related name must be a valid Python identifier or end with a '+'\",\n121                     obj=self,\n122                     id='fields.E306',\n123                 )\n124             ]\n125         return []\n126 \n127     def _check_related_query_name_is_valid(self):\n128         if self.remote_field.is_hidden():\n129             return []\n130         rel_query_name = self.related_query_name()\n131         errors = []\n132         if rel_query_name.endswith('_'):\n133             errors.append(\n134                 checks.Error(\n135                     \"Reverse query name '%s' must not end with an underscore.\"\n136                     % rel_query_name,\n137                     hint=(\"Add or change a related_name or related_query_name \"\n138                           \"argument for this field.\"),\n139                     obj=self,\n140                     id='fields.E308',\n141                 )\n142             )\n143         if LOOKUP_SEP in rel_query_name:\n144             errors.append(\n145                 checks.Error(\n146                     \"Reverse query name '%s' must not contain '%s'.\"\n147                     % (rel_query_name, LOOKUP_SEP),\n148                     hint=(\"Add or change a related_name or related_query_name \"\n149                           \"argument for this field.\"),\n150                     obj=self,\n151                     id='fields.E309',\n152                 )\n153             )\n154         return errors\n155 \n156     def _check_relation_model_exists(self):\n157         rel_is_missing = self.remote_field.model not in self.opts.apps.get_models()\n158         rel_is_string = isinstance(self.remote_field.model, str)\n159         model_name = self.remote_field.model if rel_is_string else self.remote_field.model._meta.object_name\n160         if rel_is_missing and (rel_is_string or not self.remote_field.model._meta.swapped):\n161             return [\n162                 checks.Error(\n163                     \"Field defines a relation with model '%s', which is either \"\n164                     \"not installed, or is abstract.\" % model_name,\n165                     obj=self,\n166                     id='fields.E300',\n167                 )\n168             ]\n169         return []\n170 \n171     def _check_referencing_to_swapped_model(self):\n172         if (self.remote_field.model not in self.opts.apps.get_models() and\n173                 not isinstance(self.remote_field.model, str) and\n174                 self.remote_field.model._meta.swapped):\n175             return [\n176                 checks.Error(\n177                     \"Field defines a relation with the model '%s', which has \"\n178                     \"been swapped out.\" % self.remote_field.model._meta.label,\n179                     hint=\"Update the relation to point at 'settings.%s'.\" % self.remote_field.model._meta.swappable,\n180                     obj=self,\n181                     id='fields.E301',\n182                 )\n183             ]\n184         return []\n185 \n186     def _check_clashes(self):\n187         \"\"\"Check accessor and reverse query name clashes.\"\"\"\n188         from django.db.models.base import ModelBase\n189 \n190         errors = []\n191         opts = self.model._meta\n192 \n193         # `f.remote_field.model` may be a string instead of a model. Skip if model name is\n194         # not resolved.\n195         if not isinstance(self.remote_field.model, ModelBase):\n196             return []\n197 \n198         # Consider that we are checking field `Model.foreign` and the models\n199         # are:\n200         #\n201         #     class Target(models.Model):\n202         #         model = models.IntegerField()\n203         #         model_set = models.IntegerField()\n204         #\n205         #     class Model(models.Model):\n206         #         foreign = models.ForeignKey(Target)\n207         #         m2m = models.ManyToManyField(Target)\n208 \n209         # rel_opts.object_name == \"Target\"\n210         rel_opts = self.remote_field.model._meta\n211         # If the field doesn't install a backward relation on the target model\n212         # (so `is_hidden` returns True), then there are no clashes to check\n213         # and we can skip these fields.\n214         rel_is_hidden = self.remote_field.is_hidden()\n215         rel_name = self.remote_field.get_accessor_name()  # i. e. \"model_set\"\n216         rel_query_name = self.related_query_name()  # i. e. \"model\"\n217         # i.e. \"app_label.Model.field\".\n218         field_name = '%s.%s' % (opts.label, self.name)\n219 \n220         # Check clashes between accessor or reverse query name of `field`\n221         # and any other field name -- i.e. accessor for Model.foreign is\n222         # model_set and it clashes with Target.model_set.\n223         potential_clashes = rel_opts.fields + rel_opts.many_to_many\n224         for clash_field in potential_clashes:\n225             # i.e. \"app_label.Target.model_set\".\n226             clash_name = '%s.%s' % (rel_opts.label, clash_field.name)\n227             if not rel_is_hidden and clash_field.name == rel_name:\n228                 errors.append(\n229                     checks.Error(\n230                         \"Reverse accessor for '%s' clashes with field name '%s'.\" % (field_name, clash_name),\n231                         hint=(\"Rename field '%s', or add/change a related_name \"\n232                               \"argument to the definition for field '%s'.\") % (clash_name, field_name),\n233                         obj=self,\n234                         id='fields.E302',\n235                     )\n236                 )\n237 \n238             if clash_field.name == rel_query_name:\n239                 errors.append(\n240                     checks.Error(\n241                         \"Reverse query name for '%s' clashes with field name '%s'.\" % (field_name, clash_name),\n242                         hint=(\"Rename field '%s', or add/change a related_name \"\n243                               \"argument to the definition for field '%s'.\") % (clash_name, field_name),\n244                         obj=self,\n245                         id='fields.E303',\n246                     )\n247                 )\n248 \n249         # Check clashes between accessors/reverse query names of `field` and\n250         # any other field accessor -- i. e. Model.foreign accessor clashes with\n251         # Model.m2m accessor.\n252         potential_clashes = (r for r in rel_opts.related_objects if r.field is not self)\n253         for clash_field in potential_clashes:\n254             # i.e. \"app_label.Model.m2m\".\n255             clash_name = '%s.%s' % (\n256                 clash_field.related_model._meta.label,\n257                 clash_field.field.name,\n258             )\n259             if not rel_is_hidden and clash_field.get_accessor_name() == rel_name:\n260                 errors.append(\n261                     checks.Error(\n262                         \"Reverse accessor for '%s' clashes with reverse accessor for '%s'.\" % (field_name, clash_name),\n263                         hint=(\"Add or change a related_name argument \"\n264                               \"to the definition for '%s' or '%s'.\") % (field_name, clash_name),\n265                         obj=self,\n266                         id='fields.E304',\n267                     )\n268                 )\n269 \n270             if clash_field.get_accessor_name() == rel_query_name:\n271                 errors.append(\n272                     checks.Error(\n273                         \"Reverse query name for '%s' clashes with reverse query name for '%s'.\"\n274                         % (field_name, clash_name),\n275                         hint=(\"Add or change a related_name argument \"\n276                               \"to the definition for '%s' or '%s'.\") % (field_name, clash_name),\n277                         obj=self,\n278                         id='fields.E305',\n279                     )\n280                 )\n281 \n282         return errors\n283 \n284     def db_type(self, connection):\n285         # By default related field will not have a column as it relates to\n286         # columns from another table.\n287         return None\n288 \n289     def contribute_to_class(self, cls, name, private_only=False, **kwargs):\n290 \n291         super().contribute_to_class(cls, name, private_only=private_only, **kwargs)\n292 \n293         self.opts = cls._meta\n294 \n295         if not cls._meta.abstract:\n296             if self.remote_field.related_name:\n297                 related_name = self.remote_field.related_name\n298             else:\n299                 related_name = self.opts.default_related_name\n300             if related_name:\n301                 related_name = related_name % {\n302                     'class': cls.__name__.lower(),\n303                     'model_name': cls._meta.model_name.lower(),\n304                     'app_label': cls._meta.app_label.lower()\n305                 }\n306                 self.remote_field.related_name = related_name\n307 \n308             if self.remote_field.related_query_name:\n309                 related_query_name = self.remote_field.related_query_name % {\n310                     'class': cls.__name__.lower(),\n311                     'app_label': cls._meta.app_label.lower(),\n312                 }\n313                 self.remote_field.related_query_name = related_query_name\n314 \n315             def resolve_related_class(model, related, field):\n316                 field.remote_field.model = related\n317                 field.do_related_class(related, model)\n318             lazy_related_operation(resolve_related_class, cls, self.remote_field.model, field=self)\n319 \n320     def deconstruct(self):\n321         name, path, args, kwargs = super().deconstruct()\n322         if self.remote_field.limit_choices_to:\n323             kwargs['limit_choices_to'] = self.remote_field.limit_choices_to\n324         if self.remote_field.related_name is not None:\n325             kwargs['related_name'] = self.remote_field.related_name\n326         if self.remote_field.related_query_name is not None:\n327             kwargs['related_query_name'] = self.remote_field.related_query_name\n328         return name, path, args, kwargs\n329 \n330     def get_forward_related_filter(self, obj):\n331         \"\"\"\n332         Return the keyword arguments that when supplied to\n333         self.model.object.filter(), would select all instances related through\n334         this field to the remote obj. This is used to build the querysets\n335         returned by related descriptors. obj is an instance of\n336         self.related_field.model.\n337         \"\"\"\n338         return {\n339             '%s__%s' % (self.name, rh_field.name): getattr(obj, rh_field.attname)\n340             for _, rh_field in self.related_fields\n341         }\n342 \n343     def get_reverse_related_filter(self, obj):\n344         \"\"\"\n345         Complement to get_forward_related_filter(). Return the keyword\n346         arguments that when passed to self.related_field.model.object.filter()\n347         select all instances of self.related_field.model related through\n348         this field to obj. obj is an instance of self.model.\n349         \"\"\"\n350         base_filter = {\n351             rh_field.attname: getattr(obj, lh_field.attname)\n352             for lh_field, rh_field in self.related_fields\n353         }\n354         descriptor_filter = self.get_extra_descriptor_filter(obj)\n355         base_q = Q(**base_filter)\n356         if isinstance(descriptor_filter, dict):\n357             return base_q & Q(**descriptor_filter)\n358         elif descriptor_filter:\n359             return base_q & descriptor_filter\n360         return base_q\n361 \n362     @property\n363     def swappable_setting(self):\n364         \"\"\"\n365         Get the setting that this is powered from for swapping, or None\n366         if it's not swapped in / marked with swappable=False.\n367         \"\"\"\n368         if self.swappable:\n369             # Work out string form of \"to\"\n370             if isinstance(self.remote_field.model, str):\n371                 to_string = self.remote_field.model\n372             else:\n373                 to_string = self.remote_field.model._meta.label\n374             return apps.get_swappable_settings_name(to_string)\n375         return None\n376 \n377     def set_attributes_from_rel(self):\n378         self.name = (\n379             self.name or\n380             (self.remote_field.model._meta.model_name + '_' + self.remote_field.model._meta.pk.name)\n381         )\n382         if self.verbose_name is None:\n383             self.verbose_name = self.remote_field.model._meta.verbose_name\n384         self.remote_field.set_field_name()\n385 \n386     def do_related_class(self, other, cls):\n387         self.set_attributes_from_rel()\n388         self.contribute_to_related_class(other, self.remote_field)\n389 \n390     def get_limit_choices_to(self):\n391         \"\"\"\n392         Return ``limit_choices_to`` for this model field.\n393 \n394         If it is a callable, it will be invoked and the result will be\n395         returned.\n396         \"\"\"\n397         if callable(self.remote_field.limit_choices_to):\n398             return self.remote_field.limit_choices_to()\n399         return self.remote_field.limit_choices_to\n400 \n401     def formfield(self, **kwargs):\n402         \"\"\"\n403         Pass ``limit_choices_to`` to the field being constructed.\n404 \n405         Only passes it if there is a type that supports related fields.\n406         This is a similar strategy used to pass the ``queryset`` to the field\n407         being constructed.\n408         \"\"\"\n409         defaults = {}\n410         if hasattr(self.remote_field, 'get_related_field'):\n411             # If this is a callable, do not invoke it here. Just pass\n412             # it in the defaults for when the form class will later be\n413             # instantiated.\n414             limit_choices_to = self.remote_field.limit_choices_to\n415             defaults.update({\n416                 'limit_choices_to': limit_choices_to,\n417             })\n418         defaults.update(kwargs)\n419         return super().formfield(**defaults)\n420 \n421     def related_query_name(self):\n422         \"\"\"\n423         Define the name that can be used to identify this related object in a\n424         table-spanning query.\n425         \"\"\"\n426         return self.remote_field.related_query_name or self.remote_field.related_name or self.opts.model_name\n427 \n428     @property\n429     def target_field(self):\n430         \"\"\"\n431         When filtering against this relation, return the field on the remote\n432         model against which the filtering should happen.\n433         \"\"\"\n434         target_fields = self.get_path_info()[-1].target_fields\n435         if len(target_fields) > 1:\n436             raise exceptions.FieldError(\n437                 \"The relation has multiple target fields, but only single target field was asked for\")\n438         return target_fields[0]\n439 \n440     def get_cache_name(self):\n441         return self.name\n442 \n443 \n444 class ForeignObject(RelatedField):\n445     \"\"\"\n446     Abstraction of the ForeignKey relation to support multi-column relations.\n447     \"\"\"\n448 \n449     # Field flags\n450     many_to_many = False\n451     many_to_one = True\n452     one_to_many = False\n453     one_to_one = False\n454 \n455     requires_unique_target = True\n456     related_accessor_class = ReverseManyToOneDescriptor\n457     forward_related_accessor_class = ForwardManyToOneDescriptor\n458     rel_class = ForeignObjectRel\n459 \n460     def __init__(self, to, on_delete, from_fields, to_fields, rel=None, related_name=None,\n461                  related_query_name=None, limit_choices_to=None, parent_link=False,\n462                  swappable=True, **kwargs):\n463 \n464         if rel is None:\n465             rel = self.rel_class(\n466                 self, to,\n467                 related_name=related_name,\n468                 related_query_name=related_query_name,\n469                 limit_choices_to=limit_choices_to,\n470                 parent_link=parent_link,\n471                 on_delete=on_delete,\n472             )\n473 \n474         super().__init__(rel=rel, **kwargs)\n475 \n476         self.from_fields = from_fields\n477         self.to_fields = to_fields\n478         self.swappable = swappable\n479 \n480     def check(self, **kwargs):\n481         return [\n482             *super().check(**kwargs),\n483             *self._check_to_fields_exist(),\n484             *self._check_unique_target(),\n485         ]\n486 \n487     def _check_to_fields_exist(self):\n488         # Skip nonexistent models.\n489         if isinstance(self.remote_field.model, str):\n490             return []\n491 \n492         errors = []\n493         for to_field in self.to_fields:\n494             if to_field:\n495                 try:\n496                     self.remote_field.model._meta.get_field(to_field)\n497                 except exceptions.FieldDoesNotExist:\n498                     errors.append(\n499                         checks.Error(\n500                             \"The to_field '%s' doesn't exist on the related \"\n501                             \"model '%s'.\"\n502                             % (to_field, self.remote_field.model._meta.label),\n503                             obj=self,\n504                             id='fields.E312',\n505                         )\n506                     )\n507         return errors\n508 \n509     def _check_unique_target(self):\n510         rel_is_string = isinstance(self.remote_field.model, str)\n511         if rel_is_string or not self.requires_unique_target:\n512             return []\n513 \n514         try:\n515             self.foreign_related_fields\n516         except exceptions.FieldDoesNotExist:\n517             return []\n518 \n519         if not self.foreign_related_fields:\n520             return []\n521 \n522         unique_foreign_fields = {\n523             frozenset([f.name])\n524             for f in self.remote_field.model._meta.get_fields()\n525             if getattr(f, 'unique', False)\n526         }\n527         unique_foreign_fields.update({\n528             frozenset(ut)\n529             for ut in self.remote_field.model._meta.unique_together\n530         })\n531         unique_foreign_fields.update({\n532             frozenset(uc.fields)\n533             for uc in self.remote_field.model._meta.total_unique_constraints\n534         })\n535         foreign_fields = {f.name for f in self.foreign_related_fields}\n536         has_unique_constraint = any(u <= foreign_fields for u in unique_foreign_fields)\n537 \n538         if not has_unique_constraint and len(self.foreign_related_fields) > 1:\n539             field_combination = ', '.join(\n540                 \"'%s'\" % rel_field.name for rel_field in self.foreign_related_fields\n541             )\n542             model_name = self.remote_field.model.__name__\n543             return [\n544                 checks.Error(\n545                     \"No subset of the fields %s on model '%s' is unique.\"\n546                     % (field_combination, model_name),\n547                     hint=(\n548                         'Mark a single field as unique=True or add a set of '\n549                         'fields to a unique constraint (via unique_together '\n550                         'or a UniqueConstraint (without condition) in the '\n551                         'model Meta.constraints).'\n552                     ),\n553                     obj=self,\n554                     id='fields.E310',\n555                 )\n556             ]\n557         elif not has_unique_constraint:\n558             field_name = self.foreign_related_fields[0].name\n559             model_name = self.remote_field.model.__name__\n560             return [\n561                 checks.Error(\n562                     \"'%s.%s' must be unique because it is referenced by \"\n563                     \"a foreign key.\" % (model_name, field_name),\n564                     hint=(\n565                         'Add unique=True to this field or add a '\n566                         'UniqueConstraint (without condition) in the model '\n567                         'Meta.constraints.'\n568                     ),\n569                     obj=self,\n570                     id='fields.E311',\n571                 )\n572             ]\n573         else:\n574             return []\n575 \n576     def deconstruct(self):\n577         name, path, args, kwargs = super().deconstruct()\n578         kwargs['on_delete'] = self.remote_field.on_delete\n579         kwargs['from_fields'] = self.from_fields\n580         kwargs['to_fields'] = self.to_fields\n581 \n582         if self.remote_field.parent_link:\n583             kwargs['parent_link'] = self.remote_field.parent_link\n584         if isinstance(self.remote_field.model, str):\n585             if '.' in self.remote_field.model:\n586                 app_label, model_name = self.remote_field.model.split('.')\n587                 kwargs['to'] = '%s.%s' % (app_label, model_name.lower())\n588             else:\n589                 kwargs['to'] = self.remote_field.model.lower()\n590         else:\n591             kwargs['to'] = self.remote_field.model._meta.label_lower\n592         # If swappable is True, then see if we're actually pointing to the target\n593         # of a swap.\n594         swappable_setting = self.swappable_setting\n595         if swappable_setting is not None:\n596             # If it's already a settings reference, error\n597             if hasattr(kwargs['to'], \"setting_name\"):\n598                 if kwargs['to'].setting_name != swappable_setting:\n599                     raise ValueError(\n600                         \"Cannot deconstruct a ForeignKey pointing to a model \"\n601                         \"that is swapped in place of more than one model (%s and %s)\"\n602                         % (kwargs['to'].setting_name, swappable_setting)\n603                     )\n604             # Set it\n605             kwargs['to'] = SettingsReference(\n606                 kwargs['to'],\n607                 swappable_setting,\n608             )\n609         return name, path, args, kwargs\n610 \n611     def resolve_related_fields(self):\n612         if not self.from_fields or len(self.from_fields) != len(self.to_fields):\n613             raise ValueError('Foreign Object from and to fields must be the same non-zero length')\n614         if isinstance(self.remote_field.model, str):\n615             raise ValueError('Related model %r cannot be resolved' % self.remote_field.model)\n616         related_fields = []\n617         for index in range(len(self.from_fields)):\n618             from_field_name = self.from_fields[index]\n619             to_field_name = self.to_fields[index]\n620             from_field = (\n621                 self\n622                 if from_field_name == RECURSIVE_RELATIONSHIP_CONSTANT\n623                 else self.opts.get_field(from_field_name)\n624             )\n625             to_field = (self.remote_field.model._meta.pk if to_field_name is None\n626                         else self.remote_field.model._meta.get_field(to_field_name))\n627             related_fields.append((from_field, to_field))\n628         return related_fields\n629 \n630     @cached_property\n631     def related_fields(self):\n632         return self.resolve_related_fields()\n633 \n634     @cached_property\n635     def reverse_related_fields(self):\n636         return [(rhs_field, lhs_field) for lhs_field, rhs_field in self.related_fields]\n637 \n638     @cached_property\n639     def local_related_fields(self):\n640         return tuple(lhs_field for lhs_field, rhs_field in self.related_fields)\n641 \n642     @cached_property\n643     def foreign_related_fields(self):\n644         return tuple(rhs_field for lhs_field, rhs_field in self.related_fields if rhs_field)\n645 \n646     def get_local_related_value(self, instance):\n647         return self.get_instance_value_for_fields(instance, self.local_related_fields)\n648 \n649     def get_foreign_related_value(self, instance):\n650         return self.get_instance_value_for_fields(instance, self.foreign_related_fields)\n651 \n652     @staticmethod\n653     def get_instance_value_for_fields(instance, fields):\n654         ret = []\n655         opts = instance._meta\n656         for field in fields:\n657             # Gotcha: in some cases (like fixture loading) a model can have\n658             # different values in parent_ptr_id and parent's id. So, use\n659             # instance.pk (that is, parent_ptr_id) when asked for instance.id.\n660             if field.primary_key:\n661                 possible_parent_link = opts.get_ancestor_link(field.model)\n662                 if (not possible_parent_link or\n663                         possible_parent_link.primary_key or\n664                         possible_parent_link.model._meta.abstract):\n665                     ret.append(instance.pk)\n666                     continue\n667             ret.append(getattr(instance, field.attname))\n668         return tuple(ret)\n669 \n670     def get_attname_column(self):\n671         attname, column = super().get_attname_column()\n672         return attname, None\n673 \n674     def get_joining_columns(self, reverse_join=False):\n675         source = self.reverse_related_fields if reverse_join else self.related_fields\n676         return tuple((lhs_field.column, rhs_field.column) for lhs_field, rhs_field in source)\n677 \n678     def get_reverse_joining_columns(self):\n679         return self.get_joining_columns(reverse_join=True)\n680 \n681     def get_extra_descriptor_filter(self, instance):\n682         \"\"\"\n683         Return an extra filter condition for related object fetching when\n684         user does 'instance.fieldname', that is the extra filter is used in\n685         the descriptor of the field.\n686 \n687         The filter should be either a dict usable in .filter(**kwargs) call or\n688         a Q-object. The condition will be ANDed together with the relation's\n689         joining columns.\n690 \n691         A parallel method is get_extra_restriction() which is used in\n692         JOIN and subquery conditions.\n693         \"\"\"\n694         return {}\n695 \n696     def get_extra_restriction(self, where_class, alias, related_alias):\n697         \"\"\"\n698         Return a pair condition used for joining and subquery pushdown. The\n699         condition is something that responds to as_sql(compiler, connection)\n700         method.\n701 \n702         Note that currently referring both the 'alias' and 'related_alias'\n703         will not work in some conditions, like subquery pushdown.\n704 \n705         A parallel method is get_extra_descriptor_filter() which is used in\n706         instance.fieldname related object fetching.\n707         \"\"\"\n708         return None\n709 \n710     def get_path_info(self, filtered_relation=None):\n711         \"\"\"Get path from this field to the related model.\"\"\"\n712         opts = self.remote_field.model._meta\n713         from_opts = self.model._meta\n714         return [PathInfo(\n715             from_opts=from_opts,\n716             to_opts=opts,\n717             target_fields=self.foreign_related_fields,\n718             join_field=self,\n719             m2m=False,\n720             direct=True,\n721             filtered_relation=filtered_relation,\n722         )]\n723 \n724     def get_reverse_path_info(self, filtered_relation=None):\n725         \"\"\"Get path from the related model to this field's model.\"\"\"\n726         opts = self.model._meta\n727         from_opts = self.remote_field.model._meta\n728         return [PathInfo(\n729             from_opts=from_opts,\n730             to_opts=opts,\n731             target_fields=(opts.pk,),\n732             join_field=self.remote_field,\n733             m2m=not self.unique,\n734             direct=False,\n735             filtered_relation=filtered_relation,\n736         )]\n737 \n738     @classmethod\n739     @functools.lru_cache(maxsize=None)\n740     def get_lookups(cls):\n741         bases = inspect.getmro(cls)\n742         bases = bases[:bases.index(ForeignObject) + 1]\n743         class_lookups = [parent.__dict__.get('class_lookups', {}) for parent in bases]\n744         return cls.merge_dicts(class_lookups)\n745 \n746     def contribute_to_class(self, cls, name, private_only=False, **kwargs):\n747         super().contribute_to_class(cls, name, private_only=private_only, **kwargs)\n748         setattr(cls, self.name, self.forward_related_accessor_class(self))\n749 \n750     def contribute_to_related_class(self, cls, related):\n751         # Internal FK's - i.e., those with a related name ending with '+' -\n752         # and swapped models don't get a related descriptor.\n753         if not self.remote_field.is_hidden() and not related.related_model._meta.swapped:\n754             setattr(cls._meta.concrete_model, related.get_accessor_name(), self.related_accessor_class(related))\n755             # While 'limit_choices_to' might be a callable, simply pass\n756             # it along for later - this is too early because it's still\n757             # model load time.\n758             if self.remote_field.limit_choices_to:\n759                 cls._meta.related_fkey_lookups.append(self.remote_field.limit_choices_to)\n760 \n761 \n762 ForeignObject.register_lookup(RelatedIn)\n763 ForeignObject.register_lookup(RelatedExact)\n764 ForeignObject.register_lookup(RelatedLessThan)\n765 ForeignObject.register_lookup(RelatedGreaterThan)\n766 ForeignObject.register_lookup(RelatedGreaterThanOrEqual)\n767 ForeignObject.register_lookup(RelatedLessThanOrEqual)\n768 ForeignObject.register_lookup(RelatedIsNull)\n769 \n770 \n771 class ForeignKey(ForeignObject):\n772     \"\"\"\n773     Provide a many-to-one relation by adding a column to the local model\n774     to hold the remote value.\n775 \n776     By default ForeignKey will target the pk of the remote model but this\n777     behavior can be changed by using the ``to_field`` argument.\n778     \"\"\"\n779     descriptor_class = ForeignKeyDeferredAttribute\n780     # Field flags\n781     many_to_many = False\n782     many_to_one = True\n783     one_to_many = False\n784     one_to_one = False\n785 \n786     rel_class = ManyToOneRel\n787 \n788     empty_strings_allowed = False\n789     default_error_messages = {\n790         'invalid': _('%(model)s instance with %(field)s %(value)r does not exist.')\n791     }\n792     description = _(\"Foreign Key (type determined by related field)\")\n793 \n794     def __init__(self, to, on_delete, related_name=None, related_query_name=None,\n795                  limit_choices_to=None, parent_link=False, to_field=None,\n796                  db_constraint=True, **kwargs):\n797         try:\n798             to._meta.model_name\n799         except AttributeError:\n800             assert isinstance(to, str), (\n801                 \"%s(%r) is invalid. First parameter to ForeignKey must be \"\n802                 \"either a model, a model name, or the string %r\" % (\n803                     self.__class__.__name__, to,\n804                     RECURSIVE_RELATIONSHIP_CONSTANT,\n805                 )\n806             )\n807         else:\n808             # For backwards compatibility purposes, we need to *try* and set\n809             # the to_field during FK construction. It won't be guaranteed to\n810             # be correct until contribute_to_class is called. Refs #12190.\n811             to_field = to_field or (to._meta.pk and to._meta.pk.name)\n812         if not callable(on_delete):\n813             raise TypeError('on_delete must be callable.')\n814 \n815         kwargs['rel'] = self.rel_class(\n816             self, to, to_field,\n817             related_name=related_name,\n818             related_query_name=related_query_name,\n819             limit_choices_to=limit_choices_to,\n820             parent_link=parent_link,\n821             on_delete=on_delete,\n822         )\n823         kwargs.setdefault('db_index', True)\n824 \n825         super().__init__(\n826             to,\n827             on_delete,\n828             from_fields=[RECURSIVE_RELATIONSHIP_CONSTANT],\n829             to_fields=[to_field],\n830             **kwargs,\n831         )\n832         self.db_constraint = db_constraint\n833 \n834     def check(self, **kwargs):\n835         return [\n836             *super().check(**kwargs),\n837             *self._check_on_delete(),\n838             *self._check_unique(),\n839         ]\n840 \n841     def _check_on_delete(self):\n842         on_delete = getattr(self.remote_field, 'on_delete', None)\n843         if on_delete == SET_NULL and not self.null:\n844             return [\n845                 checks.Error(\n846                     'Field specifies on_delete=SET_NULL, but cannot be null.',\n847                     hint='Set null=True argument on the field, or change the on_delete rule.',\n848                     obj=self,\n849                     id='fields.E320',\n850                 )\n851             ]\n852         elif on_delete == SET_DEFAULT and not self.has_default():\n853             return [\n854                 checks.Error(\n855                     'Field specifies on_delete=SET_DEFAULT, but has no default value.',\n856                     hint='Set a default value, or change the on_delete rule.',\n857                     obj=self,\n858                     id='fields.E321',\n859                 )\n860             ]\n861         else:\n862             return []\n863 \n864     def _check_unique(self, **kwargs):\n865         return [\n866             checks.Warning(\n867                 'Setting unique=True on a ForeignKey has the same effect as using a OneToOneField.',\n868                 hint='ForeignKey(unique=True) is usually better served by a OneToOneField.',\n869                 obj=self,\n870                 id='fields.W342',\n871             )\n872         ] if self.unique else []\n873 \n874     def deconstruct(self):\n875         name, path, args, kwargs = super().deconstruct()\n876         del kwargs['to_fields']\n877         del kwargs['from_fields']\n878         # Handle the simpler arguments\n879         if self.db_index:\n880             del kwargs['db_index']\n881         else:\n882             kwargs['db_index'] = False\n883         if self.db_constraint is not True:\n884             kwargs['db_constraint'] = self.db_constraint\n885         # Rel needs more work.\n886         to_meta = getattr(self.remote_field.model, \"_meta\", None)\n887         if self.remote_field.field_name and (\n888                 not to_meta or (to_meta.pk and self.remote_field.field_name != to_meta.pk.name)):\n889             kwargs['to_field'] = self.remote_field.field_name\n890         return name, path, args, kwargs\n891 \n892     def to_python(self, value):\n893         return self.target_field.to_python(value)\n894 \n895     @property\n896     def target_field(self):\n897         return self.foreign_related_fields[0]\n898 \n899     def get_reverse_path_info(self, filtered_relation=None):\n900         \"\"\"Get path from the related model to this field's model.\"\"\"\n901         opts = self.model._meta\n902         from_opts = self.remote_field.model._meta\n903         return [PathInfo(\n904             from_opts=from_opts,\n905             to_opts=opts,\n906             target_fields=(opts.pk,),\n907             join_field=self.remote_field,\n908             m2m=not self.unique,\n909             direct=False,\n910             filtered_relation=filtered_relation,\n911         )]\n912 \n913     def validate(self, value, model_instance):\n914         if self.remote_field.parent_link:\n915             return\n916         super().validate(value, model_instance)\n917         if value is None:\n918             return\n919 \n920         using = router.db_for_read(self.remote_field.model, instance=model_instance)\n921         qs = self.remote_field.model._base_manager.using(using).filter(\n922             **{self.remote_field.field_name: value}\n923         )\n924         qs = qs.complex_filter(self.get_limit_choices_to())\n925         if not qs.exists():\n926             raise exceptions.ValidationError(\n927                 self.error_messages['invalid'],\n928                 code='invalid',\n929                 params={\n930                     'model': self.remote_field.model._meta.verbose_name, 'pk': value,\n931                     'field': self.remote_field.field_name, 'value': value,\n932                 },  # 'pk' is included for backwards compatibility\n933             )\n934 \n935     def resolve_related_fields(self):\n936         related_fields = super().resolve_related_fields()\n937         for from_field, to_field in related_fields:\n938             if to_field and to_field.model != self.remote_field.model._meta.concrete_model:\n939                 raise exceptions.FieldError(\n940                     \"'%s.%s' refers to field '%s' which is not local to model \"\n941                     \"'%s'.\" % (\n942                         self.model._meta.label,\n943                         self.name,\n944                         to_field.name,\n945                         self.remote_field.model._meta.concrete_model._meta.label,\n946                     )\n947                 )\n948         return related_fields\n949 \n950     def get_attname(self):\n951         return '%s_id' % self.name\n952 \n953     def get_attname_column(self):\n954         attname = self.get_attname()\n955         column = self.db_column or attname\n956         return attname, column\n957 \n958     def get_default(self):\n959         \"\"\"Return the to_field if the default value is an object.\"\"\"\n960         field_default = super().get_default()\n961         if isinstance(field_default, self.remote_field.model):\n962             return getattr(field_default, self.target_field.attname)\n963         return field_default\n964 \n965     def get_db_prep_save(self, value, connection):\n966         if value is None or (value == '' and\n967                              (not self.target_field.empty_strings_allowed or\n968                               connection.features.interprets_empty_strings_as_nulls)):\n969             return None\n970         else:\n971             return self.target_field.get_db_prep_save(value, connection=connection)\n972 \n973     def get_db_prep_value(self, value, connection, prepared=False):\n974         return self.target_field.get_db_prep_value(value, connection, prepared)\n975 \n976     def get_prep_value(self, value):\n977         return self.target_field.get_prep_value(value)\n978 \n979     def contribute_to_related_class(self, cls, related):\n980         super().contribute_to_related_class(cls, related)\n981         if self.remote_field.field_name is None:\n982             self.remote_field.field_name = cls._meta.pk.name\n983 \n984     def formfield(self, *, using=None, **kwargs):\n985         if isinstance(self.remote_field.model, str):\n986             raise ValueError(\"Cannot create form field for %r yet, because \"\n987                              \"its related model %r has not been loaded yet\" %\n988                              (self.name, self.remote_field.model))\n989         return super().formfield(**{\n990             'form_class': forms.ModelChoiceField,\n991             'queryset': self.remote_field.model._default_manager.using(using),\n992             'to_field_name': self.remote_field.field_name,\n993             **kwargs,\n994             'blank': self.blank,\n995         })\n996 \n997     def db_check(self, connection):\n998         return []\n999 \n1000     def db_type(self, connection):\n1001         return self.target_field.rel_db_type(connection=connection)\n1002 \n1003     def db_parameters(self, connection):\n1004         return {\"type\": self.db_type(connection), \"check\": self.db_check(connection)}\n1005 \n1006     def convert_empty_strings(self, value, expression, connection):\n1007         if (not value) and isinstance(value, str):\n1008             return None\n1009         return value\n1010 \n1011     def get_db_converters(self, connection):\n1012         converters = super().get_db_converters(connection)\n1013         if connection.features.interprets_empty_strings_as_nulls:\n1014             converters += [self.convert_empty_strings]\n1015         return converters\n1016 \n1017     def get_col(self, alias, output_field=None):\n1018         if output_field is None:\n1019             output_field = self.target_field\n1020             while isinstance(output_field, ForeignKey):\n1021                 output_field = output_field.target_field\n1022                 if output_field is self:\n1023                     raise ValueError('Cannot resolve output_field.')\n1024         return super().get_col(alias, output_field)\n1025 \n1026 \n1027 class OneToOneField(ForeignKey):\n1028     \"\"\"\n1029     A OneToOneField is essentially the same as a ForeignKey, with the exception\n1030     that it always carries a \"unique\" constraint with it and the reverse\n1031     relation always returns the object pointed to (since there will only ever\n1032     be one), rather than returning a list.\n1033     \"\"\"\n1034 \n1035     # Field flags\n1036     many_to_many = False\n1037     many_to_one = False\n1038     one_to_many = False\n1039     one_to_one = True\n1040 \n1041     related_accessor_class = ReverseOneToOneDescriptor\n1042     forward_related_accessor_class = ForwardOneToOneDescriptor\n1043     rel_class = OneToOneRel\n1044 \n1045     description = _(\"One-to-one relationship\")\n1046 \n1047     def __init__(self, to, on_delete, to_field=None, **kwargs):\n1048         kwargs['unique'] = True\n1049         super().__init__(to, on_delete, to_field=to_field, **kwargs)\n1050 \n1051     def deconstruct(self):\n1052         name, path, args, kwargs = super().deconstruct()\n1053         if \"unique\" in kwargs:\n1054             del kwargs['unique']\n1055         return name, path, args, kwargs\n1056 \n1057     def formfield(self, **kwargs):\n1058         if self.remote_field.parent_link:\n1059             return None\n1060         return super().formfield(**kwargs)\n1061 \n1062     def save_form_data(self, instance, data):\n1063         if isinstance(data, self.remote_field.model):\n1064             setattr(instance, self.name, data)\n1065         else:\n1066             setattr(instance, self.attname, data)\n1067             # Remote field object must be cleared otherwise Model.save()\n1068             # will reassign attname using the related object pk.\n1069             if data is None:\n1070                 setattr(instance, self.name, data)\n1071 \n1072     def _check_unique(self, **kwargs):\n1073         # Override ForeignKey since check isn't applicable here.\n1074         return []\n1075 \n1076 \n1077 def create_many_to_many_intermediary_model(field, klass):\n1078     from django.db import models\n1079 \n1080     def set_managed(model, related, through):\n1081         through._meta.managed = model._meta.managed or related._meta.managed\n1082 \n1083     to_model = resolve_relation(klass, field.remote_field.model)\n1084     name = '%s_%s' % (klass._meta.object_name, field.name)\n1085     lazy_related_operation(set_managed, klass, to_model, name)\n1086 \n1087     to = make_model_tuple(to_model)[1]\n1088     from_ = klass._meta.model_name\n1089     if to == from_:\n1090         to = 'to_%s' % to\n1091         from_ = 'from_%s' % from_\n1092 \n1093     meta = type('Meta', (), {\n1094         'db_table': field._get_m2m_db_table(klass._meta),\n1095         'auto_created': klass,\n1096         'app_label': klass._meta.app_label,\n1097         'db_tablespace': klass._meta.db_tablespace,\n1098         'unique_together': (from_, to),\n1099         'verbose_name': _('%(from)s-%(to)s relationship') % {'from': from_, 'to': to},\n1100         'verbose_name_plural': _('%(from)s-%(to)s relationships') % {'from': from_, 'to': to},\n1101         'apps': field.model._meta.apps,\n1102     })\n1103     # Construct and return the new class.\n1104     return type(name, (models.Model,), {\n1105         'Meta': meta,\n1106         '__module__': klass.__module__,\n1107         from_: models.ForeignKey(\n1108             klass,\n1109             related_name='%s+' % name,\n1110             db_tablespace=field.db_tablespace,\n1111             db_constraint=field.remote_field.db_constraint,\n1112             on_delete=CASCADE,\n1113         ),\n1114         to: models.ForeignKey(\n1115             to_model,\n1116             related_name='%s+' % name,\n1117             db_tablespace=field.db_tablespace,\n1118             db_constraint=field.remote_field.db_constraint,\n1119             on_delete=CASCADE,\n1120         )\n1121     })\n1122 \n1123 \n1124 class ManyToManyField(RelatedField):\n1125     \"\"\"\n1126     Provide a many-to-many relation by using an intermediary model that\n1127     holds two ForeignKey fields pointed at the two sides of the relation.\n1128 \n1129     Unless a ``through`` model was provided, ManyToManyField will use the\n1130     create_many_to_many_intermediary_model factory to automatically generate\n1131     the intermediary model.\n1132     \"\"\"\n1133 \n1134     # Field flags\n1135     many_to_many = True\n1136     many_to_one = False\n1137     one_to_many = False\n1138     one_to_one = False\n1139 \n1140     rel_class = ManyToManyRel\n1141 \n1142     description = _(\"Many-to-many relationship\")\n1143 \n1144     def __init__(self, to, related_name=None, related_query_name=None,\n1145                  limit_choices_to=None, symmetrical=None, through=None,\n1146                  through_fields=None, db_constraint=True, db_table=None,\n1147                  swappable=True, **kwargs):\n1148         try:\n1149             to._meta\n1150         except AttributeError:\n1151             assert isinstance(to, str), (\n1152                 \"%s(%r) is invalid. First parameter to ManyToManyField must be \"\n1153                 \"either a model, a model name, or the string %r\" %\n1154                 (self.__class__.__name__, to, RECURSIVE_RELATIONSHIP_CONSTANT)\n1155             )\n1156 \n1157         if symmetrical is None:\n1158             symmetrical = (to == RECURSIVE_RELATIONSHIP_CONSTANT)\n1159 \n1160         if through is not None:\n1161             assert db_table is None, (\n1162                 \"Cannot specify a db_table if an intermediary model is used.\"\n1163             )\n1164 \n1165         kwargs['rel'] = self.rel_class(\n1166             self, to,\n1167             related_name=related_name,\n1168             related_query_name=related_query_name,\n1169             limit_choices_to=limit_choices_to,\n1170             symmetrical=symmetrical,\n1171             through=through,\n1172             through_fields=through_fields,\n1173             db_constraint=db_constraint,\n1174         )\n1175         self.has_null_arg = 'null' in kwargs\n1176 \n1177         super().__init__(**kwargs)\n1178 \n1179         self.db_table = db_table\n1180         self.swappable = swappable\n1181 \n1182     def check(self, **kwargs):\n1183         return [\n1184             *super().check(**kwargs),\n1185             *self._check_unique(**kwargs),\n1186             *self._check_relationship_model(**kwargs),\n1187             *self._check_ignored_options(**kwargs),\n1188             *self._check_table_uniqueness(**kwargs),\n1189         ]\n1190 \n1191     def _check_unique(self, **kwargs):\n1192         if self.unique:\n1193             return [\n1194                 checks.Error(\n1195                     'ManyToManyFields cannot be unique.',\n1196                     obj=self,\n1197                     id='fields.E330',\n1198                 )\n1199             ]\n1200         return []\n1201 \n1202     def _check_ignored_options(self, **kwargs):\n1203         warnings = []\n1204 \n1205         if self.has_null_arg:\n1206             warnings.append(\n1207                 checks.Warning(\n1208                     'null has no effect on ManyToManyField.',\n1209                     obj=self,\n1210                     id='fields.W340',\n1211                 )\n1212             )\n1213 \n1214         if self._validators:\n1215             warnings.append(\n1216                 checks.Warning(\n1217                     'ManyToManyField does not support validators.',\n1218                     obj=self,\n1219                     id='fields.W341',\n1220                 )\n1221             )\n1222         if (self.remote_field.limit_choices_to and self.remote_field.through and\n1223                 not self.remote_field.through._meta.auto_created):\n1224             warnings.append(\n1225                 checks.Warning(\n1226                     'limit_choices_to has no effect on ManyToManyField '\n1227                     'with a through model.',\n1228                     obj=self,\n1229                     id='fields.W343',\n1230                 )\n1231             )\n1232 \n1233         return warnings\n1234 \n1235     def _check_relationship_model(self, from_model=None, **kwargs):\n1236         if hasattr(self.remote_field.through, '_meta'):\n1237             qualified_model_name = \"%s.%s\" % (\n1238                 self.remote_field.through._meta.app_label, self.remote_field.through.__name__)\n1239         else:\n1240             qualified_model_name = self.remote_field.through\n1241 \n1242         errors = []\n1243 \n1244         if self.remote_field.through not in self.opts.apps.get_models(include_auto_created=True):\n1245             # The relationship model is not installed.\n1246             errors.append(\n1247                 checks.Error(\n1248                     \"Field specifies a many-to-many relation through model \"\n1249                     \"'%s', which has not been installed.\" % qualified_model_name,\n1250                     obj=self,\n1251                     id='fields.E331',\n1252                 )\n1253             )\n1254 \n1255         else:\n1256             assert from_model is not None, (\n1257                 \"ManyToManyField with intermediate \"\n1258                 \"tables cannot be checked if you don't pass the model \"\n1259                 \"where the field is attached to.\"\n1260             )\n1261             # Set some useful local variables\n1262             to_model = resolve_relation(from_model, self.remote_field.model)\n1263             from_model_name = from_model._meta.object_name\n1264             if isinstance(to_model, str):\n1265                 to_model_name = to_model\n1266             else:\n1267                 to_model_name = to_model._meta.object_name\n1268             relationship_model_name = self.remote_field.through._meta.object_name\n1269             self_referential = from_model == to_model\n1270             # Count foreign keys in intermediate model\n1271             if self_referential:\n1272                 seen_self = sum(\n1273                     from_model == getattr(field.remote_field, 'model', None)\n1274                     for field in self.remote_field.through._meta.fields\n1275                 )\n1276 \n1277                 if seen_self > 2 and not self.remote_field.through_fields:\n1278                     errors.append(\n1279                         checks.Error(\n1280                             \"The model is used as an intermediate model by \"\n1281                             \"'%s', but it has more than two foreign keys \"\n1282                             \"to '%s', which is ambiguous. You must specify \"\n1283                             \"which two foreign keys Django should use via the \"\n1284                             \"through_fields keyword argument.\" % (self, from_model_name),\n1285                             hint=\"Use through_fields to specify which two foreign keys Django should use.\",\n1286                             obj=self.remote_field.through,\n1287                             id='fields.E333',\n1288                         )\n1289                     )\n1290 \n1291             else:\n1292                 # Count foreign keys in relationship model\n1293                 seen_from = sum(\n1294                     from_model == getattr(field.remote_field, 'model', None)\n1295                     for field in self.remote_field.through._meta.fields\n1296                 )\n1297                 seen_to = sum(\n1298                     to_model == getattr(field.remote_field, 'model', None)\n1299                     for field in self.remote_field.through._meta.fields\n1300                 )\n1301 \n1302                 if seen_from > 1 and not self.remote_field.through_fields:\n1303                     errors.append(\n1304                         checks.Error(\n1305                             (\"The model is used as an intermediate model by \"\n1306                              \"'%s', but it has more than one foreign key \"\n1307                              \"from '%s', which is ambiguous. You must specify \"\n1308                              \"which foreign key Django should use via the \"\n1309                              \"through_fields keyword argument.\") % (self, from_model_name),\n1310                             hint=(\n1311                                 'If you want to create a recursive relationship, '\n1312                                 'use ManyToManyField(\"%s\", through=\"%s\").'\n1313                             ) % (\n1314                                 RECURSIVE_RELATIONSHIP_CONSTANT,\n1315                                 relationship_model_name,\n1316                             ),\n1317                             obj=self,\n1318                             id='fields.E334',\n1319                         )\n1320                     )\n1321 \n1322                 if seen_to > 1 and not self.remote_field.through_fields:\n1323                     errors.append(\n1324                         checks.Error(\n1325                             \"The model is used as an intermediate model by \"\n1326                             \"'%s', but it has more than one foreign key \"\n1327                             \"to '%s', which is ambiguous. You must specify \"\n1328                             \"which foreign key Django should use via the \"\n1329                             \"through_fields keyword argument.\" % (self, to_model_name),\n1330                             hint=(\n1331                                 'If you want to create a recursive relationship, '\n1332                                 'use ManyToManyField(\"%s\", through=\"%s\").'\n1333                             ) % (\n1334                                 RECURSIVE_RELATIONSHIP_CONSTANT,\n1335                                 relationship_model_name,\n1336                             ),\n1337                             obj=self,\n1338                             id='fields.E335',\n1339                         )\n1340                     )\n1341 \n1342                 if seen_from == 0 or seen_to == 0:\n1343                     errors.append(\n1344                         checks.Error(\n1345                             \"The model is used as an intermediate model by \"\n1346                             \"'%s', but it does not have a foreign key to '%s' or '%s'.\" % (\n1347                                 self, from_model_name, to_model_name\n1348                             ),\n1349                             obj=self.remote_field.through,\n1350                             id='fields.E336',\n1351                         )\n1352                     )\n1353 \n1354         # Validate `through_fields`.\n1355         if self.remote_field.through_fields is not None:\n1356             # Validate that we're given an iterable of at least two items\n1357             # and that none of them is \"falsy\".\n1358             if not (len(self.remote_field.through_fields) >= 2 and\n1359                     self.remote_field.through_fields[0] and self.remote_field.through_fields[1]):\n1360                 errors.append(\n1361                     checks.Error(\n1362                         \"Field specifies 'through_fields' but does not provide \"\n1363                         \"the names of the two link fields that should be used \"\n1364                         \"for the relation through model '%s'.\" % qualified_model_name,\n1365                         hint=\"Make sure you specify 'through_fields' as through_fields=('field1', 'field2')\",\n1366                         obj=self,\n1367                         id='fields.E337',\n1368                     )\n1369                 )\n1370 \n1371             # Validate the given through fields -- they should be actual\n1372             # fields on the through model, and also be foreign keys to the\n1373             # expected models.\n1374             else:\n1375                 assert from_model is not None, (\n1376                     \"ManyToManyField with intermediate \"\n1377                     \"tables cannot be checked if you don't pass the model \"\n1378                     \"where the field is attached to.\"\n1379                 )\n1380 \n1381                 source, through, target = from_model, self.remote_field.through, self.remote_field.model\n1382                 source_field_name, target_field_name = self.remote_field.through_fields[:2]\n1383 \n1384                 for field_name, related_model in ((source_field_name, source),\n1385                                                   (target_field_name, target)):\n1386 \n1387                     possible_field_names = []\n1388                     for f in through._meta.fields:\n1389                         if hasattr(f, 'remote_field') and getattr(f.remote_field, 'model', None) == related_model:\n1390                             possible_field_names.append(f.name)\n1391                     if possible_field_names:\n1392                         hint = \"Did you mean one of the following foreign keys to '%s': %s?\" % (\n1393                             related_model._meta.object_name,\n1394                             ', '.join(possible_field_names),\n1395                         )\n1396                     else:\n1397                         hint = None\n1398 \n1399                     try:\n1400                         field = through._meta.get_field(field_name)\n1401                     except exceptions.FieldDoesNotExist:\n1402                         errors.append(\n1403                             checks.Error(\n1404                                 \"The intermediary model '%s' has no field '%s'.\"\n1405                                 % (qualified_model_name, field_name),\n1406                                 hint=hint,\n1407                                 obj=self,\n1408                                 id='fields.E338',\n1409                             )\n1410                         )\n1411                     else:\n1412                         if not (hasattr(field, 'remote_field') and\n1413                                 getattr(field.remote_field, 'model', None) == related_model):\n1414                             errors.append(\n1415                                 checks.Error(\n1416                                     \"'%s.%s' is not a foreign key to '%s'.\" % (\n1417                                         through._meta.object_name, field_name,\n1418                                         related_model._meta.object_name,\n1419                                     ),\n1420                                     hint=hint,\n1421                                     obj=self,\n1422                                     id='fields.E339',\n1423                                 )\n1424                             )\n1425 \n1426         return errors\n1427 \n1428     def _check_table_uniqueness(self, **kwargs):\n1429         if isinstance(self.remote_field.through, str) or not self.remote_field.through._meta.managed:\n1430             return []\n1431         registered_tables = {\n1432             model._meta.db_table: model\n1433             for model in self.opts.apps.get_models(include_auto_created=True)\n1434             if model != self.remote_field.through and model._meta.managed\n1435         }\n1436         m2m_db_table = self.m2m_db_table()\n1437         model = registered_tables.get(m2m_db_table)\n1438         # The second condition allows multiple m2m relations on a model if\n1439         # some point to a through model that proxies another through model.\n1440         if model and model._meta.concrete_model != self.remote_field.through._meta.concrete_model:\n1441             if model._meta.auto_created:\n1442                 def _get_field_name(model):\n1443                     for field in model._meta.auto_created._meta.many_to_many:\n1444                         if field.remote_field.through is model:\n1445                             return field.name\n1446                 opts = model._meta.auto_created._meta\n1447                 clashing_obj = '%s.%s' % (opts.label, _get_field_name(model))\n1448             else:\n1449                 clashing_obj = model._meta.label\n1450             if settings.DATABASE_ROUTERS:\n1451                 error_class, error_id = checks.Warning, 'fields.W344'\n1452                 error_hint = (\n1453                     'You have configured settings.DATABASE_ROUTERS. Verify '\n1454                     'that the table of %r is correctly routed to a separate '\n1455                     'database.' % clashing_obj\n1456                 )\n1457             else:\n1458                 error_class, error_id = checks.Error, 'fields.E340'\n1459                 error_hint = None\n1460             return [\n1461                 error_class(\n1462                     \"The field's intermediary table '%s' clashes with the \"\n1463                     \"table name of '%s'.\" % (m2m_db_table, clashing_obj),\n1464                     obj=self,\n1465                     hint=error_hint,\n1466                     id=error_id,\n1467                 )\n1468             ]\n1469         return []\n1470 \n1471     def deconstruct(self):\n1472         name, path, args, kwargs = super().deconstruct()\n1473         # Handle the simpler arguments.\n1474         if self.db_table is not None:\n1475             kwargs['db_table'] = self.db_table\n1476         if self.remote_field.db_constraint is not True:\n1477             kwargs['db_constraint'] = self.remote_field.db_constraint\n1478         # Rel needs more work.\n1479         if isinstance(self.remote_field.model, str):\n1480             kwargs['to'] = self.remote_field.model\n1481         else:\n1482             kwargs['to'] = self.remote_field.model._meta.label\n1483         if getattr(self.remote_field, 'through', None) is not None:\n1484             if isinstance(self.remote_field.through, str):\n1485                 kwargs['through'] = self.remote_field.through\n1486             elif not self.remote_field.through._meta.auto_created:\n1487                 kwargs['through'] = self.remote_field.through._meta.label\n1488         # If swappable is True, then see if we're actually pointing to the target\n1489         # of a swap.\n1490         swappable_setting = self.swappable_setting\n1491         if swappable_setting is not None:\n1492             # If it's already a settings reference, error.\n1493             if hasattr(kwargs['to'], \"setting_name\"):\n1494                 if kwargs['to'].setting_name != swappable_setting:\n1495                     raise ValueError(\n1496                         \"Cannot deconstruct a ManyToManyField pointing to a \"\n1497                         \"model that is swapped in place of more than one model \"\n1498                         \"(%s and %s)\" % (kwargs['to'].setting_name, swappable_setting)\n1499                     )\n1500 \n1501             kwargs['to'] = SettingsReference(\n1502                 kwargs['to'],\n1503                 swappable_setting,\n1504             )\n1505         return name, path, args, kwargs\n1506 \n1507     def _get_path_info(self, direct=False, filtered_relation=None):\n1508         \"\"\"Called by both direct and indirect m2m traversal.\"\"\"\n1509         int_model = self.remote_field.through\n1510         linkfield1 = int_model._meta.get_field(self.m2m_field_name())\n1511         linkfield2 = int_model._meta.get_field(self.m2m_reverse_field_name())\n1512         if direct:\n1513             join1infos = linkfield1.get_reverse_path_info()\n1514             join2infos = linkfield2.get_path_info(filtered_relation)\n1515         else:\n1516             join1infos = linkfield2.get_reverse_path_info()\n1517             join2infos = linkfield1.get_path_info(filtered_relation)\n1518 \n1519         # Get join infos between the last model of join 1 and the first model\n1520         # of join 2. Assume the only reason these may differ is due to model\n1521         # inheritance.\n1522         join1_final = join1infos[-1].to_opts\n1523         join2_initial = join2infos[0].from_opts\n1524         if join1_final is join2_initial:\n1525             intermediate_infos = []\n1526         elif issubclass(join1_final.model, join2_initial.model):\n1527             intermediate_infos = join1_final.get_path_to_parent(join2_initial.model)\n1528         else:\n1529             intermediate_infos = join2_initial.get_path_from_parent(join1_final.model)\n1530 \n1531         return [*join1infos, *intermediate_infos, *join2infos]\n1532 \n1533     def get_path_info(self, filtered_relation=None):\n1534         return self._get_path_info(direct=True, filtered_relation=filtered_relation)\n1535 \n1536     def get_reverse_path_info(self, filtered_relation=None):\n1537         return self._get_path_info(direct=False, filtered_relation=filtered_relation)\n1538 \n1539     def _get_m2m_db_table(self, opts):\n1540         \"\"\"\n1541         Function that can be curried to provide the m2m table name for this\n1542         relation.\n1543         \"\"\"\n1544         if self.remote_field.through is not None:\n1545             return self.remote_field.through._meta.db_table\n1546         elif self.db_table:\n1547             return self.db_table\n1548         else:\n1549             m2m_table_name = '%s_%s' % (utils.strip_quotes(opts.db_table), self.name)\n1550             return utils.truncate_name(m2m_table_name, connection.ops.max_name_length())\n1551 \n1552     def _get_m2m_attr(self, related, attr):\n1553         \"\"\"\n1554         Function that can be curried to provide the source accessor or DB\n1555         column name for the m2m table.\n1556         \"\"\"\n1557         cache_attr = '_m2m_%s_cache' % attr\n1558         if hasattr(self, cache_attr):\n1559             return getattr(self, cache_attr)\n1560         if self.remote_field.through_fields is not None:\n1561             link_field_name = self.remote_field.through_fields[0]\n1562         else:\n1563             link_field_name = None\n1564         for f in self.remote_field.through._meta.fields:\n1565             if (f.is_relation and f.remote_field.model == related.related_model and\n1566                     (link_field_name is None or link_field_name == f.name)):\n1567                 setattr(self, cache_attr, getattr(f, attr))\n1568                 return getattr(self, cache_attr)\n1569 \n1570     def _get_m2m_reverse_attr(self, related, attr):\n1571         \"\"\"\n1572         Function that can be curried to provide the related accessor or DB\n1573         column name for the m2m table.\n1574         \"\"\"\n1575         cache_attr = '_m2m_reverse_%s_cache' % attr\n1576         if hasattr(self, cache_attr):\n1577             return getattr(self, cache_attr)\n1578         found = False\n1579         if self.remote_field.through_fields is not None:\n1580             link_field_name = self.remote_field.through_fields[1]\n1581         else:\n1582             link_field_name = None\n1583         for f in self.remote_field.through._meta.fields:\n1584             if f.is_relation and f.remote_field.model == related.model:\n1585                 if link_field_name is None and related.related_model == related.model:\n1586                     # If this is an m2m-intermediate to self,\n1587                     # the first foreign key you find will be\n1588                     # the source column. Keep searching for\n1589                     # the second foreign key.\n1590                     if found:\n1591                         setattr(self, cache_attr, getattr(f, attr))\n1592                         break\n1593                     else:\n1594                         found = True\n1595                 elif link_field_name is None or link_field_name == f.name:\n1596                     setattr(self, cache_attr, getattr(f, attr))\n1597                     break\n1598         return getattr(self, cache_attr)\n1599 \n1600     def contribute_to_class(self, cls, name, **kwargs):\n1601         # To support multiple relations to self, it's useful to have a non-None\n1602         # related name on symmetrical relations for internal reasons. The\n1603         # concept doesn't make a lot of sense externally (\"you want me to\n1604         # specify *what* on my non-reversible relation?!\"), so we set it up\n1605         # automatically. The funky name reduces the chance of an accidental\n1606         # clash.\n1607         if self.remote_field.symmetrical and (\n1608             self.remote_field.model == RECURSIVE_RELATIONSHIP_CONSTANT or\n1609             self.remote_field.model == cls._meta.object_name\n1610         ):\n1611             self.remote_field.related_name = \"%s_rel_+\" % name\n1612         elif self.remote_field.is_hidden():\n1613             # If the backwards relation is disabled, replace the original\n1614             # related_name with one generated from the m2m field name. Django\n1615             # still uses backwards relations internally and we need to avoid\n1616             # clashes between multiple m2m fields with related_name == '+'.\n1617             self.remote_field.related_name = \"_%s_%s_+\" % (cls.__name__.lower(), name)\n1618 \n1619         super().contribute_to_class(cls, name, **kwargs)\n1620 \n1621         # The intermediate m2m model is not auto created if:\n1622         #  1) There is a manually specified intermediate, or\n1623         #  2) The class owning the m2m field is abstract.\n1624         #  3) The class owning the m2m field has been swapped out.\n1625         if not cls._meta.abstract:\n1626             if self.remote_field.through:\n1627                 def resolve_through_model(_, model, field):\n1628                     field.remote_field.through = model\n1629                 lazy_related_operation(resolve_through_model, cls, self.remote_field.through, field=self)\n1630             elif not cls._meta.swapped:\n1631                 self.remote_field.through = create_many_to_many_intermediary_model(self, cls)\n1632 \n1633         # Add the descriptor for the m2m relation.\n1634         setattr(cls, self.name, ManyToManyDescriptor(self.remote_field, reverse=False))\n1635 \n1636         # Set up the accessor for the m2m table name for the relation.\n1637         self.m2m_db_table = partial(self._get_m2m_db_table, cls._meta)\n1638 \n1639     def contribute_to_related_class(self, cls, related):\n1640         # Internal M2Ms (i.e., those with a related name ending with '+')\n1641         # and swapped models don't get a related descriptor.\n1642         if not self.remote_field.is_hidden() and not related.related_model._meta.swapped:\n1643             setattr(cls, related.get_accessor_name(), ManyToManyDescriptor(self.remote_field, reverse=True))\n1644 \n1645         # Set up the accessors for the column names on the m2m table.\n1646         self.m2m_column_name = partial(self._get_m2m_attr, related, 'column')\n1647         self.m2m_reverse_name = partial(self._get_m2m_reverse_attr, related, 'column')\n1648 \n1649         self.m2m_field_name = partial(self._get_m2m_attr, related, 'name')\n1650         self.m2m_reverse_field_name = partial(self._get_m2m_reverse_attr, related, 'name')\n1651 \n1652         get_m2m_rel = partial(self._get_m2m_attr, related, 'remote_field')\n1653         self.m2m_target_field_name = lambda: get_m2m_rel().field_name\n1654         get_m2m_reverse_rel = partial(self._get_m2m_reverse_attr, related, 'remote_field')\n1655         self.m2m_reverse_target_field_name = lambda: get_m2m_reverse_rel().field_name\n1656 \n1657     def set_attributes_from_rel(self):\n1658         pass\n1659 \n1660     def value_from_object(self, obj):\n1661         return [] if obj.pk is None else list(getattr(obj, self.attname).all())\n1662 \n1663     def save_form_data(self, instance, data):\n1664         getattr(instance, self.attname).set(data)\n1665 \n1666     def formfield(self, *, using=None, **kwargs):\n1667         defaults = {\n1668             'form_class': forms.ModelMultipleChoiceField,\n1669             'queryset': self.remote_field.model._default_manager.using(using),\n1670             **kwargs,\n1671         }\n1672         # If initial is passed in, it's a list of related objects, but the\n1673         # MultipleChoiceField takes a list of IDs.\n1674         if defaults.get('initial') is not None:\n1675             initial = defaults['initial']\n1676             if callable(initial):\n1677                 initial = initial()\n1678             defaults['initial'] = [i.pk for i in initial]\n1679         return super().formfield(**defaults)\n1680 \n1681     def db_check(self, connection):\n1682         return None\n1683 \n1684     def db_type(self, connection):\n1685         # A ManyToManyField is not represented by a single column,\n1686         # so return None.\n1687         return None\n1688 \n1689     def db_parameters(self, connection):\n1690         return {\"type\": None, \"check\": None}\n",
        "intended_behavior": "Ensure that the usage of 'related_name='+' does not lead to conflicts during migration generation, effectively isolating the many-to-many relationships as per the design goal of using 'related_name='+'."
    }
]