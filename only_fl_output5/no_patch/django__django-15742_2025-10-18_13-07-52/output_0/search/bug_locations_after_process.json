[
    {
        "rel_file_path": "django/templatetags/i18n.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__4.2/django/templatetags/i18n.py",
        "start": 1,
        "end": 616,
        "class_name": null,
        "method_name": null,
        "code": "1 from decimal import Decimal\n2 \n3 from django.conf import settings\n4 from django.template import Library, Node, TemplateSyntaxError, Variable\n5 from django.template.base import TokenType, render_value_in_context\n6 from django.template.defaulttags import token_kwargs\n7 from django.utils import translation\n8 from django.utils.safestring import SafeData, mark_safe\n9 \n10 register = Library()\n11 \n12 \n13 class GetAvailableLanguagesNode(Node):\n14     def __init__(self, variable):\n15         self.variable = variable\n16 \n17     def render(self, context):\n18         context[self.variable] = [\n19             (k, translation.gettext(v)) for k, v in settings.LANGUAGES\n20         ]\n21         return \"\"\n22 \n23 \n24 class GetLanguageInfoNode(Node):\n25     def __init__(self, lang_code, variable):\n26         self.lang_code = lang_code\n27         self.variable = variable\n28 \n29     def render(self, context):\n30         lang_code = self.lang_code.resolve(context)\n31         context[self.variable] = translation.get_language_info(lang_code)\n32         return \"\"\n33 \n34 \n35 class GetLanguageInfoListNode(Node):\n36     def __init__(self, languages, variable):\n37         self.languages = languages\n38         self.variable = variable\n39 \n40     def get_language_info(self, language):\n41         # ``language`` is either a language code string or a sequence\n42         # with the language code as its first item\n43         if len(language[0]) > 1:\n44             return translation.get_language_info(language[0])\n45         else:\n46             return translation.get_language_info(str(language))\n47 \n48     def render(self, context):\n49         langs = self.languages.resolve(context)\n50         context[self.variable] = [self.get_language_info(lang) for lang in langs]\n51         return \"\"\n52 \n53 \n54 class GetCurrentLanguageNode(Node):\n55     def __init__(self, variable):\n56         self.variable = variable\n57 \n58     def render(self, context):\n59         context[self.variable] = translation.get_language()\n60         return \"\"\n61 \n62 \n63 class GetCurrentLanguageBidiNode(Node):\n64     def __init__(self, variable):\n65         self.variable = variable\n66 \n67     def render(self, context):\n68         context[self.variable] = translation.get_language_bidi()\n69         return \"\"\n70 \n71 \n72 class TranslateNode(Node):\n73     child_nodelists = ()\n74 \n75     def __init__(self, filter_expression, noop, asvar=None, message_context=None):\n76         self.noop = noop\n77         self.asvar = asvar\n78         self.message_context = message_context\n79         self.filter_expression = filter_expression\n80         if isinstance(self.filter_expression.var, str):\n81             self.filter_expression.is_var = True\n82             self.filter_expression.var = Variable(\"'%s'\" % self.filter_expression.var)\n83 \n84     def render(self, context):\n85         self.filter_expression.var.translate = not self.noop\n86         if self.message_context:\n87             self.filter_expression.var.message_context = self.message_context.resolve(\n88                 context\n89             )\n90         output = self.filter_expression.resolve(context)\n91         value = render_value_in_context(output, context)\n92         # Restore percent signs. Percent signs in template text are doubled\n93         # so they are not interpreted as string format flags.\n94         is_safe = isinstance(value, SafeData)\n95         value = value.replace(\"%%\", \"%\")\n96         value = mark_safe(value) if is_safe else value\n97         if self.asvar:\n98             context[self.asvar] = value\n99             return \"\"\n100         else:\n101             return value\n102 \n103 \n104 class BlockTranslateNode(Node):\n105     def __init__(\n106         self,\n107         extra_context,\n108         singular,\n109         plural=None,\n110         countervar=None,\n111         counter=None,\n112         message_context=None,\n113         trimmed=False,\n114         asvar=None,\n115         tag_name=\"blocktranslate\",\n116     ):\n117         self.extra_context = extra_context\n118         self.singular = singular\n119         self.plural = plural\n120         self.countervar = countervar\n121         self.counter = counter\n122         self.message_context = message_context\n123         self.trimmed = trimmed\n124         self.asvar = asvar\n125         self.tag_name = tag_name\n126 \n127     def __repr__(self):\n128         return (\n129             f\"<{self.__class__.__qualname__}: \"\n130             f\"extra_context={self.extra_context!r} \"\n131             f\"singular={self.singular!r} plural={self.plural!r}>\"\n132         )\n133 \n134     def render_token_list(self, tokens):\n135         result = []\n136         vars = []\n137         for token in tokens:\n138             if token.token_type == TokenType.TEXT:\n139                 result.append(token.contents.replace(\"%\", \"%%\"))\n140             elif token.token_type == TokenType.VAR:\n141                 result.append(\"%%(%s)s\" % token.contents)\n142                 vars.append(token.contents)\n143         msg = \"\".join(result)\n144         if self.trimmed:\n145             msg = translation.trim_whitespace(msg)\n146         return msg, vars\n147 \n148     def render(self, context, nested=False):\n149         if self.message_context:\n150             message_context = self.message_context.resolve(context)\n151         else:\n152             message_context = None\n153         # Update() works like a push(), so corresponding context.pop() is at\n154         # the end of function\n155         context.update(\n156             {var: val.resolve(context) for var, val in self.extra_context.items()}\n157         )\n158         singular, vars = self.render_token_list(self.singular)\n159         if self.plural and self.countervar and self.counter:\n160             count = self.counter.resolve(context)\n161             if not isinstance(count, (Decimal, float, int)):\n162                 raise TemplateSyntaxError(\n163                     \"%r argument to %r tag must be a number.\"\n164                     % (self.countervar, self.tag_name)\n165                 )\n166             context[self.countervar] = count\n167             plural, plural_vars = self.render_token_list(self.plural)\n168             if message_context:\n169                 result = translation.npgettext(message_context, singular, plural, count)\n170             else:\n171                 result = translation.ngettext(singular, plural, count)\n172             vars.extend(plural_vars)\n173         else:\n174             if message_context:\n175                 result = translation.pgettext(message_context, singular)\n176             else:\n177                 result = translation.gettext(singular)\n178         default_value = context.template.engine.string_if_invalid\n179 \n180         def render_value(key):\n181             if key in context:\n182                 val = context[key]\n183             else:\n184                 val = default_value % key if \"%s\" in default_value else default_value\n185             return render_value_in_context(val, context)\n186 \n187         data = {v: render_value(v) for v in vars}\n188         context.pop()\n189         try:\n190             result = result % data\n191         except (KeyError, ValueError):\n192             if nested:\n193                 # Either string is malformed, or it's a bug\n194                 raise TemplateSyntaxError(\n195                     \"%r is unable to format string returned by gettext: %r \"\n196                     \"using %r\" % (self.tag_name, result, data)\n197                 )\n198             with translation.override(None):\n199                 result = self.render(context, nested=True)\n200         if self.asvar:\n201             context[self.asvar] = result\n202             return \"\"\n203         else:\n204             return result\n205 \n206 \n207 class LanguageNode(Node):\n208     def __init__(self, nodelist, language):\n209         self.nodelist = nodelist\n210         self.language = language\n211 \n212     def render(self, context):\n213         with translation.override(self.language.resolve(context)):\n214             output = self.nodelist.render(context)\n215         return output\n216 \n217 \n218 @register.tag(\"get_available_languages\")\n219 def do_get_available_languages(parser, token):\n220     \"\"\"\n221     Store a list of available languages in the context.\n222 \n223     Usage::\n224 \n225         {% get_available_languages as languages %}\n226         {% for language in languages %}\n227         ...\n228         {% endfor %}\n229 \n230     This puts settings.LANGUAGES into the named variable.\n231     \"\"\"\n232     # token.split_contents() isn't useful here because this tag doesn't accept\n233     # variable as arguments.\n234     args = token.contents.split()\n235     if len(args) != 3 or args[1] != \"as\":\n236         raise TemplateSyntaxError(\n237             \"'get_available_languages' requires 'as variable' (got %r)\" % args\n238         )\n239     return GetAvailableLanguagesNode(args[2])\n240 \n241 \n242 @register.tag(\"get_language_info\")\n243 def do_get_language_info(parser, token):\n244     \"\"\"\n245     Store the language information dictionary for the given language code in a\n246     context variable.\n247 \n248     Usage::\n249 \n250         {% get_language_info for LANGUAGE_CODE as l %}\n251         {{ l.code }}\n252         {{ l.name }}\n253         {{ l.name_translated }}\n254         {{ l.name_local }}\n255         {{ l.bidi|yesno:\"bi-directional,uni-directional\" }}\n256     \"\"\"\n257     args = token.split_contents()\n258     if len(args) != 5 or args[1] != \"for\" or args[3] != \"as\":\n259         raise TemplateSyntaxError(\n260             \"'%s' requires 'for string as variable' (got %r)\" % (args[0], args[1:])\n261         )\n262     return GetLanguageInfoNode(parser.compile_filter(args[2]), args[4])\n263 \n264 \n265 @register.tag(\"get_language_info_list\")\n266 def do_get_language_info_list(parser, token):\n267     \"\"\"\n268     Store a list of language information dictionaries for the given language\n269     codes in a context variable. The language codes can be specified either as\n270     a list of strings or a settings.LANGUAGES style list (or any sequence of\n271     sequences whose first items are language codes).\n272 \n273     Usage::\n274 \n275         {% get_language_info_list for LANGUAGES as langs %}\n276         {% for l in langs %}\n277           {{ l.code }}\n278           {{ l.name }}\n279           {{ l.name_translated }}\n280           {{ l.name_local }}\n281           {{ l.bidi|yesno:\"bi-directional,uni-directional\" }}\n282         {% endfor %}\n283     \"\"\"\n284     args = token.split_contents()\n285     if len(args) != 5 or args[1] != \"for\" or args[3] != \"as\":\n286         raise TemplateSyntaxError(\n287             \"'%s' requires 'for sequence as variable' (got %r)\" % (args[0], args[1:])\n288         )\n289     return GetLanguageInfoListNode(parser.compile_filter(args[2]), args[4])\n290 \n291 \n292 @register.filter\n293 def language_name(lang_code):\n294     return translation.get_language_info(lang_code)[\"name\"]\n295 \n296 \n297 @register.filter\n298 def language_name_translated(lang_code):\n299     english_name = translation.get_language_info(lang_code)[\"name\"]\n300     return translation.gettext(english_name)\n301 \n302 \n303 @register.filter\n304 def language_name_local(lang_code):\n305     return translation.get_language_info(lang_code)[\"name_local\"]\n306 \n307 \n308 @register.filter\n309 def language_bidi(lang_code):\n310     return translation.get_language_info(lang_code)[\"bidi\"]\n311 \n312 \n313 @register.tag(\"get_current_language\")\n314 def do_get_current_language(parser, token):\n315     \"\"\"\n316     Store the current language in the context.\n317 \n318     Usage::\n319 \n320         {% get_current_language as language %}\n321 \n322     This fetches the currently active language and puts its value into the\n323     ``language`` context variable.\n324     \"\"\"\n325     # token.split_contents() isn't useful here because this tag doesn't accept\n326     # variable as arguments.\n327     args = token.contents.split()\n328     if len(args) != 3 or args[1] != \"as\":\n329         raise TemplateSyntaxError(\n330             \"'get_current_language' requires 'as variable' (got %r)\" % args\n331         )\n332     return GetCurrentLanguageNode(args[2])\n333 \n334 \n335 @register.tag(\"get_current_language_bidi\")\n336 def do_get_current_language_bidi(parser, token):\n337     \"\"\"\n338     Store the current language layout in the context.\n339 \n340     Usage::\n341 \n342         {% get_current_language_bidi as bidi %}\n343 \n344     This fetches the currently active language's layout and puts its value into\n345     the ``bidi`` context variable. True indicates right-to-left layout,\n346     otherwise left-to-right.\n347     \"\"\"\n348     # token.split_contents() isn't useful here because this tag doesn't accept\n349     # variable as arguments.\n350     args = token.contents.split()\n351     if len(args) != 3 or args[1] != \"as\":\n352         raise TemplateSyntaxError(\n353             \"'get_current_language_bidi' requires 'as variable' (got %r)\" % args\n354         )\n355     return GetCurrentLanguageBidiNode(args[2])\n356 \n357 \n358 @register.tag(\"translate\")\n359 @register.tag(\"trans\")\n360 def do_translate(parser, token):\n361     \"\"\"\n362     Mark a string for translation and translate the string for the current\n363     language.\n364 \n365     Usage::\n366 \n367         {% translate \"this is a test\" %}\n368 \n369     This marks the string for translation so it will be pulled out by\n370     makemessages into the .po files and runs the string through the translation\n371     engine.\n372 \n373     There is a second form::\n374 \n375         {% translate \"this is a test\" noop %}\n376 \n377     This marks the string for translation, but returns the string unchanged.\n378     Use it when you need to store values into forms that should be translated\n379     later on.\n380 \n381     You can use variables instead of constant strings\n382     to translate stuff you marked somewhere else::\n383 \n384         {% translate variable %}\n385 \n386     This tries to translate the contents of the variable ``variable``. Make\n387     sure that the string in there is something that is in the .po file.\n388 \n389     It is possible to store the translated string into a variable::\n390 \n391         {% translate \"this is a test\" as var %}\n392         {{ var }}\n393 \n394     Contextual translations are also supported::\n395 \n396         {% translate \"this is a test\" context \"greeting\" %}\n397 \n398     This is equivalent to calling pgettext instead of (u)gettext.\n399     \"\"\"\n400     bits = token.split_contents()\n401     if len(bits) < 2:\n402         raise TemplateSyntaxError(\"'%s' takes at least one argument\" % bits[0])\n403     message_string = parser.compile_filter(bits[1])\n404     remaining = bits[2:]\n405 \n406     noop = False\n407     asvar = None\n408     message_context = None\n409     seen = set()\n410     invalid_context = {\"as\", \"noop\"}\n411 \n412     while remaining:\n413         option = remaining.pop(0)\n414         if option in seen:\n415             raise TemplateSyntaxError(\n416                 \"The '%s' option was specified more than once.\" % option,\n417             )\n418         elif option == \"noop\":\n419             noop = True\n420         elif option == \"context\":\n421             try:\n422                 value = remaining.pop(0)\n423             except IndexError:\n424                 raise TemplateSyntaxError(\n425                     \"No argument provided to the '%s' tag for the context option.\"\n426                     % bits[0]\n427                 )\n428             if value in invalid_context:\n429                 raise TemplateSyntaxError(\n430                     \"Invalid argument '%s' provided to the '%s' tag for the context \"\n431                     \"option\" % (value, bits[0]),\n432                 )\n433             message_context = parser.compile_filter(value)\n434         elif option == \"as\":\n435             try:\n436                 value = remaining.pop(0)\n437             except IndexError:\n438                 raise TemplateSyntaxError(\n439                     \"No argument provided to the '%s' tag for the as option.\" % bits[0]\n440                 )\n441             asvar = value\n442         else:\n443             raise TemplateSyntaxError(\n444                 \"Unknown argument for '%s' tag: '%s'. The only options \"\n445                 \"available are 'noop', 'context' \\\"xxx\\\", and 'as VAR'.\"\n446                 % (\n447                     bits[0],\n448                     option,\n449                 )\n450             )\n451         seen.add(option)\n452 \n453     return TranslateNode(message_string, noop, asvar, message_context)\n454 \n455 \n456 @register.tag(\"blocktranslate\")\n457 @register.tag(\"blocktrans\")\n458 def do_block_translate(parser, token):\n459     \"\"\"\n460     Translate a block of text with parameters.\n461 \n462     Usage::\n463 \n464         {% blocktranslate with bar=foo|filter boo=baz|filter %}\n465         This is {{ bar }} and {{ boo }}.\n466         {% endblocktranslate %}\n467 \n468     Additionally, this supports pluralization::\n469 \n470         {% blocktranslate count count=var|length %}\n471         There is {{ count }} object.\n472         {% plural %}\n473         There are {{ count }} objects.\n474         {% endblocktranslate %}\n475 \n476     This is much like ngettext, only in template syntax.\n477 \n478     The \"var as value\" legacy format is still supported::\n479 \n480         {% blocktranslate with foo|filter as bar and baz|filter as boo %}\n481         {% blocktranslate count var|length as count %}\n482 \n483     The translated string can be stored in a variable using `asvar`::\n484 \n485         {% blocktranslate with bar=foo|filter boo=baz|filter asvar var %}\n486         This is {{ bar }} and {{ boo }}.\n487         {% endblocktranslate %}\n488         {{ var }}\n489 \n490     Contextual translations are supported::\n491 \n492         {% blocktranslate with bar=foo|filter context \"greeting\" %}\n493             This is {{ bar }}.\n494         {% endblocktranslate %}\n495 \n496     This is equivalent to calling pgettext/npgettext instead of\n497     (u)gettext/(u)ngettext.\n498     \"\"\"\n499     bits = token.split_contents()\n500 \n501     options = {}\n502     remaining_bits = bits[1:]\n503     asvar = None\n504     while remaining_bits:\n505         option = remaining_bits.pop(0)\n506         if option in options:\n507             raise TemplateSyntaxError(\n508                 \"The %r option was specified more than once.\" % option\n509             )\n510         if option == \"with\":\n511             value = token_kwargs(remaining_bits, parser, support_legacy=True)\n512             if not value:\n513                 raise TemplateSyntaxError(\n514                     '\"with\" in %r tag needs at least one keyword argument.' % bits[0]\n515                 )\n516         elif option == \"count\":\n517             value = token_kwargs(remaining_bits, parser, support_legacy=True)\n518             if len(value) != 1:\n519                 raise TemplateSyntaxError(\n520                     '\"count\" in %r tag expected exactly '\n521                     \"one keyword argument.\" % bits[0]\n522                 )\n523         elif option == \"context\":\n524             try:\n525                 value = remaining_bits.pop(0)\n526                 value = parser.compile_filter(value)\n527             except Exception:\n528                 raise TemplateSyntaxError(\n529                     '\"context\" in %r tag expected exactly one argument.' % bits[0]\n530                 )\n531         elif option == \"trimmed\":\n532             value = True\n533         elif option == \"asvar\":\n534             try:\n535                 value = remaining_bits.pop(0)\n536             except IndexError:\n537                 raise TemplateSyntaxError(\n538                     \"No argument provided to the '%s' tag for the asvar option.\"\n539                     % bits[0]\n540                 )\n541             asvar = value\n542         else:\n543             raise TemplateSyntaxError(\n544                 \"Unknown argument for %r tag: %r.\" % (bits[0], option)\n545             )\n546         options[option] = value\n547 \n548     if \"count\" in options:\n549         countervar, counter = next(iter(options[\"count\"].items()))\n550     else:\n551         countervar, counter = None, None\n552     if \"context\" in options:\n553         message_context = options[\"context\"]\n554     else:\n555         message_context = None\n556     extra_context = options.get(\"with\", {})\n557 \n558     trimmed = options.get(\"trimmed\", False)\n559 \n560     singular = []\n561     plural = []\n562     while parser.tokens:\n563         token = parser.next_token()\n564         if token.token_type in (TokenType.VAR, TokenType.TEXT):\n565             singular.append(token)\n566         else:\n567             break\n568     if countervar and counter:\n569         if token.contents.strip() != \"plural\":\n570             raise TemplateSyntaxError(\n571                 \"%r doesn't allow other block tags inside it\" % bits[0]\n572             )\n573         while parser.tokens:\n574             token = parser.next_token()\n575             if token.token_type in (TokenType.VAR, TokenType.TEXT):\n576                 plural.append(token)\n577             else:\n578                 break\n579     end_tag_name = \"end%s\" % bits[0]\n580     if token.contents.strip() != end_tag_name:\n581         raise TemplateSyntaxError(\n582             \"%r doesn't allow other block tags (seen %r) inside it\"\n583             % (bits[0], token.contents)\n584         )\n585 \n586     return BlockTranslateNode(\n587         extra_context,\n588         singular,\n589         plural,\n590         countervar,\n591         counter,\n592         message_context,\n593         trimmed=trimmed,\n594         asvar=asvar,\n595         tag_name=bits[0],\n596     )\n597 \n598 \n599 @register.tag\n600 def language(parser, token):\n601     \"\"\"\n602     Enable the given language just for this block.\n603 \n604     Usage::\n605 \n606         {% language \"de\" %}\n607             This is {{ bar }} and {{ boo }}.\n608         {% endlanguage %}\n609     \"\"\"\n610     bits = token.split_contents()\n611     if len(bits) != 2:\n612         raise TemplateSyntaxError(\"'%s' takes one argument (language)\" % bits[0])\n613     language = parser.compile_filter(bits[1])\n614     nodelist = parser.parse((\"endlanguage\",))\n615     parser.delete_first_token()\n616     return LanguageNode(nodelist, language)\n",
        "intended_behavior": "In this file, the logic handling the `blocktranslate` tag with the `asvar` option needs to be adjusted to prevent double escaping by checking if the content being assigned via `asvar` is already escaped and, if so, wrapping it in a `SafeString` instance before storing it."
    },
    {
        "rel_file_path": "django/utils/safestring.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__4.2/django/utils/safestring.py",
        "start": 1,
        "end": 72,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\"\n2 Functions for working with \"safe strings\": strings that can be displayed safely\n3 without further escaping in HTML. Marking something as a \"safe string\" means\n4 that the producer of the string has already turned characters that should not\n5 be interpreted by the HTML engine (e.g. '<') into the appropriate entities.\n6 \"\"\"\n7 \n8 from functools import wraps\n9 \n10 from django.utils.functional import keep_lazy\n11 \n12 \n13 class SafeData:\n14     __slots__ = ()\n15 \n16     def __html__(self):\n17         \"\"\"\n18         Return the html representation of a string for interoperability.\n19 \n20         This allows other template engines to understand Django's SafeData.\n21         \"\"\"\n22         return self\n23 \n24 \n25 class SafeString(str, SafeData):\n26     \"\"\"\n27     A str subclass that has been specifically marked as \"safe\" for HTML output\n28     purposes.\n29     \"\"\"\n30 \n31     __slots__ = ()\n32 \n33     def __add__(self, rhs):\n34         \"\"\"\n35         Concatenating a safe string with another safe bytestring or\n36         safe string is safe. Otherwise, the result is no longer safe.\n37         \"\"\"\n38         t = super().__add__(rhs)\n39         if isinstance(rhs, SafeData):\n40             return SafeString(t)\n41         return t\n42 \n43     def __str__(self):\n44         return self\n45 \n46 \n47 SafeText = SafeString  # For backwards compatibility since Django 2.0.\n48 \n49 \n50 def _safety_decorator(safety_marker, func):\n51     @wraps(func)\n52     def wrapper(*args, **kwargs):\n53         return safety_marker(func(*args, **kwargs))\n54 \n55     return wrapper\n56 \n57 \n58 @keep_lazy(SafeString)\n59 def mark_safe(s):\n60     \"\"\"\n61     Explicitly mark a string as safe for (HTML) output purposes. The returned\n62     object can be used everywhere a string is appropriate.\n63 \n64     If used on a method as a decorator, mark the returned data as safe.\n65 \n66     Can be called multiple times on a single string.\n67     \"\"\"\n68     if hasattr(s, \"__html__\"):\n69         return s\n70     if callable(s):\n71         return _safety_decorator(mark_safe, s)\n72     return SafeString(s)\n",
        "intended_behavior": "Clarify in the documentation or through additional utility functions/methods how `SafeString` can be correctly utilized by `blocktranslate` to mark strings as safe, thereby preventing double escaping and maintaining the functionality of marking strings as safe in translations."
    }
]