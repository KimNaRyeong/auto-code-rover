[
    {
        "rel_file_path": "lib/matplotlib/offsetbox.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/matplotlib__matplotlib/setup_matplotlib__matplotlib__3.7/lib/matplotlib/offsetbox.py",
        "start": 395,
        "end": 404,
        "class_name": "OffsetBox",
        "method_name": "get_window_extent",
        "code": "395     def get_window_extent(self, renderer=None):\n396         # docstring inherited\n397         if renderer is None:\n398             renderer = self.figure._get_renderer()\n399         bbox = self.get_bbox(renderer)\n400         try:  # Some subclasses redefine get_offset to take no args.\n401             px, py = self.get_offset(bbox, renderer)\n402         except TypeError:\n403             px, py = self.get_offset()\n404         return bbox.translated(px, py)\n",
        "intended_behavior": "The intended behavior within `get_window_extent` should ensure that it can gracefully handle scenarios where a renderer is not available. Before attempting to access `self.figure._get_renderer()`, there should be a check to ensure that `self.figure` is not `None` and that `_get_renderer()` can be safely called. In the absence of an available renderer, the method should either initialize a default renderer (if feasible and appropriate according to matplotlib's design principles) or fail more gracefully with a more informative error message indicating that the renderer could not be found. This would avoid the `AttributeError: 'NoneType' object has no attribute '_get_renderer'` error and provide clearer guidance to developers on the state of the rendering context."
    },
    {
        "rel_file_path": "lib/matplotlib/offsetbox.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/matplotlib__matplotlib/setup_matplotlib__matplotlib__3.7/lib/matplotlib/offsetbox.py",
        "start": 208,
        "end": 417,
        "class_name": "OffsetBox",
        "method_name": null,
        "code": "208 class OffsetBox(martist.Artist):\n209     \"\"\"\n210     The OffsetBox is a simple container artist.\n211 \n212     The child artists are meant to be drawn at a relative position to its\n213     parent.\n214 \n215     Being an artist itself, all parameters are passed on to `.Artist`.\n216     \"\"\"\n217     def __init__(self, *args, **kwargs):\n218         super().__init__(*args)\n219         self._internal_update(kwargs)\n220         # Clipping has not been implemented in the OffsetBox family, so\n221         # disable the clip flag for consistency. It can always be turned back\n222         # on to zero effect.\n223         self.set_clip_on(False)\n224         self._children = []\n225         self._offset = (0, 0)\n226 \n227     def set_figure(self, fig):\n228         \"\"\"\n229         Set the `.Figure` for the `.OffsetBox` and all its children.\n230 \n231         Parameters\n232         ----------\n233         fig : `~matplotlib.figure.Figure`\n234         \"\"\"\n235         super().set_figure(fig)\n236         for c in self.get_children():\n237             c.set_figure(fig)\n238 \n239     @martist.Artist.axes.setter\n240     def axes(self, ax):\n241         # TODO deal with this better\n242         martist.Artist.axes.fset(self, ax)\n243         for c in self.get_children():\n244             if c is not None:\n245                 c.axes = ax\n246 \n247     def contains(self, mouseevent):\n248         \"\"\"\n249         Delegate the mouse event contains-check to the children.\n250 \n251         As a container, the `.OffsetBox` does not respond itself to\n252         mouseevents.\n253 \n254         Parameters\n255         ----------\n256         mouseevent : `~matplotlib.backend_bases.MouseEvent`\n257 \n258         Returns\n259         -------\n260         contains : bool\n261             Whether any values are within the radius.\n262         details : dict\n263             An artist-specific dictionary of details of the event context,\n264             such as which points are contained in the pick radius. See the\n265             individual Artist subclasses for details.\n266 \n267         See Also\n268         --------\n269         .Artist.contains\n270         \"\"\"\n271         if self._different_canvas(mouseevent):\n272             return False, {}\n273         for c in self.get_children():\n274             a, b = c.contains(mouseevent)\n275             if a:\n276                 return a, b\n277         return False, {}\n278 \n279     def set_offset(self, xy):\n280         \"\"\"\n281         Set the offset.\n282 \n283         Parameters\n284         ----------\n285         xy : (float, float) or callable\n286             The (x, y) coordinates of the offset in display units. These can\n287             either be given explicitly as a tuple (x, y), or by providing a\n288             function that converts the extent into the offset. This function\n289             must have the signature::\n290 \n291                 def offset(width, height, xdescent, ydescent, renderer) \\\n292 -> (float, float)\n293         \"\"\"\n294         self._offset = xy\n295         self.stale = True\n296 \n297     @_compat_get_offset\n298     def get_offset(self, bbox, renderer):\n299         \"\"\"\n300         Return the offset as a tuple (x, y).\n301 \n302         The extent parameters have to be provided to handle the case where the\n303         offset is dynamically determined by a callable (see\n304         `~.OffsetBox.set_offset`).\n305 \n306         Parameters\n307         ----------\n308         bbox : `.Bbox`\n309         renderer : `.RendererBase` subclass\n310         \"\"\"\n311         return (\n312             self._offset(bbox.width, bbox.height, -bbox.x0, -bbox.y0, renderer)\n313             if callable(self._offset)\n314             else self._offset)\n315 \n316     def set_width(self, width):\n317         \"\"\"\n318         Set the width of the box.\n319 \n320         Parameters\n321         ----------\n322         width : float\n323         \"\"\"\n324         self.width = width\n325         self.stale = True\n326 \n327     def set_height(self, height):\n328         \"\"\"\n329         Set the height of the box.\n330 \n331         Parameters\n332         ----------\n333         height : float\n334         \"\"\"\n335         self.height = height\n336         self.stale = True\n337 \n338     def get_visible_children(self):\n339         r\"\"\"Return a list of the visible child `.Artist`\\s.\"\"\"\n340         return [c for c in self._children if c.get_visible()]\n341 \n342     def get_children(self):\n343         r\"\"\"Return a list of the child `.Artist`\\s.\"\"\"\n344         return self._children\n345 \n346     def _get_bbox_and_child_offsets(self, renderer):\n347         \"\"\"\n348         Return the bbox of the offsetbox and the child offsets.\n349 \n350         The bbox should satisfy ``x0 <= x1 and y0 <= y1``.\n351 \n352         Parameters\n353         ----------\n354         renderer : `.RendererBase` subclass\n355 \n356         Returns\n357         -------\n358         bbox\n359         list of (xoffset, yoffset) pairs\n360         \"\"\"\n361         raise NotImplementedError(\n362             \"get_bbox_and_offsets must be overridden in derived classes\")\n363 \n364     def get_bbox(self, renderer):\n365         \"\"\"Return the bbox of the offsetbox, ignoring parent offsets.\"\"\"\n366         bbox, offsets = self._get_bbox_and_child_offsets(renderer)\n367         return bbox\n368 \n369     @_api.deprecated(\"3.7\", alternative=\"get_bbox and child.get_offset\")\n370     def get_extent_offsets(self, renderer):\n371         \"\"\"\n372         Update offset of the children and return the extent of the box.\n373 \n374         Parameters\n375         ----------\n376         renderer : `.RendererBase` subclass\n377 \n378         Returns\n379         -------\n380         width\n381         height\n382         xdescent\n383         ydescent\n384         list of (xoffset, yoffset) pairs\n385         \"\"\"\n386         bbox, offsets = self._get_bbox_and_child_offsets(renderer)\n387         return bbox.width, bbox.height, -bbox.x0, -bbox.y0, offsets\n388 \n389     @_api.deprecated(\"3.7\", alternative=\"get_bbox\")\n390     def get_extent(self, renderer):\n391         \"\"\"Return a tuple ``width, height, xdescent, ydescent`` of the box.\"\"\"\n392         bbox = self.get_bbox(renderer)\n393         return bbox.width, bbox.height, -bbox.x0, -bbox.y0\n394 \n395     def get_window_extent(self, renderer=None):\n396         # docstring inherited\n397         if renderer is None:\n398             renderer = self.figure._get_renderer()\n399         bbox = self.get_bbox(renderer)\n400         try:  # Some subclasses redefine get_offset to take no args.\n401             px, py = self.get_offset(bbox, renderer)\n402         except TypeError:\n403             px, py = self.get_offset()\n404         return bbox.translated(px, py)\n405 \n406     def draw(self, renderer):\n407         \"\"\"\n408         Update the location of children if necessary and draw them\n409         to the given *renderer*.\n410         \"\"\"\n411         bbox, offsets = self._get_bbox_and_child_offsets(renderer)\n412         px, py = self.get_offset(bbox, renderer)\n413         for c, (ox, oy) in zip(self.get_visible_children(), offsets):\n414             c.set_offset((px + ox, py + oy))\n415             c.draw(renderer)\n416         _bbox_artist(self, renderer, fill=False, props=dict(pad=0.))\n417         self.stale = False\n",
        "intended_behavior": "This class provides additional context to the issue."
    }
]