[
    {
        "rel_file_path": "src/_pytest/junitxml.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/pytest-dev__pytest/setup_pytest-dev__pytest__4.4/src/_pytest/junitxml.py",
        "start": 1,
        "end": 647,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\"\n2     report test results in JUnit-XML format,\n3     for use with Jenkins and build integration servers.\n4 \n5 \n6 Based on initial code from Ross Lawley.\n7 \n8 Output conforms to https://github.com/jenkinsci/xunit-plugin/blob/master/\n9 src/main/resources/org/jenkinsci/plugins/xunit/types/model/xsd/junit-10.xsd\n10 \"\"\"\n11 from __future__ import absolute_import\n12 from __future__ import division\n13 from __future__ import print_function\n14 \n15 import functools\n16 import os\n17 import re\n18 import sys\n19 import time\n20 \n21 import py\n22 import six\n23 \n24 import pytest\n25 from _pytest import nodes\n26 from _pytest.config import filename_arg\n27 \n28 # Python 2.X and 3.X compatibility\n29 if sys.version_info[0] < 3:\n30     from codecs import open\n31 \n32 \n33 class Junit(py.xml.Namespace):\n34     pass\n35 \n36 \n37 # We need to get the subset of the invalid unicode ranges according to\n38 # XML 1.0 which are valid in this python build.  Hence we calculate\n39 # this dynamically instead of hardcoding it.  The spec range of valid\n40 # chars is: Char ::= #x9 | #xA | #xD | [#x20-#xD7FF] | [#xE000-#xFFFD]\n41 #                    | [#x10000-#x10FFFF]\n42 _legal_chars = (0x09, 0x0A, 0x0D)\n43 _legal_ranges = ((0x20, 0x7E), (0x80, 0xD7FF), (0xE000, 0xFFFD), (0x10000, 0x10FFFF))\n44 _legal_xml_re = [\n45     u\"%s-%s\" % (six.unichr(low), six.unichr(high))\n46     for (low, high) in _legal_ranges\n47     if low < sys.maxunicode\n48 ]\n49 _legal_xml_re = [six.unichr(x) for x in _legal_chars] + _legal_xml_re\n50 illegal_xml_re = re.compile(u\"[^%s]\" % u\"\".join(_legal_xml_re))\n51 del _legal_chars\n52 del _legal_ranges\n53 del _legal_xml_re\n54 \n55 _py_ext_re = re.compile(r\"\\.py$\")\n56 \n57 \n58 def bin_xml_escape(arg):\n59     def repl(matchobj):\n60         i = ord(matchobj.group())\n61         if i <= 0xFF:\n62             return u\"#x%02X\" % i\n63         else:\n64             return u\"#x%04X\" % i\n65 \n66     return py.xml.raw(illegal_xml_re.sub(repl, py.xml.escape(arg)))\n67 \n68 \n69 def merge_family(left, right):\n70     result = {}\n71     for kl, vl in left.items():\n72         for kr, vr in right.items():\n73             if not isinstance(vl, list):\n74                 raise TypeError(type(vl))\n75             result[kl] = vl + vr\n76     left.update(result)\n77 \n78 \n79 families = {}\n80 families[\"_base\"] = {\"testcase\": [\"classname\", \"name\"]}\n81 families[\"_base_legacy\"] = {\"testcase\": [\"file\", \"line\", \"url\"]}\n82 \n83 # xUnit 1.x inherits legacy attributes\n84 families[\"xunit1\"] = families[\"_base\"].copy()\n85 merge_family(families[\"xunit1\"], families[\"_base_legacy\"])\n86 \n87 # xUnit 2.x uses strict base attributes\n88 families[\"xunit2\"] = families[\"_base\"]\n89 \n90 \n91 class _NodeReporter(object):\n92     def __init__(self, nodeid, xml):\n93         self.id = nodeid\n94         self.xml = xml\n95         self.add_stats = self.xml.add_stats\n96         self.family = self.xml.family\n97         self.duration = 0\n98         self.properties = []\n99         self.nodes = []\n100         self.testcase = None\n101         self.attrs = {}\n102 \n103     def append(self, node):\n104         self.xml.add_stats(type(node).__name__)\n105         self.nodes.append(node)\n106 \n107     def add_property(self, name, value):\n108         self.properties.append((str(name), bin_xml_escape(value)))\n109 \n110     def add_attribute(self, name, value):\n111         self.attrs[str(name)] = bin_xml_escape(value)\n112 \n113     def make_properties_node(self):\n114         \"\"\"Return a Junit node containing custom properties, if any.\n115         \"\"\"\n116         if self.properties:\n117             return Junit.properties(\n118                 [\n119                     Junit.property(name=name, value=value)\n120                     for name, value in self.properties\n121                 ]\n122             )\n123         return \"\"\n124 \n125     def record_testreport(self, testreport):\n126         assert not self.testcase\n127         names = mangle_test_address(testreport.nodeid)\n128         existing_attrs = self.attrs\n129         classnames = names[:-1]\n130         if self.xml.prefix:\n131             classnames.insert(0, self.xml.prefix)\n132         attrs = {\n133             \"classname\": \".\".join(classnames),\n134             \"name\": bin_xml_escape(names[-1]),\n135             \"file\": testreport.location[0],\n136         }\n137         if testreport.location[1] is not None:\n138             attrs[\"line\"] = testreport.location[1]\n139         if hasattr(testreport, \"url\"):\n140             attrs[\"url\"] = testreport.url\n141         self.attrs = attrs\n142         self.attrs.update(existing_attrs)  # restore any user-defined attributes\n143 \n144         # Preserve legacy testcase behavior\n145         if self.family == \"xunit1\":\n146             return\n147 \n148         # Filter out attributes not permitted by this test family.\n149         # Including custom attributes because they are not valid here.\n150         temp_attrs = {}\n151         for key in self.attrs.keys():\n152             if key in families[self.family][\"testcase\"]:\n153                 temp_attrs[key] = self.attrs[key]\n154         self.attrs = temp_attrs\n155 \n156     def to_xml(self):\n157         testcase = Junit.testcase(time=\"%.3f\" % self.duration, **self.attrs)\n158         testcase.append(self.make_properties_node())\n159         for node in self.nodes:\n160             testcase.append(node)\n161         return testcase\n162 \n163     def _add_simple(self, kind, message, data=None):\n164         data = bin_xml_escape(data)\n165         node = kind(data, message=message)\n166         self.append(node)\n167 \n168     def write_captured_output(self, report):\n169         content_out = report.capstdout\n170         content_log = report.caplog\n171         content_err = report.capstderr\n172 \n173         if content_log or content_out:\n174             if content_log and self.xml.logging == \"system-out\":\n175                 if content_out:\n176                     # syncing stdout and the log-output is not done yet. It's\n177                     # probably not worth the effort. Therefore, first the captured\n178                     # stdout is shown and then the captured logs.\n179                     content = \"\\n\".join(\n180                         [\n181                             \" Captured Stdout \".center(80, \"-\"),\n182                             content_out,\n183                             \"\",\n184                             \" Captured Log \".center(80, \"-\"),\n185                             content_log,\n186                         ]\n187                     )\n188                 else:\n189                     content = content_log\n190             else:\n191                 content = content_out\n192 \n193             if content:\n194                 tag = getattr(Junit, \"system-out\")\n195                 self.append(tag(bin_xml_escape(content)))\n196 \n197         if content_log or content_err:\n198             if content_log and self.xml.logging == \"system-err\":\n199                 if content_err:\n200                     content = \"\\n\".join(\n201                         [\n202                             \" Captured Stderr \".center(80, \"-\"),\n203                             content_err,\n204                             \"\",\n205                             \" Captured Log \".center(80, \"-\"),\n206                             content_log,\n207                         ]\n208                     )\n209                 else:\n210                     content = content_log\n211             else:\n212                 content = content_err\n213 \n214             if content:\n215                 tag = getattr(Junit, \"system-err\")\n216                 self.append(tag(bin_xml_escape(content)))\n217 \n218     def append_pass(self, report):\n219         self.add_stats(\"passed\")\n220 \n221     def append_failure(self, report):\n222         # msg = str(report.longrepr.reprtraceback.extraline)\n223         if hasattr(report, \"wasxfail\"):\n224             self._add_simple(Junit.skipped, \"xfail-marked test passes unexpectedly\")\n225         else:\n226             if hasattr(report.longrepr, \"reprcrash\"):\n227                 message = report.longrepr.reprcrash.message\n228             elif isinstance(report.longrepr, six.string_types):\n229                 message = report.longrepr\n230             else:\n231                 message = str(report.longrepr)\n232             message = bin_xml_escape(message)\n233             fail = Junit.failure(message=message)\n234             fail.append(bin_xml_escape(report.longrepr))\n235             self.append(fail)\n236 \n237     def append_collect_error(self, report):\n238         # msg = str(report.longrepr.reprtraceback.extraline)\n239         self.append(\n240             Junit.error(bin_xml_escape(report.longrepr), message=\"collection failure\")\n241         )\n242 \n243     def append_collect_skipped(self, report):\n244         self._add_simple(Junit.skipped, \"collection skipped\", report.longrepr)\n245 \n246     def append_error(self, report):\n247         if report.when == \"teardown\":\n248             msg = \"test teardown failure\"\n249         else:\n250             msg = \"test setup failure\"\n251         self._add_simple(Junit.error, msg, report.longrepr)\n252 \n253     def append_skipped(self, report):\n254         if hasattr(report, \"wasxfail\"):\n255             xfailreason = report.wasxfail\n256             if xfailreason.startswith(\"reason: \"):\n257                 xfailreason = xfailreason[8:]\n258             self.append(\n259                 Junit.skipped(\n260                     \"\", type=\"pytest.xfail\", message=bin_xml_escape(xfailreason)\n261                 )\n262             )\n263         else:\n264             filename, lineno, skipreason = report.longrepr\n265             if skipreason.startswith(\"Skipped: \"):\n266                 skipreason = skipreason[9:]\n267             details = \"%s:%s: %s\" % (filename, lineno, skipreason)\n268 \n269             self.append(\n270                 Junit.skipped(\n271                     bin_xml_escape(details),\n272                     type=\"pytest.skip\",\n273                     message=bin_xml_escape(skipreason),\n274                 )\n275             )\n276             self.write_captured_output(report)\n277 \n278     def finalize(self):\n279         data = self.to_xml().unicode(indent=0)\n280         self.__dict__.clear()\n281         self.to_xml = lambda: py.xml.raw(data)\n282 \n283 \n284 def _warn_incompatibility_with_xunit2(request, fixture_name):\n285     \"\"\"Emits a PytestWarning about the given fixture being incompatible with newer xunit revisions\"\"\"\n286     from _pytest.warning_types import PytestWarning\n287 \n288     xml = getattr(request.config, \"_xml\", None)\n289     if xml is not None and xml.family not in (\"xunit1\", \"legacy\"):\n290         request.node.warn(\n291             PytestWarning(\n292                 \"{fixture_name} is incompatible with junit_family '{family}' (use 'legacy' or 'xunit1')\".format(\n293                     fixture_name=fixture_name, family=xml.family\n294                 )\n295             )\n296         )\n297 \n298 \n299 @pytest.fixture\n300 def record_property(request):\n301     \"\"\"Add an extra properties the calling test.\n302     User properties become part of the test report and are available to the\n303     configured reporters, like JUnit XML.\n304     The fixture is callable with ``(name, value)``, with value being automatically\n305     xml-encoded.\n306 \n307     Example::\n308 \n309         def test_function(record_property):\n310             record_property(\"example_key\", 1)\n311     \"\"\"\n312     _warn_incompatibility_with_xunit2(request, \"record_property\")\n313 \n314     def append_property(name, value):\n315         request.node.user_properties.append((name, value))\n316 \n317     return append_property\n318 \n319 \n320 @pytest.fixture\n321 def record_xml_attribute(request):\n322     \"\"\"Add extra xml attributes to the tag for the calling test.\n323     The fixture is callable with ``(name, value)``, with value being\n324     automatically xml-encoded\n325     \"\"\"\n326     from _pytest.warning_types import PytestExperimentalApiWarning\n327 \n328     request.node.warn(\n329         PytestExperimentalApiWarning(\"record_xml_attribute is an experimental feature\")\n330     )\n331 \n332     _warn_incompatibility_with_xunit2(request, \"record_xml_attribute\")\n333 \n334     # Declare noop\n335     def add_attr_noop(name, value):\n336         pass\n337 \n338     attr_func = add_attr_noop\n339 \n340     xml = getattr(request.config, \"_xml\", None)\n341     if xml is not None:\n342         node_reporter = xml.node_reporter(request.node.nodeid)\n343         attr_func = node_reporter.add_attribute\n344 \n345     return attr_func\n346 \n347 \n348 def pytest_addoption(parser):\n349     group = parser.getgroup(\"terminal reporting\")\n350     group.addoption(\n351         \"--junitxml\",\n352         \"--junit-xml\",\n353         action=\"store\",\n354         dest=\"xmlpath\",\n355         metavar=\"path\",\n356         type=functools.partial(filename_arg, optname=\"--junitxml\"),\n357         default=None,\n358         help=\"create junit-xml style report file at given path.\",\n359     )\n360     group.addoption(\n361         \"--junitprefix\",\n362         \"--junit-prefix\",\n363         action=\"store\",\n364         metavar=\"str\",\n365         default=None,\n366         help=\"prepend prefix to classnames in junit-xml output\",\n367     )\n368     parser.addini(\n369         \"junit_suite_name\", \"Test suite name for JUnit report\", default=\"pytest\"\n370     )\n371     parser.addini(\n372         \"junit_logging\",\n373         \"Write captured log messages to JUnit report: \"\n374         \"one of no|system-out|system-err\",\n375         default=\"no\",\n376     )  # choices=['no', 'stdout', 'stderr'])\n377     parser.addini(\n378         \"junit_duration_report\",\n379         \"Duration time to report: one of total|call\",\n380         default=\"total\",\n381     )  # choices=['total', 'call'])\n382     parser.addini(\n383         \"junit_family\",\n384         \"Emit XML for schema: one of legacy|xunit1|xunit2\",\n385         default=\"xunit1\",\n386     )\n387 \n388 \n389 def pytest_configure(config):\n390     xmlpath = config.option.xmlpath\n391     # prevent opening xmllog on slave nodes (xdist)\n392     if xmlpath and not hasattr(config, \"slaveinput\"):\n393         config._xml = LogXML(\n394             xmlpath,\n395             config.option.junitprefix,\n396             config.getini(\"junit_suite_name\"),\n397             config.getini(\"junit_logging\"),\n398             config.getini(\"junit_duration_report\"),\n399             config.getini(\"junit_family\"),\n400         )\n401         config.pluginmanager.register(config._xml)\n402 \n403 \n404 def pytest_unconfigure(config):\n405     xml = getattr(config, \"_xml\", None)\n406     if xml:\n407         del config._xml\n408         config.pluginmanager.unregister(xml)\n409 \n410 \n411 def mangle_test_address(address):\n412     path, possible_open_bracket, params = address.partition(\"[\")\n413     names = path.split(\"::\")\n414     try:\n415         names.remove(\"()\")\n416     except ValueError:\n417         pass\n418     # convert file path to dotted path\n419     names[0] = names[0].replace(nodes.SEP, \".\")\n420     names[0] = _py_ext_re.sub(\"\", names[0])\n421     # put any params back\n422     names[-1] += possible_open_bracket + params\n423     return names\n424 \n425 \n426 class LogXML(object):\n427     def __init__(\n428         self,\n429         logfile,\n430         prefix,\n431         suite_name=\"pytest\",\n432         logging=\"no\",\n433         report_duration=\"total\",\n434         family=\"xunit1\",\n435     ):\n436         logfile = os.path.expanduser(os.path.expandvars(logfile))\n437         self.logfile = os.path.normpath(os.path.abspath(logfile))\n438         self.prefix = prefix\n439         self.suite_name = suite_name\n440         self.logging = logging\n441         self.report_duration = report_duration\n442         self.family = family\n443         self.stats = dict.fromkeys([\"error\", \"passed\", \"failure\", \"skipped\"], 0)\n444         self.node_reporters = {}  # nodeid -> _NodeReporter\n445         self.node_reporters_ordered = []\n446         self.global_properties = []\n447         # List of reports that failed on call but teardown is pending.\n448         self.open_reports = []\n449         self.cnt_double_fail_tests = 0\n450 \n451         # Replaces convenience family with real family\n452         if self.family == \"legacy\":\n453             self.family = \"xunit1\"\n454 \n455     def finalize(self, report):\n456         nodeid = getattr(report, \"nodeid\", report)\n457         # local hack to handle xdist report order\n458         slavenode = getattr(report, \"node\", None)\n459         reporter = self.node_reporters.pop((nodeid, slavenode))\n460         if reporter is not None:\n461             reporter.finalize()\n462 \n463     def node_reporter(self, report):\n464         nodeid = getattr(report, \"nodeid\", report)\n465         # local hack to handle xdist report order\n466         slavenode = getattr(report, \"node\", None)\n467 \n468         key = nodeid, slavenode\n469 \n470         if key in self.node_reporters:\n471             # TODO: breasks for --dist=each\n472             return self.node_reporters[key]\n473 \n474         reporter = _NodeReporter(nodeid, self)\n475 \n476         self.node_reporters[key] = reporter\n477         self.node_reporters_ordered.append(reporter)\n478 \n479         return reporter\n480 \n481     def add_stats(self, key):\n482         if key in self.stats:\n483             self.stats[key] += 1\n484 \n485     def _opentestcase(self, report):\n486         reporter = self.node_reporter(report)\n487         reporter.record_testreport(report)\n488         return reporter\n489 \n490     def pytest_runtest_logreport(self, report):\n491         \"\"\"handle a setup/call/teardown report, generating the appropriate\n492         xml tags as necessary.\n493 \n494         note: due to plugins like xdist, this hook may be called in interlaced\n495         order with reports from other nodes. for example:\n496 \n497         usual call order:\n498             -> setup node1\n499             -> call node1\n500             -> teardown node1\n501             -> setup node2\n502             -> call node2\n503             -> teardown node2\n504 \n505         possible call order in xdist:\n506             -> setup node1\n507             -> call node1\n508             -> setup node2\n509             -> call node2\n510             -> teardown node2\n511             -> teardown node1\n512         \"\"\"\n513         close_report = None\n514         if report.passed:\n515             if report.when == \"call\":  # ignore setup/teardown\n516                 reporter = self._opentestcase(report)\n517                 reporter.append_pass(report)\n518         elif report.failed:\n519             if report.when == \"teardown\":\n520                 # The following vars are needed when xdist plugin is used\n521                 report_wid = getattr(report, \"worker_id\", None)\n522                 report_ii = getattr(report, \"item_index\", None)\n523                 close_report = next(\n524                     (\n525                         rep\n526                         for rep in self.open_reports\n527                         if (\n528                             rep.nodeid == report.nodeid\n529                             and getattr(rep, \"item_index\", None) == report_ii\n530                             and getattr(rep, \"worker_id\", None) == report_wid\n531                         )\n532                     ),\n533                     None,\n534                 )\n535                 if close_report:\n536                     # We need to open new testcase in case we have failure in\n537                     # call and error in teardown in order to follow junit\n538                     # schema\n539                     self.finalize(close_report)\n540                     self.cnt_double_fail_tests += 1\n541             reporter = self._opentestcase(report)\n542             if report.when == \"call\":\n543                 reporter.append_failure(report)\n544                 self.open_reports.append(report)\n545             else:\n546                 reporter.append_error(report)\n547         elif report.skipped:\n548             reporter = self._opentestcase(report)\n549             reporter.append_skipped(report)\n550         self.update_testcase_duration(report)\n551         if report.when == \"teardown\":\n552             reporter = self._opentestcase(report)\n553             reporter.write_captured_output(report)\n554 \n555             for propname, propvalue in report.user_properties:\n556                 reporter.add_property(propname, propvalue)\n557 \n558             self.finalize(report)\n559             report_wid = getattr(report, \"worker_id\", None)\n560             report_ii = getattr(report, \"item_index\", None)\n561             close_report = next(\n562                 (\n563                     rep\n564                     for rep in self.open_reports\n565                     if (\n566                         rep.nodeid == report.nodeid\n567                         and getattr(rep, \"item_index\", None) == report_ii\n568                         and getattr(rep, \"worker_id\", None) == report_wid\n569                     )\n570                 ),\n571                 None,\n572             )\n573             if close_report:\n574                 self.open_reports.remove(close_report)\n575 \n576     def update_testcase_duration(self, report):\n577         \"\"\"accumulates total duration for nodeid from given report and updates\n578         the Junit.testcase with the new total if already created.\n579         \"\"\"\n580         if self.report_duration == \"total\" or report.when == self.report_duration:\n581             reporter = self.node_reporter(report)\n582             reporter.duration += getattr(report, \"duration\", 0.0)\n583 \n584     def pytest_collectreport(self, report):\n585         if not report.passed:\n586             reporter = self._opentestcase(report)\n587             if report.failed:\n588                 reporter.append_collect_error(report)\n589             else:\n590                 reporter.append_collect_skipped(report)\n591 \n592     def pytest_internalerror(self, excrepr):\n593         reporter = self.node_reporter(\"internal\")\n594         reporter.attrs.update(classname=\"pytest\", name=\"internal\")\n595         reporter._add_simple(Junit.error, \"internal error\", excrepr)\n596 \n597     def pytest_sessionstart(self):\n598         self.suite_start_time = time.time()\n599 \n600     def pytest_sessionfinish(self):\n601         dirname = os.path.dirname(os.path.abspath(self.logfile))\n602         if not os.path.isdir(dirname):\n603             os.makedirs(dirname)\n604         logfile = open(self.logfile, \"w\", encoding=\"utf-8\")\n605         suite_stop_time = time.time()\n606         suite_time_delta = suite_stop_time - self.suite_start_time\n607 \n608         numtests = (\n609             self.stats[\"passed\"]\n610             + self.stats[\"failure\"]\n611             + self.stats[\"skipped\"]\n612             + self.stats[\"error\"]\n613             - self.cnt_double_fail_tests\n614         )\n615         logfile.write('<?xml version=\"1.0\" encoding=\"utf-8\"?>')\n616 \n617         logfile.write(\n618             Junit.testsuite(\n619                 self._get_global_properties_node(),\n620                 [x.to_xml() for x in self.node_reporters_ordered],\n621                 name=self.suite_name,\n622                 errors=self.stats[\"error\"],\n623                 failures=self.stats[\"failure\"],\n624                 skipped=self.stats[\"skipped\"],\n625                 tests=numtests,\n626                 time=\"%.3f\" % suite_time_delta,\n627             ).unicode(indent=0)\n628         )\n629         logfile.close()\n630 \n631     def pytest_terminal_summary(self, terminalreporter):\n632         terminalreporter.write_sep(\"-\", \"generated xml file: %s\" % (self.logfile))\n633 \n634     def add_global_property(self, name, value):\n635         self.global_properties.append((str(name), bin_xml_escape(value)))\n636 \n637     def _get_global_properties_node(self):\n638         \"\"\"Return a Junit node containing custom properties, if any.\n639         \"\"\"\n640         if self.global_properties:\n641             return Junit.properties(\n642                 [\n643                     Junit.property(name=name, value=value)\n644                     for name, value in self.global_properties\n645                 ]\n646             )\n647         return \"\"\n",
        "intended_behavior": "Ensure that `<properties>` elements are appended to `<testsuite>` elements rather than `<testcase>` elements. This adjustment requires a review and potential modification of how and where `<properties>` tags are generated and inserted into the XML document."
    }
]