[
    {
        "rel_file_path": "sphinx/ext/autodoc/__init__.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sphinx-doc__sphinx/setup_sphinx-doc__sphinx__3.3/sphinx/ext/autodoc/__init__.py",
        "start": 1,
        "end": 2277,
        "class_name": null,
        "method_name": null,
        "code": "1 \"\"\"\n2     sphinx.ext.autodoc\n3     ~~~~~~~~~~~~~~~~~~\n4 \n5     Automatically insert docstrings for functions, classes or whole modules into\n6     the doctree, thus avoiding duplication between docstrings and documentation\n7     for those who like elaborate docstrings.\n8 \n9     :copyright: Copyright 2007-2020 by the Sphinx team, see AUTHORS.\n10     :license: BSD, see LICENSE for details.\n11 \"\"\"\n12 \n13 import importlib\n14 import re\n15 import warnings\n16 from inspect import Parameter, Signature\n17 from types import ModuleType\n18 from typing import (\n19     Any, Callable, Dict, Iterator, List, Optional, Sequence, Set, Tuple, Type, TypeVar, Union\n20 )\n21 from typing import get_type_hints\n22 \n23 from docutils.statemachine import StringList\n24 \n25 import sphinx\n26 from sphinx.application import Sphinx\n27 from sphinx.config import Config, ENUM\n28 from sphinx.deprecation import RemovedInSphinx40Warning, RemovedInSphinx50Warning\n29 from sphinx.environment import BuildEnvironment\n30 from sphinx.ext.autodoc.importer import import_object, get_module_members, get_object_members\n31 from sphinx.ext.autodoc.mock import mock\n32 from sphinx.locale import _, __\n33 from sphinx.pycode import ModuleAnalyzer, PycodeError\n34 from sphinx.util import inspect\n35 from sphinx.util import logging\n36 from sphinx.util.docstrings import extract_metadata, prepare_docstring\n37 from sphinx.util.inspect import (\n38     evaluate_signature, getdoc, object_description, safe_getattr, stringify_signature\n39 )\n40 from sphinx.util.typing import stringify as stringify_typehint\n41 \n42 if False:\n43     # For type annotation\n44     from typing import Type  # NOQA # for python3.5.1\n45     from sphinx.ext.autodoc.directive import DocumenterBridge\n46 \n47 \n48 logger = logging.getLogger(__name__)\n49 \n50 \n51 # This type isn't exposed directly in any modules, but can be found\n52 # here in most Python versions\n53 MethodDescriptorType = type(type.__subclasses__)\n54 \n55 \n56 #: extended signature RE: with explicit module name separated by ::\n57 py_ext_sig_re = re.compile(\n58     r'''^ ([\\w.]+::)?            # explicit module name\n59           ([\\w.]+\\.)?            # module and/or class name(s)\n60           (\\w+)  \\s*             # thing name\n61           (?: \\((.*)\\)           # optional: arguments\n62            (?:\\s* -> \\s* (.*))?  #           return annotation\n63           )? $                   # and nothing more\n64           ''', re.VERBOSE)\n65 special_member_re = re.compile(r'^__\\S+__$')\n66 \n67 \n68 def identity(x: Any) -> Any:\n69     return x\n70 \n71 \n72 class _All:\n73     \"\"\"A special value for :*-members: that matches to any member.\"\"\"\n74 \n75     def __contains__(self, item: Any) -> bool:\n76         return True\n77 \n78 \n79 class _Empty:\n80     \"\"\"A special value for :exclude-members: that never matches to any member.\"\"\"\n81 \n82     def __contains__(self, item: Any) -> bool:\n83         return False\n84 \n85 \n86 ALL = _All()\n87 EMPTY = _Empty()\n88 UNINITIALIZED_ATTR = object()\n89 INSTANCEATTR = object()\n90 SLOTSATTR = object()\n91 \n92 \n93 def members_option(arg: Any) -> Union[object, List[str]]:\n94     \"\"\"Used to convert the :members: option to auto directives.\"\"\"\n95     if arg is None or arg is True:\n96         return ALL\n97     elif arg is False:\n98         return None\n99     else:\n100         return [x.strip() for x in arg.split(',') if x.strip()]\n101 \n102 \n103 def members_set_option(arg: Any) -> Union[object, Set[str]]:\n104     \"\"\"Used to convert the :members: option to auto directives.\"\"\"\n105     warnings.warn(\"members_set_option() is deprecated.\",\n106                   RemovedInSphinx50Warning, stacklevel=2)\n107     if arg is None:\n108         return ALL\n109     return {x.strip() for x in arg.split(',') if x.strip()}\n110 \n111 \n112 def exclude_members_option(arg: Any) -> Union[object, Set[str]]:\n113     \"\"\"Used to convert the :exclude-members: option.\"\"\"\n114     if arg is None:\n115         return EMPTY\n116     return {x.strip() for x in arg.split(',') if x.strip()}\n117 \n118 \n119 def inherited_members_option(arg: Any) -> Union[object, Set[str]]:\n120     \"\"\"Used to convert the :members: option to auto directives.\"\"\"\n121     if arg is None:\n122         return 'object'\n123     else:\n124         return arg\n125 \n126 \n127 def member_order_option(arg: Any) -> Optional[str]:\n128     \"\"\"Used to convert the :members: option to auto directives.\"\"\"\n129     if arg is None:\n130         return None\n131     elif arg in ('alphabetical', 'bysource', 'groupwise'):\n132         return arg\n133     else:\n134         raise ValueError(__('invalid value for member-order option: %s') % arg)\n135 \n136 \n137 SUPPRESS = object()\n138 \n139 \n140 def annotation_option(arg: Any) -> Any:\n141     if arg is None:\n142         # suppress showing the representation of the object\n143         return SUPPRESS\n144     else:\n145         return arg\n146 \n147 \n148 def bool_option(arg: Any) -> bool:\n149     \"\"\"Used to convert flag options to auto directives.  (Instead of\n150     directives.flag(), which returns None).\n151     \"\"\"\n152     return True\n153 \n154 \n155 def merge_special_members_option(options: Dict) -> None:\n156     \"\"\"Merge :special-members: option to :members: option.\"\"\"\n157     warnings.warn(\"merge_special_members_option() is deprecated.\",\n158                   RemovedInSphinx50Warning, stacklevel=2)\n159     if 'special-members' in options and options['special-members'] is not ALL:\n160         if options.get('members') is ALL:\n161             pass\n162         elif options.get('members'):\n163             for member in options['special-members']:\n164                 if member not in options['members']:\n165                     options['members'].append(member)\n166         else:\n167             options['members'] = options['special-members']\n168 \n169 \n170 def merge_members_option(options: Dict) -> None:\n171     \"\"\"Merge :*-members: option to the :members: option.\"\"\"\n172     if options.get('members') is ALL:\n173         # merging is not needed when members: ALL\n174         return\n175 \n176     members = options.setdefault('members', [])\n177     for key in {'private-members', 'special-members'}:\n178         if key in options and options[key] not in (ALL, None):\n179             for member in options[key]:\n180                 if member not in members:\n181                     members.append(member)\n182 \n183 \n184 # Some useful event listener factories for autodoc-process-docstring.\n185 \n186 def cut_lines(pre: int, post: int = 0, what: str = None) -> Callable:\n187     \"\"\"Return a listener that removes the first *pre* and last *post*\n188     lines of every docstring.  If *what* is a sequence of strings,\n189     only docstrings of a type in *what* will be processed.\n190 \n191     Use like this (e.g. in the ``setup()`` function of :file:`conf.py`)::\n192 \n193        from sphinx.ext.autodoc import cut_lines\n194        app.connect('autodoc-process-docstring', cut_lines(4, what=['module']))\n195 \n196     This can (and should) be used in place of :confval:`automodule_skip_lines`.\n197     \"\"\"\n198     def process(app: Sphinx, what_: str, name: str, obj: Any, options: Any, lines: List[str]\n199                 ) -> None:\n200         if what and what_ not in what:\n201             return\n202         del lines[:pre]\n203         if post:\n204             # remove one trailing blank line.\n205             if lines and not lines[-1]:\n206                 lines.pop(-1)\n207             del lines[-post:]\n208         # make sure there is a blank line at the end\n209         if lines and lines[-1]:\n210             lines.append('')\n211     return process\n212 \n213 \n214 def between(marker: str, what: Sequence[str] = None, keepempty: bool = False,\n215             exclude: bool = False) -> Callable:\n216     \"\"\"Return a listener that either keeps, or if *exclude* is True excludes,\n217     lines between lines that match the *marker* regular expression.  If no line\n218     matches, the resulting docstring would be empty, so no change will be made\n219     unless *keepempty* is true.\n220 \n221     If *what* is a sequence of strings, only docstrings of a type in *what* will\n222     be processed.\n223     \"\"\"\n224     marker_re = re.compile(marker)\n225 \n226     def process(app: Sphinx, what_: str, name: str, obj: Any, options: Any, lines: List[str]\n227                 ) -> None:\n228         if what and what_ not in what:\n229             return\n230         deleted = 0\n231         delete = not exclude\n232         orig_lines = lines[:]\n233         for i, line in enumerate(orig_lines):\n234             if delete:\n235                 lines.pop(i - deleted)\n236                 deleted += 1\n237             if marker_re.match(line):\n238                 delete = not delete\n239                 if delete:\n240                     lines.pop(i - deleted)\n241                     deleted += 1\n242         if not lines and not keepempty:\n243             lines[:] = orig_lines\n244         # make sure there is a blank line at the end\n245         if lines and lines[-1]:\n246             lines.append('')\n247     return process\n248 \n249 \n250 # This class is used only in ``sphinx.ext.autodoc.directive``,\n251 # But we define this class here to keep compatibility (see #4538)\n252 class Options(dict):\n253     \"\"\"A dict/attribute hybrid that returns None on nonexisting keys.\"\"\"\n254     def __getattr__(self, name: str) -> Any:\n255         try:\n256             return self[name.replace('_', '-')]\n257         except KeyError:\n258             return None\n259 \n260 \n261 class Documenter:\n262     \"\"\"\n263     A Documenter knows how to autodocument a single object type.  When\n264     registered with the AutoDirective, it will be used to document objects\n265     of that type when needed by autodoc.\n266 \n267     Its *objtype* attribute selects what auto directive it is assigned to\n268     (the directive name is 'auto' + objtype), and what directive it generates\n269     by default, though that can be overridden by an attribute called\n270     *directivetype*.\n271 \n272     A Documenter has an *option_spec* that works like a docutils directive's;\n273     in fact, it will be used to parse an auto directive's options that matches\n274     the documenter.\n275     \"\"\"\n276     #: name by which the directive is called (auto...) and the default\n277     #: generated directive name\n278     objtype = 'object'\n279     #: indentation by which to indent the directive content\n280     content_indent = '   '\n281     #: priority if multiple documenters return True from can_document_member\n282     priority = 0\n283     #: order if autodoc_member_order is set to 'groupwise'\n284     member_order = 0\n285     #: true if the generated content may contain titles\n286     titles_allowed = False\n287 \n288     option_spec = {'noindex': bool_option}  # type: Dict[str, Callable]\n289 \n290     def get_attr(self, obj: Any, name: str, *defargs: Any) -> Any:\n291         \"\"\"getattr() override for types such as Zope interfaces.\"\"\"\n292         return autodoc_attrgetter(self.env.app, obj, name, *defargs)\n293 \n294     @classmethod\n295     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any\n296                             ) -> bool:\n297         \"\"\"Called to see if a member can be documented by this documenter.\"\"\"\n298         raise NotImplementedError('must be implemented in subclasses')\n299 \n300     def __init__(self, directive: \"DocumenterBridge\", name: str, indent: str = '') -> None:\n301         self.directive = directive\n302         self.env = directive.env    # type: BuildEnvironment\n303         self.options = directive.genopt\n304         self.name = name\n305         self.indent = indent\n306         # the module and object path within the module, and the fully\n307         # qualified name (all set after resolve_name succeeds)\n308         self.modname = None         # type: str\n309         self.module = None          # type: ModuleType\n310         self.objpath = None         # type: List[str]\n311         self.fullname = None        # type: str\n312         # extra signature items (arguments and return annotation,\n313         # also set after resolve_name succeeds)\n314         self.args = None            # type: str\n315         self.retann = None          # type: str\n316         # the object to document (set after import_object succeeds)\n317         self.object = None          # type: Any\n318         self.object_name = None     # type: str\n319         # the parent/owner of the object to document\n320         self.parent = None          # type: Any\n321         # the module analyzer to get at attribute docs, or None\n322         self.analyzer = None        # type: ModuleAnalyzer\n323 \n324     @property\n325     def documenters(self) -> Dict[str, \"Type[Documenter]\"]:\n326         \"\"\"Returns registered Documenter classes\"\"\"\n327         return self.env.app.registry.documenters\n328 \n329     def add_line(self, line: str, source: str, *lineno: int) -> None:\n330         \"\"\"Append one line of generated reST to the output.\"\"\"\n331         if line.strip():  # not a blank line\n332             self.directive.result.append(self.indent + line, source, *lineno)\n333         else:\n334             self.directive.result.append('', source, *lineno)\n335 \n336     def resolve_name(self, modname: str, parents: Any, path: str, base: Any\n337                      ) -> Tuple[str, List[str]]:\n338         \"\"\"Resolve the module and name of the object to document given by the\n339         arguments and the current module/class.\n340 \n341         Must return a pair of the module name and a chain of attributes; for\n342         example, it would return ``('zipfile', ['ZipFile', 'open'])`` for the\n343         ``zipfile.ZipFile.open`` method.\n344         \"\"\"\n345         raise NotImplementedError('must be implemented in subclasses')\n346 \n347     def parse_name(self) -> bool:\n348         \"\"\"Determine what module to import and what attribute to document.\n349 \n350         Returns True and sets *self.modname*, *self.objpath*, *self.fullname*,\n351         *self.args* and *self.retann* if parsing and resolving was successful.\n352         \"\"\"\n353         # first, parse the definition -- auto directives for classes and\n354         # functions can contain a signature which is then used instead of\n355         # an autogenerated one\n356         try:\n357             explicit_modname, path, base, args, retann = \\\n358                 py_ext_sig_re.match(self.name).groups()\n359         except AttributeError:\n360             logger.warning(__('invalid signature for auto%s (%r)') % (self.objtype, self.name),\n361                            type='autodoc')\n362             return False\n363 \n364         # support explicit module and class name separation via ::\n365         if explicit_modname is not None:\n366             modname = explicit_modname[:-2]\n367             parents = path.rstrip('.').split('.') if path else []\n368         else:\n369             modname = None\n370             parents = []\n371 \n372         with mock(self.env.config.autodoc_mock_imports):\n373             self.modname, self.objpath = self.resolve_name(modname, parents, path, base)\n374 \n375         if not self.modname:\n376             return False\n377 \n378         self.args = args\n379         self.retann = retann\n380         self.fullname = (self.modname or '') + \\\n381                         ('.' + '.'.join(self.objpath) if self.objpath else '')\n382         return True\n383 \n384     def import_object(self, raiseerror: bool = False) -> bool:\n385         \"\"\"Import the object given by *self.modname* and *self.objpath* and set\n386         it as *self.object*.\n387 \n388         Returns True if successful, False if an error occurred.\n389         \"\"\"\n390         with mock(self.env.config.autodoc_mock_imports):\n391             try:\n392                 ret = import_object(self.modname, self.objpath, self.objtype,\n393                                     attrgetter=self.get_attr,\n394                                     warningiserror=self.env.config.autodoc_warningiserror)\n395                 self.module, self.parent, self.object_name, self.object = ret\n396                 return True\n397             except ImportError as exc:\n398                 if raiseerror:\n399                     raise\n400                 else:\n401                     logger.warning(exc.args[0], type='autodoc', subtype='import_object')\n402                     self.env.note_reread()\n403                     return False\n404 \n405     def get_real_modname(self) -> str:\n406         \"\"\"Get the real module name of an object to document.\n407 \n408         It can differ from the name of the module through which the object was\n409         imported.\n410         \"\"\"\n411         return self.get_attr(self.object, '__module__', None) or self.modname\n412 \n413     def check_module(self) -> bool:\n414         \"\"\"Check if *self.object* is really defined in the module given by\n415         *self.modname*.\n416         \"\"\"\n417         if self.options.imported_members:\n418             return True\n419 \n420         subject = inspect.unpartial(self.object)\n421         modname = self.get_attr(subject, '__module__', None)\n422         if modname and modname != self.modname:\n423             return False\n424         return True\n425 \n426     def format_args(self, **kwargs: Any) -> str:\n427         \"\"\"Format the argument signature of *self.object*.\n428 \n429         Should return None if the object does not have a signature.\n430         \"\"\"\n431         return None\n432 \n433     def format_name(self) -> str:\n434         \"\"\"Format the name of *self.object*.\n435 \n436         This normally should be something that can be parsed by the generated\n437         directive, but doesn't need to be (Sphinx will display it unparsed\n438         then).\n439         \"\"\"\n440         # normally the name doesn't contain the module (except for module\n441         # directives of course)\n442         return '.'.join(self.objpath) or self.modname\n443 \n444     def _call_format_args(self, **kwargs: Any) -> str:\n445         if kwargs:\n446             try:\n447                 return self.format_args(**kwargs)\n448             except TypeError:\n449                 # avoid chaining exceptions, by putting nothing here\n450                 pass\n451 \n452         # retry without arguments for old documenters\n453         return self.format_args()\n454 \n455     def format_signature(self, **kwargs: Any) -> str:\n456         \"\"\"Format the signature (arguments and return annotation) of the object.\n457 \n458         Let the user process it via the ``autodoc-process-signature`` event.\n459         \"\"\"\n460         if self.args is not None:\n461             # signature given explicitly\n462             args = \"(%s)\" % self.args\n463             retann = self.retann\n464         else:\n465             # try to introspect the signature\n466             try:\n467                 retann = None\n468                 args = self._call_format_args(**kwargs)\n469                 if args:\n470                     matched = re.match(r'^(\\(.*\\))\\s+->\\s+(.*)$', args)\n471                     if matched:\n472                         args = matched.group(1)\n473                         retann = matched.group(2)\n474             except Exception as exc:\n475                 logger.warning(__('error while formatting arguments for %s: %s'),\n476                                self.fullname, exc, type='autodoc')\n477                 args = None\n478 \n479         result = self.env.events.emit_firstresult('autodoc-process-signature',\n480                                                   self.objtype, self.fullname,\n481                                                   self.object, self.options, args, retann)\n482         if result:\n483             args, retann = result\n484 \n485         if args is not None:\n486             return args + ((' -> %s' % retann) if retann else '')\n487         else:\n488             return ''\n489 \n490     def add_directive_header(self, sig: str) -> None:\n491         \"\"\"Add the directive header and options to the generated content.\"\"\"\n492         domain = getattr(self, 'domain', 'py')\n493         directive = getattr(self, 'directivetype', self.objtype)\n494         name = self.format_name()\n495         sourcename = self.get_sourcename()\n496 \n497         # one signature per line, indented by column\n498         prefix = '.. %s:%s:: ' % (domain, directive)\n499         for i, sig_line in enumerate(sig.split(\"\\n\")):\n500             self.add_line('%s%s%s' % (prefix, name, sig_line),\n501                           sourcename)\n502             if i == 0:\n503                 prefix = \" \" * len(prefix)\n504 \n505         if self.options.noindex:\n506             self.add_line('   :noindex:', sourcename)\n507         if self.objpath:\n508             # Be explicit about the module, this is necessary since .. class::\n509             # etc. don't support a prepended module name\n510             self.add_line('   :module: %s' % self.modname, sourcename)\n511 \n512     def get_doc(self, encoding: str = None, ignore: int = None) -> List[List[str]]:\n513         \"\"\"Decode and return lines of the docstring(s) for the object.\"\"\"\n514         if encoding is not None:\n515             warnings.warn(\"The 'encoding' argument to autodoc.%s.get_doc() is deprecated.\"\n516                           % self.__class__.__name__,\n517                           RemovedInSphinx40Warning, stacklevel=2)\n518         if ignore is not None:\n519             warnings.warn(\"The 'ignore' argument to autodoc.%s.get_doc() is deprecated.\"\n520                           % self.__class__.__name__,\n521                           RemovedInSphinx50Warning, stacklevel=2)\n522         docstring = getdoc(self.object, self.get_attr,\n523                            self.env.config.autodoc_inherit_docstrings,\n524                            self.parent, self.object_name)\n525         if docstring:\n526             tab_width = self.directive.state.document.settings.tab_width\n527             return [prepare_docstring(docstring, ignore, tab_width)]\n528         return []\n529 \n530     def process_doc(self, docstrings: List[List[str]]) -> Iterator[str]:\n531         \"\"\"Let the user process the docstrings before adding them.\"\"\"\n532         for docstringlines in docstrings:\n533             if self.env.app:\n534                 # let extensions preprocess docstrings\n535                 self.env.app.emit('autodoc-process-docstring',\n536                                   self.objtype, self.fullname, self.object,\n537                                   self.options, docstringlines)\n538 \n539                 if docstringlines and docstringlines[-1] != '':\n540                     # append a blank line to the end of the docstring\n541                     docstringlines.append('')\n542 \n543             yield from docstringlines\n544 \n545     def get_sourcename(self) -> str:\n546         if self.analyzer:\n547             return '%s:docstring of %s' % (self.analyzer.srcname, self.fullname)\n548         return 'docstring of %s' % self.fullname\n549 \n550     def add_content(self, more_content: Any, no_docstring: bool = False) -> None:\n551         \"\"\"Add content from docstrings, attribute documentation and user.\"\"\"\n552         # set sourcename and add content from attribute documentation\n553         sourcename = self.get_sourcename()\n554         if self.analyzer:\n555             attr_docs = self.analyzer.find_attr_docs()\n556             if self.objpath:\n557                 key = ('.'.join(self.objpath[:-1]), self.objpath[-1])\n558                 if key in attr_docs:\n559                     no_docstring = True\n560                     # make a copy of docstring for attributes to avoid cache\n561                     # the change of autodoc-process-docstring event.\n562                     docstrings = [list(attr_docs[key])]\n563 \n564                     for i, line in enumerate(self.process_doc(docstrings)):\n565                         self.add_line(line, sourcename, i)\n566 \n567         # add content from docstrings\n568         if not no_docstring:\n569             docstrings = self.get_doc()\n570             if not docstrings:\n571                 # append at least a dummy docstring, so that the event\n572                 # autodoc-process-docstring is fired and can add some\n573                 # content if desired\n574                 docstrings.append([])\n575             for i, line in enumerate(self.process_doc(docstrings)):\n576                 self.add_line(line, sourcename, i)\n577 \n578         # add additional content (e.g. from document), if present\n579         if more_content:\n580             for line, src in zip(more_content.data, more_content.items):\n581                 self.add_line(line, src[0], src[1])\n582 \n583     def get_object_members(self, want_all: bool) -> Tuple[bool, List[Tuple[str, Any]]]:\n584         \"\"\"Return `(members_check_module, members)` where `members` is a\n585         list of `(membername, member)` pairs of the members of *self.object*.\n586 \n587         If *want_all* is True, return all members.  Else, only return those\n588         members given by *self.options.members* (which may also be none).\n589         \"\"\"\n590         members = get_object_members(self.object, self.objpath, self.get_attr, self.analyzer)\n591         if not want_all:\n592             if not self.options.members:\n593                 return False, []\n594             # specific members given\n595             selected = []\n596             for name in self.options.members:\n597                 if name in members:\n598                     selected.append((name, members[name].value))\n599                 else:\n600                     logger.warning(__('missing attribute %s in object %s') %\n601                                    (name, self.fullname), type='autodoc')\n602             return False, selected\n603         elif self.options.inherited_members:\n604             return False, [(m.name, m.value) for m in members.values()]\n605         else:\n606             return False, [(m.name, m.value) for m in members.values()\n607                            if m.directly_defined]\n608 \n609     def filter_members(self, members: List[Tuple[str, Any]], want_all: bool\n610                        ) -> List[Tuple[str, Any, bool]]:\n611         \"\"\"Filter the given member list.\n612 \n613         Members are skipped if\n614 \n615         - they are private (except if given explicitly or the private-members\n616           option is set)\n617         - they are special methods (except if given explicitly or the\n618           special-members option is set)\n619         - they are undocumented (except if the undoc-members option is set)\n620 \n621         The user can override the skipping decision by connecting to the\n622         ``autodoc-skip-member`` event.\n623         \"\"\"\n624         def is_filtered_inherited_member(name: str) -> bool:\n625             if inspect.isclass(self.object):\n626                 for cls in self.object.__mro__:\n627                     if cls.__name__ == self.options.inherited_members and cls != self.object:\n628                         # given member is a member of specified *super class*\n629                         return True\n630                     elif name in cls.__dict__:\n631                         return False\n632                     elif name in self.get_attr(cls, '__annotations__', {}):\n633                         return False\n634 \n635             return False\n636 \n637         ret = []\n638 \n639         # search for members in source code too\n640         namespace = '.'.join(self.objpath)  # will be empty for modules\n641 \n642         if self.analyzer:\n643             attr_docs = self.analyzer.find_attr_docs()\n644         else:\n645             attr_docs = {}\n646 \n647         # process members and determine which to skip\n648         for (membername, member) in members:\n649             # if isattr is True, the member is documented as an attribute\n650             if member is INSTANCEATTR:\n651                 isattr = True\n652             else:\n653                 isattr = False\n654 \n655             doc = getdoc(member, self.get_attr, self.env.config.autodoc_inherit_docstrings,\n656                          self.parent, self.object_name)\n657             if not isinstance(doc, str):\n658                 # Ignore non-string __doc__\n659                 doc = None\n660 \n661             # if the member __doc__ is the same as self's __doc__, it's just\n662             # inherited and therefore not the member's doc\n663             cls = self.get_attr(member, '__class__', None)\n664             if cls:\n665                 cls_doc = self.get_attr(cls, '__doc__', None)\n666                 if cls_doc == doc:\n667                     doc = None\n668             has_doc = bool(doc)\n669 \n670             metadata = extract_metadata(doc)\n671             if 'private' in metadata:\n672                 # consider a member private if docstring has \"private\" metadata\n673                 isprivate = True\n674             elif 'public' in metadata:\n675                 # consider a member public if docstring has \"public\" metadata\n676                 isprivate = False\n677             else:\n678                 isprivate = membername.startswith('_')\n679 \n680             keep = False\n681             if safe_getattr(member, '__sphinx_mock__', False):\n682                 # mocked module or object\n683                 pass\n684             elif self.options.exclude_members and membername in self.options.exclude_members:\n685                 # remove members given by exclude-members\n686                 keep = False\n687             elif want_all and special_member_re.match(membername):\n688                 # special __methods__\n689                 if self.options.special_members and membername in self.options.special_members:\n690                     if membername == '__doc__':\n691                         keep = False\n692                     elif is_filtered_inherited_member(membername):\n693                         keep = False\n694                     else:\n695                         keep = has_doc or self.options.undoc_members\n696                 else:\n697                     keep = False\n698             elif (namespace, membername) in attr_docs:\n699                 if want_all and isprivate:\n700                     if self.options.private_members is None:\n701                         keep = False\n702                     else:\n703                         keep = membername in self.options.private_members\n704                 else:\n705                     # keep documented attributes\n706                     keep = True\n707                 isattr = True\n708             elif want_all and isprivate:\n709                 if has_doc or self.options.undoc_members:\n710                     if self.options.private_members is None:\n711                         keep = False\n712                     elif is_filtered_inherited_member(membername):\n713                         keep = False\n714                     else:\n715                         keep = membername in self.options.private_members\n716                 else:\n717                     keep = False\n718             else:\n719                 if self.options.members is ALL and is_filtered_inherited_member(membername):\n720                     keep = False\n721                 else:\n722                     # ignore undocumented members if :undoc-members: is not given\n723                     keep = has_doc or self.options.undoc_members\n724 \n725             # give the user a chance to decide whether this member\n726             # should be skipped\n727             if self.env.app:\n728                 # let extensions preprocess docstrings\n729                 try:\n730                     skip_user = self.env.app.emit_firstresult(\n731                         'autodoc-skip-member', self.objtype, membername, member,\n732                         not keep, self.options)\n733                     if skip_user is not None:\n734                         keep = not skip_user\n735                 except Exception as exc:\n736                     logger.warning(__('autodoc: failed to determine %r to be documented, '\n737                                       'the following exception was raised:\\n%s'),\n738                                    member, exc, type='autodoc')\n739                     keep = False\n740 \n741             if keep:\n742                 ret.append((membername, member, isattr))\n743 \n744         return ret\n745 \n746     def document_members(self, all_members: bool = False) -> None:\n747         \"\"\"Generate reST for member documentation.\n748 \n749         If *all_members* is True, do all members, else those given by\n750         *self.options.members*.\n751         \"\"\"\n752         # set current namespace for finding members\n753         self.env.temp_data['autodoc:module'] = self.modname\n754         if self.objpath:\n755             self.env.temp_data['autodoc:class'] = self.objpath[0]\n756 \n757         want_all = all_members or self.options.inherited_members or \\\n758             self.options.members is ALL\n759         # find out which members are documentable\n760         members_check_module, members = self.get_object_members(want_all)\n761 \n762         # document non-skipped members\n763         memberdocumenters = []  # type: List[Tuple[Documenter, bool]]\n764         for (mname, member, isattr) in self.filter_members(members, want_all):\n765             classes = [cls for cls in self.documenters.values()\n766                        if cls.can_document_member(member, mname, isattr, self)]\n767             if not classes:\n768                 # don't know how to document this member\n769                 continue\n770             # prefer the documenter with the highest priority\n771             classes.sort(key=lambda cls: cls.priority)\n772             # give explicitly separated module name, so that members\n773             # of inner classes can be documented\n774             full_mname = self.modname + '::' + \\\n775                 '.'.join(self.objpath + [mname])\n776             documenter = classes[-1](self.directive, full_mname, self.indent)\n777             memberdocumenters.append((documenter, isattr))\n778 \n779         member_order = self.options.member_order or self.env.config.autodoc_member_order\n780         memberdocumenters = self.sort_members(memberdocumenters, member_order)\n781 \n782         for documenter, isattr in memberdocumenters:\n783             documenter.generate(\n784                 all_members=True, real_modname=self.real_modname,\n785                 check_module=members_check_module and not isattr)\n786 \n787         # reset current objects\n788         self.env.temp_data['autodoc:module'] = None\n789         self.env.temp_data['autodoc:class'] = None\n790 \n791     def sort_members(self, documenters: List[Tuple[\"Documenter\", bool]],\n792                      order: str) -> List[Tuple[\"Documenter\", bool]]:\n793         \"\"\"Sort the given member list.\"\"\"\n794         if order == 'groupwise':\n795             # sort by group; alphabetically within groups\n796             documenters.sort(key=lambda e: (e[0].member_order, e[0].name))\n797         elif order == 'bysource':\n798             if self.analyzer:\n799                 # sort by source order, by virtue of the module analyzer\n800                 tagorder = self.analyzer.tagorder\n801 \n802                 def keyfunc(entry: Tuple[Documenter, bool]) -> int:\n803                     fullname = entry[0].name.split('::')[1]\n804                     return tagorder.get(fullname, len(tagorder))\n805                 documenters.sort(key=keyfunc)\n806             else:\n807                 # Assume that member discovery order matches source order.\n808                 # This is a reasonable assumption in Python 3.6 and up, where\n809                 # module.__dict__ is insertion-ordered.\n810                 pass\n811         else:  # alphabetical\n812             documenters.sort(key=lambda e: e[0].name)\n813 \n814         return documenters\n815 \n816     def generate(self, more_content: Any = None, real_modname: str = None,\n817                  check_module: bool = False, all_members: bool = False) -> None:\n818         \"\"\"Generate reST for the object given by *self.name*, and possibly for\n819         its members.\n820 \n821         If *more_content* is given, include that content. If *real_modname* is\n822         given, use that module name to find attribute docs. If *check_module* is\n823         True, only generate if the object is defined in the module name it is\n824         imported from. If *all_members* is True, document all members.\n825         \"\"\"\n826         if not self.parse_name():\n827             # need a module to import\n828             logger.warning(\n829                 __('don\\'t know which module to import for autodocumenting '\n830                    '%r (try placing a \"module\" or \"currentmodule\" directive '\n831                    'in the document, or giving an explicit module name)') %\n832                 self.name, type='autodoc')\n833             return\n834 \n835         # now, import the module and get object to document\n836         if not self.import_object():\n837             return\n838 \n839         # If there is no real module defined, figure out which to use.\n840         # The real module is used in the module analyzer to look up the module\n841         # where the attribute documentation would actually be found in.\n842         # This is used for situations where you have a module that collects the\n843         # functions and classes of internal submodules.\n844         guess_modname = self.get_real_modname()\n845         self.real_modname = real_modname or guess_modname\n846 \n847         # try to also get a source code analyzer for attribute docs\n848         try:\n849             self.analyzer = ModuleAnalyzer.for_module(self.real_modname)\n850             # parse right now, to get PycodeErrors on parsing (results will\n851             # be cached anyway)\n852             self.analyzer.find_attr_docs()\n853         except PycodeError as exc:\n854             logger.debug('[autodoc] module analyzer failed: %s', exc)\n855             # no source file -- e.g. for builtin and C modules\n856             self.analyzer = None\n857             # at least add the module.__file__ as a dependency\n858             if hasattr(self.module, '__file__') and self.module.__file__:\n859                 self.directive.filename_set.add(self.module.__file__)\n860         else:\n861             self.directive.filename_set.add(self.analyzer.srcname)\n862 \n863         if self.real_modname != guess_modname:\n864             # Add module to dependency list if target object is defined in other module.\n865             try:\n866                 analyzer = ModuleAnalyzer.for_module(guess_modname)\n867                 self.directive.filename_set.add(analyzer.srcname)\n868             except PycodeError:\n869                 pass\n870 \n871         # check __module__ of object (for members not given explicitly)\n872         if check_module:\n873             if not self.check_module():\n874                 return\n875 \n876         sourcename = self.get_sourcename()\n877 \n878         # make sure that the result starts with an empty line.  This is\n879         # necessary for some situations where another directive preprocesses\n880         # reST and no starting newline is present\n881         self.add_line('', sourcename)\n882 \n883         # format the object's signature, if any\n884         try:\n885             sig = self.format_signature()\n886         except Exception as exc:\n887             logger.warning(__('error while formatting signature for %s: %s'),\n888                            self.fullname, exc, type='autodoc')\n889             return\n890 \n891         # generate the directive header and options, if applicable\n892         self.add_directive_header(sig)\n893         self.add_line('', sourcename)\n894 \n895         # e.g. the module directive doesn't have content\n896         self.indent += self.content_indent\n897 \n898         # add all content (from docstrings, attribute docs etc.)\n899         self.add_content(more_content)\n900 \n901         # document members, if possible\n902         self.document_members(all_members)\n903 \n904 \n905 class ModuleDocumenter(Documenter):\n906     \"\"\"\n907     Specialized Documenter subclass for modules.\n908     \"\"\"\n909     objtype = 'module'\n910     content_indent = ''\n911     titles_allowed = True\n912 \n913     option_spec = {\n914         'members': members_option, 'undoc-members': bool_option,\n915         'noindex': bool_option, 'inherited-members': inherited_members_option,\n916         'show-inheritance': bool_option, 'synopsis': identity,\n917         'platform': identity, 'deprecated': bool_option,\n918         'member-order': member_order_option, 'exclude-members': exclude_members_option,\n919         'private-members': members_option, 'special-members': members_option,\n920         'imported-members': bool_option, 'ignore-module-all': bool_option\n921     }  # type: Dict[str, Callable]\n922 \n923     def __init__(self, *args: Any) -> None:\n924         super().__init__(*args)\n925         merge_members_option(self.options)\n926         self.__all__ = None\n927 \n928     @classmethod\n929     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any\n930                             ) -> bool:\n931         # don't document submodules automatically\n932         return False\n933 \n934     def resolve_name(self, modname: str, parents: Any, path: str, base: Any\n935                      ) -> Tuple[str, List[str]]:\n936         if modname is not None:\n937             logger.warning(__('\"::\" in automodule name doesn\\'t make sense'),\n938                            type='autodoc')\n939         return (path or '') + base, []\n940 \n941     def parse_name(self) -> bool:\n942         ret = super().parse_name()\n943         if self.args or self.retann:\n944             logger.warning(__('signature arguments or return annotation '\n945                               'given for automodule %s') % self.fullname,\n946                            type='autodoc')\n947         return ret\n948 \n949     def import_object(self, raiseerror: bool = False) -> bool:\n950         def is_valid_module_all(__all__: Any) -> bool:\n951             \"\"\"Check the given *__all__* is valid for a module.\"\"\"\n952             if (isinstance(__all__, (list, tuple)) and\n953                     all(isinstance(e, str) for e in __all__)):\n954                 return True\n955             else:\n956                 return False\n957 \n958         ret = super().import_object(raiseerror)\n959 \n960         if not self.options.ignore_module_all:\n961             __all__ = getattr(self.object, '__all__', None)\n962             if is_valid_module_all(__all__):\n963                 # valid __all__ found. copy it to self.__all__\n964                 self.__all__ = __all__\n965             elif __all__:\n966                 # invalid __all__ found.\n967                 logger.warning(__('__all__ should be a list of strings, not %r '\n968                                   '(in module %s) -- ignoring __all__') %\n969                                (__all__, self.fullname), type='autodoc')\n970 \n971         return ret\n972 \n973     def add_directive_header(self, sig: str) -> None:\n974         Documenter.add_directive_header(self, sig)\n975 \n976         sourcename = self.get_sourcename()\n977 \n978         # add some module-specific options\n979         if self.options.synopsis:\n980             self.add_line('   :synopsis: ' + self.options.synopsis, sourcename)\n981         if self.options.platform:\n982             self.add_line('   :platform: ' + self.options.platform, sourcename)\n983         if self.options.deprecated:\n984             self.add_line('   :deprecated:', sourcename)\n985 \n986     def get_object_members(self, want_all: bool) -> Tuple[bool, List[Tuple[str, Any]]]:\n987         if want_all:\n988             if self.__all__:\n989                 memberlist = self.__all__\n990             else:\n991                 # for implicit module members, check __module__ to avoid\n992                 # documenting imported objects\n993                 return True, get_module_members(self.object)\n994         else:\n995             memberlist = self.options.members or []\n996         ret = []\n997         for mname in memberlist:\n998             try:\n999                 ret.append((mname, safe_getattr(self.object, mname)))\n1000             except AttributeError:\n1001                 logger.warning(\n1002                     __('missing attribute mentioned in :members: or __all__: '\n1003                        'module %s, attribute %s') %\n1004                     (safe_getattr(self.object, '__name__', '???'), mname),\n1005                     type='autodoc'\n1006                 )\n1007         return False, ret\n1008 \n1009     def sort_members(self, documenters: List[Tuple[\"Documenter\", bool]],\n1010                      order: str) -> List[Tuple[\"Documenter\", bool]]:\n1011         if order == 'bysource' and self.__all__:\n1012             # Sort alphabetically first (for members not listed on the __all__)\n1013             documenters.sort(key=lambda e: e[0].name)\n1014 \n1015             # Sort by __all__\n1016             def keyfunc(entry: Tuple[Documenter, bool]) -> int:\n1017                 name = entry[0].name.split('::')[1]\n1018                 if name in self.__all__:\n1019                     return self.__all__.index(name)\n1020                 else:\n1021                     return len(self.__all__)\n1022             documenters.sort(key=keyfunc)\n1023 \n1024             return documenters\n1025         else:\n1026             return super().sort_members(documenters, order)\n1027 \n1028 \n1029 class ModuleLevelDocumenter(Documenter):\n1030     \"\"\"\n1031     Specialized Documenter subclass for objects on module level (functions,\n1032     classes, data/constants).\n1033     \"\"\"\n1034     def resolve_name(self, modname: str, parents: Any, path: str, base: Any\n1035                      ) -> Tuple[str, List[str]]:\n1036         if modname is None:\n1037             if path:\n1038                 modname = path.rstrip('.')\n1039             else:\n1040                 # if documenting a toplevel object without explicit module,\n1041                 # it can be contained in another auto directive ...\n1042                 modname = self.env.temp_data.get('autodoc:module')\n1043                 # ... or in the scope of a module directive\n1044                 if not modname:\n1045                     modname = self.env.ref_context.get('py:module')\n1046                 # ... else, it stays None, which means invalid\n1047         return modname, parents + [base]\n1048 \n1049 \n1050 class ClassLevelDocumenter(Documenter):\n1051     \"\"\"\n1052     Specialized Documenter subclass for objects on class level (methods,\n1053     attributes).\n1054     \"\"\"\n1055     def resolve_name(self, modname: str, parents: Any, path: str, base: Any\n1056                      ) -> Tuple[str, List[str]]:\n1057         if modname is None:\n1058             if path:\n1059                 mod_cls = path.rstrip('.')\n1060             else:\n1061                 mod_cls = None\n1062                 # if documenting a class-level object without path,\n1063                 # there must be a current class, either from a parent\n1064                 # auto directive ...\n1065                 mod_cls = self.env.temp_data.get('autodoc:class')\n1066                 # ... or from a class directive\n1067                 if mod_cls is None:\n1068                     mod_cls = self.env.ref_context.get('py:class')\n1069                 # ... if still None, there's no way to know\n1070                 if mod_cls is None:\n1071                     return None, []\n1072             modname, sep, cls = mod_cls.rpartition('.')\n1073             parents = [cls]\n1074             # if the module name is still missing, get it like above\n1075             if not modname:\n1076                 modname = self.env.temp_data.get('autodoc:module')\n1077             if not modname:\n1078                 modname = self.env.ref_context.get('py:module')\n1079             # ... else, it stays None, which means invalid\n1080         return modname, parents + [base]\n1081 \n1082 \n1083 class DocstringSignatureMixin:\n1084     \"\"\"\n1085     Mixin for FunctionDocumenter and MethodDocumenter to provide the\n1086     feature of reading the signature from the docstring.\n1087     \"\"\"\n1088     _new_docstrings = None  # type: List[List[str]]\n1089     _signatures = None      # type: List[str]\n1090 \n1091     def _find_signature(self, encoding: str = None) -> Tuple[str, str]:\n1092         if encoding is not None:\n1093             warnings.warn(\"The 'encoding' argument to autodoc.%s._find_signature() is \"\n1094                           \"deprecated.\" % self.__class__.__name__,\n1095                           RemovedInSphinx40Warning, stacklevel=2)\n1096 \n1097         # candidates of the object name\n1098         valid_names = [self.objpath[-1]]  # type: ignore\n1099         if isinstance(self, ClassDocumenter):\n1100             valid_names.append('__init__')\n1101             if hasattr(self.object, '__mro__'):\n1102                 valid_names.extend(cls.__name__ for cls in self.object.__mro__)\n1103 \n1104         docstrings = self.get_doc()\n1105         self._new_docstrings = docstrings[:]\n1106         self._signatures = []\n1107         result = None\n1108         for i, doclines in enumerate(docstrings):\n1109             for j, line in enumerate(doclines):\n1110                 if not line:\n1111                     # no lines in docstring, no match\n1112                     break\n1113 \n1114                 if line.endswith('\\\\'):\n1115                     multiline = True\n1116                     line = line.rstrip('\\\\').rstrip()\n1117                 else:\n1118                     multiline = False\n1119 \n1120                 # match first line of docstring against signature RE\n1121                 match = py_ext_sig_re.match(line)\n1122                 if not match:\n1123                     continue\n1124                 exmod, path, base, args, retann = match.groups()\n1125 \n1126                 # the base name must match ours\n1127                 if base not in valid_names:\n1128                     continue\n1129 \n1130                 # re-prepare docstring to ignore more leading indentation\n1131                 tab_width = self.directive.state.document.settings.tab_width  # type: ignore\n1132                 self._new_docstrings[i] = prepare_docstring('\\n'.join(doclines[j + 1:]),\n1133                                                             tabsize=tab_width)\n1134 \n1135                 if result is None:\n1136                     # first signature\n1137                     result = args, retann\n1138                 else:\n1139                     # subsequent signatures\n1140                     self._signatures.append(\"(%s) -> %s\" % (args, retann))\n1141 \n1142                 if multiline:\n1143                     # the signature have multiple signatures on docstring\n1144                     continue\n1145                 else:\n1146                     # don't look any further\n1147                     break\n1148 \n1149             if result:\n1150                 # finish the loop when signature found\n1151                 break\n1152 \n1153         return result\n1154 \n1155     def get_doc(self, encoding: str = None, ignore: int = None) -> List[List[str]]:\n1156         if encoding is not None:\n1157             warnings.warn(\"The 'encoding' argument to autodoc.%s.get_doc() is deprecated.\"\n1158                           % self.__class__.__name__,\n1159                           RemovedInSphinx40Warning, stacklevel=2)\n1160         if self._new_docstrings is not None:\n1161             return self._new_docstrings\n1162         return super().get_doc(None, ignore)  # type: ignore\n1163 \n1164     def format_signature(self, **kwargs: Any) -> str:\n1165         if self.args is None and self.env.config.autodoc_docstring_signature:  # type: ignore\n1166             # only act if a signature is not explicitly given already, and if\n1167             # the feature is enabled\n1168             result = self._find_signature()\n1169             if result is not None:\n1170                 self.args, self.retann = result\n1171         sig = super().format_signature(**kwargs)  # type: ignore\n1172         if self._signatures:\n1173             return \"\\n\".join([sig] + self._signatures)\n1174         else:\n1175             return sig\n1176 \n1177 \n1178 class DocstringStripSignatureMixin(DocstringSignatureMixin):\n1179     \"\"\"\n1180     Mixin for AttributeDocumenter to provide the\n1181     feature of stripping any function signature from the docstring.\n1182     \"\"\"\n1183     def format_signature(self, **kwargs: Any) -> str:\n1184         if self.args is None and self.env.config.autodoc_docstring_signature:  # type: ignore\n1185             # only act if a signature is not explicitly given already, and if\n1186             # the feature is enabled\n1187             result = self._find_signature()\n1188             if result is not None:\n1189                 # Discarding _args is a only difference with\n1190                 # DocstringSignatureMixin.format_signature.\n1191                 # Documenter.format_signature use self.args value to format.\n1192                 _args, self.retann = result\n1193         return super().format_signature(**kwargs)\n1194 \n1195 \n1196 class FunctionDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # type: ignore\n1197     \"\"\"\n1198     Specialized Documenter subclass for functions.\n1199     \"\"\"\n1200     objtype = 'function'\n1201     member_order = 30\n1202 \n1203     @classmethod\n1204     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any\n1205                             ) -> bool:\n1206         # supports functions, builtins and bound methods exported at the module level\n1207         return (inspect.isfunction(member) or inspect.isbuiltin(member) or\n1208                 (inspect.isroutine(member) and isinstance(parent, ModuleDocumenter)))\n1209 \n1210     def format_args(self, **kwargs: Any) -> str:\n1211         if self.env.config.autodoc_typehints in ('none', 'description'):\n1212             kwargs.setdefault('show_annotation', False)\n1213 \n1214         try:\n1215             self.env.app.emit('autodoc-before-process-signature', self.object, False)\n1216             sig = inspect.signature(self.object, follow_wrapped=True,\n1217                                     type_aliases=self.env.config.autodoc_type_aliases)\n1218             args = stringify_signature(sig, **kwargs)\n1219         except TypeError as exc:\n1220             logger.warning(__(\"Failed to get a function signature for %s: %s\"),\n1221                            self.fullname, exc)\n1222             return None\n1223         except ValueError:\n1224             args = ''\n1225 \n1226         if self.env.config.strip_signature_backslash:\n1227             # escape backslashes for reST\n1228             args = args.replace('\\\\', '\\\\\\\\')\n1229         return args\n1230 \n1231     def document_members(self, all_members: bool = False) -> None:\n1232         pass\n1233 \n1234     def add_directive_header(self, sig: str) -> None:\n1235         sourcename = self.get_sourcename()\n1236         super().add_directive_header(sig)\n1237 \n1238         if inspect.iscoroutinefunction(self.object):\n1239             self.add_line('   :async:', sourcename)\n1240 \n1241     def format_signature(self, **kwargs: Any) -> str:\n1242         sigs = []\n1243         if self.analyzer and '.'.join(self.objpath) in self.analyzer.overloads:\n1244             # Use signatures for overloaded functions instead of the implementation function.\n1245             overloaded = True\n1246         else:\n1247             overloaded = False\n1248             sig = super().format_signature(**kwargs)\n1249             sigs.append(sig)\n1250 \n1251         if inspect.is_singledispatch_function(self.object):\n1252             # append signature of singledispatch'ed functions\n1253             for typ, func in self.object.registry.items():\n1254                 if typ is object:\n1255                     pass  # default implementation. skipped.\n1256                 else:\n1257                     self.annotate_to_first_argument(func, typ)\n1258 \n1259                     documenter = FunctionDocumenter(self.directive, '')\n1260                     documenter.object = func\n1261                     documenter.objpath = [None]\n1262                     sigs.append(documenter.format_signature())\n1263         if overloaded:\n1264             __globals__ = safe_getattr(self.object, '__globals__', {})\n1265             for overload in self.analyzer.overloads.get('.'.join(self.objpath)):\n1266                 overload = evaluate_signature(overload, __globals__,\n1267                                               self.env.config.autodoc_type_aliases)\n1268 \n1269                 sig = stringify_signature(overload, **kwargs)\n1270                 sigs.append(sig)\n1271 \n1272         return \"\\n\".join(sigs)\n1273 \n1274     def annotate_to_first_argument(self, func: Callable, typ: Type) -> None:\n1275         \"\"\"Annotate type hint to the first argument of function if needed.\"\"\"\n1276         try:\n1277             sig = inspect.signature(func, type_aliases=self.env.config.autodoc_type_aliases)\n1278         except TypeError as exc:\n1279             logger.warning(__(\"Failed to get a function signature for %s: %s\"),\n1280                            self.fullname, exc)\n1281             return\n1282         except ValueError:\n1283             return\n1284 \n1285         if len(sig.parameters) == 0:\n1286             return\n1287 \n1288         params = list(sig.parameters.values())\n1289         if params[0].annotation is Parameter.empty:\n1290             params[0] = params[0].replace(annotation=typ)\n1291             try:\n1292                 func.__signature__ = sig.replace(parameters=params)  # type: ignore\n1293             except TypeError:\n1294                 # failed to update signature (ex. built-in or extension types)\n1295                 return\n1296 \n1297 \n1298 class SingledispatchFunctionDocumenter(FunctionDocumenter):\n1299     \"\"\"\n1300     Used to be a specialized Documenter subclass for singledispatch'ed functions.\n1301 \n1302     Retained for backwards compatibility, now does the same as the FunctionDocumenter\n1303     \"\"\"\n1304 \n1305     def __init__(self, *args: Any, **kwargs: Any) -> None:\n1306         warnings.warn(\"%s is deprecated.\" % self.__class__.__name__,\n1307                       RemovedInSphinx50Warning, stacklevel=2)\n1308         super().__init__(*args, **kwargs)\n1309 \n1310 \n1311 class DecoratorDocumenter(FunctionDocumenter):\n1312     \"\"\"\n1313     Specialized Documenter subclass for decorator functions.\n1314     \"\"\"\n1315     objtype = 'decorator'\n1316 \n1317     # must be lower than FunctionDocumenter\n1318     priority = -1\n1319 \n1320     def format_args(self, **kwargs: Any) -> Any:\n1321         args = super().format_args(**kwargs)\n1322         if ',' in args:\n1323             return args\n1324         else:\n1325             return None\n1326 \n1327 \n1328 # Types which have confusing metaclass signatures it would be best not to show.\n1329 # These are listed by name, rather than storing the objects themselves, to avoid\n1330 # needing to import the modules.\n1331 _METACLASS_CALL_BLACKLIST = [\n1332     'enum.EnumMeta.__call__',\n1333 ]\n1334 \n1335 \n1336 # Types whose __new__ signature is a pass-thru.\n1337 _CLASS_NEW_BLACKLIST = [\n1338     'typing.Generic.__new__',\n1339 ]\n1340 \n1341 \n1342 class ClassDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # type: ignore\n1343     \"\"\"\n1344     Specialized Documenter subclass for classes.\n1345     \"\"\"\n1346     objtype = 'class'\n1347     member_order = 20\n1348     option_spec = {\n1349         'members': members_option, 'undoc-members': bool_option,\n1350         'noindex': bool_option, 'inherited-members': inherited_members_option,\n1351         'show-inheritance': bool_option, 'member-order': member_order_option,\n1352         'exclude-members': exclude_members_option,\n1353         'private-members': members_option, 'special-members': members_option,\n1354     }  # type: Dict[str, Callable]\n1355 \n1356     _signature_class = None  # type: Any\n1357     _signature_method_name = None  # type: str\n1358 \n1359     def __init__(self, *args: Any) -> None:\n1360         super().__init__(*args)\n1361         merge_members_option(self.options)\n1362 \n1363     @classmethod\n1364     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any\n1365                             ) -> bool:\n1366         return isinstance(member, type)\n1367 \n1368     def import_object(self, raiseerror: bool = False) -> bool:\n1369         ret = super().import_object(raiseerror)\n1370         # if the class is documented under another name, document it\n1371         # as data/attribute\n1372         if ret:\n1373             if hasattr(self.object, '__name__'):\n1374                 self.doc_as_attr = (self.objpath[-1] != self.object.__name__)\n1375             else:\n1376                 self.doc_as_attr = True\n1377         return ret\n1378 \n1379     def _get_signature(self) -> Tuple[Optional[Any], Optional[str], Optional[Signature]]:\n1380         def get_user_defined_function_or_method(obj: Any, attr: str) -> Any:\n1381             \"\"\" Get the `attr` function or method from `obj`, if it is user-defined. \"\"\"\n1382             if inspect.is_builtin_class_method(obj, attr):\n1383                 return None\n1384             attr = self.get_attr(obj, attr, None)\n1385             if not (inspect.ismethod(attr) or inspect.isfunction(attr)):\n1386                 return None\n1387             return attr\n1388 \n1389         # This sequence is copied from inspect._signature_from_callable.\n1390         # ValueError means that no signature could be found, so we keep going.\n1391 \n1392         # First, let's see if it has an overloaded __call__ defined\n1393         # in its metaclass\n1394         call = get_user_defined_function_or_method(type(self.object), '__call__')\n1395 \n1396         if call is not None:\n1397             if \"{0.__module__}.{0.__qualname__}\".format(call) in _METACLASS_CALL_BLACKLIST:\n1398                 call = None\n1399 \n1400         if call is not None:\n1401             self.env.app.emit('autodoc-before-process-signature', call, True)\n1402             try:\n1403                 sig = inspect.signature(call, bound_method=True,\n1404                                         type_aliases=self.env.config.autodoc_type_aliases)\n1405                 return type(self.object), '__call__', sig\n1406             except ValueError:\n1407                 pass\n1408 \n1409         # Now we check if the 'obj' class has a '__new__' method\n1410         new = get_user_defined_function_or_method(self.object, '__new__')\n1411 \n1412         if new is not None:\n1413             if \"{0.__module__}.{0.__qualname__}\".format(new) in _CLASS_NEW_BLACKLIST:\n1414                 new = None\n1415 \n1416         if new is not None:\n1417             self.env.app.emit('autodoc-before-process-signature', new, True)\n1418             try:\n1419                 sig = inspect.signature(new, bound_method=True,\n1420                                         type_aliases=self.env.config.autodoc_type_aliases)\n1421                 return self.object, '__new__', sig\n1422             except ValueError:\n1423                 pass\n1424 \n1425         # Finally, we should have at least __init__ implemented\n1426         init = get_user_defined_function_or_method(self.object, '__init__')\n1427         if init is not None:\n1428             self.env.app.emit('autodoc-before-process-signature', init, True)\n1429             try:\n1430                 sig = inspect.signature(init, bound_method=True,\n1431                                         type_aliases=self.env.config.autodoc_type_aliases)\n1432                 return self.object, '__init__', sig\n1433             except ValueError:\n1434                 pass\n1435 \n1436         # None of the attributes are user-defined, so fall back to let inspect\n1437         # handle it.\n1438         # We don't know the exact method that inspect.signature will read\n1439         # the signature from, so just pass the object itself to our hook.\n1440         self.env.app.emit('autodoc-before-process-signature', self.object, False)\n1441         try:\n1442             sig = inspect.signature(self.object, bound_method=False,\n1443                                     type_aliases=self.env.config.autodoc_type_aliases)\n1444             return None, None, sig\n1445         except ValueError:\n1446             pass\n1447 \n1448         # Still no signature: happens e.g. for old-style classes\n1449         # with __init__ in C and no `__text_signature__`.\n1450         return None, None, None\n1451 \n1452     def format_args(self, **kwargs: Any) -> str:\n1453         if self.env.config.autodoc_typehints in ('none', 'description'):\n1454             kwargs.setdefault('show_annotation', False)\n1455 \n1456         try:\n1457             self._signature_class, self._signature_method_name, sig = self._get_signature()\n1458         except TypeError as exc:\n1459             # __signature__ attribute contained junk\n1460             logger.warning(__(\"Failed to get a constructor signature for %s: %s\"),\n1461                            self.fullname, exc)\n1462             return None\n1463 \n1464         if sig is None:\n1465             return None\n1466 \n1467         return stringify_signature(sig, show_return_annotation=False, **kwargs)\n1468 \n1469     def format_signature(self, **kwargs: Any) -> str:\n1470         if self.doc_as_attr:\n1471             return ''\n1472 \n1473         sig = super().format_signature()\n1474 \n1475         overloaded = False\n1476         qualname = None\n1477         # TODO: recreate analyzer for the module of class (To be clear, owner of the method)\n1478         if self._signature_class and self._signature_method_name and self.analyzer:\n1479             qualname = '.'.join([self._signature_class.__qualname__,\n1480                                  self._signature_method_name])\n1481             if qualname in self.analyzer.overloads:\n1482                 overloaded = True\n1483 \n1484         sigs = []\n1485         if overloaded:\n1486             # Use signatures for overloaded methods instead of the implementation method.\n1487             method = safe_getattr(self._signature_class, self._signature_method_name, None)\n1488             __globals__ = safe_getattr(method, '__globals__', {})\n1489             for overload in self.analyzer.overloads.get(qualname):\n1490                 overload = evaluate_signature(overload, __globals__,\n1491                                               self.env.config.autodoc_type_aliases)\n1492 \n1493                 parameters = list(overload.parameters.values())\n1494                 overload = overload.replace(parameters=parameters[1:],\n1495                                             return_annotation=Parameter.empty)\n1496                 sig = stringify_signature(overload, **kwargs)\n1497                 sigs.append(sig)\n1498         else:\n1499             sigs.append(sig)\n1500 \n1501         return \"\\n\".join(sigs)\n1502 \n1503     def add_directive_header(self, sig: str) -> None:\n1504         sourcename = self.get_sourcename()\n1505 \n1506         if self.doc_as_attr:\n1507             self.directivetype = 'attribute'\n1508         super().add_directive_header(sig)\n1509 \n1510         if self.analyzer and '.'.join(self.objpath) in self.analyzer.finals:\n1511             self.add_line('   :final:', sourcename)\n1512 \n1513         # add inheritance info, if wanted\n1514         if not self.doc_as_attr and self.options.show_inheritance:\n1515             sourcename = self.get_sourcename()\n1516             self.add_line('', sourcename)\n1517             if hasattr(self.object, '__bases__') and len(self.object.__bases__):\n1518                 bases = [':class:`%s`' % b.__name__\n1519                          if b.__module__ in ('__builtin__', 'builtins')\n1520                          else ':class:`%s.%s`' % (b.__module__, b.__qualname__)\n1521                          for b in self.object.__bases__]\n1522                 self.add_line('   ' + _('Bases: %s') % ', '.join(bases),\n1523                               sourcename)\n1524 \n1525     def get_doc(self, encoding: str = None, ignore: int = None) -> List[List[str]]:\n1526         if encoding is not None:\n1527             warnings.warn(\"The 'encoding' argument to autodoc.%s.get_doc() is deprecated.\"\n1528                           % self.__class__.__name__,\n1529                           RemovedInSphinx40Warning, stacklevel=2)\n1530         lines = getattr(self, '_new_docstrings', None)\n1531         if lines is not None:\n1532             return lines\n1533 \n1534         content = self.env.config.autoclass_content\n1535 \n1536         docstrings = []\n1537         attrdocstring = self.get_attr(self.object, '__doc__', None)\n1538         if attrdocstring:\n1539             docstrings.append(attrdocstring)\n1540 \n1541         # for classes, what the \"docstring\" is can be controlled via a\n1542         # config value; the default is only the class docstring\n1543         if content in ('both', 'init'):\n1544             __init__ = self.get_attr(self.object, '__init__', None)\n1545             initdocstring = getdoc(__init__, self.get_attr,\n1546                                    self.env.config.autodoc_inherit_docstrings,\n1547                                    self.parent, self.object_name)\n1548             # for new-style classes, no __init__ means default __init__\n1549             if (initdocstring is not None and\n1550                 (initdocstring == object.__init__.__doc__ or  # for pypy\n1551                  initdocstring.strip() == object.__init__.__doc__)):  # for !pypy\n1552                 initdocstring = None\n1553             if not initdocstring:\n1554                 # try __new__\n1555                 __new__ = self.get_attr(self.object, '__new__', None)\n1556                 initdocstring = getdoc(__new__, self.get_attr,\n1557                                        self.env.config.autodoc_inherit_docstrings,\n1558                                        self.parent, self.object_name)\n1559                 # for new-style classes, no __new__ means default __new__\n1560                 if (initdocstring is not None and\n1561                     (initdocstring == object.__new__.__doc__ or  # for pypy\n1562                      initdocstring.strip() == object.__new__.__doc__)):  # for !pypy\n1563                     initdocstring = None\n1564             if initdocstring:\n1565                 if content == 'init':\n1566                     docstrings = [initdocstring]\n1567                 else:\n1568                     docstrings.append(initdocstring)\n1569 \n1570         tab_width = self.directive.state.document.settings.tab_width\n1571         return [prepare_docstring(docstring, ignore, tab_width) for docstring in docstrings]\n1572 \n1573     def add_content(self, more_content: Any, no_docstring: bool = False) -> None:\n1574         if self.doc_as_attr:\n1575             classname = safe_getattr(self.object, '__qualname__', None)\n1576             if not classname:\n1577                 classname = safe_getattr(self.object, '__name__', None)\n1578             if classname:\n1579                 module = safe_getattr(self.object, '__module__', None)\n1580                 parentmodule = safe_getattr(self.parent, '__module__', None)\n1581                 if module and module != parentmodule:\n1582                     classname = str(module) + '.' + str(classname)\n1583                 content = StringList([_('alias of :class:`%s`') % classname], source='')\n1584                 super().add_content(content, no_docstring=True)\n1585         else:\n1586             super().add_content(more_content)\n1587 \n1588     def document_members(self, all_members: bool = False) -> None:\n1589         if self.doc_as_attr:\n1590             return\n1591         super().document_members(all_members)\n1592 \n1593     def generate(self, more_content: Any = None, real_modname: str = None,\n1594                  check_module: bool = False, all_members: bool = False) -> None:\n1595         # Do not pass real_modname and use the name from the __module__\n1596         # attribute of the class.\n1597         # If a class gets imported into the module real_modname\n1598         # the analyzer won't find the source of the class, if\n1599         # it looks in real_modname.\n1600         return super().generate(more_content=more_content,\n1601                                 check_module=check_module,\n1602                                 all_members=all_members)\n1603 \n1604 \n1605 class ExceptionDocumenter(ClassDocumenter):\n1606     \"\"\"\n1607     Specialized ClassDocumenter subclass for exceptions.\n1608     \"\"\"\n1609     objtype = 'exception'\n1610     member_order = 10\n1611 \n1612     # needs a higher priority than ClassDocumenter\n1613     priority = 10\n1614 \n1615     @classmethod\n1616     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any\n1617                             ) -> bool:\n1618         return isinstance(member, type) and issubclass(member, BaseException)\n1619 \n1620 \n1621 class DataDocumenter(ModuleLevelDocumenter):\n1622     \"\"\"\n1623     Specialized Documenter subclass for data items.\n1624     \"\"\"\n1625     objtype = 'data'\n1626     member_order = 40\n1627     priority = -10\n1628     option_spec = dict(ModuleLevelDocumenter.option_spec)\n1629     option_spec[\"annotation\"] = annotation_option\n1630 \n1631     @classmethod\n1632     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any\n1633                             ) -> bool:\n1634         return isinstance(parent, ModuleDocumenter) and isattr\n1635 \n1636     def add_directive_header(self, sig: str) -> None:\n1637         super().add_directive_header(sig)\n1638         sourcename = self.get_sourcename()\n1639         if not self.options.annotation:\n1640             # obtain annotation for this data\n1641             try:\n1642                 annotations = get_type_hints(self.parent)\n1643             except NameError:\n1644                 # Failed to evaluate ForwardRef (maybe TYPE_CHECKING)\n1645                 annotations = safe_getattr(self.parent, '__annotations__', {})\n1646             except TypeError:\n1647                 annotations = {}\n1648             except KeyError:\n1649                 # a broken class found (refs: https://github.com/sphinx-doc/sphinx/issues/8084)\n1650                 annotations = {}\n1651             except AttributeError:\n1652                 # AttributeError is raised on 3.5.2 (fixed by 3.5.3)\n1653                 annotations = {}\n1654 \n1655             if self.objpath[-1] in annotations:\n1656                 objrepr = stringify_typehint(annotations.get(self.objpath[-1]))\n1657                 self.add_line('   :type: ' + objrepr, sourcename)\n1658             else:\n1659                 key = ('.'.join(self.objpath[:-1]), self.objpath[-1])\n1660                 if self.analyzer and key in self.analyzer.annotations:\n1661                     self.add_line('   :type: ' + self.analyzer.annotations[key],\n1662                                   sourcename)\n1663 \n1664             try:\n1665                 if self.object is UNINITIALIZED_ATTR:\n1666                     pass\n1667                 else:\n1668                     objrepr = object_description(self.object)\n1669                     self.add_line('   :value: ' + objrepr, sourcename)\n1670             except ValueError:\n1671                 pass\n1672         elif self.options.annotation is SUPPRESS:\n1673             pass\n1674         else:\n1675             self.add_line('   :annotation: %s' % self.options.annotation,\n1676                           sourcename)\n1677 \n1678     def document_members(self, all_members: bool = False) -> None:\n1679         pass\n1680 \n1681     def get_real_modname(self) -> str:\n1682         return self.get_attr(self.parent or self.object, '__module__', None) \\\n1683             or self.modname\n1684 \n1685 \n1686 class DataDeclarationDocumenter(DataDocumenter):\n1687     \"\"\"\n1688     Specialized Documenter subclass for data that cannot be imported\n1689     because they are declared without initial value (refs: PEP-526).\n1690     \"\"\"\n1691     objtype = 'datadecl'\n1692     directivetype = 'data'\n1693     member_order = 60\n1694 \n1695     # must be higher than AttributeDocumenter\n1696     priority = 11\n1697 \n1698     @classmethod\n1699     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any\n1700                             ) -> bool:\n1701         \"\"\"This documents only INSTANCEATTR members.\"\"\"\n1702         return (isinstance(parent, ModuleDocumenter) and\n1703                 isattr and\n1704                 member is INSTANCEATTR)\n1705 \n1706     def import_object(self, raiseerror: bool = False) -> bool:\n1707         \"\"\"Never import anything.\"\"\"\n1708         # disguise as a data\n1709         self.objtype = 'data'\n1710         self.object = UNINITIALIZED_ATTR\n1711         try:\n1712             # import module to obtain type annotation\n1713             self.parent = importlib.import_module(self.modname)\n1714         except ImportError:\n1715             pass\n1716 \n1717         return True\n1718 \n1719     def add_content(self, more_content: Any, no_docstring: bool = False) -> None:\n1720         \"\"\"Never try to get a docstring from the object.\"\"\"\n1721         super().add_content(more_content, no_docstring=True)\n1722 \n1723 \n1724 class GenericAliasDocumenter(DataDocumenter):\n1725     \"\"\"\n1726     Specialized Documenter subclass for GenericAliases.\n1727     \"\"\"\n1728 \n1729     objtype = 'genericalias'\n1730     directivetype = 'data'\n1731     priority = DataDocumenter.priority + 1\n1732 \n1733     @classmethod\n1734     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any\n1735                             ) -> bool:\n1736         return inspect.isgenericalias(member)\n1737 \n1738     def add_directive_header(self, sig: str) -> None:\n1739         self.options = Options(self.options)\n1740         self.options['annotation'] = SUPPRESS\n1741         super().add_directive_header(sig)\n1742 \n1743     def add_content(self, more_content: Any, no_docstring: bool = False) -> None:\n1744         name = stringify_typehint(self.object)\n1745         content = StringList([_('alias of %s') % name], source='')\n1746         super().add_content(content)\n1747 \n1748 \n1749 class TypeVarDocumenter(DataDocumenter):\n1750     \"\"\"\n1751     Specialized Documenter subclass for TypeVars.\n1752     \"\"\"\n1753 \n1754     objtype = 'typevar'\n1755     directivetype = 'data'\n1756     priority = DataDocumenter.priority + 1\n1757 \n1758     @classmethod\n1759     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any\n1760                             ) -> bool:\n1761         return isinstance(member, TypeVar) and isattr  # type: ignore\n1762 \n1763     def add_directive_header(self, sig: str) -> None:\n1764         self.options = Options(self.options)\n1765         self.options['annotation'] = SUPPRESS\n1766         super().add_directive_header(sig)\n1767 \n1768     def get_doc(self, encoding: str = None, ignore: int = None) -> List[List[str]]:\n1769         if ignore is not None:\n1770             warnings.warn(\"The 'ignore' argument to autodoc.%s.get_doc() is deprecated.\"\n1771                           % self.__class__.__name__,\n1772                           RemovedInSphinx50Warning, stacklevel=2)\n1773 \n1774         if self.object.__doc__ != TypeVar.__doc__:\n1775             return super().get_doc()\n1776         else:\n1777             return []\n1778 \n1779     def add_content(self, more_content: Any, no_docstring: bool = False) -> None:\n1780         attrs = [repr(self.object.__name__)]\n1781         for constraint in self.object.__constraints__:\n1782             attrs.append(stringify_typehint(constraint))\n1783         if self.object.__covariant__:\n1784             attrs.append(\"covariant=True\")\n1785         if self.object.__contravariant__:\n1786             attrs.append(\"contravariant=True\")\n1787 \n1788         content = StringList([_('alias of TypeVar(%s)') % \", \".join(attrs)], source='')\n1789         super().add_content(content)\n1790 \n1791 \n1792 class MethodDocumenter(DocstringSignatureMixin, ClassLevelDocumenter):  # type: ignore\n1793     \"\"\"\n1794     Specialized Documenter subclass for methods (normal, static and class).\n1795     \"\"\"\n1796     objtype = 'method'\n1797     directivetype = 'method'\n1798     member_order = 50\n1799     priority = 1  # must be more than FunctionDocumenter\n1800 \n1801     @classmethod\n1802     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any\n1803                             ) -> bool:\n1804         return inspect.isroutine(member) and \\\n1805             not isinstance(parent, ModuleDocumenter)\n1806 \n1807     def import_object(self, raiseerror: bool = False) -> bool:\n1808         ret = super().import_object(raiseerror)\n1809         if not ret:\n1810             return ret\n1811 \n1812         # to distinguish classmethod/staticmethod\n1813         obj = self.parent.__dict__.get(self.object_name)\n1814         if obj is None:\n1815             obj = self.object\n1816 \n1817         if (inspect.isclassmethod(obj) or\n1818                 inspect.isstaticmethod(obj, cls=self.parent, name=self.object_name)):\n1819             # document class and static members before ordinary ones\n1820             self.member_order = self.member_order - 1\n1821 \n1822         return ret\n1823 \n1824     def format_args(self, **kwargs: Any) -> str:\n1825         if self.env.config.autodoc_typehints in ('none', 'description'):\n1826             kwargs.setdefault('show_annotation', False)\n1827 \n1828         try:\n1829             if self.object == object.__init__ and self.parent != object:\n1830                 # Classes not having own __init__() method are shown as no arguments.\n1831                 #\n1832                 # Note: The signature of object.__init__() is (self, /, *args, **kwargs).\n1833                 #       But it makes users confused.\n1834                 args = '()'\n1835             else:\n1836                 if inspect.isstaticmethod(self.object, cls=self.parent, name=self.object_name):\n1837                     self.env.app.emit('autodoc-before-process-signature', self.object, False)\n1838                     sig = inspect.signature(self.object, bound_method=False,\n1839                                             type_aliases=self.env.config.autodoc_type_aliases)\n1840                 else:\n1841                     self.env.app.emit('autodoc-before-process-signature', self.object, True)\n1842                     sig = inspect.signature(self.object, bound_method=True,\n1843                                             follow_wrapped=True,\n1844                                             type_aliases=self.env.config.autodoc_type_aliases)\n1845                 args = stringify_signature(sig, **kwargs)\n1846         except TypeError as exc:\n1847             logger.warning(__(\"Failed to get a method signature for %s: %s\"),\n1848                            self.fullname, exc)\n1849             return None\n1850         except ValueError:\n1851             args = ''\n1852 \n1853         if self.env.config.strip_signature_backslash:\n1854             # escape backslashes for reST\n1855             args = args.replace('\\\\', '\\\\\\\\')\n1856         return args\n1857 \n1858     def add_directive_header(self, sig: str) -> None:\n1859         super().add_directive_header(sig)\n1860 \n1861         sourcename = self.get_sourcename()\n1862         obj = self.parent.__dict__.get(self.object_name, self.object)\n1863         if inspect.isabstractmethod(obj):\n1864             self.add_line('   :abstractmethod:', sourcename)\n1865         if inspect.iscoroutinefunction(obj):\n1866             self.add_line('   :async:', sourcename)\n1867         if inspect.isclassmethod(obj):\n1868             self.add_line('   :classmethod:', sourcename)\n1869         if inspect.isstaticmethod(obj, cls=self.parent, name=self.object_name):\n1870             self.add_line('   :staticmethod:', sourcename)\n1871         if self.analyzer and '.'.join(self.objpath) in self.analyzer.finals:\n1872             self.add_line('   :final:', sourcename)\n1873 \n1874     def document_members(self, all_members: bool = False) -> None:\n1875         pass\n1876 \n1877     def format_signature(self, **kwargs: Any) -> str:\n1878         sigs = []\n1879         if self.analyzer and '.'.join(self.objpath) in self.analyzer.overloads:\n1880             # Use signatures for overloaded methods instead of the implementation method.\n1881             overloaded = True\n1882         else:\n1883             overloaded = False\n1884             sig = super().format_signature(**kwargs)\n1885             sigs.append(sig)\n1886 \n1887         meth = self.parent.__dict__.get(self.objpath[-1])\n1888         if inspect.is_singledispatch_method(meth):\n1889             # append signature of singledispatch'ed functions\n1890             for typ, func in meth.dispatcher.registry.items():\n1891                 if typ is object:\n1892                     pass  # default implementation. skipped.\n1893                 else:\n1894                     self.annotate_to_first_argument(func, typ)\n1895 \n1896                     documenter = MethodDocumenter(self.directive, '')\n1897                     documenter.parent = self.parent\n1898                     documenter.object = func\n1899                     documenter.objpath = [None]\n1900                     sigs.append(documenter.format_signature())\n1901         if overloaded:\n1902             __globals__ = safe_getattr(self.object, '__globals__', {})\n1903             for overload in self.analyzer.overloads.get('.'.join(self.objpath)):\n1904                 overload = evaluate_signature(overload, __globals__,\n1905                                               self.env.config.autodoc_type_aliases)\n1906 \n1907                 if not inspect.isstaticmethod(self.object, cls=self.parent,\n1908                                               name=self.object_name):\n1909                     parameters = list(overload.parameters.values())\n1910                     overload = overload.replace(parameters=parameters[1:])\n1911                 sig = stringify_signature(overload, **kwargs)\n1912                 sigs.append(sig)\n1913 \n1914         return \"\\n\".join(sigs)\n1915 \n1916     def annotate_to_first_argument(self, func: Callable, typ: Type) -> None:\n1917         \"\"\"Annotate type hint to the first argument of function if needed.\"\"\"\n1918         try:\n1919             sig = inspect.signature(func, type_aliases=self.env.config.autodoc_type_aliases)\n1920         except TypeError as exc:\n1921             logger.warning(__(\"Failed to get a method signature for %s: %s\"),\n1922                            self.fullname, exc)\n1923             return\n1924         except ValueError:\n1925             return\n1926         if len(sig.parameters) == 1:\n1927             return\n1928 \n1929         params = list(sig.parameters.values())\n1930         if params[1].annotation is Parameter.empty:\n1931             params[1] = params[1].replace(annotation=typ)\n1932             try:\n1933                 func.__signature__ = sig.replace(parameters=params)  # type: ignore\n1934             except TypeError:\n1935                 # failed to update signature (ex. built-in or extension types)\n1936                 return\n1937 \n1938 \n1939 class SingledispatchMethodDocumenter(MethodDocumenter):\n1940     \"\"\"\n1941     Used to be a specialized Documenter subclass for singledispatch'ed methods.\n1942 \n1943     Retained for backwards compatibility, now does the same as the MethodDocumenter\n1944     \"\"\"\n1945 \n1946     def __init__(self, *args: Any, **kwargs: Any) -> None:\n1947         warnings.warn(\"%s is deprecated.\" % self.__class__.__name__,\n1948                       RemovedInSphinx50Warning, stacklevel=2)\n1949         super().__init__(*args, **kwargs)\n1950 \n1951 \n1952 class AttributeDocumenter(DocstringStripSignatureMixin, ClassLevelDocumenter):  # type: ignore\n1953     \"\"\"\n1954     Specialized Documenter subclass for attributes.\n1955     \"\"\"\n1956     objtype = 'attribute'\n1957     member_order = 60\n1958     option_spec = dict(ModuleLevelDocumenter.option_spec)\n1959     option_spec[\"annotation\"] = annotation_option\n1960 \n1961     # must be higher than the MethodDocumenter, else it will recognize\n1962     # some non-data descriptors as methods\n1963     priority = 10\n1964 \n1965     @staticmethod\n1966     def is_function_or_method(obj: Any) -> bool:\n1967         return inspect.isfunction(obj) or inspect.isbuiltin(obj) or inspect.ismethod(obj)\n1968 \n1969     @classmethod\n1970     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any\n1971                             ) -> bool:\n1972         if inspect.isattributedescriptor(member):\n1973             return True\n1974         elif (not isinstance(parent, ModuleDocumenter) and\n1975               not inspect.isroutine(member) and\n1976               not isinstance(member, type)):\n1977             return True\n1978         else:\n1979             return False\n1980 \n1981     def document_members(self, all_members: bool = False) -> None:\n1982         pass\n1983 \n1984     def isinstanceattribute(self) -> bool:\n1985         \"\"\"Check the subject is an instance attribute.\"\"\"\n1986         try:\n1987             analyzer = ModuleAnalyzer.for_module(self.modname)\n1988             attr_docs = analyzer.find_attr_docs()\n1989             if self.objpath:\n1990                 key = ('.'.join(self.objpath[:-1]), self.objpath[-1])\n1991                 if key in attr_docs:\n1992                     return True\n1993 \n1994             return False\n1995         except PycodeError:\n1996             return False\n1997 \n1998     def import_object(self, raiseerror: bool = False) -> bool:\n1999         try:\n2000             ret = super().import_object(raiseerror=True)\n2001             if inspect.isenumattribute(self.object):\n2002                 self.object = self.object.value\n2003             if inspect.isattributedescriptor(self.object):\n2004                 self._datadescriptor = True\n2005             else:\n2006                 # if it's not a data descriptor\n2007                 self._datadescriptor = False\n2008         except ImportError as exc:\n2009             if self.isinstanceattribute():\n2010                 self.object = INSTANCEATTR\n2011                 self._datadescriptor = False\n2012                 ret = True\n2013             elif raiseerror:\n2014                 raise\n2015             else:\n2016                 logger.warning(exc.args[0], type='autodoc', subtype='import_object')\n2017                 self.env.note_reread()\n2018                 ret = False\n2019 \n2020         return ret\n2021 \n2022     def get_real_modname(self) -> str:\n2023         return self.get_attr(self.parent or self.object, '__module__', None) \\\n2024             or self.modname\n2025 \n2026     def add_directive_header(self, sig: str) -> None:\n2027         super().add_directive_header(sig)\n2028         sourcename = self.get_sourcename()\n2029         if not self.options.annotation:\n2030             # obtain type annotation for this attribute\n2031             try:\n2032                 annotations = get_type_hints(self.parent)\n2033             except NameError:\n2034                 # Failed to evaluate ForwardRef (maybe TYPE_CHECKING)\n2035                 annotations = safe_getattr(self.parent, '__annotations__', {})\n2036             except TypeError:\n2037                 annotations = {}\n2038             except KeyError:\n2039                 # a broken class found (refs: https://github.com/sphinx-doc/sphinx/issues/8084)\n2040                 annotations = {}\n2041             except AttributeError:\n2042                 # AttributeError is raised on 3.5.2 (fixed by 3.5.3)\n2043                 annotations = {}\n2044 \n2045             if self.objpath[-1] in annotations:\n2046                 objrepr = stringify_typehint(annotations.get(self.objpath[-1]))\n2047                 self.add_line('   :type: ' + objrepr, sourcename)\n2048             else:\n2049                 key = ('.'.join(self.objpath[:-1]), self.objpath[-1])\n2050                 if self.analyzer and key in self.analyzer.annotations:\n2051                     self.add_line('   :type: ' + self.analyzer.annotations[key],\n2052                                   sourcename)\n2053 \n2054             # data descriptors do not have useful values\n2055             if not self._datadescriptor:\n2056                 try:\n2057                     if self.object is INSTANCEATTR:\n2058                         pass\n2059                     else:\n2060                         objrepr = object_description(self.object)\n2061                         self.add_line('   :value: ' + objrepr, sourcename)\n2062                 except ValueError:\n2063                     pass\n2064         elif self.options.annotation is SUPPRESS:\n2065             pass\n2066         else:\n2067             self.add_line('   :annotation: %s' % self.options.annotation, sourcename)\n2068 \n2069     def get_doc(self, encoding: str = None, ignore: int = None) -> List[List[str]]:\n2070         try:\n2071             # Disable `autodoc_inherit_docstring` temporarily to avoid to obtain\n2072             # a docstring from the value which descriptor returns unexpectedly.\n2073             # ref: https://github.com/sphinx-doc/sphinx/issues/7805\n2074             orig = self.env.config.autodoc_inherit_docstrings\n2075             self.env.config.autodoc_inherit_docstrings = False  # type: ignore\n2076             return super().get_doc(encoding, ignore)\n2077         finally:\n2078             self.env.config.autodoc_inherit_docstrings = orig  # type: ignore\n2079 \n2080     def add_content(self, more_content: Any, no_docstring: bool = False) -> None:\n2081         if not self._datadescriptor:\n2082             # if it's not a data descriptor, its docstring is very probably the\n2083             # wrong thing to display\n2084             no_docstring = True\n2085         super().add_content(more_content, no_docstring)\n2086 \n2087 \n2088 class PropertyDocumenter(DocstringStripSignatureMixin, ClassLevelDocumenter):  # type: ignore\n2089     \"\"\"\n2090     Specialized Documenter subclass for properties.\n2091     \"\"\"\n2092     objtype = 'property'\n2093     directivetype = 'method'\n2094     member_order = 60\n2095 \n2096     # before AttributeDocumenter\n2097     priority = AttributeDocumenter.priority + 1\n2098 \n2099     @classmethod\n2100     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any\n2101                             ) -> bool:\n2102         return inspect.isproperty(member) and isinstance(parent, ClassDocumenter)\n2103 \n2104     def document_members(self, all_members: bool = False) -> None:\n2105         pass\n2106 \n2107     def get_real_modname(self) -> str:\n2108         return self.get_attr(self.parent or self.object, '__module__', None) \\\n2109             or self.modname\n2110 \n2111     def add_directive_header(self, sig: str) -> None:\n2112         super().add_directive_header(sig)\n2113         sourcename = self.get_sourcename()\n2114         if inspect.isabstractmethod(self.object):\n2115             self.add_line('   :abstractmethod:', sourcename)\n2116         self.add_line('   :property:', sourcename)\n2117 \n2118 \n2119 class InstanceAttributeDocumenter(AttributeDocumenter):\n2120     \"\"\"\n2121     Specialized Documenter subclass for attributes that cannot be imported\n2122     because they are instance attributes (e.g. assigned in __init__).\n2123     \"\"\"\n2124     objtype = 'instanceattribute'\n2125     directivetype = 'attribute'\n2126     member_order = 60\n2127 \n2128     # must be higher than AttributeDocumenter\n2129     priority = 11\n2130 \n2131     @classmethod\n2132     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any\n2133                             ) -> bool:\n2134         \"\"\"This documents only INSTANCEATTR members.\"\"\"\n2135         return (not isinstance(parent, ModuleDocumenter) and\n2136                 isattr and\n2137                 member is INSTANCEATTR)\n2138 \n2139     def import_parent(self) -> Any:\n2140         try:\n2141             parent = importlib.import_module(self.modname)\n2142             for name in self.objpath[:-1]:\n2143                 parent = self.get_attr(parent, name)\n2144 \n2145             return parent\n2146         except (ImportError, AttributeError):\n2147             return None\n2148 \n2149     def import_object(self, raiseerror: bool = False) -> bool:\n2150         \"\"\"Never import anything.\"\"\"\n2151         # disguise as an attribute\n2152         self.objtype = 'attribute'\n2153         self.object = INSTANCEATTR\n2154         self.parent = self.import_parent()\n2155         self._datadescriptor = False\n2156         return True\n2157 \n2158     def add_content(self, more_content: Any, no_docstring: bool = False) -> None:\n2159         \"\"\"Never try to get a docstring from the object.\"\"\"\n2160         super().add_content(more_content, no_docstring=True)\n2161 \n2162 \n2163 class SlotsAttributeDocumenter(AttributeDocumenter):\n2164     \"\"\"\n2165     Specialized Documenter subclass for attributes that cannot be imported\n2166     because they are attributes in __slots__.\n2167     \"\"\"\n2168     objtype = 'slotsattribute'\n2169     directivetype = 'attribute'\n2170     member_order = 60\n2171 \n2172     # must be higher than AttributeDocumenter\n2173     priority = 11\n2174 \n2175     @classmethod\n2176     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any\n2177                             ) -> bool:\n2178         \"\"\"This documents only SLOTSATTR members.\"\"\"\n2179         return member is SLOTSATTR\n2180 \n2181     def import_object(self, raiseerror: bool = False) -> bool:\n2182         \"\"\"Never import anything.\"\"\"\n2183         # disguise as an attribute\n2184         self.objtype = 'attribute'\n2185         self._datadescriptor = True\n2186 \n2187         with mock(self.env.config.autodoc_mock_imports):\n2188             try:\n2189                 ret = import_object(self.modname, self.objpath[:-1], 'class',\n2190                                     attrgetter=self.get_attr,\n2191                                     warningiserror=self.env.config.autodoc_warningiserror)\n2192                 self.module, _, _, self.parent = ret\n2193                 return True\n2194             except ImportError as exc:\n2195                 if raiseerror:\n2196                     raise\n2197                 else:\n2198                     logger.warning(exc.args[0], type='autodoc', subtype='import_object')\n2199                     self.env.note_reread()\n2200                     return False\n2201 \n2202     def get_doc(self, encoding: str = None, ignore: int = None) -> List[List[str]]:\n2203         \"\"\"Decode and return lines of the docstring(s) for the object.\"\"\"\n2204         if ignore is not None:\n2205             warnings.warn(\"The 'ignore' argument to autodoc.%s.get_doc() is deprecated.\"\n2206                           % self.__class__.__name__,\n2207                           RemovedInSphinx50Warning, stacklevel=2)\n2208         name = self.objpath[-1]\n2209         __slots__ = safe_getattr(self.parent, '__slots__', [])\n2210         if isinstance(__slots__, dict) and isinstance(__slots__.get(name), str):\n2211             docstring = prepare_docstring(__slots__[name])\n2212             return [docstring]\n2213         else:\n2214             return []\n2215 \n2216 \n2217 def get_documenters(app: Sphinx) -> Dict[str, \"Type[Documenter]\"]:\n2218     \"\"\"Returns registered Documenter classes\"\"\"\n2219     warnings.warn(\"get_documenters() is deprecated.\", RemovedInSphinx50Warning, stacklevel=2)\n2220     return app.registry.documenters\n2221 \n2222 \n2223 def autodoc_attrgetter(app: Sphinx, obj: Any, name: str, *defargs: Any) -> Any:\n2224     \"\"\"Alternative getattr() for types\"\"\"\n2225     for typ, func in app.registry.autodoc_attrgettrs.items():\n2226         if isinstance(obj, typ):\n2227             return func(obj, name, *defargs)\n2228 \n2229     return safe_getattr(obj, name, *defargs)\n2230 \n2231 \n2232 def migrate_autodoc_member_order(app: Sphinx, config: Config) -> None:\n2233     if config.autodoc_member_order == 'alphabetic':\n2234         # RemovedInSphinx50Warning\n2235         logger.warning(__('autodoc_member_order now accepts \"alphabetical\" '\n2236                           'instead of \"alphabetic\". Please update your setting.'))\n2237         config.autodoc_member_order = 'alphabetical'  # type: ignore\n2238 \n2239 \n2240 def setup(app: Sphinx) -> Dict[str, Any]:\n2241     app.add_autodocumenter(ModuleDocumenter)\n2242     app.add_autodocumenter(ClassDocumenter)\n2243     app.add_autodocumenter(ExceptionDocumenter)\n2244     app.add_autodocumenter(DataDocumenter)\n2245     app.add_autodocumenter(DataDeclarationDocumenter)\n2246     app.add_autodocumenter(GenericAliasDocumenter)\n2247     app.add_autodocumenter(TypeVarDocumenter)\n2248     app.add_autodocumenter(FunctionDocumenter)\n2249     app.add_autodocumenter(DecoratorDocumenter)\n2250     app.add_autodocumenter(MethodDocumenter)\n2251     app.add_autodocumenter(AttributeDocumenter)\n2252     app.add_autodocumenter(PropertyDocumenter)\n2253     app.add_autodocumenter(InstanceAttributeDocumenter)\n2254     app.add_autodocumenter(SlotsAttributeDocumenter)\n2255 \n2256     app.add_config_value('autoclass_content', 'class', True, ENUM('both', 'class', 'init'))\n2257     app.add_config_value('autodoc_member_order', 'alphabetical', True,\n2258                          ENUM('alphabetic', 'alphabetical', 'bysource', 'groupwise'))\n2259     app.add_config_value('autodoc_default_options', {}, True)\n2260     app.add_config_value('autodoc_docstring_signature', True, True)\n2261     app.add_config_value('autodoc_mock_imports', [], True)\n2262     app.add_config_value('autodoc_typehints', \"signature\", True,\n2263                          ENUM(\"signature\", \"description\", \"none\"))\n2264     app.add_config_value('autodoc_type_aliases', {}, True)\n2265     app.add_config_value('autodoc_warningiserror', True, True)\n2266     app.add_config_value('autodoc_inherit_docstrings', True, True)\n2267     app.add_event('autodoc-before-process-signature')\n2268     app.add_event('autodoc-process-docstring')\n2269     app.add_event('autodoc-process-signature')\n2270     app.add_event('autodoc-skip-member')\n2271 \n2272     app.connect('config-inited', migrate_autodoc_member_order, priority=800)\n2273 \n2274     app.setup_extension('sphinx.ext.autodoc.type_comment')\n2275     app.setup_extension('sphinx.ext.autodoc.typehints')\n2276 \n2277     return {'version': sphinx.__display_version__, 'parallel_read_safe': True}\n",
        "intended_behavior": "This file, particularly in the section related to function signature processing, should be modified to correctly handle and preserve hexadecimal default values in function signatures when generating documentation. The code should detect when a default value is expressed in hexadecimal format and ensure that this format is maintained in the output documentation, rather than converting it to decimal. This will involve checking the format of default arguments and applying a condition to preserve the original format (hexadecimal, octal, etc.) in the rendered documentation."
    },
    {
        "rel_file_path": "sphinx/domains/python.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/sphinx-doc__sphinx/setup_sphinx-doc__sphinx__3.3/sphinx/domains/python.py",
        "start": 218,
        "end": 263,
        "class_name": null,
        "method_name": "_pseudo_parse_arglist",
        "code": "218 def _pseudo_parse_arglist(signode: desc_signature, arglist: str) -> None:\n219     \"\"\"\"Parse\" a list of arguments separated by commas.\n220 \n221     Arguments can have \"optional\" annotations given by enclosing them in\n222     brackets.  Currently, this will split at any comma, even if it's inside a\n223     string literal (e.g. default argument value).\n224     \"\"\"\n225     paramlist = addnodes.desc_parameterlist()\n226     stack = [paramlist]  # type: List[Element]\n227     try:\n228         for argument in arglist.split(','):\n229             argument = argument.strip()\n230             ends_open = ends_close = 0\n231             while argument.startswith('['):\n232                 stack.append(addnodes.desc_optional())\n233                 stack[-2] += stack[-1]\n234                 argument = argument[1:].strip()\n235             while argument.startswith(']'):\n236                 stack.pop()\n237                 argument = argument[1:].strip()\n238             while argument.endswith(']') and not argument.endswith('[]'):\n239                 ends_close += 1\n240                 argument = argument[:-1].strip()\n241             while argument.endswith('['):\n242                 ends_open += 1\n243                 argument = argument[:-1].strip()\n244             if argument:\n245                 stack[-1] += addnodes.desc_parameter(argument, argument)\n246             while ends_open:\n247                 stack.append(addnodes.desc_optional())\n248                 stack[-2] += stack[-1]\n249                 ends_open -= 1\n250             while ends_close:\n251                 stack.pop()\n252                 ends_close -= 1\n253         if len(stack) != 1:\n254             raise IndexError\n255     except IndexError:\n256         # if there are too few or too many elements on the stack, just give up\n257         # and treat the whole argument list as one argument, discarding the\n258         # already partially populated paramlist node\n259         paramlist = addnodes.desc_parameterlist()\n260         paramlist += addnodes.desc_parameter(arglist, arglist)\n261         signode += paramlist\n262     else:\n263         signode += paramlist\n",
        "intended_behavior": "In the `_pseudo_parse_arglist` method, which is involved in parsing function arguments and their annotations, care should be taken to accurately parse and maintain the representation of default arguments. If a default argument is specified in hexadecimal (or any non-decimal base), this method should ensure that the original representation is preserved in the documentation output. This might require including logic to detect the format of the default value and ensuring that this format is not altered during the documentation generation process."
    }
]