2025-10-18 18:33:59.409 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-18 18:34:02.725 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=464, output_tokens=12, cost=0.005000
2025-10-18 18:34:22.952 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=644, output_tokens=902, cost=0.033500
2025-10-18 18:34:23.974 | INFO     | registered non reproducing test 0
2025-10-18 18:34:43.089 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2104, output_tokens=898, cost=0.047980
2025-10-18 18:34:44.083 | INFO     | registered non reproducing test 1
2025-10-18 18:35:03.940 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2144, output_tokens=948, cost=0.049880
2025-10-18 18:35:04.946 | INFO     | registered non reproducing test 2
2025-10-18 18:35:04.946 | WARNING  | Failed to write a reproducer test; skipping reproducer tracing
2025-10-18 18:35:04.953 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 18:35:11.218 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=769, output_tokens=298, cost=0.016630
2025-10-18 18:35:11.224 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 18:35:13.590 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=652, output_tokens=36, cost=0.007600
2025-10-18 18:35:13.591 | DEBUG    | Extracted a valid json.
2025-10-18 18:35:13.591 | DEBUG    | Agent proxy return the following json: {
    "API_calls": ["search_method(\"render\")", "search_code(\"function signature\")", "search_code(\"default argument\")"],
    "bug_locations": []
}
2025-10-18 18:35:13.633 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-18 18:35:13.633 | DEBUG    | <Agent search> Analyzing search results.
2025-10-18 18:35:28.010 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1535, output_tokens=708, cost=0.036590
2025-10-18 18:35:28.025 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 18:35:35.415 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2459, output_tokens=354, cost=0.035210
2025-10-18 18:35:35.422 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 18:35:42.301 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=708, output_tokens=281, cost=0.015510
2025-10-18 18:35:42.302 | DEBUG    | Extracted a valid json.
2025-10-18 18:35:42.302 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations":[
        {
            "file": "sphinx/ext/autodoc/__init__.py",
            "class": "",
            "method": "",
            "intended_behavior": "This file, particularly in the section related to function signature processing, should be modified to correctly handle and preserve hexadecimal default values in function signatures when generating documentation. The code should detect when a default value is expressed in hexadecimal format and ensure that this format is maintained in the output documentation, rather than converting it to decimal. This will involve checking the format of default arguments and applying a condition to preserve the original format (hexadecimal, octal, etc.) in the rendered documentation."
        },
        {
            "file": "sphinx/domains/python.py",
            "class": "",
            "method": "_pseudo_parse_arglist",
            "intended_behavior": "In the `_pseudo_parse_arglist` method, which is involved in parsing function arguments and their annotations, care should be taken to accurately parse and maintain the representation of default arguments. If a default argument is specified in hexadecimal (or any non-decimal base), this method should ensure that the original representation is preserved in the documentation output. This might require including logic to detect the format of the default value and ensuring that this format is not altered during the documentation generation process."
        }
    ]
}
2025-10-18 18:35:42.313 | DEBUG    | Bug location extracted successfully: [<file>sphinx/ext/autodoc/__init__.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2     sphinx.ext.autodoc
3     ~~~~~~~~~~~~~~~~~~
4 
5     Automatically insert docstrings for functions, classes or whole modules into
6     the doctree, thus avoiding duplication between docstrings and documentation
7     for those who like elaborate docstrings.
8 
9     :copyright: Copyright 2007-2020 by the Sphinx team, see AUTHORS.
10     :license: BSD, see LICENSE for details.
11 """
12 
13 import importlib
14 import re
15 import warnings
16 from inspect import Parameter, Signature
17 from types import ModuleType
18 from typing import (
19     Any, Callable, Dict, Iterator, List, Optional, Sequence, Set, Tuple, Type, TypeVar, Union
20 )
21 from typing import get_type_hints
22 
23 from docutils.statemachine import StringList
24 
25 import sphinx
26 from sphinx.application import Sphinx
27 from sphinx.config import Config, ENUM
28 from sphinx.deprecation import RemovedInSphinx40Warning, RemovedInSphinx50Warning
29 from sphinx.environment import BuildEnvironment
30 from sphinx.ext.autodoc.importer import import_object, get_module_members, get_object_members
31 from sphinx.ext.autodoc.mock import mock
32 from sphinx.locale import _, __
33 from sphinx.pycode import ModuleAnalyzer, PycodeError
34 from sphinx.util import inspect
35 from sphinx.util import logging
36 from sphinx.util.docstrings import extract_metadata, prepare_docstring
37 from sphinx.util.inspect import (
38     evaluate_signature, getdoc, object_description, safe_getattr, stringify_signature
39 )
40 from sphinx.util.typing import stringify as stringify_typehint
41 
42 if False:
43     # For type annotation
44     from typing import Type  # NOQA # for python3.5.1
45     from sphinx.ext.autodoc.directive import DocumenterBridge
46 
47 
48 logger = logging.getLogger(__name__)
49 
50 
51 # This type isn't exposed directly in any modules, but can be found
52 # here in most Python versions
53 MethodDescriptorType = type(type.__subclasses__)
54 
55 
56 #: extended signature RE: with explicit module name separated by ::
57 py_ext_sig_re = re.compile(
58     r'''^ ([\w.]+::)?            # explicit module name
59           ([\w.]+\.)?            # module and/or class name(s)
60           (\w+)  \s*             # thing name
61           (?: \((.*)\)           # optional: arguments
62            (?:\s* -> \s* (.*))?  #           return annotation
63           )? $                   # and nothing more
64           ''', re.VERBOSE)
65 special_member_re = re.compile(r'^__\S+__$')
66 
67 
68 def identity(x: Any) -> Any:
69     return x
70 
71 
72 class _All:
73     """A special value for :*-members: that matches to any member."""
74 
75     def __contains__(self, item: Any) -> bool:
76         return True
77 
78 
79 class _Empty:
80     """A special value for :exclude-members: that never matches to any member."""
81 
82     def __contains__(self, item: Any) -> bool:
83         return False
84 
85 
86 ALL = _All()
87 EMPTY = _Empty()
88 UNINITIALIZED_ATTR = object()
89 INSTANCEATTR = object()
90 SLOTSATTR = object()
91 
92 
93 def members_option(arg: Any) -> Union[object, List[str]]:
94     """Used to convert the :members: option to auto directives."""
95     if arg is None or arg is True:
96         return ALL
97     elif arg is False:
98         return None
99     else:
100         return [x.strip() for x in arg.split(',') if x.strip()]
101 
102 
103 def members_set_option(arg: Any) -> Union[object, Set[str]]:
104     """Used to convert the :members: option to auto directives."""
105     warnings.warn("members_set_option() is deprecated.",
106                   RemovedInSphinx50Warning, stacklevel=2)
107     if arg is None:
108         return ALL
109     return {x.strip() for x in arg.split(',') if x.strip()}
110 
111 
112 def exclude_members_option(arg: Any) -> Union[object, Set[str]]:
113     """Used to convert the :exclude-members: option."""
114     if arg is None:
115         return EMPTY
116     return {x.strip() for x in arg.split(',') if x.strip()}
117 
118 
119 def inherited_members_option(arg: Any) -> Union[object, Set[str]]:
120     """Used to convert the :members: option to auto directives."""
121     if arg is None:
122         return 'object'
123     else:
124         return arg
125 
126 
127 def member_order_option(arg: Any) -> Optional[str]:
128     """Used to convert the :members: option to auto directives."""
129     if arg is None:
130         return None
131     elif arg in ('alphabetical', 'bysource', 'groupwise'):
132         return arg
133     else:
134         raise ValueError(__('invalid value for member-order option: %s') % arg)
135 
136 
137 SUPPRESS = object()
138 
139 
140 def annotation_option(arg: Any) -> Any:
141     if arg is None:
142         # suppress showing the representation of the object
143         return SUPPRESS
144     else:
145         return arg
146 
147 
148 def bool_option(arg: Any) -> bool:
149     """Used to convert flag options to auto directives.  (Instead of
150     directives.flag(), which returns None).
151     """
152     return True
153 
154 
155 def merge_special_members_option(options: Dict) -> None:
156     """Merge :special-members: option to :members: option."""
157     warnings.warn("merge_special_members_option() is deprecated.",
158                   RemovedInSphinx50Warning, stacklevel=2)
159     if 'special-members' in options and options['special-members'] is not ALL:
160         if options.get('members') is ALL:
161             pass
162         elif options.get('members'):
163             for member in options['special-members']:
164                 if member not in options['members']:
165                     options['members'].append(member)
166         else:
167             options['members'] = options['special-members']
168 
169 
170 def merge_members_option(options: Dict) -> None:
171     """Merge :*-members: option to the :members: option."""
172     if options.get('members') is ALL:
173         # merging is not needed when members: ALL
174         return
175 
176     members = options.setdefault('members', [])
177     for key in {'private-members', 'special-members'}:
178         if key in options and options[key] not in (ALL, None):
179             for member in options[key]:
180                 if member not in members:
181                     members.append(member)
182 
183 
184 # Some useful event listener factories for autodoc-process-docstring.
185 
186 def cut_lines(pre: int, post: int = 0, what: str = None) -> Callable:
187     """Return a listener that removes the first *pre* and last *post*
188     lines of every docstring.  If *what* is a sequence of strings,
189     only docstrings of a type in *what* will be processed.
190 
191     Use like this (e.g. in the ``setup()`` function of :file:`conf.py`)::
192 
193        from sphinx.ext.autodoc import cut_lines
194        app.connect('autodoc-process-docstring', cut_lines(4, what=['module']))
195 
196     This can (and should) be used in place of :confval:`automodule_skip_lines`.
197     """
198     def process(app: Sphinx, what_: str, name: str, obj: Any, options: Any, lines: List[str]
199                 ) -> None:
200         if what and what_ not in what:
201             return
202         del lines[:pre]
203         if post:
204             # remove one trailing blank line.
205             if lines and not lines[-1]:
206                 lines.pop(-1)
207             del lines[-post:]
208         # make sure there is a blank line at the end
209         if lines and lines[-1]:
210             lines.append('')
211     return process
212 
213 
214 def between(marker: str, what: Sequence[str] = None, keepempty: bool = False,
215             exclude: bool = False) -> Callable:
216     """Return a listener that either keeps, or if *exclude* is True excludes,
217     lines between lines that match the *marker* regular expression.  If no line
218     matches, the resulting docstring would be empty, so no change will be made
219     unless *keepempty* is true.
220 
221     If *what* is a sequence of strings, only docstrings of a type in *what* will
222     be processed.
223     """
224     marker_re = re.compile(marker)
225 
226     def process(app: Sphinx, what_: str, name: str, obj: Any, options: Any, lines: List[str]
227                 ) -> None:
228         if what and what_ not in what:
229             return
230         deleted = 0
231         delete = not exclude
232         orig_lines = lines[:]
233         for i, line in enumerate(orig_lines):
234             if delete:
235                 lines.pop(i - deleted)
236                 deleted += 1
237             if marker_re.match(line):
238                 delete = not delete
239                 if delete:
240                     lines.pop(i - deleted)
241                     deleted += 1
242         if not lines and not keepempty:
243             lines[:] = orig_lines
244         # make sure there is a blank line at the end
245         if lines and lines[-1]:
246             lines.append('')
247     return process
248 
249 
250 # This class is used only in ``sphinx.ext.autodoc.directive``,
251 # But we define this class here to keep compatibility (see #4538)
252 class Options(dict):
253     """A dict/attribute hybrid that returns None on nonexisting keys."""
254     def __getattr__(self, name: str) -> Any:
255         try:
256             return self[name.replace('_', '-')]
257         except KeyError:
258             return None
259 
260 
261 class Documenter:
262     """
263     A Documenter knows how to autodocument a single object type.  When
264     registered with the AutoDirective, it will be used to document objects
265     of that type when needed by autodoc.
266 
267     Its *objtype* attribute selects what auto directive it is assigned to
268     (the directive name is 'auto' + objtype), and what directive it generates
269     by default, though that can be overridden by an attribute called
270     *directivetype*.
271 
272     A Documenter has an *option_spec* that works like a docutils directive's;
273     in fact, it will be used to parse an auto directive's options that matches
274     the documenter.
275     """
276     #: name by which the directive is called (auto...) and the default
277     #: generated directive name
278     objtype = 'object'
279     #: indentation by which to indent the directive content
280     content_indent = '   '
281     #: priority if multiple documenters return True from can_document_member
282     priority = 0
283     #: order if autodoc_member_order is set to 'groupwise'
284     member_order = 0
285     #: true if the generated content may contain titles
286     titles_allowed = False
287 
288     option_spec = {'noindex': bool_option}  # type: Dict[str, Callable]
289 
290     def get_attr(self, obj: Any, name: str, *defargs: Any) -> Any:
291         """getattr() override for types such as Zope interfaces."""
292         return autodoc_attrgetter(self.env.app, obj, name, *defargs)
293 
294     @classmethod
295     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
296                             ) -> bool:
297         """Called to see if a member can be documented by this documenter."""
298         raise NotImplementedError('must be implemented in subclasses')
299 
300     def __init__(self, directive: "DocumenterBridge", name: str, indent: str = '') -> None:
301         self.directive = directive
302         self.env = directive.env    # type: BuildEnvironment
303         self.options = directive.genopt
304         self.name = name
305         self.indent = indent
306         # the module and object path within the module, and the fully
307         # qualified name (all set after resolve_name succeeds)
308         self.modname = None         # type: str
309         self.module = None          # type: ModuleType
310         self.objpath = None         # type: List[str]
311         self.fullname = None        # type: str
312         # extra signature items (arguments and return annotation,
313         # also set after resolve_name succeeds)
314         self.args = None            # type: str
315         self.retann = None          # type: str
316         # the object to document (set after import_object succeeds)
317         self.object = None          # type: Any
318         self.object_name = None     # type: str
319         # the parent/owner of the object to document
320         self.parent = None          # type: Any
321         # the module analyzer to get at attribute docs, or None
322         self.analyzer = None        # type: ModuleAnalyzer
323 
324     @property
325     def documenters(self) -> Dict[str, "Type[Documenter]"]:
326         """Returns registered Documenter classes"""
327         return self.env.app.registry.documenters
328 
329     def add_line(self, line: str, source: str, *lineno: int) -> None:
330         """Append one line of generated reST to the output."""
331         if line.strip():  # not a blank line
332             self.directive.result.append(self.indent + line, source, *lineno)
333         else:
334             self.directive.result.append('', source, *lineno)
335 
336     def resolve_name(self, modname: str, parents: Any, path: str, base: Any
337                      ) -> Tuple[str, List[str]]:
338         """Resolve the module and name of the object to document given by the
339         arguments and the current module/class.
340 
341         Must return a pair of the module name and a chain of attributes; for
342         example, it would return ``('zipfile', ['ZipFile', 'open'])`` for the
343         ``zipfile.ZipFile.open`` method.
344         """
345         raise NotImplementedError('must be implemented in subclasses')
346 
347     def parse_name(self) -> bool:
348         """Determine what module to import and what attribute to document.
349 
350         Returns True and sets *self.modname*, *self.objpath*, *self.fullname*,
351         *self.args* and *self.retann* if parsing and resolving was successful.
352         """
353         # first, parse the definition -- auto directives for classes and
354         # functions can contain a signature which is then used instead of
355         # an autogenerated one
356         try:
357             explicit_modname, path, base, args, retann = \
358                 py_ext_sig_re.match(self.name).groups()
359         except AttributeError:
360             logger.warning(__('invalid signature for auto%s (%r)') % (self.objtype, self.name),
361                            type='autodoc')
362             return False
363 
364         # support explicit module and class name separation via ::
365         if explicit_modname is not None:
366             modname = explicit_modname[:-2]
367             parents = path.rstrip('.').split('.') if path else []
368         else:
369             modname = None
370             parents = []
371 
372         with mock(self.env.config.autodoc_mock_imports):
373             self.modname, self.objpath = self.resolve_name(modname, parents, path, base)
374 
375         if not self.modname:
376             return False
377 
378         self.args = args
379         self.retann = retann
380         self.fullname = (self.modname or '') + \
381                         ('.' + '.'.join(self.objpath) if self.objpath else '')
382         return True
383 
384     def import_object(self, raiseerror: bool = False) -> bool:
385         """Import the object given by *self.modname* and *self.objpath* and set
386         it as *self.object*.
387 
388         Returns True if successful, False if an error occurred.
389         """
390         with mock(self.env.config.autodoc_mock_imports):
391             try:
392                 ret = import_object(self.modname, self.objpath, self.objtype,
393                                     attrgetter=self.get_attr,
394                                     warningiserror=self.env.config.autodoc_warningiserror)
395                 self.module, self.parent, self.object_name, self.object = ret
396                 return True
397             except ImportError as exc:
398                 if raiseerror:
399                     raise
400                 else:
401                     logger.warning(exc.args[0], type='autodoc', subtype='import_object')
402                     self.env.note_reread()
403                     return False
404 
405     def get_real_modname(self) -> str:
406         """Get the real module name of an object to document.
407 
408         It can differ from the name of the module through which the object was
409         imported.
410         """
411         return self.get_attr(self.object, '__module__', None) or self.modname
412 
413     def check_module(self) -> bool:
414         """Check if *self.object* is really defined in the module given by
415         *self.modname*.
416         """
417         if self.options.imported_members:
418             return True
419 
420         subject = inspect.unpartial(self.object)
421         modname = self.get_attr(subject, '__module__', None)
422         if modname and modname != self.modname:
423             return False
424         return True
425 
426     def format_args(self, **kwargs: Any) -> str:
427         """Format the argument signature of *self.object*.
428 
429         Should return None if the object does not have a signature.
430         """
431         return None
432 
433     def format_name(self) -> str:
434         """Format the name of *self.object*.
435 
436         This normally should be something that can be parsed by the generated
437         directive, but doesn't need to be (Sphinx will display it unparsed
438         then).
439         """
440         # normally the name doesn't contain the module (except for module
441         # directives of course)
442         return '.'.join(self.objpath) or self.modname
443 
444     def _call_format_args(self, **kwargs: Any) -> str:
445         if kwargs:
446             try:
447                 return self.format_args(**kwargs)
448             except TypeError:
449                 # avoid chaining exceptions, by putting nothing here
450                 pass
451 
452         # retry without arguments for old documenters
453         return self.format_args()
454 
455     def format_signature(self, **kwargs: Any) -> str:
456         """Format the signature (arguments and return annotation) of the object.
457 
458         Let the user process it via the ``autodoc-process-signature`` event.
459         """
460         if self.args is not None:
461             # signature given explicitly
462             args = "(%s)" % self.args
463             retann = self.retann
464         else:
465             # try to introspect the signature
466             try:
467                 retann = None
468                 args = self._call_format_args(**kwargs)
469                 if args:
470                     matched = re.match(r'^(\(.*\))\s+->\s+(.*)$', args)
471                     if matched:
472                         args = matched.group(1)
473                         retann = matched.group(2)
474             except Exception as exc:
475                 logger.warning(__('error while formatting arguments for %s: %s'),
476                                self.fullname, exc, type='autodoc')
477                 args = None
478 
479         result = self.env.events.emit_firstresult('autodoc-process-signature',
480                                                   self.objtype, self.fullname,
481                                                   self.object, self.options, args, retann)
482         if result:
483             args, retann = result
484 
485         if args is not None:
486             return args + ((' -> %s' % retann) if retann else '')
487         else:
488             return ''
489 
490     def add_directive_header(self, sig: str) -> None:
491         """Add the directive header and options to the generated content."""
492         domain = getattr(self, 'domain', 'py')
493         directive = getattr(self, 'directivetype', self.objtype)
494         name = self.format_name()
495         sourcename = self.get_sourcename()
496 
497         # one signature per line, indented by column
498         prefix = '.. %s:%s:: ' % (domain, directive)
499         for i, sig_line in enumerate(sig.split("\n")):
500             self.add_line('%s%s%s' % (prefix, name, sig_line),
501                           sourcename)
502             if i == 0:
503                 prefix = " " * len(prefix)
504 
505         if self.options.noindex:
506             self.add_line('   :noindex:', sourcename)
507         if self.objpath:
508             # Be explicit about the module, this is necessary since .. class::
509             # etc. don't support a prepended module name
510             self.add_line('   :module: %s' % self.modname, sourcename)
511 
512     def get_doc(self, encoding: str = None, ignore: int = None) -> List[List[str]]:
513         """Decode and return lines of the docstring(s) for the object."""
514         if encoding is not None:
515             warnings.warn("The 'encoding' argument to autodoc.%s.get_doc() is deprecated."
516                           % self.__class__.__name__,
517                           RemovedInSphinx40Warning, stacklevel=2)
518         if ignore is not None:
519             warnings.warn("The 'ignore' argument to autodoc.%s.get_doc() is deprecated."
520                           % self.__class__.__name__,
521                           RemovedInSphinx50Warning, stacklevel=2)
522         docstring = getdoc(self.object, self.get_attr,
523                            self.env.config.autodoc_inherit_docstrings,
524                            self.parent, self.object_name)
525         if docstring:
526             tab_width = self.directive.state.document.settings.tab_width
527             return [prepare_docstring(docstring, ignore, tab_width)]
528         return []
529 
530     def process_doc(self, docstrings: List[List[str]]) -> Iterator[str]:
531         """Let the user process the docstrings before adding them."""
532         for docstringlines in docstrings:
533             if self.env.app:
534                 # let extensions preprocess docstrings
535                 self.env.app.emit('autodoc-process-docstring',
536                                   self.objtype, self.fullname, self.object,
537                                   self.options, docstringlines)
538 
539                 if docstringlines and docstringlines[-1] != '':
540                     # append a blank line to the end of the docstring
541                     docstringlines.append('')
542 
543             yield from docstringlines
544 
545     def get_sourcename(self) -> str:
546         if self.analyzer:
547             return '%s:docstring of %s' % (self.analyzer.srcname, self.fullname)
548         return 'docstring of %s' % self.fullname
549 
550     def add_content(self, more_content: Any, no_docstring: bool = False) -> None:
551         """Add content from docstrings, attribute documentation and user."""
552         # set sourcename and add content from attribute documentation
553         sourcename = self.get_sourcename()
554         if self.analyzer:
555             attr_docs = self.analyzer.find_attr_docs()
556             if self.objpath:
557                 key = ('.'.join(self.objpath[:-1]), self.objpath[-1])
558                 if key in attr_docs:
559                     no_docstring = True
560                     # make a copy of docstring for attributes to avoid cache
561                     # the change of autodoc-process-docstring event.
562                     docstrings = [list(attr_docs[key])]
563 
564                     for i, line in enumerate(self.process_doc(docstrings)):
565                         self.add_line(line, sourcename, i)
566 
567         # add content from docstrings
568         if not no_docstring:
569             docstrings = self.get_doc()
570             if not docstrings:
571                 # append at least a dummy docstring, so that the event
572                 # autodoc-process-docstring is fired and can add some
573                 # content if desired
574                 docstrings.append([])
575             for i, line in enumerate(self.process_doc(docstrings)):
576                 self.add_line(line, sourcename, i)
577 
578         # add additional content (e.g. from document), if present
579         if more_content:
580             for line, src in zip(more_content.data, more_content.items):
581                 self.add_line(line, src[0], src[1])
582 
583     def get_object_members(self, want_all: bool) -> Tuple[bool, List[Tuple[str, Any]]]:
584         """Return `(members_check_module, members)` where `members` is a
585         list of `(membername, member)` pairs of the members of *self.object*.
586 
587         If *want_all* is True, return all members.  Else, only return those
588         members given by *self.options.members* (which may also be none).
589         """
590         members = get_object_members(self.object, self.objpath, self.get_attr, self.analyzer)
591         if not want_all:
592             if not self.options.members:
593                 return False, []
594             # specific members given
595             selected = []
596             for name in self.options.members:
597                 if name in members:
598                     selected.append((name, members[name].value))
599                 else:
600                     logger.warning(__('missing attribute %s in object %s') %
601                                    (name, self.fullname), type='autodoc')
602             return False, selected
603         elif self.options.inherited_members:
604             return False, [(m.name, m.value) for m in members.values()]
605         else:
606             return False, [(m.name, m.value) for m in members.values()
607                            if m.directly_defined]
608 
609     def filter_members(self, members: List[Tuple[str, Any]], want_all: bool
610                        ) -> List[Tuple[str, Any, bool]]:
611         """Filter the given member list.
612 
613         Members are skipped if
614 
615         - they are private (except if given explicitly or the private-members
616           option is set)
617         - they are special methods (except if given explicitly or the
618           special-members option is set)
619         - they are undocumented (except if the undoc-members option is set)
620 
621         The user can override the skipping decision by connecting to the
622         ``autodoc-skip-member`` event.
623         """
624         def is_filtered_inherited_member(name: str) -> bool:
625             if inspect.isclass(self.object):
626                 for cls in self.object.__mro__:
627                     if cls.__name__ == self.options.inherited_members and cls != self.object:
628                         # given member is a member of specified *super class*
629                         return True
630                     elif name in cls.__dict__:
631                         return False
632                     elif name in self.get_attr(cls, '__annotations__', {}):
633                         return False
634 
635             return False
636 
637         ret = []
638 
639         # search for members in source code too
640         namespace = '.'.join(self.objpath)  # will be empty for modules
641 
642         if self.analyzer:
643             attr_docs = self.analyzer.find_attr_docs()
644         else:
645             attr_docs = {}
646 
647         # process members and determine which to skip
648         for (membername, member) in members:
649             # if isattr is True, the member is documented as an attribute
650             if member is INSTANCEATTR:
651                 isattr = True
652             else:
653                 isattr = False
654 
655             doc = getdoc(member, self.get_attr, self.env.config.autodoc_inherit_docstrings,
656                          self.parent, self.object_name)
657             if not isinstance(doc, str):
658                 # Ignore non-string __doc__
659                 doc = None
660 
661             # if the member __doc__ is the same as self's __doc__, it's just
662             # inherited and therefore not the member's doc
663             cls = self.get_attr(member, '__class__', None)
664             if cls:
665                 cls_doc = self.get_attr(cls, '__doc__', None)
666                 if cls_doc == doc:
667                     doc = None
668             has_doc = bool(doc)
669 
670             metadata = extract_metadata(doc)
671             if 'private' in metadata:
672                 # consider a member private if docstring has "private" metadata
673                 isprivate = True
674             elif 'public' in metadata:
675                 # consider a member public if docstring has "public" metadata
676                 isprivate = False
677             else:
678                 isprivate = membername.startswith('_')
679 
680             keep = False
681             if safe_getattr(member, '__sphinx_mock__', False):
682                 # mocked module or object
683                 pass
684             elif self.options.exclude_members and membername in self.options.exclude_members:
685                 # remove members given by exclude-members
686                 keep = False
687             elif want_all and special_member_re.match(membername):
688                 # special __methods__
689                 if self.options.special_members and membername in self.options.special_members:
690                     if membername == '__doc__':
691                         keep = False
692                     elif is_filtered_inherited_member(membername):
693                         keep = False
694                     else:
695                         keep = has_doc or self.options.undoc_members
696                 else:
697                     keep = False
698             elif (namespace, membername) in attr_docs:
699                 if want_all and isprivate:
700                     if self.options.private_members is None:
701                         keep = False
702                     else:
703                         keep = membername in self.options.private_members
704                 else:
705                     # keep documented attributes
706                     keep = True
707                 isattr = True
708             elif want_all and isprivate:
709                 if has_doc or self.options.undoc_members:
710                     if self.options.private_members is None:
711                         keep = False
712                     elif is_filtered_inherited_member(membername):
713                         keep = False
714                     else:
715                         keep = membername in self.options.private_members
716                 else:
717                     keep = False
718             else:
719                 if self.options.members is ALL and is_filtered_inherited_member(membername):
720                     keep = False
721                 else:
722                     # ignore undocumented members if :undoc-members: is not given
723                     keep = has_doc or self.options.undoc_members
724 
725             # give the user a chance to decide whether this member
726             # should be skipped
727             if self.env.app:
728                 # let extensions preprocess docstrings
729                 try:
730                     skip_user = self.env.app.emit_firstresult(
731                         'autodoc-skip-member', self.objtype, membername, member,
732                         not keep, self.options)
733                     if skip_user is not None:
734                         keep = not skip_user
735                 except Exception as exc:
736                     logger.warning(__('autodoc: failed to determine %r to be documented, '
737                                       'the following exception was raised:\n%s'),
738                                    member, exc, type='autodoc')
739                     keep = False
740 
741             if keep:
742                 ret.append((membername, member, isattr))
743 
744         return ret
745 
746     def document_members(self, all_members: bool = False) -> None:
747         """Generate reST for member documentation.
748 
749         If *all_members* is True, do all members, else those given by
750         *self.options.members*.
751         """
752         # set current namespace for finding members
753         self.env.temp_data['autodoc:module'] = self.modname
754         if self.objpath:
755             self.env.temp_data['autodoc:class'] = self.objpath[0]
756 
757         want_all = all_members or self.options.inherited_members or \
758             self.options.members is ALL
759         # find out which members are documentable
760         members_check_module, members = self.get_object_members(want_all)
761 
762         # document non-skipped members
763         memberdocumenters = []  # type: List[Tuple[Documenter, bool]]
764         for (mname, member, isattr) in self.filter_members(members, want_all):
765             classes = [cls for cls in self.documenters.values()
766                        if cls.can_document_member(member, mname, isattr, self)]
767             if not classes:
768                 # don't know how to document this member
769                 continue
770             # prefer the documenter with the highest priority
771             classes.sort(key=lambda cls: cls.priority)
772             # give explicitly separated module name, so that members
773             # of inner classes can be documented
774             full_mname = self.modname + '::' + \
775                 '.'.join(self.objpath + [mname])
776             documenter = classes[-1](self.directive, full_mname, self.indent)
777             memberdocumenters.append((documenter, isattr))
778 
779         member_order = self.options.member_order or self.env.config.autodoc_member_order
780         memberdocumenters = self.sort_members(memberdocumenters, member_order)
781 
782         for documenter, isattr in memberdocumenters:
783             documenter.generate(
784                 all_members=True, real_modname=self.real_modname,
785                 check_module=members_check_module and not isattr)
786 
787         # reset current objects
788         self.env.temp_data['autodoc:module'] = None
789         self.env.temp_data['autodoc:class'] = None
790 
791     def sort_members(self, documenters: List[Tuple["Documenter", bool]],
792                      order: str) -> List[Tuple["Documenter", bool]]:
793         """Sort the given member list."""
794         if order == 'groupwise':
795             # sort by group; alphabetically within groups
796             documenters.sort(key=lambda e: (e[0].member_order, e[0].name))
797         elif order == 'bysource':
798             if self.analyzer:
799                 # sort by source order, by virtue of the module analyzer
800                 tagorder = self.analyzer.tagorder
801 
802                 def keyfunc(entry: Tuple[Documenter, bool]) -> int:
803                     fullname = entry[0].name.split('::')[1]
804                     return tagorder.get(fullname, len(tagorder))
805                 documenters.sort(key=keyfunc)
806             else:
807                 # Assume that member discovery order matches source order.
808                 # This is a reasonable assumption in Python 3.6 and up, where
809                 # module.__dict__ is insertion-ordered.
810                 pass
811         else:  # alphabetical
812             documenters.sort(key=lambda e: e[0].name)
813 
814         return documenters
815 
816     def generate(self, more_content: Any = None, real_modname: str = None,
817                  check_module: bool = False, all_members: bool = False) -> None:
818         """Generate reST for the object given by *self.name*, and possibly for
819         its members.
820 
821         If *more_content* is given, include that content. If *real_modname* is
822         given, use that module name to find attribute docs. If *check_module* is
823         True, only generate if the object is defined in the module name it is
824         imported from. If *all_members* is True, document all members.
825         """
826         if not self.parse_name():
827             # need a module to import
828             logger.warning(
829                 __('don\'t know which module to import for autodocumenting '
830                    '%r (try placing a "module" or "currentmodule" directive '
831                    'in the document, or giving an explicit module name)') %
832                 self.name, type='autodoc')
833             return
834 
835         # now, import the module and get object to document
836         if not self.import_object():
837             return
838 
839         # If there is no real module defined, figure out which to use.
840         # The real module is used in the module analyzer to look up the module
841         # where the attribute documentation would actually be found in.
842         # This is used for situations where you have a module that collects the
843         # functions and classes of internal submodules.
844         guess_modname = self.get_real_modname()
845         self.real_modname = real_modname or guess_modname
846 
847         # try to also get a source code analyzer for attribute docs
848         try:
849             self.analyzer = ModuleAnalyzer.for_module(self.real_modname)
850             # parse right now, to get PycodeErrors on parsing (results will
851             # be cached anyway)
852             self.analyzer.find_attr_docs()
853         except PycodeError as exc:
854             logger.debug('[autodoc] module analyzer failed: %s', exc)
855             # no source file -- e.g. for builtin and C modules
856             self.analyzer = None
857             # at least add the module.__file__ as a dependency
858             if hasattr(self.module, '__file__') and self.module.__file__:
859                 self.directive.filename_set.add(self.module.__file__)
860         else:
861             self.directive.filename_set.add(self.analyzer.srcname)
862 
863         if self.real_modname != guess_modname:
864             # Add module to dependency list if target object is defined in other module.
865             try:
866                 analyzer = ModuleAnalyzer.for_module(guess_modname)
867                 self.directive.filename_set.add(analyzer.srcname)
868             except PycodeError:
869                 pass
870 
871         # check __module__ of object (for members not given explicitly)
872         if check_module:
873             if not self.check_module():
874                 return
875 
876         sourcename = self.get_sourcename()
877 
878         # make sure that the result starts with an empty line.  This is
879         # necessary for some situations where another directive preprocesses
880         # reST and no starting newline is present
881         self.add_line('', sourcename)
882 
883         # format the object's signature, if any
884         try:
885             sig = self.format_signature()
886         except Exception as exc:
887             logger.warning(__('error while formatting signature for %s: %s'),
888                            self.fullname, exc, type='autodoc')
889             return
890 
891         # generate the directive header and options, if applicable
892         self.add_directive_header(sig)
893         self.add_line('', sourcename)
894 
895         # e.g. the module directive doesn't have content
896         self.indent += self.content_indent
897 
898         # add all content (from docstrings, attribute docs etc.)
899         self.add_content(more_content)
900 
901         # document members, if possible
902         self.document_members(all_members)
903 
904 
905 class ModuleDocumenter(Documenter):
906     """
907     Specialized Documenter subclass for modules.
908     """
909     objtype = 'module'
910     content_indent = ''
911     titles_allowed = True
912 
913     option_spec = {
914         'members': members_option, 'undoc-members': bool_option,
915         'noindex': bool_option, 'inherited-members': inherited_members_option,
916         'show-inheritance': bool_option, 'synopsis': identity,
917         'platform': identity, 'deprecated': bool_option,
918         'member-order': member_order_option, 'exclude-members': exclude_members_option,
919         'private-members': members_option, 'special-members': members_option,
920         'imported-members': bool_option, 'ignore-module-all': bool_option
921     }  # type: Dict[str, Callable]
922 
923     def __init__(self, *args: Any) -> None:
924         super().__init__(*args)
925         merge_members_option(self.options)
926         self.__all__ = None
927 
928     @classmethod
929     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
930                             ) -> bool:
931         # don't document submodules automatically
932         return False
933 
934     def resolve_name(self, modname: str, parents: Any, path: str, base: Any
935                      ) -> Tuple[str, List[str]]:
936         if modname is not None:
937             logger.warning(__('"::" in automodule name doesn\'t make sense'),
938                            type='autodoc')
939         return (path or '') + base, []
940 
941     def parse_name(self) -> bool:
942         ret = super().parse_name()
943         if self.args or self.retann:
944             logger.warning(__('signature arguments or return annotation '
945                               'given for automodule %s') % self.fullname,
946                            type='autodoc')
947         return ret
948 
949     def import_object(self, raiseerror: bool = False) -> bool:
950         def is_valid_module_all(__all__: Any) -> bool:
951             """Check the given *__all__* is valid for a module."""
952             if (isinstance(__all__, (list, tuple)) and
953                     all(isinstance(e, str) for e in __all__)):
954                 return True
955             else:
956                 return False
957 
958         ret = super().import_object(raiseerror)
959 
960         if not self.options.ignore_module_all:
961             __all__ = getattr(self.object, '__all__', None)
962             if is_valid_module_all(__all__):
963                 # valid __all__ found. copy it to self.__all__
964                 self.__all__ = __all__
965             elif __all__:
966                 # invalid __all__ found.
967                 logger.warning(__('__all__ should be a list of strings, not %r '
968                                   '(in module %s) -- ignoring __all__') %
969                                (__all__, self.fullname), type='autodoc')
970 
971         return ret
972 
973     def add_directive_header(self, sig: str) -> None:
974         Documenter.add_directive_header(self, sig)
975 
976         sourcename = self.get_sourcename()
977 
978         # add some module-specific options
979         if self.options.synopsis:
980             self.add_line('   :synopsis: ' + self.options.synopsis, sourcename)
981         if self.options.platform:
982             self.add_line('   :platform: ' + self.options.platform, sourcename)
983         if self.options.deprecated:
984             self.add_line('   :deprecated:', sourcename)
985 
986     def get_object_members(self, want_all: bool) -> Tuple[bool, List[Tuple[str, Any]]]:
987         if want_all:
988             if self.__all__:
989                 memberlist = self.__all__
990             else:
991                 # for implicit module members, check __module__ to avoid
992                 # documenting imported objects
993                 return True, get_module_members(self.object)
994         else:
995             memberlist = self.options.members or []
996         ret = []
997         for mname in memberlist:
998             try:
999                 ret.append((mname, safe_getattr(self.object, mname)))
1000             except AttributeError:
1001                 logger.warning(
1002                     __('missing attribute mentioned in :members: or __all__: '
1003                        'module %s, attribute %s') %
1004                     (safe_getattr(self.object, '__name__', '???'), mname),
1005                     type='autodoc'
1006                 )
1007         return False, ret
1008 
1009     def sort_members(self, documenters: List[Tuple["Documenter", bool]],
1010                      order: str) -> List[Tuple["Documenter", bool]]:
1011         if order == 'bysource' and self.__all__:
1012             # Sort alphabetically first (for members not listed on the __all__)
1013             documenters.sort(key=lambda e: e[0].name)
1014 
1015             # Sort by __all__
1016             def keyfunc(entry: Tuple[Documenter, bool]) -> int:
1017                 name = entry[0].name.split('::')[1]
1018                 if name in self.__all__:
1019                     return self.__all__.index(name)
1020                 else:
1021                     return len(self.__all__)
1022             documenters.sort(key=keyfunc)
1023 
1024             return documenters
1025         else:
1026             return super().sort_members(documenters, order)
1027 
1028 
1029 class ModuleLevelDocumenter(Documenter):
1030     """
1031     Specialized Documenter subclass for objects on module level (functions,
1032     classes, data/constants).
1033     """
1034     def resolve_name(self, modname: str, parents: Any, path: str, base: Any
1035                      ) -> Tuple[str, List[str]]:
1036         if modname is None:
1037             if path:
1038                 modname = path.rstrip('.')
1039             else:
1040                 # if documenting a toplevel object without explicit module,
1041                 # it can be contained in another auto directive ...
1042                 modname = self.env.temp_data.get('autodoc:module')
1043                 # ... or in the scope of a module directive
1044                 if not modname:
1045                     modname = self.env.ref_context.get('py:module')
1046                 # ... else, it stays None, which means invalid
1047         return modname, parents + [base]
1048 
1049 
1050 class ClassLevelDocumenter(Documenter):
1051     """
1052     Specialized Documenter subclass for objects on class level (methods,
1053     attributes).
1054     """
1055     def resolve_name(self, modname: str, parents: Any, path: str, base: Any
1056                      ) -> Tuple[str, List[str]]:
1057         if modname is None:
1058             if path:
1059                 mod_cls = path.rstrip('.')
1060             else:
1061                 mod_cls = None
1062                 # if documenting a class-level object without path,
1063                 # there must be a current class, either from a parent
1064                 # auto directive ...
1065                 mod_cls = self.env.temp_data.get('autodoc:class')
1066                 # ... or from a class directive
1067                 if mod_cls is None:
1068                     mod_cls = self.env.ref_context.get('py:class')
1069                 # ... if still None, there's no way to know
1070                 if mod_cls is None:
1071                     return None, []
1072             modname, sep, cls = mod_cls.rpartition('.')
1073             parents = [cls]
1074             # if the module name is still missing, get it like above
1075             if not modname:
1076                 modname = self.env.temp_data.get('autodoc:module')
1077             if not modname:
1078                 modname = self.env.ref_context.get('py:module')
1079             # ... else, it stays None, which means invalid
1080         return modname, parents + [base]
1081 
1082 
1083 class DocstringSignatureMixin:
1084     """
1085     Mixin for FunctionDocumenter and MethodDocumenter to provide the
1086     feature of reading the signature from the docstring.
1087     """
1088     _new_docstrings = None  # type: List[List[str]]
1089     _signatures = None      # type: List[str]
1090 
1091     def _find_signature(self, encoding: str = None) -> Tuple[str, str]:
1092         if encoding is not None:
1093             warnings.warn("The 'encoding' argument to autodoc.%s._find_signature() is "
1094                           "deprecated." % self.__class__.__name__,
1095                           RemovedInSphinx40Warning, stacklevel=2)
1096 
1097         # candidates of the object name
1098         valid_names = [self.objpath[-1]]  # type: ignore
1099         if isinstance(self, ClassDocumenter):
1100             valid_names.append('__init__')
1101             if hasattr(self.object, '__mro__'):
1102                 valid_names.extend(cls.__name__ for cls in self.object.__mro__)
1103 
1104         docstrings = self.get_doc()
1105         self._new_docstrings = docstrings[:]
1106         self._signatures = []
1107         result = None
1108         for i, doclines in enumerate(docstrings):
1109             for j, line in enumerate(doclines):
1110                 if not line:
1111                     # no lines in docstring, no match
1112                     break
1113 
1114                 if line.endswith('\\'):
1115                     multiline = True
1116                     line = line.rstrip('\\').rstrip()
1117                 else:
1118                     multiline = False
1119 
1120                 # match first line of docstring against signature RE
1121                 match = py_ext_sig_re.match(line)
1122                 if not match:
1123                     continue
1124                 exmod, path, base, args, retann = match.groups()
1125 
1126                 # the base name must match ours
1127                 if base not in valid_names:
1128                     continue
1129 
1130                 # re-prepare docstring to ignore more leading indentation
1131                 tab_width = self.directive.state.document.settings.tab_width  # type: ignore
1132                 self._new_docstrings[i] = prepare_docstring('\n'.join(doclines[j + 1:]),
1133                                                             tabsize=tab_width)
1134 
1135                 if result is None:
1136                     # first signature
1137                     result = args, retann
1138                 else:
1139                     # subsequent signatures
1140                     self._signatures.append("(%s) -> %s" % (args, retann))
1141 
1142                 if multiline:
1143                     # the signature have multiple signatures on docstring
1144                     continue
1145                 else:
1146                     # don't look any further
1147                     break
1148 
1149             if result:
1150                 # finish the loop when signature found
1151                 break
1152 
1153         return result
1154 
1155     def get_doc(self, encoding: str = None, ignore: int = None) -> List[List[str]]:
1156         if encoding is not None:
1157             warnings.warn("The 'encoding' argument to autodoc.%s.get_doc() is deprecated."
1158                           % self.__class__.__name__,
1159                           RemovedInSphinx40Warning, stacklevel=2)
1160         if self._new_docstrings is not None:
1161             return self._new_docstrings
1162         return super().get_doc(None, ignore)  # type: ignore
1163 
1164     def format_signature(self, **kwargs: Any) -> str:
1165         if self.args is None and self.env.config.autodoc_docstring_signature:  # type: ignore
1166             # only act if a signature is not explicitly given already, and if
1167             # the feature is enabled
1168             result = self._find_signature()
1169             if result is not None:
1170                 self.args, self.retann = result
1171         sig = super().format_signature(**kwargs)  # type: ignore
1172         if self._signatures:
1173             return "\n".join([sig] + self._signatures)
1174         else:
1175             return sig
1176 
1177 
1178 class DocstringStripSignatureMixin(DocstringSignatureMixin):
1179     """
1180     Mixin for AttributeDocumenter to provide the
1181     feature of stripping any function signature from the docstring.
1182     """
1183     def format_signature(self, **kwargs: Any) -> str:
1184         if self.args is None and self.env.config.autodoc_docstring_signature:  # type: ignore
1185             # only act if a signature is not explicitly given already, and if
1186             # the feature is enabled
1187             result = self._find_signature()
1188             if result is not None:
1189                 # Discarding _args is a only difference with
1190                 # DocstringSignatureMixin.format_signature.
1191                 # Documenter.format_signature use self.args value to format.
1192                 _args, self.retann = result
1193         return super().format_signature(**kwargs)
1194 
1195 
1196 class FunctionDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # type: ignore
1197     """
1198     Specialized Documenter subclass for functions.
1199     """
1200     objtype = 'function'
1201     member_order = 30
1202 
1203     @classmethod
1204     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
1205                             ) -> bool:
1206         # supports functions, builtins and bound methods exported at the module level
1207         return (inspect.isfunction(member) or inspect.isbuiltin(member) or
1208                 (inspect.isroutine(member) and isinstance(parent, ModuleDocumenter)))
1209 
1210     def format_args(self, **kwargs: Any) -> str:
1211         if self.env.config.autodoc_typehints in ('none', 'description'):
1212             kwargs.setdefault('show_annotation', False)
1213 
1214         try:
1215             self.env.app.emit('autodoc-before-process-signature', self.object, False)
1216             sig = inspect.signature(self.object, follow_wrapped=True,
1217                                     type_aliases=self.env.config.autodoc_type_aliases)
1218             args = stringify_signature(sig, **kwargs)
1219         except TypeError as exc:
1220             logger.warning(__("Failed to get a function signature for %s: %s"),
1221                            self.fullname, exc)
1222             return None
1223         except ValueError:
1224             args = ''
1225 
1226         if self.env.config.strip_signature_backslash:
1227             # escape backslashes for reST
1228             args = args.replace('\\', '\\\\')
1229         return args
1230 
1231     def document_members(self, all_members: bool = False) -> None:
1232         pass
1233 
1234     def add_directive_header(self, sig: str) -> None:
1235         sourcename = self.get_sourcename()
1236         super().add_directive_header(sig)
1237 
1238         if inspect.iscoroutinefunction(self.object):
1239             self.add_line('   :async:', sourcename)
1240 
1241     def format_signature(self, **kwargs: Any) -> str:
1242         sigs = []
1243         if self.analyzer and '.'.join(self.objpath) in self.analyzer.overloads:
1244             # Use signatures for overloaded functions instead of the implementation function.
1245             overloaded = True
1246         else:
1247             overloaded = False
1248             sig = super().format_signature(**kwargs)
1249             sigs.append(sig)
1250 
1251         if inspect.is_singledispatch_function(self.object):
1252             # append signature of singledispatch'ed functions
1253             for typ, func in self.object.registry.items():
1254                 if typ is object:
1255                     pass  # default implementation. skipped.
1256                 else:
1257                     self.annotate_to_first_argument(func, typ)
1258 
1259                     documenter = FunctionDocumenter(self.directive, '')
1260                     documenter.object = func
1261                     documenter.objpath = [None]
1262                     sigs.append(documenter.format_signature())
1263         if overloaded:
1264             __globals__ = safe_getattr(self.object, '__globals__', {})
1265             for overload in self.analyzer.overloads.get('.'.join(self.objpath)):
1266                 overload = evaluate_signature(overload, __globals__,
1267                                               self.env.config.autodoc_type_aliases)
1268 
1269                 sig = stringify_signature(overload, **kwargs)
1270                 sigs.append(sig)
1271 
1272         return "\n".join(sigs)
1273 
1274     def annotate_to_first_argument(self, func: Callable, typ: Type) -> None:
1275         """Annotate type hint to the first argument of function if needed."""
1276         try:
1277             sig = inspect.signature(func, type_aliases=self.env.config.autodoc_type_aliases)
1278         except TypeError as exc:
1279             logger.warning(__("Failed to get a function signature for %s: %s"),
1280                            self.fullname, exc)
1281             return
1282         except ValueError:
1283             return
1284 
1285         if len(sig.parameters) == 0:
1286             return
1287 
1288         params = list(sig.parameters.values())
1289         if params[0].annotation is Parameter.empty:
1290             params[0] = params[0].replace(annotation=typ)
1291             try:
1292                 func.__signature__ = sig.replace(parameters=params)  # type: ignore
1293             except TypeError:
1294                 # failed to update signature (ex. built-in or extension types)
1295                 return
1296 
1297 
1298 class SingledispatchFunctionDocumenter(FunctionDocumenter):
1299     """
1300     Used to be a specialized Documenter subclass for singledispatch'ed functions.
1301 
1302     Retained for backwards compatibility, now does the same as the FunctionDocumenter
1303     """
1304 
1305     def __init__(self, *args: Any, **kwargs: Any) -> None:
1306         warnings.warn("%s is deprecated." % self.__class__.__name__,
1307                       RemovedInSphinx50Warning, stacklevel=2)
1308         super().__init__(*args, **kwargs)
1309 
1310 
1311 class DecoratorDocumenter(FunctionDocumenter):
1312     """
1313     Specialized Documenter subclass for decorator functions.
1314     """
1315     objtype = 'decorator'
1316 
1317     # must be lower than FunctionDocumenter
1318     priority = -1
1319 
1320     def format_args(self, **kwargs: Any) -> Any:
1321         args = super().format_args(**kwargs)
1322         if ',' in args:
1323             return args
1324         else:
1325             return None
1326 
1327 
1328 # Types which have confusing metaclass signatures it would be best not to show.
1329 # These are listed by name, rather than storing the objects themselves, to avoid
1330 # needing to import the modules.
1331 _METACLASS_CALL_BLACKLIST = [
1332     'enum.EnumMeta.__call__',
1333 ]
1334 
1335 
1336 # Types whose __new__ signature is a pass-thru.
1337 _CLASS_NEW_BLACKLIST = [
1338     'typing.Generic.__new__',
1339 ]
1340 
1341 
1342 class ClassDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # type: ignore
1343     """
1344     Specialized Documenter subclass for classes.
1345     """
1346     objtype = 'class'
1347     member_order = 20
1348     option_spec = {
1349         'members': members_option, 'undoc-members': bool_option,
1350         'noindex': bool_option, 'inherited-members': inherited_members_option,
1351         'show-inheritance': bool_option, 'member-order': member_order_option,
1352         'exclude-members': exclude_members_option,
1353         'private-members': members_option, 'special-members': members_option,
1354     }  # type: Dict[str, Callable]
1355 
1356     _signature_class = None  # type: Any
1357     _signature_method_name = None  # type: str
1358 
1359     def __init__(self, *args: Any) -> None:
1360         super().__init__(*args)
1361         merge_members_option(self.options)
1362 
1363     @classmethod
1364     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
1365                             ) -> bool:
1366         return isinstance(member, type)
1367 
1368     def import_object(self, raiseerror: bool = False) -> bool:
1369         ret = super().import_object(raiseerror)
1370         # if the class is documented under another name, document it
1371         # as data/attribute
1372         if ret:
1373             if hasattr(self.object, '__name__'):
1374                 self.doc_as_attr = (self.objpath[-1] != self.object.__name__)
1375             else:
1376                 self.doc_as_attr = True
1377         return ret
1378 
1379     def _get_signature(self) -> Tuple[Optional[Any], Optional[str], Optional[Signature]]:
1380         def get_user_defined_function_or_method(obj: Any, attr: str) -> Any:
1381             """ Get the `attr` function or method from `obj`, if it is user-defined. """
1382             if inspect.is_builtin_class_method(obj, attr):
1383                 return None
1384             attr = self.get_attr(obj, attr, None)
1385             if not (inspect.ismethod(attr) or inspect.isfunction(attr)):
1386                 return None
1387             return attr
1388 
1389         # This sequence is copied from inspect._signature_from_callable.
1390         # ValueError means that no signature could be found, so we keep going.
1391 
1392         # First, let's see if it has an overloaded __call__ defined
1393         # in its metaclass
1394         call = get_user_defined_function_or_method(type(self.object), '__call__')
1395 
1396         if call is not None:
1397             if "{0.__module__}.{0.__qualname__}".format(call) in _METACLASS_CALL_BLACKLIST:
1398                 call = None
1399 
1400         if call is not None:
1401             self.env.app.emit('autodoc-before-process-signature', call, True)
1402             try:
1403                 sig = inspect.signature(call, bound_method=True,
1404                                         type_aliases=self.env.config.autodoc_type_aliases)
1405                 return type(self.object), '__call__', sig
1406             except ValueError:
1407                 pass
1408 
1409         # Now we check if the 'obj' class has a '__new__' method
1410         new = get_user_defined_function_or_method(self.object, '__new__')
1411 
1412         if new is not None:
1413             if "{0.__module__}.{0.__qualname__}".format(new) in _CLASS_NEW_BLACKLIST:
1414                 new = None
1415 
1416         if new is not None:
1417             self.env.app.emit('autodoc-before-process-signature', new, True)
1418             try:
1419                 sig = inspect.signature(new, bound_method=True,
1420                                         type_aliases=self.env.config.autodoc_type_aliases)
1421                 return self.object, '__new__', sig
1422             except ValueError:
1423                 pass
1424 
1425         # Finally, we should have at least __init__ implemented
1426         init = get_user_defined_function_or_method(self.object, '__init__')
1427         if init is not None:
1428             self.env.app.emit('autodoc-before-process-signature', init, True)
1429             try:
1430                 sig = inspect.signature(init, bound_method=True,
1431                                         type_aliases=self.env.config.autodoc_type_aliases)
1432                 return self.object, '__init__', sig
1433             except ValueError:
1434                 pass
1435 
1436         # None of the attributes are user-defined, so fall back to let inspect
1437         # handle it.
1438         # We don't know the exact method that inspect.signature will read
1439         # the signature from, so just pass the object itself to our hook.
1440         self.env.app.emit('autodoc-before-process-signature', self.object, False)
1441         try:
1442             sig = inspect.signature(self.object, bound_method=False,
1443                                     type_aliases=self.env.config.autodoc_type_aliases)
1444             return None, None, sig
1445         except ValueError:
1446             pass
1447 
1448         # Still no signature: happens e.g. for old-style classes
1449         # with __init__ in C and no `__text_signature__`.
1450         return None, None, None
1451 
1452     def format_args(self, **kwargs: Any) -> str:
1453         if self.env.config.autodoc_typehints in ('none', 'description'):
1454             kwargs.setdefault('show_annotation', False)
1455 
1456         try:
1457             self._signature_class, self._signature_method_name, sig = self._get_signature()
1458         except TypeError as exc:
1459             # __signature__ attribute contained junk
1460             logger.warning(__("Failed to get a constructor signature for %s: %s"),
1461                            self.fullname, exc)
1462             return None
1463 
1464         if sig is None:
1465             return None
1466 
1467         return stringify_signature(sig, show_return_annotation=False, **kwargs)
1468 
1469     def format_signature(self, **kwargs: Any) -> str:
1470         if self.doc_as_attr:
1471             return ''
1472 
1473         sig = super().format_signature()
1474 
1475         overloaded = False
1476         qualname = None
1477         # TODO: recreate analyzer for the module of class (To be clear, owner of the method)
1478         if self._signature_class and self._signature_method_name and self.analyzer:
1479             qualname = '.'.join([self._signature_class.__qualname__,
1480                                  self._signature_method_name])
1481             if qualname in self.analyzer.overloads:
1482                 overloaded = True
1483 
1484         sigs = []
1485         if overloaded:
1486             # Use signatures for overloaded methods instead of the implementation method.
1487             method = safe_getattr(self._signature_class, self._signature_method_name, None)
1488             __globals__ = safe_getattr(method, '__globals__', {})
1489             for overload in self.analyzer.overloads.get(qualname):
1490                 overload = evaluate_signature(overload, __globals__,
1491                                               self.env.config.autodoc_type_aliases)
1492 
1493                 parameters = list(overload.parameters.values())
1494                 overload = overload.replace(parameters=parameters[1:],
1495                                             return_annotation=Parameter.empty)
1496                 sig = stringify_signature(overload, **kwargs)
1497                 sigs.append(sig)
1498         else:
1499             sigs.append(sig)
1500 
1501         return "\n".join(sigs)
1502 
1503     def add_directive_header(self, sig: str) -> None:
1504         sourcename = self.get_sourcename()
1505 
1506         if self.doc_as_attr:
1507             self.directivetype = 'attribute'
1508         super().add_directive_header(sig)
1509 
1510         if self.analyzer and '.'.join(self.objpath) in self.analyzer.finals:
1511             self.add_line('   :final:', sourcename)
1512 
1513         # add inheritance info, if wanted
1514         if not self.doc_as_attr and self.options.show_inheritance:
1515             sourcename = self.get_sourcename()
1516             self.add_line('', sourcename)
1517             if hasattr(self.object, '__bases__') and len(self.object.__bases__):
1518                 bases = [':class:`%s`' % b.__name__
1519                          if b.__module__ in ('__builtin__', 'builtins')
1520                          else ':class:`%s.%s`' % (b.__module__, b.__qualname__)
1521                          for b in self.object.__bases__]
1522                 self.add_line('   ' + _('Bases: %s') % ', '.join(bases),
1523                               sourcename)
1524 
1525     def get_doc(self, encoding: str = None, ignore: int = None) -> List[List[str]]:
1526         if encoding is not None:
1527             warnings.warn("The 'encoding' argument to autodoc.%s.get_doc() is deprecated."
1528                           % self.__class__.__name__,
1529                           RemovedInSphinx40Warning, stacklevel=2)
1530         lines = getattr(self, '_new_docstrings', None)
1531         if lines is not None:
1532             return lines
1533 
1534         content = self.env.config.autoclass_content
1535 
1536         docstrings = []
1537         attrdocstring = self.get_attr(self.object, '__doc__', None)
1538         if attrdocstring:
1539             docstrings.append(attrdocstring)
1540 
1541         # for classes, what the "docstring" is can be controlled via a
1542         # config value; the default is only the class docstring
1543         if content in ('both', 'init'):
1544             __init__ = self.get_attr(self.object, '__init__', None)
1545             initdocstring = getdoc(__init__, self.get_attr,
1546                                    self.env.config.autodoc_inherit_docstrings,
1547                                    self.parent, self.object_name)
1548             # for new-style classes, no __init__ means default __init__
1549             if (initdocstring is not None and
1550                 (initdocstring == object.__init__.__doc__ or  # for pypy
1551                  initdocstring.strip() == object.__init__.__doc__)):  # for !pypy
1552                 initdocstring = None
1553             if not initdocstring:
1554                 # try __new__
1555                 __new__ = self.get_attr(self.object, '__new__', None)
1556                 initdocstring = getdoc(__new__, self.get_attr,
1557                                        self.env.config.autodoc_inherit_docstrings,
1558                                        self.parent, self.object_name)
1559                 # for new-style classes, no __new__ means default __new__
1560                 if (initdocstring is not None and
1561                     (initdocstring == object.__new__.__doc__ or  # for pypy
1562                      initdocstring.strip() == object.__new__.__doc__)):  # for !pypy
1563                     initdocstring = None
1564             if initdocstring:
1565                 if content == 'init':
1566                     docstrings = [initdocstring]
1567                 else:
1568                     docstrings.append(initdocstring)
1569 
1570         tab_width = self.directive.state.document.settings.tab_width
1571         return [prepare_docstring(docstring, ignore, tab_width) for docstring in docstrings]
1572 
1573     def add_content(self, more_content: Any, no_docstring: bool = False) -> None:
1574         if self.doc_as_attr:
1575             classname = safe_getattr(self.object, '__qualname__', None)
1576             if not classname:
1577                 classname = safe_getattr(self.object, '__name__', None)
1578             if classname:
1579                 module = safe_getattr(self.object, '__module__', None)
1580                 parentmodule = safe_getattr(self.parent, '__module__', None)
1581                 if module and module != parentmodule:
1582                     classname = str(module) + '.' + str(classname)
1583                 content = StringList([_('alias of :class:`%s`') % classname], source='')
1584                 super().add_content(content, no_docstring=True)
1585         else:
1586             super().add_content(more_content)
1587 
1588     def document_members(self, all_members: bool = False) -> None:
1589         if self.doc_as_attr:
1590             return
1591         super().document_members(all_members)
1592 
1593     def generate(self, more_content: Any = None, real_modname: str = None,
1594                  check_module: bool = False, all_members: bool = False) -> None:
1595         # Do not pass real_modname and use the name from the __module__
1596         # attribute of the class.
1597         # If a class gets imported into the module real_modname
1598         # the analyzer won't find the source of the class, if
1599         # it looks in real_modname.
1600         return super().generate(more_content=more_content,
1601                                 check_module=check_module,
1602                                 all_members=all_members)
1603 
1604 
1605 class ExceptionDocumenter(ClassDocumenter):
1606     """
1607     Specialized ClassDocumenter subclass for exceptions.
1608     """
1609     objtype = 'exception'
1610     member_order = 10
1611 
1612     # needs a higher priority than ClassDocumenter
1613     priority = 10
1614 
1615     @classmethod
1616     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
1617                             ) -> bool:
1618         return isinstance(member, type) and issubclass(member, BaseException)
1619 
1620 
1621 class DataDocumenter(ModuleLevelDocumenter):
1622     """
1623     Specialized Documenter subclass for data items.
1624     """
1625     objtype = 'data'
1626     member_order = 40
1627     priority = -10
1628     option_spec = dict(ModuleLevelDocumenter.option_spec)
1629     option_spec["annotation"] = annotation_option
1630 
1631     @classmethod
1632     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
1633                             ) -> bool:
1634         return isinstance(parent, ModuleDocumenter) and isattr
1635 
1636     def add_directive_header(self, sig: str) -> None:
1637         super().add_directive_header(sig)
1638         sourcename = self.get_sourcename()
1639         if not self.options.annotation:
1640             # obtain annotation for this data
1641             try:
1642                 annotations = get_type_hints(self.parent)
1643             except NameError:
1644                 # Failed to evaluate ForwardRef (maybe TYPE_CHECKING)
1645                 annotations = safe_getattr(self.parent, '__annotations__', {})
1646             except TypeError:
1647                 annotations = {}
1648             except KeyError:
1649                 # a broken class found (refs: https://github.com/sphinx-doc/sphinx/issues/8084)
1650                 annotations = {}
1651             except AttributeError:
1652                 # AttributeError is raised on 3.5.2 (fixed by 3.5.3)
1653                 annotations = {}
1654 
1655             if self.objpath[-1] in annotations:
1656                 objrepr = stringify_typehint(annotations.get(self.objpath[-1]))
1657                 self.add_line('   :type: ' + objrepr, sourcename)
1658             else:
1659                 key = ('.'.join(self.objpath[:-1]), self.objpath[-1])
1660                 if self.analyzer and key in self.analyzer.annotations:
1661                     self.add_line('   :type: ' + self.analyzer.annotations[key],
1662                                   sourcename)
1663 
1664             try:
1665                 if self.object is UNINITIALIZED_ATTR:
1666                     pass
1667                 else:
1668                     objrepr = object_description(self.object)
1669                     self.add_line('   :value: ' + objrepr, sourcename)
1670             except ValueError:
1671                 pass
1672         elif self.options.annotation is SUPPRESS:
1673             pass
1674         else:
1675             self.add_line('   :annotation: %s' % self.options.annotation,
1676                           sourcename)
1677 
1678     def document_members(self, all_members: bool = False) -> None:
1679         pass
1680 
1681     def get_real_modname(self) -> str:
1682         return self.get_attr(self.parent or self.object, '__module__', None) \
1683             or self.modname
1684 
1685 
1686 class DataDeclarationDocumenter(DataDocumenter):
1687     """
1688     Specialized Documenter subclass for data that cannot be imported
1689     because they are declared without initial value (refs: PEP-526).
1690     """
1691     objtype = 'datadecl'
1692     directivetype = 'data'
1693     member_order = 60
1694 
1695     # must be higher than AttributeDocumenter
1696     priority = 11
1697 
1698     @classmethod
1699     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
1700                             ) -> bool:
1701         """This documents only INSTANCEATTR members."""
1702         return (isinstance(parent, ModuleDocumenter) and
1703                 isattr and
1704                 member is INSTANCEATTR)
1705 
1706     def import_object(self, raiseerror: bool = False) -> bool:
1707         """Never import anything."""
1708         # disguise as a data
1709         self.objtype = 'data'
1710         self.object = UNINITIALIZED_ATTR
1711         try:
1712             # import module to obtain type annotation
1713             self.parent = importlib.import_module(self.modname)
1714         except ImportError:
1715             pass
1716 
1717         return True
1718 
1719     def add_content(self, more_content: Any, no_docstring: bool = False) -> None:
1720         """Never try to get a docstring from the object."""
1721         super().add_content(more_content, no_docstring=True)
1722 
1723 
1724 class GenericAliasDocumenter(DataDocumenter):
1725     """
1726     Specialized Documenter subclass for GenericAliases.
1727     """
1728 
1729     objtype = 'genericalias'
1730     directivetype = 'data'
1731     priority = DataDocumenter.priority + 1
1732 
1733     @classmethod
1734     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
1735                             ) -> bool:
1736         return inspect.isgenericalias(member)
1737 
1738     def add_directive_header(self, sig: str) -> None:
1739         self.options = Options(self.options)
1740         self.options['annotation'] = SUPPRESS
1741         super().add_directive_header(sig)
1742 
1743     def add_content(self, more_content: Any, no_docstring: bool = False) -> None:
1744         name = stringify_typehint(self.object)
1745         content = StringList([_('alias of %s') % name], source='')
1746         super().add_content(content)
1747 
1748 
1749 class TypeVarDocumenter(DataDocumenter):
1750     """
1751     Specialized Documenter subclass for TypeVars.
1752     """
1753 
1754     objtype = 'typevar'
1755     directivetype = 'data'
1756     priority = DataDocumenter.priority + 1
1757 
1758     @classmethod
1759     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
1760                             ) -> bool:
1761         return isinstance(member, TypeVar) and isattr  # type: ignore
1762 
1763     def add_directive_header(self, sig: str) -> None:
1764         self.options = Options(self.options)
1765         self.options['annotation'] = SUPPRESS
1766         super().add_directive_header(sig)
1767 
1768     def get_doc(self, encoding: str = None, ignore: int = None) -> List[List[str]]:
1769         if ignore is not None:
1770             warnings.warn("The 'ignore' argument to autodoc.%s.get_doc() is deprecated."
1771                           % self.__class__.__name__,
1772                           RemovedInSphinx50Warning, stacklevel=2)
1773 
1774         if self.object.__doc__ != TypeVar.__doc__:
1775             return super().get_doc()
1776         else:
1777             return []
1778 
1779     def add_content(self, more_content: Any, no_docstring: bool = False) -> None:
1780         attrs = [repr(self.object.__name__)]
1781         for constraint in self.object.__constraints__:
1782             attrs.append(stringify_typehint(constraint))
1783         if self.object.__covariant__:
1784             attrs.append("covariant=True")
1785         if self.object.__contravariant__:
1786             attrs.append("contravariant=True")
1787 
1788         content = StringList([_('alias of TypeVar(%s)') % ", ".join(attrs)], source='')
1789         super().add_content(content)
1790 
1791 
1792 class MethodDocumenter(DocstringSignatureMixin, ClassLevelDocumenter):  # type: ignore
1793     """
1794     Specialized Documenter subclass for methods (normal, static and class).
1795     """
1796     objtype = 'method'
1797     directivetype = 'method'
1798     member_order = 50
1799     priority = 1  # must be more than FunctionDocumenter
1800 
1801     @classmethod
1802     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
1803                             ) -> bool:
1804         return inspect.isroutine(member) and \
1805             not isinstance(parent, ModuleDocumenter)
1806 
1807     def import_object(self, raiseerror: bool = False) -> bool:
1808         ret = super().import_object(raiseerror)
1809         if not ret:
1810             return ret
1811 
1812         # to distinguish classmethod/staticmethod
1813         obj = self.parent.__dict__.get(self.object_name)
1814         if obj is None:
1815             obj = self.object
1816 
1817         if (inspect.isclassmethod(obj) or
1818                 inspect.isstaticmethod(obj, cls=self.parent, name=self.object_name)):
1819             # document class and static members before ordinary ones
1820             self.member_order = self.member_order - 1
1821 
1822         return ret
1823 
1824     def format_args(self, **kwargs: Any) -> str:
1825         if self.env.config.autodoc_typehints in ('none', 'description'):
1826             kwargs.setdefault('show_annotation', False)
1827 
1828         try:
1829             if self.object == object.__init__ and self.parent != object:
1830                 # Classes not having own __init__() method are shown as no arguments.
1831                 #
1832                 # Note: The signature of object.__init__() is (self, /, *args, **kwargs).
1833                 #       But it makes users confused.
1834                 args = '()'
1835             else:
1836                 if inspect.isstaticmethod(self.object, cls=self.parent, name=self.object_name):
1837                     self.env.app.emit('autodoc-before-process-signature', self.object, False)
1838                     sig = inspect.signature(self.object, bound_method=False,
1839                                             type_aliases=self.env.config.autodoc_type_aliases)
1840                 else:
1841                     self.env.app.emit('autodoc-before-process-signature', self.object, True)
1842                     sig = inspect.signature(self.object, bound_method=True,
1843                                             follow_wrapped=True,
1844                                             type_aliases=self.env.config.autodoc_type_aliases)
1845                 args = stringify_signature(sig, **kwargs)
1846         except TypeError as exc:
1847             logger.warning(__("Failed to get a method signature for %s: %s"),
1848                            self.fullname, exc)
1849             return None
1850         except ValueError:
1851             args = ''
1852 
1853         if self.env.config.strip_signature_backslash:
1854             # escape backslashes for reST
1855             args = args.replace('\\', '\\\\')
1856         return args
1857 
1858     def add_directive_header(self, sig: str) -> None:
1859         super().add_directive_header(sig)
1860 
1861         sourcename = self.get_sourcename()
1862         obj = self.parent.__dict__.get(self.object_name, self.object)
1863         if inspect.isabstractmethod(obj):
1864             self.add_line('   :abstractmethod:', sourcename)
1865         if inspect.iscoroutinefunction(obj):
1866             self.add_line('   :async:', sourcename)
1867         if inspect.isclassmethod(obj):
1868             self.add_line('   :classmethod:', sourcename)
1869         if inspect.isstaticmethod(obj, cls=self.parent, name=self.object_name):
1870             self.add_line('   :staticmethod:', sourcename)
1871         if self.analyzer and '.'.join(self.objpath) in self.analyzer.finals:
1872             self.add_line('   :final:', sourcename)
1873 
1874     def document_members(self, all_members: bool = False) -> None:
1875         pass
1876 
1877     def format_signature(self, **kwargs: Any) -> str:
1878         sigs = []
1879         if self.analyzer and '.'.join(self.objpath) in self.analyzer.overloads:
1880             # Use signatures for overloaded methods instead of the implementation method.
1881             overloaded = True
1882         else:
1883             overloaded = False
1884             sig = super().format_signature(**kwargs)
1885             sigs.append(sig)
1886 
1887         meth = self.parent.__dict__.get(self.objpath[-1])
1888         if inspect.is_singledispatch_method(meth):
1889             # append signature of singledispatch'ed functions
1890             for typ, func in meth.dispatcher.registry.items():
1891                 if typ is object:
1892                     pass  # default implementation. skipped.
1893                 else:
1894                     self.annotate_to_first_argument(func, typ)
1895 
1896                     documenter = MethodDocumenter(self.directive, '')
1897                     documenter.parent = self.parent
1898                     documenter.object = func
1899                     documenter.objpath = [None]
1900                     sigs.append(documenter.format_signature())
1901         if overloaded:
1902             __globals__ = safe_getattr(self.object, '__globals__', {})
1903             for overload in self.analyzer.overloads.get('.'.join(self.objpath)):
1904                 overload = evaluate_signature(overload, __globals__,
1905                                               self.env.config.autodoc_type_aliases)
1906 
1907                 if not inspect.isstaticmethod(self.object, cls=self.parent,
1908                                               name=self.object_name):
1909                     parameters = list(overload.parameters.values())
1910                     overload = overload.replace(parameters=parameters[1:])
1911                 sig = stringify_signature(overload, **kwargs)
1912                 sigs.append(sig)
1913 
1914         return "\n".join(sigs)
1915 
1916     def annotate_to_first_argument(self, func: Callable, typ: Type) -> None:
1917         """Annotate type hint to the first argument of function if needed."""
1918         try:
1919             sig = inspect.signature(func, type_aliases=self.env.config.autodoc_type_aliases)
1920         except TypeError as exc:
1921             logger.warning(__("Failed to get a method signature for %s: %s"),
1922                            self.fullname, exc)
1923             return
1924         except ValueError:
1925             return
1926         if len(sig.parameters) == 1:
1927             return
1928 
1929         params = list(sig.parameters.values())
1930         if params[1].annotation is Parameter.empty:
1931             params[1] = params[1].replace(annotation=typ)
1932             try:
1933                 func.__signature__ = sig.replace(parameters=params)  # type: ignore
1934             except TypeError:
1935                 # failed to update signature (ex. built-in or extension types)
1936                 return
1937 
1938 
1939 class SingledispatchMethodDocumenter(MethodDocumenter):
1940     """
1941     Used to be a specialized Documenter subclass for singledispatch'ed methods.
1942 
1943     Retained for backwards compatibility, now does the same as the MethodDocumenter
1944     """
1945 
1946     def __init__(self, *args: Any, **kwargs: Any) -> None:
1947         warnings.warn("%s is deprecated." % self.__class__.__name__,
1948                       RemovedInSphinx50Warning, stacklevel=2)
1949         super().__init__(*args, **kwargs)
1950 
1951 
1952 class AttributeDocumenter(DocstringStripSignatureMixin, ClassLevelDocumenter):  # type: ignore
1953     """
1954     Specialized Documenter subclass for attributes.
1955     """
1956     objtype = 'attribute'
1957     member_order = 60
1958     option_spec = dict(ModuleLevelDocumenter.option_spec)
1959     option_spec["annotation"] = annotation_option
1960 
1961     # must be higher than the MethodDocumenter, else it will recognize
1962     # some non-data descriptors as methods
1963     priority = 10
1964 
1965     @staticmethod
1966     def is_function_or_method(obj: Any) -> bool:
1967         return inspect.isfunction(obj) or inspect.isbuiltin(obj) or inspect.ismethod(obj)
1968 
1969     @classmethod
1970     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
1971                             ) -> bool:
1972         if inspect.isattributedescriptor(member):
1973             return True
1974         elif (not isinstance(parent, ModuleDocumenter) and
1975               not inspect.isroutine(member) and
1976               not isinstance(member, type)):
1977             return True
1978         else:
1979             return False
1980 
1981     def document_members(self, all_members: bool = False) -> None:
1982         pass
1983 
1984     def isinstanceattribute(self) -> bool:
1985         """Check the subject is an instance attribute."""
1986         try:
1987             analyzer = ModuleAnalyzer.for_module(self.modname)
1988             attr_docs = analyzer.find_attr_docs()
1989             if self.objpath:
1990                 key = ('.'.join(self.objpath[:-1]), self.objpath[-1])
1991                 if key in attr_docs:
1992                     return True
1993 
1994             return False
1995         except PycodeError:
1996             return False
1997 
1998     def import_object(self, raiseerror: bool = False) -> bool:
1999         try:
2000             ret = super().import_object(raiseerror=True)
2001             if inspect.isenumattribute(self.object):
2002                 self.object = self.object.value
2003             if inspect.isattributedescriptor(self.object):
2004                 self._datadescriptor = True
2005             else:
2006                 # if it's not a data descriptor
2007                 self._datadescriptor = False
2008         except ImportError as exc:
2009             if self.isinstanceattribute():
2010                 self.object = INSTANCEATTR
2011                 self._datadescriptor = False
2012                 ret = True
2013             elif raiseerror:
2014                 raise
2015             else:
2016                 logger.warning(exc.args[0], type='autodoc', subtype='import_object')
2017                 self.env.note_reread()
2018                 ret = False
2019 
2020         return ret
2021 
2022     def get_real_modname(self) -> str:
2023         return self.get_attr(self.parent or self.object, '__module__', None) \
2024             or self.modname
2025 
2026     def add_directive_header(self, sig: str) -> None:
2027         super().add_directive_header(sig)
2028         sourcename = self.get_sourcename()
2029         if not self.options.annotation:
2030             # obtain type annotation for this attribute
2031             try:
2032                 annotations = get_type_hints(self.parent)
2033             except NameError:
2034                 # Failed to evaluate ForwardRef (maybe TYPE_CHECKING)
2035                 annotations = safe_getattr(self.parent, '__annotations__', {})
2036             except TypeError:
2037                 annotations = {}
2038             except KeyError:
2039                 # a broken class found (refs: https://github.com/sphinx-doc/sphinx/issues/8084)
2040                 annotations = {}
2041             except AttributeError:
2042                 # AttributeError is raised on 3.5.2 (fixed by 3.5.3)
2043                 annotations = {}
2044 
2045             if self.objpath[-1] in annotations:
2046                 objrepr = stringify_typehint(annotations.get(self.objpath[-1]))
2047                 self.add_line('   :type: ' + objrepr, sourcename)
2048             else:
2049                 key = ('.'.join(self.objpath[:-1]), self.objpath[-1])
2050                 if self.analyzer and key in self.analyzer.annotations:
2051                     self.add_line('   :type: ' + self.analyzer.annotations[key],
2052                                   sourcename)
2053 
2054             # data descriptors do not have useful values
2055             if not self._datadescriptor:
2056                 try:
2057                     if self.object is INSTANCEATTR:
2058                         pass
2059                     else:
2060                         objrepr = object_description(self.object)
2061                         self.add_line('   :value: ' + objrepr, sourcename)
2062                 except ValueError:
2063                     pass
2064         elif self.options.annotation is SUPPRESS:
2065             pass
2066         else:
2067             self.add_line('   :annotation: %s' % self.options.annotation, sourcename)
2068 
2069     def get_doc(self, encoding: str = None, ignore: int = None) -> List[List[str]]:
2070         try:
2071             # Disable `autodoc_inherit_docstring` temporarily to avoid to obtain
2072             # a docstring from the value which descriptor returns unexpectedly.
2073             # ref: https://github.com/sphinx-doc/sphinx/issues/7805
2074             orig = self.env.config.autodoc_inherit_docstrings
2075             self.env.config.autodoc_inherit_docstrings = False  # type: ignore
2076             return super().get_doc(encoding, ignore)
2077         finally:
2078             self.env.config.autodoc_inherit_docstrings = orig  # type: ignore
2079 
2080     def add_content(self, more_content: Any, no_docstring: bool = False) -> None:
2081         if not self._datadescriptor:
2082             # if it's not a data descriptor, its docstring is very probably the
2083             # wrong thing to display
2084             no_docstring = True
2085         super().add_content(more_content, no_docstring)
2086 
2087 
2088 class PropertyDocumenter(DocstringStripSignatureMixin, ClassLevelDocumenter):  # type: ignore
2089     """
2090     Specialized Documenter subclass for properties.
2091     """
2092     objtype = 'property'
2093     directivetype = 'method'
2094     member_order = 60
2095 
2096     # before AttributeDocumenter
2097     priority = AttributeDocumenter.priority + 1
2098 
2099     @classmethod
2100     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
2101                             ) -> bool:
2102         return inspect.isproperty(member) and isinstance(parent, ClassDocumenter)
2103 
2104     def document_members(self, all_members: bool = False) -> None:
2105         pass
2106 
2107     def get_real_modname(self) -> str:
2108         return self.get_attr(self.parent or self.object, '__module__', None) \
2109             or self.modname
2110 
2111     def add_directive_header(self, sig: str) -> None:
2112         super().add_directive_header(sig)
2113         sourcename = self.get_sourcename()
2114         if inspect.isabstractmethod(self.object):
2115             self.add_line('   :abstractmethod:', sourcename)
2116         self.add_line('   :property:', sourcename)
2117 
2118 
2119 class InstanceAttributeDocumenter(AttributeDocumenter):
2120     """
2121     Specialized Documenter subclass for attributes that cannot be imported
2122     because they are instance attributes (e.g. assigned in __init__).
2123     """
2124     objtype = 'instanceattribute'
2125     directivetype = 'attribute'
2126     member_order = 60
2127 
2128     # must be higher than AttributeDocumenter
2129     priority = 11
2130 
2131     @classmethod
2132     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
2133                             ) -> bool:
2134         """This documents only INSTANCEATTR members."""
2135         return (not isinstance(parent, ModuleDocumenter) and
2136                 isattr and
2137                 member is INSTANCEATTR)
2138 
2139     def import_parent(self) -> Any:
2140         try:
2141             parent = importlib.import_module(self.modname)
2142             for name in self.objpath[:-1]:
2143                 parent = self.get_attr(parent, name)
2144 
2145             return parent
2146         except (ImportError, AttributeError):
2147             return None
2148 
2149     def import_object(self, raiseerror: bool = False) -> bool:
2150         """Never import anything."""
2151         # disguise as an attribute
2152         self.objtype = 'attribute'
2153         self.object = INSTANCEATTR
2154         self.parent = self.import_parent()
2155         self._datadescriptor = False
2156         return True
2157 
2158     def add_content(self, more_content: Any, no_docstring: bool = False) -> None:
2159         """Never try to get a docstring from the object."""
2160         super().add_content(more_content, no_docstring=True)
2161 
2162 
2163 class SlotsAttributeDocumenter(AttributeDocumenter):
2164     """
2165     Specialized Documenter subclass for attributes that cannot be imported
2166     because they are attributes in __slots__.
2167     """
2168     objtype = 'slotsattribute'
2169     directivetype = 'attribute'
2170     member_order = 60
2171 
2172     # must be higher than AttributeDocumenter
2173     priority = 11
2174 
2175     @classmethod
2176     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
2177                             ) -> bool:
2178         """This documents only SLOTSATTR members."""
2179         return member is SLOTSATTR
2180 
2181     def import_object(self, raiseerror: bool = False) -> bool:
2182         """Never import anything."""
2183         # disguise as an attribute
2184         self.objtype = 'attribute'
2185         self._datadescriptor = True
2186 
2187         with mock(self.env.config.autodoc_mock_imports):
2188             try:
2189                 ret = import_object(self.modname, self.objpath[:-1], 'class',
2190                                     attrgetter=self.get_attr,
2191                                     warningiserror=self.env.config.autodoc_warningiserror)
2192                 self.module, _, _, self.parent = ret
2193                 return True
2194             except ImportError as exc:
2195                 if raiseerror:
2196                     raise
2197                 else:
2198                     logger.warning(exc.args[0], type='autodoc', subtype='import_object')
2199                     self.env.note_reread()
2200                     return False
2201 
2202     def get_doc(self, encoding: str = None, ignore: int = None) -> List[List[str]]:
2203         """Decode and return lines of the docstring(s) for the object."""
2204         if ignore is not None:
2205             warnings.warn("The 'ignore' argument to autodoc.%s.get_doc() is deprecated."
2206                           % self.__class__.__name__,
2207                           RemovedInSphinx50Warning, stacklevel=2)
2208         name = self.objpath[-1]
2209         __slots__ = safe_getattr(self.parent, '__slots__', [])
2210         if isinstance(__slots__, dict) and isinstance(__slots__.get(name), str):
2211             docstring = prepare_docstring(__slots__[name])
2212             return [docstring]
2213         else:
2214             return []
2215 
2216 
2217 def get_documenters(app: Sphinx) -> Dict[str, "Type[Documenter]"]:
2218     """Returns registered Documenter classes"""
2219     warnings.warn("get_documenters() is deprecated.", RemovedInSphinx50Warning, stacklevel=2)
2220     return app.registry.documenters
2221 
2222 
2223 def autodoc_attrgetter(app: Sphinx, obj: Any, name: str, *defargs: Any) -> Any:
2224     """Alternative getattr() for types"""
2225     for typ, func in app.registry.autodoc_attrgettrs.items():
2226         if isinstance(obj, typ):
2227             return func(obj, name, *defargs)
2228 
2229     return safe_getattr(obj, name, *defargs)
2230 
2231 
2232 def migrate_autodoc_member_order(app: Sphinx, config: Config) -> None:
2233     if config.autodoc_member_order == 'alphabetic':
2234         # RemovedInSphinx50Warning
2235         logger.warning(__('autodoc_member_order now accepts "alphabetical" '
2236                           'instead of "alphabetic". Please update your setting.'))
2237         config.autodoc_member_order = 'alphabetical'  # type: ignore
2238 
2239 
2240 def setup(app: Sphinx) -> Dict[str, Any]:
2241     app.add_autodocumenter(ModuleDocumenter)
2242     app.add_autodocumenter(ClassDocumenter)
2243     app.add_autodocumenter(ExceptionDocumenter)
2244     app.add_autodocumenter(DataDocumenter)
2245     app.add_autodocumenter(DataDeclarationDocumenter)
2246     app.add_autodocumenter(GenericAliasDocumenter)
2247     app.add_autodocumenter(TypeVarDocumenter)
2248     app.add_autodocumenter(FunctionDocumenter)
2249     app.add_autodocumenter(DecoratorDocumenter)
2250     app.add_autodocumenter(MethodDocumenter)
2251     app.add_autodocumenter(AttributeDocumenter)
2252     app.add_autodocumenter(PropertyDocumenter)
2253     app.add_autodocumenter(InstanceAttributeDocumenter)
2254     app.add_autodocumenter(SlotsAttributeDocumenter)
2255 
2256     app.add_config_value('autoclass_content', 'class', True, ENUM('both', 'class', 'init'))
2257     app.add_config_value('autodoc_member_order', 'alphabetical', True,
2258                          ENUM('alphabetic', 'alphabetical', 'bysource', 'groupwise'))
2259     app.add_config_value('autodoc_default_options', {}, True)
2260     app.add_config_value('autodoc_docstring_signature', True, True)
2261     app.add_config_value('autodoc_mock_imports', [], True)
2262     app.add_config_value('autodoc_typehints', "signature", True,
2263                          ENUM("signature", "description", "none"))
2264     app.add_config_value('autodoc_type_aliases', {}, True)
2265     app.add_config_value('autodoc_warningiserror', True, True)
2266     app.add_config_value('autodoc_inherit_docstrings', True, True)
2267     app.add_event('autodoc-before-process-signature')
2268     app.add_event('autodoc-process-docstring')
2269     app.add_event('autodoc-process-signature')
2270     app.add_event('autodoc-skip-member')
2271 
2272     app.connect('config-inited', migrate_autodoc_member_order, priority=800)
2273 
2274     app.setup_extension('sphinx.ext.autodoc.type_comment')
2275     app.setup_extension('sphinx.ext.autodoc.typehints')
2276 
2277     return {'version': sphinx.__display_version__, 'parallel_read_safe': True}

</code><intended_behavior>This file, particularly in the section related to function signature processing, should be modified to correctly handle and preserve hexadecimal default values in function signatures when generating documentation. The code should detect when a default value is expressed in hexadecimal format and ensure that this format is maintained in the output documentation, rather than converting it to decimal. This will involve checking the format of default arguments and applying a condition to preserve the original format (hexadecimal, octal, etc.) in the rendered documentation.</intended_behavior>, <file>sphinx/domains/python.py</file>
<class>None</class>
<method>_pseudo_parse_arglist</method>
<code>
218 def _pseudo_parse_arglist(signode: desc_signature, arglist: str) -> None:
219     """"Parse" a list of arguments separated by commas.
220 
221     Arguments can have "optional" annotations given by enclosing them in
222     brackets.  Currently, this will split at any comma, even if it's inside a
223     string literal (e.g. default argument value).
224     """
225     paramlist = addnodes.desc_parameterlist()
226     stack = [paramlist]  # type: List[Element]
227     try:
228         for argument in arglist.split(','):
229             argument = argument.strip()
230             ends_open = ends_close = 0
231             while argument.startswith('['):
232                 stack.append(addnodes.desc_optional())
233                 stack[-2] += stack[-1]
234                 argument = argument[1:].strip()
235             while argument.startswith(']'):
236                 stack.pop()
237                 argument = argument[1:].strip()
238             while argument.endswith(']') and not argument.endswith('[]'):
239                 ends_close += 1
240                 argument = argument[:-1].strip()
241             while argument.endswith('['):
242                 ends_open += 1
243                 argument = argument[:-1].strip()
244             if argument:
245                 stack[-1] += addnodes.desc_parameter(argument, argument)
246             while ends_open:
247                 stack.append(addnodes.desc_optional())
248                 stack[-2] += stack[-1]
249                 ends_open -= 1
250             while ends_close:
251                 stack.pop()
252                 ends_close -= 1
253         if len(stack) != 1:
254             raise IndexError
255     except IndexError:
256         # if there are too few or too many elements on the stack, just give up
257         # and treat the whole argument list as one argument, discarding the
258         # already partially populated paramlist node
259         paramlist = addnodes.desc_parameterlist()
260         paramlist += addnodes.desc_parameter(arglist, arglist)
261         signode += paramlist
262     else:
263         signode += paramlist

</code><intended_behavior>In the `_pseudo_parse_arglist` method, which is involved in parsing function arguments and their annotations, care should be taken to accurately parse and maintain the representation of default arguments. If a default argument is specified in hexadecimal (or any non-decimal base), this method should ensure that the original representation is preserved in the documentation output. This might require including logic to detect the format of the default value and ensuring that this format is not altered during the documentation generation process.</intended_behavior>]
2025-10-18 18:35:42.313 | INFO     | Search completed. Bug locations: [<file>sphinx/ext/autodoc/__init__.py</file>
<class>None</class>
<method>None</method>
<code>
1 """
2     sphinx.ext.autodoc
3     ~~~~~~~~~~~~~~~~~~
4 
5     Automatically insert docstrings for functions, classes or whole modules into
6     the doctree, thus avoiding duplication between docstrings and documentation
7     for those who like elaborate docstrings.
8 
9     :copyright: Copyright 2007-2020 by the Sphinx team, see AUTHORS.
10     :license: BSD, see LICENSE for details.
11 """
12 
13 import importlib
14 import re
15 import warnings
16 from inspect import Parameter, Signature
17 from types import ModuleType
18 from typing import (
19     Any, Callable, Dict, Iterator, List, Optional, Sequence, Set, Tuple, Type, TypeVar, Union
20 )
21 from typing import get_type_hints
22 
23 from docutils.statemachine import StringList
24 
25 import sphinx
26 from sphinx.application import Sphinx
27 from sphinx.config import Config, ENUM
28 from sphinx.deprecation import RemovedInSphinx40Warning, RemovedInSphinx50Warning
29 from sphinx.environment import BuildEnvironment
30 from sphinx.ext.autodoc.importer import import_object, get_module_members, get_object_members
31 from sphinx.ext.autodoc.mock import mock
32 from sphinx.locale import _, __
33 from sphinx.pycode import ModuleAnalyzer, PycodeError
34 from sphinx.util import inspect
35 from sphinx.util import logging
36 from sphinx.util.docstrings import extract_metadata, prepare_docstring
37 from sphinx.util.inspect import (
38     evaluate_signature, getdoc, object_description, safe_getattr, stringify_signature
39 )
40 from sphinx.util.typing import stringify as stringify_typehint
41 
42 if False:
43     # For type annotation
44     from typing import Type  # NOQA # for python3.5.1
45     from sphinx.ext.autodoc.directive import DocumenterBridge
46 
47 
48 logger = logging.getLogger(__name__)
49 
50 
51 # This type isn't exposed directly in any modules, but can be found
52 # here in most Python versions
53 MethodDescriptorType = type(type.__subclasses__)
54 
55 
56 #: extended signature RE: with explicit module name separated by ::
57 py_ext_sig_re = re.compile(
58     r'''^ ([\w.]+::)?            # explicit module name
59           ([\w.]+\.)?            # module and/or class name(s)
60           (\w+)  \s*             # thing name
61           (?: \((.*)\)           # optional: arguments
62            (?:\s* -> \s* (.*))?  #           return annotation
63           )? $                   # and nothing more
64           ''', re.VERBOSE)
65 special_member_re = re.compile(r'^__\S+__$')
66 
67 
68 def identity(x: Any) -> Any:
69     return x
70 
71 
72 class _All:
73     """A special value for :*-members: that matches to any member."""
74 
75     def __contains__(self, item: Any) -> bool:
76         return True
77 
78 
79 class _Empty:
80     """A special value for :exclude-members: that never matches to any member."""
81 
82     def __contains__(self, item: Any) -> bool:
83         return False
84 
85 
86 ALL = _All()
87 EMPTY = _Empty()
88 UNINITIALIZED_ATTR = object()
89 INSTANCEATTR = object()
90 SLOTSATTR = object()
91 
92 
93 def members_option(arg: Any) -> Union[object, List[str]]:
94     """Used to convert the :members: option to auto directives."""
95     if arg is None or arg is True:
96         return ALL
97     elif arg is False:
98         return None
99     else:
100         return [x.strip() for x in arg.split(',') if x.strip()]
101 
102 
103 def members_set_option(arg: Any) -> Union[object, Set[str]]:
104     """Used to convert the :members: option to auto directives."""
105     warnings.warn("members_set_option() is deprecated.",
106                   RemovedInSphinx50Warning, stacklevel=2)
107     if arg is None:
108         return ALL
109     return {x.strip() for x in arg.split(',') if x.strip()}
110 
111 
112 def exclude_members_option(arg: Any) -> Union[object, Set[str]]:
113     """Used to convert the :exclude-members: option."""
114     if arg is None:
115         return EMPTY
116     return {x.strip() for x in arg.split(',') if x.strip()}
117 
118 
119 def inherited_members_option(arg: Any) -> Union[object, Set[str]]:
120     """Used to convert the :members: option to auto directives."""
121     if arg is None:
122         return 'object'
123     else:
124         return arg
125 
126 
127 def member_order_option(arg: Any) -> Optional[str]:
128     """Used to convert the :members: option to auto directives."""
129     if arg is None:
130         return None
131     elif arg in ('alphabetical', 'bysource', 'groupwise'):
132         return arg
133     else:
134         raise ValueError(__('invalid value for member-order option: %s') % arg)
135 
136 
137 SUPPRESS = object()
138 
139 
140 def annotation_option(arg: Any) -> Any:
141     if arg is None:
142         # suppress showing the representation of the object
143         return SUPPRESS
144     else:
145         return arg
146 
147 
148 def bool_option(arg: Any) -> bool:
149     """Used to convert flag options to auto directives.  (Instead of
150     directives.flag(), which returns None).
151     """
152     return True
153 
154 
155 def merge_special_members_option(options: Dict) -> None:
156     """Merge :special-members: option to :members: option."""
157     warnings.warn("merge_special_members_option() is deprecated.",
158                   RemovedInSphinx50Warning, stacklevel=2)
159     if 'special-members' in options and options['special-members'] is not ALL:
160         if options.get('members') is ALL:
161             pass
162         elif options.get('members'):
163             for member in options['special-members']:
164                 if member not in options['members']:
165                     options['members'].append(member)
166         else:
167             options['members'] = options['special-members']
168 
169 
170 def merge_members_option(options: Dict) -> None:
171     """Merge :*-members: option to the :members: option."""
172     if options.get('members') is ALL:
173         # merging is not needed when members: ALL
174         return
175 
176     members = options.setdefault('members', [])
177     for key in {'private-members', 'special-members'}:
178         if key in options and options[key] not in (ALL, None):
179             for member in options[key]:
180                 if member not in members:
181                     members.append(member)
182 
183 
184 # Some useful event listener factories for autodoc-process-docstring.
185 
186 def cut_lines(pre: int, post: int = 0, what: str = None) -> Callable:
187     """Return a listener that removes the first *pre* and last *post*
188     lines of every docstring.  If *what* is a sequence of strings,
189     only docstrings of a type in *what* will be processed.
190 
191     Use like this (e.g. in the ``setup()`` function of :file:`conf.py`)::
192 
193        from sphinx.ext.autodoc import cut_lines
194        app.connect('autodoc-process-docstring', cut_lines(4, what=['module']))
195 
196     This can (and should) be used in place of :confval:`automodule_skip_lines`.
197     """
198     def process(app: Sphinx, what_: str, name: str, obj: Any, options: Any, lines: List[str]
199                 ) -> None:
200         if what and what_ not in what:
201             return
202         del lines[:pre]
203         if post:
204             # remove one trailing blank line.
205             if lines and not lines[-1]:
206                 lines.pop(-1)
207             del lines[-post:]
208         # make sure there is a blank line at the end
209         if lines and lines[-1]:
210             lines.append('')
211     return process
212 
213 
214 def between(marker: str, what: Sequence[str] = None, keepempty: bool = False,
215             exclude: bool = False) -> Callable:
216     """Return a listener that either keeps, or if *exclude* is True excludes,
217     lines between lines that match the *marker* regular expression.  If no line
218     matches, the resulting docstring would be empty, so no change will be made
219     unless *keepempty* is true.
220 
221     If *what* is a sequence of strings, only docstrings of a type in *what* will
222     be processed.
223     """
224     marker_re = re.compile(marker)
225 
226     def process(app: Sphinx, what_: str, name: str, obj: Any, options: Any, lines: List[str]
227                 ) -> None:
228         if what and what_ not in what:
229             return
230         deleted = 0
231         delete = not exclude
232         orig_lines = lines[:]
233         for i, line in enumerate(orig_lines):
234             if delete:
235                 lines.pop(i - deleted)
236                 deleted += 1
237             if marker_re.match(line):
238                 delete = not delete
239                 if delete:
240                     lines.pop(i - deleted)
241                     deleted += 1
242         if not lines and not keepempty:
243             lines[:] = orig_lines
244         # make sure there is a blank line at the end
245         if lines and lines[-1]:
246             lines.append('')
247     return process
248 
249 
250 # This class is used only in ``sphinx.ext.autodoc.directive``,
251 # But we define this class here to keep compatibility (see #4538)
252 class Options(dict):
253     """A dict/attribute hybrid that returns None on nonexisting keys."""
254     def __getattr__(self, name: str) -> Any:
255         try:
256             return self[name.replace('_', '-')]
257         except KeyError:
258             return None
259 
260 
261 class Documenter:
262     """
263     A Documenter knows how to autodocument a single object type.  When
264     registered with the AutoDirective, it will be used to document objects
265     of that type when needed by autodoc.
266 
267     Its *objtype* attribute selects what auto directive it is assigned to
268     (the directive name is 'auto' + objtype), and what directive it generates
269     by default, though that can be overridden by an attribute called
270     *directivetype*.
271 
272     A Documenter has an *option_spec* that works like a docutils directive's;
273     in fact, it will be used to parse an auto directive's options that matches
274     the documenter.
275     """
276     #: name by which the directive is called (auto...) and the default
277     #: generated directive name
278     objtype = 'object'
279     #: indentation by which to indent the directive content
280     content_indent = '   '
281     #: priority if multiple documenters return True from can_document_member
282     priority = 0
283     #: order if autodoc_member_order is set to 'groupwise'
284     member_order = 0
285     #: true if the generated content may contain titles
286     titles_allowed = False
287 
288     option_spec = {'noindex': bool_option}  # type: Dict[str, Callable]
289 
290     def get_attr(self, obj: Any, name: str, *defargs: Any) -> Any:
291         """getattr() override for types such as Zope interfaces."""
292         return autodoc_attrgetter(self.env.app, obj, name, *defargs)
293 
294     @classmethod
295     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
296                             ) -> bool:
297         """Called to see if a member can be documented by this documenter."""
298         raise NotImplementedError('must be implemented in subclasses')
299 
300     def __init__(self, directive: "DocumenterBridge", name: str, indent: str = '') -> None:
301         self.directive = directive
302         self.env = directive.env    # type: BuildEnvironment
303         self.options = directive.genopt
304         self.name = name
305         self.indent = indent
306         # the module and object path within the module, and the fully
307         # qualified name (all set after resolve_name succeeds)
308         self.modname = None         # type: str
309         self.module = None          # type: ModuleType
310         self.objpath = None         # type: List[str]
311         self.fullname = None        # type: str
312         # extra signature items (arguments and return annotation,
313         # also set after resolve_name succeeds)
314         self.args = None            # type: str
315         self.retann = None          # type: str
316         # the object to document (set after import_object succeeds)
317         self.object = None          # type: Any
318         self.object_name = None     # type: str
319         # the parent/owner of the object to document
320         self.parent = None          # type: Any
321         # the module analyzer to get at attribute docs, or None
322         self.analyzer = None        # type: ModuleAnalyzer
323 
324     @property
325     def documenters(self) -> Dict[str, "Type[Documenter]"]:
326         """Returns registered Documenter classes"""
327         return self.env.app.registry.documenters
328 
329     def add_line(self, line: str, source: str, *lineno: int) -> None:
330         """Append one line of generated reST to the output."""
331         if line.strip():  # not a blank line
332             self.directive.result.append(self.indent + line, source, *lineno)
333         else:
334             self.directive.result.append('', source, *lineno)
335 
336     def resolve_name(self, modname: str, parents: Any, path: str, base: Any
337                      ) -> Tuple[str, List[str]]:
338         """Resolve the module and name of the object to document given by the
339         arguments and the current module/class.
340 
341         Must return a pair of the module name and a chain of attributes; for
342         example, it would return ``('zipfile', ['ZipFile', 'open'])`` for the
343         ``zipfile.ZipFile.open`` method.
344         """
345         raise NotImplementedError('must be implemented in subclasses')
346 
347     def parse_name(self) -> bool:
348         """Determine what module to import and what attribute to document.
349 
350         Returns True and sets *self.modname*, *self.objpath*, *self.fullname*,
351         *self.args* and *self.retann* if parsing and resolving was successful.
352         """
353         # first, parse the definition -- auto directives for classes and
354         # functions can contain a signature which is then used instead of
355         # an autogenerated one
356         try:
357             explicit_modname, path, base, args, retann = \
358                 py_ext_sig_re.match(self.name).groups()
359         except AttributeError:
360             logger.warning(__('invalid signature for auto%s (%r)') % (self.objtype, self.name),
361                            type='autodoc')
362             return False
363 
364         # support explicit module and class name separation via ::
365         if explicit_modname is not None:
366             modname = explicit_modname[:-2]
367             parents = path.rstrip('.').split('.') if path else []
368         else:
369             modname = None
370             parents = []
371 
372         with mock(self.env.config.autodoc_mock_imports):
373             self.modname, self.objpath = self.resolve_name(modname, parents, path, base)
374 
375         if not self.modname:
376             return False
377 
378         self.args = args
379         self.retann = retann
380         self.fullname = (self.modname or '') + \
381                         ('.' + '.'.join(self.objpath) if self.objpath else '')
382         return True
383 
384     def import_object(self, raiseerror: bool = False) -> bool:
385         """Import the object given by *self.modname* and *self.objpath* and set
386         it as *self.object*.
387 
388         Returns True if successful, False if an error occurred.
389         """
390         with mock(self.env.config.autodoc_mock_imports):
391             try:
392                 ret = import_object(self.modname, self.objpath, self.objtype,
393                                     attrgetter=self.get_attr,
394                                     warningiserror=self.env.config.autodoc_warningiserror)
395                 self.module, self.parent, self.object_name, self.object = ret
396                 return True
397             except ImportError as exc:
398                 if raiseerror:
399                     raise
400                 else:
401                     logger.warning(exc.args[0], type='autodoc', subtype='import_object')
402                     self.env.note_reread()
403                     return False
404 
405     def get_real_modname(self) -> str:
406         """Get the real module name of an object to document.
407 
408         It can differ from the name of the module through which the object was
409         imported.
410         """
411         return self.get_attr(self.object, '__module__', None) or self.modname
412 
413     def check_module(self) -> bool:
414         """Check if *self.object* is really defined in the module given by
415         *self.modname*.
416         """
417         if self.options.imported_members:
418             return True
419 
420         subject = inspect.unpartial(self.object)
421         modname = self.get_attr(subject, '__module__', None)
422         if modname and modname != self.modname:
423             return False
424         return True
425 
426     def format_args(self, **kwargs: Any) -> str:
427         """Format the argument signature of *self.object*.
428 
429         Should return None if the object does not have a signature.
430         """
431         return None
432 
433     def format_name(self) -> str:
434         """Format the name of *self.object*.
435 
436         This normally should be something that can be parsed by the generated
437         directive, but doesn't need to be (Sphinx will display it unparsed
438         then).
439         """
440         # normally the name doesn't contain the module (except for module
441         # directives of course)
442         return '.'.join(self.objpath) or self.modname
443 
444     def _call_format_args(self, **kwargs: Any) -> str:
445         if kwargs:
446             try:
447                 return self.format_args(**kwargs)
448             except TypeError:
449                 # avoid chaining exceptions, by putting nothing here
450                 pass
451 
452         # retry without arguments for old documenters
453         return self.format_args()
454 
455     def format_signature(self, **kwargs: Any) -> str:
456         """Format the signature (arguments and return annotation) of the object.
457 
458         Let the user process it via the ``autodoc-process-signature`` event.
459         """
460         if self.args is not None:
461             # signature given explicitly
462             args = "(%s)" % self.args
463             retann = self.retann
464         else:
465             # try to introspect the signature
466             try:
467                 retann = None
468                 args = self._call_format_args(**kwargs)
469                 if args:
470                     matched = re.match(r'^(\(.*\))\s+->\s+(.*)$', args)
471                     if matched:
472                         args = matched.group(1)
473                         retann = matched.group(2)
474             except Exception as exc:
475                 logger.warning(__('error while formatting arguments for %s: %s'),
476                                self.fullname, exc, type='autodoc')
477                 args = None
478 
479         result = self.env.events.emit_firstresult('autodoc-process-signature',
480                                                   self.objtype, self.fullname,
481                                                   self.object, self.options, args, retann)
482         if result:
483             args, retann = result
484 
485         if args is not None:
486             return args + ((' -> %s' % retann) if retann else '')
487         else:
488             return ''
489 
490     def add_directive_header(self, sig: str) -> None:
491         """Add the directive header and options to the generated content."""
492         domain = getattr(self, 'domain', 'py')
493         directive = getattr(self, 'directivetype', self.objtype)
494         name = self.format_name()
495         sourcename = self.get_sourcename()
496 
497         # one signature per line, indented by column
498         prefix = '.. %s:%s:: ' % (domain, directive)
499         for i, sig_line in enumerate(sig.split("\n")):
500             self.add_line('%s%s%s' % (prefix, name, sig_line),
501                           sourcename)
502             if i == 0:
503                 prefix = " " * len(prefix)
504 
505         if self.options.noindex:
506             self.add_line('   :noindex:', sourcename)
507         if self.objpath:
508             # Be explicit about the module, this is necessary since .. class::
509             # etc. don't support a prepended module name
510             self.add_line('   :module: %s' % self.modname, sourcename)
511 
512     def get_doc(self, encoding: str = None, ignore: int = None) -> List[List[str]]:
513         """Decode and return lines of the docstring(s) for the object."""
514         if encoding is not None:
515             warnings.warn("The 'encoding' argument to autodoc.%s.get_doc() is deprecated."
516                           % self.__class__.__name__,
517                           RemovedInSphinx40Warning, stacklevel=2)
518         if ignore is not None:
519             warnings.warn("The 'ignore' argument to autodoc.%s.get_doc() is deprecated."
520                           % self.__class__.__name__,
521                           RemovedInSphinx50Warning, stacklevel=2)
522         docstring = getdoc(self.object, self.get_attr,
523                            self.env.config.autodoc_inherit_docstrings,
524                            self.parent, self.object_name)
525         if docstring:
526             tab_width = self.directive.state.document.settings.tab_width
527             return [prepare_docstring(docstring, ignore, tab_width)]
528         return []
529 
530     def process_doc(self, docstrings: List[List[str]]) -> Iterator[str]:
531         """Let the user process the docstrings before adding them."""
532         for docstringlines in docstrings:
533             if self.env.app:
534                 # let extensions preprocess docstrings
535                 self.env.app.emit('autodoc-process-docstring',
536                                   self.objtype, self.fullname, self.object,
537                                   self.options, docstringlines)
538 
539                 if docstringlines and docstringlines[-1] != '':
540                     # append a blank line to the end of the docstring
541                     docstringlines.append('')
542 
543             yield from docstringlines
544 
545     def get_sourcename(self) -> str:
546         if self.analyzer:
547             return '%s:docstring of %s' % (self.analyzer.srcname, self.fullname)
548         return 'docstring of %s' % self.fullname
549 
550     def add_content(self, more_content: Any, no_docstring: bool = False) -> None:
551         """Add content from docstrings, attribute documentation and user."""
552         # set sourcename and add content from attribute documentation
553         sourcename = self.get_sourcename()
554         if self.analyzer:
555             attr_docs = self.analyzer.find_attr_docs()
556             if self.objpath:
557                 key = ('.'.join(self.objpath[:-1]), self.objpath[-1])
558                 if key in attr_docs:
559                     no_docstring = True
560                     # make a copy of docstring for attributes to avoid cache
561                     # the change of autodoc-process-docstring event.
562                     docstrings = [list(attr_docs[key])]
563 
564                     for i, line in enumerate(self.process_doc(docstrings)):
565                         self.add_line(line, sourcename, i)
566 
567         # add content from docstrings
568         if not no_docstring:
569             docstrings = self.get_doc()
570             if not docstrings:
571                 # append at least a dummy docstring, so that the event
572                 # autodoc-process-docstring is fired and can add some
573                 # content if desired
574                 docstrings.append([])
575             for i, line in enumerate(self.process_doc(docstrings)):
576                 self.add_line(line, sourcename, i)
577 
578         # add additional content (e.g. from document), if present
579         if more_content:
580             for line, src in zip(more_content.data, more_content.items):
581                 self.add_line(line, src[0], src[1])
582 
583     def get_object_members(self, want_all: bool) -> Tuple[bool, List[Tuple[str, Any]]]:
584         """Return `(members_check_module, members)` where `members` is a
585         list of `(membername, member)` pairs of the members of *self.object*.
586 
587         If *want_all* is True, return all members.  Else, only return those
588         members given by *self.options.members* (which may also be none).
589         """
590         members = get_object_members(self.object, self.objpath, self.get_attr, self.analyzer)
591         if not want_all:
592             if not self.options.members:
593                 return False, []
594             # specific members given
595             selected = []
596             for name in self.options.members:
597                 if name in members:
598                     selected.append((name, members[name].value))
599                 else:
600                     logger.warning(__('missing attribute %s in object %s') %
601                                    (name, self.fullname), type='autodoc')
602             return False, selected
603         elif self.options.inherited_members:
604             return False, [(m.name, m.value) for m in members.values()]
605         else:
606             return False, [(m.name, m.value) for m in members.values()
607                            if m.directly_defined]
608 
609     def filter_members(self, members: List[Tuple[str, Any]], want_all: bool
610                        ) -> List[Tuple[str, Any, bool]]:
611         """Filter the given member list.
612 
613         Members are skipped if
614 
615         - they are private (except if given explicitly or the private-members
616           option is set)
617         - they are special methods (except if given explicitly or the
618           special-members option is set)
619         - they are undocumented (except if the undoc-members option is set)
620 
621         The user can override the skipping decision by connecting to the
622         ``autodoc-skip-member`` event.
623         """
624         def is_filtered_inherited_member(name: str) -> bool:
625             if inspect.isclass(self.object):
626                 for cls in self.object.__mro__:
627                     if cls.__name__ == self.options.inherited_members and cls != self.object:
628                         # given member is a member of specified *super class*
629                         return True
630                     elif name in cls.__dict__:
631                         return False
632                     elif name in self.get_attr(cls, '__annotations__', {}):
633                         return False
634 
635             return False
636 
637         ret = []
638 
639         # search for members in source code too
640         namespace = '.'.join(self.objpath)  # will be empty for modules
641 
642         if self.analyzer:
643             attr_docs = self.analyzer.find_attr_docs()
644         else:
645             attr_docs = {}
646 
647         # process members and determine which to skip
648         for (membername, member) in members:
649             # if isattr is True, the member is documented as an attribute
650             if member is INSTANCEATTR:
651                 isattr = True
652             else:
653                 isattr = False
654 
655             doc = getdoc(member, self.get_attr, self.env.config.autodoc_inherit_docstrings,
656                          self.parent, self.object_name)
657             if not isinstance(doc, str):
658                 # Ignore non-string __doc__
659                 doc = None
660 
661             # if the member __doc__ is the same as self's __doc__, it's just
662             # inherited and therefore not the member's doc
663             cls = self.get_attr(member, '__class__', None)
664             if cls:
665                 cls_doc = self.get_attr(cls, '__doc__', None)
666                 if cls_doc == doc:
667                     doc = None
668             has_doc = bool(doc)
669 
670             metadata = extract_metadata(doc)
671             if 'private' in metadata:
672                 # consider a member private if docstring has "private" metadata
673                 isprivate = True
674             elif 'public' in metadata:
675                 # consider a member public if docstring has "public" metadata
676                 isprivate = False
677             else:
678                 isprivate = membername.startswith('_')
679 
680             keep = False
681             if safe_getattr(member, '__sphinx_mock__', False):
682                 # mocked module or object
683                 pass
684             elif self.options.exclude_members and membername in self.options.exclude_members:
685                 # remove members given by exclude-members
686                 keep = False
687             elif want_all and special_member_re.match(membername):
688                 # special __methods__
689                 if self.options.special_members and membername in self.options.special_members:
690                     if membername == '__doc__':
691                         keep = False
692                     elif is_filtered_inherited_member(membername):
693                         keep = False
694                     else:
695                         keep = has_doc or self.options.undoc_members
696                 else:
697                     keep = False
698             elif (namespace, membername) in attr_docs:
699                 if want_all and isprivate:
700                     if self.options.private_members is None:
701                         keep = False
702                     else:
703                         keep = membername in self.options.private_members
704                 else:
705                     # keep documented attributes
706                     keep = True
707                 isattr = True
708             elif want_all and isprivate:
709                 if has_doc or self.options.undoc_members:
710                     if self.options.private_members is None:
711                         keep = False
712                     elif is_filtered_inherited_member(membername):
713                         keep = False
714                     else:
715                         keep = membername in self.options.private_members
716                 else:
717                     keep = False
718             else:
719                 if self.options.members is ALL and is_filtered_inherited_member(membername):
720                     keep = False
721                 else:
722                     # ignore undocumented members if :undoc-members: is not given
723                     keep = has_doc or self.options.undoc_members
724 
725             # give the user a chance to decide whether this member
726             # should be skipped
727             if self.env.app:
728                 # let extensions preprocess docstrings
729                 try:
730                     skip_user = self.env.app.emit_firstresult(
731                         'autodoc-skip-member', self.objtype, membername, member,
732                         not keep, self.options)
733                     if skip_user is not None:
734                         keep = not skip_user
735                 except Exception as exc:
736                     logger.warning(__('autodoc: failed to determine %r to be documented, '
737                                       'the following exception was raised:\n%s'),
738                                    member, exc, type='autodoc')
739                     keep = False
740 
741             if keep:
742                 ret.append((membername, member, isattr))
743 
744         return ret
745 
746     def document_members(self, all_members: bool = False) -> None:
747         """Generate reST for member documentation.
748 
749         If *all_members* is True, do all members, else those given by
750         *self.options.members*.
751         """
752         # set current namespace for finding members
753         self.env.temp_data['autodoc:module'] = self.modname
754         if self.objpath:
755             self.env.temp_data['autodoc:class'] = self.objpath[0]
756 
757         want_all = all_members or self.options.inherited_members or \
758             self.options.members is ALL
759         # find out which members are documentable
760         members_check_module, members = self.get_object_members(want_all)
761 
762         # document non-skipped members
763         memberdocumenters = []  # type: List[Tuple[Documenter, bool]]
764         for (mname, member, isattr) in self.filter_members(members, want_all):
765             classes = [cls for cls in self.documenters.values()
766                        if cls.can_document_member(member, mname, isattr, self)]
767             if not classes:
768                 # don't know how to document this member
769                 continue
770             # prefer the documenter with the highest priority
771             classes.sort(key=lambda cls: cls.priority)
772             # give explicitly separated module name, so that members
773             # of inner classes can be documented
774             full_mname = self.modname + '::' + \
775                 '.'.join(self.objpath + [mname])
776             documenter = classes[-1](self.directive, full_mname, self.indent)
777             memberdocumenters.append((documenter, isattr))
778 
779         member_order = self.options.member_order or self.env.config.autodoc_member_order
780         memberdocumenters = self.sort_members(memberdocumenters, member_order)
781 
782         for documenter, isattr in memberdocumenters:
783             documenter.generate(
784                 all_members=True, real_modname=self.real_modname,
785                 check_module=members_check_module and not isattr)
786 
787         # reset current objects
788         self.env.temp_data['autodoc:module'] = None
789         self.env.temp_data['autodoc:class'] = None
790 
791     def sort_members(self, documenters: List[Tuple["Documenter", bool]],
792                      order: str) -> List[Tuple["Documenter", bool]]:
793         """Sort the given member list."""
794         if order == 'groupwise':
795             # sort by group; alphabetically within groups
796             documenters.sort(key=lambda e: (e[0].member_order, e[0].name))
797         elif order == 'bysource':
798             if self.analyzer:
799                 # sort by source order, by virtue of the module analyzer
800                 tagorder = self.analyzer.tagorder
801 
802                 def keyfunc(entry: Tuple[Documenter, bool]) -> int:
803                     fullname = entry[0].name.split('::')[1]
804                     return tagorder.get(fullname, len(tagorder))
805                 documenters.sort(key=keyfunc)
806             else:
807                 # Assume that member discovery order matches source order.
808                 # This is a reasonable assumption in Python 3.6 and up, where
809                 # module.__dict__ is insertion-ordered.
810                 pass
811         else:  # alphabetical
812             documenters.sort(key=lambda e: e[0].name)
813 
814         return documenters
815 
816     def generate(self, more_content: Any = None, real_modname: str = None,
817                  check_module: bool = False, all_members: bool = False) -> None:
818         """Generate reST for the object given by *self.name*, and possibly for
819         its members.
820 
821         If *more_content* is given, include that content. If *real_modname* is
822         given, use that module name to find attribute docs. If *check_module* is
823         True, only generate if the object is defined in the module name it is
824         imported from. If *all_members* is True, document all members.
825         """
826         if not self.parse_name():
827             # need a module to import
828             logger.warning(
829                 __('don\'t know which module to import for autodocumenting '
830                    '%r (try placing a "module" or "currentmodule" directive '
831                    'in the document, or giving an explicit module name)') %
832                 self.name, type='autodoc')
833             return
834 
835         # now, import the module and get object to document
836         if not self.import_object():
837             return
838 
839         # If there is no real module defined, figure out which to use.
840         # The real module is used in the module analyzer to look up the module
841         # where the attribute documentation would actually be found in.
842         # This is used for situations where you have a module that collects the
843         # functions and classes of internal submodules.
844         guess_modname = self.get_real_modname()
845         self.real_modname = real_modname or guess_modname
846 
847         # try to also get a source code analyzer for attribute docs
848         try:
849             self.analyzer = ModuleAnalyzer.for_module(self.real_modname)
850             # parse right now, to get PycodeErrors on parsing (results will
851             # be cached anyway)
852             self.analyzer.find_attr_docs()
853         except PycodeError as exc:
854             logger.debug('[autodoc] module analyzer failed: %s', exc)
855             # no source file -- e.g. for builtin and C modules
856             self.analyzer = None
857             # at least add the module.__file__ as a dependency
858             if hasattr(self.module, '__file__') and self.module.__file__:
859                 self.directive.filename_set.add(self.module.__file__)
860         else:
861             self.directive.filename_set.add(self.analyzer.srcname)
862 
863         if self.real_modname != guess_modname:
864             # Add module to dependency list if target object is defined in other module.
865             try:
866                 analyzer = ModuleAnalyzer.for_module(guess_modname)
867                 self.directive.filename_set.add(analyzer.srcname)
868             except PycodeError:
869                 pass
870 
871         # check __module__ of object (for members not given explicitly)
872         if check_module:
873             if not self.check_module():
874                 return
875 
876         sourcename = self.get_sourcename()
877 
878         # make sure that the result starts with an empty line.  This is
879         # necessary for some situations where another directive preprocesses
880         # reST and no starting newline is present
881         self.add_line('', sourcename)
882 
883         # format the object's signature, if any
884         try:
885             sig = self.format_signature()
886         except Exception as exc:
887             logger.warning(__('error while formatting signature for %s: %s'),
888                            self.fullname, exc, type='autodoc')
889             return
890 
891         # generate the directive header and options, if applicable
892         self.add_directive_header(sig)
893         self.add_line('', sourcename)
894 
895         # e.g. the module directive doesn't have content
896         self.indent += self.content_indent
897 
898         # add all content (from docstrings, attribute docs etc.)
899         self.add_content(more_content)
900 
901         # document members, if possible
902         self.document_members(all_members)
903 
904 
905 class ModuleDocumenter(Documenter):
906     """
907     Specialized Documenter subclass for modules.
908     """
909     objtype = 'module'
910     content_indent = ''
911     titles_allowed = True
912 
913     option_spec = {
914         'members': members_option, 'undoc-members': bool_option,
915         'noindex': bool_option, 'inherited-members': inherited_members_option,
916         'show-inheritance': bool_option, 'synopsis': identity,
917         'platform': identity, 'deprecated': bool_option,
918         'member-order': member_order_option, 'exclude-members': exclude_members_option,
919         'private-members': members_option, 'special-members': members_option,
920         'imported-members': bool_option, 'ignore-module-all': bool_option
921     }  # type: Dict[str, Callable]
922 
923     def __init__(self, *args: Any) -> None:
924         super().__init__(*args)
925         merge_members_option(self.options)
926         self.__all__ = None
927 
928     @classmethod
929     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
930                             ) -> bool:
931         # don't document submodules automatically
932         return False
933 
934     def resolve_name(self, modname: str, parents: Any, path: str, base: Any
935                      ) -> Tuple[str, List[str]]:
936         if modname is not None:
937             logger.warning(__('"::" in automodule name doesn\'t make sense'),
938                            type='autodoc')
939         return (path or '') + base, []
940 
941     def parse_name(self) -> bool:
942         ret = super().parse_name()
943         if self.args or self.retann:
944             logger.warning(__('signature arguments or return annotation '
945                               'given for automodule %s') % self.fullname,
946                            type='autodoc')
947         return ret
948 
949     def import_object(self, raiseerror: bool = False) -> bool:
950         def is_valid_module_all(__all__: Any) -> bool:
951             """Check the given *__all__* is valid for a module."""
952             if (isinstance(__all__, (list, tuple)) and
953                     all(isinstance(e, str) for e in __all__)):
954                 return True
955             else:
956                 return False
957 
958         ret = super().import_object(raiseerror)
959 
960         if not self.options.ignore_module_all:
961             __all__ = getattr(self.object, '__all__', None)
962             if is_valid_module_all(__all__):
963                 # valid __all__ found. copy it to self.__all__
964                 self.__all__ = __all__
965             elif __all__:
966                 # invalid __all__ found.
967                 logger.warning(__('__all__ should be a list of strings, not %r '
968                                   '(in module %s) -- ignoring __all__') %
969                                (__all__, self.fullname), type='autodoc')
970 
971         return ret
972 
973     def add_directive_header(self, sig: str) -> None:
974         Documenter.add_directive_header(self, sig)
975 
976         sourcename = self.get_sourcename()
977 
978         # add some module-specific options
979         if self.options.synopsis:
980             self.add_line('   :synopsis: ' + self.options.synopsis, sourcename)
981         if self.options.platform:
982             self.add_line('   :platform: ' + self.options.platform, sourcename)
983         if self.options.deprecated:
984             self.add_line('   :deprecated:', sourcename)
985 
986     def get_object_members(self, want_all: bool) -> Tuple[bool, List[Tuple[str, Any]]]:
987         if want_all:
988             if self.__all__:
989                 memberlist = self.__all__
990             else:
991                 # for implicit module members, check __module__ to avoid
992                 # documenting imported objects
993                 return True, get_module_members(self.object)
994         else:
995             memberlist = self.options.members or []
996         ret = []
997         for mname in memberlist:
998             try:
999                 ret.append((mname, safe_getattr(self.object, mname)))
1000             except AttributeError:
1001                 logger.warning(
1002                     __('missing attribute mentioned in :members: or __all__: '
1003                        'module %s, attribute %s') %
1004                     (safe_getattr(self.object, '__name__', '???'), mname),
1005                     type='autodoc'
1006                 )
1007         return False, ret
1008 
1009     def sort_members(self, documenters: List[Tuple["Documenter", bool]],
1010                      order: str) -> List[Tuple["Documenter", bool]]:
1011         if order == 'bysource' and self.__all__:
1012             # Sort alphabetically first (for members not listed on the __all__)
1013             documenters.sort(key=lambda e: e[0].name)
1014 
1015             # Sort by __all__
1016             def keyfunc(entry: Tuple[Documenter, bool]) -> int:
1017                 name = entry[0].name.split('::')[1]
1018                 if name in self.__all__:
1019                     return self.__all__.index(name)
1020                 else:
1021                     return len(self.__all__)
1022             documenters.sort(key=keyfunc)
1023 
1024             return documenters
1025         else:
1026             return super().sort_members(documenters, order)
1027 
1028 
1029 class ModuleLevelDocumenter(Documenter):
1030     """
1031     Specialized Documenter subclass for objects on module level (functions,
1032     classes, data/constants).
1033     """
1034     def resolve_name(self, modname: str, parents: Any, path: str, base: Any
1035                      ) -> Tuple[str, List[str]]:
1036         if modname is None:
1037             if path:
1038                 modname = path.rstrip('.')
1039             else:
1040                 # if documenting a toplevel object without explicit module,
1041                 # it can be contained in another auto directive ...
1042                 modname = self.env.temp_data.get('autodoc:module')
1043                 # ... or in the scope of a module directive
1044                 if not modname:
1045                     modname = self.env.ref_context.get('py:module')
1046                 # ... else, it stays None, which means invalid
1047         return modname, parents + [base]
1048 
1049 
1050 class ClassLevelDocumenter(Documenter):
1051     """
1052     Specialized Documenter subclass for objects on class level (methods,
1053     attributes).
1054     """
1055     def resolve_name(self, modname: str, parents: Any, path: str, base: Any
1056                      ) -> Tuple[str, List[str]]:
1057         if modname is None:
1058             if path:
1059                 mod_cls = path.rstrip('.')
1060             else:
1061                 mod_cls = None
1062                 # if documenting a class-level object without path,
1063                 # there must be a current class, either from a parent
1064                 # auto directive ...
1065                 mod_cls = self.env.temp_data.get('autodoc:class')
1066                 # ... or from a class directive
1067                 if mod_cls is None:
1068                     mod_cls = self.env.ref_context.get('py:class')
1069                 # ... if still None, there's no way to know
1070                 if mod_cls is None:
1071                     return None, []
1072             modname, sep, cls = mod_cls.rpartition('.')
1073             parents = [cls]
1074             # if the module name is still missing, get it like above
1075             if not modname:
1076                 modname = self.env.temp_data.get('autodoc:module')
1077             if not modname:
1078                 modname = self.env.ref_context.get('py:module')
1079             # ... else, it stays None, which means invalid
1080         return modname, parents + [base]
1081 
1082 
1083 class DocstringSignatureMixin:
1084     """
1085     Mixin for FunctionDocumenter and MethodDocumenter to provide the
1086     feature of reading the signature from the docstring.
1087     """
1088     _new_docstrings = None  # type: List[List[str]]
1089     _signatures = None      # type: List[str]
1090 
1091     def _find_signature(self, encoding: str = None) -> Tuple[str, str]:
1092         if encoding is not None:
1093             warnings.warn("The 'encoding' argument to autodoc.%s._find_signature() is "
1094                           "deprecated." % self.__class__.__name__,
1095                           RemovedInSphinx40Warning, stacklevel=2)
1096 
1097         # candidates of the object name
1098         valid_names = [self.objpath[-1]]  # type: ignore
1099         if isinstance(self, ClassDocumenter):
1100             valid_names.append('__init__')
1101             if hasattr(self.object, '__mro__'):
1102                 valid_names.extend(cls.__name__ for cls in self.object.__mro__)
1103 
1104         docstrings = self.get_doc()
1105         self._new_docstrings = docstrings[:]
1106         self._signatures = []
1107         result = None
1108         for i, doclines in enumerate(docstrings):
1109             for j, line in enumerate(doclines):
1110                 if not line:
1111                     # no lines in docstring, no match
1112                     break
1113 
1114                 if line.endswith('\\'):
1115                     multiline = True
1116                     line = line.rstrip('\\').rstrip()
1117                 else:
1118                     multiline = False
1119 
1120                 # match first line of docstring against signature RE
1121                 match = py_ext_sig_re.match(line)
1122                 if not match:
1123                     continue
1124                 exmod, path, base, args, retann = match.groups()
1125 
1126                 # the base name must match ours
1127                 if base not in valid_names:
1128                     continue
1129 
1130                 # re-prepare docstring to ignore more leading indentation
1131                 tab_width = self.directive.state.document.settings.tab_width  # type: ignore
1132                 self._new_docstrings[i] = prepare_docstring('\n'.join(doclines[j + 1:]),
1133                                                             tabsize=tab_width)
1134 
1135                 if result is None:
1136                     # first signature
1137                     result = args, retann
1138                 else:
1139                     # subsequent signatures
1140                     self._signatures.append("(%s) -> %s" % (args, retann))
1141 
1142                 if multiline:
1143                     # the signature have multiple signatures on docstring
1144                     continue
1145                 else:
1146                     # don't look any further
1147                     break
1148 
1149             if result:
1150                 # finish the loop when signature found
1151                 break
1152 
1153         return result
1154 
1155     def get_doc(self, encoding: str = None, ignore: int = None) -> List[List[str]]:
1156         if encoding is not None:
1157             warnings.warn("The 'encoding' argument to autodoc.%s.get_doc() is deprecated."
1158                           % self.__class__.__name__,
1159                           RemovedInSphinx40Warning, stacklevel=2)
1160         if self._new_docstrings is not None:
1161             return self._new_docstrings
1162         return super().get_doc(None, ignore)  # type: ignore
1163 
1164     def format_signature(self, **kwargs: Any) -> str:
1165         if self.args is None and self.env.config.autodoc_docstring_signature:  # type: ignore
1166             # only act if a signature is not explicitly given already, and if
1167             # the feature is enabled
1168             result = self._find_signature()
1169             if result is not None:
1170                 self.args, self.retann = result
1171         sig = super().format_signature(**kwargs)  # type: ignore
1172         if self._signatures:
1173             return "\n".join([sig] + self._signatures)
1174         else:
1175             return sig
1176 
1177 
1178 class DocstringStripSignatureMixin(DocstringSignatureMixin):
1179     """
1180     Mixin for AttributeDocumenter to provide the
1181     feature of stripping any function signature from the docstring.
1182     """
1183     def format_signature(self, **kwargs: Any) -> str:
1184         if self.args is None and self.env.config.autodoc_docstring_signature:  # type: ignore
1185             # only act if a signature is not explicitly given already, and if
1186             # the feature is enabled
1187             result = self._find_signature()
1188             if result is not None:
1189                 # Discarding _args is a only difference with
1190                 # DocstringSignatureMixin.format_signature.
1191                 # Documenter.format_signature use self.args value to format.
1192                 _args, self.retann = result
1193         return super().format_signature(**kwargs)
1194 
1195 
1196 class FunctionDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # type: ignore
1197     """
1198     Specialized Documenter subclass for functions.
1199     """
1200     objtype = 'function'
1201     member_order = 30
1202 
1203     @classmethod
1204     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
1205                             ) -> bool:
1206         # supports functions, builtins and bound methods exported at the module level
1207         return (inspect.isfunction(member) or inspect.isbuiltin(member) or
1208                 (inspect.isroutine(member) and isinstance(parent, ModuleDocumenter)))
1209 
1210     def format_args(self, **kwargs: Any) -> str:
1211         if self.env.config.autodoc_typehints in ('none', 'description'):
1212             kwargs.setdefault('show_annotation', False)
1213 
1214         try:
1215             self.env.app.emit('autodoc-before-process-signature', self.object, False)
1216             sig = inspect.signature(self.object, follow_wrapped=True,
1217                                     type_aliases=self.env.config.autodoc_type_aliases)
1218             args = stringify_signature(sig, **kwargs)
1219         except TypeError as exc:
1220             logger.warning(__("Failed to get a function signature for %s: %s"),
1221                            self.fullname, exc)
1222             return None
1223         except ValueError:
1224             args = ''
1225 
1226         if self.env.config.strip_signature_backslash:
1227             # escape backslashes for reST
1228             args = args.replace('\\', '\\\\')
1229         return args
1230 
1231     def document_members(self, all_members: bool = False) -> None:
1232         pass
1233 
1234     def add_directive_header(self, sig: str) -> None:
1235         sourcename = self.get_sourcename()
1236         super().add_directive_header(sig)
1237 
1238         if inspect.iscoroutinefunction(self.object):
1239             self.add_line('   :async:', sourcename)
1240 
1241     def format_signature(self, **kwargs: Any) -> str:
1242         sigs = []
1243         if self.analyzer and '.'.join(self.objpath) in self.analyzer.overloads:
1244             # Use signatures for overloaded functions instead of the implementation function.
1245             overloaded = True
1246         else:
1247             overloaded = False
1248             sig = super().format_signature(**kwargs)
1249             sigs.append(sig)
1250 
1251         if inspect.is_singledispatch_function(self.object):
1252             # append signature of singledispatch'ed functions
1253             for typ, func in self.object.registry.items():
1254                 if typ is object:
1255                     pass  # default implementation. skipped.
1256                 else:
1257                     self.annotate_to_first_argument(func, typ)
1258 
1259                     documenter = FunctionDocumenter(self.directive, '')
1260                     documenter.object = func
1261                     documenter.objpath = [None]
1262                     sigs.append(documenter.format_signature())
1263         if overloaded:
1264             __globals__ = safe_getattr(self.object, '__globals__', {})
1265             for overload in self.analyzer.overloads.get('.'.join(self.objpath)):
1266                 overload = evaluate_signature(overload, __globals__,
1267                                               self.env.config.autodoc_type_aliases)
1268 
1269                 sig = stringify_signature(overload, **kwargs)
1270                 sigs.append(sig)
1271 
1272         return "\n".join(sigs)
1273 
1274     def annotate_to_first_argument(self, func: Callable, typ: Type) -> None:
1275         """Annotate type hint to the first argument of function if needed."""
1276         try:
1277             sig = inspect.signature(func, type_aliases=self.env.config.autodoc_type_aliases)
1278         except TypeError as exc:
1279             logger.warning(__("Failed to get a function signature for %s: %s"),
1280                            self.fullname, exc)
1281             return
1282         except ValueError:
1283             return
1284 
1285         if len(sig.parameters) == 0:
1286             return
1287 
1288         params = list(sig.parameters.values())
1289         if params[0].annotation is Parameter.empty:
1290             params[0] = params[0].replace(annotation=typ)
1291             try:
1292                 func.__signature__ = sig.replace(parameters=params)  # type: ignore
1293             except TypeError:
1294                 # failed to update signature (ex. built-in or extension types)
1295                 return
1296 
1297 
1298 class SingledispatchFunctionDocumenter(FunctionDocumenter):
1299     """
1300     Used to be a specialized Documenter subclass for singledispatch'ed functions.
1301 
1302     Retained for backwards compatibility, now does the same as the FunctionDocumenter
1303     """
1304 
1305     def __init__(self, *args: Any, **kwargs: Any) -> None:
1306         warnings.warn("%s is deprecated." % self.__class__.__name__,
1307                       RemovedInSphinx50Warning, stacklevel=2)
1308         super().__init__(*args, **kwargs)
1309 
1310 
1311 class DecoratorDocumenter(FunctionDocumenter):
1312     """
1313     Specialized Documenter subclass for decorator functions.
1314     """
1315     objtype = 'decorator'
1316 
1317     # must be lower than FunctionDocumenter
1318     priority = -1
1319 
1320     def format_args(self, **kwargs: Any) -> Any:
1321         args = super().format_args(**kwargs)
1322         if ',' in args:
1323             return args
1324         else:
1325             return None
1326 
1327 
1328 # Types which have confusing metaclass signatures it would be best not to show.
1329 # These are listed by name, rather than storing the objects themselves, to avoid
1330 # needing to import the modules.
1331 _METACLASS_CALL_BLACKLIST = [
1332     'enum.EnumMeta.__call__',
1333 ]
1334 
1335 
1336 # Types whose __new__ signature is a pass-thru.
1337 _CLASS_NEW_BLACKLIST = [
1338     'typing.Generic.__new__',
1339 ]
1340 
1341 
1342 class ClassDocumenter(DocstringSignatureMixin, ModuleLevelDocumenter):  # type: ignore
1343     """
1344     Specialized Documenter subclass for classes.
1345     """
1346     objtype = 'class'
1347     member_order = 20
1348     option_spec = {
1349         'members': members_option, 'undoc-members': bool_option,
1350         'noindex': bool_option, 'inherited-members': inherited_members_option,
1351         'show-inheritance': bool_option, 'member-order': member_order_option,
1352         'exclude-members': exclude_members_option,
1353         'private-members': members_option, 'special-members': members_option,
1354     }  # type: Dict[str, Callable]
1355 
1356     _signature_class = None  # type: Any
1357     _signature_method_name = None  # type: str
1358 
1359     def __init__(self, *args: Any) -> None:
1360         super().__init__(*args)
1361         merge_members_option(self.options)
1362 
1363     @classmethod
1364     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
1365                             ) -> bool:
1366         return isinstance(member, type)
1367 
1368     def import_object(self, raiseerror: bool = False) -> bool:
1369         ret = super().import_object(raiseerror)
1370         # if the class is documented under another name, document it
1371         # as data/attribute
1372         if ret:
1373             if hasattr(self.object, '__name__'):
1374                 self.doc_as_attr = (self.objpath[-1] != self.object.__name__)
1375             else:
1376                 self.doc_as_attr = True
1377         return ret
1378 
1379     def _get_signature(self) -> Tuple[Optional[Any], Optional[str], Optional[Signature]]:
1380         def get_user_defined_function_or_method(obj: Any, attr: str) -> Any:
1381             """ Get the `attr` function or method from `obj`, if it is user-defined. """
1382             if inspect.is_builtin_class_method(obj, attr):
1383                 return None
1384             attr = self.get_attr(obj, attr, None)
1385             if not (inspect.ismethod(attr) or inspect.isfunction(attr)):
1386                 return None
1387             return attr
1388 
1389         # This sequence is copied from inspect._signature_from_callable.
1390         # ValueError means that no signature could be found, so we keep going.
1391 
1392         # First, let's see if it has an overloaded __call__ defined
1393         # in its metaclass
1394         call = get_user_defined_function_or_method(type(self.object), '__call__')
1395 
1396         if call is not None:
1397             if "{0.__module__}.{0.__qualname__}".format(call) in _METACLASS_CALL_BLACKLIST:
1398                 call = None
1399 
1400         if call is not None:
1401             self.env.app.emit('autodoc-before-process-signature', call, True)
1402             try:
1403                 sig = inspect.signature(call, bound_method=True,
1404                                         type_aliases=self.env.config.autodoc_type_aliases)
1405                 return type(self.object), '__call__', sig
1406             except ValueError:
1407                 pass
1408 
1409         # Now we check if the 'obj' class has a '__new__' method
1410         new = get_user_defined_function_or_method(self.object, '__new__')
1411 
1412         if new is not None:
1413             if "{0.__module__}.{0.__qualname__}".format(new) in _CLASS_NEW_BLACKLIST:
1414                 new = None
1415 
1416         if new is not None:
1417             self.env.app.emit('autodoc-before-process-signature', new, True)
1418             try:
1419                 sig = inspect.signature(new, bound_method=True,
1420                                         type_aliases=self.env.config.autodoc_type_aliases)
1421                 return self.object, '__new__', sig
1422             except ValueError:
1423                 pass
1424 
1425         # Finally, we should have at least __init__ implemented
1426         init = get_user_defined_function_or_method(self.object, '__init__')
1427         if init is not None:
1428             self.env.app.emit('autodoc-before-process-signature', init, True)
1429             try:
1430                 sig = inspect.signature(init, bound_method=True,
1431                                         type_aliases=self.env.config.autodoc_type_aliases)
1432                 return self.object, '__init__', sig
1433             except ValueError:
1434                 pass
1435 
1436         # None of the attributes are user-defined, so fall back to let inspect
1437         # handle it.
1438         # We don't know the exact method that inspect.signature will read
1439         # the signature from, so just pass the object itself to our hook.
1440         self.env.app.emit('autodoc-before-process-signature', self.object, False)
1441         try:
1442             sig = inspect.signature(self.object, bound_method=False,
1443                                     type_aliases=self.env.config.autodoc_type_aliases)
1444             return None, None, sig
1445         except ValueError:
1446             pass
1447 
1448         # Still no signature: happens e.g. for old-style classes
1449         # with __init__ in C and no `__text_signature__`.
1450         return None, None, None
1451 
1452     def format_args(self, **kwargs: Any) -> str:
1453         if self.env.config.autodoc_typehints in ('none', 'description'):
1454             kwargs.setdefault('show_annotation', False)
1455 
1456         try:
1457             self._signature_class, self._signature_method_name, sig = self._get_signature()
1458         except TypeError as exc:
1459             # __signature__ attribute contained junk
1460             logger.warning(__("Failed to get a constructor signature for %s: %s"),
1461                            self.fullname, exc)
1462             return None
1463 
1464         if sig is None:
1465             return None
1466 
1467         return stringify_signature(sig, show_return_annotation=False, **kwargs)
1468 
1469     def format_signature(self, **kwargs: Any) -> str:
1470         if self.doc_as_attr:
1471             return ''
1472 
1473         sig = super().format_signature()
1474 
1475         overloaded = False
1476         qualname = None
1477         # TODO: recreate analyzer for the module of class (To be clear, owner of the method)
1478         if self._signature_class and self._signature_method_name and self.analyzer:
1479             qualname = '.'.join([self._signature_class.__qualname__,
1480                                  self._signature_method_name])
1481             if qualname in self.analyzer.overloads:
1482                 overloaded = True
1483 
1484         sigs = []
1485         if overloaded:
1486             # Use signatures for overloaded methods instead of the implementation method.
1487             method = safe_getattr(self._signature_class, self._signature_method_name, None)
1488             __globals__ = safe_getattr(method, '__globals__', {})
1489             for overload in self.analyzer.overloads.get(qualname):
1490                 overload = evaluate_signature(overload, __globals__,
1491                                               self.env.config.autodoc_type_aliases)
1492 
1493                 parameters = list(overload.parameters.values())
1494                 overload = overload.replace(parameters=parameters[1:],
1495                                             return_annotation=Parameter.empty)
1496                 sig = stringify_signature(overload, **kwargs)
1497                 sigs.append(sig)
1498         else:
1499             sigs.append(sig)
1500 
1501         return "\n".join(sigs)
1502 
1503     def add_directive_header(self, sig: str) -> None:
1504         sourcename = self.get_sourcename()
1505 
1506         if self.doc_as_attr:
1507             self.directivetype = 'attribute'
1508         super().add_directive_header(sig)
1509 
1510         if self.analyzer and '.'.join(self.objpath) in self.analyzer.finals:
1511             self.add_line('   :final:', sourcename)
1512 
1513         # add inheritance info, if wanted
1514         if not self.doc_as_attr and self.options.show_inheritance:
1515             sourcename = self.get_sourcename()
1516             self.add_line('', sourcename)
1517             if hasattr(self.object, '__bases__') and len(self.object.__bases__):
1518                 bases = [':class:`%s`' % b.__name__
1519                          if b.__module__ in ('__builtin__', 'builtins')
1520                          else ':class:`%s.%s`' % (b.__module__, b.__qualname__)
1521                          for b in self.object.__bases__]
1522                 self.add_line('   ' + _('Bases: %s') % ', '.join(bases),
1523                               sourcename)
1524 
1525     def get_doc(self, encoding: str = None, ignore: int = None) -> List[List[str]]:
1526         if encoding is not None:
1527             warnings.warn("The 'encoding' argument to autodoc.%s.get_doc() is deprecated."
1528                           % self.__class__.__name__,
1529                           RemovedInSphinx40Warning, stacklevel=2)
1530         lines = getattr(self, '_new_docstrings', None)
1531         if lines is not None:
1532             return lines
1533 
1534         content = self.env.config.autoclass_content
1535 
1536         docstrings = []
1537         attrdocstring = self.get_attr(self.object, '__doc__', None)
1538         if attrdocstring:
1539             docstrings.append(attrdocstring)
1540 
1541         # for classes, what the "docstring" is can be controlled via a
1542         # config value; the default is only the class docstring
1543         if content in ('both', 'init'):
1544             __init__ = self.get_attr(self.object, '__init__', None)
1545             initdocstring = getdoc(__init__, self.get_attr,
1546                                    self.env.config.autodoc_inherit_docstrings,
1547                                    self.parent, self.object_name)
1548             # for new-style classes, no __init__ means default __init__
1549             if (initdocstring is not None and
1550                 (initdocstring == object.__init__.__doc__ or  # for pypy
1551                  initdocstring.strip() == object.__init__.__doc__)):  # for !pypy
1552                 initdocstring = None
1553             if not initdocstring:
1554                 # try __new__
1555                 __new__ = self.get_attr(self.object, '__new__', None)
1556                 initdocstring = getdoc(__new__, self.get_attr,
1557                                        self.env.config.autodoc_inherit_docstrings,
1558                                        self.parent, self.object_name)
1559                 # for new-style classes, no __new__ means default __new__
1560                 if (initdocstring is not None and
1561                     (initdocstring == object.__new__.__doc__ or  # for pypy
1562                      initdocstring.strip() == object.__new__.__doc__)):  # for !pypy
1563                     initdocstring = None
1564             if initdocstring:
1565                 if content == 'init':
1566                     docstrings = [initdocstring]
1567                 else:
1568                     docstrings.append(initdocstring)
1569 
1570         tab_width = self.directive.state.document.settings.tab_width
1571         return [prepare_docstring(docstring, ignore, tab_width) for docstring in docstrings]
1572 
1573     def add_content(self, more_content: Any, no_docstring: bool = False) -> None:
1574         if self.doc_as_attr:
1575             classname = safe_getattr(self.object, '__qualname__', None)
1576             if not classname:
1577                 classname = safe_getattr(self.object, '__name__', None)
1578             if classname:
1579                 module = safe_getattr(self.object, '__module__', None)
1580                 parentmodule = safe_getattr(self.parent, '__module__', None)
1581                 if module and module != parentmodule:
1582                     classname = str(module) + '.' + str(classname)
1583                 content = StringList([_('alias of :class:`%s`') % classname], source='')
1584                 super().add_content(content, no_docstring=True)
1585         else:
1586             super().add_content(more_content)
1587 
1588     def document_members(self, all_members: bool = False) -> None:
1589         if self.doc_as_attr:
1590             return
1591         super().document_members(all_members)
1592 
1593     def generate(self, more_content: Any = None, real_modname: str = None,
1594                  check_module: bool = False, all_members: bool = False) -> None:
1595         # Do not pass real_modname and use the name from the __module__
1596         # attribute of the class.
1597         # If a class gets imported into the module real_modname
1598         # the analyzer won't find the source of the class, if
1599         # it looks in real_modname.
1600         return super().generate(more_content=more_content,
1601                                 check_module=check_module,
1602                                 all_members=all_members)
1603 
1604 
1605 class ExceptionDocumenter(ClassDocumenter):
1606     """
1607     Specialized ClassDocumenter subclass for exceptions.
1608     """
1609     objtype = 'exception'
1610     member_order = 10
1611 
1612     # needs a higher priority than ClassDocumenter
1613     priority = 10
1614 
1615     @classmethod
1616     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
1617                             ) -> bool:
1618         return isinstance(member, type) and issubclass(member, BaseException)
1619 
1620 
1621 class DataDocumenter(ModuleLevelDocumenter):
1622     """
1623     Specialized Documenter subclass for data items.
1624     """
1625     objtype = 'data'
1626     member_order = 40
1627     priority = -10
1628     option_spec = dict(ModuleLevelDocumenter.option_spec)
1629     option_spec["annotation"] = annotation_option
1630 
1631     @classmethod
1632     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
1633                             ) -> bool:
1634         return isinstance(parent, ModuleDocumenter) and isattr
1635 
1636     def add_directive_header(self, sig: str) -> None:
1637         super().add_directive_header(sig)
1638         sourcename = self.get_sourcename()
1639         if not self.options.annotation:
1640             # obtain annotation for this data
1641             try:
1642                 annotations = get_type_hints(self.parent)
1643             except NameError:
1644                 # Failed to evaluate ForwardRef (maybe TYPE_CHECKING)
1645                 annotations = safe_getattr(self.parent, '__annotations__', {})
1646             except TypeError:
1647                 annotations = {}
1648             except KeyError:
1649                 # a broken class found (refs: https://github.com/sphinx-doc/sphinx/issues/8084)
1650                 annotations = {}
1651             except AttributeError:
1652                 # AttributeError is raised on 3.5.2 (fixed by 3.5.3)
1653                 annotations = {}
1654 
1655             if self.objpath[-1] in annotations:
1656                 objrepr = stringify_typehint(annotations.get(self.objpath[-1]))
1657                 self.add_line('   :type: ' + objrepr, sourcename)
1658             else:
1659                 key = ('.'.join(self.objpath[:-1]), self.objpath[-1])
1660                 if self.analyzer and key in self.analyzer.annotations:
1661                     self.add_line('   :type: ' + self.analyzer.annotations[key],
1662                                   sourcename)
1663 
1664             try:
1665                 if self.object is UNINITIALIZED_ATTR:
1666                     pass
1667                 else:
1668                     objrepr = object_description(self.object)
1669                     self.add_line('   :value: ' + objrepr, sourcename)
1670             except ValueError:
1671                 pass
1672         elif self.options.annotation is SUPPRESS:
1673             pass
1674         else:
1675             self.add_line('   :annotation: %s' % self.options.annotation,
1676                           sourcename)
1677 
1678     def document_members(self, all_members: bool = False) -> None:
1679         pass
1680 
1681     def get_real_modname(self) -> str:
1682         return self.get_attr(self.parent or self.object, '__module__', None) \
1683             or self.modname
1684 
1685 
1686 class DataDeclarationDocumenter(DataDocumenter):
1687     """
1688     Specialized Documenter subclass for data that cannot be imported
1689     because they are declared without initial value (refs: PEP-526).
1690     """
1691     objtype = 'datadecl'
1692     directivetype = 'data'
1693     member_order = 60
1694 
1695     # must be higher than AttributeDocumenter
1696     priority = 11
1697 
1698     @classmethod
1699     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
1700                             ) -> bool:
1701         """This documents only INSTANCEATTR members."""
1702         return (isinstance(parent, ModuleDocumenter) and
1703                 isattr and
1704                 member is INSTANCEATTR)
1705 
1706     def import_object(self, raiseerror: bool = False) -> bool:
1707         """Never import anything."""
1708         # disguise as a data
1709         self.objtype = 'data'
1710         self.object = UNINITIALIZED_ATTR
1711         try:
1712             # import module to obtain type annotation
1713             self.parent = importlib.import_module(self.modname)
1714         except ImportError:
1715             pass
1716 
1717         return True
1718 
1719     def add_content(self, more_content: Any, no_docstring: bool = False) -> None:
1720         """Never try to get a docstring from the object."""
1721         super().add_content(more_content, no_docstring=True)
1722 
1723 
1724 class GenericAliasDocumenter(DataDocumenter):
1725     """
1726     Specialized Documenter subclass for GenericAliases.
1727     """
1728 
1729     objtype = 'genericalias'
1730     directivetype = 'data'
1731     priority = DataDocumenter.priority + 1
1732 
1733     @classmethod
1734     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
1735                             ) -> bool:
1736         return inspect.isgenericalias(member)
1737 
1738     def add_directive_header(self, sig: str) -> None:
1739         self.options = Options(self.options)
1740         self.options['annotation'] = SUPPRESS
1741         super().add_directive_header(sig)
1742 
1743     def add_content(self, more_content: Any, no_docstring: bool = False) -> None:
1744         name = stringify_typehint(self.object)
1745         content = StringList([_('alias of %s') % name], source='')
1746         super().add_content(content)
1747 
1748 
1749 class TypeVarDocumenter(DataDocumenter):
1750     """
1751     Specialized Documenter subclass for TypeVars.
1752     """
1753 
1754     objtype = 'typevar'
1755     directivetype = 'data'
1756     priority = DataDocumenter.priority + 1
1757 
1758     @classmethod
1759     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
1760                             ) -> bool:
1761         return isinstance(member, TypeVar) and isattr  # type: ignore
1762 
1763     def add_directive_header(self, sig: str) -> None:
1764         self.options = Options(self.options)
1765         self.options['annotation'] = SUPPRESS
1766         super().add_directive_header(sig)
1767 
1768     def get_doc(self, encoding: str = None, ignore: int = None) -> List[List[str]]:
1769         if ignore is not None:
1770             warnings.warn("The 'ignore' argument to autodoc.%s.get_doc() is deprecated."
1771                           % self.__class__.__name__,
1772                           RemovedInSphinx50Warning, stacklevel=2)
1773 
1774         if self.object.__doc__ != TypeVar.__doc__:
1775             return super().get_doc()
1776         else:
1777             return []
1778 
1779     def add_content(self, more_content: Any, no_docstring: bool = False) -> None:
1780         attrs = [repr(self.object.__name__)]
1781         for constraint in self.object.__constraints__:
1782             attrs.append(stringify_typehint(constraint))
1783         if self.object.__covariant__:
1784             attrs.append("covariant=True")
1785         if self.object.__contravariant__:
1786             attrs.append("contravariant=True")
1787 
1788         content = StringList([_('alias of TypeVar(%s)') % ", ".join(attrs)], source='')
1789         super().add_content(content)
1790 
1791 
1792 class MethodDocumenter(DocstringSignatureMixin, ClassLevelDocumenter):  # type: ignore
1793     """
1794     Specialized Documenter subclass for methods (normal, static and class).
1795     """
1796     objtype = 'method'
1797     directivetype = 'method'
1798     member_order = 50
1799     priority = 1  # must be more than FunctionDocumenter
1800 
1801     @classmethod
1802     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
1803                             ) -> bool:
1804         return inspect.isroutine(member) and \
1805             not isinstance(parent, ModuleDocumenter)
1806 
1807     def import_object(self, raiseerror: bool = False) -> bool:
1808         ret = super().import_object(raiseerror)
1809         if not ret:
1810             return ret
1811 
1812         # to distinguish classmethod/staticmethod
1813         obj = self.parent.__dict__.get(self.object_name)
1814         if obj is None:
1815             obj = self.object
1816 
1817         if (inspect.isclassmethod(obj) or
1818                 inspect.isstaticmethod(obj, cls=self.parent, name=self.object_name)):
1819             # document class and static members before ordinary ones
1820             self.member_order = self.member_order - 1
1821 
1822         return ret
1823 
1824     def format_args(self, **kwargs: Any) -> str:
1825         if self.env.config.autodoc_typehints in ('none', 'description'):
1826             kwargs.setdefault('show_annotation', False)
1827 
1828         try:
1829             if self.object == object.__init__ and self.parent != object:
1830                 # Classes not having own __init__() method are shown as no arguments.
1831                 #
1832                 # Note: The signature of object.__init__() is (self, /, *args, **kwargs).
1833                 #       But it makes users confused.
1834                 args = '()'
1835             else:
1836                 if inspect.isstaticmethod(self.object, cls=self.parent, name=self.object_name):
1837                     self.env.app.emit('autodoc-before-process-signature', self.object, False)
1838                     sig = inspect.signature(self.object, bound_method=False,
1839                                             type_aliases=self.env.config.autodoc_type_aliases)
1840                 else:
1841                     self.env.app.emit('autodoc-before-process-signature', self.object, True)
1842                     sig = inspect.signature(self.object, bound_method=True,
1843                                             follow_wrapped=True,
1844                                             type_aliases=self.env.config.autodoc_type_aliases)
1845                 args = stringify_signature(sig, **kwargs)
1846         except TypeError as exc:
1847             logger.warning(__("Failed to get a method signature for %s: %s"),
1848                            self.fullname, exc)
1849             return None
1850         except ValueError:
1851             args = ''
1852 
1853         if self.env.config.strip_signature_backslash:
1854             # escape backslashes for reST
1855             args = args.replace('\\', '\\\\')
1856         return args
1857 
1858     def add_directive_header(self, sig: str) -> None:
1859         super().add_directive_header(sig)
1860 
1861         sourcename = self.get_sourcename()
1862         obj = self.parent.__dict__.get(self.object_name, self.object)
1863         if inspect.isabstractmethod(obj):
1864             self.add_line('   :abstractmethod:', sourcename)
1865         if inspect.iscoroutinefunction(obj):
1866             self.add_line('   :async:', sourcename)
1867         if inspect.isclassmethod(obj):
1868             self.add_line('   :classmethod:', sourcename)
1869         if inspect.isstaticmethod(obj, cls=self.parent, name=self.object_name):
1870             self.add_line('   :staticmethod:', sourcename)
1871         if self.analyzer and '.'.join(self.objpath) in self.analyzer.finals:
1872             self.add_line('   :final:', sourcename)
1873 
1874     def document_members(self, all_members: bool = False) -> None:
1875         pass
1876 
1877     def format_signature(self, **kwargs: Any) -> str:
1878         sigs = []
1879         if self.analyzer and '.'.join(self.objpath) in self.analyzer.overloads:
1880             # Use signatures for overloaded methods instead of the implementation method.
1881             overloaded = True
1882         else:
1883             overloaded = False
1884             sig = super().format_signature(**kwargs)
1885             sigs.append(sig)
1886 
1887         meth = self.parent.__dict__.get(self.objpath[-1])
1888         if inspect.is_singledispatch_method(meth):
1889             # append signature of singledispatch'ed functions
1890             for typ, func in meth.dispatcher.registry.items():
1891                 if typ is object:
1892                     pass  # default implementation. skipped.
1893                 else:
1894                     self.annotate_to_first_argument(func, typ)
1895 
1896                     documenter = MethodDocumenter(self.directive, '')
1897                     documenter.parent = self.parent
1898                     documenter.object = func
1899                     documenter.objpath = [None]
1900                     sigs.append(documenter.format_signature())
1901         if overloaded:
1902             __globals__ = safe_getattr(self.object, '__globals__', {})
1903             for overload in self.analyzer.overloads.get('.'.join(self.objpath)):
1904                 overload = evaluate_signature(overload, __globals__,
1905                                               self.env.config.autodoc_type_aliases)
1906 
1907                 if not inspect.isstaticmethod(self.object, cls=self.parent,
1908                                               name=self.object_name):
1909                     parameters = list(overload.parameters.values())
1910                     overload = overload.replace(parameters=parameters[1:])
1911                 sig = stringify_signature(overload, **kwargs)
1912                 sigs.append(sig)
1913 
1914         return "\n".join(sigs)
1915 
1916     def annotate_to_first_argument(self, func: Callable, typ: Type) -> None:
1917         """Annotate type hint to the first argument of function if needed."""
1918         try:
1919             sig = inspect.signature(func, type_aliases=self.env.config.autodoc_type_aliases)
1920         except TypeError as exc:
1921             logger.warning(__("Failed to get a method signature for %s: %s"),
1922                            self.fullname, exc)
1923             return
1924         except ValueError:
1925             return
1926         if len(sig.parameters) == 1:
1927             return
1928 
1929         params = list(sig.parameters.values())
1930         if params[1].annotation is Parameter.empty:
1931             params[1] = params[1].replace(annotation=typ)
1932             try:
1933                 func.__signature__ = sig.replace(parameters=params)  # type: ignore
1934             except TypeError:
1935                 # failed to update signature (ex. built-in or extension types)
1936                 return
1937 
1938 
1939 class SingledispatchMethodDocumenter(MethodDocumenter):
1940     """
1941     Used to be a specialized Documenter subclass for singledispatch'ed methods.
1942 
1943     Retained for backwards compatibility, now does the same as the MethodDocumenter
1944     """
1945 
1946     def __init__(self, *args: Any, **kwargs: Any) -> None:
1947         warnings.warn("%s is deprecated." % self.__class__.__name__,
1948                       RemovedInSphinx50Warning, stacklevel=2)
1949         super().__init__(*args, **kwargs)
1950 
1951 
1952 class AttributeDocumenter(DocstringStripSignatureMixin, ClassLevelDocumenter):  # type: ignore
1953     """
1954     Specialized Documenter subclass for attributes.
1955     """
1956     objtype = 'attribute'
1957     member_order = 60
1958     option_spec = dict(ModuleLevelDocumenter.option_spec)
1959     option_spec["annotation"] = annotation_option
1960 
1961     # must be higher than the MethodDocumenter, else it will recognize
1962     # some non-data descriptors as methods
1963     priority = 10
1964 
1965     @staticmethod
1966     def is_function_or_method(obj: Any) -> bool:
1967         return inspect.isfunction(obj) or inspect.isbuiltin(obj) or inspect.ismethod(obj)
1968 
1969     @classmethod
1970     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
1971                             ) -> bool:
1972         if inspect.isattributedescriptor(member):
1973             return True
1974         elif (not isinstance(parent, ModuleDocumenter) and
1975               not inspect.isroutine(member) and
1976               not isinstance(member, type)):
1977             return True
1978         else:
1979             return False
1980 
1981     def document_members(self, all_members: bool = False) -> None:
1982         pass
1983 
1984     def isinstanceattribute(self) -> bool:
1985         """Check the subject is an instance attribute."""
1986         try:
1987             analyzer = ModuleAnalyzer.for_module(self.modname)
1988             attr_docs = analyzer.find_attr_docs()
1989             if self.objpath:
1990                 key = ('.'.join(self.objpath[:-1]), self.objpath[-1])
1991                 if key in attr_docs:
1992                     return True
1993 
1994             return False
1995         except PycodeError:
1996             return False
1997 
1998     def import_object(self, raiseerror: bool = False) -> bool:
1999         try:
2000             ret = super().import_object(raiseerror=True)
2001             if inspect.isenumattribute(self.object):
2002                 self.object = self.object.value
2003             if inspect.isattributedescriptor(self.object):
2004                 self._datadescriptor = True
2005             else:
2006                 # if it's not a data descriptor
2007                 self._datadescriptor = False
2008         except ImportError as exc:
2009             if self.isinstanceattribute():
2010                 self.object = INSTANCEATTR
2011                 self._datadescriptor = False
2012                 ret = True
2013             elif raiseerror:
2014                 raise
2015             else:
2016                 logger.warning(exc.args[0], type='autodoc', subtype='import_object')
2017                 self.env.note_reread()
2018                 ret = False
2019 
2020         return ret
2021 
2022     def get_real_modname(self) -> str:
2023         return self.get_attr(self.parent or self.object, '__module__', None) \
2024             or self.modname
2025 
2026     def add_directive_header(self, sig: str) -> None:
2027         super().add_directive_header(sig)
2028         sourcename = self.get_sourcename()
2029         if not self.options.annotation:
2030             # obtain type annotation for this attribute
2031             try:
2032                 annotations = get_type_hints(self.parent)
2033             except NameError:
2034                 # Failed to evaluate ForwardRef (maybe TYPE_CHECKING)
2035                 annotations = safe_getattr(self.parent, '__annotations__', {})
2036             except TypeError:
2037                 annotations = {}
2038             except KeyError:
2039                 # a broken class found (refs: https://github.com/sphinx-doc/sphinx/issues/8084)
2040                 annotations = {}
2041             except AttributeError:
2042                 # AttributeError is raised on 3.5.2 (fixed by 3.5.3)
2043                 annotations = {}
2044 
2045             if self.objpath[-1] in annotations:
2046                 objrepr = stringify_typehint(annotations.get(self.objpath[-1]))
2047                 self.add_line('   :type: ' + objrepr, sourcename)
2048             else:
2049                 key = ('.'.join(self.objpath[:-1]), self.objpath[-1])
2050                 if self.analyzer and key in self.analyzer.annotations:
2051                     self.add_line('   :type: ' + self.analyzer.annotations[key],
2052                                   sourcename)
2053 
2054             # data descriptors do not have useful values
2055             if not self._datadescriptor:
2056                 try:
2057                     if self.object is INSTANCEATTR:
2058                         pass
2059                     else:
2060                         objrepr = object_description(self.object)
2061                         self.add_line('   :value: ' + objrepr, sourcename)
2062                 except ValueError:
2063                     pass
2064         elif self.options.annotation is SUPPRESS:
2065             pass
2066         else:
2067             self.add_line('   :annotation: %s' % self.options.annotation, sourcename)
2068 
2069     def get_doc(self, encoding: str = None, ignore: int = None) -> List[List[str]]:
2070         try:
2071             # Disable `autodoc_inherit_docstring` temporarily to avoid to obtain
2072             # a docstring from the value which descriptor returns unexpectedly.
2073             # ref: https://github.com/sphinx-doc/sphinx/issues/7805
2074             orig = self.env.config.autodoc_inherit_docstrings
2075             self.env.config.autodoc_inherit_docstrings = False  # type: ignore
2076             return super().get_doc(encoding, ignore)
2077         finally:
2078             self.env.config.autodoc_inherit_docstrings = orig  # type: ignore
2079 
2080     def add_content(self, more_content: Any, no_docstring: bool = False) -> None:
2081         if not self._datadescriptor:
2082             # if it's not a data descriptor, its docstring is very probably the
2083             # wrong thing to display
2084             no_docstring = True
2085         super().add_content(more_content, no_docstring)
2086 
2087 
2088 class PropertyDocumenter(DocstringStripSignatureMixin, ClassLevelDocumenter):  # type: ignore
2089     """
2090     Specialized Documenter subclass for properties.
2091     """
2092     objtype = 'property'
2093     directivetype = 'method'
2094     member_order = 60
2095 
2096     # before AttributeDocumenter
2097     priority = AttributeDocumenter.priority + 1
2098 
2099     @classmethod
2100     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
2101                             ) -> bool:
2102         return inspect.isproperty(member) and isinstance(parent, ClassDocumenter)
2103 
2104     def document_members(self, all_members: bool = False) -> None:
2105         pass
2106 
2107     def get_real_modname(self) -> str:
2108         return self.get_attr(self.parent or self.object, '__module__', None) \
2109             or self.modname
2110 
2111     def add_directive_header(self, sig: str) -> None:
2112         super().add_directive_header(sig)
2113         sourcename = self.get_sourcename()
2114         if inspect.isabstractmethod(self.object):
2115             self.add_line('   :abstractmethod:', sourcename)
2116         self.add_line('   :property:', sourcename)
2117 
2118 
2119 class InstanceAttributeDocumenter(AttributeDocumenter):
2120     """
2121     Specialized Documenter subclass for attributes that cannot be imported
2122     because they are instance attributes (e.g. assigned in __init__).
2123     """
2124     objtype = 'instanceattribute'
2125     directivetype = 'attribute'
2126     member_order = 60
2127 
2128     # must be higher than AttributeDocumenter
2129     priority = 11
2130 
2131     @classmethod
2132     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
2133                             ) -> bool:
2134         """This documents only INSTANCEATTR members."""
2135         return (not isinstance(parent, ModuleDocumenter) and
2136                 isattr and
2137                 member is INSTANCEATTR)
2138 
2139     def import_parent(self) -> Any:
2140         try:
2141             parent = importlib.import_module(self.modname)
2142             for name in self.objpath[:-1]:
2143                 parent = self.get_attr(parent, name)
2144 
2145             return parent
2146         except (ImportError, AttributeError):
2147             return None
2148 
2149     def import_object(self, raiseerror: bool = False) -> bool:
2150         """Never import anything."""
2151         # disguise as an attribute
2152         self.objtype = 'attribute'
2153         self.object = INSTANCEATTR
2154         self.parent = self.import_parent()
2155         self._datadescriptor = False
2156         return True
2157 
2158     def add_content(self, more_content: Any, no_docstring: bool = False) -> None:
2159         """Never try to get a docstring from the object."""
2160         super().add_content(more_content, no_docstring=True)
2161 
2162 
2163 class SlotsAttributeDocumenter(AttributeDocumenter):
2164     """
2165     Specialized Documenter subclass for attributes that cannot be imported
2166     because they are attributes in __slots__.
2167     """
2168     objtype = 'slotsattribute'
2169     directivetype = 'attribute'
2170     member_order = 60
2171 
2172     # must be higher than AttributeDocumenter
2173     priority = 11
2174 
2175     @classmethod
2176     def can_document_member(cls, member: Any, membername: str, isattr: bool, parent: Any
2177                             ) -> bool:
2178         """This documents only SLOTSATTR members."""
2179         return member is SLOTSATTR
2180 
2181     def import_object(self, raiseerror: bool = False) -> bool:
2182         """Never import anything."""
2183         # disguise as an attribute
2184         self.objtype = 'attribute'
2185         self._datadescriptor = True
2186 
2187         with mock(self.env.config.autodoc_mock_imports):
2188             try:
2189                 ret = import_object(self.modname, self.objpath[:-1], 'class',
2190                                     attrgetter=self.get_attr,
2191                                     warningiserror=self.env.config.autodoc_warningiserror)
2192                 self.module, _, _, self.parent = ret
2193                 return True
2194             except ImportError as exc:
2195                 if raiseerror:
2196                     raise
2197                 else:
2198                     logger.warning(exc.args[0], type='autodoc', subtype='import_object')
2199                     self.env.note_reread()
2200                     return False
2201 
2202     def get_doc(self, encoding: str = None, ignore: int = None) -> List[List[str]]:
2203         """Decode and return lines of the docstring(s) for the object."""
2204         if ignore is not None:
2205             warnings.warn("The 'ignore' argument to autodoc.%s.get_doc() is deprecated."
2206                           % self.__class__.__name__,
2207                           RemovedInSphinx50Warning, stacklevel=2)
2208         name = self.objpath[-1]
2209         __slots__ = safe_getattr(self.parent, '__slots__', [])
2210         if isinstance(__slots__, dict) and isinstance(__slots__.get(name), str):
2211             docstring = prepare_docstring(__slots__[name])
2212             return [docstring]
2213         else:
2214             return []
2215 
2216 
2217 def get_documenters(app: Sphinx) -> Dict[str, "Type[Documenter]"]:
2218     """Returns registered Documenter classes"""
2219     warnings.warn("get_documenters() is deprecated.", RemovedInSphinx50Warning, stacklevel=2)
2220     return app.registry.documenters
2221 
2222 
2223 def autodoc_attrgetter(app: Sphinx, obj: Any, name: str, *defargs: Any) -> Any:
2224     """Alternative getattr() for types"""
2225     for typ, func in app.registry.autodoc_attrgettrs.items():
2226         if isinstance(obj, typ):
2227             return func(obj, name, *defargs)
2228 
2229     return safe_getattr(obj, name, *defargs)
2230 
2231 
2232 def migrate_autodoc_member_order(app: Sphinx, config: Config) -> None:
2233     if config.autodoc_member_order == 'alphabetic':
2234         # RemovedInSphinx50Warning
2235         logger.warning(__('autodoc_member_order now accepts "alphabetical" '
2236                           'instead of "alphabetic". Please update your setting.'))
2237         config.autodoc_member_order = 'alphabetical'  # type: ignore
2238 
2239 
2240 def setup(app: Sphinx) -> Dict[str, Any]:
2241     app.add_autodocumenter(ModuleDocumenter)
2242     app.add_autodocumenter(ClassDocumenter)
2243     app.add_autodocumenter(ExceptionDocumenter)
2244     app.add_autodocumenter(DataDocumenter)
2245     app.add_autodocumenter(DataDeclarationDocumenter)
2246     app.add_autodocumenter(GenericAliasDocumenter)
2247     app.add_autodocumenter(TypeVarDocumenter)
2248     app.add_autodocumenter(FunctionDocumenter)
2249     app.add_autodocumenter(DecoratorDocumenter)
2250     app.add_autodocumenter(MethodDocumenter)
2251     app.add_autodocumenter(AttributeDocumenter)
2252     app.add_autodocumenter(PropertyDocumenter)
2253     app.add_autodocumenter(InstanceAttributeDocumenter)
2254     app.add_autodocumenter(SlotsAttributeDocumenter)
2255 
2256     app.add_config_value('autoclass_content', 'class', True, ENUM('both', 'class', 'init'))
2257     app.add_config_value('autodoc_member_order', 'alphabetical', True,
2258                          ENUM('alphabetic', 'alphabetical', 'bysource', 'groupwise'))
2259     app.add_config_value('autodoc_default_options', {}, True)
2260     app.add_config_value('autodoc_docstring_signature', True, True)
2261     app.add_config_value('autodoc_mock_imports', [], True)
2262     app.add_config_value('autodoc_typehints', "signature", True,
2263                          ENUM("signature", "description", "none"))
2264     app.add_config_value('autodoc_type_aliases', {}, True)
2265     app.add_config_value('autodoc_warningiserror', True, True)
2266     app.add_config_value('autodoc_inherit_docstrings', True, True)
2267     app.add_event('autodoc-before-process-signature')
2268     app.add_event('autodoc-process-docstring')
2269     app.add_event('autodoc-process-signature')
2270     app.add_event('autodoc-skip-member')
2271 
2272     app.connect('config-inited', migrate_autodoc_member_order, priority=800)
2273 
2274     app.setup_extension('sphinx.ext.autodoc.type_comment')
2275     app.setup_extension('sphinx.ext.autodoc.typehints')
2276 
2277     return {'version': sphinx.__display_version__, 'parallel_read_safe': True}

</code><intended_behavior>This file, particularly in the section related to function signature processing, should be modified to correctly handle and preserve hexadecimal default values in function signatures when generating documentation. The code should detect when a default value is expressed in hexadecimal format and ensure that this format is maintained in the output documentation, rather than converting it to decimal. This will involve checking the format of default arguments and applying a condition to preserve the original format (hexadecimal, octal, etc.) in the rendered documentation.</intended_behavior>, <file>sphinx/domains/python.py</file>
<class>None</class>
<method>_pseudo_parse_arglist</method>
<code>
218 def _pseudo_parse_arglist(signode: desc_signature, arglist: str) -> None:
219     """"Parse" a list of arguments separated by commas.
220 
221     Arguments can have "optional" annotations given by enclosing them in
222     brackets.  Currently, this will split at any comma, even if it's inside a
223     string literal (e.g. default argument value).
224     """
225     paramlist = addnodes.desc_parameterlist()
226     stack = [paramlist]  # type: List[Element]
227     try:
228         for argument in arglist.split(','):
229             argument = argument.strip()
230             ends_open = ends_close = 0
231             while argument.startswith('['):
232                 stack.append(addnodes.desc_optional())
233                 stack[-2] += stack[-1]
234                 argument = argument[1:].strip()
235             while argument.startswith(']'):
236                 stack.pop()
237                 argument = argument[1:].strip()
238             while argument.endswith(']') and not argument.endswith('[]'):
239                 ends_close += 1
240                 argument = argument[:-1].strip()
241             while argument.endswith('['):
242                 ends_open += 1
243                 argument = argument[:-1].strip()
244             if argument:
245                 stack[-1] += addnodes.desc_parameter(argument, argument)
246             while ends_open:
247                 stack.append(addnodes.desc_optional())
248                 stack[-2] += stack[-1]
249                 ends_open -= 1
250             while ends_close:
251                 stack.pop()
252                 ends_close -= 1
253         if len(stack) != 1:
254             raise IndexError
255     except IndexError:
256         # if there are too few or too many elements on the stack, just give up
257         # and treat the whole argument list as one argument, discarding the
258         # already partially populated paramlist node
259         paramlist = addnodes.desc_parameterlist()
260         paramlist += addnodes.desc_parameter(arglist, arglist)
261         signode += paramlist
262     else:
263         signode += paramlist

</code><intended_behavior>In the `_pseudo_parse_arglist` method, which is involved in parsing function arguments and their annotations, care should be taken to accurately parse and maintain the representation of default arguments. If a default argument is specified in hexadecimal (or any non-decimal base), this method should ensure that the original representation is preserved in the documentation output. This might require including logic to detect the format of the default value and ensuring that this format is not altered during the documentation generation process.</intended_behavior>]
2025-10-18 18:35:42.314 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-18 18:35:42.314 | INFO     | Search-only: skipping patch selection
2025-10-18 18:35:42.437 | INFO     | Task sphinx-doc__sphinx-8278 completed successfully.
2025-10-18 18:35:42.438 | INFO     | No patch generated. You can try running ACR again.
