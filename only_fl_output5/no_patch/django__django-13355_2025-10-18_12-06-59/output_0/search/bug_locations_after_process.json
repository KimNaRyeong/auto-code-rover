[
    {
        "rel_file_path": "django/forms/widgets.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.2/django/forms/widgets.py",
        "start": 147,
        "end": 151,
        "class_name": "Media",
        "method_name": "__add__",
        "code": "147     def __add__(self, other):\n148         combined = Media()\n149         combined._css_lists = self._css_lists + other._css_lists\n150         combined._js_lists = self._js_lists + other._js_lists\n151         return combined\n",
        "intended_behavior": "The `__add__` method needs to be optimized for scenarios where a large number of `Media` objects are combined. Introduce conditional logic for merging lists based on size, use a flat list or efficient data structure for merges, and ensure the optimized behavior preserves aggregate CSS and JS references without performance degradation."
    },
    {
        "rel_file_path": "django/forms/widgets.py",
        "abs_file_path": "/home/kimnal0/auto-code-rover/SWE-bench/testbed/django__django/setup_django__django__3.2/django/forms/widgets.py",
        "start": 45,
        "end": 151,
        "class_name": "Media",
        "method_name": null,
        "code": "45 class Media:\n46     def __init__(self, media=None, css=None, js=None):\n47         if media is not None:\n48             css = getattr(media, 'css', {})\n49             js = getattr(media, 'js', [])\n50         else:\n51             if css is None:\n52                 css = {}\n53             if js is None:\n54                 js = []\n55         self._css_lists = [css]\n56         self._js_lists = [js]\n57 \n58     def __repr__(self):\n59         return 'Media(css=%r, js=%r)' % (self._css, self._js)\n60 \n61     def __str__(self):\n62         return self.render()\n63 \n64     @property\n65     def _css(self):\n66         css = defaultdict(list)\n67         for css_list in self._css_lists:\n68             for medium, sublist in css_list.items():\n69                 css[medium].append(sublist)\n70         return {medium: self.merge(*lists) for medium, lists in css.items()}\n71 \n72     @property\n73     def _js(self):\n74         return self.merge(*self._js_lists)\n75 \n76     def render(self):\n77         return mark_safe('\\n'.join(chain.from_iterable(getattr(self, 'render_' + name)() for name in MEDIA_TYPES)))\n78 \n79     def render_js(self):\n80         return [\n81             format_html(\n82                 '<script src=\"{}\"></script>',\n83                 self.absolute_path(path)\n84             ) for path in self._js\n85         ]\n86 \n87     def render_css(self):\n88         # To keep rendering order consistent, we can't just iterate over items().\n89         # We need to sort the keys, and iterate over the sorted list.\n90         media = sorted(self._css)\n91         return chain.from_iterable([\n92             format_html(\n93                 '<link href=\"{}\" type=\"text/css\" media=\"{}\" rel=\"stylesheet\">',\n94                 self.absolute_path(path), medium\n95             ) for path in self._css[medium]\n96         ] for medium in media)\n97 \n98     def absolute_path(self, path):\n99         \"\"\"\n100         Given a relative or absolute path to a static asset, return an absolute\n101         path. An absolute path will be returned unchanged while a relative path\n102         will be passed to django.templatetags.static.static().\n103         \"\"\"\n104         if path.startswith(('http://', 'https://', '/')):\n105             return path\n106         return static(path)\n107 \n108     def __getitem__(self, name):\n109         \"\"\"Return a Media object that only contains media of the given type.\"\"\"\n110         if name in MEDIA_TYPES:\n111             return Media(**{str(name): getattr(self, '_' + name)})\n112         raise KeyError('Unknown media type \"%s\"' % name)\n113 \n114     @staticmethod\n115     def merge(*lists):\n116         \"\"\"\n117         Merge lists while trying to keep the relative order of the elements.\n118         Warn if the lists have the same elements in a different relative order.\n119 \n120         For static assets it can be important to have them included in the DOM\n121         in a certain order. In JavaScript you may not be able to reference a\n122         global or in CSS you might want to override a style.\n123         \"\"\"\n124         dependency_graph = defaultdict(set)\n125         all_items = OrderedSet()\n126         for list_ in filter(None, lists):\n127             head = list_[0]\n128             # The first items depend on nothing but have to be part of the\n129             # dependency graph to be included in the result.\n130             dependency_graph.setdefault(head, set())\n131             for item in list_:\n132                 all_items.add(item)\n133                 # No self dependencies\n134                 if head != item:\n135                     dependency_graph[item].add(head)\n136                 head = item\n137         try:\n138             return stable_topological_sort(all_items, dependency_graph)\n139         except CyclicDependencyError:\n140             warnings.warn(\n141                 'Detected duplicate Media files in an opposite order: {}'.format(\n142                     ', '.join(repr(list_) for list_ in lists)\n143                 ), MediaOrderConflictWarning,\n144             )\n145             return list(all_items)\n146 \n147     def __add__(self, other):\n148         combined = Media()\n149         combined._css_lists = self._css_lists + other._css_lists\n150         combined._js_lists = self._js_lists + other._js_lists\n151         return combined\n",
        "intended_behavior": "This class provides additional context to the issue."
    }
]