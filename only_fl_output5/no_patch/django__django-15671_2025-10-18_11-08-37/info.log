2025-10-18 11:08:37.529 | INFO     | Starting overall retry 0 with model gpt-4-0125-preview
2025-10-18 11:08:42.275 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=146, output_tokens=12, cost=0.001820
2025-10-18 11:08:42.275 | INFO     | Test agent decides that the issue statement does not contain reproduction steps; skipping reproducer tracing
2025-10-18 11:08:42.279 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 11:08:49.226 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=455, output_tokens=282, cost=0.013010
2025-10-18 11:08:49.233 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 11:08:52.691 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=636, output_tokens=87, cost=0.008970
2025-10-18 11:08:52.692 | DEBUG    | Extracted a valid json.
2025-10-18 11:08:52.692 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_class(\"FormSet\")",
        "search_method_in_class(\"add_error\", \"FormSet\")",
        "search_code(\"error_messages\")",
        "search_code_in_file(\"error_messages\", \"<file name from the result of search_class('FormSet')>\")",
        "search_method(\"inlineformset_factory\")"
    ],
    "bug_locations": []
}
2025-10-18 11:08:52.905 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-18 11:08:52.906 | DEBUG    | <Agent search> Analyzing search results.
2025-10-18 11:09:04.410 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=1976, output_tokens=561, cost=0.036590
2025-10-18 11:09:04.420 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 11:09:12.559 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=2753, output_tokens=371, cost=0.038660
2025-10-18 11:09:12.567 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 11:09:21.083 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=725, output_tokens=346, cost=0.017630
2025-10-18 11:09:21.084 | DEBUG    | Extracted a valid json.
2025-10-18 11:09:21.084 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [
        "search_code_in_file(\"BaseFormSet\", \"django/forms/formsets.py\")",
        "search_code_in_file(\"default_error_messages\", \"django/forms/formsets.py\")"
    ],
    "bug_locations": [
        {
            "file": "django/forms/formsets.py",
            "class": "BaseFormSet",
            "method": "",
            "intended_behavior": "The `BaseFormSet` class should include `default_error_messages` within its properties, allowing these messages to be customized through an `error_messages` argument during instantiation. This attribute should map keys such as `too_many_forms` and `too_few_forms` to their respective default messages. The instantiation process should then merge any provided `error_messages` with these defaults, allowing for easy overriding without changing the global defaults. This enhancement will enable developers to specify custom error messages for too many or too few forms directly when creating a `FormSet`, thus addressing the issue's requirement."
        },
        {
            "file": "django/forms/models.py",
            "class": "",
            "method": "inlineformset_factory",
            "intended_behavior": "The `inlineformset_factory` function should explicitly document and handle the `error_messages` parameter, ensuring it's passed down to the `BaseFormSet` properly. While the function already supports an `error_messages` argument, the handling and documentation around this parameter might need clarification or adjustment to ensure that it supports overriding messages about the number of forms. This might not require a code change if it's already supported but ensuring the documentation is clear about this capability is crucial to address the user's issue."
        }
    ]
}
2025-10-18 11:09:21.119 | DEBUG    | Obtained search results from API invocation. Going into next retrieval round.
2025-10-18 11:09:21.120 | DEBUG    | <Agent search> Analyzing search results.
2025-10-18 11:09:33.009 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=3736, output_tokens=580, cost=0.054760
2025-10-18 11:09:33.019 | DEBUG    | <Agent search> Selecting APIs to call.
2025-10-18 11:09:41.223 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=4532, output_tokens=342, cost=0.055580
2025-10-18 11:09:41.230 | DEBUG    | Trying to convert API calls/bug locations into json. Try 1 of 5.
2025-10-18 11:09:48.361 | INFO     | Model (gpt-4-0125-preview) API request cost info: input_tokens=696, output_tokens=298, cost=0.015900
2025-10-18 11:09:48.362 | DEBUG    | Extracted a valid json.
2025-10-18 11:09:48.362 | DEBUG    | Agent proxy return the following json: {
    "API_calls": [],
    "bug_locations":[
        {
            "file": "django/forms/formsets.py",
            "class": "BaseFormSet",
            "method": "N/A",
            "intended_behavior": "Extend the `default_error_messages` dictionary within `BaseFormSet` to include two new keys: `too_many_forms` and `too_few_forms`, with sensible default messages. This is in preparation for enabling these messages to be overridden more intuitively. The implementation should ensure these new keys are used in the validation logic that checks form counts against the set limits (min_num and max_num), thus providing feedback when these conditions are not met. This approach allows developers to customize error messages related to the number of forms more effectively without altering the existing functionality."
        },
        {
            "file": "django/forms/formsets.py",
            "class": "BaseFormSet",
            "method": "__init__",
            "intended_behavior": "While the `__init__` method already merges the `default_error_messages` with any provided `error_messages`, ensuring this process includes our newly introduced messages (`too_many_forms` and `too_few_forms`) allows for their customization at instantiation. Clarification in the class documentation about how to override these (and potentially other) error messages would be helpful for developers, preserving the functionality of error message customization while enhancing its usability for more specific formset validations."
        }
    ]
}
2025-10-18 11:09:48.371 | DEBUG    | Bug location extracted successfully: [<file>django/forms/formsets.py</file>
<class>BaseFormSet</class>
<method>None</method>
<code>
52 class BaseFormSet(RenderableFormMixin):
53     """
54     A collection of instances of the same Form class.
55     """
56 
57     deletion_widget = CheckboxInput
58     ordering_widget = NumberInput
59     default_error_messages = {
60         "missing_management_form": _(
61             "ManagementForm data is missing or has been tampered with. Missing fields: "
62             "%(field_names)s. You may need to file a bug report if the issue persists."
63         ),
64     }
65 
66     template_name_div = "django/forms/formsets/div.html"
67     template_name_p = "django/forms/formsets/p.html"
68     template_name_table = "django/forms/formsets/table.html"
69     template_name_ul = "django/forms/formsets/ul.html"
70 
71     def __init__(
72         self,
73         data=None,
74         files=None,
75         auto_id="id_%s",
76         prefix=None,
77         initial=None,
78         error_class=ErrorList,
79         form_kwargs=None,
80         error_messages=None,
81     ):
82         self.is_bound = data is not None or files is not None
83         self.prefix = prefix or self.get_default_prefix()
84         self.auto_id = auto_id
85         self.data = data or {}
86         self.files = files or {}
87         self.initial = initial
88         self.form_kwargs = form_kwargs or {}
89         self.error_class = error_class
90         self._errors = None
91         self._non_form_errors = None
92 
93         messages = {}
94         for cls in reversed(type(self).__mro__):
95             messages.update(getattr(cls, "default_error_messages", {}))
96         if error_messages is not None:
97             messages.update(error_messages)
98         self.error_messages = messages
99 
100     def __iter__(self):
101         """Yield the forms in the order they should be rendered."""
102         return iter(self.forms)
103 
104     def __getitem__(self, index):
105         """Return the form at the given index, based on the rendering order."""
106         return self.forms[index]
107 
108     def __len__(self):
109         return len(self.forms)
110 
111     def __bool__(self):
112         """
113         Return True since all formsets have a management form which is not
114         included in the length.
115         """
116         return True
117 
118     def __repr__(self):
119         if self._errors is None:
120             is_valid = "Unknown"
121         else:
122             is_valid = (
123                 self.is_bound
124                 and not self._non_form_errors
125                 and not any(form_errors for form_errors in self._errors)
126             )
127         return "<%s: bound=%s valid=%s total_forms=%s>" % (
128             self.__class__.__qualname__,
129             self.is_bound,
130             is_valid,
131             self.total_form_count(),
132         )
133 
134     @cached_property
135     def management_form(self):
136         """Return the ManagementForm instance for this FormSet."""
137         if self.is_bound:
138             form = ManagementForm(
139                 self.data,
140                 auto_id=self.auto_id,
141                 prefix=self.prefix,
142                 renderer=self.renderer,
143             )
144             form.full_clean()
145         else:
146             form = ManagementForm(
147                 auto_id=self.auto_id,
148                 prefix=self.prefix,
149                 initial={
150                     TOTAL_FORM_COUNT: self.total_form_count(),
151                     INITIAL_FORM_COUNT: self.initial_form_count(),
152                     MIN_NUM_FORM_COUNT: self.min_num,
153                     MAX_NUM_FORM_COUNT: self.max_num,
154                 },
155                 renderer=self.renderer,
156             )
157         return form
158 
159     def total_form_count(self):
160         """Return the total number of forms in this FormSet."""
161         if self.is_bound:
162             # return absolute_max if it is lower than the actual total form
163             # count in the data; this is DoS protection to prevent clients
164             # from forcing the server to instantiate arbitrary numbers of
165             # forms
166             return min(
167                 self.management_form.cleaned_data[TOTAL_FORM_COUNT], self.absolute_max
168             )
169         else:
170             initial_forms = self.initial_form_count()
171             total_forms = max(initial_forms, self.min_num) + self.extra
172             # Allow all existing related objects/inlines to be displayed,
173             # but don't allow extra beyond max_num.
174             if initial_forms > self.max_num >= 0:
175                 total_forms = initial_forms
176             elif total_forms > self.max_num >= 0:
177                 total_forms = self.max_num
178         return total_forms
179 
180     def initial_form_count(self):
181         """Return the number of forms that are required in this FormSet."""
182         if self.is_bound:
183             return self.management_form.cleaned_data[INITIAL_FORM_COUNT]
184         else:
185             # Use the length of the initial data if it's there, 0 otherwise.
186             initial_forms = len(self.initial) if self.initial else 0
187         return initial_forms
188 
189     @cached_property
190     def forms(self):
191         """Instantiate forms at first property access."""
192         # DoS protection is included in total_form_count()
193         return [
194             self._construct_form(i, **self.get_form_kwargs(i))
195             for i in range(self.total_form_count())
196         ]
197 
198     def get_form_kwargs(self, index):
199         """
200         Return additional keyword arguments for each individual formset form.
201 
202         index will be None if the form being constructed is a new empty
203         form.
204         """
205         return self.form_kwargs.copy()
206 
207     def _construct_form(self, i, **kwargs):
208         """Instantiate and return the i-th form instance in a formset."""
209         defaults = {
210             "auto_id": self.auto_id,
211             "prefix": self.add_prefix(i),
212             "error_class": self.error_class,
213             # Don't render the HTML 'required' attribute as it may cause
214             # incorrect validation for extra, optional, and deleted
215             # forms in the formset.
216             "use_required_attribute": False,
217             "renderer": self.renderer,
218         }
219         if self.is_bound:
220             defaults["data"] = self.data
221             defaults["files"] = self.files
222         if self.initial and "initial" not in kwargs:
223             try:
224                 defaults["initial"] = self.initial[i]
225             except IndexError:
226                 pass
227         # Allow extra forms to be empty, unless they're part of
228         # the minimum forms.
229         if i >= self.initial_form_count() and i >= self.min_num:
230             defaults["empty_permitted"] = True
231         defaults.update(kwargs)
232         form = self.form(**defaults)
233         self.add_fields(form, i)
234         return form
235 
236     @property
237     def initial_forms(self):
238         """Return a list of all the initial forms in this formset."""
239         return self.forms[: self.initial_form_count()]
240 
241     @property
242     def extra_forms(self):
243         """Return a list of all the extra forms in this formset."""
244         return self.forms[self.initial_form_count() :]
245 
246     @property
247     def empty_form(self):
248         form = self.form(
249             auto_id=self.auto_id,
250             prefix=self.add_prefix("__prefix__"),
251             empty_permitted=True,
252             use_required_attribute=False,
253             **self.get_form_kwargs(None),
254             renderer=self.renderer,
255         )
256         self.add_fields(form, None)
257         return form
258 
259     @property
260     def cleaned_data(self):
261         """
262         Return a list of form.cleaned_data dicts for every form in self.forms.
263         """
264         if not self.is_valid():
265             raise AttributeError(
266                 "'%s' object has no attribute 'cleaned_data'" % self.__class__.__name__
267             )
268         return [form.cleaned_data for form in self.forms]
269 
270     @property
271     def deleted_forms(self):
272         """Return a list of forms that have been marked for deletion."""
273         if not self.is_valid() or not self.can_delete:
274             return []
275         # construct _deleted_form_indexes which is just a list of form indexes
276         # that have had their deletion widget set to True
277         if not hasattr(self, "_deleted_form_indexes"):
278             self._deleted_form_indexes = []
279             for i, form in enumerate(self.forms):
280                 # if this is an extra form and hasn't changed, don't consider it
281                 if i >= self.initial_form_count() and not form.has_changed():
282                     continue
283                 if self._should_delete_form(form):
284                     self._deleted_form_indexes.append(i)
285         return [self.forms[i] for i in self._deleted_form_indexes]
286 
287     @property
288     def ordered_forms(self):
289         """
290         Return a list of form in the order specified by the incoming data.
291         Raise an AttributeError if ordering is not allowed.
292         """
293         if not self.is_valid() or not self.can_order:
294             raise AttributeError(
295                 "'%s' object has no attribute 'ordered_forms'" % self.__class__.__name__
296             )
297         # Construct _ordering, which is a list of (form_index, order_field_value)
298         # tuples. After constructing this list, we'll sort it by order_field_value
299         # so we have a way to get to the form indexes in the order specified
300         # by the form data.
301         if not hasattr(self, "_ordering"):
302             self._ordering = []
303             for i, form in enumerate(self.forms):
304                 # if this is an extra form and hasn't changed, don't consider it
305                 if i >= self.initial_form_count() and not form.has_changed():
306                     continue
307                 # don't add data marked for deletion to self.ordered_data
308                 if self.can_delete and self._should_delete_form(form):
309                     continue
310                 self._ordering.append((i, form.cleaned_data[ORDERING_FIELD_NAME]))
311             # After we're done populating self._ordering, sort it.
312             # A sort function to order things numerically ascending, but
313             # None should be sorted below anything else. Allowing None as
314             # a comparison value makes it so we can leave ordering fields
315             # blank.
316 
317             def compare_ordering_key(k):
318                 if k[1] is None:
319                     return (1, 0)  # +infinity, larger than any number
320                 return (0, k[1])
321 
322             self._ordering.sort(key=compare_ordering_key)
323         # Return a list of form.cleaned_data dicts in the order specified by
324         # the form data.
325         return [self.forms[i[0]] for i in self._ordering]
326 
327     @classmethod
328     def get_default_prefix(cls):
329         return "form"
330 
331     @classmethod
332     def get_deletion_widget(cls):
333         return cls.deletion_widget
334 
335     @classmethod
336     def get_ordering_widget(cls):
337         return cls.ordering_widget
338 
339     def non_form_errors(self):
340         """
341         Return an ErrorList of errors that aren't associated with a particular
342         form -- i.e., from formset.clean(). Return an empty ErrorList if there
343         are none.
344         """
345         if self._non_form_errors is None:
346             self.full_clean()
347         return self._non_form_errors
348 
349     @property
350     def errors(self):
351         """Return a list of form.errors for every form in self.forms."""
352         if self._errors is None:
353             self.full_clean()
354         return self._errors
355 
356     def total_error_count(self):
357         """Return the number of errors across all forms in the formset."""
358         return len(self.non_form_errors()) + sum(
359             len(form_errors) for form_errors in self.errors
360         )
361 
362     def _should_delete_form(self, form):
363         """Return whether or not the form was marked for deletion."""
364         return form.cleaned_data.get(DELETION_FIELD_NAME, False)
365 
366     def is_valid(self):
367         """Return True if every form in self.forms is valid."""
368         if not self.is_bound:
369             return False
370         # Accessing errors triggers a full clean the first time only.
371         self.errors
372         # List comprehension ensures is_valid() is called for all forms.
373         # Forms due to be deleted shouldn't cause the formset to be invalid.
374         forms_valid = all(
375             [
376                 form.is_valid()
377                 for form in self.forms
378                 if not (self.can_delete and self._should_delete_form(form))
379             ]
380         )
381         return forms_valid and not self.non_form_errors()
382 
383     def full_clean(self):
384         """
385         Clean all of self.data and populate self._errors and
386         self._non_form_errors.
387         """
388         self._errors = []
389         self._non_form_errors = self.error_class(
390             error_class="nonform", renderer=self.renderer
391         )
392         empty_forms_count = 0
393 
394         if not self.is_bound:  # Stop further processing.
395             return
396 
397         if not self.management_form.is_valid():
398             error = ValidationError(
399                 self.error_messages["missing_management_form"],
400                 params={
401                     "field_names": ", ".join(
402                         self.management_form.add_prefix(field_name)
403                         for field_name in self.management_form.errors
404                     ),
405                 },
406                 code="missing_management_form",
407             )
408             self._non_form_errors.append(error)
409 
410         for i, form in enumerate(self.forms):
411             # Empty forms are unchanged forms beyond those with initial data.
412             if not form.has_changed() and i >= self.initial_form_count():
413                 empty_forms_count += 1
414             # Accessing errors calls full_clean() if necessary.
415             # _should_delete_form() requires cleaned_data.
416             form_errors = form.errors
417             if self.can_delete and self._should_delete_form(form):
418                 continue
419             self._errors.append(form_errors)
420         try:
421             if (
422                 self.validate_max
423                 and self.total_form_count() - len(self.deleted_forms) > self.max_num
424             ) or self.management_form.cleaned_data[
425                 TOTAL_FORM_COUNT
426             ] > self.absolute_max:
427                 raise ValidationError(
428                     ngettext(
429                         "Please submit at most %d form.",
430                         "Please submit at most %d forms.",
431                         self.max_num,
432                     )
433                     % self.max_num,
434                     code="too_many_forms",
435                 )
436             if (
437                 self.validate_min
438                 and self.total_form_count()
439                 - len(self.deleted_forms)
440                 - empty_forms_count
441                 < self.min_num
442             ):
443                 raise ValidationError(
444                     ngettext(
445                         "Please submit at least %d form.",
446                         "Please submit at least %d forms.",
447                         self.min_num,
448                     )
449                     % self.min_num,
450                     code="too_few_forms",
451                 )
452             # Give self.clean() a chance to do cross-form validation.
453             self.clean()
454         except ValidationError as e:
455             self._non_form_errors = self.error_class(
456                 e.error_list,
457                 error_class="nonform",
458                 renderer=self.renderer,
459             )
460 
461     def clean(self):
462         """
463         Hook for doing any extra formset-wide cleaning after Form.clean() has
464         been called on every form. Any ValidationError raised by this method
465         will not be associated with a particular form; it will be accessible
466         via formset.non_form_errors()
467         """
468         pass
469 
470     def has_changed(self):
471         """Return True if data in any form differs from initial."""
472         return any(form.has_changed() for form in self)
473 
474     def add_fields(self, form, index):
475         """A hook for adding extra fields on to each form instance."""
476         initial_form_count = self.initial_form_count()
477         if self.can_order:
478             # Only pre-fill the ordering field for initial forms.
479             if index is not None and index < initial_form_count:
480                 form.fields[ORDERING_FIELD_NAME] = IntegerField(
481                     label=_("Order"),
482                     initial=index + 1,
483                     required=False,
484                     widget=self.get_ordering_widget(),
485                 )
486             else:
487                 form.fields[ORDERING_FIELD_NAME] = IntegerField(
488                     label=_("Order"),
489                     required=False,
490                     widget=self.get_ordering_widget(),
491                 )
492         if self.can_delete and (self.can_delete_extra or index < initial_form_count):
493             form.fields[DELETION_FIELD_NAME] = BooleanField(
494                 label=_("Delete"),
495                 required=False,
496                 widget=self.get_deletion_widget(),
497             )
498 
499     def add_prefix(self, index):
500         return "%s-%s" % (self.prefix, index)
501 
502     def is_multipart(self):
503         """
504         Return True if the formset needs to be multipart, i.e. it
505         has FileInput, or False otherwise.
506         """
507         if self.forms:
508             return self.forms[0].is_multipart()
509         else:
510             return self.empty_form.is_multipart()
511 
512     @property
513     def media(self):
514         # All the forms on a FormSet are the same, so you only need to
515         # interrogate the first form for media.
516         if self.forms:
517             return self.forms[0].media
518         else:
519             return self.empty_form.media
520 
521     @property
522     def template_name(self):
523         return self.renderer.formset_template_name
524 
525     def get_context(self):
526         return {"formset": self}

</code><intended_behavior>Extend the `default_error_messages` dictionary within `BaseFormSet` to include two new keys: `too_many_forms` and `too_few_forms`, with sensible default messages. This is in preparation for enabling these messages to be overridden more intuitively. The implementation should ensure these new keys are used in the validation logic that checks form counts against the set limits (min_num and max_num), thus providing feedback when these conditions are not met. This approach allows developers to customize error messages related to the number of forms more effectively without altering the existing functionality.</intended_behavior>, <file>django/forms/formsets.py</file>
<class>BaseFormSet</class>
<method>__init__</method>
<code>
71     def __init__(
72         self,
73         data=None,
74         files=None,
75         auto_id="id_%s",
76         prefix=None,
77         initial=None,
78         error_class=ErrorList,
79         form_kwargs=None,
80         error_messages=None,
81     ):
82         self.is_bound = data is not None or files is not None
83         self.prefix = prefix or self.get_default_prefix()
84         self.auto_id = auto_id
85         self.data = data or {}
86         self.files = files or {}
87         self.initial = initial
88         self.form_kwargs = form_kwargs or {}
89         self.error_class = error_class
90         self._errors = None
91         self._non_form_errors = None
92 
93         messages = {}
94         for cls in reversed(type(self).__mro__):
95             messages.update(getattr(cls, "default_error_messages", {}))
96         if error_messages is not None:
97             messages.update(error_messages)
98         self.error_messages = messages

</code><intended_behavior>While the `__init__` method already merges the `default_error_messages` with any provided `error_messages`, ensuring this process includes our newly introduced messages (`too_many_forms` and `too_few_forms`) allows for their customization at instantiation. Clarification in the class documentation about how to override these (and potentially other) error messages would be helpful for developers, preserving the functionality of error message customization while enhancing its usability for more specific formset validations.</intended_behavior>, <file>django/forms/formsets.py</file>
<class>BaseFormSet</class>
<method>None</method>
<code>
52 class BaseFormSet(RenderableFormMixin):
53     """
54     A collection of instances of the same Form class.
55     """
56 
57     deletion_widget = CheckboxInput
58     ordering_widget = NumberInput
59     default_error_messages = {
60         "missing_management_form": _(
61             "ManagementForm data is missing or has been tampered with. Missing fields: "
62             "%(field_names)s. You may need to file a bug report if the issue persists."
63         ),
64     }
65 
66     template_name_div = "django/forms/formsets/div.html"
67     template_name_p = "django/forms/formsets/p.html"
68     template_name_table = "django/forms/formsets/table.html"
69     template_name_ul = "django/forms/formsets/ul.html"
70 
71     def __init__(
72         self,
73         data=None,
74         files=None,
75         auto_id="id_%s",
76         prefix=None,
77         initial=None,
78         error_class=ErrorList,
79         form_kwargs=None,
80         error_messages=None,
81     ):
82         self.is_bound = data is not None or files is not None
83         self.prefix = prefix or self.get_default_prefix()
84         self.auto_id = auto_id
85         self.data = data or {}
86         self.files = files or {}
87         self.initial = initial
88         self.form_kwargs = form_kwargs or {}
89         self.error_class = error_class
90         self._errors = None
91         self._non_form_errors = None
92 
93         messages = {}
94         for cls in reversed(type(self).__mro__):
95             messages.update(getattr(cls, "default_error_messages", {}))
96         if error_messages is not None:
97             messages.update(error_messages)
98         self.error_messages = messages
99 
100     def __iter__(self):
101         """Yield the forms in the order they should be rendered."""
102         return iter(self.forms)
103 
104     def __getitem__(self, index):
105         """Return the form at the given index, based on the rendering order."""
106         return self.forms[index]
107 
108     def __len__(self):
109         return len(self.forms)
110 
111     def __bool__(self):
112         """
113         Return True since all formsets have a management form which is not
114         included in the length.
115         """
116         return True
117 
118     def __repr__(self):
119         if self._errors is None:
120             is_valid = "Unknown"
121         else:
122             is_valid = (
123                 self.is_bound
124                 and not self._non_form_errors
125                 and not any(form_errors for form_errors in self._errors)
126             )
127         return "<%s: bound=%s valid=%s total_forms=%s>" % (
128             self.__class__.__qualname__,
129             self.is_bound,
130             is_valid,
131             self.total_form_count(),
132         )
133 
134     @cached_property
135     def management_form(self):
136         """Return the ManagementForm instance for this FormSet."""
137         if self.is_bound:
138             form = ManagementForm(
139                 self.data,
140                 auto_id=self.auto_id,
141                 prefix=self.prefix,
142                 renderer=self.renderer,
143             )
144             form.full_clean()
145         else:
146             form = ManagementForm(
147                 auto_id=self.auto_id,
148                 prefix=self.prefix,
149                 initial={
150                     TOTAL_FORM_COUNT: self.total_form_count(),
151                     INITIAL_FORM_COUNT: self.initial_form_count(),
152                     MIN_NUM_FORM_COUNT: self.min_num,
153                     MAX_NUM_FORM_COUNT: self.max_num,
154                 },
155                 renderer=self.renderer,
156             )
157         return form
158 
159     def total_form_count(self):
160         """Return the total number of forms in this FormSet."""
161         if self.is_bound:
162             # return absolute_max if it is lower than the actual total form
163             # count in the data; this is DoS protection to prevent clients
164             # from forcing the server to instantiate arbitrary numbers of
165             # forms
166             return min(
167                 self.management_form.cleaned_data[TOTAL_FORM_COUNT], self.absolute_max
168             )
169         else:
170             initial_forms = self.initial_form_count()
171             total_forms = max(initial_forms, self.min_num) + self.extra
172             # Allow all existing related objects/inlines to be displayed,
173             # but don't allow extra beyond max_num.
174             if initial_forms > self.max_num >= 0:
175                 total_forms = initial_forms
176             elif total_forms > self.max_num >= 0:
177                 total_forms = self.max_num
178         return total_forms
179 
180     def initial_form_count(self):
181         """Return the number of forms that are required in this FormSet."""
182         if self.is_bound:
183             return self.management_form.cleaned_data[INITIAL_FORM_COUNT]
184         else:
185             # Use the length of the initial data if it's there, 0 otherwise.
186             initial_forms = len(self.initial) if self.initial else 0
187         return initial_forms
188 
189     @cached_property
190     def forms(self):
191         """Instantiate forms at first property access."""
192         # DoS protection is included in total_form_count()
193         return [
194             self._construct_form(i, **self.get_form_kwargs(i))
195             for i in range(self.total_form_count())
196         ]
197 
198     def get_form_kwargs(self, index):
199         """
200         Return additional keyword arguments for each individual formset form.
201 
202         index will be None if the form being constructed is a new empty
203         form.
204         """
205         return self.form_kwargs.copy()
206 
207     def _construct_form(self, i, **kwargs):
208         """Instantiate and return the i-th form instance in a formset."""
209         defaults = {
210             "auto_id": self.auto_id,
211             "prefix": self.add_prefix(i),
212             "error_class": self.error_class,
213             # Don't render the HTML 'required' attribute as it may cause
214             # incorrect validation for extra, optional, and deleted
215             # forms in the formset.
216             "use_required_attribute": False,
217             "renderer": self.renderer,
218         }
219         if self.is_bound:
220             defaults["data"] = self.data
221             defaults["files"] = self.files
222         if self.initial and "initial" not in kwargs:
223             try:
224                 defaults["initial"] = self.initial[i]
225             except IndexError:
226                 pass
227         # Allow extra forms to be empty, unless they're part of
228         # the minimum forms.
229         if i >= self.initial_form_count() and i >= self.min_num:
230             defaults["empty_permitted"] = True
231         defaults.update(kwargs)
232         form = self.form(**defaults)
233         self.add_fields(form, i)
234         return form
235 
236     @property
237     def initial_forms(self):
238         """Return a list of all the initial forms in this formset."""
239         return self.forms[: self.initial_form_count()]
240 
241     @property
242     def extra_forms(self):
243         """Return a list of all the extra forms in this formset."""
244         return self.forms[self.initial_form_count() :]
245 
246     @property
247     def empty_form(self):
248         form = self.form(
249             auto_id=self.auto_id,
250             prefix=self.add_prefix("__prefix__"),
251             empty_permitted=True,
252             use_required_attribute=False,
253             **self.get_form_kwargs(None),
254             renderer=self.renderer,
255         )
256         self.add_fields(form, None)
257         return form
258 
259     @property
260     def cleaned_data(self):
261         """
262         Return a list of form.cleaned_data dicts for every form in self.forms.
263         """
264         if not self.is_valid():
265             raise AttributeError(
266                 "'%s' object has no attribute 'cleaned_data'" % self.__class__.__name__
267             )
268         return [form.cleaned_data for form in self.forms]
269 
270     @property
271     def deleted_forms(self):
272         """Return a list of forms that have been marked for deletion."""
273         if not self.is_valid() or not self.can_delete:
274             return []
275         # construct _deleted_form_indexes which is just a list of form indexes
276         # that have had their deletion widget set to True
277         if not hasattr(self, "_deleted_form_indexes"):
278             self._deleted_form_indexes = []
279             for i, form in enumerate(self.forms):
280                 # if this is an extra form and hasn't changed, don't consider it
281                 if i >= self.initial_form_count() and not form.has_changed():
282                     continue
283                 if self._should_delete_form(form):
284                     self._deleted_form_indexes.append(i)
285         return [self.forms[i] for i in self._deleted_form_indexes]
286 
287     @property
288     def ordered_forms(self):
289         """
290         Return a list of form in the order specified by the incoming data.
291         Raise an AttributeError if ordering is not allowed.
292         """
293         if not self.is_valid() or not self.can_order:
294             raise AttributeError(
295                 "'%s' object has no attribute 'ordered_forms'" % self.__class__.__name__
296             )
297         # Construct _ordering, which is a list of (form_index, order_field_value)
298         # tuples. After constructing this list, we'll sort it by order_field_value
299         # so we have a way to get to the form indexes in the order specified
300         # by the form data.
301         if not hasattr(self, "_ordering"):
302             self._ordering = []
303             for i, form in enumerate(self.forms):
304                 # if this is an extra form and hasn't changed, don't consider it
305                 if i >= self.initial_form_count() and not form.has_changed():
306                     continue
307                 # don't add data marked for deletion to self.ordered_data
308                 if self.can_delete and self._should_delete_form(form):
309                     continue
310                 self._ordering.append((i, form.cleaned_data[ORDERING_FIELD_NAME]))
311             # After we're done populating self._ordering, sort it.
312             # A sort function to order things numerically ascending, but
313             # None should be sorted below anything else. Allowing None as
314             # a comparison value makes it so we can leave ordering fields
315             # blank.
316 
317             def compare_ordering_key(k):
318                 if k[1] is None:
319                     return (1, 0)  # +infinity, larger than any number
320                 return (0, k[1])
321 
322             self._ordering.sort(key=compare_ordering_key)
323         # Return a list of form.cleaned_data dicts in the order specified by
324         # the form data.
325         return [self.forms[i[0]] for i in self._ordering]
326 
327     @classmethod
328     def get_default_prefix(cls):
329         return "form"
330 
331     @classmethod
332     def get_deletion_widget(cls):
333         return cls.deletion_widget
334 
335     @classmethod
336     def get_ordering_widget(cls):
337         return cls.ordering_widget
338 
339     def non_form_errors(self):
340         """
341         Return an ErrorList of errors that aren't associated with a particular
342         form -- i.e., from formset.clean(). Return an empty ErrorList if there
343         are none.
344         """
345         if self._non_form_errors is None:
346             self.full_clean()
347         return self._non_form_errors
348 
349     @property
350     def errors(self):
351         """Return a list of form.errors for every form in self.forms."""
352         if self._errors is None:
353             self.full_clean()
354         return self._errors
355 
356     def total_error_count(self):
357         """Return the number of errors across all forms in the formset."""
358         return len(self.non_form_errors()) + sum(
359             len(form_errors) for form_errors in self.errors
360         )
361 
362     def _should_delete_form(self, form):
363         """Return whether or not the form was marked for deletion."""
364         return form.cleaned_data.get(DELETION_FIELD_NAME, False)
365 
366     def is_valid(self):
367         """Return True if every form in self.forms is valid."""
368         if not self.is_bound:
369             return False
370         # Accessing errors triggers a full clean the first time only.
371         self.errors
372         # List comprehension ensures is_valid() is called for all forms.
373         # Forms due to be deleted shouldn't cause the formset to be invalid.
374         forms_valid = all(
375             [
376                 form.is_valid()
377                 for form in self.forms
378                 if not (self.can_delete and self._should_delete_form(form))
379             ]
380         )
381         return forms_valid and not self.non_form_errors()
382 
383     def full_clean(self):
384         """
385         Clean all of self.data and populate self._errors and
386         self._non_form_errors.
387         """
388         self._errors = []
389         self._non_form_errors = self.error_class(
390             error_class="nonform", renderer=self.renderer
391         )
392         empty_forms_count = 0
393 
394         if not self.is_bound:  # Stop further processing.
395             return
396 
397         if not self.management_form.is_valid():
398             error = ValidationError(
399                 self.error_messages["missing_management_form"],
400                 params={
401                     "field_names": ", ".join(
402                         self.management_form.add_prefix(field_name)
403                         for field_name in self.management_form.errors
404                     ),
405                 },
406                 code="missing_management_form",
407             )
408             self._non_form_errors.append(error)
409 
410         for i, form in enumerate(self.forms):
411             # Empty forms are unchanged forms beyond those with initial data.
412             if not form.has_changed() and i >= self.initial_form_count():
413                 empty_forms_count += 1
414             # Accessing errors calls full_clean() if necessary.
415             # _should_delete_form() requires cleaned_data.
416             form_errors = form.errors
417             if self.can_delete and self._should_delete_form(form):
418                 continue
419             self._errors.append(form_errors)
420         try:
421             if (
422                 self.validate_max
423                 and self.total_form_count() - len(self.deleted_forms) > self.max_num
424             ) or self.management_form.cleaned_data[
425                 TOTAL_FORM_COUNT
426             ] > self.absolute_max:
427                 raise ValidationError(
428                     ngettext(
429                         "Please submit at most %d form.",
430                         "Please submit at most %d forms.",
431                         self.max_num,
432                     )
433                     % self.max_num,
434                     code="too_many_forms",
435                 )
436             if (
437                 self.validate_min
438                 and self.total_form_count()
439                 - len(self.deleted_forms)
440                 - empty_forms_count
441                 < self.min_num
442             ):
443                 raise ValidationError(
444                     ngettext(
445                         "Please submit at least %d form.",
446                         "Please submit at least %d forms.",
447                         self.min_num,
448                     )
449                     % self.min_num,
450                     code="too_few_forms",
451                 )
452             # Give self.clean() a chance to do cross-form validation.
453             self.clean()
454         except ValidationError as e:
455             self._non_form_errors = self.error_class(
456                 e.error_list,
457                 error_class="nonform",
458                 renderer=self.renderer,
459             )
460 
461     def clean(self):
462         """
463         Hook for doing any extra formset-wide cleaning after Form.clean() has
464         been called on every form. Any ValidationError raised by this method
465         will not be associated with a particular form; it will be accessible
466         via formset.non_form_errors()
467         """
468         pass
469 
470     def has_changed(self):
471         """Return True if data in any form differs from initial."""
472         return any(form.has_changed() for form in self)
473 
474     def add_fields(self, form, index):
475         """A hook for adding extra fields on to each form instance."""
476         initial_form_count = self.initial_form_count()
477         if self.can_order:
478             # Only pre-fill the ordering field for initial forms.
479             if index is not None and index < initial_form_count:
480                 form.fields[ORDERING_FIELD_NAME] = IntegerField(
481                     label=_("Order"),
482                     initial=index + 1,
483                     required=False,
484                     widget=self.get_ordering_widget(),
485                 )
486             else:
487                 form.fields[ORDERING_FIELD_NAME] = IntegerField(
488                     label=_("Order"),
489                     required=False,
490                     widget=self.get_ordering_widget(),
491                 )
492         if self.can_delete and (self.can_delete_extra or index < initial_form_count):
493             form.fields[DELETION_FIELD_NAME] = BooleanField(
494                 label=_("Delete"),
495                 required=False,
496                 widget=self.get_deletion_widget(),
497             )
498 
499     def add_prefix(self, index):
500         return "%s-%s" % (self.prefix, index)
501 
502     def is_multipart(self):
503         """
504         Return True if the formset needs to be multipart, i.e. it
505         has FileInput, or False otherwise.
506         """
507         if self.forms:
508             return self.forms[0].is_multipart()
509         else:
510             return self.empty_form.is_multipart()
511 
512     @property
513     def media(self):
514         # All the forms on a FormSet are the same, so you only need to
515         # interrogate the first form for media.
516         if self.forms:
517             return self.forms[0].media
518         else:
519             return self.empty_form.media
520 
521     @property
522     def template_name(self):
523         return self.renderer.formset_template_name
524 
525     def get_context(self):
526         return {"formset": self}

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>]
2025-10-18 11:09:48.372 | INFO     | Search completed. Bug locations: [<file>django/forms/formsets.py</file>
<class>BaseFormSet</class>
<method>None</method>
<code>
52 class BaseFormSet(RenderableFormMixin):
53     """
54     A collection of instances of the same Form class.
55     """
56 
57     deletion_widget = CheckboxInput
58     ordering_widget = NumberInput
59     default_error_messages = {
60         "missing_management_form": _(
61             "ManagementForm data is missing or has been tampered with. Missing fields: "
62             "%(field_names)s. You may need to file a bug report if the issue persists."
63         ),
64     }
65 
66     template_name_div = "django/forms/formsets/div.html"
67     template_name_p = "django/forms/formsets/p.html"
68     template_name_table = "django/forms/formsets/table.html"
69     template_name_ul = "django/forms/formsets/ul.html"
70 
71     def __init__(
72         self,
73         data=None,
74         files=None,
75         auto_id="id_%s",
76         prefix=None,
77         initial=None,
78         error_class=ErrorList,
79         form_kwargs=None,
80         error_messages=None,
81     ):
82         self.is_bound = data is not None or files is not None
83         self.prefix = prefix or self.get_default_prefix()
84         self.auto_id = auto_id
85         self.data = data or {}
86         self.files = files or {}
87         self.initial = initial
88         self.form_kwargs = form_kwargs or {}
89         self.error_class = error_class
90         self._errors = None
91         self._non_form_errors = None
92 
93         messages = {}
94         for cls in reversed(type(self).__mro__):
95             messages.update(getattr(cls, "default_error_messages", {}))
96         if error_messages is not None:
97             messages.update(error_messages)
98         self.error_messages = messages
99 
100     def __iter__(self):
101         """Yield the forms in the order they should be rendered."""
102         return iter(self.forms)
103 
104     def __getitem__(self, index):
105         """Return the form at the given index, based on the rendering order."""
106         return self.forms[index]
107 
108     def __len__(self):
109         return len(self.forms)
110 
111     def __bool__(self):
112         """
113         Return True since all formsets have a management form which is not
114         included in the length.
115         """
116         return True
117 
118     def __repr__(self):
119         if self._errors is None:
120             is_valid = "Unknown"
121         else:
122             is_valid = (
123                 self.is_bound
124                 and not self._non_form_errors
125                 and not any(form_errors for form_errors in self._errors)
126             )
127         return "<%s: bound=%s valid=%s total_forms=%s>" % (
128             self.__class__.__qualname__,
129             self.is_bound,
130             is_valid,
131             self.total_form_count(),
132         )
133 
134     @cached_property
135     def management_form(self):
136         """Return the ManagementForm instance for this FormSet."""
137         if self.is_bound:
138             form = ManagementForm(
139                 self.data,
140                 auto_id=self.auto_id,
141                 prefix=self.prefix,
142                 renderer=self.renderer,
143             )
144             form.full_clean()
145         else:
146             form = ManagementForm(
147                 auto_id=self.auto_id,
148                 prefix=self.prefix,
149                 initial={
150                     TOTAL_FORM_COUNT: self.total_form_count(),
151                     INITIAL_FORM_COUNT: self.initial_form_count(),
152                     MIN_NUM_FORM_COUNT: self.min_num,
153                     MAX_NUM_FORM_COUNT: self.max_num,
154                 },
155                 renderer=self.renderer,
156             )
157         return form
158 
159     def total_form_count(self):
160         """Return the total number of forms in this FormSet."""
161         if self.is_bound:
162             # return absolute_max if it is lower than the actual total form
163             # count in the data; this is DoS protection to prevent clients
164             # from forcing the server to instantiate arbitrary numbers of
165             # forms
166             return min(
167                 self.management_form.cleaned_data[TOTAL_FORM_COUNT], self.absolute_max
168             )
169         else:
170             initial_forms = self.initial_form_count()
171             total_forms = max(initial_forms, self.min_num) + self.extra
172             # Allow all existing related objects/inlines to be displayed,
173             # but don't allow extra beyond max_num.
174             if initial_forms > self.max_num >= 0:
175                 total_forms = initial_forms
176             elif total_forms > self.max_num >= 0:
177                 total_forms = self.max_num
178         return total_forms
179 
180     def initial_form_count(self):
181         """Return the number of forms that are required in this FormSet."""
182         if self.is_bound:
183             return self.management_form.cleaned_data[INITIAL_FORM_COUNT]
184         else:
185             # Use the length of the initial data if it's there, 0 otherwise.
186             initial_forms = len(self.initial) if self.initial else 0
187         return initial_forms
188 
189     @cached_property
190     def forms(self):
191         """Instantiate forms at first property access."""
192         # DoS protection is included in total_form_count()
193         return [
194             self._construct_form(i, **self.get_form_kwargs(i))
195             for i in range(self.total_form_count())
196         ]
197 
198     def get_form_kwargs(self, index):
199         """
200         Return additional keyword arguments for each individual formset form.
201 
202         index will be None if the form being constructed is a new empty
203         form.
204         """
205         return self.form_kwargs.copy()
206 
207     def _construct_form(self, i, **kwargs):
208         """Instantiate and return the i-th form instance in a formset."""
209         defaults = {
210             "auto_id": self.auto_id,
211             "prefix": self.add_prefix(i),
212             "error_class": self.error_class,
213             # Don't render the HTML 'required' attribute as it may cause
214             # incorrect validation for extra, optional, and deleted
215             # forms in the formset.
216             "use_required_attribute": False,
217             "renderer": self.renderer,
218         }
219         if self.is_bound:
220             defaults["data"] = self.data
221             defaults["files"] = self.files
222         if self.initial and "initial" not in kwargs:
223             try:
224                 defaults["initial"] = self.initial[i]
225             except IndexError:
226                 pass
227         # Allow extra forms to be empty, unless they're part of
228         # the minimum forms.
229         if i >= self.initial_form_count() and i >= self.min_num:
230             defaults["empty_permitted"] = True
231         defaults.update(kwargs)
232         form = self.form(**defaults)
233         self.add_fields(form, i)
234         return form
235 
236     @property
237     def initial_forms(self):
238         """Return a list of all the initial forms in this formset."""
239         return self.forms[: self.initial_form_count()]
240 
241     @property
242     def extra_forms(self):
243         """Return a list of all the extra forms in this formset."""
244         return self.forms[self.initial_form_count() :]
245 
246     @property
247     def empty_form(self):
248         form = self.form(
249             auto_id=self.auto_id,
250             prefix=self.add_prefix("__prefix__"),
251             empty_permitted=True,
252             use_required_attribute=False,
253             **self.get_form_kwargs(None),
254             renderer=self.renderer,
255         )
256         self.add_fields(form, None)
257         return form
258 
259     @property
260     def cleaned_data(self):
261         """
262         Return a list of form.cleaned_data dicts for every form in self.forms.
263         """
264         if not self.is_valid():
265             raise AttributeError(
266                 "'%s' object has no attribute 'cleaned_data'" % self.__class__.__name__
267             )
268         return [form.cleaned_data for form in self.forms]
269 
270     @property
271     def deleted_forms(self):
272         """Return a list of forms that have been marked for deletion."""
273         if not self.is_valid() or not self.can_delete:
274             return []
275         # construct _deleted_form_indexes which is just a list of form indexes
276         # that have had their deletion widget set to True
277         if not hasattr(self, "_deleted_form_indexes"):
278             self._deleted_form_indexes = []
279             for i, form in enumerate(self.forms):
280                 # if this is an extra form and hasn't changed, don't consider it
281                 if i >= self.initial_form_count() and not form.has_changed():
282                     continue
283                 if self._should_delete_form(form):
284                     self._deleted_form_indexes.append(i)
285         return [self.forms[i] for i in self._deleted_form_indexes]
286 
287     @property
288     def ordered_forms(self):
289         """
290         Return a list of form in the order specified by the incoming data.
291         Raise an AttributeError if ordering is not allowed.
292         """
293         if not self.is_valid() or not self.can_order:
294             raise AttributeError(
295                 "'%s' object has no attribute 'ordered_forms'" % self.__class__.__name__
296             )
297         # Construct _ordering, which is a list of (form_index, order_field_value)
298         # tuples. After constructing this list, we'll sort it by order_field_value
299         # so we have a way to get to the form indexes in the order specified
300         # by the form data.
301         if not hasattr(self, "_ordering"):
302             self._ordering = []
303             for i, form in enumerate(self.forms):
304                 # if this is an extra form and hasn't changed, don't consider it
305                 if i >= self.initial_form_count() and not form.has_changed():
306                     continue
307                 # don't add data marked for deletion to self.ordered_data
308                 if self.can_delete and self._should_delete_form(form):
309                     continue
310                 self._ordering.append((i, form.cleaned_data[ORDERING_FIELD_NAME]))
311             # After we're done populating self._ordering, sort it.
312             # A sort function to order things numerically ascending, but
313             # None should be sorted below anything else. Allowing None as
314             # a comparison value makes it so we can leave ordering fields
315             # blank.
316 
317             def compare_ordering_key(k):
318                 if k[1] is None:
319                     return (1, 0)  # +infinity, larger than any number
320                 return (0, k[1])
321 
322             self._ordering.sort(key=compare_ordering_key)
323         # Return a list of form.cleaned_data dicts in the order specified by
324         # the form data.
325         return [self.forms[i[0]] for i in self._ordering]
326 
327     @classmethod
328     def get_default_prefix(cls):
329         return "form"
330 
331     @classmethod
332     def get_deletion_widget(cls):
333         return cls.deletion_widget
334 
335     @classmethod
336     def get_ordering_widget(cls):
337         return cls.ordering_widget
338 
339     def non_form_errors(self):
340         """
341         Return an ErrorList of errors that aren't associated with a particular
342         form -- i.e., from formset.clean(). Return an empty ErrorList if there
343         are none.
344         """
345         if self._non_form_errors is None:
346             self.full_clean()
347         return self._non_form_errors
348 
349     @property
350     def errors(self):
351         """Return a list of form.errors for every form in self.forms."""
352         if self._errors is None:
353             self.full_clean()
354         return self._errors
355 
356     def total_error_count(self):
357         """Return the number of errors across all forms in the formset."""
358         return len(self.non_form_errors()) + sum(
359             len(form_errors) for form_errors in self.errors
360         )
361 
362     def _should_delete_form(self, form):
363         """Return whether or not the form was marked for deletion."""
364         return form.cleaned_data.get(DELETION_FIELD_NAME, False)
365 
366     def is_valid(self):
367         """Return True if every form in self.forms is valid."""
368         if not self.is_bound:
369             return False
370         # Accessing errors triggers a full clean the first time only.
371         self.errors
372         # List comprehension ensures is_valid() is called for all forms.
373         # Forms due to be deleted shouldn't cause the formset to be invalid.
374         forms_valid = all(
375             [
376                 form.is_valid()
377                 for form in self.forms
378                 if not (self.can_delete and self._should_delete_form(form))
379             ]
380         )
381         return forms_valid and not self.non_form_errors()
382 
383     def full_clean(self):
384         """
385         Clean all of self.data and populate self._errors and
386         self._non_form_errors.
387         """
388         self._errors = []
389         self._non_form_errors = self.error_class(
390             error_class="nonform", renderer=self.renderer
391         )
392         empty_forms_count = 0
393 
394         if not self.is_bound:  # Stop further processing.
395             return
396 
397         if not self.management_form.is_valid():
398             error = ValidationError(
399                 self.error_messages["missing_management_form"],
400                 params={
401                     "field_names": ", ".join(
402                         self.management_form.add_prefix(field_name)
403                         for field_name in self.management_form.errors
404                     ),
405                 },
406                 code="missing_management_form",
407             )
408             self._non_form_errors.append(error)
409 
410         for i, form in enumerate(self.forms):
411             # Empty forms are unchanged forms beyond those with initial data.
412             if not form.has_changed() and i >= self.initial_form_count():
413                 empty_forms_count += 1
414             # Accessing errors calls full_clean() if necessary.
415             # _should_delete_form() requires cleaned_data.
416             form_errors = form.errors
417             if self.can_delete and self._should_delete_form(form):
418                 continue
419             self._errors.append(form_errors)
420         try:
421             if (
422                 self.validate_max
423                 and self.total_form_count() - len(self.deleted_forms) > self.max_num
424             ) or self.management_form.cleaned_data[
425                 TOTAL_FORM_COUNT
426             ] > self.absolute_max:
427                 raise ValidationError(
428                     ngettext(
429                         "Please submit at most %d form.",
430                         "Please submit at most %d forms.",
431                         self.max_num,
432                     )
433                     % self.max_num,
434                     code="too_many_forms",
435                 )
436             if (
437                 self.validate_min
438                 and self.total_form_count()
439                 - len(self.deleted_forms)
440                 - empty_forms_count
441                 < self.min_num
442             ):
443                 raise ValidationError(
444                     ngettext(
445                         "Please submit at least %d form.",
446                         "Please submit at least %d forms.",
447                         self.min_num,
448                     )
449                     % self.min_num,
450                     code="too_few_forms",
451                 )
452             # Give self.clean() a chance to do cross-form validation.
453             self.clean()
454         except ValidationError as e:
455             self._non_form_errors = self.error_class(
456                 e.error_list,
457                 error_class="nonform",
458                 renderer=self.renderer,
459             )
460 
461     def clean(self):
462         """
463         Hook for doing any extra formset-wide cleaning after Form.clean() has
464         been called on every form. Any ValidationError raised by this method
465         will not be associated with a particular form; it will be accessible
466         via formset.non_form_errors()
467         """
468         pass
469 
470     def has_changed(self):
471         """Return True if data in any form differs from initial."""
472         return any(form.has_changed() for form in self)
473 
474     def add_fields(self, form, index):
475         """A hook for adding extra fields on to each form instance."""
476         initial_form_count = self.initial_form_count()
477         if self.can_order:
478             # Only pre-fill the ordering field for initial forms.
479             if index is not None and index < initial_form_count:
480                 form.fields[ORDERING_FIELD_NAME] = IntegerField(
481                     label=_("Order"),
482                     initial=index + 1,
483                     required=False,
484                     widget=self.get_ordering_widget(),
485                 )
486             else:
487                 form.fields[ORDERING_FIELD_NAME] = IntegerField(
488                     label=_("Order"),
489                     required=False,
490                     widget=self.get_ordering_widget(),
491                 )
492         if self.can_delete and (self.can_delete_extra or index < initial_form_count):
493             form.fields[DELETION_FIELD_NAME] = BooleanField(
494                 label=_("Delete"),
495                 required=False,
496                 widget=self.get_deletion_widget(),
497             )
498 
499     def add_prefix(self, index):
500         return "%s-%s" % (self.prefix, index)
501 
502     def is_multipart(self):
503         """
504         Return True if the formset needs to be multipart, i.e. it
505         has FileInput, or False otherwise.
506         """
507         if self.forms:
508             return self.forms[0].is_multipart()
509         else:
510             return self.empty_form.is_multipart()
511 
512     @property
513     def media(self):
514         # All the forms on a FormSet are the same, so you only need to
515         # interrogate the first form for media.
516         if self.forms:
517             return self.forms[0].media
518         else:
519             return self.empty_form.media
520 
521     @property
522     def template_name(self):
523         return self.renderer.formset_template_name
524 
525     def get_context(self):
526         return {"formset": self}

</code><intended_behavior>Extend the `default_error_messages` dictionary within `BaseFormSet` to include two new keys: `too_many_forms` and `too_few_forms`, with sensible default messages. This is in preparation for enabling these messages to be overridden more intuitively. The implementation should ensure these new keys are used in the validation logic that checks form counts against the set limits (min_num and max_num), thus providing feedback when these conditions are not met. This approach allows developers to customize error messages related to the number of forms more effectively without altering the existing functionality.</intended_behavior>, <file>django/forms/formsets.py</file>
<class>BaseFormSet</class>
<method>__init__</method>
<code>
71     def __init__(
72         self,
73         data=None,
74         files=None,
75         auto_id="id_%s",
76         prefix=None,
77         initial=None,
78         error_class=ErrorList,
79         form_kwargs=None,
80         error_messages=None,
81     ):
82         self.is_bound = data is not None or files is not None
83         self.prefix = prefix or self.get_default_prefix()
84         self.auto_id = auto_id
85         self.data = data or {}
86         self.files = files or {}
87         self.initial = initial
88         self.form_kwargs = form_kwargs or {}
89         self.error_class = error_class
90         self._errors = None
91         self._non_form_errors = None
92 
93         messages = {}
94         for cls in reversed(type(self).__mro__):
95             messages.update(getattr(cls, "default_error_messages", {}))
96         if error_messages is not None:
97             messages.update(error_messages)
98         self.error_messages = messages

</code><intended_behavior>While the `__init__` method already merges the `default_error_messages` with any provided `error_messages`, ensuring this process includes our newly introduced messages (`too_many_forms` and `too_few_forms`) allows for their customization at instantiation. Clarification in the class documentation about how to override these (and potentially other) error messages would be helpful for developers, preserving the functionality of error message customization while enhancing its usability for more specific formset validations.</intended_behavior>, <file>django/forms/formsets.py</file>
<class>BaseFormSet</class>
<method>None</method>
<code>
52 class BaseFormSet(RenderableFormMixin):
53     """
54     A collection of instances of the same Form class.
55     """
56 
57     deletion_widget = CheckboxInput
58     ordering_widget = NumberInput
59     default_error_messages = {
60         "missing_management_form": _(
61             "ManagementForm data is missing or has been tampered with. Missing fields: "
62             "%(field_names)s. You may need to file a bug report if the issue persists."
63         ),
64     }
65 
66     template_name_div = "django/forms/formsets/div.html"
67     template_name_p = "django/forms/formsets/p.html"
68     template_name_table = "django/forms/formsets/table.html"
69     template_name_ul = "django/forms/formsets/ul.html"
70 
71     def __init__(
72         self,
73         data=None,
74         files=None,
75         auto_id="id_%s",
76         prefix=None,
77         initial=None,
78         error_class=ErrorList,
79         form_kwargs=None,
80         error_messages=None,
81     ):
82         self.is_bound = data is not None or files is not None
83         self.prefix = prefix or self.get_default_prefix()
84         self.auto_id = auto_id
85         self.data = data or {}
86         self.files = files or {}
87         self.initial = initial
88         self.form_kwargs = form_kwargs or {}
89         self.error_class = error_class
90         self._errors = None
91         self._non_form_errors = None
92 
93         messages = {}
94         for cls in reversed(type(self).__mro__):
95             messages.update(getattr(cls, "default_error_messages", {}))
96         if error_messages is not None:
97             messages.update(error_messages)
98         self.error_messages = messages
99 
100     def __iter__(self):
101         """Yield the forms in the order they should be rendered."""
102         return iter(self.forms)
103 
104     def __getitem__(self, index):
105         """Return the form at the given index, based on the rendering order."""
106         return self.forms[index]
107 
108     def __len__(self):
109         return len(self.forms)
110 
111     def __bool__(self):
112         """
113         Return True since all formsets have a management form which is not
114         included in the length.
115         """
116         return True
117 
118     def __repr__(self):
119         if self._errors is None:
120             is_valid = "Unknown"
121         else:
122             is_valid = (
123                 self.is_bound
124                 and not self._non_form_errors
125                 and not any(form_errors for form_errors in self._errors)
126             )
127         return "<%s: bound=%s valid=%s total_forms=%s>" % (
128             self.__class__.__qualname__,
129             self.is_bound,
130             is_valid,
131             self.total_form_count(),
132         )
133 
134     @cached_property
135     def management_form(self):
136         """Return the ManagementForm instance for this FormSet."""
137         if self.is_bound:
138             form = ManagementForm(
139                 self.data,
140                 auto_id=self.auto_id,
141                 prefix=self.prefix,
142                 renderer=self.renderer,
143             )
144             form.full_clean()
145         else:
146             form = ManagementForm(
147                 auto_id=self.auto_id,
148                 prefix=self.prefix,
149                 initial={
150                     TOTAL_FORM_COUNT: self.total_form_count(),
151                     INITIAL_FORM_COUNT: self.initial_form_count(),
152                     MIN_NUM_FORM_COUNT: self.min_num,
153                     MAX_NUM_FORM_COUNT: self.max_num,
154                 },
155                 renderer=self.renderer,
156             )
157         return form
158 
159     def total_form_count(self):
160         """Return the total number of forms in this FormSet."""
161         if self.is_bound:
162             # return absolute_max if it is lower than the actual total form
163             # count in the data; this is DoS protection to prevent clients
164             # from forcing the server to instantiate arbitrary numbers of
165             # forms
166             return min(
167                 self.management_form.cleaned_data[TOTAL_FORM_COUNT], self.absolute_max
168             )
169         else:
170             initial_forms = self.initial_form_count()
171             total_forms = max(initial_forms, self.min_num) + self.extra
172             # Allow all existing related objects/inlines to be displayed,
173             # but don't allow extra beyond max_num.
174             if initial_forms > self.max_num >= 0:
175                 total_forms = initial_forms
176             elif total_forms > self.max_num >= 0:
177                 total_forms = self.max_num
178         return total_forms
179 
180     def initial_form_count(self):
181         """Return the number of forms that are required in this FormSet."""
182         if self.is_bound:
183             return self.management_form.cleaned_data[INITIAL_FORM_COUNT]
184         else:
185             # Use the length of the initial data if it's there, 0 otherwise.
186             initial_forms = len(self.initial) if self.initial else 0
187         return initial_forms
188 
189     @cached_property
190     def forms(self):
191         """Instantiate forms at first property access."""
192         # DoS protection is included in total_form_count()
193         return [
194             self._construct_form(i, **self.get_form_kwargs(i))
195             for i in range(self.total_form_count())
196         ]
197 
198     def get_form_kwargs(self, index):
199         """
200         Return additional keyword arguments for each individual formset form.
201 
202         index will be None if the form being constructed is a new empty
203         form.
204         """
205         return self.form_kwargs.copy()
206 
207     def _construct_form(self, i, **kwargs):
208         """Instantiate and return the i-th form instance in a formset."""
209         defaults = {
210             "auto_id": self.auto_id,
211             "prefix": self.add_prefix(i),
212             "error_class": self.error_class,
213             # Don't render the HTML 'required' attribute as it may cause
214             # incorrect validation for extra, optional, and deleted
215             # forms in the formset.
216             "use_required_attribute": False,
217             "renderer": self.renderer,
218         }
219         if self.is_bound:
220             defaults["data"] = self.data
221             defaults["files"] = self.files
222         if self.initial and "initial" not in kwargs:
223             try:
224                 defaults["initial"] = self.initial[i]
225             except IndexError:
226                 pass
227         # Allow extra forms to be empty, unless they're part of
228         # the minimum forms.
229         if i >= self.initial_form_count() and i >= self.min_num:
230             defaults["empty_permitted"] = True
231         defaults.update(kwargs)
232         form = self.form(**defaults)
233         self.add_fields(form, i)
234         return form
235 
236     @property
237     def initial_forms(self):
238         """Return a list of all the initial forms in this formset."""
239         return self.forms[: self.initial_form_count()]
240 
241     @property
242     def extra_forms(self):
243         """Return a list of all the extra forms in this formset."""
244         return self.forms[self.initial_form_count() :]
245 
246     @property
247     def empty_form(self):
248         form = self.form(
249             auto_id=self.auto_id,
250             prefix=self.add_prefix("__prefix__"),
251             empty_permitted=True,
252             use_required_attribute=False,
253             **self.get_form_kwargs(None),
254             renderer=self.renderer,
255         )
256         self.add_fields(form, None)
257         return form
258 
259     @property
260     def cleaned_data(self):
261         """
262         Return a list of form.cleaned_data dicts for every form in self.forms.
263         """
264         if not self.is_valid():
265             raise AttributeError(
266                 "'%s' object has no attribute 'cleaned_data'" % self.__class__.__name__
267             )
268         return [form.cleaned_data for form in self.forms]
269 
270     @property
271     def deleted_forms(self):
272         """Return a list of forms that have been marked for deletion."""
273         if not self.is_valid() or not self.can_delete:
274             return []
275         # construct _deleted_form_indexes which is just a list of form indexes
276         # that have had their deletion widget set to True
277         if not hasattr(self, "_deleted_form_indexes"):
278             self._deleted_form_indexes = []
279             for i, form in enumerate(self.forms):
280                 # if this is an extra form and hasn't changed, don't consider it
281                 if i >= self.initial_form_count() and not form.has_changed():
282                     continue
283                 if self._should_delete_form(form):
284                     self._deleted_form_indexes.append(i)
285         return [self.forms[i] for i in self._deleted_form_indexes]
286 
287     @property
288     def ordered_forms(self):
289         """
290         Return a list of form in the order specified by the incoming data.
291         Raise an AttributeError if ordering is not allowed.
292         """
293         if not self.is_valid() or not self.can_order:
294             raise AttributeError(
295                 "'%s' object has no attribute 'ordered_forms'" % self.__class__.__name__
296             )
297         # Construct _ordering, which is a list of (form_index, order_field_value)
298         # tuples. After constructing this list, we'll sort it by order_field_value
299         # so we have a way to get to the form indexes in the order specified
300         # by the form data.
301         if not hasattr(self, "_ordering"):
302             self._ordering = []
303             for i, form in enumerate(self.forms):
304                 # if this is an extra form and hasn't changed, don't consider it
305                 if i >= self.initial_form_count() and not form.has_changed():
306                     continue
307                 # don't add data marked for deletion to self.ordered_data
308                 if self.can_delete and self._should_delete_form(form):
309                     continue
310                 self._ordering.append((i, form.cleaned_data[ORDERING_FIELD_NAME]))
311             # After we're done populating self._ordering, sort it.
312             # A sort function to order things numerically ascending, but
313             # None should be sorted below anything else. Allowing None as
314             # a comparison value makes it so we can leave ordering fields
315             # blank.
316 
317             def compare_ordering_key(k):
318                 if k[1] is None:
319                     return (1, 0)  # +infinity, larger than any number
320                 return (0, k[1])
321 
322             self._ordering.sort(key=compare_ordering_key)
323         # Return a list of form.cleaned_data dicts in the order specified by
324         # the form data.
325         return [self.forms[i[0]] for i in self._ordering]
326 
327     @classmethod
328     def get_default_prefix(cls):
329         return "form"
330 
331     @classmethod
332     def get_deletion_widget(cls):
333         return cls.deletion_widget
334 
335     @classmethod
336     def get_ordering_widget(cls):
337         return cls.ordering_widget
338 
339     def non_form_errors(self):
340         """
341         Return an ErrorList of errors that aren't associated with a particular
342         form -- i.e., from formset.clean(). Return an empty ErrorList if there
343         are none.
344         """
345         if self._non_form_errors is None:
346             self.full_clean()
347         return self._non_form_errors
348 
349     @property
350     def errors(self):
351         """Return a list of form.errors for every form in self.forms."""
352         if self._errors is None:
353             self.full_clean()
354         return self._errors
355 
356     def total_error_count(self):
357         """Return the number of errors across all forms in the formset."""
358         return len(self.non_form_errors()) + sum(
359             len(form_errors) for form_errors in self.errors
360         )
361 
362     def _should_delete_form(self, form):
363         """Return whether or not the form was marked for deletion."""
364         return form.cleaned_data.get(DELETION_FIELD_NAME, False)
365 
366     def is_valid(self):
367         """Return True if every form in self.forms is valid."""
368         if not self.is_bound:
369             return False
370         # Accessing errors triggers a full clean the first time only.
371         self.errors
372         # List comprehension ensures is_valid() is called for all forms.
373         # Forms due to be deleted shouldn't cause the formset to be invalid.
374         forms_valid = all(
375             [
376                 form.is_valid()
377                 for form in self.forms
378                 if not (self.can_delete and self._should_delete_form(form))
379             ]
380         )
381         return forms_valid and not self.non_form_errors()
382 
383     def full_clean(self):
384         """
385         Clean all of self.data and populate self._errors and
386         self._non_form_errors.
387         """
388         self._errors = []
389         self._non_form_errors = self.error_class(
390             error_class="nonform", renderer=self.renderer
391         )
392         empty_forms_count = 0
393 
394         if not self.is_bound:  # Stop further processing.
395             return
396 
397         if not self.management_form.is_valid():
398             error = ValidationError(
399                 self.error_messages["missing_management_form"],
400                 params={
401                     "field_names": ", ".join(
402                         self.management_form.add_prefix(field_name)
403                         for field_name in self.management_form.errors
404                     ),
405                 },
406                 code="missing_management_form",
407             )
408             self._non_form_errors.append(error)
409 
410         for i, form in enumerate(self.forms):
411             # Empty forms are unchanged forms beyond those with initial data.
412             if not form.has_changed() and i >= self.initial_form_count():
413                 empty_forms_count += 1
414             # Accessing errors calls full_clean() if necessary.
415             # _should_delete_form() requires cleaned_data.
416             form_errors = form.errors
417             if self.can_delete and self._should_delete_form(form):
418                 continue
419             self._errors.append(form_errors)
420         try:
421             if (
422                 self.validate_max
423                 and self.total_form_count() - len(self.deleted_forms) > self.max_num
424             ) or self.management_form.cleaned_data[
425                 TOTAL_FORM_COUNT
426             ] > self.absolute_max:
427                 raise ValidationError(
428                     ngettext(
429                         "Please submit at most %d form.",
430                         "Please submit at most %d forms.",
431                         self.max_num,
432                     )
433                     % self.max_num,
434                     code="too_many_forms",
435                 )
436             if (
437                 self.validate_min
438                 and self.total_form_count()
439                 - len(self.deleted_forms)
440                 - empty_forms_count
441                 < self.min_num
442             ):
443                 raise ValidationError(
444                     ngettext(
445                         "Please submit at least %d form.",
446                         "Please submit at least %d forms.",
447                         self.min_num,
448                     )
449                     % self.min_num,
450                     code="too_few_forms",
451                 )
452             # Give self.clean() a chance to do cross-form validation.
453             self.clean()
454         except ValidationError as e:
455             self._non_form_errors = self.error_class(
456                 e.error_list,
457                 error_class="nonform",
458                 renderer=self.renderer,
459             )
460 
461     def clean(self):
462         """
463         Hook for doing any extra formset-wide cleaning after Form.clean() has
464         been called on every form. Any ValidationError raised by this method
465         will not be associated with a particular form; it will be accessible
466         via formset.non_form_errors()
467         """
468         pass
469 
470     def has_changed(self):
471         """Return True if data in any form differs from initial."""
472         return any(form.has_changed() for form in self)
473 
474     def add_fields(self, form, index):
475         """A hook for adding extra fields on to each form instance."""
476         initial_form_count = self.initial_form_count()
477         if self.can_order:
478             # Only pre-fill the ordering field for initial forms.
479             if index is not None and index < initial_form_count:
480                 form.fields[ORDERING_FIELD_NAME] = IntegerField(
481                     label=_("Order"),
482                     initial=index + 1,
483                     required=False,
484                     widget=self.get_ordering_widget(),
485                 )
486             else:
487                 form.fields[ORDERING_FIELD_NAME] = IntegerField(
488                     label=_("Order"),
489                     required=False,
490                     widget=self.get_ordering_widget(),
491                 )
492         if self.can_delete and (self.can_delete_extra or index < initial_form_count):
493             form.fields[DELETION_FIELD_NAME] = BooleanField(
494                 label=_("Delete"),
495                 required=False,
496                 widget=self.get_deletion_widget(),
497             )
498 
499     def add_prefix(self, index):
500         return "%s-%s" % (self.prefix, index)
501 
502     def is_multipart(self):
503         """
504         Return True if the formset needs to be multipart, i.e. it
505         has FileInput, or False otherwise.
506         """
507         if self.forms:
508             return self.forms[0].is_multipart()
509         else:
510             return self.empty_form.is_multipart()
511 
512     @property
513     def media(self):
514         # All the forms on a FormSet are the same, so you only need to
515         # interrogate the first form for media.
516         if self.forms:
517             return self.forms[0].media
518         else:
519             return self.empty_form.media
520 
521     @property
522     def template_name(self):
523         return self.renderer.formset_template_name
524 
525     def get_context(self):
526         return {"formset": self}

</code><intended_behavior>This class provides additional context to the issue.</intended_behavior>]
2025-10-18 11:09:48.372 | INFO     | Overall retry 0 succeeded; ending workflow
2025-10-18 11:09:48.372 | INFO     | Search-only: skipping patch selection
2025-10-18 11:09:48.522 | INFO     | Task django__django-15671 completed successfully.
2025-10-18 11:09:48.523 | INFO     | No patch generated. You can try running ACR again.
